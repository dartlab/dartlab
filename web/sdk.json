{"sdk:/sdk/lib/async/zone.dart":"// Copyright (c) 2013, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\npart of dart.async;\n\ntypedef dynamic ZoneCallback();\ntypedef dynamic ZoneUnaryCallback(arg);\ntypedef dynamic ZoneBinaryCallback(arg1, arg2);\n\ntypedef dynamic HandleUncaughtErrorHandler(\n    Zone self, ZoneDelegate parent, Zone zone, error, StackTrace stackTrace);\ntypedef dynamic RunHandler(Zone self, ZoneDelegate parent, Zone zone, f());\ntypedef dynamic RunUnaryHandler(\n    Zone self, ZoneDelegate parent, Zone zone, f(arg), arg);\ntypedef dynamic RunBinaryHandler(\n    Zone self, ZoneDelegate parent, Zone zone, f(arg1, arg2), arg1, arg2);\ntypedef ZoneCallback RegisterCallbackHandler(\n    Zone self, ZoneDelegate parent, Zone zone, f());\ntypedef ZoneUnaryCallback RegisterUnaryCallbackHandler(\n    Zone self, ZoneDelegate parent, Zone zone, f(arg));\ntypedef ZoneBinaryCallback RegisterBinaryCallbackHandler(\n    Zone self, ZoneDelegate parent, Zone zone, f(arg1, arg2));\ntypedef void ScheduleMicrotaskHandler(\n    Zone self, ZoneDelegate parent, Zone zone, f());\ntypedef Timer CreateTimerHandler(\n    Zone self, ZoneDelegate parent, Zone zone, Duration duration, void f());\ntypedef Timer CreatePeriodicTimerHandler(\n    Zone self, ZoneDelegate parent, Zone zone,\n    Duration period, void f(Timer timer));\ntypedef void PrintHandler(\n    Zone self, ZoneDelegate parent, Zone zone, String line);\ntypedef Zone ForkHandler(Zone self, ZoneDelegate parent, Zone zone,\n                         ZoneSpecification specification,\n                         Map zoneValues);\n\nclass _ZoneFunction {\n  final _Zone zone;\n  final Function function;\n  const _ZoneFunction(this.zone, this.function);\n}\n\n/**\n * This class provides the specification for a forked zone.\n *\n * When forking a new zone (see [Zone.fork]) one can override the default\n * behavior of the zone by providing callbacks. These callbacks must be\n * given in an instance of this class.\n *\n * Handlers have the same signature as the same-named methods on [Zone] but\n * receive three additional arguments:\n *\n *   1. the zone the handlers are attached to (the \"self\" zone).\n *   2. a [ZoneDelegate] to the parent zone.\n *   3. the zone that first received the request (before the request was\n *     bubbled up).\n *\n * Handlers can either stop propagation the request (by simply not calling the\n * parent handler), or forward to the parent zone, potentially modifying the\n * arguments on the way.\n */\nabstract class ZoneSpecification {\n  /**\n   * Creates a specification with the provided handlers.\n   */\n  const factory ZoneSpecification({\n    dynamic handleUncaughtError(Zone self, ZoneDelegate parent, Zone zone,\n                                error, StackTrace stackTrace),\n    dynamic run(Zone self, ZoneDelegate parent, Zone zone, f()),\n    dynamic runUnary(\n        Zone self, ZoneDelegate parent, Zone zone, f(arg), arg),\n    dynamic runBinary(Zone self, ZoneDelegate parent, Zone zone,\n                      f(arg1, arg2), arg1, arg2),\n    ZoneCallback registerCallback(\n        Zone self, ZoneDelegate parent, Zone zone, f()),\n    ZoneUnaryCallback registerUnaryCallback(\n        Zone self, ZoneDelegate parent, Zone zone, f(arg)),\n    ZoneBinaryCallback registerBinaryCallback(\n        Zone self, ZoneDelegate parent, Zone zone, f(arg1, arg2)),\n    void scheduleMicrotask(\n        Zone self, ZoneDelegate parent, Zone zone, f()),\n    Timer createTimer(Zone self, ZoneDelegate parent, Zone zone,\n                      Duration duration, void f()),\n    Timer createPeriodicTimer(Zone self, ZoneDelegate parent, Zone zone,\n                              Duration period, void f(Timer timer)),\n    void print(Zone self, ZoneDelegate parent, Zone zone, String line),\n    Zone fork(Zone self, ZoneDelegate parent, Zone zone,\n              ZoneSpecification specification, Map zoneValues)\n  }) = _ZoneSpecification;\n\n  /**\n   * Creates a specification from [other] with the provided handlers overriding\n   * the ones in [other].\n   */\n  factory ZoneSpecification.from(ZoneSpecification other, {\n    dynamic handleUncaughtError(Zone self, ZoneDelegate parent, Zone zone,\n                                error, StackTrace stackTrace): null,\n    dynamic run(Zone self, ZoneDelegate parent, Zone zone, f()): null,\n    dynamic runUnary(\n        Zone self, ZoneDelegate parent, Zone zone, f(arg), arg): null,\n    dynamic runBinary(Zone self, ZoneDelegate parent, Zone zone,\n                      f(arg1, arg2), arg1, arg2): null,\n    ZoneCallback registerCallback(\n        Zone self, ZoneDelegate parent, Zone zone, f()): null,\n    ZoneUnaryCallback registerUnaryCallback(\n        Zone self, ZoneDelegate parent, Zone zone, f(arg)): null,\n    ZoneBinaryCallback registerBinaryCallback(\n        Zone self, ZoneDelegate parent, Zone zone, f(arg1, arg2)): null,\n    void scheduleMicrotask(\n        Zone self, ZoneDelegate parent, Zone zone, f()): null,\n    Timer createTimer(Zone self, ZoneDelegate parent, Zone zone,\n                      Duration duration, void f()): null,\n    Timer createPeriodicTimer(Zone self, ZoneDelegate parent, Zone zone,\n                              Duration period, void f(Timer timer)): null,\n    void print(Zone self, ZoneDelegate parent, Zone zone, String line): null,\n    Zone fork(Zone self, ZoneDelegate parent, Zone zone,\n              ZoneSpecification specification,\n              Map zoneValues): null\n  }) {\n    return new ZoneSpecification(\n      handleUncaughtError: handleUncaughtError != null\n                           ? handleUncaughtError\n                           : other.handleUncaughtError,\n      run: run != null ? run : other.run,\n      runUnary: runUnary != null ? runUnary : other.runUnary,\n      runBinary: runBinary != null ? runBinary : other.runBinary,\n      registerCallback: registerCallback != null\n                        ? registerCallback\n                        : other.registerCallback,\n      registerUnaryCallback: registerUnaryCallback != null\n                         ? registerUnaryCallback\n                         : other.registerUnaryCallback,\n      registerBinaryCallback: registerBinaryCallback != null\n                         ? registerBinaryCallback\n                         : other.registerBinaryCallback,\n      scheduleMicrotask: scheduleMicrotask != null\n                         ? scheduleMicrotask\n                         : other.scheduleMicrotask,\n      createTimer : createTimer != null ? createTimer : other.createTimer,\n      createPeriodicTimer: createPeriodicTimer != null\n                           ? createPeriodicTimer\n                           : other.createPeriodicTimer,\n      print : print != null ? print : other.print,\n      fork: fork != null ? fork : other.fork);\n  }\n\n  HandleUncaughtErrorHandler get handleUncaughtError;\n  RunHandler get run;\n  RunUnaryHandler get runUnary;\n  RunBinaryHandler get runBinary;\n  RegisterCallbackHandler get registerCallback;\n  RegisterUnaryCallbackHandler get registerUnaryCallback;\n  RegisterBinaryCallbackHandler get registerBinaryCallback;\n  ScheduleMicrotaskHandler get scheduleMicrotask;\n  CreateTimerHandler get createTimer;\n  CreatePeriodicTimerHandler get createPeriodicTimer;\n  PrintHandler get print;\n  ForkHandler get fork;\n}\n\n/**\n * Internal [ZoneSpecification] class.\n *\n * The implementation wants to rely on the fact that the getters cannot change\n * dynamically. We thus require users to go through the redirecting\n * [ZoneSpecification] constructor which instantiates this class.\n */\nclass _ZoneSpecification implements ZoneSpecification {\n  const _ZoneSpecification({\n    this.handleUncaughtError: null,\n    this.run: null,\n    this.runUnary: null,\n    this.runBinary: null,\n    this.registerCallback: null,\n    this.registerUnaryCallback: null,\n    this.registerBinaryCallback: null,\n    this.scheduleMicrotask: null,\n    this.createTimer: null,\n    this.createPeriodicTimer: null,\n    this.print: null,\n    this.fork: null\n  });\n\n  // TODO(13406): Enable types when dart2js supports it.\n  final /*HandleUncaughtErrorHandler*/ handleUncaughtError;\n  final /*RunHandler*/ run;\n  final /*RunUnaryHandler*/ runUnary;\n  final /*RunBinaryHandler*/ runBinary;\n  final /*RegisterCallbackHandler*/ registerCallback;\n  final /*RegisterUnaryCallbackHandler*/ registerUnaryCallback;\n  final /*RegisterBinaryCallbackHandler*/ registerBinaryCallback;\n  final /*ScheduleMicrotaskHandler*/ scheduleMicrotask;\n  final /*CreateTimerHandler*/ createTimer;\n  final /*CreatePeriodicTimerHandler*/ createPeriodicTimer;\n  final /*PrintHandler*/ print;\n  final /*ForkHandler*/ fork;\n}\n\n/**\n * This class wraps zones for delegation.\n *\n * When forwarding to parent zones one can't just invoke the parent zone's\n * exposed functions (like [Zone.run]), but one needs to provide more\n * information (like the zone the `run` was initiated). Zone callbacks thus\n * receive more information including this [ZoneDelegate] class. When delegating\n * to the parent zone one should go through the given instance instead of\n * directly invoking the parent zone.\n */\nabstract class ZoneDelegate {\n  dynamic handleUncaughtError(Zone zone, error, StackTrace stackTrace);\n  dynamic run(Zone zone, f());\n  dynamic runUnary(Zone zone, f(arg), arg);\n  dynamic runBinary(Zone zone, f(arg1, arg2), arg1, arg2);\n  ZoneCallback registerCallback(Zone zone, f());\n  ZoneUnaryCallback registerUnaryCallback(Zone zone, f(arg));\n  ZoneBinaryCallback registerBinaryCallback(Zone zone, f(arg1, arg2));\n  void scheduleMicrotask(Zone zone, f());\n  Timer createTimer(Zone zone, Duration duration, void f());\n  Timer createPeriodicTimer(Zone zone, Duration period, void f(Timer timer));\n  void print(Zone zone, String line);\n  Zone fork(Zone zone, ZoneSpecification specification, Map zoneValues);\n}\n\n/**\n * A Zone represents the asynchronous version of a dynamic extent. Asynchronous\n * callbacks are executed in the zone they have been queued in. For example,\n * the callback of a `future.then` is executed in the same zone as the one where\n * the `then` was invoked.\n */\nabstract class Zone {\n  // Private constructor so that it is not possible instantiate a Zone class.\n  Zone._();\n\n  /// The root zone that is implicitly created.\n  static const Zone ROOT = _ROOT_ZONE;\n\n  /// The currently running zone.\n  static Zone _current = _ROOT_ZONE;\n\n  static Zone get current => _current;\n\n  dynamic handleUncaughtError(error, StackTrace stackTrace);\n\n  /**\n   * Returns the parent zone.\n   *\n   * Returns `null` if `this` is the [ROOT] zone.\n   */\n  Zone get parent;\n\n  /**\n   * The error zone is the one that is responsible for dealing with uncaught\n   * errors.\n   * Errors are not allowed to cross between zones with different error-zones.\n   *\n   * This is the closest parent or ancestor zone of this zone that has a custom\n   * [handleUncaughtError] method.\n   */\n  Zone get errorZone;\n\n  /**\n   * Returns true if `this` and [otherZone] are in the same error zone.\n   *\n   * Two zones are in the same error zone if they inherit their\n   * [handleUncaughtError] callback from the same [errorZone].\n   */\n  bool inSameErrorZone(Zone otherZone);\n\n  /**\n   * Creates a new zone as a child of `this`.\n   *\n   * The new zone will have behavior like the current zone, except where\n   * overridden by functions in [specification].\n   *\n   * The new zone will have the same stored values (accessed through\n   * `operator []`) as this zone, but updated with the keys and values\n   * in [zoneValues]. If a key is in both this zone's values and in\n   * `zoneValues`, the new zone will use the value from `zoneValues``.\n   */\n  Zone fork({ ZoneSpecification specification,\n              Map zoneValues });\n\n  /**\n   * Executes the given function [f] in this zone.\n   */\n  dynamic run(f());\n\n  /**\n   * Executes the given callback [f] with argument [arg] in this zone.\n   */\n  dynamic runUnary(f(arg), var arg);\n\n  /**\n   * Executes the given callback [f] with argument [arg1] and [arg2] in this\n   * zone.\n   */\n  dynamic runBinary(f(arg1, arg2), var arg1, var arg2);\n\n  /**\n   * Executes the given function [f] in this zone.\n   *\n   * Same as [run] but catches uncaught errors and gives them to\n   * [handleUncaughtError].\n   */\n  dynamic runGuarded(f());\n\n  /**\n   * Executes the given callback [f] in this zone.\n   *\n   * Same as [runUnary] but catches uncaught errors and gives them to\n   * [handleUncaughtError].\n   */\n  dynamic runUnaryGuarded(f(arg), var arg);\n\n  /**\n   * Executes the given callback [f] in this zone.\n   *\n   * Same as [runBinary] but catches uncaught errors and gives them to\n   * [handleUncaughtError].\n   */\n  dynamic runBinaryGuarded(f(arg1, arg2), var arg1, var arg2);\n\n  /**\n   * Registers the given callback in this zone.\n   *\n   * It is good practice to register asynchronous or delayed callbacks before\n   * invoking [run]. This gives the zone a chance to wrap the callback and\n   * to store information with the callback. For example, a zone may decide\n   * to store the stack trace (at the time of the registration) with the\n   * callback.\n   *\n   * Returns a potentially new callback that should be used in place of the\n   * given [callback].\n   */\n  ZoneCallback registerCallback(callback());\n\n  /**\n   * Registers the given callback in this zone.\n   *\n   * Similar to [registerCallback] but with a unary callback.\n   */\n  ZoneUnaryCallback registerUnaryCallback(callback(arg));\n\n  /**\n   * Registers the given callback in this zone.\n   *\n   * Similar to [registerCallback] but with a unary callback.\n   */\n  ZoneBinaryCallback registerBinaryCallback(callback(arg1, arg2));\n\n  /**\n   *  Equivalent to:\n   *\n   *      ZoneCallback registered = registerCallback(f);\n   *      if (runGuarded) return () => this.runGuarded(registered);\n   *      return () => this.run(registered);\n   *\n   */\n  ZoneCallback bindCallback(f(), { bool runGuarded: true });\n\n  /**\n   *  Equivalent to:\n   *\n   *      ZoneCallback registered = registerUnaryCallback(f);\n   *      if (runGuarded) return (arg) => this.runUnaryGuarded(registered, arg);\n   *      return (arg) => thin.runUnary(registered, arg);\n   */\n  ZoneUnaryCallback bindUnaryCallback(f(arg), { bool runGuarded: true });\n\n  /**\n   *  Equivalent to:\n   *\n   *      ZoneCallback registered = registerBinaryCallback(f);\n   *      if (runGuarded) {\n   *        return (arg1, arg2) => this.runBinaryGuarded(registered, arg);\n   *      }\n   *      return (arg1, arg2) => thin.runBinary(registered, arg1, arg2);\n   */\n  ZoneBinaryCallback bindBinaryCallback(\n      f(arg1, arg2), { bool runGuarded: true });\n\n  /**\n   * Runs [f] asynchronously in this zone.\n   */\n  void scheduleMicrotask(void f());\n\n  /**\n   * Creates a Timer where the callback is executed in this zone.\n   */\n  Timer createTimer(Duration duration, void callback());\n\n  /**\n   * Creates a periodic Timer where the callback is executed in this zone.\n   */\n  Timer createPeriodicTimer(Duration period, void callback(Timer timer));\n\n  /**\n   * Prints the given [line].\n   */\n  void print(String line);\n\n  /**\n   * Call to enter the Zone.\n   *\n   * The previous current zone is returned.\n   */\n  static Zone _enter(Zone zone) {\n    assert(zone != null);\n    assert(!identical(zone, _current));\n    Zone previous = _current;\n    _current = zone;\n    return previous;\n  }\n\n  /**\n   * Call to leave the Zone.\n   *\n   * The previous Zone must be provided as `previous`.\n   */\n  static void _leave(Zone previous) {\n    assert(previous != null);\n    Zone._current = previous;\n  }\n\n  /**\n   * Retrieves the zone-value associated with [key].\n   *\n   * If this zone does not contain the value looks up the same key in the\n   * parent zone. If the [key] is not found returns `null`.\n   *\n   * Any object can be used as key, as long as it has compatible `operator ==`\n   * and `hashCode` implementations.\n   * By controlling access to the key, a zone can grant or deny access to the\n   * zone value.\n   */\n  operator [](Object key);\n}\n\nZoneDelegate _parentDelegate(_Zone zone) {\n  if (zone.parent == null) return null;\n  return zone.parent._delegate;\n}\n\nclass _ZoneDelegate implements ZoneDelegate {\n  final _Zone _delegationTarget;\n\n  _ZoneDelegate(this._delegationTarget);\n\n  dynamic handleUncaughtError(Zone zone, error, StackTrace stackTrace) {\n    _ZoneFunction implementation = _delegationTarget._handleUncaughtError;\n    _Zone implZone = implementation.zone;\n    return (implementation.function)(\n        implZone, _parentDelegate(implZone), zone, error, stackTrace);\n  }\n\n  dynamic run(Zone zone, f()) {\n    _ZoneFunction implementation = _delegationTarget._run;\n    _Zone implZone = implementation.zone;\n    return (implementation.function)(\n        implZone, _parentDelegate(implZone), zone, f);\n  }\n\n  dynamic runUnary(Zone zone, f(arg), arg) {\n    _ZoneFunction implementation = _delegationTarget._runUnary;\n    _Zone implZone = implementation.zone;\n    return (implementation.function)(\n        implZone, _parentDelegate(implZone), zone, f, arg);\n  }\n\n  dynamic runBinary(Zone zone, f(arg1, arg2), arg1, arg2) {\n    _ZoneFunction implementation = _delegationTarget._runBinary;\n    _Zone implZone = implementation.zone;\n    return (implementation.function)(\n        implZone, _parentDelegate(implZone), zone, f, arg1, arg2);\n  }\n\n  ZoneCallback registerCallback(Zone zone, f()) {\n    _ZoneFunction implementation = _delegationTarget._registerCallback;\n    _Zone implZone = implementation.zone;\n    return (implementation.function)(\n        implZone, _parentDelegate(implZone), zone, f);\n  }\n\n  ZoneUnaryCallback registerUnaryCallback(Zone zone, f(arg)) {\n    _ZoneFunction implementation = _delegationTarget._registerUnaryCallback;\n    _Zone implZone = implementation.zone;\n    return (implementation.function)(\n        implZone, _parentDelegate(implZone), zone, f);\n  }\n\n  ZoneBinaryCallback registerBinaryCallback(Zone zone, f(arg1, arg2)) {\n    _ZoneFunction implementation = _delegationTarget._registerBinaryCallback;\n    _Zone implZone = implementation.zone;\n    return (implementation.function)(\n        implZone, _parentDelegate(implZone), zone, f);\n  }\n\n  void scheduleMicrotask(Zone zone, f()) {\n    _ZoneFunction implementation = _delegationTarget._scheduleMicrotask;\n    _Zone implZone = implementation.zone;\n    (implementation.function)(\n        implZone, _parentDelegate(implZone), zone, f);\n  }\n\n  Timer createTimer(Zone zone, Duration duration, void f()) {\n    _ZoneFunction implementation = _delegationTarget._createTimer;\n    _Zone implZone = implementation.zone;\n    return (implementation.function)(\n        implZone, _parentDelegate(implZone), zone, duration, f);\n  }\n\n  Timer createPeriodicTimer(Zone zone, Duration period, void f(Timer timer)) {\n    _ZoneFunction implementation = _delegationTarget._createPeriodicTimer;\n    _Zone implZone = implementation.zone;\n    return (implementation.function)(\n        implZone, _parentDelegate(implZone), zone, period, f);\n  }\n\n  void print(Zone zone, String line) {\n    _ZoneFunction implementation = _delegationTarget._print;\n    _Zone implZone = implementation.zone;\n    (implementation.function)(\n        implZone, _parentDelegate(implZone), zone, line);\n  }\n\n  Zone fork(Zone zone, ZoneSpecification specification,\n            Map zoneValues) {\n    _ZoneFunction implementation = _delegationTarget._fork;\n    _Zone implZone = implementation.zone;\n    return (implementation.function)(\n        implZone, _parentDelegate(implZone), zone, specification, zoneValues);\n  }\n}\n\n\n/**\n * Base class for Zone implementations.\n */\nabstract class _Zone implements Zone {\n  const _Zone();\n\n  _ZoneFunction get _runUnary;\n  _ZoneFunction get _run;\n  _ZoneFunction get _runBinary;\n  _ZoneFunction get _registerCallback;\n  _ZoneFunction get _registerUnaryCallback;\n  _ZoneFunction get _registerBinaryCallback;\n  _ZoneFunction get _scheduleMicrotask;\n  _ZoneFunction get _createTimer;\n  _ZoneFunction get _createPeriodicTimer;\n  _ZoneFunction get _print;\n  _ZoneFunction get _fork;\n  _ZoneFunction get _handleUncaughtError;\n  _Zone get parent;\n  _ZoneDelegate get _delegate;\n  Map get _map;\n\n  bool inSameErrorZone(Zone otherZone) {\n    return identical(errorZone, otherZone.errorZone);\n  }\n}\n\nclass _CustomZone extends _Zone {\n  // The actual zone and implementation of each of these\n  // inheritable zone functions.\n  _ZoneFunction _runUnary;\n  _ZoneFunction _run;\n  _ZoneFunction _runBinary;\n  _ZoneFunction _registerCallback;\n  _ZoneFunction _registerUnaryCallback;\n  _ZoneFunction _registerBinaryCallback;\n  _ZoneFunction _scheduleMicrotask;\n  _ZoneFunction _createTimer;\n  _ZoneFunction _createPeriodicTimer;\n  _ZoneFunction _print;\n  _ZoneFunction _fork;\n  _ZoneFunction _handleUncaughtError;\n\n  // A cached delegate to this zone.\n  ZoneDelegate _delegateCache;\n\n  /// The parent zone.\n  final _Zone parent;\n\n  /// The zone's scoped value declaration map.\n  ///\n  /// This is always a [HashMap].\n  final Map _map;\n\n  ZoneDelegate get _delegate {\n    if (_delegateCache != null) return _delegateCache;\n    _delegateCache = new _ZoneDelegate(this);\n    return _delegateCache;\n  }\n\n  _CustomZone(this.parent, ZoneSpecification specification, this._map) {\n    // The root zone will have implementations of all parts of the\n    // specification, so it will never try to access the (null) parent.\n    // All other zones have a non-null parent.\n    _run = (specification.run != null)\n        ? new _ZoneFunction(this, specification.run)\n        : parent._run;\n    _runUnary = (specification.runUnary != null)\n        ? new _ZoneFunction(this, specification.runUnary)\n        : parent._runUnary;\n    _runBinary = (specification.runBinary != null)\n        ? new _ZoneFunction(this, specification.runBinary)\n        : parent._runBinary;\n    _registerCallback = (specification.registerCallback != null)\n        ? new _ZoneFunction(this, specification.registerCallback)\n        : parent._registerCallback;\n    _registerUnaryCallback = (specification.registerUnaryCallback != null)\n        ? new _ZoneFunction(this, specification.registerUnaryCallback)\n        : parent._registerUnaryCallback;\n    _registerBinaryCallback = (specification.registerBinaryCallback != null)\n        ? new _ZoneFunction(this, specification.registerBinaryCallback)\n        : parent._registerBinaryCallback;\n    _scheduleMicrotask = (specification.scheduleMicrotask != null)\n        ? new _ZoneFunction(this, specification.scheduleMicrotask)\n        : parent._scheduleMicrotask;\n    _createTimer = (specification.createTimer != null)\n        ? new _ZoneFunction(this, specification.createTimer)\n        : parent._createTimer;\n    _createPeriodicTimer = (specification.createPeriodicTimer != null)\n        ? new _ZoneFunction(this, specification.createPeriodicTimer)\n        : parent._createPeriodicTimer;\n    _print = (specification.print != null)\n        ? new _ZoneFunction(this, specification.print)\n        : parent._print;\n    _fork = (specification.fork != null)\n        ? new _ZoneFunction(this, specification.fork)\n        : parent._fork;\n    _handleUncaughtError = (specification.handleUncaughtError != null)\n        ? new _ZoneFunction(this, specification.handleUncaughtError)\n        : parent._handleUncaughtError;\n  }\n\n  /**\n   * The closest error-handling zone.\n   *\n   * Returns `this` if `this` has an error-handler. Otherwise returns the\n   * parent's error-zone.\n   */\n  Zone get errorZone => _handleUncaughtError.zone;\n\n  dynamic runGuarded(f()) {\n    try {\n      return run(f);\n    } catch (e, s) {\n      return handleUncaughtError(e, s);\n    }\n  }\n\n  dynamic runUnaryGuarded(f(arg), arg) {\n    try {\n      return runUnary(f, arg);\n    } catch (e, s) {\n      return handleUncaughtError(e, s);\n    }\n  }\n\n  dynamic runBinaryGuarded(f(arg1, arg2), arg1, arg2) {\n    try {\n      return runBinary(f, arg1, arg2);\n    } catch (e, s) {\n      return handleUncaughtError(e, s);\n    }\n  }\n\n  ZoneCallback bindCallback(f(), { bool runGuarded: true }) {\n    ZoneCallback registered = registerCallback(f);\n    if (runGuarded) {\n      return () => this.runGuarded(registered);\n    } else {\n      return () => this.run(registered);\n    }\n  }\n\n  ZoneUnaryCallback bindUnaryCallback(f(arg), { bool runGuarded: true }) {\n    ZoneUnaryCallback registered = registerUnaryCallback(f);\n    if (runGuarded) {\n      return (arg) => this.runUnaryGuarded(registered, arg);\n    } else {\n      return (arg) => this.runUnary(registered, arg);\n    }\n  }\n\n  ZoneBinaryCallback bindBinaryCallback(\n      f(arg1, arg2), { bool runGuarded: true }) {\n    ZoneBinaryCallback registered = registerBinaryCallback(f);\n    if (runGuarded) {\n      return (arg1, arg2) => this.runBinaryGuarded(registered, arg1, arg2);\n    } else {\n      return (arg1, arg2) => this.runBinary(registered, arg1, arg2);\n    }\n  }\n\n  operator [](Object key) {\n    var result = _map[key];\n    if (result != null || _map.containsKey(key)) return result;\n    // If we are not the root zone, look up in the parent zone.\n    if (parent != null) {\n      // We do not optimize for repeatedly looking up a key which isn't\n      // there. That would require storing the key and keeping it alive.\n      // Copying the key/value from the parent does not keep any new values\n      // alive.\n      var value = parent[key];\n      if (value != null) {\n        _map[key] = value;\n      }\n      return value;\n    }\n    assert(this == _ROOT_ZONE);\n    return null;\n  }\n\n  // Methods that can be customized by the zone specification.\n\n  dynamic handleUncaughtError(error, StackTrace stackTrace) {\n    _ZoneFunction implementation = this._handleUncaughtError;\n    assert(implementation != null);\n    ZoneDelegate parentDelegate = _parentDelegate(implementation.zone);\n    return (implementation.function)(\n        implementation.zone, parentDelegate, this, error, stackTrace);\n  }\n\n  Zone fork({ZoneSpecification specification, Map zoneValues}) {\n    _ZoneFunction implementation = this._fork;\n    assert(implementation != null);\n    ZoneDelegate parentDelegate = _parentDelegate(implementation.zone);\n    return (implementation.function)(\n        implementation.zone, parentDelegate, this,\n                          specification, zoneValues);\n  }\n\n  dynamic run(f()) {\n    _ZoneFunction implementation = this._run;\n    assert(implementation != null);\n    ZoneDelegate parentDelegate = _parentDelegate(implementation.zone);\n    return (implementation.function)(\n        implementation.zone, parentDelegate, this, f);\n  }\n\n  dynamic runUnary(f(arg), arg) {\n    _ZoneFunction implementation = this._runUnary;\n    assert(implementation != null);\n    ZoneDelegate parentDelegate = _parentDelegate(implementation.zone);\n    return (implementation.function)(\n        implementation.zone, parentDelegate, this, f, arg);\n  }\n\n  dynamic runBinary(f(arg1, arg2), arg1, arg2) {\n    _ZoneFunction implementation = this._runBinary;\n    assert(implementation != null);\n    ZoneDelegate parentDelegate = _parentDelegate(implementation.zone);\n    return (implementation.function)(\n        implementation.zone, parentDelegate, this, f, arg1, arg2);\n  }\n\n  ZoneCallback registerCallback(f()) {\n    _ZoneFunction implementation = this._registerCallback;\n    assert(implementation != null);\n    ZoneDelegate parentDelegate = _parentDelegate(implementation.zone);\n    return (implementation.function)(\n        implementation.zone, parentDelegate, this, f);\n  }\n\n  ZoneUnaryCallback registerUnaryCallback(f(arg)) {\n    _ZoneFunction implementation = this._registerUnaryCallback;\n    assert(implementation != null);\n    ZoneDelegate parentDelegate = _parentDelegate(implementation.zone);\n    return (implementation.function)(\n        implementation.zone, parentDelegate, this, f);\n  }\n\n  ZoneBinaryCallback registerBinaryCallback(f(arg1, arg2)) {\n    _ZoneFunction implementation = this._registerBinaryCallback;\n    assert(implementation != null);\n    ZoneDelegate parentDelegate = _parentDelegate(implementation.zone);\n    return (implementation.function)(\n        implementation.zone, parentDelegate, this, f);\n  }\n\n  void scheduleMicrotask(void f()) {\n    _ZoneFunction implementation = this._scheduleMicrotask;\n    assert(implementation != null);\n    ZoneDelegate parentDelegate = _parentDelegate(implementation.zone);\n    return (implementation.function)(\n        implementation.zone, parentDelegate, this, f);\n  }\n\n  Timer createTimer(Duration duration, void f()) {\n    _ZoneFunction implementation = this._createTimer;\n    assert(implementation != null);\n    ZoneDelegate parentDelegate = _parentDelegate(implementation.zone);\n    return (implementation.function)(\n        implementation.zone, parentDelegate, this, duration, f);\n  }\n\n  Timer createPeriodicTimer(Duration duration, void f(Timer timer)) {\n    _ZoneFunction implementation = this._createPeriodicTimer;\n    assert(implementation != null);\n    ZoneDelegate parentDelegate = _parentDelegate(implementation.zone);\n    return (implementation.function)(\n        implementation.zone, parentDelegate, this, duration, f);\n  }\n\n  void print(String line) {\n    _ZoneFunction implementation = this._print;\n    assert(implementation != null);\n    ZoneDelegate parentDelegate = _parentDelegate(implementation.zone);\n    return (implementation.function)(\n        implementation.zone, parentDelegate, this, line);\n  }\n}\n\nvoid _rootHandleUncaughtError(\n    Zone self, ZoneDelegate parent, Zone zone, error, StackTrace stackTrace) {\n  _schedulePriorityAsyncCallback(() {\n    throw new _UncaughtAsyncError(error, stackTrace);\n  });\n}\n\ndynamic _rootRun(Zone self, ZoneDelegate parent, Zone zone, f()) {\n  if (Zone._current == zone) return f();\n\n  Zone old = Zone._enter(zone);\n  try {\n    return f();\n  } finally {\n    Zone._leave(old);\n  }\n}\n\ndynamic _rootRunUnary(Zone self, ZoneDelegate parent, Zone zone, f(arg), arg) {\n  if (Zone._current == zone) return f(arg);\n\n  Zone old = Zone._enter(zone);\n  try {\n    return f(arg);\n  } finally {\n    Zone._leave(old);\n  }\n}\n\ndynamic _rootRunBinary(Zone self, ZoneDelegate parent, Zone zone,\n                       f(arg1, arg2), arg1, arg2) {\n  if (Zone._current == zone) return f(arg1, arg2);\n\n  Zone old = Zone._enter(zone);\n  try {\n    return f(arg1, arg2);\n  } finally {\n    Zone._leave(old);\n  }\n}\n\nZoneCallback _rootRegisterCallback(\n    Zone self, ZoneDelegate parent, Zone zone, f()) {\n  return f;\n}\n\nZoneUnaryCallback _rootRegisterUnaryCallback(\n    Zone self, ZoneDelegate parent, Zone zone, f(arg)) {\n  return f;\n}\n\nZoneBinaryCallback _rootRegisterBinaryCallback(\n    Zone self, ZoneDelegate parent, Zone zone, f(arg1, arg2)) {\n  return f;\n}\n\nvoid _rootScheduleMicrotask(Zone self, ZoneDelegate parent, Zone zone, f()) {\n  if (!identical(_ROOT_ZONE, zone)) {\n    f = zone.bindCallback(f);\n  }\n  _scheduleAsyncCallback(f);\n}\n\nTimer _rootCreateTimer(Zone self, ZoneDelegate parent, Zone zone,\n                       Duration duration, void callback()) {\n  if (!identical(_ROOT_ZONE, zone)) {\n    callback = zone.bindCallback(callback);\n  }\n  return Timer._createTimer(duration, callback);\n}\n\nTimer _rootCreatePeriodicTimer(\n    Zone self, ZoneDelegate parent, Zone zone,\n    Duration duration, void callback(Timer timer)) {\n  if (!identical(_ROOT_ZONE, zone)) {\n    callback = zone.bindUnaryCallback(callback);\n  }\n  return Timer._createPeriodicTimer(duration, callback);\n}\n\nvoid _rootPrint(Zone self, ZoneDelegate parent, Zone zone, String line) {\n  printToConsole(line);\n}\n\nvoid _printToZone(String line) {\n  Zone.current.print(line);\n}\n\nZone _rootFork(Zone self, ZoneDelegate parent, Zone zone,\n               ZoneSpecification specification,\n               Map zoneValues) {\n  // TODO(floitsch): it would be nice if we could get rid of this hack.\n  // Change the static zoneOrDirectPrint function to go through zones\n  // from now on.\n  printToZone = _printToZone;\n\n  if (specification == null) {\n    specification = const ZoneSpecification();\n  } else if (specification is! _ZoneSpecification) {\n    throw new ArgumentError(\"ZoneSpecifications must be instantiated\"\n        \" with the provided constructor.\");\n  }\n  Map valueMap;\n  if (zoneValues == null) {\n    if (zone is _Zone) {\n      valueMap = zone._map;\n    } else {\n      valueMap = new HashMap();\n    }\n  } else {\n    valueMap = new HashMap.from(zoneValues);\n  }\n  return new _CustomZone(zone, specification, valueMap);\n}\n\nclass _RootZoneSpecification implements ZoneSpecification {\n  HandleUncaughtErrorHandler get handleUncaughtError =>\n      _rootHandleUncaughtError;\n  RunHandler get run => _rootRun;\n  RunUnaryHandler get runUnary => _rootRunUnary;\n  RunBinaryHandler get runBinary => _rootRunBinary;\n  RegisterCallbackHandler get registerCallback => _rootRegisterCallback;\n  RegisterUnaryCallbackHandler get registerUnaryCallback =>\n      _rootRegisterUnaryCallback;\n  RegisterBinaryCallbackHandler get registerBinaryCallback =>\n      _rootRegisterBinaryCallback;\n  ScheduleMicrotaskHandler get scheduleMicrotask => _rootScheduleMicrotask;\n  CreateTimerHandler get createTimer => _rootCreateTimer;\n  CreatePeriodicTimerHandler get createPeriodicTimer =>\n      _rootCreatePeriodicTimer;\n  PrintHandler get print => _rootPrint;\n  ForkHandler get fork => _rootFork;\n}\n\nclass _RootZone extends _Zone {\n  const _RootZone();\n\n  _ZoneFunction get _run =>\n      const _ZoneFunction(_ROOT_ZONE, _rootRun);\n  _ZoneFunction get _runUnary =>\n      const _ZoneFunction(_ROOT_ZONE, _rootRunUnary);\n  _ZoneFunction get _runBinary =>\n      const _ZoneFunction(_ROOT_ZONE, _rootRunBinary);\n  _ZoneFunction get _registerCallback =>\n      const _ZoneFunction(_ROOT_ZONE, _rootRegisterCallback);\n  _ZoneFunction get _registerUnaryCallback =>\n      const _ZoneFunction(_ROOT_ZONE, _rootRegisterUnaryCallback);\n  _ZoneFunction get _registerBinaryCallback =>\n      const _ZoneFunction(_ROOT_ZONE, _rootRegisterBinaryCallback);\n  _ZoneFunction get _scheduleMicrotask =>\n      const _ZoneFunction(_ROOT_ZONE, _rootScheduleMicrotask);\n  _ZoneFunction get _createTimer =>\n      const _ZoneFunction(_ROOT_ZONE, _rootCreateTimer);\n  _ZoneFunction get _createPeriodicTimer =>\n      const _ZoneFunction(_ROOT_ZONE, _rootCreatePeriodicTimer);\n  _ZoneFunction get _print =>\n      const _ZoneFunction(_ROOT_ZONE, _rootPrint);\n  _ZoneFunction get _fork =>\n      const _ZoneFunction(_ROOT_ZONE, _rootFork);\n  _ZoneFunction get _handleUncaughtError =>\n      const _ZoneFunction(_ROOT_ZONE, _rootHandleUncaughtError);\n\n  // The parent zone.\n  _Zone get parent => null;\n\n  /// The zone's scoped value declaration map.\n  ///\n  /// This is always a [HashMap].\n  Map get _map => _rootMap;\n\n  static Map _rootMap = new HashMap();\n\n  static ZoneDelegate _rootDelegate;\n\n  ZoneDelegate get _delegate {\n    if (_rootDelegate != null) return _rootDelegate;\n    return _rootDelegate = new _ZoneDelegate(this);\n  }\n\n  /**\n   * The closest error-handling zone.\n   *\n   * Returns `this` if `this` has an error-handler. Otherwise returns the\n   * parent's error-zone.\n   */\n  Zone get errorZone => this;\n\n  // Zone interface.\n\n  dynamic runGuarded(f()) {\n    try {\n      if (identical(_ROOT_ZONE, Zone._current)) {\n        return f();\n      }\n      return _rootRun(null, null, this, f);\n    } catch (e, s) {\n      return handleUncaughtError(e, s);\n    }\n  }\n\n  dynamic runUnaryGuarded(f(arg), arg) {\n    try {\n      if (identical(_ROOT_ZONE, Zone._current)) {\n        return f(arg);\n      }\n      return _rootRunUnary(null, null, this, f, arg);\n    } catch (e, s) {\n      return handleUncaughtError(e, s);\n    }\n  }\n\n  dynamic runBinaryGuarded(f(arg1, arg2), arg1, arg2) {\n    try {\n      if (identical(_ROOT_ZONE, Zone._current)) {\n        return f(arg1, arg2);\n      }\n      return _rootRunBinary(null, null, this, f, arg1, arg2);\n    } catch (e, s) {\n      return handleUncaughtError(e, s);\n    }\n  }\n\n  ZoneCallback bindCallback(f(), { bool runGuarded: true }) {\n    if (runGuarded) {\n      return () => this.runGuarded(f);\n    } else {\n      return () => this.run(f);\n    }\n  }\n\n  ZoneUnaryCallback bindUnaryCallback(f(arg), { bool runGuarded: true }) {\n    if (runGuarded) {\n      return (arg) => this.runUnaryGuarded(f, arg);\n    } else {\n      return (arg) => this.runUnary(f, arg);\n    }\n  }\n\n  ZoneBinaryCallback bindBinaryCallback(\n      f(arg1, arg2), { bool runGuarded: true }) {\n    if (runGuarded) {\n      return (arg1, arg2) => this.runBinaryGuarded(f, arg1, arg2);\n    } else {\n      return (arg1, arg2) => this.runBinary(f, arg1, arg2);\n    }\n  }\n\n  operator [](Object key) => null;\n\n  // Methods that can be customized by the zone specification.\n\n  dynamic handleUncaughtError(error, StackTrace stackTrace) {\n    return _rootHandleUncaughtError(null, null, this, error, stackTrace);\n  }\n\n  Zone fork({ZoneSpecification specification, Map zoneValues}) {\n    return _rootFork(null, null, this, specification, zoneValues);\n  }\n\n  dynamic run(f()) {\n    if (identical(Zone._current, _ROOT_ZONE)) return f();\n    return _rootRun(null, null, this, f);\n  }\n\n  dynamic runUnary(f(arg), arg) {\n    if (identical(Zone._current, _ROOT_ZONE)) return f(arg);\n    return _rootRunUnary(null, null, this, f, arg);\n  }\n\n  dynamic runBinary(f(arg1, arg2), arg1, arg2) {\n    if (identical(Zone._current, _ROOT_ZONE)) return f(arg1, arg2);\n    return _rootRunBinary(null, null, this, f, arg1, arg2);\n  }\n\n  ZoneCallback registerCallback(f()) => f;\n\n  ZoneUnaryCallback registerUnaryCallback(f(arg)) => f;\n\n  ZoneBinaryCallback registerBinaryCallback(f(arg1, arg2)) => f;\n\n  void scheduleMicrotask(void f()) {\n    _rootScheduleMicrotask(null, null, this, f);\n  }\n\n  Timer createTimer(Duration duration, void f()) {\n    return Timer._createTimer(duration, f);\n  }\n\n  Timer createPeriodicTimer(Duration duration, void f(Timer timer)) {\n    return Timer._createPeriodicTimer(duration, f);\n  }\n\n  void print(String line) {\n    printToConsole(line);\n  }\n}\n\nconst _ROOT_ZONE = const _RootZone();\n\n/**\n * Runs [body] in its own zone.\n *\n * If [onError] is non-null the zone is considered an error zone. All uncaught\n * errors, synchronous or asynchronous, in the zone are caught and handled\n * by the callback.\n *\n * Errors may never cross error-zone boundaries. This is intuitive for leaving\n * a zone, but it also applies for errors that would enter an error-zone.\n * Errors that try to cross error-zone boundaries are considered uncaught.\n *\n *     var future = new Future.value(499);\n *     runZoned(() {\n *       future = future.then((_) { throw \"error in first error-zone\"; });\n *       runZoned(() {\n *         future = future.catchError((e) { print(\"Never reached!\"); });\n *       }, onError: (e) { print(\"unused error handler\"); });\n *     }, onError: (e) { print(\"catches error of first error-zone.\"); });\n *\n * Example:\n *\n *     runZoned(() {\n *       new Future(() { throw \"asynchronous error\"; });\n *     }, onError: print);  // Will print \"asynchronous error\".\n */\ndynamic runZoned(body(),\n                 { Map zoneValues,\n                   ZoneSpecification zoneSpecification,\n                   Function onError }) {\n  HandleUncaughtErrorHandler errorHandler;\n  if (onError != null) {\n    errorHandler = (Zone self, ZoneDelegate parent, Zone zone,\n                    error, StackTrace stackTrace) {\n      try {\n        if (onError is ZoneBinaryCallback) {\n          return self.parent.runBinary(onError, error, stackTrace);\n        }\n        return self.parent.runUnary(onError, error);\n      } catch(e, s) {\n        if (identical(e, error)) {\n          return parent.handleUncaughtError(zone, error, stackTrace);\n        } else {\n          return parent.handleUncaughtError(zone, e, s);\n        }\n      }\n    };\n  }\n  if (zoneSpecification == null) {\n    zoneSpecification =\n        new ZoneSpecification(handleUncaughtError: errorHandler);\n  } else if (errorHandler != null) {\n    zoneSpecification =\n        new ZoneSpecification.from(zoneSpecification,\n                                   handleUncaughtError: errorHandler);\n  }\n  Zone zone = Zone.current.fork(specification: zoneSpecification,\n                                zoneValues: zoneValues);\n  if (onError != null) {\n    return zone.runGuarded(body);\n  } else {\n    return zone.run(body);\n  }\n}\n\u0000","sdk:/sdk/lib/async/timer.dart":"// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\npart of dart.async;\n\n/**\n * A count-down timer that can be configured to fire once or repeatedly.\n *\n * The timer counts down from the specified duration to 0.\n * When the timer reaches 0, the timer invokes the specified callback function.\n * Use a periodic timer to repeatedly count down the same interval.\n *\n * A negative duration is treated the same as a duration of 0.\n * If the duration is statically known to be 0, consider using [run].\n *\n * Frequently the duration is either a constant or computed as in the\n * following example (taking advantage of the multiplication operator of\n * the [Duration] class):\n *\n *     const TIMEOUT = const Duration(seconds: 3);\n *     const ms = const Duration(milliseconds: 1);\n *\n *     startTimeout([int milliseconds]) {\n *       var duration = milliseconds == null ? TIMEOUT : ms * milliseconds;\n *       return new Timer(duration, handleTimeout);\n *     }\n *     ...\n *     void handleTimeout() {  // callback function\n *       ...\n *     }\n *\n * Note: If Dart code using Timer is compiled to JavaScript, the finest\n * granularity available in the browser is 4 milliseconds.\n *\n * See [Stopwatch] for measuring elapsed time.\n */\nabstract class Timer {\n\n  /**\n   * Creates a new timer.\n   *\n   * The [callback] function is invoked after the given [duration].\n   *\n   */\n  factory Timer(Duration duration, void callback()) {\n    if (Zone.current == Zone.ROOT) {\n      // No need to bind the callback. We know that the root's timer will\n      // be invoked in the root zone.\n      return Zone.current.createTimer(duration, callback);\n    }\n    return Zone.current.createTimer(\n        duration, Zone.current.bindCallback(callback, runGuarded: true));\n  }\n\n  /**\n   * Creates a new repeating timer.\n   *\n   * The [callback] is invoked repeatedly with [duration] intervals until\n   * canceled with the [cancel] function.\n   */\n  factory Timer.periodic(Duration duration,\n                         void callback(Timer timer)) {\n    if (Zone.current == Zone.ROOT) {\n      // No need to bind the callback. We know that the root's timer will\n      // be invoked in the root zone.\n      return Zone.current.createPeriodicTimer(duration, callback);\n    }\n    return Zone.current.createPeriodicTimer(\n        duration, Zone.current.bindUnaryCallback(callback, runGuarded: true));\n  }\n\n  /**\n   * Runs the given [callback] asynchronously as soon as possible.\n   *\n   * This function is equivalent to `new Timer(Duration.ZERO, callback)`.\n   */\n  static void run(void callback()) {\n    new Timer(Duration.ZERO, callback);\n  }\n\n  /**\n   * Cancels the timer.\n   */\n  void cancel();\n\n  /**\n   * Returns whether the timer is still active.\n   *\n   * A non-periodic timer is active if the callback has not been executed,\n   * and the timer has not been canceled.\n   *\n   * A periodic timer is active if it has not been canceled.\n   */\n  bool get isActive;\n\n  external static Timer _createTimer(Duration duration, void callback());\n  external static Timer _createPeriodicTimer(Duration duration,\n                                             void callback(Timer timer));\n}\n\n\u0000","sdk:/sdk/lib/async/stream_transformers.dart":"// Copyright (c) 2013, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\npart of dart.async;\n\n/**\n * Wraps an [_EventSink] so it exposes only the [EventSink] interface.\n */\nclass _EventSinkWrapper<T> implements EventSink<T> {\n  _EventSink _sink;\n  _EventSinkWrapper(this._sink);\n\n  void add(T data) { _sink._add(data); }\n  void addError(error, [StackTrace stackTrace]) {\n    _sink._addError(error, stackTrace);\n  }\n  void close() { _sink._close(); }\n}\n\n/**\n * A StreamSubscription that pipes data through a sink.\n *\n * The constructor of this class takes a [_SinkMapper] which maps from\n * [EventSink] to [EventSink]. The input to the mapper is the output of\n * the transformation. The returned sink is the transformation's input.\n */\nclass _SinkTransformerStreamSubscription<S, T>\n    extends _BufferingStreamSubscription<T> {\n  /// The transformer's input sink.\n  EventSink _transformerSink;\n\n  /// The subscription to the input stream.\n  StreamSubscription<S> _subscription;\n\n  _SinkTransformerStreamSubscription(Stream<S> source,\n                                     _SinkMapper mapper,\n                                     void onData(T data),\n                                     Function onError,\n                                     void onDone(),\n                                     bool cancelOnError)\n      // We set the adapter's target only when the user is allowed to send data.\n      : super(onData, onError, onDone, cancelOnError) {\n    _EventSinkWrapper<T> eventSink = new _EventSinkWrapper<T>(this);\n    _transformerSink = mapper(eventSink);\n    _subscription = source.listen(_handleData,\n                                  onError: _handleError,\n                                  onDone: _handleDone);\n  }\n\n  /** Whether this subscription is still subscribed to its source. */\n  bool get _isSubscribed => _subscription != null;\n\n  // _EventSink interface.\n\n  /**\n   * Adds an event to this subscriptions.\n   *\n   * Contrary to normal [_BufferingStreamSubscription]s we may receive\n   * events when the stream is already closed. Report them as state\n   * error.\n   */\n  void _add(T data) {\n    if (_isClosed) {\n      throw new StateError(\"Stream is already closed\");\n    }\n    super._add(data);\n  }\n\n  /**\n   * Adds an error event to this subscriptions.\n   *\n   * Contrary to normal [_BufferingStreamSubscription]s we may receive\n   * events when the stream is already closed. Report them as state\n   * error.\n   */\n  void _addError(Object error, StackTrace stackTrace) {\n    if (_isClosed) {\n      throw new StateError(\"Stream is already closed\");\n    }\n    super._addError(error, stackTrace);\n  }\n\n  /**\n   * Adds a close event to this subscriptions.\n   *\n   * Contrary to normal [_BufferingStreamSubscription]s we may receive\n   * events when the stream is already closed. Report them as state\n   * error.\n   */\n  void _close() {\n    if (_isClosed) {\n      throw new StateError(\"Stream is already closed\");\n    }\n    super._close();\n  }\n\n  // _BufferingStreamSubscription hooks.\n\n  void _onPause() {\n    if (_isSubscribed) _subscription.pause();\n  }\n\n  void _onResume() {\n    if (_isSubscribed) _subscription.resume();\n  }\n\n  Future _onCancel() {\n    if (_isSubscribed) {\n      StreamSubscription subscription = _subscription;\n      _subscription = null;\n      subscription.cancel();\n    }\n    return null;\n  }\n\n  void _handleData(S data) {\n    try {\n      _transformerSink.add(data);\n    } catch (e, s) {\n      _addError(e, s);\n    }\n  }\n\n  void _handleError(error, [stackTrace]) {\n    try {\n      _transformerSink.addError(error, stackTrace);\n    } catch (e, s) {\n      if (identical(e, error)) {\n        _addError(error, stackTrace);\n      } else {\n        _addError(e, s);\n      }\n    }\n  }\n\n  void _handleDone() {\n    try {\n      _subscription = null;\n      _transformerSink.close();\n    } catch (e, s) {\n      _addError(e, s);\n    }\n  }\n}\n\n\ntypedef EventSink<S> _SinkMapper<S, T>(EventSink<T> output);\n\n/**\n * A StreamTransformer for Sink-mappers.\n *\n * A Sink-mapper takes an [EventSink] (its output) and returns another\n * EventSink (its input).\n *\n * Note that this class can be `const`.\n */\nclass _StreamSinkTransformer<S, T> implements StreamTransformer<S, T> {\n  final _SinkMapper<S, T> _sinkMapper;\n  const _StreamSinkTransformer(this._sinkMapper);\n\n  Stream<T> bind(Stream<S> stream)\n      => new _BoundSinkStream<S, T>(stream, _sinkMapper);\n}\n\n/**\n * The result of binding a StreamTransformer for Sink-mappers.\n *\n * It contains the bound Stream and the sink-mapper. Only when the user starts\n * listening to this stream is the sink-mapper invoked. The result is used\n * to create a StreamSubscription that transforms events.\n */\nclass _BoundSinkStream<S, T> extends Stream<T> {\n  final _SinkMapper<S, T> _sinkMapper;\n  final Stream<S> _stream;\n\n  bool get isBroadcast => _stream.isBroadcast;\n\n  _BoundSinkStream(this._stream, this._sinkMapper);\n\n  StreamSubscription<T> listen(void onData(T event),\n                               { Function onError,\n                                 void onDone(),\n                                 bool cancelOnError }) {\n    cancelOnError = identical(true, cancelOnError);\n    StreamSubscription<T> subscription = new _SinkTransformerStreamSubscription(\n        _stream, _sinkMapper, onData, onError, onDone, cancelOnError);\n    return subscription;\n  }\n}\n\n/// Data-handler coming from [StreamTransformer.fromHandlers].\ntypedef void _TransformDataHandler<S, T>(S data, EventSink<T> sink);\n/// Error-handler coming from [StreamTransformer.fromHandlers].\ntypedef void _TransformErrorHandler<T>(\n    Object error, StackTrace stackTrace, EventSink<T> sink);\n/// Done-handler coming from [StreamTransformer.fromHandlers].\ntypedef void _TransformDoneHandler<T>(EventSink<T> sink);\n\n/**\n * Wraps handlers (from [StreamTransformer.fromHandlers]) into an `EventSink`.\n *\n * This way we can reuse the code from [_StreamSinkTransformer].\n */\nclass _HandlerEventSink<S, T> implements EventSink<S> {\n  final _TransformDataHandler<S, T> _handleData;\n  final _TransformErrorHandler<T> _handleError;\n  final _TransformDoneHandler<T> _handleDone;\n\n  /// The output sink where the handlers should send their data into.\n  final EventSink<T> _sink;\n\n  _HandlerEventSink(this._handleData, this._handleError, this._handleDone,\n                    this._sink);\n\n  void add(S data) => _handleData(data, _sink);\n  void addError(Object error, [StackTrace stackTrace])\n      => _handleError(error, stackTrace, _sink);\n  void close() => _handleDone(_sink);\n}\n\n/**\n * A StreamTransformer that transformers events with the given handlers.\n *\n * Note that this transformer can only be used once.\n */\nclass _StreamHandlerTransformer<S, T> extends _StreamSinkTransformer<S, T> {\n\n  _StreamHandlerTransformer({\n      void handleData(S data, EventSink<T> sink),\n      void handleError(Object error, StackTrace stackTrace, EventSink<T> sink),\n      void handleDone(EventSink<T> sink)})\n      : super((EventSink<T> outputSink) {\n          if (handleData == null) handleData = _defaultHandleData;\n          if (handleError == null) handleError = _defaultHandleError;\n          if (handleDone == null) handleDone = _defaultHandleDone;\n          return new _HandlerEventSink<S, T>(\n              handleData, handleError, handleDone, outputSink);\n        });\n\n  Stream<T> bind(Stream<S> stream) {\n    return super.bind(stream);\n  }\n\n  /** Default data handler forwards all data. */\n  static void _defaultHandleData(var data, EventSink sink) {\n    sink.add(data);\n  }\n\n  /** Default error handler forwards all errors. */\n  static void _defaultHandleError(error, StackTrace stackTrace,\n                                  EventSink sink) {\n    sink.addError(error);\n  }\n\n  /** Default done handler forwards done. */\n  static void _defaultHandleDone(EventSink sink) {\n    sink.close();\n  }\n}\n\n/// A closure mapping a stream and cancelOnError to a StreamSubscription.\ntypedef StreamSubscription<T> _SubscriptionTransformer<S, T>(\n    Stream<S> stream, bool cancelOnError);\n\n/**\n * A [StreamTransformer] that minimizes the number of additional classes.\n *\n * Instead of implementing three classes: a [StreamTransformer], a [Stream]\n * (as the result of a `bind` call) and a [StreamSubscription] (which does the\n * actual work), this class only requires a fincution that is invoked when the\n * last bit (the subscription) of the transformer-workflow is needed.\n *\n * The given transformer function maps from Stream and cancelOnError to a\n * `StreamSubscription`. As such it can also act on `cancel` events, making it\n * fully general.\n */\nclass _StreamSubscriptionTransformer<S, T> implements StreamTransformer<S, T> {\n  final _SubscriptionTransformer<S, T> _transformer;\n\n  const _StreamSubscriptionTransformer(this._transformer);\n\n  Stream<T> bind(Stream<S> stream) =>\n      new _BoundSubscriptionStream<S, T>(stream, _transformer);\n}\n\n/**\n * A stream transformed by a [_StreamSubscriptionTransformer].\n *\n * When this stream is listened to it invokes the [_transformer] function with\n * the stored [_stream]. Usually the transformer starts listening at this\n * moment.\n */\nclass _BoundSubscriptionStream<S, T> extends Stream<T> {\n  final _SubscriptionTransformer<S, T> _transformer;\n  final Stream<S> _stream;\n\n  _BoundSubscriptionStream(this._stream, this._transformer);\n\n  StreamSubscription<T> listen(void onData(T event),\n                               { Function onError,\n                                 void onDone(),\n                                 bool cancelOnError }) {\n    cancelOnError = identical(true, cancelOnError);\n    StreamSubscription<T> result = _transformer(_stream, cancelOnError);\n    result.onData(onData);\n    result.onError(onError);\n    result.onDone(onDone);\n    return result;\n  }\n}\n\u0000","sdk:/sdk/lib/async/stream_pipe.dart":"// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\npart of dart.async;\n\n/** Runs user code and takes actions depending on success or failure. */\n_runUserCode(userCode(),\n             onSuccess(value),\n             onError(error, StackTrace stackTrace)) {\n  try {\n    onSuccess(userCode());\n  } catch (e, s) {\n    onError(e, s);\n  }\n}\n\n/** Helper function to cancel a subscription and wait for the potential future,\n  before completing with an error. */\nvoid _cancelAndError(StreamSubscription subscription,\n                     _Future future,\n                     error,\n                     StackTrace stackTrace) {\n  var cancelFuture = subscription.cancel();\n  if (cancelFuture is Future) {\n    cancelFuture.whenComplete(() => future._completeError(error, stackTrace));\n  } else {\n    future._completeError(error, stackTrace);\n  }\n}\n\n/** Helper function to make an onError argument to [_runUserCode]. */\n_cancelAndErrorClosure(StreamSubscription subscription, _Future future) =>\n  ((error, StackTrace stackTrace) => _cancelAndError(\n      subscription, future, error, stackTrace));\n\n/** Helper function to cancel a subscription and wait for the potential future,\n  before completing with a value. */\nvoid _cancelAndValue(StreamSubscription subscription, _Future future, value) {\n  var cancelFuture = subscription.cancel();\n  if (cancelFuture is Future) {\n    cancelFuture.whenComplete(() => future._complete(value));\n  } else {\n    future._complete(value);\n  }\n}\n\n\n/**\n * A [Stream] that forwards subscriptions to another stream.\n *\n * This stream implements [Stream], but forwards all subscriptions\n * to an underlying stream, and wraps the returned subscription to\n * modify the events on the way.\n *\n * This class is intended for internal use only.\n */\nabstract class _ForwardingStream<S, T> extends Stream<T> {\n  final Stream<S> _source;\n\n  _ForwardingStream(this._source);\n\n  bool get isBroadcast => _source.isBroadcast;\n\n  StreamSubscription<T> listen(void onData(T value),\n                              { Function onError,\n                                void onDone(),\n                                bool cancelOnError }) {\n    cancelOnError = identical(true, cancelOnError);\n    return _createSubscription(onData, onError, onDone, cancelOnError);\n  }\n\n  StreamSubscription<T> _createSubscription(\n      void onData(T data),\n      Function onError,\n      void onDone(),\n      bool cancelOnError) {\n    return new _ForwardingStreamSubscription<S, T>(\n        this, onData, onError, onDone, cancelOnError);\n  }\n\n  // Override the following methods in subclasses to change the behavior.\n\n  void _handleData(S data, _EventSink<T> sink) {\n    var outputData = data;\n    sink._add(outputData);\n  }\n\n  void _handleError(error, StackTrace stackTrace, _EventSink<T> sink) {\n    sink._addError(error, stackTrace);\n  }\n\n  void _handleDone(_EventSink<T> sink) {\n    sink._close();\n  }\n}\n\n/**\n * Abstract superclass for subscriptions that forward to other subscriptions.\n */\nclass _ForwardingStreamSubscription<S, T>\n    extends _BufferingStreamSubscription<T> {\n  final _ForwardingStream<S, T> _stream;\n\n  StreamSubscription<S> _subscription;\n\n  _ForwardingStreamSubscription(this._stream, void onData(T data),\n                                Function onError, void onDone(),\n                                bool cancelOnError)\n      : super(onData, onError, onDone, cancelOnError) {\n    _subscription = _stream._source.listen(_handleData,\n                                           onError: _handleError,\n                                           onDone: _handleDone);\n  }\n\n  // _StreamSink interface.\n  // Transformers sending more than one event have no way to know if the stream\n  // is canceled or closed after the first, so we just ignore remaining events.\n\n  void _add(T data) {\n    if (_isClosed) return;\n    super._add(data);\n  }\n\n  void _addError(Object error, StackTrace stackTrace) {\n    if (_isClosed) return;\n    super._addError(error, stackTrace);\n  }\n\n  // StreamSubscription callbacks.\n\n  void _onPause() {\n    if (_subscription == null) return;\n    _subscription.pause();\n  }\n\n  void _onResume() {\n    if (_subscription == null) return;\n    _subscription.resume();\n  }\n\n  Future _onCancel() {\n    if (_subscription != null) {\n      StreamSubscription subscription = _subscription;\n      _subscription = null;\n      subscription.cancel();\n    }\n    return null;\n  }\n\n  // Methods used as listener on source subscription.\n\n  void _handleData(S data) {\n    _stream._handleData(data, this);\n  }\n\n  void _handleError(error, StackTrace stackTrace) {\n    _stream._handleError(error, stackTrace, this);\n  }\n\n  void _handleDone() {\n    _stream._handleDone(this);\n  }\n}\n\n// -------------------------------------------------------------------\n// Stream transformers used by the default Stream implementation.\n// -------------------------------------------------------------------\n\ntypedef bool _Predicate<T>(T value);\n\nclass _WhereStream<T> extends _ForwardingStream<T, T> {\n  final _Predicate<T> _test;\n\n  _WhereStream(Stream<T> source, bool test(T value))\n      : _test = test, super(source);\n\n  void _handleData(T inputEvent, _EventSink<T> sink) {\n    bool satisfies;\n    try {\n      satisfies = _test(inputEvent);\n    } catch (e, s) {\n      sink._addError(e, s);\n      return;\n    }\n    if (satisfies) {\n      sink._add(inputEvent);\n    }\n  }\n}\n\n\ntypedef T _Transformation<S, T>(S value);\n\n/**\n * A stream pipe that converts data events before passing them on.\n */\nclass _MapStream<S, T> extends _ForwardingStream<S, T> {\n  final _Transformation _transform;\n\n  _MapStream(Stream<S> source, T transform(S event))\n      : this._transform = transform, super(source);\n\n  void _handleData(S inputEvent, _EventSink<T> sink) {\n    T outputEvent;\n    try {\n      outputEvent = _transform(inputEvent);\n    } catch (e, s) {\n      sink._addError(e, s);\n      return;\n    }\n    sink._add(outputEvent);\n  }\n}\n\n/**\n * A stream pipe that converts data events before passing them on.\n */\nclass _ExpandStream<S, T> extends _ForwardingStream<S, T> {\n  final _Transformation<S, Iterable<T>> _expand;\n\n  _ExpandStream(Stream<S> source, Iterable<T> expand(S event))\n      : this._expand = expand, super(source);\n\n  void _handleData(S inputEvent, _EventSink<T> sink) {\n    try {\n      for (T value in _expand(inputEvent)) {\n        sink._add(value);\n      }\n    } catch (e, s) {\n      // If either _expand or iterating the generated iterator throws,\n      // we abort the iteration.\n      sink._addError(e, s);\n    }\n  }\n}\n\n\ntypedef bool _ErrorTest(error);\n\n/**\n * A stream pipe that converts or disposes error events\n * before passing them on.\n */\nclass _HandleErrorStream<T> extends _ForwardingStream<T, T> {\n  final Function _transform;\n  final _ErrorTest _test;\n\n  _HandleErrorStream(Stream<T> source,\n                     Function onError,\n                     bool test(error))\n      : this._transform = onError, this._test = test, super(source);\n\n  void _handleError(Object error, StackTrace stackTrace, _EventSink<T> sink) {\n    bool matches = true;\n    if (_test != null) {\n      try {\n        matches = _test(error);\n      } catch (e, s) {\n        sink._addError(e, s);\n        return;\n      }\n    }\n    if (matches) {\n      try {\n        _invokeErrorHandler(_transform, error, stackTrace);\n      } catch (e, s) {\n        if (identical(e, error)) {\n          sink._addError(error, stackTrace);\n        } else {\n          sink._addError(e, s);\n        }\n        return;\n      }\n    } else {\n      sink._addError(error, stackTrace);\n    }\n  }\n}\n\n\nclass _TakeStream<T> extends _ForwardingStream<T, T> {\n  int _remaining;\n\n  _TakeStream(Stream<T> source, int count)\n      : this._remaining = count, super(source) {\n    // This test is done early to avoid handling an async error\n    // in the _handleData method.\n    if (count is! int) throw new ArgumentError(count);\n  }\n\n  void _handleData(T inputEvent, _EventSink<T> sink) {\n    if (_remaining > 0) {\n      sink._add(inputEvent);\n      _remaining -= 1;\n      if (_remaining == 0) {\n        // Closing also unsubscribes all subscribers, which unsubscribes\n        // this from source.\n        sink._close();\n      }\n    }\n  }\n}\n\n\nclass _TakeWhileStream<T> extends _ForwardingStream<T, T> {\n  final _Predicate<T> _test;\n\n  _TakeWhileStream(Stream<T> source, bool test(T value))\n      : this._test = test, super(source);\n\n  void _handleData(T inputEvent, _EventSink<T> sink) {\n    bool satisfies;\n    try {\n      satisfies = _test(inputEvent);\n    } catch (e, s) {\n      sink._addError(e, s);\n      // The test didn't say true. Didn't say false either, but we stop anyway.\n      sink._close();\n      return;\n    }\n    if (satisfies) {\n      sink._add(inputEvent);\n    } else {\n      sink._close();\n    }\n  }\n}\n\nclass _SkipStream<T> extends _ForwardingStream<T, T> {\n  int _remaining;\n\n  _SkipStream(Stream<T> source, int count)\n      : this._remaining = count, super(source) {\n    // This test is done early to avoid handling an async error\n    // in the _handleData method.\n    if (count is! int || count < 0) throw new ArgumentError(count);\n  }\n\n  void _handleData(T inputEvent, _EventSink<T> sink) {\n    if (_remaining > 0) {\n      _remaining--;\n      return;\n    }\n    sink._add(inputEvent);\n  }\n}\n\nclass _SkipWhileStream<T> extends _ForwardingStream<T, T> {\n  final _Predicate<T> _test;\n  bool _hasFailed = false;\n\n  _SkipWhileStream(Stream<T> source, bool test(T value))\n      : this._test = test, super(source);\n\n  void _handleData(T inputEvent, _EventSink<T> sink) {\n    if (_hasFailed) {\n      sink._add(inputEvent);\n      return;\n    }\n    bool satisfies;\n    try {\n      satisfies = _test(inputEvent);\n    } catch (e, s) {\n      sink._addError(e, s);\n      // A failure to return a boolean is considered \"not matching\".\n      _hasFailed = true;\n      return;\n    }\n    if (!satisfies) {\n      _hasFailed = true;\n      sink._add(inputEvent);\n    }\n  }\n}\n\ntypedef bool _Equality<T>(T a, T b);\n\nclass _DistinctStream<T> extends _ForwardingStream<T, T> {\n  static var _SENTINEL = new Object();\n\n  _Equality<T> _equals;\n  var _previous = _SENTINEL;\n\n  _DistinctStream(Stream<T> source, bool equals(T a, T b))\n      : _equals = equals, super(source);\n\n  void _handleData(T inputEvent, _EventSink<T> sink) {\n    if (identical(_previous, _SENTINEL)) {\n      _previous = inputEvent;\n      return sink._add(inputEvent);\n    } else {\n      bool isEqual;\n      try {\n        if (_equals == null) {\n          isEqual = (_previous == inputEvent);\n        } else {\n          isEqual = _equals(_previous, inputEvent);\n        }\n      } catch (e, s) {\n        sink._addError(e, s);\n        return null;\n      }\n      if (!isEqual) {\n        sink._add(inputEvent);\n        _previous = inputEvent;\n      }\n    }\n  }\n}\n\u0000","sdk:/sdk/lib/async/stream_impl.dart":"// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\npart of dart.async;\n\n/** Abstract and private interface for a place to put events. */\nabstract class _EventSink<T> {\n  void _add(T data);\n  void _addError(Object error, StackTrace stackTrace);\n  void _close();\n}\n\n/**\n * Abstract and private interface for a place to send events.\n *\n * Used by event buffering to finally dispatch the pending event, where\n * [_EventSink] is where the event first enters the stream subscription,\n * and may yet be buffered.\n */\nabstract class _EventDispatch<T> {\n  void _sendData(T data);\n  void _sendError(Object error, StackTrace stackTrace);\n  void _sendDone();\n}\n\n/**\n * Default implementation of stream subscription of buffering events.\n *\n * The only public methods are those of [StreamSubscription], so instances of\n * [_BufferingStreamSubscription] can be returned directly as a\n * [StreamSubscription] without exposing internal functionality.\n *\n * The [StreamController] is a public facing version of [Stream] and this class,\n * with some methods made public.\n *\n * The user interface of [_BufferingStreamSubscription] are the following\n * methods:\n *\n * * [_add]: Add a data event to the stream.\n * * [_addError]: Add an error event to the stream.\n * * [_close]: Request to close the stream.\n * * [_onCancel]: Called when the subscription will provide no more events,\n *     either due to being actively canceled, or after sending a done event.\n * * [_onPause]: Called when the subscription wants the event source to pause.\n * * [_onResume]: Called when allowing new events after a pause.\n *\n * The user should not add new events when the subscription requests a paused,\n * but if it happens anyway, the subscription will enqueue the events just as\n * when new events arrive while still firing an old event.\n */\nclass _BufferingStreamSubscription<T> implements StreamSubscription<T>,\n                                                 _EventSink<T>,\n                                                 _EventDispatch<T> {\n  /** The `cancelOnError` flag from the `listen` call. */\n  static const int _STATE_CANCEL_ON_ERROR = 1;\n  /**\n   * Whether the \"done\" event has been received.\n   * No further events are accepted after this.\n   */\n  static const int _STATE_CLOSED = 2;\n  /**\n   * Set if the input has been asked not to send events.\n   *\n   * This is not the same as being paused, since the input will remain paused\n   * after a call to [resume] if there are pending events.\n   */\n  static const int _STATE_INPUT_PAUSED = 4;\n  /**\n   * Whether the subscription has been canceled.\n   *\n   * Set by calling [cancel], or by handling a \"done\" event, or an \"error\" event\n   * when `cancelOnError` is true.\n   */\n  static const int _STATE_CANCELED = 8;\n  /**\n   * Set when either:\n   *\n   *   * an error is sent, and [cancelOnError] is true, or\n   *   * a done event is sent.\n   *\n   * If the subscription is canceled while _STATE_WAIT_FOR_CANCEL is set, the\n   * state is unset, and no furher events must be delivered.\n   */\n  static const int _STATE_WAIT_FOR_CANCEL = 16;\n  static const int _STATE_IN_CALLBACK = 32;\n  static const int _STATE_HAS_PENDING = 64;\n  static const int _STATE_PAUSE_COUNT = 128;\n  static const int _STATE_PAUSE_COUNT_SHIFT = 7;\n\n  /* Event handlers provided in constructor. */\n  _DataHandler<T> _onData;\n  Function _onError;\n  _DoneHandler _onDone;\n  final Zone _zone = Zone.current;\n\n  /** Bit vector based on state-constants above. */\n  int _state;\n\n  // TODO(floitsch): reuse another field\n  /** The future [_onCancel] may return. */\n  Future _cancelFuture;\n\n  /**\n   * Queue of pending events.\n   *\n   * Is created when necessary, or set in constructor for preconfigured events.\n   */\n  _PendingEvents _pending;\n\n  _BufferingStreamSubscription(void onData(T data),\n                               Function onError,\n                               void onDone(),\n                               bool cancelOnError)\n      : _state = (cancelOnError ? _STATE_CANCEL_ON_ERROR : 0) {\n    this.onData(onData);\n    this.onError(onError);\n    this.onDone(onDone);\n  }\n\n  /**\n   * Sets the subscription's pending events object.\n   *\n   * This can only be done once. The pending events object is used for the\n   * rest of the subscription's life cycle.\n   */\n  void _setPendingEvents(_PendingEvents pendingEvents) {\n    assert(_pending == null);\n    if (pendingEvents == null) return;\n    _pending = pendingEvents;\n    if (!pendingEvents.isEmpty) {\n      _state |= _STATE_HAS_PENDING;\n      _pending.schedule(this);\n    }\n  }\n\n  /**\n   * Extracts the pending events from a canceled stream.\n   *\n   * This can only be done during the [_onCancel] method call. After that,\n   * any remaining pending events will be cleared.\n   */\n  _PendingEvents _extractPending() {\n    assert(_isCanceled);\n    _PendingEvents events = _pending;\n    _pending = null;\n    return events;\n  }\n\n  // StreamSubscription interface.\n\n  void onData(void handleData(T event)) {\n    if (handleData == null) handleData = _nullDataHandler;\n    _onData = _zone.registerUnaryCallback(handleData);\n  }\n\n  void onError(Function handleError) {\n    if (handleError == null) handleError = _nullErrorHandler;\n    _onError = _registerErrorHandler(handleError, _zone);\n  }\n\n  void onDone(void handleDone()) {\n    if (handleDone == null) handleDone = _nullDoneHandler;\n    _onDone = _zone.registerCallback(handleDone);\n  }\n\n  void pause([Future resumeSignal]) {\n    if (_isCanceled) return;\n    bool wasPaused = _isPaused;\n    bool wasInputPaused = _isInputPaused;\n    // Increment pause count and mark input paused (if it isn't already).\n    _state = (_state + _STATE_PAUSE_COUNT) | _STATE_INPUT_PAUSED;\n    if (resumeSignal != null) resumeSignal.whenComplete(resume);\n    if (!wasPaused && _pending != null) _pending.cancelSchedule();\n    if (!wasInputPaused && !_inCallback) _guardCallback(_onPause);\n  }\n\n  void resume() {\n    if (_isCanceled) return;\n    if (_isPaused) {\n      _decrementPauseCount();\n      if (!_isPaused) {\n        if (_hasPending && !_pending.isEmpty) {\n          // Input is still paused.\n          _pending.schedule(this);\n        } else {\n          assert(_mayResumeInput);\n          _state &= ~_STATE_INPUT_PAUSED;\n          if (!_inCallback) _guardCallback(_onResume);\n        }\n      }\n    }\n  }\n\n  Future cancel() {\n    // The user doesn't want to receive any further events. If there is an\n    // error or done event pending (waiting for the cancel to be done) discard\n    // that event.\n    _state &= ~_STATE_WAIT_FOR_CANCEL;\n    if (_isCanceled) return _cancelFuture;\n    _cancel();\n    return _cancelFuture;\n  }\n\n  Future asFuture([var futureValue]) {\n    _Future<T> result = new _Future<T>();\n\n    // Overwrite the onDone and onError handlers.\n    _onDone = () { result._complete(futureValue); };\n    _onError = (error, stackTrace) {\n      cancel();\n      result._completeError(error, stackTrace);\n    };\n\n    return result;\n  }\n\n  // State management.\n\n  bool get _isInputPaused => (_state & _STATE_INPUT_PAUSED) != 0;\n  bool get _isClosed => (_state & _STATE_CLOSED) != 0;\n  bool get _isCanceled => (_state & _STATE_CANCELED) != 0;\n  bool get _waitsForCancel => (_state & _STATE_WAIT_FOR_CANCEL) != 0;\n  bool get _inCallback => (_state & _STATE_IN_CALLBACK) != 0;\n  bool get _hasPending => (_state & _STATE_HAS_PENDING) != 0;\n  bool get _isPaused => _state >= _STATE_PAUSE_COUNT;\n  bool get _canFire => _state < _STATE_IN_CALLBACK;\n  bool get _mayResumeInput =>\n      !_isPaused && (_pending == null || _pending.isEmpty);\n  bool get _cancelOnError => (_state & _STATE_CANCEL_ON_ERROR) != 0;\n\n  bool get isPaused => _isPaused;\n\n  void _cancel() {\n    _state |= _STATE_CANCELED;\n    if (_hasPending) {\n      _pending.cancelSchedule();\n    }\n    if (!_inCallback) _pending = null;\n    _cancelFuture = _onCancel();\n  }\n\n  /**\n   * Increment the pause count.\n   *\n   * Also marks input as paused.\n   */\n  void _incrementPauseCount() {\n    _state = (_state + _STATE_PAUSE_COUNT) | _STATE_INPUT_PAUSED;\n  }\n\n  /**\n   * Decrements the pause count.\n   *\n   * Does not automatically unpause the input (call [_onResume]) when\n   * the pause count reaches zero. This is handled elsewhere, and only\n   * if there are no pending events buffered.\n   */\n  void _decrementPauseCount() {\n    assert(_isPaused);\n    _state -= _STATE_PAUSE_COUNT;\n  }\n\n  // _EventSink interface.\n\n  void _add(T data) {\n    assert(!_isClosed);\n    if (_isCanceled) return;\n    if (_canFire) {\n      _sendData(data);\n    } else {\n      _addPending(new _DelayedData(data));\n    }\n  }\n\n  void _addError(Object error, StackTrace stackTrace) {\n    if (_isCanceled) return;\n    if (_canFire) {\n      _sendError(error, stackTrace);  // Reports cancel after sending.\n    } else {\n      _addPending(new _DelayedError(error, stackTrace));\n    }\n  }\n\n  void _close() {\n    assert(!_isClosed);\n    if (_isCanceled) return;\n    _state |= _STATE_CLOSED;\n    if (_canFire) {\n      _sendDone();\n    } else {\n      _addPending(const _DelayedDone());\n    }\n  }\n\n  // Hooks called when the input is paused, unpaused or canceled.\n  // These must not throw. If overwritten to call user code, include suitable\n  // try/catch wrapping and send any errors to\n  // [_Zone.current.handleUncaughtError].\n  void _onPause() {\n    assert(_isInputPaused);\n  }\n\n  void _onResume() {\n    assert(!_isInputPaused);\n  }\n\n  Future _onCancel() {\n    assert(_isCanceled);\n    return null;\n  }\n\n  // Handle pending events.\n\n  /**\n   * Add a pending event.\n   *\n   * If the subscription is not paused, this also schedules a firing\n   * of pending events later (if necessary).\n   */\n  void _addPending(_DelayedEvent event) {\n    _StreamImplEvents pending = _pending;\n    if (_pending == null) pending = _pending = new _StreamImplEvents();\n    pending.add(event);\n    if (!_hasPending) {\n      _state |= _STATE_HAS_PENDING;\n      if (!_isPaused) {\n        _pending.schedule(this);\n      }\n    }\n  }\n\n  /* _EventDispatch interface. */\n\n  void _sendData(T data) {\n    assert(!_isCanceled);\n    assert(!_isPaused);\n    assert(!_inCallback);\n    bool wasInputPaused = _isInputPaused;\n    _state |= _STATE_IN_CALLBACK;\n    _zone.runUnaryGuarded(_onData, data);\n    _state &= ~_STATE_IN_CALLBACK;\n    _checkState(wasInputPaused);\n  }\n\n  void _sendError(var error, StackTrace stackTrace) {\n    assert(!_isCanceled);\n    assert(!_isPaused);\n    assert(!_inCallback);\n    bool wasInputPaused = _isInputPaused;\n\n    void sendError() {\n      // If the subscription has been canceled while waiting for the cancel\n      // future to finish we must not report the error.\n      if (_isCanceled && !_waitsForCancel) return;\n      _state |= _STATE_IN_CALLBACK;\n      if (_onError is ZoneBinaryCallback) {\n        _zone.runBinaryGuarded(_onError, error, stackTrace);\n      } else {\n        _zone.runUnaryGuarded(_onError, error);\n      }\n      _state &= ~_STATE_IN_CALLBACK;\n    }\n\n    if (_cancelOnError) {\n      _state |= _STATE_WAIT_FOR_CANCEL;\n      _cancel();\n      if (_cancelFuture is Future) {\n        _cancelFuture.whenComplete(sendError);\n      } else {\n        sendError();\n      }\n    } else {\n      sendError();\n      // Only check state if not cancelOnError.\n      _checkState(wasInputPaused);\n    }\n  }\n\n  void _sendDone() {\n    assert(!_isCanceled);\n    assert(!_isPaused);\n    assert(!_inCallback);\n\n    void sendDone() {\n      // If the subscription has been canceled while waiting for the cancel\n      // future to finish we must not report the done event.\n      if (!_waitsForCancel) return;\n      _state |= (_STATE_CANCELED | _STATE_CLOSED | _STATE_IN_CALLBACK);\n      _zone.runGuarded(_onDone);\n      _state &= ~_STATE_IN_CALLBACK;\n    }\n\n    _cancel();\n    _state |= _STATE_WAIT_FOR_CANCEL;\n    if (_cancelFuture is Future) {\n      _cancelFuture.whenComplete(sendDone);\n    } else {\n      sendDone();\n    }\n  }\n\n  /**\n   * Call a hook function.\n   *\n   * The call is properly wrapped in code to avoid other callbacks\n   * during the call, and it checks for state changes after the call\n   * that should cause further callbacks.\n   */\n  void _guardCallback(callback) {\n    assert(!_inCallback);\n    bool wasInputPaused = _isInputPaused;\n    _state |= _STATE_IN_CALLBACK;\n    callback();\n    _state &= ~_STATE_IN_CALLBACK;\n    _checkState(wasInputPaused);\n  }\n\n  /**\n   * Check if the input needs to be informed of state changes.\n   *\n   * State changes are pausing, resuming and canceling.\n   *\n   * After canceling, no further callbacks will happen.\n   *\n   * The cancel callback is called after a user cancel, or after\n   * the final done event is sent.\n   */\n  void _checkState(bool wasInputPaused) {\n    assert(!_inCallback);\n    if (_hasPending && _pending.isEmpty) {\n      _state &= ~_STATE_HAS_PENDING;\n      if (_isInputPaused && _mayResumeInput) {\n        _state &= ~_STATE_INPUT_PAUSED;\n      }\n    }\n    // If the state changes during a callback, we immediately\n    // make a new state-change callback. Loop until the state didn't change.\n    while (true) {\n      if (_isCanceled) {\n        _pending = null;\n        return;\n      }\n      bool isInputPaused = _isInputPaused;\n      if (wasInputPaused == isInputPaused) break;\n      _state ^= _STATE_IN_CALLBACK;\n      if (isInputPaused) {\n        _onPause();\n      } else {\n        _onResume();\n      }\n      _state &= ~_STATE_IN_CALLBACK;\n      wasInputPaused = isInputPaused;\n    }\n    if (_hasPending && !_isPaused) {\n      _pending.schedule(this);\n    }\n  }\n}\n\n// -------------------------------------------------------------------\n// Common base class for single and multi-subscription streams.\n// -------------------------------------------------------------------\nabstract class _StreamImpl<T> extends Stream<T> {\n  // ------------------------------------------------------------------\n  // Stream interface.\n\n  StreamSubscription<T> listen(void onData(T data),\n                               { Function onError,\n                                 void onDone(),\n                                 bool cancelOnError }) {\n    cancelOnError = identical(true, cancelOnError);\n    StreamSubscription subscription =\n        _createSubscription(onData, onError, onDone, cancelOnError);\n    _onListen(subscription);\n    return subscription;\n  }\n\n  // -------------------------------------------------------------------\n  /** Create a subscription object. Called by [subcribe]. */\n  _BufferingStreamSubscription<T> _createSubscription(\n      void onData(T data),\n      Function onError,\n      void onDone(),\n      bool cancelOnError) {\n    return new _BufferingStreamSubscription<T>(onData, onError, onDone,\n                                               cancelOnError);\n  }\n\n  /** Hook called when the subscription has been created. */\n  void _onListen(StreamSubscription subscription) {}\n}\n\ntypedef _PendingEvents _EventGenerator();\n\n/** Stream that generates its own events. */\nclass _GeneratedStreamImpl<T> extends _StreamImpl<T> {\n  final _EventGenerator _pending;\n  bool _isUsed = false;\n  /**\n   * Initializes the stream to have only the events provided by a\n   * [_PendingEvents].\n   *\n   * A new [_PendingEvents] must be generated for each listen.\n   */\n  _GeneratedStreamImpl(this._pending);\n\n  StreamSubscription _createSubscription(\n      void onData(T data),\n      Function onError,\n      void onDone(),\n      bool cancelOnError) {\n    if (_isUsed) throw new StateError(\"Stream has already been listened to.\");\n    _isUsed = true;\n    return new _BufferingStreamSubscription(\n        onData, onError, onDone, cancelOnError).._setPendingEvents(_pending());\n  }\n}\n\n\n/** Pending events object that gets its events from an [Iterable]. */\nclass _IterablePendingEvents<T> extends _PendingEvents {\n  // The iterator providing data for data events.\n  // Set to null when iteration has completed.\n  Iterator<T> _iterator;\n\n  _IterablePendingEvents(Iterable<T> data) : _iterator = data.iterator;\n\n  bool get isEmpty => _iterator == null;\n\n  void handleNext(_EventDispatch dispatch) {\n    if (_iterator == null) {\n      throw new StateError(\"No events pending.\");\n    }\n    // Send one event per call to moveNext.\n    // If moveNext returns true, send the current element as data.\n    // If moveNext returns false, send a done event and clear the _iterator.\n    // If moveNext throws an error, send an error and clear the _iterator.\n    // After an error, no further events will be sent.\n    bool isDone;\n    try {\n      isDone = !_iterator.moveNext();\n    } catch (e, s) {\n      _iterator = null;\n      dispatch._sendError(e, s);\n      return;\n    }\n    if (!isDone) {\n      dispatch._sendData(_iterator.current);\n    } else {\n      _iterator = null;\n      dispatch._sendDone();\n    }\n  }\n\n  void clear() {\n    if (isScheduled) cancelSchedule();\n    _iterator = null;\n  }\n}\n\n\n// Internal helpers.\n\n// Types of the different handlers on a stream. Types used to type fields.\ntypedef void _DataHandler<T>(T value);\ntypedef void _DoneHandler();\n\n\n/** Default data handler, does nothing. */\nvoid _nullDataHandler(var value) {}\n\n/** Default error handler, reports the error to the current zone's handler. */\nvoid _nullErrorHandler(error, [StackTrace stackTrace]) {\n  Zone.current.handleUncaughtError(error, stackTrace);\n}\n\n/** Default done handler, does nothing. */\nvoid _nullDoneHandler() {}\n\n\n/** A delayed event on a buffering stream subscription. */\nabstract class _DelayedEvent {\n  /** Added as a linked list on the [StreamController]. */\n  _DelayedEvent next;\n  /** Execute the delayed event on the [StreamController]. */\n  void perform(_EventDispatch dispatch);\n}\n\n/** A delayed data event. */\nclass _DelayedData<T> extends _DelayedEvent {\n  final T value;\n  _DelayedData(this.value);\n  void perform(_EventDispatch<T> dispatch) {\n    dispatch._sendData(value);\n  }\n}\n\n/** A delayed error event. */\nclass _DelayedError extends _DelayedEvent {\n  final error;\n  final StackTrace stackTrace;\n\n  _DelayedError(this.error, this.stackTrace);\n  void perform(_EventDispatch dispatch) {\n    dispatch._sendError(error, stackTrace);\n  }\n}\n\n/** A delayed done event. */\nclass _DelayedDone implements _DelayedEvent {\n  const _DelayedDone();\n  void perform(_EventDispatch dispatch) {\n    dispatch._sendDone();\n  }\n\n  _DelayedEvent get next => null;\n\n  void set next(_DelayedEvent _) {\n    throw new StateError(\"No events after a done.\");\n  }\n}\n\n/** Superclass for provider of pending events. */\nabstract class _PendingEvents {\n  // No async event has been scheduled.\n  static const int _STATE_UNSCHEDULED = 0;\n  // An async event has been scheduled to run a function.\n  static const int _STATE_SCHEDULED = 1;\n  // An async event has been scheduled, but it will do nothing when it runs.\n  // Async events can't be preempted.\n  static const int _STATE_CANCELED = 3;\n\n  /**\n   * State of being scheduled.\n   *\n   * Set to [_STATE_SCHEDULED] when pending events are scheduled for\n   * async dispatch. Since we can't cancel a [scheduleMicrotask] call, if\n   * scheduling is \"canceled\", the _state is simply set to [_STATE_CANCELED]\n   * which will make the async code do nothing except resetting [_state].\n   *\n   * If events are scheduled while the state is [_STATE_CANCELED], it is\n   * merely switched back to [_STATE_SCHEDULED], but no new call to\n   * [scheduleMicrotask] is performed.\n   */\n  int _state = _STATE_UNSCHEDULED;\n\n  bool get isEmpty;\n\n  bool get isScheduled => _state == _STATE_SCHEDULED;\n  bool get _eventScheduled => _state >= _STATE_SCHEDULED;\n\n  /**\n   * Schedule an event to run later.\n   *\n   * If called more than once, it should be called with the same dispatch as\n   * argument each time. It may reuse an earlier argument in some cases.\n   */\n  void schedule(_EventDispatch dispatch) {\n    if (isScheduled) return;\n    assert(!isEmpty);\n    if (_eventScheduled) {\n      assert(_state == _STATE_CANCELED);\n      _state = _STATE_SCHEDULED;\n      return;\n    }\n    scheduleMicrotask(() {\n      int oldState = _state;\n      _state = _STATE_UNSCHEDULED;\n      if (oldState == _STATE_CANCELED) return;\n      handleNext(dispatch);\n    });\n    _state = _STATE_SCHEDULED;\n  }\n\n  void cancelSchedule() {\n    if (isScheduled) _state = _STATE_CANCELED;\n  }\n\n  void handleNext(_EventDispatch dispatch);\n\n  /** Throw away any pending events and cancel scheduled events. */\n  void clear();\n}\n\n\n/** Class holding pending events for a [_StreamImpl]. */\nclass _StreamImplEvents extends _PendingEvents {\n  /// Single linked list of [_DelayedEvent] objects.\n  _DelayedEvent firstPendingEvent = null;\n  /// Last element in the list of pending events. New events are added after it.\n  _DelayedEvent lastPendingEvent = null;\n\n  bool get isEmpty => lastPendingEvent == null;\n\n  void add(_DelayedEvent event) {\n    if (lastPendingEvent == null) {\n      firstPendingEvent = lastPendingEvent = event;\n    } else {\n      lastPendingEvent = lastPendingEvent.next = event;\n    }\n  }\n\n  void handleNext(_EventDispatch dispatch) {\n    assert(!isScheduled);\n    _DelayedEvent event = firstPendingEvent;\n    firstPendingEvent = event.next;\n    if (firstPendingEvent == null) {\n      lastPendingEvent = null;\n    }\n    event.perform(dispatch);\n  }\n\n  void clear() {\n    if (isScheduled) cancelSchedule();\n    firstPendingEvent = lastPendingEvent = null;\n  }\n}\n\nclass _BroadcastLinkedList {\n  _BroadcastLinkedList _next;\n  _BroadcastLinkedList _previous;\n\n  void _unlink() {\n    _previous._next = _next;\n    _next._previous = _previous;\n    _next = _previous = this;\n  }\n\n  void _insertBefore(_BroadcastLinkedList newNext) {\n    _BroadcastLinkedList newPrevious = newNext._previous;\n    newPrevious._next = this;\n    newNext._previous = _previous;\n    _previous._next = newNext;\n    _previous = newPrevious;\n  }\n}\n\ntypedef void _broadcastCallback(StreamSubscription subscription);\n\n/**\n * Done subscription that will send one done event as soon as possible.\n */\nclass _DoneStreamSubscription<T> implements StreamSubscription<T> {\n  static const int _DONE_SENT = 1;\n  static const int _SCHEDULED = 2;\n  static const int _PAUSED = 4;\n\n  final Zone _zone;\n  int _state = 0;\n  _DoneHandler _onDone;\n\n  _DoneStreamSubscription(this._onDone) : _zone = Zone.current {\n    _schedule();\n  }\n\n  bool get _isSent => (_state & _DONE_SENT) != 0;\n  bool get _isScheduled => (_state & _SCHEDULED) != 0;\n  bool get isPaused => _state >= _PAUSED;\n\n  void _schedule() {\n    if (_isScheduled) return;\n    _zone.scheduleMicrotask(_sendDone);\n    _state |= _SCHEDULED;\n  }\n\n  void onData(void handleData(T data)) {}\n  void onError(Function handleError) {}\n  void onDone(void handleDone()) { _onDone = handleDone; }\n\n  void pause([Future resumeSignal]) {\n    _state += _PAUSED;\n    if (resumeSignal != null) resumeSignal.whenComplete(resume);\n  }\n\n  void resume() {\n    if (isPaused) {\n      _state -= _PAUSED;\n      if (!isPaused && !_isSent) {\n        _schedule();\n      }\n    }\n  }\n\n  Future cancel() => null;\n\n  Future asFuture([futureValue]) {\n    _Future result = new _Future();\n    _onDone = () { result._completeWithValue(null); };\n    return result;\n  }\n\n  void _sendDone() {\n    _state &= ~_SCHEDULED;\n    if (isPaused) return;\n    _state |= _DONE_SENT;\n    if (_onDone != null) _zone.runGuarded(_onDone);\n  }\n}\n\nclass _AsBroadcastStream<T> extends Stream<T> {\n  final Stream<T> _source;\n  final _broadcastCallback _onListenHandler;\n  final _broadcastCallback _onCancelHandler;\n  final Zone _zone;\n\n  _AsBroadcastStreamController<T> _controller;\n  StreamSubscription<T> _subscription;\n\n  _AsBroadcastStream(this._source,\n                     void onListenHandler(StreamSubscription subscription),\n                     void onCancelHandler(StreamSubscription subscription))\n      : _onListenHandler = Zone.current.registerUnaryCallback(onListenHandler),\n        _onCancelHandler = Zone.current.registerUnaryCallback(onCancelHandler),\n        _zone = Zone.current {\n    _controller = new _AsBroadcastStreamController<T>(_onListen, _onCancel);\n  }\n\n  bool get isBroadcast => true;\n\n  StreamSubscription<T> listen(void onData(T data),\n                               { Function onError,\n                                 void onDone(),\n                                 bool cancelOnError}) {\n    if (_controller == null || _controller.isClosed) {\n      // Return a dummy subscription backed by nothing, since\n      // it will only ever send one done event.\n      return new _DoneStreamSubscription<T>(onDone);\n    }\n    if (_subscription == null) {\n      _subscription = _source.listen(_controller.add,\n                                     onError: _controller.addError,\n                                     onDone: _controller.close);\n    }\n    cancelOnError = identical(true, cancelOnError);\n    return _controller._subscribe(onData, onError, onDone, cancelOnError);\n  }\n\n  void _onCancel() {\n    bool shutdown = (_controller == null) || _controller.isClosed;\n    if (_onCancelHandler != null) {\n      _zone.runUnary(_onCancelHandler, new _BroadcastSubscriptionWrapper(this));\n    }\n    if (shutdown) {\n      if (_subscription != null) {\n        _subscription.cancel();\n        _subscription = null;\n      }\n    }\n  }\n\n  void _onListen() {\n    if (_onListenHandler != null) {\n      _zone.runUnary(_onListenHandler, new _BroadcastSubscriptionWrapper(this));\n    }\n  }\n\n  // Methods called from _BroadcastSubscriptionWrapper.\n  void _cancelSubscription() {\n    if (_subscription == null) return;\n    // Called by [_controller] when it has no subscribers left.\n    StreamSubscription subscription = _subscription;\n    _subscription = null;\n    _controller = null;  // Marks the stream as no longer listenable.\n    subscription.cancel();\n  }\n\n  void _pauseSubscription(Future resumeSignal) {\n    if (_subscription == null) return;\n    _subscription.pause(resumeSignal);\n  }\n\n  void _resumeSubscription() {\n    if (_subscription == null) return;\n    _subscription.resume();\n  }\n\n  bool get _isSubscriptionPaused {\n    if (_subscription == null) return false;\n    return _subscription.isPaused;\n  }\n}\n\n/**\n * Wrapper for subscription that disallows changing handlers.\n */\nclass _BroadcastSubscriptionWrapper<T> implements StreamSubscription<T> {\n  final _AsBroadcastStream _stream;\n\n  _BroadcastSubscriptionWrapper(this._stream);\n\n  void onData(void handleData(T data)) {\n    throw new UnsupportedError(\n        \"Cannot change handlers of asBroadcastStream source subscription.\");\n  }\n\n  void onError(void handleError(Object data)) {\n    throw new UnsupportedError(\n        \"Cannot change handlers of asBroadcastStream source subscription.\");\n  }\n\n  void onDone(void handleDone()) {\n    throw new UnsupportedError(\n        \"Cannot change handlers of asBroadcastStream source subscription.\");\n  }\n\n  void pause([Future resumeSignal]) {\n    _stream._pauseSubscription(resumeSignal);\n  }\n\n  void resume() {\n    _stream._resumeSubscription();\n  }\n\n  Future cancel() {\n    _stream._cancelSubscription();\n    return null;\n  }\n\n  bool get isPaused {\n    return _stream._isSubscriptionPaused;\n  }\n\n  Future asFuture([var futureValue]) {\n    throw new UnsupportedError(\n        \"Cannot change handlers of asBroadcastStream source subscription.\");\n  }\n}\n\n\n/**\n * Simple implementation of [StreamIterator].\n */\nclass _StreamIteratorImpl<T> implements StreamIterator<T> {\n  // Internal state of the stream iterator.\n  // At any time, it is in one of these states.\n  // The interpretation of the [_futureOrPrefecth] field depends on the state.\n  // In _STATE_MOVING, the _data field holds the most recently returned\n  // future.\n  // When in one of the _STATE_EXTRA_* states, the it may hold the\n  // next data/error object, and the subscription is paused.\n\n  /// The simple state where [_data] holds the data to return, and [moveNext]\n  /// is allowed. The subscription is actively listening.\n  static const int _STATE_FOUND = 0;\n  /// State set after [moveNext] has returned false or an error,\n  /// or after calling [cancel]. The subscription is always canceled.\n  static const int _STATE_DONE = 1;\n  /// State set after calling [moveNext], but before its returned future has\n  /// completed. Calling [moveNext] again is not allowed in this state.\n  /// The subscription is actively listening.\n  static const int _STATE_MOVING = 2;\n  /// States set when another event occurs while in _STATE_FOUND.\n  /// This extra overflow event is cached until the next call to [moveNext],\n  /// which will complete as if it received the event normally.\n  /// The subscription is paused in these states, so we only ever get one\n  /// event too many.\n  static const int _STATE_EXTRA_DATA = 3;\n  static const int _STATE_EXTRA_ERROR = 4;\n  static const int _STATE_EXTRA_DONE = 5;\n\n  /// Subscription being listened to.\n  StreamSubscription _subscription;\n\n  /// The current element represented by the most recent call to moveNext.\n  ///\n  /// Is null between the time moveNext is called and its future completes.\n  T _current = null;\n\n  /// The future returned by the most recent call to [moveNext].\n  ///\n  /// Also used to store the next value/error in case the stream provides an\n  /// event before [moveNext] is called again. In that case, the stream will\n  /// be paused to prevent further events.\n  var _futureOrPrefetch = null;\n\n  /// The current state.\n  int _state = _STATE_FOUND;\n\n  _StreamIteratorImpl(final Stream<T> stream) {\n    _subscription = stream.listen(_onData,\n                                  onError: _onError,\n                                  onDone: _onDone,\n                                  cancelOnError: true);\n  }\n\n  T get current => _current;\n\n  Future<bool> moveNext() {\n    if (_state == _STATE_DONE) {\n      return new _Future<bool>.immediate(false);\n    }\n    if (_state == _STATE_MOVING) {\n      throw new StateError(\"Already waiting for next.\");\n    }\n    if (_state == _STATE_FOUND) {\n      _state = _STATE_MOVING;\n      _current = null;\n      _futureOrPrefetch = new _Future<bool>();\n      return _futureOrPrefetch;\n    } else {\n      assert(_state >= _STATE_EXTRA_DATA);\n      switch (_state) {\n        case _STATE_EXTRA_DATA:\n          _state = _STATE_FOUND;\n          _current = _futureOrPrefetch;\n          _futureOrPrefetch = null;\n          _subscription.resume();\n          return new _Future<bool>.immediate(true);\n        case _STATE_EXTRA_ERROR:\n          Object prefetch = _futureOrPrefetch;\n          _clear();\n          return new _Future<bool>.immediateError(prefetch);\n        case _STATE_EXTRA_DONE:\n          _clear();\n          return new _Future<bool>.immediate(false);\n      }\n    }\n  }\n\n  /** Clears up the internal state when the iterator ends. */\n  void _clear() {\n    _subscription = null;\n    _futureOrPrefetch = null;\n    _current = null;\n    _state = _STATE_DONE;\n  }\n\n  Future cancel() {\n    StreamSubscription subscription = _subscription;\n    if (_state == _STATE_MOVING) {\n      _Future<bool> hasNext = _futureOrPrefetch;\n      _clear();\n      hasNext._complete(false);\n    } else {\n      _clear();\n    }\n    return subscription.cancel();\n  }\n\n  void _onData(T data) {\n    if (_state == _STATE_MOVING) {\n      _current = data;\n      _Future<bool> hasNext = _futureOrPrefetch;\n      _futureOrPrefetch = null;\n      _state = _STATE_FOUND;\n      hasNext._complete(true);\n      return;\n    }\n    _subscription.pause();\n    assert(_futureOrPrefetch == null);\n    _futureOrPrefetch = data;\n    _state = _STATE_EXTRA_DATA;\n  }\n\n  void _onError(Object error, [StackTrace stackTrace]) {\n    if (_state == _STATE_MOVING) {\n      _Future<bool> hasNext = _futureOrPrefetch;\n      // We have cancelOnError: true, so the subscription is canceled.\n      _clear();\n      hasNext._completeError(error, stackTrace);\n      return;\n    }\n    _subscription.pause();\n    assert(_futureOrPrefetch == null);\n    _futureOrPrefetch = error;\n    _state = _STATE_EXTRA_ERROR;\n  }\n\n  void _onDone() {\n     if (_state == _STATE_MOVING) {\n      _Future<bool> hasNext = _futureOrPrefetch;\n      _clear();\n      hasNext._complete(false);\n      return;\n    }\n    _subscription.pause();\n    _futureOrPrefetch = null;\n    _state = _STATE_EXTRA_DONE;\n  }\n}\n\u0000","sdk:/sdk/lib/async/stream_controller.dart":"// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\npart of dart.async;\n\n// -------------------------------------------------------------------\n// Controller for creating and adding events to a stream.\n// -------------------------------------------------------------------\n\n/**\n * A controller with the stream it controls.\n *\n * This controller allows sending data, error and done events on\n * its [stream].\n * This class can be used to create a simple stream that others\n * can listen on, and to push events to that stream.\n *\n * It's possible to check whether the stream is paused or not, and whether\n * it has subscribers or not, as well as getting a callback when either of\n * these change.\n *\n * If the stream starts or stops having listeners (first listener subscribing,\n * last listener unsubscribing), the `onSubscriptionStateChange` callback\n * is notified as soon as possible. If the subscription stat changes during\n * an event firing or a callback being executed, the change will not be reported\n * until the current event or callback has finished.\n * If the pause state has also changed during an event or callback, only the\n * subscription state callback is notified.\n *\n * If the subscriber state has not changed, but the pause state has, the\n * `onPauseStateChange` callback is notified as soon as possible, after firing\n * a current event or completing another callback. This happens if the stream\n * is not paused, and a listener pauses it, or if the stream has been resumed\n * from pause and has no pending events. If the listeners resume a paused stream\n * while it still has queued events, the controller will still consider the\n * stream paused until all queued events have been dispatched.\n *\n * Whether to invoke a callback depends only on the state before and after\n * a stream action, for example firing an event. If the state changes multiple\n * times during the action, and then ends up in the same state as before, no\n * callback is performed.\n *\n * If listeners are added after the stream has completed (sent a \"done\" event),\n * the listeners will be sent a \"done\" event eventually, but they won't affect\n * the stream at all, and won't trigger callbacks. From the controller's point\n * of view, the stream is completely inert when has completed.\n */\nabstract class StreamController<T> implements StreamSink<T> {\n  /** The stream that this controller is controlling. */\n  Stream<T> get stream;\n\n  /**\n   * A controller with a [stream] that supports only one single subscriber.\n   *\n   * If [sync] is true, events may be passed directly to the stream's listener\n   * during an [add], [addError] or [close] call. If [sync] is false, the event\n   * will be passed to the listener at a later time, after the code creating\n   * the event has returned.\n   *\n   * The controller will buffer all incoming events until the subscriber is\n   * registered.\n   *\n   * The [onPause] function is called when the stream becomes\n   * paused. [onResume] is called when the stream resumed.\n   *\n   * The [onListen] callback is called when the stream\n   * receives its listener and [onCancel] when the listener ends\n   * its subscription. If [onCancel] needs to perform an asynchronous operation,\n   * [onCancel] should return a future that completes when the cancel operation\n   * is done.\n   *\n   * If the stream is canceled before the controller needs new data the\n   * [onResume] call might not be executed.\n   */\n  factory StreamController({void onListen(),\n                            void onPause(),\n                            void onResume(),\n                            onCancel(),\n                            bool sync: false}) {\n    if (onListen == null && onPause == null &&\n        onResume == null && onCancel == null) {\n      return sync\n          ? new _NoCallbackSyncStreamController/*<T>*/()\n          : new _NoCallbackAsyncStreamController/*<T>*/();\n    }\n    return sync\n         ? new _SyncStreamController<T>(onListen, onPause, onResume, onCancel)\n         : new _AsyncStreamController<T>(onListen, onPause, onResume, onCancel);\n  }\n\n  /**\n   * A controller where [stream] can be listened to more than once.\n   *\n   * The [Stream] returned by [stream] is a broadcast stream.\n   * It can be listened to more than once.\n   *\n   * The controller distributes any events to all currently subscribed\n   * listeners at the time when [add], [addError] or [close] is called.\n   * It is not allowed to call `add`, `addError`, or `close` before a previous\n   * call has returned. The controller does not have any internal queue of\n   * events, and if there are no listeners at the time the event is added,\n   * it will just be dropped, or, if it is an error, be reported as uncaught.\n   *\n   * Each listener subscription is handled independently,\n   * and if one pauses, only the pausing listener is affected.\n   * A paused listener will buffer events internally until unpaused or canceled.\n   *\n   * If [sync] is true, events may be fired directly by the stream's\n   * subscriptions during an [add], [addError] or [close] call.\n   * If [sync] is false, the event will be fired at a later time,\n   * after the code adding the event has completed.\n   *\n   * When [sync] is false, no guarantees are given with regard to when\n   * multiple listeners get the events, except that each listener will get\n   * all events in the correct order. Each subscription handles the events\n   * individually.\n   * If two events are sent on an async controller with two listeners,\n   * one of the listeners may get both events\n   * before the other listener gets any.\n   * A listener must be subscribed both when the event is initiated\n   * (that is, when [add] is called)\n   * and when the event is later delivered,\n   * in order to receive the event.\n   *\n   * The [onListen] callback is called when the first listener is subscribed,\n   * and the [onCancel] is called when there are no longer any active listeners.\n   * If a listener is added again later, after the [onCancel] was called,\n   * the [onListen] will be called again.\n   */\n  factory StreamController.broadcast({void onListen(),\n                                      void onCancel(),\n                                      bool sync: false}) {\n    return sync\n        ? new _SyncBroadcastStreamController<T>(onListen, onCancel)\n        : new _AsyncBroadcastStreamController<T>(onListen, onCancel);\n  }\n\n  /**\n   * Returns a view of this object that only exposes the [StreamSink] interface.\n   */\n  StreamSink<T> get sink;\n\n  /**\n   * Whether the stream is closed for adding more events.\n   *\n   * If true, the \"done\" event might not have fired yet, but it has been\n   * scheduled, and it is too late to add more events.\n   */\n  bool get isClosed;\n\n  /**\n   * Whether the subscription would need to buffer events.\n   *\n   * This is the case if the controller's stream has a listener and it is\n   * paused, or if it has not received a listener yet. In that case, the\n   * controller is considered paused as well.\n   *\n   * A broadcast stream controller is never considered paused. It always\n   * forwards its events to all uncanceled listeners, if any, and let them\n   * handle their own pausing.\n   */\n  bool get isPaused;\n\n  /** Whether there is a subscriber on the [Stream]. */\n  bool get hasListener;\n\n  /**\n   * Send or enqueue an error event.\n   *\n   * Also allows an objection stack trace object, on top of what [EventSink]\n   * allows.\n   */\n  void addError(Object error, [StackTrace stackTrace]);\n\n  /**\n   * Receives events from [source] and puts them into this controller's stream.\n   *\n   * Returns a future which completes when the source stream is done.\n   *\n   * Events must not be added directly to this controller using [add],\n   * [addError], [close] or [addStream], until the returned future\n   * is complete.\n   *\n   * Data and error events are forwarded to this controller's stream. A done\n   * event on the source will end the `addStream` operation and complete the\n   * returned future.\n   *\n   * If [cancelOnError] is true, only the first error on [source] is\n   * forwarded to the controller's stream, and the `addStream` ends\n   * after this. If [cancelOnError] is false, all errors are forwarded\n   * and only a done event will end the `addStream`.\n   */\n  Future addStream(Stream<T> source, {bool cancelOnError: true});\n}\n\n\nabstract class _StreamControllerLifecycle<T> {\n  StreamSubscription<T> _subscribe(\n      void onData(T data),\n      Function onError,\n      void onDone(),\n      bool cancelOnError);\n  void _recordPause(StreamSubscription<T> subscription) {}\n  void _recordResume(StreamSubscription<T> subscription) {}\n  Future _recordCancel(StreamSubscription<T> subscription) => null;\n}\n\n/**\n * Default implementation of [StreamController].\n *\n * Controls a stream that only supports a single controller.\n */\nabstract class _StreamController<T> implements StreamController<T>,\n                                               _StreamControllerLifecycle<T>,\n                                               _EventSink<T>,\n                                               _EventDispatch<T> {\n  // The states are bit-flags. More than one can be set at a time.\n  //\n  // The \"subscription state\" goes through the states:\n  //   initial -> subscribed -> canceled.\n  // These are mutually exclusive.\n  // The \"closed\" state records whether the [close] method has been called\n  // on the controller. This can be done at any time. If done before\n  // subscription, the done event is queued. If done after cancel, the done\n  // event is ignored (just as any other event after a cancel).\n\n  /** The controller is in its initial state with no subscription. */\n  static const int _STATE_INITIAL = 0;\n  /** The controller has a subscription, but hasn't been closed or canceled. */\n  static const int _STATE_SUBSCRIBED = 1;\n  /** The subscription is canceled. */\n  static const int _STATE_CANCELED = 2;\n  /** Mask for the subscription state. */\n  static const int _STATE_SUBSCRIPTION_MASK = 3;\n\n  // The following state relate to the controller, not the subscription.\n  // If closed, adding more events is not allowed.\n  // If executing an [addStream], new events are not allowed either, but will\n  // be added by the stream.\n\n  /**\n   * The controller is closed due to calling [close].\n   *\n   * When the stream is closed, you can neither add new events nor add new\n   * listeners.\n   */\n  static const int _STATE_CLOSED = 4;\n  /**\n   * The controller is in the middle of an [addStream] operation.\n   *\n   * While adding events from a stream, no new events can be added directly\n   * on the controller.\n   */\n  static const int _STATE_ADDSTREAM = 8;\n\n  /**\n   * Field containing different data depending on the current subscription\n   * state.\n   *\n   * If [_state] is [_STATE_INITIAL], the field may contain a [_PendingEvents]\n   * for events added to the controller before a subscription.\n   *\n   * While [_state] is [_STATE_SUBSCRIBED], the field contains the subscription.\n   *\n   * When [_state] is [_STATE_CANCELED] the field is currently not used.\n   */\n  var _varData;\n\n  /** Current state of the controller. */\n  int _state = _STATE_INITIAL;\n\n  /**\n   * Future completed when the stream sends its last event.\n   *\n   * This is also the future returned by [close].\n   */\n  // TODO(lrn): Could this be stored in the varData field too, if it's not\n  // accessed until the call to \"close\"? Then we need to special case if it's\n  // accessed earlier, or if close is called before subscribing.\n  _Future _doneFuture;\n\n  _StreamController();\n\n  _NotificationHandler get _onListen;\n  _NotificationHandler get _onPause;\n  _NotificationHandler get _onResume;\n  _NotificationHandler get _onCancel;\n\n  // Return a new stream every time. The streams are equal, but not identical.\n  Stream<T> get stream => new _ControllerStream(this);\n\n  /**\n   * Returns a view of this object that only exposes the [StreamSink] interface.\n   */\n  StreamSink<T> get sink => new _StreamSinkWrapper<T>(this);\n\n  /**\n   * Whether a listener has existed and been canceled.\n   *\n   * After this, adding more events will be ignored.\n   */\n  bool get _isCanceled => (_state & _STATE_CANCELED) != 0;\n\n  /** Whether there is an active listener. */\n  bool get hasListener => (_state & _STATE_SUBSCRIBED) != 0;\n\n  /** Whether there has not been a listener yet. */\n  bool get _isInitialState =>\n      (_state & _STATE_SUBSCRIPTION_MASK) == _STATE_INITIAL;\n\n  bool get isClosed => (_state & _STATE_CLOSED) != 0;\n\n  bool get isPaused => hasListener ? _subscription._isInputPaused\n                                   : !_isCanceled;\n\n  bool get _isAddingStream => (_state & _STATE_ADDSTREAM) != 0;\n\n  /** New events may not be added after close, or during addStream. */\n  bool get _mayAddEvent => (_state < _STATE_CLOSED);\n\n  // Returns the pending events.\n  // Pending events are events added before a subscription exists.\n  // They are added to the subscription when it is created.\n  // Pending events, if any, are kept in the _varData field until the\n  // stream is listened to.\n  // While adding a stream, pending events are moved into the\n  // state object to allow the state object to use the _varData field.\n  _PendingEvents get _pendingEvents {\n    assert(_isInitialState);\n    if (!_isAddingStream) {\n      return _varData;\n    }\n    _StreamControllerAddStreamState state = _varData;\n    return state.varData;\n  }\n\n  // Returns the pending events, and creates the object if necessary.\n  _StreamImplEvents _ensurePendingEvents() {\n    assert(_isInitialState);\n    if (!_isAddingStream) {\n      if (_varData == null) _varData = new _StreamImplEvents();\n      return _varData;\n    }\n    _StreamControllerAddStreamState state = _varData;\n    if (state.varData == null) state.varData = new _StreamImplEvents();\n    return state.varData;\n  }\n\n  // Get the current subscription.\n  // If we are adding a stream, the subscription is moved into the state\n  // object to allow the state object to use the _varData field.\n  _ControllerSubscription get _subscription {\n    assert(hasListener);\n    if (_isAddingStream) {\n      _StreamControllerAddStreamState addState = _varData;\n      return addState.varData;\n    }\n    return _varData;\n  }\n\n  /**\n   * Creates an error describing why an event cannot be added.\n   *\n   * The reason, and therefore the error message, depends on the current state.\n   */\n  Error _badEventState() {\n    if (isClosed) {\n      return new StateError(\"Cannot add event after closing\");\n    }\n    assert(_isAddingStream);\n    return new StateError(\"Cannot add event while adding a stream\");\n  }\n\n  // StreamSink interface.\n  Future addStream(Stream<T> source, {bool cancelOnError: true}) {\n    if (!_mayAddEvent) throw _badEventState();\n    if (_isCanceled) return new _Future.immediate(null);\n    _StreamControllerAddStreamState addState =\n        new _StreamControllerAddStreamState(this,\n                                            _varData,\n                                            source,\n                                            cancelOnError);\n    _varData = addState;\n    _state |= _STATE_ADDSTREAM;\n    return addState.addStreamFuture;\n  }\n\n  /**\n   * Returns a future that is completed when the stream is done\n   * processing events.\n   *\n   * This happens either when the done event has been sent, or if the\n   * subscriber of a single-subscription stream is cancelled.\n   */\n  Future get done => _ensureDoneFuture();\n\n  Future _ensureDoneFuture() {\n    if (_doneFuture == null) {\n      _doneFuture = _isCanceled ? Future._nullFuture : new _Future();\n    }\n    return _doneFuture;\n  }\n\n  /**\n   * Send or enqueue a data event.\n   */\n  void add(T value) {\n    if (!_mayAddEvent) throw _badEventState();\n    _add(value);\n  }\n\n  /**\n   * Send or enqueue an error event.\n   */\n  void addError(Object error, [StackTrace stackTrace]) {\n    if (!_mayAddEvent) throw _badEventState();\n    _addError(error, stackTrace);\n  }\n\n  /**\n   * Closes this controller and sends a done event on the stream.\n   *\n   * The first time a controller is closed, a \"done\" event is added to its\n   * stream.\n   *\n   * You are allowed to close the controller more than once, but only the first\n   * call has any effect.\n   *\n   * After closing, no further events may be added using [add] or [addError].\n   *\n   * The returned future is completed when the done event has been delivered.\n   */\n  Future close() {\n    if (isClosed) {\n      return _ensureDoneFuture();\n    }\n    if (!_mayAddEvent) throw _badEventState();\n    _state |= _STATE_CLOSED;\n    if (hasListener) {\n      _sendDone();\n    } else if (_isInitialState) {\n      _ensurePendingEvents().add(const _DelayedDone());\n    }\n    return _ensureDoneFuture();\n  }\n\n  // EventSink interface. Used by the [addStream] events.\n\n  // Add data event, used both by the [addStream] events and by [add].\n  void _add(T value) {\n    if (hasListener) {\n      _sendData(value);\n    } else if (_isInitialState) {\n      _ensurePendingEvents().add(new _DelayedData<T>(value));\n    }\n  }\n\n  void _addError(Object error, StackTrace stackTrace) {\n    if (hasListener) {\n      _sendError(error, stackTrace);\n    } else if (_isInitialState) {\n      _ensurePendingEvents().add(new _DelayedError(error, stackTrace));\n    }\n  }\n\n  void _close() {\n    // End of addStream stream.\n    assert(_isAddingStream);\n    _StreamControllerAddStreamState addState = _varData;\n    _varData = addState.varData;\n    _state &= ~_STATE_ADDSTREAM;\n    addState.complete();\n  }\n\n  // _StreamControllerLifeCycle interface\n\n  StreamSubscription<T> _subscribe(\n      void onData(T data),\n      Function onError,\n      void onDone(),\n      bool cancelOnError) {\n    if (!_isInitialState) {\n      throw new StateError(\"Stream has already been listened to.\");\n    }\n    _ControllerSubscription subscription =\n        new _ControllerSubscription(this, onData, onError, onDone,\n                                    cancelOnError);\n\n    _PendingEvents pendingEvents = _pendingEvents;\n    _state |= _STATE_SUBSCRIBED;\n    if (_isAddingStream) {\n      _StreamControllerAddStreamState addState = _varData;\n      addState.varData = subscription;\n      addState.resume();\n    } else {\n      _varData = subscription;\n    }\n    subscription._setPendingEvents(pendingEvents);\n    subscription._guardCallback(() {\n      _runGuarded(_onListen);\n    });\n\n    return subscription;\n  }\n\n  Future _recordCancel(StreamSubscription<T> subscription) {\n    // When we cancel, we first cancel any stream being added,\n    // Then we call _onCancel, and finally the _doneFuture is completed.\n    // If either of addStream's cancel or _onCancel returns a future,\n    // we wait for it before continuing.\n    // Any error during this process ends up in the returned future.\n    // If more errors happen, we act as if it happens inside nested try/finallys\n    // or whenComplete calls, and only the last error ends up in the\n    // returned future.\n    Future result;\n    if (_isAddingStream) {\n      _StreamControllerAddStreamState addState = _varData;\n      result = addState.cancel();\n    }\n    _varData = null;\n    _state =\n        (_state & ~(_STATE_SUBSCRIBED | _STATE_ADDSTREAM)) | _STATE_CANCELED;\n\n    if (_onCancel != null) {\n      if (result == null) {\n        // Only introduce a future if one is needed.\n        // If _onCancel returns null, no future is needed.\n        try {\n          result = _onCancel();\n        } catch (e, s) {\n          // Return the error in the returned future.\n          // Complete it asynchronously, so there is time for a listener\n          // to handle the error.\n          result = new _Future().._asyncCompleteError(e, s);\n        }\n      } else {\n        // Simpler case when we already know that we will return a future.\n        result = result.whenComplete(_onCancel);\n      }\n    }\n\n    void complete() {\n      if (_doneFuture != null && _doneFuture._mayComplete) {\n        _doneFuture._asyncComplete(null);\n      }\n    }\n\n    if (result != null) {\n      result = result.whenComplete(complete);\n    } else {\n      complete();\n    }\n\n    return result;\n  }\n\n  void _recordPause(StreamSubscription<T> subscription) {\n    if (_isAddingStream) {\n      _StreamControllerAddStreamState addState = _varData;\n      addState.pause();\n    }\n    _runGuarded(_onPause);\n  }\n\n  void _recordResume(StreamSubscription<T> subscription) {\n    if (_isAddingStream) {\n      _StreamControllerAddStreamState addState = _varData;\n      addState.resume();\n    }\n    _runGuarded(_onResume);\n  }\n}\n\nabstract class _SyncStreamControllerDispatch<T>\n    implements _StreamController<T> {\n  void _sendData(T data) {\n    _subscription._add(data);\n  }\n\n  void _sendError(Object error, StackTrace stackTrace) {\n    _subscription._addError(error, stackTrace);\n  }\n\n  void _sendDone() {\n    _subscription._close();\n  }\n}\n\nabstract class _AsyncStreamControllerDispatch<T>\n    implements _StreamController<T> {\n  void _sendData(T data) {\n    _subscription._addPending(new _DelayedData(data));\n  }\n\n  void _sendError(Object error, StackTrace stackTrace) {\n    _subscription._addPending(new _DelayedError(error, stackTrace));\n  }\n\n  void _sendDone() {\n    _subscription._addPending(const _DelayedDone());\n  }\n}\n\n// TODO(lrn): Use common superclass for callback-controllers when VM supports\n// constructors in mixin superclasses.\n\nclass _AsyncStreamController<T> extends _StreamController<T>\n                                   with _AsyncStreamControllerDispatch<T> {\n  final _NotificationHandler _onListen;\n  final _NotificationHandler _onPause;\n  final _NotificationHandler _onResume;\n  final _NotificationHandler _onCancel;\n\n  _AsyncStreamController(void this._onListen(),\n                         void this._onPause(),\n                         void this._onResume(),\n                         this._onCancel());\n}\n\nclass _SyncStreamController<T> extends _StreamController<T>\n                                  with _SyncStreamControllerDispatch<T> {\n  final _NotificationHandler _onListen;\n  final _NotificationHandler _onPause;\n  final _NotificationHandler _onResume;\n  final _NotificationHandler _onCancel;\n\n  _SyncStreamController(void this._onListen(),\n                        void this._onPause(),\n                        void this._onResume(),\n                        this._onCancel());\n}\n\nabstract class _NoCallbacks {\n  _NotificationHandler get _onListen => null;\n  _NotificationHandler get _onPause => null;\n  _NotificationHandler get _onResume => null;\n  _NotificationHandler get _onCancel => null;\n}\n\nclass _NoCallbackAsyncStreamController/*<T>*/ = _StreamController/*<T>*/\n       with _AsyncStreamControllerDispatch/*<T>*/, _NoCallbacks;\n\nclass _NoCallbackSyncStreamController/*<T>*/ = _StreamController/*<T>*/\n       with _SyncStreamControllerDispatch/*<T>*/, _NoCallbacks;\n\ntypedef _NotificationHandler();\n\nFuture _runGuarded(_NotificationHandler notificationHandler) {\n  if (notificationHandler == null) return null;\n  try {\n    var result = notificationHandler();\n    if (result is Future) return result;\n    return null;\n  } catch (e, s) {\n    Zone.current.handleUncaughtError(e, s);\n  }\n}\n\nclass _ControllerStream<T> extends _StreamImpl<T> {\n  _StreamControllerLifecycle<T> _controller;\n\n  _ControllerStream(this._controller);\n\n  StreamSubscription<T> _createSubscription(\n      void onData(T data),\n      Function onError,\n      void onDone(),\n      bool cancelOnError) =>\n    _controller._subscribe(onData, onError, onDone, cancelOnError);\n\n  // Override == and hashCode so that new streams returned by the same\n  // controller are considered equal. The controller returns a new stream\n  // each time it's queried, but doesn't have to cache the result.\n\n  int get hashCode => _controller.hashCode ^ 0x35323532;\n\n  bool operator==(Object other) {\n    if (identical(this, other)) return true;\n    if (other is! _ControllerStream) return false;\n    _ControllerStream otherStream = other;\n    return identical(otherStream._controller, this._controller);\n  }\n}\n\nclass _ControllerSubscription<T> extends _BufferingStreamSubscription<T> {\n  final _StreamControllerLifecycle<T> _controller;\n\n  _ControllerSubscription(this._controller, void onData(T data),\n                          Function onError, void onDone(), bool cancelOnError)\n      : super(onData, onError, onDone, cancelOnError);\n\n  Future _onCancel() {\n    return _controller._recordCancel(this);\n  }\n\n  void _onPause() {\n    _controller._recordPause(this);\n  }\n\n  void _onResume() {\n    _controller._recordResume(this);\n  }\n}\n\n\n/** A class that exposes only the [StreamSink] interface of an object. */\nclass _StreamSinkWrapper<T> implements StreamSink<T> {\n  final StreamController _target;\n  _StreamSinkWrapper(this._target);\n  void add(T data) { _target.add(data); }\n  void addError(Object error, [StackTrace stackTrace]) {\n    _target.addError(error, stackTrace);\n  }\n  Future close() => _target.close();\n  Future addStream(Stream<T> source, {bool cancelOnError: true}) =>\n      _target.addStream(source, cancelOnError: cancelOnError);\n  Future get done => _target.done;\n}\n\n/**\n * Object containing the state used to handle [StreamController.addStream].\n */\nclass _AddStreamState<T> {\n  // [_Future] returned by call to addStream.\n  final _Future addStreamFuture;\n\n  // Subscription on stream argument to addStream.\n  final StreamSubscription addSubscription;\n\n  _AddStreamState(_EventSink<T> controller, Stream source, bool cancelOnError)\n      : addStreamFuture = new _Future(),\n        addSubscription = source.listen(controller._add,\n                                        onError: cancelOnError\n                                             ? makeErrorHandler(controller)\n                                             : controller._addError,\n                                        onDone: controller._close,\n                                        cancelOnError: cancelOnError);\n\n  static makeErrorHandler(_EventSink controller) =>\n      (e, StackTrace s) {\n        controller._addError(e, s);\n        controller._close();\n      };\n\n  void pause() {\n    addSubscription.pause();\n  }\n\n  void resume() {\n    addSubscription.resume();\n  }\n\n  /**\n   * Stop adding the stream.\n   *\n   * Complete the future returned by `StreamController.addStream` when\n   * the cancel is complete.\n   *\n   * Return a future if the cancel takes time, otherwise return `null`.\n   */\n  Future cancel() {\n    var cancel = addSubscription.cancel();\n    if (cancel == null) {\n      addStreamFuture._asyncComplete(null);\n      return null;\n    }\n    return cancel.whenComplete(() { addStreamFuture._asyncComplete(null); });\n  }\n\n  void complete() {\n    addStreamFuture._asyncComplete(null);\n  }\n}\n\nclass _StreamControllerAddStreamState<T> extends _AddStreamState<T> {\n  // The subscription or pending data of a _StreamController.\n  // Stored here because we reuse the `_varData` field  in the _StreamController\n  // to store this state object.\n  var varData;\n\n  _StreamControllerAddStreamState(_StreamController controller,\n                                  this.varData,\n                                  Stream source,\n                                  bool cancelOnError)\n      : super(controller, source, cancelOnError) {\n    if (controller.isPaused) {\n      addSubscription.pause();\n    }\n  }\n}\n\u0000","sdk:/sdk/lib/async/stream.dart":"// Copyright (c) 2013, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\npart of dart.async;\n\n// -------------------------------------------------------------------\n// Core Stream types\n// -------------------------------------------------------------------\n\n/**\n * A source of asynchronous data events.\n *\n * A Stream provides a way to receive a sequence of events.\n * Each event is either a data event or an error event,\n * representing the result of a single computation.\n * When the events provided by a Stream have all been sent,\n * a single \"done\" event will mark the end.\n *\n * You can [listen] on a stream to make it start generating events,\n * and to set up listeners that receive the events.\n * When you listen, you receive a [StreamSubscription] object\n * which is the active object providing the events,\n * and which can be used to stop listening again,\n * or to temporarily pause events from the subscription.\n *\n * There are two kinds of streams: \"Single-subscription\" streams and\n * \"broadcast\" streams.\n *\n * *A single-subscription stream* allows only a single listener during the whole\n * lifetime of the stream.\n * It doesn't start generating events until it has a listener,\n * and it stops sending events when the listener is unsubscribed,\n * even if the source of events could still provide more.\n *\n * Listening twice on a single-subscription stream is not allowed, even after\n * the first subscription has been canceled.\n *\n * Single-subscription streams are generally used for streaming chunks of\n * larger contiguous data like file I/O.\n *\n * *A broadcast stream* allows any number of listeners, and it fires\n * its events when they are ready, whether there are listeners or not.\n *\n * Broadcast streams are used for independent events/observers.\n *\n * If several listeners want to listen to a single subscription stream,\n * use [asBroadcastStream] to create a broadcast stream on top of the\n * non-broadcast stream.\n *\n * On either kind of stream, stream transformationss, such as [where] and\n * [skip], return the same type of stream as the one the method was called on,\n * unless otherwise noted.\n *\n * When an event is fired, the listener(s) at that time will receive the event.\n * If a listener is added to a broadcast stream while an event is being fired,\n * that listener will not receive the event currently being fired.\n * If a listener is canceled, it immediately stops receiving events.\n *\n * When the \"done\" event is fired, subscribers are unsubscribed before\n * receiving the event. After the event has been sent, the stream has no\n * subscribers. Adding new subscribers to a broadcast stream after this point\n * is allowed, but they will just receive a new \"done\" event as soon\n * as possible.\n *\n * Stream subscriptions always respect \"pause\" requests. If necessary they need\n * to buffer their input, but often, and preferably, they can simply request\n * their input to pause too.\n *\n * The default implementation of [isBroadcast] returns false.\n * A broadcast stream inheriting from [Stream] must override [isBroadcast]\n * to return `true`.\n */\nabstract class Stream<T> {\n  Stream();\n\n  /**\n   * Creates a new single-subscription stream from the future.\n   *\n   * When the future completes, the stream will fire one event, either\n   * data or error, and then close with a done-event.\n   */\n  factory Stream.fromFuture(Future<T> future) {\n    // Use the controller's buffering to fill in the value even before\n    // the stream has a listener. For a single value, it's not worth it\n    // to wait for a listener before doing the `then` on the future.\n    StreamController<T> controller = new StreamController<T>(sync: true);\n    future.then((value) {\n        controller.add(value);\n        controller.close();\n      },\n      onError: (error, stackTrace) {\n        controller.addError(error, stackTrace);\n        controller.close();\n      });\n    return controller.stream;\n  }\n\n  /**\n   * Creates a single-subscription stream that gets its data from [data].\n   *\n   * The iterable is iterated when the stream receives a listener, and stops\n   * iterating if the listener cancels the subscription.\n   *\n   * If iterating [data] throws an error, the stream ends immediately with\n   * that error. No done event will be sent (iteration is not complete), but no\n   * further data events will be generated either, since iteration cannot\n   * continue.\n   */\n  factory Stream.fromIterable(Iterable<T> data) {\n    return new _GeneratedStreamImpl<T>(\n        () => new _IterablePendingEvents<T>(data));\n  }\n\n  /**\n   * Creates a stream that repeatedly emits events at [period] intervals.\n   *\n   * The event values are computed by invoking [computation]. The argument to\n   * this callback is an integer that starts with 0 and is incremented for\n   * every event.\n   *\n   * If [computation] is omitted the event values will all be `null`.\n   */\n  factory Stream.periodic(Duration period,\n                          [T computation(int computationCount)]) {\n    if (computation == null) computation = ((i) => null);\n\n    Timer timer;\n    int computationCount = 0;\n    StreamController<T> controller;\n    // Counts the time that the Stream was running (and not paused).\n    Stopwatch watch = new Stopwatch();\n\n    void sendEvent() {\n      watch.reset();\n      T data = computation(computationCount++);\n      controller.add(data);\n    }\n\n    void startPeriodicTimer() {\n      assert(timer == null);\n      timer = new Timer.periodic(period, (Timer timer) {\n        sendEvent();\n      });\n    }\n\n    controller = new StreamController<T>(sync: true,\n        onListen: () {\n          watch.start();\n          startPeriodicTimer();\n        },\n        onPause: () {\n          timer.cancel();\n          timer = null;\n          watch.stop();\n        },\n        onResume: () {\n          assert(timer == null);\n          Duration elapsed = watch.elapsed;\n          watch.start();\n          timer = new Timer(period - elapsed, () {\n            timer = null;\n            startPeriodicTimer();\n            sendEvent();\n          });\n        },\n        onCancel: () {\n          if (timer != null) timer.cancel();\n          timer = null;\n        });\n    return controller.stream;\n  }\n\n  /**\n   * Creates a stream where all events of an existing stream are piped through\n   * a sink-transformation.\n   *\n   * The given [mapSink] closure is invoked when the returned stream is\n   * listened to. All events from the [source] are added into the event sink\n   * that is returned from the invocation. The transformation puts all\n   * transformed events into the sink the [mapSink] closure received during\n   * its invocation. Conceptually the [mapSink] creates a transformation pipe\n   * with the input sink being the returned [EventSink] and the output sink\n   * being the sink it received.\n   *\n   * This constructor is frequently used to build transformers.\n   *\n   * Example use for a duplicating transformer:\n   *\n   *     class DuplicationSink implements EventSink<String> {\n   *       final EventSink<String> _outputSink;\n   *       DuplicationSink(this._outputSink);\n   *\n   *       void add(String data) {\n   *         _outputSink.add(data);\n   *         _outputSink.add(data);\n   *       }\n   *\n   *       void addError(e, [st]) => _outputSink(e, st);\n   *       void close() => _outputSink.close();\n   *     }\n   *\n   *     class DuplicationTransformer implements StreamTransformer<String, String> {\n   *       // Some generic types ommitted for brevety.\n   *       Stream bind(Stream stream) => new Stream<String>.eventTransform(\n   *           stream,\n   *           (EventSink sink) => new DuplicationSink(sink));\n   *     }\n   *\n   *     stringStream.transform(new DuplicationTransformer());\n   *\n   * The resulting stream is a broadcast stream if [source] is.\n   */\n  factory Stream.eventTransformed(Stream source,\n                                  EventSink mapSink(EventSink<T> sink)) {\n    return new _BoundSinkStream(source, mapSink);\n  }\n\n  /**\n   * Reports whether this stream is a broadcast stream.\n   */\n  bool get isBroadcast => false;\n\n  /**\n   * Returns a multi-subscription stream that produces the same events as this.\n   *\n   * The returned stream will subscribe to this stream when its first\n   * subscriber is added, and will stay subscribed until this stream ends,\n   * or a callback cancels the subscription.\n   *\n   * If [onListen] is provided, it is called with a subscription-like object\n   * that represents the underlying subscription to this stream. It is\n   * possible to pause, resume or cancel the subscription during the call\n   * to [onListen]. It is not possible to change the event handlers, including\n   * using [StreamSubscription.asFuture].\n   *\n   * If [onCancel] is provided, it is called in a similar way to [onListen]\n   * when the returned stream stops having listener. If it later gets\n   * a new listener, the [onListen] function is called again.\n   *\n   * Use the callbacks, for example, for pausing the underlying subscription\n   * while having no subscribers to prevent losing events, or canceling the\n   * subscription when there are no listeners.\n   */\n  Stream<T> asBroadcastStream({\n      void onListen(StreamSubscription<T> subscription),\n      void onCancel(StreamSubscription<T> subscription) }) {\n    return new _AsBroadcastStream<T>(this, onListen, onCancel);\n  }\n\n  /**\n   * Adds a subscription to this stream.\n   *\n   * On each data event from this stream, the subscriber's [onData] handler\n   * is called. If [onData] is null, nothing happens.\n   *\n   * On errors from this stream, the [onError] handler is given a\n   * object describing the error.\n   *\n   * The [onError] callback must be of type `void onError(error)` or\n   * `void onError(error, StackTrace stackTrace)`. If [onError] accepts\n   * two arguments it is called with the stack trace (which could be `null` if\n   * the stream itself received an error without stack trace).\n   * Otherwise it is called with just the error object.\n   *\n   * If this stream closes, the [onDone] handler is called.\n   *\n   * If [cancelOnError] is true, the subscription is ended when\n   * the first error is reported. The default is false.\n   */\n  StreamSubscription<T> listen(void onData(T event),\n                               { Function onError,\n                                 void onDone(),\n                                 bool cancelOnError});\n\n  /**\n   * Creates a new stream from this stream that discards some data events.\n   *\n   * The new stream sends the same error and done events as this stream,\n   * but it only sends the data events that satisfy the [test].\n   *\n   * The returned stream is a broadcast stream if this stream is.\n   * If a broadcast stream is listened to more than once, each subscription\n   * will individually perform the `test`.\n   */\n  Stream<T> where(bool test(T event)) {\n    return new _WhereStream<T>(this, test);\n  }\n\n  /**\n   * Creates a new stream that converts each element of this stream\n   * to a new value using the [convert] function.\n   *\n   * The returned stream is a broadcast stream if this stream is.\n   * If a broadcast stream is listened to more than once, each subscription\n   * will individually execute `map` for each event.\n   */\n  Stream map(convert(T event)) {\n    return new _MapStream<T, dynamic>(this, convert);\n  }\n\n  /**\n   * Creates a new stream with each data event of this stream asynchronously\n   * mapped to a new event.\n   *\n   * This acts like [map], except that [convert] may return a [Future],\n   * and in that case, the stream waits for that future to complete before\n   * continuing with its result.\n   *\n   * The returned stream is a broadcast stream if this stream is.\n   */\n  Stream asyncMap(convert(T event)) {\n    StreamController controller;\n    StreamSubscription subscription;\n    void onListen () {\n      var add = controller.add;\n      var addError = controller.addError;\n      subscription = this.listen(\n          (T event) {\n            var newValue;\n            try {\n              newValue = convert(event);\n            } catch (e, s) {\n              controller.addError(e, s);\n              return;\n            }\n            if (newValue is Future) {\n              subscription.pause();\n              newValue.then(add, onError: addError)\n                      .whenComplete(subscription.resume);\n            } else {\n              controller.add(newValue);\n            }\n          },\n          onError: addError,\n          onDone: controller.close\n      );\n    }\n    if (this.isBroadcast) {\n      controller = new StreamController.broadcast(\n        onListen: onListen,\n        onCancel: () { subscription.cancel(); },\n        sync: true\n      );\n    } else {\n      controller = new StreamController(\n        onListen: onListen,\n        onPause: () { subscription.pause(); },\n        onResume: () { subscription.resume(); },\n        onCancel: () { subscription.cancel(); },\n        sync: true\n      );\n    }\n    return controller.stream;\n  }\n\n  /**\n   * Creates a new stream with the events of a stream per original event.\n   *\n   * This acts like [expand], except that [convert] returns a [Stream]\n   * instead of an [Iterable].\n   * The events of the returned stream becomes the events of the returned\n   * stream, in the order they are produced.\n   *\n   * If [convert] returns `null`, no value is put on the output stream,\n   * just as if it returned an empty stream.\n   *\n   * The returned stream is a broadcast stream if this stream is.\n   */\n  Stream asyncExpand(Stream convert(T event)) {\n    StreamController controller;\n    StreamSubscription subscription;\n    void onListen() {\n      subscription = this.listen(\n          (T event) {\n            Stream newStream;\n            try {\n              newStream = convert(event);\n            } catch (e, s) {\n              controller.addError(e, s);\n              return;\n            }\n            if (newStream != null) {\n              subscription.pause();\n              controller.addStream(newStream)\n                        .whenComplete(subscription.resume);\n            }\n          },\n          onError: controller.addError,\n          onDone: controller.close\n      );\n    }\n    if (this.isBroadcast) {\n      controller = new StreamController.broadcast(\n        onListen: onListen,\n        onCancel: () { subscription.cancel(); },\n        sync: true\n      );\n    } else {\n      controller = new StreamController(\n        onListen: onListen,\n        onPause: () { subscription.pause(); },\n        onResume: () { subscription.resume(); },\n        onCancel: () { subscription.cancel(); },\n        sync: true\n      );\n    }\n    return controller.stream;\n  }\n\n  /**\n   * Creates a wrapper Stream that intercepts some errors from this stream.\n   *\n   * If this stream sends an error that matches [test], then it is intercepted\n   * by the [handle] function.\n   *\n   * The [onError] callback must be of type `void onError(error)` or\n   * `void onError(error, StackTrace stackTrace)`. Depending on the function\n   * type the the stream either invokes [onError] with or without a stack\n   * trace. The stack trace argument might be `null` if the stream itself\n   * received an error without stack trace.\n   *\n   * An asynchronous error [:e:] is matched by a test function if [:test(e):]\n   * returns true. If [test] is omitted, every error is considered matching.\n   *\n   * If the error is intercepted, the [handle] function can decide what to do\n   * with it. It can throw if it wants to raise a new (or the same) error,\n   * or simply return to make the stream forget the error.\n   *\n   * If you need to transform an error into a data event, use the more generic\n   * [Stream.transform] to handle the event by writing a data event to\n   * the output sink.\n   *\n   * The returned stream is a broadcast stream if this stream is.\n   * If a broadcast stream is listened to more than once, each subscription\n   * will individually perform the `test` and handle the error.\n   */\n  Stream<T> handleError(Function onError, { bool test(error) }) {\n    return new _HandleErrorStream<T>(this, onError, test);\n  }\n\n  /**\n   * Creates a new stream from this stream that converts each element\n   * into zero or more events.\n   *\n   * Each incoming event is converted to an [Iterable] of new events,\n   * and each of these new events are then sent by the returned stream\n   * in order.\n   *\n   * The returned stream is a broadcast stream if this stream is.\n   * If a broadcast stream is listened to more than once, each subscription\n   * will individually call `convert` and expand the events.\n   */\n  Stream expand(Iterable convert(T value)) {\n    return new _ExpandStream<T, dynamic>(this, convert);\n  }\n\n  /**\n   * Binds this stream as the input of the provided [StreamConsumer].\n   *\n   * The `streamConsumer` is closed when the stream has been added to it.\n   *\n   * Returns a future which completes when the stream has been consumed\n   * and the consumer has been closed.\n   */\n  Future pipe(StreamConsumer<T> streamConsumer) {\n    return streamConsumer.addStream(this).then((_) => streamConsumer.close());\n  }\n\n  /**\n   * Chains this stream as the input of the provided [StreamTransformer].\n   *\n   * Returns the result of [:streamTransformer.bind:] itself.\n   *\n   * The `streamTransformer` can decide whether it wants to return a\n   * broadcast stream or not.\n   */\n  Stream transform(StreamTransformer<T, dynamic> streamTransformer) {\n    return streamTransformer.bind(this);\n  }\n\n  /**\n   * Reduces a sequence of values by repeatedly applying [combine].\n   */\n  Future<T> reduce(T combine(T previous, T element)) {\n    _Future<T> result = new _Future<T>();\n    bool seenFirst = false;\n    T value;\n    StreamSubscription subscription;\n    subscription = this.listen(\n      (T element) {\n        if (seenFirst) {\n          _runUserCode(() => combine(value, element),\n                       (T newValue) { value = newValue; },\n                       _cancelAndErrorClosure(subscription, result));\n        } else {\n          value = element;\n          seenFirst = true;\n        }\n      },\n      onError: result._completeError,\n      onDone: () {\n        if (!seenFirst) {\n          try {\n            throw IterableElementError.noElement();\n          } catch (e, s) {\n            result._completeError(e, s);\n          }\n        } else {\n          result._complete(value);\n        }\n      },\n      cancelOnError: true\n    );\n    return result;\n  }\n\n  /** Reduces a sequence of values by repeatedly applying [combine]. */\n  Future fold(var initialValue, combine(var previous, T element)) {\n    _Future result = new _Future();\n    var value = initialValue;\n    StreamSubscription subscription;\n    subscription = this.listen(\n      (T element) {\n        _runUserCode(\n          () => combine(value, element),\n          (newValue) { value = newValue; },\n          _cancelAndErrorClosure(subscription, result)\n        );\n      },\n      onError: (e, st) {\n        result._completeError(e, st);\n      },\n      onDone: () {\n        result._complete(value);\n      },\n      cancelOnError: true);\n    return result;\n  }\n\n  /**\n   * Collects string of data events' string representations.\n   *\n   * If [separator] is provided, it is inserted between any two\n   * elements.\n   *\n   * Any error in the stream causes the future to complete with that\n   * error. Otherwise it completes with the collected string when\n   * the \"done\" event arrives.\n   */\n  Future<String> join([String separator = \"\"]) {\n    _Future<String> result = new _Future<String>();\n    StringBuffer buffer = new StringBuffer();\n    StreamSubscription subscription;\n    bool first = true;\n    subscription = this.listen(\n      (T element) {\n        if (!first) {\n          buffer.write(separator);\n        }\n        first = false;\n        try {\n          buffer.write(element);\n        } catch (e, s) {\n          _cancelAndError(subscription, result, e, s);\n        }\n      },\n      onError: (e) {\n        result._completeError(e);\n      },\n      onDone: () {\n        result._complete(buffer.toString());\n      },\n      cancelOnError: true);\n    return result;\n  }\n\n  /**\n   * Checks whether [needle] occurs in the elements provided by this stream.\n   *\n   * Completes the [Future] when the answer is known.\n   * If this stream reports an error, the [Future] will report that error.\n   */\n  Future<bool> contains(Object needle) {\n    _Future<bool> future = new _Future<bool>();\n    StreamSubscription subscription;\n    subscription = this.listen(\n        (T element) {\n          _runUserCode(\n            () => (element == needle),\n            (bool isMatch) {\n              if (isMatch) {\n                _cancelAndValue(subscription, future, true);\n              }\n            },\n            _cancelAndErrorClosure(subscription, future)\n          );\n        },\n        onError: future._completeError,\n        onDone: () {\n          future._complete(false);\n        },\n        cancelOnError: true);\n    return future;\n  }\n\n  /**\n   * Executes [action] on each data event of the stream.\n   *\n   * Completes the returned [Future] when all events of the stream\n   * have been processed. Completes the future with an error if the\n   * stream has an error event, or if [action] throws.\n   */\n  Future forEach(void action(T element)) {\n    _Future future = new _Future();\n    StreamSubscription subscription;\n    subscription = this.listen(\n        (T element) {\n          _runUserCode(\n            () => action(element),\n            (_) {},\n            _cancelAndErrorClosure(subscription, future)\n          );\n        },\n        onError: future._completeError,\n        onDone: () {\n          future._complete(null);\n        },\n        cancelOnError: true);\n    return future;\n  }\n\n  /**\n   * Checks whether [test] accepts all elements provided by this stream.\n   *\n   * Completes the [Future] when the answer is known.\n   * If this stream reports an error, the [Future] will report that error.\n   */\n  Future<bool> every(bool test(T element)) {\n    _Future<bool> future = new _Future<bool>();\n    StreamSubscription subscription;\n    subscription = this.listen(\n        (T element) {\n          _runUserCode(\n            () => test(element),\n            (bool isMatch) {\n              if (!isMatch) {\n                _cancelAndValue(subscription, future, false);\n              }\n            },\n            _cancelAndErrorClosure(subscription, future)\n          );\n        },\n        onError: future._completeError,\n        onDone: () {\n          future._complete(true);\n        },\n        cancelOnError: true);\n    return future;\n  }\n\n  /**\n   * Checks whether [test] accepts any element provided by this stream.\n   *\n   * Completes the [Future] when the answer is known.\n   *\n   * If this stream reports an error, the [Future] reports that error.\n   *\n   * Stops listening to the stream after the first matching element has been\n   * found.\n   *\n   * Internally the method cancels its subscription after this element. This\n   * means that single-subscription (non-broadcast) streams are closed and\n   * cannot be reused after a call to this method.\n   */\n  Future<bool> any(bool test(T element)) {\n    _Future<bool> future = new _Future<bool>();\n    StreamSubscription subscription;\n    subscription = this.listen(\n        (T element) {\n          _runUserCode(\n            () => test(element),\n            (bool isMatch) {\n              if (isMatch) {\n                _cancelAndValue(subscription, future, true);\n              }\n            },\n            _cancelAndErrorClosure(subscription, future)\n          );\n        },\n        onError: future._completeError,\n        onDone: () {\n          future._complete(false);\n        },\n        cancelOnError: true);\n    return future;\n  }\n\n\n  /** Counts the elements in the stream. */\n  Future<int> get length {\n    _Future<int> future = new _Future<int>();\n    int count = 0;\n    this.listen(\n      (_) { count++; },\n      onError: future._completeError,\n      onDone: () {\n        future._complete(count);\n      },\n      cancelOnError: true);\n    return future;\n  }\n\n  /**\n   * Reports whether this stream contains any elements.\n   *\n   * Stops listening to the stream after the first element has been received.\n   *\n   * Internally the method cancels its subscription after the first element.\n   * This means that single-subscription (non-broadcast) streams are closed and\n   * cannot be reused after a call to this getter.\n   */\n  Future<bool> get isEmpty {\n    _Future<bool> future = new _Future<bool>();\n    StreamSubscription subscription;\n    subscription = this.listen(\n      (_) {\n        _cancelAndValue(subscription, future, false);\n      },\n      onError: future._completeError,\n      onDone: () {\n        future._complete(true);\n      },\n      cancelOnError: true);\n    return future;\n  }\n\n  /** Collects the data of this stream in a [List]. */\n  Future<List<T>> toList() {\n    List<T> result = <T>[];\n    _Future<List<T>> future = new _Future<List<T>>();\n    this.listen(\n      (T data) {\n        result.add(data);\n      },\n      onError: future._completeError,\n      onDone: () {\n        future._complete(result);\n      },\n      cancelOnError: true);\n    return future;\n  }\n\n  /**\n   * Collects the data of this stream in a [Set].\n   *\n   * The returned set is the same type as returned by `new Set<T>()`.\n   * If another type of set is needed, either use [forEach] to add each\n   * element to the set, or use\n   * `toList().then((list) => new SomeOtherSet.from(list))`\n   * to create the set.\n   */\n  Future<Set<T>> toSet() {\n    Set<T> result = new Set<T>();\n    _Future<Set<T>> future = new _Future<Set<T>>();\n    this.listen(\n      (T data) {\n        result.add(data);\n      },\n      onError: future._completeError,\n      onDone: () {\n        future._complete(result);\n      },\n      cancelOnError: true);\n    return future;\n  }\n\n  /**\n   * Discards all data on the stream, but signals when it's done or an error\n   * occured.\n   *\n   * When subscribing using [drain], cancelOnError will be true. This means\n   * that the future will complete with the first error on the stream and then\n   * cancel the subscription.\n   *\n   * In case of a `done` event the future completes with the given\n   * [futureValue].\n   */\n  Future drain([var futureValue]) => listen(null, cancelOnError: true)\n      .asFuture(futureValue);\n\n  /**\n   * Provides at most the first [n] values of this stream.\n   *\n   * Forwards the first [n] data events of this stream, and all error\n   * events, to the returned stream, and ends with a done event.\n   *\n   * If this stream produces fewer than [count] values before it's done,\n   * so will the returned stream.\n   *\n   * Stops listening to the stream after the first [n] elements have been\n   * received.\n   *\n   * Internally the method cancels its subscription after these elements. This\n   * means that single-subscription (non-broadcast) streams are closed and\n   * cannot be reused after a call to this method.\n   *\n   * The returned stream is a broadcast stream if this stream is.\n   * For a broadcast stream, the events are only counted from the time\n   * the returned stream is listened to.\n   */\n  Stream<T> take(int count) {\n    return new _TakeStream(this, count);\n  }\n\n  /**\n   * Forwards data events while [test] is successful.\n   *\n   * The returned stream provides the same events as this stream as long\n   * as [test] returns [:true:] for the event data. The stream is done\n   * when either this stream is done, or when this stream first provides\n   * a value that [test] doesn't accept.\n   *\n   * Stops listening to the stream after the accepted elements.\n   *\n   * Internally the method cancels its subscription after these elements. This\n   * means that single-subscription (non-broadcast) streams are closed and\n   * cannot be reused after a call to this method.\n   *\n   * The returned stream is a broadcast stream if this stream is.\n   * For a broadcast stream, the events are only tested from the time\n   * the returned stream is listened to.\n   */\n  Stream<T> takeWhile(bool test(T element)) {\n    return new _TakeWhileStream(this, test);\n  }\n\n  /**\n   * Skips the first [count] data events from this stream.\n   *\n   * The returned stream is a broadcast stream if this stream is.\n   * For a broadcast stream, the events are only counted from the time\n   * the returned stream is listened to.\n   */\n  Stream<T> skip(int count) {\n    return new _SkipStream(this, count);\n  }\n\n  /**\n   * Skip data events from this stream while they are matched by [test].\n   *\n   * Error and done events are provided by the returned stream unmodified.\n   *\n   * Starting with the first data event where [test] returns false for the\n   * event data, the returned stream will have the same events as this stream.\n   *\n   * The returned stream is a broadcast stream if this stream is.\n   * For a broadcast stream, the events are only tested from the time\n   * the returned stream is listened to.\n   */\n  Stream<T> skipWhile(bool test(T element)) {\n    return new _SkipWhileStream(this, test);\n  }\n\n  /**\n   * Skips data events if they are equal to the previous data event.\n   *\n   * The returned stream provides the same events as this stream, except\n   * that it never provides two consequtive data events that are equal.\n   *\n   * Equality is determined by the provided [equals] method. If that is\n   * omitted, the '==' operator on the last provided data element is used.\n   *\n   * The returned stream is a broadcast stream if this stream is.\n   * If a broadcast stream is listened to more than once, each subscription\n   * will individually perform the `equals` test.\n   */\n  Stream<T> distinct([bool equals(T previous, T next)]) {\n    return new _DistinctStream(this, equals);\n  }\n\n  /**\n   * Returns the first element of the stream.\n   *\n   * Stops listening to the stream after the first element has been received.\n   *\n   * Internally the method cancels its subscription after the first element.\n   * This means that single-subscription (non-broadcast) streams are closed\n   * and cannot be reused after a call to this getter.\n   *\n   * If an error event occurs before the first data event, the resulting future\n   * is completed with that error.\n   *\n   * If this stream is empty (a done event occurs before the first data event),\n   * the resulting future completes with a [StateError].\n   *\n   * Except for the type of the error, this method is equivalent to\n   * [:this.elementAt(0):].\n   */\n  Future<T> get first {\n    _Future<T> future = new _Future<T>();\n    StreamSubscription subscription;\n    subscription = this.listen(\n      (T value) {\n        _cancelAndValue(subscription, future, value);\n      },\n      onError: future._completeError,\n      onDone: () {\n        try {\n          throw IterableElementError.noElement();\n        } catch (e, s) {\n          future._completeError(e, s);\n        }\n      },\n      cancelOnError: true);\n    return future;\n  }\n\n  /**\n   * Returns the last element of the stream.\n   *\n   * If an error event occurs before the first data event, the resulting future\n   * is completed with that error.\n   *\n   * If this stream is empty (a done event occurs before the first data event),\n   * the resulting future completes with a [StateError].\n   */\n  Future<T> get last {\n    _Future<T> future = new _Future<T>();\n    T result = null;\n    bool foundResult = false;\n    StreamSubscription subscription;\n    subscription = this.listen(\n      (T value) {\n        foundResult = true;\n        result = value;\n      },\n      onError: future._completeError,\n      onDone: () {\n        if (foundResult) {\n          future._complete(result);\n          return;\n        }\n        try {\n          throw IterableElementError.noElement();\n        } catch (e, s) {\n          future._completeError(e, s);\n        }\n      },\n      cancelOnError: true);\n    return future;\n  }\n\n  /**\n   * Returns the single element.\n   *\n   * If an error event occurs before or after the first data event, the\n   * resulting future is completed with that error.\n   *\n   * If [this] is empty or has more than one element throws a [StateError].\n   */\n  Future<T> get single {\n    _Future<T> future = new _Future<T>();\n    T result = null;\n    bool foundResult = false;\n    StreamSubscription subscription;\n    subscription = this.listen(\n      (T value) {\n        if (foundResult) {\n          // This is the second element we get.\n          try {\n            throw IterableElementError.tooMany();\n          } catch (e, s) {\n            _cancelAndError(subscription, future, e, s);\n          }\n          return;\n        }\n        foundResult = true;\n        result = value;\n      },\n      onError: future._completeError,\n      onDone: () {\n        if (foundResult) {\n          future._complete(result);\n          return;\n        }\n        try {\n          throw IterableElementError.noElement();\n        } catch (e, s) {\n          future._completeError(e, s);\n        }\n      },\n      cancelOnError: true);\n    return future;\n  }\n\n  /**\n   * Finds the first element of this stream matching [test].\n   *\n   * Returns a future that is filled with the first element of this stream\n   * that [test] returns true for.\n   *\n   * If no such element is found before this stream is done, and a\n   * [defaultValue] function is provided, the result of calling [defaultValue]\n   * becomes the value of the future.\n   *\n   * Stops listening to the stream after the first matching element has been\n   * received.\n   *\n   * Internally the method cancels its subscription after the first element that\n   * matches the predicate. This means that single-subscription (non-broadcast)\n   * streams are closed and cannot be reused after a call to this method.\n   *\n   * If an error occurs, or if this stream ends without finding a match and\n   * with no [defaultValue] function provided, the future will receive an\n   * error.\n   */\n  Future<dynamic> firstWhere(bool test(T element), {Object defaultValue()}) {\n    _Future<dynamic> future = new _Future();\n    StreamSubscription subscription;\n    subscription = this.listen(\n      (T value) {\n        _runUserCode(\n          () => test(value),\n          (bool isMatch) {\n            if (isMatch) {\n              _cancelAndValue(subscription, future, value);\n            }\n          },\n          _cancelAndErrorClosure(subscription, future)\n        );\n      },\n      onError: future._completeError,\n      onDone: () {\n        if (defaultValue != null) {\n          _runUserCode(defaultValue, future._complete, future._completeError);\n          return;\n        }\n        try {\n          throw IterableElementError.noElement();\n        } catch (e, s) {\n          future._completeError(e, s);\n        }\n      },\n      cancelOnError: true);\n    return future;\n  }\n\n  /**\n   * Finds the last element in this stream matching [test].\n   *\n   * As [firstWhere], except that the last matching element is found.\n   * That means that the result cannot be provided before this stream\n   * is done.\n   */\n  Future<dynamic> lastWhere(bool test(T element), {Object defaultValue()}) {\n    _Future<dynamic> future = new _Future();\n    T result = null;\n    bool foundResult = false;\n    StreamSubscription subscription;\n    subscription = this.listen(\n      (T value) {\n        _runUserCode(\n          () => true == test(value),\n          (bool isMatch) {\n            if (isMatch) {\n              foundResult = true;\n              result = value;\n            }\n          },\n          _cancelAndErrorClosure(subscription, future)\n        );\n      },\n      onError: future._completeError,\n      onDone: () {\n        if (foundResult) {\n          future._complete(result);\n          return;\n        }\n        if (defaultValue != null) {\n          _runUserCode(defaultValue, future._complete, future._completeError);\n          return;\n        }\n        try {\n          throw IterableElementError.noElement();\n        } catch (e, s) {\n          future._completeError(e, s);\n        }\n      },\n      cancelOnError: true);\n    return future;\n  }\n\n  /**\n   * Finds the single element in this stream matching [test].\n   *\n   * Like [lastMatch], except that it is an error if more than one\n   * matching element occurs in the stream.\n   */\n  Future<T> singleWhere(bool test(T element)) {\n    _Future<T> future = new _Future<T>();\n    T result = null;\n    bool foundResult = false;\n    StreamSubscription subscription;\n    subscription = this.listen(\n      (T value) {\n        _runUserCode(\n          () => true == test(value),\n          (bool isMatch) {\n            if (isMatch) {\n              if (foundResult) {\n                try {\n                  throw IterableElementError.tooMany();\n                } catch (e, s) {\n                  _cancelAndError(subscription, future, e, s);\n                }\n                return;\n              }\n              foundResult = true;\n              result = value;\n            }\n          },\n          _cancelAndErrorClosure(subscription, future)\n        );\n      },\n      onError: future._completeError,\n      onDone: () {\n        if (foundResult) {\n          future._complete(result);\n          return;\n        }\n        try {\n          throw IterableElementError.noElement();\n        } catch (e, s) {\n          future._completeError(e, s);\n        }\n      },\n      cancelOnError: true);\n    return future;\n  }\n\n  /**\n   * Returns the value of the [index]th data event of this stream.\n   *\n   * Stops listening to the stream after the [index]th data event has been\n   * received.\n   *\n   * Internally the method cancels its subscription after these elements. This\n   * means that single-subscription (non-broadcast) streams are closed and\n   * cannot be reused after a call to this method.\n   *\n   * If an error event occurs before the value is found, the future completes\n   * with this error.\n   *\n   * If a done event occurs before the value is found, the future completes\n   * with a [RangeError].\n   */\n  Future<T> elementAt(int index) {\n    if (index is! int || index < 0) throw new ArgumentError(index);\n    _Future<T> future = new _Future<T>();\n    StreamSubscription subscription;\n    subscription = this.listen(\n      (T value) {\n        if (index == 0) {\n          _cancelAndValue(subscription, future, value);\n          return;\n        }\n        index -= 1;\n      },\n      onError: future._completeError,\n      onDone: () {\n        future._completeError(new RangeError.value(index));\n      },\n      cancelOnError: true);\n    return future;\n  }\n\n  /**\n   * Creates a new stream with the same events as this stream.\n   *\n   * Whenever more than [timeLimit] passes between two events from this stream,\n   * the [onTimeout] function is called.\n   *\n   * The countdown doesn't start until the returned stream is listened to.\n   * The countdown is reset every time an event is forwarded from this stream,\n   * or when the stream is paused and resumed.\n   *\n   * The [onTimeout] function is called with one argument: an\n   * [EventSink] that allows putting events into the returned stream.\n   * This `EventSink` is only valid during the call to `onTimeout`.\n   *\n   * If `onTimeout` is omitted, a timeout will just put a [TimeoutException]\n   * into the error channel of the returned stream.\n   *\n   * The returned stream is a broadcast stream if this stream is.\n   * If a broadcast stream is listened to more than once, each subscription\n   * will have its individually timer that starts counting on listen,\n   * and the subscriptions' timers can be paused individually.\n   */\n  Stream timeout(Duration timeLimit, {void onTimeout(EventSink sink)}) {\n    StreamController controller;\n    // The following variables are set on listen.\n    StreamSubscription<T> subscription;\n    Timer timer;\n    Zone zone;\n    Function timeout;\n\n    void onData(T event) {\n      timer.cancel();\n      controller.add(event);\n      timer = zone.createTimer(timeLimit, timeout);\n    }\n    void onError(error, StackTrace stackTrace) {\n      timer.cancel();\n      controller.addError(error, stackTrace);\n      timer = zone.createTimer(timeLimit, timeout);\n    }\n    void onDone() {\n      timer.cancel();\n      controller.close();\n    }\n    void onListen() {\n      // This is the onListen callback for of controller.\n      // It runs in the same zone that the subscription was created in.\n      // Use that zone for creating timers and running the onTimeout\n      // callback.\n      zone = Zone.current;\n      if (onTimeout == null) {\n        timeout = () {\n          controller.addError(new TimeoutException(\"No stream event\",\n                                                   timeLimit));\n        };\n      } else {\n        onTimeout = zone.registerUnaryCallback(onTimeout);\n        _ControllerEventSinkWrapper wrapper =\n            new _ControllerEventSinkWrapper(null);\n        timeout = () {\n          wrapper._sink = controller;  // Only valid during call.\n          zone.runUnaryGuarded(onTimeout, wrapper);\n          wrapper._sink = null;\n        };\n      }\n\n      subscription = this.listen(onData, onError: onError, onDone: onDone);\n      timer = zone.createTimer(timeLimit, timeout);\n    }\n    Future onCancel() {\n      timer.cancel();\n      Future result = subscription.cancel();\n      subscription = null;\n      return result;\n    }\n    controller = isBroadcast\n        ? new _SyncBroadcastStreamController(onListen, onCancel)\n        : new _SyncStreamController(\n              onListen,\n              () {\n                // Don't null the timer, onCancel may call cancel again.\n                timer.cancel();\n                subscription.pause();\n              },\n              () {\n                subscription.resume();\n                timer = zone.createTimer(timeLimit, timeout);\n              },\n              onCancel);\n    return controller.stream;\n  }\n}\n\n/**\n * A subscritption on events from a [Stream].\n *\n * When you listen on a [Stream] using [Stream.listen],\n * a [StreamSubscription] object is returned.\n *\n * The subscription provides events to the listener,\n * and holds the callbacks used to handle the events.\n * The subscription can also be used to unsubscribe from the events,\n * or to temporarily pause the events from the stream.\n */\nabstract class StreamSubscription<T> {\n  /**\n   * Cancels this subscription. It will no longer receive events.\n   *\n   * May return a future which completes when the stream is done cleaning up.\n   * This can be used if the stream needs to release some resources\n   * that are needed for a following operation,\n   * for example a file being read, that should be deleted afterwards.\n   * In that case, the file may not be able to be deleted successfully\n   * until the returned future has completed.\n   *\n   * The future will be completed with a `null` value.\n   * If the cleanup throws, which it really shouldn't, the returned future\n   * will be completed with that error.\n   *\n   * Returns `null` if there is no need to wait.\n   */\n  Future cancel();\n\n  /**\n   * Set or override the data event handler of this subscription.\n   *\n   * This method overrides the handler that has been set at the invocation of\n   * [Stream.listen].\n   */\n  void onData(void handleData(T data));\n\n  /**\n   * Set or override the error event handler of this subscription.\n   *\n   * This method overrides the handler that has been set at the invocation of\n   * [Stream.listen] or by calling [asFuture].\n   */\n  void onError(Function handleError);\n\n  /**\n   * Set or override the done event handler of this subscription.\n   *\n   * This method overrides the handler that has been set at the invocation of\n   * [Stream.listen] or by calling [asFuture].\n   */\n  void onDone(void handleDone());\n\n  /**\n   * Request that the stream pauses events until further notice.\n   *\n   * If [resumeSignal] is provided, the stream will undo the pause\n   * when the future completes. If the future completes with an error,\n   * it will not be handled!\n   *\n   * A call to [resume] will also undo a pause.\n   *\n   * If the subscription is paused more than once, an equal number\n   * of resumes must be performed to resume the stream.\n   *\n   * Currently DOM streams silently drop events when the stream is paused. This\n   * is a bug and will be fixed.\n   */\n  void pause([Future resumeSignal]);\n\n  /**\n   * Resume after a pause.\n   */\n  void resume();\n\n  /**\n   * Returns true if the [StreamSubscription] is paused.\n   */\n  bool get isPaused;\n\n  /**\n   * Returns a future that handles the [onDone] and [onError] callbacks.\n   *\n   * This method *overwrites* the existing [onDone] and [onError] callbacks\n   * with new ones that complete the returned future.\n   *\n   * In case of an error the subscription will automatically cancel (even\n   * when it was listening with `cancelOnError` set to `false`).\n   *\n   * In case of a `done` event the future completes with the given\n   * [futureValue].\n   */\n  Future asFuture([var futureValue]);\n}\n\n\n/**\n * An interface that abstracts creation or handling of [Stream] events.\n */\nabstract class EventSink<T> implements Sink<T> {\n  /** Send a data event to a stream. */\n  void add(T event);\n  /** Send an async error to a stream. */\n  void addError(errorEvent, [StackTrace stackTrace]);\n  /** Send a done event to a stream.*/\n  void close();\n}\n\n\n/** [Stream] wrapper that only exposes the [Stream] interface. */\nclass StreamView<T> extends Stream<T> {\n  Stream<T> _stream;\n\n  StreamView(this._stream);\n\n  bool get isBroadcast => _stream.isBroadcast;\n\n  Stream<T> asBroadcastStream({void onListen(StreamSubscription subscription),\n                               void onCancel(StreamSubscription subscription)})\n      => _stream.asBroadcastStream(onListen: onListen, onCancel: onCancel);\n\n  StreamSubscription<T> listen(void onData(T value),\n                               { Function onError,\n                                 void onDone(),\n                                 bool cancelOnError }) {\n    return _stream.listen(onData, onError: onError, onDone: onDone,\n                          cancelOnError: cancelOnError);\n  }\n}\n\n\n/**\n * The target of a [Stream.pipe] call.\n *\n * The [Stream.pipe] call will pass itself to this object, and then return\n * the resulting [Future]. The pipe should complete the future when it's\n * done.\n */\nabstract class StreamConsumer<S> {\n  /**\n   * Consumes the elements of [stream].\n   *\n   * Listens on [stream] and does something for each event.\n   *\n   * The consumer may stop listening after an error, or it may consume\n   * all the errors and only stop at a done event.\n   */\n  Future addStream(Stream<S> stream);\n\n  /**\n   * Tell the consumer that no futher streams will be added.\n   *\n   * Returns a future that is completed when the consumer is done handling\n   * events.\n   */\n  Future close();\n}\n\n\n/**\n * A [StreamSink] unifies the asynchronous methods from [StreamConsumer] and\n * the synchronous methods from [EventSink].\n *\n * The [EventSink] methods can't be used while the [addStream] is called.\n * As soon as the [addStream]'s [Future] completes with a value, the\n * [EventSink] methods can be used again.\n *\n * If [addStream] is called after any of the [EventSink] methods, it'll\n * be delayed until the underlying system has consumed the data added by the\n * [EventSink] methods.\n *\n * When [EventSink] methods are used, the [done] [Future] can be used to\n * catch any errors.\n *\n * When [close] is called, it will return the [done] [Future].\n */\nabstract class StreamSink<S> implements StreamConsumer<S>, EventSink<S> {\n  /**\n   * As [EventSink.close], but returns a future.\n   *\n   * Returns the same future as [done].\n   */\n  Future close();\n\n  /**\n   * Return a future which is completed when the [StreamSink] is finished.\n   *\n   * If the `StreamSink` fails with an error,\n   * perhaps in response to adding events using [add], [addError] or [close],\n   * the [done] future will complete with that error.\n   *\n   * Otherwise, the returned future will complete when either:\n   *\n   * * all events have been processed and the sink has been closed, or\n   * * the sink has otherwise been stopped from handling more events\n   *   (for example by cancelling a stream subscription).\n   */\n  Future get done;\n}\n\n\n/**\n * The target of a [Stream.transform] call.\n *\n * The [Stream.transform] call will pass itself to this object and then return\n * the resulting stream.\n *\n * It is good practice to write transformers that can be used multiple times.\n */\nabstract class StreamTransformer<S, T> {\n\n  /**\n   * Creates a [StreamTransformer].\n   *\n   * The returned instance takes responsibility of implementing ([bind]).\n   * When the user invokes `bind` it returns a new \"bound\" stream. Only when\n   * the user starts listening to the bound stream, the `listen` method\n   * invokes the given closure [transformer].\n   *\n   * The [transformer] closure receives the stream, that was bound, as argument\n   * and returns a [StreamSubscription]. In almost all cases the closure\n   * listens itself to the stream that is given as argument.\n   *\n   * The result of invoking the [transformer] closure is a [StreamSubscription].\n   * The bound stream-transformer (created by the `bind` method above) then sets\n   * the handlers it received as part of the `listen` call.\n   *\n   * Conceptually this can be summarized as follows:\n   *\n   * 1. `var transformer = new StreamTransformer(transformerClosure);`\n   *   creates a `StreamTransformer` that supports the `bind` method.\n   * 2. `var boundStream = stream.transform(transformer);` binds the `stream`\n   *   and returns a bound stream that has a pointer to `stream`.\n   * 3. `boundStream.listen(f1, onError: f2, onDone: f3, cancelOnError: b)`\n   *   starts the listening and transformation. This is accomplished\n   *   in 2 steps: first the `boundStream` invokes the `transformerClosure` with\n   *   the `stream` it captured: `transformerClosure(stream, b)`.\n   *   The result `subscription`, a [StreamSubscription], is then\n   *   updated to receive its handlers: `subscription.onData(f1)`,\n   *   `subscription.onError(f2)`, `subscription(f3)`. Finally the subscription\n   *   is returned as result of the `listen` call.\n   *\n   * There are two common ways to create a StreamSubscription:\n   *\n   * 1. by creating a new class that implements [StreamSubscription].\n   *    Note that the subscription should run callbacks in the [Zone] the\n   *    stream was listened to.\n   * 2. by allocating a [StreamController] and to return the result of\n   *    listening to its stream.\n   *\n   * Example use of a duplicating transformer:\n   *\n   *     stringStream.transform(new StreamTransformer<String, String>(\n   *         (Stream<String> input, bool cancelOnError) {\n   *           StreamController<String> controller;\n   *           StreamSubscription<String> subscription;\n   *           controller = new StreamController<String>(\n   *             onListen: () {\n   *               subscription = input.listen((data) {\n   *                   // Duplicate the data.\n   *                   controller.add(data);\n   *                   controller.add(data);\n   *                 },\n   *                 onError: controller.addError,\n   *                 onDone: controller.close,\n   *                 cancelOnError: cancelOnError);\n   *             },\n   *             onPause: subscription.pause,\n   *             onResume: subscription.resume,\n   *             onCancel: subscription.cancel,\n   *             sync: true);\n   *           return controller.stream.listen(null);\n   *         });\n   */\n  const factory StreamTransformer(\n      StreamSubscription<T> transformer(Stream<S> stream, bool cancelOnError))\n      = _StreamSubscriptionTransformer;\n\n  /**\n   * Creates a [StreamTransformer] that delegates events to the given functions.\n   *\n   * Example use of a duplicating transformer:\n   *\n   *     stringStream.transform(new StreamTransformer<String, String>.fromHandlers(\n   *         handleData: (String value, EventSink<String> sink) {\n   *           sink.add(value);\n   *           sink.add(value);  // Duplicate the incoming events.\n   *         }));\n   */\n  factory StreamTransformer.fromHandlers({\n      void handleData(S data, EventSink<T> sink),\n      void handleError(Object error, StackTrace stackTrace, EventSink<T> sink),\n      void handleDone(EventSink<T> sink)})\n          = _StreamHandlerTransformer;\n\n  Stream<T> bind(Stream<S> stream);\n}\n\n/**\n * An [Iterable] like interface for the values of a [Stream].\n *\n * This wraps a [Stream] and a subscription on the stream. It listens\n * on the stream, and completes the future returned by [moveNext] when the\n * next value becomes available.\n */\nabstract class StreamIterator<T> {\n\n  /** Create a [StreamIterator] on [stream]. */\n  factory StreamIterator(Stream<T> stream)\n      // TODO(lrn): use redirecting factory constructor when type\n      // arguments are supported.\n      => new _StreamIteratorImpl<T>(stream);\n\n  /**\n   * Wait for the next stream value to be available.\n   *\n   * It is not allowed to call this function again until the future has\n   * completed. If the returned future completes with anything except `true`,\n   * the iterator is done, and no new value will ever be available.\n   *\n   * The future may complete with an error, if the stream produces an error.\n   */\n  Future<bool> moveNext();\n\n  /**\n   * The current value of the stream.\n   *\n   * Only valid when the future returned by [moveNext] completes with `true`\n   * as value, and only until the next call to [moveNext].\n   */\n  T get current;\n\n  /**\n   * Cancels the stream iterator (and the underlying stream subscription) early.\n   *\n   * The stream iterator is automatically canceled if the [moveNext] future\n   * completes with either `false` or an error.\n   *\n   * If a [moveNext] call has been made, it will complete with `false` as value,\n   * as will all further calls to [moveNext].\n   *\n   * If you need to stop listening for values before the stream iterator is\n   * automatically closed, you must call [cancel] to ensure that the stream\n   * is properly closed.\n   *\n   * Returns a future if the cancel-operation is not completed synchronously.\n   * Otherwise returns `null`.\n   */\n  Future cancel();\n}\n\n\n/**\n * Wraps an [_EventSink] so it exposes only the [EventSink] interface.\n */\nclass _ControllerEventSinkWrapper<T> implements EventSink<T> {\n  EventSink _sink;\n  _ControllerEventSinkWrapper(this._sink);\n\n  void add(T data) { _sink.add(data); }\n  void addError(error, [StackTrace stackTrace]) {\n    _sink.addError(error, stackTrace);\n  }\n  void close() { _sink.close(); }\n}\n\u0000","sdk:/sdk/lib/async/schedule_microtask.dart":"// Copyright (c) 2013, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\npart of dart.async;\n\ntypedef void _AsyncCallback();\n\nclass _AsyncCallbackEntry {\n  final _AsyncCallback callback;\n  _AsyncCallbackEntry next;\n  _AsyncCallbackEntry(this.callback);\n}\n\n/** Head of single linked list of pending callbacks. */\n_AsyncCallbackEntry _nextCallback;\n/** Tail of single linked list of pending callbacks. */\n_AsyncCallbackEntry _lastCallback;\n/**\n * Tail of priority callbacks added by the currently executing callback.\n *\n * Priority callbacks are put at the beginning of the\n * callback queue, so that if one callback schedules more than one\n * priority callback, they are still enqueued in scheduling order.\n */\n_AsyncCallbackEntry _lastPriorityCallback;\n/**\n * Whether we are currently inside the callback loop.\n *\n * If we are inside the loop, we never need to schedule the loop,\n * even if adding a first element.\n */\nbool _isInCallbackLoop = false;\n\nvoid _asyncRunCallbackLoop() {\n  while (_nextCallback != null) {\n    _lastPriorityCallback = null;\n    _AsyncCallbackEntry entry = _nextCallback;\n    _nextCallback = entry.next;\n    if (_nextCallback == null) _lastCallback = null;\n    entry.callback();\n  }\n}\n\nvoid _asyncRunCallback() {\n  _isInCallbackLoop = true;\n  try {\n    _asyncRunCallbackLoop();\n  } finally {\n    _lastPriorityCallback = null;\n    _isInCallbackLoop = false;\n    if (_nextCallback != null) _AsyncRun._scheduleImmediate(_asyncRunCallback);\n  }\n}\n\n/**\n * Schedules a callback to be called as a microtask.\n *\n * The microtask is called after all other currently scheduled\n * microtasks, but as part of the current system event.\n */\nvoid _scheduleAsyncCallback(callback) {\n  // Optimizing a group of Timer.run callbacks to be executed in the\n  // same Timer callback.\n  if (_nextCallback == null) {\n    _nextCallback = _lastCallback = new _AsyncCallbackEntry(callback);\n    if (!_isInCallbackLoop) {\n      _AsyncRun._scheduleImmediate(_asyncRunCallback);\n    }\n  } else {\n    _AsyncCallbackEntry newEntry = new _AsyncCallbackEntry(callback);\n    _lastCallback.next = newEntry;\n    _lastCallback = newEntry;\n  }\n}\n\n/**\n * Schedules a callback to be called before all other currently scheduled ones.\n *\n * This callback takes priority over existing scheduled callbacks.\n * It is only used internally to give higher priority to error reporting.\n */\nvoid _schedulePriorityAsyncCallback(callback) {\n  _AsyncCallbackEntry entry = new _AsyncCallbackEntry(callback);\n  if (_nextCallback == null) {\n    _nextCallback = _lastCallback = _lastPriorityCallback = entry;\n    if (!_isInCallbackLoop) {\n      _AsyncRun._scheduleImmediate(_asyncRunCallback);\n    }\n  } else if (_lastPriorityCallback == null) {\n    entry.next = _nextCallback;\n    _nextCallback = _lastPriorityCallback = entry;\n  } else {\n    entry.next = _lastPriorityCallback.next;\n    _lastPriorityCallback.next = entry;\n    _lastPriorityCallback = entry;\n    if (entry.next == null) {\n      _lastCallback = entry;\n    }\n  }\n}\n\n/**\n * Runs a function asynchronously.\n *\n * Callbacks registered through this function are always executed in order and\n * are guaranteed to run before other asynchronous events (like [Timer] events,\n * or DOM events).\n *\n * **Warning:** it is possible to starve the DOM by registering asynchronous\n * callbacks through this method. For example the following program runs\n * the callbacks without ever giving the Timer callback a chance to execute:\n *\n *     main() {\n *       Timer.run(() { print(\"executed\"); });  // Will never be executed.\n *       foo() {\n *         scheduleMicrotask(foo);  // Schedules [foo] in front of other events.\n *       }\n *       foo();\n *     }\n *\n * ## Other resources\n *\n * * [The Event Loop and Dart](https://www.dartlang.org/articles/event-loop/):\n * Learn how Dart handles the event queue and microtask queue, so you can write\n * better asynchronous code with fewer surprises.\n */\nvoid scheduleMicrotask(void callback()) {\n  if (identical(_ROOT_ZONE, Zone.current)) {\n    // No need to bind the callback. We know that the root's scheduleMicrotask\n    // will be invoked in the root zone.\n    _rootScheduleMicrotask(null, null, _ROOT_ZONE, callback);\n    return;\n  }\n  Zone.current.scheduleMicrotask(\n      Zone.current.bindCallback(callback, runGuarded: true));\n}\n\nclass _AsyncRun {\n  /** Schedule the given callback before any other event in the event-loop. */\n  external static void _scheduleImmediate(void callback());\n}\n\u0000","sdk:/sdk/lib/async/future_impl.dart":"// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\npart of dart.async;\n\n/** The onValue and onError handlers return either a value or a future */\ntypedef dynamic _FutureOnValue<T>(T value);\n/** Test used by [Future.catchError] to handle skip some errors. */\ntypedef bool _FutureErrorTest(var error);\n/** Used by [WhenFuture]. */\ntypedef _FutureAction();\n\nabstract class _Completer<T> implements Completer<T> {\n  final _Future<T> future = new _Future<T>();\n\n  void complete([value]);\n\n  void completeError(Object error, [StackTrace stackTrace]);\n\n  // The future's _isComplete doesn't take into account pending completions.\n  // We therefore use _mayComplete.\n  bool get isCompleted => !future._mayComplete;\n}\n\nclass _AsyncCompleter<T> extends _Completer<T> {\n\n  void complete([value]) {\n    if (!future._mayComplete) throw new StateError(\"Future already completed\");\n    future._asyncComplete(value);\n  }\n\n  void completeError(Object error, [StackTrace stackTrace]) {\n    if (error == null) throw new ArgumentError(\"Error must not be null\");\n    if (!future._mayComplete) throw new StateError(\"Future already completed\");\n    future._asyncCompleteError(error, stackTrace);\n  }\n}\n\nclass _SyncCompleter<T> extends _Completer<T> {\n\n  void complete([value]) {\n    if (!future._mayComplete) throw new StateError(\"Future already completed\");\n    future._complete(value);\n  }\n\n  void completeError(Object error, [StackTrace stackTrace]) {\n    if (!future._mayComplete) throw new StateError(\"Future already completed\");\n    future._completeError(error, stackTrace);\n  }\n}\n\nclass _Future<T> implements Future<T> {\n  // State of the future. The state determines the interpretation of the\n  // [resultOrListeners] field.\n  // TODO(lrn): rename field since it can also contain a chained future.\n\n  /// Initial state, waiting for a result. In this state, the\n  /// [resultOrListeners] field holds a single-linked list of\n  /// [FutureListener] listeners.\n  static const int _INCOMPLETE = 0;\n  /// Pending completion. Set when completed using [_asyncComplete] or\n  /// [_asyncCompleteError]. It is an error to try to complete it again.\n  static const int _PENDING_COMPLETE = 1;\n  /// The future has been chained to another future. The result of that\n  /// other future becomes the result of this future as well.\n  /// In this state, no callback should be executed anymore.\n  // TODO(floitsch): we don't really need a special \"_CHAINED\" state. We could\n  // just use the PENDING_COMPLETE state instead.\n  static const int _CHAINED = 2;\n  /// The future has been completed with a value result.\n  static const int _VALUE = 4;\n  /// The future has been completed with an error result.\n  static const int _ERROR = 8;\n\n  /** Whether the future is complete, and as what. */\n  int _state = _INCOMPLETE;\n\n  final Zone _zone;\n\n  bool get _mayComplete => _state == _INCOMPLETE;\n  bool get _isChained => _state == _CHAINED;\n  bool get _isComplete => _state >= _VALUE;\n  bool get _hasValue => _state == _VALUE;\n  bool get _hasError => _state == _ERROR;\n\n  set _isChained(bool value) {\n    if (value) {\n      assert(!_isComplete);\n      _state = _CHAINED;\n    } else {\n      assert(_isChained);\n      _state = _INCOMPLETE;\n    }\n  }\n\n  /**\n   * Either the result, a list of listeners or another future.\n   *\n   * The result of the future is either a value or an error.\n   * A result is only stored when the future has completed.\n   *\n   * The listeners is an internally linked list of [_FutureListener]s.\n   * Listeners are only remembered while the future is not yet complete,\n   * and it is not chained to another future.\n   *\n   * The future is another future that his future is chained to. This future\n   * is waiting for the other future to complete, and when it does, this future\n   * will complete with the same result.\n   * All listeners are forwarded to the other future.\n   *\n   * The cases are disjoint (incomplete and unchained, incomplete and\n   * chained, or completed with value or error), so the field only needs to hold\n   * one value at a time.\n   */\n  var _resultOrListeners;\n\n  /**\n   * A [_Future] implements a linked list. If a future has more than one\n   * listener the [_nextListener] field of the first listener points to the\n   * remaining listeners.\n   */\n  // TODO(floitsch): since single listeners are the common case we should\n  // use a bit to indicate that the _resultOrListeners contains a container.\n  _Future _nextListener;\n\n  // TODO(floitsch): we only need two closure fields to store the callbacks.\n  // If we store the type of a closure in the state field (where there are\n  // still bits left), we can just store two closures instead of using 4\n  // fields of which 2 are always null.\n  _FutureOnValue _onValueCallback;\n  _FutureErrorTest _errorTestCallback;\n  Function _onErrorCallback;\n  _FutureAction _whenCompleteActionCallback;\n\n  _FutureOnValue get _onValue => _isChained ? null : _onValueCallback;\n  _FutureErrorTest get _errorTest => _isChained ? null : _errorTestCallback;\n  Function get _onError => _isChained ? null : _onErrorCallback;\n  _FutureAction get _whenCompleteAction\n      => _isChained ? null : _whenCompleteActionCallback;\n\n  _Future()\n      : _zone = Zone.current,\n        _onValueCallback = null, _errorTestCallback = null,\n        _onErrorCallback = null, _whenCompleteActionCallback = null;\n\n  /// Valid types for value: `T` or `Future<T>`.\n  _Future.immediate(value)\n        : _zone = Zone.current,\n          _onValueCallback = null, _errorTestCallback = null,\n          _onErrorCallback = null, _whenCompleteActionCallback = null {\n    _asyncComplete(value);\n  }\n\n  _Future.immediateError(var error, [StackTrace stackTrace])\n      : _zone = Zone.current,\n        _onValueCallback = null, _errorTestCallback = null,\n        _onErrorCallback = null, _whenCompleteActionCallback = null {\n    _asyncCompleteError(error, stackTrace);\n  }\n\n  _Future._then(onValueCallback(value), Function onErrorCallback)\n      : _zone = Zone.current,\n        _onValueCallback = Zone.current.registerUnaryCallback(onValueCallback),\n        _onErrorCallback = _registerErrorHandler(onErrorCallback, Zone.current),\n        _errorTestCallback = null,\n        _whenCompleteActionCallback = null;\n\n  _Future._catchError(Function onErrorCallback, bool errorTestCallback(e))\n    : _zone = Zone.current,\n      _onErrorCallback = _registerErrorHandler(onErrorCallback, Zone.current),\n      _errorTestCallback =\n          Zone.current.registerUnaryCallback(errorTestCallback),\n      _onValueCallback = null,\n      _whenCompleteActionCallback = null;\n\n  _Future._whenComplete(whenCompleteActionCallback())\n      : _zone = Zone.current,\n        _whenCompleteActionCallback =\n            Zone.current.registerCallback(whenCompleteActionCallback),\n        _onValueCallback = null,\n        _errorTestCallback = null,\n        _onErrorCallback = null;\n\n  Future then(f(T value), { Function onError }) {\n    _Future result;\n    result = new _Future._then(f, onError);\n    _addListener(result);\n    return result;\n  }\n\n  Future catchError(Function onError, { bool test(error) }) {\n    _Future result = new _Future._catchError(onError, test);\n    _addListener(result);\n    return result;\n  }\n\n  Future<T> whenComplete(action()) {\n    _Future result = new _Future<T>._whenComplete(action);\n    _addListener(result);\n    return result;\n  }\n\n  Stream<T> asStream() => new Stream.fromFuture(this);\n\n  void _markPendingCompletion() {\n    if (!_mayComplete) throw new StateError(\"Future already completed\");\n    _state = _PENDING_COMPLETE;\n  }\n\n  T get _value {\n    assert(_isComplete && _hasValue);\n    return _resultOrListeners;\n  }\n\n  _AsyncError get _error {\n    assert(_isComplete && _hasError);\n    return _resultOrListeners;\n  }\n\n  void _setValue(T value) {\n    assert(!_isComplete);  // But may have a completion pending.\n    _state = _VALUE;\n    _resultOrListeners = value;\n  }\n\n  void _setError(Object error, StackTrace stackTrace) {\n    assert(!_isComplete);  // But may have a completion pending.\n    _state = _ERROR;\n    _resultOrListeners = new _AsyncError(error, stackTrace);\n  }\n\n  void _addListener(_Future listener) {\n    assert(listener._nextListener == null);\n    if (_isComplete) {\n      // Handle late listeners asynchronously.\n      _zone.scheduleMicrotask(() {\n        _propagateToListeners(this, listener);\n      });\n    } else {\n      listener._nextListener = _resultOrListeners;\n      _resultOrListeners = listener;\n    }\n  }\n\n  _Future _removeListeners() {\n    // Reverse listeners before returning them, so the resulting list is in\n    // subscription order.\n    assert(!_isComplete);\n    _Future current = _resultOrListeners;\n    _resultOrListeners = null;\n    _Future prev = null;\n    while (current != null) {\n      _Future next = current._nextListener;\n      current._nextListener = prev;\n      prev = current;\n      current = next;\n    }\n    return prev;\n  }\n\n  // Take the value (when completed) of source and complete target with that\n  // value (or error). This function can chain all Futures, but is slower\n  // for _Future than _chainCoreFuture - Use _chainCoreFuture in that case.\n  static void _chainForeignFuture(Future source, _Future target) {\n    assert(!target._isComplete);\n    assert(source is! _Future);\n\n    // Mark the target as chained (and as such half-completed).\n    target._isChained = true;\n    source.then((value) {\n        assert(target._isChained);\n        target._completeWithValue(value);\n      },\n      // TODO(floitsch): eventually we would like to make this non-optional\n      // and dependent on the listeners of the target future. If none of\n      // the target future's listeners want to have the stack trace we don't\n      // need a trace.\n      onError: (error, [stackTrace]) {\n        assert(target._isChained);\n        target._completeError(error, stackTrace);\n      });\n  }\n\n  // Take the value (when completed) of source and complete target with that\n  // value (or error). This function expects that source is a _Future.\n  static void _chainCoreFuture(_Future source, _Future target) {\n    assert(!target._isComplete);\n    assert(source is _Future);\n\n    // Mark the target as chained (and as such half-completed).\n    target._isChained = true;\n    _Future internalFuture = source;\n    if (internalFuture._isComplete) {\n      _propagateToListeners(internalFuture, target);\n    } else {\n      internalFuture._addListener(target);\n    }\n  }\n\n  void _complete(value) {\n    assert(!_isComplete);\n    assert(_onValue == null);\n    assert(_onError == null);\n    assert(_whenCompleteAction == null);\n    assert(_errorTest == null);\n\n    if (value is Future) {\n      if (value is _Future) {\n        _chainCoreFuture(value, this);\n      } else {\n        _chainForeignFuture(value, this);\n      }\n    } else {\n      _Future listeners = _removeListeners();\n      _setValue(value);\n      _propagateToListeners(this, listeners);\n    }\n  }\n\n  void _completeWithValue(value) {\n    assert(!_isComplete);\n    assert(_onValue == null);\n    assert(_onError == null);\n    assert(_whenCompleteAction == null);\n    assert(_errorTest == null);\n    assert(value is! Future);\n\n    _Future listeners = _removeListeners();\n    _setValue(value);\n    _propagateToListeners(this, listeners);\n  }\n\n  void _completeError(error, [StackTrace stackTrace]) {\n    assert(!_isComplete);\n    assert(_onValue == null);\n    assert(_onError == null);\n    assert(_whenCompleteAction == null);\n    assert(_errorTest == null);\n\n    _Future listeners = _removeListeners();\n    _setError(error, stackTrace);\n    _propagateToListeners(this, listeners);\n  }\n\n  void _asyncComplete(value) {\n    assert(!_isComplete);\n    assert(_onValue == null);\n    assert(_onError == null);\n    assert(_whenCompleteAction == null);\n    assert(_errorTest == null);\n    // Two corner cases if the value is a future:\n    //   1. the future is already completed and an error.\n    //   2. the future is not yet completed but might become an error.\n    // The first case means that we must not immediately complete the Future,\n    // as our code would immediately start propagating the error without\n    // giving the time to install error-handlers.\n    // However the second case requires us to deal with the value immediately.\n    // Otherwise the value could complete with an error and report an\n    // unhandled error, even though we know we are already going to listen to\n    // it.\n\n    if (value == null) {\n      // No checks for `null`.\n    } else if (value is Future) {\n      // Assign to typed variables so we get earlier checks in checked mode.\n      Future<T> typedFuture = value;\n      if (typedFuture is _Future) {\n        _Future<T> coreFuture = typedFuture;\n        if (coreFuture._isComplete && coreFuture._hasError) {\n          // Case 1 from above. Delay completion to enable the user to register\n          // callbacks.\n          _markPendingCompletion();\n          _zone.scheduleMicrotask(() {\n            _chainCoreFuture(coreFuture, this);\n          });\n        } else {\n          _chainCoreFuture(coreFuture, this);\n        }\n      } else {\n        // Case 2 from above. Chain the future immidiately.\n        // Note that we are still completing asynchronously (through\n        // _chainForeignFuture)..\n        _chainForeignFuture(typedFuture, this);\n      }\n      return;\n    } else {\n      T typedValue = value;\n    }\n\n    _markPendingCompletion();\n    _zone.scheduleMicrotask(() {\n      _completeWithValue(value);\n    });\n  }\n\n  void _asyncCompleteError(error, StackTrace stackTrace) {\n    assert(!_isComplete);\n    assert(_onValue == null);\n    assert(_onError == null);\n    assert(_whenCompleteAction == null);\n    assert(_errorTest == null);\n\n    _markPendingCompletion();\n    _zone.scheduleMicrotask(() {\n      _completeError(error, stackTrace);\n    });\n  }\n\n  /**\n   * Propagates the value/error of [source] to its [listeners].\n   *\n   * Unlinks all listeners and propagates the source to each listener\n   * separately.\n   */\n  static void _propagateMultipleListeners(_Future source, _Future listeners) {\n    assert(listeners != null);\n    assert(listeners._nextListener != null);\n    do {\n      _Future listener = listeners;\n      listeners = listener._nextListener;\n      listener._nextListener = null;\n      _propagateToListeners(source, listener);\n    } while (listeners != null);\n  }\n\n  /**\n   * Propagates the value/error of [source] to its [listeners], executing the\n   * listeners' callbacks.\n   *\n   * If [runCallback] is true (which should be the default) it executes\n   * the registered action of listeners. If it is `false` then the callback is\n   * skipped. This is used to complete futures with chained futures.\n   */\n  static void _propagateToListeners(_Future source, _Future listeners) {\n    while (true) {\n      if (!source._isComplete) return;  // Chained future.\n      bool hasError = source._hasError;\n      if (hasError && listeners == null) {\n        _AsyncError asyncError = source._error;\n        source._zone.handleUncaughtError(\n            asyncError.error, asyncError.stackTrace);\n        return;\n      }\n      if (listeners == null) return;\n      _Future listener = listeners;\n      if (listener._nextListener != null) {\n        // Usually futures only have one listener. If they have several, we\n        // handle them specially.\n        _propagateMultipleListeners(source, listeners);\n        return;\n      }\n      // Do the actual propagation.\n      // Set initial state of listenerHasValue and listenerValueOrError. These\n      // variables are updated, with the outcome of potential callbacks.\n      bool listenerHasValue = true;\n      final sourceValue = source._hasValue ? source._value : null;\n      var listenerValueOrError = sourceValue;\n      // Set to true if a whenComplete needs to wait for a future.\n      // The whenComplete action will resume the propagation by itself.\n      bool isPropagationAborted = false;\n      // TODO(floitsch): mark the listener as pending completion. Currently\n      // we can't do this, since the markPendingCompletion verifies that\n      // the future is not already marked (or chained).\n      // Only if we either have an error or callbacks, go into this, somewhat\n      // expensive, branch. Here we'll enter/leave the zone. Many futures\n      // doesn't have callbacks, so this is a significant optimization.\n      if (hasError ||\n          listener._onValue != null ||\n          listener._whenCompleteAction != null) {\n        Zone zone = listener._zone;\n        if (hasError && !source._zone.inSameErrorZone(zone)) {\n          // Don't cross zone boundaries with errors.\n          _AsyncError asyncError = source._error;\n          source._zone.handleUncaughtError(\n              asyncError.error, asyncError.stackTrace);\n          return;\n        }\n\n        Zone oldZone;\n        if (!identical(Zone.current, zone)) {\n          // Change zone if it's not current.\n          oldZone = Zone._enter(zone);\n        }\n\n        bool handleValueCallback() {\n          try {\n            listenerValueOrError = zone.runUnary(listener._onValue,\n                                                 sourceValue);\n            return true;\n          } catch (e, s) {\n            listenerValueOrError = new _AsyncError(e, s);\n            return false;\n          }\n        }\n\n        void handleError() {\n          _AsyncError asyncError = source._error;\n          _FutureErrorTest test = listener._errorTest;\n          bool matchesTest = true;\n          if (test != null) {\n            try {\n              matchesTest = zone.runUnary(test, asyncError.error);\n            } catch (e, s) {\n              // TODO(ajohnsen): Should we suport rethrow for test throws?\n              listenerValueOrError = identical(asyncError.error, e) ?\n                  asyncError : new _AsyncError(e, s);\n              listenerHasValue = false;\n              return;\n            }\n          }\n          Function errorCallback = listener._onError;\n          if (matchesTest && errorCallback != null) {\n            try {\n              if (errorCallback is ZoneBinaryCallback) {\n                listenerValueOrError = zone.runBinary(errorCallback,\n                                                      asyncError.error,\n                                                      asyncError.stackTrace);\n              } else {\n                listenerValueOrError = zone.runUnary(errorCallback,\n                                                     asyncError.error);\n              }\n            } catch (e, s) {\n              listenerValueOrError = identical(asyncError.error, e) ?\n                  asyncError : new _AsyncError(e, s);\n              listenerHasValue = false;\n              return;\n            }\n            listenerHasValue = true;\n          } else {\n            // Copy over the error from the source.\n            listenerValueOrError = asyncError;\n            listenerHasValue = false;\n          }\n        }\n\n        void handleWhenCompleteCallback() {\n          var completeResult;\n          try {\n            completeResult = zone.run(listener._whenCompleteAction);\n          } catch (e, s) {\n            if (hasError && identical(source._error.error, e)) {\n              listenerValueOrError = source._error;\n            } else {\n              listenerValueOrError = new _AsyncError(e, s);\n            }\n            listenerHasValue = false;\n          }\n          if (completeResult is Future) {\n            listener._isChained = true;\n            isPropagationAborted = true;\n            completeResult.then((ignored) {\n              // Try again. Since the future is marked as chained it won't run\n              // the whenComplete again.\n              _propagateToListeners(source, listener);\n            }, onError: (error, [stackTrace]) {\n              // When there is an error, we have to make the error the new\n              // result of the current listener.\n              if (completeResult is! _Future) {\n                // This should be a rare case.\n                completeResult = new _Future();\n                completeResult._setError(error, stackTrace);\n              }\n              _propagateToListeners(completeResult, listener);\n            });\n          }\n        }\n\n        if (!hasError) {\n          if (listener._onValue != null) {\n            listenerHasValue = handleValueCallback();\n          }\n        } else {\n          handleError();\n        }\n        if (listener._whenCompleteAction != null) {\n          handleWhenCompleteCallback();\n        }\n        // If we changed zone, oldZone will not be null.\n        if (oldZone != null) Zone._leave(oldZone);\n        listener._onValueCallback = null;\n        listener._errorTestCallback = null;\n        listener._onErrorCallback = null;\n        listener._whenCompleteActionCallback = null;\n\n        if (isPropagationAborted) return;\n        // If the listener's value is a future we need to chain it. Note that\n        // this can only happen if there is a callback. Since 'is' checks\n        // can be expensive, we're trying to avoid it.\n        if (listenerHasValue &&\n            !identical(sourceValue, listenerValueOrError) &&\n            listenerValueOrError is Future) {\n          Future chainSource = listenerValueOrError;\n          // Shortcut if the chain-source is already completed. Just continue\n          // the loop.\n          if (chainSource is _Future) {\n            if (chainSource._isComplete) {\n              // propagate the value (simulating a tail call).\n              listener._isChained = true;\n              source = chainSource;\n              listeners = listener;\n              continue;\n            } else {\n              _chainCoreFuture(chainSource, listener);\n            }\n          } else {\n            _chainForeignFuture(chainSource, listener);\n          }\n          return;\n        }\n      }\n      if (listenerHasValue) {\n        listeners = listener._removeListeners();\n        listener._setValue(listenerValueOrError);\n      } else {\n        listeners = listener._removeListeners();\n        _AsyncError asyncError = listenerValueOrError;\n        listener._setError(asyncError.error, asyncError.stackTrace);\n      }\n      // Prepare for next round.\n      source = listener;\n    }\n  }\n\n  Future timeout(Duration timeLimit, {onTimeout()}) {\n    if (_isComplete) return new _Future.immediate(this);\n    _Future result = new _Future();\n    Timer timer;\n    if (onTimeout == null) {\n      timer = new Timer(timeLimit, () {\n        result._completeError(new TimeoutException(\"Future not completed\",\n                                                   timeLimit));\n      });\n    } else {\n      Zone zone = Zone.current;\n      onTimeout = zone.registerCallback(onTimeout);\n      timer = new Timer(timeLimit, () {\n        try {\n          result._complete(zone.run(onTimeout));\n        } catch (e, s) {\n          result._completeError(e, s);\n        }\n      });\n    }\n    this.then((T v) {\n      if (timer.isActive) {\n        timer.cancel();\n        result._completeWithValue(v);\n      }\n    }, onError: (e, s) {\n      if (timer.isActive) {\n        timer.cancel();\n        result._completeError(e, s);\n      }\n    });\n    return result;\n  }\n}\n\u0000","sdk:/sdk/lib/async/future.dart":"// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\npart of dart.async;\n\n/**\n * An object representing a delayed computation.\n *\n * A [Future] is used to represent a potential value, or error,\n * that will be available at some time in the future.\n * Receivers of a [Future] can register callbacks\n * that handle the value or error once it is available.\n * For example:\n *\n *     Future<int> future = getFuture();\n *     future.then((value) => handleValue(value))\n *           .catchError((error) => handleError(error));\n *\n * A [Future] can complete in two ways:\n * with a value (\"the future succeeds\")\n * or with an error (\"the future fails\").\n * Users can install callbacks for each case.\n * The result of registering a pair of callbacks is a new Future (the\n * \"successor\") which in turn is completed with the result of invoking the\n * corresponding callback.\n * The successor is completed with an error if the invoked callback throws.\n * For example:\n *\n *     Future<int> successor = future.then((int value) {\n *         // Invoked when the future is completed with a value.\n *         return 42;  // The successor is completed with the value 42.\n *       },\n *       onError: (e) {\n *         // Invoked when the future is completed with an error.\n *         if (canHandle(e)) {\n *           return 499;  // The successor is completed with the value 499.\n *         } else {\n *           throw e;  // The successor is completed with the error e.\n *         }\n *       });\n *\n * If a future does not have a successor when it completes with an error,\n * it forwards the error message to the global error-handler.\n * This behavior makes sure that no error is silently dropped.\n * However, it also means that error handlers should be installed early,\n * so that they are present as soon as a future is completed with an error.\n * The following example demonstrates this potential bug:\n *\n *     var future = getFuture();\n *     new Timer(new Duration(milliseconds: 5), () {\n *       // The error-handler is not attached until 5 ms after the future has\n *       // been received. If the future fails before that, the error is\n *       // forwarded to the global error-handler, even though there is code\n *       // (just below) to eventually handle the error.\n *       future.then((value) { useValue(value); },\n *                   onError: (e) { handleError(e); });\n *     });\n *\n * When registering callbacks, it's often more readable to register the two\n * callbacks separately, by first using [then] with one argument\n * (the value handler) and using a second [catchError] for handling errors.\n * Each of these will forward the result that they don't handle\n * to their successors, and together they handle both value and error result.\n * It also has the additional benefit of the [catchError] handling errors in the\n * [then] value callback too.\n * Using sequential handlers instead of parallel ones often leads to code that\n * is easier to reason about.\n * It also makes asynchronous code very similar to synchronous code:\n *\n *     // Synchronous code.\n *     try {\n *       int value = foo();\n *       return bar(value);\n *     } catch (e) {\n *       return 499;\n *     }\n *\n * Equivalent asynchronous code, based on futures:\n *\n *     Future<int> future = new Future(foo);  // Result of foo() as a future.\n *     future.then((int value) => bar(value))\n *           .catchError((e) => 499);\n *\n * Similar to the synchronous code, the error handler (registered with\n * [catchError]) is handling any errors thrown by either `foo` or `bar`.\n * If the error-handler had been registered as the `onError` parameter of\n * the `then` call, it would not catch errors from the `bar` call.\n *\n * Futures can have more than one callback-pair registered. Each successor is\n * treated independently and is handled as if it was the only successor.\n *\n * A future may also fail to ever complete. In that case, no callbacks are\n * called.\n */\nabstract class Future<T> {\n  // The `_nullFuture` is a completed Future with the value `null`.\n  static final _Future _nullFuture = new Future.value(null);\n\n  /**\n   * Creates a future containing the result of calling [computation]\n   * asynchronously with [Timer.run].\n   *\n   * If the result of executing [computation] throws, the returned future is\n   * completed with the error.\n   *\n   * If the returned value is itself a [Future], completion of\n   * the created future will wait until the returned future completes,\n   * and will then complete with the same result.\n   *\n   * If a non-future value is returned, the returned future is completed\n   * with that value.\n   */\n  factory Future(computation()) {\n    _Future result = new _Future<T>();\n    Timer.run(() {\n      try {\n        result._complete(computation());\n      } catch (e, s) {\n        result._completeError(e, s);\n      }\n    });\n    return result;\n  }\n\n  /**\n   * Creates a future containing the result of calling [computation]\n   * asynchronously with [scheduleMicrotask].\n   *\n   * If executing [computation] throws,\n   * the returned future is completed with the thrown error.\n   *\n   * If calling [computation] returns a [Future], completion of\n   * the created future will wait until the returned future completes,\n   * and will then complete with the same result.\n   *\n   * If calling [computation] returns a non-future value,\n   * the returned future is completed with that value.\n   */\n  factory Future.microtask(computation()) {\n    _Future result = new _Future<T>();\n    scheduleMicrotask(() {\n      try {\n        result._complete(computation());\n      } catch (e, s) {\n        result._completeError(e, s);\n      }\n    });\n    return result;\n  }\n\n  /**\n   * Creates a future containing the result of immediately calling\n   * [computation].\n   *\n   * If calling [computation] throws, the returned future is completed with the\n   * error.\n   *\n   * If calling [computation] returns a [Future], completion of\n   * the created future will wait until the returned future completes,\n   * and will then complete with the same result.\n   *\n   * If calling [computation] returns a non-future value,\n   * the returned future is completed with that value.\n   */\n  factory Future.sync(computation()) {\n    try {\n      var result = computation();\n      return new Future<T>.value(result);\n    } catch (error, stackTrace) {\n      return new Future<T>.error(error, stackTrace);\n    }\n  }\n\n  /**\n   * A future whose value is available in the next event-loop iteration.\n   *\n   * If [value] is not a [Future], using this constructor is equivalent\n   * to [:new Future<T>.sync(() => value):].\n   *\n   * Use [Completer] to create a Future and complete it later.\n   */\n  factory Future.value([value]) {\n    return new _Future<T>.immediate(value);\n  }\n\n  /**\n   * A future that completes with an error in the next event-loop iteration.\n   *\n   * Use [Completer] to create a Future and complete it later.\n   */\n  factory Future.error(Object error, [StackTrace stackTrace]) {\n    return new _Future<T>.immediateError(error, stackTrace);\n  }\n\n  /**\n   * Creates a future that runs its computation after a delay.\n   *\n   * The [computation] will be executed after the given [duration] has passed,\n   * and the future is completed with the result.\n   * If the duration is 0 or less,\n   * it completes no sooner than in the next event-loop iteration.\n   *\n   * If [computation] is omitted,\n   * it will be treated as if [computation] was set to `() => null`,\n   * and the future will eventually complete with the `null` value.\n   *\n   * If calling [computation] throws, the created future will complete with the\n   * error.\n   *\n   * See also [Completer] for a way to create and complete a future at a\n   * later time that isn't necessarily after a known fixed duration.\n   */\n  factory Future.delayed(Duration duration, [T computation()]) {\n    Completer completer = new Completer.sync();\n    Future result = completer.future;\n    if (computation != null) {\n      result = result.then((ignored) => computation());\n    }\n    new Timer(duration, completer.complete);\n    return result;\n  }\n\n  /**\n   * Wait for all the given futures to complete and collect their values.\n   *\n   * Returns a future which will complete once all the futures in a list are\n   * complete. If any of the futures in the list completes with an error,\n   * the resulting future also completes with an error. Otherwise the value\n   * of the returned future will be a list of all the values that were produced.\n   *\n   * If `eagerError` is true, the future completes with an error immediately on\n   * the first error from one of the futures. Otherwise all futures must\n   * complete before the returned future is completed (still with the first\n   * error to occur, the remaining errors are silently dropped).\n   */\n  static Future<List> wait(Iterable<Future> futures, {bool eagerError: false}) {\n    Completer completer;  // Completer for the returned future.\n    List values;  // Collects the values. Set to null on error.\n    int remaining = 0;  // How many futures are we waiting for.\n    var error;   // The first error from a future.\n    StackTrace stackTrace;  // The stackTrace that came with the error.\n\n    // Handle an error from any of the futures.\n    handleError(theError, theStackTrace) {\n      bool isFirstError = values != null;\n      values = null;\n      remaining--;\n      if (isFirstError) {\n        if (remaining == 0 || eagerError) {\n          completer.completeError(theError, theStackTrace);\n        } else {\n          error = theError;\n          stackTrace = theStackTrace;\n        }\n      } else if (remaining == 0 && !eagerError) {\n        completer.completeError(error, stackTrace);\n      }\n    }\n\n    // As each future completes, put its value into the corresponding\n    // position in the list of values.\n    for (Future future in futures) {\n      int pos = remaining++;\n      future.then((Object value) {\n        remaining--;\n        if (values != null) {\n          values[pos] = value;\n          if (remaining == 0) {\n            completer.complete(values);\n          }\n        } else if (remaining == 0 && !eagerError) {\n          completer.completeError(error, stackTrace);\n        }\n      }, onError: handleError);\n    }\n    if (remaining == 0) {\n      return new Future.value(const []);\n    }\n    values = new List(remaining);\n    completer = new Completer<List>();\n    return completer.future;\n  }\n\n  /**\n   * Perform an async operation for each element of the iterable, in turn.\n   *\n   * Runs [f] for each element in [input] in order, moving to the next element\n   * only when the [Future] returned by [f] completes. Returns a [Future] that\n   * completes when all elements have been processed.\n   *\n   * The return values of all [Future]s are discarded. Any errors will cause the\n   * iteration to stop and will be piped through the returned [Future].\n   *\n   * If [f] returns a non-[Future], iteration continues immediately. Otherwise\n   * it waits for the returned [Future] to complete.\n   */\n  static Future forEach(Iterable input, f(element)) {\n    Iterator iterator = input.iterator;\n    return doWhile(() {\n      if (!iterator.moveNext()) return false;\n      return new Future.sync(() => f(iterator.current)).then((_) => true);\n    });\n  }\n\n  /**\n   * Perform an async operation repeatedly until it returns `false`.\n   *\n   * Runs [f] repeatedly, starting the next iteration only when the [Future]\n   * returned by [f] completes to `true`. Returns a [Future] that completes once\n   * [f] returns `false`.\n   *\n   * The return values of all [Future]s are discarded. Any errors will cause the\n   * iteration to stop and will be piped through the returned [Future].\n   *\n   * The function [f] may return either a [bool] or a [Future] that completes to\n   * a [bool]. If it returns a non-[Future], iteration continues immediately.\n   * Otherwise it waits for the returned [Future] to complete.\n   */\n  static Future doWhile(f()) {\n    _Future doneSignal = new _Future();\n    var nextIteration;\n    // Bind this callback explicitly so that each iteration isn't bound in the\n    // context of all the previous iterations' callbacks.\n    nextIteration = Zone.current.bindUnaryCallback((bool keepGoing) {\n      if (keepGoing) {\n        new Future.sync(f).then(nextIteration,\n                                onError: doneSignal._completeError);\n      } else {\n        doneSignal._complete(null);\n      }\n    }, runGuarded: true);\n    nextIteration(true);\n    return doneSignal;\n  }\n\n  /**\n   * Register callbacks to be called when this future completes.\n   *\n   * When this future completes with a value,\n   * the [onValue] callback will be called with that value.\n   * If this future is already completed, the callback will not be called\n   * immediately, but will be scheduled in a later microtask.\n   *\n   * If [onError] is provided, and this future completes with an error,\n   * the `onError` callback is called with that error and its stack trace.\n   * The `onError` callback must accept either one argument or two arguments.\n   * If `onError` accepts two arguments,\n   * it is called with both the error and the stack trace,\n   * otherwise it is called with just the error object.\n   *\n   * Returns a new [Future]\n   * which is completed with the result of the call to `onValue`\n   * (if this future completes with a value)\n   * or to `onError` (if this future completes with an error).\n   *\n   * If the invoked callback throws,\n   * the returned future is completed with the thrown error\n   * and a stack trace for the error.\n   * In the case of `onError`,\n   * if the exception thrown is `identical` to the error argument to `onError`,\n   * the throw is considered a rethrow,\n   * and the original stack trace is used instead.\n   *\n   * If the callback returns a [Future],\n   * the future returned by `then` will be completed with\n   * the same result as the future returned by the callback.\n   *\n   * If [onError] is not given, and this future completes with an error,\n   * the error is forwarded directly to the returned future.\n   *\n   * In most cases, it is more readable to use [catchError] separately, possibly\n   * with a `test` parameter, instead of handling both value and error in a\n   * single [then] call.\n   */\n  Future then(onValue(T value), { Function onError });\n\n  /**\n   * Handles errors emitted by this [Future].\n   *\n   * This is the asynchronous equivalent of a \"catch\" block.\n   *\n   * Returns a new [Future] that will be completed with either the result of\n   * this future or the result of calling the `onError` callback.\n   *\n   * If this future completes with a value,\n   * the returned future completes with the same value.\n   *\n   * If this future completes with an error,\n   * then [test] is first called with the error value.\n   *\n   * If `test` returns false, the exception is not handled by this `catchError`,\n   * and the returned future completes with the same error and stack trace\n   * as this future.\n   *\n   * If `test` returns `true`,\n   * [onError] is called with the error and possibly stack trace,\n   * and the returned future is completed with the result of this call\n   * in exactly the same way as for [then]'s `onError`.\n   *\n   * If `test` is omitted, it defaults to a function that always returns true.\n   * The `test` function should not throw, but if it does, it is handled as\n   * if the the `onError` function had thrown.\n   *\n   * Example:\n   *\n   *     foo\n   *       .catchError(..., test: (e) => e is ArgumentError)\n   *       .catchError(..., test: (e) => e is NoSuchMethodError)\n   *       .then((v) { ... });\n   *\n   * This method is equivalent to:\n   *\n   *     Future catchError(onError(error),\n   *                       {bool test(error)}) {\n   *       this.then((v) => v,  // Forward the value.\n   *                 // But handle errors, if the [test] succeeds.\n   *                 onError: (e, stackTrace) {\n   *                   if (test == null || test(e)) {\n   *                     if (onError is ZoneBinaryCallback) {\n   *                       return onError(e, stackTrace);\n   *                     }\n   *                     return onError(e);\n   *                   }\n   *                   throw e;\n   *                 });\n   *     }\n   *\n   */\n  Future catchError(Function onError,\n                    {bool test(Object error)});\n\n  /**\n   * Register a function to be called when this future completes.\n   *\n   * The [action] function is called when this future completes, whether it\n   * does so with a value or with an error.\n   *\n   * This is the asynchronous equivalent of a \"finally\" block.\n   *\n   * The future returned by this call, `f`, will complete the same way\n   * as this future unless an error occurs in the [action] call, or in\n   * a [Future] returned by the [action] call. If the call to [action]\n   * does not return a future, its return value is ignored.\n   *\n   * If the call to [action] throws, then `f` is completed with the\n   * thrown error.\n   *\n   * If the call to [action] returns a [Future], `f2`, then completion of\n   * `f` is delayed until `f2` completes. If `f2` completes with\n   * an error, that will be the result of `f` too. The value of `f2` is always\n   * ignored.\n   *\n   * This method is equivalent to:\n   *\n   *     Future<T> whenComplete(action()) {\n   *       this.then((v) {\n   *                   var f2 = action();\n   *                   if (f2 is Future) return f2.then((_) => v);\n   *                   return v\n   *                 },\n   *                 onError: (e) {\n   *                   var f2 = action();\n   *                   if (f2 is Future) return f2.then((_) { throw e; });\n   *                   throw e;\n   *                 });\n   *     }\n   */\n  Future<T> whenComplete(action());\n\n  /**\n   * Creates a [Stream] that sends [this]' completion value, data or error, to\n   * its subscribers. The stream closes after the completion value.\n   */\n  Stream<T> asStream();\n\n  /**\n   * Time-out the future computation after [timeLimit] has passed.\n   *\n   * Returns a new future that completes with the same value as this future,\n   * if this future completes in time.\n   *\n   * If this future does not complete before `timeLimit` has passed,\n   * the [onTimeout] action is executed instead, and its result (whether it\n   * returns or throws) is used as the result of the returned future.\n   *\n   * If `onTimeout` is omitted, a timeout will cause the returned future to\n   * complete with a [TimeoutException].\n   */\n  Future timeout(Duration timeLimit, {onTimeout()});\n}\n\n/**\n * Thrown when a scheduled timeout happens while waiting for an async result.\n */\nclass TimeoutException implements Exception {\n  /** Description of the cause of the timeout. */\n  final String message;\n  /** The duration that was exceeded. */\n  final Duration duration;\n\n  TimeoutException(this.message, [this.duration]);\n\n  String toString() {\n    if (message != null) {\n      if (duration != null) return \"TimeoutException after $duration: $message\";\n      return \"TimeoutException: $message\";\n    }\n    if (duration != null) return \"TimeoutException after $duration\";\n    return \"TimeoutException\";\n  }\n}\n\n/**\n * A way to produce Future objects and to complete them later\n * with a value or error.\n *\n * Most of the time, the simplest way to create a future is to just use\n * one of the [Future] constructors to capture the result of a single\n * asynchronous computation:\n *\n *     new Future(() { doSomething(); return result; });\n *\n * or, if the future represents the result of a sequence of asynchronous\n * computations, they can be chained using [Future.then] or similar functions\n * on [Future]:\n *\n *     Future doStuff(){\n *       return someAsyncOperation().then((result) {\n *         return someOtherAsyncOperation(result);\n *       });\n *     }\n *\n * If you do need to create a Future from scratch — for example,\n * when you're converting a callback-based API into a Future-based\n * one — you can use a Completer as follows:\n *\n *     class AsyncOperation {\n *       Completer _completer = new Completer();\n *\n *       Future<T> doOperation() {\n *         _startOperation();\n *         return _completer.future; // Send future object back to client.\n *       }\n *\n *       // Something calls this when the value is ready.\n *       void _finishOperation(T result) {\n *         _completer.complete(result);\n *       }\n *\n *       // If something goes wrong, call this.\n *       void _errorHappened(error) {\n *         _completer.completeError(error);\n *       }\n *     }\n */\nabstract class Completer<T> {\n\n  /**\n   * Creates a new completer.\n   *\n   * The general workflow for creating a new future is to 1) create a\n   * new completer, 2) hand out its future, and, at a later point, 3) invoke\n   * either [complete] or [completeError].\n   *\n   * The completer completes the future asynchronously. That means that\n   * callbacks registered on the future, are not called immediately when\n   * [complete] or [completeError] is called. Instead the callbacks are\n   * delayed until a later microtask.\n   *\n   * Example:\n   *\n   *     var completer = new Completer();\n   *     handOut(completer.future);\n   *     later: {\n   *       completer.complete('completion value');\n   *     }\n   */\n  factory Completer() => new _AsyncCompleter<T>();\n\n  /**\n   * Completes the future synchronously.\n   *\n   * This constructor should be avoided unless the completion of the future is\n   * known to be the final result of another asynchronous operation. If in doubt\n   * use the default [Completer] constructor.\n   *\n   * Example:\n   *\n   *     var completer = new Completer.sync();\n   *     // The completion is the result of the asynchronous onDone event.\n   *     // No other operation is performed after the completion. It is safe\n   *     // to use the Completer.sync constructor.\n   *     stream.listen(print, onDone: () { completer.complete(\"done\"); });\n   *\n   * Bad example. Do not use this code. Only for illustrative purposes:\n   *\n   *     var completer = new Completer.sync();\n   *     completer.future.then((_) { bar(); });\n   *     // The completion is the result of the asynchronous onDone event.\n   *     // However, there is still code executed after the completion. This\n   *     // operation is *not* safe.\n   *     stream.listen(print, onDone: () {\n   *       completer.complete(\"done\");\n   *       foo();  // In this case, foo() runs after bar().\n   *     });\n   */\n  factory Completer.sync() => new _SyncCompleter<T>();\n\n  /** The future that will contain the result provided to this completer. */\n  Future get future;\n\n  /**\n   * Completes [future] with the supplied values.\n   *\n   * If the value is itself a future, the completer will wait for that future\n   * to complete, and complete with the same result, whether it is a success\n   * or an error.\n   *\n   * Calling `complete` or [completeError] must not be done more than once.\n   *\n   * All listeners on the future are informed about the value.\n   */\n  void complete([value]);\n\n  /**\n   * Complete [future] with an error.\n   *\n   * Calling [complete] or `completeError` must not be done more than once.\n   *\n   * Completing a future with an error indicates that an exception was thrown\n   * while trying to produce a value.\n   *\n   * The argument [error] must not be `null`.\n   *\n   * If `error` is a `Future`, the future itself is used as the error value.\n   * If you want to complete with the result of the future, you can use:\n   *\n   *     thisCompleter.complete(theFuture)\n   *\n   * or if you only want to handle an error from the future:\n   *\n   *     theFuture.catchError(thisCompleter.completeError);\n   *\n   */\n  void completeError(Object error, [StackTrace stackTrace]);\n\n  /**\n   * Whether the future has been completed.\n   */\n  bool get isCompleted;\n}\n\u0000","sdk:/sdk/lib/async/deferred_load.dart":"// Copyright (c) 2013, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\npart of dart.async;\n\n/**\n * Indicates that loading of [libraryName] is deferred.\n *\n * Applies to library imports, when used as metadata.\n *\n * Example usage:\n *\n *     @lazy\n *     import 'foo.dart' as foo;\n *\n *     const lazy = const DeferredLibrary('com.example.foo');\n *\n *     void main() {\n *       foo.method(); // Throws a NoSuchMethodError, foo is not loaded yet.\n *       lazy.load().then(onFooLoaded);\n *     }\n *\n *     void onFooLoaded(_) {\n *       foo.method();\n *     }\n */\nclass DeferredLibrary {\n  final String libraryName;\n  final String uri;\n\n  const DeferredLibrary(this.libraryName, {this.uri});\n\n  /**\n   * Ensure that [libraryName] has been loaded.\n   *\n   * If the library fails to load, the Future will complete with a\n   * DeferredLoadException.\n   */\n  external Future<Null> load();\n}\n\n/**\n * Thrown when a deferred library fails to load.\n */\nclass DeferredLoadException implements Exception {\n  DeferredLoadException(String this._s);\n  String toString() => \"DeferredLoadException: '$_s'\";\n  final String _s;\n}\u0000","sdk:/sdk/lib/async/broadcast_stream_controller.dart":"// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\npart of dart.async;\n\nclass _BroadcastStream<T> extends _ControllerStream<T> {\n  _BroadcastStream(_StreamControllerLifecycle controller) : super(controller);\n\n  bool get isBroadcast => true;\n}\n\nabstract class _BroadcastSubscriptionLink {\n  _BroadcastSubscriptionLink _next;\n  _BroadcastSubscriptionLink _previous;\n}\n\nclass _BroadcastSubscription<T> extends _ControllerSubscription<T>\n                                implements _BroadcastSubscriptionLink {\n  static const int _STATE_EVENT_ID = 1;\n  static const int _STATE_FIRING = 2;\n  static const int _STATE_REMOVE_AFTER_FIRING = 4;\n  // TODO(lrn): Use the _state field on _ControllerSubscription to\n  // also store this state. Requires that the subscription implementation\n  // does not assume that it's use of the state integer is the only use.\n  int _eventState;\n\n  _BroadcastSubscriptionLink _next;\n  _BroadcastSubscriptionLink _previous;\n\n  _BroadcastSubscription(_StreamControllerLifecycle controller,\n                         void onData(T data),\n                         Function onError,\n                         void onDone(),\n                         bool cancelOnError)\n      : super(controller, onData, onError, onDone, cancelOnError) {\n    _next = _previous = this;\n  }\n\n  _BroadcastStreamController get _controller => super._controller;\n\n  bool _expectsEvent(int eventId) =>\n      (_eventState & _STATE_EVENT_ID) == eventId;\n\n  void _toggleEventId() {\n    _eventState ^= _STATE_EVENT_ID;\n  }\n\n  bool get _isFiring => (_eventState & _STATE_FIRING) != 0;\n\n  void _setRemoveAfterFiring() {\n    assert(_isFiring);\n    _eventState |= _STATE_REMOVE_AFTER_FIRING;\n  }\n\n  bool get _removeAfterFiring =>\n      (_eventState & _STATE_REMOVE_AFTER_FIRING) != 0;\n\n  // The controller._recordPause doesn't do anything for a broadcast controller,\n  // so we don't bother calling it.\n  void _onPause() { }\n\n  // The controller._recordResume doesn't do anything for a broadcast\n  // controller, so we don't bother calling it.\n  void _onResume() { }\n\n  // _onCancel is inherited.\n}\n\n\nabstract class _BroadcastStreamController<T>\n    implements StreamController<T>,\n               _StreamControllerLifecycle<T>,\n               _BroadcastSubscriptionLink,\n               _EventSink<T>,\n               _EventDispatch<T> {\n  static const int _STATE_INITIAL = 0;\n  static const int _STATE_EVENT_ID = 1;\n  static const int _STATE_FIRING = 2;\n  static const int _STATE_CLOSED = 4;\n  static const int _STATE_ADDSTREAM = 8;\n\n  final _NotificationHandler _onListen;\n  final _NotificationHandler _onCancel;\n\n  // State of the controller.\n  int _state;\n\n  // Double-linked list of active listeners.\n  _BroadcastSubscriptionLink _next;\n  _BroadcastSubscriptionLink _previous;\n\n  // Extra state used during an [addStream] call.\n  _AddStreamState<T> _addStreamState;\n\n  /**\n   * Future returned by [close] and [done].\n   *\n   * The future is completed whenever the done event has been sent to all\n   * relevant listeners.\n   * The relevant listeners are the ones that were listening when [close] was\n   * called. When all of these have been canceled (sending the done event makes\n   * them cancel, but they can also be canceled before sending the event),\n   * this future completes.\n   *\n   * Any attempt to listen after calling [close] will throw, so there won't\n   * be any further listeners.\n   */\n  _Future _doneFuture;\n\n  _BroadcastStreamController(this._onListen, this._onCancel)\n      : _state = _STATE_INITIAL {\n    _next = _previous = this;\n  }\n\n  // StreamController interface.\n\n  Stream<T> get stream => new _BroadcastStream<T>(this);\n\n  StreamSink<T> get sink => new _StreamSinkWrapper<T>(this);\n\n  bool get isClosed => (_state & _STATE_CLOSED) != 0;\n\n  /**\n   * A broadcast controller is never paused.\n   *\n   * Each receiving stream may be paused individually, and they handle their\n   * own buffering.\n   */\n  bool get isPaused => false;\n\n  /** Whether there are currently one or more subscribers. */\n  bool get hasListener => !_isEmpty;\n\n  /**\n   * Test whether the stream has exactly one listener.\n   *\n   * Assumes that the stream has a listener (not [_isEmpty]).\n   */\n  bool get _hasOneListener {\n    assert(!_isEmpty);\n    return identical(_next._next, this);\n  }\n\n  /** Whether an event is being fired (sent to some, but not all, listeners). */\n  bool get _isFiring => (_state & _STATE_FIRING) != 0;\n\n  bool get _isAddingStream => (_state & _STATE_ADDSTREAM) != 0;\n\n  bool get _mayAddEvent => (_state < _STATE_CLOSED);\n\n  _Future _ensureDoneFuture() {\n    if (_doneFuture != null) return _doneFuture;\n    return _doneFuture = new _Future();\n  }\n\n  // Linked list helpers\n\n  bool get _isEmpty => identical(_next, this);\n\n  /** Adds subscription to linked list of active listeners. */\n  void _addListener(_BroadcastSubscription<T> subscription) {\n    assert(identical(subscription._next, subscription));\n    // Insert in linked list just before `this`.\n    subscription._previous = _previous;\n    subscription._next = this;\n    this._previous._next = subscription;\n    this._previous = subscription;\n    subscription._eventState = (_state & _STATE_EVENT_ID);\n  }\n\n  void _removeListener(_BroadcastSubscription<T> subscription) {\n    assert(identical(subscription._controller, this));\n    assert(!identical(subscription._next, subscription));\n    _BroadcastSubscriptionLink previous = subscription._previous;\n    _BroadcastSubscriptionLink next = subscription._next;\n    previous._next = next;\n    next._previous = previous;\n    subscription._next = subscription._previous = subscription;\n  }\n\n  // _StreamControllerLifecycle interface.\n\n  StreamSubscription<T> _subscribe(\n      void onData(T data),\n      Function onError,\n      void onDone(),\n      bool cancelOnError) {\n    if (isClosed) {\n      if (onDone == null) onDone = _nullDoneHandler;\n      return new _DoneStreamSubscription<T>(onDone);\n    }\n    StreamSubscription subscription =\n        new _BroadcastSubscription<T>(this, onData, onError, onDone,\n                                      cancelOnError);\n    _addListener(subscription);\n    if (identical(_next, _previous)) {\n      // Only one listener, so it must be the first listener.\n      _runGuarded(_onListen);\n    }\n    return subscription;\n  }\n\n  Future _recordCancel(_BroadcastSubscription<T> subscription) {\n    // If already removed by the stream, don't remove it again.\n    if (identical(subscription._next, subscription)) return null;\n    assert(!identical(subscription._next, subscription));\n    if (subscription._isFiring) {\n      subscription._setRemoveAfterFiring();\n    } else {\n      assert(!identical(subscription._next, subscription));\n      _removeListener(subscription);\n      // If we are currently firing an event, the empty-check is performed at\n      // the end of the listener loop instead of here.\n      if (!_isFiring && _isEmpty) {\n        _callOnCancel();\n      }\n    }\n    return null;\n  }\n\n  void _recordPause(StreamSubscription<T> subscription) {}\n  void _recordResume(StreamSubscription<T> subscription) {}\n\n  // EventSink interface.\n\n  Error _addEventError() {\n    if (isClosed) {\n      return new StateError(\"Cannot add new events after calling close\");\n    }\n    assert(_isAddingStream);\n    return new StateError(\"Cannot add new events while doing an addStream\");\n  }\n\n  void add(T data) {\n    if (!_mayAddEvent) throw _addEventError();\n    _sendData(data);\n  }\n\n  void addError(Object error, [StackTrace stackTrace]) {\n    if (!_mayAddEvent) throw _addEventError();\n    _sendError(error, stackTrace);\n  }\n\n  Future close() {\n    if (isClosed) {\n      assert(_doneFuture != null);\n      return _doneFuture;\n    }\n    if (!_mayAddEvent) throw _addEventError();\n    _state |= _STATE_CLOSED;\n    Future doneFuture = _ensureDoneFuture();\n    _sendDone();\n    return doneFuture;\n  }\n\n  Future get done => _ensureDoneFuture();\n\n  Future addStream(Stream<T> stream, {bool cancelOnError: true}) {\n    if (!_mayAddEvent) throw _addEventError();\n    _state |= _STATE_ADDSTREAM;\n    _addStreamState = new _AddStreamState(this, stream, cancelOnError);\n    return _addStreamState.addStreamFuture;\n  }\n\n  // _EventSink interface, called from AddStreamState.\n  void _add(T data) {\n    _sendData(data);\n  }\n\n  void _addError(Object error, StackTrace stackTrace) {\n    assert(_isAddingStream);\n    _sendError(error, stackTrace);\n  }\n\n  void _close() {\n    assert(_isAddingStream);\n    _AddStreamState addState = _addStreamState;\n    _addStreamState = null;\n    _state &= ~_STATE_ADDSTREAM;\n    addState.complete();\n  }\n\n  // Event handling.\n  void _forEachListener(\n      void action(_BufferingStreamSubscription<T> subscription)) {\n    if (_isFiring) {\n      throw new StateError(\n          \"Cannot fire new event. Controller is already firing an event\");\n    }\n    if (_isEmpty) return;\n\n    // Get event id of this event.\n    int id = (_state & _STATE_EVENT_ID);\n    // Start firing (set the _STATE_FIRING bit). We don't do [_onCancel]\n    // callbacks while firing, and we prevent reentrancy of this function.\n    //\n    // Set [_state]'s event id to the next event's id.\n    // Any listeners added while firing this event will expect the next event,\n    // not this one, and won't get notified.\n    _state ^= _STATE_EVENT_ID | _STATE_FIRING;\n    _BroadcastSubscriptionLink link = _next;\n    while (!identical(link, this)) {\n      _BroadcastSubscription<T> subscription = link;\n      if (subscription._expectsEvent(id)) {\n        subscription._eventState |= _BroadcastSubscription._STATE_FIRING;\n        action(subscription);\n        subscription._toggleEventId();\n        link = subscription._next;\n        if (subscription._removeAfterFiring) {\n          _removeListener(subscription);\n        }\n        subscription._eventState &= ~_BroadcastSubscription._STATE_FIRING;\n      } else {\n        link = subscription._next;\n      }\n    }\n    _state &= ~_STATE_FIRING;\n\n    if (_isEmpty) {\n      _callOnCancel();\n    }\n  }\n\n  void _callOnCancel() {\n    assert(_isEmpty);\n    if (isClosed && _doneFuture._mayComplete) {\n      // When closed, _doneFuture is not null.\n      _doneFuture._asyncComplete(null);\n    }\n    _runGuarded(_onCancel);\n  }\n}\n\nclass _SyncBroadcastStreamController<T> extends _BroadcastStreamController<T> {\n  _SyncBroadcastStreamController(void onListen(), void onCancel())\n      : super(onListen, onCancel);\n\n  // EventDispatch interface.\n\n  void _sendData(T data) {\n    if (_isEmpty) return;\n    if (_hasOneListener) {\n      _state |= _BroadcastStreamController._STATE_FIRING;\n      _BroadcastSubscription subscription = _next;\n      subscription._add(data);\n      _state &= ~_BroadcastStreamController._STATE_FIRING;\n      if (_isEmpty) {\n        _callOnCancel();\n      }\n      return;\n    }\n    _forEachListener((_BufferingStreamSubscription<T> subscription) {\n      subscription._add(data);\n    });\n  }\n\n  void _sendError(Object error, StackTrace stackTrace) {\n    if (_isEmpty) return;\n    _forEachListener((_BufferingStreamSubscription<T> subscription) {\n      subscription._addError(error, stackTrace);\n    });\n  }\n\n  void _sendDone() {\n    if (!_isEmpty) {\n      _forEachListener((_BroadcastSubscription<T> subscription) {\n        subscription._close();\n      });\n    } else {\n      assert(_doneFuture != null);\n      assert(_doneFuture._mayComplete);\n      _doneFuture._asyncComplete(null);\n    }\n  }\n}\n\nclass _AsyncBroadcastStreamController<T> extends _BroadcastStreamController<T> {\n  _AsyncBroadcastStreamController(void onListen(), void onCancel())\n      : super(onListen, onCancel);\n\n  // EventDispatch interface.\n\n  void _sendData(T data) {\n    for (_BroadcastSubscriptionLink link = _next;\n         !identical(link, this);\n         link = link._next) {\n      _BroadcastSubscription<T> subscription = link;\n      subscription._addPending(new _DelayedData(data));\n    }\n  }\n\n  void _sendError(Object error, StackTrace stackTrace) {\n    for (_BroadcastSubscriptionLink link = _next;\n         !identical(link, this);\n         link = link._next) {\n      _BroadcastSubscription<T> subscription = link;\n      subscription._addPending(new _DelayedError(error, stackTrace));\n    }\n  }\n\n  void _sendDone() {\n    if (!_isEmpty) {\n      for (_BroadcastSubscriptionLink link = _next;\n           !identical(link, this);\n           link = link._next) {\n        _BroadcastSubscription<T> subscription = link;\n        subscription._addPending(const _DelayedDone());\n      }\n    } else {\n      assert(_doneFuture != null);\n      assert(_doneFuture._mayComplete);\n      _doneFuture._asyncComplete(null);\n    }\n  }\n}\n\n/**\n * Stream controller that is used by [Stream.asBroadcastStream].\n *\n * This stream controller allows incoming events while it is firing\n * other events. This is handled by delaying the events until the\n * current event is done firing, and then fire the pending events.\n *\n * This class extends [_SyncBroadcastStreamController]. Events of\n * an \"asBroadcastStream\" stream are always initiated by events\n * on another stream, and it is fine to forward them synchronously.\n */\nclass _AsBroadcastStreamController<T>\n    extends _SyncBroadcastStreamController<T>\n    implements _EventDispatch<T> {\n  _StreamImplEvents _pending;\n\n  _AsBroadcastStreamController(void onListen(), void onCancel())\n      : super(onListen, onCancel);\n\n  bool get _hasPending => _pending != null && ! _pending.isEmpty;\n\n  void _addPendingEvent(_DelayedEvent event) {\n    if (_pending == null) {\n      _pending = new _StreamImplEvents();\n    }\n    _pending.add(event);\n  }\n\n  void add(T data) {\n    if (!isClosed && _isFiring) {\n      _addPendingEvent(new _DelayedData<T>(data));\n      return;\n    }\n    super.add(data);\n    while (_hasPending) {\n      _pending.handleNext(this);\n    }\n  }\n\n  void addError(Object error, [StackTrace stackTrace]) {\n    if (!isClosed && _isFiring) {\n      _addPendingEvent(new _DelayedError(error, stackTrace));\n      return;\n    }\n    super.addError(error, stackTrace);\n    while (_hasPending) {\n      _pending.handleNext(this);\n    }\n  }\n\n  Future close() {\n    if (!isClosed && _isFiring) {\n      _addPendingEvent(const _DelayedDone());\n      _state |= _BroadcastStreamController._STATE_CLOSED;\n      return super.done;\n    }\n    Future result = super.close();\n    assert(!_hasPending);\n    return result;\n  }\n\n  void _callOnCancel() {\n    if (_hasPending) {\n      _pending.clear();\n      _pending = null;\n    }\n    super._callOnCancel();\n  }\n}\n\n// A subscription that never receives any events.\n// It can simulate pauses, but otherwise does nothing.\nclass _DoneSubscription<T> implements StreamSubscription<T> {\n  int _pauseCount = 0;\n  void onData(void handleData(T data)) {}\n  void onError(Function handleError) {}\n  void onDone(void handleDone()) {}\n  void pause([Future resumeSignal]) {\n    if (resumeSignal != null) resumeSignal.then(_resume);\n    _pauseCount++;\n  }\n  void resume() { _resume(null); }\n  void _resume(_) {\n    if (_pauseCount > 0) _pauseCount--;\n  }\n  Future cancel() { return new _Future.immediate(null); }\n  bool get isPaused => _pauseCount > 0;\n  Future asFuture([Object value]) => new _Future();\n}\n\u0000","sdk:/sdk/lib/async/async_error.dart":"// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\npart of dart.async;\n\n_invokeErrorHandler(Function errorHandler,\n                    Object error, StackTrace stackTrace) {\n  if (errorHandler is ZoneBinaryCallback) {\n    return errorHandler(error, stackTrace);\n  } else {\n    return errorHandler(error);\n  }\n}\n\nFunction _registerErrorHandler(Function errorHandler, Zone zone) {\n  if (errorHandler is ZoneBinaryCallback) {\n    return zone.registerBinaryCallback(errorHandler);\n  } else {\n    return zone.registerUnaryCallback(errorHandler);\n  }\n}\n\nclass _AsyncError implements Error {\n  final error;\n  final StackTrace stackTrace;\n\n  _AsyncError(this.error, this.stackTrace);\n}\n\nclass _UncaughtAsyncError extends _AsyncError {\n  _UncaughtAsyncError(error, StackTrace stackTrace)\n      : super(error, _getBestStackTrace(error, stackTrace));\n\n  static StackTrace _getBestStackTrace(error, StackTrace stackTrace) {\n    if (stackTrace != null) return stackTrace;\n    if (error is Error) {\n      return error.stackTrace;\n    }\n    return null;\n  }\n\n  String toString() {\n    String result = \"Uncaught Error: ${error}\";\n\n    if (stackTrace != null) {\n      result += \"\\nStack Trace:\\n$stackTrace\";\n    }\n    return result;\n  }\n}\n\u0000","sdk:/sdk/lib/async/async.dart":"// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n/**\n * Support for asynchronous programming,\n * with classes such as Future and Stream.\n *\n * Understanding [Future]s and [Stream]s is a prerequisite for\n * writing just about any Dart program.\n *\n * To use this library in your code:\n *\n *     import 'dart:async';\n *\n * ## Future\n *\n * A Future object represents a computation whose return value\n * might not yet be available.\n * The Future returns the value of the computation\n * when it completes at some time in the future.\n * Futures are often used for potentially lengthy computations\n * such as I/O and interaction with users.\n *\n * Many methods in the Dart libraries return Futures when\n * performing tasks. For example, when binding an HttpServer\n * to a host and port, the `bind()` method returns a Future.\n *\n *      HttpServer.bind('127.0.0.1', 4444)\n *          .then((server) => print('${server.isBroadcast}'))\n *          .catchError(print);\n *\n * [Future.then] registers a callback function that runs\n * when the Future's operation, in this case the `bind()` method,\n * completes successfully.\n * The value returned by the operation\n * is passed into the callback function.\n * In this example, the `bind()` method returns the HttpServer\n * object. The callback function prints one of its properties.\n * [Future.catchError] registers a callback function that\n * runs if an error occurs within the Future.\n *\n * ## Stream\n *\n * A Stream provides an asynchronous sequence of data.\n * Examples of data sequences include individual events, like mouse clicks,\n * or sequential chunks of larger data, like multiple byte lists with the\n * contents of a file\n * such as mouse clicks, and a stream of byte lists read from a file.\n * The following example opens a file for reading.\n * [Stream.listen] registers a callback function that runs\n * each time more data is available.\n *\n *     Stream<List<int>> stream = new File('quotes.txt').openRead();\n *     stream.transform(UTF8.decoder).listen(print);\n *\n * The stream emits a sequence of a list of bytes.\n * The program must interpret the bytes or handle the raw byte data.\n * Here, the code uses a UTF8 decoder (provided in the `dart:convert` library)\n * to convert the sequence of bytes into a sequence\n * of Dart strings.\n *\n * Another common use of streams is for user-generated events\n * in a web app: The following code listens for mouse clicks on a button.\n *\n *     querySelector('#myButton').onClick.listen((_) => print('Click.'));\n *\n * ## Other resources\n *\n * * The [dart:async section of the library tour]\n * (https://www.dartlang.org/docs/dart-up-and-running/contents/ch03.html#ch03-asynchronous-programming):\n * A brief overview of asynchronous programming.\n *\n * * [Use Future-Based APIs]\n * (https://www.dartlang.org/docs/tutorials/futures/): A closer look at\n * Futures and how to use them to write asynchronous Dart code.\n *\n * * [Futures and Error Handling]\n * (https://www.dartlang.org/articles/futures-and-error-handling/): Everything\n * you wanted to know about handling errors and exceptions when working with\n * Futures (but were afraid to ask).\n *\n * * [The Event Loop and Dart](https://www.dartlang.org/articles/event-loop/):\n * Learn how Dart handles the event queue and microtask queue, so you can write\n * better asynchronous code with fewer surprises.\n *\n * * [Asynchronous Unit Testing with Dart]\n * (https://www.dartlang.org/articles/dart-unit-tests/#asynchronous-tests): How\n * to test asynchronous code.\n */\nlibrary dart.async;\n\nimport \"dart:collection\";\nimport \"dart:_internal\" show deprecated, printToZone, printToConsole,\n                             IterableElementError;\n\npart 'async_error.dart';\npart 'broadcast_stream_controller.dart';\npart 'deferred_load.dart';\npart 'future.dart';\npart 'future_impl.dart';\npart 'schedule_microtask.dart';\npart 'stream.dart';\npart 'stream_controller.dart';\npart 'stream_impl.dart';\npart 'stream_pipe.dart';\npart 'stream_transformers.dart';\npart 'timer.dart';\npart 'zone.dart';\n\u0000","sdk:/sdk/lib/core/uri.dart":"// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\npart of dart.core;\n\n/**\n * A parsed URI, such as a URL.\n *\n * **See also:**\n *\n * * [URIs][uris] in the [library tour][libtour]\n * * [RFC-3986](http://tools.ietf.org/html/rfc3986)\n *\n * [uris]: http://www.dartlang.org/docs/dart-up-and-running/contents/ch03.html#ch03-uri\n * [libtour]: http://www.dartlang.org/docs/dart-up-and-running/contents/ch03.html\n */\nclass Uri {\n  // The host name of the URI.\n  // Set to `null` if there is no authority in a URI.\n  final String _host;\n  // The port. Set to null if there is no port. Normalized to null if\n  // the port is the default port for the scheme.\n  // Set to the value of the default port if an empty port was supplied.\n  int _port;\n  // The path. Always non-null.\n  String _path;\n\n  /**\n   * Returns the scheme component.\n   *\n   * Returns the empty string if there is no scheme component.\n   */\n  // We represent the missing scheme as an empty string.\n  // A valid scheme cannot be empty.\n  final String scheme;\n\n  /**\n   * Returns the authority component.\n   *\n   * The authority is formatted from the [userInfo], [host] and [port]\n   * parts.\n   *\n   * Returns the empty string if there is no authority component.\n   */\n  String get authority {\n    if (!hasAuthority) return \"\";\n    var sb = new StringBuffer();\n    _writeAuthority(sb);\n    return sb.toString();\n  }\n\n  /**\n   * The user-info part of the authority.\n   *\n   * Does not distinguish between an empty user-info and an absent one.\n   * The value is always non-null.\n   */\n  final String _userInfo;\n\n  /**\n   * Returns the user info part of the authority component.\n   *\n   * Returns the empty string if there is no user info in the\n   * authority component.\n   */\n  String get userInfo => _userInfo;\n\n  /**\n   * Returns the host part of the authority component.\n   *\n   * Returns the empty string if there is no authority component and\n   * hence no host.\n   *\n   * If the host is an IP version 6 address, the surrounding `[` and `]` is\n   * removed.\n   */\n  String get host {\n    if (_host == null) return \"\";\n    if (_host.startsWith('[')) {\n      return _host.substring(1, _host.length - 1);\n    }\n    return _host;\n  }\n\n  /**\n   * Returns the port part of the authority component.\n   *\n   * Returns the defualt port if there is no port number in the authority\n   * component. That's 80 for http, 443 for https, and 0 for everything else.\n   */\n  int get port {\n    if (_port == null) return _defaultPort(scheme);\n    return _port;\n  }\n\n  // The default port for the scheme of this Uri..\n  static int _defaultPort(String scheme) {\n    if (scheme == \"http\") return 80;\n    if (scheme == \"https\") return 443;\n    return 0;\n  }\n\n  /**\n   * Returns the path component.\n   *\n   * The returned path is encoded. To get direct access to the decoded\n   * path use [pathSegments].\n   *\n   * Returns the empty string if there is no path component.\n   */\n  String get path => _path;\n\n  // The query content, or null if there is no query.\n  final String _query;\n\n  /**\n   * Returns the query component. The returned query is encoded. To get\n   * direct access to the decoded query use [queryParameters].\n   *\n   * Returns the empty string if there is no query component.\n   */\n  String get query => (_query == null) ? \"\" : _query;\n\n  // The fragment content, or null if there is no fragment.\n  final String _fragment;\n\n  /**\n   * Returns the fragment identifier component.\n   *\n   * Returns the empty string if there is no fragment identifier\n   * component.\n   */\n  String get fragment => (_fragment == null) ? \"\" : _fragment;\n\n  /**\n   * Cache the computed return value of [pathSegements].\n   */\n  List<String> _pathSegments;\n\n  /**\n   * Cache the computed return value of [queryParameters].\n   */\n  Map<String, String> _queryParameters;\n\n  /**\n   * Creates a new `Uri` object by parsing a URI string.\n   *\n   * If the string is not valid as a URI or URI reference,\n   * invalid characters will be percent escaped where possible.\n   * The resulting `Uri` will represent a valid URI or URI reference.\n   */\n  static Uri parse(String uri) {\n    // This parsing will not validate percent-encoding, IPv6, etc. When done\n    // it will call `new Uri(...)` which will perform these validations.\n    // This is purely splitting up the URI string into components.\n    //\n    // Important parts of the RFC 3986 used here:\n    // URI           = scheme \":\" hier-part [ \"?\" query ] [ \"#\" fragment ]\n    //\n    // hier-part     = \"//\" authority path-abempty\n    //               / path-absolute\n    //               / path-rootless\n    //               / path-empty\n    //\n    // URI-reference = URI / relative-ref\n    //\n    // absolute-URI  = scheme \":\" hier-part [ \"?\" query ]\n    //\n    // relative-ref  = relative-part [ \"?\" query ] [ \"#\" fragment ]\n    //\n    // relative-part = \"//\" authority path-abempty\n    //               / path-absolute\n    //               / path-noscheme\n    //               / path-empty\n    //\n    // scheme        = ALPHA *( ALPHA / DIGIT / \"+\" / \"-\" / \".\" )\n    //\n    // authority     = [ userinfo \"@\" ] host [ \":\" port ]\n    // userinfo      = *( unreserved / pct-encoded / sub-delims / \":\" )\n    // host          = IP-literal / IPv4address / reg-name\n    // port          = *DIGIT\n    // reg-name      = *( unreserved / pct-encoded / sub-delims )\n    //\n    // path          = path-abempty    ; begins with \"/\" or is empty\n    //               / path-absolute   ; begins with \"/\" but not \"//\"\n    //               / path-noscheme   ; begins with a non-colon segment\n    //               / path-rootless   ; begins with a segment\n    //               / path-empty      ; zero characters\n    //\n    // path-abempty  = *( \"/\" segment )\n    // path-absolute = \"/\" [ segment-nz *( \"/\" segment ) ]\n    // path-noscheme = segment-nz-nc *( \"/\" segment )\n    // path-rootless = segment-nz *( \"/\" segment )\n    // path-empty    = 0<pchar>\n    //\n    // segment       = *pchar\n    // segment-nz    = 1*pchar\n    // segment-nz-nc = 1*( unreserved / pct-encoded / sub-delims / \"@\" )\n    //               ; non-zero-length segment without any colon \":\"\n    //\n    // pchar         = unreserved / pct-encoded / sub-delims / \":\" / \"@\"\n    //\n    // query         = *( pchar / \"/\" / \"?\" )\n    //\n    // fragment      = *( pchar / \"/\" / \"?\" )\n    bool isRegName(int ch) {\n      return ch < 128 && ((_regNameTable[ch >> 4] & (1 << (ch & 0x0f))) != 0);\n    }\n    const int EOI = -1;\n\n    String scheme = \"\";\n    String userinfo = \"\";\n    String host = null;\n    int port = null;\n    String path = null;\n    String query = null;\n    String fragment = null;\n\n    int index = 0;\n    int pathStart = 0;\n    // End of input-marker.\n    int char = EOI;\n\n    void parseAuth() {\n      if (index == uri.length) {\n        char = EOI;\n        return;\n      }\n      int authStart = index;\n      int lastColon = -1;\n      int lastAt = -1;\n      char = uri.codeUnitAt(index);\n      while (index < uri.length) {\n        char = uri.codeUnitAt(index);\n        if (char == _SLASH || char == _QUESTION || char == _NUMBER_SIGN) {\n          break;\n        }\n        if (char == _AT_SIGN) {\n          lastAt = index;\n          lastColon = -1;\n        } else if (char == _COLON) {\n          lastColon = index;\n        } else if (char == _LEFT_BRACKET) {\n          lastColon = -1;\n          int endBracket = uri.indexOf(']', index + 1);\n          if (endBracket == -1) {\n            index = uri.length;\n            char = EOI;\n            break;\n          } else {\n            index = endBracket;\n          }\n        }\n        index++;\n        char = EOI;\n      }\n      int hostStart = authStart;\n      int hostEnd = index;\n      if (lastAt >= 0) {\n        userinfo = _makeUserInfo(uri, authStart, lastAt);\n        hostStart = lastAt + 1;\n      }\n      if (lastColon >= 0) {\n        int portNumber;\n        if (lastColon + 1 < index) {\n          portNumber = 0;\n          for (int i = lastColon + 1; i < index; i++) {\n            int digit = uri.codeUnitAt(i);\n            if (_ZERO > digit || _NINE < digit) {\n              _fail(uri, i, \"Invalid port number\");\n            }\n            portNumber = portNumber * 10 + (digit - _ZERO);\n          }\n        }\n        port = _makePort(portNumber, scheme);\n        hostEnd = lastColon;\n      }\n      host = _makeHost(uri, hostStart, hostEnd, true);\n      if (index < uri.length) {\n        char = uri.codeUnitAt(index);\n      }\n    }\n\n    // When reaching path parsing, the current character is known to not\n    // be part of the path.\n    const int NOT_IN_PATH = 0;\n    // When reaching path parsing, the current character is part\n    // of the a non-empty path.\n    const int IN_PATH = 1;\n    // When reaching authority parsing, authority is possible.\n    // This is only true at start or right after scheme.\n    const int ALLOW_AUTH = 2;\n\n    // Current state.\n    // Initialized to the default value that is used when exiting the\n    // scheme loop by reaching the end of input.\n    // All other breaks set their own state.\n    int state = NOT_IN_PATH;\n    int i = index;  // Temporary alias for index to avoid bug 19550 in dart2js.\n    while (i < uri.length) {\n      char = uri.codeUnitAt(i);\n      if (char == _QUESTION || char == _NUMBER_SIGN) {\n        state = NOT_IN_PATH;\n        break;\n      }\n      if (char == _SLASH) {\n        state = (i == 0) ? ALLOW_AUTH : IN_PATH;\n        break;\n      }\n      if (char == _COLON) {\n        if (i == 0) _fail(uri, 0, \"Invalid empty scheme\");\n        scheme = _makeScheme(uri, i);\n        i++;\n        pathStart = i;\n        if (i == uri.length) {\n          char = EOI;\n          state = NOT_IN_PATH;\n        } else {\n          char = uri.codeUnitAt(i);\n          if (char == _QUESTION || char == _NUMBER_SIGN) {\n            state = NOT_IN_PATH;\n          } else if (char == _SLASH) {\n            state = ALLOW_AUTH;\n          } else {\n            state = IN_PATH;\n          }\n        }\n        break;\n      }\n      i++;\n      char = EOI;\n    }\n    index = i;  // Remove alias when bug is fixed.\n\n    if (state == ALLOW_AUTH) {\n      assert(char == _SLASH);\n      // Have seen one slash either at start or right after scheme.\n      // If two slashes, it's an authority, otherwise it's just the path.\n      index++;\n      if (index == uri.length) {\n        char = EOI;\n        state = NOT_IN_PATH;\n      } else {\n        char = uri.codeUnitAt(index);\n        if (char == _SLASH) {\n          index++;\n          parseAuth();\n          pathStart = index;\n        }\n        if (char == _QUESTION || char == _NUMBER_SIGN || char == EOI) {\n          state = NOT_IN_PATH;\n        } else {\n          state = IN_PATH;\n        }\n      }\n    }\n\n    assert(state == IN_PATH || state == NOT_IN_PATH);\n    if (state == IN_PATH) {\n      // Characters from pathStart to index (inclusive) are known\n      // to be part of the path.\n      while (++index < uri.length) {\n        char = uri.codeUnitAt(index);\n        if (char == _QUESTION || char == _NUMBER_SIGN) {\n          break;\n        }\n        char = EOI;\n      }\n      state = NOT_IN_PATH;\n    }\n\n    assert(state == NOT_IN_PATH);\n    bool isFile = (scheme == \"file\");\n    bool ensureLeadingSlash = host != null;\n    path = _makePath(uri, pathStart, index, null, ensureLeadingSlash, isFile);\n\n    if (char == _QUESTION) {\n      int numberSignIndex = uri.indexOf('#', index + 1);\n      if (numberSignIndex < 0) {\n        query = _makeQuery(uri, index + 1, uri.length, null);\n      } else {\n        query = _makeQuery(uri, index + 1, numberSignIndex, null);\n        fragment = _makeFragment(uri, numberSignIndex + 1, uri.length);\n      }\n    } else if (char == _NUMBER_SIGN) {\n      fragment = _makeFragment(uri, index + 1, uri.length);\n    }\n    return new Uri._internal(scheme,\n                             userinfo,\n                             host,\n                             port,\n                             path,\n                             query,\n                             fragment);\n  }\n\n  // Report a parse failure.\n  static void _fail(String uri, int index, String message) {\n    throw new FormatException(message, uri, index);\n  }\n\n  /// Internal non-verifying constructor. Only call with validated arguments.\n  Uri._internal(this.scheme,\n                this._userInfo,\n                this._host,\n                this._port,\n                this._path,\n                this._query,\n                this._fragment);\n\n  /**\n   * Creates a new URI from its components.\n   *\n   * Each component is set through a named argument. Any number of\n   * components can be provided. The [path] and [query] components can be set\n   * using either of two different named arguments.\n   *\n   * The scheme component is set through [scheme]. The scheme is\n   * normalized to all lowercase letters. If the scheme is omitted or empty,\n   * the URI will not have a scheme part.\n   *\n   * The user info part of the authority component is set through\n   * [userInfo]. It defaults to the empty string, which will be omitted\n   * from the string representation of the URI.\n   *\n   * The host part of the authority component is set through\n   * [host]. The host can either be a hostname, an IPv4 address or an\n   * IPv6 address, contained in '[' and ']'. If the host contains a\n   * ':' character, the '[' and ']' are added if not already provided.\n   * The host is normalized to all lowercase letters.\n   *\n   * The port part of the authority component is set through\n   * [port].\n   * If [port] is omitted or `null`, it implies the default port for\n   * the URI's scheme, and is equivalent to passing that port explicitly.\n   * The recognized schemes, and their default ports, are \"http\" (80) and\n   * \"https\" (443). All other schemes are considered as having zero as the\n   * default port.\n   *\n   * If any of `userInfo`, `host` or `port` are provided,\n   * the URI will have an autority according to [hasAuthority].\n   *\n   * The path component is set through either [path] or\n   * [pathSegments]. When [path] is used, it should be a valid URI path,\n   * but invalid characters, except the general delimiters ':/@[]?#',\n   * will be escaped if necessary.\n   * When [pathSegments] is used, each of the provided segments\n   * is first percent-encoded and then joined using the forward slash\n   * separator. The percent-encoding of the path segments encodes all\n   * characters except for the unreserved characters and the following\n   * list of characters: `!$&'()*+,;=:@`. If the other components\n   * calls for an absolute path a leading slash `/` is prepended if\n   * not already there.\n   *\n   * The query component is set through either [query] or\n   * [queryParameters]. When [query] is used the provided string should\n   * be a valid URI query, but invalid characters other than general delimiters,\n   * will be escaped if necessary.\n   * When [queryParameters] is used the query is built from the\n   * provided map. Each key and value in the map is percent-encoded\n   * and joined using equal and ampersand characters. The\n   * percent-encoding of the keys and values encodes all characters\n   * except for the unreserved characters.\n   * If `query` is the empty string, it is equivalent to omitting it.\n   * To have an actual empty query part,\n   * use an empty list for `queryParameters`.\n   * If both `query` and `queryParameters` are omitted or `null`, the\n   * URI will have no query part.\n   *\n   * The fragment component is set through [fragment].\n   * It should be a valid URI fragment, but invalid characters other than\n   * general delimiters, will be escaped if necessary.\n   * If `fragment` is omitted or `null`, the URI will have no fragment part.\n   */\n  factory Uri({String scheme : \"\",\n               String userInfo : \"\",\n               String host,\n               int port,\n               String path,\n               Iterable<String> pathSegments,\n               String query,\n               Map<String, String> queryParameters,\n               String fragment}) {\n    scheme = _makeScheme(scheme, _stringOrNullLength(scheme));\n    userInfo = _makeUserInfo(userInfo, 0, _stringOrNullLength(userInfo));\n    host = _makeHost(host, 0, _stringOrNullLength(host), false);\n    // Special case this constructor for backwards compatibility.\n    if (query == \"\") query = null;\n    query = _makeQuery(query, 0, _stringOrNullLength(query), queryParameters);\n    fragment = _makeFragment(fragment, 0, _stringOrNullLength(fragment));\n    port = _makePort(port, scheme);\n    bool isFile = (scheme == \"file\");\n    if (host == null &&\n        (userInfo.isNotEmpty || port != null || isFile)) {\n      host = \"\";\n    }\n    bool ensureLeadingSlash = host != null;\n    path = _makePath(path, 0, _stringOrNullLength(path), pathSegments,\n                     ensureLeadingSlash, isFile);\n    return new Uri._internal(scheme, userInfo, host, port,\n                             path, query, fragment);\n  }\n\n  /**\n   * Creates a new `http` URI from authority, path and query.\n   *\n   * Examples:\n   *\n   * ```\n   * // http://example.org/path?q=dart.\n   * new Uri.http(\"google.com\", \"/search\", { \"q\" : \"dart\" });\n   *\n   * // http://user:pass@localhost:8080\n   * new Uri.http(\"user:pass@localhost:8080\", \"\");\n   *\n   * // http://example.org/a%20b\n   * new Uri.http(\"example.org\", \"a b\");\n   *\n   * // http://example.org/a%252F\n   * new Uri.http(\"example.org\", \"/a%2F\");\n   * ```\n   *\n   * The `scheme` is always set to `http`.\n   *\n   * The `userInfo`, `host` and `port` components are set from the\n   * [authority] argument. If `authority` is `null` or empty,\n   * the created `Uri` will have no authority, and will not be directly usable\n   * as an HTTP URL, which must have a non-empty host.\n   *\n   * The `path` component is set from the [unencodedPath]\n   * argument. The path passed must not be encoded as this constructor\n   * encodes the path.\n   *\n   * The `query` component is set from the optional [queryParameters]\n   * argument.\n   */\n  factory Uri.http(String authority,\n                   String unencodedPath,\n                   [Map<String, String> queryParameters]) {\n    return _makeHttpUri(\"http\", authority, unencodedPath, queryParameters);\n  }\n\n  /**\n   * Creates a new `https` URI from authority, path and query.\n   *\n   * This constructor is the same as [Uri.http] except for the scheme\n   * which is set to `https`.\n   */\n  factory Uri.https(String authority,\n                    String unencodedPath,\n                    [Map<String, String> queryParameters]) {\n    return _makeHttpUri(\"https\", authority, unencodedPath, queryParameters);\n  }\n\n  static Uri _makeHttpUri(String scheme,\n                          String authority,\n                          String unencodedPath,\n                          Map<String, String> queryParameters) {\n    var userInfo = \"\";\n    var host = null;\n    var port = null;\n\n    if (authority != null && authority.isNotEmpty) {\n      var hostStart = 0;\n      // Split off the user info.\n      bool hasUserInfo = false;\n      for (int i = 0; i < authority.length; i++) {\n        if (authority.codeUnitAt(i) == _AT_SIGN) {\n          hasUserInfo = true;\n          userInfo = authority.substring(0, i);\n          hostStart = i + 1;\n          break;\n        }\n      }\n      var hostEnd = hostStart;\n      if (hostStart < authority.length &&\n          authority.codeUnitAt(hostStart) == _LEFT_BRACKET) {\n        // IPv6 host.\n        for (; hostEnd < authority.length; hostEnd++) {\n          if (authority.codeUnitAt(hostEnd) == _RIGHT_BRACKET) break;\n        }\n        if (hostEnd == authority.length) {\n          throw new FormatException(\"Invalid IPv6 host entry.\",\n                                    authority, hostStart);\n        }\n        parseIPv6Address(authority, hostStart + 1, hostEnd);\n        hostEnd++;  // Skip the closing bracket.\n        if (hostEnd != authority.length &&\n            authority.codeUnitAt(hostEnd) != _COLON) {\n          throw new FormatException(\"Invalid end of authority\",\n                                    authority, hostEnd);\n        }\n      }\n      // Split host and port.\n      bool hasPort = false;\n      for (; hostEnd < authority.length; hostEnd++) {\n        if (authority.codeUnitAt(hostEnd) == _COLON) {\n          var portString = authority.substring(hostEnd + 1);\n          // We allow the empty port - falling back to initial value.\n          if (portString.isNotEmpty) port = int.parse(portString);\n          break;\n        }\n      }\n      host = authority.substring(hostStart, hostEnd);\n    }\n    return new Uri(scheme: scheme,\n                   userInfo: userInfo,\n                   host: host,\n                   port: port,\n                   pathSegments: unencodedPath.split(\"/\"),\n                   queryParameters: queryParameters);\n  }\n\n  /**\n   * Creates a new file URI from an absolute or relative file path.\n   *\n   * The file path is passed in [path].\n   *\n   * This path is interpreted using either Windows or non-Windows\n   * semantics.\n   *\n   * With non-Windows semantics the slash (\"/\") is used to separate\n   * path segments.\n   *\n   * With Windows semantics, backslash (\"\\\") and forward-slash (\"/\")\n   * are used to separate path segments, except if the path starts\n   * with \"\\\\?\\\" in which case, only backslash (\"\\\") separates path\n   * segments.\n   *\n   * If the path starts with a path separator an absolute URI is\n   * created. Otherwise a relative URI is created. One exception from\n   * this rule is that when Windows semantics is used and the path\n   * starts with a drive letter followed by a colon (\":\") and a\n   * path separator then an absolute URI is created.\n   *\n   * The default for whether to use Windows or non-Windows semantics\n   * determined from the platform Dart is running on. When running in\n   * the standalone VM this is detected by the VM based on the\n   * operating system. When running in a browser non-Windows semantics\n   * is always used.\n   *\n   * To override the automatic detection of which semantics to use pass\n   * a value for [windows]. Passing `true` will use Windows\n   * semantics and passing `false` will use non-Windows semantics.\n   *\n   * Examples using non-Windows semantics:\n   *\n   * ```\n   * // xxx/yyy\n   * new Uri.file(\"xxx/yyy\", windows: false);\n   *\n   * // xxx/yyy/\n   * new Uri.file(\"xxx/yyy/\", windows: false);\n   *\n   * // file:///xxx/yyy\n   * new Uri.file(\"/xxx/yyy\", windows: false);\n   *\n   * // file:///xxx/yyy/\n   * new Uri.file(\"/xxx/yyy/\", windows: false);\n   *\n   * // C:\n   * new Uri.file(\"C:\", windows: false);\n   * ```\n   *\n   * Examples using Windows semantics:\n   *\n   * ```\n   * // xxx/yyy\n   * new Uri.file(r\"xxx\\yyy\", windows: true);\n   *\n   * // xxx/yyy/\n   * new Uri.file(r\"xxx\\yyy\\\", windows: true);\n   *\n   * file:///xxx/yyy\n   * new Uri.file(r\"\\xxx\\yyy\", windows: true);\n   *\n   * file:///xxx/yyy/\n   * new Uri.file(r\"\\xxx\\yyy/\", windows: true);\n   *\n   * // file:///C:/xxx/yyy\n   * new Uri.file(r\"C:\\xxx\\yyy\", windows: true);\n   *\n   * // This throws an error. A path with a drive letter is not absolute.\n   * new Uri.file(r\"C:\", windows: true);\n   *\n   * // This throws an error. A path with a drive letter is not absolute.\n   * new Uri.file(r\"C:xxx\\yyy\", windows: true);\n   *\n   * // file://server/share/file\n   * new Uri.file(r\"\\\\server\\share\\file\", windows: true);\n   * ```\n   *\n   * If the path passed is not a legal file path [ArgumentError] is thrown.\n   */\n  factory Uri.file(String path, {bool windows}) {\n    windows = windows == null ? Uri._isWindows : windows;\n    return windows ? _makeWindowsFileUrl(path) : _makeFileUri(path);\n  }\n\n  /**\n   * Returns the natural base URI for the current platform.\n   *\n   * When running in a browser this is the current URL (from\n   * `window.location.href`).\n   *\n   * When not running in a browser this is the file URI referencing\n   * the current working directory.\n   */\n  external static Uri get base;\n\n  external static bool get _isWindows;\n\n  static _checkNonWindowsPathReservedCharacters(List<String> segments,\n                                                bool argumentError) {\n    segments.forEach((segment) {\n      if (segment.contains(\"/\")) {\n        if (argumentError) {\n          throw new ArgumentError(\"Illegal path character $segment\");\n        } else {\n          throw new UnsupportedError(\"Illegal path character $segment\");\n        }\n      }\n    });\n  }\n\n  static _checkWindowsPathReservedCharacters(List<String> segments,\n                                             bool argumentError,\n                                             [int firstSegment = 0]) {\n    segments.skip(firstSegment).forEach((segment) {\n      if (segment.contains(new RegExp(r'[\"*/:<>?\\\\|]'))) {\n        if (argumentError) {\n          throw new ArgumentError(\"Illegal character in path\");\n        } else {\n          throw new UnsupportedError(\"Illegal character in path\");\n        }\n      }\n    });\n  }\n\n  static _checkWindowsDriveLetter(int charCode, bool argumentError) {\n    if ((_UPPER_CASE_A <= charCode && charCode <= _UPPER_CASE_Z) ||\n        (_LOWER_CASE_A <= charCode && charCode <= _LOWER_CASE_Z)) {\n      return;\n    }\n    if (argumentError) {\n      throw new ArgumentError(\"Illegal drive letter \" +\n                              new String.fromCharCode(charCode));\n    } else {\n      throw new UnsupportedError(\"Illegal drive letter \" +\n                              new String.fromCharCode(charCode));\n    }\n  }\n\n  static _makeFileUri(String path) {\n    String sep = \"/\";\n  if (path.startsWith(sep)) {\n      // Absolute file:// URI.\n      return new Uri(scheme: \"file\", pathSegments: path.split(sep));\n    } else {\n      // Relative URI.\n      return new Uri(pathSegments: path.split(sep));\n    }\n  }\n\n  static _makeWindowsFileUrl(String path) {\n    if (path.startsWith(\"\\\\\\\\?\\\\\")) {\n      if (path.startsWith(\"\\\\\\\\?\\\\UNC\\\\\")) {\n        path = \"\\\\${path.substring(7)}\";\n      } else {\n        path = path.substring(4);\n        if (path.length < 3 ||\n            path.codeUnitAt(1) != _COLON ||\n            path.codeUnitAt(2) != _BACKSLASH) {\n          throw new ArgumentError(\n              \"Windows paths with \\\\\\\\?\\\\ prefix must be absolute\");\n        }\n      }\n    } else {\n      path = path.replaceAll(\"/\", \"\\\\\");\n    }\n    String sep = \"\\\\\";\n    if (path.length > 1 && path[1] == \":\") {\n      _checkWindowsDriveLetter(path.codeUnitAt(0), true);\n      if (path.length == 2 || path.codeUnitAt(2) != _BACKSLASH) {\n        throw new ArgumentError(\n            \"Windows paths with drive letter must be absolute\");\n      }\n      // Absolute file://C:/ URI.\n      var pathSegments = path.split(sep);\n      _checkWindowsPathReservedCharacters(pathSegments, true, 1);\n      return new Uri(scheme: \"file\", pathSegments: pathSegments);\n    }\n\n    if (path.length > 0 && path[0] == sep) {\n      if (path.length > 1 && path[1] == sep) {\n        // Absolute file:// URI with host.\n        int pathStart = path.indexOf(\"\\\\\", 2);\n        String hostPart =\n            pathStart == -1 ? path.substring(2) : path.substring(2, pathStart);\n        String pathPart =\n            pathStart == -1 ? \"\" : path.substring(pathStart + 1);\n        var pathSegments = pathPart.split(sep);\n        _checkWindowsPathReservedCharacters(pathSegments, true);\n        return new Uri(\n            scheme: \"file\", host: hostPart, pathSegments: pathSegments);\n      } else {\n        // Absolute file:// URI.\n        var pathSegments = path.split(sep);\n        _checkWindowsPathReservedCharacters(pathSegments, true);\n        return new Uri(scheme: \"file\", pathSegments: pathSegments);\n      }\n    } else {\n      // Relative URI.\n      var pathSegments = path.split(sep);\n      _checkWindowsPathReservedCharacters(pathSegments, true);\n      return new Uri(pathSegments: pathSegments);\n    }\n  }\n\n  /**\n   * Returns a new `Uri` based on this one, but with some parts replaced.\n   *\n   * This method takes the same parameters as the [new Uri] constructor,\n   * and they have the same meaning.\n   *\n   * At most one of [path] and [pathSegments] must be provided.\n   * Likewise, at most one of [query] and [queryParameters] must be provided.\n   *\n   * Each part that is not provided will default to the corresponding\n   * value from this `Uri` instead.\n   *\n   * This method is different from [Uri.resolve] which overrides in a\n   * hierarchial manner,\n   * and can instead replace each part of a `Uri` individually.\n   *\n   * Example:\n   *\n   *     Uri uri1 = Uri.parse(\"a://b@c:4/d/e?f#g\");\n   *     Uri uri2 = uri1.replace(scheme: \"A\", path: \"D/E/E\", fragment: \"G\");\n   *     print(uri2);  // prints \"A://b@c:4/D/E/E/?f#G\"\n   *\n   * This method acts similarly to using the `new Uri` constructor with\n   * some of the arguments taken from this `Uri` . Example:\n   *\n   *     Uri uri3 = new Uri(\n   *         scheme: \"A\",\n   *         userInfo: uri1.userInfo,\n   *         host: uri1.host,\n   *         port: uri1.port,\n   *         path: \"D/E/E\",\n   *         query: uri1.query,\n   *         fragment: \"G\");\n   *     print(uri3);  // prints \"A://b@c:4/D/E/E/?f#G\"\n   *     print(uri2 == uri3);  // prints true.\n   *\n   * Using this method can be seen as a shorthand for the `Uri` constructor\n   * call above, but may also be slightly faster because the parts taken\n   * from this `Uri` need not be checked for validity again.\n   */\n  Uri replace({String scheme,\n               String userInfo,\n               String host,\n               int port,\n               String path,\n               Iterable<String> pathSegments,\n               String query,\n               Map<String, String> queryParameters,\n               String fragment}) {\n    // Set to true if the scheme has (potentially) changed.\n    // In that case, the default port may also have changed and we need\n    // to check even the existing port.\n    bool schemeChanged = false;\n    if (scheme != null) {\n      scheme = _makeScheme(scheme, scheme.length);\n      schemeChanged = true;\n    } else {\n      scheme = this.scheme;\n    }\n    bool isFile = (scheme == \"file\");\n    if (userInfo != null) {\n      userInfo = _makeUserInfo(userInfo, 0, userInfo.length);\n    } else {\n      userInfo = this.userInfo;\n    }\n    if (port != null) {\n      port = _makePort(port, scheme);\n    } else {\n      port = this.port;\n      if (schemeChanged) {\n        // The default port might have changed.\n        port = _makePort(port, scheme);\n      }\n    }\n    if (host != null) {\n      host = _makeHost(host, 0, host.length, false);\n    } else if (this.hasAuthority) {\n      host = this.host;\n    } else if (userInfo.isNotEmpty || port != null || isFile) {\n      host = \"\";\n    }\n\n    bool ensureLeadingSlash = (host != null);\n    if (path != null || pathSegments != null) {\n      path = _makePath(path, 0, _stringOrNullLength(path), pathSegments,\n                       ensureLeadingSlash, isFile);\n    } else {\n      path = this.path;\n      if ((isFile || (ensureLeadingSlash && !path.isEmpty)) &&\n          !path.startsWith('/')) {\n        path = \"/$path\";\n      }\n    }\n\n    if (query != null || queryParameters != null) {\n      query = _makeQuery(query, 0, _stringOrNullLength(query), queryParameters);\n    } else if (this.hasQuery) {\n      query = this.query;\n    }\n\n    if (fragment != null) {\n      fragment = _makeFragment(fragment, 0, fragment.length);\n    } else if (this.hasFragment) {\n      fragment = this.fragment;\n    }\n\n    return new Uri._internal(\n        scheme, userInfo, host, port, path, query, fragment);\n  }\n\n  /**\n   * Returns the URI path split into its segments. Each of the\n   * segments in the returned list have been decoded. If the path is\n   * empty the empty list will be returned. A leading slash `/` does\n   * not affect the segments returned.\n   *\n   * The returned list is unmodifiable and will throw [UnsupportedError] on any\n   * calls that would mutate it.\n   */\n  List<String> get pathSegments {\n    if (_pathSegments == null) {\n      var pathToSplit = !path.isEmpty && path.codeUnitAt(0) == _SLASH\n                        ? path.substring(1)\n                        : path;\n      _pathSegments = new UnmodifiableListView(\n        pathToSplit == \"\" ? const<String>[]\n                          : pathToSplit.split(\"/\")\n                                       .map(Uri.decodeComponent)\n                                       .toList(growable: false));\n    }\n    return _pathSegments;\n  }\n\n  /**\n   * Returns the URI query split into a map according to the rules\n   * specified for FORM post in the [HTML 4.01 specification section 17.13.4]\n   * (http://www.w3.org/TR/REC-html40/interact/forms.html#h-17.13.4\n   * \"HTML 4.01 section 17.13.4\"). Each key and value in the returned map\n   * has been decoded. If there is no query the empty map is returned.\n   *\n   * Keys in the query string that have no value are mapped to the\n   * empty string.\n   *\n   * The returned map is unmodifiable and will throw [UnsupportedError] on any\n   * calls that would mutate it.\n   */\n  Map<String, String> get queryParameters {\n    if (_queryParameters == null) {\n      _queryParameters = new UnmodifiableMapView(splitQueryString(query));\n    }\n    return _queryParameters;\n  }\n\n  static int _makePort(int port, String scheme) {\n    // Perform scheme specific normalization.\n    if (port != null && port == _defaultPort(scheme)) return null;\n    return port;\n  }\n\n  /**\n   * Check and normalize a most name.\n   *\n   * If the host name starts and ends with '[' and ']', it is considered an\n   * IPv6 address. If [strictIPv6] is false, the address is also considered\n   * an IPv6 address if it contains any ':' character.\n   *\n   * If it is not an IPv6 address, it is case- and escape-normalized.\n   * This escapes all characters not valid in a reg-name,\n   * and converts all non-escape upper-case letters to lower-case.\n   */\n  static String _makeHost(String host, int start, int end, bool strictIPv6) {\n    // TODO(lrn): Should we normalize IPv6 addresses according to RFC 5952?\n    if (host == null) return null;\n    if (start == end) return \"\";\n    // Host is an IPv6 address if it starts with '[' or contains a colon.\n    if (host.codeUnitAt(start) == _LEFT_BRACKET) {\n      if (host.codeUnitAt(end - 1) != _RIGHT_BRACKET) {\n        _fail(host, start, 'Missing end `]` to match `[` in host');\n      }\n      parseIPv6Address(host, start + 1, end - 1);\n      // RFC 5952 requires hex digits to be lower case.\n      return host.substring(start, end).toLowerCase();\n    }\n    if (!strictIPv6) {\n      // TODO(lrn): skip if too short to be a valid IPv6 address?\n      for (int i = start; i < end; i++) {\n        if (host.codeUnitAt(i) == _COLON) {\n          parseIPv6Address(host, start, end);\n          return '[$host]';\n        }\n      }\n    }\n    return _normalizeRegName(host, start, end);\n  }\n\n  static bool _isRegNameChar(int char) {\n    return char < 127 && (_regNameTable[char >> 4] & (1 << (char & 0xf))) != 0;\n  }\n\n  /**\n   * Validates and does case- and percent-encoding normalization.\n   *\n   * The [host] must be an RFC3986 \"reg-name\". It is converted\n   * to lower case, and percent escapes are converted to either\n   * lower case unreserved characters or upper case escapes.\n   */\n  static String _normalizeRegName(String host, int start, int end) {\n    StringBuffer buffer;\n    int sectionStart = start;\n    int index = start;\n    // Whether all characters between sectionStart and index are normalized,\n    bool isNormalized = true;\n\n    while (index < end) {\n      int char = host.codeUnitAt(index);\n      if (char == _PERCENT) {\n        // The _regNameTable contains \"%\", so we check that first.\n        String replacement = _normalizeEscape(host, index, true);\n        if (replacement == null && isNormalized) {\n          index += 3;\n          continue;\n        }\n        if (buffer == null) buffer = new StringBuffer();\n        String slice = host.substring(sectionStart, index);\n        if (!isNormalized) slice = slice.toLowerCase();\n        buffer.write(slice);\n        int sourceLength = 3;\n        if (replacement == null) {\n          replacement = host.substring(index, index + 3);\n        } else if (replacement == \"%\") {\n          replacement = \"%25\";\n          sourceLength = 1;\n        }\n        buffer.write(replacement);\n        index += sourceLength;\n        sectionStart = index;\n        isNormalized = true;\n      } else if (_isRegNameChar(char)) {\n        if (isNormalized && _UPPER_CASE_A <= char && _UPPER_CASE_Z >= char) {\n          // Put initial slice in buffer and continue in non-normalized mode\n          if (buffer == null) buffer = new StringBuffer();\n          if (sectionStart < index) {\n            buffer.write(host.substring(sectionStart, index));\n            sectionStart = index;\n          }\n          isNormalized = false;\n        }\n        index++;\n      } else if (_isGeneralDelimiter(char)) {\n        _fail(host, index, \"Invalid character\");\n      } else {\n        int sourceLength = 1;\n        if ((char & 0xFC00) == 0xD800 && (index + 1) < end) {\n          int tail = host.codeUnitAt(index + 1);\n          if ((tail & 0xFC00) == 0xDC00) {\n            char = 0x10000 | ((char & 0x3ff) << 10) | (tail & 0x3ff);\n            sourceLength = 2;\n          }\n        }\n        if (buffer == null) buffer = new StringBuffer();\n        String slice = host.substring(sectionStart, index);\n        if (!isNormalized) slice = slice.toLowerCase();\n        buffer.write(slice);\n        buffer.write(_escapeChar(char));\n        index += sourceLength;\n        sectionStart = index;\n      }\n    }\n    if (buffer == null) return host.substring(start, end);\n    if (sectionStart < end) {\n      String slice = host.substring(sectionStart, end);\n      if (!isNormalized) slice = slice.toLowerCase();\n      buffer.write(slice);\n    }\n    return buffer.toString();\n  }\n\n  /**\n   * Validates scheme characters and does case-normalization.\n   *\n   * Schemes are converted to lower case. They cannot contain escapes.\n   */\n  static String _makeScheme(String scheme, int end) {\n    if (end == 0) return \"\";\n    int char = scheme.codeUnitAt(0);\n    if (!_isAlphabeticCharacter(char)) {\n      _fail(scheme, 0, \"Scheme not starting with alphabetic character\");\n    }\n    bool allLowercase = char >= _LOWER_CASE_A;\n    for (int i = 0; i < end; i++) {\n      int codeUnit = scheme.codeUnitAt(i);\n      if (!_isSchemeCharacter(codeUnit)) {\n        _fail(scheme, i, \"Illegal scheme character\");\n      }\n      if (_LOWER_CASE_A <= char && _LOWER_CASE_Z >= char) {\n        allLowercase = false;\n      }\n    }\n    scheme = scheme.substring(0, end);\n    if (!allLowercase) scheme = scheme.toLowerCase();\n    return scheme;\n  }\n\n  static String _makeUserInfo(String userInfo, int start, int end) {\n    if (userInfo == null) return \"\";\n    return _normalize(userInfo, start, end, _userinfoTable);\n  }\n\n  static String _makePath(String path, int start, int end,\n                          Iterable<String> pathSegments,\n                          bool ensureLeadingSlash,\n                          bool isFile) {\n    if (path == null && pathSegments == null) return isFile ? \"/\" : \"\";\n    if (path != null && pathSegments != null) {\n      throw new ArgumentError('Both path and pathSegments specified');\n    }\n    var result;\n    if (path != null) {\n      result = _normalize(path, start, end, _pathCharOrSlashTable);\n    } else {\n      result = pathSegments.map((s) => _uriEncode(_pathCharTable, s)).join(\"/\");\n    }\n    if (result.isEmpty) {\n      if (isFile) return \"/\";\n    } else if ((isFile || ensureLeadingSlash) &&\n               result.codeUnitAt(0) != _SLASH) {\n      return \"/$result\";\n    }\n    return result;\n  }\n\n  static String _makeQuery(String query, int start, int end,\n                           Map<String, String> queryParameters) {\n    if (query == null && queryParameters == null) return null;\n    if (query != null && queryParameters != null) {\n      throw new ArgumentError('Both query and queryParameters specified');\n    }\n    if (query != null) return _normalize(query, start, end, _queryCharTable);\n\n    var result = new StringBuffer();\n    var first = true;\n    queryParameters.forEach((key, value) {\n      if (!first) {\n        result.write(\"&\");\n      }\n      first = false;\n      result.write(Uri.encodeQueryComponent(key));\n      if (value != null && !value.isEmpty) {\n        result.write(\"=\");\n        result.write(Uri.encodeQueryComponent(value));\n      }\n    });\n    return result.toString();\n  }\n\n  static String _makeFragment(String fragment, int start, int end) {\n    if (fragment == null) return null;\n    return _normalize(fragment, start, end, _queryCharTable);\n  }\n\n  static int _stringOrNullLength(String s) => (s == null) ? 0 : s.length;\n\n  static bool _isHexDigit(int char) {\n    if (_NINE >= char) return _ZERO <= char;\n    char |= 0x20;\n    return _LOWER_CASE_A <= char && _LOWER_CASE_F >= char;\n  }\n\n  static int _hexValue(int char) {\n    assert(_isHexDigit(char));\n    if (_NINE >= char) return char - _ZERO;\n    char |= 0x20;\n    return char - (_LOWER_CASE_A - 10);\n  }\n\n  /**\n   * Performs RFC 3986 Percent-Encoding Normalization.\n   *\n   * Returns a replacement string that should be replace the original escape.\n   * Returns null if no replacement is necessary because the escape is\n   * not for an unreserved character and is already non-lower-case.\n   *\n   * Returns \"%\" if the escape is invalid (not two valid hex digits following\n   * the percent sign). The calling code should replace the percent\n   * sign with \"%25\", but leave the following two characters unmodified.\n   *\n   * If [lowerCase] is true, a single character returned is always lower case,\n   */\n  static String _normalizeEscape(String source, int index, bool lowerCase) {\n    assert(source.codeUnitAt(index) == _PERCENT);\n    if (index + 2 >= source.length) {\n      return \"%\";  // Marks the escape as invalid.\n    }\n    int firstDigit = source.codeUnitAt(index + 1);\n    int secondDigit = source.codeUnitAt(index + 2);\n    if (!_isHexDigit(firstDigit) || !_isHexDigit(secondDigit)) {\n      return \"%\";  // Marks the escape as invalid.\n    }\n    int value = _hexValue(firstDigit) * 16 + _hexValue(secondDigit);\n    if (_isUnreservedChar(value)) {\n      if (lowerCase && _UPPER_CASE_A <= value && _UPPER_CASE_Z >= value) {\n        value |= 0x20;\n      }\n      return new String.fromCharCode(value);\n    }\n    if (firstDigit >= _LOWER_CASE_A || secondDigit >= _LOWER_CASE_A) {\n      // Either digit is lower case.\n      return source.substring(index, index + 3).toUpperCase();\n    }\n    // Escape is retained, and is already non-lower case, so return null to\n    // represent \"no replacement necessary\".\n    return null;\n  }\n\n  static bool _isUnreservedChar(int ch) {\n    return ch < 127 &&\n           ((_unreservedTable[ch >> 4] & (1 << (ch & 0x0f))) != 0);\n  }\n\n  static String _escapeChar(char) {\n    assert(char <= 0x10ffff);  // It's a valid unicode code point.\n    const hexDigits = \"0123456789ABCDEF\";\n    List codeUnits;\n    if (char < 0x80) {\n      // ASCII, a single percent encoded sequence.\n      codeUnits = new List(3);\n      codeUnits[0] = _PERCENT;\n      codeUnits[1] = hexDigits.codeUnitAt(char >> 4);\n      codeUnits[2] = hexDigits.codeUnitAt(char & 0xf);\n    } else {\n      // Do UTF-8 encoding of character, then percent encode bytes.\n      int flag = 0xc0;  // The high-bit markers on the first byte of UTF-8.\n      int encodedBytes = 2;\n      if (char > 0x7ff) {\n        flag = 0xe0;\n        encodedBytes = 3;\n        if (char > 0xffff) {\n          encodedBytes = 4;\n          flag = 0xf0;\n        }\n      }\n      codeUnits = new List(3 * encodedBytes);\n      int index = 0;\n      while (--encodedBytes >= 0) {\n        int byte = ((char >> (6 * encodedBytes)) & 0x3f) | flag;\n        codeUnits[index] = _PERCENT;\n        codeUnits[index + 1] = hexDigits.codeUnitAt(byte >> 4);\n        codeUnits[index + 2] = hexDigits.codeUnitAt(byte & 0xf);\n        index += 3;\n        flag = 0x80;  // Following bytes have only high bit set.\n      }\n    }\n    return new String.fromCharCodes(codeUnits);\n  }\n\n  /**\n   * Runs through component checking that each character is valid and\n   * normalize percent escapes.\n   *\n   * Uses [charTable] to check if a non-`%` character is allowed.\n   * Each `%` character must be followed by two hex digits.\n   * If the hex-digits are lower case letters, they are converted to\n   * upper case.\n   */\n  static String _normalize(String component, int start, int end,\n                           List<int> charTable) {\n    StringBuffer buffer;\n    int sectionStart = start;\n    int index = start;\n    // Loop while characters are valid and escapes correct and upper-case.\n    while (index < end) {\n      int char = component.codeUnitAt(index);\n      if (char < 127 && (charTable[char >> 4] & (1 << (char & 0x0f))) != 0) {\n        index++;\n      } else {\n        String replacement;\n        int sourceLength;\n        if (char == _PERCENT) {\n          replacement = _normalizeEscape(component, index, false);\n          // Returns null if we should keep the existing escape.\n          if (replacement == null) {\n            index += 3;\n            continue;\n          }\n          // Returns \"%\" if we should escape the existing percent.\n          if (\"%\" == replacement) {\n            replacement = \"%25\";\n            sourceLength = 1;\n          } else {\n            sourceLength = 3;\n          }\n        } else if (_isGeneralDelimiter(char)) {\n          _fail(component, index, \"Invalid character\");\n        } else {\n          sourceLength = 1;\n          if ((char & 0xFC00) == 0xD800) {\n            // Possible lead surrogate.\n            if (index + 1 < end) {\n              int tail = component.codeUnitAt(index + 1);\n              if ((tail & 0xFC00) == 0xDC00) {\n                // Tail surrogat.\n                sourceLength = 2;\n                char = 0x10000 | ((char & 0x3ff) << 10) | (tail & 0x3ff);\n              }\n            }\n          }\n          replacement = _escapeChar(char);\n        }\n        if (buffer == null) buffer = new StringBuffer();\n        buffer.write(component.substring(sectionStart, index));\n        buffer.write(replacement);\n        index += sourceLength;\n        sectionStart = index;\n      }\n    }\n    if (buffer == null) {\n      // Makes no copy if start == 0 and end == component.length.\n      return component.substring(start, end);\n    }\n    if (sectionStart < end) {\n      buffer.write(component.substring(sectionStart, end));\n    }\n    return buffer.toString();\n  }\n\n  static bool _isSchemeCharacter(int ch) {\n    return ch < 128 && ((_schemeTable[ch >> 4] & (1 << (ch & 0x0f))) != 0);\n  }\n\n  static bool _isGeneralDelimiter(int ch) {\n    return ch <= _RIGHT_BRACKET &&\n        ((_genDelimitersTable[ch >> 4] & (1 << (ch & 0x0f))) != 0);\n  }\n\n  /**\n   * Returns whether the URI is absolute.\n   */\n  bool get isAbsolute => scheme != \"\" && fragment == \"\";\n\n  String _merge(String base, String reference) {\n    if (base == \"\") return \"/$reference\";\n    return \"${base.substring(0, base.lastIndexOf(\"/\") + 1)}$reference\";\n  }\n\n  bool _hasDotSegments(String path) {\n    if (path.length > 0 && path.codeUnitAt(0) == _COLON) return true;\n    int index = path.indexOf(\"/.\");\n    return index != -1;\n  }\n\n  String _removeDotSegments(String path) {\n    if (!_hasDotSegments(path)) return path;\n    List<String> output = [];\n    bool appendSlash = false;\n    for (String segment in path.split(\"/\")) {\n      appendSlash = false;\n      if (segment == \"..\") {\n        if (!output.isEmpty &&\n            ((output.length != 1) || (output[0] != \"\"))) output.removeLast();\n        appendSlash = true;\n      } else if (\".\" == segment) {\n        appendSlash = true;\n      } else {\n        output.add(segment);\n      }\n    }\n    if (appendSlash) output.add(\"\");\n    return output.join(\"/\");\n  }\n\n  /**\n   * Resolve [reference] as an URI relative to `this`.\n   *\n   * First turn [reference] into a URI using [Uri.parse]. Then resolve the\n   * resulting URI relative to `this`.\n   *\n   * Returns the resolved URI.\n   *\n   * See [resolveUri] for details.\n   */\n  Uri resolve(String reference) {\n    return resolveUri(Uri.parse(reference));\n  }\n\n  /**\n   * Resolve [reference] as an URI relative to `this`.\n   *\n   * Returns the resolved URI.\n   *\n   * The algorithm for resolving a reference is described in\n   * [RFC-3986 Section 5]\n   * (http://tools.ietf.org/html/rfc3986#section-5 \"RFC-1123\").\n   */\n  Uri resolveUri(Uri reference) {\n    // From RFC 3986.\n    String targetScheme;\n    String targetUserInfo = \"\";\n    String targetHost;\n    int targetPort;\n    String targetPath;\n    String targetQuery;\n    if (reference.scheme.isNotEmpty) {\n      targetScheme = reference.scheme;\n      if (reference.hasAuthority) {\n        targetUserInfo = reference.userInfo;\n        targetHost = reference.host;\n        targetPort = reference.hasPort ? reference.port : null;\n      }\n      targetPath = _removeDotSegments(reference.path);\n      if (reference.hasQuery) {\n        targetQuery = reference.query;\n      }\n    } else {\n      targetScheme = this.scheme;\n      if (reference.hasAuthority) {\n        targetUserInfo = reference.userInfo;\n        targetHost = reference.host;\n        targetPort = _makePort(reference.hasPort ? reference.port : null,\n                               targetScheme);\n        targetPath = _removeDotSegments(reference.path);\n        if (reference.hasQuery) targetQuery = reference.query;\n      } else {\n        if (reference.path == \"\") {\n          targetPath = this._path;\n          if (reference.hasQuery) {\n            targetQuery = reference.query;\n          } else {\n            targetQuery = this._query;\n          }\n        } else {\n          if (reference.path.startsWith(\"/\")) {\n            targetPath = _removeDotSegments(reference.path);\n          } else {\n            targetPath = _removeDotSegments(_merge(this._path, reference.path));\n          }\n          if (reference.hasQuery) targetQuery = reference.query;\n        }\n        targetUserInfo = this._userInfo;\n        targetHost = this._host;\n        targetPort = this._port;\n      }\n    }\n    String fragment = reference.hasFragment ? reference.fragment : null;\n    return new Uri._internal(targetScheme,\n                             targetUserInfo,\n                             targetHost,\n                             targetPort,\n                             targetPath,\n                             targetQuery,\n                             fragment);\n  }\n\n  /**\n   * Returns whether the URI has an [authority] component.\n   */\n  bool get hasAuthority => _host != null;\n\n  /**\n   * Returns whether the URI has an explicit port.\n   *\n   * If the port number is the default port number\n   * (zero for unrecognized schemes, with http (80) and https (443) being\n   * recognized),\n   * then the port is made implicit and omitted from the URI.\n   */\n  bool get hasPort => _port != null;\n\n  /**\n   * Returns whether the URI has a query part.\n   */\n  bool get hasQuery => _query != null;\n\n  /**\n   * Returns whether the URI has a fragment part.\n   */\n  bool get hasFragment => _fragment != null;\n\n  /**\n   * Returns the origin of the URI in the form scheme://host:port for the\n   * schemes http and https.\n   *\n   * It is an error if the scheme is not \"http\" or \"https\".\n   *\n   * See: http://www.w3.org/TR/2011/WD-html5-20110405/origin-0.html#origin\n   */\n  String get origin {\n    if (scheme == \"\" || _host == null || _host == \"\") {\n      throw new StateError(\"Cannot use origin without a scheme: $this\");\n    }\n    if (scheme != \"http\" && scheme != \"https\") {\n      throw new StateError(\n        \"Origin is only applicable schemes http and https: $this\");\n    }\n    if (_port == null) return \"$scheme://$_host\";\n    return \"$scheme://$_host:$_port\";\n  }\n\n  /**\n   * Returns the file path from a file URI.\n   *\n   * The returned path has either Windows or non-Windows\n   * semantics.\n   *\n   * For non-Windows semantics the slash (\"/\") is used to separate\n   * path segments.\n   *\n   * For Windows semantics the backslash (\"\\\") separator is used to\n   * separate path segments.\n   *\n   * If the URI is absolute the path starts with a path separator\n   * unless Windows semantics is used and the first path segment is a\n   * drive letter. When Windows semantics is used a host component in\n   * the uri in interpreted as a file server and a UNC path is\n   * returned.\n   *\n   * The default for whether to use Windows or non-Windows semantics\n   * determined from the platform Dart is running on. When running in\n   * the standalone VM this is detected by the VM based on the\n   * operating system. When running in a browser non-Windows semantics\n   * is always used.\n   *\n   * To override the automatic detection of which semantics to use pass\n   * a value for [windows]. Passing `true` will use Windows\n   * semantics and passing `false` will use non-Windows semantics.\n   *\n   * If the URI ends with a slash (i.e. the last path component is\n   * empty) the returned file path will also end with a slash.\n   *\n   * With Windows semantics URIs starting with a drive letter cannot\n   * be relative to the current drive on the designated drive. That is\n   * for the URI `file:///c:abc` calling `toFilePath` will throw as a\n   * path segment cannot contain colon on Windows.\n   *\n   * Examples using non-Windows semantics (resulting of calling\n   * toFilePath in comment):\n   *\n   *     Uri.parse(\"xxx/yyy\");  // xxx/yyy\n   *     Uri.parse(\"xxx/yyy/\");  // xxx/yyy/\n   *     Uri.parse(\"file:///xxx/yyy\");  // /xxx/yyy\n   *     Uri.parse(\"file:///xxx/yyy/\");  // /xxx/yyy/\n   *     Uri.parse(\"file:///C:\");  // /C:\n   *     Uri.parse(\"file:///C:a\");  // /C:a\n   *\n   * Examples using Windows semantics (resulting URI in comment):\n   *\n   *     Uri.parse(\"xxx/yyy\");  // xxx\\yyy\n   *     Uri.parse(\"xxx/yyy/\");  // xxx\\yyy\\\n   *     Uri.parse(\"file:///xxx/yyy\");  // \\xxx\\yyy\n   *     Uri.parse(\"file:///xxx/yyy/\");  // \\xxx\\yyy/\n   *     Uri.parse(\"file:///C:/xxx/yyy\");  // C:\\xxx\\yyy\n   *     Uri.parse(\"file:C:xxx/yyy\");  // Throws as a path segment\n   *                                   // cannot contain colon on Windows.\n   *     Uri.parse(\"file://server/share/file\");  // \\\\server\\share\\file\n   *\n   * If the URI is not a file URI calling this throws\n   * [UnsupportedError].\n   *\n   * If the URI cannot be converted to a file path calling this throws\n   * [UnsupportedError].\n   */\n  String toFilePath({bool windows}) {\n    if (scheme != \"\" && scheme != \"file\") {\n      throw new UnsupportedError(\n          \"Cannot extract a file path from a $scheme URI\");\n    }\n    if (query != \"\") {\n      throw new UnsupportedError(\n          \"Cannot extract a file path from a URI with a query component\");\n    }\n    if (fragment != \"\") {\n      throw new UnsupportedError(\n          \"Cannot extract a file path from a URI with a fragment component\");\n    }\n    if (windows == null) windows = _isWindows;\n    return windows ? _toWindowsFilePath() : _toFilePath();\n  }\n\n  String _toFilePath() {\n    if (host != \"\") {\n      throw new UnsupportedError(\n          \"Cannot extract a non-Windows file path from a file URI \"\n          \"with an authority\");\n    }\n    _checkNonWindowsPathReservedCharacters(pathSegments, false);\n    var result = new StringBuffer();\n    if (_isPathAbsolute) result.write(\"/\");\n    result.writeAll(pathSegments, \"/\");\n    return result.toString();\n  }\n\n  String _toWindowsFilePath() {\n    bool hasDriveLetter = false;\n    var segments = pathSegments;\n    if (segments.length > 0 &&\n        segments[0].length == 2 &&\n        segments[0].codeUnitAt(1) == _COLON) {\n      _checkWindowsDriveLetter(segments[0].codeUnitAt(0), false);\n      _checkWindowsPathReservedCharacters(segments, false, 1);\n      hasDriveLetter = true;\n    } else {\n      _checkWindowsPathReservedCharacters(segments, false);\n    }\n    var result = new StringBuffer();\n    if (_isPathAbsolute && !hasDriveLetter) result.write(\"\\\\\");\n    if (host != \"\") {\n      result.write(\"\\\\\");\n      result.write(host);\n      result.write(\"\\\\\");\n    }\n    result.writeAll(segments, \"\\\\\");\n    if (hasDriveLetter && segments.length == 1) result.write(\"\\\\\");\n    return result.toString();\n  }\n\n  bool get _isPathAbsolute {\n    if (path == null || path.isEmpty) return false;\n    return path.startsWith('/');\n  }\n\n  void _writeAuthority(StringSink ss) {\n    if (_userInfo.isNotEmpty) {\n      ss.write(_userInfo);\n      ss.write(\"@\");\n    }\n    if (_host != null) ss.write(_host);\n    if (_port != null) {\n      ss.write(\":\");\n      ss.write(_port);\n    }\n  }\n\n  String toString() {\n    StringBuffer sb = new StringBuffer();\n    _addIfNonEmpty(sb, scheme, scheme, ':');\n    if (hasAuthority || path.startsWith(\"//\") || (scheme == \"file\")) {\n      // File URIS always have the authority, even if it is empty.\n      // The empty URI means \"localhost\".\n      sb.write(\"//\");\n      _writeAuthority(sb);\n    }\n    sb.write(path);\n    if (_query != null) { sb..write(\"?\")..write(_query); }\n    if (_fragment != null) { sb..write(\"#\")..write(_fragment); }\n    return sb.toString();\n  }\n\n  bool operator==(other) {\n    if (other is! Uri) return false;\n    Uri uri = other;\n    return scheme == uri.scheme &&\n        hasAuthority == uri.hasAuthority &&\n        userInfo == uri.userInfo &&\n        host == uri.host &&\n        port == uri.port &&\n        path == uri.path &&\n        hasQuery == uri.hasQuery &&\n        query == uri.query &&\n        hasFragment == uri.hasFragment &&\n        fragment == uri.fragment;\n  }\n\n  int get hashCode {\n    int combine(part, current) {\n      // The sum is truncated to 30 bits to make sure it fits into a Smi.\n      return (current * 31 + part.hashCode) & 0x3FFFFFFF;\n    }\n    return combine(scheme, combine(userInfo, combine(host, combine(port,\n        combine(path, combine(query, combine(fragment, 1)))))));\n  }\n\n  static void _addIfNonEmpty(StringBuffer sb, String test,\n                             String first, String second) {\n    if (\"\" != test) {\n      sb.write(first);\n      sb.write(second);\n    }\n  }\n\n  /**\n   * Encode the string [component] using percent-encoding to make it\n   * safe for literal use as a URI component.\n   *\n   * All characters except uppercase and lowercase letters, digits and\n   * the characters `-_.!~*'()` are percent-encoded. This is the\n   * set of characters specified in RFC 2396 and the which is\n   * specified for the encodeUriComponent in ECMA-262 version 5.1.\n   *\n   * When manually encoding path segments or query components remember\n   * to encode each part separately before building the path or query\n   * string.\n   *\n   * For encoding the query part consider using\n   * [encodeQueryComponent].\n   *\n   * To avoid the need for explicitly encoding use the [pathSegments]\n   * and [queryParameters] optional named arguments when constructing\n   * a [Uri].\n   */\n  static String encodeComponent(String component) {\n    return _uriEncode(_unreserved2396Table, component);\n  }\n\n  /**\n   * Encode the string [component] according to the HTML 4.01 rules\n   * for encoding the posting of a HTML form as a query string\n   * component.\n   *\n   * Encode the string [component] according to the HTML 4.01 rules\n   * for encoding the posting of a HTML form as a query string\n   * component.\n\n   * The component is first encoded to bytes using [encoding].\n   * The default is to use [UTF8] encoding, which preserves all\n   * the characters that don't need encoding.\n\n   * Then the resulting bytes are \"percent-encoded\". This transforms\n   * spaces (U+0020) to a plus sign ('+') and all bytes that are not\n   * the ASCII decimal digits, letters or one of '-._~' are written as\n   * a percent sign '%' followed by the two-digit hexadecimal\n   * representation of the byte.\n\n   * Note that the set of characters which are percent-encoded is a\n   * superset of what HTML 4.01 requires, since it refers to RFC 1738\n   * for reserved characters.\n   *\n   * When manually encoding query components remember to encode each\n   * part separately before building the query string.\n   *\n   * To avoid the need for explicitly encoding the query use the\n   * [queryParameters] optional named arguments when constructing a\n   * [Uri].\n   *\n   * See http://www.w3.org/TR/html401/interact/forms.html#h-17.13.4.2 for more\n   * details.\n   */\n  static String encodeQueryComponent(String component,\n                                     {Encoding encoding: UTF8}) {\n    return _uriEncode(\n        _unreservedTable, component, encoding: encoding, spaceToPlus: true);\n  }\n\n  /**\n   * Decodes the percent-encoding in [encodedComponent].\n   *\n   * Note that decoding a URI component might change its meaning as\n   * some of the decoded characters could be characters with are\n   * delimiters for a given URI componene type. Always split a URI\n   * component using the delimiters for the component before decoding\n   * the individual parts.\n   *\n   * For handling the [path] and [query] components consider using\n   * [pathSegments] and [queryParameters] to get the separated and\n   * decoded component.\n   */\n  static String decodeComponent(String encodedComponent) {\n    return _uriDecode(encodedComponent);\n  }\n\n  /**\n   * Decodes the percent-encoding in [encodedComponent], converting\n   * pluses to spaces.\n   *\n   * It will create a byte-list of the decoded characters, and then use\n   * [encoding] to decode the byte-list to a String. The default encoding is\n   * UTF-8.\n   */\n  static String decodeQueryComponent(\n      String encodedComponent,\n      {Encoding encoding: UTF8}) {\n    return _uriDecode(encodedComponent, plusToSpace: true, encoding: encoding);\n  }\n\n  /**\n   * Encode the string [uri] using percent-encoding to make it\n   * safe for literal use as a full URI.\n   *\n   * All characters except uppercase and lowercase letters, digits and\n   * the characters `!#$&'()*+,-./:;=?@_~` are percent-encoded. This\n   * is the set of characters specified in in ECMA-262 version 5.1 for\n   * the encodeURI function .\n   */\n  static String encodeFull(String uri) {\n    return _uriEncode(_encodeFullTable, uri);\n  }\n\n  /**\n   * Decodes the percent-encoding in [uri].\n   *\n   * Note that decoding a full URI might change its meaning as some of\n   * the decoded characters could be reserved characters. In most\n   * cases an encoded URI should be parsed into components using\n   * [Uri.parse] before decoding the separate components.\n   */\n  static String decodeFull(String uri) {\n    return _uriDecode(uri);\n  }\n\n  /**\n   * Returns the [query] split into a map according to the rules\n   * specified for FORM post in the\n   * [HTML 4.01 specification section 17.13.4]\n   * (http://www.w3.org/TR/REC-html40/interact/forms.html#h-17.13.4\n   * \"HTML 4.01 section 17.13.4\"). Each key and value in the returned\n   * map has been decoded. If the [query]\n   * is the empty string an empty map is returned.\n   *\n   * Keys in the query string that have no value are mapped to the\n   * empty string.\n   *\n   * Each query component will be decoded using [encoding]. The default encoding\n   * is UTF-8.\n   */\n  static Map<String, String> splitQueryString(String query,\n                                              {Encoding encoding: UTF8}) {\n    return query.split(\"&\").fold({}, (map, element) {\n      int index = element.indexOf(\"=\");\n      if (index == -1) {\n        if (element != \"\") {\n          map[decodeQueryComponent(element, encoding: encoding)] = \"\";\n        }\n      } else if (index != 0) {\n        var key = element.substring(0, index);\n        var value = element.substring(index + 1);\n        map[Uri.decodeQueryComponent(key, encoding: encoding)] =\n            decodeQueryComponent(value, encoding: encoding);\n      }\n      return map;\n    });\n  }\n\n  /**\n   * Parse the [host] as an IP version 4 (IPv4) address, returning the address\n   * as a list of 4 bytes in network byte order (big endian).\n   *\n   * Throws a [FormatException] if [host] is not a valid IPv4 address\n   * representation.\n   */\n  static List<int> parseIPv4Address(String host) {\n    void error(String msg) {\n      throw new FormatException('Illegal IPv4 address, $msg');\n    }\n    var bytes = host.split('.');\n    if (bytes.length != 4) {\n      error('IPv4 address should contain exactly 4 parts');\n    }\n    // TODO(ajohnsen): Consider using Uint8List.\n    return bytes\n        .map((byteString) {\n          int byte = int.parse(byteString);\n          if (byte < 0 || byte > 255) {\n            error('each part must be in the range of `0..255`');\n          }\n          return byte;\n        })\n        .toList();\n  }\n\n  /**\n   * Parse the [host] as an IP version 6 (IPv6) address, returning the address\n   * as a list of 16 bytes in network byte order (big endian).\n   *\n   * Throws a [FormatException] if [host] is not a valid IPv6 address\n   * representation.\n   *\n   * Acts on the substring from [start] to [end]. If [end] is omitted, it\n   * defaults ot the end of the string.\n   *\n   * Some examples of IPv6 addresses:\n   *  * ::1\n   *  * FEDC:BA98:7654:3210:FEDC:BA98:7654:3210\n   *  * 3ffe:2a00:100:7031::1\n   *  * ::FFFF:129.144.52.38\n   *  * 2010:836B:4179::836B:4179\n   */\n  static List<int> parseIPv6Address(String host, [int start = 0, int end]) {\n    if (end == null) end = host.length;\n    // An IPv6 address consists of exactly 8 parts of 1-4 hex digits, seperated\n    // by `:`'s, with the following exceptions:\n    //\n    //  - One (and only one) wildcard (`::`) may be present, representing a fill\n    //    of 0's. The IPv6 `::` is thus 16 bytes of `0`.\n    //  - The last two parts may be replaced by an IPv4 address.\n    void error(String msg, [position]) {\n      throw new FormatException('Illegal IPv6 address, $msg', host, position);\n    }\n    int parseHex(int start, int end) {\n      if (end - start > 4) {\n        error('an IPv6 part can only contain a maximum of 4 hex digits', start);\n      }\n      int value = int.parse(host.substring(start, end), radix: 16);\n      if (value < 0 || value > (1 << 16) - 1) {\n        error('each part must be in the range of `0x0..0xFFFF`', start);\n      }\n      return value;\n    }\n    if (host.length < 2) error('address is too short');\n    List<int> parts = [];\n    bool wildcardSeen = false;\n    int partStart = start;\n    // Parse all parts, except a potential last one.\n    for (int i = start; i < end; i++) {\n      if (host.codeUnitAt(i) == _COLON) {\n        if (i == start) {\n          // If we see a `:` in the beginning, expect wildcard.\n          i++;\n          if (host.codeUnitAt(i) != _COLON) {\n            error('invalid start colon.', i);\n          }\n          partStart = i;\n        }\n        if (i == partStart) {\n          // Wildcard. We only allow one.\n          if (wildcardSeen) {\n            error('only one wildcard `::` is allowed', i);\n          }\n          wildcardSeen = true;\n          parts.add(-1);\n        } else {\n          // Found a single colon. Parse [partStart..i] as a hex entry.\n          parts.add(parseHex(partStart, i));\n        }\n        partStart = i + 1;\n      }\n    }\n    if (parts.length == 0) error('too few parts');\n    bool atEnd = (partStart == end);\n    bool isLastWildcard = (parts.last == -1);\n    if (atEnd && !isLastWildcard) {\n      error('expected a part after last `:`', end);\n    }\n    if (!atEnd) {\n      try {\n        parts.add(parseHex(partStart, end));\n      } catch (e) {\n        // Failed to parse the last chunk as hex. Try IPv4.\n        try {\n          List<int> last = parseIPv4Address(host.substring(partStart, end));\n          parts.add(last[0] << 8 | last[1]);\n          parts.add(last[2] << 8 | last[3]);\n        } catch (e) {\n          error('invalid end of IPv6 address.', partStart);\n        }\n      }\n    }\n    if (wildcardSeen) {\n      if (parts.length > 7) {\n        error('an address with a wildcard must have less than 7 parts');\n      }\n    } else if (parts.length != 8) {\n      error('an address without a wildcard must contain exactly 8 parts');\n    }\n    // TODO(ajohnsen): Consider using Uint8List.\n    List bytes = new List<int>(16);\n    for (int i = 0, index = 0; i < parts.length; i++) {\n      int value = parts[i];\n      if (value == -1) {\n        int wildCardLength = 9 - parts.length;\n        for (int j = 0; j < wildCardLength; j++) {\n          bytes[index] = 0;\n          bytes[index + 1] = 0;\n          index += 2;\n        }\n      } else {\n        bytes[index] = value >> 8;\n        bytes[index + 1] = value & 0xff;\n        index += 2;\n      }\n    }\n    return bytes;\n  }\n\n  // Frequently used character codes.\n  static const int _SPACE = 0x20;\n  static const int _DOUBLE_QUOTE = 0x22;\n  static const int _NUMBER_SIGN = 0x23;\n  static const int _PERCENT = 0x25;\n  static const int _ASTERISK = 0x2A;\n  static const int _PLUS = 0x2B;\n  static const int _SLASH = 0x2F;\n  static const int _ZERO = 0x30;\n  static const int _NINE = 0x39;\n  static const int _COLON = 0x3A;\n  static const int _LESS = 0x3C;\n  static const int _GREATER = 0x3E;\n  static const int _QUESTION = 0x3F;\n  static const int _AT_SIGN = 0x40;\n  static const int _UPPER_CASE_A = 0x41;\n  static const int _UPPER_CASE_F = 0x46;\n  static const int _UPPER_CASE_Z = 0x5A;\n  static const int _LEFT_BRACKET = 0x5B;\n  static const int _BACKSLASH = 0x5C;\n  static const int _RIGHT_BRACKET = 0x5D;\n  static const int _LOWER_CASE_A = 0x61;\n  static const int _LOWER_CASE_F = 0x66;\n  static const int _LOWER_CASE_Z = 0x7A;\n  static const int _BAR = 0x7C;\n\n  /**\n   * This is the internal implementation of JavaScript's encodeURI function.\n   * It encodes all characters in the string [text] except for those\n   * that appear in [canonicalTable], and returns the escaped string.\n   */\n  static String _uriEncode(List<int> canonicalTable,\n                           String text,\n                           {Encoding encoding: UTF8,\n                            bool spaceToPlus: false}) {\n    byteToHex(byte, buffer) {\n      const String hex = '0123456789ABCDEF';\n      buffer.writeCharCode(hex.codeUnitAt(byte >> 4));\n      buffer.writeCharCode(hex.codeUnitAt(byte & 0x0f));\n    }\n\n    // Encode the string into bytes then generate an ASCII only string\n    // by percent encoding selected bytes.\n    StringBuffer result = new StringBuffer();\n    var bytes = encoding.encode(text);\n    for (int i = 0; i < bytes.length; i++) {\n      int byte = bytes[i];\n      if (byte < 128 &&\n          ((canonicalTable[byte >> 4] & (1 << (byte & 0x0f))) != 0)) {\n        result.writeCharCode(byte);\n      } else if (spaceToPlus && byte == _SPACE) {\n        result.writeCharCode(_PLUS);\n      } else {\n        result.writeCharCode(_PERCENT);\n        byteToHex(byte, result);\n      }\n    }\n    return result.toString();\n  }\n\n  /**\n   * Convert a byte (2 character hex sequence) in string [s] starting\n   * at position [pos] to its ordinal value\n   */\n  static int _hexCharPairToByte(String s, int pos) {\n    int byte = 0;\n    for (int i = 0; i < 2; i++) {\n      var charCode = s.codeUnitAt(pos + i);\n      if (0x30 <= charCode && charCode <= 0x39) {\n        byte = byte * 16 + charCode - 0x30;\n      } else {\n        // Check ranges A-F (0x41-0x46) and a-f (0x61-0x66).\n        charCode |= 0x20;\n        if (0x61 <= charCode && charCode <= 0x66) {\n          byte = byte * 16 + charCode - 0x57;\n        } else {\n          throw new ArgumentError(\"Invalid URL encoding\");\n        }\n      }\n    }\n    return byte;\n  }\n\n  /**\n   * Uri-decode a percent-encoded string.\n   *\n   * It unescapes the string [text] and returns the unescaped string.\n   *\n   * This function is similar to the JavaScript-function `decodeURI`.\n   *\n   * If [plusToSpace] is `true`, plus characters will be converted to spaces.\n   *\n   * The decoder will create a byte-list of the percent-encoded parts, and then\n   * decode the byte-list using [encoding]. The default encodingis UTF-8.\n   */\n  static String _uriDecode(String text,\n                           {bool plusToSpace: false,\n                            Encoding encoding: UTF8}) {\n    // First check whether there is any characters which need special handling.\n    bool simple = true;\n    for (int i = 0; i < text.length && simple; i++) {\n      var codeUnit = text.codeUnitAt(i);\n      simple = codeUnit != _PERCENT && codeUnit != _PLUS;\n    }\n    List<int> bytes;\n    if (simple) {\n      if (encoding == UTF8 || encoding == LATIN1) {\n        return text;\n      } else {\n        bytes = text.codeUnits;\n      }\n    } else {\n      bytes = new List();\n      for (int i = 0; i < text.length; i++) {\n        var codeUnit = text.codeUnitAt(i);\n        if (codeUnit > 127) {\n          throw new ArgumentError(\"Illegal percent encoding in URI\");\n        }\n        if (codeUnit == _PERCENT) {\n          if (i + 3 > text.length) {\n            throw new ArgumentError('Truncated URI');\n          }\n          bytes.add(_hexCharPairToByte(text, i + 1));\n          i += 2;\n        } else if (plusToSpace && codeUnit == _PLUS) {\n          bytes.add(_SPACE);\n        } else {\n          bytes.add(codeUnit);\n        }\n      }\n    }\n    return encoding.decode(bytes);\n  }\n\n  static bool _isAlphabeticCharacter(int codeUnit)\n    => (codeUnit >= _LOWER_CASE_A && codeUnit <= _LOWER_CASE_Z) ||\n       (codeUnit >= _UPPER_CASE_A && codeUnit <= _UPPER_CASE_Z);\n\n  // Tables of char-codes organized as a bit vector of 128 bits where\n  // each bit indicate whether a character code on the 0-127 needs to\n  // be escaped or not.\n\n  // The unreserved characters of RFC 3986.\n  static const _unreservedTable = const [\n                //             LSB            MSB\n                //              |              |\n      0x0000,   // 0x00 - 0x0f  0000000000000000\n      0x0000,   // 0x10 - 0x1f  0000000000000000\n                //                           -.\n      0x6000,   // 0x20 - 0x2f  0000000000000110\n                //              0123456789\n      0x03ff,   // 0x30 - 0x3f  1111111111000000\n                //               ABCDEFGHIJKLMNO\n      0xfffe,   // 0x40 - 0x4f  0111111111111111\n                //              PQRSTUVWXYZ    _\n      0x87ff,   // 0x50 - 0x5f  1111111111100001\n                //               abcdefghijklmno\n      0xfffe,   // 0x60 - 0x6f  0111111111111111\n                //              pqrstuvwxyz   ~\n      0x47ff];  // 0x70 - 0x7f  1111111111100010\n\n  // The unreserved characters of RFC 2396.\n  static const _unreserved2396Table = const [\n                //             LSB            MSB\n                //              |              |\n      0x0000,   // 0x00 - 0x0f  0000000000000000\n      0x0000,   // 0x10 - 0x1f  0000000000000000\n                //               !     '()*  -.\n      0x6782,   // 0x20 - 0x2f  0100000111100110\n                //              0123456789\n      0x03ff,   // 0x30 - 0x3f  1111111111000000\n                //               ABCDEFGHIJKLMNO\n      0xfffe,   // 0x40 - 0x4f  0111111111111111\n                //              PQRSTUVWXYZ    _\n      0x87ff,   // 0x50 - 0x5f  1111111111100001\n                //               abcdefghijklmno\n      0xfffe,   // 0x60 - 0x6f  0111111111111111\n                //              pqrstuvwxyz   ~\n      0x47ff];  // 0x70 - 0x7f  1111111111100010\n\n  // Table of reserved characters specified by ECMAScript 5.\n  static const _encodeFullTable = const [\n                //             LSB            MSB\n                //              |              |\n      0x0000,   // 0x00 - 0x0f  0000000000000000\n      0x0000,   // 0x10 - 0x1f  0000000000000000\n                //               ! #$ &'()*+,-./\n      0xffda,   // 0x20 - 0x2f  0101101111111111\n                //              0123456789:; = ?\n      0xafff,   // 0x30 - 0x3f  1111111111110101\n                //              @ABCDEFGHIJKLMNO\n      0xffff,   // 0x40 - 0x4f  1111111111111111\n                //              PQRSTUVWXYZ    _\n      0x87ff,   // 0x50 - 0x5f  1111111111100001\n                //               abcdefghijklmno\n      0xfffe,   // 0x60 - 0x6f  0111111111111111\n                //              pqrstuvwxyz   ~\n      0x47ff];  // 0x70 - 0x7f  1111111111100010\n\n  // Characters allowed in the scheme.\n  static const _schemeTable = const [\n                //             LSB            MSB\n                //              |              |\n      0x0000,   // 0x00 - 0x0f  0000000000000000\n      0x0000,   // 0x10 - 0x1f  0000000000000000\n                //                         + -.\n      0x6800,   // 0x20 - 0x2f  0000000000010110\n                //              0123456789\n      0x03ff,   // 0x30 - 0x3f  1111111111000000\n                //               ABCDEFGHIJKLMNO\n      0xfffe,   // 0x40 - 0x4f  0111111111111111\n                //              PQRSTUVWXYZ\n      0x07ff,   // 0x50 - 0x5f  1111111111100001\n                //               abcdefghijklmno\n      0xfffe,   // 0x60 - 0x6f  0111111111111111\n                //              pqrstuvwxyz\n      0x07ff];  // 0x70 - 0x7f  1111111111100010\n\n  // Characters allowed in scheme except for upper case letters.\n  static const _schemeLowerTable = const [\n                //             LSB            MSB\n                //              |              |\n      0x0000,   // 0x00 - 0x0f  0000000000000000\n      0x0000,   // 0x10 - 0x1f  0000000000000000\n                //                         + -.\n      0x6800,   // 0x20 - 0x2f  0000000000010110\n                //              0123456789\n      0x03ff,   // 0x30 - 0x3f  1111111111000000\n                //\n      0x0000,   // 0x40 - 0x4f  0111111111111111\n                //\n      0x0000,   // 0x50 - 0x5f  1111111111100001\n                //               abcdefghijklmno\n      0xfffe,   // 0x60 - 0x6f  0111111111111111\n                //              pqrstuvwxyz\n      0x07ff];  // 0x70 - 0x7f  1111111111100010\n\n  // Sub delimiter characters combined with unreserved as of 3986.\n  // sub-delims  = \"!\" / \"$\" / \"&\" / \"'\" / \"(\" / \")\"\n  //             / \"*\" / \"+\" / \",\" / \";\" / \"=\"\n  // RFC 3986 section 2.3.\n  // unreserved  = ALPHA / DIGIT / \"-\" / \".\" / \"_\" / \"~\"\n  static const _subDelimitersTable = const [\n                //             LSB            MSB\n                //              |              |\n      0x0000,   // 0x00 - 0x0f  0000000000000000\n      0x0000,   // 0x10 - 0x1f  0000000000000000\n                //               !  $ &'()*+,-.\n      0x7fd2,   // 0x20 - 0x2f  0100101111111110\n                //              0123456789 ; =\n      0x2bff,   // 0x30 - 0x3f  1111111111010100\n                //               ABCDEFGHIJKLMNO\n      0xfffe,   // 0x40 - 0x4f  0111111111111111\n                //              PQRSTUVWXYZ    _\n      0x87ff,   // 0x50 - 0x5f  1111111111100001\n                //               abcdefghijklmno\n      0xfffe,   // 0x60 - 0x6f  0111111111111111\n                //              pqrstuvwxyz   ~\n      0x47ff];  // 0x70 - 0x7f  1111111111100010\n\n  // General delimiter characters, RFC 3986 section 2.2.\n  // gen-delims  = \":\" / \"/\" / \"?\" / \"#\" / \"[\" / \"]\" / \"@\"\n  //\n  static const _genDelimitersTable = const [\n                //             LSB            MSB\n                //              |              |\n      0x0000,   // 0x00 - 0x0f  0000000000000000\n      0x0000,   // 0x10 - 0x1f  0000000000000000\n                //                 #           /\n      0x8008,   // 0x20 - 0x2f  0001000000000001\n                //                        :    ?\n      0x8400,   // 0x30 - 0x3f  0000000000100001\n                //              @\n      0x0001,   // 0x40 - 0x4f  1000000000000000\n                //                         [ ]\n      0x2800,   // 0x50 - 0x5f  0000000000010100\n                //\n      0x0000,   // 0x60 - 0x6f  0000000000000000\n                //\n      0x0000];  // 0x70 - 0x7f  0000000000000000\n\n  // Characters allowed in the userinfo as of RFC 3986.\n  // RFC 3986 Apendix A\n  // userinfo = *( unreserved / pct-encoded / sub-delims / ':')\n  static const _userinfoTable = const [\n                //             LSB            MSB\n                //              |              |\n      0x0000,   // 0x00 - 0x0f  0000000000000000\n      0x0000,   // 0x10 - 0x1f  0000000000000000\n                //               !  $ &'()*+,-.\n      0x7fd2,   // 0x20 - 0x2f  0100101111111110\n                //              0123456789:; =\n      0x2fff,   // 0x30 - 0x3f  1111111111110100\n                //               ABCDEFGHIJKLMNO\n      0xfffe,   // 0x40 - 0x4f  0111111111111111\n                //              PQRSTUVWXYZ    _\n      0x87ff,   // 0x50 - 0x5f  1111111111100001\n                //               abcdefghijklmno\n      0xfffe,   // 0x60 - 0x6f  0111111111111111\n                //              pqrstuvwxyz   ~\n      0x47ff];  // 0x70 - 0x7f  1111111111100010\n\n  // Characters allowed in the reg-name as of RFC 3986.\n  // RFC 3986 Apendix A\n  // reg-name = *( unreserved / pct-encoded / sub-delims )\n  static const _regNameTable = const [\n                //             LSB            MSB\n                //              |              |\n      0x0000,   // 0x00 - 0x0f  0000000000000000\n      0x0000,   // 0x10 - 0x1f  0000000000000000\n                //               !  $%&'()*+,-.\n      0x7ff2,   // 0x20 - 0x2f  0100111111111110\n                //              0123456789 ; =\n      0x2bff,   // 0x30 - 0x3f  1111111111010100\n                //               ABCDEFGHIJKLMNO\n      0xfffe,   // 0x40 - 0x4f  0111111111111111\n                //              PQRSTUVWXYZ    _\n      0x87ff,   // 0x50 - 0x5f  1111111111100001\n                //               abcdefghijklmno\n      0xfffe,   // 0x60 - 0x6f  0111111111111111\n                //              pqrstuvwxyz   ~\n      0x47ff];  // 0x70 - 0x7f  1111111111100010\n\n  // Characters allowed in the path as of RFC 3986.\n  // RFC 3986 section 3.3.\n  // pchar = unreserved / pct-encoded / sub-delims / \":\" / \"@\"\n  static const _pathCharTable = const [\n                //             LSB            MSB\n                //              |              |\n      0x0000,   // 0x00 - 0x0f  0000000000000000\n      0x0000,   // 0x10 - 0x1f  0000000000000000\n                //               !  $ &'()*+,-.\n      0x7fd2,   // 0x20 - 0x2f  0100101111111110\n                //              0123456789:; =\n      0x2fff,   // 0x30 - 0x3f  1111111111110100\n                //              @ABCDEFGHIJKLMNO\n      0xffff,   // 0x40 - 0x4f  1111111111111111\n                //              PQRSTUVWXYZ    _\n      0x87ff,   // 0x50 - 0x5f  1111111111100001\n                //               abcdefghijklmno\n      0xfffe,   // 0x60 - 0x6f  0111111111111111\n                //              pqrstuvwxyz   ~\n      0x47ff];  // 0x70 - 0x7f  1111111111100010\n\n  // Characters allowed in the path as of RFC 3986.\n  // RFC 3986 section 3.3 *and* slash.\n  static const _pathCharOrSlashTable = const [\n                //             LSB            MSB\n                //              |              |\n      0x0000,   // 0x00 - 0x0f  0000000000000000\n      0x0000,   // 0x10 - 0x1f  0000000000000000\n                //               !  $ &'()*+,-./\n      0xffd2,   // 0x20 - 0x2f  0100101111111111\n                //              0123456789:; =\n      0x2fff,   // 0x30 - 0x3f  1111111111110100\n                //              @ABCDEFGHIJKLMNO\n      0xffff,   // 0x40 - 0x4f  1111111111111111\n\n                //              PQRSTUVWXYZ    _\n      0x87ff,   // 0x50 - 0x5f  1111111111100001\n                //               abcdefghijklmno\n      0xfffe,   // 0x60 - 0x6f  0111111111111111\n                //              pqrstuvwxyz   ~\n      0x47ff];  // 0x70 - 0x7f  1111111111100010\n\n  // Characters allowed in the query as of RFC 3986.\n  // RFC 3986 section 3.4.\n  // query = *( pchar / \"/\" / \"?\" )\n  static const _queryCharTable = const [\n                //             LSB            MSB\n                //              |              |\n      0x0000,   // 0x00 - 0x0f  0000000000000000\n      0x0000,   // 0x10 - 0x1f  0000000000000000\n                //               !  $ &'()*+,-./\n      0xffd2,   // 0x20 - 0x2f  0100101111111111\n                //              0123456789:; = ?\n      0xafff,   // 0x30 - 0x3f  1111111111110101\n                //              @ABCDEFGHIJKLMNO\n      0xffff,   // 0x40 - 0x4f  1111111111111111\n                //              PQRSTUVWXYZ    _\n      0x87ff,   // 0x50 - 0x5f  1111111111100001\n                //               abcdefghijklmno\n      0xfffe,   // 0x60 - 0x6f  0111111111111111\n                //              pqrstuvwxyz   ~\n      0x47ff];  // 0x70 - 0x7f  1111111111100010\n}\n\u0000","sdk:/sdk/lib/core/type.dart":"// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\npart of dart.core;\n\n/**\n * Runtime representation of a type.\n */\nabstract class Type {}\n\u0000","sdk:/sdk/lib/core/symbol.dart":"// Copyright (c) 2013, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\npart of dart.core;\n\n/// Opaque name used by mirrors, invocations and [Function.apply].\nabstract class Symbol {\n  /**\n   * Constructs a new Symbol.\n   *\n   * The name must be a valid public Dart member name,\n   * public constructor name, or library name, optionally qualified.\n   *\n   * A qualified name is a valid name preceded by a public identifier name\n   * and a '`.`', e.g., `foo.bar.baz=` is a qualified version of `baz=`.\n   * That means that the content of the [name] String must be either\n   *\n   * * a valid public Dart identifier\n   *   (that is, an identifier not starting with \"`_`\"),\n   * * such an identifier followed by \"=\" (a setter name),\n   * * the name of a declarable operator\n   *   (one of \"`+`\", \"`-`\", \"`*`\", \"`/`\", \"`%`\", \"`~/`\", \"`&`\", \"`|`\",\n   *   \"`^`\", \"`~`\", \"`<<`\", \"`>>`\", \"`<`\", \"`<=`\", \"`>`\", \"`>=`\", \"`==`\",\n   *   \"`[]`\", \"`[]=`\", or \"`unary-`\"),\n   * * any of the above preceeded by any number of qualifiers,\n   *   where a qualifier is a non-private identifier followed by '`.`',\n   * * or the empty string (the default name of a library with no library\n   *   name declaration).\n   *\n   * The following text is non-normative:\n   *\n   * Creating non-const Symbol instances may result in larger output.  If\n   * possible, use [MirrorsUsed] in \"dart:mirrors\" to specify which names might\n   * be passed to this constructor.\n   */\n  const factory Symbol(String name) = internal.Symbol;\n\n  /**\n   * Returns a hash code compatible with [operator==].\n   *\n   * Equal symbols have the same hash code.\n   */\n  int get hashCode;\n\n  /**\n   * Symbols are equal to other symbols that correspond to the same member name.\n   *\n   * Qualified member names, like `#foo.bar` are equal only if they have the\n   * same identifiers before the same final member name.\n   */\n  bool operator ==(Object other);\n}\n\u0000","sdk:/sdk/lib/core/string_sink.dart":"// Copyright (c) 2013, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\npart of dart.core;\n\nabstract class StringSink {\n\n  /**\n   * Converts [obj] to a String by invoking [Object.toString] and \n   * adds the result to `this`.\n   */\n  void write(Object obj);\n\n  /**\n   * Iterates over the given [objects] and [write]s them in sequence.\n   */\n  void writeAll(Iterable objects, [String separator = \"\"]);\n\n  /**\n   * Converts [obj] to a String by invoking [Object.toString] and \n   * adds the result to `this`, followed by a newline.\n   */\n  void writeln([Object obj = \"\"]);\n\n  /**\n   * Writes the [charCode] to `this`.\n   *\n   * This method is equivalent to `write(new String.fromCharCode(charCode))`.\n   */\n  void writeCharCode(int charCode);\n}\n\u0000","sdk:/sdk/lib/core/string_buffer.dart":"// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\npart of dart.core;\n\n/**\n * A class for concatenating strings efficiently.\n *\n * Allows for the incremental building of a string using write*() methods.\n * The strings are concatenated to a single string only when [toString] is\n * called.\n */\nclass StringBuffer implements StringSink {\n\n  /** Creates the string buffer with an initial content. */\n  external StringBuffer([Object content = \"\"]);\n\n  /**\n   * Returns the length of the content that has been accumulated so far.\n   * This is a constant-time operation.\n   */\n  external int get length;\n\n  /** Returns whether the buffer is empty. This is a constant-time operation. */\n  bool get isEmpty => length == 0;\n\n  /**\n   * Returns whether the buffer is not empty. This is a constant-time\n   * operation.\n   */\n  bool get isNotEmpty => !isEmpty;\n\n  /// Adds the contents of [obj], converted to a string, to the buffer.\n  external void write(Object obj);\n\n  /// Adds the string representation of [charCode] to the buffer.\n  external void writeCharCode(int charCode);\n\n  void writeAll(Iterable objects, [String separator = \"\"]) {\n    Iterator iterator = objects.iterator;\n    if (!iterator.moveNext()) return;\n    if (separator.isEmpty) {\n      do {\n        write(iterator.current);\n      } while (iterator.moveNext());\n    } else {\n      write(iterator.current);\n      while (iterator.moveNext()) {\n        write(separator);\n        write(iterator.current);\n      }\n    }\n  }\n\n  void writeln([Object obj = \"\"]) {\n    write(obj);\n    write(\"\\n\");\n  }\n\n  /**\n   * Clears the string buffer.\n   */\n  external void clear();\n\n  /// Returns the contents of buffer as a concatenated string.\n  external String toString();\n}\n\u0000","sdk:/sdk/lib/core/string.dart":"// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\npart of dart.core;\n\n/**\n * A sequence of characters.\n *\n * A string can be either single or multiline. Single line strings are\n * written using matching single or double quotes, and multiline strings are\n * written using triple quotes. The following are all valid Dart strings:\n *\n *     'Single quotes';\n *     \"Double quotes\";\n *     'Double quotes in \"single\" quotes';\n *     \"Single quotes in 'double' quotes\";\n *\n *     '''A\n *     multiline\n *     string''';\n *\n *     \"\"\"\n *     Another\n *     multiline\n *     string\"\"\";\n *\n * Strings are immutable. Although you cannot change a string, you can perform\n * an operation on a string and assign the result to a new string:\n *\n *     var string = 'Dart is fun';\n *     var newString = string.substring(0, 5);\n *\n * You can use the plus (`+`) operator to concatenate strings:\n *\n *     'Dart ' + 'is ' + 'fun!'; // 'Dart is fun!'\n *\n * You can also use adjacent string literals for concatenation:\n *\n *     'Dart ' 'is ' 'fun!';    // 'Dart is fun!'\n *\n * You can use `${}` to interpolate the value of Dart expressions\n * within strings. The curly braces can be omitted when evaluating identifiers:\n *\n *     string = 'dartlang';\n *     '$string has ${string.length} letters'; // 'dartlang has 8 letters'\n *\n * A string is represented by a sequence of Unicode UTF-16 code units\n * accessible through the [codeUnitAt] or the [codeUnits] members:\n *\n *     string = 'Dart';\n *     string.codeUnitAt(0); // 68\n *     string.codeUnits;     // [68, 97, 114, 116]\n *\n * The string representation of code units is accessible through the index\n * operator:\n *\n *     string[0];            // 'D'\n *\n * The characters of a string are encoded in UTF-16. Decoding UTF-16, which\n * combines surrogate pairs, yields Unicode code points. Following a similar\n * terminology to Go, we use the name 'rune' for an integer representing a\n * Unicode code point. Use the [runes] property to get the runes of a string:\n *\n *     string.runes.toList(); // [68, 97, 114, 116]\n *\n * For a character outside the Basic Multilingual Plane (plane 0) that is\n * composed of a surrogate pair, [runes] combines the pair and returns a\n * single integer.  For example, the Unicode character for a\n * musical G-clef ('𝄞') with rune value 0x1D11E consists of a UTF-16 surrogate\n * pair: `0xD834` and `0xDD1E`. Using [codeUnits] returns the surrogate pair,\n * and using `runes` returns their combined value:\n *\n *     var clef = '\\u{1D11E}';\n *     clef.codeUnits;         // [0xD834, 0xDD1E]\n *     clef.runes.toList();    // [0x1D11E]\n *\n * The String class can not be extended or implemented. Attempting to do so\n * yields a compile-time error.\n *\n * ## Other resources\n *\n * See [StringBuffer] to efficiently build a string incrementally. See\n * [RegExp] to work with regular expressions.\n *\n * Also see:\n\n * * [Dart Cookbook](https://www.dartlang.org/docs/cookbook/#strings)\n * for String examples and recipes.\n * * [Dart Up and Running]\n * (https://www.dartlang.org/docs/dart-up-and-running/contents/ch03.html#ch03-strings-and-regular-expressions)\n */\nabstract class String implements Comparable<String>, Pattern {\n  /**\n   * Allocates a new String for the specified [charCodes].\n   *\n   * The [charCodes] can be UTF-16 code units or runes. If a char-code value is\n   * 16-bit, it is copied verbatim:\n   *\n   *     new String.fromCharCodes([68]); // 'D'\n   *\n   * If a char-code value is greater than 16-bits, it is decomposed into a\n   * surrogate pair:\n   *\n   *     var clef = new String.fromCharCodes([0x1D11E]);\n   *     clef.codeUnitAt(0); // 0xD834\n   *     clef.codeUnitAt(1); // 0xDD1E\n   */\n  external factory String.fromCharCodes(Iterable<int> charCodes);\n\n  /**\n   * Allocates a new String for the specified [charCode].\n   *\n   * If the [charCode] can be represented by a single UTF-16 code unit, the new\n   * string contains a single code unit. Otherwise, the [length] is 2 and\n   * the code units form a surrogate pair. See documentation for\n   * [fromCharCodes].\n   *\n   * Creating a String with half of a surrogate pair is allowed.\n   */\n  external factory String.fromCharCode(int charCode);\n\n  /**\n   * Returns the string value of the environment declaration [name].\n   *\n   * Environment declarations are provided by the surrounding system compiling\n   * or running the Dart program. Declarations map a string key to a string\n   * value.\n   *\n   * If [name] is not declared in the environment, the result is instead\n   * [defaultValue].\n   *\n   * Example of getting a value:\n   *\n   *     const String.fromEnvironment(\"defaultFloo\", defaultValue: \"no floo\")\n   *\n   * Example of checking whether a declaration is there at all:\n   *\n   *     var isDeclared = const String.fromEnvironment(\"maybeDeclared\") != null;\n   */\n  external const factory String.fromEnvironment(String name,\n                                                {String defaultValue});\n\n  /**\n   * Gets the character (as a single-code-unit [String]) at the given [index].\n   *\n   * The returned string represents exactly one UTF-16 code unit, which may be\n   * half of a surrogate pair. A single member of a surrogate pair is an\n   * invalid UTF-16 string:\n   *\n   *     var clef = '\\u{1D11E}';\n   *     // These represent invalid UTF-16 strings.\n   *     clef[0].codeUnits;      // [0xD834]\n   *     clef[1].codeUnits;      // [0xDD1E]\n   *\n   * This method is equivalent to\n   * `new String.fromCharCode(this.codeUnitAt(index))`.\n   */\n  String operator [](int index);\n\n  /**\n   * Returns the 16-bit UTF-16 code unit at the given [index].\n   */\n  int codeUnitAt(int index);\n\n  /**\n   * The length of the string.\n   *\n   * Returns the number of UTF-16 code units in this string. The number\n   * of [runes] might be fewer, if the string contains characters outside\n   * the Basic Multilingual Plane (plane 0):\n   *\n   *     'Dart'.length;          // 4\n   *     'Dart'.runes.length;    // 4\n   *\n   *     var clef = '\\u{1D11E}';\n   *     clef.length;            // 2\n   *     clef.runes.length;      // 1\n   */\n  int get length;\n\n  /**\n   * Returns a hash code derived from the code units of the string.\n   *\n   * This is compatible with [operator==]. Strings with the same sequence\n   * of code units have the same hash code.\n   */\n  int get hashCode;\n\n  /**\n   * Returns true if other is a `String` with the same sequence of code units.\n   *\n   * This method compares each individual code unit of the strings.\n   * It does not check for Unicode equivalence.\n   * For example, both the following strings represent the string 'Amélie',\n   * but due to their different encoding, are not equal:\n   *\n   *     'Am\\xe9lie' == 'Ame\\u{301}lie'; // false\n   *\n   * The first string encodes 'é' as a single unicode code unit (also\n   * a single rune), whereas the second string encodes it as 'e' with the\n   * combining accent character '◌́'.\n   */\n  bool operator ==(Object other);\n\n  /**\n   * Returns true if this string ends with [other]. For example:\n   *\n   *     'Dart'.endsWith('t'); // true\n   */\n  bool endsWith(String other);\n\n  /**\n   * Returns true if this string starts with a match of [pattern].\n   *\n   *     var string = 'Dart';\n   *     string.startsWith('D');                       // true\n   *     string.startsWith(new RegExp(r'[A-Z][a-z]')); // true\n   *\n   * If [index] is provided, this method checks if the substring starting\n   * at that index starts with a match of [pattern]:\n   *\n   *     string.startsWith('art', 1);                  // true\n   *     string.startsWith(new RegExp(r'\\w{3}'));      // true\n   *\n   * [index] must not be negative or greater than [length].\n   *\n   * A [RegExp] containing '^' does not match if the [index] is greater than\n   * zero. The pattern works on the string as a whole, and does not extract\n   * a substring starting at [index] first:\n   *\n   *     string.startsWith(new RegExp(r'^art'), 1);    // false\n   *     string.startsWith(new RegExp(r'art'), 1);     // true\n   */\n  bool startsWith(Pattern pattern, [int index = 0]);\n\n  /**\n   * Returns the position of the first match of [pattern] in this string,\n   * starting at [start], inclusive:\n   *\n   *     var string = 'Dartisans';\n   *     string.indexOf('art');                     // 1\n   *     string.indexOf(new RegExp(r'[A-Z][a-z]')); // 0\n   *\n   * Returns -1 if no match is found:\n   *\n   *     string.indexOf(new RegExp(r'dart'));       // -1\n   *\n   * [start] must not be negative or greater than [length].\n   */\n  int indexOf(Pattern pattern, [int start]);\n\n  /**\n   * Returns the position of the last match [pattern] in this string, searching\n   * backward starting at [start], inclusive:\n   *\n   *     var string = 'Dartisans';\n   *     string.lastIndexOf('a');                    // 6\n   *     string.lastIndexOf(new RegExp(r'a(r|n)'));  // 6\n   *\n   * Returns -1 if [other] could not be found.\n   *\n   *     string.lastIndexOf(new RegExp(r'DART'));    // -1\n   *\n   * [start] must not be negative or greater than [length].\n   */\n  int lastIndexOf(Pattern pattern, [int start]);\n\n  /**\n   * Returns true if this string is empty.\n   */\n  bool get isEmpty;\n\n  /**\n   * Returns true if this string is not empty.\n   */\n  bool get isNotEmpty;\n\n  /**\n   * Creates a new string by concatenating this string with [other].\n   *\n   *     'dart' + 'lang'; // 'dartlang'\n   */\n  String operator +(String other);\n\n  /**\n   * Returns the substring of this string that extends from [startIndex],\n   * inclusive, to [endIndex], exclusive.\n   *\n   *     var string = 'dartlang';\n   *     string.substring(1);    // 'artlang'\n   *     string.substring(1, 4); // 'art'\n   */\n  String substring(int startIndex, [int endIndex]);\n\n  /**\n   * Returns the string without any leading and trailing whitespace.\n   *\n   * If the string contains leading or trailing whitespace, a new string with no\n   * leading and no trailing whitespace is returned:\n   *\n   *     '\\tDart is fun\\n'.trim(); // 'Dart is fun'\n   *\n   * Otherwise, the original string itself is returned:\n   *\n   *     var str1 = 'Dart';\n   *     var str2 = str1.trim();\n   *     identical(str1, str2);    // true\n   *\n   * Whitespace is defined by the Unicode White_Space property (as defined in\n   * version 6.2 or later) and the BOM character, 0xFEFF.\n   *\n   * Here is the list of trimmed characters (following version 6.2):\n   *\n   *     0009..000D    ; White_Space # Cc   <control-0009>..<control-000D>\n   *     0020          ; White_Space # Zs   SPACE\n   *     0085          ; White_Space # Cc   <control-0085>\n   *     00A0          ; White_Space # Zs   NO-BREAK SPACE\n   *     1680          ; White_Space # Zs   OGHAM SPACE MARK\n   *     180E          ; White_Space # Zs   MONGOLIAN VOWEL SEPARATOR\n   *     2000..200A    ; White_Space # Zs   EN QUAD..HAIR SPACE\n   *     2028          ; White_Space # Zl   LINE SEPARATOR\n   *     2029          ; White_Space # Zp   PARAGRAPH SEPARATOR\n   *     202F          ; White_Space # Zs   NARROW NO-BREAK SPACE\n   *     205F          ; White_Space # Zs   MEDIUM MATHEMATICAL SPACE\n   *     3000          ; White_Space # Zs   IDEOGRAPHIC SPACE\n   *\n   *     FEFF          ; BOM                ZERO WIDTH NO_BREAK SPACE\n   */\n  String trim();\n\n  /**\n   * Returns the string without any leading whitespace.\n   *\n   * As [trim], but only removes leading whitespace.\n   */\n  String trimLeft();\n\n  /**\n   * Returns the string without any trailing whitespace.\n   *\n   * As [trim], but only removes trailing whitespace.\n   */\n  String trimRight();\n\n  /**\n   * Creates a new string by concatenating this string with itself a number\n   * of times.\n   *\n   * The result of `str * n` is equivalent to\n   * `str + str + ...`(n times)`... + str`.\n   *\n   * Returns an empty string if [times] is zero or negative.\n   */\n  String operator *(int times);\n\n  /**\n   * Pads this string on the left if it is shorther than [width].\n   *\n   * Return a new string that prepends [padding] onto this string\n   * one time for each position the length is less than [width].\n   *\n   * If [width] is already smaller than or equal to `this.length`,\n   * no padding is added. A negative `width` is treated as zero.\n   *\n   * If [padding] has length different from 1, the result will not\n   * have length `width`. This may be useful for cases where the\n   * padding is a longer string representing a single character, like\n   * `\"&nbsp;\"` or `\"\\u{10002}`\".\n   * In that case, the user should make sure that `this.length` is\n   * the correct measure of the strings length.\n   */\n  String padLeft(int width, [String padding = ' ']);\n\n  /**\n   * Pads this string on the right if it is shorther than [width].\n   *\n   * Return a new string that appends [padding] after this string\n   * one time for each position the length is less than [width].\n   *\n   * If [width] is already smaller than or equal to `this.length`,\n   * no padding is added. A negative `width` is treated as zero.\n   *\n   * If [padding] has length different from 1, the result will not\n   * have length `width`. This may be useful for cases where the\n   * padding is a longer string representing a single character, like\n   * `\"&nbsp;\"` or `\"\\u{10002}`\".\n   * In that case, the user should make sure that `this.length` is\n   * the correct measure of the strings length.\n   */\n  String padRight(int width, [String padding = ' ']);\n\n  /**\n   * Returns true if this string contains a match of [other]:\n   *\n   *     var string = 'Dart strings';\n   *     string.contains('D');                     // true\n   *     string.contains(new RegExp(r'[A-Z]'));    // true\n   *\n   * If [startIndex] is provided, this method matches only at or after that\n   * index:\n   *\n   *     string.contains('X', 1);                  // false\n   *     string.contains(new RegExp(r'[A-Z]'), 1); // false\n   *\n   * [startIndex] must not be negative or greater than [length].\n   */\n  bool contains(Pattern other, [int startIndex = 0]);\n\n  /**\n   * Returns a new string in which  the first occurence of [from] in this string\n   * is replaced with [to]:\n   *\n   *     '0.0001'.replaceFirst(new RegExp(r'0'), ''); // '.0001'\n   */\n  String replaceFirst(Pattern from, String to);\n\n  /**\n   * Replaces all substrings that match [from] with [replace].\n   *\n   * Returns a new string in which the non-overlapping substrings matching\n   * [from] (the ones iterated by `from.allMatches(thisString)`) are replaced\n   * by the literal string [replace].\n   *\n   *     'resume'.replaceAll(new RegExp(r'e'), 'é'); // 'résumé'\n   *\n   * Notice that the [replace] string is not interpreted. If the replacement\n   * depends on the match (for example on a [RegExp]'s capture groups), use\n   * the [replaceAllMapped] method instead.\n   */\n  String replaceAll(Pattern from, String replace);\n\n  /**\n   * Replace all substrings that match [from] by a string computed from the\n   * match.\n   *\n   * Returns a new string in which the non-overlapping substrings that match\n   * [from] (the ones iterated by `from.allMatches(thisString)`) are replaced\n   * by the result of calling [replace] on the corresponding [Match] object.\n   *\n   * This can be used to replace matches with new content that depends on the\n   * match, unlike [replaceAll] where the replacement string is always the same.\n   *\n   * The [replace] function is called with the [Match] generated\n   * by the pattern, and its result is used as replacement.\n   *\n   * The function defined below converts each word in a string to simplified\n   * 'pig latin' using [replaceAllMapped]:\n   *\n   *     pigLatin(String words) => words.replaceAllMapped(\n   *         new RegExp(r'\\b(\\w*?)([aeiou]\\w*)', caseSensitive: false),\n   *         (Match m) => \"${m[2]}${m[1]}${m[1].isEmpty ? 'way' : 'ay'}\");\n   *\n   *     pigLatin('I have a secret now!'); // 'Iway avehay away ecretsay ownay!'\n   */\n  String replaceAllMapped(Pattern from, String replace(Match match));\n\n  /**\n   * Splits the string at matches of [pattern]. Returns\n   * a list of substrings.\n   *\n   * Splitting with an empty string pattern (`''`) splits at UTF-16 code unit\n   * boundaries and not at rune boundaries:\n   *\n   *     var string = 'Pub';\n   *     string.split('');                       // ['P', 'u', 'b']\n   *\n   *     string.codeUnits.map((unit) {\n   *       return new String.fromCharCode(unit);\n   *     }).toList();                            // ['P', 'u', 'b']\n   *\n   *     // String made up of two code units, but one rune.\n   *     string = '\\u{1D11E}';\n   *     string.split('').length;                 // 2\n   *\n   * You should [map] the runes unless you are certain that the string is in\n   * the basic multilingual plane (meaning that each code unit represents a\n   * rune):\n   *\n   *     string.runes.map((rune) => new String.fromCharCode(rune));\n   */\n  List<String> split(Pattern pattern);\n\n  /**\n   * Splits the string, converts its parts, and combines them into a new\n   * string.\n   *\n   * [pattern] is used to split the string into parts and separating matches.\n   *\n   * Each match is converted to a string by calling [onMatch]. If [onMatch]\n   * is omitted, the matched string is used.\n   *\n   * Each non-matched part is converted by a call to [onNonMatch]. If\n   * [onNonMatch] is omitted, the non-matching part is used.\n   *\n   * Then all the converted parts are combined into the resulting string.\n   *\n   *     'Eats shoots leaves'.splitMapJoin((new RegExp(r'shoots')),\n   *         onMatch:    (m) => '${m.group(0)}',\n   *         onNonMatch: (n) => '*'); // *shoots*\n   */\n  String splitMapJoin(Pattern pattern,\n                      {String onMatch(Match match),\n                       String onNonMatch(String nonMatch)});\n\n  /**\n   * Returns an unmodifiable list of the UTF-16 code units of this string.\n   */\n  List<int> get codeUnits;\n\n  /**\n   * Returns an [Iterable] of Unicode code-points of this string.\n   *\n   * If the string contains surrogate pairs, they are combined and returned\n   * as one integer by this iterator. Unmatched surrogate halves are treated\n   * like valid 16-bit code-units.\n   */\n  Runes get runes;\n\n  /**\n   * Converts all characters in this string to lower case.\n   * If the string is already in all lower case, this method returns [:this:].\n   *\n   *     'ALPHABET'.toLowerCase(); // 'alphabet'\n   *     'abc'.toLowerCase();      // 'abc'\n   *\n   * This function uses the language independent Unicode mapping and thus only\n   * works in some languages.\n   */\n  // TODO(floitsch): document better. (See EcmaScript for description).\n  String toLowerCase();\n\n  /**\n   * Converts all characters in this string to upper case.\n   * If the string is already in all upper case, this method returns [:this:].\n   *\n   *     'alphabet'.toUpperCase(); // 'ALPHABET'\n   *     'ABC'.toUpperCase();      // 'ABC'\n   *\n   * This function uses the language independent Unicode mapping and thus only\n   * works in some languages.\n   */\n  // TODO(floitsch): document better. (See EcmaScript for description).\n  String toUpperCase();\n}\n\n/**\n * The runes (integer Unicode code points) of a [String].\n */\nclass Runes extends IterableBase<int> {\n  final String string;\n  Runes(this.string);\n\n  RuneIterator get iterator => new RuneIterator(string);\n\n  int get last {\n    if (string.length == 0) {\n      throw new StateError('No elements.');\n    }\n    int length = string.length;\n    int code = string.codeUnitAt(length - 1);\n    if (_isTrailSurrogate(code) && string.length > 1) {\n      int previousCode = string.codeUnitAt(length - 2);\n      if (_isLeadSurrogate(previousCode)) {\n        return _combineSurrogatePair(previousCode, code);\n      }\n    }\n    return code;\n  }\n\n}\n\n// Is then code (a 16-bit unsigned integer) a UTF-16 lead surrogate.\nbool _isLeadSurrogate(int code) => (code & 0xFC00) == 0xD800;\n\n// Is then code (a 16-bit unsigned integer) a UTF-16 trail surrogate.\nbool _isTrailSurrogate(int code) => (code & 0xFC00) == 0xDC00;\n\n// Combine a lead and a trail surrogate value into a single code point.\nint _combineSurrogatePair(int start, int end) {\n  return 0x10000 + ((start & 0x3FF) << 10) + (end & 0x3FF);\n}\n\n/** [Iterator] for reading runes (integer Unicode code points) out of a Dart\n  * string.\n  */\nclass RuneIterator implements BidirectionalIterator<int> {\n  /** String being iterated. */\n  final String string;\n  /** Position before the current code point. */\n  int _position;\n  /** Position after the current code point. */\n  int _nextPosition;\n  /**\n   * Current code point.\n   *\n   * If the iterator has hit either end, the [_currentCodePoint] is null\n   * and [: _position == _nextPosition :].\n   */\n  int _currentCodePoint;\n\n  /** Create an iterator positioned at the beginning of the string. */\n  RuneIterator(String string)\n      : this.string = string, _position = 0, _nextPosition = 0;\n\n  /**\n   * Create an iterator positioned before the [index]th code unit of the string.\n   *\n   * When created, there is no [current] value.\n   * A [moveNext] will use the rune starting at [index] the current value,\n   * and a [movePrevious] will use the rune ending just before [index] as the\n   * the current value.\n   *\n   * It is an error if the [index] position is in the middle of a surrogate\n   * pair.\n   */\n  RuneIterator.at(String string, int index)\n      : string = string, _position = index, _nextPosition = index {\n    if (index < 0 || index > string.length) {\n      throw new RangeError.range(index, 0, string.length);\n    }\n    _checkSplitSurrogate(index);\n  }\n\n  /** Throw an error if the index is in the middle of a surrogate pair. */\n  void _checkSplitSurrogate(int index) {\n    if (index > 0 && index < string.length &&\n        _isLeadSurrogate(string.codeUnitAt(index - 1)) &&\n        _isTrailSurrogate(string.codeUnitAt(index))) {\n      throw new ArgumentError('Index inside surrogate pair: $index');\n    }\n  }\n\n  /**\n   * Returns the starting position of the current rune in the string.\n   *\n   * Returns null if the [current] rune is null.\n   */\n  int get rawIndex => (_position != _nextPosition) ? _position : null;\n\n  /**\n   * Resets the iterator to the rune at the specified index of the string.\n   *\n   * Setting a negative [rawIndex], or one greater than or equal to\n   * [:string.length:],\n   * is an error. So is setting it in the middle of a surrogate pair.\n   *\n   * Setting the position to the end of then string will set [current] to null.\n   */\n  void set rawIndex(int rawIndex) {\n    if (rawIndex >= string.length) {\n      throw new RangeError.range(rawIndex, 0, string.length - 1);\n    }\n    reset(rawIndex);\n    moveNext();\n  }\n\n  /**\n   * Resets the iterator to the given index into the string.\n   *\n   * After this the [current] value is unset.\n   * You must call [moveNext] make the rune at the position current,\n   * or [movePrevious] for the last rune before the position.\n   *\n   * Setting a negative [rawIndex], or one greater than [:string.length:],\n   * is an error. So is setting it in the middle of a surrogate pair.\n   */\n  void reset([int rawIndex = 0]) {\n    if (rawIndex < 0 || rawIndex > string.length) {\n      throw new RangeError.range(rawIndex, 0, string.length);\n    }\n    _checkSplitSurrogate(rawIndex);\n    _position = _nextPosition = rawIndex;\n    _currentCodePoint = null;\n  }\n\n  /** The rune (integer Unicode code point) starting at the current position in\n   *  the string.\n   */\n  int get current => _currentCodePoint;\n\n  /**\n   * The number of code units comprising the current rune.\n   *\n   * Returns zero if there is no current rune ([current] is null).\n   */\n  int get currentSize => _nextPosition - _position;\n\n  /**\n   * A string containing the current rune.\n   *\n   * For runes outside the basic multilingual plane, this will be\n   * a String of length 2, containing two code units.\n   *\n   * Returns null if [current] is null.\n   */\n  String get currentAsString {\n    if (_position == _nextPosition) return null;\n    if (_position + 1 == _nextPosition) return string[_position];\n    return string.substring(_position, _nextPosition);\n  }\n\n  bool moveNext() {\n    _position = _nextPosition;\n    if (_position == string.length) {\n      _currentCodePoint = null;\n      return false;\n    }\n    int codeUnit = string.codeUnitAt(_position);\n    int nextPosition = _position + 1;\n    if (_isLeadSurrogate(codeUnit) && nextPosition < string.length) {\n      int nextCodeUnit = string.codeUnitAt(nextPosition);\n      if (_isTrailSurrogate(nextCodeUnit)) {\n        _nextPosition = nextPosition + 1;\n        _currentCodePoint = _combineSurrogatePair(codeUnit, nextCodeUnit);\n        return true;\n      }\n    }\n    _nextPosition = nextPosition;\n    _currentCodePoint = codeUnit;\n    return true;\n  }\n\n  bool movePrevious() {\n    _nextPosition = _position;\n    if (_position == 0) {\n      _currentCodePoint = null;\n      return false;\n    }\n    int position = _position - 1;\n    int codeUnit = string.codeUnitAt(position);\n    if (_isTrailSurrogate(codeUnit) && position > 0) {\n      int prevCodeUnit = string.codeUnitAt(position - 1);\n      if (_isLeadSurrogate(prevCodeUnit)) {\n        _position = position - 1;\n        _currentCodePoint = _combineSurrogatePair(prevCodeUnit, codeUnit);\n        return true;\n      }\n    }\n    _position = position;\n    _currentCodePoint = codeUnit;\n    return true;\n  }\n}\n\u0000","sdk:/sdk/lib/core/stopwatch.dart":"// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\npart of dart.core;\n\n/**\n * A simple stopwatch interface to measure elapsed time.\n */\nclass Stopwatch {\n  /**\n   * Frequency of the elapsed counter in Hz.\n   */\n  int get frequency => _frequency;\n\n  // The _start and _stop fields capture the time when [start] and [stop]\n  // are called respectively.\n  // If _start is null, then the [Stopwatch] has not been started yet.\n  // If _stop is null, then the [Stopwatch] has not been stopped yet,\n  // or is running.\n  int _start;\n  int _stop;\n\n  /**\n   * Creates a [Stopwatch] in stopped state with a zero elapsed count.\n   *\n   * The following example shows how to start a [Stopwatch]\n   * immediately after allocation.\n   *\n   *     Stopwatch stopwatch = new Stopwatch()..start();\n   */\n  Stopwatch() {\n    _initTicker();\n  }\n\n  /**\n   * Starts the [Stopwatch].\n   *\n   * The [elapsed] count is increasing monotonically. If the [Stopwatch] has\n   * been stopped, then calling start again restarts it without resetting the\n   * [elapsed] count.\n   *\n   * If the [Stopwatch] is currently running, then calling start does nothing.\n   */\n  void start() {\n    if (isRunning) return;\n    if (_start == null) {\n      // This stopwatch has never been started.\n      _start = _now();\n    } else {\n      // Restart this stopwatch. Prepend the elapsed time to the current\n      // start time.\n      _start = _now() - (_stop - _start);\n      _stop = null;\n    }\n  }\n\n  /**\n   * Stops the [Stopwatch].\n   *\n   * The [elapsedTicks] count stops increasing after this call. If the\n   * [Stopwatch] is currently not running, then calling this method has no\n   * effect.\n   */\n  void stop() {\n    if (!isRunning) return;\n    _stop = _now();\n  }\n\n  /**\n   * Resets the [elapsed] count to zero.\n   *\n   * This method does not stop or start the [Stopwatch].\n   */\n  void reset() {\n    if (_start == null) return;\n    // If [_start] is not null, then the stopwatch had already been started. It\n    // may running right now.\n    _start = _now();\n    if (_stop != null) {\n      // The watch is not running. So simply set the [_stop] to [_start] thus\n      // having an elapsed time of 0.\n      _stop = _start;\n    }\n  }\n\n  /**\n   * Returns the elapsed number of clock ticks since calling [start] while the\n   * [Stopwatch] is running.\n   *\n   * Returns the elapsed number of clock ticks between calling [start] and\n   * calling [stop].\n   *\n   * Returns 0 if the [Stopwatch] has never been started.\n   *\n   * The elapsed number of clock ticks increases by [frequency] every second.\n   */\n  int get elapsedTicks {\n    if (_start == null) {\n      return 0;\n    }\n    return (_stop == null) ? (_now() - _start) : (_stop - _start);\n  }\n\n  /**\n   * Returns the [elapsedTicks] counter converted to a [Duration].\n   */\n  Duration get elapsed {\n    return new Duration(microseconds: elapsedMicroseconds);\n  }\n\n  /**\n   * Returns the [elapsedTicks] counter converted to microseconds.\n   */\n  int get elapsedMicroseconds {\n    return (elapsedTicks * 1000000) ~/ frequency;\n  }\n\n  /**\n   * Returns the [elapsedTicks] counter converted to milliseconds.\n   */\n  int get elapsedMilliseconds {\n    return (elapsedTicks * 1000) ~/ frequency;\n  }\n\n\n  /**\n   * Returns wether the [StopWatch] is currently running.\n   */\n  bool get isRunning => _start != null && _stop == null;\n\n  /**\n   * Cached frequency of the system. Must be initialized in [_initTicker];\n   */\n  static int _frequency;\n\n  /**\n   * Initializes the time-measuring system. *Must* initialize the [_frequency]\n   * variable.\n   */\n  external static void _initTicker();\n  external static int _now();\n}\n\u0000","sdk:/sdk/lib/core/stacktrace.dart":"// Copyright (c) 2013, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\npart of dart.core;\n\n/**\n * An interface implemented by all stack trace objects.\n *\n * A [StackTrace] is intended to convey information to the user about the call\n * sequence that triggered an exception.\n *\n * These objects are created by the runtime, it is not possible to create\n * them programmatically.\n */\nabstract class StackTrace {\n  /**\n   * Returns a [String] representation of the stack trace.\n   *\n   * The string represents the full stack trace starting from\n   * the point where a throw ocurred to the top of the current call sequence.\n   *\n   * The exact format of the string representation is not final.\n   */\n  String toString();\n}\n\n\u0000","sdk:/sdk/lib/core/sink.dart":"// Copyright (c) 2014, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\npart of dart.core;\n\n/**\n * A generic destination for data.\n *\n * Multiple data values can be put into a sink, and when no more data is\n * available, the sink should be closed.\n *\n * This is a generic interface that other data receivers can implement.\n */\nabstract class Sink<T> {\n  /**\n   * Put the data into the sink.\n   *\n   * Must not be called after a call to [close].\n   */\n  void add(T data);\n\n  /**\n   * Tell the sink that no further data will be added.\n   *\n   * Calling this method more than once is allowed, but does nothing.\n   *\n   * The [add] method must not be called after this method.\n   */\n  void close();\n}\n\u0000","sdk:/sdk/lib/core/set.dart":"// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\npart of dart.core;\n\n/**\n * A collection of objects in which each object can occur only once.\n *\n * That is, for each object of the element type, the object is either considered\n * to be in the set, or to _not_ be in the set.\n *\n * Set implementations may consider some elements indistinguishable. These\n * elements are treated as being the same for any operation on the set.\n *\n * The default [Set] implementation, [LinkedHashSet], considers objects\n * indistinguishable if they are equal with regard to\n * operator [Object.==].\n *\n * Iterating over elements of a set may be either unordered\n * or ordered in some way. Examples:\n *\n * * A [HashSet] is unordered, which means that its iteration order is\n *   uspecified,\n * * [LinkedHashSet] iterates in the insertion order of its elements, and\n * * a sorted set like [SplayTreeSet] iterates the elements in sorted order.\n *\n * It is generally not allowed to modify the set (add or remove elements) while\n * an operation on the set is being performed, for example during a call to\n * [forEach] or [containsAll]. Nor is it allowed to modify the set while\n * iterating either the set itself or any [Iterable] that is backed by the set,\n * such as the ones returned by methods like [where] and [map].\n */\nabstract class Set<E> extends IterableBase<E> implements EfficientLength {\n  /**\n   * Creates an empty [Set].\n   *\n   * The created [Set] is a plain [LinkedHashSet].\n   * As such, it considers elements that are equal (using [==]) to be\n   * indistinguishable, and requires them to have a compatible\n   * [Object.hashCode] implementation.\n   *\n   * The set is equivalent to one created by `new LinkedHashSet<E>()`.\n   */\n  factory Set() = LinkedHashSet<E>;\n\n  /**\n   * Creates an empty identity [Set].\n   *\n   * The created [Set] is a [LinkedHashSet] that uses identity as equality\n   * relation.\n   *\n   * The set is equivalent to one created by `new LinkedHashSet<E>.identity()`.\n   */\n  factory Set.identity() = LinkedHashSet<E>.identity;\n\n  /**\n   * Creates a [Set] that contains all elements of [other].\n   *\n   * The created [Set] is a [LinkedHashSet]. As such, it considers elements that\n   * are equal (using [==]) to be undistinguishable, and requires them to\n   * have a compatible [Object.hashCode] implementation.\n   *\n   * The set is equivalent to one created by `new LinkedHashSet<E>.from(other)`.\n   */\n  factory Set.from(Iterable<E> other) = LinkedHashSet<E>.from;\n\n  /**\n   * Provides an iterator that iterates over the elements of this set.\n   *\n   * The order of iteration is defined by the individual `Set` implementation,\n   * but must be consistent between changes to the set.\n   */\n  Iterator<E> get iterator;\n\n  /**\n   * Returns true if [value] is in the set.\n   */\n  bool contains(Object value);\n\n  /**\n   * Adds [value] into the set. Returns `true` if [value] was added to the set.\n   *\n   * If [value] already exists, the set is not changed and `false` is returned.\n   */\n  bool add(E value);\n\n  /**\n   * Adds all of [elements] to this Set.\n   *\n   * Equivalent to adding each element in [elements] using [add],\n   * but some collections may be able to optimize it.\n   */\n  void addAll(Iterable<E> elements);\n\n  /**\n   * Removes [value] from the set. Returns true if [value] was\n   * in the set. Returns false otherwise. The method has no effect\n   * if [value] value was not in the set.\n   */\n  bool remove(Object value);\n\n  /**\n   * If an object equal to [object] is in the set, return it.\n   *\n   * Checks if there is an object in the set that is equal to [object].\n   * If so, that object is returned, otherwise returns null.\n   */\n  E lookup(Object object);\n\n  /**\n   * Removes each element of [elements] from this set.\n   */\n  void removeAll(Iterable<Object> elements);\n\n  /**\n   * Removes all elements of this set that are not elements in [elements].\n   *\n   * Checks for each element of [elements] whether there is an element in this\n   * set that is equal to it (according to `this.contains`), and if so, the\n   * equal element in this set is retained, and elements that are not equal\n   * to any element in `elements` are removed.\n   */\n  void retainAll(Iterable<Object> elements);\n\n  /**\n   * Removes all elements of this set that satisfy [test].\n   */\n  void removeWhere(bool test(E element));\n\n  /**\n   * Removes all elements of this set that fail to satisfy [test].\n   */\n  void retainWhere(bool test(E element));\n\n  /**\n   * Returns whether this Set contains all the elements of [other].\n   */\n  bool containsAll(Iterable<Object> other);\n\n  /**\n   * Returns a new set which is the intersection between this set and [other].\n   *\n   * That is, the returned set contains all the elements of this [Set] that\n   * are also elements of [other] according to `other.contains`.\n   */\n  Set<E> intersection(Set<Object> other);\n\n  /**\n   * Returns a new set which contains all the elements of this set and [other].\n   *\n   * That is, the returned set contains all the elements of this [Set] and\n   * all the elements of [other].\n   */\n  Set<E> union(Set<E> other);\n\n  /**\n   * Returns a new set with the the elements of this that are not in [other].\n   *\n   * That is, the returned set contains all the elements of this [Set] that\n   * are not elements of [other] according to `other.contains`.\n   */\n  Set<E> difference(Set<E> other);\n\n  /**\n   * Removes all elements in the set.\n   */\n  void clear();\n\n  /* Creates a [Set] with the same elements and behavior as this `Set`.\n   *\n   * The returned set behaves the same as this set\n   * with regard to adding and removing elements.\n   * It initially contains the same elements.\n   * If this set specifies an ordering of the elements,\n   * the returned set will have the same order.\n   */\n  Set<E> toSet();\n}\n\u0000","sdk:/sdk/lib/core/regexp.dart":"// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\npart of dart.core;\n\n/**\n * A result from searching within a string.\n *\n * A Match or an [Iterable] of Match objects is returned from [Pattern]\n * matching methods.\n *\n * The following example finds all matches of a [RegExp] in a [String]\n * and iterates through the returned iterable of Match objects.\n *\n *     RegExp exp = new RegExp(r\"(\\w+)\");\n *     String str = \"Parse my string\";\n *     Iterable<Match> matches = exp.allMatches(str);\n *     for (Match m in matches) {\n *       String match = m.group(0);\n *       print(match);\n *     }\n *\n * The output of the example is:\n *\n *     Parse\n *     my\n *     string\n *\n * Some patterns, regular expressions in particular, may record subtrings\n * that were part of the matching. These are called _groups_ in the Match\n * object. Some patterns may never have any groups, and their matches always\n * have zero [groupCount].\n */\nabstract class Match {\n  /**\n   * Returns the index in the string where the match starts.\n   */\n  int get start;\n\n  /**\n   * Returns the index in the string after the last character of the\n   * match.\n   */\n  int get end;\n\n  /**\n   * Returns the string matched by the given [group].\n   *\n   * If [group] is 0, returns the match of the pattern.\n   *\n   * The result may be `null` if the pattern didn't assign a value to it\n   * as part of this match.\n   */\n  String group(int group);\n\n  /**\n   * Returns the string matched by the given [group].\n   *\n   * If [group] is 0, returns the match of the pattern.\n   *\n   * Short alias for [Match.group].\n   */\n  String operator [](int group);\n\n  /**\n   * Returns a list of the groups with the given indices.\n   *\n   * The list contains the strings returned by [group] for each index in\n   * [groupIndices].\n   */\n  List<String> groups(List<int> groupIndices);\n\n  /**\n   * Returns the number of captured groups in the match.\n   *\n   * Some patterns may capture parts of the input that was used to\n   * compute the full match. This is the number of captured groups,\n   * which is also the maximal allowed argument to the [group] method.\n   */\n  int get groupCount;\n\n  /**\n   * The string on which this match was computed.\n   */\n  String get input;\n\n  /**\n   * The pattern used to search in [input].\n   */\n  Pattern get pattern;\n}\n\n\n/**\n * A regular expression pattern.\n *\n * Regular expressions are [Pattern]s, and can as such be used to match strings\n * or parts of strings.\n *\n * Dart regular expressions have the same syntax and semantics as\n * JavaScript regular expressions. See\n * <http://ecma-international.org/ecma-262/5.1/#sec-15.10>\n * for the specification of JavaScript regular expressions.\n *\n * [firstMatch] is the main implementation method that applies a regular\n * expression to a string and returns the first [Match]. All\n * other methods in [RegExp] can build on it.\n *\n * Use [allMatches] to look for all matches of a regular expression in\n * a string.\n *\n * The following example finds all matches of a regular expression in\n * a string.\n *\n *     RegExp exp = new RegExp(r\"(\\w+)\");\n *     String str = \"Parse my string\";\n *     Iterable<Match> matches = exp.allMatches(str);\n */\nabstract class RegExp implements Pattern {\n  /**\n   * Constructs a regular expression.\n   *\n   * Throws a [FormatException] if [source] is not valid regular\n   * expression syntax.\n   */\n  external factory RegExp(String source, {bool multiLine: false,\n                                          bool caseSensitive: true});\n\n  /**\n   * Searches for the first match of the regular expression\n   * in the string [input]. Returns `null` if there is no match.\n   */\n  Match firstMatch(String input);\n\n  /**\n   * Returns an iterable of the matches of the regular expression on [input].\n   *\n   * If [start] is provided, only start looking for matches at `start`.\n   */\n  Iterable<Match> allMatches(String input, [int start = 0]);\n\n  /**\n   * Returns whether the regular expression has a match in the string [input].\n   */\n  bool hasMatch(String input);\n\n  /**\n   * Returns the first substring match of this regular expression in [input].\n   */\n  String stringMatch(String input);\n\n  /**\n   * The source regular expression string used to create this `RegExp`.\n   */\n  String get pattern;\n\n  /**\n   * Whether this regular expression matches multiple lines.\n   *\n   * If the regexp does match multiple lines, the \"^\" and \"$\" characters\n   * match the beginning and end of lines. If not, the character match the\n   * beginning and end of the input.\n   */\n  bool get isMultiLine;\n\n  /**\n   * Whether this regular expression is case sensitive.\n   *\n   * If the regular expression is not case sensitive, it will match an input\n   * letter with a pattern letter even if the two letters are different case\n   * versions of the same letter.\n   */\n  bool get isCaseSensitive;\n}\n\u0000","sdk:/sdk/lib/core/print.dart":"// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\npart of dart.core;\n\n/// Prints a string representation of the object to the console.\nvoid print(Object object) {\n  String line = \"$object\";\n  if (printToZone == null) {\n    printToConsole(line);\n  } else {\n    printToZone(line);\n  }\n}\n\u0000","sdk:/sdk/lib/core/pattern.dart":"// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\npart of dart.core;\n\n/**\n * An interface for basic searches within strings.\n */\nabstract class Pattern {\n  // NOTE: When using \"start\" index from the language library, call\n  // without an argument if start is zero. This allows backwards compatiblity\n  // with implementations of the older interface that didn't have the start\n  // index argument.\n  /**\n   * Match this pattern against the string repeatedly.\n   *\n   * If [start] is provided, matching will start at that index.\n   *\n   * The iterable will contain all the non-overlapping matches of the\n   * pattern on the string, ordered by start index.\n   *\n   * The matches are found by repeatedly finding the first match\n   * of the pattern on the string, starting from the end of the previous\n   * match, and initially starting from index zero.\n   *\n   * If the pattern matches the empty string at some point, the next\n   * match is found by starting at the previous match's end plus one.\n   */\n  Iterable<Match> allMatches(String string, [int start = 0]);\n\n  /**\n   * Match this pattern against the start of string.\n   *\n   * If [start] is provided, it must be an integer in the range `0` ..\n   * `string.length`. In that case, this patten is tested against the\n   * string at the [start] position. That is, a match is returned if the\n   * pattern can match a part of the string starting from position [start].\n   */\n  Match matchAsPrefix(String string, [int start = 0]);\n}\n\u0000","sdk:/sdk/lib/core/object.dart":"// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\npart of dart.core;\n\n/**\n * The base class for all Dart objects.\n *\n * Because Object is the root of the Dart class hierarchy,\n * every other Dart class is a subclass of Object.\n *\n * When you define a class, you should override [toString]\n * to return a string describing an instance of that class.\n * You might also need to define [hashCode] and [==], as described in the\n * [Implementing map keys]\n * (http://www.dartlang.org/docs/dart-up-and-running/contents/ch03.html#ch03-implementing-map-keys)\n * section of the [library tour]\n * (http://www.dartlang.org/docs/dart-up-and-running/contents/ch03.html).\n */\nclass Object {\n  /**\n   * Creates a new [Object] instance.\n   *\n   * [Object] instances have no meaningful state, and are only useful\n   * through their identity. An [Object] instance is equal to itself\n   * only.\n   */\n  const Object();\n\n  /**\n   * The equality operator.\n   *\n   * The default behavior for all [Object]s is to return true if and\n   * only if [:this:] and [other] are the same object.\n   *\n   * Override this method to specify a different equality relation on\n   * a class. The overriding method must still be an equivalence relation.\n   * That is, it must be:\n   *\n   *  * Total: It must return a boolean for all arguments. It should never throw\n   *    or return `null`.\n   *\n   *  * Reflexive: For all objects `o`, `o == o` must be true.\n   *\n   *  * Symmetric: For all objects `o1` and `o2`, `o1 == o2` and `o2 == o1` must\n   *    either both be true, or both be false.\n   *\n   *  * Transitive: For all objects `o1`, `o2`, and `o3`, if `o1 == o2` and\n   *    `o2 == o3` are true, then `o1 == o3` must be true.\n   *\n   * The method should also be consistent over time, so equality of two objects\n   * should not change over time, or at least only change if one of the objects\n   * was modified.\n   *\n   * If a subclass overrides the equality operator it should override\n   * the [hashCode] method as well to maintain consistency.\n   */\n  bool operator ==(other) => identical(this, other);\n\n  /**\n   * Get a hash code for this object.\n   *\n   * All objects have hash codes. Hash codes are guaranteed to be the\n   * same for objects that are equal when compared using the equality\n   * operator [:==:]. Other than that there are no guarantees about\n   * the hash codes. They will not be consistent between runs and\n   * there are no distribution guarantees.\n   *\n   * If a subclass overrides [hashCode] it should override the\n   * equality operator as well to maintain consistency.\n   */\n  external int get hashCode;\n\n  /**\n   * Returns a string representation of this object.\n   */\n  external String toString();\n\n  /**\n   * [noSuchMethod] is invoked when users invoke a non-existent method\n   * on an object. The name of the method and the arguments of the\n   * invocation are passed to [noSuchMethod] in an [Invocation].\n   * If [noSuchMethod] returns a value, that value becomes the result of\n   * the original invocation.\n   *\n   * The default behavior of [noSuchMethod] is to throw a\n   * [NoSuchMethodError].\n   */\n  external dynamic noSuchMethod(Invocation invocation);\n\n  /**\n   * A representation of the runtime type of the object.\n   */\n  external Type get runtimeType;\n}\n\u0000","sdk:/sdk/lib/core/num.dart":"// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\npart of dart.core;\n\n/**\n * An integer or floating-point number.\n *\n * It is a compile-time error for any type other than [int] or [double]\n * to attempt to extend or implement num.\n */\nabstract class num implements Comparable<num> {\n  /**\n   * Test whether this value is numerically equal to `other`.\n   *\n   * If both operands are doubles, they are equal if they have the same\n   * representation, except that:\n   *\n   *   * zero and minus zero (0.0 and -0.0) are considered equal. They\n   *     both have the numerical value zero.\n   *   * NaN is not equal to anything, including NaN. If either operand is\n   *     NaN, the result is always false.\n   *\n   * If one operand is a double and the other is an int, they are equal if\n   * the double has an integer value (finite with no fractional part) and\n   * `identical(doubleValue.toInt(), intValue)` is true.\n   *\n   * If both operands are integers, they are equal if they have the same value.\n   *\n   * Returns false if `other` is not a [num].\n   *\n   * Notice that the behavior for NaN is non-reflexive. This means that\n   * equality of double values is not a proper equality relation, as is\n   * otherwise required of `operator==`. Using NaN in, e.g., a [HashSet]\n   * will fail to work. The behavior is the standard IEEE-754 equality of\n   * doubles.\n   *\n   * If you can avoid NaN values, the remaining doubles do have a proper eqality\n   * relation, and can be used safely.\n   *\n   * Use [compareTo] for a comparison that distinguishes zero and minus zero,\n   * and that considers NaN values as equal.\n   */\n  bool operator==(Object other);\n\n  /**\n   * Returns a hash code for a numerical value.\n   *\n   * The hash code is compatible with equality. It returns the same value\n   * for an [int] and a [double] with the same numerical value, and therefore\n   * the same value for the doubles zero and minus zero.\n   *\n   * No guarantees are made about the hash code of NaN.\n   */\n  int get hashCode;\n\n  /**\n   * Compares this to `other`.\n   *\n   * Returns a negative number if `this` is less than `other`, zero if they are\n   * equal, and a positive number if `this` is greater than `other`.\n   *\n   * The orderding represented by this method is a total ordering of [num]\n   * values. All distinct doubles are non-equal, as are all distinct integers,\n   * but integers are equal to doubles if they have the same numerical\n   * value.\n   *\n   * For ordering, the double NaN value is considered equal to itself, and\n   * greater than any numeric value (unlike its behavior in `operator==`).\n   *\n   * The double value -0.0 is considered less than 0.0 (and the integer 0), but\n   * greater than any non-zero negative value.\n   *\n   * Positive infinity is greater than any finite value (any value apart from\n   * itself and NaN), and negative infinity is less than any other value.\n   *\n   * All other values are compared using their numeric value.\n   */\n  int compareTo(num other);\n\n  /** Addition operator. */\n  num operator +(num other);\n\n  /** Subtraction operator. */\n  num operator -(num other);\n\n  /** Multiplication operator. */\n  num operator *(num other);\n\n  /**\n   * Euclidean modulo operator.\n   *\n   * Returns the remainder of the euclidean division. The euclidean division of\n   * two integers `a` and `b` yields two integers `q` and `r` such that\n   * `a == b * q + r` and `0 <= r < b.abs()`.\n   *\n   * The euclidean division is only defined for integers, but can be easily\n   * extended to work with doubles. In that case `r` may have a non-integer\n   * value, but it still verifies `0 <= r < |b|`.\n   *\n   * The sign of the returned value `r` is always positive.\n   *\n   * See [remainder] for the remainder of the truncating division.\n   */\n  num operator %(num other);\n\n  /** Division operator. */\n  double operator /(num other);\n\n  /**\n   * Truncating division operator.\n   *\n   * If either operand is a [double] then the result of the truncating division\n   * `a ~/ b` is equivalent to `(a / b).truncate().toInt()`.\n   *\n   * If both operands are [int]s then `a ~/ b` performs the truncating\n   * integer division.\n   */\n  int operator ~/(num other);\n\n  /** Negate operator. */\n  num operator -();\n\n /**\n   * Returns the remainder of the truncating division of `this` by [other].\n   *\n   * The result `r` of this operation satisfies:\n   * `this == (this ~/ other) * other + r`.\n   * As a consequence the remainder `r` has the same sign as the divider `this`.\n   */\n  num remainder(num other);\n\n  /** Relational less than operator. */\n  bool operator <(num other);\n\n  /** Relational less than or equal operator. */\n  bool operator <=(num other);\n\n  /** Relational greater than operator. */\n  bool operator >(num other);\n\n  /** Relational greater than or equal operator. */\n  bool operator >=(num other);\n\n  /** True if the number is the double Not-a-Number value; otherwise, false. */\n  bool get isNaN;\n\n  /**\n   * True if the number is negative; otherwise, false.\n   *\n   * Negative numbers are those less than zero, and the double `-0.0`.\n   */\n  bool get isNegative;\n\n  /**\n   * True if the number is positive infinity or negative infinity; otherwise,\n   * false.\n   */\n  bool get isInfinite;\n\n  /**\n   * True if the number is finite; otherwise, false.\n   *\n   * The only non-finite numbers are NaN, positive infinitity and\n   * negative infinity.\n   */\n  bool get isFinite;\n\n  /** Returns the absolute value of this [num]. */\n  num abs();\n\n  /**\n   * Returns minus one, zero or plus one depending on the sign and\n   * numerical value of the number.\n   *\n   * Returns minus one if the number is less than zero,\n   * plus one if the number is greater than zero,\n   * and zero if the number is equal to zero.\n   *\n   * Returns NaN if the number is the double NaN value.\n   *\n   * Returns a number of the same type as this number.\n   * For doubles, `-0.0.sign == -0.0`.\n\n   * The result satisfies:\n   *\n   *     n == n.sign * n.abs()\n   *\n   * for all numbers `n` (except NaN, because NaN isn't `==` to itself).\n   */\n  num get sign;\n\n  /**\n   * Returns the integer closest to `this`.\n   *\n   * Rounds away from zero when there is no closest integer:\n   *  `(3.5).round() == 4` and `(-3.5).round() == -4`.\n   *\n   * If `this` is not finite (`NaN` or infinity), throws an [UnsupportedError].\n   */\n  int round();\n\n  /**\n   * Returns the greatest integer no greater than `this`.\n   *\n   * If `this` is not finite (`NaN` or infinity), throws an [UnsupportedError].\n   */\n  int floor();\n\n  /**\n   * Returns the least integer no smaller than `this`.\n   *\n   * If `this` is not finite (`NaN` or infinity), throws an [UnsupportedError].\n   */\n  int ceil();\n\n  /**\n   * Returns the integer obtained by discarding any fractional\n   * digits from `this`.\n   *\n   * If `this` is not finite (`NaN` or infinity), throws an [UnsupportedError].\n   */\n  int truncate();\n\n  /**\n   * Returns the double integer value closest to `this`.\n   *\n   * Rounds away from zero when there is no closest integer:\n   *  `(3.5).roundToDouble() == 4` and `(-3.5).roundToDouble() == -4`.\n   *\n   * If this is already an integer valued double, including `-0.0`, or it is a\n   * non-finite double value, the value is returned unmodified.\n   *\n   * For the purpose of rounding, `-0.0` is considered to be below `0.0`,\n   * and `-0.0` is therefore considered closer to negative numbers than `0.0`.\n   * This means that for a value, `d` in the range `-0.5 < d < 0.0`,\n   * the result is `-0.0`.\n   *\n   * The result is always a double.\n   * If this is a numerically large integer, the result may be an infinite\n   * double.\n   */\n  double roundToDouble();\n\n  /**\n   * Returns the greatest double integer value no greater than `this`.\n   *\n   * If this is already an integer valued double, including `-0.0`, or it is a\n   * non-finite double value, the value is returned unmodified.\n   *\n   * For the purpose of rounding, `-0.0` is considered to be below `0.0`.\n   * A number `d` in the range `0.0 < d < 1.0` will return `0.0`.\n   *\n   * The result is always a double.\n   * If this is a numerically large integer, the result may be an infinite\n   * double.\n   */\n  double floorToDouble();\n\n  /**\n   * Returns the least double integer value no smaller than `this`.\n   *\n   * If this is already an integer valued double, including `-0.0`, or it is a\n   * non-finite double value, the value is returned unmodified.\n   *\n   * For the purpose of rounding, `-0.0` is considered to be below `0.0`.\n   * A number `d` in the range `-1.0 < d < 0.0` will return `-0.0`.\n   *\n   * The result is always a double.\n   * If this is a numerically large integer, the result may be an infinite\n   * double.\n   */\n  double ceilToDouble();\n\n  /**\n   * Returns the double integer value obtained by discarding any fractional\n   * digits from the double value of `this`.\n   *\n   * If this is already an integer valued double, including `-0.0`, or it is a\n   * non-finite double value, the value is returned unmodified.\n   *\n   * For the purpose of rounding, `-0.0` is considered to be below `0.0`.\n   * A number `d` in the range `-1.0 < d < 0.0` will return `-0.0`, and\n   * in the range `0.0 < d < 1.0` it will return 0.0.\n   *\n   * The result is always a double.\n   * If this is a numerically large integer, the result may be an infinite\n   * double.\n   */\n  double truncateToDouble();\n\n  /**\n   * Clamps [this] to be in the range [lowerLimit]-[upperLimit]. The comparison\n   * is done using [compareTo] and therefore takes `-0.0` into account.\n   * It also implies that [double.NAN] is treated as the maximal double value.\n   */\n  num clamp(num lowerLimit, num upperLimit);\n\n  /** Truncates this [num] to an integer and returns the result as an [int]. */\n  int toInt();\n\n  /**\n   * Return this [num] as a [double].\n   *\n   * If the number is not representable as a [double], an\n   * approximation is returned. For numerically large integers, the\n   * approximation may be infinite.\n   */\n  double toDouble();\n\n  /**\n   * Returns a decimal-point string-representation of `this`.\n   *\n   * Converts `this` to a [double] before computing the string representation.\n   *\n   * If the absolute value of `this` is greater or equal to `10^21` then this\n   * methods returns an exponential representation computed by\n   * `this.toStringAsExponential()`. Otherwise the result\n   * is the closest string representation with exactly [fractionDigits] digits\n   * after the decimal point. If [fractionDigits] equals 0 then the decimal\n   * point is omitted.\n   *\n   * The parameter [fractionDigits] must be an integer satisfying:\n   * `0 <= fractionDigits <= 20`.\n   *\n   * Examples:\n   *\n   *     1.toStringAsFixed(3);  // 1.000\n   *     (4321.12345678).toStringAsFixed(3);  // 4321.123\n   *     (4321.12345678).toStringAsFixed(5);  // 4321.12346\n   *     123456789012345678901.toStringAsFixed(3);  // 123456789012345683968.000\n   *     1000000000000000000000.toStringAsFixed(3); // 1e+21\n   *     5.25.toStringAsFixed(0); // 5\n   */\n  String toStringAsFixed(int fractionDigits);\n\n  /**\n   * Returns an exponential string-representation of `this`.\n   *\n   * Converts `this` to a [double] before computing the string representation.\n   *\n   * If [fractionDigits] is given then it must be an integer satisfying:\n   * `0 <= fractionDigits <= 20`. In this case the string contains exactly\n   * [fractionDigits] after the decimal point. Otherwise, without the parameter,\n   * the returned string uses the shortest number of digits that accurately\n   * represent [this].\n   *\n   * If [fractionDigits] equals 0 then the decimal point is omitted.\n   * Examples:\n   *\n   *     1.toStringAsExponential();       // 1e+0\n   *     1.toStringAsExponential(3);      // 1.000e+0\n   *     123456.toStringAsExponential();  // 1.23456e+5\n   *     123456.toStringAsExponential(3); // 1.235e+5\n   *     123.toStringAsExponential(0);    // 1e+2\n   */\n  String toStringAsExponential([int fractionDigits]);\n\n  /**\n   * Converts `this` to a double and returns a string representation with\n   * exactly [precision] significant digits.\n   *\n   * The parameter [precision] must be an integer satisfying:\n   * `1 <= precision <= 21`.\n   *\n   * Examples:\n   *\n   *     1.toStringAsPrecision(2);       // 1.0\n   *     1e15.toStringAsPrecision(3);    // 1.00+15\n   *     1234567.toStringAsPrecision(3); // 1.23e+6\n   *     1234567.toStringAsPrecision(9); // 1234567.00\n   *     12345678901234567890.toStringAsPrecision(20); // 12345678901234567168\n   *     12345678901234567890.toStringAsPrecision(14); // 1.2345678901235e+19\n   *     0.00000012345.toPrecision(15); // 1.23450000000000e-7\n   *     0.0000012345.toPrecision(15);  // 0.00000123450000000000\n   */\n  String toStringAsPrecision(int precision);\n\n  /**\n   * Returns the shortest string that correctly represent the input number.\n   *\n   * All [double]s in the range `10^-6` (inclusive) to `10^21` (exclusive)\n   * are converted to their decimal representation with at least one digit\n   * after the decimal point. For all other doubles,\n   * except for special values like `NaN` or `Infinity`, this method returns an\n   * exponential representation (see [toStringAsExponential]).\n   *\n   * Returns `\"NaN\"` for [double.NAN], `\"Infinity\"` for [double.INFINITY], and\n   * `\"-Infinity\"` for [double.MINUS_INFINITY].\n   *\n   * An [int] is converted to a decimal representation with no decimal point.\n   *\n   * Examples:\n   *\n   *     (0.000001).toString();  // \"0.000001\"\n   *     (0.0000001).toString(); // \"1e-7\"\n   *     (111111111111111111111.0).toString();  // \"111111111111111110000.0\"\n   *     (100000000000000000000.0).toString();  // \"100000000000000000000.0\"\n   *     (1000000000000000000000.0).toString(); // \"1e+21\"\n   *     (1111111111111111111111.0).toString(); // \"1.1111111111111111e+21\"\n   *     1.toString(); // \"1\"\n   *     111111111111111111111.toString();  // \"111111111111111110000\"\n   *     100000000000000000000.toString();  // \"100000000000000000000\"\n   *     1000000000000000000000.toString(); // \"1000000000000000000000\"\n   *     1111111111111111111111.toString(); // \"1111111111111111111111\"\n   *     1.234e5.toString();   // 123400\n   *     1234.5e6.toString();  // 1234500000\n   *     12.345e67.toString(); // 1.2345e+68\n   *\n   * Note: the conversion may round the output if the returned string\n   * is accurate enough to uniquely identify the input-number.\n   * For example the most precise representation of the [double] `9e59` equals\n   * `\"899999999999999918767229449717619953810131273674690656206848\"`, but\n   * this method returns the shorter (but still uniquely identifying) `\"9e59\"`.\n   *\n   */\n  String toString();\n\n  /**\n   * Parses a string containing a number literal into a number.\n   *\n   * The method first tries to read the [input] as integer (similar to\n   * [int.parse] without a radix).\n   * If that fails, it tries to parse the [input] as a double (similar to\n   * [double.parse]).\n   * If that fails, too, it invokes [onError] with [input].\n   *\n   * If no [onError] is supplied, it defaults to a function that throws a\n   * [FormatException].\n   *\n   * For any number `n`, this function satisfies\n   * `identical(n, num.parse(n.toString()))`.\n   */\n  static num parse(String input, [num onError(String input)]) {\n    String source = input.trim();\n    // TODO(lrn): Optimize to detect format and result type in one check.\n    num result = int.parse(source, onError: _returnNull);\n    if (result != null) return result;\n    result = double.parse(source, _returnNull);\n    if (result != null) return result;\n    if (onError == null) throw new FormatException(input);\n    return onError(input);\n  }\n\n  /** Helper function for [parse]. */\n  static _returnNull(_) => null;\n}\n\u0000","sdk:/sdk/lib/core/null.dart":"// Copyright (c) 2013, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\npart of dart.core;\n\n/**\n * The reserved word [:null:] denotes an object that is the sole instance of \n * this class.\n * \n * It is a compile-time error for a class to attempt to extend or implement\n * Null.\n */\nclass Null {\n  factory Null._uninstantiable() {\n    throw new UnsupportedError('class Null cannot be instantiated');\n  }\n\n  /** Returns the string `\"null\"`. */\n  String toString() => \"null\";\n}\n\u0000","sdk:/sdk/lib/core/map.dart":"// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\npart of dart.core;\n\n/**\n * An collection of key-value pairs, from which you retrieve a value\n * using its associated key.\n *\n * There is a finite number of keys in the map,\n * and each key has exactly one value associated with it.\n *\n * Maps, and their keys and values, can be iterated.\n * The order of iteration is defined by the individual type of map.\n * Examples:\n *\n * * The plain [HashMap] is unordered (no order is guaranteed),\n * * the [LinkedHashMap] iterates in key insertion order,\n * * and a sorted map like [SplayTreeMap] iterates the keys in sorted order.\n *\n * It is generally not allowed to modify the map (add or remove keys) while\n * an operation is being performed on the map, for example in functions called\n * during a [forEach] or [putIfAbsent] call.\n * Modifying the map while iterating the keys or values\n * may also break the iteration.\n */\nabstract class Map<K, V> {\n  /**\n   * Creates a Map instance with the default implementation, [LinkedHashMap].\n   *\n   * This constructor is equivalent to the non-const map literal `<K,V>{}`.\n   *\n   * A `LinkedHashMap` requires the keys to implement compatible\n   * `operator==` and `hashCode`, and it allows null as a key.\n   * It iterates in key insertion order.\n   */\n  factory Map() = LinkedHashMap<K, V>;\n\n  /**\n   * Creates a [LinkedHashMap] instance that contains all key-value pairs of\n   * [other].\n   *\n   * A `LinkedHashMap` requires the keys to implement compatible\n   * `operator==` and `hashCode`, and it allows null as a key.\n   * It iterates in key insertion order.\n   */\n  factory Map.from(Map<K, V> other) = LinkedHashMap<K, V>.from;\n\n  /**\n   * Creates an identity map with the default implementation, [LinkedHashMap].\n   *\n   * The returned map allows `null` as a key.\n   * It iterates in key insertion order.\n   */\n  factory Map.identity() = LinkedHashMap<K, V>.identity;\n\n  /**\n   * Creates a Map instance in which the keys and values are computed from the\n   * [iterable].\n   *\n   * The created map is a [LinkedHashMap].\n   * A `LinkedHashMap` requires the keys to implement compatible\n   * `operator==` and `hashCode`, and it allows null as a key.\n   * It iterates in key insertion order.\n   *\n   * For each element of the [iterable] this constructor computes a key-value\n   * pair, by applying [key] and [value] respectively.\n   *\n   * The example below creates a new Map from a List. The keys of `map` are\n   * `list` values converted to strings, and the values of the `map` are the\n   * squares of the `list` values:\n   *\n   *     List<int> list = [1, 2, 3];\n   *     Map<String, int> map = new Map.fromIterable(list,\n   *         key: (item) => item.toString(),\n   *         value: (item) => item * item));\n   *\n   *     map['1'] + map['2']; // 1 + 4\n   *     map['3'] - map['2']; // 9 - 4\n   *\n   * If no values are specified for [key] and [value] the default is the\n   * identity function.\n   *\n   * In the following example, the keys and corresponding values of `map`\n   * are `list` values:\n   *\n   *     map = new Map.fromIterable(list);\n   *     map[1] + map[2]; // 1 + 2\n   *     map[3] - map[2]; // 3 - 2\n   *\n   * The keys computed by the source [iterable] do not need to be unique. The\n   * last occurrence of a key will simply overwrite any previous value.\n   */\n  factory Map.fromIterable(Iterable iterable,\n      {K key(element), V value(element)}) = LinkedHashMap<K, V>.fromIterable;\n\n  /**\n   * Creates a Map instance associating the given [keys] to [values].\n   *\n   * The created map is a [LinkedHashMap].\n   * A `LinkedHashMap` requires the keys to implement compatible\n   * `operator==` and `hashCode`, and it allows null as a key.\n   * It iterates in key insertion order.\n   *\n   * This constructor iterates over [keys] and [values] and maps each element of\n   * [keys] to the corresponding element of [values].\n   *\n   *     List<String> letters = ['b', 'c'];\n   *     List<String> words = ['bad', 'cat'];\n   *     Map<String, String> map = new Map.fromIterables(letters, words);\n   *     map['b'] + map['c'];  // badcat\n   *\n   * If [keys] contains the same object multiple times, the last occurrence\n   * overwrites the previous value.\n   *\n   * The two [Iterable]s must have the same length.\n   */\n  factory Map.fromIterables(Iterable<K> keys, Iterable<V> values)\n      = LinkedHashMap<K, V>.fromIterables;\n\n  /**\n   * Returns true if this map contains the given [value].\n   *\n   * Returns true if any of the values in the map are equal to `value`\n   * according to the `==` operator.\n   */\n  bool containsValue(Object value);\n\n  /**\n   * Returns true if this map contains the given [key].\n   *\n   * Returns true if any of the keys in the map ar equal to `key`\n   * according to the equality used by the map.\n   */\n  bool containsKey(Object key);\n\n  /**\n   * Returns the value for the given [key] or null if [key] is not in the map.\n   *\n   * Some maps allows keys to have `null` as a value,\n   * For those maps, a lookup using this operator does cannot be used to\n   * distinguish between a key not being in the map, and the key having a null\n   * value.\n   * Methods like [containsKey] or [putIfAbsent] can be use if the distinction\n   * is important.\n   */\n  V operator [](Object key);\n\n  /**\n   * Associates the [key] with the given [value].\n   *\n   * If the key was already in the map, its associated value is changed.\n   * Otherwise the key-value pair is added to the map.\n   */\n  void operator []=(K key, V value);\n\n  /**\n   * Look up the value of [key], or add a new value if it isn't there.\n   *\n   * Returns the value associated to [key], if there is one.\n   * Otherwise calls [ifAbsent] to get a new value, associates [key] to\n   * that value, and then returns the new value.\n   *\n   *     Map<String, int> scores = {'Bob': 36};\n   *     for (var key in ['Bob', 'Rohan', 'Sophena']) {\n   *       scores.putIfAbsent(key, () => key.length);\n   *     }\n   *     scores['Bob'];      // 36\n   *     scores['Rohan'];    //  5\n   *     scores['Sophena'];  //  7\n   *\n   * Calling [ifAbsent] must not add or remove keys from the map.\n   */\n  V putIfAbsent(K key, V ifAbsent());\n\n  /**\n   * Adds all key-value pairs of [other] to this map.\n   *\n   * If a key of [other] is already in this map, its value is overwritten.\n   *\n   * The operation is equivalent to doing `this[key] = value` for each key\n   * and associated value in other. It iterates over [other], which must\n   * therefore not change during the iteration.\n   */\n  void addAll(Map<K, V> other);\n\n  /**\n   * Removes [key] and its associated value, if present, from the map.\n   *\n   * Returns the value associated with `key` before it was removed.\n   * Returns `null` if `key` was not in the map.\n   *\n   * Note that values can be `null` and a returned `null` value doesn't\n   * always mean that the key was absent.\n   */\n  V remove(Object key);\n\n  /**\n   * Removes all pairs from the map.\n   *\n   * After this, the map is empty.\n   */\n  void clear();\n\n  /**\n   * Applies [f] to each key-value pair of the map.\n   *\n   * Calling `f` must not add or remove keys from the map.\n   */\n  void forEach(void f(K key, V value));\n\n  /**\n   * The keys of [this].\n   *\n   * The returned iterable has efficient `length` and `contains` operations,\n   * based on [length] and [containsKey] of the map.\n   *\n   * The order of iteration is defined by the individual `Map` implementation,\n   * but must be consistent between changes to the map.\n   */\n  Iterable<K> get keys;\n\n  /**\n   * The values of [this].\n   *\n   * The values are iterated in the order of their corresponding keys.\n   * This means that iterating [keys] and [values] in parrallel will\n   * provided matching pairs of keys and values.\n   *\n   * The returned iterable has an efficient `length` method based on the\n   * [length] of the map. Its [Iterable.contains] method is based on\n   * `==` comparison.\n   */\n  Iterable<V> get values;\n\n  /**\n   * The number of key-value pairs in the map.\n   */\n  int get length;\n\n  /**\n   * Returns true if there is no key-value pair in the map.\n   */\n  bool get isEmpty;\n\n  /**\n   * Returns true if there is at least one key-value pair in the map.\n   */\n  bool get isNotEmpty;\n}\n\u0000","sdk:/sdk/lib/core/list.dart":"// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\npart of dart.core;\n\n/**\n * An indexable collection of objects with a length.\n *\n * Subclasses of this class implement different kinds of lists.\n * The most common kinds of lists are:\n *\n * * Fixed-length list.\n *   An error occurs when attempting to use operations\n *   that can change the length of the list.\n *\n * * Growable list. Full implementation of the API defined in this class.\n *\n * The default growable list, as returned by `new List()` or `[]`, keeps\n * an internal buffer, and grows that buffer when necessary. This guarantees\n * that a sequence of [add] operations will each execute in amortized constant\n * time. Setting the length directly may take time proportional to the new\n * length, and may change the internal capacity so that a following add\n * operation will need to immediately increase the buffer capacity.\n * Other list implementations may have different performance behavior.\n *\n * The following code illustrates that some List implementations support\n * only a subset of the API.\n *\n *     List<int> fixedLengthList = new List(5);\n *     fixedLengthList.length = 0;  // Error\n *     fixedLengthList.add(499);    // Error\n *     fixedLengthList[0] = 87;\n *     List<int> growableList = [1, 2];\n *     growableList.length = 0;\n *     growableList.add(499);\n *     growableList[0] = 87;\n *\n * Lists are [Iterable]. Iteration occurs over values in index order. Changing\n * the values does not affect iteration, but changing the valid\n * indices&mdash;that is, changing the list's length&mdash;between iteration\n * steps causes a [ConcurrentModificationError]. This means that only growable\n * lists can throw ConcurrentModificationError. If the length changes\n * temporarily and is restored before continuing the iteration, the iterator\n * does not detect it.\n *\n * It is generally not allowed to modify the list's length (adding or removing\n * elements) while an operation on the list is being performed,\n * for example during a call to [forEach] or [sort].\n * Changing the list's length while it is being iterated, either by iterating it\n * directly or through iterating an [Iterable] that is backed by the list, will\n * break the iteration.\n */\nabstract class List<E> implements Iterable<E>, EfficientLength {\n  /**\n   * Creates a list of the given length.\n   *\n   * The created list is fixed-length if [length] is provided.\n   *\n   *     List fixedLengthList = new List(3);\n   *     fixedLengthList.length;     // 3\n   *     fixedLengthList.length = 1; // Error\n   *\n   *\n   * The list has length 0 and is growable if [length] is omitted.\n   *\n   *     List growableList = new List();\n   *     growableList.length; // 0;\n   *     growableList.length = 3;\n   *\n   * The [length] must not be negative or null, if it is provided.\n   */\n  external factory List([int length]);\n\n  /**\n   * Creates a fixed-length list of the given length, and initializes the\n   * value at each position with [fill]:\n   *\n   *     new List<int>.filled(3, 0); // [0, 0, 0]\n   *\n   * The [length] must not be negative or null.\n   */\n  external factory List.filled(int length, E fill);\n\n  /**\n   * Creates a list and initializes it using the contents of [other].\n   *\n   * The [Iterator] of [other] provides the order of the objects.\n   *\n   * This constructor returns a growable list if [growable] is true;\n   * otherwise, it returns a fixed-length list.\n   */\n  factory List.from(Iterable other, { bool growable: true }) {\n    List<E> list = new List<E>();\n    for (E e in other) {\n      list.add(e);\n    }\n    if (growable) return list;\n    return makeListFixedLength(list);\n  }\n\n  /**\n   * Generates a list of values.\n   *\n   * Creates a list with [length] positions and fills it with values created by\n   * calling [generator] for each index in the range `0` .. `length - 1`\n   * in increasing order.\n   *\n   *     new List<int>.generate(3, (int index) => index * index); // [0, 1, 4]\n   *\n   * The created list is fixed-length unless [growable] is true.\n   */\n  factory List.generate(int length, E generator(int index),\n                       { bool growable: true }) {\n    List<E> result;\n    if (growable) {\n      result = <E>[]..length = length;\n    } else {\n      result = new List<E>(length);\n    }\n    for (int i = 0; i < length; i++) {\n      result[i] = generator(i);\n    }\n    return result;\n  }\n\n  /**\n   * Returns the object at the given [index] in the list\n   * or throws a [RangeError] if [index] is out of bounds.\n   */\n  E operator [](int index);\n\n  /**\n   * Sets the value at the given [index] in the list to [value]\n   * or throws a [RangeError] if [index] is out of bounds.\n   */\n  void operator []=(int index, E value);\n\n  /**\n   * Returns the number of objects in this list.\n   *\n   * The valid indices for a list are `0` through `length - 1`.\n   */\n  int get length;\n\n  /**\n   * Changes the length of this list.\n   *\n   * If [newLength] is greater than\n   * the current length, entries are initialized to [:null:].\n   *\n   * Throws an [UnsupportedError] if the list is fixed-length.\n   */\n  void set length(int newLength);\n\n  /**\n   * Adds [value] to the end of this list,\n   * extending the length by one.\n   *\n   * Throws an [UnsupportedError] if the list is fixed-length.\n   */\n  void add(E value);\n\n  /**\n   * Appends all objects of [iterable] to the end of this list.\n   *\n   * Extends the length of the list by the number of objects in [iterable].\n   * Throws an [UnsupportedError] if this list is fixed-length.\n   */\n  void addAll(Iterable<E> iterable);\n\n  /**\n   * Returns an [Iterable] of the objects in this list in reverse order.\n   */\n  Iterable<E> get reversed;\n\n  /**\n   * Sorts this list according to the order specified by the [compare] function.\n   *\n   * The [compare] function must act as a [Comparator].\n\n   *     List<String> numbers = ['one', 'two', 'three', 'four'];\n   *     // Sort from shortest to longest.\n   *     numbers.sort((x, y) => x.length.compareTo(y.length));\n   *     numbers.join(', '); // 'one, two, four, three'\n   *\n   * The default List implementations use [Comparable.compare] if\n   * [compare] is omitted.\n   *\n   *     List<int> nums = [13, 2, -11];\n   *     nums.sort();\n         nums.join(', '); // '-11, 2, 13'\n   */\n  void sort([int compare(E a, E b)]);\n\n  /**\n   * Shuffles the elements of this list randomly.\n   */\n  void shuffle([Random random]);\n\n  /**\n   * Returns the first index of [element] in this list.\n   *\n   * Searches the list from index [start] to the end of the list.\n   * The first time an object [:o:] is encountered so that [:o == element:],\n   * the index of [:o:] is returned.\n   *\n   *     List<String> notes = ['do', 're', 'mi', 're'];\n   *     notes.indexOf('re');    // 1\n   *     notes.indexOf('re', 2); // 3\n   *\n   * Returns -1 if [element] is not found.\n   *\n   *     notes.indexOf('fa');    // -1\n   */\n  int indexOf(E element, [int start = 0]);\n\n  /**\n   * Returns the last index of [element] in this list.\n   *\n   * Searches the list backwards from index [start] to 0.\n   *\n   * The first time an object [:o:] is encountered so that [:o == element:],\n   * the index of [:o:] is returned.\n   *\n   *     List<String> notes = ['do', 're', 'mi', 're'];\n   *     notes.lastIndexOf('re', 2); // 1\n   *\n   * If [start] is not provided, this method searches from the end of the\n   * list./Returns\n   *\n   *     notes.lastIndexOf('re');  // 3\n   *\n   * Returns -1 if [element] is not found.\n   *\n   *     notes.lastIndexOf('fa');  // -1\n   */\n  int lastIndexOf(E element, [int start]);\n\n  /**\n   * Removes all objects from this list;\n   * the length of the list becomes zero.\n   *\n   * Throws an [UnsupportedError], and retains all objects, if this\n   * is a fixed-length list.\n   */\n  void clear();\n\n  /**\n   * Inserts the object at position [index] in this list.\n   *\n   * This increases the length of the list by one and shifts all objects\n   * at or after the index towards the end of the list.\n   *\n   * An error occurs if the [index] is less than 0 or greater than length.\n   * An [UnsupportedError] occurs if the list is fixed-length.\n   */\n  void insert(int index, E element);\n\n  /**\n   * Inserts all objects of [iterable] at position [index] in this list.\n   *\n   * This increases the length of the list by the length of [iterable] and\n   * shifts all later objects towards the end of the list.\n   *\n   * An error occurs if the [index] is less than 0 or greater than length.\n   * An [UnsupportedError] occurs if the list is fixed-length.\n   */\n  void insertAll(int index, Iterable<E> iterable);\n\n  /**\n   * Overwrites objects of `this` with the objects of [iterable], starting\n   * at position [index] in this list.\n   *\n   *     List<String> list = ['a', 'b', 'c'];\n   *     list.setAll(1, ['bee', 'sea']);\n   *     list.join(', '); // 'a, bee, sea'\n   *\n   * This operation does not increase the length of `this`.\n   *\n   * The [index] must be non-negative and no greater than [length].\n   *\n   * The [iterable] must not have more elements than what can fit from [index]\n   * to [length].\n   *\n   * If `iterable` is based on this list, its values may change /during/ the\n   * `setAll` operation.\n   */\n  void setAll(int index, Iterable<E> iterable);\n\n  /**\n   * Removes the first occurence of [value] from this list.\n   *\n   * Returns true if [value] was in the list, false otherwise.\n   *\n   *     List<String> parts = ['head', 'shoulders', 'knees', 'toes'];\n   *     parts.remove('head'); // true\n   *     parts.join(', ');     // 'shoulders, knees, toes'\n   *\n   * The method has no effect if [value] was not in the list.\n   *\n   *     // Note: 'head' has already been removed.\n   *     parts.remove('head'); // false\n   *     parts.join(', ');     // 'shoulders, knees, toes'\n   *\n   * An [UnsupportedError] occurs if the list is fixed-length.\n   */\n  bool remove(Object value);\n\n  /**\n   * Removes the object at position [index] from this list.\n   *\n   * This method reduces the length of `this` by one and moves all later objects\n   * down by one position.\n   *\n   * Returns the removed object.\n   *\n   * The [index] must be in the range `0 ≤ index < length`.\n   *\n   * Throws an [UnsupportedError] if this is a fixed-length list. In that case\n   * the list is not modified.\n   */\n  E removeAt(int index);\n\n  /**\n   * Pops and returns the last object in this list.\n   *\n   * Throws an [UnsupportedError] if this is a fixed-length list.\n   */\n  E removeLast();\n\n  /**\n   * Removes all objects from this list that satisfy [test].\n   *\n   * An object [:o:] satisfies [test] if [:test(o):] is true.\n   *\n   *     List<String> numbers = ['one', 'two', 'three', 'four'];\n   *     numbers.removeWhere((item) => item.length == 3);\n   *     numbers.join(', '); // 'three, four'\n   *\n   * Throws an [UnsupportedError] if this is a fixed-length list.\n   */\n  void removeWhere(bool test(E element));\n\n  /**\n   * Removes all objects from this list that fail to satisfy [test].\n   *\n   * An object [:o:] satisfies [test] if [:test(o):] is true.\n   *\n   *     List<String> numbers = ['one', 'two', 'three', 'four'];\n   *     numbers.retainWhere((item) => item.length == 3);\n   *     numbers.join(', '); // 'one, two'\n   *\n   * Throws an [UnsupportedError] if this is a fixed-length list.\n   */\n  void retainWhere(bool test(E element));\n\n  /**\n   * Returns a new list containing the objects from [start] inclusive to [end]\n   * exclusive.\n   *\n   *     List<String> colors = ['red', 'green', 'blue', 'orange', 'pink'];\n   *     colors.sublist(1, 3); // ['green', 'blue']\n   *\n   * If [end] is omitted, the [length] of `this` is used.\n   *\n   *     colors.sublist(1);  // ['green', 'blue', 'orange', 'pink']\n   *\n   * An error occurs if [start] is outside the range `0` .. `length` or if\n   * [end] is outside the range `start` .. `length`.\n   */\n  List<E> sublist(int start, [int end]);\n\n  /**\n   * Returns an [Iterable] that iterates over the objects in the range\n   * [start] inclusive to [end] exclusive.\n   *\n   * An error occurs if [end] is before [start].\n   *\n   * An error occurs if the [start] and [end] are not valid ranges at the time\n   * of the call to this method. The returned [Iterable] behaves like\n   * `skip(start).take(end - start)`. That is, it does not throw exceptions\n   * if `this` changes size.\n   *\n   *     List<String> colors = ['red', 'green', 'blue', 'orange', 'pink'];\n   *     Iterable<String> range = colors.getRange(1, 4);\n   *     range.join(', ');  // 'green, blue, orange'\n   *     colors.length = 3;\n   *     range.join(', ');  // 'green, blue'\n   */\n  Iterable<E> getRange(int start, int end);\n\n  /**\n   * Copies the objects of [iterable], skipping [skipCount] objects first,\n   * into the range [start], inclusive, to [end], exclusive, of the list.\n   *\n   *     List<int> list1 = [1, 2, 3, 4];\n   *     List<int> list2 = [5, 6, 7, 8, 9];\n   *     // Copies the 4th and 5th items in list2 as the 2nd and 3rd items\n   *     // of list1.\n   *     list1.setRange(1, 3, list2, 3);\n   *     list1.join(', '); // '1, 8, 9, 4'\n   *\n   * The [start] and [end] indices must satisfy `0 ≤ start ≤ end ≤ length`.\n   * If [start] equals [end], this method has no effect.\n   *\n   * The [iterable] must have enough objects to fill the range from `start`\n   * to `end` after skipping [skipCount] objects.\n   *\n   * If `iterable` is this list, the operation will copy the elements originally\n   * in the range from `skipCount` to `skipCount + (end - start)` to the\n   * range `start` to `end`, even if the two ranges overlap.\n   *\n   * If `iterable` depends on this list in some other way, no guarantees are\n   * made.\n   */\n  void setRange(int start, int end, Iterable<E> iterable, [int skipCount = 0]);\n\n  /**\n   * Removes the objects in the range [start] inclusive to [end] exclusive.\n   *\n   * The [start] and [end] indices must be in the range\n   * `0 ≤ index ≤ length`, and `start ≤ end`.\n   *\n   * Throws an [UnsupportedError] if this is a fixed-length list. In that case\n   * the list is not modified.\n   */\n  void removeRange(int start, int end);\n\n  /**\n   * Sets the objects in the range [start] inclusive to [end] exclusive\n   * to the given [fillValue].\n   *\n   * An error occurs if [start]..[end] is not a valid range for `this`.\n   */\n  void fillRange(int start, int end, [E fillValue]);\n\n  /**\n   * Removes the objects in the range [start] inclusive to [end] exclusive\n   * and inserts the contents of [replacement] in its place.\n   *\n   *     List<int> list = [1, 2, 3, 4, 5];\n   *     list.replaceRange(1, 4, [6, 7]);\n   *     list.join(', '); // '1, 6, 7, 5'\n   *\n   * An error occurs if [start]..[end] is not a valid range for `this`.\n   */\n  void replaceRange(int start, int end, Iterable<E> replacement);\n\n  /**\n   * Returns an unmodifiable [Map] view of `this`.\n   *\n   * The map uses the indices of this list as keys and the corresponding objects\n   * as values. The `Map.keys` [Iterable] iterates the indices of this list\n   * in numerical order.\n   *\n   *     List<String> words = ['fee', 'fi', 'fo', 'fum'];\n   *     Map<int, String> map = words.asMap();\n   *     map[0] + map[1];   // 'feefi';\n   *     map.keys.toList(); // [0, 1, 2, 3]\n   */\n  Map<int, E> asMap();\n}\n\u0000","sdk:/sdk/lib/core/iterator.dart":"// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\npart of dart.core;\n\n/**\n * An interface for getting items, one at a time, from an object.\n *\n * The for-in construct transparently uses Iterator to test for the end\n * of the iteration, and to get each item (or _element_).\n *\n * If the object iterated over is changed during the iteration, the\n * behavior is unspecified.\n *\n * The Iterator is initially positioned before the first element. Before\n * accessing the first element the iterator must thus be advanced ([moveNext])\n * to point to the first element. If no element is left, then [moveNext]\n * returns false.\n *\n * A typical usage of an Iterator looks as follows:\n *\n *     var it = obj.iterator;\n *     while (it.moveNext()) {\n *       use(it.current);\n *     }\n *\n * **See also:** [Iteration]\n * (http://www.dartlang.org/docs/dart-up-and-running/contents/ch03.html#ch03-iteration)\n * in the [library tour]\n * (http://www.dartlang.org/docs/dart-up-and-running/contents/ch03.html)\n */\nabstract class Iterator<E> {\n  /**\n   * Moves to the next element. Returns true if [current] contains the next\n   * element. Returns false, if no element was left.\n   *\n   * It is safe to invoke [moveNext] even when the iterator is already\n   * positioned after the last element. In this case [moveNext] has no effect.\n   */\n  bool moveNext();\n\n  /**\n   * Returns the current element.\n   *\n   * Return [:null:] if the iterator has not yet been moved to the first\n   * element, or if the iterator has been moved after the last element of the\n   * [Iterable].\n   */\n  E get current;\n}\n\u0000","sdk:/sdk/lib/core/iterable.dart":"// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\npart of dart.core;\n\n/**\n * An object that uses an [Iterator] to serve objects one at a time.\n *\n * You can iterate over all objects served by an Iterable object\n * using the for-in loop construct.\n * For example, you can iterate over all of the keys in a [Map],\n * because Map keys are iterable.\n *\n *     Map kidsBooks = {'Matilda': 'Roald Dahl',\n *                      'Green Eggs and Ham': 'Dr Seuss',\n *                      'Where the Wild Things Are': 'Maurice Sendak'};\n *     for (var book in kidsBooks.keys) {\n *       print('$book was written by ${kidsBooks[book]}');\n *     }\n *\n * The [List] class and the [Set] class implement this interface,\n * as do classes in the [dart:collection](#dart-collection) library.\n *\n * You can implement Iterable in your own class.\n * If you do, then an instance of your Iterable class\n * can be the right-hand side of a for-in construct.\n *\n * Some subclasss of [Iterable] can be modified. It is generally not allowed\n * to modify such collections while they are being iterated. Doing so will break\n * the iteration, which is typically signalled by throwing a\n * [ConcurrentModificationError] when it is detected.\n */\nabstract class Iterable<E> {\n  const Iterable();\n\n  /**\n   * Creates an Iterable that generates its elements dynamically.\n   *\n   * The Iterators created by the Iterable count from\n   * zero to [:count - 1:] while iterating, and call [generator]\n   * with that index to create the next value.\n   *\n   * If [generator] is omitted, it defaults to an identity function\n   * on integers `(int x) => x`, so it should only be omitted if the type\n   * parameter allows integer values.\n   *\n   * As an Iterable, [:new Iterable.generate(n, generator)):] is equivalent to\n   * [:const [0, ..., n - 1].map(generator):]\n   */\n  factory Iterable.generate(int count, [E generator(int index)]) {\n    if (count <= 0) return new EmptyIterable<E>();\n    return new _GeneratorIterable<E>(count, generator);\n  }\n\n  /**\n   * Returns a new `Iterator` that allows iterating the elements of this\n   * `Iterable`.\n   */\n  Iterator<E> get iterator;\n\n  /**\n   * Returns a new lazy [Iterable] with elements that are created by\n   * calling `f` on the elements of this `Iterable`.\n   *\n   * This method returns a view of the mapped elements. As long as the\n   * returned [Iterable] is not iterated over, the supplied function [f] will\n   * not be invoked. The transformed elements will not be cached. Iterating\n   * multiple times over the the returned [Iterable] will invoke the supplied\n   * function [f] multiple times on the same element.\n   */\n  Iterable map(f(E element));\n\n  /**\n   * Returns a new lazy [Iterable] with all elements that satisfy the\n   * predicate [test].\n   *\n   * This method returns a view of the mapped elements. As long as the\n   * returned [Iterable] is not iterated over, the supplied function [test] will\n   * not be invoked. Iterating will not cache results, and thus iterating\n   * multiple times over the returned [Iterable] will invoke the supplied\n   * function [test] multiple times on the same element.\n   */\n  Iterable<E> where(bool test(E element));\n\n  /**\n   * Expands each element of this [Iterable] into zero or more elements.\n   *\n   * The resulting Iterable runs through the elements returned\n   * by [f] for each element of this, in order.\n   *\n   * The returned [Iterable] is lazy, and calls [f] for each element\n   * of this every time it's iterated.\n   */\n  Iterable expand(Iterable f(E element));\n\n  /**\n   * Returns true if the collection contains an element equal to [element].\n   *\n   * The equality used to determine whether [element] is equal to an element of\n   * the iterable, depends on the type of iterable.\n   * For example, a [Set] may have a custom equality\n   * (see, e.g., [Set.identical]) that its `contains` uses.\n   * Likewise the `Iterable` returned by a [Map.keys] call\n   * will likely use the same equality that the `Map` uses for keys.\n   */\n  bool contains(Object element);\n\n  /**\n   * Applies the function [f] to each element of this collection.\n   */\n  void forEach(void f(E element));\n\n  /**\n   * Reduces a collection to a single value by iteratively combining elements\n   * of the collection using the provided function.\n   *\n   * Example of calculating the sum of an iterable:\n   *\n   *     iterable.reduce((value, element) => value + element);\n   *\n   */\n  E reduce(E combine(E value, E element));\n\n  /**\n   * Reduces a collection to a single value by iteratively combining each\n   * element of the collection with an existing value using the provided\n   * function.\n   *\n   * Use [initialValue] as the initial value, and the function [combine] to\n   * create a new value from the previous one and an element.\n   *\n   * Example of calculating the sum of an iterable:\n   *\n   *     iterable.fold(0, (prev, element) => prev + element);\n   *\n   */\n  dynamic fold(var initialValue,\n               dynamic combine(var previousValue, E element));\n\n  /**\n   * Returns true if every elements of this collection satisify the\n   * predicate [test]. Returns `false` otherwise.\n   */\n  bool every(bool test(E element));\n\n  /**\n   * Converts each element to a [String] and concatenates the strings.\n   *\n   * Converts each element to a [String] by calling [Object.toString] on it.\n   * Then concatenates the strings, optionally separated by the [separator]\n   * string.\n   */\n  String join([String separator = \"\"]) {\n    StringBuffer buffer = new StringBuffer();\n    buffer.writeAll(this, separator);\n    return buffer.toString();\n  }\n\n  /**\n   * Returns true if one element of this collection satisfies the\n   * predicate [test]. Returns false otherwise.\n   */\n  bool any(bool test(E element));\n\n  /**\n   * Creates a [List] containing the elements of this [Iterable].\n   *\n   * The elements are in iteration order. The list is fixed-length\n   * if [growable] is false.\n   */\n  List<E> toList({ bool growable: true });\n\n  /**\n   * Creates a [Set] containing the same elements as this iterable.\n   *\n   * The returned `Set` will have the same `Set.length`\n   * as the `length` of this iterable,\n   * and its `Set.contains` will return the same result\n   * as the `contains` of this iterable.\n   * The order of the elements may be different.\n   */\n  Set<E> toSet();\n\n  /**\n   * Returns the number of elements in [this].\n   *\n   * Counting all elements may be involve running through all elements and can\n   * therefore be slow.\n   */\n  int get length;\n\n  /**\n   * Returns true if there is no element in this collection.\n   */\n  bool get isEmpty;\n\n  /**\n   * Returns true if there is at least one element in this collection.\n   */\n  bool get isNotEmpty;\n\n  /**\n   * Returns an [Iterable] with at most [n] elements.\n   *\n   * The returned [Iterable] may contain fewer than [n] elements, if `this`\n   * contains fewer than [n] elements.\n   *\n   * It is an error if [n] is negative.\n   */\n  Iterable<E> take(int n);\n\n  /**\n   * Returns an Iterable that stops once [test] is not satisfied anymore.\n   *\n   * The filtering happens lazily. Every new Iterator of the returned\n   * Iterable starts iterating over the elements of `this`.\n   *\n   * When the iterator encounters an element `e` that does not satisfy [test],\n   * it discards `e` and moves into the finished state. That is, it does not\n   * get or provide any more elements.\n   */\n  Iterable<E> takeWhile(bool test(E value));\n\n  /**\n   * Returns an Iterable that skips the first [n] elements.\n   *\n   * If `this` has fewer than [n] elements, then the resulting Iterable is\n   * empty.\n   *\n   * It is an error if [n] is negative.\n   */\n  Iterable<E> skip(int n);\n\n  /**\n   * Returns an Iterable that skips elements while [test] is satisfied.\n   *\n   * The filtering happens lazily. Every new Iterator of the returned\n   * Iterable iterates over all elements of `this`.\n   *\n   * As long as the iterator's elements satisfy [test] they are\n   * discarded. Once an element does not satisfy the [test] the iterator stops\n   * testing and uses every later element unconditionally. That is, the elements\n   * of the returned Iterable are the elements of `this` starting from the\n   * first element that does not satisfy [test].\n   */\n  Iterable<E> skipWhile(bool test(E value));\n\n  /**\n   * Returns the first element.\n   *\n   * If `this` is empty throws a [StateError]. Otherwise this method is\n   * equivalent to [:this.elementAt(0):]\n   */\n  E get first;\n\n  /**\n   * Returns the last element.\n   *\n   * If `this` is empty throws a [StateError].\n   */\n  E get last;\n\n  /**\n   * Returns the single element in `this`.\n   *\n   * If `this` is empty or has more than one element throws a [StateError].\n   */\n  E get single;\n\n  /**\n   * Returns the first element that satisfies the given predicate [test].\n   *\n   * If none matches, the result of invoking the [orElse] function is\n   * returned. By default, when [orElse] is `null`, a [StateError] is\n   * thrown.\n   */\n  E firstWhere(bool test(E element), { E orElse() });\n\n  /**\n   * Returns the last element that satisfies the given predicate [test].\n   *\n   * If none matches, the result of invoking the [orElse] function is\n   * returned. By default, when [orElse] is `null`, a [StateError] is\n   * thrown.\n   */\n  E lastWhere(bool test(E element), {E orElse()});\n\n  /**\n   * Returns the single element that satisfies [test]. If no or more than one\n   * element match then a [StateError] is thrown.\n   */\n  E singleWhere(bool test(E element));\n\n  /**\n   * Returns the [index]th element.\n   *\n   * The [index] must be non-negative and less than [length].\n   *\n   * Note: if `this` does not have a deterministic iteration order then the\n   * function may simply return any element without any iteration if there are\n   * at least [index] elements in `this`.\n   */\n  E elementAt(int index);\n}\n\ntypedef E _Generator<E>(int index);\n\nclass _GeneratorIterable<E> extends IterableBase<E>\n                            implements EfficientLength {\n  final int _start;\n  final int _end;\n  final _Generator<E> _generator;\n  _GeneratorIterable(this._end, E generator(int n))\n      : _start = 0,\n        _generator = (generator != null) ? generator : _id;\n\n  _GeneratorIterable.slice(this._start, this._end, this._generator);\n\n  Iterator<E> get iterator =>\n      new _GeneratorIterator<E>(_start, _end, _generator);\n  int get length => _end - _start;\n\n  Iterable<E> skip(int n) {\n    if (n < 0) throw new RangeError.value(n);\n    if (n == 0) return this;\n    int newStart = _start + n;\n    if (newStart >= _end) return new EmptyIterable<E>();\n    return new _GeneratorIterable<E>.slice(newStart, _end, _generator);\n  }\n\n  Iterable<E> take(int n) {\n    if (n < 0) throw new RangeError.value(n);\n    if (n == 0) return new EmptyIterable<E>();\n    int newEnd = _start + n;\n    if (newEnd >= _end) return this;\n    return new _GeneratorIterable<E>.slice(_start, newEnd, _generator);\n  }\n\n  static int _id(int n) => n;\n}\n\nclass _GeneratorIterator<E> implements Iterator<E> {\n  final int _end;\n  final _Generator<E> _generator;\n  int _index;\n  E _current;\n\n  _GeneratorIterator(this._index, this._end, this._generator);\n\n  bool moveNext() {\n    if (_index < _end) {\n      _current = _generator(_index);\n      _index++;\n      return true;\n    } else {\n      _current = null;\n      return false;\n    }\n  }\n\n  E get current => _current;\n}\n\n/**\n * An Iterator that allows moving backwards as well as forwards.\n */\nabstract class BidirectionalIterator<E> implements Iterator<E> {\n  /**\n   * Move back to the previous element.\n   *\n   * Returns true and updates [current] if successful. Returns false\n   * and sets [current] to null if there is no previous element.\n   */\n  bool movePrevious();\n}\n\u0000","sdk:/sdk/lib/core/invocation.dart":"// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\npart of dart.core;\n\n/**\n * Representation of the invocation of a member on an object.\n *\n * This is the type of objects passed to [Object.noSuchMethod] when\n * an object doesn't support the member invocation that was attempted\n * on it.\n */\nabstract class Invocation {\n  /** The name of the invoked member. */\n  Symbol get memberName;\n\n  /**\n   * An unmodifiable view of the positional arguments of the call.\n   *\n   * If the member is a getter, the positional arguments is empty.\n   */\n  List get positionalArguments;\n\n  /**\n   * An unmodifiable view of the named arguments of the call.\n   *\n   * If the member is a getter, setter or operator, the named arguments\n   * is empty.\n   */\n  Map<Symbol, dynamic> get namedArguments;\n\n  /** Whether the invocation was a method call. */\n  bool get isMethod;\n\n  /**\n   * Whether the invocation was a getter call.\n   * If so, both types of arguments is empty.\n   */\n  bool get isGetter;\n\n  /**\n   * Whether the invocation was a setter call.\n   *\n   * If so, [arguments] has exactly one positonal argument,\n   * and [namedArguments] is empty.\n   */\n  bool get isSetter;\n\n  /** Whether the invocation was a getter or a setter call. */\n  bool get isAccessor => isGetter || isSetter;\n}\n\u0000","sdk:/sdk/lib/core/int.dart":"// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\npart of dart.core;\n\n/**\n * An arbitrarily large integer.\n *\n * **Note:** When compiling to JavaScript, integers are\n * implemented as JavaScript numbers. When compiling to JavaScript,\n * integers are therefore restricted to 53 significant bits because\n * all JavaScript numbers are double-precision floating point\n * values. The behavior of the operators and methods in the [int]\n * class therefore sometimes differs between the Dart VM and Dart code\n * compiled to JavaScript.\n *\n * It is a compile-time error for a class to attempt to extend or implement int.\n */\nabstract class int extends num {\n  /**\n   * Returns the integer value of the given environment declaration [name].\n   *\n   * The result is the same as would be returned by:\n   *\n   *     int.parse(const String.fromEnvironment(name, defaultValue: \"\"),\n   *               (_) => defaultValue)\n   *\n   * Example:\n   *\n   *     const int.fromEnvironment(\"defaultPort\", defaultValue: 80)\n   */\n  external const factory int.fromEnvironment(String name, {int defaultValue});\n\n  /**\n   * Bit-wise and operator.\n   *\n   * Treating both `this` and [other] as sufficiently large two's component\n   * integers, the result is a number with only the bits set that are set in\n   * both `this` and [other]\n   *\n   * Of both operands are negative, the result is negative, otherwise\n   * the result is non-negative.\n   */\n  int operator &(int other);\n\n  /**\n   * Bit-wise or operator.\n   *\n   * Treating both `this` and [other] as sufficiently large two's component\n   * integers, the result is a number with the bits set that are set in either\n   * of `this` and [other]\n   *\n   * If both operands are non-negative, the result is non-negative,\n   * otherwise the result us negative.\n   */\n  int operator |(int other);\n\n  /**\n   * Bit-wise exclusive-or operator.\n   *\n   * Treating both `this` and [other] as sufficiently large two's component\n   * integers, the result is a number with the bits set that are set in one,\n   * but not both, of `this` and [other]\n   *\n   * If the operands have the same sign, the result is non-negative,\n   * otherwise the result is negative.\n   */\n  int operator ^(int other);\n\n  /**\n   * The bit-wise negate operator.\n   *\n   * Treating `this` as a sufficiently large two's component integer,\n   * the result is a number with the opposite bits set.\n   *\n   * This maps any integer `x` to `-x - 1`.\n   */\n  int operator ~();\n\n  /**\n   * Shift the bits of this integer to the left by [shiftAmount].\n   *\n   * Shifting to the left makes the number larger, effectively multiplying\n   * the number by `pow(2, shiftIndex)`.\n   *\n   * There is no limit on the size of the result. It may be relevant to\n   * limit intermediate values by using the \"and\" operator with a suitable\n   * mask.\n   *\n   * It is an error of [shiftAmount] is negative.\n   */\n  int operator <<(int shiftAmount);\n\n  /**\n   * Shift the bits of this integer to the right by [shiftAmount].\n   *\n   * Shifting to the right makes the number smaller and drops the least\n   * significant bits, effectively doing an integer division by\n   *`pow(2, shiftIndex)`.\n   *\n   * It is an error of [shiftAmount] is negative.\n   */\n  int operator >>(int shiftAmount);\n\n  /** Returns true if and only if this integer is even. */\n  bool get isEven;\n\n  /** Returns true if and only if this integer is odd. */\n  bool get isOdd;\n\n  /**\n   * Returns the minimum number of bits required to store this integer.\n   *\n   * The number of bits excludes the sign bit, which gives the natural length\n   * for non-negative (unsigned) values.  Negative values are complemented to\n   * return the bit position of the first bit that differs from the sign bit.\n   *\n   * To find the the number of bits needed to store the value as a signed value,\n   * add one, i.e. use `x.bitLength + 1`.\n   *\n   *      x.bitLength == (-x-1).bitLength\n   *\n   *      3.bitLength == 2;     // 00000011\n   *      2.bitLength == 2;     // 00000010\n   *      1.bitLength == 1;     // 00000001\n   *      0.bitLength == 0;     // 00000000\n   *      (-1).bitLength == 0;  // 11111111\n   *      (-2).bitLength == 1;  // 11111110\n   *      (-3).bitLength == 2;  // 11111101\n   *      (-4).bitLength == 2;  // 11111100\n   */\n  int get bitLength;\n\n  /**\n   * Returns the least significant [width] bits of this integer as a\n   * non-negative number (i.e. unsigned representation).  The returned value has\n   * zeros in all bit positions higher than [width].\n   *\n   *     (-1).toUnsigned(5) == 32   // 11111111  ->  00011111\n   *\n   * This operation can be used to simulate arithmetic from low level languages.\n   * For example, to increment an 8 bit quantity:\n   *\n   *     q = (q + 1).toUnsigned(8);\n   *\n   * `q` will count from `0` up to `255` and then wrap around to `0`.\n   *\n   * If the input fits in [width] bits without truncation, the result is the\n   * same as the input.  The minimum width needed to avoid truncation of `x` is\n   * given by `x.bitLength`, i.e.\n   *\n   *     x == x.toUnsigned(x.bitLength);\n   */\n  int toUnsigned(int width);\n\n  /**\n   * Returns the least significant [width] bits of this integer, extending the\n   * highest retained bit to the sign.  This is the same as truncating the value\n   * to fit in [width] bits using an signed 2-s complement representation.  The\n   * returned value has the same bit value in all positions higher than [width].\n   *\n   *                                    V--sign bit-V\n   *     16.toSigned(5) == -16   //  00010000 -> 11110000\n   *     239.toSigned(5) == 15   //  11101111 -> 00001111\n   *                                    ^           ^\n   *\n   * This operation can be used to simulate arithmetic from low level languages.\n   * For example, to increment an 8 bit signed quantity:\n   *\n   *     q = (q + 1).toSigned(8);\n   *\n   * `q` will count from `0` up to `127`, wrap to `-128` and count back up to\n   * `127`.\n   *\n   * If the input value fits in [width] bits without truncation, the result is\n   * the same as the input.  The minimum width needed to avoid truncation of `x`\n   * is `x.bitLength + 1`, i.e.\n   *\n   *     x == x.toSigned(x.bitLength + 1);\n   */\n  int toSigned(int width);\n\n  /**\n   * Return the negative value of this integer.\n   *\n   * The result of negating an integer always has the opposite sign, except\n   * for zero, which is its own negation.\n   */\n  int operator -();\n\n  /**\n   * Returns the absolute value of this integer.\n   *\n   * For any integer `x`, the result is the same as `x < 0 ? -x : x`.\n   */\n  int abs();\n\n  /**\n   * Returns the sign of this integer.\n   *\n   * Returns 0 for zero, -1 for values less than zero and\n   * +1 for values greater than zero.\n   */\n  int get sign;\n\n  /** Returns `this`. */\n  int round();\n\n  /** Returns `this`. */\n  int floor();\n\n  /** Returns `this`. */\n  int ceil();\n\n  /** Returns `this`. */\n  int truncate();\n\n  /** Returns `this.toDouble()`. */\n  double roundToDouble();\n\n  /** Returns `this.toDouble()`. */\n  double floorToDouble();\n\n  /** Returns `this.toDouble()`. */\n  double ceilToDouble();\n\n  /** Returns `this.toDouble()`. */\n  double truncateToDouble();\n\n  /**\n   * Returns a String-representation of this integer.\n   *\n   * The returned string is parsable by [parse].\n   * For any `int` [:i:], it is guaranteed that\n   * [:i == int.parse(i.toString()):].\n   */\n  String toString();\n\n  /**\n   * Converts [this] to a string representation in the given [radix].\n   *\n   * In the string representation, lower-case letters are used for digits above\n   * '9'.\n   *\n   * The [radix] argument must be an integer in the range 2 to 36.\n   */\n  String toRadixString(int radix);\n\n  /**\n   * Parse [source] as an integer literal and return its value.\n   *\n   * The [radix] must be in the range 2..36. The digits used are\n   * first the decimal digits 0..9, and then the letters 'a'..'z'.\n   * Accepts capital letters as well.\n   *\n   * If no [radix] is given then it defaults to 10, unless the string starts\n   * with \"0x\", \"-0x\" or \"+0x\", in which case the radix is set to 16 and the\n   * \"0x\" is ignored.\n   *\n   * The [source] must be a non-empty sequence of base-[radix] digits,\n   * optionally prefixed with a minus or plus sign ('-' or '+').\n   *\n   * It must always be the case for an int [:n:] and radix [:r:] that\n   * [:n == parseRadix(n.toRadixString(r), r):].\n   *\n   * If the [source] is not a valid integer literal, optionally prefixed by a\n   * sign, the [onError] is called with the [source] as argument, and its return\n   * value is used instead. If no [onError] is provided, a [FormatException]\n   * is thrown.\n   *\n   * The [onError] function is only invoked if [source] is a [String]. It is\n   * not invoked if the [source] is, for example, `null`.\n   */\n  external static int parse(String source,\n                            { int radix,\n                              int onError(String source) });\n}\n\u0000","sdk:/sdk/lib/core/identical.dart":"// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\npart of dart.core;\n\n/**\n * Check whether two references are to the same object.\n */\nexternal bool identical(Object a, Object b);\n\n/**\n * Returns the identity hash code of `object`.\n *\n * Returns the same value as `object.hashCode` if [object] has not overridden\n * [Object.hashCode]. Returns the value that [Object.hashCode] would return\n * on this object, even if `hashCode` has been overridden.\n *\n * This hash code is compatible with [identical].\n */\nexternal int identityHashCode(Object object);\n\u0000","sdk:/sdk/lib/core/function.dart":"// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\npart of dart.core;\n\n/**\n * The base class for all function types.\n *\n * A function value, or an instance of a class with a \"call\" method, is a\n * subtype of a function type, and as such, a subtype of [Function].\n */\nabstract class Function {\n  /**\n   * Dynamically call [function] with the specified arguments.\n   *\n   * Acts the same as calling function with positional arguments\n   * corresponding to the elements of [positionalArguments] and\n   * named arguments corresponding to the elements of [namedArguments].\n   *\n   * This includes giving the same errors if [function] isn't callable or\n   * if it expects different parameters.\n   *\n   * Example:\n   *       Map<Symbol, dynamic> namedArguments = new Map<Symbol, dynamic>();\n   *       namedArguments[const Symbol(\"f\")] = 4;\n   *       namedArguments[const Symbol(\"g\")] = 5;\n   *       Function.apply(foo, [1,2,3], namedArguments);\n   *\n   * gives exactly the same result as\n   *       foo(1, 2, 3, f: 4, g: 5).\n   *\n   * If [positionalArguments] is null, it's considered an empty list.\n   * If [namedArguments] is omitted or null, it is considered an empty map.\n   */\n  external static apply(Function function,\n                        List positionalArguments,\n                        [Map<Symbol, dynamic> namedArguments]);\n\n  /**\n   * Returns a hash code value that is compatible with `operator==`.\n   */\n  int get hashCode;\n\n  /**\n   * Test whether another object is equal to this function.\n   *\n   * System-created function objects are only equal to other functions.\n   *\n   * Two function objects are known to represent the same function if\n   *\n   * - It is the same object. Static and top-level functions are compile time\n   *   constants when used as values, so referring to the same function twice\n   *   always give the same object,\n   * - or if they refer to the same member method extracted from the same object.\n   *   Extracting a member method as a function value twice gives equal, but\n   *   not necessarily identical, function values.\n   *\n   * Function expressions never give rise to equal function objects. Each time\n   * a function expression is evaluated, it creates a new closure value that\n   * is not known to be equal to other closures created by the same expression.\n   *\n   * Classes implementing `Function` by having a `call` method should have their\n   * own `operator==` and `hashCode` depending on the object.\n   */\n  bool operator==(Object other);\n}\n\u0000","sdk:/sdk/lib/core/expando.dart":"// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\npart of dart.core;\n\n/**\n * An [Expando] allows adding new properties to objects.\n *\n * Does not work on numbers, strings, booleans or null.\n *\n * An `Expando` does not hold on to the added property value after an object\n * becomes inacessible.\n *\n * Since you can always create a new number that is identical to an existing\n * number, it means that an expando property on a number could never be\n * released. To avoid this, expando properties cannot be added to numbers.\n * The same argument applies to strings, booleans and null, which also have\n * literals that evaluate to identical values when they occur more than once.\n *\n * There is no restriction on other classes, even for compile time constant\n * objects. Be careful if adding expando properties to compile time constants,\n * since they will stay alive forever.\n */\nclass Expando<T> {\n\n  /**\n   * The name of the this [Expando] as passed to the constructor. If\n   * no name was passed to the constructor, the name is [:null:].\n   */\n  final String name;\n\n  /**\n   * Creates a new [Expando]. The optional name is only used for\n   * debugging purposes and creating two different [Expando]s with the\n   * same name yields two [Expando]s that work on different properties\n   * of the objects they are used on.\n   */\n  external Expando([String name]);\n\n  /**\n   * Expando toString method override.\n   */\n  String toString() => \"Expando:$name\";\n\n  /**\n   * Gets the value of this [Expando]'s property on the given\n   * object. If the object hasn't been expanded, the method returns\n   * [:null:].\n   *\n   * The object must not be a number, a string, a boolean or null.\n   */\n  external T operator [](Object object);\n\n  /**\n   * Sets the value of this [Expando]'s property on the given\n   * object. Properties can effectively be removed again by setting\n   * their value to null.\n   *\n   * The object must not be a number, a string, a boolean or null.\n   */\n  external void operator []=(Object object, T value);\n\n}\n\u0000","sdk:/sdk/lib/core/exceptions.dart":"// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\npart of dart.core;\n\n// Exceptions are thrown either by the VM or from Dart code.\n\n/**\n * A marker interface implemented by all core library exceptions.\n *\n * An [Exception] is intended to convey information to the user about a failure,\n * so that the error can be addressed programmatically. It is intended to be\n * caught, and it should contain useful data fields.\n *\n * Creating instances of [Exception] directly with [:new Exception(\"message\"):]\n * is discouraged, and only included as a temporary measure during development,\n * until the actual exceptions used by a library are done.\n */\nabstract class Exception {\n  factory Exception([var message]) => new _ExceptionImplementation(message);\n}\n\n\n/** Default implementation of [Exception] which carries a message. */\nclass _ExceptionImplementation implements Exception {\n  final message;\n\n  _ExceptionImplementation([this.message]);\n\n  String toString() {\n    if (message == null) return \"Exception\";\n    return \"Exception: $message\";\n  }\n}\n\n\n/**\n * Exception thrown when a string or some other data does not have an expected\n * format and cannot be parsed or processed.\n */\nclass FormatException implements Exception {\n  /**\n   * A message describing the format error.\n   */\n  final String message;\n\n  /**\n   * The actual source input that caused the error.\n   *\n   * This is usually a [String], but can be other types too.\n   * If it is a string, parts of it may be included in the [toString] message.\n   *\n   * The source is `null` if omitted or unknown.\n   */\n  final source;\n\n  /**\n   * The offset in [source] where the error was detected.\n   *\n   * A zero-based offset into the source that marks the format error causing\n   * this exception to be created. If `source` is a string, this should be a\n   * string index in the range `0 <= offset <= source.length`.\n   *\n   * If input is a string, the [toString] method may represent this offset as\n   * a line and character position. The offset should be inside the string,\n   * or at the end of the string.\n   *\n   * May be omitted. If present, [source] should also be present if possible.\n   */\n  final int offset;\n\n  /**\n   * Creates a new FormatException with an optional error [message].\n   *\n   * Optionally also supply the actual [source] that had the incorrect format,\n   * and an [offset] in the format where a problem was detected.\n   */\n  const FormatException([this.message = \"\", this.source, this.offset]);\n\n  /**\n   * Returns a description of the format exception.\n   *\n   * The description always contains the [message].\n   *\n   * If [source] is present and is a string, the description will contain\n   * (at least a part of) the source.\n   * If [offset] is also provided, the part of the source included will\n   * contain that offset, and the offset will be marked.\n   *\n   * If the source is a string and it contains a line break before offset,\n   * only the line containing offset will be included, and its line number\n   * will also be part of the description. Line and character offsets are\n   * 1-based.\n   */\n  String toString() {\n    String report = \"FormatException\";\n    if (message != null && \"\" != message) {\n      report = \"$report: $message\";\n    }\n    int offset = this.offset;\n    if (source is! String) {\n      if (offset != null) {\n        report += \" (at offset $offset)\";\n      }\n      return report;\n    }\n    if (offset != null && (offset < 0 || offset > source.length)) {\n      offset = null;\n    }\n    // Source is string and offset is null or valid.\n    if (offset == null) {\n      String source = this.source;\n      if (source.length > 78) {\n        source = source.substring(0, 75) + \"...\";\n      }\n      return \"$report\\n$source\";\n    }\n    int lineNum = 1;\n    int lineStart = 0;\n    bool lastWasCR;\n    for (int i = 0; i < offset; i++) {\n      int char = source.codeUnitAt(i);\n      if (char == 0x0a) {\n        if (lineStart != i || !lastWasCR) {\n          lineNum++;\n        }\n        lineStart = i + 1;\n        lastWasCR = false;\n      } else if (char == 0x0d) {\n        lineNum++;\n        lineStart = i + 1;\n        lastWasCR = true;\n      }\n    }\n    if (lineNum > 1) {\n      report += \" (at line $lineNum, character ${offset - lineStart + 1})\\n\";\n    } else {\n      report += \" (at character ${offset + 1})\\n\";\n    }\n    int lineEnd = source.length;\n    for (int i = offset; i < source.length; i++) {\n      int char = source.codeUnitAt(i);\n      if (char == 0x0a || char == 0x0d) {\n        lineEnd = i;\n        break;\n      }\n    }\n    int length = lineEnd - lineStart;\n    int start = lineStart;\n    int end = lineEnd;\n    String prefix = \"\";\n    String postfix = \"\";\n    if (length > 78) {\n      // Can't show entire line. Try to anchor at the nearest end, if\n      // one is within reach.\n      int index = offset - lineStart;\n      if (index < 75) {\n        end = start + 75;\n        postfix = \"...\";\n      } else if (end - offset < 75) {\n        start = end - 75;\n        prefix = \"...\";\n      } else {\n        // Neither end is near, just pick an area around the offset.\n        start = offset - 36;\n        end = offset + 36;\n        prefix = postfix = \"...\";\n      }\n    }\n    String slice = source.substring(start, end);\n    int markOffset = offset - start + prefix.length;\n    return \"$report$prefix$slice$postfix\\n${\" \" * markOffset}^\\n\";\n  }\n}\n\nclass IntegerDivisionByZeroException implements Exception {\n  const IntegerDivisionByZeroException();\n  String toString() => \"IntegerDivisionByZeroException\";\n}\n\u0000","sdk:/sdk/lib/core/errors.dart":"// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\npart of dart.core;\n\n/**\n * Error objects thrown in the case of a program failure.\n *\n * An `Error` object represents a program failure that the programmer\n * should have avoided.\n *\n * Examples include calling a function with invalid arguments,\n * or even with the wrong number of arguments,\n * or calling it at a time when it is not allowed.\n *\n * These are not errors that a caller should expect or catch -\n * if they occur, the program is erroneous,\n * and terminating the program may be the safest response.\n *\n * When deciding that a function throws an error,\n * the conditions where it happens should be clearly described,\n * and they should be detectable and predictable,\n * so the programmer using the function can avoid triggering the error.\n *\n * Such descriptions often uses words like\n * \"must\" or \"must not\" to describe the condition,\n * and if you see words like that in a function's documentation,\n * then not satisfying the requirement\n * is very likely to cause an error to be thrown.\n *\n * Example (from [String.contains]):\n *\n *        `startIndex` must not be negative or greater than `length`.\n *\n * In this case, an error will be thrown if `startIndex` is negative\n * or too large.\n *\n * If the conditions are not detectable before calling a function,\n * the called function should not throw an `Error`.\n * It may still throw a value,\n * but the caller will have to catch the thrown value,\n * effectively making it an alternative result rather than an error.\n * The thrown object can choose to implement [Exception]\n * to document that it represents an exceptional, but not erroneous, occurrence,\n * but it has no other effect than documentation.\n *\n * All non-`null` values can be thrown in Dart.\n * Objects extending `Error` are handled specially:\n * The first time they are thrown,\n * the stack trace at the throw point is recorded\n * and stored in the error object.\n * It can be retrieved using the [stackTrace] getter.\n * An error object that merely implements `Error`, and doesn't extend it,\n * will not store the stack trace automatically.\n *\n * Error objects are also used for system wide failures\n * like stack overflow or an out-of-memory situation.\n *\n * Since errors are not created to be caught,\n * there is no need for subclasses to distinguish the errors.\n * Instead subclasses have been created in order to make groups\n * of related errors easy to create with consistent error messages.\n * For example, the [String.contains] method will use a [RangeError]\n * if its `startIndex` isn't in the range `0..length`,\n * which is easily created by `new RangeError.range(startIndex, 0, length)`.\n */\nclass Error {\n  Error();  // Prevent use as mixin.\n\n  /**\n   * Safely convert a value to a [String] description.\n   *\n   * The conversion is guaranteed to not throw, so it won't use the object's\n   * toString method.\n   */\n  static String safeToString(Object object) {\n    if (object is num || object is bool || null == object) {\n      return object.toString();\n    }\n    if (object is String) {\n      String string = object;\n      StringBuffer buffer = new StringBuffer('\"');\n      const int TAB = 0x09;\n      const int NEWLINE = 0x0a;\n      const int CARRIGE_RETURN = 0x0d;\n      const int BACKSLASH = 0x5c;\n      const int DOUBLE_QUOTE = 0x22;\n      const int DIGIT_ZERO = 0x30;\n      const int LOWERCASE_A = 0x61;\n      const int MAX_CONTROL = 0x1f;\n      for (int i = 0; i < string.length; i++) {\n        int codeUnit = string.codeUnitAt(i);\n        if (codeUnit <= MAX_CONTROL) {\n          if (codeUnit == NEWLINE) {\n            buffer.write(r\"\\n\");\n          } else if (codeUnit == CARRIGE_RETURN) {\n            buffer.write(r\"\\r\");\n          } else if (codeUnit == TAB) {\n            buffer.write(r\"\\t\");\n          } else {\n            buffer.write(r\"\\x\");\n            // Convert code in range 0x00 .. 0x1f to hex a two-digit hex string.\n            if (codeUnit < 0x10) {\n              buffer.write(\"0\");\n            } else {\n              buffer.write(\"1\");\n              codeUnit -= 0x10;\n            }\n            // Single digit to hex.\n            buffer.writeCharCode(codeUnit < 10 ? DIGIT_ZERO + codeUnit\n                                               : LOWERCASE_A - 10 + codeUnit);\n          }\n        } else if (codeUnit == BACKSLASH) {\n          buffer.write(r\"\\\\\");\n        } else if (codeUnit == DOUBLE_QUOTE) {\n          buffer.write(r'\\\"');\n        } else {\n          buffer.writeCharCode(codeUnit);\n        }\n      }\n      buffer.write('\"');\n      return buffer.toString();\n    }\n    return _objectToString(object);\n  }\n\n  external static String _objectToString(Object object);\n\n  external StackTrace get stackTrace;\n}\n\n/**\n * Error thrown by the runtime system when an assert statement fails.\n */\nclass AssertionError extends Error {\n}\n\n/**\n * Error thrown by the runtime system when a type assertion fails.\n */\nclass TypeError extends AssertionError {\n}\n\n/**\n * Error thrown by the runtime system when a cast operation fails.\n */\nclass CastError extends Error {\n}\n\n/**\n * Error thrown when attempting to throw [:null:].\n */\nclass NullThrownError extends Error {\n  String toString() => \"Throw of null.\";\n}\n\n/**\n * Error thrown when a function is passed an unacceptable argument.\n */\nclass ArgumentError extends Error {\n  final message;\n\n  /** The [message] describes the erroneous argument. */\n  ArgumentError([this.message]);\n\n  String toString() {\n    if (message != null) {\n      return \"Illegal argument(s): $message\";\n    }\n    return \"Illegal argument(s)\";\n  }\n}\n\n/**\n * Error thrown due to an index being outside a valid range.\n */\nclass RangeError extends ArgumentError {\n  // TODO(lrn): This constructor should be called only with string values.\n  // It currently isn't in all cases.\n  /**\n   * Create a new [RangeError] with the given [message].\n   */\n  RangeError(var message) : super(message);\n\n  /** Create a new [RangeError] with a message for the given [value]. */\n  RangeError.value(num value) : super(\"value $value\");\n\n  /**\n   * Create a new [RangeError] with a message for a value and a range.\n   *\n   * The allowed range is from [start] to [end], inclusive.\n   */\n  RangeError.range(num value, num start, num end)\n      : super(\"value $value not in range $start..$end\");\n\n  String toString() => \"RangeError: $message\";\n}\n\n\n/**\n * Error thrown when control reaches the end of a switch case.\n *\n * The Dart specification requires this error to be thrown when\n * control reaches the end of a switch case (except the last case\n * of a switch) without meeting a break or similar end of the control\n * flow.\n */\nclass FallThroughError extends Error {\n  FallThroughError();\n}\n\n/**\n * Error thrown when trying to instantiate an abstract class.\n */\nclass AbstractClassInstantiationError extends Error {\n  final String _className;\n  AbstractClassInstantiationError(String this._className);\n  String toString() => \"Cannot instantiate abstract class: '$_className'\";\n}\n\n\n/**\n * Error thrown by the default implementation of [:noSuchMethod:] on [Object].\n */\nclass NoSuchMethodError extends Error {\n  final Object _receiver;\n  final Symbol _memberName;\n  final List _arguments;\n  final Map<Symbol, dynamic> _namedArguments;\n  final List _existingArgumentNames;\n\n  /**\n   * Create a [NoSuchMethodError] corresponding to a failed method call.\n   *\n   * The [receiver] is the receiver of the method call.\n   * That is, the object on which the method was attempted called.\n   * If the receiver is `null`, it is interpreted as a call to a top-level\n   * function of a library.\n   *\n   * The [memberName] is a [Symbol] representing the name of the called method\n   * or accessor. It should not be `null`.\n   *\n   * The [positionalArguments] is a list of the positional arguments that the\n   * method was called with. If `null`, it is considered equivalent to the\n   * empty list.\n   *\n   * The [namedArguments] is a map from [Symbol]s to the values of named\n   * arguments that the method was called with.\n   *\n   * The optional [exisitingArgumentNames] is the expected parameters of a\n   * method with the same name on the receiver, if available. This is\n   * the signature of the method that would have been called if the parameters\n   * had matched.\n   */\n  NoSuchMethodError(Object receiver,\n                    Symbol memberName,\n                    List positionalArguments,\n                    Map<Symbol ,dynamic> namedArguments,\n                    [List existingArgumentNames = null])\n      : _receiver = receiver,\n        _memberName = memberName,\n        _arguments = positionalArguments,\n        _namedArguments = namedArguments,\n        _existingArgumentNames = existingArgumentNames;\n\n  external String toString();\n}\n\n\n/**\n * The operation was not allowed by the object.\n *\n * This [Error] is thrown when an instance cannot implement one of the methods\n * in its signature.\n */\nclass UnsupportedError extends Error {\n  final String message;\n  UnsupportedError(this.message);\n  String toString() => \"Unsupported operation: $message\";\n}\n\n\n/**\n * Thrown by operations that have not been implemented yet.\n *\n * This [Error] is thrown by unfinished code that hasn't yet implemented\n * all the features it needs.\n *\n * If a class is not intending to implement the feature, it should throw\n * an [UnsupportedError] instead. This error is only intended for\n * use during development.\n */\nclass UnimplementedError extends Error implements UnsupportedError {\n  final String message;\n  UnimplementedError([String this.message]);\n  String toString() => (this.message != null\n                        ? \"UnimplementedError: $message\"\n                        : \"UnimplementedError\");\n}\n\n\n/**\n * The operation was not allowed by the current state of the object.\n *\n * This is a generic error used for a variety of different erroneous\n * actions. The message should be descriptive.\n */\nclass StateError extends Error {\n  final String message;\n  StateError(this.message);\n  String toString() => \"Bad state: $message\";\n}\n\n\n/**\n * Error occurring when a collection is modified during iteration.\n *\n * Some modifications may be allowed for some collections, so each collection\n * ([Iterable] or similar collection of values) should declare which operations\n * are allowed during an iteration.\n */\nclass ConcurrentModificationError extends Error {\n  /** The object that was modified in an incompatible way. */\n  final Object modifiedObject;\n\n  ConcurrentModificationError([this.modifiedObject]);\n\n  String toString() {\n    if (modifiedObject == null) {\n      return \"Concurrent modification during iteration.\";\n    }\n    return \"Concurrent modification during iteration: \"\n           \"${Error.safeToString(modifiedObject)}.\";\n  }\n}\n\n\nclass OutOfMemoryError implements Error {\n  const OutOfMemoryError();\n  String toString() => \"Out of Memory\";\n\n  StackTrace get stackTrace => null;\n}\n\n\nclass StackOverflowError implements Error {\n  const StackOverflowError();\n  String toString() => \"Stack Overflow\";\n\n  StackTrace get stackTrace => null;\n}\n\n/**\n * Error thrown when a lazily initialized variable cannot be initialized.\n *\n * A static/library variable with an initializer expression is initialized\n * the first time it is read. If evaluating the initializer expression causes\n * another read of the variable, this error is thrown.\n */\nclass CyclicInitializationError extends Error {\n  final String variableName;\n  CyclicInitializationError([this.variableName]);\n  String toString() => variableName == null\n      ? \"Reading static variable during its initialization\"\n      : \"Reading static variable '$variableName' during its initialization\";\n}\n\u0000","sdk:/sdk/lib/core/duration.dart":"// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\npart of dart.core;\n\n/**\n * A span of time, such as 27 days, 4 hours, 12 minutes, and 3 seconds.\n *\n * A `Duration` represents a difference from one point in time to another. The\n * duration may be \"negative\" if the difference is from a later time to an\n * earlier.\n *\n * To create a new Duration object, use this class's single constructor\n * giving the appropriate arguments:\n *\n *     Duration fastestMarathon = new Duration(hours:2, minutes:3, seconds:2);\n *\n * The Duration is the sum of all individual parts.\n * This means that individual parts can be larger than the next-bigger unit.\n * For example, [minutes] can be greater than 59.\n *\n *     assert(fastestMarathon.inMinutes == 123);\n *\n * All individual parts are allowed to be negative.\n *\n * Use one of the properties, such as [inDays],\n * to retrieve the integer value of the Duration in the specified time unit.\n * Note that the returned value is rounded down.\n * For example,\n *\n *     Duration aLongWeekend = new Duration(hours:88);\n *     assert(aLongWeekend.inDays == 3);\n *\n * This class provides a collection of arithmetic\n * and comparison operators,\n * plus a set of constants useful for converting time units.\n *\n * See [DateTime] to represent a point in time.\n * See [Stopwatch] to measure time-spans.\n *\n */\nclass Duration implements Comparable<Duration> {\n  static const int MICROSECONDS_PER_MILLISECOND = 1000;\n  static const int MILLISECONDS_PER_SECOND = 1000;\n  static const int SECONDS_PER_MINUTE = 60;\n  static const int MINUTES_PER_HOUR = 60;\n  static const int HOURS_PER_DAY = 24;\n\n  static const int MICROSECONDS_PER_SECOND =\n      MICROSECONDS_PER_MILLISECOND * MILLISECONDS_PER_SECOND;\n  static const int MICROSECONDS_PER_MINUTE =\n      MICROSECONDS_PER_SECOND * SECONDS_PER_MINUTE;\n  static const int MICROSECONDS_PER_HOUR =\n      MICROSECONDS_PER_MINUTE * MINUTES_PER_HOUR;\n  static const int MICROSECONDS_PER_DAY =\n      MICROSECONDS_PER_HOUR * HOURS_PER_DAY;\n\n\n  static const int MILLISECONDS_PER_MINUTE =\n      MILLISECONDS_PER_SECOND * SECONDS_PER_MINUTE;\n  static const int MILLISECONDS_PER_HOUR =\n      MILLISECONDS_PER_MINUTE * MINUTES_PER_HOUR;\n  static const int MILLISECONDS_PER_DAY =\n      MILLISECONDS_PER_HOUR * HOURS_PER_DAY;\n\n  static const int SECONDS_PER_HOUR = SECONDS_PER_MINUTE * MINUTES_PER_HOUR;\n  static const int SECONDS_PER_DAY = SECONDS_PER_HOUR * HOURS_PER_DAY;\n\n  static const int MINUTES_PER_DAY = MINUTES_PER_HOUR * HOURS_PER_DAY;\n\n  static const Duration ZERO = const Duration(seconds: 0);\n\n  /*\n   * The value of this Duration object in microseconds.\n   */\n  final int _duration;\n\n  /**\n   * Creates a new Duration object whose value\n   * is the sum of all individual parts.\n   *\n   * Individual parts can be larger than the next-bigger unit.\n   * For example, [hours] can be greater than 23.\n   *\n   * All individual parts are allowed to be negative.\n   * All arguments are 0 by default.\n   */\n  const Duration({int days: 0,\n                  int hours: 0,\n                  int minutes: 0,\n                  int seconds: 0,\n                  int milliseconds: 0,\n                  int microseconds: 0})\n      : _duration = days * MICROSECONDS_PER_DAY +\n                    hours * MICROSECONDS_PER_HOUR +\n                    minutes * MICROSECONDS_PER_MINUTE +\n                    seconds * MICROSECONDS_PER_SECOND +\n                    milliseconds * MICROSECONDS_PER_MILLISECOND +\n                    microseconds;\n\n  /**\n   * Adds this Duration and [other] and\n   * returns the sum as a new Duration object.\n   */\n  Duration operator +(Duration other) {\n    return new Duration(microseconds: _duration + other._duration);\n  }\n\n  /**\n   * Subtracts [other] from this Duration and\n   * returns the difference as a new Duration object.\n   */\n  Duration operator -(Duration other) {\n    return new Duration(microseconds: _duration - other._duration);\n  }\n\n  /**\n   * Multiplies this Duration by the given [factor] and returns the result\n   * as a new Duration object.\n   *\n   * Note that when [factor] is a double, and the duration is greater than\n   * 53 bits, precision is lost because of double-precision arithmetic.\n   */\n  Duration operator *(num factor) {\n    return new Duration(microseconds: (_duration * factor).round());\n  }\n\n  /**\n   * Divides this Duration by the given [quotient] and returns the truncated\n   * result as a new Duration object.\n   *\n   * Throws an [IntegerDivisionByZeroException] if [quotient] is `0`.\n   */\n  Duration operator ~/(int quotient) {\n    // By doing the check here instead of relying on \"~/\" below we get the\n    // exception even with dart2js.\n    if (quotient == 0) throw new IntegerDivisionByZeroException();\n    return new Duration(microseconds: _duration ~/ quotient);\n  }\n\n  /**\n   * Returns `true` if the value of this Duration\n   * is less than the value of [other].\n   */\n  bool operator <(Duration other) => this._duration < other._duration;\n\n  /**\n   * Returns `true` if the value of this Duration\n   * is greater than the value of [other].\n   */\n  bool operator >(Duration other) => this._duration > other._duration;\n\n  /**\n   * Returns `true` if the value of this Duration\n   * is less than or equal to the value of [other].\n   */\n  bool operator <=(Duration other) => this._duration <= other._duration;\n\n  /**\n   * Returns `true` if the value of this Duration\n   * is greater than or equal to the value of [other].\n   */\n  bool operator >=(Duration other) => this._duration >= other._duration;\n\n  /**\n   * Returns the number of whole days spanned by this Duration.\n   */\n  int get inDays => _duration ~/ Duration.MICROSECONDS_PER_DAY;\n\n  /**\n   * Returns the number of whole hours spanned by this Duration.\n   *\n   * The returned value can be greater than 23.\n   */\n  int get inHours => _duration ~/ Duration.MICROSECONDS_PER_HOUR;\n\n  /**\n   * Returns the number of whole minutes spanned by this Duration.\n   *\n   * The returned value can be greater than 59.\n   */\n  int get inMinutes => _duration ~/ Duration.MICROSECONDS_PER_MINUTE;\n\n  /**\n   * Returns the number of whole seconds spanned by this Duration.\n   *\n   * The returned value can be greater than 59.\n   */\n  int get inSeconds => _duration ~/ Duration.MICROSECONDS_PER_SECOND;\n\n  /**\n   * Returns number of whole milliseconds spanned by this Duration.\n   *\n   * The returned value can be greater than 999.\n   */\n  int get inMilliseconds => _duration ~/ Duration.MICROSECONDS_PER_MILLISECOND;\n\n  /**\n   * Returns number of whole microseconds spanned by this Duration.\n   */\n  int get inMicroseconds => _duration;\n\n  /**\n   * Returns `true` if this Duration is the same object as [other].\n   */\n  bool operator ==(other) {\n    if (other is !Duration) return false;\n    return _duration == other._duration;\n  }\n\n  int get hashCode => _duration.hashCode;\n\n  /**\n   * Compares this Duration to [other], returning zero if the values are equal.\n   *\n   * Returns a negative integer if this `Duration` is shorter than\n   * [other], or a positive integer if it is longer.\n   *\n   * A negative `Duration` is always considered shorter than a positive one.\n   *\n   * It is always the case that `duration1.compareTo(duration2) < 0` iff\n   * `(someDate + duration1).compareTo(someDate + duration2) < 0`.\n   */\n  int compareTo(Duration other) => _duration.compareTo(other._duration);\n\n  /**\n   * Returns a string representation of this `Duration`.\n   *\n   * Returns a string with hours, minutes, seconds, and microseconds, in the\n   * following format: `HH:MM:SS.mmmmmm`. For example,\n   *\n   *     var d = new Duration(days:1, hours:1, minutes:33, microseconds: 500);\n   *     d.toString();  // \"25:33:00.000500\"\n   */\n  String toString() {\n    String sixDigits(int n) {\n      if (n >= 100000) return \"$n\";\n      if (n >= 10000) return \"0$n\";\n      if (n >= 1000) return \"00$n\";\n      if (n >= 100) return \"000$n\";\n      if (n >= 10) return \"0000$n\";\n      return \"00000$n\";\n    }\n    String twoDigits(int n) {\n      if (n >= 10) return \"$n\";\n      return \"0$n\";\n    }\n\n    if (inMicroseconds < 0) {\n      Duration duration =\n          new Duration(microseconds: -inMicroseconds);\n      return \"-$duration\";\n    }\n    String twoDigitMinutes = twoDigits(inMinutes.remainder(MINUTES_PER_HOUR));\n    String twoDigitSeconds = twoDigits(inSeconds.remainder(SECONDS_PER_MINUTE));\n    String sixDigitUs =\n        sixDigits(inMicroseconds.remainder(MICROSECONDS_PER_SECOND));\n    return \"$inHours:$twoDigitMinutes:$twoDigitSeconds.$sixDigitUs\";\n  }\n\n  /**\n   * Returns whether this `Duration` is negative.\n   *\n   * A negative `Duration` represents the difference from a later time to an\n   * earlier time.\n   */\n  bool get isNegative => _duration < 0;\n\n  /**\n   * Returns a new `Duration` representing the absolute value of this\n   * `Duration`.\n   *\n   * The returned `Duration` has the same length as this one, but is always\n   * positive.\n   */\n  Duration abs() => new Duration(microseconds: _duration.abs());\n\n  /**\n   * Returns a new `Duration` representing this `Duration` negated.\n   *\n   * The returned `Duration` has the same length as this one, but will have the\n   * opposite sign of this one.\n   */\n  Duration operator -() => new Duration(microseconds: -_duration);\n}\n\u0000","sdk:/sdk/lib/core/double.dart":"// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\npart of dart.core;\n\n// TODO: Convert this abstract class into a concrete class double\n// that uses the patch class functionality to account for the\n// different platform implementations.\n\n/**\n * A double-precision floating point number.\n *\n * Representation of Dart doubles containing double specific constants\n * and operations and specializations of operations inherited from\n * [num]. Dart doubles are 64-bit floating-point numbers as specified in the\n * IEEE 754 standard.\n *\n * The [double] type is contagious. Operations on [double]s return\n * [double] results.\n *\n * It is a compile-time error for a class to attempt to extend or implement\n * double.\n */\nabstract class double extends num {\n  static const double NAN = 0.0 / 0.0;\n  static const double INFINITY = 1.0 / 0.0;\n  static const double NEGATIVE_INFINITY = -INFINITY;\n  static const double MIN_POSITIVE = 5e-324;\n  static const double MAX_FINITE = 1.7976931348623157e+308;\n\n  double remainder(num other);\n\n  /** Addition operator. */\n  double operator +(num other);\n\n  /** Subtraction operator. */\n  double operator -(num other);\n\n  /** Multiplication operator. */\n  double operator *(num other);\n\n  double operator %(num other);\n\n  /** Division operator. */\n  double operator /(num other);\n\n  /**\n   * Truncating division operator.\n   *\n   * The result of the truncating division `a ~/ b` is equivalent to\n   * `(a / b).truncate()`.\n   */\n  int operator ~/(num other);\n\n  /** Negate operator. */\n  double operator -();\n\n  /** Returns the absolute value of this [double]. */\n  double abs();\n\n  /**\n   * Returns the sign of the double's numerical value.\n   *\n   * Returns -1.0 if the value is less than zero,\n   * +1.0 if the value is greater than zero,\n   * and the value itself if it is -0.0, 0.0 or NaN.\n   */\n  double get sign;\n\n  /**\n   * Returns the integer closest to `this`.\n   *\n   * Rounds away from zero when there is no closest integer:\n   *  `(3.5).round() == 4` and `(-3.5).round() == -4`.\n   *\n   * If `this` is not finite (`NaN` or infinity), throws an [UnsupportedError].\n   */\n  int round();\n\n  /**\n   * Returns the greatest integer no greater than `this`.\n   *\n   * If `this` is not finite (`NaN` or infinity), throws an [UnsupportedError].\n   */\n  int floor();\n\n  /**\n   * Returns the least integer no smaller than `this`.\n   *\n   * If `this` is not finite (`NaN` or infinity), throws an [UnsupportedError].\n   */\n  int ceil();\n\n  /**\n   * Returns the integer obtained by discarding any fractional\n   * digits from `this`.\n   *\n   * If `this` is not finite (`NaN` or infinity), throws an [UnsupportedError].\n   */\n  int truncate();\n\n  /**\n   * Returns the integer double value closest to `this`.\n   *\n   * Rounds away from zero when there is no closest integer:\n   *  `(3.5).roundToDouble() == 4` and `(-3.5).roundToDouble() == -4`.\n   *\n   * If this is already an integer valued double, including `-0.0`, or it is not\n   * a finite value, the value is returned unmodified.\n   *\n   * For the purpose of rounding, `-0.0` is considered to be below `0.0`,\n   * and `-0.0` is therefore considered closer to negative numbers than `0.0`.\n   * This means that for a value, `d` in the range `-0.5 < d < 0.0`,\n   * the result is `-0.0`.\n   */\n  double roundToDouble();\n\n  /**\n   * Returns the greatest integer double value no greater than `this`.\n   *\n   * If this is already an integer valued double, including `-0.0`, or it is not\n   * a finite value, the value is returned unmodified.\n   *\n   * For the purpose of rounding, `-0.0` is considered to be below `0.0`.\n   * A number `d` in the range `0.0 < d < 1.0` will return `0.0`.\n   */\n  double floorToDouble();\n\n  /**\n   * Returns the least integer double value no smaller than `this`.\n   *\n   * If this is already an integer valued double, including `-0.0`, or it is not\n   * a finite value, the value is returned unmodified.\n   *\n   * For the purpose of rounding, `-0.0` is considered to be below `0.0`.\n   * A number `d` in the range `-1.0 < d < 0.0` will return `-0.0`.\n   */\n  double ceilToDouble();\n\n  /**\n   * Returns the integer double value obtained by discarding any fractional\n   * digits from `this`.\n   *\n   * If this is already an integer valued double, including `-0.0`, or it is not\n   * a finite value, the value is returned unmodified.\n   *\n   * For the purpose of rounding, `-0.0` is considered to be below `0.0`.\n   * A number `d` in the range `-1.0 < d < 0.0` will return `-0.0`, and\n   * in the range `0.0 < d < 1.0` it will return 0.0.\n   */\n  double truncateToDouble();\n\n  /**\n   * Provide a representation of this [double] value.\n   *\n   * The representation is a number literal such that the closest double value\n   * to the representation's mathematical value is this [double].\n   *\n   * Returns \"NaN\" for the Not-a-Number value.\n   * Returns \"Infinity\" and \"-Infinity\" for positive and negative Infinity.\n   * Returns \"-0.0\" for negative zero.\n   *\n   * For all doubles, `d`, converting to a string and parsing the string back\n   * gives the same value again: `d == double.parse(d.toString())`.\n   */\n  String toString();\n\n  /**\n   * Parse [source] as an double literal and return its value.\n   *\n   * Accepts an optional sign (`+` or `-`) followed by either the characters\n   * \"Infinity\", the characters \"NaN\" or a floating-point representation.\n   * A floating-point representation is composed of a mantissa and an optional\n   * exponent part. The mantissa is either a decimal point (`.`) followed by a\n   * sequence of (decimal) digits, or a sequence of digits\n   * optionally followed by a decimal point and optionally more digits. The\n   * (optional) exponent part consists of the character \"e\" or \"E\", an optional\n   * sign, and one or more digits.\n   *\n   * Leading and trailing whitespace is ignored.\n   *\n   * If the [source] is not a valid double literal, the [onError]\n   * is called with the [source] as argument, and its return value is\n   * used instead. If no `onError` is provided, a [FormatException]\n   * is thrown instead.\n   *\n   * The [onError] function is only invoked if [source] is a [String] with an\n   * invalid format. It is not invoked if the [source] is invalid for some\n   * other reason, for example by being `null`.\n   *\n   * Examples of accepted strings:\n   *\n   *     \"3.14\"\n   *     \"  3.14 \\xA0\"\n   *     \"0.\"\n   *     \".0\"\n   *     \"-1.e3\"\n   *     \"1234E+7\"\n   *     \"+.12e-9\"\n   *     \"-NaN\"\n   */\n  external static double parse(String source,\n                               [double onError(String source)]);\n}\n\u0000","sdk:/sdk/lib/core/date_time.dart":"// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\npart of dart.core;\n\n/**\n * An instant in time, such as July 20, 1969, 8:18pm GMT.\n *\n * Create a DateTime object by using one of the constructors\n * or by parsing a correctly formatted string,\n * which complies with a subset of ISO 8601.\n * Note that hours are specified between 0 and 23,\n * as in a 24-hour clock.\n * For example:\n *\n *     DateTime now = new DateTime.now();\n *     DateTime berlinWallFell = new DateTime(1989, 11, 9);\n *     DateTime moonLanding = DateTime.parse(\"1969-07-20 20:18:00\");  // 8:18pm\n *\n * A DateTime object is anchored either in the UTC time zone\n * or in the local time zone of the current computer\n * when the object is created.\n *\n * Once created, neither the value nor the time zone\n * of a DateTime object may be changed.\n *\n * You can use properties to get\n * the individual units of a DateTime object.\n *\n *     assert(berlinWallFell.month == 11);\n *     assert(moonLanding.hour == 20);\n *\n * For convenience and readability,\n * the DateTime class provides a constant for each day and month\n * name&mdash;for example, [AUGUST] and [FRIDAY].\n * You can use these constants to improve code readibility:\n *\n *     DateTime berlinWallFell = new DateTime(1989, DateTime.NOVEMBER, 9);\n *     assert(berlinWallFell.weekday == DateTime.THURSDAY);\n *\n * Day and month values begin at 1, and the week starts on Monday.\n * That is, the constants [JANUARY] and [MONDAY] are both 1.\n *\n * ## Working with UTC and local time\n *\n * A DateTime object is in the local time zone\n * unless explicitly created in the UTC time zone.\n *\n *     DateTime dDay = new DateTime.utc(1944, 6, 6);\n *\n * Use [isUtc] to determine whether a DateTime object is based in UTC.\n * Use the methods [toLocal] and [toUtc]\n * to get the equivalent date/time value specified in the other time zone.\n * Use [timeZoneName] to get an abbreviated name of the time zone\n * for the DateTime object.\n * To find the difference\n * between UTC and the time zone of a DateTime object\n * call [timeZoneOffset].\n *\n * ## Comparing DateTime objects\n *\n * The DateTime class contains several handy methods,\n * such as [isAfter], [isBefore], and [isAtSameMomentAs],\n * for comparing DateTime objects.\n *\n *     assert(berlinWallFell.isAfter(moonLanding) == true);\n *     assert(berlinWallFell.isBefore(moonLanding) == false);\n *\n * ## Using DateTime with Duration\n *\n * Use the [add] and [subtract] methods with a [Duration] object\n * to create a new DateTime object based on another.\n * For example, to find the date that is sixty days after today, write:\n *\n *     DateTime today = new DateTime.now();\n *     DateTime sixtyDaysFromNow = today.add(new Duration(days: 60));\n *\n * To find out how much time is between two DateTime objects use\n * [difference], which returns a [Duration] object:\n *\n *     Duration difference = berlinWallFell.difference(moonLanding)\n *     assert(difference.inDays == 7416);\n *\n * The difference between two dates in different time zones\n * is just the number of nanoseconds between the two points in time.\n * It doesn't take calendar days into account.\n * That means that the difference between two midnights in local time may be\n * less than 24 hours times the number of days between them,\n * if there is a daylight saving change in between.\n * If the difference above is calculated using Australian local time, the\n * difference is 7415 days and 23 hours, which is only 7415 whole days as\n * reported by `inDays`.\n *\n * ## Other resources\n *\n * See [Duration] to represent a span of time.\n * See [Stopwatch] to measure timespans.\n *\n * The DateTime class does not provide internationalization.\n * To internationalize your code, use\n * the [intl](http://pub.dartlang.org/packages/intl) package.\n *\n */\nclass DateTime implements Comparable {\n  // Weekday constants that are returned by [weekday] method:\n  static const int MONDAY = 1;\n  static const int TUESDAY = 2;\n  static const int WEDNESDAY = 3;\n  static const int THURSDAY = 4;\n  static const int FRIDAY = 5;\n  static const int SATURDAY = 6;\n  static const int SUNDAY = 7;\n  static const int DAYS_PER_WEEK = 7;\n\n  // Month constants that are returned by the [month] getter.\n  static const int JANUARY = 1;\n  static const int FEBRUARY = 2;\n  static const int MARCH = 3;\n  static const int APRIL = 4;\n  static const int MAY = 5;\n  static const int JUNE = 6;\n  static const int JULY = 7;\n  static const int AUGUST = 8;\n  static const int SEPTEMBER = 9;\n  static const int OCTOBER = 10;\n  static const int NOVEMBER = 11;\n  static const int DECEMBER = 12;\n  static const int MONTHS_PER_YEAR = 12;\n\n  /**\n   * The number of milliseconds since\n   * the \"Unix epoch\" 1970-01-01T00:00:00Z (UTC).\n   *\n   * This value is independent of the time zone.\n   *\n   * This value is at most\n   * 8,640,000,000,000,000ms (100,000,000 days) from the Unix epoch.\n   * In other words: [:millisecondsSinceEpoch.abs() <= 8640000000000000:].\n   *\n   */\n  final int millisecondsSinceEpoch;\n\n  /**\n   * True if this [DateTime] is set to UTC time.\n   *\n   *     DateTime dDay = new DateTime.utc(1944, 6, 6);\n   *     assert(dDay.isUtc);\n   *\n   */\n  final bool isUtc;\n\n  /**\n   * Constructs a [DateTime] instance specified in the local time zone.\n   *\n   * For example,\n   * to create a new DateTime object representing April 29, 2014, 6:04am:\n   *\n   *     DateTime annularEclipse = new DateTime(2014, DateTime.APRIL, 29, 6, 4);\n   */\n  DateTime(int year,\n           [int month = 1,\n            int day = 1,\n            int hour = 0,\n            int minute = 0,\n            int second = 0,\n            int millisecond = 0])\n      : this._internal(\n            year, month, day, hour, minute, second, millisecond, false);\n\n  /**\n   * Constructs a [DateTime] instance specified in the UTC time zone.\n   *\n   *     DateTime dDay = new DateTime.utc(1944, DateTime.JUNE, 6);\n   */\n  DateTime.utc(int year,\n               [int month = 1,\n                int day = 1,\n                int hour = 0,\n                int minute = 0,\n                int second = 0,\n                int millisecond = 0])\n    : this._internal(\n          year, month, day, hour, minute, second, millisecond, true);\n\n  /**\n   * Constructs a [DateTime] instance with current date and time in the\n   * local time zone.\n   *\n   *     DateTime thisInstant = new DateTime.now();\n   *\n   */\n  DateTime.now() : this._now();\n\n  /**\n   * Constructs a new [DateTime] instance based on [formattedString].\n   *\n   * Throws a [FormatException] if the input cannot be parsed.\n   *\n   * The function parses a subset of ISO 8601\n   * which includes the subset accepted by RFC 3339.\n   *\n   * The result is always in either local time or UTC.\n   * If a time zone offset other than UTC is specified,\n   * the time is converted to the equivalent UTC time.\n   *\n   * Examples of accepted strings:\n   *\n   * * `\"2012-02-27 13:27:00\"`\n   * * `\"2012-02-27 13:27:00.123456z\"`\n   * * `\"20120227 13:27:00\"`\n   * * `\"20120227T132700\"`\n   * * `\"20120227\"`\n   * * `\"+20120227\"`\n   * * `\"2012-02-27T14Z\"`\n   * * `\"2012-02-27T14+00:00\"`\n   * * `\"-123450101 00:00:00 Z\"`: in the year -12345.\n   * * `\"2002-02-27T14:00:00-0500\"`: Same as `\"2002-02-27T19:00:00Z\"`\n   */\n  // TODO(floitsch): specify grammar.\n  // TODO(lrn): restrict incorrect values like  2003-02-29T50:70:80.\n  static DateTime parse(String formattedString) {\n    /*\n     * date ::= yeardate time_opt timezone_opt\n     * yeardate ::= year colon_opt month colon_opt day\n     * year ::= sign_opt digit{4,5}\n     * colon_opt :: <empty> | ':'\n     * sign ::= '+' | '-'\n     * sign_opt ::=  <empty> | sign\n     * month ::= digit{2}\n     * day ::= digit{2}\n     * time_opt ::= <empty> | (' ' | 'T') hour minutes_opt\n     * minutes_opt ::= <empty> | ':' digit{2} seconds_opt\n     * seconds_opt ::= <empty> | ':' digit{2} millis_opt\n     * millis_opt ::= <empty> | '.' digit{1,6}\n     * timezone_opt ::= <empty> | space_opt timezone\n     * space_opt :: ' ' | <empty>\n     * timezone ::= 'z' | 'Z' | sign digit{2} timezonemins_opt\n     * timezonemins_opt ::= <empty> | colon_opt digit{2}\n     */\n    final RegExp re = new RegExp(\n        r'^([+-]?\\d{4,6})-?(\\d\\d)-?(\\d\\d)'  // The day part.\n        r'(?:[ T](\\d\\d)(?::?(\\d\\d)(?::?(\\d\\d)(.\\d{1,6})?)?)?' // The time part\n        r'( ?[zZ]| ?([-+])(\\d\\d)(?::?(\\d\\d))?)?)?$'); // The timezone part\n\n    Match match = re.firstMatch(formattedString);\n    if (match != null) {\n      int parseIntOrZero(String matched) {\n        if (matched == null) return 0;\n        return int.parse(matched);\n      }\n\n      double parseDoubleOrZero(String matched) {\n        if (matched == null) return 0.0;\n        return double.parse(matched);\n      }\n\n      int years = int.parse(match[1]);\n      int month = int.parse(match[2]);\n      int day = int.parse(match[3]);\n      int hour = parseIntOrZero(match[4]);\n      int minute = parseIntOrZero(match[5]);\n      int second = parseIntOrZero(match[6]);\n      bool addOneMillisecond = false;\n      int millisecond = (parseDoubleOrZero(match[7]) * 1000).round();\n      if (millisecond == 1000) {\n        addOneMillisecond = true;\n        millisecond = 999;\n      }\n      bool isUtc = false;\n      if (match[8] != null) {  // timezone part\n        isUtc = true;\n        if (match[9] != null) {\n          // timezone other than 'Z' and 'z'.\n          int sign = (match[9] == '-') ? -1 : 1;\n          int hourDifference = int.parse(match[10]);\n          int minuteDifference = parseIntOrZero(match[11]);\n          minuteDifference += 60 * hourDifference;\n          minute -= sign * minuteDifference;\n        }\n      }\n      int millisecondsSinceEpoch = _brokenDownDateToMillisecondsSinceEpoch(\n          years, month, day, hour, minute, second, millisecond, isUtc);\n      if (millisecondsSinceEpoch == null) {\n        throw new FormatException(\"Time out of range\", formattedString);\n      }\n      if (addOneMillisecond) millisecondsSinceEpoch++;\n      return new DateTime.fromMillisecondsSinceEpoch(millisecondsSinceEpoch,\n                                                     isUtc: isUtc);\n    } else {\n      throw new FormatException(\"Invalid date format\", formattedString);\n    }\n  }\n\n  static const int _MAX_MILLISECONDS_SINCE_EPOCH = 8640000000000000;\n\n  /**\n   * Constructs a new [DateTime] instance\n   * with the given [millisecondsSinceEpoch].\n   *\n   * If [isUtc] is false then the date is in the local time zone.\n   *\n   * The constructed [DateTime] represents\n   * 1970-01-01T00:00:00Z + [millisecondsSinceEpoch] ms in the given\n   * time zone (local or UTC).\n   */\n  DateTime.fromMillisecondsSinceEpoch(int millisecondsSinceEpoch,\n                                      {bool isUtc: false})\n      : this.millisecondsSinceEpoch = millisecondsSinceEpoch,\n        this.isUtc = isUtc {\n    if (millisecondsSinceEpoch.abs() > _MAX_MILLISECONDS_SINCE_EPOCH) {\n      throw new ArgumentError(millisecondsSinceEpoch);\n    }\n    if (isUtc == null) throw new ArgumentError(isUtc);\n  }\n\n  /**\n   * Returns true if [other] is a [DateTime] at the same moment and in the\n   * same time zone (UTC or local).\n   *\n   *     DateTime dDayUtc   = new DateTime.utc(1944, DateTime.JUNE, 6);\n   *     DateTime dDayLocal = new DateTime(1944, DateTime.JUNE, 6);\n   *\n   *     assert(dDayUtc.isAtSameMomentAs(dDayLocal) == false);\n   *\n   * See [isAtSameMomentAs] for a comparison that adjusts for time zone.\n   */\n  bool operator ==(other) {\n    if (!(other is DateTime)) return false;\n    return (millisecondsSinceEpoch == other.millisecondsSinceEpoch &&\n            isUtc == other.isUtc);\n  }\n\n  /**\n   * Returns true if [this] occurs before [other].\n   *\n   * The comparison is independent\n   * of whether the time is in UTC or in the local time zone.\n   *\n   *     DateTime berlinWallFell = new DateTime(1989, 11, 9);\n   *     DateTime moonLanding    = DateTime.parse(\"1969-07-20 20:18:00\");\n   *\n   *     assert(berlinWallFell.isBefore(moonLanding) == false);\n   *\n   */\n  bool isBefore(DateTime other) {\n    return millisecondsSinceEpoch < other.millisecondsSinceEpoch;\n  }\n\n  /**\n   * Returns true if [this] occurs after [other].\n   *\n   * The comparison is independent\n   * of whether the time is in UTC or in the local time zone.\n   *\n   *     DateTime berlinWallFell = new DateTime(1989, 11, 9);\n   *     DateTime moonLanding    = DateTime.parse(\"1969-07-20 20:18:00\");\n   *\n   *     assert(berlinWallFell.isAfter(moonLanding) == true);\n   *\n   */\n  bool isAfter(DateTime other) {\n    return millisecondsSinceEpoch > other.millisecondsSinceEpoch;\n  }\n\n  /**\n   * Returns true if [this] occurs at the same moment as [other].\n   *\n   * The comparison is independent of whether the time is in UTC or in the local\n   * time zone.\n   *\n   *     DateTime berlinWallFell = new DateTime(1989, 11, 9);\n   *     DateTime moonLanding    = DateTime.parse(\"1969-07-20 20:18:00\");\n   *\n   *     assert(berlinWallFell.isAtSameMomentAs(moonLanding) == false);\n   */\n  bool isAtSameMomentAs(DateTime other) {\n    return millisecondsSinceEpoch == other.millisecondsSinceEpoch;\n  }\n\n  /**\n   * Compares this DateTime object to [other],\n   * returning zero if the values are equal.\n   *\n   * This function returns a negative integer\n   * if this DateTime is smaller (earlier) than [other],\n   * or a positive integer if it is greater (later).\n   */\n  int compareTo(DateTime other)\n      => millisecondsSinceEpoch.compareTo(other.millisecondsSinceEpoch);\n\n  int get hashCode => millisecondsSinceEpoch;\n\n  /**\n   * Returns this DateTime value in the local time zone.\n   *\n   * Returns [this] if it is already in the local time zone.\n   * Otherwise this method is equivalent to:\n   *\n   *     new DateTime.fromMillisecondsSinceEpoch(millisecondsSinceEpoch,\n   *                                             isUtc: false)\n   */\n  DateTime toLocal() {\n    if (isUtc) {\n      return new DateTime.fromMillisecondsSinceEpoch(millisecondsSinceEpoch,\n                                                     isUtc: false);\n    }\n    return this;\n  }\n\n  /**\n   * Returns this DateTime value in the UTC time zone.\n   *\n   * Returns [this] if it is already in UTC.\n   * Otherwise this method is equivalent to:\n   *\n   *     new DateTime.fromMillisecondsSinceEpoch(millisecondsSinceEpoch,\n   *                                             isUtc: true)\n   */\n  DateTime toUtc() {\n    if (isUtc) return this;\n    return new DateTime.fromMillisecondsSinceEpoch(millisecondsSinceEpoch,\n                                                   isUtc: true);\n  }\n\n  static String _fourDigits(int n) {\n    int absN = n.abs();\n    String sign = n < 0 ? \"-\" : \"\";\n    if (absN >= 1000) return \"$n\";\n    if (absN >= 100) return \"${sign}0$absN\";\n    if (absN >= 10) return \"${sign}00$absN\";\n    return \"${sign}000$absN\";\n  }\n\n  static String _threeDigits(int n) {\n    if (n >= 100) return \"${n}\";\n    if (n >= 10) return \"0${n}\";\n    return \"00${n}\";\n  }\n\n  static String _twoDigits(int n) {\n    if (n >= 10) return \"${n}\";\n    return \"0${n}\";\n  }\n\n  /**\n   * Returns a human-readable string for this instance.\n   *\n   * The returned string is constructed for the time zone of this instance.\n   * The `toString()` method provides a simply formatted string.\n   * It does not support internationalized strings.\n   * Use the [intl](http://pub.dartlang.org/packages/intl) package\n   * at the pub shared packages repo.\n   */\n  String toString() {\n    String y = _fourDigits(year);\n    String m = _twoDigits(month);\n    String d = _twoDigits(day);\n    String h = _twoDigits(hour);\n    String min = _twoDigits(minute);\n    String sec = _twoDigits(second);\n    String ms = _threeDigits(millisecond);\n    if (isUtc) {\n      return \"$y-$m-$d $h:$min:$sec.${ms}Z\";\n    } else {\n      return \"$y-$m-$d $h:$min:$sec.$ms\";\n    }\n  }\n\n  /**\n   * Returns an ISO-8601 full-precision extended format representation.\n   *\n   * The format is \"YYYY-MM-DDTHH:mm:ss.sssZ\" for UTC time, and\n   * \"YYYY-MM-DDTHH:mm:ss.sss\" (no trailing \"Z\") for local/non-UTC time.\n   */\n  String toIso8601String() {\n    String y = _fourDigits(year);\n    String m = _twoDigits(month);\n    String d = _twoDigits(day);\n    String h = _twoDigits(hour);\n    String min = _twoDigits(minute);\n    String sec = _twoDigits(second);\n    String ms = _threeDigits(millisecond);\n    if (isUtc) {\n      return \"$y-$m-${d}T$h:$min:$sec.${ms}Z\";\n    } else {\n      return \"$y-$m-${d}T$h:$min:$sec.$ms\";\n    }\n  }\n\n  /**\n   * Returns a new [DateTime] instance with [duration] added to [this].\n   *\n   *     DateTime today = new DateTime.now();\n   *     DateTime sixtyDaysFromNow = today.add(new Duration(days: 60));\n   */\n  DateTime add(Duration duration) {\n    int ms = millisecondsSinceEpoch;\n    return new DateTime.fromMillisecondsSinceEpoch(\n        ms + duration.inMilliseconds, isUtc: isUtc);\n  }\n\n  /**\n   * Returns a new [DateTime] instance with [duration] subtracted from [this].\n   *\n   *     DateTime today = new DateTime.now();\n   *     DateTime sixtyDaysAgo = today.subtract(new Duration(days: 60));\n   */\n  DateTime subtract(Duration duration) {\n    int ms = millisecondsSinceEpoch;\n    return new DateTime.fromMillisecondsSinceEpoch(\n        ms - duration.inMilliseconds, isUtc: isUtc);\n  }\n\n  /**\n   * Returns a [Duration] with the difference between [this] and [other].\n   *\n   *     DateTime berlinWallFell = new DateTime(1989, DateTime.NOVEMBER, 9);\n   *     DateTime dDay = new DateTime(1944, DateTime.JUNE, 6);\n   *\n   *     Duration difference = berlinWallFell.difference(dDay);\n   *     assert(difference.inDays == 16592);\n   */\n\n  Duration difference(DateTime other) {\n    int ms = millisecondsSinceEpoch;\n    int otherMs = other.millisecondsSinceEpoch;\n    return new Duration(milliseconds: ms - otherMs);\n  }\n\n  external DateTime._internal(int year,\n                              int month,\n                              int day,\n                              int hour,\n                              int minute,\n                              int second,\n                              int millisecond,\n                              bool isUtc);\n  external DateTime._now();\n  /// Returns the time as milliseconds since epoch, or null if the\n  /// values are out of range.\n  external static int _brokenDownDateToMillisecondsSinceEpoch(\n      int year, int month, int day, int hour, int minute, int second,\n      int millisecond, bool isUtc);\n\n  /**\n   * The abbreviated time zone name&mdash;for example,\n   * [:\"CET\":] or [:\"CEST\":].\n   */\n  external String get timeZoneName;\n\n  /**\n   * The time zone offset, which\n   * is the difference between local time and UTC.\n   *\n   * The offset is positive for time zones east of UTC.\n   *\n   * Note, that JavaScript, Python and C return the difference between UTC and\n   * local time. Java, C# and Ruby return the difference between local time and\n   * UTC.\n   */\n  external Duration get timeZoneOffset;\n\n  /**\n   * The year.\n   *\n   *     DateTime moonLanding = DateTime.parse(\"1969-07-20 20:18:00\");\n   *     assert(moonLanding.year == 1969);\n   */\n  external int get year;\n\n  /**\n   * The month [1..12].\n   *\n   *     DateTime moonLanding = DateTime.parse(\"1969-07-20 20:18:00\");\n   *     assert(moonLanding.month == 7);\n   *     assert(moonLanding.month == DateTime.JULY);\n   */\n  external int get month;\n\n  /**\n   * The day of the month [1..31].\n   *\n   *     DateTime moonLanding = DateTime.parse(\"1969-07-20 20:18:00\");\n   *     assert(moonLanding.day == 20);\n   */\n  external int get day;\n\n  /**\n   * The hour of the day, expressed as in a 24-hour clock [0..23].\n   *\n   *     DateTime moonLanding = DateTime.parse(\"1969-07-20 20:18:00\");\n   *     assert(moonLanding.hour == 20);\n   */\n  external int get hour;\n\n  /**\n   * The minute [0...59].\n   *\n   *     DateTime moonLanding = DateTime.parse(\"1969-07-20 20:18:00\");\n   *     assert(moonLanding.minute == 18);\n   */\n  external int get minute;\n\n  /**\n   * The second [0...59].\n   *\n   *     DateTime moonLanding = DateTime.parse(\"1969-07-20 20:18:00\");\n   *     assert(moonLanding.second == 0);\n   */\n  external int get second;\n\n  /**\n   * The millisecond [0...999].\n   *\n   *     DateTime moonLanding = DateTime.parse(\"1969-07-20 20:18:00\");\n   *     assert(moonLanding.millisecond == 0);\n   */\n  external int get millisecond;\n\n  /**\n   * The day of the week [MONDAY]..[SUNDAY].\n   *\n   * In accordance with ISO 8601\n   * a week starts with Monday, which has the value 1.\n   *\n   *     DateTime moonLanding = DateTime.parse(\"1969-07-20 20:18:00\");\n   *     assert(moonLanding.weekday == 7);\n   *     assert(moonLanding.weekday == DateTime.SUNDAY);\n   *\n   */\n  external int get weekday;\n}\n\u0000","sdk:/sdk/lib/core/comparable.dart":"// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\npart of dart.core;\n\n/**\n * The signature of a generic comparison function.\n *\n * A comparison function represents an ordering on a type of objects.\n * A total ordering on a type means that for two values, either they\n * are equal or one is greater than the other (and the latter must then be\n * smaller than the former).\n *\n * A [Comparator] function represents such a total ordering by returning\n *\n * * a negative integer if [a] is smaller than [b],\n * * zero if [a] is equal to [b], and\n * * a positive integer if [a] is greater than [b].\n */\ntypedef int Comparator<T>(T a, T b);\n\n/**\n * Interface used by types that have an intrinsic ordering.\n *\n * The [compareTo] operation defines a total ordering of objects,\n * which can be used for ordering and sorting.\n *\n * The [Comparable] interface should be used for the natural ordering of a type.\n * If a type can be ordered in more than one way,\n * and none of them is the obvious natural ordering,\n * then it might be better not to use the [Comparable] interface,\n * and to provide separate [Comparator]s instead.\n *\n * It is recommended that the order of a [Comparable] agrees\n * with its operator [==] equality (`a.compareTo(b) == 0` iff `a == b`),\n * but this is not a requirement.\n * For example, [double] and [DateTime] have `compareTo` methods\n * that do not agree with operator [==].\n * For doubles the [compareTo] method is more precise than the equality,\n * and for [DateTime] it is less precise.\n *\n * Examples:\n *\n *      (0.0).compareTo(-0.0);  // => 1\n *      0.0 == -0.0;            // => true\n *      var dt = new DateTime.now();\n *      var dt2 = dt.toUtc();\n *      dt == dt2;              // => false\n *      dt.compareTo(dt2);      // => 0\n *\n * The [Comparable] interface does not imply the existence\n * of the comparison operators `<`, `<=`, `>` and `>=`.\n * These should only be defined\n * if the ordering is a less-than/greater-than ordering,\n * that is, an ordering where you would naturally\n * use the words \"less than\" about the order of two elements.\n *\n * If the equality operator and [compareTo] disagree,\n * the comparison operators should follow the equality operator,\n * and will likely also disagree with [compareTo].\n * Otherwise they should match the [compareTo] method,\n * so that `a < b` iff `a.compareTo(b) < 0`.\n *\n * The [double] class defines comparison operators\n * that are compatible with equality.\n * The operators differ from `double.compareTo` on -0.0 and NaN.\n *\n * The [DateTime] class has no comparison operators, instead it has the more\n * precisely named [DateTime.isBefore] and [DateTime.isAfter].\n */\nabstract class Comparable<T> {\n  /**\n   * Compares this object to another [Comparable]\n   *\n   * Returns a value like a [Comparator] when comparing `this` to [other].\n   * That is, it returns a negative integer if `this` is ordered before [other],\n   * a positive integer if `this` is ordered after [other],\n   * and zero if `this` and [other] are ordered together.\n   *\n   * The [other] argument must be a value that is comparable to this object.\n   */\n  int compareTo(T other);\n\n  /**\n   * A [Comparator] that compares one comparable to another.\n   *\n   * It returns the result of `a.compareTo(b)`.\n   *\n   * This utility function is used as the default comparator\n   * for ordering collections, for example in the [List] sort function.\n   */\n  static int compare(Comparable a, Comparable b) => a.compareTo(b);\n}\n\u0000","sdk:/sdk/lib/core/bool.dart":"// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\npart of dart.core;\n\n/**\n * The reserved words [:true:] and [:false:] denote objects that are the only\n * instances of this class.\n *\n * It is a compile-time error for a class to attempt to extend or implement\n * bool.\n */\nclass bool {\n  /**\n   * Returns the boolean value of the environment declaration [name].\n   *\n   * The boolean value of the declaration is `true` if the declared value is\n   * the string `\"true\"`, and `false` if the value is `\"false\"`.\n   *\n   * In all other cases, including when there is no declaration for `name`,\n   * the result is the [defaultValue].\n   *\n   * Example:\n   *\n   *     const loggingFlag = const bool.fromEnvironment(\"logging\");\n   *\n   * If you want to use a different truth-string, you can use the\n   * [String.fromEnvironment] constructor directly:\n   *\n   *     const isLoggingOn = (const String.fromEnvironment(\"logging\") == \"on\");\n   */\n  external const factory bool.fromEnvironment(String name,\n                                              {bool defaultValue: false});\n\n  /**\n   * Returns [:\"true\":] if the receiver is [:true:], or [:\"false\":] if the\n   * receiver is [:false:].\n   */\n  String toString() {\n    return this ? \"true\" : \"false\";\n  }\n}\n\u0000","sdk:/sdk/lib/core/annotations.dart":"// Copyright (c) 2013, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\npart of dart.core;\n\n/**\n * The annotation `@Deprecated('expires when')` marks a feature as deprecated.\n *\n * The annotation `@deprecated` is a shorthand for deprecating until\n * an unspecified \"next release\".\n *\n * The intent of the `@Deprecated` annotation is to inform users of a feature\n * that they should change their code, even if it is currently still working\n * correctly.\n *\n * A deprecated feature is scheduled to be removed at a later time, possibly\n * specified as the \"expires\" field of the annotation.\n * This means that a deprecated feature should not be used, or code using it\n * will break at some point in the future. If there is code using the feature,\n * that code should be rewritten to not use the deprecated feature.\n *\n * A deprecated feature should document how the same effect can be achieved,\n * so the programmer knows how to rewrite the code.\n *\n * The `@Deprecated` annotation applies to libraries, top-level declarations\n * (variables, getters, setters, functions, classes and typedefs),\n * class-level declarations (variables, getters, setters, methods, operators or\n * constructors, whether static or not), named optional arguments and\n * trailing optional positional parameters.\n *\n * Deprecation is transitive:\n *\n *  - If a library is deprecated, so is every member of it.\n *  - If a class is deprecated, so is every member of it.\n *  - If a variable is deprecated, so are its implicit getter and setter.\n *\n *\n * A tool that processes Dart source code may report when:\n *\n * - the code imports a deprecated library.\n * - the code exports a deprecated library, or any deprecated member of\n *   a non-deprecated library.\n * - the code refers statically to a deprecated declaration.\n * - the code dynamically uses a member of an object with a statically known\n *   type, where the member is deprecated on the static type of the object.\n * - the code dynamically calls a method with an argument where the\n *   corresponding optional parameter is deprecated on the object's static type.\n *\n *\n * If the deprecated use is inside a library, class or method which is itself\n * deprecated, the tool should not bother the user about it.\n * A deprecated feature is expected to use other deprecated features.\n */\nclass Deprecated {\n  /**\n   * A description of when the deprecated feature is expected to be retired.\n   */\n  final String expires;\n\n  /**\n   * Create a deprecation annotation which specifies the expiration of the\n   * annotated feature.\n   *\n   * The [expires] argument should be readable by programmers, and should state\n   * when an annotated feature is expected to be removed.\n   * This can be specified, for example, as a date, as a release number, or\n   * as relative to some other change (like \"when bug 4418 is fixed\").\n   */\n  const Deprecated(String expires) : this.expires = expires;\n\n  String toString() => \"Deprecated feature. Will be removed $expires\";\n}\n\nclass _Override {\n  const _Override();\n}\n\n/**\n * Marks a feature as [Deprecated] until the next release.\n */\nconst Deprecated deprecated = const Deprecated(\"next release\");\n\n/**\n * The annotation `@override` marks an instance member as overriding a\n * superclass member with the same name.\n *\n * The annotation applies to instance methods, getters and setters, and to\n * instance fields, where it means that the implicit getter and setter of the\n * field is marked as overriding, but the field itself is not.\n *\n * The intent of the `@override` notation is to catch situations where a\n * superclass renames a member, and an independent subclass which used to\n * override the member, could silently continue working using the\n * superclass implementation.\n *\n * The editor, or a similar tool aimed at the programmer, may report if no\n * declaration of an annotated member is inherited by the class from either a\n * superclass or an interface.\n *\n * Use the `@override` annotation judiciously and only for methods where\n * the superclass is not under the programmer's control, the superclass is in a\n * different library or package, and it is not considered stable.\n * In any case, the use of `@override` is optional.\n *\n * For example, the annotation is intentionally not used in the Dart platform\n * libraries, since they only depend on themselves.\n */\nconst Object override = const _Override();\n\nclass _Proxy {\n  const _Proxy();\n}\n\n/**\n * The annotation `@proxy` marks a class as implementing interfaces and members\n * dynamically through `noSuchMethod`.\n *\n * The annotation applies to any class. It is inherited by subclasses from both\n * superclass and interfaces.\n *\n * If a class is annotated with `@proxy`, or it implements any class that is\n * annotated, then the class is considered to implement any interface and\n * any member with regard to static type analysis. As such, it is not a static\n * type warning to assign the object to a variable of any type, and it is not\n * a static type warning to access any member of the object.\n *\n * This only applies to static type warnings. The runtime type of the object\n * is unaffected. It is not considered to implement any special interfaces at\n * runtime, so assigning it to a typed variable may fail in checked mode, and\n * testing it with the `is` operator will not work for any type except the\n * ones it actually implements.\n *\n * Tools that understand `@proxy` should tell the user if a class using `@proxy`\n * does not override the `noSuchMethod` declared on [Object].\n *\n * The intent of the `@proxy` notation is to create objects that implement a\n * type (or multiple types) that are not known at compile time. If the types\n * are known at compile time, a class can be written that implements these\n * types.\n */\nconst Object proxy = const _Proxy();\n\u0000","sdk:/sdk/lib/core/core.dart":"// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n/**\n *\n * Built-in types, collections,\n * and other core functionality for every Dart program.\n *\n * This library is automatically imported.\n *\n * Some classes in this library,\n * such as [String] and [num],\n * support Dart's built-in data types.\n * Other classes, such as [List] and [Map], provide data structures\n * for managing collections of objects.\n * And still other classes represent commonly used types of data\n * such as URIs, dates and times, and errors.\n *\n * ## Numbers and booleans\n *\n * [int] and [double] provide support for Dart's built-in numerical data types:\n * integers and double-precision floating point numbers, respectively.\n * An object of type [bool] is either true or false.\n * Variables of these types can be constructed from literals:\n *\n *     int meaningOfLife = 42;\n *     double valueOfPi  = 3.141592;\n *     bool visible      = true;\n *\n * ## Strings and regular expressions\n *\n * A [String] is immutable and represents a sequence of characters.\n *\n *     String shakespeareQuote = \"All the world's a stage, ...\";\n *\n * [StringBuffer] provides a way to construct strings efficiently.\n *\n *     StringBuffer moreShakespeare = new StringBuffer();\n *     moreShakespeare.write('And all the men and women ');\n *     moreShakespeare.write('merely players; ...');\n *\n * The String and StringBuffer classes implement string concatenation,\n * interpolation, and other string manipulation features.\n *\n *     String philosophy = 'Live on ';\n *     String get palindrome => philosophy + philosophy.split('').reversed.join();\n *\n * [RegExp] implements Dart regular expressions,\n * which provide a grammar for matching patterns within text.\n * For example, here's a regular expression that matches\n * a string of one or more digits:\n *\n *     var numbers = new RegExp(r'\\d+');\n *\n * Dart regular expressions have the same syntax and semantics as\n * JavaScript regular expressions. See\n * <http://ecma-international.org/ecma-262/5.1/#sec-15.10>\n * for the specification of JavaScript regular expressions.\n *\n * ## Collections\n *\n * The dart:core library provides basic collections,\n * such as [List], [Map], and [Set].\n *\n * A List is an ordered collection of objects, with a length.\n * Lists are sometimes called arrays.\n * Use a List when you need to access objects by index.\n *\n *     List superheroes = [ 'Batman', 'Superman', 'Harry Potter' ];\n *\n * A Set is an unordered collection of unique objects.\n * You cannot get an item by index (position).\n * Adding a duplicate item has no effect.\n *\n *     Set villains = new Set();\n *     villains.add('Joker');\n *     villains.addAll( ['Lex Luther', 'Voldemort'] );\n *\n * A Map is an unordered collection of key-value pairs.\n * Maps are sometimes called associative arrays because\n * maps associate a key to some value for easy retrieval.\n * Keys are unique.\n * Use a Map when you need to access objects\n * by a unique identifier.\n *\n *     Map sidekicks = { 'Batman': 'Robin',\n *                       'Superman': 'Lois Lane',\n *                       'Harry Potter': 'Ron and Hermione' };\n *\n * In addition to these classes,\n * dart:core contains [Iterable],\n * an interface that defines functionality\n * common in collections of objects.\n * Examples include the ability\n * to run a function on each element in the collection,\n * to apply a test to each element,\n * to retrieve an object, and to determine length.\n *\n * Iterable is implemented by List and Set,\n * and used by Map for its keys and values.\n *\n * For other kinds of collections, check out the\n * [dart:collection](#dart-collection) library.\n *\n * ## Date and time\n *\n * Use [DateTime] to represent a point in time\n * and [Duration] to represent a span of time.\n *\n * You can create DateTime objects with constructors\n * or by parsing a correctly formatted string.\n *\n *     DateTime now = new DateTime.now();\n *     DateTime berlinWallFell = new DateTime(1989, 11, 9);\n *     DateTime moonLanding = DateTime.parse(\"1969-07-20\");\n *\n * Create a Duration object specifying the individual time units.\n *\n *     Duration timeRemaining = new Duration(hours:56, minutes:14);\n *\n * In addition to DateTime and Duration,\n * dart:core contains the [Stopwatch] class for measuring elapsed time.\n *\n * ## Uri\n *\n * A [Uri] object represents a uniform resource identifier,\n * which identifies a resource on the web.\n *\n *     Uri dartlang = Uri.parse('http://dartlang.org/');\n *\n * ## Errors\n *\n * The [Error] class represents the occurrence of an error\n * during runtime.\n * Subclasses of this class represent specific kinds of errors.\n *\n * ## Other documentation\n *\n * For more information about how to use the built-in types, refer to\n * [Built-in Types](http://www.dartlang.org/docs/dart-up-and-running/contents/ch02.html#built-in-types)\n * in Chapter 2 of\n * [Dart: Up and Running](http://www.dartlang.org/docs/dart-up-and-running/).\n *\n * Also, see\n * [dart:core - Numbers, Collections, Strings, and More](http://www.dartlang.org/docs/dart-up-and-running/contents/ch03.html#ch03-dartcore---strings-collections-and-more)\n * for more coverage of classes in this package.\n *\n * The\n * [Dart Language Specification](http://www.dartlang.org/docs/spec/)\n * provides technical details.\n */\nlibrary dart.core;\n\nimport \"dart:collection\";\nimport \"dart:_internal\" hide Symbol;\nimport \"dart:_internal\" as internal show Symbol;\nimport \"dart:convert\" show UTF8, LATIN1, Encoding;\nimport \"dart:math\" show Random;  // Used by List.shuffle.\n\npart \"annotations.dart\";\npart \"bool.dart\";\npart \"comparable.dart\";\npart \"date_time.dart\";\npart \"double.dart\";\npart \"duration.dart\";\npart \"errors.dart\";\npart \"exceptions.dart\";\npart \"expando.dart\";\npart \"function.dart\";\npart \"identical.dart\";\npart \"int.dart\";\npart \"invocation.dart\";\npart \"iterable.dart\";\npart \"iterator.dart\";\npart \"list.dart\";\npart \"map.dart\";\npart \"null.dart\";\npart \"num.dart\";\npart \"object.dart\";\npart \"pattern.dart\";\npart \"print.dart\";\npart \"regexp.dart\";\npart \"set.dart\";\npart \"sink.dart\";\npart \"stacktrace.dart\";\npart \"stopwatch.dart\";\npart \"string.dart\";\npart \"string_buffer.dart\";\npart \"string_sink.dart\";\npart \"symbol.dart\";\npart \"type.dart\";\npart \"uri.dart\";\n\u0000","sdk:/sdk/lib/internal/symbol.dart":"// Copyright (c) 2013, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\npart of dart._internal;\n\n/**\n * Implementation of [core.Symbol].  This class uses the same name as\n * a core class so a user can't tell the difference.\n *\n * The purpose of this class is to hide [_name] from user code, but\n * make it accessible to Dart platform code via the static method\n * [getName].\n */\nclass Symbol implements core.Symbol {\n  final String _name;\n\n  /**\n   * Source of RegExp matching Dart reserved words.\n   *\n   * Reserved words are not allowed as identifiers.\n   */\n  static const String reservedWordRE =\n      r'(?:assert|break|c(?:a(?:se|tch)|lass|on(?:st|tinue))|d(?:efault|o)|'\n      r'e(?:lse|num|xtends)|f(?:alse|inal(?:ly)?|or)|i[fns]|n(?:ew|ull)|'\n      r'ret(?:hrow|urn)|s(?:uper|witch)|t(?:h(?:is|row)|r(?:ue|y))|'\n      r'v(?:ar|oid)|w(?:hile|ith))';\n  /**\n   * Source of RegExp matching any public identifier.\n   *\n   * A public identifier is a valid identifier (not a reserved word)\n   * that doesn't start with '_'.\n   */\n  static const String publicIdentifierRE =\n      r'(?!' '$reservedWordRE' r'\\b(?!\\$))[a-zA-Z$][\\w$]*';\n  /**\n   * Source of RegExp matching any identifier.\n   *\n   * It matches identifiers but not reserved words. The identifiers\n   * may start with '_'.\n   */\n  static const String identifierRE =\n      r'(?!' '$reservedWordRE' r'\\b(?!\\$))[a-zA-Z$_][\\w$]*';\n  /**\n   * Source of RegExp matching a declarable operator names.\n   *\n   * The operators that can be declared using `operator` declarations are\n   * also the only ones allowed as symbols. The name of the oeprators is\n   * the same as the operator itself except for unary minus, where the name\n   * is \"unary-\".\n   */\n  static const String operatorRE =\n      r'(?:[\\-+*/%&|^]|\\[\\]=?|==|~/?|<[<=]?|>[>=]?|unary-)';\n\n  // Grammar if symbols:\n  //    symbol ::= qualifiedName | <empty>\n  //    qualifiedName ::= publicIdentifier '.' qualifiedName | name\n  //    name ::= publicIdentifier\n  //           | publicIdentifier '='\n  //           | operator\n  // where publicIdentifier is any valid identifier (not a reserved word)\n  // that isn't private (doesn't start with '_').\n  //\n  // Railroad diagram of the accepted grammar:\n  //\n  //    /----------------\\\n  //    |                |\n  //    |          /-[.]-/     /-[=]-\\\n  //    \\         /           /       \\\n  //  -------[id]------------------------->\n  //       \\                     /\n  //        \\------[operator]---/\n  //            \\              /\n  //             \\------------/\n  //\n\n  /**\n   * RegExp that validates a non-empty non-private symbol.\n   *\n   * The empty symbol is handled before this regexp is used, and is not\n   * accepted.\n   */\n  static final RegExp publicSymbolPattern = new RegExp(\n      '^(?:$operatorRE\\$|$publicIdentifierRE(?:=?\\$|[.](?!\\$)))+?\\$');\n\n  // The grammar of symbols that may be private is the same as for public\n  // symbols, except that \"publicIdentifier\" is replaced by \"identifier\",\n  // which matches any identifier.\n\n  /**\n   * RegExp that validates a non-empty symbol.\n   *\n   * Private symbols are accepted.\n   *\n   * The empty symbol is handled before this regexp is used, and is not\n   * accepted.\n   */\n  static final RegExp symbolPattern = new RegExp(\n      '^(?:$operatorRE\\$|$identifierRE(?:=?\\$|[.](?!\\$)))+?\\$');\n\n  external const Symbol(String name);\n\n  /**\n   * Platform-private method used by the mirror system to create\n   * otherwise invalid names.\n   */\n  const Symbol.unvalidated(this._name);\n\n  // This is called by dart2js.\n  Symbol.validated(String name)\n      : this._name = validatePublicSymbol(name);\n\n  bool operator ==(other) => other is Symbol && _name == other._name;\n\n  int get hashCode {\n    const arbitraryPrime = 664597;\n    return 0x1fffffff & (arbitraryPrime * _name.hashCode);\n  }\n\n  toString() => 'Symbol(\"$_name\")';\n\n  /// Platform-private accessor which cannot be called from user libraries.\n  static String getName(Symbol symbol) => symbol._name;\n\n  static String validatePublicSymbol(String name) {\n    if (name.isEmpty || publicSymbolPattern.hasMatch(name)) return name;\n    if (name.startsWith('_')) {\n      // There may be other private parts in a qualified name than the first\n      // one, but this is a common case that deserves a specific error\n      // message.\n      throw new ArgumentError('\"$name\" is a private identifier');\n    }\n    throw new ArgumentError(\n        '\"$name\" is not a valid (qualified) symbol name');\n  }\n\n  /**\n   * Checks whether name is a valid symbol name.\n   *\n   * This test allows both private and non-private symbols.\n   */\n  static bool isValidSymbol(String name) {\n    return (name.isEmpty || symbolPattern.hasMatch(name));\n  }\n}\n\u0000","sdk:/sdk/lib/internal/sort.dart":"// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\npart of dart._internal;\n\n/**\n * Dual-Pivot Quicksort algorithm.\n *\n * This class implements the dual-pivot quicksort algorithm as presented in\n * Vladimir Yaroslavskiy's paper.\n *\n * Some improvements have been copied from Android's implementation.\n */\nclass Sort {\n  // When a list has less then [:_INSERTION_SORT_THRESHOLD:] elements it will\n  // be sorted by an insertion sort.\n  static const int _INSERTION_SORT_THRESHOLD = 32;\n\n  /**\n   * Sorts all elements of the given list [:a:] according to the given\n   * [:compare:] function.\n   *\n   * The [:compare:] function takes two arguments [:x:] and [:y:] and returns\n   *  -1 if [:x < y:],\n   *   0 if [:x == y:], and\n   *   1 if [:x > y:].\n   *\n   * The function's behavior must be consistent. It must not return different\n   * results for the same values.\n   */\n  static void sort(List a, int compare(a, b)) {\n    _doSort(a, 0, a.length - 1, compare);\n  }\n\n  /**\n   * Sorts all elements in the range [:from:] (inclusive) to [:to:] (exclusive)\n   * of the given list [:a:].\n   *\n   * If the given range is invalid an \"OutOfRange\" error is raised.\n   * TODO(floitsch): do we want an error?\n   *\n   * See [:sort:] for requirements of the [:compare:] function.\n   */\n  static void sortRange(List a, int from, int to, int compare(a, b)) {\n    if ((from < 0) || (to > a.length) || (to < from)) {\n      throw \"OutOfRange\";\n    }\n    _doSort(a, from, to - 1, compare);\n  }\n\n  /**\n   * Sorts the list in the interval [:left:] to [:right:] (both inclusive).\n   */\n  static void _doSort(List a, int left, int right, int compare(a, b)) {\n    if ((right - left) <= _INSERTION_SORT_THRESHOLD) {\n      _insertionSort(a, left, right, compare);\n    } else {\n      _dualPivotQuicksort(a, left, right, compare);\n    }\n  }\n\n  static void _insertionSort(List a, int left, int right, int compare(a, b)) {\n    for (int i = left + 1; i <= right; i++) {\n      var el = a[i];\n      int j = i;\n      while ((j > left) && (compare(a[j - 1], el) > 0)) {\n        a[j] = a[j - 1];\n        j--;\n      }\n      a[j] = el;\n    }\n  }\n\n  static void _dualPivotQuicksort(List a,\n                                  int left, int right,\n                                  int compare(a, b)) {\n    assert(right - left > _INSERTION_SORT_THRESHOLD);\n\n    // Compute the two pivots by looking at 5 elements.\n    int sixth = (right - left + 1) ~/ 6;\n    int index1 = left + sixth;\n    int index5 = right - sixth;\n    int index3 = (left + right) ~/ 2;  // The midpoint.\n    int index2 = index3 - sixth;\n    int index4 = index3 + sixth;\n\n    var el1 = a[index1];\n    var el2 = a[index2];\n    var el3 = a[index3];\n    var el4 = a[index4];\n    var el5 = a[index5];\n\n    // Sort the selected 5 elements using a sorting network.\n    if (compare(el1, el2) > 0) { var t = el1; el1 = el2; el2 = t; }\n    if (compare(el4, el5) > 0) { var t = el4; el4 = el5; el5 = t; }\n    if (compare(el1, el3) > 0) { var t = el1; el1 = el3; el3 = t; }\n    if (compare(el2, el3) > 0) { var t = el2; el2 = el3; el3 = t; }\n    if (compare(el1, el4) > 0) { var t = el1; el1 = el4; el4 = t; }\n    if (compare(el3, el4) > 0) { var t = el3; el3 = el4; el4 = t; }\n    if (compare(el2, el5) > 0) { var t = el2; el2 = el5; el5 = t; }\n    if (compare(el2, el3) > 0) { var t = el2; el2 = el3; el3 = t; }\n    if (compare(el4, el5) > 0) { var t = el4; el4 = el5; el5 = t; }\n\n    var pivot1 = el2;\n    var pivot2 = el4;\n\n    // el2 and el4 have been saved in the pivot variables. They will be written\n    // back, once the partioning is finished.\n    a[index1] = el1;\n    a[index3] = el3;\n    a[index5] = el5;\n\n    a[index2] = a[left];\n    a[index4] = a[right];\n\n    int less = left + 1;    // First element in the middle partition.\n    int great = right - 1;  // Last element in the middle partition.\n\n    bool pivots_are_equal = (compare(pivot1, pivot2) == 0);\n    if (pivots_are_equal) {\n      var pivot = pivot1;\n      // Degenerated case where the partioning becomes a dutch national flag\n      // problem.\n      //\n      // [ |  < pivot  | == pivot | unpartitioned | > pivot  | ]\n      //  ^             ^          ^             ^            ^\n      // left         less         k           great         right\n      //\n      // a[left] and a[right] are undefined and are filled after the\n      // partitioning.\n      //\n      // Invariants:\n      //   1) for x in ]left, less[ : x < pivot.\n      //   2) for x in [less, k[ : x == pivot.\n      //   3) for x in ]great, right[ : x > pivot.\n      for (int k = less; k <= great; k++) {\n        var ak = a[k];\n        int comp = compare(ak, pivot);\n        if (comp == 0) continue;\n        if (comp < 0) {\n          if (k != less) {\n            a[k] = a[less];\n            a[less] = ak;\n          }\n          less++;\n        } else {\n          // comp > 0.\n          //\n          // Find the first element <= pivot in the range [k - 1, great] and\n          // put [:ak:] there. We know that such an element must exist:\n          // When k == less, then el3 (which is equal to pivot) lies in the\n          // interval. Otherwise a[k - 1] == pivot and the search stops at k-1.\n          // Note that in the latter case invariant 2 will be violated for a\n          // short amount of time. The invariant will be restored when the\n          // pivots are put into their final positions.\n          while (true) {\n            comp = compare(a[great], pivot);\n            if (comp > 0) {\n              great--;\n              // This is the only location in the while-loop where a new\n              // iteration is started.\n              continue;\n            } else if (comp < 0) {\n              // Triple exchange.\n              a[k] = a[less];\n              a[less++] = a[great];\n              a[great--] = ak;\n              break;\n            } else {\n              // comp == 0;\n              a[k] = a[great];\n              a[great--] = ak;\n              // Note: if great < k then we will exit the outer loop and fix\n              // invariant 2 (which we just violated).\n              break;\n            }\n          }\n        }\n      }\n    } else {\n      // We partition the list into three parts:\n      //  1. < pivot1\n      //  2. >= pivot1 && <= pivot2\n      //  3. > pivot2\n      //\n      // During the loop we have:\n      // [ | < pivot1 | >= pivot1 && <= pivot2 | unpartitioned  | > pivot2  | ]\n      //  ^            ^                        ^              ^             ^\n      // left         less                     k              great        right\n      //\n      // a[left] and a[right] are undefined and are filled after the\n      // partitioning.\n      //\n      // Invariants:\n      //   1. for x in ]left, less[ : x < pivot1\n      //   2. for x in [less, k[ : pivot1 <= x && x <= pivot2\n      //   3. for x in ]great, right[ : x > pivot2\n      for (int k = less; k <= great; k++) {\n        var ak = a[k];\n        int comp_pivot1 = compare(ak, pivot1);\n        if (comp_pivot1 < 0) {\n          if (k != less) {\n            a[k] = a[less];\n            a[less] = ak;\n          }\n          less++;\n        } else {\n          int comp_pivot2 = compare(ak, pivot2);\n          if (comp_pivot2 > 0) {\n            while (true) {\n              int comp = compare(a[great], pivot2);\n              if (comp > 0) {\n                great--;\n                if (great < k) break;\n                // This is the only location inside the loop where a new\n                // iteration is started.\n                continue;\n              } else {\n                // a[great] <= pivot2.\n                comp = compare(a[great], pivot1);\n                if (comp < 0) {\n                  // Triple exchange.\n                  a[k] = a[less];\n                  a[less++] = a[great];\n                  a[great--] = ak;\n                } else {\n                  // a[great] >= pivot1.\n                  a[k] = a[great];\n                  a[great--] = ak;\n                }\n                break;\n              }\n            }\n          }\n        }\n      }\n    }\n\n    // Move pivots into their final positions.\n    // We shrunk the list from both sides (a[left] and a[right] have\n    // meaningless values in them) and now we move elements from the first\n    // and third partition into these locations so that we can store the\n    // pivots.\n    a[left] = a[less - 1];\n    a[less - 1] = pivot1;\n    a[right] = a[great + 1];\n    a[great + 1] = pivot2;\n\n    // The list is now partitioned into three partitions:\n    // [ < pivot1   | >= pivot1 && <= pivot2   |  > pivot2   ]\n    //  ^            ^                        ^             ^\n    // left         less                     great        right\n\n    // Recursive descent. (Don't include the pivot values.)\n    _doSort(a, left, less - 2, compare);\n    _doSort(a, great + 2, right, compare);\n\n    if (pivots_are_equal) {\n      // All elements in the second partition are equal to the pivot. No\n      // need to sort them.\n      return;\n    }\n\n    // In theory it should be enough to call _doSort recursively on the second\n    // partition.\n    // The Android source however removes the pivot elements from the recursive\n    // call if the second partition is too large (more than 2/3 of the list).\n    if (less < index1 && great > index5) {\n      while (compare(a[less], pivot1) == 0) { less++; }\n      while (compare(a[great], pivot2) == 0) { great--; }\n\n      // Copy paste of the previous 3-way partitioning with adaptions.\n      //\n      // We partition the list into three parts:\n      //  1. == pivot1\n      //  2. > pivot1 && < pivot2\n      //  3. == pivot2\n      //\n      // During the loop we have:\n      // [ == pivot1 | > pivot1 && < pivot2 | unpartitioned  | == pivot2 ]\n      //              ^                      ^              ^\n      //            less                     k              great\n      //\n      // Invariants:\n      //   1. for x in [ *, less[ : x == pivot1\n      //   2. for x in [less, k[ : pivot1 < x && x < pivot2\n      //   3. for x in ]great, * ] : x == pivot2\n      for (int k = less; k <= great; k++) {\n        var ak = a[k];\n        int comp_pivot1 = compare(ak, pivot1);\n        if (comp_pivot1 == 0) {\n          if (k != less) {\n            a[k] = a[less];\n            a[less] = ak;\n          }\n          less++;\n        } else {\n          int comp_pivot2 = compare(ak, pivot2);\n          if (comp_pivot2 == 0) {\n            while (true) {\n              int comp = compare(a[great], pivot2);\n              if (comp == 0) {\n                great--;\n                if (great < k) break;\n                // This is the only location inside the loop where a new\n                // iteration is started.\n                continue;\n              } else {\n                // a[great] < pivot2.\n                comp = compare(a[great], pivot1);\n                if (comp < 0) {\n                  // Triple exchange.\n                  a[k] = a[less];\n                  a[less++] = a[great];\n                  a[great--] = ak;\n                } else {\n                  // a[great] == pivot1.\n                  a[k] = a[great];\n                  a[great--] = ak;\n                }\n                break;\n              }\n            }\n          }\n        }\n      }\n      // The second partition has now been cleared of pivot elements and looks\n      // as follows:\n      // [  *  |  > pivot1 && < pivot2  | * ]\n      //        ^                      ^\n      //       less                  great\n      // Sort the second partition using recursive descent.\n      _doSort(a, less, great, compare);\n    } else {\n      // The second partition looks as follows:\n      // [  *  |  >= pivot1 && <= pivot2  | * ]\n      //        ^                        ^\n      //       less                    great\n      // Simply sort it by recursive descent.\n      _doSort(a, less, great, compare);\n    }\n  }\n}\n\u0000","sdk:/sdk/lib/internal/print.dart":"// Copyright (c) 2013, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\npart of dart._internal;\n\n/**\n * This function is set by the first allocation of a Zone.\n *\n * Once the function is set the core `print` function calls this closure instead\n * of [printToConsole].\n *\n * This decouples the core library from the async library.\n */\nFunction printToZone = null;\n\nexternal void printToConsole(String line);\n\u0000","sdk:/sdk/lib/internal/lists.dart":"// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\npart of dart._internal;\n\nclass Lists {\n  static void copy(List src, int srcStart,\n                   List dst, int dstStart, int count) {\n    if (srcStart < dstStart) {\n      for (int i = srcStart + count - 1, j = dstStart + count - 1;\n           i >= srcStart; i--, j--) {\n        dst[j] = src[i];\n      }\n    } else {\n      for (int i = srcStart, j = dstStart; i < srcStart + count; i++, j++) {\n        dst[j] = src[i];\n      }\n    }\n  }\n\n  static bool areEqual(List a, var b) {\n    if (identical(a, b)) return true;\n    if (!(b is List)) return false;\n    int length = a.length;\n    if (length != b.length) return false;\n\n    for (int i = 0; i < length; i++) {\n      if (!identical(a[i], b[i])) return false;\n    }\n    return true;\n  }\n\n  /**\n   * Returns the index in the list [a] of the given [element], starting\n   * the search at index [startIndex] to [endIndex] (exclusive).\n   * Returns -1 if [element] is not found.\n   */\n  static int indexOf(List a,\n                     Object element,\n                     int startIndex,\n                     int endIndex) {\n    if (startIndex >= a.length) {\n      return -1;\n    }\n    if (startIndex < 0) {\n      startIndex = 0;\n    }\n    for (int i = startIndex; i < endIndex; i++) {\n      if (a[i] == element) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Returns the last index in the list [a] of the given [element], starting\n   * the search at index [startIndex] to 0.\n   * Returns -1 if [element] is not found.\n   */\n  static int lastIndexOf(List a, Object element, int startIndex) {\n    if (startIndex < 0) {\n      return -1;\n    }\n    if (startIndex >= a.length) {\n      startIndex = a.length - 1;\n    }\n    for (int i = startIndex; i >= 0; i--) {\n      if (a[i] == element) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  static void indicesCheck(List a, int start, int end) {\n    if (start < 0 || start > a.length) {\n      throw new RangeError.range(start, 0, a.length);\n    }\n    if (end != null && (end < start || end > a.length)) {\n      throw new RangeError.range(end, start, a.length);\n    }\n  }\n\n  static void rangeCheck(List a, int start, int length) {\n    if (length < 0) {\n      throw new ArgumentError(\"negative length $length\");\n    }\n    if (start < 0 ) {\n      String message = \"$start must be greater than or equal to 0\";\n      throw new RangeError(message);\n    }\n    if (start + length > a.length) {\n      String message = \"$start + $length must be in the range [0..${a.length})\";\n      throw new RangeError(message);\n    }\n  }\n}\n\u0000","sdk:/sdk/lib/internal/list.dart":"// Copyright (c) 2013, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\npart of dart._internal;\n\n/**\n * Mixin that throws on the length changing operations of [List].\n *\n * Intended to mix-in on top of [ListMixin] for fixed-length lists.\n */\nabstract class FixedLengthListMixin<E> {\n  /** This operation is not supported by a fixed length list. */\n  void set length(int newLength) {\n    throw new UnsupportedError(\n        \"Cannot change the length of a fixed-length list\");\n  }\n\n  /** This operation is not supported by a fixed length list. */\n  void add(E value) {\n    throw new UnsupportedError(\n        \"Cannot add to a fixed-length list\");\n  }\n\n  /** This operation is not supported by a fixed length list. */\n  void insert(int index, E value) {\n    throw new UnsupportedError(\n        \"Cannot add to a fixed-length list\");\n  }\n\n  /** This operation is not supported by a fixed length list. */\n  void insertAll(int at, Iterable<E> iterable) {\n    throw new UnsupportedError(\n        \"Cannot add to a fixed-length list\");\n  }\n\n  /** This operation is not supported by a fixed length list. */\n  void addAll(Iterable<E> iterable) {\n    throw new UnsupportedError(\n        \"Cannot add to a fixed-length list\");\n  }\n\n  /** This operation is not supported by a fixed length list. */\n  bool remove(Object element) {\n    throw new UnsupportedError(\n        \"Cannot remove from a fixed-length list\");\n  }\n\n  /** This operation is not supported by a fixed length list. */\n  void removeWhere(bool test(E element)) {\n    throw new UnsupportedError(\n        \"Cannot remove from a fixed-length list\");\n  }\n\n  /** This operation is not supported by a fixed length list. */\n  void retainWhere(bool test(E element)) {\n    throw new UnsupportedError(\n        \"Cannot remove from a fixed-length list\");\n  }\n\n  /** This operation is not supported by a fixed length list. */\n  void clear() {\n    throw new UnsupportedError(\n        \"Cannot clear a fixed-length list\");\n  }\n\n  /** This operation is not supported by a fixed length list. */\n  E removeAt(int index) {\n    throw new UnsupportedError(\n        \"Cannot remove from a fixed-length list\");\n  }\n\n  /** This operation is not supported by a fixed length list. */\n  E removeLast() {\n    throw new UnsupportedError(\n        \"Cannot remove from a fixed-length list\");\n  }\n\n  /** This operation is not supported by a fixed length list. */\n  void removeRange(int start, int end) {\n    throw new UnsupportedError(\n        \"Cannot remove from a fixed-length list\");\n  }\n\n  /** This operation is not supported by a fixed length list. */\n  void replaceRange(int start, int end, Iterable<E> iterable) {\n    throw new UnsupportedError(\n        \"Cannot remove from a fixed-length list\");\n  }\n}\n\n/**\n * Mixin for an unmodifiable [List] class.\n *\n * This overrides all mutating methods with methods that throw.\n * This mixin is intended to be mixed in on top of [ListMixin] on\n * unmodifiable lists.\n */\nabstract class UnmodifiableListMixin<E> implements List<E> {\n\n  /** This operation is not supported by an unmodifiable list. */\n  void operator []=(int index, E value) {\n    throw new UnsupportedError(\n        \"Cannot modify an unmodifiable list\");\n  }\n\n  /** This operation is not supported by an unmodifiable list. */\n  void set length(int newLength) {\n    throw new UnsupportedError(\n        \"Cannot change the length of an unmodifiable list\");\n  }\n\n  /** This operation is not supported by an unmodifiable list. */\n  void setAll(int at, Iterable<E> iterable) {\n    throw new UnsupportedError(\n        \"Cannot modify an unmodifiable list\");\n  }\n\n  /** This operation is not supported by an unmodifiable list. */\n  void add(E value) {\n    throw new UnsupportedError(\n      \"Cannot add to an unmodifiable list\");\n  }\n\n  /** This operation is not supported by an unmodifiable list. */\n  E insert(int index, E value) {\n    throw new UnsupportedError(\n        \"Cannot add to an unmodifiable list\");\n  }\n\n  /** This operation is not supported by an unmodifiable list. */\n  void insertAll(int at, Iterable<E> iterable) {\n    throw new UnsupportedError(\n        \"Cannot add to an unmodifiable list\");\n  }\n\n  /** This operation is not supported by an unmodifiable list. */\n  void addAll(Iterable<E> iterable) {\n    throw new UnsupportedError(\n        \"Cannot add to an unmodifiable list\");\n  }\n\n  /** This operation is not supported by an unmodifiable list. */\n  bool remove(Object element) {\n    throw new UnsupportedError(\n        \"Cannot remove from an unmodifiable list\");\n  }\n\n  /** This operation is not supported by an unmodifiable list. */\n  void removeWhere(bool test(E element)) {\n    throw new UnsupportedError(\n        \"Cannot remove from an unmodifiable list\");\n  }\n\n  /** This operation is not supported by an unmodifiable list. */\n  void retainWhere(bool test(E element)) {\n    throw new UnsupportedError(\n        \"Cannot remove from an unmodifiable list\");\n  }\n\n  /** This operation is not supported by an unmodifiable list. */\n  void sort([Comparator<E> compare]) {\n    throw new UnsupportedError(\n        \"Cannot modify an unmodifiable list\");\n  }\n\n  /** This operation is not supported by an unmodifiable list. */\n  void shuffle([Random random]) {\n    throw new UnsupportedError(\n        \"Cannot modify an unmodifiable list\");\n  }\n\n  /** This operation is not supported by an unmodifiable list. */\n  void clear() {\n    throw new UnsupportedError(\n        \"Cannot clear an unmodifiable list\");\n  }\n\n  /** This operation is not supported by an unmodifiable list. */\n  E removeAt(int index) {\n    throw new UnsupportedError(\n        \"Cannot remove from an unmodifiable list\");\n  }\n\n  /** This operation is not supported by an unmodifiable list. */\n  E removeLast() {\n    throw new UnsupportedError(\n        \"Cannot remove from an unmodifiable list\");\n  }\n\n  /** This operation is not supported by an unmodifiable list. */\n  void setRange(int start, int end, Iterable<E> iterable, [int skipCount = 0]) {\n    throw new UnsupportedError(\n        \"Cannot modify an unmodifiable list\");\n  }\n\n  /** This operation is not supported by an unmodifiable list. */\n  void removeRange(int start, int end) {\n    throw new UnsupportedError(\n        \"Cannot remove from an unmodifiable list\");\n  }\n\n  /** This operation is not supported by an unmodifiable list. */\n  void replaceRange(int start, int end, Iterable<E> iterable) {\n    throw new UnsupportedError(\n        \"Cannot remove from an unmodifiable list\");\n  }\n\n  /** This operation is not supported by an unmodifiable list. */\n  void fillRange(int start, int end, [E fillValue]) {\n    throw new UnsupportedError(\n        \"Cannot modify an unmodifiable list\");\n  }\n}\n\n/**\n * Abstract implementation of a fixed-length list.\n *\n * All operations are defined in terms of `length`, `operator[]` and\n * `operator[]=`, which need to be implemented.\n */\nabstract class FixedLengthListBase<E> =\n    ListBase<E> with FixedLengthListMixin<E>;\n\n/**\n * Abstract implementation of an unmodifiable list.\n *\n * All operations are defined in terms of `length` and `operator[]`,\n * which need to be implemented.\n */\nabstract class UnmodifiableListBase<E> =\n    ListBase<E> with UnmodifiableListMixin<E>;\n\nclass _ListIndicesIterable extends ListIterable<int> {\n  List _backedList;\n\n  _ListIndicesIterable(this._backedList);\n\n  int get length => _backedList.length;\n  int elementAt(int index) {\n    if (index < 0 || index >= length) {\n      throw new RangeError.range(index, 0, length);\n    }\n    return index;\n  }\n}\n\nclass ListMapView<E> implements Map<int, E> {\n  List<E> _values;\n\n  ListMapView(this._values);\n\n  E operator[] (int key) => containsKey(key) ? _values[key] : null;\n  int get length => _values.length;\n\n  Iterable<E> get values => new SubListIterable<E>(_values, 0, null);\n  Iterable<int> get keys => new _ListIndicesIterable(_values);\n\n  bool get isEmpty => _values.isEmpty;\n  bool get isNotEmpty => _values.isNotEmpty;\n  bool containsValue(Object value) => _values.contains(value);\n  bool containsKey(int key) => key is int && key >= 0 && key < length;\n\n  void forEach(void f(int key, E value)) {\n    int length = _values.length;\n    for (int i = 0; i < length; i++) {\n      f(i, _values[i]);\n      if (length != _values.length) {\n        throw new ConcurrentModificationError(_values);\n      }\n    }\n  }\n\n  /** This operation is not supported by an unmodifiable map. */\n  void operator[]= (int key, E value) {\n    throw new UnsupportedError(\"Cannot modify an unmodifiable map\");\n  }\n\n  /** This operation is not supported by an unmodifiable map. */\n  E putIfAbsent(int key, E ifAbsent()) {\n    throw new UnsupportedError(\"Cannot modify an unmodifiable map\");\n  }\n\n  /** This operation is not supported by an unmodifiable map. */\n  E remove(int key) {\n    throw new UnsupportedError(\"Cannot modify an unmodifiable map\");\n  }\n\n  /** This operation is not supported by an unmodifiable map. */\n  void clear() {\n    throw new UnsupportedError(\"Cannot modify an unmodifiable map\");\n  }\n\n  /** This operation is not supported by an unmodifiable map. */\n  void addAll(Map<int, E> other) {\n    throw new UnsupportedError(\"Cannot modify an unmodifiable map\");\n  }\n\n  String toString() => Maps.mapToString(this);\n}\n\nclass ReversedListIterable<E> extends ListIterable<E> {\n  Iterable<E> _source;\n  ReversedListIterable(this._source);\n\n  int get length => _source.length;\n\n  E elementAt(int index) => _source.elementAt(_source.length - 1 - index);\n}\n\n/**\n * Creates errors thrown by unmodifiable lists when they are attempted modified.\n *\n * This class creates [UnsupportedError]s with specialized messages.\n */\nabstract class UnmodifiableListError {\n  /** Error thrown when trying to add elements to an unmodifiable list. */\n  static UnsupportedError add()\n      => new UnsupportedError(\"Cannot add to unmodifiable List\");\n\n  /** Error thrown when trying to add elements to an unmodifiable list. */\n  static UnsupportedError change()\n      => new UnsupportedError(\n             \"Cannot change the content of an unmodifiable List\");\n\n  /** Error thrown when trying to change the length of an unmodifiable list. */\n  static UnsupportedError length()\n      => new UnsupportedError(\"Cannot change length of unmodifiable List\");\n\n  /** Error thrown when trying to remove elements from an unmodifiable list. */\n  static UnsupportedError remove()\n      => new UnsupportedError(\"Cannot remove from unmodifiable List\");\n}\n\n/**\n * Creates errors thrown by non-growable lists when they are attempted modified.\n *\n * This class creates [UnsupportedError]s with specialized messages.\n */\nabstract class NonGrowableListError {\n  /** Error thrown when trying to add elements to an non-growable list. */\n  static UnsupportedError add()\n      => new UnsupportedError(\"Cannot add to non-growable List\");\n\n  /** Error thrown when trying to change the length of an non-growable list. */\n  static UnsupportedError length()\n      => new UnsupportedError(\"Cannot change length of non-growable List\");\n\n  /** Error thrown when trying to remove elements from an non-growable list. */\n  static UnsupportedError remove()\n      => new UnsupportedError(\"Cannot remove from non-growable List\");\n}\n\n/**\n * Converts a growable list to a fixed length list with the same elements.\n *\n * For internal use only.\n * Only works on growable lists as created by `[]` or `new List()`.\n * May throw on any other list.\n *\n * The operation is efficient. It doesn't copy the elements, but converts\n * the existing list directly to a fixed length list.\n * That means that it is a destructive conversion.\n * The original list should not be used afterwards.\n *\n * The returned list may be the same list as the orginal,\n * or it may be a different list (according to [identical]).\n * The original list may have changed type to be a fixed list,\n * or become empty or been otherwise modified.\n * It will still be a valid object, so references to it will not, e.g., crash\n * the runtime if accessed, but no promises are made wrt. its contents.\n *\n * This unspecified behavior is the reason the function is not exposed to\n * users. We allow the underlying implementation to make the most efficient\n * conversion, at the cost of leaving the original list in an unspecified\n * state.\n */\nexternal List makeListFixedLength(List growableList);\n\u0000","sdk:/sdk/lib/internal/iterable.dart":"// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\npart of dart._internal;\n\n/**\n * Marker interface for [Iterable] subclasses that have an efficient\n * [length] implementation.\n */\nabstract class EfficientLength {\n  /**\n   * Returns the number of elements in the iterable.\n   *\n   * This is an efficient operation that doesn't require iterating through\n   * the elements.\n   */\n  int get length;\n}\n\n/**\n * An [Iterable] for classes that have efficient [length] and [elementAt].\n *\n * All other methods are implemented in terms of [length] and [elementAt],\n * including [iterator].\n */\nabstract class ListIterable<E> extends IterableBase<E>\n                               implements EfficientLength {\n  int get length;\n  E elementAt(int i);\n\n  const ListIterable();\n\n  Iterator<E> get iterator => new ListIterator<E>(this);\n\n  void forEach(void action(E element)) {\n    int length = this.length;\n    for (int i = 0; i < length; i++) {\n      action(elementAt(i));\n      if (length != this.length) {\n        throw new ConcurrentModificationError(this);\n      }\n    }\n  }\n\n  bool get isEmpty => length == 0;\n\n  E get first {\n    if (length == 0) throw IterableElementError.noElement();\n    return elementAt(0);\n  }\n\n  E get last {\n    if (length == 0) throw IterableElementError.noElement();\n    return elementAt(length - 1);\n  }\n\n  E get single {\n    if (length == 0) throw IterableElementError.noElement();\n    if (length > 1) throw IterableElementError.tooMany();\n    return elementAt(0);\n  }\n\n  bool contains(Object element) {\n    int length = this.length;\n    for (int i = 0; i < length; i++) {\n      if (elementAt(i) == element) return true;\n      if (length != this.length) {\n        throw new ConcurrentModificationError(this);\n      }\n    }\n    return false;\n  }\n\n  bool every(bool test(E element)) {\n    int length = this.length;\n    for (int i = 0; i < length; i++) {\n      if (!test(elementAt(i))) return false;\n      if (length != this.length) {\n        throw new ConcurrentModificationError(this);\n      }\n    }\n    return true;\n  }\n\n  bool any(bool test(E element)) {\n    int length = this.length;\n    for (int i = 0; i < length; i++) {\n      if (test(elementAt(i))) return true;\n      if (length != this.length) {\n        throw new ConcurrentModificationError(this);\n      }\n    }\n    return false;\n  }\n\n  dynamic firstWhere(bool test(E element), { Object orElse() }) {\n    int length = this.length;\n    for (int i = 0; i < length; i++) {\n      E element = elementAt(i);\n      if (test(element)) return element;\n      if (length != this.length) {\n        throw new ConcurrentModificationError(this);\n      }\n    }\n    if (orElse != null) return orElse();\n    throw IterableElementError.noElement();\n  }\n\n  dynamic lastWhere(bool test(E element), { Object orElse() }) {\n    int length = this.length;\n    for (int i = length - 1; i >= 0; i--) {\n      E element = elementAt(i);\n      if (test(element)) return element;\n      if (length != this.length) {\n        throw new ConcurrentModificationError(this);\n      }\n    }\n    if (orElse != null) return orElse();\n    throw IterableElementError.noElement();\n  }\n\n  E singleWhere(bool test(E element)) {\n    int length = this.length;\n    E match = null;\n    bool matchFound = false;\n    for (int i = 0; i < length; i++) {\n      E element = elementAt(i);\n      if (test(element)) {\n        if (matchFound) {\n          throw IterableElementError.tooMany();\n        }\n        matchFound = true;\n        match = element;\n      }\n      if (length != this.length) {\n        throw new ConcurrentModificationError(this);\n      }\n    }\n    if (matchFound) return match;\n    throw IterableElementError.noElement();\n  }\n\n  String join([String separator = \"\"]) {\n    int length = this.length;\n    if (!separator.isEmpty) {\n      if (length == 0) return \"\";\n      String first = \"${elementAt(0)}\";\n      if (length != this.length) {\n        throw new ConcurrentModificationError(this);\n      }\n      StringBuffer buffer = new StringBuffer(first);\n      for (int i = 1; i < length; i++) {\n        buffer.write(separator);\n        buffer.write(elementAt(i));\n        if (length != this.length) {\n          throw new ConcurrentModificationError(this);\n        }\n      }\n      return buffer.toString();\n    } else {\n      StringBuffer buffer = new StringBuffer();\n      for (int i = 0; i < length; i++) {\n        buffer.write(elementAt(i));\n        if (length != this.length) {\n          throw new ConcurrentModificationError(this);\n        }\n      }\n      return buffer.toString();\n    }\n  }\n\n  Iterable<E> where(bool test(E element)) => super.where(test);\n\n  Iterable map(f(E element)) => new MappedListIterable(this, f);\n\n  E reduce(E combine(var value, E element)) {\n    if (length == 0) throw IterableElementError.noElement();\n    E value = elementAt(0);\n    for (int i = 1; i < length; i++) {\n      value = combine(value, elementAt(i));\n    }\n    return value;\n  }\n\n  fold(var initialValue, combine(var previousValue, E element)) {\n    var value = initialValue;\n    int length = this.length;\n    for (int i = 0; i < length; i++) {\n      value = combine(value, elementAt(i));\n      if (length != this.length) {\n        throw new ConcurrentModificationError(this);\n      }\n    }\n    return value;\n  }\n\n  Iterable<E> skip(int count) => new SubListIterable<E>(this, count, null);\n\n  Iterable<E> skipWhile(bool test(E element)) => super.skipWhile(test);\n\n  Iterable<E> take(int count) => new SubListIterable<E>(this, 0, count);\n\n  Iterable<E> takeWhile(bool test(E element)) => super.takeWhile(test);\n\n  List<E> toList({ bool growable: true }) {\n    List<E> result;\n    if (growable) {\n      result = new List<E>()..length = length;\n    } else {\n      result = new List<E>(length);\n    }\n    for (int i = 0; i < length; i++) {\n      result[i] = elementAt(i);\n    }\n    return result;\n  }\n\n  Set<E> toSet() {\n    Set<E> result = new Set<E>();\n    for (int i = 0; i < length; i++) {\n      result.add(elementAt(i));\n    }\n    return result;\n  }\n}\n\nclass SubListIterable<E> extends ListIterable<E> {\n  final Iterable<E> _iterable;\n  final int _start;\n  /** If null, represents the length of the iterable. */\n  final int _endOrLength;\n\n  SubListIterable(this._iterable, this._start, this._endOrLength) {\n    if (_start < 0) {\n      throw new RangeError.value(_start);\n    }\n    if (_endOrLength != null) {\n      if (_endOrLength < 0) {\n        throw new RangeError.value(_endOrLength);\n      }\n      if (_start > _endOrLength) {\n        throw new RangeError.range(_start, 0, _endOrLength);\n      }\n    }\n  }\n\n  int get _endIndex {\n    int length = _iterable.length;\n    if (_endOrLength == null || _endOrLength > length) return length;\n    return _endOrLength;\n  }\n\n  int get _startIndex {\n    int length = _iterable.length;\n    if (_start > length) return length;\n    return _start;\n  }\n\n  int get length {\n    int length = _iterable.length;\n    if (_start >= length) return 0;\n    if (_endOrLength == null || _endOrLength >= length) {\n      return length - _start;\n    }\n    return _endOrLength - _start;\n  }\n\n  E elementAt(int index) {\n    int realIndex = _startIndex + index;\n    if (index < 0 || realIndex >= _endIndex) {\n      throw new RangeError.range(index, 0, length);\n    }\n    return _iterable.elementAt(realIndex);\n  }\n\n  Iterable<E> skip(int count) {\n    if (count < 0) throw new RangeError.value(count);\n    int newStart = _start + count;\n    if (_endOrLength != null && newStart >= _endOrLength) {\n      return new EmptyIterable<E>();\n    }\n    return new SubListIterable<E>(_iterable, newStart, _endOrLength);\n  }\n\n  Iterable<E> take(int count) {\n    if (count < 0) throw new RangeError.value(count);\n    if (_endOrLength == null) {\n      return new SubListIterable<E>(_iterable, _start, _start + count);\n    } else {\n      int newEnd = _start + count;\n      if (_endOrLength < newEnd) return this;\n      return new SubListIterable<E>(_iterable, _start, newEnd);\n    }\n  }\n}\n\n/**\n * An [Iterator] that iterates a list-like [Iterable].\n *\n * All iterations is done in terms of [Iterable.length] and\n * [Iterable.elementAt]. These operations are fast for list-like\n * iterables.\n */\nclass ListIterator<E> implements Iterator<E> {\n  final Iterable<E> _iterable;\n  final int _length;\n  int _index;\n  E _current;\n\n  ListIterator(Iterable<E> iterable)\n      : _iterable = iterable, _length = iterable.length, _index = 0;\n\n  E get current => _current;\n\n  bool moveNext() {\n    int length = _iterable.length;\n    if (_length != length) {\n      throw new ConcurrentModificationError(_iterable);\n    }\n    if (_index >= length) {\n      _current = null;\n      return false;\n    }\n    _current = _iterable.elementAt(_index);\n    _index++;\n    return true;\n  }\n}\n\ntypedef T _Transformation<S, T>(S value);\n\nclass MappedIterable<S, T> extends IterableBase<T> {\n  final Iterable<S> _iterable;\n  final _Transformation<S, T> _f;\n\n  factory MappedIterable(Iterable iterable, T function(S value)) {\n    if (iterable is EfficientLength) {\n      return new EfficientLengthMappedIterable<S, T>(iterable, function);\n    }\n    return new MappedIterable<S, T>._(iterable, function);\n  }\n\n  MappedIterable._(this._iterable, T this._f(S element));\n\n  Iterator<T> get iterator => new MappedIterator<S, T>(_iterable.iterator, _f);\n\n  // Length related functions are independent of the mapping.\n  int get length => _iterable.length;\n  bool get isEmpty => _iterable.isEmpty;\n\n  // Index based lookup can be done before transforming.\n  T get first => _f(_iterable.first);\n  T get last => _f(_iterable.last);\n  T get single => _f(_iterable.single);\n  T elementAt(int index) => _f(_iterable.elementAt(index));\n}\n\nclass EfficientLengthMappedIterable<S, T> extends MappedIterable<S, T>\n                                          implements EfficientLength {\n  EfficientLengthMappedIterable(Iterable iterable, T function(S value))\n      : super._(iterable, function);\n}\n\nclass MappedIterator<S, T> extends Iterator<T> {\n  T _current;\n  final Iterator<S> _iterator;\n  final _Transformation<S, T> _f;\n\n  MappedIterator(this._iterator, T this._f(S element));\n\n  bool moveNext() {\n    if (_iterator.moveNext()) {\n      _current = _f(_iterator.current);\n      return true;\n    }\n    _current = null;\n    return false;\n  }\n\n  T get current => _current;\n}\n\n/**\n * Specialized alternative to [MappedIterable] for mapped [List]s.\n *\n * Expects efficient `length` and `elementAt` on the source iterable.\n */\nclass MappedListIterable<S, T> extends ListIterable<T>\n                               implements EfficientLength {\n  final Iterable<S> _source;\n  final _Transformation<S, T> _f;\n\n  MappedListIterable(this._source, T this._f(S value));\n\n  int get length => _source.length;\n  T elementAt(int index) => _f(_source.elementAt(index));\n}\n\n\ntypedef bool _ElementPredicate<E>(E element);\n\nclass WhereIterable<E> extends IterableBase<E> {\n  final Iterable<E> _iterable;\n  final _ElementPredicate _f;\n\n  WhereIterable(this._iterable, bool this._f(E element));\n\n  Iterator<E> get iterator => new WhereIterator<E>(_iterable.iterator, _f);\n}\n\nclass WhereIterator<E> extends Iterator<E> {\n  final Iterator<E> _iterator;\n  final _ElementPredicate _f;\n\n  WhereIterator(this._iterator, bool this._f(E element));\n\n  bool moveNext() {\n    while (_iterator.moveNext()) {\n      if (_f(_iterator.current)) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  E get current => _iterator.current;\n}\n\ntypedef Iterable<T> _ExpandFunction<S, T>(S sourceElement);\n\nclass ExpandIterable<S, T> extends IterableBase<T> {\n  final Iterable<S> _iterable;\n  final _ExpandFunction _f;\n\n  ExpandIterable(this._iterable, Iterable<T> this._f(S element));\n\n  Iterator<T> get iterator => new ExpandIterator<S, T>(_iterable.iterator, _f);\n}\n\nclass ExpandIterator<S, T> implements Iterator<T> {\n  final Iterator<S> _iterator;\n  final _ExpandFunction _f;\n  // Initialize _currentExpansion to an empty iterable. A null value\n  // marks the end of iteration, and we don't want to call _f before\n  // the first moveNext call.\n  Iterator<T> _currentExpansion = const EmptyIterator();\n  T _current;\n\n  ExpandIterator(this._iterator, Iterable<T> this._f(S element));\n\n  void _nextExpansion() {\n  }\n\n  T get current => _current;\n\n  bool moveNext() {\n    if (_currentExpansion == null) return false;\n    while (!_currentExpansion.moveNext()) {\n      _current = null;\n      if (_iterator.moveNext()) {\n        // If _f throws, this ends iteration. Otherwise _currentExpansion and\n        // _current will be set again below.\n        _currentExpansion = null;\n        _currentExpansion = _f(_iterator.current).iterator;\n      } else {\n        return false;\n      }\n    }\n    _current = _currentExpansion.current;\n    return true;\n  }\n}\n\nclass TakeIterable<E> extends IterableBase<E> {\n  final Iterable<E> _iterable;\n  final int _takeCount;\n\n  factory TakeIterable(Iterable<E> iterable, int takeCount) {\n    if (takeCount is! int || takeCount < 0) {\n      throw new ArgumentError(takeCount);\n    }\n    if (iterable is EfficientLength) {\n      return new EfficientLengthTakeIterable<E>(iterable, takeCount);\n    }\n    return new TakeIterable<E>._(iterable, takeCount);\n  }\n\n  TakeIterable._(this._iterable, this._takeCount);\n\n  Iterator<E> get iterator {\n    return new TakeIterator<E>(_iterable.iterator, _takeCount);\n  }\n}\n\nclass EfficientLengthTakeIterable<E> extends TakeIterable<E>\n                                     implements EfficientLength {\n  EfficientLengthTakeIterable(Iterable<E> iterable, int takeCount)\n      : super._(iterable, takeCount);\n\n  int get length {\n    int iterableLength = _iterable.length;\n    if (iterableLength > _takeCount) return _takeCount;\n    return iterableLength;\n  }\n}\n\n\nclass TakeIterator<E> extends Iterator<E> {\n  final Iterator<E> _iterator;\n  int _remaining;\n\n  TakeIterator(this._iterator, this._remaining) {\n    assert(_remaining is int && _remaining >= 0);\n  }\n\n  bool moveNext() {\n    _remaining--;\n    if (_remaining >= 0) {\n      return _iterator.moveNext();\n    }\n    _remaining = -1;\n    return false;\n  }\n\n  E get current {\n    if (_remaining < 0) return null;\n    return _iterator.current;\n  }\n}\n\nclass TakeWhileIterable<E> extends IterableBase<E> {\n  final Iterable<E> _iterable;\n  final _ElementPredicate _f;\n\n  TakeWhileIterable(this._iterable, bool this._f(E element));\n\n  Iterator<E> get iterator {\n    return new TakeWhileIterator<E>(_iterable.iterator, _f);\n  }\n}\n\nclass TakeWhileIterator<E> extends Iterator<E> {\n  final Iterator<E> _iterator;\n  final _ElementPredicate _f;\n  bool _isFinished = false;\n\n  TakeWhileIterator(this._iterator, bool this._f(E element));\n\n  bool moveNext() {\n    if (_isFinished) return false;\n    if (!_iterator.moveNext() || !_f(_iterator.current)) {\n      _isFinished = true;\n      return false;\n    }\n    return true;\n  }\n\n  E get current {\n    if (_isFinished) return null;\n    return _iterator.current;\n  }\n}\n\nclass SkipIterable<E> extends IterableBase<E> {\n  final Iterable<E> _iterable;\n  final int _skipCount;\n\n  factory SkipIterable(Iterable<E> iterable, int skipCount) {\n    if (iterable is EfficientLength) {\n      return new EfficientLengthSkipIterable<E>(iterable, skipCount);\n    }\n    return new SkipIterable<E>._(iterable, skipCount);\n  }\n\n  SkipIterable._(this._iterable, this._skipCount) {\n    if (_skipCount is! int || _skipCount < 0) {\n      throw new RangeError(_skipCount);\n    }\n  }\n\n  Iterable<E> skip(int n) {\n    if (n is! int || n < 0) {\n      throw new RangeError.value(n);\n    }\n    return new SkipIterable<E>(_iterable, _skipCount + n);\n  }\n\n  Iterator<E> get iterator {\n    return new SkipIterator<E>(_iterable.iterator, _skipCount);\n  }\n}\n\nclass EfficientLengthSkipIterable<E> extends SkipIterable<E>\n                                     implements EfficientLength {\n  EfficientLengthSkipIterable(Iterable<E> iterable, int skipCount)\n      : super._(iterable, skipCount);\n\n  int get length {\n    int length = _iterable.length - _skipCount;\n    if (length >= 0) return length;\n    return 0;\n  }\n}\n\nclass SkipIterator<E> extends Iterator<E> {\n  final Iterator<E> _iterator;\n  int _skipCount;\n\n  SkipIterator(this._iterator, this._skipCount) {\n    assert(_skipCount is int && _skipCount >= 0);\n  }\n\n  bool moveNext() {\n    for (int i = 0; i < _skipCount; i++) _iterator.moveNext();\n    _skipCount = 0;\n    return _iterator.moveNext();\n  }\n\n  E get current => _iterator.current;\n}\n\nclass SkipWhileIterable<E> extends IterableBase<E> {\n  final Iterable<E> _iterable;\n  final _ElementPredicate _f;\n\n  SkipWhileIterable(this._iterable, bool this._f(E element));\n\n  Iterator<E> get iterator {\n    return new SkipWhileIterator<E>(_iterable.iterator, _f);\n  }\n}\n\nclass SkipWhileIterator<E> extends Iterator<E> {\n  final Iterator<E> _iterator;\n  final _ElementPredicate _f;\n  bool _hasSkipped = false;\n\n  SkipWhileIterator(this._iterator, bool this._f(E element));\n\n  bool moveNext() {\n    if (!_hasSkipped) {\n      _hasSkipped = true;\n      while (_iterator.moveNext()) {\n        if (!_f(_iterator.current)) return true;\n      }\n    }\n    return _iterator.moveNext();\n  }\n\n  E get current => _iterator.current;\n}\n\n/**\n * The always empty [Iterable].\n */\nclass EmptyIterable<E> extends IterableBase<E> implements EfficientLength {\n  const EmptyIterable();\n\n  Iterator<E> get iterator => const EmptyIterator();\n\n  void forEach(void action(E element)) {}\n\n  bool get isEmpty => true;\n\n  int get length => 0;\n\n  E get first { throw IterableElementError.noElement(); }\n\n  E get last { throw IterableElementError.noElement(); }\n\n  E get single { throw IterableElementError.noElement(); }\n\n  E elementAt(int index) { throw new RangeError.value(index); }\n\n  bool contains(Object element) => false;\n\n  bool every(bool test(E element)) => true;\n\n  bool any(bool test(E element)) => false;\n\n  E firstWhere(bool test(E element), { E orElse() }) {\n    if (orElse != null) return orElse();\n    throw IterableElementError.noElement();\n  }\n\n  E lastWhere(bool test(E element), { E orElse() }) {\n    if (orElse != null) return orElse();\n    throw IterableElementError.noElement();\n  }\n\n  E singleWhere(bool test(E element), { E orElse() }) {\n    if (orElse != null) return orElse();\n    throw IterableElementError.noElement();\n  }\n\n  String join([String separator = \"\"]) => \"\";\n\n  Iterable<E> where(bool test(E element)) => this;\n\n  Iterable map(f(E element)) => const EmptyIterable();\n\n  E reduce(E combine(E value, E element)) {\n    throw IterableElementError.noElement();\n  }\n\n  fold(var initialValue, combine(var previousValue, E element)) {\n    return initialValue;\n  }\n\n  Iterable<E> skip(int count) {\n    if (count < 0) throw new RangeError.value(count);\n    return this;\n  }\n\n  Iterable<E> skipWhile(bool test(E element)) => this;\n\n  Iterable<E> take(int count) {\n    if (count < 0) throw new RangeError.value(count);\n    return this;\n  }\n\n  Iterable<E> takeWhile(bool test(E element)) => this;\n\n  List toList({ bool growable: true }) => growable ? <E>[] : new List<E>(0);\n\n  Set toSet() => new Set<E>();\n}\n\n/** The always empty iterator. */\nclass EmptyIterator<E> implements Iterator<E> {\n  const EmptyIterator();\n  bool moveNext() => false;\n  E get current => null;\n}\n\n/** An [Iterator] that can move in both directions. */\nabstract class BidirectionalIterator<T> implements Iterator<T> {\n  bool movePrevious();\n}\n\n/**\n * This class provides default implementations for Iterables (including Lists).\n *\n * The uses of this class will be replaced by mixins.\n */\nclass IterableMixinWorkaround<T> {\n  static bool contains(Iterable iterable, var element) {\n    for (final e in iterable) {\n      if (e == element) return true;\n    }\n    return false;\n  }\n\n  static void forEach(Iterable iterable, void f(o)) {\n    for (final e in iterable) {\n      f(e);\n    }\n  }\n\n  static bool any(Iterable iterable, bool f(o)) {\n    for (final e in iterable) {\n      if (f(e)) return true;\n    }\n    return false;\n  }\n\n  static bool every(Iterable iterable, bool f(o)) {\n    for (final e in iterable) {\n      if (!f(e)) return false;\n    }\n    return true;\n  }\n\n  static dynamic reduce(Iterable iterable,\n                        dynamic combine(previousValue, element)) {\n    Iterator iterator = iterable.iterator;\n    if (!iterator.moveNext()) throw IterableElementError.noElement();\n    var value = iterator.current;\n    while (iterator.moveNext()) {\n      value = combine(value, iterator.current);\n    }\n    return value;\n  }\n\n  static dynamic fold(Iterable iterable,\n                      dynamic initialValue,\n                      dynamic combine(dynamic previousValue, element)) {\n    for (final element in iterable) {\n      initialValue = combine(initialValue, element);\n    }\n    return initialValue;\n  }\n\n  /**\n   * Removes elements matching [test] from [list].\n   *\n   * This is performed in two steps, to avoid exposing an inconsistent state\n   * to the [test] function. First the elements to retain are found, and then\n   * the original list is updated to contain those elements.\n   */\n  static void removeWhereList(List list, bool test(var element)) {\n    List retained = [];\n    int length = list.length;\n    for (int i = 0; i < length; i++) {\n      var element = list[i];\n      if (!test(element)) {\n        retained.add(element);\n      }\n      if (length != list.length) {\n        throw new ConcurrentModificationError(list);\n      }\n    }\n    if (retained.length == length) return;\n    list.length = retained.length;\n    for (int i = 0; i < retained.length; i++) {\n      list[i] = retained[i];\n    }\n  }\n\n  static bool isEmpty(Iterable iterable) {\n    return !iterable.iterator.moveNext();\n  }\n\n  static dynamic first(Iterable iterable) {\n    Iterator it = iterable.iterator;\n    if (!it.moveNext()) {\n      throw IterableElementError.noElement();\n    }\n    return it.current;\n  }\n\n  static dynamic last(Iterable iterable) {\n    Iterator it = iterable.iterator;\n    if (!it.moveNext()) {\n      throw IterableElementError.noElement();\n    }\n    dynamic result;\n    do {\n      result = it.current;\n    } while(it.moveNext());\n    return result;\n  }\n\n  static dynamic single(Iterable iterable) {\n    Iterator it = iterable.iterator;\n    if (!it.moveNext()) throw IterableElementError.noElement();\n    dynamic result = it.current;\n    if (it.moveNext()) throw IterableElementError.tooMany();\n    return result;\n  }\n\n  static dynamic firstWhere(Iterable iterable,\n                            bool test(dynamic value),\n                            dynamic orElse()) {\n    for (dynamic element in iterable) {\n      if (test(element)) return element;\n    }\n    if (orElse != null) return orElse();\n    throw IterableElementError.noElement();\n  }\n\n  static dynamic lastWhere(Iterable iterable,\n                           bool test(dynamic value),\n                           dynamic orElse()) {\n    dynamic result = null;\n    bool foundMatching = false;\n    for (dynamic element in iterable) {\n      if (test(element)) {\n        result = element;\n        foundMatching = true;\n      }\n    }\n    if (foundMatching) return result;\n    if (orElse != null) return orElse();\n    throw IterableElementError.noElement();\n  }\n\n  static dynamic lastWhereList(List list,\n                               bool test(dynamic value),\n                               dynamic orElse()) {\n    // TODO(floitsch): check that arguments are of correct type?\n    for (int i = list.length - 1; i >= 0; i--) {\n      dynamic element = list[i];\n      if (test(element)) return element;\n    }\n    if (orElse != null) return orElse();\n    throw IterableElementError.noElement();\n  }\n\n  static dynamic singleWhere(Iterable iterable, bool test(dynamic value)) {\n    dynamic result = null;\n    bool foundMatching = false;\n    for (dynamic element in iterable) {\n      if (test(element)) {\n        if (foundMatching) {\n          throw IterableElementError.tooMany();\n        }\n        result = element;\n        foundMatching = true;\n      }\n    }\n    if (foundMatching) return result;\n    throw IterableElementError.noElement();\n  }\n\n  static dynamic elementAt(Iterable iterable, int index) {\n    if (index is! int || index < 0) throw new RangeError.value(index);\n    int remaining = index;\n    for (dynamic element in iterable) {\n      if (remaining == 0) return element;\n      remaining--;\n    }\n    throw new RangeError.value(index);\n  }\n\n  static String join(Iterable iterable, [String separator]) {\n    StringBuffer buffer = new StringBuffer();\n    buffer.writeAll(iterable, separator);\n    return buffer.toString();\n  }\n\n  static String joinList(List list, [String separator]) {\n    if (list.isEmpty) return \"\";\n    if (list.length == 1) return \"${list[0]}\";\n    StringBuffer buffer = new StringBuffer();\n    if (separator.isEmpty) {\n      for (int i = 0; i < list.length; i++) {\n        buffer.write(list[i]);\n      }\n    } else {\n      buffer.write(list[0]);\n      for (int i = 1; i < list.length; i++) {\n        buffer.write(separator);\n        buffer.write(list[i]);\n      }\n    }\n    return buffer.toString();\n  }\n\n  Iterable<T> where(Iterable iterable, bool f(var element)) {\n    return new WhereIterable<T>(iterable, f);\n  }\n\n  static Iterable map(Iterable iterable, f(var element)) {\n    return new MappedIterable(iterable, f);\n  }\n\n  static Iterable mapList(List list, f(var element)) {\n    return new MappedListIterable(list, f);\n  }\n\n  static Iterable expand(Iterable iterable, Iterable f(var element)) {\n    return new ExpandIterable(iterable, f);\n  }\n\n  Iterable<T> takeList(List list, int n) {\n    // The generic type is currently lost. It will be fixed with mixins.\n    return new SubListIterable<T>(list, 0, n);\n  }\n\n  Iterable<T> takeWhile(Iterable iterable, bool test(var value)) {\n    // The generic type is currently lost. It will be fixed with mixins.\n    return new TakeWhileIterable<T>(iterable, test);\n  }\n\n  Iterable<T> skipList(List list, int n) {\n    // The generic type is currently lost. It will be fixed with mixins.\n    return new SubListIterable<T>(list, n, null);\n  }\n\n  Iterable<T> skipWhile(Iterable iterable, bool test(var value)) {\n    // The generic type is currently lost. It will be fixed with mixins.\n    return new SkipWhileIterable<T>(iterable, test);\n  }\n\n  Iterable<T> reversedList(List list) {\n    return new ReversedListIterable<T>(list);\n  }\n\n  static void sortList(List list, int compare(a, b)) {\n    if (compare == null) compare = Comparable.compare;\n    Sort.sort(list, compare);\n  }\n\n  static void shuffleList(List list, Random random) {\n    if (random == null) random = new Random();\n    int length = list.length;\n    while (length > 1) {\n      int pos = random.nextInt(length);\n      length -= 1;\n      var tmp = list[length];\n      list[length] = list[pos];\n      list[pos] = tmp;\n    }\n  }\n\n  static int indexOfList(List list, var element, int start) {\n    return Lists.indexOf(list, element, start, list.length);\n  }\n\n  static int lastIndexOfList(List list, var element, int start) {\n    if (start == null) start = list.length - 1;\n    return Lists.lastIndexOf(list, element, start);\n  }\n\n  static void _rangeCheck(List list, int start, int end) {\n    if (start < 0 || start > list.length) {\n      throw new RangeError.range(start, 0, list.length);\n    }\n    if (end < start || end > list.length) {\n      throw new RangeError.range(end, start, list.length);\n    }\n  }\n\n  Iterable<T> getRangeList(List list, int start, int end) {\n    _rangeCheck(list, start, end);\n    // The generic type is currently lost. It will be fixed with mixins.\n    return new SubListIterable<T>(list, start, end);\n  }\n\n  static void setRangeList(List list, int start, int end,\n                           Iterable from, int skipCount) {\n    _rangeCheck(list, start, end);\n    int length = end - start;\n    if (length == 0) return;\n\n    if (skipCount < 0) throw new ArgumentError(skipCount);\n\n    // TODO(floitsch): Make this accept more.\n    List otherList;\n    int otherStart;\n    if (from is List) {\n      otherList = from;\n      otherStart = skipCount;\n    } else {\n      otherList = from.skip(skipCount).toList(growable: false);\n      otherStart = 0;\n    }\n    if (otherStart + length > otherList.length) {\n      throw IterableElementError.tooFew();\n    }\n    Lists.copy(otherList, otherStart, list, start, length);\n  }\n\n  static void replaceRangeList(List list, int start, int end,\n                               Iterable iterable) {\n    _rangeCheck(list, start, end);\n    if (iterable is! EfficientLength) {\n      iterable = iterable.toList();\n    }\n    int removeLength = end - start;\n    int insertLength = iterable.length;\n    if (removeLength >= insertLength) {\n      int delta = removeLength - insertLength;\n      int insertEnd = start + insertLength;\n      int newEnd = list.length - delta;\n      list.setRange(start, insertEnd, iterable);\n      if (delta != 0) {\n        list.setRange(insertEnd, newEnd, list, end);\n        list.length = newEnd;\n      }\n    } else {\n      int delta = insertLength - removeLength;\n      int newLength = list.length + delta;\n      int insertEnd = start + insertLength;  // aka. end + delta.\n      list.length = newLength;\n      list.setRange(insertEnd, newLength, list, end);\n      list.setRange(start, insertEnd, iterable);\n    }\n  }\n\n  static void fillRangeList(List list, int start, int end, fillValue) {\n    _rangeCheck(list, start, end);\n    for (int i = start; i < end; i++) {\n      list[i] = fillValue;\n    }\n  }\n\n  static void insertAllList(List list, int index, Iterable iterable) {\n    if (index < 0 || index > list.length) {\n      throw new RangeError.range(index, 0, list.length);\n    }\n    if (iterable is! EfficientLength) {\n      iterable = iterable.toList(growable: false);\n    }\n    int insertionLength = iterable.length;\n    list.length += insertionLength;\n    list.setRange(index + insertionLength, list.length, list, index);\n    for (var element in iterable) {\n      list[index++] = element;\n    }\n  }\n\n  static void setAllList(List list, int index, Iterable iterable) {\n    if (index < 0 || index > list.length) {\n      throw new RangeError.range(index, 0, list.length);\n    }\n    for (var element in iterable) {\n      list[index++] = element;\n    }\n  }\n\n  Map<int, T> asMapList(List l) {\n    return new ListMapView<T>(l);\n  }\n\n  static bool setContainsAll(Set set, Iterable other) {\n    for (var element in other) {\n      if (!set.contains(element)) return false;\n    }\n    return true;\n  }\n\n  static Set setIntersection(Set set, Set other, Set result) {\n    Set smaller;\n    Set larger;\n    if (set.length < other.length) {\n      smaller = set;\n      larger = other;\n    } else {\n      smaller = other;\n      larger = set;\n    }\n    for (var element in smaller) {\n      if (larger.contains(element)) {\n        result.add(element);\n      }\n    }\n    return result;\n  }\n\n  static Set setUnion(Set set, Set other, Set result) {\n    result.addAll(set);\n    result.addAll(other);\n    return result;\n  }\n\n  static Set setDifference(Set set, Set other, Set result) {\n    for (var element in set) {\n      if (!other.contains(element)) {\n        result.add(element);\n      }\n    }\n    return result;\n  }\n}\n\n/**\n * Creates errors throw by [Iterable] when the element count is wrong.\n */\nabstract class IterableElementError {\n  /** Error thrown thrown by, e.g., [Iterable.first] when there is no result. */\n  static StateError noElement() => new StateError(\"No element\");\n  /** Error thrown by, e.g., [Iterable.single] if there are too many results. */\n  static StateError tooMany() => new StateError(\"Too many elements\");\n  /** Error thrown by, e.g., [List.setRange] if there are too few elements. */\n  static StateError tooFew() => new StateError(\"Too few elements\");\n}\n\u0000","sdk:/sdk/lib/internal/internal.dart":"// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\nlibrary dart._internal;\n\nimport 'dart:collection';\n\nimport 'dart:core' hide Symbol;\nimport 'dart:core' as core;\nimport 'dart:math' show Random;\n\npart 'iterable.dart';\npart 'list.dart';\npart 'lists.dart';\npart 'print.dart';\npart 'sort.dart';\npart 'symbol.dart';\n\u0000","sdk:/sdk/lib/_internal/lib/js_primitives.dart":"// Copyright (c) 2013, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n/// dart2js \"primitives\", that is, features that cannot be implemented without\n/// access to JavaScript features.\nlibrary dart2js._js_primitives;\n\nimport 'dart:_foreign_helper' show\n    JS;\n\n/**\n * This is the low-level method that is used to implement [print].  It is\n * possible to override this function from JavaScript by defining a function in\n * JavaScript called \"dartPrint\".\n *\n * Notice that it is also possible to intercept calls to [print] from within a\n * Dart program using zones. This means that there is no guarantee that a call\n * to print ends in this method.\n */\nvoid printString(String string) {\n  if (JS('bool', r'typeof dartPrint == \"function\"')) {\n    // Support overriding print from JavaScript.\n    JS('void', r'dartPrint(#)', string);\n    return;\n  }\n\n  // Inside browser or nodejs.\n  if (JS('bool', r'typeof console == \"object\"') &&\n      JS('bool', r'typeof console.log != \"undefined\"')) {\n    JS('void', r'console.log(#)', string);\n    return;\n  }\n\n  // Don't throw inside IE, the console is only defined if dev tools is open.\n  if (JS('bool', r'typeof window == \"object\"')) {\n    return;\n  }\n\n  // Running in d8, the V8 developer shell, or in Firefox' js-shell.\n  if (JS('bool', r'typeof print == \"function\"')) {\n    JS('void', r'print(#)', string);\n    return;\n  }\n\n  // This is somewhat nasty, but we don't want to drag in a bunch of\n  // dependencies to handle a situation that cannot happen. So we\n  // avoid using Dart [:throw:] and Dart [toString].\n  JS('void', 'throw \"Unable to print message: \" + String(#)', string);\n}\n\u0000","sdk:/sdk/lib/_internal/lib/foreign_helper.dart":"// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\nlibrary _foreign_helper;\n\n/**\n * Emits a JavaScript code fragment parameterized by arguments.\n *\n * Hash characters `#` in the [codeTemplate] are replaced in left-to-right order\n * with expressions that contain the values of, or evaluate to, the arguments.\n * The number of hash marks must match the number or arguments.  Although\n * declared with arguments [arg0] through [arg2], the form actually has no limit\n * on the number of arguments.\n *\n * The [typeDescription] argument is interpreted as a description of the\n * behavior of the JavaScript code.  Currently it describes the types that may\n * be returned by the expression, with the additional behavior that the returned\n * values may be fresh instances of the types.  The type information must be\n * correct as it is trusted by the compiler in optimizations, and it must be\n * precise as possible since it is used for native live type analysis to\n * tree-shake large parts of the DOM libraries.  If poorly written, the\n * [typeDescription] will cause unnecessarily bloated programs.  (You can check\n * for this by compiling with `--verbose`; there is an info message describing\n * the number of native (DOM) types that can be removed, which usually should be\n * greater than zero.)\n *\n * The [typeDescription] is a [String] which contains a union of types separated\n * by vertical bar `|` symbols, e.g.  `\"num|String\"` describes the union of\n * numbers and Strings.  There is no type in Dart that is this precise.  The\n * Dart alternative would be `Object` or `dynamic`, but these types imply that\n * the JS-code might also be creating instances of all the DOM types.  If `null`\n * is possible, it must be specified explicitly, e.g. `\"String|Null\"`.\n * [typeDescription] has several extensions to help describe the behavior more\n * accurately.  In addition to the union type already described:\n *\n *  + `=Object` is a plain JavaScript object.  Some DOM methods return instances\n *     that have no corresponing Dart type (e.g. cross-frame documents),\n *     `=Object` can be used to describe these untyped' values.\n *\n *  + `var` (or empty string).  If the entire [typeDescription] is `var` (or\n *    empty string) then the type is `dynamic` but the code is known to not\n *    create any instances.\n *\n * Examples:\n *\n *     // Parent window might be an opaque cross-frame window.\n *     var thing = JS('=Object|Window', '#.parent', myWindow);\n *\n * Guidelines:\n *\n *  + Do not use any parameter, local, method or field names in the\n *    [codeTemplate].  These names are all subject to arbitrary renaming by the\n *    compiler.  Pass the values in via `#` substition, and test with the\n *    `--minify` dart2js command-line option.\n *\n *  + The substituted expressions are values, not locations.\n *\n *        JS('void', '# += \"x\"', this.field);\n *\n *    `this.field` might not be a substituted as a reference to the field.  The\n *    generated code might accidentally work as intended, but it also might be\n *\n *        var t1 = this.field;\n *        t1 += \"x\";\n *\n *    or\n *\n *        this.get$field() += \"x\";\n *\n *    The remedy in this case is to expand the `+=` operator, leaving all\n *    references to the Dart field as Dart code:\n *\n *        this.field = JS('String', '# + \"x\"', this.field);\n *\n *  + Never use `#` in function bodies.\n *\n *    This is a variation on the previous guideline.  Since `#` is replaced with\n *    an *expression* and the expression is only valid in the immediate context,\n *    `#` should never appear in a function body.  Doing so might defer the\n *    evaluation of the expression, and its side effects, until the function is\n *    called.\n *\n *    For example,\n *\n *        var value = foo();\n *        var f = JS('', 'function(){return #}', value)\n *\n *    might result in no immediate call to `foo` and a call to `foo` on every\n *    call to the JavaScript function bound to `f`.  This is better:\n *\n *        var f = JS('',\n *            '(function(val) { return function(){return val}; })(#)', value);\n *\n *    Since `#` occurs in the immediately evaluated expression, the expression\n *    is immediately evaluated and bound to `val` in the immediate call.\n *\n *\n * Additional notes.\n *\n * In the future we may extend [typeDescription] to include other aspects of the\n * behavior, for example, separating the returned types from the instantiated\n * types, or including effects to allow the compiler to perform more\n * optimizations around the code.  This might be an extension of [JS] or a new\n * function similar to [JS] with additional arguments for the new information.\n */\n// Add additional optional arguments if needed. The method is treated internally\n// as a variable argument method.\nJS(String typeDescription, String codeTemplate,\n    [arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11])\n{}\n\n/**\n * Returns the isolate in which this code is running.\n */\nIsolateContext JS_CURRENT_ISOLATE_CONTEXT() {}\n\nabstract class IsolateContext {\n  /// Holds a (native) JavaScript instance of Isolate, see\n  /// finishIsolateConstructorFunction in emitter.dart.\n  get isolateStatics;\n}\n\n/**\n * Invokes [function] in the context of [isolate].\n */\nJS_CALL_IN_ISOLATE(isolate, Function function) {}\n\n/**\n * Converts the Dart closure [function] into a JavaScript closure.\n *\n * Warning: This is no different from [RAW_DART_FUNCTION_REF] which means care\n * must be taken to store the current isolate.\n */\nDART_CLOSURE_TO_JS(Function function) {}\n\n/**\n * Returns a raw reference to the JavaScript function which implements\n * [function].\n *\n * Warning: this is dangerous, you should probably use\n * [DART_CLOSURE_TO_JS] instead. The returned object is not a valid\n * Dart closure, does not store the isolate context or arity.\n *\n * A valid example of where this can be used is as the second argument\n * to V8's Error.captureStackTrace. See\n * https://code.google.com/p/v8/wiki/JavaScriptStackTraceApi.\n */\nRAW_DART_FUNCTION_REF(Function function) {}\n\n/**\n * Sets the current isolate to [isolate].\n */\nvoid JS_SET_CURRENT_ISOLATE(isolate) {}\n\n/**\n * Creates an isolate and returns it.\n */\nJS_CREATE_ISOLATE() {}\n\n/**\n * Returns the JavaScript constructor function for Dart's Object class.\n * This can be used for type tests, as in\n *\n *     if (JS('bool', '# instanceof #', obj, JS_DART_OBJECT_CONSTRUCTOR()))\n *       ...\n */\nJS_DART_OBJECT_CONSTRUCTOR() {}\n\n/**\n * Returns the interceptor for class [type].  The interceptor is the type's\n * constructor's `prototype` property.  [type] will typically be the class, not\n * an interface, e.g. `JS_INTERCEPTOR_CONSTANT(JSInt)`, not\n * `JS_INTERCEPTOR_CONSTANT(int)`.\n */\nJS_INTERCEPTOR_CONSTANT(Type type) {}\n\n/**\n * Returns the prefix used for generated is checks on classes.\n */\nString JS_OPERATOR_IS_PREFIX() {}\n\n/**\n * Returns the prefix used for generated type argument substitutions on classes.\n */\nString JS_OPERATOR_AS_PREFIX() {}\n\n/// Returns the name of the class `Object` in the generated code.\nString JS_OBJECT_CLASS_NAME() {}\n\n/// Returns the name of the class `Null` in the generated code.\nString JS_NULL_CLASS_NAME() {}\n\n/// Returns the name of the class `Function` in the generated code.\nString JS_FUNCTION_CLASS_NAME() {}\n\n/**\n * Returns the field name used for determining if an object or its\n * interceptor has JavaScript indexing behavior.\n */\nString JS_IS_INDEXABLE_FIELD_NAME() {}\n\n/**\n * Returns the object corresponding to Namer.CURRENT_ISOLATE.\n */\nJS_CURRENT_ISOLATE() {}\n\n/// Returns the name used for generated function types on classes and methods.\nString JS_SIGNATURE_NAME() {}\n\n/// Returns the name used to tag function type representations in JavaScript.\nString JS_FUNCTION_TYPE_TAG() {}\n\n/**\n * Returns the name used to tag void return in function type representations\n * in JavaScript.\n */\nString JS_FUNCTION_TYPE_VOID_RETURN_TAG() {}\n\n/**\n * Returns the name used to tag return types in function type representations\n * in JavaScript.\n */\nString JS_FUNCTION_TYPE_RETURN_TYPE_TAG() {}\n\n/**\n * Returns the name used to tag required parameters in function type\n * representations in JavaScript.\n */\nString JS_FUNCTION_TYPE_REQUIRED_PARAMETERS_TAG() {}\n\n/**\n * Returns the name used to tag optional parameters in function type\n * representations in JavaScript.\n */\nString JS_FUNCTION_TYPE_OPTIONAL_PARAMETERS_TAG() {}\n\n/**\n * Returns the name used to tag named parameters in function type\n * representations in JavaScript.\n */\nString JS_FUNCTION_TYPE_NAMED_PARAMETERS_TAG() {}\n\n/**\n * Obtain [name] from Namer.\n */\nString JS_GET_NAME(String name) {}\n\n/// Returns the state of a flag that is determined by the state of the compiler\n/// when the program has been analyzed.\nbool JS_GET_FLAG(String name) {}\n\n/**\n * Pretend [code] is executed.  Generates no executable code.  This is used to\n * model effects at some other point in external code.  For example, the\n * following models an assignment to foo with an unknown value.\n *\n *     var foo;\n *\n *     main() {\n *       JS_EFFECT((_){ foo = _; })\n *     }\n *\n * TODO(sra): Replace this hack with something to mark the volatile or\n * externally initialized elements.\n */\nvoid JS_EFFECT(Function code) { code(null); }\n\n/**\n * Use this class for creating constants that hold JavaScript code.\n * For example:\n *\n * const constant = JS_CONST('typeof window != \"undefined\");\n *\n * This code will generate:\n * $.JS_CONST_1 = typeof window != \"undefined\";\n */\nclass JS_CONST {\n  final String code;\n  const JS_CONST(this.code);\n}\n\n/**\n * JavaScript string concatenation. Inputs must be Strings.  Corresponds to the\n * HStringConcat SSA instruction and may be constant-folded.\n */\nString JS_STRING_CONCAT(String a, String b) {\n  // This body is unused, only here for type analysis.\n  return JS('String', '# + #', a, b);\n}\n\u0000","sdk:/sdk/lib/_internal/lib/js_rti.dart":"// Copyright (c) 2013, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n/**\n * This part contains helpers for supporting runtime type information.\n *\n * The helper use a mixture of Dart and JavaScript objects. To indicate which is\n * used where we adopt the scheme of using explicit type annotation for Dart\n * objects and 'var' or omitted return type for JavaScript objects.\n *\n * Since bool, int, and String values are represented by the same JavaScript\n * primitives, type annotations are used for these types in all cases.\n *\n * Several methods use a common JavaScript encoding of runtime type information.\n * This encoding is referred to as the type representation which is one of\n * these:\n *  1) a JavaScript constructor for a class C: the represented type is the raw\n *     type C.\n *  2) a Dart object: this is the interceptor instance for a native type.\n *  3) a JavaScript object: this represents a class for which there is no\n *     JavaScript constructor, because it is only used in type arguments or it\n *     is native. The represented type is the raw type of this class.\n *  4) a JavaScript array: the first entry is of type 1, 2 or 3 and contains the\n *     subtyping flags and the substitution of the type and the rest of the\n *     array are the type arguments.\n *  5) `null`: the dynamic type.\n *\n *\n * To check subtype relations between generic classes we use a JavaScript\n * expression that describes the necessary substitution for type arguments.\n * Such a substitution expresssion can be:\n *  1) `null`, if no substituted check is necessary, because the\n *     type variables are the same or there are no type variables in the class\n *     that is checked for.\n *  2) A list expression describing the type arguments to be used in the\n *     subtype check, if the type arguments to be used in the check do not\n *     depend on the type arguments of the object.\n *  3) A function mapping the type variables of the object to be checked to\n *     a list expression.\n */\n\npart of _js_helper;\n\nType createRuntimeType(String name) => new TypeImpl(name);\n\nclass TypeImpl implements Type {\n  final String _typeName;\n  String _unmangledName;\n\n  TypeImpl(this._typeName);\n\n  String toString() {\n    if (_unmangledName != null) return _unmangledName;\n    String unmangledName = unmangleAllIdentifiersIfPreservedAnyways(_typeName);\n    return _unmangledName = unmangledName;\n  }\n\n  // TODO(ahe): This is a poor hashCode as it collides with its name.\n  int get hashCode => _typeName.hashCode;\n\n  bool operator ==(other) {\n    return  (other is TypeImpl) && _typeName == other._typeName;\n  }\n}\n\n/**\n * Represents a type variable.\n *\n * This class holds the information needed when reflecting on generic classes\n * and their members.\n */\nclass TypeVariable {\n  final Type owner;\n  final String name;\n  final int bound;\n\n  const TypeVariable(this.owner, this.name, this.bound);\n}\n\ngetMangledTypeName(TypeImpl type) => type._typeName;\n\n/**\n * Sets the runtime type information on [target]. [typeInfo] is a type\n * representation of type 4 or 5, that is, either a JavaScript array or\n * [:null:].\n */\nObject setRuntimeTypeInfo(Object target, var typeInfo) {\n  assert(isNull(typeInfo) || isJsArray(typeInfo));\n  // We have to check for null because factories may return null.\n  if (target != null) JS('var', r'#.$builtinTypeInfo = #', target, typeInfo);\n  return target;\n}\n\n/**\n * Returns the runtime type information of [target]. The returned value is a\n * list of type representations for the type arguments.\n */\ngetRuntimeTypeInfo(Object target) {\n  if (target == null) return null;\n  return JS('var', r'#.$builtinTypeInfo', target);\n}\n\n/**\n * Returns the type arguments of [target] as an instance of [substitutionName].\n */\ngetRuntimeTypeArguments(target, substitutionName) {\n  var substitution =\n      getField(target, '${JS_OPERATOR_AS_PREFIX()}$substitutionName');\n  return substitute(substitution, getRuntimeTypeInfo(target));\n}\n\n/**\n * Returns the [index]th type argument of [target] as an instance of\n * [substitutionName].\n */\n@NoThrows() @NoSideEffects() @NoInline()\ngetRuntimeTypeArgument(Object target, String substitutionName, int index) {\n  var arguments = getRuntimeTypeArguments(target, substitutionName);\n  return isNull(arguments) ? null : getIndex(arguments, index);\n}\n\n@NoThrows() @NoSideEffects() @NoInline()\ngetTypeArgumentByIndex(Object target, int index) {\n  var rti = getRuntimeTypeInfo(target);\n  return isNull(rti) ? null : getIndex(rti, index);\n}\n\nvoid copyTypeArguments(Object source, Object target) {\n  JS('var', r'#.$builtinTypeInfo = #.$builtinTypeInfo', target, source);\n}\n\n/**\n * Retrieves the class name from type information stored on the constructor\n * of [object].\n */\nString getClassName(var object) {\n  return JS('String', r'#.constructor.builtin$cls', getInterceptor(object));\n}\n\n/**\n * Creates the string representation for the type representation [runtimeType]\n * of type 4, the JavaScript array, where the first element represents the class\n * and the remaining elements represent the type arguments.\n */\nString getRuntimeTypeAsString(var runtimeType, {String onTypeVariable(int i)}) {\n  assert(isJsArray(runtimeType));\n  String className = getConstructorName(getIndex(runtimeType, 0));\n  return '$className'\n         '${joinArguments(runtimeType, 1, onTypeVariable: onTypeVariable)}';\n}\n\n/**\n * Retrieves the class name from type information stored on the constructor\n * [type].\n */\nString getConstructorName(var type) => JS('String', r'#.builtin$cls', type);\n\n/**\n * Returns a human-readable representation of the type representation [type].\n */\nString runtimeTypeToString(var type, {String onTypeVariable(int i)}) {\n  if (isNull(type)) {\n    return 'dynamic';\n  } else if (isJsArray(type)) {\n    // A list representing a type with arguments.\n    return getRuntimeTypeAsString(type, onTypeVariable: onTypeVariable);\n  } else if (isJsFunction(type)) {\n    // A reference to the constructor.\n    return getConstructorName(type);\n  } else if (type is int) {\n    if (onTypeVariable == null) {\n      return type.toString();\n    } else {\n      return onTypeVariable(type);\n    }\n  } else {\n    // TODO(ahe): Handle function types, and be sure to always return a string.\n    return null;\n  }\n}\n\n/**\n * Creates a comma-separated string of human-readable representations of the\n * type representations in the JavaScript array [types] starting at index\n * [startIndex].\n */\nString joinArguments(var types, int startIndex,\n                     {String onTypeVariable(int i)}) {\n  if (isNull(types)) return '';\n  assert(isJsArray(types));\n  bool firstArgument = true;\n  bool allDynamic = true;\n  StringBuffer buffer = new StringBuffer();\n  for (int index = startIndex; index < getLength(types); index++) {\n    if (firstArgument) {\n      firstArgument = false;\n    } else {\n      buffer.write(', ');\n    }\n    var argument = getIndex(types, index);\n    if (argument != null) {\n      allDynamic = false;\n    }\n    buffer.write(runtimeTypeToString(argument, onTypeVariable: onTypeVariable));\n  }\n  return allDynamic ? '' : '<$buffer>';\n}\n\n/**\n * Returns a human-readable representation of the type of [object].\n *\n * In minified mode does *not* use unminified identifiers (even when present).\n */\nString getRuntimeTypeString(var object) {\n  String className = getClassName(object);\n  if (object == null) return className;\n  var typeInfo = JS('var', r'#.$builtinTypeInfo', object);\n  return \"$className${joinArguments(typeInfo, 0)}\";\n}\n\nType getRuntimeType(var object) {\n  String type = getRuntimeTypeString(object);\n  return new TypeImpl(type);\n}\n\n/**\n * Applies the [substitution] on the [arguments].\n *\n * See the comment in the beginning of this file for a description of the\n * possible values for [substitution].\n */\nsubstitute(var substitution, var arguments) {\n  assert(isNull(substitution) ||\n         isJsArray(substitution) ||\n         isJsFunction(substitution));\n  assert(isNull(arguments) || isJsArray(arguments));\n  if (isJsArray(substitution)) {\n    arguments = substitution;\n  } else if (isJsFunction(substitution)) {\n    substitution = invoke(substitution, arguments);\n    if (isJsArray(substitution)) {\n      arguments = substitution;\n    } else if (isJsFunction(substitution)) {\n      // TODO(johnniwinther): Check if this is still needed.\n      arguments = invoke(substitution, arguments);\n    }\n  }\n  return arguments;\n}\n\n/**\n * Perform a type check with arguments on the Dart object [object].\n *\n * Parameters:\n * - [isField]: the name of the flag/function to check if the object\n *   is of the correct class.\n * - [checks]: the (JavaScript) list of type representations for the\n *   arguments to check against.\n * - [asField]: the name of the function that transforms the type\n *   arguments of [objects] to an instance of the class that we check\n *   against.\n */\nbool checkSubtype(Object object, String isField, List checks, String asField) {\n  if (object == null) return false;\n  var arguments = getRuntimeTypeInfo(object);\n  // Interceptor is needed for JSArray and native classes.\n  // TODO(sra): It could be a more specialized interceptor since [object] is not\n  // `null` or a primitive.\n  // TODO(9586): Move type info for static functions onto an interceptor.\n  var interceptor = getInterceptor(object);\n  var isSubclass = getField(interceptor, isField);\n  // When we read the field and it is not there, [isSubclass] will be [:null:].\n  if (isNull(isSubclass)) return false;\n  // Should the asField function be passed the receiver?\n  var substitution = getField(interceptor, asField);\n  return checkArguments(substitution, arguments, checks);\n}\n\n/// Returns the field's type name.\n///\n/// In minified mode, uses the unminified names if available.\nString computeTypeName(String isField, List arguments) {\n  // Shorten the field name to the class name and append the textual\n  // representation of the type arguments.\n  int prefixLength = JS_OPERATOR_IS_PREFIX().length;\n  return Primitives.formatType(isField.substring(prefixLength, isField.length),\n                               arguments);\n}\n\nObject subtypeCast(Object object, String isField, List checks, String asField) {\n  if (object != null && !checkSubtype(object, isField, checks, asField)) {\n    String actualType = Primitives.objectTypeName(object);\n    String typeName = computeTypeName(isField, checks);\n    // TODO(johnniwinther): Move type lookup to [CastErrorImplementation] to\n    // align with [TypeErrorImplementation].\n    throw new CastErrorImplementation(actualType, typeName);\n  }\n  return object;\n}\n\nObject assertSubtype(Object object, String isField, List checks,\n                     String asField) {\n  if (object != null && !checkSubtype(object, isField, checks, asField)) {\n    String typeName = computeTypeName(isField, checks);\n    throw new TypeErrorImplementation(object, typeName);\n  }\n  return object;\n}\n\n/// Checks that the type represented by [subtype] is a subtype of [supertype].\n/// If not a type error with [message] is thrown.\nassertIsSubtype(var subtype, var supertype, String message) {\n  if (!isSubtype(subtype, supertype)) {\n    throwTypeError(message);\n  }\n}\n\nthrowTypeError(message) {\n  throw new TypeErrorImplementation.fromMessage(message);\n}\n\n/**\n * Check that the types in the list [arguments] are subtypes of the types in\n * list [checks] (at the respective positions), possibly applying [substitution]\n * to the arguments before the check.\n *\n * See the comment in the beginning of this file for a description of the\n * possible values for [substitution].\n */\nbool checkArguments(var substitution, var arguments, var checks) {\n  return areSubtypes(substitute(substitution, arguments), checks);\n}\n\n/**\n * Checks whether the types of [s] are all subtypes of the types of [t].\n *\n * [s] and [t] are either [:null:] or JavaScript arrays of type representations,\n * A [:null:] argument is interpreted as the arguments of a raw type, that is a\n * list of [:dynamic:]. If [s] and [t] are JavaScript arrays they must be of the\n * same length.\n *\n * See the comment in the beginning of this file for a description of type\n * representations.\n */\nbool areSubtypes(var s, var t) {\n  // [:null:] means a raw type.\n  if (isNull(s) || isNull(t)) return true;\n\n  assert(isJsArray(s));\n  assert(isJsArray(t));\n  assert(getLength(s) == getLength(t));\n\n  int len = getLength(s);\n  for (int i = 0; i < len; i++) {\n    if (!isSubtype(getIndex(s, i), getIndex(t, i))) {\n      return false;\n    }\n  }\n  return true;\n}\n\n/**\n * Computes the signature by applying the type arguments of [context] as an\n * instance of [contextName] to the signature function [signature].\n */\ncomputeSignature(var signature, var context, var contextName) {\n  var typeArguments = getRuntimeTypeArguments(context, contextName);\n  return invokeOn(signature, context, typeArguments);\n}\n\n/**\n * Returns [:true:] if the runtime type representation [type] is a supertype of\n * [:Null:].\n */\nbool isSupertypeOfNull(var type) {\n  // `null` means `dynamic`.\n  return isNull(type) || getConstructorName(type) == JS_OBJECT_CLASS_NAME()\n                      || getConstructorName(type) == JS_NULL_CLASS_NAME();\n}\n\n/**\n * Tests whether the Dart object [o] is a subtype of the runtime type\n * representation [t].\n *\n * See the comment in the beginning of this file for a description of type\n * representations.\n */\nbool checkSubtypeOfRuntimeType(o, t) {\n  if (isNull(o)) return isSupertypeOfNull(t);\n  if (isNull(t)) return true;\n  // Get the runtime type information from the object here, because we may\n  // overwrite o with the interceptor below.\n  var rti = getRuntimeTypeInfo(o);\n  o = getInterceptor(o);\n  // We can use the object as its own type representation because we install\n  // the subtype flags and the substitution on the prototype, so they are\n  // properties of the object in JS.\n  var type;\n  if (isNotNull(rti)) {\n    // If the type has type variables (that is, [:rti != null:]), make a copy of\n    // the type arguments and insert [o] in the first position to create a\n    // compound type representation.\n    type = JS('JSExtendableArray', '#.slice()', rti);\n    JS('', '#.splice(0, 0, #)', type, o);\n  } else {\n    // Use the object as representation of the raw type.\n    type = o;\n  }\n  return isSubtype(type, t);\n}\n\nObject subtypeOfRuntimeTypeCast(Object object, var type) {\n  if (object != null && !checkSubtypeOfRuntimeType(object, type)) {\n    String actualType = Primitives.objectTypeName(object);\n    throw new CastErrorImplementation(actualType, runtimeTypeToString(type));\n  }\n  return object;\n}\n\nObject assertSubtypeOfRuntimeType(Object object, var type) {\n  if (object != null && !checkSubtypeOfRuntimeType(object, type)) {\n    throw new TypeErrorImplementation(object, runtimeTypeToString(type));\n  }\n  return object;\n}\n\n/**\n * Extracts the type arguments from a type representation. The result is a\n * JavaScript array or [:null:].\n */\ngetArguments(var type) {\n  return isJsArray(type) ? JS('var', r'#.slice(1)', type) : null;\n}\n\n/**\n * Checks whether the type represented by the type representation [s] is a\n * subtype of the type represented by the type representation [t].\n *\n * See the comment in the beginning of this file for a description of type\n * representations.\n */\nbool isSubtype(var s, var t) {\n  // Subtyping is reflexive.\n  if (isIdentical(s, t)) return true;\n  // If either type is dynamic, [s] is a subtype of [t].\n  if (isNull(s) || isNull(t)) return true;\n  if (hasField(t, '${JS_FUNCTION_TYPE_TAG()}')) {\n    if (hasNoField(s, '${JS_FUNCTION_TYPE_TAG()}')) {\n      var signatureName =\n          '${JS_OPERATOR_IS_PREFIX()}_${getField(t, JS_FUNCTION_TYPE_TAG())}';\n      if (hasField(s, signatureName)) return true;\n      var targetSignatureFunction = getField(s, '${JS_SIGNATURE_NAME()}');\n      if (isNull(targetSignatureFunction)) return false;\n      s = invokeOn(targetSignatureFunction, s, null);\n    }\n    return isFunctionSubtype(s, t);\n  }\n  // Check function types against the Function class.\n  if (getConstructorName(t) == JS_FUNCTION_CLASS_NAME() &&\n      hasField(s, '${JS_FUNCTION_TYPE_TAG()}')) {\n    return true;\n  }\n  // Get the object describing the class and check for the subtyping flag\n  // constructed from the type of [t].\n  var typeOfS = isJsArray(s) ? getIndex(s, 0) : s;\n  var typeOfT = isJsArray(t) ? getIndex(t, 0) : t;\n  // Check for a subtyping flag.\n  var name = runtimeTypeToString(typeOfT);\n  // Get the necessary substitution of the type arguments, if there is one.\n  var substitution;\n  if (isNotIdentical(typeOfT, typeOfS)) {\n    var test = '${JS_OPERATOR_IS_PREFIX()}${name}';\n    if (hasNoField(typeOfS, test)) return false;\n    var field = '${JS_OPERATOR_AS_PREFIX()}${runtimeTypeToString(typeOfT)}';\n    substitution = getField(typeOfS, field);\n  }\n  // The class of [s] is a subclass of the class of [t].  If [s] has no type\n  // arguments and no substitution, it is used as raw type.  If [t] has no\n  // type arguments, it used as a raw type.  In both cases, [s] is a subtype\n  // of [t].\n  if ((!isJsArray(s) && isNull(substitution)) || !isJsArray(t)) {\n    return true;\n  }\n  // Recursively check the type arguments.\n  return checkArguments(substitution, getArguments(s), getArguments(t));\n}\n\nbool isAssignable(var s, var t) {\n  return isSubtype(s, t) || isSubtype(t, s);\n}\n\n/**\n * If [allowShorter] is [:true:], [t] is allowed to be shorter than [s].\n */\nbool areAssignable(List s, List t, bool allowShorter) {\n  // Both lists are empty and thus equal.\n  if (isNull(t) && isNull(s)) return true;\n  // [t] is empty (and [s] is not) => only OK if [allowShorter].\n  if (isNull(t)) return allowShorter;\n  // [s] is empty (and [t] is not) => [s] is not longer or equal to [t].\n  if (isNull(s)) return false;\n\n  assert(isJsArray(s));\n  assert(isJsArray(t));\n\n  int sLength = getLength(s);\n  int tLength = getLength(t);\n  if (allowShorter) {\n    if (sLength < tLength) return false;\n  } else {\n    if (sLength != tLength) return false;\n  }\n\n  for (int i = 0; i < tLength; i++) {\n    if (!isAssignable(getIndex(s, i), getIndex(t, i))) {\n      return false;\n    }\n  }\n  return true;\n}\n\nbool areAssignableMaps(var s, var t) {\n  if (isNull(t)) return true;\n  if (isNull(s)) return false;\n\n  assert(isJsObject(s));\n  assert(isJsObject(t));\n\n  List names =\n      JSArray.markFixedList(JS('', 'Object.getOwnPropertyNames(#)', t));\n  for (int i = 0; i < names.length; i++) {\n    var name = names[i];\n    if (JS('bool', '!Object.hasOwnProperty.call(#, #)', s, name)) {\n      return false;\n    }\n    var tType = JS('', '#[#]', t, name);\n    var sType = JS('', '#[#]', s, name);\n    if (!isAssignable(tType, sType)) return false;\n  }\n  return true;\n}\n\nbool isFunctionSubtype(var s, var t) {\n  assert(hasField(t, '${JS_FUNCTION_TYPE_TAG()}'));\n  if (hasNoField(s, '${JS_FUNCTION_TYPE_TAG()}')) return false;\n  if (hasField(s, '${JS_FUNCTION_TYPE_VOID_RETURN_TAG()}')) {\n    if (hasNoField(t, '${JS_FUNCTION_TYPE_VOID_RETURN_TAG()}') &&\n        hasField(t, '${JS_FUNCTION_TYPE_RETURN_TYPE_TAG()}')) {\n      return false;\n    }\n  } else if (hasNoField(t, '${JS_FUNCTION_TYPE_VOID_RETURN_TAG()}')) {\n    var sReturnType = getField(s, '${JS_FUNCTION_TYPE_RETURN_TYPE_TAG()}');\n    var tReturnType = getField(t, '${JS_FUNCTION_TYPE_RETURN_TYPE_TAG()}');\n    if (!isAssignable(sReturnType, tReturnType)) return false;\n  }\n  var sParameterTypes =\n      getField(s, '${JS_FUNCTION_TYPE_REQUIRED_PARAMETERS_TAG()}');\n  var tParameterTypes =\n      getField(t, '${JS_FUNCTION_TYPE_REQUIRED_PARAMETERS_TAG()}');\n\n  var sOptionalParameterTypes =\n      getField(s, '${JS_FUNCTION_TYPE_OPTIONAL_PARAMETERS_TAG()}');\n  var tOptionalParameterTypes =\n      getField(t, '${JS_FUNCTION_TYPE_OPTIONAL_PARAMETERS_TAG()}');\n\n  int sParametersLen =\n      isNotNull(sParameterTypes) ? getLength(sParameterTypes) : 0;\n  int tParametersLen =\n      isNotNull(tParameterTypes) ? getLength(tParameterTypes) : 0;\n\n  int sOptionalParametersLen = isNotNull(sOptionalParameterTypes)\n      ? getLength(sOptionalParameterTypes) : 0;\n  int tOptionalParametersLen = isNotNull(tOptionalParameterTypes)\n      ? getLength(tOptionalParameterTypes) : 0;\n\n  if (sParametersLen > tParametersLen) {\n    // Too many required parameters in [s].\n    return false;\n  }\n  if (sParametersLen + sOptionalParametersLen <\n      tParametersLen + tOptionalParametersLen) {\n    // Too few required and optional parameters in [s].\n    return false;\n  }\n  if (sParametersLen == tParametersLen) {\n    // Simple case: Same number of required parameters.\n    if (!areAssignable(sParameterTypes, tParameterTypes, false)) return false;\n    if (!areAssignable(sOptionalParameterTypes,\n                       tOptionalParameterTypes, true)) {\n      return false;\n    }\n  } else {\n    // Complex case: Optional parameters of [s] for required parameters of [t].\n    int pos = 0;\n    // Check all required parameters of [s].\n    for (; pos < sParametersLen; pos++) {\n      if (!isAssignable(getIndex(sParameterTypes, pos),\n                        getIndex(tParameterTypes, pos))) {\n        return false;\n      }\n    }\n    int sPos = 0;\n    int tPos = pos;\n    // Check the remaining parameters of [t] with the first optional parameters\n    // of [s].\n    for (; tPos < tParametersLen ; sPos++, tPos++) {\n      if (!isAssignable(getIndex(sOptionalParameterTypes, sPos),\n                        getIndex(tParameterTypes, tPos))) {\n        return false;\n      }\n    }\n    tPos = 0;\n    // Check the optional parameters of [t] with the remaining optional\n    // parameters of [s]:\n    for (; tPos < tOptionalParametersLen ; sPos++, tPos++) {\n      if (!isAssignable(getIndex(sOptionalParameterTypes, sPos),\n                        getIndex(tOptionalParameterTypes, tPos))) {\n        return false;\n      }\n    }\n  }\n\n  var sNamedParameters =\n      getField(s, '${JS_FUNCTION_TYPE_NAMED_PARAMETERS_TAG()}');\n  var tNamedParameters =\n      getField(t, '${JS_FUNCTION_TYPE_NAMED_PARAMETERS_TAG()}');\n  return areAssignableMaps(sNamedParameters, tNamedParameters);\n}\n\n/**\n * Calls the JavaScript [function] with the [arguments] with the global scope\n * as the [:this:] context.\n */\ninvoke(var function, var arguments) => invokeOn(function, null, arguments);\n\n/**\n * Calls the JavaScript [function] with the [arguments] with [receiver] as the\n * [:this:] context.\n */\nObject invokeOn(function, receiver, arguments) {\n  assert(isJsFunction(function));\n  assert(isNull(arguments) || isJsArray(arguments));\n  return JS('var', r'#.apply(#, #)', function, receiver, arguments);\n}\n\n/// Calls the property [name] on the JavaScript [object].\ncall(var object, String name) => JS('var', r'#[#]()', object, name);\n\n/// Returns the property [name] of the JavaScript object [object].\ngetField(var object, String name) => JS('var', r'#[#]', object, name);\n\n/// Returns the property [index] of the JavaScript array [array].\ngetIndex(var array, int index) {\n  assert(isJsArray(array));\n  return JS('var', r'#[#]', array, index);\n}\n\n/// Returns the length of the JavaScript array [array].\nint getLength(var array) {\n  assert(isJsArray(array));\n  return JS('int', r'#.length', array);\n}\n\n/// Returns whether [value] is a JavaScript array.\nbool isJsArray(var value) {\n  return value is JSArray;\n}\n\nhasField(var object, var name) => JS('bool', r'# in #', name, object);\n\nhasNoField(var object, var name) => !hasField(object, name);\n\n/// Returns [:true:] if [o] is a JavaScript function.\nbool isJsFunction(var o) => JS('bool', r'typeof # == \"function\"', o);\n\n/// Returns [:true:] if [o] is a JavaScript object.\nbool isJsObject(var o) => JS('bool', r\"typeof # == 'object'\", o);\n\n/**\n * Returns [:true:] if [o] is equal to [:null:], that is either [:null:] or\n * [:undefined:]. We use this helper to avoid generating code under the invalid\n * assumption that [o] is a Dart value.\n */\nbool isNull(var o) => JS('bool', '# == null', o);\n\n/**\n * Returns [:true:] if [o] is not equal to [:null:], that is neither [:null:]\n * nor [:undefined:].  We use this helper to avoid generating code under the\n * invalid assumption that [o] is a Dart value.\n */\nbool isNotNull(var o) => JS('bool', '# != null', o);\n\n/**\n * Returns [:true:] if the JavaScript values [s] and [t] are identical. We use\n * this helper to avoid generating code under the invalid assumption that [s]\n * and [t] are Dart values.\n */\nbool isIdentical(var s, var t) => JS('bool', '# === #', s, t);\n\n/**\n * Returns [:true:] if the JavaScript values [s] and [t] are not identical. We\n * use this helper to avoid generating code under the invalid assumption that\n * [s] and [t] are Dart values.\n */\nbool isNotIdentical(var s, var t) => JS('bool', '# !== #', s, t);\n\u0000","sdk:/sdk/lib/_internal/lib/string_helper.dart":"// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\npart of _js_helper;\n\nclass StringMatch implements Match {\n  const StringMatch(int this.start,\n                    String this.input,\n                    String this.pattern);\n\n  int get end => start + pattern.length;\n  String operator[](int g) => group(g);\n  int get groupCount => 0;\n\n  String group(int group_) {\n    if (group_ != 0) {\n      throw new RangeError.value(group_);\n    }\n    return pattern;\n  }\n\n  List<String> groups(List<int> groups_) {\n    List<String> result = new List<String>();\n    for (int g in groups_) {\n      result.add(group(g));\n    }\n    return result;\n  }\n\n  final int start;\n  final String input;\n  final String pattern;\n}\n\nList<Match> allMatchesInStringUnchecked(String needle, String haystack,\n                                        int startIndex) {\n  // Copied from StringBase.allMatches in\n  // /runtime/lib/string_base.dart\n  List<Match> result = new List<Match>();\n  int length = haystack.length;\n  int patternLength = needle.length;\n  while (true) {\n    int position = haystack.indexOf(needle, startIndex);\n    if (position == -1) {\n      break;\n    }\n    result.add(new StringMatch(position, haystack, needle));\n    int endIndex = position + patternLength;\n    if (endIndex == length) {\n      break;\n    } else if (position == endIndex) {\n      ++startIndex;  // empty match, advance and restart\n    } else {\n      startIndex = endIndex;\n    }\n  }\n  return result;\n}\n\nstringContainsUnchecked(receiver, other, startIndex) {\n  if (other is String) {\n    return receiver.indexOf(other, startIndex) != -1;\n  } else if (other is JSSyntaxRegExp) {\n    return other.hasMatch(receiver.substring(startIndex));\n  } else {\n    var substr = receiver.substring(startIndex);\n    return other.allMatches(substr).isNotEmpty;\n  }\n}\n\nstringReplaceJS(receiver, replacer, to) {\n  // The JavaScript String.replace method recognizes replacement\n  // patterns in the replacement string. Dart does not have that\n  // behavior.\n  to = JS('String', r'#.replace(/\\$/g, \"$$$$\")', to);\n  return JS('String', r'#.replace(#, #)', receiver, replacer, to);\n}\n\nconst String ESCAPE_REGEXP = r'[[\\]{}()*+?.\\\\^$|]';\n\nstringReplaceAllUnchecked(receiver, from, to) {\n  checkString(to);\n  if (from is String) {\n    if (from == \"\") {\n      if (receiver == \"\") {\n        return to;\n      } else {\n        StringBuffer result = new StringBuffer();\n        int length = receiver.length;\n        result.write(to);\n        for (int i = 0; i < length; i++) {\n          result.write(receiver[i]);\n          result.write(to);\n        }\n        return result.toString();\n      }\n    } else {\n      var quoter = JS('', \"new RegExp(#, 'g')\", ESCAPE_REGEXP);\n      var quoted = JS('String', r'#.replace(#, \"\\\\$&\")', from, quoter);\n      var replacer = JS('', \"new RegExp(#, 'g')\", quoted);\n      return stringReplaceJS(receiver, replacer, to);\n    }\n  } else if (from is JSSyntaxRegExp) {\n    var re = regExpGetGlobalNative(from);\n    return stringReplaceJS(receiver, re, to);\n  } else {\n    checkNull(from);\n    // TODO(floitsch): implement generic String.replace (with patterns).\n    throw \"String.replaceAll(Pattern) UNIMPLEMENTED\";\n  }\n}\n\nString _matchString(Match match) => match[0];\nString _stringIdentity(String string) => string;\n\nstringReplaceAllFuncUnchecked(receiver, pattern, onMatch, onNonMatch) {\n  if (pattern is! Pattern) {\n    throw new ArgumentError(\"${pattern} is not a Pattern\");\n  }\n  if (onMatch == null) onMatch = _matchString;\n  if (onNonMatch == null) onNonMatch = _stringIdentity;\n  if (pattern is String) {\n    return stringReplaceAllStringFuncUnchecked(receiver, pattern,\n                                               onMatch, onNonMatch);\n  }\n  StringBuffer buffer = new StringBuffer();\n  int startIndex = 0;\n  for (Match match in pattern.allMatches(receiver)) {\n    buffer.write(onNonMatch(receiver.substring(startIndex, match.start)));\n    buffer.write(onMatch(match));\n    startIndex = match.end;\n  }\n  buffer.write(onNonMatch(receiver.substring(startIndex)));\n  return buffer.toString();\n}\n\nstringReplaceAllEmptyFuncUnchecked(receiver, onMatch, onNonMatch) {\n  // Pattern is the empty string.\n  StringBuffer buffer = new StringBuffer();\n  int length = receiver.length;\n  int i = 0;\n  buffer.write(onNonMatch(\"\"));\n  while (i < length) {\n    buffer.write(onMatch(new StringMatch(i, receiver, \"\")));\n    // Special case to avoid splitting a surrogate pair.\n    int code = receiver.codeUnitAt(i);\n    if ((code & ~0x3FF) == 0xD800 && length > i + 1) {\n      // Leading surrogate;\n      code = receiver.codeUnitAt(i + 1);\n      if ((code & ~0x3FF) == 0xDC00) {\n        // Matching trailing surrogate.\n        buffer.write(onNonMatch(receiver.substring(i, i + 2)));\n        i += 2;\n        continue;\n      }\n    }\n    buffer.write(onNonMatch(receiver[i]));\n    i++;\n  }\n  buffer.write(onMatch(new StringMatch(i, receiver, \"\")));\n  buffer.write(onNonMatch(\"\"));\n  return buffer.toString();\n}\n\nstringReplaceAllStringFuncUnchecked(receiver, pattern, onMatch, onNonMatch) {\n  int patternLength = pattern.length;\n  if (patternLength == 0) {\n    return stringReplaceAllEmptyFuncUnchecked(receiver, onMatch, onNonMatch);\n  }\n  int length = receiver.length;\n  StringBuffer buffer = new StringBuffer();\n  int startIndex = 0;\n  while (startIndex < length) {\n    int position = receiver.indexOf(pattern, startIndex);\n    if (position == -1) {\n      break;\n    }\n    buffer.write(onNonMatch(receiver.substring(startIndex, position)));\n    buffer.write(onMatch(new StringMatch(position, receiver, pattern)));\n    startIndex = position + patternLength;\n  }\n  buffer.write(onNonMatch(receiver.substring(startIndex)));\n  return buffer.toString();\n}\n\n\nstringReplaceFirstUnchecked(receiver, from, to) {\n  if (from is String) {\n    return stringReplaceJS(receiver, from, to);\n  } else if (from is JSSyntaxRegExp) {\n    var re = regExpGetNative(from);\n    return stringReplaceJS(receiver, re, to);\n  } else {\n    checkNull(from);\n    // TODO(floitsch): implement generic String.replace (with patterns).\n    throw \"String.replace(Pattern) UNIMPLEMENTED\";\n  }\n}\n\nstringJoinUnchecked(array, separator) {\n  return JS('String', r'#.join(#)', array, separator);\n}\n\u0000","sdk:/sdk/lib/_internal/lib/regexp_helper.dart":"// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\npart of _js_helper;\n\n// Helper method used by internal libraries.\nregExpGetNative(JSSyntaxRegExp regexp) => regexp._nativeRegExp;\n\n/**\n * Returns a native version of the RegExp with the global flag set.\n *\n * The RegExp's `lastIndex` property is zero when it is returned.\n *\n * The returned regexp is shared, and its `lastIndex` property may be\n * modified by other uses, so the returned regexp must be used immediately\n * when it's returned, with no user-provided code run in between.\n */\nregExpGetGlobalNative(JSSyntaxRegExp regexp) {\n  var nativeRegexp = regexp._nativeGlobalVersion;\n  JS(\"void\", \"#.lastIndex = 0\", nativeRegexp);\n  return nativeRegexp;\n}\n\nclass JSSyntaxRegExp implements RegExp {\n  final String pattern;\n  final _nativeRegExp;\n  var _nativeGlobalRegExp;\n  var _nativeAnchoredRegExp;\n\n\n  JSSyntaxRegExp(String source,\n                 { bool multiLine: false,\n                   bool caseSensitive: true })\n      : this.pattern = source,\n        this._nativeRegExp =\n            makeNative(source, multiLine, caseSensitive, false);\n\n  get _nativeGlobalVersion {\n    if (_nativeGlobalRegExp != null) return _nativeGlobalRegExp;\n    return _nativeGlobalRegExp = makeNative(pattern,\n                                            _isMultiLine,\n                                            _isCaseSensitive,\n                                            true);\n  }\n\n  get _nativeAnchoredVersion {\n    if (_nativeAnchoredRegExp != null) return _nativeAnchoredRegExp;\n    // An \"anchored version\" of a regexp is created by adding \"|()\" to the\n    // source. This means that the regexp always matches at the first position\n    // that it tries, and you can see if the original regexp matched, or it\n    // was the added zero-width match that matched, by looking at the last\n    // capture. If it is a String, the match participated, otherwise it didn't.\n    return _nativeAnchoredRegExp = makeNative(\"$pattern|()\",\n                                              _isMultiLine,\n                                              _isCaseSensitive,\n                                              true);\n  }\n\n  bool get _isMultiLine => JS(\"bool\", \"#.multiline\", _nativeRegExp);\n  bool get _isCaseSensitive => JS(\"bool\", \"!#.ignoreCase\", _nativeRegExp);\n\n  static makeNative(\n      String source, bool multiLine, bool caseSensitive, bool global) {\n    checkString(source);\n    String m = multiLine ? 'm' : '';\n    String i = caseSensitive ? '' : 'i';\n    String g = global ? 'g' : '';\n    // We're using the JavaScript's try catch instead of the Dart one\n    // to avoid dragging in Dart runtime support just because of using\n    // RegExp.\n    var regexp = JS('',\n        '(function() {'\n         'try {'\n          'return new RegExp(#, # + # + #);'\n         '} catch (e) {'\n           'return e;'\n         '}'\n        '})()', source, m, i, g);\n    if (JS('bool', '# instanceof RegExp', regexp)) return regexp;\n    // The returned value is the JavaScript exception. Turn it into a\n    // Dart exception.\n    String errorMessage = JS('String', r'String(#)', regexp);\n    throw new FormatException(\n        \"Illegal RegExp pattern: $source, $errorMessage\");\n  }\n\n  Match firstMatch(String string) {\n    List<String> m = JS('JSExtendableArray|Null',\n                        r'#.exec(#)',\n                        _nativeRegExp,\n                        checkString(string));\n    if (m == null) return null;\n    return new _MatchImplementation(this, m);\n  }\n\n  bool hasMatch(String string) {\n    return JS('bool', r'#.test(#)', _nativeRegExp, checkString(string));\n  }\n\n  String stringMatch(String string) {\n    var match = firstMatch(string);\n    if (match != null) return match.group(0);\n    return null;\n  }\n\n  Iterable<Match> allMatches(String string, [int start = 0]) {\n    checkString(string);\n    checkInt(start);\n    if (start < 0 || start > string.length) {\n      throw new RangeError.range(start, 0, string.length);\n    }\n    return new _AllMatchesIterable(this, string, start);\n  }\n\n  Match _execGlobal(String string, int start) {\n    Object regexp = _nativeGlobalVersion;\n    JS(\"void\", \"#.lastIndex = #\", regexp, start);\n    List match = JS(\"JSExtendableArray|Null\", \"#.exec(#)\", regexp, string);\n    if (match == null) return null;\n    return new _MatchImplementation(this, match);\n  }\n\n  Match _execAnchored(String string, int start) {\n    Object regexp = _nativeAnchoredVersion;\n    JS(\"void\", \"#.lastIndex = #\", regexp, start);\n    List match = JS(\"JSExtendableArray|Null\", \"#.exec(#)\", regexp, string);\n    if (match == null) return null;\n    // If the last capture group participated, the original regexp did not\n    // match at the start position.\n    if (match[match.length - 1] != null) return null;\n    match.length -= 1;\n    return new _MatchImplementation(this, match);\n  }\n\n  Match matchAsPrefix(String string, [int start = 0]) {\n    if (start < 0 || start > string.length) {\n      throw new RangeError.range(start, 0, string.length);\n    }\n    return _execAnchored(string, start);\n  }\n\n  bool get isMultiLine => _isMultiLine;\n  bool get isCaseSensitive => _isCaseSensitive;\n}\n\nclass _MatchImplementation implements Match {\n  final Pattern pattern;\n  // Contains a JS RegExp match object.\n  // It is an Array of String values with extra \"index\" and \"input\" properties.\n  final List<String> _match;\n\n  _MatchImplementation(this.pattern, this._match) {\n    assert(JS(\"var\", \"#.input\", _match) is String);\n    assert(JS(\"var\", \"#.index\", _match) is int);\n  }\n\n  String get input => JS(\"String\", \"#.input\", _match);\n  int get start => JS(\"int\", \"#.index\", _match);\n  int get end => start + _match[0].length;\n\n  String group(int index) => _match[index];\n  String operator [](int index) => group(index);\n  int get groupCount => _match.length - 1;\n\n  List<String> groups(List<int> groups) {\n    List<String> out = [];\n    for (int i in groups) {\n      out.add(group(i));\n    }\n    return out;\n  }\n}\n\nclass _AllMatchesIterable extends IterableBase<Match> {\n  final JSSyntaxRegExp _re;\n  final String _string;\n  final int _start;\n\n  _AllMatchesIterable(this._re, this._string, this._start);\n\n  Iterator<Match> get iterator => new _AllMatchesIterator(_re, _string, _start);\n}\n\nclass _AllMatchesIterator implements Iterator<Match> {\n  final JSSyntaxRegExp _regExp;\n  String _string;\n  int _nextIndex;\n  Match _current;\n\n  _AllMatchesIterator(this._regExp, this._string, this._nextIndex);\n\n  Match get current => _current;\n\n  bool moveNext() {\n    if (_string == null) return false;\n    if (_nextIndex <= _string.length) {\n      var match = _regExp._execGlobal(_string, _nextIndex);\n      if (match != null) {\n        _current = match;\n        int nextIndex = match.end;\n        if (match.start == nextIndex) {\n          nextIndex++;\n        }\n        _nextIndex = nextIndex;\n        return true;\n      }\n    }\n    _current = null;\n    _string = null;  // Marks iteration as ended.\n    return false;\n  }\n}\n\n/** Find the first match of [regExp] in [string] at or after [start]. */\nMatch firstMatchAfter(JSSyntaxRegExp regExp, String string, int start) {\n  return regExp._execGlobal(string, start);\n}\n\u0000","sdk:/sdk/lib/_internal/lib/native_helper.dart":"// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\npart of _js_helper;\n\n\n// TODO(ngeoffray): stop using this method once our optimizers can\n// change str1.contains(str2) into str1.indexOf(str2) != -1.\nbool contains(String userAgent, String name) {\n  return JS('int', '#.indexOf(#)', userAgent, name) != -1;\n}\n\nint arrayLength(List array) {\n  return JS('int', '#.length', array);\n}\n\narrayGet(List array, int index) {\n  return JS('var', '#[#]', array, index);\n}\n\nvoid arraySet(List array, int index, var value) {\n  JS('var', '#[#] = #', array, index, value);\n}\n\npropertyGet(var object, String property) {\n  return JS('var', '#[#]', object, property);\n}\n\nbool callHasOwnProperty(var function, var object, String property) {\n  return JS('bool', '#.call(#, #)', function, object, property);\n}\n\nvoid propertySet(var object, String property, var value) {\n  JS('var', '#[#] = #', object, property, value);\n}\n\ngetPropertyFromPrototype(var object, String name) {\n  return JS('var', 'Object.getPrototypeOf(#)[#]', object, name);\n}\n\nnewJsObject() {\n  return JS('var', '{}');\n}\n\n/**\n * Returns a String tag identifying the type of the native object, or `null`.\n * The tag is not the name of the type, but usually the name of the JavaScript\n * constructor function.  Initialized by [initHooks].\n */\nFunction getTagFunction;\n\n/**\n * If a lookup via [getTagFunction] on an object [object] that has [tag] fails,\n * this function is called to provide an alternate tag.  This allows us to fail\n * gracefully if we can make a good guess, for example, when browsers add novel\n * kinds of HTMLElement that we have never heard of.  Initialized by\n * [initHooks].\n */\nFunction alternateTagFunction;\n\n/**\n * Returns the prototype for the JavaScript constructor named by an input tag.\n * Returns `null` if there is no such constructor, or if pre-patching of the\n * constructor is to be avoided.  Initialized by [initHooks].\n */\nFunction prototypeForTagFunction;\n\n\nString toStringForNativeObject(var obj) {\n  // TODO(sra): Is this code dead?\n  // [getTagFunction] might be uninitialized, but in usual usage, toString has\n  // been called via an interceptor and initialized it.\n  String name = getTagFunction == null\n      ? '<Unknown>'\n      : JS('String', '#', getTagFunction(obj));\n  return 'Instance of $name';\n}\n\nint hashCodeForNativeObject(object) => Primitives.objectHashCode(object);\n\n/**\n * Sets a JavaScript property on an object.\n */\nvoid defineProperty(var obj, String property, var value) {\n  JS('void',\n      'Object.defineProperty(#, #, '\n          '{value: #, enumerable: false, writable: true, configurable: true})',\n      obj,\n      property,\n      value);\n}\n\n\n// Is [obj] an instance of a Dart-defined class?\nbool isDartObject(obj) {\n  // Some of the extra parens here are necessary.\n  return JS('bool', '((#) instanceof (#))', obj, JS_DART_OBJECT_CONSTRUCTOR());\n}\n\n/**\n * A JavaScript object mapping tags to the constructors of interceptors.\n * This is a JavaScript object with no prototype.\n *\n * Example: 'HTMLImageElement' maps to the ImageElement class constructor.\n */\nget interceptorsByTag => JS('=Object', 'init.interceptorsByTag');\n\n/**\n * A JavaScript object mapping tags to `true` or `false`.\n *\n * Example: 'HTMLImageElement' maps to `true` since, as there are no subclasses\n * of ImageElement, it is a leaf class in the native class hierarchy.\n */\nget leafTags => JS('=Object', 'init.leafTags');\n\nString findDispatchTagForInterceptorClass(interceptorClassConstructor) {\n  return JS('', r'#.$nativeSuperclassTag', interceptorClassConstructor);\n}\n\n/**\n * Cache of dispatch records for instances.  This is a JavaScript object used as\n * a map.  Keys are instance tags, e.g. \"!SomeThing\".  The cache permits the\n * sharing of one dispatch record between multiple instances.\n */\nvar dispatchRecordsForInstanceTags;\n\n/**\n * Cache of interceptors indexed by uncacheable tags, e.g. \"~SomeThing\".\n * This is a JavaScript object used as a map.\n */\nvar interceptorsForUncacheableTags;\n\n\nlookupInterceptor(String tag) {\n  return propertyGet(interceptorsByTag, tag);\n}\n\n\n// Dispatch tag marks are optional prefixes for a dispatch tag that direct how\n// the interceptor for the tag may be cached.\n\n/// No caching permitted.\nconst UNCACHED_MARK = '~';\n\n/// Dispatch record must be cached per instance\nconst INSTANCE_CACHED_MARK = '!';\n\n/// Dispatch record is cached on immediate prototype.\nconst LEAF_MARK = '-';\n\n/// Dispatch record is cached on immediate prototype with a prototype\n/// verification to prevent the interceptor being associated with a subclass\n/// before a dispatch record is cached on the subclass.\nconst INTERIOR_MARK = '+';\n\n/// A 'discriminator' function is to be used. TBD.\nconst DISCRIMINATED_MARK = '*';\n\n\n/**\n * Returns the interceptor for a native object, or returns `null` if not found.\n *\n * A dispatch record is cached according to the specification of the dispatch\n * tag for [obj].\n */\nlookupAndCacheInterceptor(obj) {\n  assert(!isDartObject(obj));\n  String tag = getTagFunction(obj);\n\n  // Fast path for instance (and uncached) tags because the lookup is repeated\n  // for each instance (or getInterceptor call).\n  var record = propertyGet(dispatchRecordsForInstanceTags, tag);\n  if (record != null) return patchInstance(obj, record);\n  var interceptor = propertyGet(interceptorsForUncacheableTags, tag);\n  if (interceptor != null) return interceptor;\n\n  // This lookup works for derived dispatch tags because we add them all in\n  // [initNativeDispatch].\n  var interceptorClass = lookupInterceptor(tag);\n  if (interceptorClass == null) {\n    tag = alternateTagFunction(obj, tag);\n    if (tag != null) {\n      // Fast path for instance and uncached tags again.\n      record = propertyGet(dispatchRecordsForInstanceTags, tag);\n      if (record != null) return patchInstance(obj, record);\n      interceptor = propertyGet(interceptorsForUncacheableTags, tag);\n      if (interceptor != null) return interceptor;\n\n      interceptorClass = lookupInterceptor(tag);\n    }\n  }\n\n  if (interceptorClass == null) {\n    // This object is not known to Dart.  There could be several reasons for\n    // that, including (but not limited to):\n    //\n    // * A bug in native code (hopefully this is caught during development).\n    // * An unknown DOM object encountered.\n    // * JavaScript code running in an unexpected context.  For example, on\n    //   node.js.\n    return null;\n  }\n\n  interceptor = JS('', '#.prototype', interceptorClass);\n\n  var mark = JS('String|Null', '#[0]', tag);\n\n  if (mark == INSTANCE_CACHED_MARK) {\n    record = makeLeafDispatchRecord(interceptor);\n    propertySet(dispatchRecordsForInstanceTags, tag, record);\n    return patchInstance(obj, record);\n  }\n\n  if (mark == UNCACHED_MARK) {\n    propertySet(interceptorsForUncacheableTags, tag, interceptor);\n    return interceptor;\n  }\n\n  if (mark == LEAF_MARK) {\n    return patchProto(obj, makeLeafDispatchRecord(interceptor));\n  }\n\n  if (mark == INTERIOR_MARK) {\n    return patchInteriorProto(obj, interceptor);\n  }\n\n  if (mark == DISCRIMINATED_MARK) {\n    // TODO(sra): Use discriminator of tag.\n    throw new UnimplementedError(tag);\n  }\n\n  // [tag] was not explicitly an interior or leaf tag, so\n  var isLeaf = JS('bool', '(#[#]) === true', leafTags, tag);\n  if (isLeaf) {\n    return patchProto(obj, makeLeafDispatchRecord(interceptor));\n  } else {\n    return patchInteriorProto(obj, interceptor);\n  }\n}\n\npatchInstance(obj, record) {\n  setDispatchProperty(obj, record);\n  return dispatchRecordInterceptor(record);\n}\n\npatchProto(obj, record) {\n  setDispatchProperty(JS('', 'Object.getPrototypeOf(#)', obj), record);\n  return dispatchRecordInterceptor(record);\n}\n\npatchInteriorProto(obj, interceptor) {\n  var proto = JS('', 'Object.getPrototypeOf(#)', obj);\n  var record = makeDispatchRecord(interceptor, proto, null, null);\n  setDispatchProperty(proto, record);\n  return interceptor;\n}\n\n\nmakeLeafDispatchRecord(interceptor) {\n  var fieldName = JS_IS_INDEXABLE_FIELD_NAME();\n  bool indexability = JS('bool', r'!!#[#]', interceptor, fieldName);\n  return makeDispatchRecord(interceptor, false, null, indexability);\n}\n\nmakeDefaultDispatchRecord(tag, interceptorClass, proto) {\n  var interceptor = JS('', '#.prototype', interceptorClass);\n  var isLeaf = JS('bool', '(#[#]) === true', leafTags, tag);\n  if (isLeaf) {\n    return makeLeafDispatchRecord(interceptor);\n  } else {\n    return makeDispatchRecord(interceptor, proto, null, null);\n  }\n}\n\n/**\n * [proto] should have no shadowing prototypes that are not also assigned a\n * dispatch rescord.\n */\nsetNativeSubclassDispatchRecord(proto, interceptor) {\n  setDispatchProperty(proto, makeLeafDispatchRecord(interceptor));\n}\n\nString constructorNameFallback(object) {\n  return JS('String', '#(#)', _constructorNameFallback, object);\n}\n\n\nvar initNativeDispatchFlag;  // null or true\n\nvoid initNativeDispatch() {\n  if (true == initNativeDispatchFlag) return;\n  initNativeDispatchFlag = true;\n  initNativeDispatchContinue();\n}\n\nvoid initNativeDispatchContinue() {\n\n  dispatchRecordsForInstanceTags = JS('', 'Object.create(null)');\n  interceptorsForUncacheableTags = JS('', 'Object.create(null)');\n\n  initHooks();\n\n  // Try to pro-actively patch prototypes of DOM objects.  For each of our known\n  // tags `TAG`, if `window.TAG` is a (constructor) function, set the dispatch\n  // property if the function's prototype to a dispatch record.\n  var map = interceptorsByTag;\n  var tags = JS('JSMutableArray', 'Object.getOwnPropertyNames(#)', map);\n\n  if (JS('bool', 'typeof window != \"undefined\"')) {\n    var context = JS('=Object', 'window');\n    var fun = JS('=Object', 'function () {}');\n    for (int i = 0; i < tags.length; i++) {\n      var tag = tags[i];\n      var proto = prototypeForTagFunction(tag);\n      if (proto != null) {\n        var interceptorClass = JS('', '#[#]', map, tag);\n        var record = makeDefaultDispatchRecord(tag, interceptorClass, proto);\n        if (record != null) {\n          setDispatchProperty(proto, record);\n          // Ensure the modified prototype is still fast by assigning it to\n          // the prototype property of a function object.\n          JS('', '#.prototype = #', fun, proto);\n        }\n      }\n    }\n  }\n\n  // [interceptorsByTag] maps 'plain' dispatch tags.  Add all the derived\n  // dispatch tags to simplify lookup of derived tags.\n  for (int i = 0; i < tags.length; i++) {\n    var tag = JS('String', '#[#]', tags, i);\n    if (JS('bool', '/^[A-Za-z_]/.test(#)', tag)) {\n      var interceptorClass = propertyGet(map, tag);\n      propertySet(map, INSTANCE_CACHED_MARK + tag, interceptorClass);\n      propertySet(map, UNCACHED_MARK + tag, interceptorClass);\n      propertySet(map, LEAF_MARK + tag, interceptorClass);\n      propertySet(map, INTERIOR_MARK + tag, interceptorClass);\n      propertySet(map, DISCRIMINATED_MARK + tag, interceptorClass);\n    }\n  }\n}\n\n\n/**\n * Initializes [getTagFunction] and [alternateTagFunction].\n *\n * These functions are 'hook functions', collectively 'hooks'.  They initialized\n * by applying a series of hooks transformers.  Built-in hooks transformers deal\n * with various known browser behaviours.\n *\n * Each hook tranformer takes a 'hooks' input which is a JavaScript object\n * containing the hook functions, and returns the same or a new object with\n * replacements.  The replacements can wrap the originals to provide alternate\n * or modified behaviour.\n *\n *     { getTag: function(obj) {...},\n *       getUnknownTag: function(obj, tag) {...},\n *       prototypeForTag: function(tag) {...},\n *       discriminator: function(tag) {...},\n *      }\n *\n * * getTag(obj) returns the dispatch tag, or `null`.\n * * getUnknownTag(obj, tag) returns a tag when [getTag] fails.\n * * prototypeForTag(tag) returns the prototype of the constructor for tag,\n *   or `null` if not available or prepatching is undesirable.\n * * discriminator(tag) returns a function TBD.\n *\n * The web site can adapt a dart2js application by loading code ahead of the\n * dart2js application that defines hook transformers to be after the built in\n * ones.  Code defining a transformer HT should use the following pattern to\n * ensure multiple transformers can be composed:\n *\n *     (dartNativeDispatchHooksTransformer =\n *      window.dartNativeDispatchHooksTransformer || []).push(HT);\n *\n *\n * TODO: Implement and describe dispatch tags and their caching methods.\n */\nvoid initHooks() {\n  // The initial simple hooks:\n  var hooks = JS('', '#()', _baseHooks);\n\n  // Customize for browsers where `object.constructor.name` fails:\n  var _fallbackConstructorHooksTransformer =\n      JS('', '#(#)', _fallbackConstructorHooksTransformerGenerator,\n          _constructorNameFallback);\n  hooks = applyHooksTransformer(_fallbackConstructorHooksTransformer, hooks);\n\n  // Customize for browsers:\n  hooks = applyHooksTransformer(_firefoxHooksTransformer, hooks);\n  hooks = applyHooksTransformer(_ieHooksTransformer, hooks);\n  hooks = applyHooksTransformer(_operaHooksTransformer, hooks);\n  hooks = applyHooksTransformer(_safariHooksTransformer, hooks);\n\n  hooks = applyHooksTransformer(_fixDocumentHooksTransformer, hooks);\n\n  // TODO(sra): Update ShadowDOM polyfil to use\n  // [dartNativeDispatchHooksTransformer] and remove this hook.\n  hooks = applyHooksTransformer(_dartExperimentalFixupGetTagHooksTransformer,\n      hooks);\n\n  // Apply global hooks.\n  //\n  // If defined, dartNativeDispatchHookdTransformer should be a single function\n  // of a JavaScript Array of functions.\n\n  if (JS('bool', 'typeof dartNativeDispatchHooksTransformer != \"undefined\"')) {\n    var transformers = JS('', 'dartNativeDispatchHooksTransformer');\n    if (JS('bool', 'typeof # == \"function\"', transformers)) {\n      transformers = [transformers];\n    }\n    if (JS('bool', '#.constructor == Array', transformers)) {\n      for (int i = 0; i < JS('int', '#.length', transformers); i++) {\n        var transformer = JS('', '#[#]', transformers, i);\n        if (JS('bool', 'typeof # == \"function\"', transformer)) {\n          hooks = applyHooksTransformer(transformer, hooks);\n        }\n      }\n    }\n  }\n\n  var getTag = JS('', '#.getTag', hooks);\n  var getUnknownTag = JS('', '#.getUnknownTag', hooks);\n  var prototypeForTag = JS('', '#.prototypeForTag', hooks);\n\n  getTagFunction = (o) => JS('String|Null', '#(#)', getTag, o);\n  alternateTagFunction =\n      (o, String tag) => JS('String|Null', '#(#, #)', getUnknownTag, o, tag);\n  prototypeForTagFunction =\n      (String tag) => JS('', '#(#)', prototypeForTag, tag);\n}\n\napplyHooksTransformer(transformer, hooks) {\n  var newHooks = JS('=Object|Null', '#(#)', transformer, hooks);\n  return JS('', '# || #', newHooks, hooks);\n}\n\n// JavaScript code fragments.\n//\n// This is a temporary place for the JavaScript code.\n//\n// TODO(sra): These code fragments are not minified.  They could be generated by\n// the code emitter, or JS_CONST could be improved to parse entire functions and\n// take care of the minification.\n\nconst _baseHooks = const JS_CONST(r'''\nfunction() {\n  function typeNameInChrome(o) {\n    var name = o.constructor.name;\n    if (name) return name;\n    var s = Object.prototype.toString.call(o);\n    return s.substring(8, s.length - 1);\n  }\n  function getUnknownTag(object, tag) {\n    // This code really belongs in [getUnknownTagGenericBrowser] but having it\n    // here allows [getUnknownTag] to be tested on d8.\n    if (/^HTML[A-Z].*Element$/.test(tag)) {\n      // Check that it is not a simple JavaScript object.\n      var name = Object.prototype.toString.call(object);\n      if (name == \"[object Object]\") return null;\n      return \"HTMLElement\";\n    }\n  }\n  function getUnknownTagGenericBrowser(object, tag) {\n    if (self.HTMLElement && object instanceof HTMLElement) return \"HTMLElement\";\n    return getUnknownTag(object, tag);\n  }\n  function prototypeForTag(tag) {\n    if (typeof window == \"undefined\") return null;\n    if (typeof window[tag] == \"undefined\") return null;\n    var constructor = window[tag];\n    if (typeof constructor != \"function\") return null;\n    return constructor.prototype;\n  }\n  function discriminator(tag) { return null; }\n\n  var isBrowser = typeof navigator == \"object\";\n\n  return {\n    getTag: typeNameInChrome,\n    getUnknownTag: isBrowser ? getUnknownTagGenericBrowser : getUnknownTag,\n    prototypeForTag: prototypeForTag,\n    discriminator: discriminator };\n}''');\n\n\n/**\n * Returns the name of the constructor function for browsers where\n * `object.constructor.name` is not reliable.\n *\n * This function is split out of [_fallbackConstructorHooksTransformerGenerator]\n * as it is called from both the dispatch hooks and via\n * [constructorNameFallback] from objectToString.\n */\nconst _constructorNameFallback = const JS_CONST(r'''\nfunction getTagFallback(o) {\n  var constructor = o.constructor;\n  if (typeof constructor == \"function\") {\n    var name = constructor.name;\n    // If the name is a non-empty string, we use that as the type name of this\n    // object.  There are various cases where that does not work, so we have to\n    // detect them and fall through to the toString() based implementation.\n\n    if (typeof name == \"string\" &&\n\n        // Sometimes the string is empty.  This test also catches minified\n        // shadow dom polyfil wrapper for Window on Firefox where the faked\n        // constructor name does not 'stick'.  The shortest real DOM object\n        // names have three characters (e.g. URL, CSS).\n        name.length > 2 &&\n\n        // On Firefox we often get \"Object\" as the constructor name, even for\n        // more specialized DOM objects.\n        name !== \"Object\" &&\n\n        // This can happen in Opera.\n        name !== \"Function.prototype\") {\n      return name;\n    }\n  }\n  var s = Object.prototype.toString.call(o);\n  return s.substring(8, s.length - 1);\n}''');\n\n\nconst _fallbackConstructorHooksTransformerGenerator = const JS_CONST(r'''\nfunction(getTagFallback) {\n  return function(hooks) {\n    // If we are not in a browser, assume we are in d8.\n    // TODO(sra): Recognize jsshell.\n    if (typeof navigator != \"object\") return hooks;\n\n    var ua = navigator.userAgent;\n    // TODO(antonm): remove a reference to DumpRenderTree.\n    if (ua.indexOf(\"DumpRenderTree\") >= 0) return hooks;\n    if (ua.indexOf(\"Chrome\") >= 0) {\n      // Confirm constructor name is usable for dispatch.\n      function confirm(p) {\n        return typeof window == \"object\" && window[p] && window[p].name == p;\n      }\n      if (confirm(\"Window\") && confirm(\"HTMLElement\")) return hooks;\n    }\n\n    hooks.getTag = getTagFallback;\n  };\n}''');\n\n\nconst _ieHooksTransformer = const JS_CONST(r'''\nfunction(hooks) {\n  var userAgent = typeof navigator == \"object\" ? navigator.userAgent : \"\";\n  if (userAgent.indexOf(\"Trident/\") == -1) return hooks;\n\n  var getTag = hooks.getTag;\n\n  var quickMap = {\n    \"BeforeUnloadEvent\": \"Event\",\n    \"DataTransfer\": \"Clipboard\",\n    \"HTMLDDElement\": \"HTMLElement\",\n    \"HTMLDTElement\": \"HTMLElement\",\n    \"HTMLPhraseElement\": \"HTMLElement\",\n    \"Position\": \"Geoposition\"\n  };\n\n  function getTagIE(o) {\n    var tag = getTag(o);\n    var newTag = quickMap[tag];\n    if (newTag) return newTag;\n    // Patches for types which report themselves as Objects.\n    if (tag == \"Object\") {\n      if (window.DataView && (o instanceof window.DataView)) return \"DataView\";\n    }\n    return tag;\n  }\n\n  function prototypeForTagIE(tag) {\n    var constructor = window[tag];\n    if (constructor == null) return null;\n    return constructor.prototype;\n  }\n\n  hooks.getTag = getTagIE;\n  hooks.prototypeForTag = prototypeForTagIE;\n}''');\n\nconst _fixDocumentHooksTransformer = const JS_CONST(r'''\nfunction(hooks) {\n  var getTag = hooks.getTag;\n  var prototypeForTag = hooks.prototypeForTag;\n  function getTagFixed(o) {\n    var tag = getTag(o);\n    if (tag == \"Document\") {\n      // Some browsers and the polymer polyfill call both HTML and XML documents\n      // \"Document\", so we check for the xmlVersion property, which is the empty\n      // string on HTML documents. Since both dart:html classes Document and\n      // HtmlDocument share the same type, we must patch the instances and not\n      // the prototype.\n      if (!!o.xmlVersion) return \"!Document\";\n      return \"!HTMLDocument\";\n    }\n    return tag;\n  }\n\n  function prototypeForTagFixed(tag) {\n    if (tag == \"Document\") return null;  // Do not pre-patch Document.\n    return prototypeForTag(tag);\n  }\n\n  hooks.getTag = getTagFixed;\n  hooks.prototypeForTag = prototypeForTagFixed;\n}''');\n\nconst _firefoxHooksTransformer = const JS_CONST(r'''\nfunction(hooks) {\n  var userAgent = typeof navigator == \"object\" ? navigator.userAgent : \"\";\n  if (userAgent.indexOf(\"Firefox\") == -1) return hooks;\n\n  var getTag = hooks.getTag;\n\n  var quickMap = {\n    \"BeforeUnloadEvent\": \"Event\",\n    \"DataTransfer\": \"Clipboard\",\n    \"GeoGeolocation\": \"Geolocation\",\n    \"Location\": \"!Location\",               // Fixes issue 18151\n    \"WorkerMessageEvent\": \"MessageEvent\",\n    \"XMLDocument\": \"!Document\"};\n\n  function getTagFirefox(o) {\n    var tag = getTag(o);\n    return quickMap[tag] || tag;\n  }\n\n  hooks.getTag = getTagFirefox;\n}''');\n\n\nconst _operaHooksTransformer = const JS_CONST(r'''\nfunction(hooks) { return hooks; }\n''');\n\n\nconst _safariHooksTransformer = const JS_CONST(r'''\nfunction(hooks) { return hooks; }\n''');\n\n\nconst _dartExperimentalFixupGetTagHooksTransformer = const JS_CONST(r'''\nfunction(hooks) {\n  if (typeof dartExperimentalFixupGetTag != \"function\") return hooks;\n  hooks.getTag = dartExperimentalFixupGetTag(hooks.getTag);\n}''');\n\u0000","sdk:/sdk/lib/_internal/lib/constant_map.dart":"// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\npart of _js_helper;\n\nabstract class ConstantMap<K, V> implements Map<K, V> {\n  const ConstantMap._();\n\n  bool get isEmpty => length == 0;\n\n  bool get isNotEmpty => !isEmpty;\n\n  String toString() => Maps.mapToString(this);\n\n  _throwUnmodifiable() {\n    throw new UnsupportedError(\"Cannot modify unmodifiable Map\");\n  }\n  void operator []=(K key, V val) => _throwUnmodifiable();\n  V putIfAbsent(K key, V ifAbsent()) => _throwUnmodifiable();\n  V remove(K key) => _throwUnmodifiable();\n  void clear() => _throwUnmodifiable();\n  void addAll(Map<K, V> other) => _throwUnmodifiable();\n}\n\nclass ConstantStringMap<K, V> extends ConstantMap<K, V>\n                              implements _symbol_dev.EfficientLength {\n\n  // This constructor is not used.  The instantiation is shortcut by the\n  // compiler. It is here to make the uninitialized final fields legal.\n  const ConstantStringMap._(this.length, this._jsObject, this._keys)\n      : super._();\n\n  final int length;\n  // A constant map is backed by a JavaScript object.\n  final _jsObject;\n  final List<K> _keys;\n\n  bool containsValue(V needle) {\n    return values.any((V value) => value == needle);\n  }\n\n  bool containsKey(Object key) {\n    if (key is! String) return false;\n    if ('__proto__' == key) return false;\n    return jsHasOwnProperty(_jsObject, key);\n  }\n\n  V operator [](Object key) {\n    if (!containsKey(key)) return null;\n    return _fetch(key);\n  }\n\n  // [_fetch] is the indexer for keys for which `containsKey(key)` is true.\n  _fetch(key) => jsPropertyAccess(_jsObject, key);\n\n  void forEach(void f(K key, V value)) {\n    // Use a JS 'cast' to get efficient loop.  Type inferrence doesn't get this\n    // since constant map representation is chosen after type inferrence and the\n    // instantiation is shortcut by the compiler.\n    var keys = JS('JSArray', '#', _keys);\n    for (int i = 0; i < keys.length; i++) {\n      var key = keys[i];\n      f(key, _fetch(key));\n    }\n  }\n\n  Iterable<K> get keys {\n    return new _ConstantMapKeyIterable<K>(this);\n  }\n\n  Iterable<V> get values {\n    return new MappedIterable<K, V>(_keys, (key) => _fetch(key));\n  }\n}\n\nclass ConstantProtoMap<K, V> extends ConstantStringMap<K, V> {\n  // This constructor is not used.  The instantiation is shortcut by the\n  // compiler. It is here to make the uninitialized final fields legal.\n  ConstantProtoMap._(length, jsObject, keys, this._protoValue)\n      : super._(length, jsObject, keys);\n\n  final V _protoValue;\n\n  bool containsKey(Object key) {\n    if (key is! String) return false;\n    if ('__proto__' == key) return true;\n    return jsHasOwnProperty(_jsObject, key);\n  }\n\n  _fetch(key) =>\n      '__proto__' == key ? _protoValue : jsPropertyAccess(_jsObject, key);\n}\n\nclass _ConstantMapKeyIterable<K> extends IterableBase<K> {\n  ConstantStringMap<K, dynamic> _map;\n  _ConstantMapKeyIterable(this._map);\n\n  Iterator<K> get iterator => _map._keys.iterator;\n}\n\nclass GeneralConstantMap<K, V> extends ConstantMap<K, V> {\n  // This constructor is not used.  The instantiation is shortcut by the\n  // compiler. It is here to make the uninitialized final fields legal.\n  GeneralConstantMap(this._jsData) : super._();\n\n  // [_jsData] holds a key-value pair list.\n  final _jsData;\n\n  // We cannot create the backing map on creation since hashCode interceptors\n  // have not been defined when constants are created.\n  Map<K, V> _getMap() {\n    if (JS('bool', r'!this.$map')) {\n      Map backingMap = new LinkedHashMap<K, V>();\n      JS('', r'this.$map = #', fillLiteralMap(_jsData, backingMap));\n    }\n    return JS('Map', r'this.$map');\n  }\n\n  bool containsValue(V needle) {\n    return _getMap().containsValue(needle);\n  }\n\n  bool containsKey(Object key) {\n    return _getMap().containsKey(key);\n  }\n\n  V operator [](Object key) {\n    return _getMap()[key];\n  }\n\n  void forEach(void f(K key, V value)) {\n    _getMap().forEach(f);\n  }\n\n  Iterable<K> get keys {\n    return _getMap().keys;\n  }\n\n  Iterable<V> get values {\n    return _getMap().values;\n  }\n\n  int get length => _getMap().length;\n}\n\u0000","sdk:/sdk/lib/_internal/lib/annotations.dart":"// Copyright (c) 2013, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\npart of _js_helper;\n\n/// Tells the optimizing compiler that the annotated method has no\n/// side-effects.\n/// Requires @NoInline() to function correctly.\nclass NoSideEffects {\n  const NoSideEffects();\n}\n\n/// Tells the optimizing compiler that the annotated method cannot throw.\n/// Requires @NoInline() to function correctly.\nclass NoThrows {\n  const NoThrows();\n}\n\n/// Tells the optimizing compiler to not inline the annotated method.\nclass NoInline {\n  const NoInline();\n}\n\n// Ensures that the annotated method is represented internally using\n// IR nodes ([:value == true:]) or AST nodes ([:value == false:]).\nclass IrRepresentation {\n  final bool value;\n  const IrRepresentation(this.value);\n}\n\n/// Marks a class as native and defines its JavaScript name(s).\nclass Native {\n  final String name;\n  const Native(this.name);\n}\n\u0000","sdk:/sdk/lib/_internal/lib/js_helper.dart":"// Copyright (c) 2013, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\nlibrary _js_helper;\n\nimport 'dart:collection';\nimport 'dart:_isolate_helper' show\n    IsolateNatives,\n    leaveJsAsync,\n    enterJsAsync,\n    isWorker;\n\nimport 'dart:async' show Future, DeferredLoadException, Completer;\n\nimport 'dart:_foreign_helper' show\n    DART_CLOSURE_TO_JS,\n    JS,\n    JS_CALL_IN_ISOLATE,\n    JS_CONST,\n    JS_CURRENT_ISOLATE,\n    JS_CURRENT_ISOLATE_CONTEXT,\n    JS_DART_OBJECT_CONSTRUCTOR,\n    JS_EFFECT,\n    JS_FUNCTION_CLASS_NAME,\n    JS_FUNCTION_TYPE_NAMED_PARAMETERS_TAG,\n    JS_FUNCTION_TYPE_OPTIONAL_PARAMETERS_TAG,\n    JS_FUNCTION_TYPE_REQUIRED_PARAMETERS_TAG,\n    JS_FUNCTION_TYPE_RETURN_TYPE_TAG,\n    JS_FUNCTION_TYPE_TAG,\n    JS_FUNCTION_TYPE_VOID_RETURN_TAG,\n    JS_GET_NAME,\n    JS_GET_FLAG,\n    JS_HAS_EQUALS,\n    JS_IS_INDEXABLE_FIELD_NAME,\n    JS_NULL_CLASS_NAME,\n    JS_OBJECT_CLASS_NAME,\n    JS_OPERATOR_AS_PREFIX,\n    JS_OPERATOR_IS_PREFIX,\n    JS_SIGNATURE_NAME,\n    JS_STRING_CONCAT,\n    RAW_DART_FUNCTION_REF;\n\nimport 'dart:_interceptors';\nimport 'dart:_internal' as _symbol_dev;\nimport 'dart:_internal' show MappedIterable;\n\nimport 'dart:_js_names' show\n    extractKeys,\n    mangledNames,\n    unmangleGlobalNameIfPreservedAnyways,\n    unmangleAllIdentifiersIfPreservedAnyways;\n\npart 'annotations.dart';\npart 'constant_map.dart';\npart 'native_helper.dart';\npart 'regexp_helper.dart';\npart 'string_helper.dart';\npart 'js_rti.dart';\n\nclass _Patch {\n  const _Patch();\n}\n\nconst _Patch patch = const _Patch();\n\n/// No-op method that is called to inform the compiler that preambles might\n/// be needed when executing the resulting JS file in a command-line\n/// JS engine.\nrequiresPreamble() {}\n\nbool isJsIndexable(var object, var record) {\n  if (record != null) {\n    var result = dispatchRecordIndexability(record);\n    if (result != null) return result;\n  }\n  return object is JavaScriptIndexingBehavior;\n}\n\nString S(value) {\n  if (value is String) return value;\n  if (value is num) {\n    if (value != 0) {\n      // \"\"+x is faster than String(x) for integers on most browsers.\n      return JS('String', r'\"\" + (#)', value);\n    }\n  } else if (true == value) {\n    return 'true';\n  } else if (false == value) {\n    return 'false';\n  } else if (value == null) {\n    return 'null';\n  }\n  var res = value.toString();\n  if (res is !String) throw new ArgumentError(value);\n  return res;\n}\n\ncreateInvocationMirror(String name, internalName, kind, arguments,\n                       argumentNames) {\n  return new JSInvocationMirror(name,\n                                internalName,\n                                kind,\n                                arguments,\n                                argumentNames);\n}\n\ncreateUnmangledInvocationMirror(Symbol symbol, internalName, kind, arguments,\n                                argumentNames) {\n  return new JSInvocationMirror(symbol,\n                                internalName,\n                                kind,\n                                arguments,\n                                argumentNames);\n}\n\nvoid throwInvalidReflectionError(String memberName) {\n  throw new UnsupportedError(\"Can't use '$memberName' in reflection \"\n      \"because it is not included in a @MirrorsUsed annotation.\");\n}\n\n/// Helper to print the given method information to the console the first\n/// time it is called with it.\n@NoInline()\nvoid traceHelper(String method) {\n  if (JS('bool', '!this.cache')) {\n    JS('', 'this.cache = Object.create(null)');\n  }\n  if (JS('bool', '!this.cache[#]', method)) {\n    JS('', 'console.log(#)', method);\n    JS('', 'this.cache[#] = true', method);\n  }\n}\n\nclass JSInvocationMirror implements Invocation {\n  static const METHOD = 0;\n  static const GETTER = 1;\n  static const SETTER = 2;\n\n  /// When [_memberName] is a String, it holds the mangled name of this\n  /// invocation.  When it is a Symbol, it holds the unmangled name.\n  var /* String or Symbol */ _memberName;\n  final String _internalName;\n  final int _kind;\n  final List _arguments;\n  final List _namedArgumentNames;\n  /** Map from argument name to index in _arguments. */\n  Map<String, dynamic> _namedIndices = null;\n\n  JSInvocationMirror(this._memberName,\n                     this._internalName,\n                     this._kind,\n                     this._arguments,\n                     this._namedArgumentNames);\n\n  Symbol get memberName {\n    if (_memberName is Symbol) return _memberName;\n    String name = _memberName;\n    String unmangledName = mangledNames[name];\n    if (unmangledName != null) {\n      name = unmangledName.split(':')[0];\n    } else {\n      if (mangledNames[_internalName] == null) {\n        print(\"Warning: '$name' is used reflectively but not in MirrorsUsed. \"\n              \"This will break minified code.\");\n      }\n    }\n    _memberName = new _symbol_dev.Symbol.unvalidated(name);\n    return _memberName;\n  }\n\n  bool get isMethod => _kind == METHOD;\n  bool get isGetter => _kind == GETTER;\n  bool get isSetter => _kind == SETTER;\n  bool get isAccessor => _kind != METHOD;\n\n  List get positionalArguments {\n    if (isGetter) return const [];\n    var argumentCount = _arguments.length - _namedArgumentNames.length;\n    if (argumentCount == 0) return const [];\n    var list = [];\n    for (var index = 0 ; index < argumentCount ; index++) {\n      list.add(_arguments[index]);\n    }\n    return makeLiteralListConst(list);\n  }\n\n  Map<Symbol, dynamic> get namedArguments {\n    // TODO: Make maps const (issue 10471)\n    if (isAccessor) return <Symbol, dynamic>{};\n    int namedArgumentCount = _namedArgumentNames.length;\n    int namedArgumentsStartIndex = _arguments.length - namedArgumentCount;\n    if (namedArgumentCount == 0) return <Symbol, dynamic>{};\n    var map = new Map<Symbol, dynamic>();\n    for (int i = 0; i < namedArgumentCount; i++) {\n      map[new _symbol_dev.Symbol.unvalidated(_namedArgumentNames[i])] =\n          _arguments[namedArgumentsStartIndex + i];\n    }\n    return map;\n  }\n\n  _getCachedInvocation(Object object) {\n    var interceptor = getInterceptor(object);\n    var receiver = object;\n    var name = _internalName;\n    var arguments = _arguments;\n    // TODO(ngeoffray): If this functionality ever become performance\n    // critical, we might want to dynamically change [interceptedNames]\n    // to be a JavaScript object with intercepted names as property\n    // instead of a JavaScript array.\n    // TODO(floitsch): we already add stubs (tear-off getters) as properties\n    // in init.interceptedNames.\n    // Finish the transition and always use the object as hashtable.\n    bool isIntercepted =\n        JS(\"bool\",\n            'Object.prototype.hasOwnProperty.call(init.interceptedNames, #) ||'\n            '#.indexOf(#) !== -1',\n            name, interceptedNames, name);\n    if (isIntercepted) {\n      receiver = interceptor;\n      if (JS('bool', '# === #', object, interceptor)) {\n        interceptor = null;\n      }\n    } else {\n      interceptor = null;\n    }\n    bool isCatchAll = false;\n    var method = JS('var', '#[#]', receiver, name);\n    if (JS('bool', 'typeof # != \"function\"', method) ) {\n      String baseName = _symbol_dev.Symbol.getName(memberName);\n      method = JS('', '#[# + \"*\"]', receiver, baseName);\n      if (method == null) {\n        interceptor = getInterceptor(object);\n        method = JS('', '#[# + \"*\"]', interceptor, baseName);\n        if (method != null) {\n          isIntercepted = true;\n          receiver = interceptor;\n        } else {\n          interceptor = null;\n        }\n      }\n      isCatchAll = true;\n    }\n    if (JS('bool', 'typeof # == \"function\"', method)) {\n      if (isCatchAll) {\n        return new CachedCatchAllInvocation(\n            name, method, isIntercepted, interceptor);\n      } else {\n        return new CachedInvocation(name, method, isIntercepted, interceptor);\n      }\n    } else {\n      // In this case, receiver doesn't implement name.  So we should\n      // invoke noSuchMethod instead (which will often throw a\n      // NoSuchMethodError).\n      return new CachedNoSuchMethodInvocation(interceptor);\n    }\n  }\n\n  /// This method is called by [InstanceMirror.delegate].\n  static invokeFromMirror(JSInvocationMirror invocation, Object victim) {\n    var cached = invocation._getCachedInvocation(victim);\n    if (cached.isNoSuchMethod) {\n      return cached.invokeOn(victim, invocation);\n    } else {\n      return cached.invokeOn(victim, invocation._arguments);\n    }\n  }\n\n  static getCachedInvocation(JSInvocationMirror invocation, Object victim) {\n    return invocation._getCachedInvocation(victim);\n  }\n}\n\nclass CachedInvocation {\n  // The mangled name of this invocation.\n  String mangledName;\n\n  /// The JS function to call.\n  var jsFunction;\n\n  /// True if this is an intercepted call.\n  bool isIntercepted;\n\n  /// Non-null interceptor if this is an intercepted call through an\n  /// [Interceptor].\n  Interceptor cachedInterceptor;\n\n  CachedInvocation(this.mangledName,\n                   this.jsFunction,\n                   this.isIntercepted,\n                   this.cachedInterceptor);\n\n  bool get isNoSuchMethod => false;\n  bool get isGetterStub => JS(\"bool\", \"!!#.\\$getterStub\", jsFunction);\n\n  /// Applies [jsFunction] to [victim] with [arguments].\n  /// Users of this class must take care to check the arguments first.\n  invokeOn(Object victim, List arguments) {\n    var receiver = victim;\n    if (!isIntercepted) {\n      if (arguments is! JSArray) arguments = new List.from(arguments);\n    } else {\n      arguments = [victim]..addAll(arguments);\n      if (cachedInterceptor != null) receiver = cachedInterceptor;\n    }\n    return JS(\"var\", \"#.apply(#, #)\", jsFunction, receiver, arguments);\n  }\n}\n\nclass CachedCatchAllInvocation extends CachedInvocation {\n  final ReflectionInfo info;\n\n  CachedCatchAllInvocation(String name,\n                           jsFunction,\n                           bool isIntercepted,\n                           Interceptor cachedInterceptor)\n      : info = new ReflectionInfo(jsFunction),\n        super(name, jsFunction, isIntercepted, cachedInterceptor);\n\n  bool get isGetterStub => false;\n\n  invokeOn(Object victim, List arguments) {\n    var receiver = victim;\n    int providedArgumentCount;\n    int fullParameterCount =\n        info.requiredParameterCount + info.optionalParameterCount;\n    if (!isIntercepted) {\n      if (arguments is JSArray) {\n        providedArgumentCount = arguments.length;\n        // If we need to add extra arguments before calling, we have\n        // to copy the arguments array.\n        if (providedArgumentCount < fullParameterCount) {\n          arguments = new List.from(arguments);\n        }\n      } else {\n        arguments = new List.from(arguments);\n        providedArgumentCount = arguments.length;\n      }\n    } else {\n      arguments = [victim]..addAll(arguments);\n      if (cachedInterceptor != null) receiver = cachedInterceptor;\n      providedArgumentCount = arguments.length - 1;\n    }\n    if (info.areOptionalParametersNamed &&\n        (providedArgumentCount > info.requiredParameterCount)) {\n      throw new UnimplementedNoSuchMethodError(\n          \"Invocation of unstubbed method '${info.reflectionName}'\"\n          \" with ${arguments.length} arguments.\");\n    } else if (providedArgumentCount < info.requiredParameterCount) {\n      throw new UnimplementedNoSuchMethodError(\n          \"Invocation of unstubbed method '${info.reflectionName}'\"\n          \" with $providedArgumentCount arguments (too few).\");\n    } else if (providedArgumentCount > fullParameterCount) {\n      throw new UnimplementedNoSuchMethodError(\n          \"Invocation of unstubbed method '${info.reflectionName}'\"\n          \" with $providedArgumentCount arguments (too many).\");\n    }\n    for (int i = providedArgumentCount; i < fullParameterCount; i++) {\n      arguments.add(getMetadata(info.defaultValue(i)));\n    }\n    return JS(\"var\", \"#.apply(#, #)\", jsFunction, receiver, arguments);\n  }\n}\n\nclass CachedNoSuchMethodInvocation {\n  /// Non-null interceptor if this is an intercepted call through an\n  /// [Interceptor].\n  var interceptor;\n\n  CachedNoSuchMethodInvocation(this.interceptor);\n\n  bool get isNoSuchMethod => true;\n  bool get isGetterStub => false;\n\n  invokeOn(Object victim, Invocation invocation) {\n    var receiver = (interceptor == null) ? victim : interceptor;\n    return receiver.noSuchMethod(invocation);\n  }\n}\n\nclass ReflectionInfo {\n  static const int REQUIRED_PARAMETERS_INFO = 0;\n  static const int OPTIONAL_PARAMETERS_INFO = 1;\n  static const int FUNCTION_TYPE_INDEX = 2;\n  static const int FIRST_DEFAULT_ARGUMENT = 3;\n\n  /// A JavaScript function object.\n  final jsFunction;\n\n  /// Raw reflection information.\n  final List data;\n\n  /// Is this a getter or a setter.\n  final bool isAccessor;\n\n  /// Number of required parameters.\n  final int requiredParameterCount;\n\n  /// Number of optional parameters.\n  final int optionalParameterCount;\n\n  /// Are optional parameters named.\n  final bool areOptionalParametersNamed;\n\n  /// Either an index to the function type in [:init.metadata:] or a JavaScript\n  /// function object which can compute such a type (presumably due to free\n  /// type variables).\n  final functionType;\n\n  List cachedSortedIndices;\n\n  ReflectionInfo.internal(this.jsFunction,\n                          this.data,\n                          this.isAccessor,\n                          this.requiredParameterCount,\n                          this.optionalParameterCount,\n                          this.areOptionalParametersNamed,\n                          this.functionType);\n\n  factory ReflectionInfo(jsFunction) {\n    List data = JS('JSExtendableArray|Null', r'#.$reflectionInfo', jsFunction);\n    if (data == null) return null;\n    data = JSArray.markFixedList(data);\n\n    int requiredParametersInfo =\n        JS('int', '#[#]', data, REQUIRED_PARAMETERS_INFO);\n    int requiredParameterCount = JS('int', '# >> 1', requiredParametersInfo);\n    bool isAccessor = (requiredParametersInfo & 1) == 1;\n\n    int optionalParametersInfo =\n        JS('int', '#[#]', data, OPTIONAL_PARAMETERS_INFO);\n    int optionalParameterCount = JS('int', '# >> 1', optionalParametersInfo);\n    bool areOptionalParametersNamed = (optionalParametersInfo & 1) == 1;\n\n    var functionType = JS('', '#[#]', data, FUNCTION_TYPE_INDEX);\n    return new ReflectionInfo.internal(\n        jsFunction, data, isAccessor, requiredParameterCount,\n        optionalParameterCount, areOptionalParametersNamed, functionType);\n  }\n\n  String parameterName(int parameter) {\n    int metadataIndex;\n    if (JS_GET_FLAG('MUST_RETAIN_METADATA')) {\n      metadataIndex = JS('int', '#[2 * # + # + #]', data,\n          parameter, optionalParameterCount, FIRST_DEFAULT_ARGUMENT);\n    } else {\n      metadataIndex = JS('int', '#[# + # + #]', data,\n          parameter, optionalParameterCount, FIRST_DEFAULT_ARGUMENT);\n    }\n    return JS('String', 'init.metadata[#]', metadataIndex);\n  }\n\n  List<int> parameterMetadataAnnotations(int parameter) {\n    if (!JS_GET_FLAG('MUST_RETAIN_METADATA')) {\n      throw new StateError('metadata has not been preserved');\n    } else {\n      return JS('', '#[2 * # + # + # + 1]', data, parameter,\n          optionalParameterCount, FIRST_DEFAULT_ARGUMENT);\n    }\n  }\n\n  int defaultValue(int parameter) {\n    if (parameter < requiredParameterCount) return null;\n    return JS('int', '#[# + # - #]', data,\n              FIRST_DEFAULT_ARGUMENT, parameter, requiredParameterCount);\n  }\n\n  /// Returns the default value of the [parameter]th entry of the list of\n  /// parameters sorted by name.\n  int defaultValueInOrder(int parameter) {\n    if (parameter < requiredParameterCount) return null;\n\n    if (!areOptionalParametersNamed || optionalParameterCount == 1) {\n      return defaultValue(parameter);\n    }\n\n    int index = sortedIndex(parameter - requiredParameterCount);\n    return defaultValue(index);\n  }\n\n  /// Returns the default value of the [parameter]th entry of the list of\n  /// parameters sorted by name.\n  String parameterNameInOrder(int parameter) {\n    if (parameter < requiredParameterCount) return null;\n\n    if (!areOptionalParametersNamed ||\n        optionalParameterCount == 1) {\n      return parameterName(parameter);\n    }\n\n    int index = sortedIndex(parameter - requiredParameterCount);\n    return parameterName(index);\n  }\n\n  /// Computes the index of the parameter in the list of named parameters sorted\n  /// by their name.\n  int sortedIndex(int unsortedIndex) {\n    if (cachedSortedIndices == null) {\n      // TODO(karlklose): cache this between [ReflectionInfo] instances or cache\n      // [ReflectionInfo] instances by [jsFunction].\n      cachedSortedIndices = new List(optionalParameterCount);\n      Map<String, int> positions = <String, int>{};\n      for (int i = 0; i < optionalParameterCount; i++) {\n        int index = requiredParameterCount + i;\n        positions[parameterName(index)] = index;\n      }\n      int index = 0;\n      (positions.keys.toList()..sort()).forEach((String name) {\n        cachedSortedIndices[index++] = positions[name];\n      });\n    }\n    return cachedSortedIndices[unsortedIndex];\n  }\n\n  @NoInline()\n  computeFunctionRti(jsConstructor) {\n    if (JS('bool', 'typeof # == \"number\"', functionType)) {\n      return getMetadata(functionType);\n    } else if (JS('bool', 'typeof # == \"function\"', functionType)) {\n      var fakeInstance = JS('', 'new #()', jsConstructor);\n      setRuntimeTypeInfo(\n          fakeInstance, JS('JSExtendableArray', '#[\"<>\"]', fakeInstance));\n      return JS('=Object|Null', r'#.apply({$receiver:#})',\n                functionType, fakeInstance);\n    } else {\n      throw new RuntimeError('Unexpected function type');\n    }\n  }\n\n  String get reflectionName => JS('String', r'#.$reflectionName', jsFunction);\n}\n\ngetMetadata(int index) => JS('', 'init.metadata[#]', index);\n\nclass Primitives {\n  /// Isolate-unique ID for caching [JsClosureMirror.function].\n  /// Note the initial value is used by the first isolate (or if there are no\n  /// isolates), new isolates will update this value to avoid conflicts by\n  /// calling [initializeStatics].\n  static String mirrorFunctionCacheName = '\\$cachedFunction';\n\n  /// Isolate-unique ID for caching [JsInstanceMirror._invoke].\n  static String mirrorInvokeCacheName = '\\$cachedInvocation';\n\n  /// Called when creating a new isolate (see _IsolateContext constructor in\n  /// isolate_helper.dart).\n  /// Please don't add complicated code to this method, as it will impact\n  /// start-up performance.\n  static void initializeStatics(int id) {\n    // Benchmarking shows significant performance improvements if this is a\n    // fixed value.\n    mirrorFunctionCacheName += '_$id';\n    mirrorInvokeCacheName += '_$id';\n  }\n\n  static int objectHashCode(object) {\n    int hash = JS('int|Null', r'#.$identityHash', object);\n    if (hash == null) {\n      hash = JS('int', '(Math.random() * 0x3fffffff) | 0');\n      JS('void', r'#.$identityHash = #', object, hash);\n    }\n    return JS('int', '#', hash);\n  }\n\n  static _throwFormatException(String string) {\n    throw new FormatException(string);\n  }\n\n  static int parseInt(String source,\n                      int radix,\n                      int handleError(String source)) {\n    if (handleError == null) handleError = _throwFormatException;\n\n    checkString(source);\n    var match = JS('JSExtendableArray|Null',\n        r'/^\\s*[+-]?((0x[a-f0-9]+)|(\\d+)|([a-z0-9]+))\\s*$/i.exec(#)',\n        source);\n    int digitsIndex = 1;\n    int hexIndex = 2;\n    int decimalIndex = 3;\n    int nonDecimalHexIndex = 4;\n    if (radix == null) {\n      radix = 10;\n      if (match != null) {\n        if (match[hexIndex] != null) {\n          // Cannot fail because we know that the digits are all hex.\n          return JS('num', r'parseInt(#, 16)', source);\n        }\n        if (match[decimalIndex] != null) {\n          // Cannot fail because we know that the digits are all decimal.\n          return JS('num', r'parseInt(#, 10)', source);\n        }\n        return handleError(source);\n      }\n    } else {\n      if (radix is! int) throw new ArgumentError(\"Radix is not an integer\");\n      if (radix < 2 || radix > 36) {\n        throw new RangeError(\"Radix $radix not in range 2..36\");\n      }\n      if (match != null) {\n        if (radix == 10 && match[decimalIndex] != null) {\n          // Cannot fail because we know that the digits are all decimal.\n          return JS('num', r'parseInt(#, 10)', source);\n        }\n        if (radix < 10 || match[decimalIndex] == null) {\n          // We know that the characters must be ASCII as otherwise the\n          // regexp wouldn't have matched. Lowercasing by doing `| 0x20` is thus\n          // guaranteed to be a safe operation, since it preserves digits\n          // and lower-cases ASCII letters.\n          int maxCharCode;\n          if (radix <= 10) {\n            // Allow all digits less than the radix. For example 0, 1, 2 for\n            // radix 3.\n            // \"0\".codeUnitAt(0) + radix - 1;\n            maxCharCode = 0x30 + radix - 1;\n          } else {\n            // Letters are located after the digits in ASCII. Therefore we\n            // only check for the character code. The regexp above made already\n            // sure that the string does not contain anything but digits or\n            // letters.\n            // \"a\".codeUnitAt(0) + (radix - 10) - 1;\n            maxCharCode = 0x61 + radix - 10 - 1;\n          }\n          String digitsPart = match[digitsIndex];\n          for (int i = 0; i < digitsPart.length; i++) {\n            int characterCode = digitsPart.codeUnitAt(0) | 0x20;\n            if (digitsPart.codeUnitAt(i) > maxCharCode) {\n              return handleError(source);\n            }\n          }\n        }\n      }\n    }\n    if (match == null) return handleError(source);\n    return JS('num', r'parseInt(#, #)', source, radix);\n  }\n\n  static double parseDouble(String source, double handleError(String source)) {\n    checkString(source);\n    if (handleError == null) handleError = _throwFormatException;\n    // Notice that JS parseFloat accepts garbage at the end of the string.\n    // Accept only:\n    // - [+/-]NaN\n    // - [+/-]Infinity\n    // - a Dart double literal\n    // We do allow leading or trailing whitespace.\n    if (!JS('bool',\n            r'/^\\s*[+-]?(?:Infinity|NaN|'\n                r'(?:\\.\\d+|\\d+(?:\\.\\d*)?)(?:[eE][+-]?\\d+)?)\\s*$/.test(#)',\n            source)) {\n      return handleError(source);\n    }\n    var result = JS('num', r'parseFloat(#)', source);\n    if (result.isNaN) {\n      var trimmed = source.trim();\n      if (trimmed == 'NaN' || trimmed == '+NaN' || trimmed == '-NaN') {\n        return result;\n      }\n      return handleError(source);\n    }\n    return result;\n  }\n\n  /** [: r\"$\".codeUnitAt(0) :] */\n  static const int DOLLAR_CHAR_VALUE = 36;\n\n  /// Creates a string containing the complete type for the class [className]\n  /// with the given type arguments.\n  ///\n  /// In minified mode, uses the unminified names if available.\n  static String formatType(String className, List typeArguments) {\n    return unmangleAllIdentifiersIfPreservedAnyways\n        ('$className${joinArguments(typeArguments, 0)}');\n  }\n\n  /// Returns the type of [object] as a string (including type arguments).\n  ///\n  /// In minified mode, uses the unminified names if available.\n  static String objectTypeName(Object object) {\n    String name = constructorNameFallback(getInterceptor(object));\n    if (name == 'Object') {\n      // Try to decompile the constructor by turning it into a string and get\n      // the name out of that. If the decompiled name is a string containing an\n      // identifier, we use that instead of the very generic 'Object'.\n      var decompiled =\n          JS('var', r'#.match(/^\\s*function\\s*(\\S*)\\s*\\(/)[1]',\n              JS('var', r'String(#.constructor)', object));\n      if (decompiled is String)\n        if (JS('bool', r'/^\\w+$/.test(#)', decompiled))\n          name = decompiled;\n    }\n    // TODO(kasperl): If the namer gave us a fresh global name, we may\n    // want to remove the numeric suffix that makes it unique too.\n    if (name.length > 1 && identical(name.codeUnitAt(0), DOLLAR_CHAR_VALUE)) {\n      name = name.substring(1);\n    }\n    return formatType(name, getRuntimeTypeInfo(object));\n  }\n\n  /// In minified mode, uses the unminified names if available.\n  static String objectToString(Object object) {\n    String name = objectTypeName(object);\n    return \"Instance of '$name'\";\n  }\n\n  static num dateNow() => JS('num', r'Date.now()');\n\n  static void initTicker() {\n    if (timerFrequency != null) return;\n    // Start with low-resolution. We overwrite the fields if we find better.\n    timerFrequency = 1000;\n    timerTicks = dateNow;\n    if (JS('bool', 'typeof window == \"undefined\"')) return;\n    var window = JS('var', 'window');\n    if (window == null) return;\n    var performance = JS('var', '#.performance', window);\n    if (performance == null) return;\n    if (JS('bool', 'typeof #.now != \"function\"', performance)) return;\n    timerFrequency = 1000000;\n    timerTicks = () => (1000 * JS('num', '#.now()', performance)).floor();\n  }\n\n  static int timerFrequency;\n  static Function timerTicks;\n\n  static bool get isD8 {\n    return JS('bool',\n              'typeof version == \"function\"'\n              ' && typeof os == \"object\" && \"system\" in os');\n  }\n\n  static bool get isJsshell {\n    return JS('bool',\n              'typeof version == \"function\" && typeof system == \"function\"');\n  }\n\n  static String currentUri() {\n    requiresPreamble();\n    // In a browser return self.location.href.\n    if (JS('bool', '!!self.location')) {\n      return JS('String', 'self.location.href');\n    }\n\n    return null;\n  }\n\n  // This is to avoid stack overflows due to very large argument arrays in\n  // apply().  It fixes http://dartbug.com/6919\n  static String _fromCharCodeApply(List<int> array) {\n    String result = \"\";\n    const kMaxApply = 500;\n    int end = array.length;\n    for (var i = 0; i < end; i += kMaxApply) {\n      var subarray;\n      if (end <= kMaxApply) {\n        subarray = array;\n      } else {\n        subarray = JS('JSExtendableArray', r'#.slice(#, #)', array,\n                      i, i + kMaxApply < end ? i + kMaxApply : end);\n      }\n      result = JS('String', '# + String.fromCharCode.apply(#, #)',\n                  result, null, subarray);\n    }\n    return result;\n  }\n\n  static String stringFromCodePoints(codePoints) {\n    List<int> a = <int>[];\n    for (var i in codePoints) {\n      if (i is !int) throw new ArgumentError(i);\n      if (i <= 0xffff) {\n        a.add(i);\n      } else if (i <= 0x10ffff) {\n        a.add(0xd800 + ((((i - 0x10000) >> 10) & 0x3ff)));\n        a.add(0xdc00 + (i & 0x3ff));\n      } else {\n        throw new ArgumentError(i);\n      }\n    }\n    return _fromCharCodeApply(a);\n  }\n\n  static String stringFromCharCodes(charCodes) {\n    for (var i in charCodes) {\n      if (i is !int) throw new ArgumentError(i);\n      if (i < 0) throw new ArgumentError(i);\n      if (i > 0xffff) return stringFromCodePoints(charCodes);\n    }\n    return _fromCharCodeApply(charCodes);\n  }\n\n  static String stringFromCharCode(charCode) {\n    if (0 <= charCode) {\n      if (charCode <= 0xffff) {\n        return JS('String', 'String.fromCharCode(#)', charCode);\n      }\n      if (charCode <= 0x10ffff) {\n        var bits = charCode - 0x10000;\n        var low = 0xDC00 | (bits & 0x3ff);\n        var high = 0xD800 | (bits >> 10);\n        return  JS('String', 'String.fromCharCode(#, #)', high, low);\n      }\n    }\n    throw new RangeError.range(charCode, 0, 0x10ffff);\n  }\n\n  static String stringConcatUnchecked(String string1, String string2) {\n    return JS_STRING_CONCAT(string1, string2);\n  }\n\n  static String getTimeZoneName(receiver) {\n    // Firefox and Chrome emit the timezone in parenthesis.\n    // Example: \"Wed May 16 2012 21:13:00 GMT+0200 (CEST)\".\n    // We extract this name using a regexp.\n    var d = lazyAsJsDate(receiver);\n    List match = JS('JSArray|Null', r'/\\((.*)\\)/.exec(#.toString())', d);\n    if (match != null) return match[1];\n\n    // Internet Explorer 10+ emits the zone name without parenthesis:\n    // Example: Thu Oct 31 14:07:44 PDT 2013\n    match = JS('JSArray|Null',\n                // Thu followed by a space.\n                r'/^[A-Z,a-z]{3}\\s'\n                // Oct 31 followed by space.\n                r'[A-Z,a-z]{3}\\s\\d+\\s'\n                // Time followed by a space.\n                r'\\d{2}:\\d{2}:\\d{2}\\s'\n                // The time zone name followed by a space.\n                r'([A-Z]{3,5})\\s'\n                // The year.\n                r'\\d{4}$/'\n                '.exec(#.toString())',\n                d);\n    if (match != null) return match[1];\n\n    // IE 9 and Opera don't provide the zone name. We fall back to emitting the\n    // UTC/GMT offset.\n    // Example (IE9): Wed Nov 20 09:51:00 UTC+0100 2013\n    //       (Opera): Wed Nov 20 2013 11:03:38 GMT+0100\n    match = JS('JSArray|Null', r'/(?:GMT|UTC)[+-]\\d{4}/.exec(#.toString())', d);\n    if (match != null) return match[0];\n    return \"\";\n  }\n\n  static int getTimeZoneOffsetInMinutes(receiver) {\n    // Note that JS and Dart disagree on the sign of the offset.\n    return -JS('int', r'#.getTimezoneOffset()', lazyAsJsDate(receiver));\n  }\n\n  static valueFromDecomposedDate(years, month, day, hours, minutes, seconds,\n                                 milliseconds, isUtc) {\n    final int MAX_MILLISECONDS_SINCE_EPOCH = 8640000000000000;\n    checkInt(years);\n    checkInt(month);\n    checkInt(day);\n    checkInt(hours);\n    checkInt(minutes);\n    checkInt(seconds);\n    checkInt(milliseconds);\n    checkBool(isUtc);\n    var jsMonth = month - 1;\n    var value;\n    if (isUtc) {\n      value = JS('num', r'Date.UTC(#, #, #, #, #, #, #)',\n                 years, jsMonth, day, hours, minutes, seconds, milliseconds);\n    } else {\n      value = JS('num', r'new Date(#, #, #, #, #, #, #).valueOf()',\n                 years, jsMonth, day, hours, minutes, seconds, milliseconds);\n    }\n    if (value.isNaN ||\n        value < -MAX_MILLISECONDS_SINCE_EPOCH ||\n        value > MAX_MILLISECONDS_SINCE_EPOCH) {\n      return null;\n    }\n    if (years <= 0 || years < 100) return patchUpY2K(value, years, isUtc);\n    return value;\n  }\n\n  static patchUpY2K(value, years, isUtc) {\n    var date = JS('', r'new Date(#)', value);\n    if (isUtc) {\n      JS('num', r'#.setUTCFullYear(#)', date, years);\n    } else {\n      JS('num', r'#.setFullYear(#)', date, years);\n    }\n    return JS('num', r'#.valueOf()', date);\n  }\n\n  // Lazily keep a JS Date stored in the JS object.\n  static lazyAsJsDate(receiver) {\n    if (JS('bool', r'#.date === (void 0)', receiver)) {\n      JS('void', r'#.date = new Date(#)', receiver,\n         receiver.millisecondsSinceEpoch);\n    }\n    return JS('var', r'#.date', receiver);\n  }\n\n  // The getters for date and time parts below add a positive integer to ensure\n  // that the result is really an integer, because the JavaScript implementation\n  // may return -0.0 instead of 0.\n\n  static getYear(receiver) {\n    return (receiver.isUtc)\n      ? JS('int', r'(#.getUTCFullYear() + 0)', lazyAsJsDate(receiver))\n      : JS('int', r'(#.getFullYear() + 0)', lazyAsJsDate(receiver));\n  }\n\n  static getMonth(receiver) {\n    return (receiver.isUtc)\n      ? JS('int', r'#.getUTCMonth() + 1', lazyAsJsDate(receiver))\n      : JS('int', r'#.getMonth() + 1', lazyAsJsDate(receiver));\n  }\n\n  static getDay(receiver) {\n    return (receiver.isUtc)\n      ? JS('int', r'(#.getUTCDate() + 0)', lazyAsJsDate(receiver))\n      : JS('int', r'(#.getDate() + 0)', lazyAsJsDate(receiver));\n  }\n\n  static getHours(receiver) {\n    return (receiver.isUtc)\n      ? JS('int', r'(#.getUTCHours() + 0)', lazyAsJsDate(receiver))\n      : JS('int', r'(#.getHours() + 0)', lazyAsJsDate(receiver));\n  }\n\n  static getMinutes(receiver) {\n    return (receiver.isUtc)\n      ? JS('int', r'(#.getUTCMinutes() + 0)', lazyAsJsDate(receiver))\n      : JS('int', r'(#.getMinutes() + 0)', lazyAsJsDate(receiver));\n  }\n\n  static getSeconds(receiver) {\n    return (receiver.isUtc)\n      ? JS('int', r'(#.getUTCSeconds() + 0)', lazyAsJsDate(receiver))\n      : JS('int', r'(#.getSeconds() + 0)', lazyAsJsDate(receiver));\n  }\n\n  static getMilliseconds(receiver) {\n    return (receiver.isUtc)\n      ? JS('int', r'(#.getUTCMilliseconds() + 0)', lazyAsJsDate(receiver))\n      : JS('int', r'(#.getMilliseconds() + 0)', lazyAsJsDate(receiver));\n  }\n\n  static getWeekday(receiver) {\n    int weekday = (receiver.isUtc)\n      ? JS('int', r'#.getUTCDay() + 0', lazyAsJsDate(receiver))\n      : JS('int', r'#.getDay() + 0', lazyAsJsDate(receiver));\n    // Adjust by one because JS weeks start on Sunday.\n    return (weekday + 6) % 7 + 1;\n  }\n\n  static valueFromDateString(str) {\n    if (str is !String) throw new ArgumentError(str);\n    var value = JS('num', r'Date.parse(#)', str);\n    if (value.isNaN) throw new ArgumentError(str);\n    return value;\n  }\n\n  static getProperty(object, key) {\n    if (object == null || object is bool || object is num || object is String) {\n      throw new ArgumentError(object);\n    }\n    return JS('var', '#[#]', object, key);\n  }\n\n  static void setProperty(object, key, value) {\n    if (object == null || object is bool || object is num || object is String) {\n      throw new ArgumentError(object);\n    }\n    JS('void', '#[#] = #', object, key, value);\n  }\n\n  static functionNoSuchMethod(function,\n                              List positionalArguments,\n                              Map<String, dynamic> namedArguments) {\n    int argumentCount = 0;\n    List arguments = [];\n    List namedArgumentList = [];\n\n    if (positionalArguments != null) {\n      argumentCount += positionalArguments.length;\n      arguments.addAll(positionalArguments);\n    }\n\n    String names = '';\n    if (namedArguments != null && !namedArguments.isEmpty) {\n      namedArguments.forEach((String name, argument) {\n        names = '$names\\$$name';\n        namedArgumentList.add(name);\n        arguments.add(argument);\n        argumentCount++;\n      });\n    }\n\n    String selectorName =\n      '${JS_GET_NAME(\"CALL_PREFIX\")}\\$$argumentCount$names';\n\n    return function.noSuchMethod(\n        createUnmangledInvocationMirror(\n            #call,\n            selectorName,\n            JSInvocationMirror.METHOD,\n            arguments,\n            namedArgumentList));\n  }\n\n  static applyFunction(Function function,\n                       List positionalArguments,\n                       Map<String, dynamic> namedArguments) {\n    if (namedArguments != null && !namedArguments.isEmpty) {\n      // TODO(ahe): The following code can be shared with\n      // JsInstanceMirror.invoke.\n      var interceptor = getInterceptor(function);\n      var jsFunction = JS('', '#[\"call*\"]', interceptor);\n\n      if (jsFunction == null) {\n        return functionNoSuchMethod(\n            function, positionalArguments, namedArguments);\n      }\n      ReflectionInfo info = new ReflectionInfo(jsFunction);\n      if (info == null || !info.areOptionalParametersNamed) {\n        return functionNoSuchMethod(\n            function, positionalArguments, namedArguments);\n      }\n\n      if (positionalArguments != null) {\n        positionalArguments = new List.from(positionalArguments);\n      } else {\n        positionalArguments = [];\n      }\n      // Check the number of positional arguments is valid.\n      if (info.requiredParameterCount != positionalArguments.length) {\n        return functionNoSuchMethod(\n            function, positionalArguments, namedArguments);\n      }\n      var defaultArguments = new Map();\n      for (int i = 0; i < info.optionalParameterCount; i++) {\n        int index = i + info.requiredParameterCount;\n        var parameterName = info.parameterNameInOrder(index);\n        var value = info.defaultValueInOrder(index);\n        var defaultValue = getMetadata(value);\n        defaultArguments[parameterName] = defaultValue;\n      }\n      bool bad = false;\n      namedArguments.forEach((String parameter, value) {\n        if (defaultArguments.containsKey(parameter)) {\n          defaultArguments[parameter] = value;\n        } else {\n          // Extraneous named argument.\n          bad = true;\n        }\n      });\n      if (bad) {\n        return functionNoSuchMethod(\n            function, positionalArguments, namedArguments);\n      }\n      positionalArguments.addAll(defaultArguments.values);\n      return JS('', '#.apply(#, #)', jsFunction, function, positionalArguments);\n    }\n\n    int argumentCount = 0;\n    List arguments = [];\n\n    if (positionalArguments != null) {\n      argumentCount += positionalArguments.length;\n      arguments.addAll(positionalArguments);\n    }\n\n    String selectorName = '${JS_GET_NAME(\"CALL_PREFIX\")}\\$$argumentCount';\n    var jsFunction = JS('var', '#[#]', function, selectorName);\n    if (jsFunction == null) {\n\n      // TODO(ahe): This might occur for optional arguments if there is no call\n      // selector with that many arguments.\n\n      return\n          functionNoSuchMethod(function, positionalArguments, namedArguments);\n    }\n    // We bound 'this' to [function] because of how we compile\n    // closures: escaped local variables are stored and accessed through\n    // [function].\n    return JS('var', '#.apply(#, #)', jsFunction, function, arguments);\n  }\n\n  static _mangledNameMatchesType(String mangledName, TypeImpl type) {\n    return JS('bool', '# == #', mangledName, type._typeName);\n  }\n\n  static bool identicalImplementation(a, b) {\n    return JS('bool', '# == null', a)\n      ? JS('bool', '# == null', b)\n      : JS('bool', '# === #', a, b);\n  }\n\n  static StackTrace extractStackTrace(Error error) {\n    return getTraceFromException(JS('', r'#.$thrownJsError', error));\n  }\n}\n\n/// Helper class for allocating and using JS object literals as caches.\nclass JsCache {\n  /// Returns a JavaScript object suitable for use as a cache.\n  static allocate() {\n    var result = JS('=Object', 'Object.create(null)');\n    // Deleting a property makes V8 assume that it shouldn't create a hidden\n    // class for [result] and map transitions. Although these map transitions\n    // pay off if there are many cache hits for the same keys, it becomes\n    // really slow when there aren't many repeated hits.\n    JS('void', '#.x=0', result);\n    JS('void', 'delete #.x', result);\n    return result;\n  }\n\n  static fetch(cache, String key) {\n    return JS('', '#[#]', cache, key);\n  }\n\n  static void update(cache, String key, value) {\n    JS('void', '#[#] = #', cache, key, value);\n  }\n}\n\n/**\n * Called by generated code to throw an illegal-argument exception,\n * for example, if a non-integer index is given to an optimized\n * indexed access.\n */\niae(argument) {\n  throw new ArgumentError(argument);\n}\n\n/**\n * Called by generated code to throw an index-out-of-range exception,\n * for example, if a bounds check fails in an optimized indexed\n * access.  This may also be called when the index is not an integer, in\n * which case it throws an illegal-argument exception instead, like\n * [iae], or when the receiver is null.\n */\nioore(receiver, index) {\n  if (receiver == null) receiver.length; // Force a NoSuchMethodError.\n  if (index is !int) iae(index);\n  throw new RangeError.value(index);\n}\n\nstringLastIndexOfUnchecked(receiver, element, start)\n  => JS('int', r'#.lastIndexOf(#, #)', receiver, element, start);\n\n\ncheckNull(object) {\n  if (object == null) throw new ArgumentError(null);\n  return object;\n}\n\ncheckNum(value) {\n  if (value is !num) {\n    throw new ArgumentError(value);\n  }\n  return value;\n}\n\ncheckInt(value) {\n  if (value is !int) {\n    throw new ArgumentError(value);\n  }\n  return value;\n}\n\ncheckBool(value) {\n  if (value is !bool) {\n    throw new ArgumentError(value);\n  }\n  return value;\n}\n\ncheckString(value) {\n  if (value is !String) {\n    throw new ArgumentError(value);\n  }\n  return value;\n}\n\n/**\n * Wrap the given Dart object and record a stack trace.\n *\n * The code in [unwrapException] deals with getting the original Dart\n * object out of the wrapper again.\n */\n@NoInline()\nwrapException(ex) {\n  if (ex == null) ex = new NullThrownError();\n  var wrapper = JS('', 'new Error()');\n  // [unwrapException] looks for the property 'dartException'.\n  JS('void', '#.dartException = #', wrapper, ex);\n\n  if (JS('bool', '\"defineProperty\" in Object')) {\n    // Define a JavaScript getter for 'message'. This is to work around V8 bug\n    // (https://code.google.com/p/v8/issues/detail?id=2519).  The default\n    // toString on Error returns the value of 'message' if 'name' is\n    // empty. Setting toString directly doesn't work, see the bug.\n    JS('void', 'Object.defineProperty(#, \"message\", { get: # })',\n       wrapper, DART_CLOSURE_TO_JS(toStringWrapper));\n    JS('void', '#.name = \"\"', wrapper);\n  } else {\n    // In the unlikely event the browser doesn't support Object.defineProperty,\n    // hope that it just calls toString.\n    JS('void', '#.toString = #', wrapper, DART_CLOSURE_TO_JS(toStringWrapper));\n  }\n\n  return wrapper;\n}\n\n/// Do not call directly.\ntoStringWrapper() {\n  // This method gets installed as toString on a JavaScript object. Due to the\n  // weird scope rules of JavaScript, JS 'this' will refer to that object.\n  return JS('', r'this.dartException').toString();\n}\n\n/**\n * This wraps the exception and does the throw.  It is possible to call this in\n * a JS expression context, where the throw statement is not allowed.  Helpers\n * are never inlined, so we don't risk inlining the throw statement into an\n * expression context.\n */\nthrowExpression(ex) {\n  JS('void', 'throw #', wrapException(ex));\n}\n\nmakeLiteralListConst(list) {\n  JS('bool', r'#.immutable$list = #', list, true);\n  JS('bool', r'#.fixed$length = #', list, true);\n  return list;\n}\n\nthrowRuntimeError(message) {\n  throw new RuntimeError(message);\n}\n\nthrowAbstractClassInstantiationError(className) {\n  throw new AbstractClassInstantiationError(className);\n}\n\n\n/**\n * Helper class for building patterns recognizing native type errors.\n */\nclass TypeErrorDecoder {\n  // Field names are private to help tree-shaking.\n\n  /// A regular expression which matches is matched against an error message.\n  final String _pattern;\n\n  /// The group index of \"arguments\" in [_pattern], or -1 if _pattern has no\n  /// match for \"arguments\".\n  final int _arguments;\n\n  /// The group index of \"argumentsExpr\" in [_pattern], or -1 if _pattern has\n  /// no match for \"argumentsExpr\".\n  final int _argumentsExpr;\n\n  /// The group index of \"expr\" in [_pattern], or -1 if _pattern has no match\n  /// for \"expr\".\n  final int _expr;\n\n  /// The group index of \"method\" in [_pattern], or -1 if _pattern has no match\n  /// for \"method\".\n  final int _method;\n\n  /// The group index of \"receiver\" in [_pattern], or -1 if _pattern has no\n  /// match for \"receiver\".\n  final int _receiver;\n\n  /// Pattern used to recognize a NoSuchMethodError error (and\n  /// possibly extract the method name).\n  static final TypeErrorDecoder noSuchMethodPattern =\n      extractPattern(provokeCallErrorOn(buildJavaScriptObject()));\n\n  /// Pattern used to recognize an \"object not a closure\" error (and\n  /// possibly extract the method name).\n  static final TypeErrorDecoder notClosurePattern =\n      extractPattern(provokeCallErrorOn(buildJavaScriptObjectWithNonClosure()));\n\n  /// Pattern used to recognize a NoSuchMethodError on JavaScript null\n  /// call.\n  static final TypeErrorDecoder nullCallPattern =\n      extractPattern(provokeCallErrorOn(JS('', 'null')));\n\n  /// Pattern used to recognize a NoSuchMethodError on JavaScript literal null\n  /// call.\n  static final TypeErrorDecoder nullLiteralCallPattern =\n      extractPattern(provokeCallErrorOnNull());\n\n  /// Pattern used to recognize a NoSuchMethodError on JavaScript\n  /// undefined call.\n  static final TypeErrorDecoder undefinedCallPattern =\n      extractPattern(provokeCallErrorOn(JS('', 'void 0')));\n\n  /// Pattern used to recognize a NoSuchMethodError on JavaScript literal\n  /// undefined call.\n  static final TypeErrorDecoder undefinedLiteralCallPattern =\n      extractPattern(provokeCallErrorOnUndefined());\n\n  /// Pattern used to recognize a NoSuchMethodError on JavaScript null\n  /// property access.\n  static final TypeErrorDecoder nullPropertyPattern =\n      extractPattern(provokePropertyErrorOn(JS('', 'null')));\n\n  /// Pattern used to recognize a NoSuchMethodError on JavaScript literal null\n  /// property access.\n  static final TypeErrorDecoder nullLiteralPropertyPattern =\n      extractPattern(provokePropertyErrorOnNull());\n\n  /// Pattern used to recognize a NoSuchMethodError on JavaScript\n  /// undefined property access.\n  static final TypeErrorDecoder undefinedPropertyPattern =\n      extractPattern(provokePropertyErrorOn(JS('', 'void 0')));\n\n  /// Pattern used to recognize a NoSuchMethodError on JavaScript literal\n  /// undefined property access.\n  static final TypeErrorDecoder undefinedLiteralPropertyPattern =\n      extractPattern(provokePropertyErrorOnUndefined());\n\n  TypeErrorDecoder(this._arguments,\n                   this._argumentsExpr,\n                   this._expr,\n                   this._method,\n                   this._receiver,\n                   this._pattern);\n\n  /// Returns a JavaScript object literal (map) with at most the\n  /// following keys:\n  ///\n  /// * arguments: The arguments as formatted by the JavaScript\n  ///   engine. No browsers are known to provide this information.\n  ///\n  /// * argumentsExpr: The syntax of the arguments (JavaScript source\n  ///   code). No browsers are known to provide this information.\n  ///\n  /// * expr: The syntax of the receiver expression (JavaScript source\n  ///   code). Firefox provides this information, for example: \"$expr$.$method$\n  ///   is not a function\".\n  ///\n  /// * method: The name of the called method (mangled name). At least Firefox\n  ///   and Chrome/V8 provides this information, for example, \"Object [object\n  ///   Object] has no method '$method$'\".\n  ///\n  /// * receiver: The string representation of the receiver. Chrome/V8\n  ///   used to provide this information (by calling user-defined\n  ///   JavaScript toString on receiver), but it has degenerated into\n  ///   \"[object Object]\" in recent versions.\n  matchTypeError(message) {\n    var match = JS('JSExtendableArray|Null',\n        'new RegExp(#).exec(#)', _pattern, message);\n    if (match == null) return null;\n    var result = JS('', '{}');\n    if (_arguments != -1) {\n      JS('', '#.arguments = #[# + 1]', result, match, _arguments);\n    }\n    if (_argumentsExpr != -1) {\n      JS('', '#.argumentsExpr = #[# + 1]', result, match, _argumentsExpr);\n    }\n    if (_expr != -1) {\n      JS('', '#.expr = #[# + 1]', result, match, _expr);\n    }\n    if (_method != -1) {\n      JS('', '#.method = #[# + 1]', result, match, _method);\n    }\n    if (_receiver != -1) {\n      JS('', '#.receiver = #[# + 1]', result, match, _receiver);\n    }\n\n    return result;\n  }\n\n  /// Builds a JavaScript Object with a toString method saying\n  /// r\"$receiver$\".\n  static buildJavaScriptObject() {\n    return JS('', r'{ toString: function() { return \"$receiver$\"; } }');\n  }\n\n  /// Builds a JavaScript Object with a toString method saying\n  /// r\"$receiver$\". The property \"$method\" is defined, but is not a function.\n  static buildJavaScriptObjectWithNonClosure() {\n    return JS('', r'{ $method$: null, '\n              r'toString: function() { return \"$receiver$\"; } }');\n  }\n\n  /// Extract a pattern from a JavaScript TypeError message.\n  ///\n  /// The patterns are extracted by forcing TypeErrors on known\n  /// objects thus forcing known strings into the error message. The\n  /// known strings are then replaced with wildcards which in theory\n  /// makes it possible to recognize the desired information even if\n  /// the error messages are reworded or translated.\n  static extractPattern(String message) {\n    // Some JavaScript implementations (V8 at least) include a\n    // representation of the receiver in the error message, however,\n    // this representation is not always [: receiver.toString() :],\n    // sometimes it is [: Object.prototype.toString(receiver) :], and\n    // sometimes it is an implementation specific method (but that\n    // doesn't seem to happen for object literals). So sometimes we\n    // get the text \"[object Object]\". The shortest way to get that\n    // string is using \"String({})\".\n    // See: http://code.google.com/p/v8/issues/detail?id=2519.\n    message = JS('String', r\"#.replace(String({}), '$receiver$')\", message);\n\n    // Since we want to create a new regular expression from an unknown string,\n    // we must escape all regular expression syntax.\n    message = JS('String', r\"#.replace(new RegExp(#, 'g'), '\\\\$&')\",\n                 message, ESCAPE_REGEXP);\n\n    // Look for the special pattern \\$camelCase\\$ (all the $ symbols\n    // have been escaped already), as we will soon be inserting\n    // regular expression syntax that we want interpreted by RegExp.\n    List<String> match =\n        JS('JSExtendableArray|Null', r\"#.match(/\\\\\\$[a-zA-Z]+\\\\\\$/g)\", message);\n    if (match == null) match = [];\n\n    // Find the positions within the substring matches of the error message\n    // components.  This will help us extract information later, such as the\n    // method name.\n    int arguments = JS('int', '#.indexOf(#)', match, r'\\$arguments\\$');\n    int argumentsExpr = JS('int', '#.indexOf(#)', match, r'\\$argumentsExpr\\$');\n    int expr = JS('int', '#.indexOf(#)', match, r'\\$expr\\$');\n    int method = JS('int', '#.indexOf(#)', match, r'\\$method\\$');\n    int receiver = JS('int', '#.indexOf(#)', match, r'\\$receiver\\$');\n\n    // Replace the patterns with a regular expression wildcard.\n    // Note: in a perfect world, one would use \"(.*)\", but not in\n    // JavaScript, \".\" does not match newlines.\n    String pattern = JS('String',\n                        r\"#.replace('\\\\$arguments\\\\$', '((?:x|[^x])*)')\"\n                        r\".replace('\\\\$argumentsExpr\\\\$',  '((?:x|[^x])*)')\"\n                        r\".replace('\\\\$expr\\\\$',  '((?:x|[^x])*)')\"\n                        r\".replace('\\\\$method\\\\$',  '((?:x|[^x])*)')\"\n                        r\".replace('\\\\$receiver\\\\$',  '((?:x|[^x])*)')\",\n                        message);\n\n    return new TypeErrorDecoder(arguments,\n                                argumentsExpr,\n                                expr,\n                                method,\n                                receiver,\n                                pattern);\n  }\n\n  /// Provokes a TypeError and returns its message.\n  ///\n  /// The error is provoked so all known variable content can be recognized and\n  /// a pattern can be inferred.\n  static String provokeCallErrorOn(expression) {\n    // This function is carefully created to maximize the possibility\n    // of decoding the TypeError message and turning it into a general\n    // pattern.\n    //\n    // The idea is to inject something known into something unknown.  The\n    // unknown entity is the error message that the browser provides with a\n    // TypeError.  It is a human readable message, possibly localized in a\n    // language no dart2js engineer understand.  We assume that $name$ would\n    // never naturally occur in a human readable error message, yet it is easy\n    // to decode.\n    //\n    // For example, evaluate this in V8 version 3.13.7.6:\n    //\n    // var $expr$ = null; $expr$.$method$()\n    //\n    // The VM throws an instance of TypeError whose message property contains\n    // \"Cannot call method '$method$' of null\".  We can then reasonably assume\n    // that if the string contains $method$, that's where the method name will\n    // be in general.  Call this automatically reverse engineering the error\n    // format string in V8.\n    //\n    // So the error message from V8 is turned into this regular expression:\n    //\n    // \"Cannot call method '(.*)' of null\"\n    //\n    // Similarly, if we evaluate:\n    //\n    // var $expr$ = {toString: function() { return '$receiver$'; }};\n    // $expr$.$method$()\n    //\n    // We get this message: \"Object $receiver$ has no method '$method$'\"\n    //\n    // Which is turned into this regular expression:\n    //\n    // \"Object (.*) has no method '(.*)'\"\n    //\n    // Firefox/jsshell is slightly different, it tries to include the source\n    // code that caused the exception, so we get this message: \"$expr$.$method$\n    // is not a function\" which is turned into this regular expression:\n    //\n    // \"(.*)\\\\.(.*) is not a function\"\n\n    var function = JS('', r\"\"\"function($expr$) {\n  var $argumentsExpr$ = '$arguments$';\n  try {\n    $expr$.$method$($argumentsExpr$);\n  } catch (e) {\n    return e.message;\n  }\n}\"\"\");\n    return JS('String', '(#)(#)', function, expression);\n  }\n\n  /// Similar to [provokeCallErrorOn], but provokes an error directly on\n  /// literal \"null\" expression.\n  static String provokeCallErrorOnNull() {\n    // See [provokeCallErrorOn] for a detailed explanation.\n    var function = JS('', r\"\"\"function() {\n  var $argumentsExpr$ = '$arguments$';\n  try {\n    null.$method$($argumentsExpr$);\n  } catch (e) {\n    return e.message;\n  }\n}\"\"\");\n    return JS('String', '(#)()', function);\n  }\n\n  /// Similar to [provokeCallErrorOnNull], but provokes an error directly on\n  /// (void 0), that is, \"undefined\".\n  static String provokeCallErrorOnUndefined() {\n    // See [provokeCallErrorOn] for a detailed explanation.\n    var function = JS('', r\"\"\"function() {\n  var $argumentsExpr$ = '$arguments$';\n  try {\n    (void 0).$method$($argumentsExpr$);\n  } catch (e) {\n    return e.message;\n  }\n}\"\"\");\n    return JS('String', '(#)()', function);\n  }\n\n  /// Similar to [provokeCallErrorOn], but provokes a property access\n  /// error.\n  static String provokePropertyErrorOn(expression) {\n    // See [provokeCallErrorOn] for a detailed explanation.\n    var function = JS('', r\"\"\"function($expr$) {\n  try {\n    $expr$.$method$;\n  } catch (e) {\n    return e.message;\n  }\n}\"\"\");\n    return JS('String', '(#)(#)', function, expression);\n  }\n\n  /// Similar to [provokePropertyErrorOn], but provokes an property access\n  /// error directly on literal \"null\" expression.\n  static String provokePropertyErrorOnNull() {\n    // See [provokeCallErrorOn] for a detailed explanation.\n    var function = JS('', r\"\"\"function() {\n  try {\n    null.$method$;\n  } catch (e) {\n    return e.message;\n  }\n}\"\"\");\n    return JS('String', '(#)()', function);\n  }\n\n  /// Similar to [provokePropertyErrorOnNull], but provokes an property access\n  /// error directly on (void 0), that is, \"undefined\".\n  static String provokePropertyErrorOnUndefined() {\n    // See [provokeCallErrorOn] for a detailed explanation.\n    var function = JS('', r\"\"\"function() {\n  try {\n    (void 0).$method$;\n  } catch (e) {\n    return e.message;\n  }\n}\"\"\");\n    return JS('String', '(#)()', function);\n  }\n}\n\nclass NullError extends Error implements NoSuchMethodError {\n  final String _message;\n  final String _method;\n\n  NullError(this._message, match)\n      : _method = match == null ? null : JS('', '#.method', match);\n\n  String toString() {\n    if (_method == null) return 'NullError: $_message';\n    return 'NullError: Cannot call \"$_method\" on null';\n  }\n}\n\nclass JsNoSuchMethodError extends Error implements NoSuchMethodError {\n  final String _message;\n  final String _method;\n  final String _receiver;\n\n  JsNoSuchMethodError(this._message, match)\n      : _method = match == null ? null : JS('String|Null', '#.method', match),\n        _receiver =\n            match == null ? null : JS('String|Null', '#.receiver', match);\n\n  String toString() {\n    if (_method == null) return 'NoSuchMethodError: $_message';\n    if (_receiver == null) {\n      return 'NoSuchMethodError: Cannot call \"$_method\" ($_message)';\n    }\n    return 'NoSuchMethodError: Cannot call \"$_method\" on \"$_receiver\" '\n        '($_message)';\n  }\n}\n\nclass UnknownJsTypeError extends Error {\n  final String _message;\n\n  UnknownJsTypeError(this._message);\n\n  String toString() => _message.isEmpty ? 'Error' : 'Error: $_message';\n}\n\n/**\n * Called from catch blocks in generated code to extract the Dart\n * exception from the thrown value. The thrown value may have been\n * created by [wrapException] or it may be a 'native' JS exception.\n *\n * Some native exceptions are mapped to new Dart instances, others are\n * returned unmodified.\n */\nunwrapException(ex) {\n  /// If error implements Error, save [ex] in [error.$thrownJsError].\n  /// Otherwise, do nothing. Later, the stack trace can then be extraced from\n  /// [ex].\n  saveStackTrace(error) {\n    if (error is Error) {\n      var thrownStackTrace = JS('', r'#.$thrownJsError', error);\n      if (thrownStackTrace == null) {\n        JS('void', r'#.$thrownJsError = #', error, ex);\n      }\n    }\n    return error;\n  }\n\n  // Note that we are checking if the object has the property. If it\n  // has, it could be set to null if the thrown value is null.\n  if (ex == null) return null;\n  if (JS('bool', 'typeof # !== \"object\"', ex)) return ex;\n\n  if (JS('bool', r'\"dartException\" in #', ex)) {\n    return saveStackTrace(JS('', r'#.dartException', ex));\n  } else if (!JS('bool', r'\"message\" in #', ex)) {\n    return ex;\n  }\n\n  // Grab hold of the exception message. This field is available on\n  // all supported browsers.\n  var message = JS('var', r'#.message', ex);\n\n  // Internet Explorer has an error number.  This is the most reliable way to\n  // detect specific errors, so check for this first.\n  if (JS('bool', '\"number\" in #', ex)\n      && JS('bool', 'typeof #.number == \"number\"', ex)) {\n    int number = JS('int', '#.number', ex);\n\n    // From http://msdn.microsoft.com/en-us/library/ie/hc53e755(v=vs.94).aspx\n    // \"number\" is a 32-bit word. The error code is the low 16 bits, and the\n    // facility code is the upper 16 bits.\n    var ieErrorCode = number & 0xffff;\n    var ieFacilityNumber = (number >> 16) & 0x1fff;\n\n    // http://msdn.microsoft.com/en-us/library/aa264975(v=vs.60).aspx\n    // http://msdn.microsoft.com/en-us/library/ie/1dk3k160(v=vs.94).aspx\n    if (ieFacilityNumber == 10) {\n      switch (ieErrorCode) {\n      case 438:\n        return saveStackTrace(\n            new JsNoSuchMethodError('$message (Error $ieErrorCode)', null));\n      case 445:\n      case 5007:\n        return saveStackTrace(\n            new NullError('$message (Error $ieErrorCode)', null));\n      }\n    }\n  }\n\n  if (JS('bool', r'# instanceof TypeError', ex)) {\n    var match;\n    // Using JS to give type hints to the compiler to help tree-shaking.\n    // TODO(ahe): That should be unnecessary due to type inference.\n    var nsme =\n        JS('TypeErrorDecoder', '#', TypeErrorDecoder.noSuchMethodPattern);\n    var notClosure =\n        JS('TypeErrorDecoder', '#', TypeErrorDecoder.notClosurePattern);\n    var nullCall =\n        JS('TypeErrorDecoder', '#', TypeErrorDecoder.nullCallPattern);\n    var nullLiteralCall =\n        JS('TypeErrorDecoder', '#', TypeErrorDecoder.nullLiteralCallPattern);\n    var undefCall =\n        JS('TypeErrorDecoder', '#', TypeErrorDecoder.undefinedCallPattern);\n    var undefLiteralCall =\n        JS('TypeErrorDecoder', '#',\n           TypeErrorDecoder.undefinedLiteralCallPattern);\n    var nullProperty =\n        JS('TypeErrorDecoder', '#', TypeErrorDecoder.nullPropertyPattern);\n    var nullLiteralProperty =\n        JS('TypeErrorDecoder', '#',\n           TypeErrorDecoder.nullLiteralPropertyPattern);\n    var undefProperty =\n        JS('TypeErrorDecoder', '#', TypeErrorDecoder.undefinedPropertyPattern);\n    var undefLiteralProperty =\n        JS('TypeErrorDecoder', '#',\n           TypeErrorDecoder.undefinedLiteralPropertyPattern);\n    if ((match = nsme.matchTypeError(message)) != null) {\n      return saveStackTrace(new JsNoSuchMethodError(message, match));\n    } else if ((match = notClosure.matchTypeError(message)) != null) {\n      // notClosure may match \"({c:null}).c()\" or \"({c:1}).c()\", so we\n      // cannot tell if this an attempt to invoke call on null or a\n      // non-function object.\n      // But we do know the method name is \"call\".\n      JS('', '#.method = \"call\"', match);\n      return saveStackTrace(new JsNoSuchMethodError(message, match));\n    } else if ((match = nullCall.matchTypeError(message)) != null ||\n               (match = nullLiteralCall.matchTypeError(message)) != null ||\n               (match = undefCall.matchTypeError(message)) != null ||\n               (match = undefLiteralCall.matchTypeError(message)) != null ||\n               (match = nullProperty.matchTypeError(message)) != null ||\n               (match = nullLiteralCall.matchTypeError(message)) != null ||\n               (match = undefProperty.matchTypeError(message)) != null ||\n               (match = undefLiteralProperty.matchTypeError(message)) != null) {\n      return saveStackTrace(new NullError(message, match));\n    }\n\n    // If we cannot determine what kind of error this is, we fall back\n    // to reporting this as a generic error. It's probably better than\n    // nothing.\n    return saveStackTrace(\n        new UnknownJsTypeError(message is String ? message : ''));\n  }\n\n  if (JS('bool', r'# instanceof RangeError', ex)) {\n    if (message is String && contains(message, 'call stack')) {\n      return new StackOverflowError();\n    }\n\n    // In general, a RangeError is thrown when trying to pass a number\n    // as an argument to a function that does not allow a range that\n    // includes that number.\n    return saveStackTrace(new ArgumentError());\n  }\n\n  // Check for the Firefox specific stack overflow signal.\n  if (JS('bool',\n         r'typeof InternalError == \"function\" && # instanceof InternalError',\n         ex)) {\n    if (message is String && message == 'too much recursion') {\n      return new StackOverflowError();\n    }\n  }\n\n  // Just return the exception. We should not wrap it because in case\n  // the exception comes from the DOM, it is a JavaScript\n  // object backed by a native Dart class.\n  return ex;\n}\n\n/**\n * Called by generated code to fetch the stack trace from an\n * exception. Should never return null.\n */\nStackTrace getTraceFromException(exception) => new _StackTrace(exception);\n\nclass _StackTrace implements StackTrace {\n  var _exception;\n  String _trace;\n  _StackTrace(this._exception);\n\n  String toString() {\n    if (_trace != null) return _trace;\n\n    String trace;\n    if (JS('bool', 'typeof # === \"object\"', _exception)) {\n      trace = JS(\"String|Null\", r\"#.stack\", _exception);\n    }\n    return _trace = (trace == null) ? '' : trace;\n  }\n}\n\nint objectHashCode(var object) {\n  if (object == null || JS('bool', \"typeof # != 'object'\", object)) {\n    return object.hashCode;\n  } else {\n    return Primitives.objectHashCode(object);\n  }\n}\n\n/**\n * Called by generated code to build a map literal. [keyValuePairs] is\n * a list of key, value, key, value, ..., etc.\n */\nfillLiteralMap(keyValuePairs, Map result) {\n  // TODO(johnniwinther): Use JSArray to optimize this code instead of calling\n  // [getLength] and [getIndex].\n  int index = 0;\n  int length = getLength(keyValuePairs);\n  while (index < length) {\n    var key = getIndex(keyValuePairs, index++);\n    var value = getIndex(keyValuePairs, index++);\n    result[key] = value;\n  }\n  return result;\n}\n\ninvokeClosure(Function closure,\n              var isolate,\n              int numberOfArguments,\n              var arg1,\n              var arg2,\n              var arg3,\n              var arg4) {\n  if (numberOfArguments == 0) {\n    return JS_CALL_IN_ISOLATE(isolate, () => closure());\n  } else if (numberOfArguments == 1) {\n    return JS_CALL_IN_ISOLATE(isolate, () => closure(arg1));\n  } else if (numberOfArguments == 2) {\n    return JS_CALL_IN_ISOLATE(isolate, () => closure(arg1, arg2));\n  } else if (numberOfArguments == 3) {\n    return JS_CALL_IN_ISOLATE(isolate, () => closure(arg1, arg2, arg3));\n  } else if (numberOfArguments == 4) {\n    return JS_CALL_IN_ISOLATE(isolate, () => closure(arg1, arg2, arg3, arg4));\n  } else {\n    throw new Exception(\n        'Unsupported number of arguments for wrapped closure');\n  }\n}\n\n/**\n * Called by generated code to convert a Dart closure to a JS\n * closure when the Dart closure is passed to the DOM.\n */\nconvertDartClosureToJS(closure, int arity) {\n  if (closure == null) return null;\n  var function = JS('var', r'#.$identity', closure);\n  if (JS('bool', r'!!#', function)) return function;\n\n  // We use $0 and $1 to not clash with variable names used by the\n  // compiler and/or minifier.\n  function = JS('var',\n                '(function(closure, arity, context, invoke) {'\n                '  return function(a1, a2, a3, a4) {'\n                '     return invoke(closure, context, arity, a1, a2, a3, a4);'\n                '  };'\n                '})(#,#,#,#)',\n                closure,\n                arity,\n                // Capture the current isolate now.  Remember that \"#\"\n                // in JS is simply textual substitution of compiled\n                // expressions.\n                JS_CURRENT_ISOLATE_CONTEXT(),\n                DART_CLOSURE_TO_JS(invokeClosure));\n\n  JS('void', r'#.$identity = #', closure, function);\n  return function;\n}\n\n/**\n * Super class for Dart closures.\n */\nabstract class Closure implements Function {\n  // TODO(ahe): These constants must be in sync with\n  // reflection_data_parser.dart.\n  static const FUNCTION_INDEX = 0;\n  static const NAME_INDEX = 1;\n  static const CALL_NAME_INDEX = 2;\n  static const REQUIRED_PARAMETER_INDEX = 3;\n  static const OPTIONAL_PARAMETER_INDEX = 4;\n  static const DEFAULT_ARGUMENTS_INDEX = 5;\n\n  /**\n   * Global counter to prevent reusing function code objects.\n   *\n   * V8 will share the underlying function code objects when the same string is\n   * passed to \"new Function\".  Shared function code objects can lead to\n   * sub-optimal performance due to polymorhism, and can be prevented by\n   * ensuring the strings are different.\n   */\n  static int functionCounter = 0;\n\n  Closure();\n\n  /**\n   * Creates a new closure class for use by implicit getters associated with a\n   * method.\n   *\n   * In other words, creates a tear-off closure.\n   *\n   * Called from [closureFromTearOff] as well as from reflection when tearing\n   * of a method via [:getField:].\n   *\n   * This method assumes that [functions] was created by the JavaScript function\n   * `addStubs` in `reflection_data_parser.dart`. That is, a list of JavaScript\n   * function objects with properties `$stubName` and `$callName`.\n   *\n   * Further assumes that [reflectionInfo] is the end of the array created by\n   * [dart2js.js_emitter.ContainerBuilder.addMemberMethod] starting with\n   * required parameter count.\n   *\n   * Caution: this function may be called when building constants.\n   * TODO(ahe): Don't call this function when building constants.\n   */\n  static fromTearOff(receiver,\n                     List functions,\n                     List reflectionInfo,\n                     bool isStatic,\n                     jsArguments,\n                     String propertyName) {\n    JS_EFFECT(() {\n      BoundClosure.receiverOf(JS('BoundClosure', 'void 0'));\n      BoundClosure.selfOf(JS('BoundClosure', 'void 0'));\n    });\n    // TODO(ahe): All the place below using \\$ should be rewritten to go\n    // through the namer.\n    var function = JS('', '#[#]', functions, 0);\n    String name = JS('String|Null', '#.\\$stubName', function);\n    String callName = JS('String|Null', '#.\\$callName', function);\n\n    JS('', '#.\\$reflectionInfo = #', function, reflectionInfo);\n    ReflectionInfo info = new ReflectionInfo(function);\n\n    var functionType = info.functionType;\n\n    // function tmp() {};\n    // tmp.prototype = BC.prototype;\n    // var proto = new tmp;\n    // for each computed prototype property:\n    //   proto[property] = ...;\n    // proto._init = BC;\n    // var dynClosureConstructor =\n    //     new Function('self', 'target', 'receiver', 'name',\n    //                  'this._init(self, target, receiver, name)');\n    // proto.constructor = dynClosureConstructor; // Necessary?\n    // dynClosureConstructor.prototype = proto;\n    // return dynClosureConstructor;\n\n    // We need to create a new subclass of either TearOffClosure or\n    // BoundClosure.  For this, we need to create an object whose prototype is\n    // the prototype is either TearOffClosure.prototype or\n    // BoundClosure.prototype, respectively in pseudo JavaScript code. The\n    // simplest way to access the JavaScript construction function of a Dart\n    // class is to create an instance and access its constructor property.  The\n    // newly created instance could in theory be used directly as the\n    // prototype, but it might include additional fields that we don't need.\n    // So we only use the new instance to access the constructor property and\n    // use Object.create to create the desired prototype.\n    var prototype = isStatic\n        // TODO(ahe): Safe to use Object.create?\n        ? JS('TearOffClosure', 'Object.create(#.constructor.prototype)',\n             new TearOffClosure())\n        : JS('BoundClosure', 'Object.create(#.constructor.prototype)',\n             new BoundClosure(null, null, null, null));\n\n    JS('', '#.\\$initialize = #', prototype, JS('', '#.constructor', prototype));\n    var constructor = isStatic\n        ? JS('', 'function(){this.\\$initialize()}')\n        : isCsp\n            ? JS('', 'function(a,b,c,d) {this.\\$initialize(a,b,c,d)}')\n            : JS('',\n                 'new Function(\"a\",\"b\",\"c\",\"d\",'\n                     '\"this.\\$initialize(a,b,c,d);\"+#)',\n                 functionCounter++);\n\n    // TODO(ahe): Is it necessary to set the constructor property?\n    JS('', '#.constructor = #', prototype, constructor);\n\n    JS('', '#.prototype = #', constructor, prototype);\n\n    // Create a closure and \"monkey\" patch it with call stubs.\n    var trampoline = function;\n    var isIntercepted = false;\n    if (!isStatic) {\n      if (JS('bool', '#.length == 1', jsArguments)) {\n        // Intercepted call.\n        isIntercepted = true;\n      }\n      trampoline = forwardCallTo(receiver, function, isIntercepted);\n      JS('', '#.\\$reflectionInfo = #', trampoline, reflectionInfo);\n    } else {\n      JS('', '#.\\$name = #', prototype, propertyName);\n    }\n\n    var signatureFunction;\n    if (JS('bool', 'typeof # == \"number\"', functionType)) {\n      signatureFunction =\n          JS('', '(function(s){return function(){return init.metadata[s]}})(#)',\n             functionType);\n    } else if (!isStatic\n               && JS('bool', 'typeof # == \"function\"', functionType)) {\n      var getReceiver = isIntercepted\n          ? RAW_DART_FUNCTION_REF(BoundClosure.receiverOf)\n          : RAW_DART_FUNCTION_REF(BoundClosure.selfOf);\n      signatureFunction = JS(\n        '',\n        'function(f,r){'\n          'return function(){'\n            'return f.apply({\\$receiver:r(this)},arguments)'\n          '}'\n        '}(#,#)', functionType, getReceiver);\n    } else {\n      throw 'Error in reflectionInfo.';\n    }\n\n    JS('', '#.\\$signature = #', prototype, signatureFunction);\n\n    JS('', '#[#] = #', prototype, callName, trampoline);\n    for (int i = 1; i < functions.length; i++) {\n      var stub = functions[i];\n      var stubCallName = JS('String|Null', '#.\\$callName', stub);\n      if (stubCallName != null) {\n        JS('', '#[#] = #', prototype, stubCallName,\n           isStatic ? stub : forwardCallTo(receiver, stub, isIntercepted));\n      }\n    }\n\n    JS('', '#[\"call*\"] = #', prototype, trampoline);\n\n    return constructor;\n  }\n\n  static cspForwardCall(int arity, bool isSuperCall, String stubName,\n                        function) {\n    var getSelf = RAW_DART_FUNCTION_REF(BoundClosure.selfOf);\n    // Handle intercepted stub-names with the default slow case.\n    if (isSuperCall) arity = -1;\n    switch (arity) {\n    case 0:\n      return JS(\n          '',\n          'function(n,S){'\n            'return function(){'\n              'return S(this)[n]()'\n            '}'\n          '}(#,#)', stubName, getSelf);\n    case 1:\n      return JS(\n          '',\n          'function(n,S){'\n            'return function(a){'\n              'return S(this)[n](a)'\n            '}'\n          '}(#,#)', stubName, getSelf);\n    case 2:\n      return JS(\n          '',\n          'function(n,S){'\n            'return function(a,b){'\n              'return S(this)[n](a,b)'\n            '}'\n          '}(#,#)', stubName, getSelf);\n    case 3:\n      return JS(\n          '',\n          'function(n,S){'\n            'return function(a,b,c){'\n              'return S(this)[n](a,b,c)'\n            '}'\n          '}(#,#)', stubName, getSelf);\n    case 4:\n      return JS(\n          '',\n          'function(n,S){'\n            'return function(a,b,c,d){'\n              'return S(this)[n](a,b,c,d)'\n            '}'\n          '}(#,#)', stubName, getSelf);\n    case 5:\n      return JS(\n          '',\n          'function(n,S){'\n            'return function(a,b,c,d,e){'\n              'return S(this)[n](a,b,c,d,e)'\n            '}'\n          '}(#,#)', stubName, getSelf);\n    default:\n      return JS(\n          '',\n          'function(f,s){'\n            'return function(){'\n              'return f.apply(s(this),arguments)'\n            '}'\n          '}(#,#)', function, getSelf);\n    }\n  }\n\n  static bool get isCsp => JS('bool', 'typeof dart_precompiled == \"function\"');\n\n  static forwardCallTo(receiver, function, bool isIntercepted) {\n    if (isIntercepted) return forwardInterceptedCallTo(receiver, function);\n    String stubName = JS('String|Null', '#.\\$stubName', function);\n    int arity = JS('int', '#.length', function);\n    var lookedUpFunction = JS(\"\", \"#[#]\", receiver, stubName);\n    // The receiver[stubName] may not be equal to the function if we try to\n    // forward to a super-method. Especially when we create a bound closure\n    // of a super-call we need to make sure that we don't forward back to the\n    // dynamically looked up function.\n    bool isSuperCall = !identical(function, lookedUpFunction);\n\n    if (isCsp || isSuperCall || arity >= 27) {\n      return cspForwardCall(arity, isSuperCall, stubName, function);\n    }\n\n    if (arity == 0) {\n      return JS(\n          '',\n          '(new Function(#))()',\n          'return function(){'\n            'return this.${BoundClosure.selfFieldName()}.$stubName();'\n            '${functionCounter++}'\n          '}');\n    }\n    assert (1 <= arity && arity < 27);\n    String arguments = JS(\n        'String',\n        '\"abcdefghijklmnopqrstuvwxyz\".split(\"\").splice(0,#).join(\",\")',\n        arity);\n    return JS(\n        '',\n        '(new Function(#))()',\n        'return function($arguments){'\n          'return this.${BoundClosure.selfFieldName()}.$stubName($arguments);'\n          '${functionCounter++}'\n        '}');\n  }\n\n  static cspForwardInterceptedCall(int arity, bool isSuperCall,\n                                   String name, function) {\n    var getSelf = RAW_DART_FUNCTION_REF(BoundClosure.selfOf);\n    var getReceiver = RAW_DART_FUNCTION_REF(BoundClosure.receiverOf);\n    // Handle intercepted stub-names with the default slow case.\n    if (isSuperCall) arity = -1;\n    switch (arity) {\n    case 0:\n      // Intercepted functions always takes at least one argument (the\n      // receiver).\n      throw new RuntimeError('Intercepted function with no arguments.');\n    case 1:\n      return JS(\n          '',\n          'function(n,s,r){'\n            'return function(){'\n              'return s(this)[n](r(this))'\n            '}'\n          '}(#,#,#)', name, getSelf, getReceiver);\n    case 2:\n      return JS(\n          '',\n          'function(n,s,r){'\n            'return function(a){'\n              'return s(this)[n](r(this),a)'\n            '}'\n          '}(#,#,#)', name, getSelf, getReceiver);\n    case 3:\n      return JS(\n          '',\n          'function(n,s,r){'\n            'return function(a,b){'\n              'return s(this)[n](r(this),a,b)'\n            '}'\n          '}(#,#,#)', name, getSelf, getReceiver);\n    case 4:\n      return JS(\n          '',\n          'function(n,s,r){'\n            'return function(a,b,c){'\n              'return s(this)[n](r(this),a,b,c)'\n            '}'\n          '}(#,#,#)', name, getSelf, getReceiver);\n    case 5:\n      return JS(\n          '',\n          'function(n,s,r){'\n            'return function(a,b,c,d){'\n              'return s(this)[n](r(this),a,b,c,d)'\n            '}'\n          '}(#,#,#)', name, getSelf, getReceiver);\n    case 6:\n      return JS(\n          '',\n          'function(n,s,r){'\n            'return function(a,b,c,d,e){'\n              'return s(this)[n](r(this),a,b,c,d,e)'\n            '}'\n          '}(#,#,#)', name, getSelf, getReceiver);\n    default:\n      return JS(\n          '',\n          'function(f,s,r,a){'\n            'return function(){'\n              'a=[r(this)];'\n              'Array.prototype.push.apply(a,arguments);'\n              'return f.apply(s(this),a)'\n            '}'\n          '}(#,#,#)', function, getSelf, getReceiver);\n    }\n  }\n\n  static forwardInterceptedCallTo(receiver, function) {\n    String selfField = BoundClosure.selfFieldName();\n    String receiverField = BoundClosure.receiverFieldName();\n    String stubName = JS('String|Null', '#.\\$stubName', function);\n    int arity = JS('int', '#.length', function);\n    bool isCsp = JS('bool', 'typeof dart_precompiled == \"function\"');\n    var lookedUpFunction = JS(\"\", \"#[#]\", receiver, stubName);\n    // The receiver[stubName] may not be equal to the function if we try to\n    // forward to a super-method. Especially when we create a bound closure\n    // of a super-call we need to make sure that we don't forward back to the\n    // dynamically looked up function.\n    bool isSuperCall = !identical(function, lookedUpFunction);\n\n    if (isCsp || isSuperCall || arity >= 28) {\n      return cspForwardInterceptedCall(arity, isSuperCall, stubName,\n                                       function);\n    }\n    if (arity == 1) {\n      return JS(\n          '',\n          '(new Function(#))()',\n          'return function(){'\n            'return this.$selfField.$stubName(this.$receiverField);'\n            '${functionCounter++}'\n          '}');\n    }\n    assert(1 < arity && arity < 28);\n    String arguments = JS(\n        'String',\n        '\"abcdefghijklmnopqrstuvwxyz\".split(\"\").splice(0,#).join(\",\")',\n        arity - 1);\n    return JS(\n        '',\n        '(new Function(#))()',\n        'return function($arguments){'\n          'return this.$selfField.$stubName(this.$receiverField, $arguments);'\n          '${functionCounter++}'\n        '}');\n  }\n\n  // The backend adds a special getter of the form\n  //\n  // Closure get call => this;\n  //\n  // to allow tearing off a closure from itself. We do this magically in the\n  // backend rather than simply adding it here, as we do not want this getter\n  // to be visible to resolution and the generation of extra stubs.\n\n  String toString() => \"Closure\";\n}\n\n/// Called from implicit method getter (aka tear-off).\nclosureFromTearOff(receiver,\n                   functions,\n                   reflectionInfo,\n                   isStatic,\n                   jsArguments,\n                   name) {\n  return Closure.fromTearOff(\n      receiver,\n      JSArray.markFixedList(functions),\n      JSArray.markFixedList(reflectionInfo),\n      JS('bool', '!!#', isStatic),\n      jsArguments,\n      JS('String', '#', name));\n}\n\n/// Represents an implicit closure of a function.\nclass TearOffClosure extends Closure {\n}\n\n/// Represents a 'tear-off' closure, that is an instance method bound\n/// to a specific receiver (instance).\nclass BoundClosure extends TearOffClosure {\n  /// The receiver or interceptor.\n  // TODO(ahe): This could just be the interceptor, we always know if\n  // we need the interceptor when generating the call method.\n  final _self;\n\n  /// The method.\n  final _target;\n\n  /// The receiver. Null if [_self] is not an interceptor.\n  final _receiver;\n\n  /// The name of the function. Only used by the mirror system.\n  final String _name;\n\n  BoundClosure(this._self, this._target, this._receiver, this._name);\n\n  bool operator==(other) {\n    if (identical(this, other)) return true;\n    if (other is! BoundClosure) return false;\n    return JS('bool', '# === # && # === # && # === #',\n        _self, other._self,\n        _target, other._target,\n        _receiver, other._receiver);\n  }\n\n  int get hashCode {\n    int receiverHashCode;\n    if (_receiver == null) {\n      // A bound closure on a regular Dart object, just use the\n      // identity hash code.\n      receiverHashCode = Primitives.objectHashCode(_self);\n    } else if (JS('String', 'typeof #', _receiver) != 'object') {\n      // A bound closure on a primitive JavaScript type. We\n      // use the hashCode method we define for those primitive types.\n      receiverHashCode = _receiver.hashCode;\n    } else {\n      // A bound closure on an intercepted native class, just use the\n      // identity hash code.\n      receiverHashCode = Primitives.objectHashCode(_receiver);\n    }\n    return receiverHashCode ^ Primitives.objectHashCode(_target);\n  }\n\n  @NoInline()\n  static selfOf(BoundClosure closure) => closure._self;\n\n  static targetOf(BoundClosure closure) => closure._target;\n\n  @NoInline()\n  static receiverOf(BoundClosure closure) => closure._receiver;\n\n  static nameOf(BoundClosure closure) => closure._name;\n\n  static String selfFieldNameCache;\n\n  static String selfFieldName() {\n    if (selfFieldNameCache == null) {\n      selfFieldNameCache = computeFieldNamed('self');\n    }\n    return selfFieldNameCache;\n  }\n\n  static String receiverFieldNameCache;\n\n  static String receiverFieldName() {\n    if (receiverFieldNameCache == null) {\n      receiverFieldNameCache = computeFieldNamed('receiver');\n    }\n    return receiverFieldNameCache;\n  }\n\n  @NoInline() @NoSideEffects()\n  static String computeFieldNamed(String fieldName) {\n    var template = new BoundClosure('self', 'target', 'receiver', 'name');\n    var names = JSArray.markFixedList(\n        JS('', 'Object.getOwnPropertyNames(#)', template));\n    for (int i = 0; i < names.length; i++) {\n      var name = names[i];\n      if (JS('bool', '#[#] === #', template, name, fieldName)) {\n        return JS('String', '#', name);\n      }\n    }\n  }\n}\n\nbool jsHasOwnProperty(var jsObject, String property) {\n  return JS('bool', r'#.hasOwnProperty(#)', jsObject, property);\n}\n\njsPropertyAccess(var jsObject, String property) {\n  return JS('var', r'#[#]', jsObject, property);\n}\n\n/**\n * Called at the end of unaborted switch cases to get the singleton\n * FallThroughError exception that will be thrown.\n */\ngetFallThroughError() => new FallThroughErrorImplementation();\n\n/**\n * A metadata annotation describing the types instantiated by a native element.\n *\n * The annotation is valid on a native method and a field of a native class.\n *\n * By default, a field of a native class is seen as an instantiation point for\n * all native classes that are a subtype of the field's type, and a native\n * method is seen as an instantiation point fo all native classes that are a\n * subtype of the method's return type, or the argument types of the declared\n * type of the method's callback parameter.\n *\n * An @[Creates] annotation overrides the default set of instantiated types.  If\n * one or more @[Creates] annotations are present, the type of the native\n * element is ignored, and the union of @[Creates] annotations is used instead.\n * The names in the strings are resolved and the program will fail to compile\n * with dart2js if they do not name types.\n *\n * The argument to [Creates] is a string.  The string is parsed as the names of\n * one or more types, separated by vertical bars `|`.  There are some special\n * names:\n *\n * * `=Object`. This means 'exactly Object', which is a plain JavaScript object\n *   with properties and none of the subtypes of Object.\n *\n * Example: we may know that a method always returns a specific implementation:\n *\n *     @Creates('_NodeList')\n *     List<Node> getElementsByTagName(String tag) native;\n *\n * Useful trick: A method can be marked as not instantiating any native classes\n * with the annotation `@Creates('Null')`.  This is useful for fields on native\n * classes that are used only in Dart code.\n *\n *     @Creates('Null')\n *     var _cachedFoo;\n */\nclass Creates {\n  final String types;\n  const Creates(this.types);\n}\n\n/**\n * A metadata annotation describing the types returned or yielded by a native\n * element.\n *\n * The annotation is valid on a native method and a field of a native class.\n *\n * By default, a native method or field is seen as returning or yielding all\n * subtypes if the method return type or field type.  This annotation allows a\n * more precise set of types to be specified.\n *\n * See [Creates] for the syntax of the argument.\n *\n * Example: IndexedDB keys are numbers, strings and JavaScript Arrays of keys.\n *\n *     @Returns('String|num|JSExtendableArray')\n *     dynamic key;\n *\n *     // Equivalent:\n *     @Returns('String') @Returns('num') @Returns('JSExtendableArray')\n *     dynamic key;\n */\nclass Returns {\n  final String types;\n  const Returns(this.types);\n}\n\n/**\n * A metadata annotation placed on native methods and fields of native classes\n * to specify the JavaScript name.\n *\n * This example declares a Dart field + getter + setter called `$dom_title` that\n * corresponds to the JavaScript property `title`.\n *\n *     class Docmument native \"*Foo\" {\n *       @JSName('title')\n *       String $dom_title;\n *     }\n */\nclass JSName {\n  final String name;\n  const JSName(this.name);\n}\n\n/**\n * The following methods are called by the runtime to implement\n * checked mode and casts. We specialize each primitive type (eg int, bool), and\n * use the compiler's convention to do is-checks on regular objects.\n */\nboolConversionCheck(value) {\n  if (value is bool) return value;\n  // One of the following checks will always fail.\n  boolTypeCheck(value);\n  assert(value != null);\n  return false;\n}\n\nstringTypeCheck(value) {\n  if (value == null) return value;\n  if (value is String) return value;\n  throw new TypeErrorImplementation(value, 'String');\n}\n\nstringTypeCast(value) {\n  if (value is String || value == null) return value;\n  // TODO(lrn): When reified types are available, pass value.class and String.\n  throw new CastErrorImplementation(\n      Primitives.objectTypeName(value), 'String');\n}\n\ndoubleTypeCheck(value) {\n  if (value == null) return value;\n  if (value is double) return value;\n  throw new TypeErrorImplementation(value, 'double');\n}\n\ndoubleTypeCast(value) {\n  if (value is double || value == null) return value;\n  throw new CastErrorImplementation(\n      Primitives.objectTypeName(value), 'double');\n}\n\nnumTypeCheck(value) {\n  if (value == null) return value;\n  if (value is num) return value;\n  throw new TypeErrorImplementation(value, 'num');\n}\n\nnumTypeCast(value) {\n  if (value is num || value == null) return value;\n  throw new CastErrorImplementation(\n      Primitives.objectTypeName(value), 'num');\n}\n\nboolTypeCheck(value) {\n  if (value == null) return value;\n  if (value is bool) return value;\n  throw new TypeErrorImplementation(value, 'bool');\n}\n\nboolTypeCast(value) {\n  if (value is bool || value == null) return value;\n  throw new CastErrorImplementation(\n      Primitives.objectTypeName(value), 'bool');\n}\n\nintTypeCheck(value) {\n  if (value == null) return value;\n  if (value is int) return value;\n  throw new TypeErrorImplementation(value, 'int');\n}\n\nintTypeCast(value) {\n  if (value is int || value == null) return value;\n  throw new CastErrorImplementation(\n      Primitives.objectTypeName(value), 'int');\n}\n\nvoid propertyTypeError(value, property) {\n  // Cuts the property name to the class name.\n  String name = property.substring(3, property.length);\n  throw new TypeErrorImplementation(value, name);\n}\n\nvoid propertyTypeCastError(value, property) {\n  // Cuts the property name to the class name.\n  String actualType = Primitives.objectTypeName(value);\n  String expectedType = property.substring(3, property.length);\n  throw new CastErrorImplementation(actualType, expectedType);\n}\n\n/**\n * For types that are not supertypes of native (eg DOM) types,\n * we emit a simple property check to check that an object implements\n * that type.\n */\npropertyTypeCheck(value, property) {\n  if (value == null) return value;\n  if (JS('bool', '!!#[#]', value, property)) return value;\n  propertyTypeError(value, property);\n}\n\n/**\n * For types that are not supertypes of native (eg DOM) types,\n * we emit a simple property check to check that an object implements\n * that type.\n */\npropertyTypeCast(value, property) {\n  if (value == null || JS('bool', '!!#[#]', value, property)) return value;\n  propertyTypeCastError(value, property);\n}\n\n/**\n * For types that are supertypes of native (eg DOM) types, we use the\n * interceptor for the class because we cannot add a JS property to the\n * prototype at load time.\n */\ninterceptedTypeCheck(value, property) {\n  if (value == null) return value;\n  if ((identical(JS('String', 'typeof #', value), 'object'))\n      && JS('bool', '#[#]', getInterceptor(value), property)) {\n    return value;\n  }\n  propertyTypeError(value, property);\n}\n\n/**\n * For types that are supertypes of native (eg DOM) types, we use the\n * interceptor for the class because we cannot add a JS property to the\n * prototype at load time.\n */\ninterceptedTypeCast(value, property) {\n  if (value == null\n      || ((JS('bool', 'typeof # === \"object\"', value))\n          && JS('bool', '#[#]', getInterceptor(value), property))) {\n    return value;\n  }\n  propertyTypeCastError(value, property);\n}\n\n/**\n * Specialization of the type check for num and String and their\n * supertype since [value] can be a JS primitive.\n */\nnumberOrStringSuperTypeCheck(value, property) {\n  if (value == null) return value;\n  if (value is String) return value;\n  if (value is num) return value;\n  if (JS('bool', '!!#[#]', value, property)) return value;\n  propertyTypeError(value, property);\n}\n\nnumberOrStringSuperTypeCast(value, property) {\n  if (value is String) return value;\n  if (value is num) return value;\n  return propertyTypeCast(value, property);\n}\n\nnumberOrStringSuperNativeTypeCheck(value, property) {\n  if (value == null) return value;\n  if (value is String) return value;\n  if (value is num) return value;\n  if (JS('bool', '#[#]', getInterceptor(value), property)) return value;\n  propertyTypeError(value, property);\n}\n\nnumberOrStringSuperNativeTypeCast(value, property) {\n  if (value == null) return value;\n  if (value is String) return value;\n  if (value is num) return value;\n  if (JS('bool', '#[#]', getInterceptor(value), property)) return value;\n  propertyTypeCastError(value, property);\n}\n\n/**\n * Specialization of the type check for String and its supertype\n * since [value] can be a JS primitive.\n */\nstringSuperTypeCheck(value, property) {\n  if (value == null) return value;\n  if (value is String) return value;\n  if (JS('bool', '!!#[#]', value, property)) return value;\n  propertyTypeError(value, property);\n}\n\nstringSuperTypeCast(value, property) {\n  if (value is String) return value;\n  return propertyTypeCast(value, property);\n}\n\nstringSuperNativeTypeCheck(value, property) {\n  if (value == null) return value;\n  if (value is String) return value;\n  if (JS('bool', '#[#]', getInterceptor(value), property)) return value;\n  propertyTypeError(value, property);\n}\n\nstringSuperNativeTypeCast(value, property) {\n  if (value is String || value == null) return value;\n  if (JS('bool', '#[#]', getInterceptor(value), property)) return value;\n  propertyTypeCastError(value, property);\n}\n\n/**\n * Specialization of the type check for List and its supertypes,\n * since [value] can be a JS array.\n */\nlistTypeCheck(value) {\n  if (value == null) return value;\n  if (value is List) return value;\n  throw new TypeErrorImplementation(value, 'List');\n}\n\nlistTypeCast(value) {\n  if (value is List || value == null) return value;\n  throw new CastErrorImplementation(\n      Primitives.objectTypeName(value), 'List');\n}\n\nlistSuperTypeCheck(value, property) {\n  if (value == null) return value;\n  if (value is List) return value;\n  if (JS('bool', '!!#[#]', value, property)) return value;\n  propertyTypeError(value, property);\n}\n\nlistSuperTypeCast(value, property) {\n  if (value is List) return value;\n  return propertyTypeCast(value, property);\n}\n\nlistSuperNativeTypeCheck(value, property) {\n  if (value == null) return value;\n  if (value is List) return value;\n  if (JS('bool', '#[#]', getInterceptor(value), property)) return value;\n  propertyTypeError(value, property);\n}\n\nlistSuperNativeTypeCast(value, property) {\n  if (value is List || value == null) return value;\n  if (JS('bool', '#[#]', getInterceptor(value), property)) return value;\n  propertyTypeCastError(value, property);\n}\n\nvoidTypeCheck(value) {\n  if (value == null) return value;\n  throw new TypeErrorImplementation(value, 'void');\n}\n\ncheckMalformedType(value, message) {\n  if (value == null) return value;\n  throw new TypeErrorImplementation.fromMessage(message);\n}\n\n@NoInline()\nvoid checkDeferredIsLoaded(String loadId, String uri) {\n  if (!_loadedLibraries.contains(loadId)) {\n    throw new DeferredNotLoadedError(uri);\n  }\n}\n\n/**\n * Special interface recognized by the compiler and implemented by DOM\n * objects that support integer indexing. This interface is not\n * visible to anyone, and is only injected into special libraries.\n */\nabstract class JavaScriptIndexingBehavior extends JSMutableIndexable {\n}\n\n// TODO(lrn): These exceptions should be implemented in core.\n// When they are, remove the 'Implementation' here.\n\n/** Thrown by type assertions that fail. */\nclass TypeErrorImplementation extends Error implements TypeError {\n  final String message;\n\n  /**\n   * Normal type error caused by a failed subtype test.\n   */\n  TypeErrorImplementation(Object value, String type)\n      : message = \"type '${Primitives.objectTypeName(value)}' is not a subtype \"\n                  \"of type '$type'\";\n\n  TypeErrorImplementation.fromMessage(String this.message);\n\n  String toString() => message;\n}\n\n/** Thrown by the 'as' operator if the cast isn't valid. */\nclass CastErrorImplementation extends Error implements CastError {\n  // TODO(lrn): Rename to CastError (and move implementation into core).\n  final String message;\n\n  /**\n   * Normal cast error caused by a failed type cast.\n   */\n  CastErrorImplementation(Object actualType, Object expectedType)\n      : message = \"CastError: Casting value of type $actualType to\"\n                  \" incompatible type $expectedType\";\n\n  String toString() => message;\n}\n\nclass FallThroughErrorImplementation extends FallThroughError {\n  FallThroughErrorImplementation();\n  String toString() => \"Switch case fall-through.\";\n}\n\n/**\n * Helper function for implementing asserts. The compiler treats this specially.\n */\nvoid assertHelper(condition) {\n  // Do a bool check first because it is common and faster than 'is Function'.\n  if (condition is !bool) {\n    if (condition is Function) condition = condition();\n    if (condition is !bool) {\n      throw new TypeErrorImplementation(condition, 'bool');\n    }\n  }\n  // Compare to true to avoid boolean conversion check in checked\n  // mode.\n  if (true != condition) throw new AssertionError();\n}\n\n/**\n * Called by generated code when a method that must be statically\n * resolved cannot be found.\n */\nvoid throwNoSuchMethod(obj, name, arguments, expectedArgumentNames) {\n  Symbol memberName = new _symbol_dev.Symbol.unvalidated(name);\n  throw new NoSuchMethodError(obj, memberName, arguments,\n                              new Map<Symbol, dynamic>(),\n                              expectedArgumentNames);\n}\n\n/**\n * Called by generated code when a static field's initializer references the\n * field that is currently being initialized.\n */\nvoid throwCyclicInit(String staticName) {\n  throw new CyclicInitializationError(\n      \"Cyclic initialization for static $staticName\");\n}\n\n/**\n * Error thrown when a runtime error occurs.\n */\nclass RuntimeError extends Error {\n  final message;\n  RuntimeError(this.message);\n  String toString() => \"RuntimeError: $message\";\n}\n\nclass DeferredNotLoadedError extends Error implements NoSuchMethodError {\n  String libraryName;\n\n  DeferredNotLoadedError(this.libraryName);\n\n  String toString() {\n    return \"Deferred library $libraryName was not loaded.\";\n  }\n}\n\nabstract class RuntimeType {\n  const RuntimeType();\n\n  toRti();\n}\n\nclass RuntimeFunctionType extends RuntimeType {\n  final RuntimeType returnType;\n  final List<RuntimeType> parameterTypes;\n  final List<RuntimeType> optionalParameterTypes;\n  final namedParameters;\n\n  static var /* bool */ inAssert = false;\n\n  RuntimeFunctionType(this.returnType,\n                      this.parameterTypes,\n                      this.optionalParameterTypes,\n                      this.namedParameters);\n\n  bool get isVoid => returnType is VoidRuntimeType;\n\n  /// Called from generated code. [expression] is a Dart object and this method\n  /// returns true if [this] is a supertype of [expression].\n  @NoInline() @NoSideEffects()\n  bool _isTest(expression) {\n    var functionTypeObject = _extractFunctionTypeObjectFrom(expression);\n    return functionTypeObject == null\n        ? false\n        : isFunctionSubtype(functionTypeObject, toRti());\n  }\n\n  @NoInline() @NoSideEffects()\n  _asCheck(expression) {\n    // Type inferrer doesn't think this is called with dynamic arguments.\n    return _check(JS('', '#', expression), true);\n  }\n\n  @NoInline() @NoSideEffects()\n  _assertCheck(expression) {\n    if (inAssert) return null;\n    inAssert = true; // Don't try to check this library itself.\n    try {\n      // Type inferrer don't think this is called with dynamic arguments.\n      return _check(JS('', '#', expression), false);\n    } finally {\n      inAssert = false;\n    }\n  }\n\n  _check(expression, bool isCast) {\n    if (expression == null) return null;\n    if (_isTest(expression)) return expression;\n\n    var self = new FunctionTypeInfoDecoderRing(toRti()).toString();\n    if (isCast) {\n      var functionTypeObject = _extractFunctionTypeObjectFrom(expression);\n      var pretty;\n      if (functionTypeObject != null) {\n        pretty = new FunctionTypeInfoDecoderRing(functionTypeObject).toString();\n      } else {\n        pretty = Primitives.objectTypeName(expression);\n      }\n      throw new CastErrorImplementation(pretty, self);\n    } else {\n      // TODO(ahe): Pass \"pretty\" function-type to TypeErrorImplementation?\n      throw new TypeErrorImplementation(expression, self);\n    }\n  }\n\n  _extractFunctionTypeObjectFrom(o) {\n    var interceptor = getInterceptor(o);\n    return JS('bool', '# in #', JS_SIGNATURE_NAME(), interceptor)\n        ? JS('', '#[#]()', interceptor, JS_SIGNATURE_NAME())\n        : null;\n  }\n\n  toRti() {\n    var result = JS('=Object', '{ #: \"dynafunc\" }', JS_FUNCTION_TYPE_TAG());\n    if (isVoid) {\n      JS('', '#[#] = true', result, JS_FUNCTION_TYPE_VOID_RETURN_TAG());\n    } else {\n      if (returnType is! DynamicRuntimeType) {\n        JS('', '#[#] = #', result, JS_FUNCTION_TYPE_RETURN_TYPE_TAG(),\n           returnType.toRti());\n      }\n    }\n    if (parameterTypes != null && !parameterTypes.isEmpty) {\n      JS('', '#[#] = #', result, JS_FUNCTION_TYPE_REQUIRED_PARAMETERS_TAG(),\n         listToRti(parameterTypes));\n    }\n\n    if (optionalParameterTypes != null && !optionalParameterTypes.isEmpty) {\n      JS('', '#[#] = #', result, JS_FUNCTION_TYPE_OPTIONAL_PARAMETERS_TAG(),\n         listToRti(optionalParameterTypes));\n    }\n\n    if (namedParameters != null) {\n      var namedRti = JS('=Object', '{}');\n      var keys = extractKeys(namedParameters);\n      for (var i = 0; i < keys.length; i++) {\n        var name = keys[i];\n        var rti = JS('', '#[#]', namedParameters, name).toRti();\n        JS('', '#[#] = #', namedRti, name, rti);\n      }\n      JS('', '#[#] = #', result, JS_FUNCTION_TYPE_NAMED_PARAMETERS_TAG(),\n         namedRti);\n    }\n\n    return result;\n  }\n\n  static listToRti(list) {\n    list = JS('JSFixedArray', '#', list);\n    var result = JS('JSExtendableArray', '[]');\n    for (var i = 0; i < list.length; i++) {\n      JS('', '#.push(#)', result, list[i].toRti());\n    }\n    return result;\n  }\n\n  String toString() {\n    String result = '(';\n    bool needsComma = false;\n    if (parameterTypes != null) {\n      for (var i = 0; i < parameterTypes.length; i++) {\n        RuntimeType type = parameterTypes[i];\n        if (needsComma) result += ', ';\n        result += '$type';\n        needsComma = true;\n      }\n    }\n    if (optionalParameterTypes != null && !optionalParameterTypes.isEmpty) {\n      if (needsComma) result += ', ';\n      needsComma = false;\n      result += '[';\n      for (var i = 0; i < optionalParameterTypes.length; i++) {\n        RuntimeType type = optionalParameterTypes[i];\n        if (needsComma) result += ', ';\n        result += '$type';\n        needsComma = true;\n      }\n      result += ']';\n    } else if (namedParameters != null) {\n      if (needsComma) result += ', ';\n      needsComma = false;\n      result += '{';\n      var keys = extractKeys(namedParameters);\n      for (var i = 0; i < keys.length; i++) {\n        var name = keys[i];\n        if (needsComma) result += ', ';\n        var rti = JS('', '#[#]', namedParameters, name).toRti();\n        result += '$rti ${JS(\"String\", \"#\", name)}';\n        needsComma = true;\n      }\n      result += '}';\n    }\n\n    result += ') -> $returnType';\n    return result;\n  }\n}\n\nRuntimeFunctionType buildFunctionType(returnType,\n                                      parameterTypes,\n                                      optionalParameterTypes) {\n  return new RuntimeFunctionType(\n      returnType,\n      parameterTypes,\n      optionalParameterTypes,\n      null);\n}\n\nRuntimeFunctionType buildNamedFunctionType(returnType,\n                                           parameterTypes,\n                                           namedParameters) {\n  return new RuntimeFunctionType(\n      returnType,\n      parameterTypes,\n      null,\n      namedParameters);\n}\n\nRuntimeType buildInterfaceType(rti, typeArguments) {\n  String name = JS('String|Null', r'#.name', rti);\n  if (typeArguments == null || typeArguments.isEmpty) {\n    return new RuntimeTypePlain(name);\n  }\n  return new RuntimeTypeGeneric(name, typeArguments, null);\n}\n\nclass DynamicRuntimeType extends RuntimeType {\n  const DynamicRuntimeType();\n\n  String toString() => 'dynamic';\n\n  toRti() => null;\n}\n\nRuntimeType getDynamicRuntimeType() => const DynamicRuntimeType();\n\nclass VoidRuntimeType extends RuntimeType {\n  const VoidRuntimeType();\n\n  String toString() => 'void';\n\n  toRti() => throw 'internal error';\n}\n\nRuntimeType getVoidRuntimeType() => const VoidRuntimeType();\n\n/**\n * Meta helper for function type tests.\n *\n * A \"meta helper\" is a helper function that is never called but simulates how\n * generated code behaves as far as resolution and type inference is concerned.\n */\nfunctionTypeTestMetaHelper() {\n  var dyn = JS('', 'x');\n  var dyn2 = JS('', 'x');\n  List fixedListOrNull = JS('JSFixedArray|Null', 'x');\n  List fixedListOrNull2 = JS('JSFixedArray|Null', 'x');\n  List fixedList = JS('JSFixedArray', 'x');\n  // TODO(ahe): Can we use [UnknownJavaScriptObject] below?\n  var /* UnknownJavaScriptObject */ jsObject = JS('=Object', 'x');\n\n  buildFunctionType(dyn, fixedListOrNull, fixedListOrNull2);\n  buildNamedFunctionType(dyn, fixedList, jsObject);\n  buildInterfaceType(dyn, fixedListOrNull);\n  getDynamicRuntimeType();\n  getVoidRuntimeType();\n  convertRtiToRuntimeType(dyn);\n  dyn._isTest(dyn2);\n  dyn._asCheck(dyn2);\n  dyn._assertCheck(dyn2);\n}\n\nRuntimeType convertRtiToRuntimeType(rti) {\n  if (rti == null) {\n    return getDynamicRuntimeType();\n  } else if (JS('bool', 'typeof # == \"function\"', rti)) {\n    return new RuntimeTypePlain(JS('String', r'rti.name'));\n  } else if (JS('bool', '#.constructor == Array', rti)) {\n    List list = JS('JSFixedArray', '#', rti);\n    String name = JS('String', r'#.name', list[0]);\n    List arguments = [];\n    for (int i = 1; i < list.length; i++) {\n      arguments.add(convertRtiToRuntimeType(list[i]));\n    }\n    return new RuntimeTypeGeneric(name, arguments, rti);\n  } else if (JS('bool', '\"func\" in #', rti)) {\n    return new FunctionTypeInfoDecoderRing(rti).toRuntimeType();\n  } else {\n    throw new RuntimeError(\n        \"Cannot convert \"\n        \"'${JS('String', 'JSON.stringify(#)', rti)}' to RuntimeType.\");\n  }\n}\n\nclass RuntimeTypePlain extends RuntimeType {\n  final String name;\n\n  RuntimeTypePlain(this.name);\n\n  toRti() {\n    var rti = JS('', 'init.allClasses[#]', name);\n    if (rti == null) throw \"no type for '$name'\";\n    return rti;\n  }\n\n  String toString() => name;\n}\n\nclass RuntimeTypeGeneric extends RuntimeType {\n  final String name;\n  final List<RuntimeType> arguments;\n  var rti;\n\n  RuntimeTypeGeneric(this.name, this.arguments, this.rti);\n\n  toRti() {\n    if (rti != null) return rti;\n    var result = JS('JSExtendableArray', '[init.allClasses[#]]', name);\n    if (result[0] == null) {\n      throw \"no type for '$name<...>'\";\n    }\n    for (RuntimeType argument in arguments) {\n      JS('', '#.push(#)', result, argument.toRti());\n    }\n    return rti = result;\n  }\n\n  String toString() => '$name<${arguments.join(\", \")}>';\n}\n\nclass FunctionTypeInfoDecoderRing {\n  final _typeData;\n  String _cachedToString;\n\n  FunctionTypeInfoDecoderRing(this._typeData);\n\n  bool get _hasReturnType => JS('bool', '\"ret\" in #', _typeData);\n  get _returnType => JS('', '#.ret', _typeData);\n\n  bool get _isVoid => JS('bool', '!!#.void', _typeData);\n\n  bool get _hasArguments => JS('bool', '\"args\" in #', _typeData);\n  List get _arguments => JS('JSExtendableArray', '#.args', _typeData);\n\n  bool get _hasOptionalArguments => JS('bool', '\"opt\" in #', _typeData);\n  List get _optionalArguments => JS('JSExtendableArray', '#.opt', _typeData);\n\n  bool get _hasNamedArguments => JS('bool', '\"named\" in #', _typeData);\n  get _namedArguments => JS('=Object', '#.named', _typeData);\n\n  RuntimeType toRuntimeType() {\n    // TODO(ahe): Implement this (and update return type).\n    return const DynamicRuntimeType();\n  }\n\n  String _convert(type) {\n    String result = runtimeTypeToString(type);\n    if (result != null) return result;\n    if (JS('bool', '\"func\" in #', type)) {\n      return new FunctionTypeInfoDecoderRing(type).toString();\n    } else {\n      throw 'bad type';\n    }\n  }\n\n  String toString() {\n    if (_cachedToString != null) return _cachedToString;\n    var s = \"(\";\n    var sep = '';\n    if (_hasArguments) {\n      for (var argument in _arguments) {\n        s += sep;\n        s += _convert(argument);\n        sep = ', ';\n      }\n    }\n    if (_hasOptionalArguments) {\n      s += '$sep[';\n      sep = '';\n      for (var argument in _optionalArguments) {\n        s += sep;\n        s += _convert(argument);\n        sep = ', ';\n      }\n      s += ']';\n    }\n    if (_hasNamedArguments) {\n      s += '$sep{';\n      sep = '';\n      for (var name in extractKeys(_namedArguments)) {\n        s += sep;\n        s += '$name: ';\n        s += _convert(JS('', '#[#]', _namedArguments, name));\n        sep = ', ';\n      }\n      s += '}';\n    }\n    s += ') -> ';\n    if (_isVoid) {\n      s += 'void';\n    } else if (_hasReturnType) {\n      s += _convert(_returnType);\n    } else {\n      s += 'dynamic';\n    }\n    return _cachedToString = \"$s\";\n  }\n}\n\n// TODO(ahe): Remove this class and call noSuchMethod instead.\nclass UnimplementedNoSuchMethodError extends Error\n    implements NoSuchMethodError {\n  final String _message;\n\n  UnimplementedNoSuchMethodError(this._message);\n\n  String toString() => \"Unsupported operation: $_message\";\n}\n\n/**\n * Creates a random number with 64 bits of randomness.\n *\n * This will be truncated to the 53 bits available in a double.\n */\nint random64() {\n  // TODO(lrn): Use a secure random source.\n  int int32a = JS(\"int\", \"(Math.random() * 0x100000000) >>> 0\");\n  int int32b = JS(\"int\", \"(Math.random() * 0x100000000) >>> 0\");\n  return int32a + int32b * 0x100000000;\n}\n\n/**\n * Returns a property name for placing data on JavaScript objects shared between\n * DOM isolates.  This happens when multiple programs are loaded in the same\n * JavaScript context (i.e. page).  The name is based on [name] but with an\n * additional part that is unique for each isolate.\n *\n * The form of the name is '___dart_$name_$id'.\n */\nString getIsolateAffinityTag(String name) {\n  return JS('String', 'init.getIsolateTag(#)', name);\n}\n\ntypedef Future<Null> LoadLibraryFunctionType();\n\nLoadLibraryFunctionType _loadLibraryWrapper(String loadId) {\n  return () => loadDeferredLibrary(loadId);\n}\n\nfinal Map<String, Future<Null>> _loadingLibraries = <String, Future<Null>>{};\nfinal Set<String> _loadedLibraries = new Set<String>();\n\nFuture<Null> loadDeferredLibrary(String loadId, [String uri]) {\n  List<List<String>> hunkLists = JS('JSExtendableArray|Null',\n      '\\$.libraries_to_load[#]', loadId);\n  if (hunkLists == null) return new Future.value(null);\n\n  return Future.forEach(hunkLists, (hunkNames) {\n    Iterable<Future<Null>> allLoads =\n        hunkNames.map((hunkName) => _loadHunk(hunkName, uri));\n    return Future.wait(allLoads).then((_) => null);\n  }).then((_) => _loadedLibraries.add(loadId));\n}\n\nFuture<Null> _loadHunk(String hunkName, String uri) {\n  // TODO(ahe): Validate libraryName.  Kasper points out that you want\n  // to be able to experiment with the effect of toggling @DeferLoad,\n  // so perhaps we should silently ignore \"bad\" library names.\n  Future<Null> future = _loadingLibraries[hunkName];\n  if (future != null) {\n    return future.then((_) => null);\n  }\n\n  if (uri == null) {\n    uri = IsolateNatives.thisScript;\n  }\n  int index = uri.lastIndexOf('/');\n  uri = '${uri.substring(0, index + 1)}$hunkName';\n\n  if (Primitives.isJsshell || Primitives.isD8) {\n    // TODO(ahe): Move this code to a JavaScript command helper script that is\n    // not included in generated output.\n    return _loadingLibraries[hunkName] = new Future<Null>(() {\n      try {\n        // Create a new function to avoid getting access to current function\n        // context.\n        JS('void', '(new Function(#))()', 'load(\"$uri\")');\n      } catch (error, stackTrace) {\n        throw new DeferredLoadException(\"Loading $uri failed.\");\n      }\n      return null;\n    });\n  } else if (isWorker()) {\n    // We are in a web worker. Load the code with an XMLHttpRequest.\n    return _loadingLibraries[hunkName] = new Future<Null>(() {\n      Completer completer = new Completer<Null>();\n      enterJsAsync();\n      Future<Null> leavingFuture = completer.future.whenComplete(() {\n        leaveJsAsync();\n      });\n\n      int index = uri.lastIndexOf('/');\n      uri = '${uri.substring(0, index + 1)}$hunkName';\n      var xhr = JS('dynamic', 'new XMLHttpRequest()');\n      JS('void', '#.open(\"GET\", #)', xhr, uri);\n      JS('void', '#.addEventListener(\"load\", #, false)',\n         xhr, convertDartClosureToJS((event) {\n        if (JS('int', '#.status', xhr) != 200) {\n          completer.completeError(\n              new DeferredLoadException(\"Loading $uri failed.\"));\n          return;\n        }\n        String code = JS('String', '#.responseText', xhr);\n        try {\n          // Create a new function to avoid getting access to current function\n          // context.\n          JS('void', '(new Function(#))()', code);\n        } catch (error, stackTrace) {\n          completer.completeError(\n            new DeferredLoadException(\"Evaluating $uri failed.\"));\n          return;\n        }\n        completer.complete(null);\n      }, 1));\n\n      var fail = convertDartClosureToJS((event) {\n        new DeferredLoadException(\"Loading $uri failed.\");\n      }, 1);\n      JS('void', '#.addEventListener(\"error\", #, false)', xhr, fail);\n      JS('void', '#.addEventListener(\"abort\", #, false)', xhr, fail);\n\n      JS('void', '#.send()', xhr);\n      return leavingFuture;\n    });\n  }\n  // We are in a dom-context.\n  return _loadingLibraries[hunkName] = new Future<Null>(() {\n    Completer completer = new Completer<Null>();\n    // Inject a script tag.\n    var script = JS('', 'document.createElement(\"script\")');\n    JS('', '#.type = \"text/javascript\"', script);\n    JS('', '#.src = #', script, uri);\n    JS('', '#.addEventListener(\"load\", #, false)',\n       script, convertDartClosureToJS((event) {\n      completer.complete(null);\n    }, 1));\n    JS('', '#.addEventListener(\"error\", #, false)',\n       script, convertDartClosureToJS((event) {\n      completer.completeError(\n          new DeferredLoadException(\"Loading $uri failed.\"));\n    }, 1));\n    JS('', 'document.body.appendChild(#)', script);\n\n    return completer.future;\n  });\n}\n\nclass MainError extends Error implements NoSuchMethodError {\n  final String _message;\n\n  MainError(this._message);\n\n  String toString() => 'NoSuchMethodError: $_message';\n}\n\nvoid missingMain() {\n  throw new MainError(\"No top-level function named 'main'.\");\n}\n\nvoid badMain() {\n  throw new MainError(\"'main' is not a function.\");\n}\n\nvoid mainHasTooManyParameters() {\n  throw new MainError(\"'main' expects too many parameters.\");\n}\n\u0000","sdk:/sdk/lib/collection/splay_tree.dart":"// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\npart of dart.collection;\n\ntypedef bool _Predicate<T>(T value);\n\n/**\n * A node in a splay tree. It holds the sorting key and the left\n * and right children in the tree.\n */\nclass _SplayTreeNode<K> {\n  final K key;\n  _SplayTreeNode<K> left;\n  _SplayTreeNode<K> right;\n\n  _SplayTreeNode(K this.key);\n}\n\n/**\n * A node in a splay tree based map.\n *\n * A [_SplayTreeNode] that also contains a value\n */\nclass _SplayTreeMapNode<K, V> extends _SplayTreeNode<K> {\n  V value;\n  _SplayTreeMapNode(K key, V this.value) : super(key);\n}\n\n/**\n * A splay tree is a self-balancing binary search tree.\n *\n * It has the additional property that recently accessed elements\n * are quick to access again.\n * It performs basic operations such as insertion, look-up and\n * removal, in O(log(n)) amortized time.\n */\nabstract class _SplayTree<K> {\n  // The root node of the splay tree. It will contain either the last\n  // element inserted or the last element looked up.\n  _SplayTreeNode<K> _root;\n\n  // The dummy node used when performing a splay on the tree. Reusing it\n  // avoids allocating a node each time a splay is performed.\n  _SplayTreeNode<K> _dummy = new _SplayTreeNode<K>(null);\n\n  // Number of elements in the splay tree.\n  int _count = 0;\n\n  /**\n   * Counter incremented whenever the keys in the map changes.\n   *\n   * Used to detect concurrent modifications.\n   */\n  int _modificationCount = 0;\n\n  /**\n   * Counter incremented whenever the tree structure changes.\n   *\n   * Used to detect that an in-place traversal cannot use\n   * cached information that relies on the tree structure.\n   */\n  int _splayCount = 0;\n\n  /** Comparison used to compare keys. */\n  int _compare(K key1, K key2);\n\n  /**\n   * Perform the splay operation for the given key. Moves the node with\n   * the given key to the top of the tree.  If no node has the given\n   * key, the last node on the search path is moved to the top of the\n   * tree. This is the simplified top-down splaying algorithm from:\n   * \"Self-adjusting Binary Search Trees\" by Sleator and Tarjan.\n   *\n   * Returns the result of comparing the new root of the tree to [key].\n   * Returns -1 if the table is empty.\n   */\n  int _splay(K key) {\n    if (_root == null) return -1;\n\n    // The right child of the dummy node will hold\n    // the L tree of the algorithm.  The left child of the dummy node\n    // will hold the R tree of the algorithm.  Using a dummy node, left\n    // and right will always be nodes and we avoid special cases.\n    _SplayTreeNode<K> left = _dummy;\n    _SplayTreeNode<K> right = _dummy;\n    _SplayTreeNode<K> current = _root;\n    int comp;\n    while (true) {\n      comp = _compare(current.key, key);\n      if (comp > 0) {\n        if (current.left == null) break;\n        comp = _compare(current.left.key, key);\n        if (comp > 0) {\n          // Rotate right.\n          _SplayTreeNode<K> tmp = current.left;\n          current.left = tmp.right;\n          tmp.right = current;\n          current = tmp;\n          if (current.left == null) break;\n        }\n        // Link right.\n        right.left = current;\n        right = current;\n        current = current.left;\n      } else if (comp < 0) {\n        if (current.right == null) break;\n        comp = _compare(current.right.key, key);\n        if (comp < 0) {\n          // Rotate left.\n          _SplayTreeNode<K> tmp = current.right;\n          current.right = tmp.left;\n          tmp.left = current;\n          current = tmp;\n          if (current.right == null) break;\n        }\n        // Link left.\n        left.right = current;\n        left = current;\n        current = current.right;\n      } else {\n        break;\n      }\n    }\n    // Assemble.\n    left.right = current.left;\n    right.left = current.right;\n    current.left = _dummy.right;\n    current.right = _dummy.left;\n    _root = current;\n\n    _dummy.right = null;\n    _dummy.left = null;\n    _splayCount++;\n    return comp;\n  }\n\n  // Emulates splaying with a key that is smaller than any in the subtree\n  // anchored at [node].\n  // and that node is returned. It should replace the reference to [node]\n  // in any parent tree or root pointer.\n  _SplayTreeNode<K> _splayMin(_SplayTreeNode<K> node) {\n    _SplayTreeNode current = node;\n    while (current.left != null) {\n      _SplayTreeNode left = current.left;\n      current.left = left.right;\n      left.right = current;\n      current = left;\n    }\n    return current;\n  }\n\n  // Emulates splaying with a key that is greater than any in the subtree\n  // anchored at [node].\n  // After this, the largest element in the tree is the root of the subtree,\n  // and that node is returned. It should replace the reference to [node]\n  // in any parent tree or root pointer.\n  _SplayTreeNode<K> _splayMax(_SplayTreeNode<K> node) {\n    _SplayTreeNode current = node;\n    while (current.right != null) {\n      _SplayTreeNode right = current.right;\n      current.right = right.left;\n      right.left = current;\n      current = right;\n    }\n    return current;\n  }\n\n  _SplayTreeNode _remove(K key) {\n    if (_root == null) return null;\n    int comp = _splay(key);\n    if (comp != 0) return null;\n    _SplayTreeNode result = _root;\n    _count--;\n    // assert(_count >= 0);\n    if (_root.left == null) {\n      _root = _root.right;\n    } else {\n      _SplayTreeNode<K> right = _root.right;\n      // Splay to make sure that the new root has an empty right child.\n      _root = _splayMax(_root.left);\n      // Insert the original right child as the right child of the new\n      // root.\n      _root.right = right;\n    }\n    _modificationCount++;\n    return result;\n  }\n\n  /**\n   * Adds a new root node with the given [key] or [value].\n   *\n   * The [comp] value is the result of comparing the existing root's key\n   * with key.\n   */\n  void _addNewRoot(_SplayTreeNode<K> node, int comp) {\n    _count++;\n    _modificationCount++;\n    if (_root == null) {\n      _root = node;\n      return;\n    }\n    // assert(_count >= 0);\n    if (comp < 0) {\n      node.left = _root;\n      node.right = _root.right;\n      _root.right = null;\n    } else {\n      node.right = _root;\n      node.left = _root.left;\n      _root.left = null;\n    }\n    _root = node;\n  }\n\n  _SplayTreeNode get _first {\n    if (_root == null) return null;\n    _root = _splayMin(_root);\n    return _root;\n  }\n\n  _SplayTreeNode get _last {\n    if (_root == null) return null;\n    _root = _splayMax(_root);\n    return _root;\n  }\n\n  void _clear() {\n    _root = null;\n    _count = 0;\n    _modificationCount++;\n  }\n}\n\nclass _TypeTest<T> {\n  bool test(v) => v is T;\n}\n\n/**\n * A [Map] of objects that can be ordered relative to each other.\n *\n * The map is based on a self-balancing binary tree. It allows most operations\n * in amortized logarithmic time.\n *\n * Keys of the map are compared using the `compare` function passed in\n * the constructor. If that is omitted, the objects are assumed to be\n * [Comparable], and are compared using their [Comparable.compareTo]\n * method. Non-comparable objects (including `null`) will not work as keys\n * in that case.\n *\n * To allow calling [operator[]], [remove] or [containsKey] with objects\n * that are not supported by the `compare` function, an extra `isValidKey`\n * predicate function can be supplied. This function is tested before\n * using the `compare` function on an argument value that may not be a [K]\n * value. If omitted, the `isValidKey` function defaults to testing if the\n * value is a [K].\n */\nclass SplayTreeMap<K, V> extends _SplayTree<K> implements Map<K, V> {\n  Comparator<K> _comparator;\n  _Predicate _validKey;\n\n  SplayTreeMap([int compare(K key1, K key2), bool isValidKey(potentialKey)])\n      : _comparator = (compare == null) ? Comparable.compare : compare,\n        _validKey = (isValidKey != null) ? isValidKey : ((v) => v is K);\n\n  /**\n   * Creates a [SplayTreeMap] that contains all key value pairs of [other].\n   */\n  factory SplayTreeMap.from(Map<K, V> other,\n                            [ int compare(K key1, K key2),\n                              bool isValidKey(potentialKey)]) =>\n      new SplayTreeMap(compare, isValidKey)..addAll(other);\n\n  /**\n   * Creates a [SplayTreeMap] where the keys and values are computed from the\n   * [iterable].\n   *\n   * For each element of the [iterable] this constructor computes a key/value\n   * pair, by applying [key] and [value] respectively.\n   *\n   * The keys of the key/value pairs do not need to be unique. The last\n   * occurrence of a key will simply overwrite any previous value.\n   *\n   * If no values are specified for [key] and [value] the default is the\n   * identity function.\n   */\n  factory SplayTreeMap.fromIterable(Iterable<K> iterable,\n      {K key(element), V value(element), int compare(K key1, K key2),\n       bool isValidKey(potentialKey) }) {\n    SplayTreeMap<K, V> map = new SplayTreeMap<K, V>(compare, isValidKey);\n    Maps._fillMapWithMappedIterable(map, iterable, key, value);\n    return map;\n  }\n\n  /**\n   * Creates a [SplayTreeMap] associating the given [keys] to [values].\n   *\n   * This constructor iterates over [keys] and [values] and maps each element of\n   * [keys] to the corresponding element of [values].\n   *\n   * If [keys] contains the same object multiple times, the last occurrence\n   * overwrites the previous value.\n   *\n   * It is an error if the two [Iterable]s don't have the same length.\n   */\n  factory SplayTreeMap.fromIterables(Iterable<K> keys, Iterable<V> values,\n      [int compare(K key1, K key2), bool isValidKey(potentialKey)]) {\n    SplayTreeMap<K, V> map = new SplayTreeMap<K, V>(compare, isValidKey);\n    Maps._fillMapWithIterables(map, keys, values);\n    return map;\n  }\n\n  int _compare(K key1, K key2) => _comparator(key1, key2);\n\n  SplayTreeMap._internal();\n\n  V operator [](Object key) {\n    if (key == null) throw new ArgumentError(key);\n    if (!_validKey(key)) return null;\n    if (_root != null) {\n      int comp = _splay(key);\n      if (comp == 0) {\n        _SplayTreeMapNode mapRoot = _root;\n        return mapRoot.value;\n      }\n    }\n    return null;\n  }\n\n  V remove(Object key) {\n    if (!_validKey(key)) return null;\n    _SplayTreeMapNode mapRoot = _remove(key);\n    if (mapRoot != null) return mapRoot.value;\n    return null;\n  }\n\n  void operator []=(K key, V value) {\n    if (key == null) throw new ArgumentError(key);\n    // Splay on the key to move the last node on the search path for\n    // the key to the root of the tree.\n    int comp = _splay(key);\n    if (comp == 0) {\n      _SplayTreeMapNode mapRoot = _root;\n      mapRoot.value = value;\n      return;\n    }\n    _addNewRoot(new _SplayTreeMapNode(key, value), comp);\n  }\n\n\n  V putIfAbsent(K key, V ifAbsent()) {\n    if (key == null) throw new ArgumentError(key);\n    int comp = _splay(key);\n    if (comp == 0) {\n      _SplayTreeMapNode mapRoot = _root;\n      return mapRoot.value;\n    }\n    int modificationCount = _modificationCount;\n    int splayCount = _splayCount;\n    V value = ifAbsent();\n    if (modificationCount != _modificationCount) {\n      throw new ConcurrentModificationError(this);\n    }\n    if (splayCount != _splayCount) {\n      comp = _splay(key);\n      // Key is still not there, otherwise _modificationCount would be changed.\n      assert(comp != 0);\n    }\n    _addNewRoot(new _SplayTreeMapNode(key, value), comp);\n    return value;\n  }\n\n  void addAll(Map<K, V> other) {\n    other.forEach((K key, V value) { this[key] = value; });\n  }\n\n  bool get isEmpty {\n    return (_root == null);\n  }\n\n  bool get isNotEmpty => !isEmpty;\n\n  void forEach(void f(K key, V value)) {\n    Iterator<_SplayTreeNode<K>> nodes =\n        new _SplayTreeNodeIterator<K>(this);\n    while (nodes.moveNext()) {\n      _SplayTreeMapNode<K, V> node = nodes.current;\n      f(node.key, node.value);\n    }\n  }\n\n  int get length {\n    return _count;\n  }\n\n  void clear() {\n    _clear();\n  }\n\n  bool containsKey(Object key) {\n    return _validKey(key) && _splay(key) == 0;\n  }\n\n  bool containsValue(Object value) {\n    bool found = false;\n    int initialSplayCount = _splayCount;\n    bool visit(_SplayTreeMapNode node) {\n      while (node != null) {\n        if (node.value == value) return true;\n        if (initialSplayCount != _splayCount) {\n          throw new ConcurrentModificationError(this);\n        }\n        if (node.right != null && visit(node.right)) return true;\n        node = node.left;\n      }\n      return false;\n    }\n    return visit(_root);\n  }\n\n  Iterable<K> get keys => new _SplayTreeKeyIterable<K>(this);\n\n  Iterable<V> get values => new _SplayTreeValueIterable<K, V>(this);\n\n  String toString() {\n    return Maps.mapToString(this);\n  }\n\n  /**\n   * Get the first key in the map. Returns [:null:] if the map is empty.\n   */\n  K firstKey() {\n    if (_root == null) return null;\n    return _first.key;\n  }\n\n  /**\n   * Get the last key in the map. Returns [:null:] if the map is empty.\n   */\n  K lastKey() {\n    if (_root == null) return null;\n    return _last.key;\n  }\n\n  /**\n   * Get the last key in the map that is strictly smaller than [key]. Returns\n   * [:null:] if no key was not found.\n   */\n  K lastKeyBefore(K key) {\n    if (key == null) throw new ArgumentError(key);\n    if (_root == null) return null;\n    int comp = _splay(key);\n    if (comp < 0) return _root.key;\n    _SplayTreeNode<K> node = _root.left;\n    if (node == null) return null;\n    while (node.right != null) {\n      node = node.right;\n    }\n    return node.key;\n  }\n\n  /**\n   * Get the first key in the map that is strictly larger than [key]. Returns\n   * [:null:] if no key was not found.\n   */\n  K firstKeyAfter(K key) {\n    if (key == null) throw new ArgumentError(key);\n    if (_root == null) return null;\n    int comp = _splay(key);\n    if (comp > 0) return _root.key;\n    _SplayTreeNode<K> node = _root.right;\n    if (node == null) return null;\n    while (node.left != null) {\n      node = node.left;\n    }\n    return node.key;\n  }\n}\n\nabstract class _SplayTreeIterator<T> implements Iterator<T> {\n  final _SplayTree _tree;\n  /**\n   * Worklist of nodes to visit.\n   *\n   * These nodes have been passed over on the way down in a\n   * depth-first left-to-right traversal. Visiting each node,\n   * and their right subtrees will visit the remainder of\n   * the nodes of a full traversal.\n   *\n   * Only valid as long as the original tree isn't reordered.\n   */\n  final List<_SplayTreeNode> _workList = <_SplayTreeNode>[];\n\n  /**\n   * Original modification counter of [_tree].\n   *\n   * Incremented on [_tree] when a key is added or removed.\n   * If it changes, iteration is aborted.\n   *\n   * Not final because some iterators may modify the tree knowingly,\n   * and they update the modification count in that case.\n   */\n  int _modificationCount;\n\n  /**\n   * Count of splay operations on [_tree] when [_workList] was built.\n   *\n   * If the splay count on [_tree] increases, [_workList] becomes invalid.\n   */\n  int _splayCount;\n\n  /** Current node. */\n  _SplayTreeNode _currentNode;\n\n  _SplayTreeIterator(_SplayTree tree)\n      : _tree = tree,\n        _modificationCount = tree._modificationCount,\n        _splayCount = tree._splayCount {\n    _findLeftMostDescendent(tree._root);\n  }\n\n  _SplayTreeIterator.startAt(_SplayTree tree, var startKey)\n      : _tree = tree,\n        _modificationCount = tree._modificationCount {\n    if (tree._root == null) return;\n    int compare = tree._splay(startKey);\n    _splayCount = tree._splayCount;\n    if (compare < 0) {\n      // Don't include the root, start at the next element after the root.\n      _findLeftMostDescendent(tree._root.right);\n    } else {\n      _workList.add(tree._root);\n    }\n  }\n\n  T get current {\n    if (_currentNode == null) return null;\n    return _getValue(_currentNode);\n  }\n\n  void _findLeftMostDescendent(_SplayTreeNode node) {\n    while (node != null) {\n      _workList.add(node);\n      node = node.left;\n    }\n  }\n\n  /**\n   * Called when the tree structure of the tree has changed.\n   *\n   * This can be caused by a splay operation.\n   * If the key-set changes, iteration is aborted before getting\n   * here, so we know that the keys are the same as before, it's\n   * only the tree that has been reordered.\n   */\n  void _rebuildWorkList(_SplayTreeNode currentNode) {\n    assert(!_workList.isEmpty);\n    _workList.clear();\n    if (currentNode == null) {\n      _findLeftMostDescendent(_tree._root);\n    } else {\n      _tree._splay(currentNode.key);\n      _findLeftMostDescendent(_tree._root.right);\n      assert(!_workList.isEmpty);\n    }\n  }\n\n  bool moveNext() {\n    if (_modificationCount != _tree._modificationCount) {\n      throw new ConcurrentModificationError(_tree);\n    }\n    // Picks the next element in the worklist as current.\n    // Updates the worklist with the left-most path of the current node's\n    // right-hand child.\n    // If the worklist is no longer valid (after a splay), it is rebuild\n    // from scratch.\n    if (_workList.isEmpty) {\n      _currentNode = null;\n      return false;\n    }\n    if (_tree._splayCount != _splayCount && _currentNode != null) {\n      _rebuildWorkList(_currentNode);\n    }\n    _currentNode = _workList.removeLast();\n    _findLeftMostDescendent(_currentNode.right);\n    return true;\n  }\n\n  T _getValue(_SplayTreeNode node);\n}\n\nclass _SplayTreeKeyIterable<K> extends IterableBase<K>\n                              implements EfficientLength {\n  _SplayTree<K> _tree;\n  _SplayTreeKeyIterable(this._tree);\n  int get length => _tree._count;\n  bool get isEmpty => _tree._count == 0;\n  Iterator<K> get iterator => new _SplayTreeKeyIterator<K>(_tree);\n}\n\nclass _SplayTreeValueIterable<K, V> extends IterableBase<V>\n                                    implements EfficientLength {\n  SplayTreeMap<K, V> _map;\n  _SplayTreeValueIterable(this._map);\n  int get length => _map._count;\n  bool get isEmpty => _map._count == 0;\n  Iterator<V> get iterator => new _SplayTreeValueIterator<K, V>(_map);\n}\n\nclass _SplayTreeKeyIterator<K> extends _SplayTreeIterator<K> {\n  _SplayTreeKeyIterator(_SplayTree<K> map): super(map);\n  K _getValue(_SplayTreeNode node) => node.key;\n}\n\nclass _SplayTreeValueIterator<K, V> extends _SplayTreeIterator<V> {\n  _SplayTreeValueIterator(SplayTreeMap<K, V> map): super(map);\n  V _getValue(_SplayTreeMapNode node) => node.value;\n}\n\nclass _SplayTreeNodeIterator<K>\n    extends _SplayTreeIterator<_SplayTreeNode<K>> {\n  _SplayTreeNodeIterator(_SplayTree<K> tree): super(tree);\n  _SplayTreeNodeIterator.startAt(_SplayTree<K> tree, var startKey)\n      : super.startAt(tree, startKey);\n  _SplayTreeNode<K> _getValue(_SplayTreeNode node) => node;\n}\n\n\n/**\n * A [Set] of objects that can be ordered relative to each other.\n *\n * The set is based on a self-balancing binary tree. It allows most operations\n * in amortized logarithmic time.\n *\n * Elements of the set are compared using the `compare` function passed in\n * the constructor. If that is omitted, the objects are assumed to be\n * [Comparable], and are compared using their [Comparable.compareTo]\n * method. Non-comparable objects (including `null`) will not work as an element\n * in that case.\n */\nclass SplayTreeSet<E> extends _SplayTree<E> with IterableMixin<E>, SetMixin<E> {\n  Comparator _comparator;\n  _Predicate _validKey;\n\n  /**\n   * Create a new [SplayTreeSet] with the given compare function.\n   *\n   * If the [compare] function is omitted, it defaults to [Comparable.compare],\n   * and the elements must be comparable.\n   *\n   * A provided `compare` function may not work on all objects. It may not even\n   * work on all `E` instances.\n   *\n   * For operations that add elements to the set, the user is supposed to not\n   * pass in objects that doesn't work with the compare function.\n   *\n   * The methods [contains], [remove], [lookup], [removeAll] or [retainAll]\n   * are typed to accept any object(s), and the [isValidKey] test can used to\n   * filter those objects before handing them to the `compare` function.\n   *\n   * If [isValidKey] is provided, only values satisfying `isValidKey(other)`\n   * are compared using the `compare` method in the methods mentioned above.\n   * If the `isValidKey` function returns false for an object, it is assumed to\n   * not be in the set.\n   *\n   * If omitted, the `isValidKey` function defaults to checking against the\n   * type parameter: `other is E`.\n   */\n  SplayTreeSet([int compare(E key1, E key2), bool isValidKey(potentialKey)])\n      : _comparator = (compare == null) ? Comparable.compare : compare,\n        _validKey = (isValidKey != null) ? isValidKey : ((v) => v is E);\n\n  int _compare(E e1, E e2) => _comparator(e1, e2);\n\n  // From Iterable.\n\n  Iterator<E> get iterator => new _SplayTreeKeyIterator<E>(this);\n\n  int get length => _count;\n  bool get isEmpty => _root == null;\n  bool get isNotEmpty => _root != null;\n\n  E get first {\n    if (_count == 0) throw IterableElementError.noElement();\n    return _first.key;\n  }\n\n  E get last {\n    if (_count == 0) throw IterableElementError.noElement();\n    return _last.key;\n  }\n\n  E get single {\n    if (_count == 0) throw IterableElementError.noElement();\n    if (_count > 1) throw IterableElementError.tooMany();\n    return _root.key;\n  }\n\n  // From Set.\n  bool contains(Object object) {\n    return _validKey(object) && _splay(object) == 0;\n  }\n\n  bool add(E element) {\n    int compare = _splay(element);\n    if (compare == 0) return false;\n    _addNewRoot(new _SplayTreeNode(element), compare);\n    return true;\n  }\n\n  bool remove(Object object) {\n    if (!_validKey(object)) return false;\n    return _remove(object) != null;\n  }\n\n  void addAll(Iterable<E> elements) {\n    for (E element in elements) {\n      int compare = _splay(element);\n      if (compare != 0) {\n        _addNewRoot(new _SplayTreeNode(element), compare);\n      }\n    }\n  }\n\n  void removeAll(Iterable<Object> elements) {\n    for (Object element in elements) {\n      if (_validKey(element)) _remove(element);\n    }\n  }\n\n  void retainAll(Iterable<Object> elements) {\n    // Build a set with the same sense of equality as this set.\n    SplayTreeSet<E> retainSet = new SplayTreeSet<E>(_comparator, _validKey);\n    int modificationCount = _modificationCount;\n    for (Object object in elements) {\n      if (modificationCount != _modificationCount) {\n        // The iterator should not have side effects.\n        throw new ConcurrentModificationError(this);\n      }\n      // Equivalent to this.contains(object).\n      if (_validKey(object) && _splay(object) == 0) retainSet.add(_root.key);\n    }\n    // Take over the elements from the retained set, if it differs.\n    if (retainSet._count != _count) {\n      _root = retainSet._root;\n      _count = retainSet._count;\n      _modificationCount++;\n    }\n  }\n\n  E lookup(Object object) {\n    if (!_validKey(object)) return null;\n    int comp = _splay(object);\n    if (comp != 0) return null;\n    return _root.key;\n  }\n\n  Set<E> intersection(Set<E> other) {\n    Set<E> result = new SplayTreeSet<E>(_comparator, _validKey);\n    for (E element in this) {\n      if (other.contains(element)) result.add(element);\n    }\n    return result;\n  }\n\n  Set<E> difference(Set<E> other) {\n    Set<E> result = new SplayTreeSet<E>(_comparator, _validKey);\n    for (E element in this) {\n      if (!other.contains(element)) result.add(element);\n    }\n    return result;\n  }\n\n  Set<E> union(Set<E> other) {\n    return _clone()..addAll(other);\n  }\n\n  SplayTreeSet<E> _clone() {\n    var set = new SplayTreeSet<E>(_comparator, _validKey);\n    set._count = _count;\n    set._root = _cloneNode(_root);\n    return set;\n  }\n\n  _SplayTreeNode<E> _cloneNode(_SplayTreeNode<E> node) {\n    if (node == null) return null;\n    return new _SplayTreeNode<E>(node.key)..left = _cloneNode(node.left)\n                                          ..right = _cloneNode(node.right);\n  }\n\n  void clear() { _clear(); }\n\n  Set<E> toSet() => _clone();\n\n  String toString() => IterableBase.iterableToFullString(this, '{', '}');\n}\n\u0000","sdk:/sdk/lib/collection/set.dart":"// Copyright (c) 2014, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n/**\n * Base implementations of [Set].\n */\npart of dart.collection;\n\n/**\n * Mixin implementation of [Set].\n *\n * This class provides a base implementation of a `Set` that depends only\n * on the abstract members: [add], [contains], [lookup], [remove],\n * [iterator], [length] and [toSet].\n *\n * Some of the methods assume that `toSet` creates a modifiable set.\n * If using this mixin for an unmodifiable set,\n * where `toSet` should return an unmodifiable set,\n * it's necessary to reimplement\n * [retainAll], [union], [intersection] and [difference].\n *\n * Implementations of `Set` using this mixin should consider also implementing\n * `clear` in constant time. The default implementation works by removing every\n * element.\n */\nabstract class SetMixin<E> implements Set<E> {\n  // This class reimplements all of [IterableMixin].\n  // If/when Dart mixins get more powerful, we should just create a single\n  // Mixin class from IterableMixin and the new methods of thisclass.\n\n  bool add(E element);\n\n  bool contains(Object element);\n\n  E lookup(E element);\n\n  bool remove(Object element);\n\n  Iterator<E> get iterator;\n\n  Set<E> toSet();\n\n  int get length;\n\n  bool get isEmpty => length == 0;\n\n  bool get isNotEmpty => length != 0;\n\n  void clear() {\n    removeAll(toList());\n  }\n\n  void addAll(Iterable<E> elements) {\n    for (E element in elements) add(element);\n  }\n\n  void removeAll(Iterable<Object> elements) {\n    for (Object element in elements) remove(element);\n  }\n\n  void retainAll(Iterable<Object> elements) {\n    // Create a copy of the set, remove all of elements from the copy,\n    // then remove all remaining elements in copy from this.\n    Set<E> toRemove = toSet();\n    for (Object o in elements) {\n      toRemove.remove(o);\n    }\n    removeAll(toRemove);\n  }\n\n  void removeWhere(bool test(E element)) {\n    List toRemove = [];\n    for (E element in this) {\n      if (test(element)) toRemove.add(element);\n    }\n    removeAll(toRemove);\n  }\n\n  void retainWhere(bool test(E element)) {\n    List toRemove = [];\n    for (E element in this) {\n      if (!test(element)) toRemove.add(element);\n    }\n    removeAll(toRemove);\n  }\n\n  bool containsAll(Iterable<Object> other) {\n    for (Object o in other) {\n      if (!contains(o)) return false;\n    }\n    return true;\n  }\n\n  Set<E> union(Set<E> other) {\n    return toSet()..addAll(other);\n  }\n\n  Set<E> intersection(Set<Object> other) {\n    Set<E> result = toSet();\n    for (E element in this) {\n      if (!other.contains(element)) result.remove(element);\n    }\n    return result;\n  }\n\n  Set<E> difference(Set<Object> other) {\n    Set<E> result = toSet();\n    for (E element in this) {\n      if (other.contains(element)) result.remove(element);\n    }\n    return result;\n  }\n\n  List<E> toList({bool growable: true}) {\n    List<E> result = growable ? (new List<E>()..length = length)\n                              : new List<E>(length);\n    int i = 0;\n    for (E element in this) result[i++] = element;\n    return result;\n  }\n\n  Iterable map(f(E element)) =>\n      new EfficientLengthMappedIterable<E, dynamic>(this, f);\n\n  E get single {\n    if (length > 1) throw IterableElementError.tooMany();\n    Iterator it = iterator;\n    if (!it.moveNext()) throw IterableElementError.noElement();\n    E result = it.current;\n    return result;\n  }\n\n  String toString() => IterableBase.iterableToFullString(this, '{', '}');\n\n  // Copied from IterableMixin.\n  // Should be inherited if we had multi-level mixins.\n\n  Iterable<E> where(bool f(E element)) => new WhereIterable<E>(this, f);\n\n  Iterable expand(Iterable f(E element)) =>\n      new ExpandIterable<E, dynamic>(this, f);\n\n  void forEach(void f(E element)) {\n    for (E element in this) f(element);\n  }\n\n  E reduce(E combine(E value, E element)) {\n    Iterator<E> iterator = this.iterator;\n    if (!iterator.moveNext()) {\n      throw IterableElementError.noElement();\n    }\n    E value = iterator.current;\n    while (iterator.moveNext()) {\n      value = combine(value, iterator.current);\n    }\n    return value;\n  }\n\n  dynamic fold(var initialValue,\n               dynamic combine(var previousValue, E element)) {\n    var value = initialValue;\n    for (E element in this) value = combine(value, element);\n    return value;\n  }\n\n  bool every(bool f(E element)) {\n    for (E element in this) {\n      if (!f(element)) return false;\n    }\n    return true;\n  }\n\n  String join([String separator = \"\"]) {\n    Iterator<E> iterator = this.iterator;\n    if (!iterator.moveNext()) return \"\";\n    StringBuffer buffer = new StringBuffer();\n    if (separator == null || separator == \"\") {\n      do {\n        buffer.write(\"${iterator.current}\");\n      } while (iterator.moveNext());\n    } else {\n      buffer.write(\"${iterator.current}\");\n      while (iterator.moveNext()) {\n        buffer.write(separator);\n        buffer.write(\"${iterator.current}\");\n      }\n    }\n    return buffer.toString();\n  }\n\n  bool any(bool test(E element)) {\n    for (E element in this) {\n      if (test(element)) return true;\n    }\n    return false;\n  }\n\n  Iterable<E> take(int n) {\n    return new TakeIterable<E>(this, n);\n  }\n\n  Iterable<E> takeWhile(bool test(E value)) {\n    return new TakeWhileIterable<E>(this, test);\n  }\n\n  Iterable<E> skip(int n) {\n    return new SkipIterable<E>(this, n);\n  }\n\n  Iterable<E> skipWhile(bool test(E value)) {\n    return new SkipWhileIterable<E>(this, test);\n  }\n\n  E get first {\n    Iterator it = iterator;\n    if (!it.moveNext()) {\n      throw IterableElementError.noElement();\n    }\n    return it.current;\n  }\n\n  E get last {\n    Iterator it = iterator;\n    if (!it.moveNext()) {\n      throw IterableElementError.noElement();\n    }\n    E result;\n    do {\n      result = it.current;\n    } while(it.moveNext());\n    return result;\n  }\n\n  dynamic firstWhere(bool test(E value), { Object orElse() }) {\n    for (E element in this) {\n      if (test(element)) return element;\n    }\n    if (orElse != null) return orElse();\n    throw IterableElementError.noElement();\n  }\n\n  dynamic lastWhere(bool test(E value), { Object orElse() }) {\n    E result = null;\n    bool foundMatching = false;\n    for (E element in this) {\n      if (test(element)) {\n        result = element;\n        foundMatching = true;\n      }\n    }\n    if (foundMatching) return result;\n    if (orElse != null) return orElse();\n    throw IterableElementError.noElement();\n  }\n\n  E singleWhere(bool test(E value)) {\n    E result = null;\n    bool foundMatching = false;\n    for (E element in this) {\n      if (test(element)) {\n        if (foundMatching) {\n          throw IterableElementError.tooMany();\n        }\n        result = element;\n        foundMatching = true;\n      }\n    }\n    if (foundMatching) return result;\n    throw IterableElementError.noElement();\n  }\n\n  E elementAt(int index) {\n    if (index is! int || index < 0) throw new RangeError.value(index);\n    int remaining = index;\n    for (E element in this) {\n      if (remaining == 0) return element;\n      remaining--;\n    }\n    throw new RangeError.value(index);\n  }\n}\n\n/**\n * Base implementation of [Set].\n *\n * This class provides a base implementation of a `Set` that depends only\n * on the abstract members: [add], [contains], [lookup], [remove],\n * [iterator], [length] and [toSet].\n *\n * Some of the methods assume that `toSet` creates a modifiable set.\n * If using this base class for an unmodifiable set,\n * where `toSet` should return an unmodifiable set,\n * it's necessary to reimplement\n * [retainAll], [union], [intersection] and [difference].\n *\n * Implementations of `Set` using this base should consider also implementing\n * `clear` in constant time. The default implementation works by removing every\n * element.\n */\nabstract class SetBase<E> extends SetMixin<E> {\n  /**\n   * Convert a `Set` to a string as `{each, element, as, string}`.\n   *\n   * Handles circular references where converting one of the elements\n   * to a string ends up converting [set] to a string again.\n   */\n  static String setToString(Set set) =>\n      IterableBase.iterableToFullString(set, '{', '}');\n}\n\u0000","sdk:/sdk/lib/collection/queue.dart":"// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\npart of dart.collection;\n\n/**\n * A [Queue] is a collection that can be manipulated at both ends. One\n * can iterate over the elements of a queue through [forEach] or with\n * an [Iterator].\n *\n * It is generally not allowed to modify the queue (add or remove entries) while\n * an operation on the queue is being performed, for example during a call to\n * [forEach].\n * Modifying the queue while it is being iterated will most likely break the\n * iteration.\n * This goes both for using the [iterator] directly, or for iterating an\n * `Iterable` returned by a method like [map] or [where].\n */\nabstract class Queue<E> implements Iterable<E>, EfficientLength {\n\n  /**\n   * Creates a queue.\n   */\n  factory Queue() = ListQueue<E>;\n\n  /**\n   * Creates a queue with the elements of [other]. The order in\n   * the queue will be the order provided by the iterator of [other].\n   */\n  factory Queue.from(Iterable<E> other) = ListQueue<E>.from;\n\n  /**\n   * Removes and returns the first element of this queue.\n   *\n   * The queue must not be empty when this method is called.\n   */\n  E removeFirst();\n\n  /**\n   * Removes and returns the last element of the queue.\n   *\n   * The queue must not be empty when this method is called.\n   */\n  E removeLast();\n\n  /**\n   * Adds [value] at the beginning of the queue.\n   */\n  void addFirst(E value);\n\n  /**\n   * Adds [value] at the end of the queue.\n   */\n  void addLast(E value);\n\n  /**\n   * Adds [value] at the end of the queue.\n   */\n  void add(E value);\n\n  /**\n   * Remove a single instance of [value] from the queue.\n   *\n   * Returns `true` if a value was removed, or `false` if the queue\n   * contained no element equal to [value].\n   */\n  bool remove(Object object);\n\n  /**\n   * Adds all elements of [iterable] at the end of the queue. The\n   * length of the queue is extended by the length of [iterable].\n   */\n  void addAll(Iterable<E> iterable);\n\n  /**\n   * Removes all elements matched by [test] from the queue.\n   *\n   * The `test` function must not throw or modify the queue.\n   */\n  void removeWhere(bool test(E element));\n\n  /**\n   * Removes all elements not matched by [test] from the queue.\n   *\n   * The `test` function must not throw or modify the queue.\n   */\n  void retainWhere(bool test(E element));\n\n  /**\n   * Removes all elements in the queue. The size of the queue becomes zero.\n   */\n  void clear();\n}\n\n\n/**\n * An entry in a doubly linked list. It contains a pointer to the next\n * entry, the previous entry, and the boxed element.\n */\nclass DoubleLinkedQueueEntry<E> {\n  DoubleLinkedQueueEntry<E> _previous;\n  DoubleLinkedQueueEntry<E> _next;\n  E _element;\n\n  DoubleLinkedQueueEntry(E e) : _element = e;\n\n  void _link(DoubleLinkedQueueEntry<E> previous,\n             DoubleLinkedQueueEntry<E> next) {\n    _next = next;\n    _previous = previous;\n    previous._next = this;\n    next._previous = this;\n  }\n\n  void append(E e) {\n    new DoubleLinkedQueueEntry<E>(e)._link(this, _next);\n  }\n\n  void prepend(E e) {\n    new DoubleLinkedQueueEntry<E>(e)._link(_previous, this);\n  }\n\n  E remove() {\n    _previous._next = _next;\n    _next._previous = _previous;\n    _next = null;\n    _previous = null;\n    return _element;\n  }\n\n  DoubleLinkedQueueEntry<E> _asNonSentinelEntry() {\n    return this;\n  }\n\n  DoubleLinkedQueueEntry<E> previousEntry() {\n    return _previous._asNonSentinelEntry();\n  }\n\n  DoubleLinkedQueueEntry<E> nextEntry() {\n    return _next._asNonSentinelEntry();\n  }\n\n  E get element {\n    return _element;\n  }\n\n  void set element(E e) {\n    _element = e;\n  }\n}\n\n/**\n * A sentinel in a double linked list is used to manipulate the list\n * at both ends.\n * A double linked list has exactly one sentinel,\n * which is the only entry when the list is constructed.\n * Initially, a sentinel has its next and previous entry point to itself.\n * A sentinel does not box any user element.\n */\nclass _DoubleLinkedQueueEntrySentinel<E> extends DoubleLinkedQueueEntry<E> {\n  _DoubleLinkedQueueEntrySentinel() : super(null) {\n    _link(this, this);\n  }\n\n  E remove() {\n    throw IterableElementError.noElement();\n  }\n\n  DoubleLinkedQueueEntry<E> _asNonSentinelEntry() {\n    return null;\n  }\n\n  void set element(E e) {\n    // This setter is unreachable.\n    // TODO(lrn): Don't inherit the field if we don't use it.\n    assert(false);\n  }\n\n  E get element {\n    throw IterableElementError.noElement();\n  }\n}\n\n/**\n * A [Queue] implementation based on a double-linked list.\n *\n * Allows constant time add, remove-at-ends and peek operations.\n */\nclass DoubleLinkedQueue<E> extends IterableBase<E> implements Queue<E> {\n  _DoubleLinkedQueueEntrySentinel<E> _sentinel;\n  int _elementCount = 0;\n\n  DoubleLinkedQueue() {\n    _sentinel = new _DoubleLinkedQueueEntrySentinel<E>();\n  }\n\n  factory DoubleLinkedQueue.from(Iterable<E> other) {\n    Queue<E> list = new DoubleLinkedQueue();\n    for (final e in other) {\n      list.addLast(e);\n    }\n    return list;\n  }\n\n  int get length => _elementCount;\n\n  void addLast(E value) {\n    _sentinel.prepend(value);\n    _elementCount++;\n  }\n\n  void addFirst(E value) {\n    _sentinel.append(value);\n    _elementCount++;\n  }\n\n  void add(E value) {\n    _sentinel.prepend(value);\n    _elementCount++;\n  }\n\n  void addAll(Iterable<E> iterable) {\n    for (final E value in iterable) {\n      _sentinel.prepend(value);\n      _elementCount++;\n    }\n  }\n\n  E removeLast() {\n    E result = _sentinel._previous.remove();\n    _elementCount--;\n    return result;\n  }\n\n  E removeFirst() {\n    E result = _sentinel._next.remove();\n    _elementCount--;\n    return result;\n  }\n\n  bool remove(Object o) {\n    DoubleLinkedQueueEntry<E> entry = _sentinel._next;\n    while (!identical(entry, _sentinel)) {\n      if (entry.element == o) {\n        entry.remove();\n        _elementCount--;\n        return true;\n      }\n      entry = entry._next;\n    }\n    return false;\n  }\n\n  void _filter(bool test(E element), bool removeMatching) {\n    DoubleLinkedQueueEntry<E> entry = _sentinel._next;\n    while (!identical(entry, _sentinel)) {\n      DoubleLinkedQueueEntry<E> next = entry._next;\n      if (identical(removeMatching, test(entry.element))) {\n        entry.remove();\n        _elementCount--;\n      }\n      entry = next;\n    }\n  }\n\n  void removeWhere(bool test(E element)) {\n    _filter(test, true);\n  }\n\n  void retainWhere(bool test(E element)) {\n    _filter(test, false);\n  }\n\n  E get first {\n    return _sentinel._next.element;\n  }\n\n  E get last {\n    return _sentinel._previous.element;\n  }\n\n  E get single {\n    // Note that this throws correctly if the queue is empty.\n    if (identical(_sentinel._next, _sentinel._previous)) {\n      return _sentinel._next.element;\n    }\n    throw IterableElementError.tooMany();\n  }\n\n  DoubleLinkedQueueEntry<E> lastEntry() {\n    return _sentinel.previousEntry();\n  }\n\n  DoubleLinkedQueueEntry<E> firstEntry() {\n    return _sentinel.nextEntry();\n  }\n\n  bool get isEmpty {\n    return (identical(_sentinel._next, _sentinel));\n  }\n\n  void clear() {\n    _sentinel._next = _sentinel;\n    _sentinel._previous = _sentinel;\n    _elementCount = 0;\n  }\n\n  void forEachEntry(void f(DoubleLinkedQueueEntry<E> element)) {\n    DoubleLinkedQueueEntry<E> entry = _sentinel._next;\n    while (!identical(entry, _sentinel)) {\n      DoubleLinkedQueueEntry<E> nextEntry = entry._next;\n      f(entry);\n      entry = nextEntry;\n    }\n  }\n\n  _DoubleLinkedQueueIterator<E> get iterator {\n    return new _DoubleLinkedQueueIterator<E>(_sentinel);\n  }\n\n  String toString() => IterableBase.iterableToFullString(this, '{', '}');\n}\n\nclass _DoubleLinkedQueueIterator<E> implements Iterator<E> {\n  _DoubleLinkedQueueEntrySentinel<E> _sentinel;\n  DoubleLinkedQueueEntry<E> _nextEntry = null;\n  E _current;\n\n  _DoubleLinkedQueueIterator(_DoubleLinkedQueueEntrySentinel<E> sentinel)\n      : _sentinel = sentinel, _nextEntry = sentinel._next;\n\n  bool moveNext() {\n    // When [_currentEntry] it is set to [:null:] then it is at the end.\n    if (!identical(_nextEntry, _sentinel)) {\n      _current = _nextEntry._element;\n      _nextEntry = _nextEntry._next;\n      return true;\n    }\n    _current = null;\n    _nextEntry = _sentinel = null;  // Still identical.\n    return false;\n  }\n\n  E get current => _current;\n}\n\n/**\n * List based [Queue].\n *\n * Keeps a cyclic buffer of elements, and grows to a larger buffer when\n * it fills up. This guarantees constant time peek and remove operations, and\n * amortized constant time add operations.\n *\n * The structure is efficient for any queue or stack usage.\n */\nclass ListQueue<E> extends IterableBase<E> implements Queue<E> {\n  static const int _INITIAL_CAPACITY = 8;\n  List<E> _table;\n  int _head;\n  int _tail;\n  int _modificationCount = 0;\n\n  /**\n   * Create an empty queue.\n   *\n   * If [initialCapacity] is given, prepare the queue for at least that many\n   * elements.\n   */\n  ListQueue([int initialCapacity]) : _head = 0, _tail = 0 {\n    if (initialCapacity == null || initialCapacity < _INITIAL_CAPACITY) {\n      initialCapacity = _INITIAL_CAPACITY;\n    } else if (!_isPowerOf2(initialCapacity)) {\n      initialCapacity = _nextPowerOf2(initialCapacity);\n    }\n    assert(_isPowerOf2(initialCapacity));\n    _table = new List<E>(initialCapacity);\n  }\n\n  /**\n   * Create a queue initially containing the elements of [source].\n   */\n  factory ListQueue.from(Iterable<E> source) {\n    if (source is List) {\n      int length = source.length;\n      ListQueue<E> queue = new ListQueue(length + 1);\n      assert(queue._table.length > length);\n      List sourceList = source;\n      queue._table.setRange(0, length, sourceList, 0);\n      queue._tail = length;\n      return queue;\n    } else {\n      return new ListQueue<E>()..addAll(source);\n    }\n  }\n\n  // Iterable interface.\n\n  Iterator<E> get iterator => new _ListQueueIterator<E>(this);\n\n  void forEach(void action (E element)) {\n    int modificationCount = _modificationCount;\n    for (int i = _head; i != _tail; i = (i + 1) & (_table.length - 1)) {\n      action(_table[i]);\n      _checkModification(modificationCount);\n    }\n  }\n\n  bool get isEmpty => _head == _tail;\n\n  int get length => (_tail - _head) & (_table.length - 1);\n\n  E get first {\n    if (_head == _tail) throw IterableElementError.noElement();\n    return _table[_head];\n  }\n\n  E get last {\n    if (_head == _tail) throw IterableElementError.noElement();\n    return _table[(_tail - 1) & (_table.length - 1)];\n  }\n\n  E get single {\n    if (_head == _tail) throw IterableElementError.noElement();\n    if (length > 1) throw IterableElementError.tooMany();\n    return _table[_head];\n  }\n\n  E elementAt(int index) {\n    if (index < 0 || index > length) {\n      throw new RangeError.range(index, 0, length);\n    }\n    return _table[(_head + index) & (_table.length - 1)];\n  }\n\n  List<E> toList({ bool growable: true }) {\n    List<E> list;\n    if (growable) {\n      list = new List<E>()..length = length;\n    } else {\n      list = new List<E>(length);\n    }\n    _writeToList(list);\n    return list;\n  }\n\n  // Collection interface.\n\n  void add(E element) {\n    _add(element);\n  }\n\n  void addAll(Iterable<E> elements) {\n    if (elements is List) {\n      List list = elements;\n      int addCount = list.length;\n      int length = this.length;\n      if (length + addCount >= _table.length) {\n        _preGrow(length + addCount);\n        // After preGrow, all elements are at the start of the list.\n        _table.setRange(length, length + addCount, list, 0);\n        _tail += addCount;\n      } else {\n        // Adding addCount elements won't reach _head.\n        int endSpace = _table.length - _tail;\n        if (addCount < endSpace) {\n          _table.setRange(_tail, _tail + addCount, list, 0);\n          _tail += addCount;\n        } else {\n          int preSpace = addCount - endSpace;\n          _table.setRange(_tail, _tail + endSpace, list, 0);\n          _table.setRange(0, preSpace, list, endSpace);\n          _tail = preSpace;\n        }\n      }\n      _modificationCount++;\n    } else {\n      for (E element in elements) _add(element);\n    }\n  }\n\n  bool remove(Object object) {\n    for (int i = _head; i != _tail; i = (i + 1) & (_table.length - 1)) {\n      E element = _table[i];\n      if (element == object) {\n        _remove(i);\n        _modificationCount++;\n        return true;\n      }\n    }\n    return false;\n  }\n\n  void _filterWhere(bool test(E element), bool removeMatching) {\n    int index = _head;\n    int modificationCount = _modificationCount;\n    int i = _head;\n    while (i != _tail) {\n      E element = _table[i];\n      bool remove = identical(removeMatching, test(element));\n      _checkModification(modificationCount);\n      if (remove) {\n        i = _remove(i);\n        modificationCount = ++_modificationCount;\n      } else {\n        i = (i + 1) & (_table.length - 1);\n      }\n    }\n  }\n\n  /**\n   * Remove all elements matched by [test].\n   *\n   * This method is inefficient since it works by repeatedly removing single\n   * elements, each of which can take linear time.\n   */\n  void removeWhere(bool test(E element)) {\n    _filterWhere(test, true);\n  }\n\n  /**\n   * Remove all elements not matched by [test].\n   *\n   * This method is inefficient since it works by repeatedly removing single\n   * elements, each of which can take linear time.\n   */\n  void retainWhere(bool test(E element)) {\n    _filterWhere(test, false);\n  }\n\n  void clear() {\n    if (_head != _tail) {\n      for (int i = _head; i != _tail; i = (i + 1) & (_table.length - 1)) {\n        _table[i] = null;\n      }\n      _head = _tail = 0;\n      _modificationCount++;\n    }\n  }\n\n  String toString() => IterableBase.iterableToFullString(this, \"{\", \"}\");\n\n  // Queue interface.\n\n  void addLast(E element) { _add(element); }\n\n  void addFirst(E element) {\n    _head = (_head - 1) & (_table.length - 1);\n    _table[_head] = element;\n    if (_head == _tail) _grow();\n    _modificationCount++;\n  }\n\n  E removeFirst() {\n    if (_head == _tail) throw IterableElementError.noElement();\n    _modificationCount++;\n    E result = _table[_head];\n    _table[_head] = null;\n    _head = (_head + 1) & (_table.length - 1);\n    return result;\n  }\n\n  E removeLast() {\n    if (_head == _tail) throw IterableElementError.noElement();\n    _modificationCount++;\n    _tail = (_tail - 1) & (_table.length - 1);\n    E result = _table[_tail];\n    _table[_tail] = null;\n    return result;\n  }\n\n  // Internal helper functions.\n\n  /**\n   * Whether [number] is a power of two.\n   *\n   * Only works for positive numbers.\n   */\n  static bool _isPowerOf2(int number) => (number & (number - 1)) == 0;\n\n  /**\n   * Rounds [number] up to the nearest power of 2.\n   *\n   * If [number] is a power of 2 already, it is returned.\n   *\n   * Only works for positive numbers.\n   */\n  static int _nextPowerOf2(int number) {\n    assert(number > 0);\n    number = (number << 2) - 1;\n    for(;;) {\n      int nextNumber = number & (number - 1);\n      if (nextNumber == 0) return number;\n      number = nextNumber;\n    }\n  }\n\n  /** Check if the queue has been modified during iteration. */\n  void _checkModification(int expectedModificationCount) {\n    if (expectedModificationCount != _modificationCount) {\n      throw new ConcurrentModificationError(this);\n    }\n  }\n\n  /** Adds element at end of queue. Used by both [add] and [addAll]. */\n  void _add(E element) {\n    _table[_tail] = element;\n    _tail = (_tail + 1) & (_table.length - 1);\n    if (_head == _tail) _grow();\n    _modificationCount++;\n  }\n\n  /**\n   * Removes the element at [offset] into [_table].\n   *\n   * Removal is performed by linerarly moving elements either before or after\n   * [offset] by one position.\n   *\n   * Returns the new offset of the following element. This may be the same\n   * offset or the following offset depending on how elements are moved\n   * to fill the hole.\n   */\n  int _remove(int offset) {\n    int mask = _table.length - 1;\n    int startDistance = (offset - _head) & mask;\n    int endDistance = (_tail - offset) & mask;\n    if (startDistance < endDistance) {\n      // Closest to start.\n      int i = offset;\n      while (i != _head) {\n        int prevOffset = (i - 1) & mask;\n        _table[i] = _table[prevOffset];\n        i = prevOffset;\n      }\n      _table[_head] = null;\n      _head = (_head + 1) & mask;\n      return (offset + 1) & mask;\n    } else {\n      _tail = (_tail - 1) & mask;\n      int i = offset;\n      while (i != _tail) {\n        int nextOffset = (i + 1) & mask;\n        _table[i] = _table[nextOffset];\n        i = nextOffset;\n      }\n      _table[_tail] = null;\n      return offset;\n    }\n  }\n\n  /**\n   * Grow the table when full.\n   */\n  void _grow() {\n    List<E> newTable = new List<E>(_table.length * 2);\n    int split = _table.length - _head;\n    newTable.setRange(0, split, _table, _head);\n    newTable.setRange(split, split + _head, _table, 0);\n    _head = 0;\n    _tail = _table.length;\n    _table = newTable;\n  }\n\n  int _writeToList(List<E> target) {\n    assert(target.length >= length);\n    if (_head <= _tail) {\n      int length = _tail - _head;\n      target.setRange(0, length, _table, _head);\n      return length;\n    } else {\n      int firstPartSize = _table.length - _head;\n      target.setRange(0, firstPartSize, _table, _head);\n      target.setRange(firstPartSize, firstPartSize + _tail, _table, 0);\n      return _tail + firstPartSize;\n    }\n  }\n\n  /** Grows the table even if it is not full. */\n  void _preGrow(int newElementCount) {\n    assert(newElementCount >= length);\n    int newCapacity = _nextPowerOf2(newElementCount);\n    List<E> newTable = new List<E>(newCapacity);\n    _tail = _writeToList(newTable);\n    _table = newTable;\n    _head = 0;\n  }\n}\n\n/**\n * Iterator for a [ListQueue].\n *\n * Considers any add or remove operation a concurrent modification.\n */\nclass _ListQueueIterator<E> implements Iterator<E> {\n  final ListQueue _queue;\n  final int _end;\n  final int _modificationCount;\n  int _position;\n  E _current;\n\n  _ListQueueIterator(ListQueue queue)\n      : _queue = queue,\n        _end = queue._tail,\n        _modificationCount = queue._modificationCount,\n        _position = queue._head;\n\n  E get current => _current;\n\n  bool moveNext() {\n    _queue._checkModification(_modificationCount);\n    if (_position == _end) {\n      _current = null;\n      return false;\n    }\n    _current = _queue._table[_position];\n    _position = (_position + 1) & (_queue._table.length - 1);\n    return true;\n  }\n}\n\u0000","sdk:/sdk/lib/collection/maps.dart":"// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\npart of dart.collection;\n\n/**\n * Base class for implementing a [Map].\n *\n * This class has a basic implementation of all but five of the members of\n * [Map].\n * A basic `Map` class can be implemented by extending this class and\n * implementing `keys`, `operator[]`, `operator[]=`, `remove` and `clear`.\n * The remaining operations are implemented in terms of these five.\n *\n * The `keys` iterable should have efficient [length] and [contains]\n * operations, and it should catch concurrent modifications of the keys\n * while iterating.\n *\n * A more efficient implementation is usually possible by overriding\n * some of the other members as well.\n */\nabstract class MapBase<K, V> = Object with MapMixin<K, V>;\n\n\n/**\n * Mixin implementing a [Map].\n *\n * This mixin has a basic implementation of all but five of the members of\n * [Map].\n * A basic `Map` class can be implemented by mixin in this class and\n * implementing `keys`, `operator[]`, `operator[]=`, `remove` and `clear`.\n * The remaining operations are implemented in terms of these five.\n *\n * The `keys` iterable should have efficient [length] and [contains]\n * operations, and it should catch concurrent modifications of the keys\n * while iterating.\n *\n * A more efficient implementation is usually possible by overriding\n * some of the other members as well.\n */\nabstract class MapMixin<K, V> implements Map<K, V> {\n  Iterable<K> get keys;\n  V operator[](Object key);\n  operator []=(K key, V value);\n  V remove(Object key);\n  // The `clear` operation should not be based on `remove`.\n  // It should clear the map even if some keys are not equal to themselves.\n  void clear();\n\n  void forEach(void action(K key, V value)) {\n    for (K key in keys) {\n      action(key, this[key]);\n    }\n  }\n\n  void addAll(Map<K, V> other) {\n    for (K key in other.keys) {\n      this[key] = other[key];\n    }\n  }\n\n  bool containsValue(V value) {\n    for (K key in keys) {\n      if (this[key] == value) return true;\n    }\n    return false;\n  }\n\n  V putIfAbsent(K key, V ifAbsent()) {\n    if (keys.contains(key)) {\n      return this[key];\n    }\n    return this[key] = ifAbsent();\n  }\n\n  bool containsKey(Object key) => keys.contains(key);\n  int get length => keys.length;\n  bool get isEmpty => keys.isEmpty;\n  bool get isNotEmpty => keys.isNotEmpty;\n  Iterable<V> get values => new _MapBaseValueIterable<V>(this);\n  String toString() => Maps.mapToString(this);\n}\n\n/**\n * Basic implementation of an unmodifiable [Map].\n *\n * This class has a basic implementation of all but two of the members of\n * an umodifiable [Map].\n * A simple unmodifiable `Map` class can be implemented by extending this\n * class and implementing `keys` and `operator[]`.\n *\n * Modifying operations throw when used.\n * The remaining non-modifying operations are implemented in terms of `keys`\n * and `operator[]`.\n *\n * The `keys` iterable should have efficient [length] and [contains]\n * operations, and it should catch concurrent modifications of the keys\n * while iterating.\n *\n * A more efficient implementation is usually possible by overriding\n * some of the other members as well.\n */\nabstract class UnmodifiableMapBase<K, V> =\n    MapBase<K, V> with _UnmodifiableMapMixin<K, V>;\n\n/**\n * Implementation of [Map.values] based on the map and its [Map.keys] iterable.\n *\n * Iterable that iterates over the values of a `Map`.\n * It accesses the values by iterating over the keys of the map, and using the\n * map's `operator[]` to lookup the keys.\n */\nclass _MapBaseValueIterable<V> extends IterableBase<V>\n                               implements EfficientLength {\n  final Map _map;\n  _MapBaseValueIterable(this._map);\n\n  int get length => _map.length;\n  bool get isEmpty => _map.isEmpty;\n  bool get isNotEmpty => _map.isNotEmpty;\n  V get first => _map[_map.keys.first];\n  V get single => _map[_map.keys.single];\n  V get last => _map[_map.keys.last];\n\n  Iterator<V> get iterator => new _MapBaseValueIterator<V>(_map);\n}\n\n/**\n * Iterator created by [_MapBaseValueIterable].\n *\n * Iterates over the values of a map by iterating its keys and lookup up the\n * values.\n */\nclass _MapBaseValueIterator<V> implements Iterator<V> {\n  final Iterator _keys;\n  final Map _map;\n  V _current = null;\n\n  _MapBaseValueIterator(Map map) : _map = map, _keys = map.keys.iterator;\n\n  bool moveNext() {\n    if (_keys.moveNext()) {\n      _current = _map[_keys.current];\n      return true;\n    }\n    _current = null;\n    return false;\n  }\n\n  V get current => _current;\n}\n\n/**\n * Mixin that overrides mutating map operations with implementations that throw.\n */\nabstract class _UnmodifiableMapMixin<K, V> implements Map<K, V> {\n  void operator[]=(K key, V value) {\n    throw new UnsupportedError(\"Cannot modify unmodifiable map\");\n  }\n  void addAll(Map<K, V> other) {\n    throw new UnsupportedError(\"Cannot modify unmodifiable map\");\n  }\n  void clear() {\n    throw new UnsupportedError(\"Cannot modify unmodifiable map\");\n  }\n  V remove(Object key) {\n    throw new UnsupportedError(\"Cannot modify unmodifiable map\");\n  }\n  V putIfAbsent(K key, V ifAbsent()) {\n    throw new UnsupportedError(\"Cannot modify unmodifiable map\");\n  }\n}\n\n/**\n * Wrapper around a class that implements [Map] that only exposes `Map` members.\n *\n * A simple wrapper that delegates all `Map` members to the map provided in the\n * constructor.\n *\n * Base for delegating map implementations like [UnmodifiableMapView].\n */\nclass MapView<K, V> implements Map<K, V> {\n  final Map<K, V> _map;\n  const MapView(Map<K, V> map) : _map = map;\n\n  V operator[](Object key) => _map[key];\n  void operator[]=(K key, V value) { _map[key] = value; }\n  void addAll(Map<K, V> other) { _map.addAll(other); }\n  void clear() { _map.clear(); }\n  V putIfAbsent(K key, V ifAbsent()) => _map.putIfAbsent(key, ifAbsent);\n  bool containsKey(Object key) => _map.containsKey(key);\n  bool containsValue(Object value) => _map.containsValue(value);\n  void forEach(void action(K key, V value)) { _map.forEach(action); }\n  bool get isEmpty => _map.isEmpty;\n  bool get isNotEmpty => _map.isNotEmpty;\n  int get length => _map.length;\n  Iterable<K> get keys => _map.keys;\n  V remove(Object key) => _map.remove(key);\n  String toString() => _map.toString();\n  Iterable<V> get values => _map.values;\n}\n\n/**\n * View of a [Map] that disallow modifying the map.\n *\n * A wrapper around a `Map` that forwards all members to the map provided in\n * the constructor, except for operations that modify the map.\n * Modifying operations throw instead.\n */\nclass UnmodifiableMapView<K, V> =\n    MapView<K, V> with _UnmodifiableMapMixin<K, V>;\n\n/**\n * Helper class which implements complex [Map] operations\n * in term of basic ones ([Map.keys], [Map.operator []],\n * [Map.operator []=] and [Map.remove].)  Not all methods are\n * necessary to implement each particular operation.\n */\nclass Maps {\n  static bool containsValue(Map map, value) {\n    for (final v in map.values) {\n      if (value == v) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  static bool containsKey(Map map, key) {\n    for (final k in map.keys) {\n      if (key == k) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  static putIfAbsent(Map map, key, ifAbsent()) {\n    if (map.containsKey(key)) {\n      return map[key];\n    }\n    final v = ifAbsent();\n    map[key] = v;\n    return v;\n  }\n\n  static clear(Map map) {\n    for (final k in map.keys.toList()) {\n      map.remove(k);\n    }\n  }\n\n  static forEach(Map map, void f(key, value)) {\n    for (final k in map.keys) {\n      f(k, map[k]);\n    }\n  }\n\n  static Iterable getValues(Map map) {\n    return map.keys.map((key) => map[key]);\n  }\n\n  static int length(Map map) => map.keys.length;\n\n  static bool isEmpty(Map map) => map.keys.isEmpty;\n\n  static bool isNotEmpty(Map map) => map.keys.isNotEmpty;\n\n  /**\n   * Returns a string representing the specified map. The returned string\n   * looks like this: [:'{key0: value0, key1: value1, ... keyN: valueN}':].\n   * The value returned by its [toString] method is used to represent each\n   * key or value.\n   *\n   * If the map collection contains a reference to itself, either\n   * directly as a key or value, or indirectly through other collections\n   * or maps, the contained reference is rendered as [:'{...}':]. This\n   * prevents the infinite regress that would otherwise occur. So, for example,\n   * calling this method on a map whose sole entry maps the string key 'me'\n   * to a reference to the map would return [:'{me: {...}}':].\n   *\n   * A typical implementation of a map's [toString] method will\n   * simply return the results of this method applied to the collection.\n   */\n  static String mapToString(Map m) {\n    // Reuse the list in IterableBase for detecting toString cycles.\n    if (IterableBase._isToStringVisiting(m)) { return '{...}'; }\n\n    var result = new StringBuffer();\n    try {\n      IterableBase._toStringVisiting.add(m);\n      result.write('{');\n      bool first = true;\n      m.forEach((k, v) {\n        if(!first) {\n          result.write(', ');\n        }\n        first = false;\n        result.write(k);\n        result.write(': ');\n        result.write(v);\n      });\n      result.write('}');\n    } finally {\n      assert(identical(IterableBase._toStringVisiting.last, m));\n      IterableBase._toStringVisiting.removeLast();\n    }\n\n    return result.toString();\n  }\n\n  static _id(x) => x;\n\n  /**\n   * Fills a map with key/value pairs computed from [iterable].\n   *\n   * This method is used by Map classes in the named constructor fromIterable.\n   */\n  static void _fillMapWithMappedIterable(Map map, Iterable iterable,\n                                         key(element), value(element)) {\n    if (key == null) key = _id;\n    if (value == null) value = _id;\n\n    for (var element in iterable) {\n      map[key(element)] = value(element);\n    }\n  }\n\n  /**\n   * Fills a map by associating the [keys] to [values].\n   *\n   * This method is used by Map classes in the named constructor fromIterables.\n   */\n  static void _fillMapWithIterables(Map map, Iterable keys,\n                                    Iterable values) {\n    Iterator keyIterator = keys.iterator;\n    Iterator valueIterator = values.iterator;\n\n    bool hasNextKey = keyIterator.moveNext();\n    bool hasNextValue = valueIterator.moveNext();\n\n    while (hasNextKey && hasNextValue) {\n      map[keyIterator.current] = valueIterator.current;\n      hasNextKey = keyIterator.moveNext();\n      hasNextValue = valueIterator.moveNext();\n    }\n\n    if (hasNextKey || hasNextValue) {\n      throw new ArgumentError(\"Iterables do not have same length.\");\n    }\n  }\n}\n\u0000","sdk:/sdk/lib/collection/list.dart":"// Copyright (c) 2013, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\npart of dart.collection;\n\n/**\n * Abstract implementation of a list.\n *\n * All operations are defined in terms of `length`, `operator[]`,\n * `operator[]=` and `length=`, which need to be implemented.\n *\n * *NOTICE*: Forwarding just these four operations to a normal growable [List]\n * (as created by `new List()`) will give very bad performance for `add` and\n * `addAll` operations of `ListBase`. These operations are implemented by\n * increasing the length of the list by one for each `add` operation, and\n * repeatedly increasing the length of a growable list is not efficient.\n * To avoid this, either override 'add' and 'addAll' to also forward directly\n * to the growable list, or, preferably, use `DelegatingList` from\n * \"package:collection/wrappers.dart\" instead.\n */\nabstract class ListBase<E> extends Object with ListMixin<E> {\n  /**\n   * Convert a `List` to a string as `[each, element, as, string]`.\n   *\n   * Handles circular references where converting one of the elements\n   * to a string ends up converting [list] to a string again.\n   */\n  static String listToString(List list) =>\n      IterableBase.iterableToFullString(list, '[', ']');\n}\n\n/**\n * Base implementation of a [List] class.\n *\n * This class can be used as a mixin.\n *\n * This implements all read operations using only the `length` and\n * `operator[]` members. It implements write operations using those and\n * `length=` and `operator[]=`\n *\n * *NOTICE*: Forwarding just these four operations to a normal growable [List]\n * (as created by `new List()`) will give very bad performance for `add` and\n * `addAll` operations of `ListBase`. These operations are implemented by\n * increasing the length of the list by one for each `add` operation, and\n * repeatedly increasing the length of a growable list is not efficient.\n * To avoid this, either override 'add' and 'addAll' to also forward directly\n * to the growable list, or, if possible, use `DelegatingList` from\n * \"package:collection/wrappers.dart\" instead.\n */\nabstract class ListMixin<E> implements List<E> {\n  // Iterable interface.\n  Iterator<E> get iterator => new ListIterator<E>(this);\n\n  E elementAt(int index) => this[index];\n\n  void forEach(void action(E element)) {\n    int length = this.length;\n    for (int i = 0; i < length; i++) {\n      action(this[i]);\n      if (length != this.length) {\n        throw new ConcurrentModificationError(this);\n      }\n    }\n  }\n\n  bool get isEmpty => length == 0;\n\n  bool get isNotEmpty => !isEmpty;\n\n  E get first {\n    if (length == 0) throw new StateError(\"No elements\");\n    return this[0];\n  }\n\n  E get last {\n    if (length == 0) throw new StateError(\"No elements\");\n    return this[length - 1];\n  }\n\n  E get single {\n    if (length == 0) throw new StateError(\"No elements\");\n    if (length > 1) throw new StateError(\"Too many elements\");\n    return this[0];\n  }\n\n  bool contains(Object element) {\n    int length = this.length;\n    for (int i = 0; i < this.length; i++) {\n      if (this[i] == element) return true;\n      if (length != this.length) {\n        throw new ConcurrentModificationError(this);\n      }\n    }\n    return false;\n  }\n\n  bool every(bool test(E element)) {\n    int length = this.length;\n    for (int i = 0; i < length; i++) {\n      if (!test(this[i])) return false;\n      if (length != this.length) {\n        throw new ConcurrentModificationError(this);\n      }\n    }\n    return true;\n  }\n\n  bool any(bool test(E element)) {\n    int length = this.length;\n    for (int i = 0; i < length; i++) {\n      if (test(this[i])) return true;\n      if (length != this.length) {\n        throw new ConcurrentModificationError(this);\n      }\n    }\n    return false;\n  }\n\n  dynamic firstWhere(bool test(E element), { Object orElse() }) {\n    int length = this.length;\n    for (int i = 0; i < length; i++) {\n      E element = this[i];\n      if (test(element)) return element;\n      if (length != this.length) {\n        throw new ConcurrentModificationError(this);\n      }\n    }\n    if (orElse != null) return orElse();\n    throw new StateError(\"No matching element\");\n  }\n\n  dynamic lastWhere(bool test(E element), { Object orElse() }) {\n    int length = this.length;\n    for (int i = length - 1; i >= 0; i--) {\n      E element = this[i];\n      if (test(element)) return element;\n      if (length != this.length) {\n        throw new ConcurrentModificationError(this);\n      }\n    }\n    if (orElse != null) return orElse();\n    throw new StateError(\"No matching element\");\n  }\n\n  E singleWhere(bool test(E element)) {\n    int length = this.length;\n    E match = null;\n    bool matchFound = false;\n    for (int i = 0; i < length; i++) {\n      E element = this[i];\n      if (test(element)) {\n        if (matchFound) {\n          throw new StateError(\"More than one matching element\");\n        }\n        matchFound = true;\n        match = element;\n      }\n      if (length != this.length) {\n        throw new ConcurrentModificationError(this);\n      }\n    }\n    if (matchFound) return match;\n    throw new StateError(\"No matching element\");\n  }\n\n  String join([String separator = \"\"]) {\n    if (length == 0) return \"\";\n    StringBuffer buffer = new StringBuffer()..writeAll(this, separator);\n    return buffer.toString();\n  }\n\n  Iterable<E> where(bool test(E element)) => new WhereIterable<E>(this, test);\n\n  Iterable map(f(E element)) => new MappedListIterable(this, f);\n\n  Iterable expand(Iterable f(E element)) =>\n      new ExpandIterable<E, dynamic>(this, f);\n\n  E reduce(E combine(E previousValue, E element)) {\n    if (length == 0) throw new StateError(\"No elements\");\n    E value = this[0];\n    for (int i = 1; i < length; i++) {\n      value = combine(value, this[i]);\n    }\n    return value;\n  }\n\n  fold(var initialValue, combine(var previousValue, E element)) {\n    var value = initialValue;\n    int length = this.length;\n    for (int i = 0; i < length; i++) {\n      value = combine(value, this[i]);\n      if (length != this.length) {\n        throw new ConcurrentModificationError(this);\n      }\n    }\n    return value;\n  }\n\n  Iterable<E> skip(int count) => new SubListIterable(this, count, null);\n\n  Iterable<E> skipWhile(bool test(E element)) {\n    return new SkipWhileIterable<E>(this, test);\n  }\n\n  Iterable<E> take(int count) => new SubListIterable(this, 0, count);\n\n  Iterable<E> takeWhile(bool test(E element)) {\n    return new TakeWhileIterable<E>(this, test);\n  }\n\n  List<E> toList({ bool growable: true }) {\n    List<E> result;\n    if (growable) {\n      result = new List<E>()..length = length;\n    } else {\n      result = new List<E>(length);\n    }\n    for (int i = 0; i < length; i++) {\n      result[i] = this[i];\n    }\n    return result;\n  }\n\n  Set<E> toSet() {\n    Set<E> result = new Set<E>();\n    for (int i = 0; i < length; i++) {\n      result.add(this[i]);\n    }\n    return result;\n  }\n\n  // Collection interface.\n  void add(E element) {\n    this[this.length++] = element;\n  }\n\n  void addAll(Iterable<E> iterable) {\n    for (E element in iterable) {\n      this[this.length++] = element;\n    }\n  }\n\n  bool remove(Object element) {\n    for (int i = 0; i < this.length; i++) {\n      if (this[i] == element) {\n        this.setRange(i, this.length - 1, this, i + 1);\n        this.length -= 1;\n        return true;\n      }\n    }\n    return false;\n  }\n\n  void removeWhere(bool test(E element)) {\n    _filter(this, test, false);\n  }\n\n  void retainWhere(bool test(E element)) {\n    _filter(this, test, true);\n  }\n\n  static void _filter(List source,\n                      bool test(var element),\n                      bool retainMatching) {\n    List retained = [];\n    int length = source.length;\n    for (int i = 0; i < length; i++) {\n      var element = source[i];\n      if (test(element) == retainMatching) {\n        retained.add(element);\n      }\n      if (length != source.length) {\n        throw new ConcurrentModificationError(source);\n      }\n    }\n    if (retained.length != source.length) {\n      source.setRange(0, retained.length, retained);\n      source.length = retained.length;\n    }\n  }\n\n  void clear() { this.length = 0; }\n\n  // List interface.\n\n  E removeLast() {\n    if (length == 0) {\n      throw new StateError(\"No elements\");\n    }\n    E result = this[length - 1];\n    length--;\n    return result;\n  }\n\n  void sort([int compare(E a, E b)]) {\n    if (compare == null) {\n      var defaultCompare = Comparable.compare;\n      compare = defaultCompare;\n    }\n    Sort.sort(this, compare);\n  }\n\n  void shuffle([Random random]) {\n    if (random == null) random = new Random();\n    int length = this.length;\n    while (length > 1) {\n      int pos = random.nextInt(length);\n      length -= 1;\n      var tmp = this[length];\n      this[length] = this[pos];\n      this[pos] = tmp;\n    }\n  }\n\n  Map<int, E> asMap() {\n    return new ListMapView(this);\n  }\n\n  void _rangeCheck(int start, int end) {\n    if (start < 0 || start > this.length) {\n      throw new RangeError.range(start, 0, this.length);\n    }\n    if (end < start || end > this.length) {\n      throw new RangeError.range(end, start, this.length);\n    }\n  }\n\n  List<E> sublist(int start, [int end]) {\n    if (end == null) end = this.length;\n    _rangeCheck(start, end);\n    int length = end - start;\n    List<E> result = new List<E>()..length = length;\n    for (int i = 0; i < length; i++) {\n      result[i] = this[start + i];\n    }\n    return result;\n  }\n\n  Iterable<E> getRange(int start, int end) {\n    _rangeCheck(start, end);\n    return new SubListIterable(this, start, end);\n  }\n\n  void removeRange(int start, int end) {\n    _rangeCheck(start, end);\n    int length = end - start;\n    setRange(start, this.length - length, this, end);\n    this.length -= length;\n  }\n\n  void fillRange(int start, int end, [E fill]) {\n    _rangeCheck(start, end);\n    for (int i = start; i < end; i++) {\n      this[i] = fill;\n    }\n  }\n\n  void setRange(int start, int end, Iterable<E> iterable, [int skipCount = 0]) {\n    _rangeCheck(start, end);\n    int length = end - start;\n    if (length == 0) return;\n\n    if (skipCount < 0) throw new ArgumentError(skipCount);\n\n    List otherList;\n    int otherStart;\n    // TODO(floitsch): Make this accept more.\n    if (iterable is List) {\n      otherList = iterable;\n      otherStart = skipCount;\n    } else {\n      otherList = iterable.skip(skipCount).toList(growable: false);\n      otherStart = 0;\n    }\n    if (otherStart + length > otherList.length) {\n      throw new StateError(\"Not enough elements\");\n    }\n    if (otherStart < start) {\n      // Copy backwards to ensure correct copy if [from] is this.\n      for (int i = length - 1; i >= 0; i--) {\n        this[start + i] = otherList[otherStart + i];\n      }\n    } else {\n      for (int i = 0; i < length; i++) {\n        this[start + i] = otherList[otherStart + i];\n      }\n    }\n  }\n\n  void replaceRange(int start, int end, Iterable<E> newContents) {\n    _rangeCheck(start, end);\n    if (newContents is! EfficientLength) {\n      newContents = newContents.toList();\n    }\n    int removeLength = end - start;\n    int insertLength = newContents.length;\n    if (removeLength >= insertLength) {\n      int delta = removeLength - insertLength;\n      int insertEnd = start + insertLength;\n      int newLength = this.length - delta;\n      this.setRange(start, insertEnd, newContents);\n      if (delta != 0) {\n        this.setRange(insertEnd, newLength, this, end);\n        this.length = newLength;\n      }\n    } else {\n      int delta = insertLength - removeLength;\n      int newLength = this.length + delta;\n      int insertEnd = start + insertLength;  // aka. end + delta.\n      this.length = newLength;\n      this.setRange(insertEnd, newLength, this, end);\n      this.setRange(start, insertEnd, newContents);\n    }\n  }\n\n  int indexOf(Object element, [int startIndex = 0]) {\n    if (startIndex >= this.length) {\n      return -1;\n    }\n    if (startIndex < 0) {\n      startIndex = 0;\n    }\n    for (int i = startIndex; i < this.length; i++) {\n      if (this[i] == element) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Returns the last index in the list [a] of the given [element], starting\n   * the search at index [startIndex] to 0.\n   * Returns -1 if [element] is not found.\n   */\n  int lastIndexOf(Object element, [int startIndex]) {\n    if (startIndex == null) {\n      startIndex = this.length - 1;\n    } else {\n      if (startIndex < 0) {\n        return -1;\n      }\n      if (startIndex >= this.length) {\n        startIndex = this.length - 1;\n      }\n    }\n    for (int i = startIndex; i >= 0; i--) {\n      if (this[i] == element) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  void insert(int index, E element) {\n    if (index < 0 || index > length) {\n      throw new RangeError.range(index, 0, length);\n    }\n    if (index == this.length) {\n      add(element);\n      return;\n    }\n    // We are modifying the length just below the is-check. Without the check\n    // Array.copy could throw an exception, leaving the list in a bad state\n    // (with a length that has been increased, but without a new element).\n    if (index is! int) throw new ArgumentError(index);\n    this.length++;\n    setRange(index + 1, this.length, this, index);\n    this[index] = element;\n  }\n\n  E removeAt(int index) {\n    E result = this[index];\n    setRange(index, this.length - 1, this, index + 1);\n    length--;\n    return result;\n  }\n\n  void insertAll(int index, Iterable<E> iterable) {\n    if (index < 0 || index > length) {\n      throw new RangeError.range(index, 0, length);\n    }\n    if (iterable is EfficientLength) {\n      iterable = iterable.toList();\n    }\n    int insertionLength = iterable.length;\n    // There might be errors after the length change, in which case the list\n    // will end up being modified but the operation not complete. Unless we\n    // always go through a \"toList\" we can't really avoid that.\n    this.length += insertionLength;\n    setRange(index + insertionLength, this.length, this, index);\n    setAll(index, iterable);\n  }\n\n  void setAll(int index, Iterable<E> iterable) {\n    if (iterable is List) {\n      setRange(index, index + iterable.length, iterable);\n    } else {\n      for (E element in iterable) {\n        this[index++] = element;\n      }\n    }\n  }\n\n  Iterable<E> get reversed => new ReversedListIterable(this);\n\n  String toString() => IterableBase.iterableToFullString(this, '[', ']');\n}\n\u0000","sdk:/sdk/lib/collection/linked_list.dart":"// Copyright (c) 2013, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\npart of dart.collection;\n\n\n/**\n * A specialized double-linked list of elements that extends [LinkedListEntry].\n *\n * This is not a generic data structure. It only accepts elements that extend\n * the [LinkedListEntry] class. See the [Queue] implementations for\n * generic collections that allow constant time adding and removing at the ends.\n *\n * This is not a [List] implementation. Despite its name, this class does not\n * implement the [List] interface. It does not allow constant time lookup by\n * index.\n *\n * Because the elements themselves contain the links of this linked list,\n * each element can be in only one list at a time. To add an element to another\n * list, it must first be removed from its current list (if any).\n *\n * In return, each element knows its own place in the linked list, as well as\n * which list it is in. This allows constant time [LinkedListEntry.addAfter],\n * [LinkedListEntry.addBefore] and [LinkedListEntry.unlink] operations\n * when all you have is the element.\n *\n * A `LinkedList` also allows constant time adding and removing at either end,\n * and a constant time length getter.\n */\nclass LinkedList<E extends LinkedListEntry<E>>\n    extends IterableBase<E>\n    implements _LinkedListLink {\n\n  int _modificationCount = 0;\n  int _length = 0;\n  _LinkedListLink _next;\n  _LinkedListLink _previous;\n\n  /**\n   * Construct a new empty linked list.\n   */\n  LinkedList() {\n    _next = _previous = this;\n  }\n\n  /**\n   * Add [entry] to the beginning of the linked list.\n   */\n  void addFirst(E entry) {\n    _insertAfter(this, entry);\n  }\n\n  /**\n   * Add [entry] to the end of the linked list.\n   */\n  void add(E entry) {\n    _insertAfter(_previous, entry);\n  }\n\n  /**\n   * Add [entries] to the end of the linked list.\n   */\n  void addAll(Iterable<E> entries) {\n    entries.forEach((entry) => _insertAfter(_previous, entry));\n  }\n\n  /**\n   * Remove [entry] from the linked list.\n   *\n   * Returns false and does nothing if [entry] is not in this linked list.\n   *\n   * This is equivalent to calling `entry.unlink()` if the entry is in this\n   * list.\n   */\n  bool remove(E entry) {\n    if (entry._list != this) return false;\n    _unlink(entry);  // Unlink will decrement length.\n    return true;\n  }\n\n  Iterator<E> get iterator => new _LinkedListIterator<E>(this);\n\n  int get length => _length;\n\n  /**\n   * Remove all elements from this linked list.\n   */\n  void clear() {\n    _modificationCount++;\n    _LinkedListLink next = _next;\n    while (!identical(next, this)) {\n      E entry = next;\n      next = entry._next;\n      entry._next = entry._previous = entry._list = null;\n    }\n    _next = _previous = this;\n    _length = 0;\n  }\n\n  E get first {\n    if (identical(_next, this)) {\n      throw new StateError('No such element');\n    }\n    return _next;\n  }\n\n  E get last {\n    if (identical(_previous, this)) {\n      throw new StateError('No such element');\n    }\n    return _previous;\n  }\n\n  E get single {\n    if (identical(_previous, this)) {\n      throw new StateError('No such element');\n    }\n    if (!identical(_previous, _next)) {\n      throw new StateError('Too many elements');\n    }\n    return _next;\n  }\n\n  /**\n   * Call [action] with each entry in this linked list.\n   *\n   * It's an error if [action] modify the linked list.\n   */\n  void forEach(void action(E entry)) {\n    int modificationCount = _modificationCount;\n    _LinkedListLink current = _next;\n    while (!identical(current, this)) {\n      action(current);\n      if (modificationCount != _modificationCount) {\n        throw new ConcurrentModificationError(this);\n      }\n      current = current._next;\n    }\n  }\n\n  bool get isEmpty => _length == 0;\n\n  void _insertAfter(_LinkedListLink entry, E newEntry) {\n    if (newEntry.list != null) {\n      throw new StateError(\n          'LinkedListEntry is already in a LinkedList');\n    }\n    _modificationCount++;\n    newEntry._list = this;\n    var predecessor = entry;\n    var successor = entry._next;\n    successor._previous = newEntry;\n    newEntry._previous = predecessor;\n    newEntry._next = successor;\n    predecessor._next = newEntry;\n    _length++;\n  }\n\n  void _unlink(LinkedListEntry<E> entry) {\n    _modificationCount++;\n    entry._next._previous = entry._previous;\n    entry._previous._next = entry._next;\n    _length--;\n    entry._list = entry._next = entry._previous = null;\n  }\n}\n\n\nclass _LinkedListIterator<E extends LinkedListEntry<E>>\n    implements Iterator<E> {\n  final LinkedList<E> _list;\n  final int _modificationCount;\n  E _current;\n  _LinkedListLink _next;\n\n  _LinkedListIterator(LinkedList<E> list)\n    : _list = list,\n      _modificationCount = list._modificationCount,\n      _next = list._next;\n\n  E get current => _current;\n\n  bool moveNext() {\n    if (identical(_next, _list)) {\n      _current = null;\n      return false;\n    }\n    if (_modificationCount != _list._modificationCount) {\n      throw new ConcurrentModificationError(this);\n    }\n    _current = _next;\n    _next = _next._next;\n    return true;\n  }\n}\n\n\nclass _LinkedListLink {\n  _LinkedListLink _next;\n  _LinkedListLink _previous;\n}\n\n\n/**\n * An object that can be an element in a [LinkedList].\n *\n * All elements of a `LinkedList` must extend this class.\n * The class provides the internal links that link elements together\n * in the `LinkedList`, and a reference to the linked list itself\n * that an element is currently part of.\n *\n * An entry can be in at most one linked list at a time.\n * While an entry is in a linked list, the [list] property points to that\n * linked list, and otherwise the `list` property is `null`.\n *\n * When created, an entry is not in any linked list.\n */\nabstract class LinkedListEntry<E extends LinkedListEntry<E>>\n    implements _LinkedListLink {\n  LinkedList<E> _list;\n  _LinkedListLink _next;\n  _LinkedListLink _previous;\n\n  /**\n   * Get the linked list containing this element.\n   *\n   * Returns `null` if this entry is not currently in any list.\n   */\n  LinkedList<E> get list => _list;\n\n  /**\n   * Unlink the element from its linked list.\n   *\n   * The entry must currently be in a linked list when this method is called.\n   */\n  void unlink() {\n    _list._unlink(this);\n  }\n\n  /**\n   * Return the succeessor of this element in its linked list.\n   *\n   * Returns `null` if there is no successor in the linked list, or if this\n   * entry is not currently in any list.\n   */\n  E get next {\n    if (identical(_next, _list)) return null;\n    E result = _next;\n    return result;\n  }\n\n  /**\n   * Return the predecessor of this element in its linked list.\n   *\n   * Returns `null` if there is no predecessor in the linked list, or if this\n   * entry is not currently in any list.\n   */\n  E get previous {\n    if (identical(_previous, _list)) return null;\n    return _previous as E;\n  }\n\n  /**\n   * Insert an element after this element in this element's linked list.\n   *\n   * This entry must be in a linked list when this method is called.\n   * The [entry] must not be in a linked list.\n   */\n  void insertAfter(E entry) {\n    _list._insertAfter(this, entry);\n  }\n\n  /**\n   * Insert an element before this element in this element's linked list.\n   *\n   * This entry must be in a linked list when this method is called.\n   * The [entry] must not be in a linked list.\n   */\n  void insertBefore(E entry) {\n    _list._insertAfter(_previous, entry);\n  }\n}\n\u0000","sdk:/sdk/lib/collection/linked_hash_set.dart":"// Copyright (c) 2013, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\npart of dart.collection;\n\n/**\n * A [LinkedHashSet] is a hash-table based [Set] implementation.\n *\n * The `LinkedHashSet` also keep track of the order that elements were inserted\n * in, and iteration happens in first-to-last insertion order.\n *\n * The elements of a `LinkedHashSet` must have consistent [Object.operator==]\n * and [Object.hashCode] implementations. This means that the `==` operator\n * must define a stable equivalence relation on the elements (reflexive,\n * symmetric, transitive, and consistent over time), and that `hashCode`\n * must be the same for objects that are considered equal by `==`.\n *\n * The set allows `null` as an element.\n *\n * Iteration of elements is done in element insertion order.\n * An element that was added after another will occur later in the iteration.\n * Adding an element that is already in the set\n * does not change its position in the iteration order,\n * but removing an element and adding it again,\n * will make it the last element of an iteration.\n *\n * Most simple operations on `HashSet` are done in (potentially amortized)\n * constant time: [add], [contains], [remove], and [length], provided the hash\n * codes of objects are well distributed..\n */\nabstract class LinkedHashSet<E> implements HashSet<E> {\n  /**\n   * Create an insertion-ordered hash set using the provided\n   * [equals] and [hashCode].\n   *\n   * The provided [equals] must define a stable equivalence relation, and\n   * [hashCode] must be consistent with [equals]. If the [equals] or [hashCode]\n   * methods won't work on all objects, but only to instances of E, the\n   * [isValidKey] predicate can be used to restrict the keys that they are\n   * applied to. Any key for which [isValidKey] returns false is automatically\n   * assumed to not be in the set.\n   *\n   * If [equals] or [hashCode] are omitted, the set uses\n   * the objects' intrinsic [Object.operator==] and [Object.hashCode],\n   *\n   * If [isValidKey] is omitted, it defaults to testing if the object is an\n   * [E] instance.\n   *\n   * If you supply one of [equals] and [hashCode],\n   * you should generally also to supply the other.\n   * An example would be using [identical] and [identityHashCode],\n   * which is equivalent to using the shorthand [LinkedSet.identity]).\n   */\n  external factory LinkedHashSet({ bool equals(E e1, E e2),\n                                   int hashCode(E e),\n                                   bool isValidKey(potentialKey) });\n\n  /**\n   * Creates an insertion-ordered identity-based set.\n   *\n   * Effectively a shorthand for:\n   *\n   *     new LinkedHashSet(equals: identical, hashCode: identityHashCodeOf)\n   */\n  external factory LinkedHashSet.identity();\n\n  factory LinkedHashSet.from(Iterable<E> iterable) {\n    return new LinkedHashSet<E>()..addAll(iterable);\n  }\n\n  /**\n   * Executes a function on each element of the set.\n   *\n   * The elements are iterated in insertion order.\n   */\n  void forEach(void action(E element));\n\n  /**\n   * Provides an iterator that iterates over the elements in insertion order.\n   */\n  Iterator<E> get iterator;\n}\n\u0000","sdk:/sdk/lib/collection/linked_hash_map.dart":"// Copyright (c) 2013, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\npart of dart.collection;\n\n/**\n * A hash-table based implementation of [Map].\n *\n * The insertion order of keys is remembered,\n * and keys are iterated in the order they were insertion into the map.\n * Values are iterated in their corresponding key's order.\n * Changing a key's value, when the key is already in the map,\n * does not change the iteration order,\n * but removing the key and adding it again\n * will make it be last in the iteration order.\n *\n * The keys of a `LinkedHashMap` must have consistent [Object.operator==]\n * and [Object.hashCode] implementations. This means that the `==` operator\n * must define a stable equivalence relation on the keys (reflexive,\n * symmetric, transitive, and consistent over time), and that `hashCode`\n * must be the same for objects that are considered equal by `==`.\n *\n * The map allows `null` as a key.\n */\nabstract class LinkedHashMap<K, V> implements HashMap<K, V> {\n  /**\n   * Creates an insertion-ordered hash-table based [Map].\n   *\n   * If [equals] is provided, it is used to compare the keys in the table with\n   * new keys. If [equals] is omitted, the key's own [Object.operator==] is used\n   * instead.\n   *\n   * Similar, if [hashCode] is provided, it is used to produce a hash value\n   * for keys in order to place them in the hash table. If it is omitted, the\n   * key's own [Object.hashCode] is used.\n   *\n   * If using methods like [operator[]], [remove] and [containsKey] together\n   * with a custom equality and hashcode, an extra `isValidKey` function\n   * can be supplied. This function is called before calling [equals] or\n   * [hashCode] with an argument that may not be a [K] instance, and if the\n   * call returns false, the key is assumed to not be in the set.\n   * The [isValidKey] function defaults to just testing if the object is a\n   * [K] instance.\n   *\n   * The used `equals` and `hashCode` method should always be consistent,\n   * so that if `equals(a, b)` then `hashCode(a) == hashCode(b)`. The hash\n   * of an object, or what it compares equal to, should not change while the\n   * object is in the table. If it does change, the result is unpredictable.\n   *\n   * If you supply one of [equals] and [hashCode],\n   * you should generally also to supply the other.\n   * An example would be using [identical] and [identityHashCode],\n   * which is equivalent to using the shorthand [LinkedHashMap.identity]).\n   */\n  external factory LinkedHashMap({ bool equals(K key1, K key2),\n                                   int hashCode(K key),\n                                   bool isValidKey(potentialKey) });\n\n  /**\n   * Creates an insertion-ordered identity-based map.\n   *\n   * Effectively a shorthand for:\n   *\n   *     new LinkedHashMap(equals: identical, hashCode: identityHashCodeOf)\n   */\n  external factory LinkedHashMap.identity();\n\n  /**\n   * Creates a [LinkedHashMap] that contains all key value pairs of [other].\n   */\n  factory LinkedHashMap.from(Map<K, V> other) {\n    return new LinkedHashMap<K, V>()..addAll(other);\n  }\n\n  /**\n   * Creates a [LinkedHashMap] where the keys and values are computed from the\n   * [iterable].\n   *\n   * For each element of the [iterable] this constructor computes a key/value\n   * pair, by applying [key] and [value] respectively.\n   *\n   * The keys of the key/value pairs do not need to be unique. The last\n   * occurrence of a key will simply overwrite any previous value.\n   *\n   * If no values are specified for [key] and [value] the default is the\n   * identity function.\n   */\n  factory LinkedHashMap.fromIterable(Iterable iterable,\n      {K key(element), V value(element)}) {\n    LinkedHashMap<K, V> map = new LinkedHashMap<K, V>();\n    Maps._fillMapWithMappedIterable(map, iterable, key, value);\n    return map;\n  }\n\n  /**\n   * Creates a [LinkedHashMap] associating the given [keys] to [values].\n   *\n   * This constructor iterates over [keys] and [values] and maps each element of\n   * [keys] to the corresponding element of [values].\n   *\n   * If [keys] contains the same object multiple times, the last occurrence\n   * overwrites the previous value.\n   *\n   * It is an error if the two [Iterable]s don't have the same length.\n   */\n  factory LinkedHashMap.fromIterables(Iterable<K> keys, Iterable<V> values) {\n    LinkedHashMap<K, V> map = new LinkedHashMap<K, V>();\n    Maps._fillMapWithIterables(map, keys, values);\n    return map;\n  }\n}\n\u0000","sdk:/sdk/lib/collection/iterator.dart":"// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\npart of dart.collection;\n\n/**\n * The [HasNextIterator] class wraps an [Iterator] and provides methods to\n * iterate over an object using `hasNext` and `next`.\n *\n * An [HasNextIterator] does not implement the [Iterator] interface.\n */\nclass HasNextIterator<E> {\n  static const int _HAS_NEXT_AND_NEXT_IN_CURRENT = 0;\n  static const int _NO_NEXT = 1;\n  static const int _NOT_MOVED_YET = 2;\n\n  Iterator _iterator;\n  int _state = _NOT_MOVED_YET;\n\n  HasNextIterator(this._iterator);\n\n  bool get hasNext {\n    if (_state == _NOT_MOVED_YET) _move();\n    return _state == _HAS_NEXT_AND_NEXT_IN_CURRENT;\n  }\n\n  E next() {\n    // Call to hasNext is necessary to make sure we are positioned at the first\n    // element when we start iterating.\n    if (!hasNext) throw new StateError(\"No more elements\");\n    assert(_state == _HAS_NEXT_AND_NEXT_IN_CURRENT);\n    E result = _iterator.current;\n    _move();\n    return result;\n  }\n\n  void _move() {\n    if (_iterator.moveNext()) {\n      _state = _HAS_NEXT_AND_NEXT_IN_CURRENT;\n    } else {\n      _state = _NO_NEXT;\n    }\n  }\n}\n\u0000","sdk:/sdk/lib/collection/iterable.dart":"// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\npart of dart.collection;\n\n/**\n * This [Iterable] mixin implements all [Iterable] members except `iterator`.\n *\n * All other methods are implemented in terms of `iterator`.\n */\nabstract class IterableMixin<E> implements Iterable<E> {\n  // This class has methods copied verbatim into:\n  // - IterableBase\n  // - SetMixin\n  // If changing a method here, also change the other copies.\n\n  Iterable map(f(E element)) => new MappedIterable<E, dynamic>(this, f);\n\n  Iterable<E> where(bool f(E element)) => new WhereIterable<E>(this, f);\n\n  Iterable expand(Iterable f(E element)) =>\n      new ExpandIterable<E, dynamic>(this, f);\n\n  bool contains(Object element) {\n    for (E e in this) {\n      if (e == element) return true;\n    }\n    return false;\n  }\n\n  void forEach(void f(E element)) {\n    for (E element in this) f(element);\n  }\n\n  E reduce(E combine(E value, E element)) {\n    Iterator<E> iterator = this.iterator;\n    if (!iterator.moveNext()) {\n      throw IterableElementError.noElement();\n    }\n    E value = iterator.current;\n    while (iterator.moveNext()) {\n      value = combine(value, iterator.current);\n    }\n    return value;\n  }\n\n  dynamic fold(var initialValue,\n               dynamic combine(var previousValue, E element)) {\n    var value = initialValue;\n    for (E element in this) value = combine(value, element);\n    return value;\n  }\n\n  bool every(bool f(E element)) {\n    for (E element in this) {\n      if (!f(element)) return false;\n    }\n    return true;\n  }\n\n  String join([String separator = \"\"]) {\n    Iterator<E> iterator = this.iterator;\n    if (!iterator.moveNext()) return \"\";\n    StringBuffer buffer = new StringBuffer();\n    if (separator == null || separator == \"\") {\n      do {\n        buffer.write(\"${iterator.current}\");\n      } while (iterator.moveNext());\n    } else {\n      buffer.write(\"${iterator.current}\");\n      while (iterator.moveNext()) {\n        buffer.write(separator);\n        buffer.write(\"${iterator.current}\");\n      }\n    }\n    return buffer.toString();\n  }\n\n  bool any(bool f(E element)) {\n    for (E element in this) {\n      if (f(element)) return true;\n    }\n    return false;\n  }\n\n  List<E> toList({ bool growable: true }) =>\n      new List<E>.from(this, growable: growable);\n\n  Set<E> toSet() => new Set<E>.from(this);\n\n  int get length {\n    assert(this is! EfficientLength);\n    int count = 0;\n    Iterator it = iterator;\n    while (it.moveNext()) {\n      count++;\n    }\n    return count;\n  }\n\n  bool get isEmpty => !iterator.moveNext();\n\n  bool get isNotEmpty => !isEmpty;\n\n  Iterable<E> take(int n) {\n    return new TakeIterable<E>(this, n);\n  }\n\n  Iterable<E> takeWhile(bool test(E value)) {\n    return new TakeWhileIterable<E>(this, test);\n  }\n\n  Iterable<E> skip(int n) {\n    return new SkipIterable<E>(this, n);\n  }\n\n  Iterable<E> skipWhile(bool test(E value)) {\n    return new SkipWhileIterable<E>(this, test);\n  }\n\n  E get first {\n    Iterator it = iterator;\n    if (!it.moveNext()) {\n      throw IterableElementError.noElement();\n    }\n    return it.current;\n  }\n\n  E get last {\n    Iterator it = iterator;\n    if (!it.moveNext()) {\n      throw IterableElementError.noElement();\n    }\n    E result;\n    do {\n      result = it.current;\n    } while(it.moveNext());\n    return result;\n  }\n\n  E get single {\n    Iterator it = iterator;\n    if (!it.moveNext()) throw IterableElementError.noElement();\n    E result = it.current;\n    if (it.moveNext()) throw IterableElementError.tooMany();\n    return result;\n  }\n\n  dynamic firstWhere(bool test(E value), { Object orElse() }) {\n    for (E element in this) {\n      if (test(element)) return element;\n    }\n    if (orElse != null) return orElse();\n    throw IterableElementError.noElement();\n  }\n\n  dynamic lastWhere(bool test(E value), { Object orElse() }) {\n    E result = null;\n    bool foundMatching = false;\n    for (E element in this) {\n      if (test(element)) {\n        result = element;\n        foundMatching = true;\n      }\n    }\n    if (foundMatching) return result;\n    if (orElse != null) return orElse();\n    throw IterableElementError.noElement();\n  }\n\n  E singleWhere(bool test(E value)) {\n    E result = null;\n    bool foundMatching = false;\n    for (E element in this) {\n      if (test(element)) {\n        if (foundMatching) {\n          throw IterableElementError.tooMany();\n        }\n        result = element;\n        foundMatching = true;\n      }\n    }\n    if (foundMatching) return result;\n    throw IterableElementError.noElement();\n  }\n\n  E elementAt(int index) {\n    if (index is! int || index < 0) throw new RangeError.value(index);\n    int remaining = index;\n    for (E element in this) {\n      if (remaining == 0) return element;\n      remaining--;\n    }\n    throw new RangeError.value(index);\n  }\n\n  String toString() => IterableBase.iterableToShortString(this, '(', ')');\n}\n\n/**\n * Base class for implementing [Iterable].\n *\n * This class implements all methods of [Iterable] except [Iterable.iterator]\n * in terms of `iterator`.\n */\nabstract class IterableBase<E> implements Iterable<E> {\n  // TODO(lrn): Base this on IterableMixin if there ever becomes a way\n  // to combine const constructors and mixins.\n  const IterableBase();\n\n  Iterable map(f(E element)) => new MappedIterable<E, dynamic>(this, f);\n\n  Iterable<E> where(bool f(E element)) => new WhereIterable<E>(this, f);\n\n  Iterable expand(Iterable f(E element)) =>\n      new ExpandIterable<E, dynamic>(this, f);\n\n  bool contains(Object element) {\n    for (E e in this) {\n      if (e == element) return true;\n    }\n    return false;\n  }\n\n  void forEach(void f(E element)) {\n    for (E element in this) f(element);\n  }\n\n  E reduce(E combine(E value, E element)) {\n    Iterator<E> iterator = this.iterator;\n    if (!iterator.moveNext()) {\n      throw IterableElementError.noElement();\n    }\n    E value = iterator.current;\n    while (iterator.moveNext()) {\n      value = combine(value, iterator.current);\n    }\n    return value;\n  }\n\n  dynamic fold(var initialValue,\n               dynamic combine(var previousValue, E element)) {\n    var value = initialValue;\n    for (E element in this) value = combine(value, element);\n    return value;\n  }\n\n  bool every(bool f(E element)) {\n    for (E element in this) {\n      if (!f(element)) return false;\n    }\n    return true;\n  }\n\n  String join([String separator = \"\"]) {\n    Iterator<E> iterator = this.iterator;\n    if (!iterator.moveNext()) return \"\";\n    StringBuffer buffer = new StringBuffer();\n    if (separator == null || separator == \"\") {\n      do {\n        buffer.write(\"${iterator.current}\");\n      } while (iterator.moveNext());\n    } else {\n      buffer.write(\"${iterator.current}\");\n      while (iterator.moveNext()) {\n        buffer.write(separator);\n        buffer.write(\"${iterator.current}\");\n      }\n    }\n    return buffer.toString();\n  }\n\n  bool any(bool f(E element)) {\n    for (E element in this) {\n      if (f(element)) return true;\n    }\n    return false;\n  }\n\n  List<E> toList({ bool growable: true }) =>\n      new List<E>.from(this, growable: growable);\n\n  Set<E> toSet() => new Set<E>.from(this);\n\n  int get length {\n    assert(this is! EfficientLength);\n    int count = 0;\n    Iterator it = iterator;\n    while (it.moveNext()) {\n      count++;\n    }\n    return count;\n  }\n\n  bool get isEmpty => !iterator.moveNext();\n\n  bool get isNotEmpty => !isEmpty;\n\n  Iterable<E> take(int n) {\n    return new TakeIterable<E>(this, n);\n  }\n\n  Iterable<E> takeWhile(bool test(E value)) {\n    return new TakeWhileIterable<E>(this, test);\n  }\n\n  Iterable<E> skip(int n) {\n    return new SkipIterable<E>(this, n);\n  }\n\n  Iterable<E> skipWhile(bool test(E value)) {\n    return new SkipWhileIterable<E>(this, test);\n  }\n\n  E get first {\n    Iterator it = iterator;\n    if (!it.moveNext()) {\n      throw IterableElementError.noElement();\n    }\n    return it.current;\n  }\n\n  E get last {\n    Iterator it = iterator;\n    if (!it.moveNext()) {\n      throw IterableElementError.noElement();\n    }\n    E result;\n    do {\n      result = it.current;\n    } while(it.moveNext());\n    return result;\n  }\n\n  E get single {\n    Iterator it = iterator;\n    if (!it.moveNext()) throw IterableElementError.noElement();\n    E result = it.current;\n    if (it.moveNext()) throw IterableElementError.tooMany();\n    return result;\n  }\n\n  dynamic firstWhere(bool test(E value), { Object orElse() }) {\n    for (E element in this) {\n      if (test(element)) return element;\n    }\n    if (orElse != null) return orElse();\n    throw IterableElementError.noElement();\n  }\n\n  dynamic lastWhere(bool test(E value), { Object orElse() }) {\n    E result = null;\n    bool foundMatching = false;\n    for (E element in this) {\n      if (test(element)) {\n        result = element;\n        foundMatching = true;\n      }\n    }\n    if (foundMatching) return result;\n    if (orElse != null) return orElse();\n    throw IterableElementError.noElement();\n  }\n\n  E singleWhere(bool test(E value)) {\n    E result = null;\n    bool foundMatching = false;\n    for (E element in this) {\n      if (test(element)) {\n        if (foundMatching) {\n          throw IterableElementError.tooMany();\n        }\n        result = element;\n        foundMatching = true;\n      }\n    }\n    if (foundMatching) return result;\n    throw IterableElementError.noElement();\n  }\n\n  E elementAt(int index) {\n    if (index is! int || index < 0) throw new RangeError.value(index);\n    int remaining = index;\n    for (E element in this) {\n      if (remaining == 0) return element;\n      remaining--;\n    }\n    throw new RangeError.value(index);\n  }\n\n  /**\n   * Returns a string representation of (some of) the elements of `this`.\n   *\n   * Elements are represented by their own `toString` results.\n   *\n   * The representation always contains the first three elements.\n   * If there are less than a hundred elements in the iterable, it also\n   * contains the last two elements.\n   *\n   * If the resulting string isn't above 80 characters, more elements are\n   * included from the start of the iterable.\n   *\n   * The conversion may omit calling `toString` on some elements if they\n   * are known to not occur in the output, and it may stop iterating after\n   * a hundred elements.\n   */\n  String toString() => iterableToShortString(this, '(', ')');\n\n  /**\n   * Convert an `Iterable` to a string like [IterableBase.toString].\n   *\n   * Allows using other delimiters than '(' and ')'.\n   *\n   * Handles circular references where converting one of the elements\n   * to a string ends up converting [iterable] to a string again.\n   */\n  static String iterableToShortString(Iterable iterable,\n                                      [String leftDelimiter = '(',\n                                       String rightDelimiter = ')']) {\n    if (_isToStringVisiting(iterable)) {\n      if (leftDelimiter == \"(\" && rightDelimiter == \")\") {\n        // Avoid creating a new string in the \"common\" case.\n        return \"(...)\";\n      }\n      return \"$leftDelimiter...$rightDelimiter\";\n    }\n    List parts = [];\n    _toStringVisiting.add(iterable);\n    try {\n      _iterablePartsToStrings(iterable, parts);\n    } finally {\n      assert(identical(_toStringVisiting.last, iterable));\n      _toStringVisiting.removeLast();\n    }\n    return (new StringBuffer(leftDelimiter)\n                ..writeAll(parts, \", \")\n                ..write(rightDelimiter)).toString();\n  }\n\n  /**\n   * Converts an `Iterable` to a string.\n   *\n   * Converts each elements to a string, and separates the results by \", \".\n   * Then wraps the result in [leftDelimiter] and [rightDelimiter].\n   *\n   * Unlike [iterableToShortString], this conversion doesn't omit any\n   * elements or puts any limit on the size of the result.\n   *\n   * Handles circular references where converting one of the elements\n   * to a string ends up converting [iterable] to a string again.\n   */\n  static String iterableToFullString(Iterable iterable,\n                                     [String leftDelimiter = '(',\n                                      String rightDelimiter = ')']) {\n    if (_isToStringVisiting(iterable)) {\n      return \"$leftDelimiter...$rightDelimiter\";\n    }\n    StringBuffer buffer = new StringBuffer(leftDelimiter);\n    _toStringVisiting.add(iterable);\n    try {\n      buffer.writeAll(iterable, \", \");\n    } finally {\n      assert(identical(_toStringVisiting.last, iterable));\n      _toStringVisiting.removeLast();\n    }\n    buffer.write(rightDelimiter);\n    return buffer.toString();\n  }\n\n  /** A set used to identify cyclic lists during toString() calls. */\n  static final List _toStringVisiting = [];\n\n  /** Check if we are currently visiting `o` in a toString call. */\n  static bool _isToStringVisiting(Object o) {\n    for (int i = 0; i < _toStringVisiting.length; i++) {\n      if (identical(o, _toStringVisiting[i])) return true;\n    }\n    return false;\n  }\n\n  /**\n   * Convert elments of [iterable] to strings and store them in [parts].\n   */\n  static void _iterablePartsToStrings(Iterable iterable, List parts) {\n    /*\n     * This is the complicated part of [iterableToShortString].\n     * It is extracted as a separate function to avoid having too much code\n     * inside the try/finally.\n     */\n    /// Try to stay below this many characters.\n    const int LENGTH_LIMIT = 80;\n    /// Always at least this many elements at the start.\n    const int HEAD_COUNT = 3;\n    /// Always at least this many elements at the end.\n    const int TAIL_COUNT = 2;\n    /// Stop iterating after this many elements. Iterables can be infinite.\n    const int MAX_COUNT = 100;\n    // Per entry length overhead. It's for \", \" for all after the first entry,\n    // and for \"(\" and \")\" for the initial entry. By pure luck, that's the same\n    // number.\n    const int OVERHEAD = 2;\n    const int ELLIPSIS_SIZE = 3;  // \"...\".length.\n\n    int length = 0;\n    int count = 0;\n    Iterator it = iterable.iterator;\n    // Initial run of elements, at least HEAD_COUNT, and then continue until\n    // passing at most LENGTH_LIMIT characters.\n    while (length < LENGTH_LIMIT || count < HEAD_COUNT) {\n      if (!it.moveNext()) return;\n      String next = \"${it.current}\";\n      parts.add(next);\n      length += next.length + OVERHEAD;\n      count++;\n    }\n\n    String penultimateString;\n    String ultimateString;\n\n    // Find last two elements. One or more of them may already be in the\n    // parts array. Include their length in `length`.\n    var penultimate = null;\n    var ultimate = null;\n    if (!it.moveNext()) {\n      if (count <= HEAD_COUNT + TAIL_COUNT) return;\n      ultimateString = parts.removeLast();\n      penultimateString = parts.removeLast();\n    } else {\n      penultimate = it.current;\n      count++;\n      if (!it.moveNext()) {\n        if (count <= HEAD_COUNT + 1) {\n          parts.add(\"$penultimate\");\n          return;\n        }\n        ultimateString = \"$penultimate\";\n        penultimateString = parts.removeLast();\n        length += ultimateString.length + OVERHEAD;\n      } else {\n        ultimate = it.current;\n        count++;\n        // Then keep looping, keeping the last two elements in variables.\n        assert(count < MAX_COUNT);\n        while (it.moveNext()) {\n          penultimate = ultimate;\n          ultimate = it.current;\n          count++;\n          if (count > MAX_COUNT) {\n            // If we haven't found the end before MAX_COUNT, give up.\n            // This cannot happen in the code above because each entry\n            // increases length by at least two, so there is no way to\n            // visit more than ~40 elements before this loop.\n\n            // Remove any surplus elements until length, including \", ...)\",\n            // is at most LENGTH_LIMIT.\n            while (length > LENGTH_LIMIT - ELLIPSIS_SIZE - OVERHEAD &&\n                   count > HEAD_COUNT) {\n              length -= parts.removeLast().length + OVERHEAD;\n              count--;\n            }\n            parts.add(\"...\");\n            return;\n          }\n        }\n        penultimateString = \"$penultimate\";\n        ultimateString = \"$ultimate\";\n        length +=\n            ultimateString.length + penultimateString.length + 2 * OVERHEAD;\n      }\n    }\n\n    // If there is a gap between the initial run and the last two,\n    // prepare to add an ellipsis.\n    String elision = null;\n    if (count > parts.length + TAIL_COUNT) {\n      elision = \"...\";\n      length += ELLIPSIS_SIZE + OVERHEAD;\n    }\n\n    // If the last two elements were very long, and we have more than\n    // HEAD_COUNT elements in the initial run, drop some to make room for\n    // the last two.\n    while (length > LENGTH_LIMIT && parts.length > HEAD_COUNT) {\n      length -= parts.removeLast().length + OVERHEAD;\n      if (elision == null) {\n        elision = \"...\";\n        length += ELLIPSIS_SIZE + OVERHEAD;\n      }\n    }\n    if (elision != null) {\n      parts.add(elision);\n    }\n    parts.add(penultimateString);\n    parts.add(ultimateString);\n  }\n}\n\u0000","sdk:/sdk/lib/collection/hash_set.dart":"// Copyright (c) 2013, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\npart of dart.collection;\n\n/** Common parts of [HashSet] and [LinkedHashSet] implementations. */\nabstract class _HashSetBase<E> extends SetBase<E> {\n\n  // The following two methods override the ones in SetBase.\n  // It's possible to be more efficient if we have a way to create an empty\n  // set of the correct type.\n\n  Set<E> difference(Set<Object> other) {\n    Set<E> result = _newSet();\n    for (var element in this) {\n      if (!other.contains(element)) result.add(element);\n    }\n    return result;\n  }\n\n  Set<E> intersection(Set<Object> other) {\n    Set<E> result = _newSet();\n    for (var element in this) {\n      if (other.contains(element)) result.add(element);\n    }\n    return result;\n  }\n\n  Set<E> _newSet();\n\n  // Subclasses can optimize this further.\n  Set<E> toSet() => _newSet()..addAll(this);\n}\n\n/**\n * An unordered hash-table based [Set] implementation.\n *\n * The elements of a `HashSet` must have consistent equality\n * and hashCode implementations. This means that the equals operation\n * must define a stable equivalence relation on the elements (reflexive,\n * symmetric, transitive, and consistent over time), and that the hashCode\n * must consistent with equality, so that the same for objects that are\n * considered equal.\n *\n * The set allows `null` as an element.\n *\n * Most simple operations on `HashSet` are done in (potentially amorteized)\n * constant time: [add], [contains], [remove], and [length], provided the hash\n * codes of objects are well distributed.\n */\nabstract class HashSet<E> implements Set<E> {\n  /**\n   * Create a hash set using the provided [equals] as equality.\n   *\n   * The provided [equals] must define a stable equivalence relation, and\n   * [hashCode] must be consistent with [equals]. If the [equals] or [hashCode]\n   * methods won't work on all objects, but only to instances of E, the\n   * [isValidKey] predicate can be used to restrict the keys that they are\n   * applied to. Any key for which [isValidKey] returns false is automatically\n   * assumed to not be in the set.\n   *\n   * If [equals] or [hashCode] are omitted, the set uses\n   * the objects' intrinsic [Object.operator==] and [Object.hashCode].\n   *\n   * If [isValidKey] is omitted, it defaults to testing if the object is an\n   * [E] instance.\n   *\n   * If you supply one of [equals] and [hashCode],\n   * you should generally also to supply the other.\n   * An example would be using [identical] and [identityHashCode],\n   * which is equivalent to using the shorthand [LinkedSet.identity]).\n   */\n  external factory HashSet({ bool equals(E e1, E e2),\n                             int hashCode(E e),\n                             bool isValidKey(potentialKey) });\n\n  /**\n   * Creates an unordered identity-based set.\n   *\n   * Effectively a shorthand for:\n   *\n   *     new HashSet(equals: identical, hashCode: identityHashCodeOf)\n   */\n  external factory HashSet.identity();\n\n  /**\n   * Create a hash set containing the elements of [iterable].\n   *\n   * Creates a hash set as by `new HashSet<E>()` and adds each element of\n   * `iterable` to this set in the order they are iterated.\n   */\n  factory HashSet.from(Iterable<E> iterable) {\n    return new HashSet<E>()..addAll(iterable);\n  }\n\n  /**\n   * Provides an iterator that iterates over the elements of this set.\n   *\n   * The order of iteration is unspecified,\n   * but consistent between changes to the set.\n   */\n  Iterator<E> get iterator;\n}\n\u0000","sdk:/sdk/lib/collection/hash_map.dart":"// Copyright (c) 2013, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\npart of dart.collection;\n\n/** Default function for equality comparison in customized HashMaps */\nbool _defaultEquals(a, b) => a == b;\n/** Default function for hash-code computation in customized HashMaps */\nint _defaultHashCode(a) => a.hashCode;\n\n/** Type of custom equality function */\ntypedef bool _Equality<K>(K a, K b);\n/** Type of custom hash code function. */\ntypedef int _Hasher<K>(K object);\n\n/**\n * A hash-table based implementation of [Map].\n *\n * The keys of a `HashMap` must have consistent [Object.operator==]\n * and [Object.hashCode] implementations. This means that the `==` operator\n * must define a stable equivalence relation on the keys (reflexive,\n * symmetric, transitive, and consistent over time), and that `hashCode`\n * must be the same for objects that are considered equal by `==`.\n *\n * The map allows `null` as a key.\n *\n * Iterating the map's keys, values or entries (through [forEach])\n * may happen in any order.\n * The itearation order only changes when the map is modified.\n * Values are iterated in the same order as their associated keys,\n * so iterating the [keys] and [values] in parallel\n * will give matching key and value pairs.\n */\nabstract class HashMap<K, V> implements Map<K, V> {\n  /**\n   * Creates an unordered hash-table based [Map].\n   *\n   * The created map is not ordered in any way. When iterating the keys or\n   * values, the iteration order is unspecified except that it will stay the\n   * same as long as the map isn't changed.\n   *\n   * If [equals] is provided, it is used to compare the keys in the table with\n   * new keys. If [equals] is omitted, the key's own [Object.operator==] is used\n   * instead.\n   *\n   * Similar, if [hashCode] is provided, it is used to produce a hash value\n   * for keys in order to place them in the hash table. If it is omitted, the\n   * key's own [Object.hashCode] is used.\n   *\n   * If using methods like [operator[]], [remove] and [containsKey] together\n   * with a custom equality and hashcode, an extra `isValidKey` function\n   * can be supplied. This function is called before calling [equals] or\n   * [hashCode] with an argument that may not be a [K] instance, and if the\n   * call returns false, the key is assumed to not be in the set.\n   * The [isValidKey] function defaults to just testing if the object is a\n   * [K] instance.\n   *\n   * The used `equals` and `hashCode` method should always be consistent,\n   * so that if `equals(a, b)` then `hashCode(a) == hashCode(b)`. The hash\n   * of an object, or what it compares equal to, should not change while the\n   * object is in the table. If it does change, the result is unpredictable.\n   *\n   * If you supply one of [equals] and [hashCode],\n   * you should generally also to supply the other.\n   * An example would be using [identical] and [identityHashCode],\n   * which is equivalent to using the shorthand [HashMap.identity]).\n   */\n  external factory HashMap({bool equals(K key1, K key2),\n                            int hashCode(K key),\n                            bool isValidKey(potentialKey)});\n\n  /**\n   * Creates an unordered identity-based map.\n   *\n   * Effectively a shorthand for:\n   *\n   *     new HashMap(equals: identical, hashCode: identityHashCodeOf)\n   */\n  external factory HashMap.identity();\n\n  /**\n   * Creates a [HashMap] that contains all key value pairs of [other].\n   */\n  factory HashMap.from(Map<K, V> other) {\n    return new HashMap<K, V>()..addAll(other);\n  }\n\n  /**\n   * Creates a [HashMap] where the keys and values are computed from the\n   * [iterable].\n   *\n   * For each element of the [iterable] this constructor computes a key/value\n   * pair, by applying [key] and [value] respectively.\n   *\n   * The keys of the key/value pairs do not need to be unique. The last\n   * occurrence of a key will simply overwrite any previous value.\n   *\n   * If no values are specified for [key] and [value] the default is the\n   * identity function.\n   */\n  factory HashMap.fromIterable(Iterable iterable,\n      {K key(element), V value(element)}) {\n    HashMap<K, V> map = new HashMap<K, V>();\n    Maps._fillMapWithMappedIterable(map, iterable, key, value);\n    return map;\n  }\n\n  /**\n   * Creates a [HashMap] associating the given [keys] to [values].\n   *\n   * This constructor iterates over [keys] and [values] and maps each element of\n   * [keys] to the corresponding element of [values].\n   *\n   * If [keys] contains the same object multiple times, the last occurrence\n   * overwrites the previous value.\n   *\n   * It is an error if the two [Iterable]s don't have the same length.\n   */\n  factory HashMap.fromIterables(Iterable<K> keys, Iterable<V> values) {\n    HashMap<K, V> map = new HashMap<K, V>();\n    Maps._fillMapWithIterables(map, keys, values);\n    return map;\n  }\n}\n\u0000","sdk:/sdk/lib/collection/collections.dart":"// Copyright (c) 2013, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\npart of dart.collection;\n\n/**\n * An unmodifiable [List] view of another List.\n *\n * The source of the elements may be a [List] or any [Iterable] with\n * efficient [Iterable.length] and [Iterable.elementAt].\n */\nclass UnmodifiableListView<E> extends UnmodifiableListBase<E> {\n  final Iterable<E> _source;\n  /** Create an unmodifiable list backed by [source]. */\n  UnmodifiableListView(Iterable<E> source) : _source = source;\n  int get length => _source.length;\n  E operator[](int index) => _source.elementAt(index);\n}\n\u0000","sdk:/sdk/lib/collection/collection.dart":"// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n/**\n * Classes and utilities that supplement the collection support in dart:core.\n */\nlibrary dart.collection;\n\nimport 'dart:_internal';\nimport 'dart:math' show Random;  // Used by ListMixin.shuffle.\n\npart 'collections.dart';\npart 'hash_map.dart';\npart 'hash_set.dart';\npart 'iterable.dart';\npart 'iterator.dart';\npart 'linked_hash_map.dart';\npart 'linked_hash_set.dart';\npart 'linked_list.dart';\npart 'list.dart';\npart 'maps.dart';\npart 'queue.dart';\npart 'set.dart';\npart 'splay_tree.dart';\n\u0000","sdk:/sdk/lib/math/rectangle.dart":"// Copyright (c) 2013, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\npart of dart.math;\n\n/**\n * A base class for representing two-dimensional axis-aligned rectangles.\n *\n * This rectangle uses a left-handed Cartesian coordinate system, with x\n * directed to the right and y directed down, as per the convention in 2D\n * computer graphics.\n *\n * See also:\n *    [W3C Coordinate Systems Specification](http://www.w3.org/TR/SVG/coords.html#InitialCoordinateSystem).\n *\n * The rectangle is the set of points with representable coordinates greater\n * than or equal to left/top, and with distance to left/top no greater than\n * width/height (to the limit of the precission of the coordinates).\n */\nabstract class _RectangleBase<T extends num> {\n  const _RectangleBase();\n\n  /** The x-coordinate of the left edge. */\n  T get left;\n  /** The y-coordinate of the top edge. */\n  T get top;\n  /** The width of the rectangle. */\n  T get width;\n  /** The height of the rectangle. */\n  T get height;\n\n  /** The x-coordinate of the right edge. */\n  T get right => left + width;\n  /** The y-coordinate of the bottom edge. */\n  T get bottom => top + height;\n\n  String toString() {\n    return 'Rectangle ($left, $top) $width x $height';\n  }\n\n  bool operator ==(other) {\n    if (other is !Rectangle) return false;\n    return left == other.left && top == other.top && right == other.right &&\n        bottom == other.bottom;\n  }\n\n  int get hashCode => _JenkinsSmiHash.hash4(left.hashCode, top.hashCode,\n      right.hashCode, bottom.hashCode);\n\n  /**\n   * Computes the intersection of `this` and [other].\n   *\n   * The intersection of two axis-aligned rectangles, if any, is always another\n   * axis-aligned rectangle.\n   *\n   * Returns the intersection of this and `other`, or `null` if they don't\n   * intersect.\n   */\n  Rectangle<T> intersection(Rectangle<T> other) {\n    var x0 = max(left, other.left);\n    var x1 = min(left + width, other.left + other.width);\n\n    if (x0 <= x1) {\n      var y0 = max(top, other.top);\n      var y1 = min(top + height, other.top + other.height);\n\n      if (y0 <= y1) {\n        return new Rectangle<T>(x0, y0, x1 - x0, y1 - y0);\n      }\n    }\n    return null;\n  }\n\n\n  /**\n   * Returns true if `this` intersects [other].\n   */\n  bool intersects(Rectangle<num> other) {\n    return (left <= other.left + other.width &&\n        other.left <= left + width &&\n        top <= other.top + other.height &&\n        other.top <= top + height);\n  }\n\n  /**\n   * Returns a new rectangle which completely contains `this` and [other].\n   */\n  Rectangle<T> boundingBox(Rectangle<T> other) {\n    var right = max(this.left + this.width, other.left + other.width);\n    var bottom = max(this.top + this.height, other.top + other.height);\n\n    var left = min(this.left, other.left);\n    var top = min(this.top, other.top);\n\n    return new Rectangle<T>(left, top, right - left, bottom - top);\n  }\n\n  /**\n   * Tests whether `this` entirely contains [another].\n   */\n  bool containsRectangle(Rectangle<num> another) {\n    return left <= another.left &&\n           left + width >= another.left + another.width &&\n           top <= another.top &&\n           top + height >= another.top + another.height;\n  }\n\n  /**\n   * Tests whether [another] is inside or along the edges of `this`.\n   */\n  bool containsPoint(Point<num> another) {\n    return another.x >= left &&\n           another.x <= left + width &&\n           another.y >= top &&\n           another.y <= top + height;\n  }\n\n  Point<T> get topLeft => new Point<T>(this.left, this.top);\n  Point<T> get topRight => new Point<T>(this.left + this.width, this.top);\n  Point<T> get bottomRight => new Point<T>(this.left + this.width,\n      this.top + this.height);\n  Point<T> get bottomLeft => new Point<T>(this.left,\n      this.top + this.height);\n}\n\n\n/**\n * A class for representing two-dimensional rectangles whose properties are\n * immutable.\n */\nclass Rectangle<T extends num> extends _RectangleBase<T> {\n  final T left;\n  final T top;\n  final T width;\n  final T height;\n\n  /**\n   * Create a rectangle spanned by `(left, top)` and `(left+width, top+height)`.\n   *\n   * The rectangle contains the points\n   * with x-coordinate between `left` and `left + width`, and\n   * with y-coordinate between `top` and `top + height`, both inclusive.\n   *\n   * The `width` and `height` should be non-negative.\n   * If `width` or `height` are negative, they are clamped to zero.\n   *\n   * If `width` and `height` are zero, the \"rectangle\" comprises only the single\n   * point `(left, top)`.\n   */\n  const Rectangle(this.left, this.top, T width, T height)\n      : this.width = (width < 0) ? -width * 0 : width,  // Inline _clampToZero.\n        this.height = (height < 0) ?  -height * 0 : height;\n\n  /**\n   * Create a rectangle spanned by the points [a] and [b];\n   *\n   * The rectangle contains the points\n   * with x-coordinate between `a.x` and `b.x`, and\n   * with y-coordinate between `a.y` and `b.y`, both inclusive.\n   *\n   * If the distance between `a.x` and `b.x` is not representable\n   * (which can happen if one or both is a double),\n   * the actual right edge might be slightly off from `max(a.x, b.x)`.\n   * Similar for the y-coordinates and the bottom edge.\n   */\n  factory Rectangle.fromPoints(Point<T> a, Point<T> b) {\n    T left = min(a.x, b.x);\n    T width = max(a.x, b.x) - left;\n    T top = min(a.y, b.y);\n    T height = max(a.y, b.y) - top;\n    return new Rectangle<T>(left, top, width, height);\n  }\n}\n\n/**\n * A class for representing two-dimensional axis-aligned rectangles with mutable\n * properties.\n */\nclass MutableRectangle<T extends num> extends _RectangleBase<T>\n                                      implements Rectangle<T> {\n\n  /**\n   * The x-coordinate of the left edge.\n   *\n   * Setting the value will move the rectangle without changing its width.\n   */\n  T left;\n  /**\n   * The y-coordinate of the left edge.\n   *\n   * Setting the value will move the rectangle without changing its height.\n   */\n  T top;\n  T _width;\n  T _height;\n\n  /**\n   * Create a mutable rectangle spanned by `(left, top)` and\n   * `(left+width, top+height)`.\n   *\n   * The rectangle contains the points\n   * with x-coordinate between `left` and `left + width`, and\n   * with y-coordinate between `top` and `top + height`, both inclusive.\n   *\n   * The `width` and `height` should be non-negative.\n   * If `width` or `height` are negative, they are clamped to zero.\n   *\n   * If `width` and `height` are zero, the \"rectangle\" comprises only the single\n   * point `(left, top)`.\n   */\n  MutableRectangle(this.left, this.top, T width, T height)\n      : this._width = (width < 0) ? _clampToZero(width) : width,\n        this._height = (height < 0) ? _clampToZero(height) : height;\n\n  /**\n   * Create a mutable rectangle spanned by the points [a] and [b];\n   *\n   * The rectangle contains the points\n   * with x-coordinate between `a.x` and `b.x`, and\n   * with y-coordinate between `a.y` and `b.y`, both inclusive.\n   *\n   * If the distance between `a.x` and `b.x` is not representable\n   * (which can happen if one or both is a double),\n   * the actual right edge might be slightly off from `max(a.x, b.x)`.\n   * Similar for the y-coordinates and the bottom edge.\n   */\n  factory MutableRectangle.fromPoints(Point<T> a, Point<T> b) {\n    T left = min(a.x, b.x);\n    T width = max(a.x, b.x) - left;\n    T top = min(a.y, b.y);\n    T height = max(a.y, b.y) - top;\n    return new MutableRectangle<T>(left, top, width, height);\n  }\n\n  T get width => _width;\n\n /**\n   * Sets the width of the rectangle.\n   *\n   * The width must be non-negative.\n   * If a negative width is supplied, it is clamped to zero.\n   *\n   * Setting the value will change the right edge of the rectangle,\n   * but will not change [left].\n   */\n  void set width(T width) {\n    if (width < 0) width = _clampToZero(width);\n    _width = width;\n  }\n\n  T get height => _height;\n\n  /**\n   * Sets the height of the rectangle.\n   *\n   * The height must be non-negative.\n   * If a negative height is supplied, it is clamped to zero.\n   *\n   * Setting the value will change the bottom edge of the rectangle,\n   * but will not change [top].\n   */\n  void set height(T height) {\n    if (height < 0) height = _clampToZero(height);\n    _height = height;\n  }\n}\n\n/**\n * Converts a negative [int] or [double] to a zero-value of the same type.\n *\n * Returns `0` if value is int, `0.0` if value is double.\n */\nnum _clampToZero(num value) {\n  assert(value < 0);\n  return -value * 0;\n}\n\u0000","sdk:/sdk/lib/math/random.dart":"// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\npart of dart.math;\n\n/**\n * A generator of random bool, int, or double values.\n *\n * The default implementation supplies a stream of\n * pseudo-random bits that are not suitable for cryptographic purposes.\n */\nabstract class Random {\n  /**\n   * Creates a random-number generator. The optional parameter [seed] is used\n   * to initialize the internal state of the generator. The implementation of\n   * the random stream can change between releases of the library.\n   */\n  external factory Random([int seed]);\n\n  /**\n   * Generates a positive random integer uniformly distributed on the range\n   * from 0, inclusive, to [max], exclusive.\n   *\n   * Implementation note: The default implementation supports [max] values\n   * between 1 and ((1<<32) - 1) inclusive.\n   */\n  int nextInt(int max);\n\n  /**\n   * Generates a positive random floating point value uniformly distributed on\n   * the range from 0.0, inclusive, to 1.0, exclusive.\n   */\n  double nextDouble();\n\n  /**\n   * Generates a random boolean value.\n   */\n  bool nextBool();\n}\n\u0000","sdk:/sdk/lib/math/point.dart":"// Copyright (c) 2013, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\npart of dart.math;\n\n/**\n * A utility class for representing two-dimensional positions.\n */\nclass Point<T extends num> {\n  final T x;\n  final T y;\n\n  const Point(T x, T y): this.x = x, this.y = y;\n\n  String toString() => 'Point($x, $y)';\n\n  /**\n   * A `Point` is only equal to another `Point` with the same coordinates.\n   *\n   * This point is equal to `other` if, and only if,\n   * `other` is a `Point` with\n   * [x] equal to `other.x` and [y] equal to `other.y`.\n   */\n  bool operator ==(other) {\n    if (other is !Point) return false;\n    return x == other.x && y == other.y;\n  }\n\n  int get hashCode => _JenkinsSmiHash.hash2(x.hashCode, y.hashCode);\n\n  /**\n   * Add [other] to `this`, as if both points were vectors.\n   *\n   * Returns the resulting \"vector\" as a Point.\n   */\n  Point<T> operator +(Point<T> other) {\n    return new Point<T>(x + other.x, y + other.y);\n  }\n\n  /**\n   * Subtract [other] from `this`, as if both points were vectors.\n   *\n   * Returns the resulting \"vector\" as a Point.\n   */\n  Point<T> operator -(Point<T> other) {\n    return new Point<T>(x - other.x, y - other.y);\n  }\n\n  /**\n   * Scale this point by [factor] as if it were a vector.\n   *\n   * *Important* *Note*: This function accepts a `num` as its argument only so\n   * that you can scale Point<double> objects by an `int` factor. Because the\n   * star operator always returns the same type of Point that originally called\n   * it, passing in a double [factor] on a `Point<int>` _causes_ _a_\n   * _runtime_ _error_ in checked mode.\n   */\n  Point<T> operator *(num factor) {\n    return new Point<T>(x * factor, y * factor);\n  }\n\n  /**\n   * Get the straight line (Euclidean) distance between the origin (0, 0) and\n   * this point.\n   */\n  double get magnitude => sqrt(x * x + y * y);\n\n  /**\n   * Returns the distance between `this` and [other].\n   */\n  double distanceTo(Point<T> other) {\n    var dx = x - other.x;\n    var dy = y - other.y;\n    return sqrt(dx * dx + dy * dy);\n  }\n\n  /**\n   * Returns the squared distance between `this` and [other].\n   *\n   * Squared distances can be used for comparisons when the actual value is not\n   * required.\n   */\n  T squaredDistanceTo(Point<T> other) {\n    var dx = x - other.x;\n    var dy = y - other.y;\n    return dx * dx + dy * dy;\n  }\n}\n\u0000","sdk:/sdk/lib/math/jenkins_smi_hash.dart":"// Copyright (c) 2013, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\npart of dart.math;\n\n/**\n * This is the [Jenkins hash function][1] but using masking to keep\n * values in SMI range.\n *\n * [1]: http://en.wikipedia.org/wiki/Jenkins_hash_function\n *\n * Use:\n * Hash each value with the hash of the previous value, then get the final\n * hash by calling finish.\n *\n *     var hash = 0;\n *     for (var value in values) {\n *       hash = JenkinsSmiHash.combine(hash, value.hashCode);\n *     }\n *     hash = JenkinsSmiHash.finish(hash);\n */\nclass _JenkinsSmiHash {\n  // TODO(11617): This class should be optimized and standardized elsewhere.\n\n  static int combine(int hash, int value) {\n    hash = 0x1fffffff & (hash + value);\n    hash = 0x1fffffff & (hash + ((0x0007ffff & hash) << 10));\n    return hash ^ (hash >> 6);\n  }\n\n  static int finish(int hash) {\n    hash = 0x1fffffff & (hash + ((0x03ffffff & hash) <<  3));\n    hash = hash ^ (hash >> 11);\n    return 0x1fffffff & (hash + ((0x00003fff & hash) << 15));\n  }\n\n  static int hash2(a, b) => finish(combine(combine(0, a), b));\n\n  static int hash4(a, b, c, d) =>\n      finish(combine(combine(combine(combine(0, a), b), c), d));\n}\n\u0000","sdk:/sdk/lib/math/math.dart":"// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n/**\n * Mathematical constants and functions, plus a random number generator.\n */\nlibrary dart.math;\n\npart \"jenkins_smi_hash.dart\";\npart \"point.dart\";\npart \"random.dart\";\npart \"rectangle.dart\";\n\n/**\n * Base of the natural logarithms.\n *\n * Typically written as \"e\".\n */\nconst double E = 2.718281828459045;\n\n/**\n * Natural logarithm of 10.\n */\nconst double LN10 =  2.302585092994046;\n\n/**\n * Natural logarithm of 2.\n */\nconst double LN2 =  0.6931471805599453;\n\n/**\n * Base-2 logarithm of [E].\n */\nconst double LOG2E = 1.4426950408889634;\n\n/**\n * Base-10 logarithm of [E].\n */\nconst double LOG10E = 0.4342944819032518;\n\n/**\n * The PI constant.\n */\nconst double PI = 3.1415926535897932;\n\n/**\n * Square root of 1/2.\n */\nconst double SQRT1_2 = 0.7071067811865476;\n\n/**\n * Square root of 2.\n */\nconst double SQRT2 = 1.4142135623730951;\n\n/**\n  * Returns the lesser of two numbers.\n  *\n  * Returns NaN if either argument is NaN.\n  * The lesser of [:-0.0:] and [:0.0:] is [:-0.0:].\n  * If the arguments are otherwise equal (including int and doubles with the\n  * same mathematical value) then it is unspecified which of the two arguments\n  * is returned.\n  */\nnum min(num a, num b) {\n  // These partially redundant type checks improve code quality for dart2js.\n  // Most of the improvement is at call sites from the inferred non-null num\n  // return type.\n  if (a is! num) throw new ArgumentError(a);\n  if (b is! num) throw new ArgumentError(b);\n\n  if (a > b) return b;\n  if (a < b) return a;\n  if (b is double) {\n    // Special case for NaN and -0.0. If one argument is NaN return NaN.\n    // [min] must also distinguish between -0.0 and 0.0.\n    if (a is double) {\n      if (a == 0.0) {\n        // a is either 0.0 or -0.0. b is either 0.0, -0.0 or NaN.\n        // The following returns -0.0 if either a or b is -0.0, and it\n        // returns NaN if b is NaN.\n        return (a + b) * a * b;\n      }\n    }\n    // Check for NaN and b == -0.0.\n    if (a == 0 && b.isNegative || b.isNaN) return b;\n    return a;\n  }\n  return a;\n}\n\n/**\n  * Returns the larger of two numbers.\n  *\n  * Returns NaN if either argument is NaN.\n  * The larger of [:-0.0:] and [:0.0:] is [:0.0:]. If the arguments are\n  * otherwise equal (including int and doubles with the same mathematical value)\n  * then it is unspecified which of the two arguments is returned.\n  */\nnum max(num a, num b) {\n  // These partially redundant type checks improve code quality for dart2js.\n  // Most of the improvement is at call sites from the inferred non-null num\n  // return type.\n  if (a is! num) throw new ArgumentError(a);\n  if (b is! num) throw new ArgumentError(b);\n\n  if (a > b) return a;\n  if (a < b) return b;\n  if (b is double) {\n    // Special case for NaN and -0.0. If one argument is NaN return NaN.\n    // [max] must also distinguish between -0.0 and 0.0.\n    if (a is double) {\n      if (a == 0.0) {\n        // a is either 0.0 or -0.0. b is either 0.0, -0.0, or NaN.\n        // The following returns 0.0 if either a or b is 0.0, and it\n        // returns NaN if b is NaN.\n        return a + b;\n      }\n    }\n    // Check for NaN.\n    if (b.isNaN) return b;\n    return a;\n  }\n  // max(-0.0, 0) must return 0.\n  if (b == 0 && a.isNegative) return b;\n  return a;\n}\n\n/**\n * A variant of [atan].\n *\n * Converts both arguments to doubles.\n *\n * Returns the angle between the positive x-axis and the vector ([b],[a]).\n * The result, in radians, is in the range -PI..PI.\n *\n * If [b] is positive, this is the same as [:atan(b/a):].\n *\n * The result is negative when [a] is negative (including when [a] is the\n * double -0.0).\n *\n * If [a] is equal to zero, the vector ([b],[a]) is considered parallel to\n * the x-axis, even if [b] is also equal to zero. The sign of [b] determines\n * the direction of the vector along the x-axis.\n *\n * Returns NaN if either argument is NaN.\n */\nexternal double atan2(num a, num b);\n\n/**\n * Returns [x] to the power of [exponent].\n *\n * If [x] is an [int] and [exponent] is a non-negative [int], the result is\n * an [int], otherwise both arguments are converted to doubles first, and the\n * result is a [double].\n *\n * For integers, the power is always equal to the mathematical result of `x` to\n * the power `exponent`, only limited by the available memory.\n *\n * For doubles, `pow(x, y)` handles edge cases as follows:\n *\n * - if `y` is zero (0.0 or -0.0), the result is always 1.0.\n * - if `x` is 1.0, the result is always 1.0.\n * - otherwise, if either `x` or `y` is NaN then the result is NaN.\n * - if `x` is negative (but not -0.0) and `y` is a finite non-integer, the\n *   result is NaN.\n * - if `x` is Infinity and `y` is negative, the result is 0.0.\n * - if `x` is Infinity and `y` is positive, the result is Infinity.\n * - if `x` is 0.0 and `y` is negative, the result is Infinity.\n * - if `x` is 0.0 and `y` is positive, the result is 0.0.\n * - if `x` is -Infinity or -0.0 and `y` is an odd integer, then the result is\n *   `-pow(-x ,y)`.\n * - if `x` is -Infinity or -0.0 and `y` is not an odd integer, then the result\n *   is the same as `pow(-x , y)`.\n * - if `y` is Infinity and the absolute value of `x` is less than 1, the\n *   result is 0.0.\n * - if `y` is Infinity and `x` is -1, the result is 1.0.\n * - if `y` is Infinity and the absolute value of `x` is greater than 1,\n *   the result is Infinity.\n * - if `y` is -Infinity, the result is `1/pow(x, Infinity)`.\n *\n * This corresponds to the `pow` function defined in the IEEE Standard 754-2008.\n *\n * Notice that an [int] result cannot overflow, but a [double] result might\n * be [double.INFINITY].\n */\nexternal num pow(num x, num exponent);\n\n/**\n * Converts [x] to a double and returns the sine of the value.\n *\n * If [x] is not a finite number, the result is NaN.\n */\nexternal double sin(num x);\n\n/**\n * Converts [x] to a double and returns the cosine of the value.\n *\n * If [x] is not a finite number, the result is NaN.\n */\nexternal double cos(num x);\n\n/**\n * Converts [x] to a double and returns the tangent of the value.\n *\n * The tangent function is equivalent to [:sin(x)/cos(x):] and may be\n * infinite (positive or negative) when [:cos(x):] is equal to zero.\n * If [x] is not a finite number, the result is NaN.\n */\nexternal double tan(num x);\n\n/**\n * Converts [x] to a double and returns the arc cosine of the value.\n *\n * Returns a value in the range -PI..PI, or NaN if [x] is outside\n * the range -1..1.\n */\nexternal double acos(num x);\n\n/**\n * Converts [x] to a double and returns the arc sine of the value.\n * Returns a value in the range -PI..PI, or  NaN if [x] is outside\n * the range -1..1.\n */\nexternal double asin(num x);\n\n/**\n * Converts [x] to a dobule and returns the arc tangent of the vlaue.\n * Returns a value in the range -PI/2..PI/2, or NaN if [x] is NaN.\n */\nexternal double atan(num x);\n\n/**\n * Converts [x] to a double and returns the positive square root of the value.\n *\n * Returns -0.0 if [x] is -0.0, and NaN if [x] is otherwise negative or NaN.\n */\nexternal double sqrt(num x);\n\n/**\n * Converts [x] to a double and returns the natural exponent, [E],\n * to the power [x].\n * Returns NaN if [x] is NaN.\n */\nexternal double exp(num x);\n\n/**\n * Converts [x] to a double and returns the natural logarithm of the value.\n * Returns negative infinity if [x] is equal to zero.\n * Returns NaN if [x] is NaN or less than zero.\n */\nexternal double log(num x);\n\u0000","sdk:/sdk/lib/_internal/lib/isolate_helper.dart":"// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\nlibrary _isolate_helper;\n\nimport 'dart:async';\nimport 'dart:collection' show Queue, HashMap;\nimport 'dart:isolate';\nimport 'dart:_js_helper' show\n    Closure,\n    Null,\n    Primitives,\n    convertDartClosureToJS,\n    random64,\n    requiresPreamble;\nimport 'dart:_foreign_helper' show DART_CLOSURE_TO_JS,\n                                   JS,\n                                   JS_CREATE_ISOLATE,\n                                   JS_CURRENT_ISOLATE_CONTEXT,\n                                   JS_CURRENT_ISOLATE,\n                                   JS_SET_CURRENT_ISOLATE,\n                                   IsolateContext;\nimport 'dart:_interceptors' show JSExtendableArray;\n\n/**\n * Called by the compiler to support switching\n * between isolates when we get a callback from the DOM.\n */\n_callInIsolate(_IsolateContext isolate, Function function) {\n  var result = isolate.eval(function);\n  _globalState.topEventLoop.run();\n  return result;\n}\n\n/// Marks entering a JavaScript async operation to keep the worker alive.\n///\n/// To be called by library code before starting an async operation controlled\n/// by the JavaScript event handler.\n///\n/// Also call [leaveJsAsync] in all callback handlers marking the end of that\n/// async operation (also error handlers) so the worker can be released.\n///\n/// These functions only has to be called for code that can be run from a\n/// worker-isolate (so not for general dom operations).\nenterJsAsync() {\n  _globalState.topEventLoop._activeJsAsyncCount++;\n}\n\n/// Marks leaving a javascript async operation.\n///\n/// See [enterJsAsync].\nleaveJsAsync() {\n  _globalState.topEventLoop._activeJsAsyncCount--;\n  assert(_globalState.topEventLoop._activeJsAsyncCount >= 0);\n}\n\n/// Returns true if we are currently in a worker context.\nbool isWorker() => _globalState.isWorker;\n\n/**\n * Called by the compiler to fetch the current isolate context.\n */\n_IsolateContext _currentIsolate() => _globalState.currentContext;\n\n/**\n * Wrapper that takes the dart entry point and runs it within an isolate. The\n * dart2js compiler will inject a call of the form\n * [: startRootIsolate(main); :] when it determines that this wrapping\n * is needed. For single-isolate applications (e.g. hello world), this\n * call is not emitted.\n */\nvoid startRootIsolate(entry, args) {\n  // The dartMainRunner can inject a new arguments array. We pass the arguments\n  // through a \"JS\", so that the type-inferrer loses track of it.\n  args = JS(\"\", \"#\", args);\n  if (args == null) args = [];\n  if (args is! List) {\n    throw new ArgumentError(\"Arguments to main must be a List: $args\");\n  }\n  _globalState = new _Manager(entry);\n\n  // Don't start the main loop again, if we are in a worker.\n  if (_globalState.isWorker) return;\n  final rootContext = new _IsolateContext();\n  _globalState.rootContext = rootContext;\n\n  // BUG(5151491): Setting currentContext should not be necessary, but\n  // because closures passed to the DOM as event handlers do not bind their\n  // isolate automatically we try to give them a reasonable context to live in\n  // by having a \"default\" isolate (the first one created).\n  _globalState.currentContext = rootContext;\n  if (entry is _MainFunctionArgs) {\n    rootContext.eval(() { entry(args); });\n  } else if (entry is _MainFunctionArgsMessage) {\n    rootContext.eval(() { entry(args, null); });\n  } else {\n    rootContext.eval(entry);\n  }\n  _globalState.topEventLoop.run();\n}\n\n/********************************************************\n  Inserted from lib/isolate/dart2js/isolateimpl.dart\n ********************************************************/\n\n/**\n * Concepts used here:\n *\n * \"manager\" - A manager contains one or more isolates, schedules their\n * execution, and performs other plumbing on their behalf.  The isolate\n * present at the creation of the manager is designated as its \"root isolate\".\n * A manager may, for example, be implemented on a web Worker.\n *\n * [_Manager] - State present within a manager (exactly once, as a global).\n *\n * [_ManagerStub] - A handle held within one manager that allows interaction\n * with another manager.  A target manager may be addressed by zero or more\n * [_ManagerStub]s.\n * TODO(ahe): The _ManagerStub concept is broken.  It was an attempt\n * to create a common interface between the native Worker class and\n * _MainManagerStub.\n */\n\n/**\n * A native object that is shared across isolates. This object is visible to all\n * isolates running under the same manager (either UI or background web worker).\n *\n * This is code that is intended to 'escape' the isolate boundaries in order to\n * implement the semantics of isolates in JavaScript. Without this we would have\n * been forced to implement more code (including the top-level event loop) in\n * JavaScript itself.\n */\n// TODO(eub, sigmund): move the \"manager\" to be entirely in JS.\n// Running any Dart code outside the context of an isolate gives it\n// the chance to break the isolate abstraction.\n_Manager get _globalState => JS(\"_Manager\", \"init.globalState\");\n\nset _globalState(_Manager val) {\n  JS(\"void\", \"init.globalState = #\", val);\n}\n\n/** State associated with the current manager. See [globalState]. */\n// TODO(sigmund): split in multiple classes: global, thread, main-worker states?\nclass _Manager {\n\n  /** Next available isolate id within this [_Manager]. */\n  int nextIsolateId = 0;\n\n  /** id assigned to this [_Manager]. */\n  int currentManagerId = 0;\n\n  /**\n   * Next available manager id. Only used by the main manager to assign a unique\n   * id to each manager created by it.\n   */\n  int nextManagerId = 1;\n\n  /** Context for the currently running [Isolate]. */\n  _IsolateContext currentContext = null;\n\n  /** Context for the root [Isolate] that first run in this [_Manager]. */\n  _IsolateContext rootContext = null;\n\n  /** The top-level event loop. */\n  _EventLoop topEventLoop;\n\n  /** Whether this program is running from the command line. */\n  bool fromCommandLine;\n\n  /** Whether this [_Manager] is running as a web worker. */\n  bool isWorker;\n\n  /** Whether we support spawning web workers. */\n  bool supportsWorkers;\n\n  /**\n   * Whether to use web workers when implementing isolates. Set to false for\n   * debugging/testing.\n   */\n  bool get useWorkers => supportsWorkers;\n\n  /**\n   * Whether to use the web-worker JSON-based message serialization protocol. By\n   * default this is only used with web workers. For debugging, you can force\n   * using this protocol by changing this field value to [:true:].\n   */\n  bool get needSerialization => useWorkers;\n\n  /**\n   * Registry of isolates. Isolates must be registered if, and only if, receive\n   * ports are alive.  Normally no open receive-ports means that the isolate is\n   * dead, but DOM callbacks could resurrect it.\n   */\n  Map<int, _IsolateContext> isolates;\n\n  /** Reference to the main [_Manager].  Null in the main [_Manager] itself. */\n  _MainManagerStub mainManager;\n\n  /// Registry of active Web Workers.  Only used in the main [_Manager].\n  Map<int, dynamic /* Worker */> managers;\n\n  /** The entry point given by [startRootIsolate]. */\n  final Function entry;\n\n  _Manager(this.entry) {\n    _nativeDetectEnvironment();\n    topEventLoop = new _EventLoop();\n    isolates = new Map<int, _IsolateContext>();\n    managers = new Map<int, dynamic>();\n    if (isWorker) {  // \"if we are not the main manager ourself\" is the intent.\n      mainManager = new _MainManagerStub();\n      _nativeInitWorkerMessageHandler();\n    }\n  }\n\n  void _nativeDetectEnvironment() {\n    bool isWindowDefined = globalWindow != null;\n    bool isWorkerDefined = globalWorker != null;\n\n    isWorker = !isWindowDefined && globalPostMessageDefined;\n    supportsWorkers = isWorker\n       || (isWorkerDefined && IsolateNatives.thisScript != null);\n    fromCommandLine = !isWindowDefined && !isWorker;\n  }\n\n  void _nativeInitWorkerMessageHandler() {\n    var function = JS('',\n        \"(function (f, a) { return function (e) { f(a, e); }})(#, #)\",\n        DART_CLOSURE_TO_JS(IsolateNatives._processWorkerMessage),\n        mainManager);\n    JS(\"void\", r\"self.onmessage = #\", function);\n    // We ensure dartPrint is defined so that the implementation of the Dart\n    // print method knows what to call.\n    JS('', '''self.dartPrint = self.dartPrint || (function(serialize) {\n  return function (object) {\n    if (self.console && self.console.log) {\n      self.console.log(object)\n    } else {\n      self.postMessage(serialize(object));\n    }\n  }\n})(#)''', DART_CLOSURE_TO_JS(_serializePrintMessage));\n  }\n\n  static _serializePrintMessage(object) {\n    return _serializeMessage({\"command\": \"print\", \"msg\": object});\n  }\n\n  /**\n   * Close the worker running this code if all isolates are done and\n   * there are no active async JavaScript tasks still running.\n   */\n  void maybeCloseWorker() {\n    if (isWorker\n        && isolates.isEmpty\n        && topEventLoop._activeJsAsyncCount == 0) {\n      mainManager.postMessage(_serializeMessage({'command': 'close'}));\n    }\n  }\n}\n\n/** Context information tracked for each isolate. */\nclass _IsolateContext implements IsolateContext {\n  /** Current isolate id. */\n  final int id = _globalState.nextIsolateId++;\n\n  /** Registry of receive ports currently active on this isolate. */\n  final Map<int, RawReceivePortImpl> ports = new Map<int, RawReceivePortImpl>();\n\n  /** Registry of weak receive ports currently active on this isolate. */\n  final Set<int> weakPorts = new Set<int>();\n\n  /** Holds isolate globals (statics and top-level properties). */\n  // native object containing all globals of an isolate.\n  final isolateStatics = JS_CREATE_ISOLATE();\n\n  final RawReceivePortImpl controlPort = new RawReceivePortImpl._controlPort();\n\n  final Capability pauseCapability = new Capability();\n  final Capability terminateCapability = new Capability();  // License to kill.\n\n  /// Boolean flag set when the initial method of the isolate has been executed.\n  ///\n  /// Used to avoid considering the isolate dead when it has no open\n  /// receive ports and no scheduled timers, because it hasn't had time to\n  /// create them yet.\n  bool initialized = false;\n\n  // TODO(lrn): Store these in single \"PauseState\" object, so they don't take\n  // up as much room when not pausing.\n  bool isPaused = false;\n  List<_IsolateEvent> delayedEvents = [];\n  Set<Capability> pauseTokens = new Set();\n\n  // Container with the \"on exit\" handler send-ports.\n  var doneHandlers;\n\n  /**\n   * Queue of functions to call when the current event is complete.\n   *\n   * These events are not just put at the front of the event queue, because\n   * they represent control messages, and should be handled even if the\n   * event queue is paused.\n   */\n  var _scheduledControlEvents;\n  bool _isExecutingEvent = false;\n\n  /** Whether uncaught errors are considered fatal. */\n  bool errorsAreFatal = true;\n\n  // Set of ports that listen to uncaught errors.\n  Set<SendPort> errorPorts = new Set();\n\n  _IsolateContext() {\n    this.registerWeak(controlPort._id, controlPort);\n  }\n\n  void addPause(Capability authentification, Capability resume) {\n    if (pauseCapability != authentification) return;\n    if (pauseTokens.add(resume) && !isPaused) {\n      isPaused = true;\n    }\n    _updateGlobalState();\n  }\n\n  void removePause(Capability resume) {\n    if (!isPaused) return;\n    pauseTokens.remove(resume);\n    if (pauseTokens.isEmpty) {\n      while(delayedEvents.isNotEmpty) {\n        _IsolateEvent event = delayedEvents.removeLast();\n        _globalState.topEventLoop.prequeue(event);\n      }\n      isPaused = false;\n    }\n    _updateGlobalState();\n  }\n\n  void addDoneListener(SendPort responsePort) {\n    if (doneHandlers == null) {\n      doneHandlers = [];\n    }\n    // If necessary, we can switch doneHandlers to a Set if it gets larger.\n    // That is not expected to happen in practice.\n    if (doneHandlers.contains(responsePort)) return;\n    doneHandlers.add(responsePort);\n  }\n\n  void removeDoneListener(SendPort responsePort) {\n    if (doneHandlers == null) return;\n    doneHandlers.remove(responsePort);\n  }\n\n  void setErrorsFatal(Capability authentification, bool errorsAreFatal) {\n    if (terminateCapability != authentification) return;\n    this.errorsAreFatal = errorsAreFatal;\n  }\n\n  void handlePing(SendPort responsePort, int pingType) {\n    if (pingType == Isolate.IMMEDIATE ||\n        (pingType == Isolate.BEFORE_NEXT_EVENT &&\n         !_isExecutingEvent)) {\n      responsePort.send(null);\n      return;\n    }\n    void respond() { responsePort.send(null); }\n    if (pingType == Isolate.AS_EVENT) {\n      _globalState.topEventLoop.enqueue(this, respond, \"ping\");\n      return;\n    }\n    assert(pingType == Isolate.BEFORE_NEXT_EVENT);\n    if (_scheduledControlEvents == null) {\n      _scheduledControlEvents = new Queue();\n    }\n    _scheduledControlEvents.addLast(respond);\n  }\n\n  void handleKill(Capability authentification, int priority) {\n    if (this.terminateCapability != authentification) return;\n    if (priority == Isolate.IMMEDIATE ||\n        (priority == Isolate.BEFORE_NEXT_EVENT &&\n         !_isExecutingEvent)) {\n      kill();\n      return;\n    }\n    if (priority == Isolate.AS_EVENT) {\n      _globalState.topEventLoop.enqueue(this, kill, \"kill\");\n      return;\n    }\n    assert(priority == Isolate.BEFORE_NEXT_EVENT);\n    if (_scheduledControlEvents == null) {\n      _scheduledControlEvents = new Queue();\n    }\n    _scheduledControlEvents.addLast(kill);\n  }\n\n  void addErrorListener(SendPort port) {\n    errorPorts.add(port);\n  }\n\n  void removeErrorListener(SendPort port) {\n    errorPorts.remove(port);\n  }\n\n  /** Function called with an uncaught error. */\n  void handleUncaughtError(error, StackTrace stackTrace) {\n    // Just print the error if there is no error listener registered.\n    if (errorPorts.isEmpty) {\n      // An uncaught error in the root isolate will terminate the program?\n      if (errorsAreFatal && identical(this, _globalState.rootContext)) {\n        // The error will be rethrown to reach the global scope, so\n        // don't print it.\n        return;\n      }\n      if (JS('bool', 'self.console && self.console.error')) {\n        JS('void', 'self.console.error(#, #)', error, stackTrace);\n      } else {\n        print(error);\n        if (stackTrace != null) print(stackTrace);\n      }\n      return;\n    }\n    List message = new List(2)\n        ..[0] = error.toString()\n        ..[1] = (stackTrace == null) ? null : stackTrace.toString();\n    for (SendPort port in errorPorts) port.send(message);\n  }\n\n  /**\n   * Run [code] in the context of the isolate represented by [this].\n   */\n  dynamic eval(Function code) {\n    var old = _globalState.currentContext;\n    _globalState.currentContext = this;\n    this._setGlobals();\n    var result = null;\n    _isExecutingEvent = true;\n    try {\n      result = code();\n    } catch (e, s) {\n      handleUncaughtError(e, s);\n      if (errorsAreFatal) {\n        kill();\n        // An uncaught error in the root context terminates all isolates.\n        if (identical(this, _globalState.rootContext)) {\n          rethrow;\n        }\n      }\n    } finally {\n      _isExecutingEvent = false;\n      _globalState.currentContext = old;\n      if (old != null) old._setGlobals();\n      if (_scheduledControlEvents != null) {\n        while (_scheduledControlEvents.isNotEmpty) {\n          (_scheduledControlEvents.removeFirst())();\n        }\n      }\n    }\n    return result;\n  }\n\n  void _setGlobals() {\n    JS_SET_CURRENT_ISOLATE(isolateStatics);\n  }\n\n  /**\n   * Handle messages comming in on the control port.\n   *\n   * These events do not go through the event queue.\n   * The `_globalState.currentContext` context is not set to this context\n   * during the handling.\n   */\n  void handleControlMessage(message) {\n    switch (message[0]) {\n      case \"pause\":\n        addPause(message[1], message[2]);\n        break;\n      case \"resume\":\n        removePause(message[1]);\n        break;\n      case 'add-ondone':\n        addDoneListener(message[1]);\n        break;\n      case 'remove-ondone':\n        removeDoneListener(message[1]);\n        break;\n      case 'set-errors-fatal':\n        setErrorsFatal(message[1], message[2]);\n        break;\n      case \"ping\":\n        handlePing(message[1], message[2]);\n        break;\n      case \"kill\":\n        handleKill(message[1], message[2]);\n        break;\n      case \"getErrors\":\n        addErrorListener(message[1]);\n        break;\n      case \"stopErrors\":\n        removeErrorListener(message[1]);\n        break;\n      default:\n    }\n  }\n\n  /** Looks up a port registered for this isolate. */\n  RawReceivePortImpl lookup(int portId) => ports[portId];\n\n  void _addRegistration(int portId, RawReceivePortImpl port) {\n    if (ports.containsKey(portId)) {\n      throw new Exception(\"Registry: ports must be registered only once.\");\n    }\n    ports[portId] = port;\n  }\n\n  /** Registers a port on this isolate. */\n  void register(int portId, RawReceivePortImpl port)  {\n    _addRegistration(portId, port);\n    _updateGlobalState();\n  }\n\n  /**\n   * Registers a weak port on this isolate.\n   *\n   * The port does not keep the isolate active.\n   */\n  void registerWeak(int portId, RawReceivePortImpl port)  {\n    weakPorts.add(portId);\n    _addRegistration(portId, port);\n  }\n\n  void _updateGlobalState() {\n    if (ports.length - weakPorts.length > 0 || isPaused || !initialized) {\n      _globalState.isolates[id] = this; // indicate this isolate is active\n    } else {\n      kill();\n    }\n  }\n\n  void kill() {\n    if (_scheduledControlEvents != null) {\n      // Kill all pending events.\n      _scheduledControlEvents.clear();\n    }\n    // Stop listening on all ports.\n    // This should happen before sending events to done handlers, in case\n    // we are listening on ourselves.\n    // Closes all ports, including control port.\n    for (var port in ports.values) {\n      port._close();\n    }\n    ports.clear();\n    weakPorts.clear();\n    _globalState.isolates.remove(id); // indicate this isolate is not active\n    errorPorts.clear();\n    if (doneHandlers != null) {\n      for (SendPort port in doneHandlers) {\n        port.send(null);\n      }\n      doneHandlers = null;\n    }\n  }\n\n  /** Unregister a port on this isolate. */\n  void unregister(int portId) {\n    ports.remove(portId);\n    weakPorts.remove(portId);\n    _updateGlobalState();\n  }\n}\n\n/** Represent the event loop on a javascript thread (DOM or worker). */\nclass _EventLoop {\n  final Queue<_IsolateEvent> events = new Queue<_IsolateEvent>();\n\n  /// The number of waiting callbacks not controlled by the dart event loop.\n  ///\n  /// This could be timers or http requests. The worker will only be killed if\n  /// this count reaches 0.\n  /// Access this by using [enterJsAsync] before starting a JavaScript async\n  /// operation and [leaveJsAsync] when the callback has fired.\n  int _activeJsAsyncCount = 0;\n\n  _EventLoop();\n\n  void enqueue(isolate, fn, msg) {\n    events.addLast(new _IsolateEvent(isolate, fn, msg));\n  }\n\n  void prequeue(_IsolateEvent event) {\n    events.addFirst(event);\n  }\n\n  _IsolateEvent dequeue() {\n    if (events.isEmpty) return null;\n    return events.removeFirst();\n  }\n\n  void checkOpenReceivePortsFromCommandLine() {\n    if (_globalState.rootContext != null\n        && _globalState.isolates.containsKey(_globalState.rootContext.id)\n        && _globalState.fromCommandLine\n        && _globalState.rootContext.ports.isEmpty) {\n      // We want to reach here only on the main [_Manager] and only\n      // on the command-line.  In the browser the isolate might\n      // still be alive due to DOM callbacks, but the presumption is\n      // that on the command-line, no future events can be injected\n      // into the event queue once it's empty.  Node has setTimeout\n      // so this presumption is incorrect there.  We think(?) that\n      // in d8 this assumption is valid.\n      throw new Exception(\"Program exited with open ReceivePorts.\");\n    }\n  }\n\n  /** Process a single event, if any. */\n  bool runIteration() {\n    final event = dequeue();\n    if (event == null) {\n      checkOpenReceivePortsFromCommandLine();\n      _globalState.maybeCloseWorker();\n      return false;\n    }\n    event.process();\n    return true;\n  }\n\n  /**\n   * Runs multiple iterations of the run-loop. If possible, each iteration is\n   * run asynchronously.\n   */\n  void _runHelper() {\n    if (globalWindow != null) {\n      // Run each iteration from the browser's top event loop.\n      void next() {\n        if (!runIteration()) return;\n        Timer.run(next);\n      }\n      next();\n    } else {\n      // Run synchronously until no more iterations are available.\n      while (runIteration()) {}\n    }\n  }\n\n  /**\n   * Call [_runHelper] but ensure that worker exceptions are propragated.\n   */\n  void run() {\n    if (!_globalState.isWorker) {\n      _runHelper();\n    } else {\n      try {\n        _runHelper();\n      } catch (e, trace) {\n        _globalState.mainManager.postMessage(_serializeMessage(\n            {'command': 'error', 'msg': '$e\\n$trace' }));\n      }\n    }\n  }\n}\n\n/** An event in the top-level event queue. */\nclass _IsolateEvent {\n  _IsolateContext isolate;\n  Function fn;\n  String message;\n\n  _IsolateEvent(this.isolate, this.fn, this.message);\n\n  void process() {\n    if (isolate.isPaused) {\n      isolate.delayedEvents.add(this);\n      return;\n    }\n    isolate.eval(fn);\n  }\n}\n\n/** A stub for interacting with the main manager. */\nclass _MainManagerStub {\n  void postMessage(msg) {\n    // \"self\" is a way to refer to the global context object that\n    // works in HTML pages and in Web Workers.  It does not work in d8\n    // and Firefox jsshell, because that would have been too easy.\n    //\n    // See: http://www.w3.org/TR/workers/#the-global-scope\n    // and: http://www.w3.org/TR/Window/#dfn-self-attribute\n    requiresPreamble();\n    JS(\"void\", r\"self.postMessage(#)\", msg);\n  }\n}\n\nconst String _SPAWNED_SIGNAL = \"spawned\";\nconst String _SPAWN_FAILED_SIGNAL = \"spawn failed\";\n\nget globalWindow {\n  requiresPreamble();\n  return JS('', \"self.window\");\n}\n\nget globalWorker {\n  requiresPreamble();\n  return JS('', \"self.Worker\");\n}\nbool get globalPostMessageDefined {\n  requiresPreamble();\n  return JS('bool', \"!!self.postMessage\");\n}\n\ntypedef _MainFunction();\ntypedef _MainFunctionArgs(args);\ntypedef _MainFunctionArgsMessage(args, message);\n\n/// Note: IsolateNatives depends on _globalState which is only set up correctly\n/// when 'dart:isolate' has been imported.\nclass IsolateNatives {\n\n  // We set [enableSpawnWorker] to true (not null) when calling isolate\n  // primitives that require support for spawning workers. The field starts out\n  // by being null, and dart2js' type inference will track if it can have a\n  // non-null value. So by testing if this value is not null, we generate code\n  // that dart2js knows is dead when worker support isn't needed.\n  // TODO(herhut): Initialize this to false when able to track compile-time\n  // constants.\n  static var enableSpawnWorker;\n\n  static String thisScript = computeThisScript();\n\n  /// Associates an ID with a native worker object.\n  static final Expando<int> workerIds = new Expando<int>();\n\n  /**\n   * The src url for the script tag that loaded this Used to create\n   * JavaScript workers.\n   */\n  static String computeThisScript() {\n    var currentScript = JS('', r'init.currentScript');\n    if (currentScript != null) {\n      return JS('String', 'String(#.src)', currentScript);\n    }\n    if (Primitives.isD8) return computeThisScriptD8();\n    if (Primitives.isJsshell) return computeThisScriptJsshell();\n    // A worker has no script tag - so get an url from a stack-trace.\n    if (_globalState.isWorker) return computeThisScriptFromTrace();\n    return null;\n  }\n\n  static String computeThisScriptJsshell() {\n    return JS('String|Null', 'thisFilename()');\n  }\n\n  // TODO(ahe): The following is for supporting D8.  We should move this code\n  // to a helper library that is only loaded when testing on D8.\n  static String computeThisScriptD8() => computeThisScriptFromTrace();\n\n  static String computeThisScriptFromTrace() {\n    var stack = JS('String|Null', 'new Error().stack');\n    if (stack == null) {\n      // According to Internet Explorer documentation, the stack\n      // property is not set until the exception is thrown. The stack\n      // property was not provided until IE10.\n      stack = JS('String|Null',\n                 '(function() {'\n                 'try { throw new Error() } catch(e) { return e.stack }'\n                 '})()');\n      if (stack == null) throw new UnsupportedError('No stack trace');\n    }\n    var pattern, matches;\n\n    // This pattern matches V8, Chrome, and Internet Explorer stack\n    // traces that look like this:\n    // Error\n    //     at methodName (URI:LINE:COLUMN)\n    pattern = JS('',\n                 r'new RegExp(\"^ *at [^(]*\\\\((.*):[0-9]*:[0-9]*\\\\)$\", \"m\")');\n\n\n    matches = JS('JSExtendableArray|Null', '#.match(#)', stack, pattern);\n    if (matches != null) return JS('String', '#[1]', matches);\n\n    // This pattern matches Firefox stack traces that look like this:\n    // methodName@URI:LINE\n    pattern = JS('', r'new RegExp(\"^[^@]*@(.*):[0-9]*$\", \"m\")');\n\n    matches = JS('JSExtendableArray|Null', '#.match(#)', stack, pattern);\n    if (matches != null) return JS('String', '#[1]', matches);\n\n    throw new UnsupportedError('Cannot extract URI from \"$stack\"');\n  }\n\n  /**\n   * Assume that [e] is a browser message event and extract its message data.\n   * We don't import the dom explicitly so, when workers are disabled, this\n   * library can also run on top of nodejs.\n   */\n  static _getEventData(e) => JS(\"\", \"#.data\", e);\n\n  /**\n   * Process messages on a worker, either to control the worker instance or to\n   * pass messages along to the isolate running in the worker.\n   */\n  static void _processWorkerMessage(/* Worker */ sender, e) {\n    var msg = _deserializeMessage(_getEventData(e));\n    switch (msg['command']) {\n      case 'start':\n        _globalState.currentManagerId = msg['id'];\n        String functionName = msg['functionName'];\n        Function entryPoint = (functionName == null)\n            ? _globalState.entry\n            : _getJSFunctionFromName(functionName);\n        var args = msg['args'];\n        var message = _deserializeMessage(msg['msg']);\n        var isSpawnUri = msg['isSpawnUri'];\n        var startPaused = msg['startPaused'];\n        var replyTo = _deserializeMessage(msg['replyTo']);\n        var context = new _IsolateContext();\n        _globalState.topEventLoop.enqueue(context, () {\n          _startIsolate(entryPoint, args, message,\n                        isSpawnUri, startPaused, replyTo);\n        }, 'worker-start');\n        // Make sure we always have a current context in this worker.\n        // TODO(7907): This is currently needed because we're using\n        // Timers to implement Futures, and this isolate library\n        // implementation uses Futures. We should either stop using\n        // Futures in this library, or re-adapt if Futures get a\n        // different implementation.\n        _globalState.currentContext = context;\n        _globalState.topEventLoop.run();\n        break;\n      case 'spawn-worker':\n        if (enableSpawnWorker != null) handleSpawnWorkerRequest(msg);\n        break;\n      case 'message':\n        SendPort port = msg['port'];\n        // If the port has been closed, we ignore the message.\n        if (port != null) {\n          msg['port'].send(msg['msg']);\n        }\n        _globalState.topEventLoop.run();\n        break;\n      case 'close':\n        _globalState.managers.remove(workerIds[sender]);\n        JS('void', '#.terminate()', sender);\n        _globalState.topEventLoop.run();\n        break;\n      case 'log':\n        _log(msg['msg']);\n        break;\n      case 'print':\n        if (_globalState.isWorker) {\n          _globalState.mainManager.postMessage(\n              _serializeMessage({'command': 'print', 'msg': msg}));\n        } else {\n          print(msg['msg']);\n        }\n        break;\n      case 'error':\n        throw msg['msg'];\n    }\n  }\n\n  static handleSpawnWorkerRequest(msg) {\n    var replyPort = msg['replyPort'];\n    spawn(msg['functionName'], msg['uri'],\n          msg['args'], msg['msg'],\n          false, msg['isSpawnUri'], msg['startPaused']).then((msg) {\n      replyPort.send(msg);\n    }, onError: (String errorMessage) {\n      replyPort.send([_SPAWN_FAILED_SIGNAL, errorMessage]);\n    });\n  }\n\n  /** Log a message, forwarding to the main [_Manager] if appropriate. */\n  static _log(msg) {\n    if (_globalState.isWorker) {\n      _globalState.mainManager.postMessage(\n          _serializeMessage({'command': 'log', 'msg': msg }));\n    } else {\n      try {\n        _consoleLog(msg);\n      } catch (e, trace) {\n        throw new Exception(trace);\n      }\n    }\n  }\n\n  static void _consoleLog(msg) {\n    requiresPreamble();\n    JS(\"void\", r\"self.console.log(#)\", msg);\n  }\n\n  static _getJSFunctionFromName(String functionName) {\n    return JS(\"\", \"init.globalFunctions[#]()\", functionName);\n  }\n\n  /**\n   * Get a string name for the function, if possible.  The result for\n   * anonymous functions is browser-dependent -- it may be \"\" or \"anonymous\"\n   * but you should probably not count on this.\n   */\n  static String _getJSFunctionName(Function f) {\n    return (f is Closure) ? JS(\"String|Null\", r'#.$name', f) : null;\n  }\n\n  /** Create a new JavaScript object instance given its constructor. */\n  static dynamic _allocate(var ctor) {\n    return JS(\"\", \"new #()\", ctor);\n  }\n\n  static Future<List> spawnFunction(void topLevelFunction(message),\n                                    var message,\n                                    bool startPaused) {\n    IsolateNatives.enableSpawnWorker = true;\n    final name = _getJSFunctionName(topLevelFunction);\n    if (name == null) {\n      throw new UnsupportedError(\n          \"only top-level functions can be spawned.\");\n    }\n    bool isLight = false;\n    bool isSpawnUri = false;\n    return spawn(name, null, null, message, isLight, isSpawnUri, startPaused);\n  }\n\n  static Future<List> spawnUri(Uri uri, List<String> args, var message,\n                               bool startPaused) {\n    IsolateNatives.enableSpawnWorker = true;\n    bool isLight = false;\n    bool isSpawnUri = true;\n    return spawn(null, uri.toString(), args, message,\n                 isLight, isSpawnUri, startPaused);\n  }\n\n  // TODO(sigmund): clean up above, after we make the new API the default:\n\n  /// If [uri] is `null` it is replaced with the current script.\n  static Future<List> spawn(String functionName, String uri,\n                            List<String> args, message,\n                            bool isLight, bool isSpawnUri, bool startPaused) {\n    // Assume that the compiled version of the Dart file lives just next to the\n    // dart file.\n    // TODO(floitsch): support precompiled version of dart2js output.\n    if (uri != null && uri.endsWith(\".dart\")) uri += \".js\";\n\n    ReceivePort port = new ReceivePort();\n    Completer<List> completer = new Completer();\n    port.first.then((msg) {\n      if (msg[0] == _SPAWNED_SIGNAL) {\n        completer.complete(msg);\n      } else {\n        assert(msg[0] == _SPAWN_FAILED_SIGNAL);\n        completer.completeError(msg[1]);\n      }\n    });\n\n    SendPort signalReply = port.sendPort;\n\n    if (_globalState.useWorkers && !isLight) {\n      _startWorker(\n          functionName, uri, args, message, isSpawnUri, startPaused,\n          signalReply, (String message) => completer.completeError(message));\n    } else {\n      _startNonWorker(\n          functionName, uri, args, message, isSpawnUri, startPaused,\n          signalReply);\n    }\n    return completer.future;\n  }\n\n  static void _startWorker(\n      String functionName, String uri,\n      List<String> args, message,\n      bool isSpawnUri,\n      bool startPaused,\n      SendPort replyPort,\n      void onError(String message)) {\n    if (_globalState.isWorker) {\n      _globalState.mainManager.postMessage(_serializeMessage({\n          'command': 'spawn-worker',\n          'functionName': functionName,\n          'args': args,\n          'msg': message,\n          'uri': uri,\n          'isSpawnUri': isSpawnUri,\n          'startPaused': startPaused,\n          'replyPort': replyPort}));\n    } else {\n      _spawnWorker(functionName, uri, args, message,\n                   isSpawnUri, startPaused, replyPort, onError);\n    }\n  }\n\n  static void _startNonWorker(\n      String functionName, String uri,\n      List<String> args, var message,\n      bool isSpawnUri,\n      bool startPaused,\n      SendPort replyPort) {\n    // TODO(eub): support IE9 using an iframe -- Dart issue 1702.\n    if (uri != null) {\n      throw new UnsupportedError(\n          \"Currently spawnUri is not supported without web workers.\");\n    }\n    message = _serializeMessage(message);\n    args = _serializeMessage(args);  // Or just args.toList() ?\n    _globalState.topEventLoop.enqueue(new _IsolateContext(), () {\n      final func = _getJSFunctionFromName(functionName);\n      _startIsolate(func, args, message, isSpawnUri, startPaused, replyPort);\n    }, 'nonworker start');\n  }\n\n  static void _startIsolate(Function topLevel,\n                            List<String> args, message,\n                            bool isSpawnUri,\n                            bool startPaused,\n                            SendPort replyTo) {\n    _IsolateContext context = JS_CURRENT_ISOLATE_CONTEXT();\n    Primitives.initializeStatics(context.id);\n    // The isolate's port does not keep the isolate open.\n    replyTo.send([_SPAWNED_SIGNAL,\n                  context.controlPort.sendPort,\n                  context.pauseCapability,\n                  context.terminateCapability]);\n\n    void runStartFunction() {\n      context.initialized = true;\n      if (!isSpawnUri) {\n        topLevel(message);\n      } else if (topLevel is _MainFunctionArgsMessage) {\n        topLevel(args, message);\n      } else if (topLevel is _MainFunctionArgs) {\n        topLevel(args);\n      } else {\n        topLevel();\n      }\n    }\n\n    if (startPaused) {\n      context.addPause(context.pauseCapability, context.pauseCapability);\n      _globalState.topEventLoop.enqueue(context, runStartFunction,\n                                        'start isolate');\n    } else {\n      runStartFunction();\n    }\n  }\n\n  /**\n   * Spawns an isolate in a worker. [factoryName] is the Javascript constructor\n   * name for the isolate entry point class.\n   */\n  static void _spawnWorker(functionName, String uri,\n                           List<String> args, message,\n                           bool isSpawnUri,\n                           bool startPaused,\n                           SendPort replyPort,\n                           void onError(String message)) {\n    if (uri == null) uri = thisScript;\n    final worker = JS('var', 'new Worker(#)', uri);\n    // Trampolines are used when wanting to call a Dart closure from\n    // JavaScript.  The helper function DART_CLOSURE_TO_JS only accepts\n    // top-level or static methods, and the trampoline allows us to capture\n    // arguments and values which can be passed to a static method.\n    final onerrorTrampoline = JS(\n        '',\n        '''\n(function (f, u, c) {\n  return function(e) {\n    return f(e, u, c)\n  }\n})(#, #, #)''',\n        DART_CLOSURE_TO_JS(workerOnError), uri, onError);\n    JS('void', '#.onerror = #', worker, onerrorTrampoline);\n\n    var processWorkerMessageTrampoline = JS(\n        '',\n        \"\"\"\n(function (f, a) {\n  return function (e) {\n    // We can stop listening for errors when the first message is received as\n    // we only listen for messages to determine if the uri was bad.\n    e.onerror = null;\n    return f(a, e);\n  }\n})(#, #)\"\"\",\n        DART_CLOSURE_TO_JS(_processWorkerMessage),\n        worker);\n    JS('void', '#.onmessage = #', worker, processWorkerMessageTrampoline);\n    var workerId = _globalState.nextManagerId++;\n    // We also store the id on the worker itself so that we can unregister it.\n    workerIds[worker] = workerId;\n    _globalState.managers[workerId] = worker;\n    JS('void', '#.postMessage(#)', worker, _serializeMessage({\n        'command': 'start',\n        'id': workerId,\n        // Note: we serialize replyPort twice because the child worker needs to\n        // first deserialize the worker id, before it can correctly deserialize\n        // the port (port deserialization is sensitive to what is the current\n        // workerId).\n        'replyTo': _serializeMessage(replyPort),\n        'args': args,\n        'msg': _serializeMessage(message),\n        'isSpawnUri': isSpawnUri,\n        'startPaused': startPaused,\n        'functionName': functionName }));\n  }\n\n  static bool workerOnError(\n      /* Event */ event,\n      String uri,\n      void onError(String message)) {\n    // Attempt to shut up the browser, as the error has been handled.  Chrome\n    // ignores this :-(\n    JS('void', '#.preventDefault()', event);\n    String message = JS('String|Null', '#.message', event);\n    if (message == null) {\n      // Some browsers, including Chrome, fail to provide a proper error\n      // event.\n      message = 'Error spawning worker for $uri';\n    } else {\n      message = 'Error spawning worker for $uri ($message)';\n    }\n    onError(message);\n    return true;\n  }\n}\n\n/********************************************************\n  Inserted from lib/isolate/dart2js/ports.dart\n ********************************************************/\n\n/** Common functionality to all send ports. */\nabstract class _BaseSendPort implements SendPort {\n  /** Id for the destination isolate. */\n  final int _isolateId;\n\n  const _BaseSendPort(this._isolateId);\n\n  void _checkReplyTo(SendPort replyTo) {\n    if (replyTo != null\n        && replyTo is! _NativeJsSendPort\n        && replyTo is! _WorkerSendPort) {\n      throw new Exception(\"SendPort.send: Illegal replyTo port type\");\n    }\n  }\n\n  void send(var message);\n  bool operator ==(var other);\n  int get hashCode;\n}\n\n/** A send port that delivers messages in-memory via native JavaScript calls. */\nclass _NativeJsSendPort extends _BaseSendPort implements SendPort {\n  final RawReceivePortImpl _receivePort;\n\n  const _NativeJsSendPort(this._receivePort, int isolateId) : super(isolateId);\n\n  void send(var message) {\n    // Check that the isolate still runs and the port is still open\n    final isolate = _globalState.isolates[_isolateId];\n    if (isolate == null) return;\n    if (_receivePort._isClosed) return;\n    // We force serialization/deserialization as a simple way to ensure\n    // isolate communication restrictions are respected between isolates that\n    // live in the same worker. [_NativeJsSendPort] delivers both messages\n    // from the same worker and messages from other workers. In particular,\n    // messages sent from a worker via a [_WorkerSendPort] are received at\n    // [_processWorkerMessage] and forwarded to a native port. In such cases,\n    // here we'll see [_globalState.currentContext == null].\n    final shouldSerialize = _globalState.currentContext != null\n        && _globalState.currentContext.id != _isolateId;\n    var msg = message;\n    if (shouldSerialize) {\n      msg = _serializeMessage(msg);\n    }\n    if (isolate.controlPort == _receivePort) {\n      isolate.handleControlMessage(msg);\n      return;\n    }\n    _globalState.topEventLoop.enqueue(isolate, () {\n      if (!_receivePort._isClosed) {\n        if (shouldSerialize) {\n          msg = _deserializeMessage(msg);\n        }\n        _receivePort._add(msg);\n      }\n    }, 'receive $message');\n  }\n\n  bool operator ==(var other) => (other is _NativeJsSendPort) &&\n      (_receivePort == other._receivePort);\n\n  int get hashCode => _receivePort._id;\n}\n\n/** A send port that delivers messages via worker.postMessage. */\n// TODO(eub): abstract this for iframes.\nclass _WorkerSendPort extends _BaseSendPort implements SendPort {\n  final int _workerId;\n  final int _receivePortId;\n\n  const _WorkerSendPort(this._workerId, int isolateId, this._receivePortId)\n      : super(isolateId);\n\n  void send(var message) {\n    final workerMessage = _serializeMessage({\n        'command': 'message',\n        'port': this,\n        'msg': message});\n\n    if (_globalState.isWorker) {\n      // Communication from one worker to another go through the\n      // main worker.\n      _globalState.mainManager.postMessage(workerMessage);\n    } else {\n      // Deliver the message only if the worker is still alive.\n      /* Worker */ var manager = _globalState.managers[_workerId];\n      if (manager != null) {\n        JS('void', '#.postMessage(#)', manager, workerMessage);\n      }\n    }\n  }\n\n  bool operator ==(var other) {\n    return (other is _WorkerSendPort) &&\n        (_workerId == other._workerId) &&\n        (_isolateId == other._isolateId) &&\n        (_receivePortId == other._receivePortId);\n  }\n\n  int get hashCode {\n    // TODO(sigmund): use a standard hash when we get one available in corelib.\n    return (_workerId << 16) ^ (_isolateId << 8) ^ _receivePortId;\n  }\n}\n\nclass RawReceivePortImpl implements RawReceivePort {\n  static int _nextFreeId = 1;\n\n  final int _id;\n  Function _handler;\n  bool _isClosed = false;\n\n  RawReceivePortImpl(this._handler) : _id = _nextFreeId++ {\n    _globalState.currentContext.register(_id, this);\n  }\n\n  RawReceivePortImpl.weak(this._handler) : _id = _nextFreeId++ {\n    _globalState.currentContext.registerWeak(_id, this);\n  }\n\n  // Creates the control port of an isolate.\n  // This is created before the isolate context object itself,\n  // so it cannot access the static _nextFreeId field.\n  RawReceivePortImpl._controlPort() : _handler = null, _id = 0;\n\n  void set handler(Function newHandler) {\n    _handler = newHandler;\n  }\n\n  // Close the port without unregistering it.\n  // Used by an isolate context to close all ports when shutting down.\n  void _close() {\n    _isClosed = true;\n    _handler = null;\n  }\n\n  void close() {\n    if (_isClosed) return;\n    _isClosed = true;\n    _handler = null;\n    _globalState.currentContext.unregister(_id);\n  }\n\n  void _add(dataEvent) {\n    if (_isClosed) return;\n    _handler(dataEvent);\n  }\n\n  SendPort get sendPort {\n    return new _NativeJsSendPort(this, _globalState.currentContext.id);\n  }\n}\n\nclass ReceivePortImpl extends Stream implements ReceivePort {\n  final RawReceivePort _rawPort;\n  StreamController _controller;\n\n  ReceivePortImpl() : this.fromRawReceivePort(new RawReceivePortImpl(null));\n\n  ReceivePortImpl.weak()\n      : this.fromRawReceivePort(new RawReceivePortImpl.weak(null));\n\n  ReceivePortImpl.fromRawReceivePort(this._rawPort) {\n    _controller = new StreamController(onCancel: close, sync: true);\n    _rawPort.handler = _controller.add;\n  }\n\n  StreamSubscription listen(void onData(var event),\n                            {Function onError,\n                             void onDone(),\n                             bool cancelOnError}) {\n    return _controller.stream.listen(onData, onError: onError, onDone: onDone,\n                                     cancelOnError: cancelOnError);\n  }\n\n  void close() {\n    _rawPort.close();\n    _controller.close();\n  }\n\n  SendPort get sendPort => _rawPort.sendPort;\n}\n\n\n/********************************************************\n  Inserted from lib/isolate/dart2js/messages.dart\n ********************************************************/\n\n// Defines message visitors, serialization, and deserialization.\n\n/** Serialize [message] (or simulate serialization). */\n_serializeMessage(message) {\n  if (_globalState.needSerialization) {\n    return new _JsSerializer().traverse(message);\n  } else {\n    return new _JsCopier().traverse(message);\n  }\n}\n\n/** Deserialize [message] (or simulate deserialization). */\n_deserializeMessage(message) {\n  if (_globalState.needSerialization) {\n    return new _JsDeserializer().deserialize(message);\n  } else {\n    // Nothing more to do.\n    return message;\n  }\n}\n\nclass _JsSerializer extends _Serializer {\n\n  _JsSerializer() : super() { _visited = new _JsVisitedMap(); }\n\n  visitSendPort(SendPort x) {\n    if (x is _NativeJsSendPort) return visitNativeJsSendPort(x);\n    if (x is _WorkerSendPort) return visitWorkerSendPort(x);\n    throw \"Illegal underlying port $x\";\n  }\n\n  visitCapability(Capability x) {\n    if (x is CapabilityImpl) {\n      return ['capability', x._id];\n    }\n    throw \"Capability not serializable: $x\";\n  }\n\n  visitNativeJsSendPort(_NativeJsSendPort port) {\n    return ['sendport', _globalState.currentManagerId,\n        port._isolateId, port._receivePort._id];\n  }\n\n  visitWorkerSendPort(_WorkerSendPort port) {\n    return ['sendport', port._workerId, port._isolateId, port._receivePortId];\n  }\n}\n\n\nclass _JsCopier extends _Copier {\n\n  _JsCopier() : super() { _visited = new _JsVisitedMap(); }\n\n  visitSendPort(SendPort x) {\n    if (x is _NativeJsSendPort) return visitNativeJsSendPort(x);\n    if (x is _WorkerSendPort) return visitWorkerSendPort(x);\n    throw \"Illegal underlying port $x\";\n  }\n\n  visitCapability(Capability x) {\n    if (x is CapabilityImpl) {\n      return new CapabilityImpl._internal(x._id);\n    }\n    throw \"Capability not serializable: $x\";\n  }\n\n  SendPort visitNativeJsSendPort(_NativeJsSendPort port) {\n    return new _NativeJsSendPort(port._receivePort, port._isolateId);\n  }\n\n  SendPort visitWorkerSendPort(_WorkerSendPort port) {\n    return new _WorkerSendPort(\n        port._workerId, port._isolateId, port._receivePortId);\n  }\n}\n\nclass _JsDeserializer extends _Deserializer {\n\n  SendPort deserializeSendPort(List list) {\n    int managerId = list[1];\n    int isolateId = list[2];\n    int receivePortId = list[3];\n    // If two isolates are in the same manager, we use NativeJsSendPorts to\n    // deliver messages directly without using postMessage.\n    if (managerId == _globalState.currentManagerId) {\n      var isolate = _globalState.isolates[isolateId];\n      if (isolate == null) return null; // Isolate has been closed.\n      var receivePort = isolate.lookup(receivePortId);\n      if (receivePort == null) return null; // Port has been closed.\n      return new _NativeJsSendPort(receivePort, isolateId);\n    } else {\n      return new _WorkerSendPort(managerId, isolateId, receivePortId);\n    }\n  }\n\n  Capability deserializeCapability(List list) {\n    return new CapabilityImpl._internal(list[1]);\n  }\n}\n\nclass _JsVisitedMap implements _MessageTraverserVisitedMap {\n  List tagged;\n\n  /** Retrieves any information stored in the native object [object]. */\n  operator[](var object) {\n    return _getAttachedInfo(object);\n  }\n\n  /** Injects some information into the native [object]. */\n  void operator[]=(var object, var info) {\n    tagged.add(object);\n    _setAttachedInfo(object, info);\n  }\n\n  /** Get ready to rumble. */\n  void reset() {\n    assert(tagged == null);\n    tagged = new List();\n  }\n\n  /** Remove all information injected in the native objects. */\n  void cleanup() {\n    for (int i = 0, length = tagged.length; i < length; i++) {\n      _clearAttachedInfo(tagged[i]);\n    }\n    tagged = null;\n  }\n\n  void _clearAttachedInfo(var o) {\n    JS(\"void\", \"#['__MessageTraverser__attached_info__'] = #\", o, null);\n  }\n\n  void _setAttachedInfo(var o, var info) {\n    JS(\"void\", \"#['__MessageTraverser__attached_info__'] = #\", o, info);\n  }\n\n  _getAttachedInfo(var o) {\n    return JS(\"\", \"#['__MessageTraverser__attached_info__']\", o);\n  }\n}\n\n// only visible for testing purposes\n// TODO(sigmund): remove once we can disable privacy for testing (bug #1882)\nclass TestingOnly {\n  static copy(x) {\n    return new _JsCopier().traverse(x);\n  }\n\n  // only visible for testing purposes\n  static serialize(x) {\n    _Serializer serializer = new _JsSerializer();\n    _Deserializer deserializer = new _JsDeserializer();\n    return deserializer.deserialize(serializer.traverse(x));\n  }\n}\n\n/********************************************************\n  Inserted from lib/isolate/serialization.dart\n ********************************************************/\n\nclass _MessageTraverserVisitedMap {\n\n  operator[](var object) => null;\n  void operator[]=(var object, var info) { }\n\n  void reset() { }\n  void cleanup() { }\n\n}\n\n/** Abstract visitor for dart objects that can be sent as isolate messages. */\nabstract class _MessageTraverser {\n\n  _MessageTraverserVisitedMap _visited;\n  _MessageTraverser() : _visited = new _MessageTraverserVisitedMap();\n\n  /** Visitor's entry point. */\n  traverse(var x) {\n    if (isPrimitive(x)) return visitPrimitive(x);\n    _visited.reset();\n    var result;\n    try {\n      result = _dispatch(x);\n    } finally {\n      _visited.cleanup();\n    }\n    return result;\n  }\n\n  _dispatch(var x) {\n    // This code likely fails for user classes implementing\n    // SendPort and Capability because it assumes the internal classes.\n    if (isPrimitive(x)) return visitPrimitive(x);\n    if (x is List) return visitList(x);\n    if (x is Map) return visitMap(x);\n    if (x is SendPort) return visitSendPort(x);\n    if (x is Capability) return visitCapability(x);\n\n    // Overridable fallback.\n    return visitObject(x);\n  }\n\n  visitPrimitive(x);\n  visitList(List x);\n  visitMap(Map x);\n  visitSendPort(SendPort x);\n  visitCapability(Capability x);\n\n  visitObject(Object x) {\n    // TODO(floitsch): make this a real exception. (which one)?\n    throw \"Message serialization: Illegal value $x passed\";\n  }\n\n  static bool isPrimitive(x) {\n    return (x == null) || (x is String) || (x is num) || (x is bool);\n  }\n}\n\n\n/** A visitor that recursively copies a message. */\nclass _Copier extends _MessageTraverser {\n\n  visitPrimitive(x) => x;\n\n  List visitList(List list) {\n    List copy = _visited[list];\n    if (copy != null) return copy;\n\n    int len = list.length;\n\n    // TODO(floitsch): we loose the generic type of the List.\n    copy = new List(len);\n    _visited[list] = copy;\n    for (int i = 0; i < len; i++) {\n      copy[i] = _dispatch(list[i]);\n    }\n    return copy;\n  }\n\n  Map visitMap(Map map) {\n    Map copy = _visited[map];\n    if (copy != null) return copy;\n\n    // TODO(floitsch): we loose the generic type of the map.\n    copy = new Map();\n    _visited[map] = copy;\n    map.forEach((key, val) {\n      copy[_dispatch(key)] = _dispatch(val);\n    });\n    return copy;\n  }\n\n  visitSendPort(SendPort x) => throw new UnimplementedError();\n\n  visitCapability(Capability x) => throw new UnimplementedError();\n}\n\n/** Visitor that serializes a message as a JSON array. */\nclass _Serializer extends _MessageTraverser {\n  int _nextFreeRefId = 0;\n\n  visitPrimitive(x) => x;\n\n  visitList(List list) {\n    int copyId = _visited[list];\n    if (copyId != null) return ['ref', copyId];\n\n    int id = _nextFreeRefId++;\n    _visited[list] = id;\n    var jsArray = _serializeList(list);\n    // TODO(floitsch): we are losing the generic type.\n    return ['list', id, jsArray];\n  }\n\n  visitMap(Map map) {\n    int copyId = _visited[map];\n    if (copyId != null) return ['ref', copyId];\n\n    int id = _nextFreeRefId++;\n    _visited[map] = id;\n    var keys = _serializeList(map.keys.toList());\n    var values = _serializeList(map.values.toList());\n    // TODO(floitsch): we are losing the generic type.\n    return ['map', id, keys, values];\n  }\n\n  _serializeList(List list) {\n    int len = list.length;\n    // Use a growable list because we do not add extra properties on\n    // them.\n    var result = new List()..length = len;\n    for (int i = 0; i < len; i++) {\n      result[i] = _dispatch(list[i]);\n    }\n    return result;\n  }\n\n  visitSendPort(SendPort x) => throw new UnimplementedError();\n\n  visitCapability(Capability x) => throw new UnimplementedError();\n}\n\n/** Deserializes arrays created with [_Serializer]. */\nabstract class _Deserializer {\n  Map<int, dynamic> _deserialized;\n\n  _Deserializer();\n\n  static bool isPrimitive(x) {\n    return (x == null) || (x is String) || (x is num) || (x is bool);\n  }\n\n  deserialize(x) {\n    if (isPrimitive(x)) return x;\n    // TODO(floitsch): this should be new HashMap<int, dynamic>()\n    _deserialized = new HashMap();\n    return _deserializeHelper(x);\n  }\n\n  _deserializeHelper(x) {\n    if (isPrimitive(x)) return x;\n    assert(x is List);\n    switch (x[0]) {\n      case 'ref': return _deserializeRef(x);\n      case 'list': return _deserializeList(x);\n      case 'map': return _deserializeMap(x);\n      case 'sendport': return deserializeSendPort(x);\n      case 'capability': return deserializeCapability(x);\n      default: return deserializeObject(x);\n    }\n  }\n\n  _deserializeRef(List x) {\n    int id = x[1];\n    var result = _deserialized[id];\n    assert(result != null);\n    return result;\n  }\n\n  List _deserializeList(List x) {\n    int id = x[1];\n    // We rely on the fact that Dart-lists are directly mapped to Js-arrays.\n    List dartList = x[2];\n    _deserialized[id] = dartList;\n    int len = dartList.length;\n    for (int i = 0; i < len; i++) {\n      dartList[i] = _deserializeHelper(dartList[i]);\n    }\n    return dartList;\n  }\n\n  Map _deserializeMap(List x) {\n    Map result = new Map();\n    int id = x[1];\n    _deserialized[id] = result;\n    List keys = x[2];\n    List values = x[3];\n    int len = keys.length;\n    assert(len == values.length);\n    for (int i = 0; i < len; i++) {\n      var key = _deserializeHelper(keys[i]);\n      var value = _deserializeHelper(values[i]);\n      result[key] = value;\n    }\n    return result;\n  }\n\n  deserializeSendPort(List x);\n\n  deserializeCapability(List x);\n\n  deserializeObject(List x) {\n    // TODO(floitsch): Use real exception (which one?).\n    throw \"Unexpected serialized object\";\n  }\n}\n\nclass TimerImpl implements Timer {\n  final bool _once;\n  bool _inEventLoop = false;\n  int _handle;\n\n  TimerImpl(int milliseconds, void callback())\n      : _once = true {\n    if (milliseconds == 0 && (!hasTimer() || _globalState.isWorker)) {\n\n      void internalCallback() {\n        _handle = null;\n        callback();\n      }\n\n      // Setting _handle to something different from null indicates that the\n      // callback has not been run. Hence, the choice of 1 is arbitrary.\n      _handle = 1;\n\n      // This makes a dependency between the async library and the\n      // event loop of the isolate library. The compiler makes sure\n      // that the event loop is compiled if [Timer] is used.\n      // TODO(7907): In case of web workers, we need to use the event\n      // loop instead of setTimeout, to make sure the futures get executed in\n      // order.\n      _globalState.topEventLoop.enqueue(\n          _globalState.currentContext, internalCallback, 'timer');\n      _inEventLoop = true;\n    } else if (hasTimer()) {\n\n      void internalCallback() {\n        _handle = null;\n        leaveJsAsync();\n        callback();\n      }\n\n      enterJsAsync();\n\n      _handle = JS('int', 'self.setTimeout(#, #)',\n                   convertDartClosureToJS(internalCallback, 0),\n                   milliseconds);\n    } else {\n      assert(milliseconds > 0);\n      throw new UnsupportedError(\"Timer greater than 0.\");\n    }\n  }\n\n  TimerImpl.periodic(int milliseconds, void callback(Timer timer))\n      : _once = false {\n    if (hasTimer()) {\n      enterJsAsync();\n      _handle = JS('int', 'self.setInterval(#, #)',\n                   convertDartClosureToJS(() { callback(this); }, 0),\n                   milliseconds);\n    } else {\n      throw new UnsupportedError(\"Periodic timer.\");\n    }\n  }\n\n  void cancel() {\n    if (hasTimer()) {\n      if (_inEventLoop) {\n        throw new UnsupportedError(\"Timer in event loop cannot be canceled.\");\n      }\n      if (_handle == null) return;\n      leaveJsAsync();\n      if (_once) {\n        JS('void', 'self.clearTimeout(#)', _handle);\n      } else {\n        JS('void', 'self.clearInterval(#)', _handle);\n      }\n      _handle = null;\n    } else {\n      throw new UnsupportedError(\"Canceling a timer.\");\n    }\n  }\n\n  bool get isActive => _handle != null;\n}\n\nbool hasTimer() {\n  requiresPreamble();\n  return JS('', 'self.setTimeout') != null;\n}\n\n\n/**\n * Implementation class for [Capability].\n *\n * It has the same name to make it harder for users to distinguish.\n */\nclass CapabilityImpl implements Capability {\n  /** Internal random secret identifying the capability. */\n  final int _id;\n\n  CapabilityImpl() : this._internal(random64());\n\n  CapabilityImpl._internal(this._id);\n\n  int get hashCode {\n    // Thomas Wang 32 bit Mix.\n    // http://www.concentric.net/~Ttwang/tech/inthash.htm\n    // (via https://gist.github.com/badboy/6267743)\n    int hash = _id;\n    hash = (hash >> 0) ^ (hash ~/ 0x100000000);  // To 32 bit from ~64.\n    hash = (~hash + (hash << 15)) & 0xFFFFFFFF;\n    hash ^= hash >> 12;\n    hash = (hash * 5) & 0xFFFFFFFF;\n    hash ^= hash >> 4;\n    hash = (hash * 2057) & 0xFFFFFFFF;\n    hash ^= hash >> 16;\n    return hash;\n  }\n\n  bool operator==(Object other) {\n    if (identical(other, this)) return true;\n    if (other is CapabilityImpl) {\n      return identical(_id, other._id);\n    }\n    return false;\n  }\n}\n\u0000","sdk:/sdk/lib/isolate/capability.dart":"// Copyright (c) 2014, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\npart of dart.isolate;\n\n/**\n * An unforgeable object that comes back as equal when passed through other\n * isolates.\n *\n * Sending a capability object to another isolate, and getting it back,\n * will produce an object that is equal to the original.\n * There is no other way to create objects equal to a capability object.\n *\n * Capabilities can be used as access guards: A remote isolate can send\n * a request for an operation, but it is only allowed if the request contains\n * the correct capability object.\n *\n * This allows exposing the same interface to multiple clients,\n * but restricting some operations to only those clients\n * that have also been given the corresponding capability.\n *\n * Capabilities can be used inside a single isolate,\n * but they have no advantage over\n * just using `new Object` to create a unique object,\n * and it offers no real security against other code\n * running in the same isolate.\n */\nclass Capability {\n  /**\n   * Create a new unforgeable capability object.\n   */\n  external factory Capability();\n}\n\u0000","sdk:/sdk/lib/isolate/isolate.dart":"// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n/**\n * Concurrent programming using _isolates_:\n * independent workers that are similar to threads\n * but don't share memory,\n * communicating only via messages.\n */\nlibrary dart.isolate;\n\nimport \"dart:async\";\n\npart \"capability.dart\";\n\n/**\n * Thrown when an isolate cannot be created.\n */\nclass IsolateSpawnException implements Exception {\n  // TODO(floitsch): clean up spawn exception.\n  const IsolateSpawnException(String this._s);\n  String toString() => \"IsolateSpawnException: '$_s'\";\n  final String _s;\n}\n\nclass Isolate {\n  /** Argument to `ping` and `kill`: Ask for immediate action. */\n  static const int IMMEDIATE = 0;\n  /** Argument to `ping` and `kill`: Ask for action before the next event. */\n  static const int BEFORE_NEXT_EVENT = 1;\n  /** Argument to `ping` and `kill`: Ask for action after normal events. */\n  static const int AS_EVENT = 2;\n\n  /**\n   * Control port used to send control messages to the isolate.\n   *\n   * This class provides helper functions that sends control messages\n   * to the control port.\n   */\n  final SendPort controlPort;\n  /**\n   * Capability granting the ability to pause the isolate.\n   */\n  final Capability pauseCapability;\n\n  /**\n   * Capability granting the ability to terminate the isolate.\n   */\n  final Capability terminateCapability;\n\n  /**\n   * Create a new [Isolate] object with a restricted set of capabilities.\n   *\n   * The port should be a control port for an isolate, as taken from\n   * another `Isolate` object.\n   *\n   * The capabilities should be the subset of the capabilities that are\n   * available to the original isolate.\n   * Capabilities of an isolate are locked to that isolate, and have no effect\n   * anywhere else, so the capabilities should come from the same isolate as\n   * the control port.\n   *\n   * If all the available capabilities are included,\n   * there is no reason to create a new object,\n   * since the behavior is defined entirely\n   * by the control port and capabilities.\n   */\n  Isolate(this.controlPort, {this.pauseCapability,\n                             this.terminateCapability});\n\n  /**\n   * Creates and spawns an isolate that shares the same code as the current\n   * isolate.\n   *\n   * The argument [entryPoint] specifies the entry point of the spawned\n   * isolate. It must be a top-level function or a static method that\n   * takes one argument - that is, one-parameter functions that can be\n   * compile-time constant function values.\n   * It is not allowed to pass the value of function expressions or an instance\n   * method extracted from an object.\n   *\n   * The entry-point function is invoked with the initial [message].\n   * Usually the initial [message] contains a [SendPort] so\n   * that the spawner and spawnee can communicate with each other.\n   *\n   * Returns a future that will complete with an [Isolate] instance if the\n   * spawning succeeded. It will complete with an error otherwise.\n   */\n  external static Future<Isolate> spawn(void entryPoint(message), var message,\n                                        { bool paused: false });\n\n  /**\n   * Creates and spawns an isolate that runs the code from the library with\n   * the specified URI.\n   *\n   * The isolate starts executing the top-level `main` function of the library\n   * with the given URI.\n   *\n   * The target `main` must be a subtype of one of these three signatures:\n   *\n   * * `main()`\n   * * `main(args)`\n   * * `main(args, message)`\n   *\n   * When present, the parameter `args` is set to the provided [args] list.\n   * When present, the parameter `message` is set to the initial [message].\n   *\n   * Returns a future that will complete with an [Isolate] instance if the\n   * spawning succeeded. It will complete with an error otherwise.\n   */\n  external static Future<Isolate> spawnUri(\n      Uri uri, List<String> args, var message, { bool paused: false });\n\n  /**\n   * Requests the isolate to pause.\n   *\n   * WARNING: This method is experimental and not handled on every platform yet.\n   *\n   * The isolate should stop handling events by pausing its event queue.\n   * The request will eventually make the isolate stop doing anything.\n   * It will be handled before any other messages that are later sent to the\n   * isolate from the current isolate, but no other guarantees are provided.\n   *\n   * The event loop may be paused before previously sent, but not yet exeuted,\n   * messages have been reached.\n   *\n   * If [resumeCapability] is provided, it is used to identity the pause,\n   * and must be used again to end the pause using [resume].\n   * Otherwise a new resume capability is created and returned.\n   *\n   * If an isolate is paused more than once using the same capability,\n   * only one resume with that capability is needed to end the pause.\n   *\n   * If an isolate is paused using more than one capability,\n   * they must all be individully ended before the isolate resumes.\n   *\n   * Returns the capability that must be used to resume end the pause.\n   */\n  Capability pause([Capability resumeCapability]) {\n    if (resumeCapability == null) resumeCapability = new Capability();\n    _pause(resumeCapability);\n    return resumeCapability;\n  }\n\n  /** Internal implementation of [pause]. */\n  external void _pause(Capability resumeCapability);\n\n  /**\n   * Resumes a paused isolate.\n   *\n   * WARNING: This method is experimental and not handled on every platform yet.\n   *\n   * Sends a message to an isolate requesting that it ends a pause\n   * that was requested using the [resumeCapability].\n   *\n   * When all active pause requests have been cancelled, the isolate\n   * will continue handling normal messages.\n   *\n   * The capability must be one returned by a call to [pause] on this\n   * isolate, otherwise the resume call does nothing.\n   */\n  external void resume(Capability resumeCapability);\n\n  /**\n   * Asks the isolate to send a message on [responsePort] when it terminates.\n   *\n   * WARNING: This method is experimental and not handled on every platform yet.\n   *\n   * The isolate will send a `null` message on [responsePort] as the last\n   * thing before it terminates. It will run no further code after the message\n   * has been sent.\n   *\n   * If the isolate is already dead, no message will be sent.\n   */\n  /* TODO(lrn): Can we do better? Can the system recognize this message and\n   * send a reply if the receiving isolate is dead?\n   */\n  external void addOnExitListener(SendPort responsePort);\n\n  /**\n   * Stop listening on exit messages from the isolate.\n   *\n   * WARNING: This method is experimental and not handled on every platform yet.\n   *\n   * If a call has previously been made to [addOnExitListener] with the same\n   * send-port, this will unregister the port, and it will no longer receive\n   * a message when the isolate terminates.\n   * A response may still be sent until this operation is fully processed by\n   * the isolate.\n   */\n  external void removeOnExitListener(SendPort responsePort);\n\n  /**\n   * Set whether uncaught errors will terminate the isolate.\n   *\n   * WARNING: This method is experimental and not handled on every platform yet.\n   *\n   * If errors are fatal, any uncaught error will terminate the isolate\n   * event loop and shut down the isolate.\n   *\n   * This call requires the [terminateCapability] for the isolate.\n   * If the capability is not correct, no change is made.\n   */\n  external void setErrorsFatal(bool errorsAreFatal);\n\n  /**\n   * Requests the isolate to shut down.\n   *\n   * WARNING: This method is experimental and not handled on every platform yet.\n   *\n   * The isolate is requested to terminate itself.\n   * The [priority] argument specifies when this must happen.\n   *\n   * The [priority] must be one of [IMMEDIATE], [BEFORE_NEXT_EVENT] or\n   * [AS_EVENT].\n   * The shutdown is performed at different times depending on the priority:\n   *\n   * * `IMMEDIATE`: The the isolate shuts down as soon as possible.\n   *     Control messages are handled in order, so all previously sent control\n   *     events from this isolate will all have been processed.\n   *     The shutdown should happen no later than if sent with\n   *     `BEFORE_NEXT_EVENT`.\n   *     It may happen earlier if the system has a way to shut down cleanly\n   *     at an earlier time, even during the execution of another event.\n   * * `BEFORE_NEXT_EVENT`: The shutdown is scheduled for the next time\n   *     control returns to the event loop of the receiving isolate.\n   *     If more than one such event are scheduled, they are executed in\n   *     the order their control messages were received.\n   * * `AS_EVENT`: The shutdown does not happen until all prevously sent\n   *     non-control messages from the current isolate to the receiving isolate\n   *     have been processed.\n   *     The kill operation effectively puts the shutdown into the normal event\n   *     queue after previously sent messages, and it is affected by any control\n   *     messages that affect normal events, including `pause`.\n   *     This can be used to wait for a another event to be processed.\n   */\n  external void kill([int priority = BEFORE_NEXT_EVENT]);\n\n  /**\n   * Request that the isolate send a response on the [responsePort].\n   *\n   * WARNING: This method is experimental and not handled on every platform yet.\n   *\n   * If the isolate is alive, it will eventually send a `null` response on\n   * the response port.\n   *\n   * The [pingType] must be one of [IMMEDIATE], [BEFORE_NEXT_EVENT] or\n   * [AS_EVENT].\n   * The response is sent at different times depending on the ping type:\n   *\n   * * `IMMEDIATE`: The the isolate responds as soon as it receives the\n   *     control message.\n   * * `BEFORE_NEXT_EVENT`: The response is scheduled for the next time\n   *     control returns to the event loop of the receiving isolate.\n   *     If more than one such event are scheduled, they are executed in\n   *     the order their control messages were received.\n   * * `AS_EVENT`: The response is not sent until all prevously sent\n   *     non-control messages from the current isolate to the receiving isolate\n   *     have been processed.\n   *     The ping effectively puts the response into the normal event queue\n   *     after previously sent messages, and it is affected by any control\n   *     messages that affect normal events, including `pause`.\n   *     This can be used to wait for a another event to be processed.\n   */\n  external void ping(SendPort responsePort, [int pingType = IMMEDIATE]);\n\n  /**\n   * Requests that uncaught errors of the isolate are sent back to [port].\n   *\n   * WARNING: This method is experimental and not handled on every platform yet.\n   *\n   * The errors are sent back as two elements lists.\n   * The first element is a `String` representation of the error, usually\n   * created by calling `toString` on the error.\n   * The second element is a `String` representation of an accompanying\n   * stack trace, or `null` if no stack trace was provided.\n   *\n   * Listening using the same port more than once does nothing. It will only\n   * get each error once.\n   */\n  external void addErrorListener(SendPort port);\n\n  /**\n   * Stop listening for uncaught errors through [port].\n   *\n   * WARNING: This method is experimental and not handled on every platform yet.\n   *\n   * The `port` should be a port that is listening for errors through\n   * [addErrorListener]. This call requests that the isolate stops sending\n   * errors on the port.\n   *\n   * If the same port has been passed via `addErrorListener` more than once,\n   * only one call to `removeErrorListener` is needed to stop it from receiving\n   * errors.\n   *\n   * Closing the receive port at the end of the send port will not stop the\n   * isolate from sending errors, they are just going to be lost.\n   */\n  external void removeErrorListener(SendPort port);\n\n  /**\n   * Returns a broadcast stream of uncaught errors from the isolate.\n   *\n   * Each error is provided as an error event on the stream.\n   *\n   * The actual error object and stackTraces will not necessarily\n   * be the same object types as in the actual isolate, but they will\n   * always have the same [Object.toString] result.\n   *\n   * This stream is based on [addErrorListener] and [removeErrorListener].\n   */\n  Stream get errors {\n    StreamController controller;\n    RawReceivePort port;\n    void handleError(message) {\n      String errorDescription = message[0];\n      String stackDescription = message[1];\n      var error = new RemoteError(errorDescription, stackDescription);\n      controller.addError(error, error.stackTrace);\n    }\n    controller = new StreamController.broadcast(\n        sync: true,\n        onListen: () {\n          port = new RawReceivePort(handleError);\n          this.addErrorListener(port.sendPort);\n        },\n        onCancel: () {\n          this.removeErrorListener(port.sendPort);\n          port.close();\n          port = null;\n        });\n    return controller.stream;\n  }\n}\n\n/**\n * Sends messages to its [ReceivePort]s.\n *\n * [SendPort]s are created from [ReceivePort]s. Any message sent through\n * a [SendPort] is delivered to its corresponding [ReceivePort]. There might be\n * many [SendPort]s for the same [ReceivePort].\n *\n * [SendPort]s can be transmitted to other isolates, and they preserve equality\n * when sent.\n */\nabstract class SendPort implements Capability {\n\n  /**\n   * Sends an asynchronous [message] through this send port, to its\n   * corresponding `ReceivePort`.\n   *\n   * The content of [message] can be: primitive values (null, num, bool, double,\n   * String), instances of [SendPort], and lists and maps whose elements are any\n   * of these. List and maps are also allowed to be cyclic.\n   *\n   * In the special circumstances when two isolates share the same code and are\n   * running in the same process (e.g. isolates created via [Isolate.spawn]), it\n   * is also possible to send object instances (which would be copied in the\n   * process). This is currently only supported by the dartvm.  For now, the\n   * dart2js compiler only supports the restricted messages described above.\n   */\n  void send(var message);\n\n  /**\n   * Tests whether [other] is a [SendPort] pointing to the same\n   * [ReceivePort] as this one.\n   */\n  bool operator==(var other);\n\n  /**\n   * Returns an immutable hash code for this send port that is\n   * consistent with the == operator.\n   */\n  int get hashCode;\n}\n\n/**\n * Together with [SendPort], the only means of communication between isolates.\n *\n * [ReceivePort]s have a `sendPort` getter which returns a [SendPort].\n * Any message that is sent through this [SendPort]\n * is delivered to the [ReceivePort] it has been created from. There, the\n * message is dispatched to the `ReceivePort`'s listener.\n *\n * A [ReceivePort] is a non-broadcast stream. This means that it buffers\n * incoming messages until a listener is registered. Only one listener can\n * receive messages. See [Stream.asBroadcastStream] for transforming the port\n * to a broadcast stream.\n *\n * A [ReceivePort] may have many [SendPort]s.\n */\nabstract class ReceivePort implements Stream {\n\n  /**\n   * Opens a long-lived port for receiving messages.\n   *\n   * A [ReceivePort] is a non-broadcast stream. This means that it buffers\n   * incoming messages until a listener is registered. Only one listener can\n   * receive messages. See [Stream.asBroadcastStream] for transforming the port\n   * to a broadcast stream.\n   *\n   * A receive port is closed by canceling its subscription.\n   */\n  external factory ReceivePort();\n\n  /**\n   * Creates a [ReceivePort] from a [RawReceivePort].\n   *\n   * The handler of the given [rawPort] is overwritten during the construction\n   * of the result.\n   */\n  external factory ReceivePort.fromRawReceivePort(RawReceivePort rawPort);\n\n  /**\n   * Inherited from [Stream].\n   *\n   * Note that [onError] and [cancelOnError] are ignored since a ReceivePort\n   * will never receive an error.\n   *\n   * The [onDone] handler will be called when the stream closes.\n   * The stream closes when [close] is called.\n   */\n  StreamSubscription listen(void onData(var message),\n                            { Function onError,\n                              void onDone(),\n                              bool cancelOnError });\n\n  /**\n   * Closes `this`.\n   *\n   * If the stream has not been canceled yet, adds a close-event to the event\n   * queue and discards any further incoming messages.\n   *\n   * If the stream has already been canceled this method has no effect.\n   */\n  void close();\n\n  /**\n   * Returns a [SendPort] that sends to this receive port.\n   */\n  SendPort get sendPort;\n}\n\nabstract class RawReceivePort {\n  /**\n   * Opens a long-lived port for receiving messages.\n   *\n   * A [RawReceivePort] is low level and does not work with [Zone]s. It\n   * can not be paused. The data-handler must be set before the first\n   * event is received.\n   */\n  external factory RawReceivePort([void handler(event)]);\n\n  /**\n   * Sets the handler that is invoked for every incoming message.\n   *\n   * The handler is invoked in the root-zone ([Zone.ROOT]).\n   */\n  void set handler(Function newHandler);\n\n  /**\n   * Closes the port.\n   *\n   * After a call to this method any incoming message is silently dropped.\n   */\n  void close();\n\n  /**\n   * Returns a [SendPort] that sends to this raw receive port.\n   */\n  SendPort get sendPort;\n}\n\n/**\n * Wraps unhandled exceptions thrown during isolate execution. It is\n * used to show both the error message and the stack trace for unhandled\n * exceptions.\n */\n// TODO(floitsch): probably going to remove and replace with something else.\nclass _IsolateUnhandledException implements Exception {\n  /** Message being handled when exception occurred. */\n  final message;\n\n  /** Wrapped exception. */\n  final source;\n\n  /** Trace for the wrapped exception. */\n  final StackTrace stackTrace;\n\n  const _IsolateUnhandledException(this.message, this.source, this.stackTrace);\n\n  String toString() {\n    return 'IsolateUnhandledException: exception while handling message: '\n        '${message} \\n  '\n        '${source.toString().replaceAll(\"\\n\", \"\\n  \")}\\n'\n        'original stack trace:\\n  '\n        '${stackTrace.toString().replaceAll(\"\\n\",\"\\n  \")}';\n  }\n}\n\n/**\n * Description of an error from another isolate.\n *\n * This error has the same `toString()` and `stackTrace.toString()` behavior\n * as the original error, but has no other features of the original error.\n */\nclass RemoteError implements Error {\n  final String _description;\n  final StackTrace stackTrace;\n  RemoteError(String description, String stackDescription)\n      : _description = description,\n        stackTrace = new _RemoteStackTrace(stackDescription);\n  String toString() => _description;\n}\n\nclass _RemoteStackTrace implements StackTrace {\n  String _trace;\n  _RemoteStackTrace(this._trace);\n  String toString() => _trace;\n}\n\u0000","sdk:/sdk/lib/_internal/lib/js_string.dart":"// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\npart of _interceptors;\n\n/**\n * The interceptor class for [String]. The compiler recognizes this\n * class as an interceptor, and changes references to [:this:] to\n * actually use the receiver of the method, which is generated as an extra\n * argument added to each member.\n */\nclass JSString extends Interceptor implements String, JSIndexable {\n  const JSString();\n\n  int codeUnitAt(int index) {\n    if (index is !int) throw new ArgumentError(index);\n    if (index < 0) throw new RangeError.value(index);\n    if (index >= length) throw new RangeError.value(index);\n    return JS('JSUInt31', r'#.charCodeAt(#)', this, index);\n  }\n\n  Iterable<Match> allMatches(String string, [int start = 0]) {\n    checkString(string);\n    checkInt(start);\n    if (0 > start || start > string.length) {\n      throw new RangeError.range(start, 0, string.length);\n    }\n    return allMatchesInStringUnchecked(this, string, start);\n  }\n\n  Match matchAsPrefix(String string, [int start = 0]) {\n    if (start < 0 || start > string.length) {\n      throw new RangeError.range(start, 0, string.length);\n    }\n    if (start + this.length > string.length) return null;\n    // TODO(lrn): See if this can be optimized.\n    for (int i = 0; i < this.length; i++) {\n      if (string.codeUnitAt(start + i) != this.codeUnitAt(i)) {\n        return null;\n      }\n    }\n    return new StringMatch(start, string, this);\n  }\n\n  String operator +(String other) {\n    if (other is !String) throw new ArgumentError(other);\n    return JS('String', r'# + #', this, other);\n  }\n\n  bool endsWith(String other) {\n    checkString(other);\n    int otherLength = other.length;\n    if (otherLength > length) return false;\n    return other == substring(length - otherLength);\n  }\n\n  String replaceAll(Pattern from, String to) {\n    checkString(to);\n    return stringReplaceAllUnchecked(this, from, to);\n  }\n\n  String replaceAllMapped(Pattern from, String convert(Match match)) {\n    return this.splitMapJoin(from, onMatch: convert);\n  }\n\n  String splitMapJoin(Pattern from,\n                      {String onMatch(Match match),\n                       String onNonMatch(String nonMatch)}) {\n    return stringReplaceAllFuncUnchecked(this, from, onMatch, onNonMatch);\n  }\n\n  String replaceFirst(Pattern from, String to) {\n    checkString(to);\n    return stringReplaceFirstUnchecked(this, from, to);\n  }\n\n  List<String> split(Pattern pattern) {\n    checkNull(pattern);\n    if (pattern is String) {\n      return JS('JSExtendableArray', r'#.split(#)', this, pattern);\n    } else if (pattern is JSSyntaxRegExp) {\n      var re = regExpGetNative(pattern);\n      return JS('JSExtendableArray', r'#.split(#)', this, re);\n    } else {\n      throw \"String.split(Pattern) UNIMPLEMENTED\";\n    }\n  }\n\n  bool startsWith(Pattern pattern, [int index = 0]) {\n    checkInt(index);\n    if (index < 0 || index > this.length) {\n      throw new RangeError.range(index, 0, this.length);\n    }\n    if (pattern is String) {\n      String other = pattern;\n      int otherLength = other.length;\n      int endIndex = index + otherLength;\n      if (endIndex > length) return false;\n      return other == JS('String', r'#.substring(#, #)', this, index, endIndex);\n    }\n    return pattern.matchAsPrefix(this, index) != null;\n  }\n\n  String substring(int startIndex, [int endIndex]) {\n    checkInt(startIndex);\n    if (endIndex == null) endIndex = length;\n    checkInt(endIndex);\n    if (startIndex < 0 ) throw new RangeError.value(startIndex);\n    if (startIndex > endIndex) throw new RangeError.value(startIndex);\n    if (endIndex > length) throw new RangeError.value(endIndex);\n    return JS('String', r'#.substring(#, #)', this, startIndex, endIndex);\n  }\n\n  String toLowerCase() {\n    return JS('String', r'#.toLowerCase()', this);\n  }\n\n  String toUpperCase() {\n    return JS('String', r'#.toUpperCase()', this);\n  }\n\n  // Characters with Whitespace property (Unicode 6.2).\n  // 0009..000D    ; White_Space # Cc       <control-0009>..<control-000D>\n  // 0020          ; White_Space # Zs       SPACE\n  // 0085          ; White_Space # Cc       <control-0085>\n  // 00A0          ; White_Space # Zs       NO-BREAK SPACE\n  // 1680          ; White_Space # Zs       OGHAM SPACE MARK\n  // 180E          ; White_Space # Zs       MONGOLIAN VOWEL SEPARATOR\n  // 2000..200A    ; White_Space # Zs       EN QUAD..HAIR SPACE\n  // 2028          ; White_Space # Zl       LINE SEPARATOR\n  // 2029          ; White_Space # Zp       PARAGRAPH SEPARATOR\n  // 202F          ; White_Space # Zs       NARROW NO-BREAK SPACE\n  // 205F          ; White_Space # Zs       MEDIUM MATHEMATICAL SPACE\n  // 3000          ; White_Space # Zs       IDEOGRAPHIC SPACE\n  //\n  // BOM: 0xFEFF\n  static bool _isWhitespace(int codeUnit) {\n    // Most codeUnits should be less than 256. Special case with a smaller\n    // switch.\n    if (codeUnit < 256) {\n      switch (codeUnit) {\n        case 0x09:\n        case 0x0A:\n        case 0x0B:\n        case 0x0C:\n        case 0x0D:\n        case 0x20:\n        case 0x85:\n        case 0xA0:\n          return true;\n        default:\n          return false;\n      }\n    }\n    switch (codeUnit) {\n      case 0x1680:\n      case 0x180E:\n      case 0x2000:\n      case 0x2001:\n      case 0x2002:\n      case 0x2003:\n      case 0x2004:\n      case 0x2005:\n      case 0x2006:\n      case 0x2007:\n      case 0x2008:\n      case 0x2009:\n      case 0x200A:\n      case 0x2028:\n      case 0x2029:\n      case 0x202F:\n      case 0x205F:\n      case 0x3000:\n      case 0xFEFF:\n        return true;\n      default:\n        return false;\n    }\n  }\n\n  /// Finds the index of the first non-whitespace character, or the\n  /// end of the string. Start looking at position [index].\n  static int _skipLeadingWhitespace(String string, int index) {\n    const int SPACE = 0x20;\n    const int CARRIAGE_RETURN = 0x0D;\n    while (index < string.length) {\n      int codeUnit = string.codeUnitAt(index);\n      if (codeUnit != SPACE &&\n          codeUnit != CARRIAGE_RETURN &&\n          !_isWhitespace(codeUnit)) {\n        break;\n      }\n      index++;\n    }\n    return index;\n  }\n\n  /// Finds the index after the the last non-whitespace character, or 0.\n  /// Start looking at position [index - 1].\n  static int _skipTrailingWhitespace(String string, int index) {\n    const int SPACE = 0x20;\n    const int CARRIAGE_RETURN = 0x0D;\n    while (index > 0) {\n      int codeUnit = string.codeUnitAt(index - 1);\n      if (codeUnit != SPACE &&\n          codeUnit != CARRIAGE_RETURN &&\n          !_isWhitespace(codeUnit)) {\n        break;\n      }\n      index--;\n    }\n    return index;\n  }\n\n  // Dart2js can't use JavaScript trim directly,\n  // because JavaScript does not trim\n  // the NEXT LINE (NEL) character (0x85).\n  String trim() {\n    const int NEL = 0x85;\n\n    // Start by doing JS trim. Then check if it leaves a NEL at\n    // either end of the string.\n    String result = JS('String', '#.trim()', this);\n    if (result.length == 0) return result;\n    int firstCode = result.codeUnitAt(0);\n    int startIndex = 0;\n    if (firstCode == NEL) {\n      startIndex = _skipLeadingWhitespace(result, 1);\n      if (startIndex == result.length) return \"\";\n    }\n\n    int endIndex = result.length;\n    // We know that there is at least one character that is non-whitespace.\n    // Therefore we don't need to verify that endIndex > startIndex.\n    int lastCode = result.codeUnitAt(endIndex - 1);\n    if (lastCode == NEL) {\n      endIndex = _skipTrailingWhitespace(result, endIndex - 1);\n    }\n    if (startIndex == 0 && endIndex == result.length) return result;\n    return JS('String', r'#.substring(#, #)', result, startIndex, endIndex);\n  }\n\n  // Dart2js can't use JavaScript trimLeft directly,\n  // because it is not in ES5, so not every browser implements it,\n  // and because those that do will not trim the NEXT LINE character (0x85).\n  String trimLeft() {\n    const int NEL = 0x85;\n\n    // Start by doing JS trim. Then check if it leaves a NEL at\n    // the beginning of the string.\n    String result;\n    int startIndex = 0;\n    if (JS('bool', 'typeof #.trimLeft != \"undefined\"', this)) {\n      result = JS('String', '#.trimLeft()', this);\n      if (result.length == 0) return result;\n      int firstCode = result.codeUnitAt(0);\n      if (firstCode == NEL) {\n        startIndex = _skipLeadingWhitespace(result, 1);\n      }\n    } else {\n      result = this;\n      startIndex = _skipLeadingWhitespace(this, 0);\n    }\n    if (startIndex == 0) return result;\n    if (startIndex == result.length) return \"\";\n    return JS('String', r'#.substring(#)', result, startIndex);\n  }\n\n  // Dart2js can't use JavaScript trimRight directly,\n  // because it is not in ES5 and because JavaScript does not trim\n  // the NEXT LINE character (0x85).\n  String trimRight() {\n    const int NEL = 0x85;\n\n    // Start by doing JS trim. Then check if it leaves a NEL or BOM at\n    // the end of the string.\n    String result;\n    int endIndex;\n    // trimRight is implemented by Firefox and Chrome/Blink,\n    // so use it if it is there.\n    if (JS('bool', 'typeof #.trimRight != \"undefined\"', this)) {\n      result = JS('String', '#.trimRight()', this);\n      endIndex = result.length;\n      if (endIndex == 0) return result;\n      int lastCode = result.codeUnitAt(endIndex - 1);\n      if (lastCode == NEL) {\n        endIndex = _skipTrailingWhitespace(result, endIndex - 1);\n      }\n    } else {\n      result = this;\n      endIndex = _skipTrailingWhitespace(this, this.length);\n    }\n\n    if (endIndex == result.length) return result;\n    if (endIndex == 0) return \"\";\n    return JS('String', r'#.substring(#, #)', result, 0, endIndex);\n  }\n\n  String operator*(int times) {\n    if (0 >= times) return '';  // Unnecessary but hoists argument type check.\n    if (times == 1 || this.length == 0) return this;\n    if (times != JS('JSUInt32', '# >>> 0', times)) {\n      // times >= 2^32. We can't create a string that big.\n      throw const OutOfMemoryError();\n    }\n    var result = '';\n    var s = this;\n    while (true) {\n      if (times & 1 == 1) result = s + result;\n      times = JS('JSUInt31', '# >>> 1', times);\n      if (times == 0) break;\n      s += s;\n    }\n    return result;\n  }\n\n  String padLeft(int width, [String padding = ' ']) {\n    int delta = width - this.length;\n    if (delta <= 0) return this;\n    return padding * delta + this;\n  }\n\n  String padRight(int width, [String padding = ' ']) {\n    int delta = width - this.length;\n    if (delta <= 0) return this;\n    return this + padding * delta;\n  }\n\n  List<int> get codeUnits => new _CodeUnits(this);\n\n  Runes get runes => new Runes(this);\n\n  int indexOf(Pattern pattern, [int start = 0]) {\n    checkNull(pattern);\n    if (start is! int) throw new ArgumentError(start);\n    if (start < 0 || start > this.length) {\n      throw new RangeError.range(start, 0, this.length);\n    }\n    if (pattern is String) {\n      return JS('int', r'#.indexOf(#, #)', this, pattern, start);\n    }\n    if (pattern is JSSyntaxRegExp) {\n      JSSyntaxRegExp re = pattern;\n      Match match = firstMatchAfter(re, this, start);\n      return (match == null) ? -1 : match.start;\n    }\n    for (int i = start; i <= this.length; i++) {\n      if (pattern.matchAsPrefix(this, i) != null) return i;\n    }\n    return -1;\n  }\n\n  int lastIndexOf(Pattern pattern, [int start]) {\n    checkNull(pattern);\n    if (start == null) {\n      start = length;\n    } else if (start is! int) {\n      throw new ArgumentError(start);\n    } else if (start < 0 || start > this.length) {\n      throw new RangeError.range(start, 0, this.length);\n    }\n    if (pattern is String) {\n      String other = pattern;\n      if (start + other.length > this.length) {\n        start = this.length - other.length;\n      }\n      return stringLastIndexOfUnchecked(this, other, start);\n    }\n    for (int i = start; i >= 0; i--) {\n      if (pattern.matchAsPrefix(this, i) != null) return i;\n    }\n    return -1;\n  }\n\n  bool contains(Pattern other, [int startIndex = 0]) {\n    checkNull(other);\n    if (startIndex < 0 || startIndex > this.length) {\n      throw new RangeError.range(startIndex, 0, this.length);\n    }\n    return stringContainsUnchecked(this, other, startIndex);\n  }\n\n  bool get isEmpty => length == 0;\n\n  bool get isNotEmpty => !isEmpty;\n\n  int compareTo(String other) {\n    if (other is !String) throw new ArgumentError(other);\n    return this == other ? 0\n      : JS('bool', r'# < #', this, other) ? -1 : 1;\n  }\n\n  // Note: if you change this, also change the function [S].\n  String toString() => this;\n\n  /**\n   * This is the [Jenkins hash function][1] but using masking to keep\n   * values in SMI range.\n   *\n   * [1]: http://en.wikipedia.org/wiki/Jenkins_hash_function\n   */\n  int get hashCode {\n    // TODO(ahe): This method shouldn't have to use JS. Update when our\n    // optimizations are smarter.\n    int hash = 0;\n    for (int i = 0; i < length; i++) {\n      hash = 0x1fffffff & (hash + JS('int', r'#.charCodeAt(#)', this, i));\n      hash = 0x1fffffff & (hash + ((0x0007ffff & hash) << 10));\n      hash = JS('int', '# ^ (# >> 6)', hash, hash);\n    }\n    hash = 0x1fffffff & (hash + ((0x03ffffff & hash) <<  3));\n    hash = JS('int', '# ^ (# >> 11)', hash, hash);\n    return 0x1fffffff & (hash + ((0x00003fff & hash) << 15));\n  }\n\n  Type get runtimeType => String;\n\n  int get length => JS('int', r'#.length', this);\n\n  String operator [](int index) {\n    if (index is !int) throw new ArgumentError(index);\n    if (index >= length || index < 0) throw new RangeError.value(index);\n    return JS('String', '#[#]', this, index);\n  }\n}\n\n/**\n * An [Iterable] of the UTF-16 code units of a [String] in index order.\n */\nclass _CodeUnits extends UnmodifiableListBase<int> {\n  /** The string that this is the code units of. */\n  String _string;\n\n  _CodeUnits(this._string);\n\n  int get length => _string.length;\n  int operator[](int i) => _string.codeUnitAt(i);\n}\n\u0000","sdk:/sdk/lib/_internal/lib/js_number.dart":"// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\npart of _interceptors;\n\n/**\n * The super interceptor class for [JSInt] and [JSDouble]. The compiler\n * recognizes this class as an interceptor, and changes references to\n * [:this:] to actually use the receiver of the method, which is\n * generated as an extra argument added to each member.\n *\n * Note that none of the methods here delegate to a method defined on JSInt or\n * JSDouble.  This is exploited in [tryComputeConstantInterceptor].\n */\nclass JSNumber extends Interceptor implements num {\n  const JSNumber();\n\n  int compareTo(num b) {\n    if (b is! num) throw new ArgumentError(b);\n    if (this < b) {\n      return -1;\n    } else if (this > b) {\n      return 1;\n    } else if (this == b) {\n      if (this == 0) {\n        bool bIsNegative = b.isNegative;\n        if (isNegative == bIsNegative) return 0;\n        if (isNegative) return -1;\n        return 1;\n      }\n      return 0;\n    } else if (isNaN) {\n      if (b.isNaN) {\n        return 0;\n      }\n      return 1;\n    } else {\n      return -1;\n    }\n  }\n\n  bool get isNegative => (this == 0) ? (1 / this) < 0 : this < 0;\n\n  bool get isNaN => JS('bool', r'isNaN(#)', this);\n\n  bool get isInfinite {\n    return JS('bool', r'# == Infinity', this)\n        || JS('bool', r'# == -Infinity', this);\n  }\n\n  bool get isFinite => JS('bool', r'isFinite(#)', this);\n\n  num remainder(num b) {\n    checkNull(b); // TODO(ngeoffray): This is not specified but co19 tests it.\n    if (b is! num) throw new ArgumentError(b);\n    return JS('num', r'# % #', this, b);\n  }\n\n  num abs() => JS('num', r'Math.abs(#)', this);\n\n  num get sign => this > 0 ? 1 : this < 0 ? -1 : this;\n\n  static const int _MIN_INT32 = -0x80000000;\n  static const int _MAX_INT32 = 0x7FFFFFFF;\n\n  int toInt() {\n    if (this >= _MIN_INT32 && this <= _MAX_INT32) {\n      return JS('int', '# | 0', this);\n    }\n    if (JS('bool', r'isFinite(#)', this)) {\n      return JS('int', r'# + 0', truncateToDouble());  // Converts -0.0 to +0.0.\n    }\n    // This is either NaN, Infinity or -Infinity.\n    throw new UnsupportedError(JS(\"String\", \"''+#\", this));\n  }\n\n  int truncate() => toInt();\n  int ceil() => ceilToDouble().toInt();\n  int floor() => floorToDouble().toInt();\n  int round() => roundToDouble().toInt();\n\n  double ceilToDouble() => JS('num', r'Math.ceil(#)', this);\n\n  double floorToDouble() => JS('num', r'Math.floor(#)', this);\n\n  double roundToDouble() {\n    if (this < 0) {\n      return JS('num', r'-Math.round(-#)', this);\n    } else {\n      return JS('num', r'Math.round(#)', this);\n    }\n  }\n\n  double truncateToDouble() => this < 0 ? ceilToDouble() : floorToDouble();\n\n  num clamp(lowerLimit, upperLimit) {\n    if (lowerLimit is! num) throw new ArgumentError(lowerLimit);\n    if (upperLimit is! num) throw new ArgumentError(upperLimit);\n    if (lowerLimit.compareTo(upperLimit) > 0) {\n      throw new ArgumentError(lowerLimit);\n    }\n    if (this.compareTo(lowerLimit) < 0) return lowerLimit;\n    if (this.compareTo(upperLimit) > 0) return upperLimit;\n    return this;\n  }\n\n  // The return type is intentionally omitted to avoid type checker warnings\n  // from assigning JSNumber to double.\n  toDouble() => this;\n\n  String toStringAsFixed(int fractionDigits) {\n    checkNum(fractionDigits);\n    // TODO(floitsch): fractionDigits must be an integer.\n    if (fractionDigits < 0 || fractionDigits > 20) {\n      throw new RangeError(fractionDigits);\n    }\n    String result = JS('String', r'#.toFixed(#)', this, fractionDigits);\n    if (this == 0 && isNegative) return \"-$result\";\n    return result;\n  }\n\n  String toStringAsExponential([int fractionDigits]) {\n    String result;\n    if (fractionDigits != null) {\n      // TODO(floitsch): fractionDigits must be an integer.\n      checkNum(fractionDigits);\n      if (fractionDigits < 0 || fractionDigits > 20) {\n        throw new RangeError(fractionDigits);\n      }\n      result = JS('String', r'#.toExponential(#)', this, fractionDigits);\n    } else {\n      result = JS('String', r'#.toExponential()', this);\n    }\n    if (this == 0 && isNegative) return \"-$result\";\n    return result;\n  }\n\n  String toStringAsPrecision(int precision) {\n    // TODO(floitsch): precision must be an integer.\n    checkNum(precision);\n    if (precision < 1 || precision > 21) {\n      throw new RangeError(precision);\n    }\n    String result = JS('String', r'#.toPrecision(#)',\n                       this, precision);\n    if (this == 0 && isNegative) return \"-$result\";\n    return result;\n  }\n\n  String toRadixString(int radix) {\n    checkNum(radix);\n    if (radix < 2 || radix > 36) throw new RangeError(radix);\n    return JS('String', r'#.toString(#)', this, radix);\n  }\n\n  // Note: if you change this, also change the function [S].\n  String toString() {\n    if (this == 0 && JS('bool', '(1 / #) < 0', this)) {\n      return '-0.0';\n    } else {\n      return JS('String', r'\"\" + (#)', this);\n    }\n  }\n\n  int get hashCode => JS('int', '# & 0x1FFFFFFF', this);\n\n  num operator -() => JS('num', r'-#', this);\n\n  num operator +(num other) {\n    if (other is !num) throw new ArgumentError(other);\n    return JS('num', '# + #', this, other);\n  }\n\n  num operator -(num other) {\n    if (other is !num) throw new ArgumentError(other);\n    return JS('num', '# - #', this, other);\n  }\n\n  num operator /(num other) {\n    if (other is !num) throw new ArgumentError(other);\n    return JS('num', '# / #', this, other);\n  }\n\n  num operator *(num other) {\n    if (other is !num) throw new ArgumentError(other);\n    return JS('num', '# * #', this, other);\n  }\n\n  num operator %(num other) {\n    if (other is !num) throw new ArgumentError(other);\n    // Euclidean Modulo.\n    num result = JS('num', r'# % #', this, other);\n    if (result == 0) return 0;  // Make sure we don't return -0.0.\n    if (result > 0) return result;\n    if (JS('num', '#', other) < 0) {\n      return result - JS('num', '#', other);\n    } else {\n      return result + JS('num', '#', other);\n    }\n  }\n\n  bool _isInt32(value) => JS('bool', '(# | 0) === #', value, value);\n\n  num operator ~/(num other) {\n    if (false) _tdivFast(other); // Ensure resolution.\n    if (_isInt32(this) && _isInt32(other) && 0 != other && -1 != other) {\n      return JS('num', r'(# / #) | 0', this, other);\n    } else {\n      return _tdivSlow(other);\n    }\n  }\n\n  num _tdivFast(num other) {\n    return _isInt32(this)\n        ? JS('num', r'(# / #) | 0', this, other)\n        : (JS('num', r'# / #', this, other)).toInt();\n  }\n\n  num _tdivSlow(num other) {\n    if (other is !num) throw new ArgumentError(other);\n    return (JS('num', r'# / #', this, other)).toInt();\n  }\n\n  // TODO(ngeoffray): Move the bit operations below to [JSInt] and\n  // make them take an int. Because this will make operations slower,\n  // we define these methods on number for now but we need to decide\n  // the grain at which we do the type checks.\n\n  num operator <<(num other) {\n    if (other is !num) throw new ArgumentError(other);\n    if (JS('num', '#', other) < 0) throw new ArgumentError(other);\n    return _shlPositive(other);\n  }\n\n  num _shlPositive(num other) {\n    // JavaScript only looks at the last 5 bits of the shift-amount. Shifting\n    // by 33 is hence equivalent to a shift by 1.\n    return JS('bool', r'# > 31', other)\n        ? 0\n        : JS('JSUInt32', r'(# << #) >>> 0', this, other);\n  }\n\n  num operator >>(num other) {\n    if (false) _shrReceiverPositive(other);\n    if (other is !num) throw new ArgumentError(other);\n    if (JS('num', '#', other) < 0) throw new ArgumentError(other);\n    return _shrOtherPositive(other);\n  }\n\n  num _shrOtherPositive(num other) {\n    return JS('num', '#', this) > 0\n        ? _shrBothPositive(other)\n        // For negative numbers we just clamp the shift-by amount.\n        // `this` could be negative but not have its 31st bit set.\n        // The \">>\" would then shift in 0s instead of 1s. Therefore\n        // we cannot simply return 0xFFFFFFFF.\n        : JS('JSUInt32', r'(# >> #) >>> 0', this, other > 31 ? 31 : other);\n  }\n\n  num _shrReceiverPositive(num other) {\n    if (JS('num', '#', other) < 0) throw new ArgumentError(other);\n    return _shrBothPositive(other);\n  }\n\n  num _shrBothPositive(num other) {\n    return JS('bool', r'# > 31', other)\n        // JavaScript only looks at the last 5 bits of the shift-amount. In JS\n        // shifting by 33 is hence equivalent to a shift by 1. Shortcut the\n        // computation when that happens.\n        ? 0\n        // Given that `this` is positive we must not use '>>'. Otherwise a\n        // number that has the 31st bit set would be treated as negative and\n        // shift in ones.\n        : JS('JSUInt32', r'# >>> #', this, other);\n  }\n\n  num operator &(num other) {\n    if (other is !num) throw new ArgumentError(other);\n    return JS('JSUInt32', r'(# & #) >>> 0', this, other);\n  }\n\n  num operator |(num other) {\n    if (other is !num) throw new ArgumentError(other);\n    return JS('JSUInt32', r'(# | #) >>> 0', this, other);\n  }\n\n  num operator ^(num other) {\n    if (other is !num) throw new ArgumentError(other);\n    return JS('JSUInt32', r'(# ^ #) >>> 0', this, other);\n  }\n\n  bool operator <(num other) {\n    if (other is !num) throw new ArgumentError(other);\n    return JS('bool', '# < #', this, other);\n  }\n\n  bool operator >(num other) {\n    if (other is !num) throw new ArgumentError(other);\n    return JS('bool', '# > #', this, other);\n  }\n\n  bool operator <=(num other) {\n    if (other is !num) throw new ArgumentError(other);\n    return JS('bool', '# <= #', this, other);\n  }\n\n  bool operator >=(num other) {\n    if (other is !num) throw new ArgumentError(other);\n    return JS('bool', '# >= #', this, other);\n  }\n\n  Type get runtimeType => num;\n}\n\n/**\n * The interceptor class for [int]s.\n *\n * This class implements double since in JavaScript all numbers are doubles, so\n * while we want to treat `2.0` as an integer for some operations, its\n * interceptor should answer `true` to `is double`.\n */\nclass JSInt extends JSNumber implements int, double {\n  const JSInt();\n\n  bool get isEven => (this & 1) == 0;\n\n  bool get isOdd => (this & 1) == 1;\n\n  int toUnsigned(int width) {\n    return this & ((1 << width) - 1);\n  }\n\n  int toSigned(int width) {\n    int signMask = 1 << (width - 1);\n    return (this & (signMask - 1)) - (this & signMask);\n  }\n\n  int get bitLength {\n    int nonneg = this < 0 ? -this - 1 : this;\n    if (nonneg >= 0x100000000) {\n      nonneg = nonneg ~/ 0x100000000;\n      return _bitCount(_spread(nonneg)) + 32;\n    }\n    return _bitCount(_spread(nonneg));\n  }\n\n  // Assumes i is <= 32-bit and unsigned.\n  static int _bitCount(int i) {\n    // See \"Hacker's Delight\", section 5-1, \"Counting 1-Bits\".\n\n    // The basic strategy is to use \"divide and conquer\" to\n    // add pairs (then quads, etc.) of bits together to obtain\n    // sub-counts.\n    //\n    // A straightforward approach would look like:\n    //\n    // i = (i & 0x55555555) + ((i >>  1) & 0x55555555);\n    // i = (i & 0x33333333) + ((i >>  2) & 0x33333333);\n    // i = (i & 0x0F0F0F0F) + ((i >>  4) & 0x0F0F0F0F);\n    // i = (i & 0x00FF00FF) + ((i >>  8) & 0x00FF00FF);\n    // i = (i & 0x0000FFFF) + ((i >> 16) & 0x0000FFFF);\n    //\n    // The code below removes unnecessary &'s and uses a\n    // trick to remove one instruction in the first line.\n\n    i = _shru(i, 0) - (_shru(i, 1) & 0x55555555);\n    i = (i & 0x33333333) + (_shru(i, 2) & 0x33333333);\n    i = 0x0F0F0F0F & (i + _shru(i, 4));\n    i += _shru(i, 8);\n    i += _shru(i, 16);\n    return (i & 0x0000003F);\n  }\n\n  static _shru(int value, int shift) => JS('int', '# >>> #', value, shift);\n  static _shrs(int value, int shift) => JS('int', '# >> #', value, shift);\n  static _ors(int a, int b) => JS('int', '# | #', a, b);\n\n  // Assumes i is <= 32-bit\n  static int _spread(int i) {\n    i = _ors(i, _shrs(i, 1));\n    i = _ors(i, _shrs(i, 2));\n    i = _ors(i, _shrs(i, 4));\n    i = _ors(i, _shrs(i, 8));\n    i = _shru(_ors(i, _shrs(i, 16)), 0);\n    return i;\n  }\n\n  Type get runtimeType => int;\n\n  int operator ~() => JS('JSUInt32', r'(~#) >>> 0', this);\n}\n\nclass JSDouble extends JSNumber implements double {\n  const JSDouble();\n  Type get runtimeType => double;\n}\n\nclass JSPositiveInt extends JSInt {}\nclass JSUInt32 extends JSPositiveInt {}\nclass JSUInt31 extends JSUInt32 {}\n\u0000","sdk:/sdk/lib/_internal/lib/js_array.dart":"// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\npart of _interceptors;\n\n/**\n * The interceptor class for [List]. The compiler recognizes this\n * class as an interceptor, and changes references to [:this:] to\n * actually use the receiver of the method, which is generated as an extra\n * argument added to each member.\n */\nclass JSArray<E> extends Interceptor implements List<E>, JSIndexable {\n\n  const JSArray();\n\n  /**\n   * Returns a fresh JavaScript Array, marked as fixed-length.\n   *\n   * [length] must be a non-negative integer.\n   */\n  factory JSArray.fixed(int length)  {\n    // Explicit type test is necessary to guard against JavaScript conversions\n    // in unchecked mode.\n    if ((length is !int) || (length < 0)) {\n      throw new ArgumentError(\"Length must be a non-negative integer: $length\");\n    }\n    return new JSArray<E>.markFixed(JS('', 'new Array(#)', length));\n  }\n\n  /**\n   * Returns a fresh growable JavaScript Array of zero length length.\n   */\n  factory JSArray.emptyGrowable() => new JSArray<E>.markGrowable(JS('', '[]'));\n\n  /**\n   * Returns a fresh growable JavaScript Array with initial length.\n   *\n   * [validatedLength] must be a non-negative integer.\n   */\n  factory JSArray.growable(int length) {\n    // Explicit type test is necessary to guard against JavaScript conversions\n    // in unchecked mode.\n    if ((length is !int) || (length < 0)) {\n      throw new ArgumentError(\"Length must be a non-negative integer: $length\");\n    }\n    return new JSArray<E>.markGrowable(JS('', 'new Array(#)', length));\n  }\n\n  /**\n   * Constructor for adding type parameters to an existing JavaScript Array.\n   * The compiler specially recognizes this constructor.\n   *\n   *     var a = new JSArray<int>.typed(JS('JSExtendableArray', '[]'));\n   *     a is List<int>    --> true\n   *     a is List<String> --> false\n   *\n   * Usually either the [JSArray.markFixed] or [JSArray.markGrowable]\n   * constructors is used instead.\n   *\n   * The input must be a JavaScript Array.  The JS form is just a re-assertion\n   * to help type analysis when the input type is sloppy.\n   */\n  factory JSArray.typed(allocation) => JS('JSArray', '#', allocation);\n\n  factory JSArray.markFixed(allocation) =>\n      JS('JSFixedArray', '#', markFixedList(new JSArray<E>.typed(allocation)));\n\n  factory JSArray.markGrowable(allocation) =>\n      JS('JSExtendableArray', '#', new JSArray<E>.typed(allocation));\n\n  static List markFixedList(List list) {\n    JS('void', r'#.fixed$length = init', list);\n    return JS('JSFixedArray', '#', list);\n  }\n\n  checkMutable(reason) {\n    if (this is !JSMutableArray) {\n      throw new UnsupportedError(reason);\n    }\n  }\n\n  checkGrowable(reason) {\n    if (this is !JSExtendableArray) {\n      throw new UnsupportedError(reason);\n    }\n  }\n\n  void add(E value) {\n    checkGrowable('add');\n    JS('void', r'#.push(#)', this, value);\n  }\n\n  E removeAt(int index) {\n    if (index is !int) throw new ArgumentError(index);\n    if (index < 0 || index >= length) {\n      throw new RangeError.value(index);\n    }\n    checkGrowable('removeAt');\n    return JS('var', r'#.splice(#, 1)[0]', this, index);\n  }\n\n  void insert(int index, E value) {\n    if (index is !int) throw new ArgumentError(index);\n    if (index < 0 || index > length) {\n      throw new RangeError.value(index);\n    }\n    checkGrowable('insert');\n    JS('void', r'#.splice(#, 0, #)', this, index, value);\n  }\n\n  void insertAll(int index, Iterable<E> iterable) {\n    checkGrowable('insertAll');\n    IterableMixinWorkaround.insertAllList(this, index, iterable);\n  }\n\n  void setAll(int index, Iterable<E> iterable) {\n    checkMutable('setAll');\n    IterableMixinWorkaround.setAllList(this, index, iterable);\n  }\n\n  E removeLast() {\n    checkGrowable('removeLast');\n    if (length == 0) throw new RangeError.value(-1);\n    return JS('var', r'#.pop()', this);\n  }\n\n  bool remove(Object element) {\n    checkGrowable('remove');\n    for (int i = 0; i < this.length; i++) {\n      if (this[i] == element) {\n        JS('var', r'#.splice(#, 1)', this, i);\n        return true;\n      }\n    }\n    return false;\n  }\n\n  void removeWhere(bool test(E element)) {\n    // This could, and should, be optimized.\n    IterableMixinWorkaround.removeWhereList(this, test);\n  }\n\n  void retainWhere(bool test(E element)) {\n    IterableMixinWorkaround.removeWhereList(this,\n                                            (E element) => !test(element));\n  }\n\n  Iterable<E> where(bool f(E element)) {\n    return new IterableMixinWorkaround<E>().where(this, f);\n  }\n\n  Iterable expand(Iterable f(E element)) {\n    return IterableMixinWorkaround.expand(this, f);\n  }\n\n  void addAll(Iterable<E> collection) {\n    for (E e in collection) {\n      this.add(e);\n    }\n  }\n\n  void clear() {\n    length = 0;\n  }\n\n  void forEach(void f(E element)) {\n    return IterableMixinWorkaround.forEach(this, f);\n  }\n\n  Iterable map(f(E element)) {\n    return IterableMixinWorkaround.mapList(this, f);\n  }\n\n  String join([String separator = \"\"]) {\n    var list = new List(this.length);\n    for (int i = 0; i < this.length; i++) {\n      list[i] = \"${this[i]}\";\n    }\n    return JS('String', \"#.join(#)\", list, separator);\n  }\n\n  Iterable<E> take(int n) {\n    return new IterableMixinWorkaround<E>().takeList(this, n);\n  }\n\n  Iterable<E> takeWhile(bool test(E value)) {\n    return new IterableMixinWorkaround<E>().takeWhile(this, test);\n  }\n\n  Iterable<E> skip(int n) {\n    return new IterableMixinWorkaround<E>().skipList(this, n);\n  }\n\n  Iterable<E> skipWhile(bool test(E value)) {\n    return new IterableMixinWorkaround<E>().skipWhile(this, test);\n  }\n\n  E reduce(E combine(E value, E element)) {\n    return IterableMixinWorkaround.reduce(this, combine);\n  }\n\n  fold(initialValue, combine(previousValue, E element)) {\n    return IterableMixinWorkaround.fold(this, initialValue, combine);\n  }\n\n  dynamic firstWhere(bool test(E value), {Object orElse()}) {\n    return IterableMixinWorkaround.firstWhere(this, test, orElse);\n  }\n\n  dynamic lastWhere(bool test(E value), {Object orElse()}) {\n    return IterableMixinWorkaround.lastWhereList(this, test, orElse);\n  }\n\n  E singleWhere(bool test(E value)) {\n    return IterableMixinWorkaround.singleWhere(this, test);\n  }\n\n  E elementAt(int index) {\n    return this[index];\n  }\n\n  List<E> sublist(int start, [int end]) {\n    checkNull(start); // TODO(ahe): This is not specified but co19 tests it.\n    if (start is !int) throw new ArgumentError(start);\n    if (start < 0 || start > length) {\n      throw new RangeError.range(start, 0, length);\n    }\n    if (end == null) {\n      end = length;\n    } else {\n      if (end is !int) throw new ArgumentError(end);\n      if (end < start || end > length) {\n        throw new RangeError.range(end, start, length);\n      }\n    }\n    if (start == end) return <E>[];\n    return new JSArray<E>.markGrowable(\n        JS('', r'#.slice(#, #)', this, start, end));\n  }\n\n\n  Iterable<E> getRange(int start, int end) {\n    return new IterableMixinWorkaround<E>().getRangeList(this, start, end);\n  }\n\n  E get first {\n    if (length > 0) return this[0];\n    throw new StateError(\"No elements\");\n  }\n\n  E get last {\n    if (length > 0) return this[length - 1];\n    throw new StateError(\"No elements\");\n  }\n\n  E get single {\n    if (length == 1) return this[0];\n    if (length == 0) throw new StateError(\"No elements\");\n    throw new StateError(\"More than one element\");\n  }\n\n  void removeRange(int start, int end) {\n    checkGrowable('removeRange');\n    int receiverLength = this.length;\n    if (start < 0 || start > receiverLength) {\n      throw new RangeError.range(start, 0, receiverLength);\n    }\n    if (end < start || end > receiverLength) {\n      throw new RangeError.range(end, start, receiverLength);\n    }\n    Lists.copy(this,\n               end,\n               this,\n               start,\n               receiverLength - end);\n    this.length = receiverLength - (end - start);\n  }\n\n  void setRange(int start, int end, Iterable<E> iterable, [int skipCount = 0]) {\n    checkMutable('set range');\n    IterableMixinWorkaround.setRangeList(this, start, end, iterable, skipCount);\n  }\n\n  void fillRange(int start, int end, [E fillValue]) {\n    checkMutable('fill range');\n    IterableMixinWorkaround.fillRangeList(this, start, end, fillValue);\n  }\n\n  void replaceRange(int start, int end, Iterable<E> iterable) {\n    checkGrowable('removeRange');\n    IterableMixinWorkaround.replaceRangeList(this, start, end, iterable);\n  }\n\n  bool any(bool f(E element)) => IterableMixinWorkaround.any(this, f);\n\n  bool every(bool f(E element)) => IterableMixinWorkaround.every(this, f);\n\n  Iterable<E> get reversed =>\n      new IterableMixinWorkaround<E>().reversedList(this);\n\n  void sort([int compare(E a, E b)]) {\n    checkMutable('sort');\n    IterableMixinWorkaround.sortList(this, compare);\n  }\n\n  void shuffle([Random random]) {\n    IterableMixinWorkaround.shuffleList(this, random);\n  }\n\n  int indexOf(Object element, [int start = 0]) {\n    return IterableMixinWorkaround.indexOfList(this, element, start);\n  }\n\n  int lastIndexOf(Object element, [int start]) {\n    return IterableMixinWorkaround.lastIndexOfList(this, element, start);\n  }\n\n  bool contains(Object other) {\n    for (int i = 0; i < length; i++) {\n      if (this[i] == other) return true;\n    }\n    return false;\n  }\n\n  bool get isEmpty => length == 0;\n\n  bool get isNotEmpty => !isEmpty;\n\n  String toString() => ListBase.listToString(this);\n\n  List<E> toList({ bool growable: true }) {\n    if (growable) {\n      return new JSArray<E>.markGrowable(JS('', '#.slice()', this));\n    } else {\n      return new JSArray<E>.markFixed(JS('', '#.slice()', this));\n    }\n  }\n\n  Set<E> toSet() => new Set<E>.from(this);\n\n  Iterator<E> get iterator => new ListIterator<E>(this);\n\n  int get hashCode => Primitives.objectHashCode(this);\n\n  int get length => JS('JSUInt32', r'#.length', this);\n\n  void set length(int newLength) {\n    if (newLength is !int) throw new ArgumentError(newLength);\n    if (newLength < 0) throw new RangeError.value(newLength);\n    checkGrowable('set length');\n    JS('void', r'#.length = #', this, newLength);\n  }\n\n  E operator [](int index) {\n    if (index is !int) throw new ArgumentError(index);\n    if (index >= length || index < 0) throw new RangeError.value(index);\n    return JS('var', '#[#]', this, index);\n  }\n\n  void operator []=(int index, E value) {\n    checkMutable('indexed set');\n    if (index is !int) throw new ArgumentError(index);\n    if (index >= length || index < 0) throw new RangeError.value(index);\n    JS('void', r'#[#] = #', this, index, value);\n  }\n\n  Map<int, E> asMap() {\n    return new IterableMixinWorkaround<E>().asMapList(this);\n  }\n}\n\n/**\n * Dummy subclasses that allow the backend to track more precise\n * information about arrays through their type. The CPA type inference\n * relies on the fact that these classes do not override [] nor []=.\n */\nclass JSMutableArray<E> extends JSArray<E> implements JSMutableIndexable {}\nclass JSFixedArray<E> extends JSMutableArray<E> {}\nclass JSExtendableArray<E> extends JSMutableArray<E> {}\n\u0000","sdk:/sdk/lib/_internal/lib/interceptors.dart":"// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\nlibrary _interceptors;\n\nimport 'dart:collection';\nimport 'dart:_internal' hide Symbol;\nimport \"dart:_internal\" as _symbol_dev show Symbol;\nimport 'dart:_js_helper' show allMatchesInStringUnchecked,\n                              Null,\n                              JSSyntaxRegExp,\n                              Primitives,\n                              checkInt,\n                              checkNull,\n                              checkNum,\n                              checkString,\n                              defineProperty,\n                              getRuntimeType,\n                              initNativeDispatch,\n                              initNativeDispatchFlag,\n                              regExpGetNative,\n                              stringContainsUnchecked,\n                              stringLastIndexOfUnchecked,\n                              stringReplaceAllFuncUnchecked,\n                              stringReplaceAllUnchecked,\n                              stringReplaceFirstUnchecked,\n                              lookupAndCacheInterceptor,\n                              lookupDispatchRecord,\n                              StringMatch,\n                              firstMatchAfter,\n                              NoInline;\nimport 'dart:_foreign_helper' show\n    JS, JS_EFFECT, JS_INTERCEPTOR_CONSTANT, JS_STRING_CONCAT;\nimport 'dart:math' show Random;\n\npart 'js_array.dart';\npart 'js_number.dart';\npart 'js_string.dart';\n\nString _symbolToString(Symbol symbol) => _symbol_dev.Symbol.getName(symbol);\n\n_symbolMapToStringMap(Map<Symbol, dynamic> map) {\n  if (map == null) return null;\n  var result = new Map<String, dynamic>();\n  map.forEach((Symbol key, value) {\n    result[_symbolToString(key)] = value;\n  });\n  return result;\n}\n\n/**\n * Get the interceptor for [object]. Called by the compiler when it needs\n * to emit a call to an intercepted method, that is a method that is\n * defined in an interceptor class.\n */\ngetInterceptor(object) {\n  // This is a magic method: the compiler does specialization of it\n  // depending on the uses of intercepted methods and instantiated\n  // primitive types.\n\n  // The [JS] call prevents the type analyzer from making assumptions about the\n  // return type.\n  return JS('', 'void 0');\n}\n\ngetDispatchProperty(object) {\n  return JS('', '#[#]', object, JS('String', 'init.dispatchPropertyName'));\n}\n\nsetDispatchProperty(object, value) {\n  defineProperty(object, JS('String', 'init.dispatchPropertyName'), value);\n}\n\nmakeDispatchRecord(interceptor, proto, extension, indexability) {\n  // Dispatch records are stored in the prototype chain, and in some cases, on\n  // instances.\n  //\n  // The record layout and field usage is designed to minimize the number of\n  // operations on the common paths.\n  //\n  // [interceptor] is the interceptor - a holder of methods for the object,\n  // i.e. the prototype of the interceptor class.\n  //\n  // [proto] is usually the prototype, used to check that the dispatch record\n  // matches the object and is not the dispatch record of a superclass.  Other\n  // values:\n  //  - `false` for leaf classes that need no check.\n  //  - `true` for Dart classes where the object is its own interceptor (unused)\n  //  - a function used to continue matching.\n  //\n  // [extension] is used for irregular cases.\n  //\n  // [indexability] is used to cache whether or not the object\n  // implements JavaScriptIndexingBehavior.\n  //\n  //     proto  interceptor extension action\n  //     -----  ----------- --------- ------\n  //     false  I                     use interceptor I\n  //     true   -                     use object\n  //     P      I                     if object's prototype is P, use I\n  //     F      -           P         if object's prototype is P, call F\n\n  // BUG(10903): Remove this hack. It is needed to avoid inlining this\n  // method because inlining gives us multiple allocation points for\n  // records which is bad because it leads to polymorphic access.\n  if (false) return null;\n  return JS('', '{i: #, p: #, e: #, x: #}',\n            interceptor, proto, extension, indexability);\n}\n\ndispatchRecordInterceptor(record) => JS('', '#.i', record);\ndispatchRecordProto(record) => JS('', '#.p', record);\ndispatchRecordExtension(record) => JS('', '#.e', record);\ndispatchRecordIndexability(record) => JS('bool|Null', '#.x', record);\n\n/**\n * Returns the interceptor for a native class instance. Used by\n * [getInterceptor].\n */\ngetNativeInterceptor(object) {\n  var record = getDispatchProperty(object);\n\n  if (record == null) {\n    if (initNativeDispatchFlag == null) {\n      initNativeDispatch();\n      record = getDispatchProperty(object);\n    }\n  }\n\n  if (record != null) {\n    var proto = dispatchRecordProto(record);\n    if (false == proto) return dispatchRecordInterceptor(record);\n    if (true == proto) return object;\n    var objectProto = JS('', 'Object.getPrototypeOf(#)', object);\n    if (JS('bool', '# === #', proto, objectProto)) {\n      return dispatchRecordInterceptor(record);\n    }\n\n    var extension = dispatchRecordExtension(record);\n    if (JS('bool', '# === #', extension, objectProto)) {\n      // TODO(sra): The discriminator returns a tag.  The tag is an uncached or\n      // instance-cached tag, defaulting to instance-cached if caching\n      // unspecified.\n      var discriminatedTag = JS('', '(#)(#, #)', proto, object, record);\n      throw new UnimplementedError('Return interceptor for $discriminatedTag');\n    }\n  }\n\n  var interceptor = lookupAndCacheInterceptor(object);\n  if (interceptor == null) {\n    // JavaScript Objects created via object literals and `Object.create(null)`\n    // are 'plain' Objects.  This test could be simplified and the dispatch path\n    // be faster if Object.prototype was pre-patched with a non-leaf dispatch\n    // record.\n    var proto = JS('', 'Object.getPrototypeOf(#)', object);\n    if (JS('bool', '# == null || # === Object.prototype', proto, proto)) {\n      return JS_INTERCEPTOR_CONSTANT(PlainJavaScriptObject);\n    } else {\n      return JS_INTERCEPTOR_CONSTANT(UnknownJavaScriptObject);\n    }\n  }\n\n  return interceptor;\n}\n\n/**\n * If [JSInvocationMirror._invokeOn] is being used, this variable\n * contains a JavaScript array with the names of methods that are\n * intercepted.\n */\nvar interceptedNames;\n\n\n/**\n * Data structure used to map a [Type] to the [Interceptor] and constructors for\n * that type.  It is JavaScript array of 3N entries of adjacent slots containing\n * a [Type], followed by an [Interceptor] class for the type, followed by a\n * JavaScript object map for the constructors.\n *\n * The value of this variable is set by the compiler and contains only types\n * that are user extensions of native classes where the type occurs as a\n * constant in the program.\n *\n * The compiler, in CustomElementsAnalysis, assumes that [mapTypeToInterceptor]\n * is accessed only by code that also calls [findIndexForWebComponentType].  If\n * this assumption is invalidated, the compiler will have to be updated.\n */\n// TODO(sra): Mark this as initialized to a constant with unknown value.\nvar mapTypeToInterceptor;\n\nint findIndexForNativeSubclassType(Type type) {\n  if (JS('bool', '# == null', mapTypeToInterceptor)) return null;\n  List map = JS('JSFixedArray', '#', mapTypeToInterceptor);\n  for (int i = 0; i + 1 < map.length; i += 3) {\n    if (type == map[i]) {\n      return i;\n    }\n  }\n  return null;\n}\n\nfindInterceptorConstructorForType(Type type) {\n  var index = findIndexForNativeSubclassType(type);\n  if (index == null) return null;\n  List map = JS('JSFixedArray', '#', mapTypeToInterceptor);\n  return map[index + 1];\n}\n\n/**\n * Returns a JavaScript function that runs the constructor on its argument, or\n * `null` if there is no such constructor.\n *\n * The returned function takes one argument, the web component object.\n */\nfindConstructorForNativeSubclassType(Type type, String name) {\n  var index = findIndexForNativeSubclassType(type);\n  if (index == null) return null;\n  List map = JS('JSFixedArray', '#', mapTypeToInterceptor);\n  var constructorMap = map[index + 2];\n  var constructorFn = JS('', '#[#]', constructorMap, name);\n  return constructorFn;\n}\n\nfindInterceptorForType(Type type) {\n  var constructor = findInterceptorConstructorForType(type);\n  if (constructor == null) return null;\n  return JS('', '#.prototype', constructor);\n}\n\n/**\n * The base interceptor class.\n *\n * The code `r.foo(a)` is compiled to `getInterceptor(r).foo$1(r, a)`.  The\n * value returned by [getInterceptor] holds the methods separately from the\n * state of the instance.  The compiler converts the methods on an interceptor\n * to take the Dart `this` argument as an explicit `receiver` argument.  The\n * JavaScript `this` parameter is bound to the interceptor.\n *\n * In order to have uniform call sites, if a method is defined on an\n * interceptor, methods of that name on plain unintercepted classes also use the\n * interceptor calling convention.  The plain classes are _self-interceptors_,\n * and for them, `getInterceptor(r)` returns `r`.  Methods on plain\n * unintercepted classes have a redundant `receiver` argument and should ignore\n * it in favour of `this`.\n *\n * In the case of mixins, a method may be placed on both an intercepted class\n * and an unintercepted class.  In this case, the method must use the `receiver`\n * parameter.\n *\n *\n * There are various optimizations of the general call pattern.\n *\n * When the interceptor can be statically determined, it can be used directly:\n *\n *     CONSTANT_INTERCEPTOR.foo$1(r, a)\n *\n * If there are only a few classes, [getInterceptor] can be specialized with a\n * more efficient dispatch:\n *\n *     getInterceptor$specialized(r).foo$1(r, a)\n *\n * If it can be determined that the receiver is an unintercepted class, it can\n * be called directly:\n *\n *     r.foo$1(r, a)\n *\n * If, further, it is known that the call site cannot call a foo that is\n * mixed-in to a native class, then it is known that the explicit receiver is\n * ignored, and space-saving dummy value can be passed instead:\n *\n *     r.foo$1(0, a)\n *\n * This class defines implementations of *all* methods on [Object] so no\n * interceptor inherits an implementation from [Object].  This enables the\n * implementations on Object to ignore the explicit receiver argument, which\n * allows dummy receiver optimization.\n */\nabstract class Interceptor {\n  const Interceptor();\n\n  bool operator ==(other) => identical(this, other);\n\n  int get hashCode => Primitives.objectHashCode(this);\n\n  String toString() => Primitives.objectToString(this);\n\n  dynamic noSuchMethod(Invocation invocation) {\n    throw new NoSuchMethodError(\n        this,\n        invocation.memberName,\n        invocation.positionalArguments,\n        invocation.namedArguments);\n  }\n\n  Type get runtimeType => getRuntimeType(this);\n}\n\n/**\n * The interceptor class for [bool].\n */\nclass JSBool extends Interceptor implements bool {\n  const JSBool();\n\n  // Note: if you change this, also change the function [S].\n  String toString() => JS('String', r'String(#)', this);\n\n  // The values here are SMIs, co-prime and differ about half of the bit\n  // positions, including the low bit, so they are different mod 2^k.\n  int get hashCode => this ? (2 * 3 * 23 * 3761) : (269 * 811);\n\n  Type get runtimeType => bool;\n}\n\n/**\n * The interceptor class for [Null].\n *\n * This class defines implementations for *all* methods on [Object] since\n * the methods on Object assume the receiver is non-null.  This means that\n * JSNull will always be in the interceptor set for methods defined on Object.\n */\nclass JSNull extends Interceptor implements Null {\n  const JSNull();\n\n  bool operator ==(other) => identical(null, other);\n\n  // Note: if you change this, also change the function [S].\n  String toString() => 'null';\n\n  int get hashCode => 0;\n\n  // The spec guarantees that `null` is the singleton instance of the `Null`\n  // class. In the mirrors library we also have to patch the `type` getter to\n  // special case `null`.\n  Type get runtimeType => Null;\n\n  dynamic noSuchMethod(Invocation invocation) => super.noSuchMethod(invocation);\n}\n\n/**\n * The supertype for JSString and JSArray. Used by the backend as to\n * have a type mask that contains the objects that we can use the\n * native JS [] operator and length on.\n */\nabstract class JSIndexable {\n  int get length;\n  operator[](int index);\n}\n\n/**\n * The supertype for JSMutableArray and\n * JavaScriptIndexingBehavior. Used by the backend to have a type mask\n * that contains the objects we can use the JS []= operator on.\n */\nabstract class JSMutableIndexable extends JSIndexable {\n  operator[]=(int index, var value);\n}\n\n/**\n * The interface implemented by JavaScript objects.  These are methods in\n * addition to the regular Dart Object methods like [Object.hashCode].\n *\n * This is the type that should be exported by a JavaScript interop library.\n */\nabstract class JSObject {\n}\n\n\n/**\n * Interceptor base class for JavaScript objects not recognized as some more\n * specific native type.\n */\nabstract class JavaScriptObject extends Interceptor implements JSObject {\n  const JavaScriptObject();\n\n  // It would be impolite to stash a property on the object.\n  int get hashCode => 0;\n\n  Type get runtimeType => JSObject;\n}\n\n\n/**\n * Interceptor for plain JavaScript objects created as JavaScript object\n * literals or `new Object()`.\n */\nclass PlainJavaScriptObject extends JavaScriptObject {\n  const PlainJavaScriptObject();\n}\n\n\n/**\n * Interceptor for unclassified JavaScript objects, typically objects with a\n * non-trivial prototype chain.\n *\n * This class also serves as a fallback for unknown JavaScript exceptions.\n */\nclass UnknownJavaScriptObject extends JavaScriptObject {\n  const UnknownJavaScriptObject();\n\n  String toString() => JS('String', 'String(#)', this);\n}\n\u0000","sdk:/sdk/lib/_internal/lib/js_names.dart":"// Copyright (c) 2013, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\nlibrary dart._js_names;\n\nimport 'dart:_foreign_helper' show\n    JS,\n    JS_GET_NAME;\n\nimport 'dart:_js_helper' show\n    JsCache,\n    NoInline;\n\nimport 'dart:_interceptors' show JSArray;\n\n/// No-op method that is called to inform the compiler that unmangled named\n/// must be preserved.\npreserveNames() {}\n\n/// A map from mangled names to \"reflective\" names, that is, unmangled names\n/// with some additional information, such as, number of required arguments.\n/// This map is for mangled names used as instance members.\nfinal Map<String, String> mangledNames =\n    computeMangledNames(JS('=Object', 'init.mangledNames'), false);\n\n/// A map from \"reflective\" names to mangled names (the reverse of\n/// [mangledNames]).\nfinal Map<String, String> reflectiveNames =\n    computeReflectiveNames(mangledNames);\n\n/// A map from mangled names to \"reflective\" names (see [mangledNames]).  This\n/// map is for globals, that is, static and top-level members.\nfinal Map<String, String> mangledGlobalNames =\n    computeMangledNames(JS('=Object', 'init.mangledGlobalNames'), true);\n\n/// A map from \"reflective\" names to mangled names (the reverse of\n/// [mangledGlobalNames]).\nfinal Map<String, String> reflectiveGlobalNames =\n    computeReflectiveNames(mangledGlobalNames);\n\n/// [jsMangledNames] is a JavaScript object literal.  The keys are the mangled\n/// names, and the values are the \"reflective\" names.\nMap<String, String> computeMangledNames(jsMangledNames, bool isGlobal) {\n  preserveNames();\n  var keys = extractKeys(jsMangledNames);\n  var result = <String, String>{};\n  String getterPrefix = JS_GET_NAME('GETTER_PREFIX');\n  int getterPrefixLength = getterPrefix.length;\n  String setterPrefix = JS_GET_NAME('SETTER_PREFIX');\n  for (String key in keys) {\n    String value = JS('String', '#[#]', jsMangledNames, key);\n    result[key] = value;\n    if (!isGlobal) {\n      if (key.startsWith(getterPrefix)) {\n        result['$setterPrefix${key.substring(getterPrefixLength)}'] = '$value=';\n      }\n    }\n  }\n  return result;\n}\n\nMap<String, String> computeReflectiveNames(Map<String, String> map) {\n  preserveNames();\n  var result = <String, String>{};\n  map.forEach((String mangledName, String reflectiveName) {\n    result[reflectiveName] = mangledName;\n  });\n  return result;\n}\n\n@NoInline()\nList extractKeys(victim) {\n  var result = JS('', '''\n(function(victim, hasOwnProperty) {\n  var result = [];\n  for (var key in victim) {\n    if (hasOwnProperty.call(victim, key)) result.push(key);\n  }\n  return result;\n})(#, Object.prototype.hasOwnProperty)''', victim);\n  return new JSArray.markFixed(result);\n}\n\n/**\n * Returns the (global) unmangled version of [name].\n *\n * Normally, you should use [mangledGlobalNames] directly, but this method\n * doesn't tell the compiler to preserve names. So this method only returns a\n * non-null value if some other component has made the compiler preserve names.\n *\n * This is used, for example, to return unmangled names from TypeImpl.toString\n * *if* names are being preserved for other reasons (use of dart:mirrors, for\n * example).\n */\nString unmangleGlobalNameIfPreservedAnyways(String name) {\n  var names = JS('=Object', 'init.mangledGlobalNames');\n  return JsCache.fetch(names, name);\n}\n\nString unmangleAllIdentifiersIfPreservedAnyways(String str) {\n  return JS(\"String\",\n            r\"(#).replace(/[^<,> ]+/g,\"\n            r\"function(m) { return init.mangledGlobalNames[m] || m; })\",\n            str);\n}\u0000","sdk:/sdk/lib/convert/utf.dart":"// Copyright (c) 2013, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\npart of dart.convert;\n\n/** The Unicode Replacement character `U+FFFD` (�). */\nconst int UNICODE_REPLACEMENT_CHARACTER_RUNE = 0xFFFD;\n\n/** The Unicode Byte Order Marker (BOM) character `U+FEFF`. */\nconst int UNICODE_BOM_CHARACTER_RUNE = 0xFEFF;\n\n/**\n * An instance of the default implementation of the [Utf8Codec].\n *\n * This instance provides a convenient access to the most common UTF-8\n * use cases.\n *\n * Examples:\n *\n *     var encoded = UTF8.encode(\"Îñţérñåţîöñåļîžåţîờñ\");\n *     var decoded = UTF8.decode([0x62, 0x6c, 0xc3, 0xa5, 0x62, 0xc3, 0xa6,\n *                                0x72, 0x67, 0x72, 0xc3, 0xb8, 0x64]);\n */\nconst Utf8Codec UTF8 = const Utf8Codec();\n\n/**\n * A [Utf8Codec] encodes strings to utf-8 code units (bytes) and decodes\n * UTF-8 code units to strings.\n */\nclass Utf8Codec extends Encoding {\n  final bool _allowMalformed;\n\n  /**\n   * Instantiates a new [Utf8Codec].\n   *\n   * The optional [allowMalformed] argument defines how [decoder] (and [decode])\n   * deal with invalid or unterminated character sequences.\n   *\n   * If it is `true` (and not overriden at the method invocation) [decode] and\n   * the [decoder] replace invalid (or unterminated) octet\n   * sequences with the Unicode Replacement character `U+FFFD` (�). Otherwise\n   * they throw a [FormatException].\n   */\n  const Utf8Codec({ bool allowMalformed: false })\n      : _allowMalformed = allowMalformed;\n\n  String get name => \"utf-8\";\n\n  /**\n   * Decodes the UTF-8 [codeUnits] (a list of unsigned 8-bit integers) to the\n   * corresponding string.\n   *\n   * If the [codeUnits] start with a leading [UNICODE_BOM_CHARACTER_RUNE] this\n   * character is discarded.\n   *\n   * If [allowMalformed] is `true` the decoder replaces invalid (or\n   * unterminated) character sequences with the Unicode Replacement character\n   * `U+FFFD` (�). Otherwise it throws a [FormatException].\n   *\n   * If [allowMalformed] is not given, it defaults to the `allowMalformed` that\n   * was used to instantiate `this`.\n   */\n  String decode(List<int> codeUnits, { bool allowMalformed }) {\n    if (allowMalformed == null) allowMalformed = _allowMalformed;\n    return new Utf8Decoder(allowMalformed: allowMalformed).convert(codeUnits);\n  }\n\n  Converter<String, List<int>> get encoder => new Utf8Encoder();\n  Converter<List<int>, String> get decoder {\n    return new Utf8Decoder(allowMalformed: _allowMalformed);\n  }\n}\n\n/**\n * This class converts strings to their UTF-8 code units (a list of\n * unsigned 8-bit integers).\n */\nclass Utf8Encoder extends Converter<String, List<int>> {\n\n  const Utf8Encoder();\n\n  /**\n   * Converts [string] to its UTF-8 code units (a list of\n   * unsigned 8-bit integers).\n   */\n  List<int> convert(String string) {\n    // Create a new encoder with a length that is guaranteed to be big enough.\n    // A single code unit uses at most 3 bytes. Two code units at most 4.\n    _Utf8Encoder encoder = new _Utf8Encoder.withBufferSize(string.length * 3);\n    int endPosition = encoder._fillBuffer(string, 0, string.length);\n    assert(endPosition >= string.length - 1);\n    if (endPosition != string.length) {\n      int lastCodeUnit = string.codeUnitAt(string.length - 1);\n      assert(_isLeadSurrogate(lastCodeUnit));\n      // We use a non-surrogate as `nextUnit` so that _writeSurrogate just\n      // writes the lead-surrogate.\n      bool wasCombined = encoder._writeSurrogate(lastCodeUnit, 0);\n      assert(!wasCombined);\n    }\n    return encoder._buffer.sublist(0, encoder._bufferIndex);\n  }\n\n  /**\n   * Starts a chunked conversion.\n   *\n   * The converter works more efficiently if the given [sink] is a\n   * [ByteConversionSink].\n   */\n  StringConversionSink startChunkedConversion(Sink<List<int>> sink) {\n    if (sink is! ByteConversionSink) {\n      sink = new ByteConversionSink.from(sink);\n    }\n    return new _Utf8EncoderSink(sink);\n  }\n\n  // Override the base-classes bind, to provide a better type.\n  Stream<List<int>> bind(Stream<String> stream) => super.bind(stream);\n}\n\n/**\n * This class encodes Strings to UTF-8 code units (unsigned 8 bit integers).\n */\n// TODO(floitsch): make this class public.\nclass _Utf8Encoder {\n  int _carry = 0;\n  int _bufferIndex = 0;\n  final List<int> _buffer;\n\n  static const _DEFAULT_BYTE_BUFFER_SIZE = 1024;\n\n  _Utf8Encoder() : this.withBufferSize(_DEFAULT_BYTE_BUFFER_SIZE);\n\n  _Utf8Encoder.withBufferSize(int bufferSize)\n      : _buffer = _createBuffer(bufferSize);\n\n  // TODO(11971): Always use Uint8List.\n  /**\n   * Allow an implementation to pick the most efficient way of storing bytes.\n   */\n  external static List<int> _createBuffer(int size);\n\n  /**\n   * Tries to combine the given [leadingSurrogate] with the [nextCodeUnit] and\n   * writes it to [_buffer].\n   *\n   * Returns true if the [nextCodeUnit] was combined with the\n   * [leadingSurrogate]. If it wasn't then nextCodeUnit was not a trailing\n   * surrogate and has not been written yet.\n   *\n   * It is safe to pass 0 for [nextCodeUnit] in which case only the leading\n   * surrogate is written.\n   */\n  bool _writeSurrogate(int leadingSurrogate, int nextCodeUnit) {\n    if (_isTailSurrogate(nextCodeUnit)) {\n      int rune = _combineSurrogatePair(leadingSurrogate, nextCodeUnit);\n      // If the rune is encoded with 2 code-units then it must be encoded\n      // with 4 bytes in UTF-8.\n      assert(rune > _THREE_BYTE_LIMIT);\n      assert(rune <= _FOUR_BYTE_LIMIT);\n      _buffer[_bufferIndex++] = 0xF0 | (rune >> 18);\n      _buffer[_bufferIndex++] = 0x80 | ((rune >> 12) & 0x3f);\n      _buffer[_bufferIndex++] = 0x80 | ((rune >> 6) & 0x3f);\n      _buffer[_bufferIndex++] = 0x80 | (rune & 0x3f);\n      return true;\n    } else {\n      // TODO(floitsch): allow to throw on malformed strings.\n      // Encode the half-surrogate directly into UTF-8. This yields\n      // invalid UTF-8, but we started out with invalid UTF-16.\n\n      // Surrogates are always encoded in 3 bytes in UTF-8.\n      _buffer[_bufferIndex++] = 0xE0 | (leadingSurrogate >> 12);\n      _buffer[_bufferIndex++] = 0x80 | ((leadingSurrogate >> 6) & 0x3f);\n      _buffer[_bufferIndex++] = 0x80 | (leadingSurrogate & 0x3f);\n      return false;\n    }\n  }\n\n  /**\n   * Fills the [_buffer] with as many characters as possible.\n   *\n   * Does not encode any trailing lead-surrogate. This must be done by the\n   * caller.\n   *\n   * Returns the position in the string. The returned index points to the\n   * first code unit that hasn't been encoded.\n   */\n  int _fillBuffer(String str, int start, int end) {\n    if (start != end && _isLeadSurrogate(str.codeUnitAt(end - 1))) {\n      // Don't handle a trailing lead-surrogate in this loop. The caller has\n      // to deal with those.\n      end--;\n    }\n    int stringIndex;\n    for (stringIndex = start; stringIndex < end; stringIndex++) {\n      int codeUnit = str.codeUnitAt(stringIndex);\n      // ASCII has the same representation in UTF-8 and UTF-16.\n      if (codeUnit <= _ONE_BYTE_LIMIT) {\n        if (_bufferIndex >= _buffer.length) break;\n        _buffer[_bufferIndex++] = codeUnit;\n      } else if (_isLeadSurrogate(codeUnit)) {\n        if (_bufferIndex + 3 >= _buffer.length) break;\n        // Note that it is safe to read the next code unit. We decremented\n        // [end] above when the last valid code unit was a leading surrogate.\n        int nextCodeUnit = str.codeUnitAt(stringIndex + 1);\n        bool wasCombined = _writeSurrogate(codeUnit, nextCodeUnit);\n        if (wasCombined) stringIndex++;\n      } else {\n        int rune = codeUnit;\n        if (rune <= _TWO_BYTE_LIMIT) {\n          if (_bufferIndex + 1 >= _buffer.length) break;\n          _buffer[_bufferIndex++] = 0xC0 | (rune >> 6);\n          _buffer[_bufferIndex++] = 0x80 | (rune & 0x3f);\n        } else {\n          assert(rune <= _THREE_BYTE_LIMIT);\n          if (_bufferIndex + 2 >= _buffer.length) break;\n          _buffer[_bufferIndex++] = 0xE0 | (rune >> 12);\n          _buffer[_bufferIndex++] = 0x80 | ((rune >> 6) & 0x3f);\n          _buffer[_bufferIndex++] = 0x80 | (rune & 0x3f);\n        }\n      }\n    }\n    return stringIndex;\n  }\n}\n\n/**\n * This class encodes chunked strings to UTF-8 code units (unsigned 8-bit\n * integers).\n */\nclass _Utf8EncoderSink extends _Utf8Encoder with StringConversionSinkMixin {\n\n  final ByteConversionSink _sink;\n\n  _Utf8EncoderSink(this._sink);\n\n  void close() {\n    if (_carry != 0) {\n      // addSlice will call close again, but then the carry must be equal to 0.\n      addSlice(\"\", 0, 0, true);\n      return;\n    }\n    _sink.close();\n  }\n\n  void addSlice(String str, int start, int end, bool isLast) {\n    _bufferIndex = 0;\n\n    if (start == end && !isLast) {\n      return;\n    }\n\n    if (_carry != 0) {\n      int nextCodeUnit = 0;\n      if (start != end) {\n        nextCodeUnit = str.codeUnitAt(start);\n      } else {\n        assert(isLast);\n      }\n      bool wasCombined = _writeSurrogate(_carry, nextCodeUnit);\n      // Either we got a non-empty string, or we must not have been combined.\n      assert(!wasCombined || start != end );\n      if (wasCombined) start++;\n      _carry = 0;\n    }\n    do {\n      start = _fillBuffer(str, start, end);\n      bool isLastSlice = isLast && (start == end);\n      if (start == end - 1 && _isLeadSurrogate(str.codeUnitAt(start))) {\n        if (isLast && _bufferIndex < _buffer.length - 3) {\n          // There is still space for the last incomplete surrogate.\n          // We use a non-surrogate as second argument. This way the\n          // function will just add the surrogate-half to the buffer.\n          bool hasBeenCombined = _writeSurrogate(str.codeUnitAt(start), 0);\n          assert(!hasBeenCombined);\n        } else {\n          // Otherwise store it in the carry. If isLast is true, then\n          // close will flush the last carry.\n          _carry = str.codeUnitAt(start);\n        }\n        start++;\n      }\n      _sink.addSlice(_buffer, 0, _bufferIndex, isLastSlice);\n      _bufferIndex = 0;\n    } while (start < end);\n    if (isLast) close();\n  }\n\n  // TODO(floitsch): implement asUtf8Sink. Sligthly complicated because it\n  // needs to deal with malformed input.\n}\n\n/**\n * This class converts UTF-8 code units (lists of unsigned 8-bit integers)\n * to a string.\n */\nclass Utf8Decoder extends Converter<List<int>, String> {\n  final bool _allowMalformed;\n\n  /**\n   * Instantiates a new [Utf8Decoder].\n   *\n   * The optional [allowMalformed] argument defines how [convert] deals\n   * with invalid or unterminated character sequences.\n   *\n   * If it is `true` [convert] replaces invalid (or unterminated) character\n   * sequences with the Unicode Replacement character `U+FFFD` (�). Otherwise\n   * it throws a [FormatException].\n   */\n  const Utf8Decoder({ bool allowMalformed: false })\n      : this._allowMalformed = allowMalformed;\n\n  /**\n   * Converts the UTF-8 [codeUnits] (a list of unsigned 8-bit integers) to the\n   * corresponding string.\n   *\n   * If the [codeUnits] start with a leading [UNICODE_BOM_CHARACTER_RUNE] this\n   * character is discarded.\n   */\n  String convert(List<int> codeUnits) {\n    StringBuffer buffer = new StringBuffer();\n    _Utf8Decoder decoder = new _Utf8Decoder(buffer, _allowMalformed);\n    decoder.convert(codeUnits, 0, codeUnits.length);\n    decoder.close();\n    return buffer.toString();\n  }\n\n  /**\n   * Starts a chunked conversion.\n   *\n   * The converter works more efficiently if the given [sink] is a\n   * [StringConversionSink].\n   */\n  ByteConversionSink startChunkedConversion(Sink<String> sink) {\n    StringConversionSink stringSink;\n    if (sink is StringConversionSink) {\n      stringSink = sink;\n    } else {\n      stringSink = new StringConversionSink.from(sink);\n    }\n    return stringSink.asUtf8Sink(_allowMalformed);\n  }\n\n  // Override the base-classes bind, to provide a better type.\n  Stream<String> bind(Stream<List<int>> stream) => super.bind(stream);\n}\n\n// UTF-8 constants.\nconst int _ONE_BYTE_LIMIT = 0x7f;   // 7 bits\nconst int _TWO_BYTE_LIMIT = 0x7ff;  // 11 bits\nconst int _THREE_BYTE_LIMIT = 0xffff;  // 16 bits\nconst int _FOUR_BYTE_LIMIT = 0x10ffff;  // 21 bits, truncated to Unicode max.\n\n// UTF-16 constants.\nconst int _SURROGATE_MASK = 0xF800;\nconst int _SURROGATE_TAG_MASK = 0xFC00;\nconst int _SURROGATE_VALUE_MASK = 0x3FF;\nconst int _LEAD_SURROGATE_MIN = 0xD800;\nconst int _TAIL_SURROGATE_MIN = 0xDC00;\n\nbool _isSurrogate(int codeUnit) =>\n    (codeUnit & _SURROGATE_MASK) == _LEAD_SURROGATE_MIN;\nbool _isLeadSurrogate(int codeUnit) =>\n    (codeUnit & _SURROGATE_TAG_MASK) == _LEAD_SURROGATE_MIN;\nbool _isTailSurrogate(int codeUnit) =>\n    (codeUnit & _SURROGATE_TAG_MASK) == _TAIL_SURROGATE_MIN;\nint _combineSurrogatePair(int lead, int tail) =>\n    0x10000 + ((lead & _SURROGATE_VALUE_MASK) << 10)\n            | (tail & _SURROGATE_VALUE_MASK);\n\n\n/**\n * Decodes UTF-8.\n *\n * The decoder handles chunked input.\n */\n// TODO(floitsch): make this class public.\nclass _Utf8Decoder {\n  final bool _allowMalformed;\n  final StringSink _stringSink;\n  bool _isFirstCharacter = true;\n  int _value = 0;\n  int _expectedUnits = 0;\n  int _extraUnits = 0;\n\n  _Utf8Decoder(this._stringSink, this._allowMalformed);\n\n  bool get hasPartialInput => _expectedUnits > 0;\n\n  // Limits of one through four byte encodings.\n  static const List<int> _LIMITS = const <int>[\n      _ONE_BYTE_LIMIT,\n      _TWO_BYTE_LIMIT,\n      _THREE_BYTE_LIMIT,\n      _FOUR_BYTE_LIMIT ];\n\n  void close() {\n    flush();\n  }\n\n  /**\n   * Flushes this decoder as if closed.\n   *\n   * This method throws if the input was partial and the decoder was\n   * constructed with `allowMalformed` set to `false`.\n   */\n  void flush() {\n    if (hasPartialInput) {\n      if (!_allowMalformed) {\n        throw new FormatException(\"Unfinished UTF-8 octet sequence\");\n      }\n      _stringSink.writeCharCode(UNICODE_REPLACEMENT_CHARACTER_RUNE);\n      _value = 0;\n      _expectedUnits = 0;\n      _extraUnits = 0;\n    }\n  }\n\n  void convert(List<int> codeUnits, int startIndex, int endIndex) {\n    int value = _value;\n    int expectedUnits = _expectedUnits;\n    int extraUnits = _extraUnits;\n    _value = 0;\n    _expectedUnits = 0;\n    _extraUnits = 0;\n\n    int scanOneByteCharacters(units, int from) {\n      final to = endIndex;\n      final mask = _ONE_BYTE_LIMIT;\n      for (var i = from; i < to; i++) {\n        final unit = units[i];\n        if ((unit & mask) != unit) return i - from;\n      }\n      return to - from;\n    }\n\n    void addSingleBytes(int from, int to) {\n      assert(from >= startIndex && from <= endIndex);\n      assert(to >= startIndex && to <= endIndex);\n      if (from == 0 && to == codeUnits.length) {\n        _stringSink.write(new String.fromCharCodes(codeUnits));\n      } else {\n        _stringSink.write(\n            new String.fromCharCodes(codeUnits.sublist(from, to)));\n      }\n    }\n\n    int i = startIndex;\n    loop: while (true) {\n      multibyte: if (expectedUnits > 0) {\n        do {\n          if (i == endIndex) {\n            break loop;\n          }\n          int unit = codeUnits[i];\n          if ((unit & 0xC0) != 0x80) {\n            expectedUnits = 0;\n            if (!_allowMalformed) {\n              throw new FormatException(\n                  \"Bad UTF-8 encoding 0x${unit.toRadixString(16)}\");\n            }\n            _isFirstCharacter = false;\n            _stringSink.writeCharCode(UNICODE_REPLACEMENT_CHARACTER_RUNE);\n            break multibyte;\n          } else {\n            value = (value << 6) | (unit & 0x3f);\n            expectedUnits--;\n            i++;\n          }\n        } while (expectedUnits > 0);\n        if (value <= _LIMITS[extraUnits - 1]) {\n          // Overly long encoding. The value could be encoded with a shorter\n          // encoding.\n          if (!_allowMalformed) {\n            throw new FormatException(\n                \"Overlong encoding of 0x${value.toRadixString(16)}\");\n          }\n          expectedUnits = extraUnits = 0;\n          value = UNICODE_REPLACEMENT_CHARACTER_RUNE;\n        }\n        if (value > _FOUR_BYTE_LIMIT) {\n          if (!_allowMalformed) {\n            throw new FormatException(\"Character outside valid Unicode range: \"\n                                      \"0x${value.toRadixString(16)}\");\n          }\n          value = UNICODE_REPLACEMENT_CHARACTER_RUNE;\n        }\n        if (!_isFirstCharacter || value != UNICODE_BOM_CHARACTER_RUNE) {\n          _stringSink.writeCharCode(value);\n        }\n        _isFirstCharacter = false;\n      }\n\n      while (i < endIndex) {\n        int oneBytes = scanOneByteCharacters(codeUnits, i);\n        if (oneBytes > 0) {\n          _isFirstCharacter = false;\n          addSingleBytes(i, i + oneBytes);\n          i += oneBytes;\n          if (i == endIndex) break;\n        }\n        int unit = codeUnits[i++];\n        // TODO(floitsch): the way we test we could potentially allow\n        // units that are too large, if they happen to have the\n        // right bit-pattern. (Same is true for the multibyte loop above).\n        // TODO(floitsch): optimize this loop. See:\n        // https://codereview.chromium.org/22929022/diff/1/sdk/lib/convert/utf.dart?column_width=80\n        if (unit < 0) {\n          // TODO(floitsch): should this be unit <= 0 ?\n          if (!_allowMalformed) {\n            throw new FormatException(\n                \"Negative UTF-8 code unit: -0x${(-unit).toRadixString(16)}\");\n          }\n          _stringSink.writeCharCode(UNICODE_REPLACEMENT_CHARACTER_RUNE);\n        } else {\n          assert(unit > _ONE_BYTE_LIMIT);\n          if ((unit & 0xE0) == 0xC0) {\n            value = unit & 0x1F;\n            expectedUnits = extraUnits = 1;\n            continue loop;\n          }\n          if ((unit & 0xF0) == 0xE0) {\n            value = unit & 0x0F;\n            expectedUnits = extraUnits = 2;\n            continue loop;\n          }\n          // 0xF5, 0xF6 ... 0xFF never appear in valid UTF-8 sequences.\n          if ((unit & 0xF8) == 0xF0 && unit < 0xF5) {\n            value = unit & 0x07;\n            expectedUnits = extraUnits = 3;\n            continue loop;\n          }\n          if (!_allowMalformed) {\n            throw new FormatException(\n                \"Bad UTF-8 encoding 0x${unit.toRadixString(16)}\");\n          }\n          value = UNICODE_REPLACEMENT_CHARACTER_RUNE;\n          expectedUnits = extraUnits = 0;\n          _isFirstCharacter = false;\n          _stringSink.writeCharCode(value);\n        }\n      }\n      break loop;\n    }\n    if (expectedUnits > 0) {\n      _value = value;\n      _expectedUnits = expectedUnits;\n      _extraUnits = extraUnits;\n    }\n  }\n}\n\u0000","sdk:/sdk/lib/convert/string_conversion.dart":"// Copyright (c) 2013, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\npart of dart.convert;\n\n/**\n * This class provides an interface for converters to\n * efficiently transmit String data.\n *\n * Instead of limiting the interface to one non-chunked String it accepts\n * partial strings or can be transformed into a byte sink that\n * accepts UTF-8 code units.\n *\n * This abstract class will likely get more methods over time. Implementers are\n * urged to extend [StringConversionSinkBase] or to mix in\n * [StringConversionSinkMixin], to ensure that their class covers the newly\n * added methods.\n */\nabstract class StringConversionSink\n    extends ChunkedConversionSink<String> {\n  StringConversionSink();\n  factory StringConversionSink.withCallback(void callback(String accumulated))\n      = _StringCallbackSink;\n  factory StringConversionSink.from(Sink<String> sink)\n      = _StringAdapterSink;\n\n  /**\n   * Creates a new instance wrapping the given [sink].\n   *\n   * Every string that is added to the returned instance is forwarded to\n   * the [sink]. The instance is allowed to buffer and is not required to\n   * forward immediately.\n   */\n  factory StringConversionSink.fromStringSink(StringSink sink) =\n      _StringSinkConversionSink;\n\n  /**\n   * Adds the next [chunk] to `this`.\n   *\n   * Adds the substring defined by [start] and [end]-exclusive to `this`.\n   *\n   * If [isLast] is `true` closes `this`.\n   */\n  void addSlice(String chunk, int start, int end, bool isLast);\n\n  /**\n   * Returns `this` as a sink that accepts UTF-8 input.\n   *\n   * If used, this method must be the first and only call to `this`. It\n   * invalidates `this`. All further operations must be performed on the result.\n   */\n  ByteConversionSink asUtf8Sink(bool allowMalformed);\n  // - asRuneSink\n  // - asCodeUnitsSink\n\n  /**\n   * Returns `this` as a [ClosableStringSink].\n   *\n   * If used, this method must be the first and only call to `this`. It\n   * invalidates `this`. All further operations must be performed on the result.\n   */\n  ClosableStringSink asStringSink();\n}\n\n/**\n * A [ClosableStringSink] extends the [StringSink] interface by adding a\n * `close` method.\n */\nabstract class ClosableStringSink extends StringSink {\n  /**\n   * Creates a new instance combining a [StringSink] [sink] and a callback\n   * [onClose] which is invoked when the returned instance is closed.\n   */\n  factory ClosableStringSink.fromStringSink(StringSink sink, void onClose())\n      = _ClosableStringSink;\n\n  /**\n   * Closes `this` and flushes any outstanding data.\n   */\n  void close();\n}\n\ntypedef void _StringSinkCloseCallback();\n\n/**\n * This class wraps an existing [StringSink] and invokes a\n * closure when [close] is invoked.\n */\nclass _ClosableStringSink implements ClosableStringSink {\n  final _StringSinkCloseCallback _callback;\n  final StringSink _sink;\n\n  _ClosableStringSink(this._sink, this._callback);\n\n  void close() => _callback();\n\n  void writeCharCode(int charCode) => _sink.writeCharCode(charCode);\n  void write(Object o) => _sink.write(o);\n  void writeln([Object o = \"\"]) => _sink.writeln(o);\n  void writeAll(Iterable objects, [String separator = \"\"])\n      => _sink.writeAll(objects, separator);\n}\n\n/**\n * This class wraps an existing [StringConversionSink] and exposes a\n * [ClosableStringSink] interface. The wrapped sink only needs to implement\n * `add` and `close`.\n */\n// TODO(floitsch): make this class public?\nclass _StringConversionSinkAsStringSinkAdapter implements ClosableStringSink {\n  static const _MIN_STRING_SIZE = 16;\n\n  StringBuffer _buffer;\n  StringConversionSink _chunkedSink;\n\n  _StringConversionSinkAsStringSinkAdapter(this._chunkedSink)\n      : _buffer = new StringBuffer();\n\n  void close() {\n    if (_buffer.isNotEmpty) _flush();\n    _chunkedSink.close();\n  }\n\n  void writeCharCode(int charCode) {\n    _buffer.writeCharCode(charCode);\n    if (_buffer.length > _MIN_STRING_SIZE) _flush();\n  }\n\n  void write(Object o) {\n    if (_buffer.isNotEmpty) _flush();\n    String str = o.toString();\n    _chunkedSink.add(o.toString());\n  }\n\n  void writeln([Object o = \"\"]) {\n    _buffer.writeln(o);\n    if (_buffer.length > _MIN_STRING_SIZE) _flush();\n  }\n\n  void writeAll(Iterable objects, [String separator = \"\"]) {\n    if (_buffer.isNotEmpty) _flush();\n    Iterator iterator = objects.iterator;\n    if (!iterator.moveNext()) return;\n    if (separator.isEmpty) {\n      do {\n        _chunkedSink.add(iterator.current.toString());\n      } while (iterator.moveNext());\n    } else {\n      _chunkedSink.add(iterator.current.toString());\n      while (iterator.moveNext()) {\n        write(separator);\n        _chunkedSink.add(iterator.current.toString());\n      }\n    }\n  }\n\n  void _flush() {\n    String accumulated = _buffer.toString();\n    _buffer.clear();\n    _chunkedSink.add(accumulated);\n  }\n}\n\n/**\n * This class provides a base-class for converters that need to accept String\n * inputs.\n */\nabstract class StringConversionSinkBase extends StringConversionSinkMixin {\n}\n\n/**\n * This class provides a mixin for converters that need to accept String\n * inputs.\n */\nabstract class StringConversionSinkMixin implements StringConversionSink {\n\n  void addSlice(String str, int start, int end, bool isLast);\n  void close();\n\n  void add(String str) => addSlice(str, 0, str.length, false);\n\n  ByteConversionSink asUtf8Sink(bool allowMalformed) {\n    return new _Utf8ConversionSink(this, allowMalformed);\n  }\n\n  ClosableStringSink asStringSink() {\n    return new _StringConversionSinkAsStringSinkAdapter(this);\n  }\n}\n\n/**\n * This class is a [StringConversionSink] that wraps a [StringSink].\n */\nclass _StringSinkConversionSink extends StringConversionSinkBase {\n  StringSink _stringSink;\n  _StringSinkConversionSink(StringSink this._stringSink);\n\n  void close() {}\n  void addSlice(String str, int start, int end, bool isLast) {\n    if (start != 0 || end != str.length) {\n      for (int i = start; i < end; i++) {\n        _stringSink.writeCharCode(str.codeUnitAt(i));\n      }\n    } else {\n      _stringSink.write(str);\n    }\n    if (isLast) close();\n  }\n\n  void add(String str) => _stringSink.write(str);\n\n  ByteConversionSink asUtf8Sink(bool allowMalformed) {\n    return new _Utf8StringSinkAdapter(this, _stringSink, allowMalformed);\n  }\n\n  ClosableStringSink asStringSink() {\n    return new ClosableStringSink.fromStringSink(_stringSink, this.close);\n  }\n}\n\n/**\n * This class accumulates all chunks into one string\n * and invokes a callback when the sink is closed.\n *\n * This class can be used to terminate a chunked conversion.\n */\nclass _StringCallbackSink extends _StringSinkConversionSink {\n  final _ChunkedConversionCallback<String> _callback;\n  _StringCallbackSink(this._callback) : super(new StringBuffer());\n\n  void close() {\n    StringBuffer buffer = _stringSink;\n    String accumulated = buffer.toString();\n    buffer.clear();\n    _callback(accumulated);\n  }\n\n  ByteConversionSink asUtf8Sink(bool allowMalformed) {\n    return new _Utf8StringSinkAdapter(\n        this, _stringSink, allowMalformed);\n  }\n}\n\n/**\n * This class adapts a simple [ChunkedConversionSink] to a\n * [StringConversionSink].\n *\n * All additional methods of the [StringConversionSink] (compared to the\n * ChunkedConversionSink) are redirected to the `add` method.\n */\nclass _StringAdapterSink extends StringConversionSinkBase {\n  final Sink<String> _sink;\n\n  _StringAdapterSink(this._sink);\n\n  void add(String str) => _sink.add(str);\n\n  void addSlice(String str, int start, int end, bool isLast) {\n    if (start == 0 && end == str.length) {\n      add(str);\n    } else {\n      add(str.substring(start, end));\n    }\n    if (isLast) close();\n  }\n\n  void close() => _sink.close();\n}\n\n\n/**\n * Decodes UTF-8 code units and stores them in a [StringSink].\n */\nclass _Utf8StringSinkAdapter extends ByteConversionSink {\n  final _Utf8Decoder _decoder;\n  final Sink _sink;\n\n  _Utf8StringSinkAdapter(this._sink,\n                         StringSink stringSink, bool allowMalformed)\n      : _decoder = new _Utf8Decoder(stringSink, allowMalformed);\n\n  void close() {\n    _decoder.close();\n    if(_sink != null) _sink.close();\n  }\n\n  void add(List<int> chunk) {\n    addSlice(chunk, 0, chunk.length, false);\n  }\n\n  void addSlice(List<int> codeUnits, int startIndex, int endIndex,\n                bool isLast) {\n    _decoder.convert(codeUnits, startIndex, endIndex);\n    if (isLast) close();\n  }\n}\n\n/**\n * Decodes UTF-8 code units.\n *\n * Forwards the decoded strings to the given [StringConversionSink].\n */\n// TODO(floitsch): make this class public?\nclass _Utf8ConversionSink extends ByteConversionSink {\n\n  final _Utf8Decoder _decoder;\n  final StringConversionSink _chunkedSink;\n  final StringBuffer _buffer;\n  _Utf8ConversionSink(StringConversionSink sink, bool allowMalformed)\n      : this._(sink, new StringBuffer(), allowMalformed);\n\n  _Utf8ConversionSink._(this._chunkedSink, StringBuffer stringBuffer,\n                       bool allowMalformed)\n      : _decoder = new _Utf8Decoder(stringBuffer, allowMalformed),\n        _buffer = stringBuffer;\n\n  void close() {\n    _decoder.close();\n    if (_buffer.isNotEmpty) {\n      String accumulated = _buffer.toString();\n      _buffer.clear();\n      _chunkedSink.addSlice(accumulated, 0, accumulated.length, true);\n    } else  {\n      _chunkedSink.close();\n    }\n  }\n\n  void add(List<int> chunk) {\n    addSlice(chunk, 0, chunk.length, false);\n  }\n\n  void addSlice(List<int> chunk, int startIndex, int endIndex, bool isLast) {\n    _decoder.convert(chunk, startIndex, endIndex);\n    if (_buffer.isNotEmpty) {\n      String accumulated = _buffer.toString();\n      _chunkedSink.addSlice(accumulated, 0, accumulated.length, isLast);\n      _buffer.clear();\n      return;\n    }\n    if (isLast) close();\n  }\n}\n\u0000","sdk:/sdk/lib/convert/line_splitter.dart":"// Copyright (c) 2013, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\npart of dart.convert;\n\n/**\n * This class splits [String] values into individual lines.\n */\nclass LineSplitter extends Converter<String, List<String>> {\n\n  const LineSplitter();\n\n  List<String> convert(String data) {\n    var lines = new List<String>();\n\n    _LineSplitterSink._addSlice(data, 0, data.length, true, lines.add);\n\n    return lines;\n  }\n\n  StringConversionSink startChunkedConversion(Sink<String> sink) {\n    if (sink is! StringConversionSink) {\n      sink = new StringConversionSink.from(sink);\n    }\n    return new _LineSplitterSink(sink);\n  }\n}\n\n// TODO(floitsch): deal with utf8.\nclass _LineSplitterSink extends StringConversionSinkBase {\n  static const int _LF = 10;\n  static const int _CR = 13;\n\n  final StringConversionSink _sink;\n\n  String _carry;\n\n  _LineSplitterSink(this._sink);\n\n  void addSlice(String chunk, int start, int end, bool isLast) {\n    if (_carry != null) {\n      chunk = _carry + chunk.substring(start, end);\n      start = 0;\n      end = chunk.length;\n      _carry = null;\n    }\n    _carry = _addSlice(chunk, start, end, isLast, _sink.add);\n    if (isLast) _sink.close();\n  }\n\n  void close() {\n    addSlice('', 0, 0, true);\n  }\n\n  static String _addSlice(String chunk, int start, int end, bool isLast,\n                          void adder(String val)) {\n\n    int pos = start;\n    while (pos < end) {\n      int skip = 0;\n      int char = chunk.codeUnitAt(pos);\n      if (char == _LF) {\n        skip = 1;\n      } else if (char == _CR) {\n        skip = 1;\n        if (pos + 1 < end) {\n          if (chunk.codeUnitAt(pos + 1) == _LF) {\n            skip = 2;\n          }\n        } else if (!isLast) {\n          return chunk.substring(start, end);\n        }\n      }\n      if (skip > 0) {\n        adder(chunk.substring(start, pos));\n        start = pos = pos + skip;\n      } else {\n        pos++;\n      }\n    }\n    if (pos != start) {\n      var carry = chunk.substring(start, pos);\n      if (isLast) {\n        // Add remaining\n        adder(carry);\n      } else {\n        return carry;\n      }\n    }\n    return null;\n  }\n}\n\u0000","sdk:/sdk/lib/convert/latin1.dart":"// Copyright (c) 2013, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\npart of dart.convert;\n\n/**\n * An instance of the default implementation of the [Latin1Codec].\n *\n * This instance provides a convenient access to the most common ISO Latin 1\n * use cases.\n *\n * Examples:\n *\n *     var encoded = LATIN1.encode(\"blåbærgrød\");\n *     var decoded = LATIN1.decode([0x62, 0x6c, 0xe5, 0x62, 0xe6,\n *                                  0x72, 0x67, 0x72, 0xf8, 0x64]);\n */\nconst Latin1Codec LATIN1 = const Latin1Codec();\n\nconst int _LATIN1_MASK = 0xFF;\n\n/**\n * A [LatinCodec] encodes strings to ISO Latin-1 (aka ISO-8859-1) bytes\n * and decodes Latin-1 bytes to strings.\n */\nclass Latin1Codec extends Encoding {\n  final bool _allowInvalid;\n  /**\n   * Instantiates a new [Latin1Codec].\n   *\n   * If [allowInvalid] is true, the [decode] method and the converter\n   * returned by [decoder] will default to allowing invalid values. Invalid\n   * values are decoded into the Unicode Replacement character (U+FFFD).\n   * Calls to the [decode] method can override this default.\n   *\n   * Encoders will not accept invalid (non Latin-1) characters.\n   */\n  const Latin1Codec({bool allowInvalid: false}) : _allowInvalid = allowInvalid;\n\n  String get name => \"iso-8859-1\";\n\n  /**\n   * Decodes the Latin-1 [bytes] (a list of unsigned 8-bit integers) to the\n   * corresponding string.\n   *\n   * If [bytes] contains values that are not in the range 0 .. 255, the decoder\n   * will eventually throw a [FormatException].\n   *\n   * If [allowInvalid] is not provided, it defaults to the value used to create\n   * this [Latin1Codec].\n   */\n  String decode(List<int> bytes, { bool allowInvalid }) {\n    if (allowInvalid == null) allowInvalid = _allowInvalid;\n    if (allowInvalid) {\n      return const Latin1Decoder(allowInvalid: true).convert(bytes);\n    } else {\n      return const Latin1Decoder(allowInvalid: false).convert(bytes);\n    }\n  }\n\n  Converter<String, List<int>> get encoder => const Latin1Encoder();\n\n  Converter<List<int>, String> get decoder =>\n      _allowInvalid ? const Latin1Decoder(allowInvalid: true)\n                    : const Latin1Decoder(allowInvalid: false);\n}\n\n/**\n * This class converts strings of only ISO Latin-1 characters to bytes.\n */\nclass Latin1Encoder extends _UnicodeSubsetEncoder {\n  const Latin1Encoder() : super(_LATIN1_MASK);\n}\n\n/**\n * This class converts Latin-1 bytes (lists of unsigned 8-bit integers)\n * to a string.\n */\nclass Latin1Decoder extends _UnicodeSubsetDecoder {\n  /**\n   * Instantiates a new [Latin1Decoder].\n   *\n   * The optional [allowInvalid] argument defines how [convert] deals\n   * with invalid bytes.\n   *\n   * If it is `true`, [convert] replaces invalid bytes with the Unicode\n   * Replacement character `U+FFFD` (�).\n   * Otherwise it throws a [FormatException].\n   */\n  const Latin1Decoder({ bool allowInvalid: false })\n      : super(allowInvalid, _LATIN1_MASK);\n\n  /**\n   * Starts a chunked conversion.\n   *\n   * The converter works more efficiently if the given [sink] is a\n   * [StringConversionSink].\n   */\n  ByteConversionSink startChunkedConversion(Sink<String> sink) {\n    StringConversionSink stringSink;\n    if (sink is StringConversionSink) {\n      stringSink = sink;\n    } else {\n      stringSink = new StringConversionSink.from(sink);\n    }\n    // TODO(lrn): Use stringSink.asUtf16Sink() if it becomes available.\n    if (!_allowInvalid) return new _Latin1DecoderSink(stringSink);\n    return new _Latin1AllowInvalidDecoderSink(stringSink);\n  }\n}\n\nclass _Latin1DecoderSink extends ByteConversionSinkBase {\n  StringConversionSink _sink;\n  _Latin1DecoderSink(this._sink);\n\n  void close() {\n    _sink.close();\n  }\n\n  void add(List<int> source) {\n    addSlice(source, 0, source.length, false);\n  }\n\n  void _addSliceToSink(List<int> source, int start, int end, bool isLast) {\n    // If _sink was a UTF-16 conversion sink, just add the slice directly with\n    // _sink.addSlice(source, start, end, isLast).\n    // The code below is an moderately stupid workaround until a real\n    // solution can be made.\n    if (start == 0 && end == source.length) {\n      _sink.add(new String.fromCharCodes(source));\n    } else {\n      _sink.add(new String.fromCharCodes(source.sublist(start, end)));\n    }\n    if (isLast) close();\n  }\n\n  void addSlice(List<int> source, int start, int end, bool isLast) {\n    if (start < 0 || start > source.length) {\n      throw new RangeError.range(start, 0, source.length);\n    }\n    if (end < start || end > source.length) {\n      throw new RangeError.range(end, start, source.length);\n    }\n    for (int i = start; i < end; i++) {\n      int char = source[i];\n      if (char > _LATIN1_MASK || char < 0) {\n        throw new FormatException(\"Source contains non-Latin-1 characters.\");\n      }\n    }\n    if (start < end) {\n      _addSliceToSink(source, start, end, isLast);\n    }\n    if (isLast) {\n      close();\n    }\n  }\n}\n\nclass _Latin1AllowInvalidDecoderSink extends _Latin1DecoderSink {\n  _Latin1AllowInvalidDecoderSink(StringConversionSink sink): super(sink);\n\n  void addSlice(List<int> source, int start, int end, bool isLast) {\n    if (start < 0 || start > source.length) {\n      throw new RangeError.range(start, 0, source.length);\n    }\n    if (end < start || end > source.length) {\n      throw new RangeError.range(end, start, source.length);\n    }\n    for (int i = start; i < end; i++) {\n      int char = source[i];\n      if (char > _LATIN1_MASK || char < 0) {\n        if (i > start) _addSliceToSink(source, start, i, false);\n        // Add UTF-8 encoding of U+FFFD.\n        _addSliceToSink(const[0xFFFD], 0, 1, false);\n        start = i + 1;\n      }\n    }\n    if (start < end) {\n      _addSliceToSink(source, start, end, isLast);\n    }\n    if (isLast) {\n      close();\n    }\n  }\n}\n\u0000","sdk:/sdk/lib/convert/json.dart":"// Copyright (c) 2013, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\npart of dart.convert;\n\n/**\n * Error thrown by JSON serialization if an object cannot be serialized.\n *\n * The [unsupportedObject] field holds that object that failed to be serialized.\n *\n * If an object isn't directly serializable, the serializer calls the 'toJson'\n * method on the object. If that call fails, the error will be stored in the\n * [cause] field. If the call returns an object that isn't directly\n * serializable, the [cause] is be null.\n */\nclass JsonUnsupportedObjectError extends Error {\n  /** The object that could not be serialized. */\n  final unsupportedObject;\n  /** The exception thrown when trying to convert the object. */\n  final cause;\n\n  JsonUnsupportedObjectError(this.unsupportedObject, { this.cause });\n\n  String toString() {\n    if (cause != null) {\n      return \"Converting object to an encodable object failed.\";\n    } else {\n      return \"Converting object did not return an encodable object.\";\n    }\n  }\n}\n\n\n/**\n * Reports that an object could not be stringified due to cyclic references.\n *\n * An object that references itself cannot be serialized by [stringify].\n * When the cycle is detected, a [JsonCyclicError] is thrown.\n */\nclass JsonCyclicError extends JsonUnsupportedObjectError {\n  /** The first object that was detected as part of a cycle. */\n  JsonCyclicError(Object object): super(object);\n  String toString() => \"Cyclic error in JSON stringify\";\n}\n\n\n/**\n * An instance of the default implementation of the [JsonCodec].\n *\n * This instance provides a convenient access to the most common JSON\n * use cases.\n *\n * Examples:\n *\n *     var encoded = JSON.encode([1, 2, { \"a\": null }]);\n *     var decoded = JSON.decode('[\"foo\", { \"bar\": 499 }]');\n */\nconst JsonCodec JSON = const JsonCodec();\n\ntypedef _Reviver(var key, var value);\ntypedef _ToEncodable(var o);\n\n\n/**\n * A [JsonCodec] encodes JSON objects to strings and decodes strings to\n * JSON objects.\n */\nclass JsonCodec extends Codec<Object, String> {\n  final _Reviver _reviver;\n  final _ToEncodable _toEncodable;\n\n  /**\n   * Creates a `JsonCodec` with the given reviver and encoding function.\n   *\n   * The [reviver] function is called during decoding. It is invoked\n   * once for each object or list property that has been parsed.\n   * The `key` argument is either the\n   * integer list index for a list property, the string map key for object\n   * properties, or `null` for the final result.\n   *\n   * If [reviver] is omitted, it defaults to returning the value argument.\n   *\n   * The [toEncodable] function is used during encoding. It is invoked for\n   * values that are not directly encodable to a JSON1toE\n   * string (a value that is not a number, boolean, string, null, list or a map\n   * with string keys). The function must return an object that is directly\n   * encodable. The elements of a returned list and values of a returned map\n   * do not need be directly encodable, and if they aren't, `toEncodable` will\n   * be used on them as well.\n   * Please notice that it is possible to cause an infinite recursive\n   * regress in this way, by effectively creating an infinite data structure\n   * through repeated call to `toEncodable`.\n   *\n   * If [toEncodable] is omitted, it defaults to a function that returns the\n   * result of calling `.toJson()` on the unencodable object.\n   */\n  const JsonCodec({reviver(var key, var value), toEncodable(var object)})\n      : _reviver = reviver,\n        _toEncodable = toEncodable;\n\n  /**\n   * Creates a `JsonCodec` with the given reviver.\n   *\n   * The [reviver] function is called once for each object or list property\n   * that has been parsed during decoding. The `key` argument is either the\n   * integer list index for a list property, the string map key for object\n   * properties, or `null` for the final result.\n   */\n  JsonCodec.withReviver(reviver(var key, var value)) : this(reviver: reviver);\n\n  /**\n   * Parses the string and returns the resulting Json object.\n   *\n   * The optional [reviver] function is called once for each object or list\n   * property that has been parsed during decoding. The `key` argument is either\n   * the integer list index for a list property, the string map key for object\n   * properties, or `null` for the final result.\n   *\n   * The default [reviver] (when not provided) is the identity function.\n   */\n  dynamic decode(String source, {reviver(var key, var value)}) {\n    if (reviver == null) reviver = _reviver;\n    if (reviver == null) return decoder.convert(source);\n    return new JsonDecoder(reviver).convert(source);\n  }\n\n  /**\n   * Converts [value] to a JSON string.\n   *\n   * If value contains objects that are not directly encodable to a JSON\n   * string (a value that is not a number, boolean, string, null, list or a map\n   * with string keys), the [toEncodable] function is used to convert it to an\n   * object that must be directly encodable.\n   *\n   * If [toEncodable] is omitted, it defaults to a function that returns the\n   * result of calling `.toJson()` on the unencodable object.\n   */\n  String encode(Object value, {toEncodable(var object)}) {\n    if (toEncodable == null) toEncodable = _toEncodable;\n    if (toEncodable == null) return encoder.convert(value);\n    return new JsonEncoder(toEncodable).convert(value);\n  }\n\n  JsonEncoder get encoder {\n    if (_toEncodable == null) return const JsonEncoder();\n    return new JsonEncoder(_toEncodable);\n  }\n\n  JsonDecoder get decoder {\n    if (_reviver == null) return const JsonDecoder();\n    return new JsonDecoder(_reviver);\n  }\n}\n\n/**\n * This class converts JSON objects to strings.\n */\nclass JsonEncoder extends Converter<Object, String> {\n  /**\n   * The string used for indention.\n   *\n   * When generating multi-line output, this string is inserted once at the\n   * beginning of each indented line for each level of indentation.\n   *\n   * If `null`, the output is encoded as a single line.\n   */\n  final String indent;\n\n  final _toEncodableFunction;\n\n  /**\n   * Creates a JSON encoder.\n   *\n   * The JSON encoder handles numbers, strings, booleans, null, lists and\n   * maps directly.\n   *\n   * Any other object is attempted converted by [toEncodable] to an\n   * object that is of one of the convertible types.\n   *\n   * If [toEncodable] is omitted, it defaults to calling `.toJson()` on\n   * the object.\n   */\n  const JsonEncoder([Object toEncodable(Object nonSerializable)])\n      : this.indent = null,\n        this._toEncodableFunction = toEncodable;\n\n  /**\n   * Creates a JSON encoder that creates multi-line JSON.\n   *\n   * The encoding of elements of lists and maps are indented and put on separate\n   * lines. The [indent] string is prepended to these elements, once for each\n   * level of indentation.\n   *\n   * If [indent] is `null`, the output is encoded as a single line.\n   *\n   * The JSON encoder handles numbers, strings, booleans, null, lists and\n   * maps directly.\n   *\n   * Any other object is attempted converted by [toEncodable] to an\n   * object that is of one of the convertible types.\n   *\n   * If [toEncodable] is omitted, it defaults to calling `.toJson()` on\n   * the object.\n   */\n  const JsonEncoder.withIndent(this.indent,\n      [Object toEncodable(Object nonSerializable)])\n      : this._toEncodableFunction = toEncodable;\n\n  /**\n   * Converts [object] to a JSON [String].\n   *\n   * Directly serializable values are [num], [String], [bool], and [Null], as\n   * well as some [List] and [Map] values.\n   * For [List], the elements must all be serializable.\n   * For [Map], the keys must be [String] and the values must be serializable.\n   *\n   * If a value is any other type is attempted serialized, the conversion\n   * function provided in the constructor is invoked with the object as argument\n   * and the result, which must be a directly serializable value,\n   * is serialized instead of the original value.\n   *\n   * If the conversion throws, or returns a value that is not directly\n   * serializable, a [JsonUnsupportedObjectError] exception is thrown.\n   * If the call throws, the error is caught and stored in the\n   * [JsonUnsupportedObjectError]'s [:cause:] field.\n   *\n   * If a [List] or [Map] contains a reference to itself, directly or through\n   * other lists or maps, it cannot be serialized and a [JsonCyclicError] is\n   * thrown.\n   *\n   * [object] should not change during serialization.\n   *\n   * If an object is serialized more than once, [convert] may cache the text\n   * for it. In other words, if the content of an object changes after it is\n   * first serialized, the new values may not be reflected in the result.\n   */\n  String convert(Object object) =>\n      _JsonStringifier.stringify(object, _toEncodableFunction, indent);\n\n  /**\n   * Starts a chunked conversion.\n   *\n   * The converter works more efficiently if the given [sink] is a\n   * [StringConversionSink].\n   *\n   * Returns a chunked-conversion sink that accepts at most one object. It is\n   * an error to invoke `add` more than once on the returned sink.\n   */\n  ChunkedConversionSink<Object> startChunkedConversion(Sink<String> sink) {\n    if (sink is! StringConversionSink) {\n      sink = new StringConversionSink.from(sink);\n    }\n    return new _JsonEncoderSink(sink, _toEncodableFunction, indent);\n  }\n\n  // Override the base-classes bind, to provide a better type.\n  Stream<String> bind(Stream<Object> stream) => super.bind(stream);\n}\n\n/**\n * Implements the chunked conversion from object to its JSON representation.\n *\n * The sink only accepts one value, but will produce output in a chunked way.\n */\nclass _JsonEncoderSink extends ChunkedConversionSink<Object> {\n  final String _indent;\n  final Function _toEncodableFunction;\n  final StringConversionSink _sink;\n  bool _isDone = false;\n\n  _JsonEncoderSink(this._sink, this._toEncodableFunction, this._indent);\n\n  /**\n   * Encodes the given object [o].\n   *\n   * It is an error to invoke this method more than once on any instance. While\n   * this makes the input effectly non-chunked the output will be generated in\n   * a chunked way.\n   */\n  void add(Object o) {\n    if (_isDone) {\n      throw new StateError(\"Only one call to add allowed\");\n    }\n    _isDone = true;\n    ClosableStringSink stringSink = _sink.asStringSink();\n    _JsonStringifier.printOn(o, stringSink, _toEncodableFunction, _indent);\n    stringSink.close();\n  }\n\n  void close() { /* do nothing */ }\n}\n\n/**\n * This class parses JSON strings and builds the corresponding objects.\n */\nclass JsonDecoder extends Converter<String, Object> {\n  final _Reviver _reviver;\n  /**\n   * Constructs a new JsonDecoder.\n   *\n   * The [reviver] may be `null`.\n   */\n  const JsonDecoder([reviver(var key, var value)]) : this._reviver = reviver;\n\n  /**\n   * Converts the given JSON-string [input] to its corresponding object.\n   *\n   * Parsed JSON values are of the types [num], [String], [bool], [Null],\n   * [List]s of parsed JSON values or [Map]s from [String] to parsed\n   * JSON values.\n   *\n   * If `this` was initialized with a reviver, then the parsing operation\n   * invokes the reviver on every object or list property that has been parsed.\n   * The arguments are the property name ([String]) or list index ([int]), and\n   * the value is the parsed value. The return value of the reviver is used as\n   * the value of that property instead the parsed value.\n   *\n   * Throws [FormatException] if the input is not valid JSON text.\n   */\n  dynamic convert(String input) => _parseJson(input, _reviver);\n\n  /**\n   * Starts a conversion from a chunked JSON string to its corresponding\n   * object.\n   *\n   * The output [sink] receives exactly one decoded element through `add`.\n   */\n  StringConversionSink startChunkedConversion(Sink<Object> sink) {\n    return new _JsonDecoderSink(_reviver, sink);\n  }\n\n  // Override the base-classes bind, to provide a better type.\n  Stream<Object> bind(Stream<String> stream) => super.bind(stream);\n}\n\n/**\n * Implements the chunked conversion from a JSON string to its corresponding\n * object.\n *\n * The sink only creates one object, but its input can be chunked.\n */\n// TODO(floitsch): don't accumulate everything before starting to decode.\nclass _JsonDecoderSink extends _StringSinkConversionSink {\n  final _Reviver _reviver;\n  final Sink<Object> _sink;\n\n  _JsonDecoderSink(this._reviver, this._sink)\n      : super(new StringBuffer());\n\n  void close() {\n    super.close();\n    StringBuffer buffer = _stringSink;\n    String accumulated = buffer.toString();\n    buffer.clear();\n    Object decoded = _parseJson(accumulated, _reviver);\n    _sink.add(decoded);\n    _sink.close();\n  }\n}\n\n// Internal optimized JSON parsing implementation.\nexternal _parseJson(String source, reviver(key, value));\n\n\n// Implementation of encoder/stringifier.\n\nObject _defaultToEncodable(object) => object.toJson();\n\nclass _JsonStringifier {\n  // Character code constants.\n  static const int BACKSPACE       = 0x08;\n  static const int TAB             = 0x09;\n  static const int NEWLINE         = 0x0a;\n  static const int CARRIAGE_RETURN = 0x0d;\n  static const int FORM_FEED       = 0x0c;\n  static const int QUOTE           = 0x22;\n  static const int CHAR_0          = 0x30;\n  static const int BACKSLASH       = 0x5c;\n  static const int CHAR_b          = 0x62;\n  static const int CHAR_f          = 0x66;\n  static const int CHAR_n          = 0x6e;\n  static const int CHAR_r          = 0x72;\n  static const int CHAR_t          = 0x74;\n  static const int CHAR_u          = 0x75;\n\n  final Function _toEncodable;\n  final StringSink _sink;\n  final List _seen;\n\n  factory _JsonStringifier(StringSink sink, Function toEncodable,\n      String indent) {\n    if (indent == null) return new _JsonStringifier._(sink, toEncodable);\n    return new _JsonStringifierPretty(sink, toEncodable, indent);\n  }\n\n  _JsonStringifier._(this._sink, this._toEncodable)\n      : this._seen = new List();\n\n  static String stringify(object, toEncodable(object), String indent) {\n    if (toEncodable == null) toEncodable = _defaultToEncodable;\n    StringBuffer output = new StringBuffer();\n    printOn(object, output, toEncodable, indent);\n    return output.toString();\n  }\n\n  static void printOn(object, StringSink output, toEncodable(object),\n      String indent) {\n    new _JsonStringifier(output, toEncodable, indent).stringifyValue(object);\n  }\n\n  static String numberToString(num x) {\n    return x.toString();\n  }\n\n  // ('0' + x) or ('a' + x - 10)\n  static int hexDigit(int x) => x < 10 ? 48 + x : 87 + x;\n\n  void escape(String s) {\n    int offset = 0;\n    final int length = s.length;\n    for (int i = 0; i < length; i++) {\n      int charCode = s.codeUnitAt(i);\n      if (charCode > BACKSLASH) continue;\n      if (charCode < 32) {\n        if (i > offset) _sink.write(s.substring(offset, i));\n        offset = i + 1;\n        _sink.writeCharCode(BACKSLASH);\n        switch (charCode) {\n        case BACKSPACE:\n          _sink.writeCharCode(CHAR_b);\n          break;\n        case TAB:\n          _sink.writeCharCode(CHAR_t);\n          break;\n        case NEWLINE:\n          _sink.writeCharCode(CHAR_n);\n          break;\n        case FORM_FEED:\n          _sink.writeCharCode(CHAR_f);\n          break;\n        case CARRIAGE_RETURN:\n          _sink.writeCharCode(CHAR_r);\n          break;\n        default:\n          _sink.writeCharCode(CHAR_u);\n          _sink.writeCharCode(CHAR_0);\n          _sink.writeCharCode(CHAR_0);\n          _sink.writeCharCode(hexDigit((charCode >> 4) & 0xf));\n          _sink.writeCharCode(hexDigit(charCode & 0xf));\n          break;\n        }\n      } else if (charCode == QUOTE || charCode == BACKSLASH) {\n        if (i > offset) _sink.write(s.substring(offset, i));\n        offset = i + 1;\n        _sink.writeCharCode(BACKSLASH);\n        _sink.writeCharCode(charCode);\n      }\n    }\n    if (offset == 0) {\n      _sink.write(s);\n    } else if (offset < length) {\n      _sink.write(s.substring(offset, length));\n    }\n  }\n\n  void checkCycle(object) {\n    for (int i = 0; i < _seen.length; i++) {\n      if (identical(object, _seen[i])) {\n        throw new JsonCyclicError(object);\n      }\n    }\n    _seen.add(object);\n  }\n\n  void stringifyValue(object) {\n    // Tries stringifying object directly. If it's not a simple value, List or\n    // Map, call toJson() to get a custom representation and try serializing\n    // that.\n    if (!stringifyJsonValue(object)) {\n      checkCycle(object);\n      try {\n        var customJson = _toEncodable(object);\n        if (!stringifyJsonValue(customJson)) {\n          throw new JsonUnsupportedObjectError(object);\n        }\n        _removeSeen(object);\n      } catch (e) {\n        throw new JsonUnsupportedObjectError(object, cause: e);\n      }\n    }\n  }\n\n  /**\n   * Serializes a [num], [String], [bool], [Null], [List] or [Map] value.\n   *\n   * Returns true if the value is one of these types, and false if not.\n   * If a value is both a [List] and a [Map], it's serialized as a [List].\n   */\n  bool stringifyJsonValue(object) {\n    if (object is num) {\n      if (!object.isFinite) return false;\n      _sink.write(numberToString(object));\n      return true;\n    } else if (identical(object, true)) {\n      _sink.write('true');\n      return true;\n    } else if (identical(object, false)) {\n      _sink.write('false');\n       return true;\n    } else if (object == null) {\n      _sink.write('null');\n      return true;\n    } else if (object is String) {\n      _sink.write('\"');\n      escape(object);\n      _sink.write('\"');\n      return true;\n    } else if (object is List) {\n      checkCycle(object);\n      List a = object;\n      _sink.write('[');\n      if (a.length > 0) {\n        stringifyValue(a[0]);\n        for (int i = 1; i < a.length; i++) {\n          _sink.write(',');\n          stringifyValue(a[i]);\n        }\n      }\n      _sink.write(']');\n      _removeSeen(object);\n      return true;\n    } else if (object is Map) {\n      checkCycle(object);\n      Map<String, Object> m = object;\n      _sink.write('{');\n      String separator = '\"';\n      m.forEach((String key, value) {\n        _sink.write(separator);\n        separator = ',\"';\n        escape(key);\n        _sink.write('\":');\n        stringifyValue(value);\n      });\n      _sink.write('}');\n      _removeSeen(object);\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  void _removeSeen(object) {\n    assert(!_seen.isEmpty);\n    assert(identical(_seen.last, object));\n    _seen.removeLast();\n  }\n}\n\n/**\n * A subclass of [_JsonStringifier] which indents the contents of [List] and\n * [Map] objects using the specified indent value.\n */\nclass _JsonStringifierPretty extends _JsonStringifier {\n  final String _indent;\n\n  int _indentLevel = 0;\n\n  _JsonStringifierPretty(_sink, _toEncodable, this._indent)\n      : super._(_sink, _toEncodable);\n\n  void _write([String value = '']) {\n    _sink.write(_indent * _indentLevel);\n    _sink.write(value);\n  }\n\n  /**\n   * Serializes a [num], [String], [bool], [Null], [List] or [Map] value.\n   *\n   * Returns true if the value is one of these types, and false if not.\n   * If a value is both a [List] and a [Map], it's serialized as a [List].\n   */\n  bool stringifyJsonValue(final object) {\n    if (object is List) {\n      checkCycle(object);\n      List a = object;\n      if (a.isEmpty) {\n        _sink.write('[]');\n      } else {\n        _sink.writeln('[');\n        _indentLevel++;\n        _write();\n        stringifyValue(a[0]);\n        for (int i = 1; i < a.length; i++) {\n          _sink.writeln(',');\n          _write();\n          stringifyValue(a[i]);\n        }\n        _sink.writeln();\n        _indentLevel--;\n        _write(']');\n      }\n      _seen.remove(object);\n      return true;\n    } else if (object is Map) {\n      checkCycle(object);\n      Map<String, Object> m = object;\n      if (m.isEmpty) {\n        _sink.write('{}');\n      } else {\n        _sink.write('{');\n        _sink.writeln();\n        _indentLevel++;\n        bool first = true;\n        m.forEach((String key, Object value) {\n          if (!first) {\n            _sink.writeln(',');\n          }\n          _write('\"');\n          escape(key);\n          _sink.write('\": ');\n          stringifyValue(value);\n          first = false;\n        });\n        _sink.writeln();\n        _indentLevel--;\n        _write('}');\n      }\n      _seen.remove(object);\n      return true;\n    }\n    return super.stringifyJsonValue(object);\n  }\n}\n\u0000","sdk:/sdk/lib/convert/html_escape.dart":"// Copyright (c) 2013, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\npart of dart.convert;\n\n// TODO(floitsch) - Document - Issue 13097\nconst HtmlEscape HTML_ESCAPE = const HtmlEscape();\n\nclass HtmlEscapeMode {\n  final String _name;\n  final bool escapeLtGt;\n  final bool escapeQuot;\n  final bool escapeApos;\n  final bool escapeSlash;\n\n  // TODO(floitsch) - Document - Issue 13097\n  static const HtmlEscapeMode UNKNOWN =\n    const HtmlEscapeMode._('unknown', true, true, true, true);\n\n  // TODO(floitsch) - Document - Issue 13097\n  static const HtmlEscapeMode ATTRIBUTE =\n    const HtmlEscapeMode._('attribute', false, true, false, false);\n\n  // TODO(floitsch) - Document - Issue 13097\n  static const HtmlEscapeMode ELEMENT =\n    const HtmlEscapeMode._('element', true, false, false, true);\n\n  // TODO(floitsch) - Document - Issue 13097\n  const HtmlEscapeMode._(this._name, this.escapeLtGt, this.escapeQuot,\n    this.escapeApos, this.escapeSlash);\n\n  String toString() => _name;\n}\n\n  // TODO(floitsch) - Document - Issue 13097\nclass HtmlEscape extends Converter<String, String> {\n\n  // TODO(floitsch) - Document - Issue 13097\n  final HtmlEscapeMode mode;\n\n  // TODO(floitsch) - Document - Issue 13097\n  const HtmlEscape([this.mode = HtmlEscapeMode.UNKNOWN]);\n\n  String convert(String text) {\n    var val = _convert(text, 0, text.length);\n    return val == null ? text : val;\n  }\n\n  String _convert(String text, int start, int end) {\n    StringBuffer result = null;\n    for (int i = start; i < end; i++) {\n      var ch = text[i];\n      String replace = null;\n      switch (ch) {\n        case '&': replace = '&amp;'; break;\n        case '\\u00A0'/*NO-BREAK SPACE*/: replace = '&nbsp;'; break;\n        case '\"': if (mode.escapeQuot) replace = '&quot;'; break;\n        case \"'\": if (mode.escapeApos) replace = '&#x27;'; break;\n        case '<': if (mode.escapeLtGt) replace = '&lt;'; break;\n        case '>': if (mode.escapeLtGt) replace = '&gt;'; break;\n        case '/': if (mode.escapeSlash) replace = '&#x2F;'; break;\n      }\n      if (replace != null) {\n        if (result == null) result = new StringBuffer(text.substring(start, i));\n        result.write(replace);\n      } else if (result != null) {\n        result.write(ch);\n      }\n    }\n\n    return result != null ? result.toString() : null;\n  }\n\n  StringConversionSink startChunkedConversion(Sink<String> sink) {\n    if (sink is! StringConversionSink) {\n      sink = new StringConversionSink.from(sink);\n    }\n    return new _HtmlEscapeSink(this, sink);\n  }\n}\n\nclass _HtmlEscapeSink extends StringConversionSinkBase {\n  final HtmlEscape _escape;\n  final StringConversionSink _sink;\n\n  _HtmlEscapeSink(this._escape, this._sink);\n\n  void addSlice(String chunk, int start, int end, bool isLast) {\n    var val = _escape._convert(chunk, start, end);\n    if(val == null) {\n      _sink.addSlice(chunk, start, end, isLast);\n    } else {\n      _sink.add(val);\n      if (isLast) _sink.close();\n    }\n  }\n\n  void close() => _sink.close();\n}\n\u0000","sdk:/sdk/lib/convert/encoding.dart":"// Copyright (c) 2013, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\npart of dart.convert;\n\n/**\n * Open-ended Encoding enum.\n */\nabstract class Encoding extends Codec<String, List<int>> {\n  const Encoding();\n\n  Future<String> decodeStream(Stream<List<int>> byteStream) {\n    return byteStream\n      .transform(decoder)\n      .fold(new StringBuffer(), (buffer, string) => buffer..write(string))\n      .then((buffer) => buffer.toString());\n  }\n\n  /**\n   * Name of the encoding.\n   *\n   * If the encoding is standardized, this is the lower-case version of one of\n   * the IANA official names for the character set (see\n   * http://www.iana.org/assignments/character-sets/character-sets.xml)\n   */\n  String get name;\n\n  // All aliases (in lowercase) of supported encoding from\n  // http://www.iana.org/assignments/character-sets/character-sets.xml.\n  static Map<String, Encoding> _nameToEncoding = <String, Encoding> {\n    // ISO_8859-1:1987.\n    \"iso_8859-1:1987\": LATIN1,\n    \"iso-ir-100\": LATIN1,\n    \"iso_8859-1\": LATIN1,\n    \"iso-8859-1\": LATIN1,\n    \"latin1\": LATIN1,\n    \"l1\": LATIN1,\n    \"ibm819\": LATIN1,\n    \"cp819\": LATIN1,\n    \"csisolatin1\": LATIN1,\n\n    // US-ASCII.\n    \"iso-ir-6\": ASCII,\n    \"ansi_x3.4-1968\": ASCII,\n    \"ansi_x3.4-1986\": ASCII,\n    \"iso_646.irv:1991\": ASCII,\n    \"iso646-us\": ASCII,\n    \"us-ascii\": ASCII,\n    \"us\": ASCII,\n    \"ibm367\": ASCII,\n    \"cp367\": ASCII,\n    \"csascii\": ASCII,\n    \"ascii\": ASCII,  // This is not in the IANA official names.\n\n    // UTF-8.\n    \"csutf8\": UTF8,\n    \"utf-8\": UTF8\n  };\n\n  /**\n  * Gets an [Encoding] object from the name of the character set\n  * name. The names used are the IANA official names for the\n  * character set (see\n  * http://www.iana.org/assignments/character-sets/character-sets.xml).\n  *\n  * The [name] passed is case insensitive.\n  *\n  * If character set is not supported [:null:] is returned.\n  */\n  static Encoding getByName(String name) {\n      if (name == null) return null;\n      name = name.toLowerCase();\n      return _nameToEncoding[name];\n  }\n}\n\u0000","sdk:/sdk/lib/convert/converter.dart":"// Copyright (c) 2013, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\npart of dart.convert;\n\n/**\n * A [Converter] converts data from one representation into another.\n *\n * It is recommended that implementations of `Converter` extend this class,\n * to inherit any further methods that may be added to the class.\n */\nabstract class Converter<S, T> implements StreamTransformer {\n  const Converter();\n\n  /**\n   * Converts [input] and returns the result of the conversion.\n   */\n  T convert(S input);\n\n  /**\n   * Fuses `this` with [other].\n   *\n   * Encoding with the resulting converter is equivalent to converting with\n   * `this` before converting with `other`.\n   */\n  Converter<S, dynamic> fuse(Converter<T, dynamic> other) {\n    return new _FusedConverter<S, T, dynamic>(this, other);\n  }\n\n  /**\n   * Starts a chunked conversion.\n   */\n  ChunkedConversionSink startChunkedConversion(Sink sink) {\n    throw new UnsupportedError(\n        \"This converter does not support chunked conversions: $this\");\n  }\n\n  // Subclasses are encouraged to provide better types.\n  Stream bind(Stream source) {\n    return new Stream.eventTransformed(\n        source,\n        (EventSink sink) => new _ConverterStreamEventSink(this, sink));\n  }\n}\n\n/**\n * Fuses two converters.\n *\n * For a non-chunked conversion converts the input in sequence.\n */\nclass _FusedConverter<S, M, T> extends Converter<S, T> {\n  final Converter _first;\n  final Converter _second;\n\n  _FusedConverter(this._first, this._second);\n\n  T convert(S input) => _second.convert(_first.convert(input));\n\n  ChunkedConversionSink startChunkedConversion(Sink sink) {\n    return _first.startChunkedConversion(_second.startChunkedConversion(sink));\n  }\n}\n\u0000","sdk:/sdk/lib/convert/codec.dart":"// Copyright (c) 2013, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\npart of dart.convert;\n\n/**\n * A [Codec] encodes and (if supported) decodes data.\n *\n * Codecs can be fused. For example fusing [JSON] and [UTF8] produces\n * an encoder that can convert Json objects directly to bytes, or can decode\n * bytes directly to json objects.\n *\n * Fused codecs generally attempt to optimize the operations and can be faster\n * than executing each step of an encoding separately.\n *\n * *Codecs are still experimental and are subject to change without notice.*\n */\nabstract class Codec<S, T> {\n  const Codec();\n\n  T encode(S input) => encoder.convert(input);\n  S decode(T encoded) => decoder.convert(encoded);\n\n  /**\n   * Returns the encoder from [S] to [T].\n   *\n   * It may be stateful and should not be reused.\n   */\n  Converter<S, T> get encoder;\n  /**\n   * Returns the decoder of `this`, converting from [T] to [S].\n   *\n   * It may be stateful an should not be reused.\n   */\n  Converter<T, S> get decoder;\n\n  /**\n   * Fuses `this` with `other`.\n   *\n   * When encoding, the resulting codec encodes with `this` before\n   * encoding with [other].\n   *\n   * When decoding, the resulting codec decodes with [other] before decoding\n   * with `this`.\n   *\n   * In some cases one needs to use the [inverted] codecs to be able to fuse\n   * them correctly. That is, the output type of `this` ([T]) must match the\n   * input type of the second codec [other].\n   *\n   * Examples:\n   *\n   *     final JSON_TO_BYTES = JSON.fuse(UTF8);\n   *     List<int> bytes = JSON_TO_BYTES.encode([\"json-object\"]);\n   *     var decoded = JSON_TO_BYTES.decode(bytes);\n   *     assert(decoded is List && decoded[0] == \"json-object\");\n   *\n   *     var inverted = JSON.inverted;\n   *     var jsonIdentity = JSON.fuse(inverted);\n   *     var jsonObject = jsonIdentity.encode([\"1\", 2]);\n   *     assert(jsonObject is List && jsonObject[0] == \"1\" && jsonObject[1] == 2);\n   */\n  // TODO(floitsch): use better example with line-splitter once that one is\n  // in this library.\n  Codec<S, dynamic> fuse(Codec<T, dynamic> other) {\n    return new _FusedCodec<S, T, dynamic>(this, other);\n  }\n\n  /**\n   * Inverts `this`.\n   *\n   * The [encoder] and [decoder] of the resulting codec are swapped.\n   */\n  Codec<T, S> get inverted => new _InvertedCodec<T, S>(this);\n}\n\n/**\n * Fuses the given codecs.\n *\n * In the non-chunked conversion simply invokes the non-chunked conversions in\n * sequence.\n */\nclass _FusedCodec<S, M, T> extends Codec<S, T> {\n  final Codec<S, M> _first;\n  final Codec<M, T> _second;\n\n  Converter<S, T> get encoder => _first.encoder.fuse(_second.encoder);\n  Converter<T, S> get decoder => _second.decoder.fuse(_first.decoder);\n\n  _FusedCodec(this._first, this._second);\n}\n\nclass _InvertedCodec<T, S> extends Codec<T, S> {\n  final Codec<S, T> _codec;\n\n  _InvertedCodec(Codec<S, T> codec) : _codec = codec;\n\n  Converter<T, S> get encoder => _codec.decoder;\n  Converter<S, T> get decoder => _codec.encoder;\n\n  Codec<S, T> get inverted => _codec;\n}\u0000","sdk:/sdk/lib/convert/chunked_conversion.dart":"// Copyright (c) 2013, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\npart of dart.convert;\n\ntypedef void _ChunkedConversionCallback<T>(T accumulated);\n\n/**\n * A [ChunkedConversionSink] is used to transmit data more efficiently between\n * two converters during chunked conversions.\n *\n * The basic `ChunkedConversionSink` is just a [Sink], and converters should\n * work with a plain `Sink`, but may work more efficiently with certain\n * specialized types of `ChunkedConversionSink`.\n *\n * It is recommended that implementations of `ChunkedConversionSink` extends\n * this class, to inherit any further methods that may be added to the class.\n */\nabstract class ChunkedConversionSink<T> implements Sink<T> {\n  ChunkedConversionSink();\n  factory ChunkedConversionSink.withCallback(\n      void callback(List<T> accumulated)) = _SimpleCallbackSink;\n\n  /**\n   * Adds chunked data to this sink.\n   *\n   * This method is also used when converters are used as [StreamTransformer]s.\n   */\n  void add(T chunk);\n\n  /**\n   * Closes the sink.\n   *\n   * This signals the end of the chunked conversion. This method is called\n   * when converters are used as [StreamTransformer]'s.\n   */\n  void close();\n}\n\n/**\n * This class accumulates all chunks and invokes a callback with a list of\n * the chunks when the sink is closed.\n *\n * This class can be used to terminate a chunked conversion.\n */\nclass _SimpleCallbackSink<T> extends ChunkedConversionSink<T> {\n  final _ChunkedConversionCallback<List<T>> _callback;\n  final List<T> _accumulated = <T>[];\n\n  _SimpleCallbackSink(this._callback);\n\n  void add(T chunk) { _accumulated.add(chunk); }\n  void close() { _callback(_accumulated); }\n}\n\nclass _EventSinkAdapter<T> implements ChunkedConversionSink<T> {\n  final EventSink<T> _sink;\n\n  _EventSinkAdapter(this._sink);\n\n  void add(T data) => _sink.add(data);\n  void close() => _sink.close();\n}\n\n/**\n * This class converts implements the logic for a chunked conversion as a\n * stream transformer.\n *\n * It is used as strategy in the [EventTransformStream].\n *\n * It also implements the [ChunkedConversionSink] interface so that it\n * can be used as output sink in a chunked conversion.\n */\nclass _ConverterStreamEventSink<S, T> implements EventSink<S> {\n  /** The output sink for the converter. */\n  final EventSink<T> _eventSink;\n\n  /**\n   * The input sink for new data. All data that is received with\n   * [handleData] is added into this sink.\n   */\n  ChunkedConversionSink _chunkedSink;\n\n  _ConverterStreamEventSink(Converter converter, EventSink<T> sink)\n      : this._eventSink = sink,\n        _chunkedSink = converter.startChunkedConversion(sink);\n\n  void add(S o) => _chunkedSink.add(o);\n  void addError(Object error, [StackTrace stackTrace]) {\n    _eventSink.addError(error, stackTrace);\n  }\n  void close() => _chunkedSink.close();\n}\n\u0000","sdk:/sdk/lib/convert/byte_conversion.dart":"// Copyright (c) 2013, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\npart of dart.convert;\n\n/**\n * The [ByteConversionSink] provides an interface for converters to\n * efficiently transmit byte data.\n *\n * Instead of limiting the interface to one non-chunked list of bytes it\n * accepts its input in chunks (themselves being lists of bytes).\n *\n * This abstract class will likely get more methods over time. Implementers are\n * urged to extend or mix in [ByteConversionSinkBase] to ensure that their\n * class covers the newly added methods.\n */\nabstract class ByteConversionSink extends ChunkedConversionSink<List<int>> {\n  ByteConversionSink();\n  factory ByteConversionSink.withCallback(void callback(List<int> accumulated))\n      = _ByteCallbackSink;\n  factory ByteConversionSink.from(Sink<List<int>> sink)\n      = _ByteAdapterSink;\n\n  /**\n   * Adds the next [chunk] to `this`.\n   *\n   * Adds the bytes defined by [start] and [end]-exclusive to `this`.\n   *\n   * If [isLast] is `true` closes `this`.\n   *\n   * Contrary to `add` the given [chunk] must not be held onto. Once the method\n   * returns, it is safe to overwrite the data in it.\n   */\n  void addSlice(List<int> chunk, int start, int end, bool isLast);\n\n  // TODO(floitsch): add more methods:\n  // - iterateBytes.\n}\n\n/**\n * This class provides a base-class for converters that need to accept byte\n * inputs.\n */\nabstract class ByteConversionSinkBase extends ByteConversionSink {\n\n  void add(List<int> chunk);\n  void close();\n\n  void addSlice(List<int> chunk, int start, int end, bool isLast) {\n    add(chunk.sublist(start, end));\n    if (isLast) close();\n  }\n}\n\n/**\n * This class adapts a simple [Sink] to a [ByteConversionSink].\n *\n * All additional methods of the [ByteConversionSink] (compared to the\n * ChunkedConversionSink) are redirected to the `add` method.\n */\nclass _ByteAdapterSink extends ByteConversionSinkBase {\n  final Sink<List<int>> _sink;\n\n  _ByteAdapterSink(this._sink);\n\n  void add(List<int> chunk) => _sink.add(chunk);\n  void close() => _sink.close();\n}\n\n/**\n * This class accumulates all chunks into one list of bytes\n * and invokes a callback when the sink is closed.\n *\n * This class can be used to terminate a chunked conversion.\n */\nclass _ByteCallbackSink extends ByteConversionSinkBase {\n  static const _INITIAL_BUFFER_SIZE = 1024;\n\n  final _ChunkedConversionCallback<List<int>> _callback;\n  // TODO(11971, floitsch): use Uint8List instead of normal lists.\n  List<int> _buffer = new List<int>(_INITIAL_BUFFER_SIZE);\n  int _bufferIndex = 0;\n\n  _ByteCallbackSink(void callback(List<int> accumulated))\n      : this._callback = callback;\n\n  void add(Iterable<int> chunk) {\n    int freeCount = _buffer.length - _bufferIndex;\n    if (chunk.length > freeCount) {\n      // Grow the buffer.\n      int oldLength = _buffer.length;\n      int newLength = _roundToPowerOf2(chunk.length + oldLength) * 2;\n      // TODO(11971, floitsch): use Uint8List instead of normal lists.\n      List<int> grown = new List<int>(newLength);\n      grown.setRange(0, _buffer.length, _buffer);\n      _buffer = grown;\n    }\n    _buffer.setRange(_bufferIndex, _bufferIndex + chunk.length, chunk);\n    _bufferIndex += chunk.length;\n  }\n\n  static int _roundToPowerOf2(int v) {\n    assert(v > 0);\n    v--;\n    v |= v >> 1;\n    v |= v >> 2;\n    v |= v >> 4;\n    v |= v >> 8;\n    v |= v >> 16;\n    v++;\n    return v;\n  }\n\n  void close() {\n    _callback(_buffer.sublist(0, _bufferIndex));\n  }\n}\n\u0000","sdk:/sdk/lib/convert/ascii.dart":"// Copyright (c) 2013, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\npart of dart.convert;\n\n/**\n * An instance of the default implementation of the [AsciiCodec].\n *\n * This instance provides a convenient access to the most common ASCII\n * use cases.\n *\n * Examples:\n *\n *     var encoded = ASCII.encode(\"This is ASCII!\");\n *     var decoded = ASCII.decode([0x54, 0x68, 0x69, 0x73, 0x20, 0x69, 0x73,\n *                                 0x20, 0x41, 0x53, 0x43, 0x49, 0x49, 0x21]);\n */\nconst AsciiCodec ASCII = const AsciiCodec();\n\nconst int _ASCII_MASK = 0x7F;\n\n/**\n * An [AsciiCodec] allows encoding strings as ASCII bytes\n * and decoding ASCII bytes to strings.\n */\nclass AsciiCodec extends Encoding {\n  final bool _allowInvalid;\n  /**\n   * Instantiates a new [AsciiCodec].\n   *\n   * If [allowInvalid] is true, the [decode] method and the converter\n   * returned by [decoder] will default to allowing invalid values.\n   * If allowing invalid values, the values will be decoded into the Unicode\n   * Replacement character (U+FFFD). If not, an exception will be thrown.\n   * Calls to the [decode] method can choose to override this default.\n   *\n   * Encoders will not accept invalid (non Latin-1) characters.\n   */\n  const AsciiCodec({bool allowInvalid: false}) : _allowInvalid = allowInvalid;\n\n  String get name => \"us-ascii\";\n\n  /**\n   * Decodes the ASCII [bytes] (a list of unsigned 7-bit integers) to the\n   * corresponding string.\n   *\n   * If [bytes] contains values that are not in the range 0 .. 127, the decoder\n   * will eventually throw a [FormatException].\n   *\n   * If [allowInvalid] is not provided, it defaults to the value used to create\n   * this [AsciiCodec].\n   */\n  String decode(List<int> bytes, { bool allowInvalid }) {\n    if (allowInvalid == null) allowInvalid = _allowInvalid;\n    if (allowInvalid) {\n      return const AsciiDecoder(allowInvalid: true).convert(bytes);\n    } else {\n      return const AsciiDecoder(allowInvalid: false).convert(bytes);\n    }\n  }\n\n  Converter<String, List<int>> get encoder => const AsciiEncoder();\n\n  Converter<List<int>, String> get decoder =>\n      _allowInvalid ? const AsciiDecoder(allowInvalid: true)\n                    : const AsciiDecoder(allowInvalid: false);\n}\n\n// Superclass for [AsciiEncoder] and [Latin1Encoder].\n// Generalizes common operations that only differ by a mask;\nclass _UnicodeSubsetEncoder extends Converter<String, List<int>> {\n  final int _subsetMask;\n\n  const _UnicodeSubsetEncoder(this._subsetMask);\n\n  List<int> convert(String string) {\n    // TODO(11971): Use Uint8List when possible.\n    List result = new List<int>(string.length);\n    for (int i = 0; i < string.length; i++) {\n      var codeUnit = string.codeUnitAt(i);\n      if ((codeUnit & ~_subsetMask) != 0) {\n        throw new ArgumentError(\"String contains invalid characters.\");\n      }\n      result[i] = codeUnit;\n    }\n    return result;\n  }\n\n  /**\n   * Starts a chunked conversion.\n   *\n   * The converter works more efficiently if the given [sink] is a\n   * [ByteConversionSink].\n   */\n  StringConversionSink startChunkedConversion(Sink<List<int>> sink) {\n    if (sink is! ByteConversionSink) {\n      sink = new ByteConversionSink.from(sink);\n    }\n    return new _UnicodeSubsetEncoderSink(_subsetMask, sink);\n  }\n\n  // Override the base-class' bind, to provide a better type.\n  Stream<List<int>> bind(Stream<String> stream) => super.bind(stream);\n}\n\n/**\n * This class converts strings of only ASCII characters to bytes.\n */\nclass AsciiEncoder extends _UnicodeSubsetEncoder {\n  const AsciiEncoder() : super(_ASCII_MASK);\n}\n\n/**\n * This class encodes chunked strings to bytes (unsigned 8-bit\n * integers).\n */\nclass _UnicodeSubsetEncoderSink extends StringConversionSinkBase {\n  final ByteConversionSink _sink;\n  final int _subsetMask;\n\n  _UnicodeSubsetEncoderSink(this._subsetMask, this._sink);\n\n  void close() {\n    _sink.close();\n  }\n\n  void addSlice(String source, int start, int end, bool isLast) {\n    if (start < 0 || start > source.length) {\n      throw new RangeError.range(start, 0, source.length);\n    }\n    if (end < start || end > source.length) {\n      throw new RangeError.range(end, start, source.length);\n    }\n    for (int i = start; i < end; i++) {\n      int codeUnit = source.codeUnitAt(i);\n      if ((codeUnit & ~_subsetMask) != 0) {\n        throw new ArgumentError(\n            \"Source contains invalid character with code point: $codeUnit.\");\n      }\n    }\n    _sink.add(source.codeUnits.sublist(start, end));\n    if (isLast) {\n      close();\n    }\n  }\n}\n\n/**\n * This class converts Latin-1 bytes (lists of unsigned 8-bit integers)\n * to a string.\n */\nabstract class _UnicodeSubsetDecoder extends Converter<List<int>, String> {\n  final bool _allowInvalid;\n  final int _subsetMask;\n\n  /**\n   * Instantiates a new decoder.\n   *\n   * The [_allowInvalid] argument defines how [convert] deals\n   * with invalid bytes.\n   *\n   * The [_subsetMask] argument is a bit mask used to define the subset\n   * of Unicode being decoded. Use [_LATIN1_MASK] for Latin-1 (8-bit) or\n   * [_ASCII_MASK] for ASCII (7-bit).\n   *\n   * If [_allowInvalid] is `true`, [convert] replaces invalid bytes with the\n   * Unicode Replacement character `U+FFFD` (�).\n   * Otherwise it throws a [FormatException].\n   */\n  const _UnicodeSubsetDecoder(this._allowInvalid, this._subsetMask);\n\n  /**\n   * Converts the [bytes] (a list of unsigned 7- or 8-bit integers) to the\n   * corresponding string.\n   */\n  String convert(List<int> bytes) {\n    for (int i = 0; i < bytes.length; i++) {\n      int byte = bytes[i];\n      if ((byte & ~_subsetMask) != 0) {\n        if (!_allowInvalid) {\n          throw new FormatException(\"Invalid value in input: $byte\");\n        }\n        return _convertInvalid(bytes);\n      }\n    }\n    return new String.fromCharCodes(bytes);\n  }\n\n  String _convertInvalid(List<int> bytes) {\n    StringBuffer buffer = new StringBuffer();\n    for (int i = 0; i < bytes.length; i++) {\n      int value = bytes[i];\n      if ((value & ~_subsetMask) != 0) value = 0xFFFD;\n      buffer.writeCharCode(value);\n    }\n    return buffer.toString();\n  }\n\n  /**\n   * Starts a chunked conversion.\n   *\n   * The converter works more efficiently if the given [sink] is a\n   * [StringConversionSink].\n   */\n  ByteConversionSink startChunkedConversion(Sink<String> sink);\n\n  // Override the base-class's bind, to provide a better type.\n  Stream<String> bind(Stream<List<int>> stream) => super.bind(stream);\n}\n\nclass AsciiDecoder extends _UnicodeSubsetDecoder {\n  const AsciiDecoder({bool allowInvalid: false})\n      : super(allowInvalid, _ASCII_MASK);\n\n  /**\n   * Starts a chunked conversion.\n   *\n   * The converter works more efficiently if the given [sink] is a\n   * [StringConversionSink].\n   */\n  ByteConversionSink startChunkedConversion(Sink<String> sink) {\n    StringConversionSink stringSink;\n    if (sink is StringConversionSink) {\n      stringSink = sink;\n    } else {\n      stringSink = new StringConversionSink.from(sink);\n    }\n    // TODO(lrn): Use asUtf16Sink when it becomes available. It\n    // works just as well, is likely to have less decoding overhead,\n    // and make adding U+FFFD easier.\n    // At that time, merge this with _Latin1DecoderSink;\n    if (_allowInvalid) {\n      return new _ErrorHandlingAsciiDecoderSink(stringSink.asUtf8Sink(false));\n    } else {\n      return new _SimpleAsciiDecoderSink(stringSink);\n    }\n  }\n}\n\nclass _ErrorHandlingAsciiDecoderSink extends ByteConversionSinkBase {\n  ByteConversionSink _utf8Sink;\n  _ErrorHandlingAsciiDecoderSink(this._utf8Sink);\n\n  void close() {\n    _utf8Sink.close();\n  }\n\n  void add(List<int> source) {\n    addSlice(source, 0, source.length, false);\n  }\n\n  void addSlice(List<int> source, int start, int end, bool isLast) {\n    if (start < 0 || start > source.length) {\n      throw new RangeError.range(start, 0, source.length);\n    }\n    if (end < start || end > source.length) {\n      throw new RangeError.range(end, start, source.length);\n    }\n    for (int i = start; i < end; i++) {\n      if ((source[i] & ~_ASCII_MASK) != 0) {\n        if (i > start) _utf8Sink.addSlice(source, start, i, false);\n        // Add UTF-8 encoding of U+FFFD.\n        _utf8Sink.add(const<int>[0xEF, 0xBF, 0xBD]);\n        start = i + 1;\n      }\n    }\n    if (start < end) {\n      _utf8Sink.addSlice(source, start, end, isLast);\n    } else if (isLast) {\n      close();\n    }\n  }\n}\n\nclass _SimpleAsciiDecoderSink extends ByteConversionSinkBase {\n  Sink _sink;\n  _SimpleAsciiDecoderSink(this._sink);\n\n  void close() {\n    _sink.close();\n  }\n\n  void add(List<int> source) {\n    for (int i = 0; i < source.length; i++) {\n      if ((source[i] & ~_ASCII_MASK) != 0) {\n        throw new FormatException(\"Source contains non-ASCII bytes.\");\n      }\n    }\n    _sink.add(new String.fromCharCodes(source));\n  }\n\n  void addSlice(List<int> source, int start, int end, bool isLast) {\n    final int length = source.length;\n    if (start < 0 || start > length) {\n      throw new RangeError.range(start, 0, length - 1);\n    }\n    if (end < start || end > length) {\n      throw new RangeError.range(end, start, length - 1);\n    }\n    if (start < end) {\n      if (start != 0 || end != length) {\n        source = source.sublist(start, end);\n      }\n      add(source);\n    }\n    if (isLast) close();\n  }\n}\n\u0000","sdk:/sdk/lib/convert/convert.dart":"// Copyright (c) 2013, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n/**\n *\n * Encoders and decoders for converting between different data representations,\n * including JSON and UTF-8.\n *\n * In addition to converters for common data representations, this library\n * provides support for implementing converters in a way which makes them easy to\n * chain and to use with streams.\n *\n * The `dart:convert` library works in both web apps and command-line apps.\n * To use it:\n *\n *     import 'dart:convert';\n *\n * Two commonly used converters are the top-level instances of\n * [JsonCodec] and [Utf8Codec], named JSON and UTF8, respectively.\n *\n * JSON is a simple text format for representing\n * structured objects and collections.\n * The JSON encoder/decoder transforms between strings and\n * object structures, such as lists and maps, using the JSON format.\n *\n * UTF-8 is a common variable-width encoding that can represent\n * every character in the Unicode character set.\n * The UTF-8 encoder/decoder transforms between Strings and bytes.\n *\n * Converters are often used with streams\n * to transform the data that comes through the stream\n * as it becomes available.\n * The following code uses two converters.\n * The first is a UTF-8 decoder, which converts the data from bytes to UTF-8\n * as it's read from a file,\n * The second is an instance of [LineSplitter],\n * which splits the data on newline boundaries.\n *\n *     int lineNumber = 1;\n *     Stream<List<int>> stream = new File('quotes.txt').openRead();\n *\n *     stream.transform(UTF8.decoder)\n *           .transform(const LineSplitter())\n *           .listen((line) {\n *             if (showLineNumbers) {\n *               stdout.write('${lineNumber++} ');\n *             }\n *             stdout.writeln(line);\n *           });\n *\n * See the documentation for the [Codec] and [Converter] classes\n * for information about creating your own converters.\n */\nlibrary dart.convert;\n\nimport 'dart:async';\n\npart 'ascii.dart';\npart 'byte_conversion.dart';\npart 'chunked_conversion.dart';\npart 'codec.dart';\npart 'converter.dart';\npart 'encoding.dart';\npart 'html_escape.dart';\npart 'json.dart';\npart 'latin1.dart';\npart 'line_splitter.dart';\npart 'string_conversion.dart';\npart 'utf.dart';\n\u0000","sdk:/sdk/lib/html/dart2js/html_dart2js.dart":"/**\n * HTML elements and other resources for web-based applications that need to\n * interact with the browser and the DOM (Document Object Model).\n *\n * This library includes DOM element types, CSS styling, local storage,\n * media, speech, events, and more.\n * To get started,\n * check out the [Element] class, the base class for many of the HTML\n * DOM types.\n *\n * ## Other resources\n *\n * * If you've never written a web app before, try our\n * tutorials&mdash;[A Game of Darts](http://dartlang.org/docs/tutorials).\n *\n * * To see some web-based Dart apps in action and to play with the code,\n * download\n * [Dart Editor](http://www.dartlang.org/#get-started)\n * and run its built-in examples.\n *\n * * For even more examples, see\n * [Dart HTML5 Samples](https://github.com/dart-lang/dart-html5-samples)\n * on Github.\n */\nlibrary dart.dom.html;\n\nimport 'dart:async';\nimport 'dart:collection';\nimport 'dart:_internal' hide Symbol, deprecated;\nimport 'dart:html_common';\nimport 'dart:indexed_db';\nimport 'dart:isolate';\nimport \"dart:convert\";\nimport 'dart:math';\nimport 'dart:_native_typed_data';\nimport 'dart:typed_data';\nimport 'dart:svg' as svg;\nimport 'dart:svg' show Matrix;\nimport 'dart:svg' show SvgSvgElement;\nimport 'dart:web_audio' as web_audio;\nimport 'dart:web_gl' as gl;\nimport 'dart:web_sql';\nimport 'dart:_isolate_helper' show IsolateNatives;\nimport 'dart:_foreign_helper' show JS, JS_INTERCEPTOR_CONSTANT, JS_CONST;\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n// DO NOT EDIT - unless you are editing documentation as per:\n// https://code.google.com/p/dart/wiki/ContributingHTMLDocumentation\n// Auto-generated dart:html library.\n\n\n// Not actually used, but imported since dart:html can generate these objects.\nimport 'dart:_js_helper' show\n    convertDartClosureToJS, Creates, JavaScriptIndexingBehavior,\n    JSName, Native, Null, Returns,\n    findDispatchTagForInterceptorClass, setNativeSubclassDispatchRecord,\n    makeLeafDispatchRecord;\nimport 'dart:_interceptors' show\n    Interceptor, JSExtendableArray, findInterceptorConstructorForType,\n    findConstructorForNativeSubclassType, getNativeInterceptor,\n    setDispatchProperty;\n\nexport 'dart:math' show Rectangle, Point;\n\n\n\n\n\n/**\n * Top-level container for a web page, which is usually a browser tab or window.\n *\n * Each web page loaded in the browser has its own [Window], which is a\n * container for the web page.\n *\n * If the web page has any `<iframe>` elements, then each `<iframe>` has its own\n * [Window] object, which is accessible only to that `<iframe>`.\n *\n * See also:\n *\n *   * [Window](https://developer.mozilla.org/en-US/docs/Web/API/window) from MDN.\n */\nWindow get window => JS('Window', 'window');\n\n/**\n * Root node for all content in a web page.\n */\nHtmlDocument get document => JS('HtmlDocument', 'document');\n\n// Workaround for tags like <cite> that lack their own Element subclass --\n// Dart issue 1990.\n@Native(\"HTMLElement\")\nclass HtmlElement extends Element {\n  factory HtmlElement() { throw new UnsupportedError(\"Not supported\"); }\n\n  /**\n   * Constructor instantiated by the DOM when a custom element has been created.\n   *\n   * This can only be called by subclasses from their created constructor.\n   */\n  HtmlElement.created() : super.created();\n}\n\n// EntryArray type was removed, so explicitly adding it to allow support for\n// older Chrome versions.\n// Issue #12573.\n@Native(\"EntryArray\")\nabstract class _EntryArray implements List<Entry> {}\n\n/**\n * Spawn a DOM isolate using the given URI in the same window.\n * This isolate is not concurrent.  It runs on the browser thread\n * with full access to the DOM.\n * Note: this API is still evolving and may move to dart:isolate.\n */\n@Experimental()\nFuture<Isolate> spawnDomUri(Uri uri, List<String> args, message) {\n  // TODO(17738): Implement this.\n  throw new UnimplementedError();\n}\n// Copyright (c) 2013, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('AbstractWorker')\n@Native(\"AbstractWorker\")\nabstract class AbstractWorker extends Interceptor implements EventTarget {\n  // To suppress missing implicit constructor warnings.\n  factory AbstractWorker._() { throw new UnsupportedError(\"Not supported\"); }\n\n  /**\n   * Static factory designed to expose `error` events to event\n   * handlers that are not necessarily instances of [AbstractWorker].\n   *\n   * See [EventStreamProvider] for usage information.\n   */\n  @DomName('AbstractWorker.errorEvent')\n  @DocsEditable()\n  static const EventStreamProvider<ErrorEvent> errorEvent = const EventStreamProvider<ErrorEvent>('error');\n\n  /// Stream of `error` events handled by this [AbstractWorker].\n  @DomName('AbstractWorker.onerror')\n  @DocsEditable()\n  Stream<ErrorEvent> get onError => errorEvent.forTarget(this);\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('Algorithm')\n@Experimental() // untriaged\n@Native(\"Algorithm\")\nclass Algorithm extends Interceptor {\n  // To suppress missing implicit constructor warnings.\n  factory Algorithm._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('Algorithm.name')\n  @DocsEditable()\n  @Experimental() // untriaged\n  final String name;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('HTMLAnchorElement')\n@Native(\"HTMLAnchorElement\")\nclass AnchorElement extends HtmlElement implements UrlUtils {\n  // To suppress missing implicit constructor warnings.\n  factory AnchorElement._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('HTMLAnchorElement.HTMLAnchorElement')\n  @DocsEditable()\n  factory AnchorElement({String href}) {\n    var e = document.createElement(\"a\");\n    if (href != null) e.href = href;\n    return e;\n  }\n  /**\n   * Constructor instantiated by the DOM when a custom element has been created.\n   *\n   * This can only be called by subclasses from their created constructor.\n   */\n  AnchorElement.created() : super.created();\n\n  @DomName('HTMLAnchorElement.download')\n  @DocsEditable()\n  String download;\n\n  @DomName('HTMLAnchorElement.hreflang')\n  @DocsEditable()\n  String hreflang;\n\n  @DomName('HTMLAnchorElement.rel')\n  @DocsEditable()\n  String rel;\n\n  @DomName('HTMLAnchorElement.target')\n  @DocsEditable()\n  String target;\n\n  @DomName('HTMLAnchorElement.type')\n  @DocsEditable()\n  String type;\n\n  // From URLUtils\n\n  @DomName('HTMLAnchorElement.hash')\n  @DocsEditable()\n  String hash;\n\n  @DomName('HTMLAnchorElement.host')\n  @DocsEditable()\n  String host;\n\n  @DomName('HTMLAnchorElement.hostname')\n  @DocsEditable()\n  String hostname;\n\n  @DomName('HTMLAnchorElement.href')\n  @DocsEditable()\n  String href;\n\n  @DomName('HTMLAnchorElement.origin')\n  @DocsEditable()\n  // WebKit only\n  @Experimental() // non-standard\n  final String origin;\n\n  @DomName('HTMLAnchorElement.password')\n  @DocsEditable()\n  @Experimental() // untriaged\n  String password;\n\n  @DomName('HTMLAnchorElement.pathname')\n  @DocsEditable()\n  String pathname;\n\n  @DomName('HTMLAnchorElement.port')\n  @DocsEditable()\n  String port;\n\n  @DomName('HTMLAnchorElement.protocol')\n  @DocsEditable()\n  String protocol;\n\n  @DomName('HTMLAnchorElement.search')\n  @DocsEditable()\n  String search;\n\n  @DomName('HTMLAnchorElement.username')\n  @DocsEditable()\n  @Experimental() // untriaged\n  String username;\n\n  @DomName('HTMLAnchorElement.toString')\n  @DocsEditable()\n  String toString() native;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('Animation')\n@Experimental() // untriaged\n@Native(\"Animation\")\nclass Animation extends TimedItem {\n  // To suppress missing implicit constructor warnings.\n  factory Animation._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('Animation.Animation')\n  @DocsEditable()\n  factory Animation(Element target, List<Map> keyframes, [timingInput]) {\n    if ((timingInput is Map || timingInput == null) && (keyframes is List<Map> || keyframes == null) && (target is Element || target == null)) {\n      return Animation._create_1(target, keyframes, timingInput);\n    }\n    if ((timingInput is num || timingInput == null) && (keyframes is List<Map> || keyframes == null) && (target is Element || target == null)) {\n      return Animation._create_2(target, keyframes, timingInput);\n    }\n    if ((keyframes is List<Map> || keyframes == null) && (target is Element || target == null) && timingInput == null) {\n      return Animation._create_3(target, keyframes);\n    }\n    throw new ArgumentError(\"Incorrect number or type of arguments\");\n  }\n  static Animation _create_1(target, keyframes, timingInput) => JS('Animation', 'new Animation(#,#,#)', target, keyframes, timingInput);\n  static Animation _create_2(target, keyframes, timingInput) => JS('Animation', 'new Animation(#,#,#)', target, keyframes, timingInput);\n  static Animation _create_3(target, keyframes) => JS('Animation', 'new Animation(#,#)', target, keyframes);\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('WebKitAnimationEvent')\n@SupportedBrowser(SupportedBrowser.CHROME)\n@SupportedBrowser(SupportedBrowser.SAFARI)\n@Experimental()\n@Native(\"WebKitAnimationEvent\")\nclass AnimationEvent extends Event {\n  // To suppress missing implicit constructor warnings.\n  factory AnimationEvent._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('WebKitAnimationEvent.animationName')\n  @DocsEditable()\n  final String animationName;\n\n  @DomName('WebKitAnimationEvent.elapsedTime')\n  @DocsEditable()\n  final double elapsedTime;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n/**\n * ApplicationCache is accessed via [Window.applicationCache].\n */\n@DomName('ApplicationCache')\n@SupportedBrowser(SupportedBrowser.CHROME)\n@SupportedBrowser(SupportedBrowser.FIREFOX)\n@SupportedBrowser(SupportedBrowser.IE, '10')\n@SupportedBrowser(SupportedBrowser.OPERA)\n@SupportedBrowser(SupportedBrowser.SAFARI)\n@Unstable()\n@Native(\"ApplicationCache,DOMApplicationCache,OfflineResourceList\")\nclass ApplicationCache extends EventTarget {\n  // To suppress missing implicit constructor warnings.\n  factory ApplicationCache._() { throw new UnsupportedError(\"Not supported\"); }\n\n  /**\n   * Static factory designed to expose `cached` events to event\n   * handlers that are not necessarily instances of [ApplicationCache].\n   *\n   * See [EventStreamProvider] for usage information.\n   */\n  @DomName('ApplicationCache.cachedEvent')\n  @DocsEditable()\n  static const EventStreamProvider<Event> cachedEvent = const EventStreamProvider<Event>('cached');\n\n  /**\n   * Static factory designed to expose `checking` events to event\n   * handlers that are not necessarily instances of [ApplicationCache].\n   *\n   * See [EventStreamProvider] for usage information.\n   */\n  @DomName('ApplicationCache.checkingEvent')\n  @DocsEditable()\n  static const EventStreamProvider<Event> checkingEvent = const EventStreamProvider<Event>('checking');\n\n  /**\n   * Static factory designed to expose `downloading` events to event\n   * handlers that are not necessarily instances of [ApplicationCache].\n   *\n   * See [EventStreamProvider] for usage information.\n   */\n  @DomName('ApplicationCache.downloadingEvent')\n  @DocsEditable()\n  static const EventStreamProvider<Event> downloadingEvent = const EventStreamProvider<Event>('downloading');\n\n  /**\n   * Static factory designed to expose `error` events to event\n   * handlers that are not necessarily instances of [ApplicationCache].\n   *\n   * See [EventStreamProvider] for usage information.\n   */\n  @DomName('ApplicationCache.errorEvent')\n  @DocsEditable()\n  static const EventStreamProvider<Event> errorEvent = const EventStreamProvider<Event>('error');\n\n  /**\n   * Static factory designed to expose `noupdate` events to event\n   * handlers that are not necessarily instances of [ApplicationCache].\n   *\n   * See [EventStreamProvider] for usage information.\n   */\n  @DomName('ApplicationCache.noupdateEvent')\n  @DocsEditable()\n  static const EventStreamProvider<Event> noUpdateEvent = const EventStreamProvider<Event>('noupdate');\n\n  /**\n   * Static factory designed to expose `obsolete` events to event\n   * handlers that are not necessarily instances of [ApplicationCache].\n   *\n   * See [EventStreamProvider] for usage information.\n   */\n  @DomName('ApplicationCache.obsoleteEvent')\n  @DocsEditable()\n  static const EventStreamProvider<Event> obsoleteEvent = const EventStreamProvider<Event>('obsolete');\n\n  /**\n   * Static factory designed to expose `progress` events to event\n   * handlers that are not necessarily instances of [ApplicationCache].\n   *\n   * See [EventStreamProvider] for usage information.\n   */\n  @DomName('ApplicationCache.progressEvent')\n  @DocsEditable()\n  static const EventStreamProvider<ProgressEvent> progressEvent = const EventStreamProvider<ProgressEvent>('progress');\n\n  /**\n   * Static factory designed to expose `updateready` events to event\n   * handlers that are not necessarily instances of [ApplicationCache].\n   *\n   * See [EventStreamProvider] for usage information.\n   */\n  @DomName('ApplicationCache.updatereadyEvent')\n  @DocsEditable()\n  static const EventStreamProvider<Event> updateReadyEvent = const EventStreamProvider<Event>('updateready');\n\n  /// Checks if this type is supported on the current platform.\n  static bool get supported => JS('bool', '!!(window.applicationCache)');\n\n  @DomName('ApplicationCache.CHECKING')\n  @DocsEditable()\n  static const int CHECKING = 2;\n\n  @DomName('ApplicationCache.DOWNLOADING')\n  @DocsEditable()\n  static const int DOWNLOADING = 3;\n\n  @DomName('ApplicationCache.IDLE')\n  @DocsEditable()\n  static const int IDLE = 1;\n\n  @DomName('ApplicationCache.OBSOLETE')\n  @DocsEditable()\n  static const int OBSOLETE = 5;\n\n  @DomName('ApplicationCache.UNCACHED')\n  @DocsEditable()\n  static const int UNCACHED = 0;\n\n  @DomName('ApplicationCache.UPDATEREADY')\n  @DocsEditable()\n  static const int UPDATEREADY = 4;\n\n  @DomName('ApplicationCache.status')\n  @DocsEditable()\n  final int status;\n\n  @DomName('ApplicationCache.abort')\n  @DocsEditable()\n  void abort() native;\n\n  @DomName('ApplicationCache.swapCache')\n  @DocsEditable()\n  void swapCache() native;\n\n  @DomName('ApplicationCache.update')\n  @DocsEditable()\n  void update() native;\n\n  /// Stream of `cached` events handled by this [ApplicationCache].\n  @DomName('ApplicationCache.oncached')\n  @DocsEditable()\n  Stream<Event> get onCached => cachedEvent.forTarget(this);\n\n  /// Stream of `checking` events handled by this [ApplicationCache].\n  @DomName('ApplicationCache.onchecking')\n  @DocsEditable()\n  Stream<Event> get onChecking => checkingEvent.forTarget(this);\n\n  /// Stream of `downloading` events handled by this [ApplicationCache].\n  @DomName('ApplicationCache.ondownloading')\n  @DocsEditable()\n  Stream<Event> get onDownloading => downloadingEvent.forTarget(this);\n\n  /// Stream of `error` events handled by this [ApplicationCache].\n  @DomName('ApplicationCache.onerror')\n  @DocsEditable()\n  Stream<Event> get onError => errorEvent.forTarget(this);\n\n  /// Stream of `noupdate` events handled by this [ApplicationCache].\n  @DomName('ApplicationCache.onnoupdate')\n  @DocsEditable()\n  Stream<Event> get onNoUpdate => noUpdateEvent.forTarget(this);\n\n  /// Stream of `obsolete` events handled by this [ApplicationCache].\n  @DomName('ApplicationCache.onobsolete')\n  @DocsEditable()\n  Stream<Event> get onObsolete => obsoleteEvent.forTarget(this);\n\n  /// Stream of `progress` events handled by this [ApplicationCache].\n  @DomName('ApplicationCache.onprogress')\n  @DocsEditable()\n  Stream<ProgressEvent> get onProgress => progressEvent.forTarget(this);\n\n  /// Stream of `updateready` events handled by this [ApplicationCache].\n  @DomName('ApplicationCache.onupdateready')\n  @DocsEditable()\n  Stream<Event> get onUpdateReady => updateReadyEvent.forTarget(this);\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n/**\n * DOM Area Element, which links regions of an image map with a hyperlink.\n *\n * The element can also define an uninteractive region of the map.\n *\n * See also:\n *\n * * [<area>](https://developer.mozilla.org/en-US/docs/HTML/Element/area)\n * on MDN.\n */\n@DomName('HTMLAreaElement')\n@Native(\"HTMLAreaElement\")\nclass AreaElement extends HtmlElement implements UrlUtils {\n  // To suppress missing implicit constructor warnings.\n  factory AreaElement._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('HTMLAreaElement.HTMLAreaElement')\n  @DocsEditable()\n  factory AreaElement() => document.createElement(\"area\");\n  /**\n   * Constructor instantiated by the DOM when a custom element has been created.\n   *\n   * This can only be called by subclasses from their created constructor.\n   */\n  AreaElement.created() : super.created();\n\n  @DomName('HTMLAreaElement.alt')\n  @DocsEditable()\n  String alt;\n\n  @DomName('HTMLAreaElement.coords')\n  @DocsEditable()\n  String coords;\n\n  @DomName('HTMLAreaElement.shape')\n  @DocsEditable()\n  String shape;\n\n  @DomName('HTMLAreaElement.target')\n  @DocsEditable()\n  String target;\n\n  // From URLUtils\n\n  @DomName('HTMLAreaElement.hash')\n  @DocsEditable()\n  String hash;\n\n  @DomName('HTMLAreaElement.host')\n  @DocsEditable()\n  String host;\n\n  @DomName('HTMLAreaElement.hostname')\n  @DocsEditable()\n  String hostname;\n\n  @DomName('HTMLAreaElement.href')\n  @DocsEditable()\n  String href;\n\n  @DomName('HTMLAreaElement.origin')\n  @DocsEditable()\n  @Experimental() // untriaged\n  final String origin;\n\n  @DomName('HTMLAreaElement.password')\n  @DocsEditable()\n  @Experimental() // untriaged\n  String password;\n\n  @DomName('HTMLAreaElement.pathname')\n  @DocsEditable()\n  String pathname;\n\n  @DomName('HTMLAreaElement.port')\n  @DocsEditable()\n  String port;\n\n  @DomName('HTMLAreaElement.protocol')\n  @DocsEditable()\n  String protocol;\n\n  @DomName('HTMLAreaElement.search')\n  @DocsEditable()\n  String search;\n\n  @DomName('HTMLAreaElement.username')\n  @DocsEditable()\n  @Experimental() // untriaged\n  String username;\n\n  @DomName('HTMLAreaElement.toString')\n  @DocsEditable()\n  @Experimental() // untriaged\n  String toString() native;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('HTMLAudioElement')\n@Native(\"HTMLAudioElement\")\nclass AudioElement extends MediaElement {\n  // To suppress missing implicit constructor warnings.\n  factory AudioElement._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('HTMLAudioElement.HTMLAudioElement')\n  @DocsEditable()\n  factory AudioElement([String src]) {\n    if (src != null) {\n      return AudioElement._create_1(src);\n    }\n    return AudioElement._create_2();\n  }\n  static AudioElement _create_1(src) => JS('AudioElement', 'new Audio(#)', src);\n  static AudioElement _create_2() => JS('AudioElement', 'new Audio()');\n  /**\n   * Constructor instantiated by the DOM when a custom element has been created.\n   *\n   * This can only be called by subclasses from their created constructor.\n   */\n  AudioElement.created() : super.created();\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('AutocompleteErrorEvent')\n// http://wiki.whatwg.org/wiki/RequestAutocomplete\n@Experimental()\n@Native(\"AutocompleteErrorEvent\")\nclass AutocompleteErrorEvent extends Event {\n  // To suppress missing implicit constructor warnings.\n  factory AutocompleteErrorEvent._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('AutocompleteErrorEvent.reason')\n  @DocsEditable()\n  final String reason;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('HTMLBRElement')\n@Native(\"HTMLBRElement\")\nclass BRElement extends HtmlElement {\n  // To suppress missing implicit constructor warnings.\n  factory BRElement._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('HTMLBRElement.HTMLBRElement')\n  @DocsEditable()\n  factory BRElement() => document.createElement(\"br\");\n  /**\n   * Constructor instantiated by the DOM when a custom element has been created.\n   *\n   * This can only be called by subclasses from their created constructor.\n   */\n  BRElement.created() : super.created();\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('BarProp')\n// http://www.whatwg.org/specs/web-apps/current-work/multipage/browsers.html#barprop\n@deprecated // standard\n@Native(\"BarProp\")\nclass BarProp extends Interceptor {\n  // To suppress missing implicit constructor warnings.\n  factory BarProp._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('BarProp.visible')\n  @DocsEditable()\n  final bool visible;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('HTMLBaseElement')\n@Native(\"HTMLBaseElement\")\nclass BaseElement extends HtmlElement {\n  // To suppress missing implicit constructor warnings.\n  factory BaseElement._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('HTMLBaseElement.HTMLBaseElement')\n  @DocsEditable()\n  factory BaseElement() => document.createElement(\"base\");\n  /**\n   * Constructor instantiated by the DOM when a custom element has been created.\n   *\n   * This can only be called by subclasses from their created constructor.\n   */\n  BaseElement.created() : super.created();\n\n  @DomName('HTMLBaseElement.href')\n  @DocsEditable()\n  String href;\n\n  @DomName('HTMLBaseElement.target')\n  @DocsEditable()\n  String target;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('BeforeLoadEvent')\n@Experimental()\n@Native(\"BeforeLoadEvent\")\nclass BeforeLoadEvent extends Event {\n  // To suppress missing implicit constructor warnings.\n  factory BeforeLoadEvent._() { throw new UnsupportedError(\"Not supported\"); }\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('BeforeUnloadEvent')\n@Native(\"BeforeUnloadEvent\")\nclass BeforeUnloadEvent extends Event {\n  // To suppress missing implicit constructor warnings.\n  factory BeforeUnloadEvent._() { throw new UnsupportedError(\"Not supported\"); }\n\n  // Shadowing definition.\n  String get returnValue => JS(\"String\", \"#.returnValue\", this);\n\n  void set returnValue(String value) {\n    JS(\"void\", \"#.returnValue = #\", this, value);\n  }\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DomName('Blob')\n@Native(\"Blob\")\nclass Blob extends Interceptor {\n  // To suppress missing implicit constructor warnings.\n  factory Blob._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('Blob.size')\n  @DocsEditable()\n  final int size;\n\n  @DomName('Blob.type')\n  @DocsEditable()\n  final String type;\n\n  @DomName('Blob.slice')\n  @DocsEditable()\n  Blob slice([int start, int end, String contentType]) native;\n\n  factory Blob(List blobParts, [String type, String endings]) {\n    // TODO: validate that blobParts is a JS Array and convert if not.\n    // TODO: any coercions on the elements of blobParts, e.g. coerce a typed\n    // array to ArrayBuffer if it is a total view.\n    if (type == null && endings == null) {\n      return _create_1(blobParts);\n    }\n    var bag = _create_bag();\n    if (type != null) _bag_set(bag, 'type', type);\n    if (endings != null) _bag_set(bag, 'endings', endings);\n    return _create_2(blobParts, bag);\n  }\n\n  static _create_1(parts) => JS('Blob', 'new Blob(#)', parts);\n  static _create_2(parts, bag) => JS('Blob', 'new Blob(#, #)', parts, bag);\n\n  static _create_bag() => JS('var', '{}');\n  static _bag_set(bag, key, value) { JS('void', '#[#] = #', bag, key, value); }\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('HTMLBodyElement')\n@Native(\"HTMLBodyElement\")\nclass BodyElement extends HtmlElement implements WindowEventHandlers {\n  // To suppress missing implicit constructor warnings.\n  factory BodyElement._() { throw new UnsupportedError(\"Not supported\"); }\n\n  /**\n   * Static factory designed to expose `blur` events to event\n   * handlers that are not necessarily instances of [BodyElement].\n   *\n   * See [EventStreamProvider] for usage information.\n   */\n  @DomName('HTMLBodyElement.blurEvent')\n  @DocsEditable()\n  static const EventStreamProvider<Event> blurEvent = const EventStreamProvider<Event>('blur');\n\n  /**\n   * Static factory designed to expose `error` events to event\n   * handlers that are not necessarily instances of [BodyElement].\n   *\n   * See [EventStreamProvider] for usage information.\n   */\n  @DomName('HTMLBodyElement.errorEvent')\n  @DocsEditable()\n  static const EventStreamProvider<Event> errorEvent = const EventStreamProvider<Event>('error');\n\n  /**\n   * Static factory designed to expose `focus` events to event\n   * handlers that are not necessarily instances of [BodyElement].\n   *\n   * See [EventStreamProvider] for usage information.\n   */\n  @DomName('HTMLBodyElement.focusEvent')\n  @DocsEditable()\n  static const EventStreamProvider<Event> focusEvent = const EventStreamProvider<Event>('focus');\n\n  /**\n   * Static factory designed to expose `hashchange` events to event\n   * handlers that are not necessarily instances of [BodyElement].\n   *\n   * See [EventStreamProvider] for usage information.\n   */\n  @DomName('HTMLBodyElement.hashchangeEvent')\n  @DocsEditable()\n  static const EventStreamProvider<Event> hashChangeEvent = const EventStreamProvider<Event>('hashchange');\n\n  /**\n   * Static factory designed to expose `load` events to event\n   * handlers that are not necessarily instances of [BodyElement].\n   *\n   * See [EventStreamProvider] for usage information.\n   */\n  @DomName('HTMLBodyElement.loadEvent')\n  @DocsEditable()\n  static const EventStreamProvider<Event> loadEvent = const EventStreamProvider<Event>('load');\n\n  /**\n   * Static factory designed to expose `message` events to event\n   * handlers that are not necessarily instances of [BodyElement].\n   *\n   * See [EventStreamProvider] for usage information.\n   */\n  @DomName('HTMLBodyElement.messageEvent')\n  @DocsEditable()\n  static const EventStreamProvider<MessageEvent> messageEvent = const EventStreamProvider<MessageEvent>('message');\n\n  /**\n   * Static factory designed to expose `offline` events to event\n   * handlers that are not necessarily instances of [BodyElement].\n   *\n   * See [EventStreamProvider] for usage information.\n   */\n  @DomName('HTMLBodyElement.offlineEvent')\n  @DocsEditable()\n  static const EventStreamProvider<Event> offlineEvent = const EventStreamProvider<Event>('offline');\n\n  /**\n   * Static factory designed to expose `online` events to event\n   * handlers that are not necessarily instances of [BodyElement].\n   *\n   * See [EventStreamProvider] for usage information.\n   */\n  @DomName('HTMLBodyElement.onlineEvent')\n  @DocsEditable()\n  static const EventStreamProvider<Event> onlineEvent = const EventStreamProvider<Event>('online');\n\n  /**\n   * Static factory designed to expose `popstate` events to event\n   * handlers that are not necessarily instances of [BodyElement].\n   *\n   * See [EventStreamProvider] for usage information.\n   */\n  @DomName('HTMLBodyElement.popstateEvent')\n  @DocsEditable()\n  static const EventStreamProvider<PopStateEvent> popStateEvent = const EventStreamProvider<PopStateEvent>('popstate');\n\n  /**\n   * Static factory designed to expose `resize` events to event\n   * handlers that are not necessarily instances of [BodyElement].\n   *\n   * See [EventStreamProvider] for usage information.\n   */\n  @DomName('HTMLBodyElement.resizeEvent')\n  @DocsEditable()\n  static const EventStreamProvider<Event> resizeEvent = const EventStreamProvider<Event>('resize');\n\n  @DomName('HTMLBodyElement.scrollEvent')\n  @DocsEditable()\n  @Experimental() // untriaged\n  static const EventStreamProvider<Event> scrollEvent = const EventStreamProvider<Event>('scroll');\n\n  /**\n   * Static factory designed to expose `storage` events to event\n   * handlers that are not necessarily instances of [BodyElement].\n   *\n   * See [EventStreamProvider] for usage information.\n   */\n  @DomName('HTMLBodyElement.storageEvent')\n  @DocsEditable()\n  static const EventStreamProvider<StorageEvent> storageEvent = const EventStreamProvider<StorageEvent>('storage');\n\n  /**\n   * Static factory designed to expose `unload` events to event\n   * handlers that are not necessarily instances of [BodyElement].\n   *\n   * See [EventStreamProvider] for usage information.\n   */\n  @DomName('HTMLBodyElement.unloadEvent')\n  @DocsEditable()\n  static const EventStreamProvider<Event> unloadEvent = const EventStreamProvider<Event>('unload');\n\n  @DomName('HTMLBodyElement.HTMLBodyElement')\n  @DocsEditable()\n  factory BodyElement() => document.createElement(\"body\");\n  /**\n   * Constructor instantiated by the DOM when a custom element has been created.\n   *\n   * This can only be called by subclasses from their created constructor.\n   */\n  BodyElement.created() : super.created();\n\n  /// Stream of `blur` events handled by this [BodyElement].\n  @DomName('HTMLBodyElement.onblur')\n  @DocsEditable()\n  ElementStream<Event> get onBlur => blurEvent.forElement(this);\n\n  /// Stream of `error` events handled by this [BodyElement].\n  @DomName('HTMLBodyElement.onerror')\n  @DocsEditable()\n  ElementStream<Event> get onError => errorEvent.forElement(this);\n\n  /// Stream of `focus` events handled by this [BodyElement].\n  @DomName('HTMLBodyElement.onfocus')\n  @DocsEditable()\n  ElementStream<Event> get onFocus => focusEvent.forElement(this);\n\n  /// Stream of `hashchange` events handled by this [BodyElement].\n  @DomName('HTMLBodyElement.onhashchange')\n  @DocsEditable()\n  ElementStream<Event> get onHashChange => hashChangeEvent.forElement(this);\n\n  /// Stream of `load` events handled by this [BodyElement].\n  @DomName('HTMLBodyElement.onload')\n  @DocsEditable()\n  ElementStream<Event> get onLoad => loadEvent.forElement(this);\n\n  /// Stream of `message` events handled by this [BodyElement].\n  @DomName('HTMLBodyElement.onmessage')\n  @DocsEditable()\n  ElementStream<MessageEvent> get onMessage => messageEvent.forElement(this);\n\n  /// Stream of `offline` events handled by this [BodyElement].\n  @DomName('HTMLBodyElement.onoffline')\n  @DocsEditable()\n  ElementStream<Event> get onOffline => offlineEvent.forElement(this);\n\n  /// Stream of `online` events handled by this [BodyElement].\n  @DomName('HTMLBodyElement.ononline')\n  @DocsEditable()\n  ElementStream<Event> get onOnline => onlineEvent.forElement(this);\n\n  /// Stream of `popstate` events handled by this [BodyElement].\n  @DomName('HTMLBodyElement.onpopstate')\n  @DocsEditable()\n  ElementStream<PopStateEvent> get onPopState => popStateEvent.forElement(this);\n\n  /// Stream of `resize` events handled by this [BodyElement].\n  @DomName('HTMLBodyElement.onresize')\n  @DocsEditable()\n  ElementStream<Event> get onResize => resizeEvent.forElement(this);\n\n  @DomName('HTMLBodyElement.onscroll')\n  @DocsEditable()\n  @Experimental() // untriaged\n  ElementStream<Event> get onScroll => scrollEvent.forElement(this);\n\n  /// Stream of `storage` events handled by this [BodyElement].\n  @DomName('HTMLBodyElement.onstorage')\n  @DocsEditable()\n  ElementStream<StorageEvent> get onStorage => storageEvent.forElement(this);\n\n  /// Stream of `unload` events handled by this [BodyElement].\n  @DomName('HTMLBodyElement.onunload')\n  @DocsEditable()\n  ElementStream<Event> get onUnload => unloadEvent.forElement(this);\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('HTMLButtonElement')\n@Native(\"HTMLButtonElement\")\nclass ButtonElement extends HtmlElement {\n  // To suppress missing implicit constructor warnings.\n  factory ButtonElement._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('HTMLButtonElement.HTMLButtonElement')\n  @DocsEditable()\n  factory ButtonElement() => document.createElement(\"button\");\n  /**\n   * Constructor instantiated by the DOM when a custom element has been created.\n   *\n   * This can only be called by subclasses from their created constructor.\n   */\n  ButtonElement.created() : super.created();\n\n  @DomName('HTMLButtonElement.autofocus')\n  @DocsEditable()\n  bool autofocus;\n\n  @DomName('HTMLButtonElement.disabled')\n  @DocsEditable()\n  bool disabled;\n\n  @DomName('HTMLButtonElement.form')\n  @DocsEditable()\n  final FormElement form;\n\n  @DomName('HTMLButtonElement.formAction')\n  @DocsEditable()\n  String formAction;\n\n  @DomName('HTMLButtonElement.formEnctype')\n  @DocsEditable()\n  String formEnctype;\n\n  @DomName('HTMLButtonElement.formMethod')\n  @DocsEditable()\n  String formMethod;\n\n  @DomName('HTMLButtonElement.formNoValidate')\n  @DocsEditable()\n  bool formNoValidate;\n\n  @DomName('HTMLButtonElement.formTarget')\n  @DocsEditable()\n  String formTarget;\n\n  @DomName('HTMLButtonElement.labels')\n  @DocsEditable()\n  @Unstable()\n  @Returns('NodeList')\n  @Creates('NodeList')\n  final List<Node> labels;\n\n  @DomName('HTMLButtonElement.name')\n  @DocsEditable()\n  String name;\n\n  @DomName('HTMLButtonElement.type')\n  @DocsEditable()\n  String type;\n\n  @DomName('HTMLButtonElement.validationMessage')\n  @DocsEditable()\n  final String validationMessage;\n\n  @DomName('HTMLButtonElement.validity')\n  @DocsEditable()\n  final ValidityState validity;\n\n  @DomName('HTMLButtonElement.value')\n  @DocsEditable()\n  String value;\n\n  @DomName('HTMLButtonElement.willValidate')\n  @DocsEditable()\n  final bool willValidate;\n\n  @DomName('HTMLButtonElement.checkValidity')\n  @DocsEditable()\n  bool checkValidity() native;\n\n  @DomName('HTMLButtonElement.setCustomValidity')\n  @DocsEditable()\n  void setCustomValidity(String error) native;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('CDATASection')\n// http://dom.spec.whatwg.org/#cdatasection\n@deprecated // deprecated\n@Native(\"CDATASection\")\nclass CDataSection extends Text {\n  // To suppress missing implicit constructor warnings.\n  factory CDataSection._() { throw new UnsupportedError(\"Not supported\"); }\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('Canvas2DContextAttributes')\n// http://wiki.whatwg.org/wiki/CanvasOpaque#Suggested_IDL\n@Experimental()\n@Native(\"Canvas2DContextAttributes\")\nclass Canvas2DContextAttributes extends Interceptor {\n  // To suppress missing implicit constructor warnings.\n  factory Canvas2DContextAttributes._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('Canvas2DContextAttributes.alpha')\n  @DocsEditable()\n  bool alpha;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DomName('HTMLCanvasElement')\n@Native(\"HTMLCanvasElement\")\nclass CanvasElement extends HtmlElement implements CanvasImageSource {\n  // To suppress missing implicit constructor warnings.\n  factory CanvasElement._() { throw new UnsupportedError(\"Not supported\"); }\n\n  /**\n   * Static factory designed to expose `webglcontextlost` events to event\n   * handlers that are not necessarily instances of [CanvasElement].\n   *\n   * See [EventStreamProvider] for usage information.\n   */\n  @DomName('HTMLCanvasElement.webglcontextlostEvent')\n  @DocsEditable()\n  static const EventStreamProvider<gl.ContextEvent> webGlContextLostEvent = const EventStreamProvider<gl.ContextEvent>('webglcontextlost');\n\n  /**\n   * Static factory designed to expose `webglcontextrestored` events to event\n   * handlers that are not necessarily instances of [CanvasElement].\n   *\n   * See [EventStreamProvider] for usage information.\n   */\n  @DomName('HTMLCanvasElement.webglcontextrestoredEvent')\n  @DocsEditable()\n  static const EventStreamProvider<gl.ContextEvent> webGlContextRestoredEvent = const EventStreamProvider<gl.ContextEvent>('webglcontextrestored');\n\n  @DomName('HTMLCanvasElement.HTMLCanvasElement')\n  @DocsEditable()\n  factory CanvasElement({int width, int height}) {\n    var e = document.createElement(\"canvas\");\n    if (width != null) e.width = width;\n    if (height != null) e.height = height;\n    return e;\n  }\n  /**\n   * Constructor instantiated by the DOM when a custom element has been created.\n   *\n   * This can only be called by subclasses from their created constructor.\n   */\n  CanvasElement.created() : super.created();\n\n  /// The height of this canvas element in CSS pixels.\n  @DomName('HTMLCanvasElement.height')\n  @DocsEditable()\n  int height;\n\n  /// The width of this canvas element in CSS pixels.\n  @DomName('HTMLCanvasElement.width')\n  @DocsEditable()\n  int width;\n\n  @DomName('HTMLCanvasElement.getContext')\n  @DocsEditable()\n  CanvasRenderingContext getContext(String contextId, [Map attrs]) {\n    if (attrs != null) {\n      var attrs_1 = convertDartToNative_Dictionary(attrs);\n      return _getContext_1(contextId, attrs_1);\n    }\n    return _getContext_2(contextId);\n  }\n  @JSName('getContext')\n  @DomName('HTMLCanvasElement.getContext')\n  @DocsEditable()\n  CanvasRenderingContext _getContext_1(contextId, attrs) native;\n  @JSName('getContext')\n  @DomName('HTMLCanvasElement.getContext')\n  @DocsEditable()\n  CanvasRenderingContext _getContext_2(contextId) native;\n\n  @JSName('toDataURL')\n  @DomName('HTMLCanvasElement.toDataURL')\n  @DocsEditable()\n  String _toDataUrl(String type, [num quality]) native;\n\n  /// Stream of `webglcontextlost` events handled by this [CanvasElement].\n  @DomName('HTMLCanvasElement.onwebglcontextlost')\n  @DocsEditable()\n  ElementStream<gl.ContextEvent> get onWebGlContextLost => webGlContextLostEvent.forElement(this);\n\n  /// Stream of `webglcontextrestored` events handled by this [CanvasElement].\n  @DomName('HTMLCanvasElement.onwebglcontextrestored')\n  @DocsEditable()\n  ElementStream<gl.ContextEvent> get onWebGlContextRestored => webGlContextRestoredEvent.forElement(this);\n\n  /** An API for drawing on this canvas. */\n  CanvasRenderingContext2D get context2D =>\n      JS('Null|CanvasRenderingContext2D', '#.getContext(#)', this, '2d');\n\n  /**\n   * Returns a new Web GL context for this canvas.\n   *\n   * ## Other resources\n   *\n   * * [WebGL fundamentals]\n   * (http://www.html5rocks.com/en/tutorials/webgl/webgl_fundamentals/) from\n   * HTML5Rocks.\n   * * [WebGL homepage] (http://get.webgl.org/).\n   */\n  @SupportedBrowser(SupportedBrowser.CHROME)\n  @SupportedBrowser(SupportedBrowser.FIREFOX)\n  @Experimental()\n  gl.RenderingContext getContext3d({alpha: true, depth: true, stencil: false,\n    antialias: true, premultipliedAlpha: true, preserveDrawingBuffer: false}) {\n\n    var options = {\n      'alpha': alpha,\n      'depth': depth,\n      'stencil': stencil,\n      'antialias': antialias,\n      'premultipliedAlpha': premultipliedAlpha,\n      'preserveDrawingBuffer': preserveDrawingBuffer,\n    };\n    var context = getContext('webgl', options);\n    if (context == null) {\n      context = getContext('experimental-webgl', options);\n    }\n    return context;\n  }\n\n  /**\n   * Returns a data URI containing a representation of the image in the\n   * format specified by type (defaults to 'image/png').\n   *\n   * Data Uri format is as follow\n   * `data:[<MIME-type>][;charset=<encoding>][;base64],<data>`\n   *\n   * Optional parameter [quality] in the range of 0.0 and 1.0 can be used when\n   * requesting [type] 'image/jpeg' or 'image/webp'. If [quality] is not passed\n   * the default value is used. Note: the default value varies by browser.\n   *\n   * If the height or width of this canvas element is 0, then 'data:' is\n   * returned, representing no data.\n   *\n   * If the type requested is not 'image/png', and the returned value is\n   * 'data:image/png', then the requested type is not supported.\n   *\n   * Example usage:\n   *\n   *     CanvasElement canvas = new CanvasElement();\n   *     var ctx = canvas.context2D\n   *     ..fillStyle = \"rgb(200,0,0)\"\n   *     ..fillRect(10, 10, 55, 50);\n   *     var dataUrl = canvas.toDataUrl(\"image/jpeg\", 0.95);\n   *     // The Data Uri would look similar to\n   *     // 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUA\n   *     // AAAFCAYAAACNbyblAAAAHElEQVQI12P4//8/w38GIAXDIBKE0DHxgljNBAAO\n   *     // 9TXL0Y4OHwAAAABJRU5ErkJggg=='\n   *     //Create a new image element from the data URI.\n   *     var img = new ImageElement();\n   *     img.src = dataUrl;\n   *     document.body.children.add(img);\n   *\n   * See also:\n   *\n   * * [Data URI Scheme](http://en.wikipedia.org/wiki/Data_URI_scheme) from Wikipedia.\n   *\n   * * [HTMLCanvasElement](https://developer.mozilla.org/en-US/docs/DOM/HTMLCanvasElement) from MDN.\n   *\n   * * [toDataUrl](http://dev.w3.org/html5/spec/the-canvas-element.html#dom-canvas-todataurl) from W3C.\n   */\n  String toDataUrl([String type = 'image/png', num quality]) =>\n      _toDataUrl(type, quality);\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n/**\n * An opaque canvas object representing a gradient.\n *\n * Created by calling [createLinearGradient] or [createRadialGradient] on a\n * [CanvasRenderingContext2D] object.\n *\n * Example usage:\n *\n *     var canvas = new CanvasElement(width: 600, height: 600);\n *     var ctx = canvas.context2D;\n *     ctx.clearRect(0, 0, 600, 600);\n *     ctx.save();\n *     // Create radial gradient.\n *     CanvasGradient gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, 600);\n *     gradient.addColorStop(0, '#000');\n *     gradient.addColorStop(1, 'rgb(255, 255, 255)');\n *     // Assign gradients to fill.\n *     ctx.fillStyle = gradient;\n *     // Draw a rectangle with a gradient fill.\n *     ctx.fillRect(0, 0, 600, 600);\n *     ctx.save();\n *     document.body.children.add(canvas);\n *\n * See also:\n *\n * * [CanvasGradient](https://developer.mozilla.org/en-US/docs/DOM/CanvasGradient) from MDN.\n * * [CanvasGradient](http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#canvasgradient) from whatwg.\n * * [CanvasGradient](http://www.w3.org/TR/2010/WD-2dcontext-20100304/#canvasgradient) from W3C.\n */\n@DomName('CanvasGradient')\n@Native(\"CanvasGradient\")\nclass CanvasGradient extends Interceptor {\n  // To suppress missing implicit constructor warnings.\n  factory CanvasGradient._() { throw new UnsupportedError(\"Not supported\"); }\n\n  /**\n   * Adds a color stop to this gradient at the offset.\n   *\n   * The [offset] can range between 0.0 and 1.0.\n   *\n   * See also:\n   *\n   * * [Multiple Color Stops](https://developer.mozilla.org/en-US/docs/CSS/linear-gradient#Gradient_with_multiple_color_stops) from MDN.\n   */\n  @DomName('CanvasGradient.addColorStop')\n  @DocsEditable()\n  void addColorStop(num offset, String color) native;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n/**\n * An opaque object representing a pattern of image, canvas, or video.\n *\n * Created by calling [createPattern] on a [CanvasRenderingContext2D] object.\n *\n * Example usage:\n *\n *     var canvas = new CanvasElement(width: 600, height: 600);\n *     var ctx = canvas.context2D;\n *     var img = new ImageElement();\n *     // Image src needs to be loaded before pattern is applied.\n *     img.onLoad.listen((event) {\n *       // When the image is loaded, create a pattern\n *       // from the ImageElement.\n *       CanvasPattern pattern = ctx.createPattern(img, 'repeat');\n *       ctx.rect(0, 0, canvas.width, canvas.height);\n *       ctx.fillStyle = pattern;\n *       ctx.fill();\n *     });\n *     img.src = \"images/foo.jpg\";\n *     document.body.children.add(canvas);\n *\n * See also:\n * * [CanvasPattern](https://developer.mozilla.org/en-US/docs/DOM/CanvasPattern) from MDN.\n * * [CanvasPattern](http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#canvaspattern) from whatwg.\n * * [CanvasPattern](http://www.w3.org/TR/2010/WD-2dcontext-20100304/#canvaspattern) from W3C.\n */\n@DomName('CanvasPattern')\n@Native(\"CanvasPattern\")\nclass CanvasPattern extends Interceptor {\n  // To suppress missing implicit constructor warnings.\n  factory CanvasPattern._() { throw new UnsupportedError(\"Not supported\"); }\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n/**\n * A rendering context for a canvas element.\n *\n * This context is extended by [CanvasRenderingContext2D] and\n * [WebGLRenderingContext].\n */\n@DomName('CanvasRenderingContext')\n@Native(\"CanvasRenderingContext\")\nclass CanvasRenderingContext extends Interceptor {\n  // To suppress missing implicit constructor warnings.\n  factory CanvasRenderingContext._() { throw new UnsupportedError(\"Not supported\"); }\n\n  /// Reference to the canvas element to which this context belongs.\n  @DomName('CanvasRenderingContext.canvas')\n  @DocsEditable()\n  final CanvasElement canvas;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DomName('CanvasRenderingContext2D')\n@Native(\"CanvasRenderingContext2D\")\nclass CanvasRenderingContext2D extends CanvasRenderingContext {\n  // To suppress missing implicit constructor warnings.\n  factory CanvasRenderingContext2D._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('CanvasRenderingContext2D.currentTransform')\n  @DocsEditable()\n  @Experimental() // untriaged\n  Matrix currentTransform;\n\n  @DomName('CanvasRenderingContext2D.fillStyle')\n  @DocsEditable()\n  @Creates('String|CanvasGradient|CanvasPattern')\n  @Returns('String|CanvasGradient|CanvasPattern')\n  Object fillStyle;\n\n  @DomName('CanvasRenderingContext2D.font')\n  @DocsEditable()\n  String font;\n\n  @DomName('CanvasRenderingContext2D.globalAlpha')\n  @DocsEditable()\n  num globalAlpha;\n\n  @DomName('CanvasRenderingContext2D.globalCompositeOperation')\n  @DocsEditable()\n  String globalCompositeOperation;\n\n  /**\n   * Whether images and patterns on this canvas will be smoothed when this\n   * canvas is scaled.\n   *\n   * ## Other resources\n   *\n   * * [Image smoothing]\n   * (http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#image-smoothing)\n   * from WHATWG.\n   */\n  @DomName('CanvasRenderingContext2D.imageSmoothingEnabled')\n  @DocsEditable()\n  @Experimental() // untriaged\n  bool imageSmoothingEnabled;\n\n  @DomName('CanvasRenderingContext2D.lineCap')\n  @DocsEditable()\n  String lineCap;\n\n  @DomName('CanvasRenderingContext2D.lineJoin')\n  @DocsEditable()\n  String lineJoin;\n\n  @DomName('CanvasRenderingContext2D.lineWidth')\n  @DocsEditable()\n  num lineWidth;\n\n  @DomName('CanvasRenderingContext2D.miterLimit')\n  @DocsEditable()\n  num miterLimit;\n\n  @DomName('CanvasRenderingContext2D.shadowBlur')\n  @DocsEditable()\n  num shadowBlur;\n\n  @DomName('CanvasRenderingContext2D.shadowColor')\n  @DocsEditable()\n  String shadowColor;\n\n  @DomName('CanvasRenderingContext2D.shadowOffsetX')\n  @DocsEditable()\n  num shadowOffsetX;\n\n  @DomName('CanvasRenderingContext2D.shadowOffsetY')\n  @DocsEditable()\n  num shadowOffsetY;\n\n  @DomName('CanvasRenderingContext2D.strokeStyle')\n  @DocsEditable()\n  @Creates('String|CanvasGradient|CanvasPattern')\n  @Returns('String|CanvasGradient|CanvasPattern')\n  Object strokeStyle;\n\n  @DomName('CanvasRenderingContext2D.textAlign')\n  @DocsEditable()\n  String textAlign;\n\n  @DomName('CanvasRenderingContext2D.textBaseline')\n  @DocsEditable()\n  String textBaseline;\n\n  @JSName('arc')\n  @DomName('CanvasRenderingContext2D.arc')\n  @DocsEditable()\n  void _arc(num x, num y, num radius, num startAngle, num endAngle, bool anticlockwise) native;\n\n  @DomName('CanvasRenderingContext2D.arcTo')\n  @DocsEditable()\n  void arcTo(num x1, num y1, num x2, num y2, num radius) native;\n\n  @DomName('CanvasRenderingContext2D.beginPath')\n  @DocsEditable()\n  void beginPath() native;\n\n  @DomName('CanvasRenderingContext2D.bezierCurveTo')\n  @DocsEditable()\n  void bezierCurveTo(num cp1x, num cp1y, num cp2x, num cp2y, num x, num y) native;\n\n  @DomName('CanvasRenderingContext2D.clearRect')\n  @DocsEditable()\n  void clearRect(num x, num y, num width, num height) native;\n\n  @DomName('CanvasRenderingContext2D.clip')\n  @DocsEditable()\n  void clip([String winding]) native;\n\n  @DomName('CanvasRenderingContext2D.closePath')\n  @DocsEditable()\n  void closePath() native;\n\n  @DomName('CanvasRenderingContext2D.createImageData')\n  @DocsEditable()\n  @Creates('ImageData|=Object')\n  ImageData createImageData(num sw, num sh) {\n    return convertNativeToDart_ImageData(_createImageData_1(sw, sh));\n  }\n  @JSName('createImageData')\n  @DomName('CanvasRenderingContext2D.createImageData')\n  @DocsEditable()\n  @Creates('ImageData|=Object')\n  _createImageData_1(sw, sh) native;\n\n  @DomName('CanvasRenderingContext2D.createImageData')\n  @DocsEditable()\n  @Creates('ImageData|=Object')\n  ImageData createImageDataFromImageData(ImageData imagedata) {\n    var imagedata_1 = convertDartToNative_ImageData(imagedata);\n    return convertNativeToDart_ImageData(_createImageDataFromImageData_1(imagedata_1));\n  }\n  @JSName('createImageData')\n  @DomName('CanvasRenderingContext2D.createImageData')\n  @DocsEditable()\n  @Creates('ImageData|=Object')\n  _createImageDataFromImageData_1(imagedata) native;\n\n  @DomName('CanvasRenderingContext2D.createLinearGradient')\n  @DocsEditable()\n  CanvasGradient createLinearGradient(num x0, num y0, num x1, num y1) native;\n\n  @DomName('CanvasRenderingContext2D.createPattern')\n  @DocsEditable()\n  CanvasPattern createPattern(CanvasElement canvas, String repetitionType) native;\n\n  @JSName('createPattern')\n  @DomName('CanvasRenderingContext2D.createPattern')\n  @DocsEditable()\n  CanvasPattern createPatternFromImage(ImageElement image, String repetitionType) native;\n\n  @DomName('CanvasRenderingContext2D.createRadialGradient')\n  @DocsEditable()\n  CanvasGradient createRadialGradient(num x0, num y0, num r0, num x1, num y1, num r1) native;\n\n  @DomName('CanvasRenderingContext2D.drawCustomFocusRing')\n  @DocsEditable()\n  @Experimental() // untriaged\n  bool drawCustomFocusRing(Element element) native;\n\n  @DomName('CanvasRenderingContext2D.ellipse')\n  @DocsEditable()\n  @Experimental() // untriaged\n  void ellipse(num x, num y, num radiusX, num radiusY, num rotation, num startAngle, num endAngle, bool anticlockwise) native;\n\n  @DomName('CanvasRenderingContext2D.fillRect')\n  @DocsEditable()\n  void fillRect(num x, num y, num width, num height) native;\n\n  @DomName('CanvasRenderingContext2D.getContextAttributes')\n  @DocsEditable()\n  // http://wiki.whatwg.org/wiki/CanvasOpaque#Suggested_IDL\n  @Experimental()\n  Canvas2DContextAttributes getContextAttributes() native;\n\n  @DomName('CanvasRenderingContext2D.getImageData')\n  @DocsEditable()\n  @Creates('ImageData|=Object')\n  ImageData getImageData(num sx, num sy, num sw, num sh) {\n    return convertNativeToDart_ImageData(_getImageData_1(sx, sy, sw, sh));\n  }\n  @JSName('getImageData')\n  @DomName('CanvasRenderingContext2D.getImageData')\n  @DocsEditable()\n  @Creates('ImageData|=Object')\n  _getImageData_1(sx, sy, sw, sh) native;\n\n  @JSName('getLineDash')\n  @DomName('CanvasRenderingContext2D.getLineDash')\n  @DocsEditable()\n  List<num> _getLineDash() native;\n\n  @DomName('CanvasRenderingContext2D.isPointInPath')\n  @DocsEditable()\n  bool isPointInPath(num x, num y, [String winding]) native;\n\n  @DomName('CanvasRenderingContext2D.isPointInStroke')\n  @DocsEditable()\n  bool isPointInStroke(num x, num y) native;\n\n  @DomName('CanvasRenderingContext2D.lineTo')\n  @DocsEditable()\n  void lineTo(num x, num y) native;\n\n  @DomName('CanvasRenderingContext2D.measureText')\n  @DocsEditable()\n  TextMetrics measureText(String text) native;\n\n  @DomName('CanvasRenderingContext2D.moveTo')\n  @DocsEditable()\n  void moveTo(num x, num y) native;\n\n  @DomName('CanvasRenderingContext2D.putImageData')\n  @DocsEditable()\n  void putImageData(ImageData imagedata, num dx, num dy, [num dirtyX, num dirtyY, num dirtyWidth, num dirtyHeight]) {\n    if (dirtyX == null && dirtyY == null && dirtyWidth == null && dirtyHeight == null) {\n      var imagedata_1 = convertDartToNative_ImageData(imagedata);\n      _putImageData_1(imagedata_1, dx, dy);\n      return;\n    }\n    if (dirtyHeight != null && dirtyWidth != null && dirtyY != null && dirtyX != null) {\n      var imagedata_2 = convertDartToNative_ImageData(imagedata);\n      _putImageData_2(imagedata_2, dx, dy, dirtyX, dirtyY, dirtyWidth, dirtyHeight);\n      return;\n    }\n    throw new ArgumentError(\"Incorrect number or type of arguments\");\n  }\n  @JSName('putImageData')\n  @DomName('CanvasRenderingContext2D.putImageData')\n  @DocsEditable()\n  void _putImageData_1(imagedata, dx, dy) native;\n  @JSName('putImageData')\n  @DomName('CanvasRenderingContext2D.putImageData')\n  @DocsEditable()\n  void _putImageData_2(imagedata, dx, dy, dirtyX, dirtyY, dirtyWidth, dirtyHeight) native;\n\n  @DomName('CanvasRenderingContext2D.quadraticCurveTo')\n  @DocsEditable()\n  void quadraticCurveTo(num cpx, num cpy, num x, num y) native;\n\n  @DomName('CanvasRenderingContext2D.rect')\n  @DocsEditable()\n  void rect(num x, num y, num width, num height) native;\n\n  @DomName('CanvasRenderingContext2D.resetTransform')\n  @DocsEditable()\n  @Experimental() // untriaged\n  void resetTransform() native;\n\n  @DomName('CanvasRenderingContext2D.restore')\n  @DocsEditable()\n  void restore() native;\n\n  @DomName('CanvasRenderingContext2D.rotate')\n  @DocsEditable()\n  void rotate(num angle) native;\n\n  @DomName('CanvasRenderingContext2D.save')\n  @DocsEditable()\n  void save() native;\n\n  @DomName('CanvasRenderingContext2D.scale')\n  @DocsEditable()\n  void scale(num sx, num sy) native;\n\n  @DomName('CanvasRenderingContext2D.setTransform')\n  @DocsEditable()\n  void setTransform(num m11, num m12, num m21, num m22, num dx, num dy) native;\n\n  @DomName('CanvasRenderingContext2D.stroke')\n  @DocsEditable()\n  void stroke() native;\n\n  @DomName('CanvasRenderingContext2D.strokeRect')\n  @DocsEditable()\n  void strokeRect(num x, num y, num width, num height) native;\n\n  @DomName('CanvasRenderingContext2D.strokeText')\n  @DocsEditable()\n  void strokeText(String text, num x, num y, [num maxWidth]) native;\n\n  @DomName('CanvasRenderingContext2D.transform')\n  @DocsEditable()\n  void transform(num m11, num m12, num m21, num m22, num dx, num dy) native;\n\n  @DomName('CanvasRenderingContext2D.translate')\n  @DocsEditable()\n  void translate(num tx, num ty) native;\n\n\n  /**\n   * Sets the color used inside shapes.\n   * [r], [g], [b] are 0-255, [a] is 0-1.\n   */\n  void setFillColorRgb(int r, int g, int b, [num a = 1]) {\n    this.fillStyle = 'rgba($r, $g, $b, $a)';\n  }\n\n  /**\n   * Sets the color used inside shapes.\n   * [h] is in degrees, 0-360.\n   * [s], [l] are in percent, 0-100.\n   * [a] is 0-1.\n   */\n  void setFillColorHsl(int h, num s, num l, [num a = 1]) {\n    this.fillStyle = 'hsla($h, $s%, $l%, $a)';\n  }\n\n  /**\n   * Sets the color used for stroking shapes.\n   * [r], [g], [b] are 0-255, [a] is 0-1.\n   */\n  void setStrokeColorRgb(int r, int g, int b, [num a = 1]) {\n    this.strokeStyle = 'rgba($r, $g, $b, $a)';\n  }\n\n  /**\n   * Sets the color used for stroking shapes.\n   * [h] is in degrees, 0-360.\n   * [s], [l] are in percent, 0-100.\n   * [a] is 0-1.\n   */\n  void setStrokeColorHsl(int h, num s, num l, [num a = 1]) {\n    this.strokeStyle = 'hsla($h, $s%, $l%, $a)';\n  }\n\n  @DomName('CanvasRenderingContext2D.arc')\n  void arc(num x,  num y,  num radius,  num startAngle, num endAngle,\n      [bool anticlockwise = false]) {\n    _arc(x, y, radius, startAngle, endAngle, anticlockwise);\n  }\n\n  /**\n   * Draws an image from a CanvasImageSource to an area of this canvas.\n   *\n   * The image will be drawn to an area of this canvas defined by\n   * [destRect]. [sourceRect] defines the region of the source image that is\n   * drawn.\n   * If [sourceRect] is not provided, then\n   * the entire rectangular image from [source] will be drawn to this context.\n   *\n   * If the image is larger than canvas\n   * will allow, the image will be clipped to fit the available space.\n   *\n   *     CanvasElement canvas = new CanvasElement(width: 600, height: 600);\n   *     CanvasRenderingContext2D ctx = canvas.context2D;\n   *     ImageElement img = document.query('img');\n   *     img.width = 100;\n   *     img.height = 100;\n   *\n   *     // Scale the image to 20x20.\n   *     ctx.drawImageToRect(img, new Rectangle(50, 50, 20, 20));\n   *\n   *     VideoElement video = document.query('video');\n   *     video.width = 100;\n   *     video.height = 100;\n   *     // Take the middle 20x20 pixels from the video and stretch them.\n   *     ctx.drawImageToRect(video, new Rectangle(50, 50, 100, 100),\n   *         sourceRect: new Rectangle(40, 40, 20, 20));\n   *\n   *     // Draw the top 100x20 pixels from the otherCanvas.\n   *     CanvasElement otherCanvas = document.query('canvas');\n   *     ctx.drawImageToRect(otherCanvas, new Rectangle(0, 0, 100, 20),\n   *         sourceRect: new Rectangle(0, 0, 100, 20));\n   *\n   * See also:\n   *\n   *   * [CanvasImageSource] for more information on what data is retrieved\n   * from [source].\n   *   * [drawImage](http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#dom-context-2d-drawimage)\n   * from the WHATWG.\n   */\n  @DomName('CanvasRenderingContext2D.drawImage')\n  void drawImageToRect(CanvasImageSource source, Rectangle destRect,\n      {Rectangle sourceRect}) {\n    if (sourceRect == null) {\n      drawImageScaled(source,\n          destRect.left,\n          destRect.top,\n          destRect.width,\n          destRect.height);\n    } else {\n      drawImageScaledFromSource(source,\n          sourceRect.left,\n          sourceRect.top,\n          sourceRect.width,\n          sourceRect.height,\n          destRect.left,\n          destRect.top,\n          destRect.width,\n          destRect.height);\n    }\n  }\n\n  /**\n   * Draws an image from a CanvasImageSource to this canvas.\n   *\n   * The entire image from [source] will be drawn to this context with its top\n   * left corner at the point ([destX], [destY]). If the image is\n   * larger than canvas will allow, the image will be clipped to fit the\n   * available space.\n   *\n   *     CanvasElement canvas = new CanvasElement(width: 600, height: 600);\n   *     CanvasRenderingContext2D ctx = canvas.context2D;\n   *     ImageElement img = document.query('img');\n   *\n   *     ctx.drawImage(img, 100, 100);\n   *\n   *     VideoElement video = document.query('video');\n   *     ctx.drawImage(video, 0, 0);\n   *\n   *     CanvasElement otherCanvas = document.query('canvas');\n   *     otherCanvas.width = 100;\n   *     otherCanvas.height = 100;\n   *     ctx.drawImage(otherCanvas, 590, 590); // will get clipped\n   *\n   * See also:\n   *\n   *   * [CanvasImageSource] for more information on what data is retrieved\n   * from [source].\n   *   * [drawImage](http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#dom-context-2d-drawimage)\n   * from the WHATWG.\n   */\n  @DomName('CanvasRenderingContext2D.drawImage')\n  @JSName('drawImage')\n  void drawImage(CanvasImageSource source, num destX, num destY) native;\n\n  /**\n   * Draws an image from a CanvasImageSource to an area of this canvas.\n   *\n   * The image will be drawn to this context with its top left corner at the\n   * point ([destX], [destY]) and will be scaled to be [destWidth] wide and\n   * [destHeight] tall.\n   *\n   * If the image is larger than canvas\n   * will allow, the image will be clipped to fit the available space.\n   *\n   *     CanvasElement canvas = new CanvasElement(width: 600, height: 600);\n   *     CanvasRenderingContext2D ctx = canvas.context2D;\n   *     ImageElement img = document.query('img');\n   *     img.width = 100;\n   *     img.height = 100;\n   *\n   *     // Scale the image to 300x50 at the point (20, 20)\n   *     ctx.drawImageScaled(img, 20, 20, 300, 50);\n   *\n   * See also:\n   *\n   *   * [CanvasImageSource] for more information on what data is retrieved\n   * from [source].\n   *   * [drawImage](http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#dom-context-2d-drawimage)\n   * from the WHATWG.\n   */\n  @DomName('CanvasRenderingContext2D.drawImage')\n  @JSName('drawImage')\n  void drawImageScaled(CanvasImageSource source,\n      num destX, num destY, num destWidth, num destHeight) native;\n\n  /**\n   * Draws an image from a CanvasImageSource to an area of this canvas.\n   *\n   * The image is a region of [source] that is [sourceWidth] wide and\n   * [destHeight] tall with top left corner at ([sourceX], [sourceY]).\n   * The image will be drawn to this context with its top left corner at the\n   * point ([destX], [destY]) and will be scaled to be [destWidth] wide and\n   * [destHeight] tall.\n   *\n   * If the image is larger than canvas\n   * will allow, the image will be clipped to fit the available space.\n   *\n   *     VideoElement video = document.query('video');\n   *     video.width = 100;\n   *     video.height = 100;\n   *     // Take the middle 20x20 pixels from the video and stretch them.\n   *     ctx.drawImageScaledFromSource(video, 40, 40, 20, 20, 50, 50, 100, 100);\n   *\n   *     // Draw the top 100x20 pixels from the otherCanvas to this one.\n   *     CanvasElement otherCanvas = document.query('canvas');\n   *     ctx.drawImageScaledFromSource(otherCanvas, 0, 0, 100, 20, 0, 0, 100, 20);\n   *\n   * See also:\n   *\n   *   * [CanvasImageSource] for more information on what data is retrieved\n   * from [source].\n   *   * [drawImage](http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#dom-context-2d-drawimage)\n   * from the WHATWG.\n   */\n  @DomName('CanvasRenderingContext2D.drawImage')\n  @JSName('drawImage')\n  void drawImageScaledFromSource(CanvasImageSource source,\n      num sourceX, num sourceY, num sourceWidth, num sourceHeight,\n      num destX, num destY, num destWidth, num destHeight) native;\n\n  @SupportedBrowser(SupportedBrowser.CHROME)\n  @SupportedBrowser(SupportedBrowser.SAFARI)\n  @SupportedBrowser(SupportedBrowser.IE, '11')\n  @Unstable()\n  @DomName('CanvasRenderingContext2D.lineDashOffset')\n  // TODO(14316): Firefox has this functionality with mozDashOffset, but it\n  // needs to be polyfilled.\n  num get lineDashOffset => JS('num',\n      '#.lineDashOffset || #.webkitLineDashOffset', this, this);\n\n  @SupportedBrowser(SupportedBrowser.CHROME)\n  @SupportedBrowser(SupportedBrowser.SAFARI)\n  @SupportedBrowser(SupportedBrowser.IE, '11')\n  @Unstable()\n  @DomName('CanvasRenderingContext2D.lineDashOffset')\n  // TODO(14316): Firefox has this functionality with mozDashOffset, but it\n  // needs to be polyfilled.\n  void set lineDashOffset(num value) {\n    JS('void',\n       'typeof #.lineDashOffset != \"undefined\" ? #.lineDashOffset = # : '\n       '#.webkitLineDashOffset = #', this, this, value, this, value);\n  }\n\n  @SupportedBrowser(SupportedBrowser.CHROME)\n  @SupportedBrowser(SupportedBrowser.SAFARI)\n  @SupportedBrowser(SupportedBrowser.IE, '11')\n  @Unstable()\n  @DomName('CanvasRenderingContext2D.getLineDash')\n  List<num> getLineDash() {\n    // TODO(14316): Firefox has this functionality with mozDash, but it's a bit\n    // different.\n    if (JS('bool', '!!#.getLineDash', this)) {\n      return JS('List<num>', '#.getLineDash()', this);\n    } else if (JS('bool', '!!#.webkitLineDash', this)) {\n      return JS('List<num>', '#.webkitLineDash', this);\n    } \n  }\n\n  @SupportedBrowser(SupportedBrowser.CHROME)\n  @SupportedBrowser(SupportedBrowser.SAFARI)\n  @SupportedBrowser(SupportedBrowser.IE, '11')\n  @Unstable()\n  @DomName('CanvasRenderingContext2D.setLineDash')\n  void setLineDash(List<num> dash) {\n    // TODO(14316): Firefox has this functionality with mozDash, but it's a bit\n    // different.\n    if (JS('bool', '!!#.setLineDash', this)) {\n      JS('void', '#.setLineDash(#)', this, dash);\n    } else if (JS('bool', '!!#.webkitLineDash', this)) {\n      JS('void', '#.webkitLineDash = #', this, dash);\n    }\n  }\n\n\n  /**\n   * Draws text to the canvas.\n   *\n   * The text is drawn starting at coordinates ([x], [y]).\n   * If [maxWidth] is provided and the [text] is computed to be wider than\n   * [maxWidth], then the drawn text is scaled down horizontally to fit.\n   *\n   * The text uses the current [CanvasRenderingContext2D.font] property for font\n   * options, such as typeface and size, and the current\n   * [CanvasRenderingContext2D.fillStyle] for style options such as color.\n   * The current [CanvasRenderingContext2D.textAlign] and\n   * [CanvasRenderingContext2D.textBaseLine] properties are also applied to the\n   * drawn text.\n   */\n  @DomName('CanvasRenderingContext2D.fillText')\n  void fillText(String text, num x, num y, [num maxWidth]) {\n    if (maxWidth != null) {\n      JS('void', '#.fillText(#, #, #, #)', this, text, x, y, maxWidth);\n    } else {\n      JS('void', '#.fillText(#, #, #)', this, text, x, y);\n    }\n  }\n\n  @DomName('CanvasRenderingContext2D.fill')\n  void fill([String winding = 'nonzero']) {\n    JS('void', '#.fill(#)', this, winding);\n  }\n\n  /** Deprecated always returns 1.0 */\n  @DomName('CanvasRenderingContext2D.webkitBackingStorePixelRation')\n  @Experimental()\n  @deprecated\n  double get backingStorePixelRatio => 1.0;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('CharacterData')\n@Native(\"CharacterData\")\nclass CharacterData extends Node implements ChildNode {\n  // To suppress missing implicit constructor warnings.\n  factory CharacterData._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('CharacterData.data')\n  @DocsEditable()\n  String data;\n\n  @DomName('CharacterData.length')\n  @DocsEditable()\n  final int length;\n\n  @DomName('CharacterData.appendData')\n  @DocsEditable()\n  void appendData(String data) native;\n\n  @DomName('CharacterData.deleteData')\n  @DocsEditable()\n  void deleteData(int offset, int length) native;\n\n  @DomName('CharacterData.insertData')\n  @DocsEditable()\n  void insertData(int offset, String data) native;\n\n  @DomName('CharacterData.replaceData')\n  @DocsEditable()\n  void replaceData(int offset, int length, String data) native;\n\n  @DomName('CharacterData.substringData')\n  @DocsEditable()\n  String substringData(int offset, int length) native;\n\n  // From ChildNode\n\n  @DomName('CharacterData.nextElementSibling')\n  @DocsEditable()\n  final Element nextElementSibling;\n\n  @DomName('CharacterData.previousElementSibling')\n  @DocsEditable()\n  final Element previousElementSibling;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('ChildNode')\n@Experimental() // untriaged\nabstract class ChildNode extends Interceptor {\n  // To suppress missing implicit constructor warnings.\n  factory ChildNode._() { throw new UnsupportedError(\"Not supported\"); }\n\n  final Element nextElementSibling;\n\n  final Element previousElementSibling;\n\n  void remove();\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('CloseEvent')\n@Native(\"CloseEvent\")\nclass CloseEvent extends Event {\n  // To suppress missing implicit constructor warnings.\n  factory CloseEvent._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('CloseEvent.code')\n  @DocsEditable()\n  final int code;\n\n  @DomName('CloseEvent.reason')\n  @DocsEditable()\n  final String reason;\n\n  @DomName('CloseEvent.wasClean')\n  @DocsEditable()\n  final bool wasClean;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('Comment')\n@Native(\"Comment\")\nclass Comment extends CharacterData {\n  factory Comment([String data]) {\n    if (data != null) {\n      return JS('Comment', '#.createComment(#)', document, data);\n    }\n    return JS('Comment', '#.createComment(\"\")', document);\n  }\n  // To suppress missing implicit constructor warnings.\n  factory Comment._() { throw new UnsupportedError(\"Not supported\"); }\n}\n// Copyright (c) 2013, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n// WARNING: Do not edit - generated code.\n\n\n@DomName('CompositionEvent')\n@Native(\"CompositionEvent\")\nclass CompositionEvent extends UIEvent {\n  factory CompositionEvent(String type,\n      {bool canBubble: false, bool cancelable: false, Window view,\n      String data}) {\n    if (view == null) {\n      view = window;\n    }\n    var e = document._createEvent(\"CompositionEvent\");\n    e._initCompositionEvent(type, canBubble, cancelable, view, data);\n    return e;\n  }\n  // To suppress missing implicit constructor warnings.\n  factory CompositionEvent._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('CompositionEvent.activeSegmentEnd')\n  @DocsEditable()\n  @Experimental() // untriaged\n  final int activeSegmentEnd;\n\n  @DomName('CompositionEvent.activeSegmentStart')\n  @DocsEditable()\n  @Experimental() // untriaged\n  final int activeSegmentStart;\n\n  @DomName('CompositionEvent.data')\n  @DocsEditable()\n  final String data;\n\n  @JSName('initCompositionEvent')\n  @DomName('CompositionEvent.initCompositionEvent')\n  @DocsEditable()\n  void _initCompositionEvent(String typeArg, bool canBubbleArg, bool cancelableArg, Window viewArg, String dataArg) native;\n\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DomName('Console')\nclass Console {\n\n  const Console._safe();\n\n  static const Console _safeConsole = const Console._safe();\n\n  bool get _isConsoleDefined => JS('bool', 'typeof console != \"undefined\"');\n\n  @DomName('Console.memory')\n  MemoryInfo get memory => _isConsoleDefined ?\n      JS('MemoryInfo', 'console.memory') : null;\n\n  @DomName('Console.assertCondition')\n  void assertCondition(bool condition, Object arg) => _isConsoleDefined ?\n      JS('void', 'console.assertCondition(#, #)', condition, arg) : null;\n\n  @DomName('Console.clear')\n  void clear(Object arg) => _isConsoleDefined ?\n      JS('void', 'console.clear(#)', arg) : null;\n\n  @DomName('Console.count')\n  void count(Object arg) => _isConsoleDefined ?\n      JS('void', 'console.count(#)', arg) : null;\n\n  @DomName('Console.debug')\n  void debug(Object arg) => _isConsoleDefined ?\n      JS('void', 'console.debug(#)', arg) : null;\n\n  @DomName('Console.dir')\n  void dir(Object arg) => _isConsoleDefined ?\n      JS('void', 'console.dir(#)', arg) : null;\n\n  @DomName('Console.dirxml')\n  void dirxml(Object arg) => _isConsoleDefined ?\n      JS('void', 'console.dirxml(#)', arg) : null;\n\n  @DomName('Console.error')\n  void error(Object arg) => _isConsoleDefined ?\n      JS('void', 'console.error(#)', arg) : null;\n\n  @DomName('Console.group')\n  void group(Object arg) => _isConsoleDefined ?\n      JS('void', 'console.group(#)', arg) : null;\n\n  @DomName('Console.groupCollapsed')\n  void groupCollapsed(Object arg) => _isConsoleDefined ?\n      JS('void', 'console.groupCollapsed(#)', arg) : null;\n\n  @DomName('Console.groupEnd')\n  void groupEnd() => _isConsoleDefined ?\n      JS('void', 'console.groupEnd()') : null;\n\n  @DomName('Console.info')\n  void info(Object arg) => _isConsoleDefined ?\n      JS('void', 'console.info(#)', arg) : null;\n\n  @DomName('Console.log')\n  void log(Object arg) => _isConsoleDefined ?\n      JS('void', 'console.log(#)', arg) : null;\n\n  @DomName('Console.markTimeline')\n  void markTimeline(Object arg) => _isConsoleDefined ?\n      JS('void', 'console.markTimeline(#)', arg) : null;\n\n  @DomName('Console.profile')\n  void profile(String title) => _isConsoleDefined ?\n      JS('void', 'console.profile(#)', title) : null;\n\n  @DomName('Console.profileEnd')\n  void profileEnd(String title) => _isConsoleDefined ?\n      JS('void', 'console.profileEnd(#)', title) : null;\n\n  @DomName('Console.table')\n  void table(Object arg) => _isConsoleDefined ?\n      JS('void', 'console.table(#)', arg) : null;\n\n  @DomName('Console.time')\n  void time(String title) => _isConsoleDefined ?\n      JS('void', 'console.time(#)', title) : null;\n\n  @DomName('Console.timeEnd')\n  void timeEnd(String title) => _isConsoleDefined ?\n      JS('void', 'console.timeEnd(#)', title) : null;\n\n  @DomName('Console.timeStamp')\n  void timeStamp(Object arg) => _isConsoleDefined ?\n      JS('void', 'console.timeStamp(#)', arg) : null;\n\n  @DomName('Console.trace')\n  void trace(Object arg) => _isConsoleDefined ?\n      JS('void', 'console.trace(#)', arg) : null;\n\n  @DomName('Console.warn')\n  void warn(Object arg) => _isConsoleDefined ?\n      JS('void', 'console.warn(#)', arg) : null;\n  // To suppress missing implicit constructor warnings.\n  factory Console._() { throw new UnsupportedError(\"Not supported\"); }\n\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('ConsoleBase')\n@Experimental() // untriaged\n@Native(\"ConsoleBase\")\nclass ConsoleBase extends Interceptor {\n  // To suppress missing implicit constructor warnings.\n  factory ConsoleBase._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('ConsoleBase.timeline')\n  @DocsEditable()\n  @Experimental() // untriaged\n  void timeline(String title) native;\n\n  @DomName('ConsoleBase.timelineEnd')\n  @DocsEditable()\n  @Experimental() // untriaged\n  void timelineEnd(String title) native;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('HTMLContentElement')\n@SupportedBrowser(SupportedBrowser.CHROME, '26')\n@Experimental()\n// https://dvcs.w3.org/hg/webcomponents/raw-file/tip/spec/shadow/index.html#content-element\n@Native(\"HTMLContentElement\")\nclass ContentElement extends HtmlElement {\n  // To suppress missing implicit constructor warnings.\n  factory ContentElement._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('HTMLContentElement.HTMLContentElement')\n  @DocsEditable()\n  factory ContentElement() => document.createElement(\"content\");\n  /**\n   * Constructor instantiated by the DOM when a custom element has been created.\n   *\n   * This can only be called by subclasses from their created constructor.\n   */\n  ContentElement.created() : super.created();\n\n  /// Checks if this type is supported on the current platform.\n  static bool get supported => Element.isTagSupported('content');\n\n  @DomName('HTMLContentElement.resetStyleInheritance')\n  @DocsEditable()\n  bool resetStyleInheritance;\n\n  @DomName('HTMLContentElement.select')\n  @DocsEditable()\n  String select;\n\n  @DomName('HTMLContentElement.getDistributedNodes')\n  @DocsEditable()\n  @Returns('NodeList')\n  @Creates('NodeList')\n  List<Node> getDistributedNodes() native;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('Coordinates')\n@Native(\"Coordinates\")\nclass Coordinates extends Interceptor {\n  // To suppress missing implicit constructor warnings.\n  factory Coordinates._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('Coordinates.accuracy')\n  @DocsEditable()\n  final double accuracy;\n\n  @DomName('Coordinates.altitude')\n  @DocsEditable()\n  final double altitude;\n\n  @DomName('Coordinates.altitudeAccuracy')\n  @DocsEditable()\n  final double altitudeAccuracy;\n\n  @DomName('Coordinates.heading')\n  @DocsEditable()\n  final double heading;\n\n  @DomName('Coordinates.latitude')\n  @DocsEditable()\n  final double latitude;\n\n  @DomName('Coordinates.longitude')\n  @DocsEditable()\n  final double longitude;\n\n  @DomName('Coordinates.speed')\n  @DocsEditable()\n  final double speed;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('Crypto')\n@SupportedBrowser(SupportedBrowser.CHROME)\n@SupportedBrowser(SupportedBrowser.SAFARI)\n@Experimental()\n// http://www.w3.org/TR/WebCryptoAPI/\n@Native(\"Crypto\")\nclass Crypto extends Interceptor {\n  // To suppress missing implicit constructor warnings.\n  factory Crypto._() { throw new UnsupportedError(\"Not supported\"); }\n\n  /// Checks if this type is supported on the current platform.\n  static bool get supported => JS('bool', '!!(window.crypto && window.crypto.getRandomValues)');\n\n  @DomName('Crypto.subtle')\n  @DocsEditable()\n  @Experimental() // untriaged\n  final _SubtleCrypto subtle;\n\n  @DomName('Crypto.getRandomValues')\n  @DocsEditable()\n  @Creates('TypedData')\n  @Returns('TypedData|Null')\n  TypedData getRandomValues(TypedData array) native;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('Key')\n@Experimental() // untriaged\n@Native(\"Key\")\nclass CryptoKey extends Interceptor {\n  // To suppress missing implicit constructor warnings.\n  factory CryptoKey._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('Key.algorithm')\n  @DocsEditable()\n  @Experimental() // untriaged\n  final Algorithm algorithm;\n\n  @DomName('Key.extractable')\n  @DocsEditable()\n  @Experimental() // untriaged\n  final bool extractable;\n\n  @DomName('Key.type')\n  @DocsEditable()\n  @Experimental() // untriaged\n  final String type;\n\n  @DomName('Key.usages')\n  @DocsEditable()\n  @Experimental() // untriaged\n  final List<String> usages;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('CSS')\n// http://www.w3.org/TR/css3-conditional/#the-css-interface\n@Experimental() // None\n@Native(\"CSS\")\nclass Css extends Interceptor {\n  // To suppress missing implicit constructor warnings.\n  factory Css._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('CSS.supports')\n  @DocsEditable()\n  bool supports(String property, String value) native;\n\n  @JSName('supports')\n  @DomName('CSS.supports')\n  @DocsEditable()\n  bool supportsCondition(String conditionText) native;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('CSSCharsetRule')\n// http://dev.w3.org/csswg/cssom/#the-csscharsetrule-interface\n@Experimental()\n@Native(\"CSSCharsetRule\")\nclass CssCharsetRule extends CssRule {\n  // To suppress missing implicit constructor warnings.\n  factory CssCharsetRule._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('CSSCharsetRule.encoding')\n  @DocsEditable()\n  String encoding;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('WebKitCSSFilterRule')\n@SupportedBrowser(SupportedBrowser.CHROME)\n@SupportedBrowser(SupportedBrowser.SAFARI)\n@Experimental()\n// http://www.w3.org/TR/filter-effects/\n@Native(\"WebKitCSSFilterRule\")\nclass CssFilterRule extends CssRule {\n  // To suppress missing implicit constructor warnings.\n  factory CssFilterRule._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('WebKitCSSFilterRule.style')\n  @DocsEditable()\n  final CssStyleDeclaration style;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('CSSFontFaceLoadEvent')\n// http://www.w3.org/TR/css3-fonts/\n@Experimental()\n@Native(\"CSSFontFaceLoadEvent\")\nclass CssFontFaceLoadEvent extends Event {\n  // To suppress missing implicit constructor warnings.\n  factory CssFontFaceLoadEvent._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('CSSFontFaceLoadEvent.fontfaces')\n  @DocsEditable()\n  @Experimental() // untriaged\n  final List<FontFace> fontfaces;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('CSSFontFaceRule')\n@Native(\"CSSFontFaceRule\")\nclass CssFontFaceRule extends CssRule {\n  // To suppress missing implicit constructor warnings.\n  factory CssFontFaceRule._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('CSSFontFaceRule.style')\n  @DocsEditable()\n  final CssStyleDeclaration style;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('CSSImportRule')\n@Native(\"CSSImportRule\")\nclass CssImportRule extends CssRule {\n  // To suppress missing implicit constructor warnings.\n  factory CssImportRule._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('CSSImportRule.href')\n  @DocsEditable()\n  final String href;\n\n  @DomName('CSSImportRule.media')\n  @DocsEditable()\n  final MediaList media;\n\n  @DomName('CSSImportRule.styleSheet')\n  @DocsEditable()\n  final CssStyleSheet styleSheet;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('CSSKeyframeRule')\n@Experimental() // untriaged\n@Native(\"CSSKeyframeRule,MozCSSKeyframeRule,WebKitCSSKeyframeRule\")\nclass CssKeyframeRule extends CssRule {\n  // To suppress missing implicit constructor warnings.\n  factory CssKeyframeRule._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('CSSKeyframeRule.keyText')\n  @DocsEditable()\n  @Experimental() // untriaged\n  String keyText;\n\n  @DomName('CSSKeyframeRule.style')\n  @DocsEditable()\n  @Experimental() // untriaged\n  final CssStyleDeclaration style;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('CSSKeyframesRule')\n@Experimental() // untriaged\n@Native(\"CSSKeyframesRule,MozCSSKeyframesRule,WebKitCSSKeyframesRule\")\nclass CssKeyframesRule extends CssRule {\n  // To suppress missing implicit constructor warnings.\n  factory CssKeyframesRule._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('CSSKeyframesRule.cssRules')\n  @DocsEditable()\n  @Experimental() // untriaged\n  @Returns('_CssRuleList')\n  @Creates('_CssRuleList')\n  final List<CssRule> cssRules;\n\n  @DomName('CSSKeyframesRule.name')\n  @DocsEditable()\n  @Experimental() // untriaged\n  String name;\n\n  @DomName('CSSKeyframesRule.__getter__')\n  @DocsEditable()\n  @Experimental() // untriaged\n  CssKeyframeRule __getter__(int index) native;\n\n  @DomName('CSSKeyframesRule.deleteRule')\n  @DocsEditable()\n  @Experimental() // untriaged\n  void deleteRule(String key) native;\n\n  @DomName('CSSKeyframesRule.findRule')\n  @DocsEditable()\n  @Experimental() // untriaged\n  CssKeyframeRule findRule(String key) native;\n\n  @JSName('insertRule')\n  @DomName('CSSKeyframesRule.insertRule')\n  @DocsEditable()\n  @Experimental() // untriaged\n  void appendRule(String rule) native;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('CSSMediaRule')\n@Native(\"CSSMediaRule\")\nclass CssMediaRule extends CssRule {\n  // To suppress missing implicit constructor warnings.\n  factory CssMediaRule._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('CSSMediaRule.cssRules')\n  @DocsEditable()\n  @Returns('_CssRuleList')\n  @Creates('_CssRuleList')\n  final List<CssRule> cssRules;\n\n  @DomName('CSSMediaRule.media')\n  @DocsEditable()\n  final MediaList media;\n\n  @DomName('CSSMediaRule.deleteRule')\n  @DocsEditable()\n  void deleteRule(int index) native;\n\n  @DomName('CSSMediaRule.insertRule')\n  @DocsEditable()\n  int insertRule(String rule, int index) native;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('CSSPageRule')\n@Native(\"CSSPageRule\")\nclass CssPageRule extends CssRule {\n  // To suppress missing implicit constructor warnings.\n  factory CssPageRule._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('CSSPageRule.selectorText')\n  @DocsEditable()\n  String selectorText;\n\n  @DomName('CSSPageRule.style')\n  @DocsEditable()\n  final CssStyleDeclaration style;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('CSSRule')\n@Native(\"CSSRule\")\nclass CssRule extends Interceptor {\n  // To suppress missing implicit constructor warnings.\n  factory CssRule._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('CSSRule.CHARSET_RULE')\n  @DocsEditable()\n  static const int CHARSET_RULE = 2;\n\n  @DomName('CSSRule.FONT_FACE_RULE')\n  @DocsEditable()\n  static const int FONT_FACE_RULE = 5;\n\n  @DomName('CSSRule.IMPORT_RULE')\n  @DocsEditable()\n  static const int IMPORT_RULE = 3;\n\n  @DomName('CSSRule.KEYFRAMES_RULE')\n  @DocsEditable()\n  @Experimental() // untriaged\n  static const int KEYFRAMES_RULE = 7;\n\n  @DomName('CSSRule.KEYFRAME_RULE')\n  @DocsEditable()\n  @Experimental() // untriaged\n  static const int KEYFRAME_RULE = 8;\n\n  @DomName('CSSRule.MEDIA_RULE')\n  @DocsEditable()\n  static const int MEDIA_RULE = 4;\n\n  @DomName('CSSRule.PAGE_RULE')\n  @DocsEditable()\n  static const int PAGE_RULE = 6;\n\n  @DomName('CSSRule.STYLE_RULE')\n  @DocsEditable()\n  static const int STYLE_RULE = 1;\n\n  @DomName('CSSRule.SUPPORTS_RULE')\n  @DocsEditable()\n  static const int SUPPORTS_RULE = 12;\n\n  @DomName('CSSRule.VIEWPORT_RULE')\n  @DocsEditable()\n  @Experimental() // untriaged\n  static const int VIEWPORT_RULE = 15;\n\n  @DomName('CSSRule.WEBKIT_FILTER_RULE')\n  @DocsEditable()\n  // http://www.w3.org/TR/filter-effects/\n  @Experimental()\n  static const int WEBKIT_FILTER_RULE = 17;\n\n  @DomName('CSSRule.WEBKIT_KEYFRAMES_RULE')\n  @DocsEditable()\n  // http://www.w3.org/TR/css3-animations/#cssrule\n  @Experimental()\n  static const int WEBKIT_KEYFRAMES_RULE = 7;\n\n  @DomName('CSSRule.WEBKIT_KEYFRAME_RULE')\n  @DocsEditable()\n  // http://www.w3.org/TR/css3-animations/#cssrule\n  @Experimental()\n  static const int WEBKIT_KEYFRAME_RULE = 8;\n\n  @DomName('CSSRule.cssText')\n  @DocsEditable()\n  String cssText;\n\n  @DomName('CSSRule.parentRule')\n  @DocsEditable()\n  final CssRule parentRule;\n\n  @DomName('CSSRule.parentStyleSheet')\n  @DocsEditable()\n  final CssStyleSheet parentStyleSheet;\n\n  @DomName('CSSRule.type')\n  @DocsEditable()\n  final int type;\n}\n\n// Copyright (c) 2014, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n// WARNING: DO NOT EDIT THIS TEMPLATE FILE.\n// The template file was generated by scripts/css_code_generator.py\n\n// Source of CSS properties:\n//   CSSPropertyNames.in\n\n\n@DomName('CSSStyleDeclaration')\n@Native(\"CSSStyleDeclaration,MSStyleCSSProperties,CSS2Properties\")\n class CssStyleDeclaration  extends Interceptor with\n    CssStyleDeclarationBase  {\n  factory CssStyleDeclaration() => new CssStyleDeclaration.css('');\n\n  factory CssStyleDeclaration.css(String css) {\n    final style = new Element.tag('div').style;\n    style.cssText = css;\n    return style;\n  }\n\n  String getPropertyValue(String propertyName) {\n    var propValue = _getPropertyValueHelper(propertyName);\n    return propValue != null ? propValue : '';\n  }\n\n  String _getPropertyValueHelper(String propertyName) {\n    if (_supportsProperty(_camelCase(propertyName))) {\n      return _getPropertyValue(propertyName);\n    } else {\n      return _getPropertyValue(Device.cssPrefix + propertyName);\n    }\n  }\n\n  /**\n   * Returns true if the provided *CSS* property name is supported on this\n   * element.\n   *\n   * Please note the property name camelCase, not-hyphens. This\n   * method returns true if the property is accessible via an unprefixed _or_\n   * prefixed property.\n   */\n  bool supportsProperty(String propertyName) {\n    return _supportsProperty(propertyName) ||\n        _supportsProperty(_camelCase(Device.cssPrefix + propertyName));\n  }\n\n  bool _supportsProperty(String propertyName) {\n    return JS('bool', '# in #', propertyName, this);\n  }\n\n  @DomName('CSSStyleDeclaration.setProperty')\n  void setProperty(String propertyName, String value, [String priority]) {\n    if (_supportsProperty(_camelCase(propertyName))) {\n      return _setPropertyHelper(propertyName, value, priority);\n    } else {\n      return _setPropertyHelper(Device.cssPrefix + propertyName, value,\n          priority);\n    }\n  }\n\n  static String _camelCase(String hyphenated) {\n    var replacedMs = JS('String', r'#.replace(/^-ms-/, \"ms-\")', hyphenated);\n\n    var fToUpper = const JS_CONST(\n        r'function(_, letter) { return letter.toUpperCase(); }');\n    return JS('String', r'#.replace(/-([\\da-z])/ig, #)', replacedMs, fToUpper);\n  }\n\n  void _setPropertyHelper(String propertyName, String value, [String priority]) {\n    // try/catch for IE9 which throws on unsupported values.\n    try {\n      if (value == null) value = '';\n      if (priority == null) {\n        priority = '';\n      }\n      JS('void', '#.setProperty(#, #, #)', this, propertyName, value, priority);\n      // Bug #2772, IE9 requires a poke to actually apply the value.\n      if (JS('bool', '!!#.setAttribute', this)) {\n        JS('void', '#.setAttribute(#, #)', this, propertyName, value);\n      }\n    } catch (e) {}\n  }\n\n  /**\n   * Checks to see if CSS Transitions are supported.\n   */\n  static bool get supportsTransitions {\n    return document.body.style.supportsProperty('transition');\n  }\n  // To suppress missing implicit constructor warnings.\n  factory CssStyleDeclaration._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('CSSStyleDeclaration.cssText')\n  @DocsEditable()\n  String cssText;\n\n  @DomName('CSSStyleDeclaration.length')\n  @DocsEditable()\n  final int length;\n\n  @DomName('CSSStyleDeclaration.parentRule')\n  @DocsEditable()\n  final CssRule parentRule;\n\n  @DomName('CSSStyleDeclaration.__setter__')\n  @DocsEditable()\n  void __setter__(String propertyName, String propertyValue) native;\n\n  @DomName('CSSStyleDeclaration.getPropertyPriority')\n  @DocsEditable()\n  String getPropertyPriority(String propertyName) native;\n\n  @JSName('getPropertyValue')\n  @DomName('CSSStyleDeclaration.getPropertyValue')\n  @DocsEditable()\n  String _getPropertyValue(String propertyName) native;\n\n  @DomName('CSSStyleDeclaration.item')\n  @DocsEditable()\n  String item(int index) native;\n\n  @DomName('CSSStyleDeclaration.removeProperty')\n  @DocsEditable()\n  String removeProperty(String propertyName) native;\n\n}\n\nclass _CssStyleDeclarationSet extends Object with CssStyleDeclarationBase {\n  final Iterable<Element> _elementIterable;\n  Iterable<CssStyleDeclaration> _elementCssStyleDeclarationSetIterable;\n\n  _CssStyleDeclarationSet(this._elementIterable) {\n    _elementCssStyleDeclarationSetIterable = new List.from(\n        _elementIterable).map((e) => e.style);\n  }\n\n  String getPropertyValue(String propertyName) =>\n      _elementCssStyleDeclarationSetIterable.first.getPropertyValue(\n          propertyName);\n\n  void setProperty(String propertyName, String value, [String priority]) {\n    _elementCssStyleDeclarationSetIterable.forEach((e) =>\n        e.setProperty(propertyName, value, priority));\n  }\n  // Important note: CssStyleDeclarationSet does NOT implement every method\n  // available in CssStyleDeclaration. Some of the methods don't make so much\n  // sense in terms of having a resonable value to return when you're\n  // considering a list of Elements. You will need to manually add any of the\n  // items in the MEMBERS set if you want that functionality.\n}\n\nabstract class CssStyleDeclarationBase {\n  String getPropertyValue(String propertyName);\n  void setProperty(String propertyName, String value, [String priority]);\n\n  /** Gets the value of \"align-content\" */\n  String get alignContent =>\n    getPropertyValue('align-content');\n\n  /** Sets the value of \"align-content\" */\n  void set alignContent(String value) {\n    setProperty('align-content', value, '');\n  }\n\n  /** Gets the value of \"align-items\" */\n  String get alignItems =>\n    getPropertyValue('align-items');\n\n  /** Sets the value of \"align-items\" */\n  void set alignItems(String value) {\n    setProperty('align-items', value, '');\n  }\n\n  /** Gets the value of \"align-self\" */\n  String get alignSelf =>\n    getPropertyValue('align-self');\n\n  /** Sets the value of \"align-self\" */\n  void set alignSelf(String value) {\n    setProperty('align-self', value, '');\n  }\n\n  /** Gets the value of \"animation\" */\n  String get animation =>\n    getPropertyValue('animation');\n\n  /** Sets the value of \"animation\" */\n  void set animation(String value) {\n    setProperty('animation', value, '');\n  }\n\n  /** Gets the value of \"animation-delay\" */\n  String get animationDelay =>\n    getPropertyValue('animation-delay');\n\n  /** Sets the value of \"animation-delay\" */\n  void set animationDelay(String value) {\n    setProperty('animation-delay', value, '');\n  }\n\n  /** Gets the value of \"animation-direction\" */\n  String get animationDirection =>\n    getPropertyValue('animation-direction');\n\n  /** Sets the value of \"animation-direction\" */\n  void set animationDirection(String value) {\n    setProperty('animation-direction', value, '');\n  }\n\n  /** Gets the value of \"animation-duration\" */\n  String get animationDuration =>\n    getPropertyValue('animation-duration');\n\n  /** Sets the value of \"animation-duration\" */\n  void set animationDuration(String value) {\n    setProperty('animation-duration', value, '');\n  }\n\n  /** Gets the value of \"animation-fill-mode\" */\n  String get animationFillMode =>\n    getPropertyValue('animation-fill-mode');\n\n  /** Sets the value of \"animation-fill-mode\" */\n  void set animationFillMode(String value) {\n    setProperty('animation-fill-mode', value, '');\n  }\n\n  /** Gets the value of \"animation-iteration-count\" */\n  String get animationIterationCount =>\n    getPropertyValue('animation-iteration-count');\n\n  /** Sets the value of \"animation-iteration-count\" */\n  void set animationIterationCount(String value) {\n    setProperty('animation-iteration-count', value, '');\n  }\n\n  /** Gets the value of \"animation-name\" */\n  String get animationName =>\n    getPropertyValue('animation-name');\n\n  /** Sets the value of \"animation-name\" */\n  void set animationName(String value) {\n    setProperty('animation-name', value, '');\n  }\n\n  /** Gets the value of \"animation-play-state\" */\n  String get animationPlayState =>\n    getPropertyValue('animation-play-state');\n\n  /** Sets the value of \"animation-play-state\" */\n  void set animationPlayState(String value) {\n    setProperty('animation-play-state', value, '');\n  }\n\n  /** Gets the value of \"animation-timing-function\" */\n  String get animationTimingFunction =>\n    getPropertyValue('animation-timing-function');\n\n  /** Sets the value of \"animation-timing-function\" */\n  void set animationTimingFunction(String value) {\n    setProperty('animation-timing-function', value, '');\n  }\n\n  /** Gets the value of \"app-region\" */\n  String get appRegion =>\n    getPropertyValue('app-region');\n\n  /** Sets the value of \"app-region\" */\n  void set appRegion(String value) {\n    setProperty('app-region', value, '');\n  }\n\n  /** Gets the value of \"appearance\" */\n  String get appearance =>\n    getPropertyValue('appearance');\n\n  /** Sets the value of \"appearance\" */\n  void set appearance(String value) {\n    setProperty('appearance', value, '');\n  }\n\n  /** Gets the value of \"aspect-ratio\" */\n  String get aspectRatio =>\n    getPropertyValue('aspect-ratio');\n\n  /** Sets the value of \"aspect-ratio\" */\n  void set aspectRatio(String value) {\n    setProperty('aspect-ratio', value, '');\n  }\n\n  /** Gets the value of \"backface-visibility\" */\n  String get backfaceVisibility =>\n    getPropertyValue('backface-visibility');\n\n  /** Sets the value of \"backface-visibility\" */\n  void set backfaceVisibility(String value) {\n    setProperty('backface-visibility', value, '');\n  }\n\n  /** Gets the value of \"background\" */\n  String get background =>\n    getPropertyValue('background');\n\n  /** Sets the value of \"background\" */\n  void set background(String value) {\n    setProperty('background', value, '');\n  }\n\n  /** Gets the value of \"background-attachment\" */\n  String get backgroundAttachment =>\n    getPropertyValue('background-attachment');\n\n  /** Sets the value of \"background-attachment\" */\n  void set backgroundAttachment(String value) {\n    setProperty('background-attachment', value, '');\n  }\n\n  /** Gets the value of \"background-blend-mode\" */\n  String get backgroundBlendMode =>\n    getPropertyValue('background-blend-mode');\n\n  /** Sets the value of \"background-blend-mode\" */\n  void set backgroundBlendMode(String value) {\n    setProperty('background-blend-mode', value, '');\n  }\n\n  /** Gets the value of \"background-clip\" */\n  String get backgroundClip =>\n    getPropertyValue('background-clip');\n\n  /** Sets the value of \"background-clip\" */\n  void set backgroundClip(String value) {\n    setProperty('background-clip', value, '');\n  }\n\n  /** Gets the value of \"background-color\" */\n  String get backgroundColor =>\n    getPropertyValue('background-color');\n\n  /** Sets the value of \"background-color\" */\n  void set backgroundColor(String value) {\n    setProperty('background-color', value, '');\n  }\n\n  /** Gets the value of \"background-composite\" */\n  String get backgroundComposite =>\n    getPropertyValue('background-composite');\n\n  /** Sets the value of \"background-composite\" */\n  void set backgroundComposite(String value) {\n    setProperty('background-composite', value, '');\n  }\n\n  /** Gets the value of \"background-image\" */\n  String get backgroundImage =>\n    getPropertyValue('background-image');\n\n  /** Sets the value of \"background-image\" */\n  void set backgroundImage(String value) {\n    setProperty('background-image', value, '');\n  }\n\n  /** Gets the value of \"background-origin\" */\n  String get backgroundOrigin =>\n    getPropertyValue('background-origin');\n\n  /** Sets the value of \"background-origin\" */\n  void set backgroundOrigin(String value) {\n    setProperty('background-origin', value, '');\n  }\n\n  /** Gets the value of \"background-position\" */\n  String get backgroundPosition =>\n    getPropertyValue('background-position');\n\n  /** Sets the value of \"background-position\" */\n  void set backgroundPosition(String value) {\n    setProperty('background-position', value, '');\n  }\n\n  /** Gets the value of \"background-position-x\" */\n  String get backgroundPositionX =>\n    getPropertyValue('background-position-x');\n\n  /** Sets the value of \"background-position-x\" */\n  void set backgroundPositionX(String value) {\n    setProperty('background-position-x', value, '');\n  }\n\n  /** Gets the value of \"background-position-y\" */\n  String get backgroundPositionY =>\n    getPropertyValue('background-position-y');\n\n  /** Sets the value of \"background-position-y\" */\n  void set backgroundPositionY(String value) {\n    setProperty('background-position-y', value, '');\n  }\n\n  /** Gets the value of \"background-repeat\" */\n  String get backgroundRepeat =>\n    getPropertyValue('background-repeat');\n\n  /** Sets the value of \"background-repeat\" */\n  void set backgroundRepeat(String value) {\n    setProperty('background-repeat', value, '');\n  }\n\n  /** Gets the value of \"background-repeat-x\" */\n  String get backgroundRepeatX =>\n    getPropertyValue('background-repeat-x');\n\n  /** Sets the value of \"background-repeat-x\" */\n  void set backgroundRepeatX(String value) {\n    setProperty('background-repeat-x', value, '');\n  }\n\n  /** Gets the value of \"background-repeat-y\" */\n  String get backgroundRepeatY =>\n    getPropertyValue('background-repeat-y');\n\n  /** Sets the value of \"background-repeat-y\" */\n  void set backgroundRepeatY(String value) {\n    setProperty('background-repeat-y', value, '');\n  }\n\n  /** Gets the value of \"background-size\" */\n  String get backgroundSize =>\n    getPropertyValue('background-size');\n\n  /** Sets the value of \"background-size\" */\n  void set backgroundSize(String value) {\n    setProperty('background-size', value, '');\n  }\n\n  /** Gets the value of \"border\" */\n  String get border =>\n    getPropertyValue('border');\n\n  /** Sets the value of \"border\" */\n  void set border(String value) {\n    setProperty('border', value, '');\n  }\n\n  /** Gets the value of \"border-after\" */\n  String get borderAfter =>\n    getPropertyValue('border-after');\n\n  /** Sets the value of \"border-after\" */\n  void set borderAfter(String value) {\n    setProperty('border-after', value, '');\n  }\n\n  /** Gets the value of \"border-after-color\" */\n  String get borderAfterColor =>\n    getPropertyValue('border-after-color');\n\n  /** Sets the value of \"border-after-color\" */\n  void set borderAfterColor(String value) {\n    setProperty('border-after-color', value, '');\n  }\n\n  /** Gets the value of \"border-after-style\" */\n  String get borderAfterStyle =>\n    getPropertyValue('border-after-style');\n\n  /** Sets the value of \"border-after-style\" */\n  void set borderAfterStyle(String value) {\n    setProperty('border-after-style', value, '');\n  }\n\n  /** Gets the value of \"border-after-width\" */\n  String get borderAfterWidth =>\n    getPropertyValue('border-after-width');\n\n  /** Sets the value of \"border-after-width\" */\n  void set borderAfterWidth(String value) {\n    setProperty('border-after-width', value, '');\n  }\n\n  /** Gets the value of \"border-before\" */\n  String get borderBefore =>\n    getPropertyValue('border-before');\n\n  /** Sets the value of \"border-before\" */\n  void set borderBefore(String value) {\n    setProperty('border-before', value, '');\n  }\n\n  /** Gets the value of \"border-before-color\" */\n  String get borderBeforeColor =>\n    getPropertyValue('border-before-color');\n\n  /** Sets the value of \"border-before-color\" */\n  void set borderBeforeColor(String value) {\n    setProperty('border-before-color', value, '');\n  }\n\n  /** Gets the value of \"border-before-style\" */\n  String get borderBeforeStyle =>\n    getPropertyValue('border-before-style');\n\n  /** Sets the value of \"border-before-style\" */\n  void set borderBeforeStyle(String value) {\n    setProperty('border-before-style', value, '');\n  }\n\n  /** Gets the value of \"border-before-width\" */\n  String get borderBeforeWidth =>\n    getPropertyValue('border-before-width');\n\n  /** Sets the value of \"border-before-width\" */\n  void set borderBeforeWidth(String value) {\n    setProperty('border-before-width', value, '');\n  }\n\n  /** Gets the value of \"border-bottom\" */\n  String get borderBottom =>\n    getPropertyValue('border-bottom');\n\n  /** Sets the value of \"border-bottom\" */\n  void set borderBottom(String value) {\n    setProperty('border-bottom', value, '');\n  }\n\n  /** Gets the value of \"border-bottom-color\" */\n  String get borderBottomColor =>\n    getPropertyValue('border-bottom-color');\n\n  /** Sets the value of \"border-bottom-color\" */\n  void set borderBottomColor(String value) {\n    setProperty('border-bottom-color', value, '');\n  }\n\n  /** Gets the value of \"border-bottom-left-radius\" */\n  String get borderBottomLeftRadius =>\n    getPropertyValue('border-bottom-left-radius');\n\n  /** Sets the value of \"border-bottom-left-radius\" */\n  void set borderBottomLeftRadius(String value) {\n    setProperty('border-bottom-left-radius', value, '');\n  }\n\n  /** Gets the value of \"border-bottom-right-radius\" */\n  String get borderBottomRightRadius =>\n    getPropertyValue('border-bottom-right-radius');\n\n  /** Sets the value of \"border-bottom-right-radius\" */\n  void set borderBottomRightRadius(String value) {\n    setProperty('border-bottom-right-radius', value, '');\n  }\n\n  /** Gets the value of \"border-bottom-style\" */\n  String get borderBottomStyle =>\n    getPropertyValue('border-bottom-style');\n\n  /** Sets the value of \"border-bottom-style\" */\n  void set borderBottomStyle(String value) {\n    setProperty('border-bottom-style', value, '');\n  }\n\n  /** Gets the value of \"border-bottom-width\" */\n  String get borderBottomWidth =>\n    getPropertyValue('border-bottom-width');\n\n  /** Sets the value of \"border-bottom-width\" */\n  void set borderBottomWidth(String value) {\n    setProperty('border-bottom-width', value, '');\n  }\n\n  /** Gets the value of \"border-collapse\" */\n  String get borderCollapse =>\n    getPropertyValue('border-collapse');\n\n  /** Sets the value of \"border-collapse\" */\n  void set borderCollapse(String value) {\n    setProperty('border-collapse', value, '');\n  }\n\n  /** Gets the value of \"border-color\" */\n  String get borderColor =>\n    getPropertyValue('border-color');\n\n  /** Sets the value of \"border-color\" */\n  void set borderColor(String value) {\n    setProperty('border-color', value, '');\n  }\n\n  /** Gets the value of \"border-end\" */\n  String get borderEnd =>\n    getPropertyValue('border-end');\n\n  /** Sets the value of \"border-end\" */\n  void set borderEnd(String value) {\n    setProperty('border-end', value, '');\n  }\n\n  /** Gets the value of \"border-end-color\" */\n  String get borderEndColor =>\n    getPropertyValue('border-end-color');\n\n  /** Sets the value of \"border-end-color\" */\n  void set borderEndColor(String value) {\n    setProperty('border-end-color', value, '');\n  }\n\n  /** Gets the value of \"border-end-style\" */\n  String get borderEndStyle =>\n    getPropertyValue('border-end-style');\n\n  /** Sets the value of \"border-end-style\" */\n  void set borderEndStyle(String value) {\n    setProperty('border-end-style', value, '');\n  }\n\n  /** Gets the value of \"border-end-width\" */\n  String get borderEndWidth =>\n    getPropertyValue('border-end-width');\n\n  /** Sets the value of \"border-end-width\" */\n  void set borderEndWidth(String value) {\n    setProperty('border-end-width', value, '');\n  }\n\n  /** Gets the value of \"border-fit\" */\n  String get borderFit =>\n    getPropertyValue('border-fit');\n\n  /** Sets the value of \"border-fit\" */\n  void set borderFit(String value) {\n    setProperty('border-fit', value, '');\n  }\n\n  /** Gets the value of \"border-horizontal-spacing\" */\n  String get borderHorizontalSpacing =>\n    getPropertyValue('border-horizontal-spacing');\n\n  /** Sets the value of \"border-horizontal-spacing\" */\n  void set borderHorizontalSpacing(String value) {\n    setProperty('border-horizontal-spacing', value, '');\n  }\n\n  /** Gets the value of \"border-image\" */\n  String get borderImage =>\n    getPropertyValue('border-image');\n\n  /** Sets the value of \"border-image\" */\n  void set borderImage(String value) {\n    setProperty('border-image', value, '');\n  }\n\n  /** Gets the value of \"border-image-outset\" */\n  String get borderImageOutset =>\n    getPropertyValue('border-image-outset');\n\n  /** Sets the value of \"border-image-outset\" */\n  void set borderImageOutset(String value) {\n    setProperty('border-image-outset', value, '');\n  }\n\n  /** Gets the value of \"border-image-repeat\" */\n  String get borderImageRepeat =>\n    getPropertyValue('border-image-repeat');\n\n  /** Sets the value of \"border-image-repeat\" */\n  void set borderImageRepeat(String value) {\n    setProperty('border-image-repeat', value, '');\n  }\n\n  /** Gets the value of \"border-image-slice\" */\n  String get borderImageSlice =>\n    getPropertyValue('border-image-slice');\n\n  /** Sets the value of \"border-image-slice\" */\n  void set borderImageSlice(String value) {\n    setProperty('border-image-slice', value, '');\n  }\n\n  /** Gets the value of \"border-image-source\" */\n  String get borderImageSource =>\n    getPropertyValue('border-image-source');\n\n  /** Sets the value of \"border-image-source\" */\n  void set borderImageSource(String value) {\n    setProperty('border-image-source', value, '');\n  }\n\n  /** Gets the value of \"border-image-width\" */\n  String get borderImageWidth =>\n    getPropertyValue('border-image-width');\n\n  /** Sets the value of \"border-image-width\" */\n  void set borderImageWidth(String value) {\n    setProperty('border-image-width', value, '');\n  }\n\n  /** Gets the value of \"border-left\" */\n  String get borderLeft =>\n    getPropertyValue('border-left');\n\n  /** Sets the value of \"border-left\" */\n  void set borderLeft(String value) {\n    setProperty('border-left', value, '');\n  }\n\n  /** Gets the value of \"border-left-color\" */\n  String get borderLeftColor =>\n    getPropertyValue('border-left-color');\n\n  /** Sets the value of \"border-left-color\" */\n  void set borderLeftColor(String value) {\n    setProperty('border-left-color', value, '');\n  }\n\n  /** Gets the value of \"border-left-style\" */\n  String get borderLeftStyle =>\n    getPropertyValue('border-left-style');\n\n  /** Sets the value of \"border-left-style\" */\n  void set borderLeftStyle(String value) {\n    setProperty('border-left-style', value, '');\n  }\n\n  /** Gets the value of \"border-left-width\" */\n  String get borderLeftWidth =>\n    getPropertyValue('border-left-width');\n\n  /** Sets the value of \"border-left-width\" */\n  void set borderLeftWidth(String value) {\n    setProperty('border-left-width', value, '');\n  }\n\n  /** Gets the value of \"border-radius\" */\n  String get borderRadius =>\n    getPropertyValue('border-radius');\n\n  /** Sets the value of \"border-radius\" */\n  void set borderRadius(String value) {\n    setProperty('border-radius', value, '');\n  }\n\n  /** Gets the value of \"border-right\" */\n  String get borderRight =>\n    getPropertyValue('border-right');\n\n  /** Sets the value of \"border-right\" */\n  void set borderRight(String value) {\n    setProperty('border-right', value, '');\n  }\n\n  /** Gets the value of \"border-right-color\" */\n  String get borderRightColor =>\n    getPropertyValue('border-right-color');\n\n  /** Sets the value of \"border-right-color\" */\n  void set borderRightColor(String value) {\n    setProperty('border-right-color', value, '');\n  }\n\n  /** Gets the value of \"border-right-style\" */\n  String get borderRightStyle =>\n    getPropertyValue('border-right-style');\n\n  /** Sets the value of \"border-right-style\" */\n  void set borderRightStyle(String value) {\n    setProperty('border-right-style', value, '');\n  }\n\n  /** Gets the value of \"border-right-width\" */\n  String get borderRightWidth =>\n    getPropertyValue('border-right-width');\n\n  /** Sets the value of \"border-right-width\" */\n  void set borderRightWidth(String value) {\n    setProperty('border-right-width', value, '');\n  }\n\n  /** Gets the value of \"border-spacing\" */\n  String get borderSpacing =>\n    getPropertyValue('border-spacing');\n\n  /** Sets the value of \"border-spacing\" */\n  void set borderSpacing(String value) {\n    setProperty('border-spacing', value, '');\n  }\n\n  /** Gets the value of \"border-start\" */\n  String get borderStart =>\n    getPropertyValue('border-start');\n\n  /** Sets the value of \"border-start\" */\n  void set borderStart(String value) {\n    setProperty('border-start', value, '');\n  }\n\n  /** Gets the value of \"border-start-color\" */\n  String get borderStartColor =>\n    getPropertyValue('border-start-color');\n\n  /** Sets the value of \"border-start-color\" */\n  void set borderStartColor(String value) {\n    setProperty('border-start-color', value, '');\n  }\n\n  /** Gets the value of \"border-start-style\" */\n  String get borderStartStyle =>\n    getPropertyValue('border-start-style');\n\n  /** Sets the value of \"border-start-style\" */\n  void set borderStartStyle(String value) {\n    setProperty('border-start-style', value, '');\n  }\n\n  /** Gets the value of \"border-start-width\" */\n  String get borderStartWidth =>\n    getPropertyValue('border-start-width');\n\n  /** Sets the value of \"border-start-width\" */\n  void set borderStartWidth(String value) {\n    setProperty('border-start-width', value, '');\n  }\n\n  /** Gets the value of \"border-style\" */\n  String get borderStyle =>\n    getPropertyValue('border-style');\n\n  /** Sets the value of \"border-style\" */\n  void set borderStyle(String value) {\n    setProperty('border-style', value, '');\n  }\n\n  /** Gets the value of \"border-top\" */\n  String get borderTop =>\n    getPropertyValue('border-top');\n\n  /** Sets the value of \"border-top\" */\n  void set borderTop(String value) {\n    setProperty('border-top', value, '');\n  }\n\n  /** Gets the value of \"border-top-color\" */\n  String get borderTopColor =>\n    getPropertyValue('border-top-color');\n\n  /** Sets the value of \"border-top-color\" */\n  void set borderTopColor(String value) {\n    setProperty('border-top-color', value, '');\n  }\n\n  /** Gets the value of \"border-top-left-radius\" */\n  String get borderTopLeftRadius =>\n    getPropertyValue('border-top-left-radius');\n\n  /** Sets the value of \"border-top-left-radius\" */\n  void set borderTopLeftRadius(String value) {\n    setProperty('border-top-left-radius', value, '');\n  }\n\n  /** Gets the value of \"border-top-right-radius\" */\n  String get borderTopRightRadius =>\n    getPropertyValue('border-top-right-radius');\n\n  /** Sets the value of \"border-top-right-radius\" */\n  void set borderTopRightRadius(String value) {\n    setProperty('border-top-right-radius', value, '');\n  }\n\n  /** Gets the value of \"border-top-style\" */\n  String get borderTopStyle =>\n    getPropertyValue('border-top-style');\n\n  /** Sets the value of \"border-top-style\" */\n  void set borderTopStyle(String value) {\n    setProperty('border-top-style', value, '');\n  }\n\n  /** Gets the value of \"border-top-width\" */\n  String get borderTopWidth =>\n    getPropertyValue('border-top-width');\n\n  /** Sets the value of \"border-top-width\" */\n  void set borderTopWidth(String value) {\n    setProperty('border-top-width', value, '');\n  }\n\n  /** Gets the value of \"border-vertical-spacing\" */\n  String get borderVerticalSpacing =>\n    getPropertyValue('border-vertical-spacing');\n\n  /** Sets the value of \"border-vertical-spacing\" */\n  void set borderVerticalSpacing(String value) {\n    setProperty('border-vertical-spacing', value, '');\n  }\n\n  /** Gets the value of \"border-width\" */\n  String get borderWidth =>\n    getPropertyValue('border-width');\n\n  /** Sets the value of \"border-width\" */\n  void set borderWidth(String value) {\n    setProperty('border-width', value, '');\n  }\n\n  /** Gets the value of \"bottom\" */\n  String get bottom =>\n    getPropertyValue('bottom');\n\n  /** Sets the value of \"bottom\" */\n  void set bottom(String value) {\n    setProperty('bottom', value, '');\n  }\n\n  /** Gets the value of \"box-align\" */\n  String get boxAlign =>\n    getPropertyValue('box-align');\n\n  /** Sets the value of \"box-align\" */\n  void set boxAlign(String value) {\n    setProperty('box-align', value, '');\n  }\n\n  /** Gets the value of \"box-decoration-break\" */\n  String get boxDecorationBreak =>\n    getPropertyValue('box-decoration-break');\n\n  /** Sets the value of \"box-decoration-break\" */\n  void set boxDecorationBreak(String value) {\n    setProperty('box-decoration-break', value, '');\n  }\n\n  /** Gets the value of \"box-direction\" */\n  String get boxDirection =>\n    getPropertyValue('box-direction');\n\n  /** Sets the value of \"box-direction\" */\n  void set boxDirection(String value) {\n    setProperty('box-direction', value, '');\n  }\n\n  /** Gets the value of \"box-flex\" */\n  String get boxFlex =>\n    getPropertyValue('box-flex');\n\n  /** Sets the value of \"box-flex\" */\n  void set boxFlex(String value) {\n    setProperty('box-flex', value, '');\n  }\n\n  /** Gets the value of \"box-flex-group\" */\n  String get boxFlexGroup =>\n    getPropertyValue('box-flex-group');\n\n  /** Sets the value of \"box-flex-group\" */\n  void set boxFlexGroup(String value) {\n    setProperty('box-flex-group', value, '');\n  }\n\n  /** Gets the value of \"box-lines\" */\n  String get boxLines =>\n    getPropertyValue('box-lines');\n\n  /** Sets the value of \"box-lines\" */\n  void set boxLines(String value) {\n    setProperty('box-lines', value, '');\n  }\n\n  /** Gets the value of \"box-ordinal-group\" */\n  String get boxOrdinalGroup =>\n    getPropertyValue('box-ordinal-group');\n\n  /** Sets the value of \"box-ordinal-group\" */\n  void set boxOrdinalGroup(String value) {\n    setProperty('box-ordinal-group', value, '');\n  }\n\n  /** Gets the value of \"box-orient\" */\n  String get boxOrient =>\n    getPropertyValue('box-orient');\n\n  /** Sets the value of \"box-orient\" */\n  void set boxOrient(String value) {\n    setProperty('box-orient', value, '');\n  }\n\n  /** Gets the value of \"box-pack\" */\n  String get boxPack =>\n    getPropertyValue('box-pack');\n\n  /** Sets the value of \"box-pack\" */\n  void set boxPack(String value) {\n    setProperty('box-pack', value, '');\n  }\n\n  /** Gets the value of \"box-reflect\" */\n  String get boxReflect =>\n    getPropertyValue('box-reflect');\n\n  /** Sets the value of \"box-reflect\" */\n  void set boxReflect(String value) {\n    setProperty('box-reflect', value, '');\n  }\n\n  /** Gets the value of \"box-shadow\" */\n  String get boxShadow =>\n    getPropertyValue('box-shadow');\n\n  /** Sets the value of \"box-shadow\" */\n  void set boxShadow(String value) {\n    setProperty('box-shadow', value, '');\n  }\n\n  /** Gets the value of \"box-sizing\" */\n  String get boxSizing =>\n    getPropertyValue('box-sizing');\n\n  /** Sets the value of \"box-sizing\" */\n  void set boxSizing(String value) {\n    setProperty('box-sizing', value, '');\n  }\n\n  /** Gets the value of \"caption-side\" */\n  String get captionSide =>\n    getPropertyValue('caption-side');\n\n  /** Sets the value of \"caption-side\" */\n  void set captionSide(String value) {\n    setProperty('caption-side', value, '');\n  }\n\n  /** Gets the value of \"clear\" */\n  String get clear =>\n    getPropertyValue('clear');\n\n  /** Sets the value of \"clear\" */\n  void set clear(String value) {\n    setProperty('clear', value, '');\n  }\n\n  /** Gets the value of \"clip\" */\n  String get clip =>\n    getPropertyValue('clip');\n\n  /** Sets the value of \"clip\" */\n  void set clip(String value) {\n    setProperty('clip', value, '');\n  }\n\n  /** Gets the value of \"clip-path\" */\n  String get clipPath =>\n    getPropertyValue('clip-path');\n\n  /** Sets the value of \"clip-path\" */\n  void set clipPath(String value) {\n    setProperty('clip-path', value, '');\n  }\n\n  /** Gets the value of \"color\" */\n  String get color =>\n    getPropertyValue('color');\n\n  /** Sets the value of \"color\" */\n  void set color(String value) {\n    setProperty('color', value, '');\n  }\n\n  /** Gets the value of \"column-break-after\" */\n  String get columnBreakAfter =>\n    getPropertyValue('column-break-after');\n\n  /** Sets the value of \"column-break-after\" */\n  void set columnBreakAfter(String value) {\n    setProperty('column-break-after', value, '');\n  }\n\n  /** Gets the value of \"column-break-before\" */\n  String get columnBreakBefore =>\n    getPropertyValue('column-break-before');\n\n  /** Sets the value of \"column-break-before\" */\n  void set columnBreakBefore(String value) {\n    setProperty('column-break-before', value, '');\n  }\n\n  /** Gets the value of \"column-break-inside\" */\n  String get columnBreakInside =>\n    getPropertyValue('column-break-inside');\n\n  /** Sets the value of \"column-break-inside\" */\n  void set columnBreakInside(String value) {\n    setProperty('column-break-inside', value, '');\n  }\n\n  /** Gets the value of \"column-count\" */\n  String get columnCount =>\n    getPropertyValue('column-count');\n\n  /** Sets the value of \"column-count\" */\n  void set columnCount(String value) {\n    setProperty('column-count', value, '');\n  }\n\n  /** Gets the value of \"column-fill\" */\n  String get columnFill =>\n    getPropertyValue('column-fill');\n\n  /** Sets the value of \"column-fill\" */\n  void set columnFill(String value) {\n    setProperty('column-fill', value, '');\n  }\n\n  /** Gets the value of \"column-gap\" */\n  String get columnGap =>\n    getPropertyValue('column-gap');\n\n  /** Sets the value of \"column-gap\" */\n  void set columnGap(String value) {\n    setProperty('column-gap', value, '');\n  }\n\n  /** Gets the value of \"column-rule\" */\n  String get columnRule =>\n    getPropertyValue('column-rule');\n\n  /** Sets the value of \"column-rule\" */\n  void set columnRule(String value) {\n    setProperty('column-rule', value, '');\n  }\n\n  /** Gets the value of \"column-rule-color\" */\n  String get columnRuleColor =>\n    getPropertyValue('column-rule-color');\n\n  /** Sets the value of \"column-rule-color\" */\n  void set columnRuleColor(String value) {\n    setProperty('column-rule-color', value, '');\n  }\n\n  /** Gets the value of \"column-rule-style\" */\n  String get columnRuleStyle =>\n    getPropertyValue('column-rule-style');\n\n  /** Sets the value of \"column-rule-style\" */\n  void set columnRuleStyle(String value) {\n    setProperty('column-rule-style', value, '');\n  }\n\n  /** Gets the value of \"column-rule-width\" */\n  String get columnRuleWidth =>\n    getPropertyValue('column-rule-width');\n\n  /** Sets the value of \"column-rule-width\" */\n  void set columnRuleWidth(String value) {\n    setProperty('column-rule-width', value, '');\n  }\n\n  /** Gets the value of \"column-span\" */\n  String get columnSpan =>\n    getPropertyValue('column-span');\n\n  /** Sets the value of \"column-span\" */\n  void set columnSpan(String value) {\n    setProperty('column-span', value, '');\n  }\n\n  /** Gets the value of \"column-width\" */\n  String get columnWidth =>\n    getPropertyValue('column-width');\n\n  /** Sets the value of \"column-width\" */\n  void set columnWidth(String value) {\n    setProperty('column-width', value, '');\n  }\n\n  /** Gets the value of \"columns\" */\n  String get columns =>\n    getPropertyValue('columns');\n\n  /** Sets the value of \"columns\" */\n  void set columns(String value) {\n    setProperty('columns', value, '');\n  }\n\n  /** Gets the value of \"content\" */\n  String get content =>\n    getPropertyValue('content');\n\n  /** Sets the value of \"content\" */\n  void set content(String value) {\n    setProperty('content', value, '');\n  }\n\n  /** Gets the value of \"counter-increment\" */\n  String get counterIncrement =>\n    getPropertyValue('counter-increment');\n\n  /** Sets the value of \"counter-increment\" */\n  void set counterIncrement(String value) {\n    setProperty('counter-increment', value, '');\n  }\n\n  /** Gets the value of \"counter-reset\" */\n  String get counterReset =>\n    getPropertyValue('counter-reset');\n\n  /** Sets the value of \"counter-reset\" */\n  void set counterReset(String value) {\n    setProperty('counter-reset', value, '');\n  }\n\n  /** Gets the value of \"cursor\" */\n  String get cursor =>\n    getPropertyValue('cursor');\n\n  /** Sets the value of \"cursor\" */\n  void set cursor(String value) {\n    setProperty('cursor', value, '');\n  }\n\n  /** Gets the value of \"direction\" */\n  String get direction =>\n    getPropertyValue('direction');\n\n  /** Sets the value of \"direction\" */\n  void set direction(String value) {\n    setProperty('direction', value, '');\n  }\n\n  /** Gets the value of \"display\" */\n  String get display =>\n    getPropertyValue('display');\n\n  /** Sets the value of \"display\" */\n  void set display(String value) {\n    setProperty('display', value, '');\n  }\n\n  /** Gets the value of \"empty-cells\" */\n  String get emptyCells =>\n    getPropertyValue('empty-cells');\n\n  /** Sets the value of \"empty-cells\" */\n  void set emptyCells(String value) {\n    setProperty('empty-cells', value, '');\n  }\n\n  /** Gets the value of \"filter\" */\n  String get filter =>\n    getPropertyValue('filter');\n\n  /** Sets the value of \"filter\" */\n  void set filter(String value) {\n    setProperty('filter', value, '');\n  }\n\n  /** Gets the value of \"flex\" */\n  String get flex =>\n    getPropertyValue('flex');\n\n  /** Sets the value of \"flex\" */\n  void set flex(String value) {\n    setProperty('flex', value, '');\n  }\n\n  /** Gets the value of \"flex-basis\" */\n  String get flexBasis =>\n    getPropertyValue('flex-basis');\n\n  /** Sets the value of \"flex-basis\" */\n  void set flexBasis(String value) {\n    setProperty('flex-basis', value, '');\n  }\n\n  /** Gets the value of \"flex-direction\" */\n  String get flexDirection =>\n    getPropertyValue('flex-direction');\n\n  /** Sets the value of \"flex-direction\" */\n  void set flexDirection(String value) {\n    setProperty('flex-direction', value, '');\n  }\n\n  /** Gets the value of \"flex-flow\" */\n  String get flexFlow =>\n    getPropertyValue('flex-flow');\n\n  /** Sets the value of \"flex-flow\" */\n  void set flexFlow(String value) {\n    setProperty('flex-flow', value, '');\n  }\n\n  /** Gets the value of \"flex-grow\" */\n  String get flexGrow =>\n    getPropertyValue('flex-grow');\n\n  /** Sets the value of \"flex-grow\" */\n  void set flexGrow(String value) {\n    setProperty('flex-grow', value, '');\n  }\n\n  /** Gets the value of \"flex-shrink\" */\n  String get flexShrink =>\n    getPropertyValue('flex-shrink');\n\n  /** Sets the value of \"flex-shrink\" */\n  void set flexShrink(String value) {\n    setProperty('flex-shrink', value, '');\n  }\n\n  /** Gets the value of \"flex-wrap\" */\n  String get flexWrap =>\n    getPropertyValue('flex-wrap');\n\n  /** Sets the value of \"flex-wrap\" */\n  void set flexWrap(String value) {\n    setProperty('flex-wrap', value, '');\n  }\n\n  /** Gets the value of \"float\" */\n  String get float =>\n    getPropertyValue('float');\n\n  /** Sets the value of \"float\" */\n  void set float(String value) {\n    setProperty('float', value, '');\n  }\n\n  /** Gets the value of \"font\" */\n  String get font =>\n    getPropertyValue('font');\n\n  /** Sets the value of \"font\" */\n  void set font(String value) {\n    setProperty('font', value, '');\n  }\n\n  /** Gets the value of \"font-family\" */\n  String get fontFamily =>\n    getPropertyValue('font-family');\n\n  /** Sets the value of \"font-family\" */\n  void set fontFamily(String value) {\n    setProperty('font-family', value, '');\n  }\n\n  /** Gets the value of \"font-feature-settings\" */\n  String get fontFeatureSettings =>\n    getPropertyValue('font-feature-settings');\n\n  /** Sets the value of \"font-feature-settings\" */\n  void set fontFeatureSettings(String value) {\n    setProperty('font-feature-settings', value, '');\n  }\n\n  /** Gets the value of \"font-kerning\" */\n  String get fontKerning =>\n    getPropertyValue('font-kerning');\n\n  /** Sets the value of \"font-kerning\" */\n  void set fontKerning(String value) {\n    setProperty('font-kerning', value, '');\n  }\n\n  /** Gets the value of \"font-size\" */\n  String get fontSize =>\n    getPropertyValue('font-size');\n\n  /** Sets the value of \"font-size\" */\n  void set fontSize(String value) {\n    setProperty('font-size', value, '');\n  }\n\n  /** Gets the value of \"font-size-delta\" */\n  String get fontSizeDelta =>\n    getPropertyValue('font-size-delta');\n\n  /** Sets the value of \"font-size-delta\" */\n  void set fontSizeDelta(String value) {\n    setProperty('font-size-delta', value, '');\n  }\n\n  /** Gets the value of \"font-smoothing\" */\n  String get fontSmoothing =>\n    getPropertyValue('font-smoothing');\n\n  /** Sets the value of \"font-smoothing\" */\n  void set fontSmoothing(String value) {\n    setProperty('font-smoothing', value, '');\n  }\n\n  /** Gets the value of \"font-stretch\" */\n  String get fontStretch =>\n    getPropertyValue('font-stretch');\n\n  /** Sets the value of \"font-stretch\" */\n  void set fontStretch(String value) {\n    setProperty('font-stretch', value, '');\n  }\n\n  /** Gets the value of \"font-style\" */\n  String get fontStyle =>\n    getPropertyValue('font-style');\n\n  /** Sets the value of \"font-style\" */\n  void set fontStyle(String value) {\n    setProperty('font-style', value, '');\n  }\n\n  /** Gets the value of \"font-variant\" */\n  String get fontVariant =>\n    getPropertyValue('font-variant');\n\n  /** Sets the value of \"font-variant\" */\n  void set fontVariant(String value) {\n    setProperty('font-variant', value, '');\n  }\n\n  /** Gets the value of \"font-variant-ligatures\" */\n  String get fontVariantLigatures =>\n    getPropertyValue('font-variant-ligatures');\n\n  /** Sets the value of \"font-variant-ligatures\" */\n  void set fontVariantLigatures(String value) {\n    setProperty('font-variant-ligatures', value, '');\n  }\n\n  /** Gets the value of \"font-weight\" */\n  String get fontWeight =>\n    getPropertyValue('font-weight');\n\n  /** Sets the value of \"font-weight\" */\n  void set fontWeight(String value) {\n    setProperty('font-weight', value, '');\n  }\n\n  /** Gets the value of \"grid\" */\n  String get grid =>\n    getPropertyValue('grid');\n\n  /** Sets the value of \"grid\" */\n  void set grid(String value) {\n    setProperty('grid', value, '');\n  }\n\n  /** Gets the value of \"grid-area\" */\n  String get gridArea =>\n    getPropertyValue('grid-area');\n\n  /** Sets the value of \"grid-area\" */\n  void set gridArea(String value) {\n    setProperty('grid-area', value, '');\n  }\n\n  /** Gets the value of \"grid-auto-columns\" */\n  String get gridAutoColumns =>\n    getPropertyValue('grid-auto-columns');\n\n  /** Sets the value of \"grid-auto-columns\" */\n  void set gridAutoColumns(String value) {\n    setProperty('grid-auto-columns', value, '');\n  }\n\n  /** Gets the value of \"grid-auto-flow\" */\n  String get gridAutoFlow =>\n    getPropertyValue('grid-auto-flow');\n\n  /** Sets the value of \"grid-auto-flow\" */\n  void set gridAutoFlow(String value) {\n    setProperty('grid-auto-flow', value, '');\n  }\n\n  /** Gets the value of \"grid-auto-rows\" */\n  String get gridAutoRows =>\n    getPropertyValue('grid-auto-rows');\n\n  /** Sets the value of \"grid-auto-rows\" */\n  void set gridAutoRows(String value) {\n    setProperty('grid-auto-rows', value, '');\n  }\n\n  /** Gets the value of \"grid-column\" */\n  String get gridColumn =>\n    getPropertyValue('grid-column');\n\n  /** Sets the value of \"grid-column\" */\n  void set gridColumn(String value) {\n    setProperty('grid-column', value, '');\n  }\n\n  /** Gets the value of \"grid-column-end\" */\n  String get gridColumnEnd =>\n    getPropertyValue('grid-column-end');\n\n  /** Sets the value of \"grid-column-end\" */\n  void set gridColumnEnd(String value) {\n    setProperty('grid-column-end', value, '');\n  }\n\n  /** Gets the value of \"grid-column-start\" */\n  String get gridColumnStart =>\n    getPropertyValue('grid-column-start');\n\n  /** Sets the value of \"grid-column-start\" */\n  void set gridColumnStart(String value) {\n    setProperty('grid-column-start', value, '');\n  }\n\n  /** Gets the value of \"grid-row\" */\n  String get gridRow =>\n    getPropertyValue('grid-row');\n\n  /** Sets the value of \"grid-row\" */\n  void set gridRow(String value) {\n    setProperty('grid-row', value, '');\n  }\n\n  /** Gets the value of \"grid-row-end\" */\n  String get gridRowEnd =>\n    getPropertyValue('grid-row-end');\n\n  /** Sets the value of \"grid-row-end\" */\n  void set gridRowEnd(String value) {\n    setProperty('grid-row-end', value, '');\n  }\n\n  /** Gets the value of \"grid-row-start\" */\n  String get gridRowStart =>\n    getPropertyValue('grid-row-start');\n\n  /** Sets the value of \"grid-row-start\" */\n  void set gridRowStart(String value) {\n    setProperty('grid-row-start', value, '');\n  }\n\n  /** Gets the value of \"grid-template\" */\n  String get gridTemplate =>\n    getPropertyValue('grid-template');\n\n  /** Sets the value of \"grid-template\" */\n  void set gridTemplate(String value) {\n    setProperty('grid-template', value, '');\n  }\n\n  /** Gets the value of \"grid-template-areas\" */\n  String get gridTemplateAreas =>\n    getPropertyValue('grid-template-areas');\n\n  /** Sets the value of \"grid-template-areas\" */\n  void set gridTemplateAreas(String value) {\n    setProperty('grid-template-areas', value, '');\n  }\n\n  /** Gets the value of \"grid-template-columns\" */\n  String get gridTemplateColumns =>\n    getPropertyValue('grid-template-columns');\n\n  /** Sets the value of \"grid-template-columns\" */\n  void set gridTemplateColumns(String value) {\n    setProperty('grid-template-columns', value, '');\n  }\n\n  /** Gets the value of \"grid-template-rows\" */\n  String get gridTemplateRows =>\n    getPropertyValue('grid-template-rows');\n\n  /** Sets the value of \"grid-template-rows\" */\n  void set gridTemplateRows(String value) {\n    setProperty('grid-template-rows', value, '');\n  }\n\n  /** Gets the value of \"height\" */\n  String get height =>\n    getPropertyValue('height');\n\n  /** Sets the value of \"height\" */\n  void set height(String value) {\n    setProperty('height', value, '');\n  }\n\n  /** Gets the value of \"highlight\" */\n  String get highlight =>\n    getPropertyValue('highlight');\n\n  /** Sets the value of \"highlight\" */\n  void set highlight(String value) {\n    setProperty('highlight', value, '');\n  }\n\n  /** Gets the value of \"hyphenate-character\" */\n  String get hyphenateCharacter =>\n    getPropertyValue('hyphenate-character');\n\n  /** Sets the value of \"hyphenate-character\" */\n  void set hyphenateCharacter(String value) {\n    setProperty('hyphenate-character', value, '');\n  }\n\n  /** Gets the value of \"image-rendering\" */\n  String get imageRendering =>\n    getPropertyValue('image-rendering');\n\n  /** Sets the value of \"image-rendering\" */\n  void set imageRendering(String value) {\n    setProperty('image-rendering', value, '');\n  }\n\n  /** Gets the value of \"isolation\" */\n  String get isolation =>\n    getPropertyValue('isolation');\n\n  /** Sets the value of \"isolation\" */\n  void set isolation(String value) {\n    setProperty('isolation', value, '');\n  }\n\n  /** Gets the value of \"justify-content\" */\n  String get justifyContent =>\n    getPropertyValue('justify-content');\n\n  /** Sets the value of \"justify-content\" */\n  void set justifyContent(String value) {\n    setProperty('justify-content', value, '');\n  }\n\n  /** Gets the value of \"justify-self\" */\n  String get justifySelf =>\n    getPropertyValue('justify-self');\n\n  /** Sets the value of \"justify-self\" */\n  void set justifySelf(String value) {\n    setProperty('justify-self', value, '');\n  }\n\n  /** Gets the value of \"left\" */\n  String get left =>\n    getPropertyValue('left');\n\n  /** Sets the value of \"left\" */\n  void set left(String value) {\n    setProperty('left', value, '');\n  }\n\n  /** Gets the value of \"letter-spacing\" */\n  String get letterSpacing =>\n    getPropertyValue('letter-spacing');\n\n  /** Sets the value of \"letter-spacing\" */\n  void set letterSpacing(String value) {\n    setProperty('letter-spacing', value, '');\n  }\n\n  /** Gets the value of \"line-box-contain\" */\n  String get lineBoxContain =>\n    getPropertyValue('line-box-contain');\n\n  /** Sets the value of \"line-box-contain\" */\n  void set lineBoxContain(String value) {\n    setProperty('line-box-contain', value, '');\n  }\n\n  /** Gets the value of \"line-break\" */\n  String get lineBreak =>\n    getPropertyValue('line-break');\n\n  /** Sets the value of \"line-break\" */\n  void set lineBreak(String value) {\n    setProperty('line-break', value, '');\n  }\n\n  /** Gets the value of \"line-clamp\" */\n  String get lineClamp =>\n    getPropertyValue('line-clamp');\n\n  /** Sets the value of \"line-clamp\" */\n  void set lineClamp(String value) {\n    setProperty('line-clamp', value, '');\n  }\n\n  /** Gets the value of \"line-height\" */\n  String get lineHeight =>\n    getPropertyValue('line-height');\n\n  /** Sets the value of \"line-height\" */\n  void set lineHeight(String value) {\n    setProperty('line-height', value, '');\n  }\n\n  /** Gets the value of \"list-style\" */\n  String get listStyle =>\n    getPropertyValue('list-style');\n\n  /** Sets the value of \"list-style\" */\n  void set listStyle(String value) {\n    setProperty('list-style', value, '');\n  }\n\n  /** Gets the value of \"list-style-image\" */\n  String get listStyleImage =>\n    getPropertyValue('list-style-image');\n\n  /** Sets the value of \"list-style-image\" */\n  void set listStyleImage(String value) {\n    setProperty('list-style-image', value, '');\n  }\n\n  /** Gets the value of \"list-style-position\" */\n  String get listStylePosition =>\n    getPropertyValue('list-style-position');\n\n  /** Sets the value of \"list-style-position\" */\n  void set listStylePosition(String value) {\n    setProperty('list-style-position', value, '');\n  }\n\n  /** Gets the value of \"list-style-type\" */\n  String get listStyleType =>\n    getPropertyValue('list-style-type');\n\n  /** Sets the value of \"list-style-type\" */\n  void set listStyleType(String value) {\n    setProperty('list-style-type', value, '');\n  }\n\n  /** Gets the value of \"locale\" */\n  String get locale =>\n    getPropertyValue('locale');\n\n  /** Sets the value of \"locale\" */\n  void set locale(String value) {\n    setProperty('locale', value, '');\n  }\n\n  /** Gets the value of \"logical-height\" */\n  String get logicalHeight =>\n    getPropertyValue('logical-height');\n\n  /** Sets the value of \"logical-height\" */\n  void set logicalHeight(String value) {\n    setProperty('logical-height', value, '');\n  }\n\n  /** Gets the value of \"logical-width\" */\n  String get logicalWidth =>\n    getPropertyValue('logical-width');\n\n  /** Sets the value of \"logical-width\" */\n  void set logicalWidth(String value) {\n    setProperty('logical-width', value, '');\n  }\n\n  /** Gets the value of \"margin\" */\n  String get margin =>\n    getPropertyValue('margin');\n\n  /** Sets the value of \"margin\" */\n  void set margin(String value) {\n    setProperty('margin', value, '');\n  }\n\n  /** Gets the value of \"margin-after\" */\n  String get marginAfter =>\n    getPropertyValue('margin-after');\n\n  /** Sets the value of \"margin-after\" */\n  void set marginAfter(String value) {\n    setProperty('margin-after', value, '');\n  }\n\n  /** Gets the value of \"margin-after-collapse\" */\n  String get marginAfterCollapse =>\n    getPropertyValue('margin-after-collapse');\n\n  /** Sets the value of \"margin-after-collapse\" */\n  void set marginAfterCollapse(String value) {\n    setProperty('margin-after-collapse', value, '');\n  }\n\n  /** Gets the value of \"margin-before\" */\n  String get marginBefore =>\n    getPropertyValue('margin-before');\n\n  /** Sets the value of \"margin-before\" */\n  void set marginBefore(String value) {\n    setProperty('margin-before', value, '');\n  }\n\n  /** Gets the value of \"margin-before-collapse\" */\n  String get marginBeforeCollapse =>\n    getPropertyValue('margin-before-collapse');\n\n  /** Sets the value of \"margin-before-collapse\" */\n  void set marginBeforeCollapse(String value) {\n    setProperty('margin-before-collapse', value, '');\n  }\n\n  /** Gets the value of \"margin-bottom\" */\n  String get marginBottom =>\n    getPropertyValue('margin-bottom');\n\n  /** Sets the value of \"margin-bottom\" */\n  void set marginBottom(String value) {\n    setProperty('margin-bottom', value, '');\n  }\n\n  /** Gets the value of \"margin-bottom-collapse\" */\n  String get marginBottomCollapse =>\n    getPropertyValue('margin-bottom-collapse');\n\n  /** Sets the value of \"margin-bottom-collapse\" */\n  void set marginBottomCollapse(String value) {\n    setProperty('margin-bottom-collapse', value, '');\n  }\n\n  /** Gets the value of \"margin-collapse\" */\n  String get marginCollapse =>\n    getPropertyValue('margin-collapse');\n\n  /** Sets the value of \"margin-collapse\" */\n  void set marginCollapse(String value) {\n    setProperty('margin-collapse', value, '');\n  }\n\n  /** Gets the value of \"margin-end\" */\n  String get marginEnd =>\n    getPropertyValue('margin-end');\n\n  /** Sets the value of \"margin-end\" */\n  void set marginEnd(String value) {\n    setProperty('margin-end', value, '');\n  }\n\n  /** Gets the value of \"margin-left\" */\n  String get marginLeft =>\n    getPropertyValue('margin-left');\n\n  /** Sets the value of \"margin-left\" */\n  void set marginLeft(String value) {\n    setProperty('margin-left', value, '');\n  }\n\n  /** Gets the value of \"margin-right\" */\n  String get marginRight =>\n    getPropertyValue('margin-right');\n\n  /** Sets the value of \"margin-right\" */\n  void set marginRight(String value) {\n    setProperty('margin-right', value, '');\n  }\n\n  /** Gets the value of \"margin-start\" */\n  String get marginStart =>\n    getPropertyValue('margin-start');\n\n  /** Sets the value of \"margin-start\" */\n  void set marginStart(String value) {\n    setProperty('margin-start', value, '');\n  }\n\n  /** Gets the value of \"margin-top\" */\n  String get marginTop =>\n    getPropertyValue('margin-top');\n\n  /** Sets the value of \"margin-top\" */\n  void set marginTop(String value) {\n    setProperty('margin-top', value, '');\n  }\n\n  /** Gets the value of \"margin-top-collapse\" */\n  String get marginTopCollapse =>\n    getPropertyValue('margin-top-collapse');\n\n  /** Sets the value of \"margin-top-collapse\" */\n  void set marginTopCollapse(String value) {\n    setProperty('margin-top-collapse', value, '');\n  }\n\n  /** Gets the value of \"mask\" */\n  String get mask =>\n    getPropertyValue('mask');\n\n  /** Sets the value of \"mask\" */\n  void set mask(String value) {\n    setProperty('mask', value, '');\n  }\n\n  /** Gets the value of \"mask-box-image\" */\n  String get maskBoxImage =>\n    getPropertyValue('mask-box-image');\n\n  /** Sets the value of \"mask-box-image\" */\n  void set maskBoxImage(String value) {\n    setProperty('mask-box-image', value, '');\n  }\n\n  /** Gets the value of \"mask-box-image-outset\" */\n  String get maskBoxImageOutset =>\n    getPropertyValue('mask-box-image-outset');\n\n  /** Sets the value of \"mask-box-image-outset\" */\n  void set maskBoxImageOutset(String value) {\n    setProperty('mask-box-image-outset', value, '');\n  }\n\n  /** Gets the value of \"mask-box-image-repeat\" */\n  String get maskBoxImageRepeat =>\n    getPropertyValue('mask-box-image-repeat');\n\n  /** Sets the value of \"mask-box-image-repeat\" */\n  void set maskBoxImageRepeat(String value) {\n    setProperty('mask-box-image-repeat', value, '');\n  }\n\n  /** Gets the value of \"mask-box-image-slice\" */\n  String get maskBoxImageSlice =>\n    getPropertyValue('mask-box-image-slice');\n\n  /** Sets the value of \"mask-box-image-slice\" */\n  void set maskBoxImageSlice(String value) {\n    setProperty('mask-box-image-slice', value, '');\n  }\n\n  /** Gets the value of \"mask-box-image-source\" */\n  String get maskBoxImageSource =>\n    getPropertyValue('mask-box-image-source');\n\n  /** Sets the value of \"mask-box-image-source\" */\n  void set maskBoxImageSource(String value) {\n    setProperty('mask-box-image-source', value, '');\n  }\n\n  /** Gets the value of \"mask-box-image-width\" */\n  String get maskBoxImageWidth =>\n    getPropertyValue('mask-box-image-width');\n\n  /** Sets the value of \"mask-box-image-width\" */\n  void set maskBoxImageWidth(String value) {\n    setProperty('mask-box-image-width', value, '');\n  }\n\n  /** Gets the value of \"mask-clip\" */\n  String get maskClip =>\n    getPropertyValue('mask-clip');\n\n  /** Sets the value of \"mask-clip\" */\n  void set maskClip(String value) {\n    setProperty('mask-clip', value, '');\n  }\n\n  /** Gets the value of \"mask-composite\" */\n  String get maskComposite =>\n    getPropertyValue('mask-composite');\n\n  /** Sets the value of \"mask-composite\" */\n  void set maskComposite(String value) {\n    setProperty('mask-composite', value, '');\n  }\n\n  /** Gets the value of \"mask-image\" */\n  String get maskImage =>\n    getPropertyValue('mask-image');\n\n  /** Sets the value of \"mask-image\" */\n  void set maskImage(String value) {\n    setProperty('mask-image', value, '');\n  }\n\n  /** Gets the value of \"mask-origin\" */\n  String get maskOrigin =>\n    getPropertyValue('mask-origin');\n\n  /** Sets the value of \"mask-origin\" */\n  void set maskOrigin(String value) {\n    setProperty('mask-origin', value, '');\n  }\n\n  /** Gets the value of \"mask-position\" */\n  String get maskPosition =>\n    getPropertyValue('mask-position');\n\n  /** Sets the value of \"mask-position\" */\n  void set maskPosition(String value) {\n    setProperty('mask-position', value, '');\n  }\n\n  /** Gets the value of \"mask-position-x\" */\n  String get maskPositionX =>\n    getPropertyValue('mask-position-x');\n\n  /** Sets the value of \"mask-position-x\" */\n  void set maskPositionX(String value) {\n    setProperty('mask-position-x', value, '');\n  }\n\n  /** Gets the value of \"mask-position-y\" */\n  String get maskPositionY =>\n    getPropertyValue('mask-position-y');\n\n  /** Sets the value of \"mask-position-y\" */\n  void set maskPositionY(String value) {\n    setProperty('mask-position-y', value, '');\n  }\n\n  /** Gets the value of \"mask-repeat\" */\n  String get maskRepeat =>\n    getPropertyValue('mask-repeat');\n\n  /** Sets the value of \"mask-repeat\" */\n  void set maskRepeat(String value) {\n    setProperty('mask-repeat', value, '');\n  }\n\n  /** Gets the value of \"mask-repeat-x\" */\n  String get maskRepeatX =>\n    getPropertyValue('mask-repeat-x');\n\n  /** Sets the value of \"mask-repeat-x\" */\n  void set maskRepeatX(String value) {\n    setProperty('mask-repeat-x', value, '');\n  }\n\n  /** Gets the value of \"mask-repeat-y\" */\n  String get maskRepeatY =>\n    getPropertyValue('mask-repeat-y');\n\n  /** Sets the value of \"mask-repeat-y\" */\n  void set maskRepeatY(String value) {\n    setProperty('mask-repeat-y', value, '');\n  }\n\n  /** Gets the value of \"mask-size\" */\n  String get maskSize =>\n    getPropertyValue('mask-size');\n\n  /** Sets the value of \"mask-size\" */\n  void set maskSize(String value) {\n    setProperty('mask-size', value, '');\n  }\n\n  /** Gets the value of \"mask-source-type\" */\n  String get maskSourceType =>\n    getPropertyValue('mask-source-type');\n\n  /** Sets the value of \"mask-source-type\" */\n  void set maskSourceType(String value) {\n    setProperty('mask-source-type', value, '');\n  }\n\n  /** Gets the value of \"max-height\" */\n  String get maxHeight =>\n    getPropertyValue('max-height');\n\n  /** Sets the value of \"max-height\" */\n  void set maxHeight(String value) {\n    setProperty('max-height', value, '');\n  }\n\n  /** Gets the value of \"max-logical-height\" */\n  String get maxLogicalHeight =>\n    getPropertyValue('max-logical-height');\n\n  /** Sets the value of \"max-logical-height\" */\n  void set maxLogicalHeight(String value) {\n    setProperty('max-logical-height', value, '');\n  }\n\n  /** Gets the value of \"max-logical-width\" */\n  String get maxLogicalWidth =>\n    getPropertyValue('max-logical-width');\n\n  /** Sets the value of \"max-logical-width\" */\n  void set maxLogicalWidth(String value) {\n    setProperty('max-logical-width', value, '');\n  }\n\n  /** Gets the value of \"max-width\" */\n  String get maxWidth =>\n    getPropertyValue('max-width');\n\n  /** Sets the value of \"max-width\" */\n  void set maxWidth(String value) {\n    setProperty('max-width', value, '');\n  }\n\n  /** Gets the value of \"max-zoom\" */\n  String get maxZoom =>\n    getPropertyValue('max-zoom');\n\n  /** Sets the value of \"max-zoom\" */\n  void set maxZoom(String value) {\n    setProperty('max-zoom', value, '');\n  }\n\n  /** Gets the value of \"min-height\" */\n  String get minHeight =>\n    getPropertyValue('min-height');\n\n  /** Sets the value of \"min-height\" */\n  void set minHeight(String value) {\n    setProperty('min-height', value, '');\n  }\n\n  /** Gets the value of \"min-logical-height\" */\n  String get minLogicalHeight =>\n    getPropertyValue('min-logical-height');\n\n  /** Sets the value of \"min-logical-height\" */\n  void set minLogicalHeight(String value) {\n    setProperty('min-logical-height', value, '');\n  }\n\n  /** Gets the value of \"min-logical-width\" */\n  String get minLogicalWidth =>\n    getPropertyValue('min-logical-width');\n\n  /** Sets the value of \"min-logical-width\" */\n  void set minLogicalWidth(String value) {\n    setProperty('min-logical-width', value, '');\n  }\n\n  /** Gets the value of \"min-width\" */\n  String get minWidth =>\n    getPropertyValue('min-width');\n\n  /** Sets the value of \"min-width\" */\n  void set minWidth(String value) {\n    setProperty('min-width', value, '');\n  }\n\n  /** Gets the value of \"min-zoom\" */\n  String get minZoom =>\n    getPropertyValue('min-zoom');\n\n  /** Sets the value of \"min-zoom\" */\n  void set minZoom(String value) {\n    setProperty('min-zoom', value, '');\n  }\n\n  /** Gets the value of \"mix-blend-mode\" */\n  String get mixBlendMode =>\n    getPropertyValue('mix-blend-mode');\n\n  /** Sets the value of \"mix-blend-mode\" */\n  void set mixBlendMode(String value) {\n    setProperty('mix-blend-mode', value, '');\n  }\n\n  /** Gets the value of \"object-fit\" */\n  String get objectFit =>\n    getPropertyValue('object-fit');\n\n  /** Sets the value of \"object-fit\" */\n  void set objectFit(String value) {\n    setProperty('object-fit', value, '');\n  }\n\n  /** Gets the value of \"object-position\" */\n  String get objectPosition =>\n    getPropertyValue('object-position');\n\n  /** Sets the value of \"object-position\" */\n  void set objectPosition(String value) {\n    setProperty('object-position', value, '');\n  }\n\n  /** Gets the value of \"opacity\" */\n  String get opacity =>\n    getPropertyValue('opacity');\n\n  /** Sets the value of \"opacity\" */\n  void set opacity(String value) {\n    setProperty('opacity', value, '');\n  }\n\n  /** Gets the value of \"order\" */\n  String get order =>\n    getPropertyValue('order');\n\n  /** Sets the value of \"order\" */\n  void set order(String value) {\n    setProperty('order', value, '');\n  }\n\n  /** Gets the value of \"orientation\" */\n  String get orientation =>\n    getPropertyValue('orientation');\n\n  /** Sets the value of \"orientation\" */\n  void set orientation(String value) {\n    setProperty('orientation', value, '');\n  }\n\n  /** Gets the value of \"orphans\" */\n  String get orphans =>\n    getPropertyValue('orphans');\n\n  /** Sets the value of \"orphans\" */\n  void set orphans(String value) {\n    setProperty('orphans', value, '');\n  }\n\n  /** Gets the value of \"outline\" */\n  String get outline =>\n    getPropertyValue('outline');\n\n  /** Sets the value of \"outline\" */\n  void set outline(String value) {\n    setProperty('outline', value, '');\n  }\n\n  /** Gets the value of \"outline-color\" */\n  String get outlineColor =>\n    getPropertyValue('outline-color');\n\n  /** Sets the value of \"outline-color\" */\n  void set outlineColor(String value) {\n    setProperty('outline-color', value, '');\n  }\n\n  /** Gets the value of \"outline-offset\" */\n  String get outlineOffset =>\n    getPropertyValue('outline-offset');\n\n  /** Sets the value of \"outline-offset\" */\n  void set outlineOffset(String value) {\n    setProperty('outline-offset', value, '');\n  }\n\n  /** Gets the value of \"outline-style\" */\n  String get outlineStyle =>\n    getPropertyValue('outline-style');\n\n  /** Sets the value of \"outline-style\" */\n  void set outlineStyle(String value) {\n    setProperty('outline-style', value, '');\n  }\n\n  /** Gets the value of \"outline-width\" */\n  String get outlineWidth =>\n    getPropertyValue('outline-width');\n\n  /** Sets the value of \"outline-width\" */\n  void set outlineWidth(String value) {\n    setProperty('outline-width', value, '');\n  }\n\n  /** Gets the value of \"overflow\" */\n  String get overflow =>\n    getPropertyValue('overflow');\n\n  /** Sets the value of \"overflow\" */\n  void set overflow(String value) {\n    setProperty('overflow', value, '');\n  }\n\n  /** Gets the value of \"overflow-wrap\" */\n  String get overflowWrap =>\n    getPropertyValue('overflow-wrap');\n\n  /** Sets the value of \"overflow-wrap\" */\n  void set overflowWrap(String value) {\n    setProperty('overflow-wrap', value, '');\n  }\n\n  /** Gets the value of \"overflow-x\" */\n  String get overflowX =>\n    getPropertyValue('overflow-x');\n\n  /** Sets the value of \"overflow-x\" */\n  void set overflowX(String value) {\n    setProperty('overflow-x', value, '');\n  }\n\n  /** Gets the value of \"overflow-y\" */\n  String get overflowY =>\n    getPropertyValue('overflow-y');\n\n  /** Sets the value of \"overflow-y\" */\n  void set overflowY(String value) {\n    setProperty('overflow-y', value, '');\n  }\n\n  /** Gets the value of \"padding\" */\n  String get padding =>\n    getPropertyValue('padding');\n\n  /** Sets the value of \"padding\" */\n  void set padding(String value) {\n    setProperty('padding', value, '');\n  }\n\n  /** Gets the value of \"padding-after\" */\n  String get paddingAfter =>\n    getPropertyValue('padding-after');\n\n  /** Sets the value of \"padding-after\" */\n  void set paddingAfter(String value) {\n    setProperty('padding-after', value, '');\n  }\n\n  /** Gets the value of \"padding-before\" */\n  String get paddingBefore =>\n    getPropertyValue('padding-before');\n\n  /** Sets the value of \"padding-before\" */\n  void set paddingBefore(String value) {\n    setProperty('padding-before', value, '');\n  }\n\n  /** Gets the value of \"padding-bottom\" */\n  String get paddingBottom =>\n    getPropertyValue('padding-bottom');\n\n  /** Sets the value of \"padding-bottom\" */\n  void set paddingBottom(String value) {\n    setProperty('padding-bottom', value, '');\n  }\n\n  /** Gets the value of \"padding-end\" */\n  String get paddingEnd =>\n    getPropertyValue('padding-end');\n\n  /** Sets the value of \"padding-end\" */\n  void set paddingEnd(String value) {\n    setProperty('padding-end', value, '');\n  }\n\n  /** Gets the value of \"padding-left\" */\n  String get paddingLeft =>\n    getPropertyValue('padding-left');\n\n  /** Sets the value of \"padding-left\" */\n  void set paddingLeft(String value) {\n    setProperty('padding-left', value, '');\n  }\n\n  /** Gets the value of \"padding-right\" */\n  String get paddingRight =>\n    getPropertyValue('padding-right');\n\n  /** Sets the value of \"padding-right\" */\n  void set paddingRight(String value) {\n    setProperty('padding-right', value, '');\n  }\n\n  /** Gets the value of \"padding-start\" */\n  String get paddingStart =>\n    getPropertyValue('padding-start');\n\n  /** Sets the value of \"padding-start\" */\n  void set paddingStart(String value) {\n    setProperty('padding-start', value, '');\n  }\n\n  /** Gets the value of \"padding-top\" */\n  String get paddingTop =>\n    getPropertyValue('padding-top');\n\n  /** Sets the value of \"padding-top\" */\n  void set paddingTop(String value) {\n    setProperty('padding-top', value, '');\n  }\n\n  /** Gets the value of \"page\" */\n  String get page =>\n    getPropertyValue('page');\n\n  /** Sets the value of \"page\" */\n  void set page(String value) {\n    setProperty('page', value, '');\n  }\n\n  /** Gets the value of \"page-break-after\" */\n  String get pageBreakAfter =>\n    getPropertyValue('page-break-after');\n\n  /** Sets the value of \"page-break-after\" */\n  void set pageBreakAfter(String value) {\n    setProperty('page-break-after', value, '');\n  }\n\n  /** Gets the value of \"page-break-before\" */\n  String get pageBreakBefore =>\n    getPropertyValue('page-break-before');\n\n  /** Sets the value of \"page-break-before\" */\n  void set pageBreakBefore(String value) {\n    setProperty('page-break-before', value, '');\n  }\n\n  /** Gets the value of \"page-break-inside\" */\n  String get pageBreakInside =>\n    getPropertyValue('page-break-inside');\n\n  /** Sets the value of \"page-break-inside\" */\n  void set pageBreakInside(String value) {\n    setProperty('page-break-inside', value, '');\n  }\n\n  /** Gets the value of \"perspective\" */\n  String get perspective =>\n    getPropertyValue('perspective');\n\n  /** Sets the value of \"perspective\" */\n  void set perspective(String value) {\n    setProperty('perspective', value, '');\n  }\n\n  /** Gets the value of \"perspective-origin\" */\n  String get perspectiveOrigin =>\n    getPropertyValue('perspective-origin');\n\n  /** Sets the value of \"perspective-origin\" */\n  void set perspectiveOrigin(String value) {\n    setProperty('perspective-origin', value, '');\n  }\n\n  /** Gets the value of \"perspective-origin-x\" */\n  String get perspectiveOriginX =>\n    getPropertyValue('perspective-origin-x');\n\n  /** Sets the value of \"perspective-origin-x\" */\n  void set perspectiveOriginX(String value) {\n    setProperty('perspective-origin-x', value, '');\n  }\n\n  /** Gets the value of \"perspective-origin-y\" */\n  String get perspectiveOriginY =>\n    getPropertyValue('perspective-origin-y');\n\n  /** Sets the value of \"perspective-origin-y\" */\n  void set perspectiveOriginY(String value) {\n    setProperty('perspective-origin-y', value, '');\n  }\n\n  /** Gets the value of \"pointer-events\" */\n  String get pointerEvents =>\n    getPropertyValue('pointer-events');\n\n  /** Sets the value of \"pointer-events\" */\n  void set pointerEvents(String value) {\n    setProperty('pointer-events', value, '');\n  }\n\n  /** Gets the value of \"position\" */\n  String get position =>\n    getPropertyValue('position');\n\n  /** Sets the value of \"position\" */\n  void set position(String value) {\n    setProperty('position', value, '');\n  }\n\n  /** Gets the value of \"print-color-adjust\" */\n  String get printColorAdjust =>\n    getPropertyValue('print-color-adjust');\n\n  /** Sets the value of \"print-color-adjust\" */\n  void set printColorAdjust(String value) {\n    setProperty('print-color-adjust', value, '');\n  }\n\n  /** Gets the value of \"quotes\" */\n  String get quotes =>\n    getPropertyValue('quotes');\n\n  /** Sets the value of \"quotes\" */\n  void set quotes(String value) {\n    setProperty('quotes', value, '');\n  }\n\n  /** Gets the value of \"resize\" */\n  String get resize =>\n    getPropertyValue('resize');\n\n  /** Sets the value of \"resize\" */\n  void set resize(String value) {\n    setProperty('resize', value, '');\n  }\n\n  /** Gets the value of \"right\" */\n  String get right =>\n    getPropertyValue('right');\n\n  /** Sets the value of \"right\" */\n  void set right(String value) {\n    setProperty('right', value, '');\n  }\n\n  /** Gets the value of \"rtl-ordering\" */\n  String get rtlOrdering =>\n    getPropertyValue('rtl-ordering');\n\n  /** Sets the value of \"rtl-ordering\" */\n  void set rtlOrdering(String value) {\n    setProperty('rtl-ordering', value, '');\n  }\n\n  /** Gets the value of \"ruby-position\" */\n  String get rubyPosition =>\n    getPropertyValue('ruby-position');\n\n  /** Sets the value of \"ruby-position\" */\n  void set rubyPosition(String value) {\n    setProperty('ruby-position', value, '');\n  }\n\n  /** Gets the value of \"scroll-behavior\" */\n  String get scrollBehavior =>\n    getPropertyValue('scroll-behavior');\n\n  /** Sets the value of \"scroll-behavior\" */\n  void set scrollBehavior(String value) {\n    setProperty('scroll-behavior', value, '');\n  }\n\n  /** Gets the value of \"shape-image-threshold\" */\n  String get shapeImageThreshold =>\n    getPropertyValue('shape-image-threshold');\n\n  /** Sets the value of \"shape-image-threshold\" */\n  void set shapeImageThreshold(String value) {\n    setProperty('shape-image-threshold', value, '');\n  }\n\n  /** Gets the value of \"shape-margin\" */\n  String get shapeMargin =>\n    getPropertyValue('shape-margin');\n\n  /** Sets the value of \"shape-margin\" */\n  void set shapeMargin(String value) {\n    setProperty('shape-margin', value, '');\n  }\n\n  /** Gets the value of \"shape-outside\" */\n  String get shapeOutside =>\n    getPropertyValue('shape-outside');\n\n  /** Sets the value of \"shape-outside\" */\n  void set shapeOutside(String value) {\n    setProperty('shape-outside', value, '');\n  }\n\n  /** Gets the value of \"size\" */\n  String get size =>\n    getPropertyValue('size');\n\n  /** Sets the value of \"size\" */\n  void set size(String value) {\n    setProperty('size', value, '');\n  }\n\n  /** Gets the value of \"speak\" */\n  String get speak =>\n    getPropertyValue('speak');\n\n  /** Sets the value of \"speak\" */\n  void set speak(String value) {\n    setProperty('speak', value, '');\n  }\n\n  /** Gets the value of \"src\" */\n  String get src =>\n    getPropertyValue('src');\n\n  /** Sets the value of \"src\" */\n  void set src(String value) {\n    setProperty('src', value, '');\n  }\n\n  /** Gets the value of \"tab-size\" */\n  String get tabSize =>\n    getPropertyValue('tab-size');\n\n  /** Sets the value of \"tab-size\" */\n  void set tabSize(String value) {\n    setProperty('tab-size', value, '');\n  }\n\n  /** Gets the value of \"table-layout\" */\n  String get tableLayout =>\n    getPropertyValue('table-layout');\n\n  /** Sets the value of \"table-layout\" */\n  void set tableLayout(String value) {\n    setProperty('table-layout', value, '');\n  }\n\n  /** Gets the value of \"tap-highlight-color\" */\n  String get tapHighlightColor =>\n    getPropertyValue('tap-highlight-color');\n\n  /** Sets the value of \"tap-highlight-color\" */\n  void set tapHighlightColor(String value) {\n    setProperty('tap-highlight-color', value, '');\n  }\n\n  /** Gets the value of \"text-align\" */\n  String get textAlign =>\n    getPropertyValue('text-align');\n\n  /** Sets the value of \"text-align\" */\n  void set textAlign(String value) {\n    setProperty('text-align', value, '');\n  }\n\n  /** Gets the value of \"text-align-last\" */\n  String get textAlignLast =>\n    getPropertyValue('text-align-last');\n\n  /** Sets the value of \"text-align-last\" */\n  void set textAlignLast(String value) {\n    setProperty('text-align-last', value, '');\n  }\n\n  /** Gets the value of \"text-combine\" */\n  String get textCombine =>\n    getPropertyValue('text-combine');\n\n  /** Sets the value of \"text-combine\" */\n  void set textCombine(String value) {\n    setProperty('text-combine', value, '');\n  }\n\n  /** Gets the value of \"text-decoration\" */\n  String get textDecoration =>\n    getPropertyValue('text-decoration');\n\n  /** Sets the value of \"text-decoration\" */\n  void set textDecoration(String value) {\n    setProperty('text-decoration', value, '');\n  }\n\n  /** Gets the value of \"text-decoration-color\" */\n  String get textDecorationColor =>\n    getPropertyValue('text-decoration-color');\n\n  /** Sets the value of \"text-decoration-color\" */\n  void set textDecorationColor(String value) {\n    setProperty('text-decoration-color', value, '');\n  }\n\n  /** Gets the value of \"text-decoration-line\" */\n  String get textDecorationLine =>\n    getPropertyValue('text-decoration-line');\n\n  /** Sets the value of \"text-decoration-line\" */\n  void set textDecorationLine(String value) {\n    setProperty('text-decoration-line', value, '');\n  }\n\n  /** Gets the value of \"text-decoration-style\" */\n  String get textDecorationStyle =>\n    getPropertyValue('text-decoration-style');\n\n  /** Sets the value of \"text-decoration-style\" */\n  void set textDecorationStyle(String value) {\n    setProperty('text-decoration-style', value, '');\n  }\n\n  /** Gets the value of \"text-decorations-in-effect\" */\n  String get textDecorationsInEffect =>\n    getPropertyValue('text-decorations-in-effect');\n\n  /** Sets the value of \"text-decorations-in-effect\" */\n  void set textDecorationsInEffect(String value) {\n    setProperty('text-decorations-in-effect', value, '');\n  }\n\n  /** Gets the value of \"text-emphasis\" */\n  String get textEmphasis =>\n    getPropertyValue('text-emphasis');\n\n  /** Sets the value of \"text-emphasis\" */\n  void set textEmphasis(String value) {\n    setProperty('text-emphasis', value, '');\n  }\n\n  /** Gets the value of \"text-emphasis-color\" */\n  String get textEmphasisColor =>\n    getPropertyValue('text-emphasis-color');\n\n  /** Sets the value of \"text-emphasis-color\" */\n  void set textEmphasisColor(String value) {\n    setProperty('text-emphasis-color', value, '');\n  }\n\n  /** Gets the value of \"text-emphasis-position\" */\n  String get textEmphasisPosition =>\n    getPropertyValue('text-emphasis-position');\n\n  /** Sets the value of \"text-emphasis-position\" */\n  void set textEmphasisPosition(String value) {\n    setProperty('text-emphasis-position', value, '');\n  }\n\n  /** Gets the value of \"text-emphasis-style\" */\n  String get textEmphasisStyle =>\n    getPropertyValue('text-emphasis-style');\n\n  /** Sets the value of \"text-emphasis-style\" */\n  void set textEmphasisStyle(String value) {\n    setProperty('text-emphasis-style', value, '');\n  }\n\n  /** Gets the value of \"text-fill-color\" */\n  String get textFillColor =>\n    getPropertyValue('text-fill-color');\n\n  /** Sets the value of \"text-fill-color\" */\n  void set textFillColor(String value) {\n    setProperty('text-fill-color', value, '');\n  }\n\n  /** Gets the value of \"text-indent\" */\n  String get textIndent =>\n    getPropertyValue('text-indent');\n\n  /** Sets the value of \"text-indent\" */\n  void set textIndent(String value) {\n    setProperty('text-indent', value, '');\n  }\n\n  /** Gets the value of \"text-justify\" */\n  String get textJustify =>\n    getPropertyValue('text-justify');\n\n  /** Sets the value of \"text-justify\" */\n  void set textJustify(String value) {\n    setProperty('text-justify', value, '');\n  }\n\n  /** Gets the value of \"text-line-through-color\" */\n  String get textLineThroughColor =>\n    getPropertyValue('text-line-through-color');\n\n  /** Sets the value of \"text-line-through-color\" */\n  void set textLineThroughColor(String value) {\n    setProperty('text-line-through-color', value, '');\n  }\n\n  /** Gets the value of \"text-line-through-mode\" */\n  String get textLineThroughMode =>\n    getPropertyValue('text-line-through-mode');\n\n  /** Sets the value of \"text-line-through-mode\" */\n  void set textLineThroughMode(String value) {\n    setProperty('text-line-through-mode', value, '');\n  }\n\n  /** Gets the value of \"text-line-through-style\" */\n  String get textLineThroughStyle =>\n    getPropertyValue('text-line-through-style');\n\n  /** Sets the value of \"text-line-through-style\" */\n  void set textLineThroughStyle(String value) {\n    setProperty('text-line-through-style', value, '');\n  }\n\n  /** Gets the value of \"text-line-through-width\" */\n  String get textLineThroughWidth =>\n    getPropertyValue('text-line-through-width');\n\n  /** Sets the value of \"text-line-through-width\" */\n  void set textLineThroughWidth(String value) {\n    setProperty('text-line-through-width', value, '');\n  }\n\n  /** Gets the value of \"text-orientation\" */\n  String get textOrientation =>\n    getPropertyValue('text-orientation');\n\n  /** Sets the value of \"text-orientation\" */\n  void set textOrientation(String value) {\n    setProperty('text-orientation', value, '');\n  }\n\n  /** Gets the value of \"text-overflow\" */\n  String get textOverflow =>\n    getPropertyValue('text-overflow');\n\n  /** Sets the value of \"text-overflow\" */\n  void set textOverflow(String value) {\n    setProperty('text-overflow', value, '');\n  }\n\n  /** Gets the value of \"text-overline-color\" */\n  String get textOverlineColor =>\n    getPropertyValue('text-overline-color');\n\n  /** Sets the value of \"text-overline-color\" */\n  void set textOverlineColor(String value) {\n    setProperty('text-overline-color', value, '');\n  }\n\n  /** Gets the value of \"text-overline-mode\" */\n  String get textOverlineMode =>\n    getPropertyValue('text-overline-mode');\n\n  /** Sets the value of \"text-overline-mode\" */\n  void set textOverlineMode(String value) {\n    setProperty('text-overline-mode', value, '');\n  }\n\n  /** Gets the value of \"text-overline-style\" */\n  String get textOverlineStyle =>\n    getPropertyValue('text-overline-style');\n\n  /** Sets the value of \"text-overline-style\" */\n  void set textOverlineStyle(String value) {\n    setProperty('text-overline-style', value, '');\n  }\n\n  /** Gets the value of \"text-overline-width\" */\n  String get textOverlineWidth =>\n    getPropertyValue('text-overline-width');\n\n  /** Sets the value of \"text-overline-width\" */\n  void set textOverlineWidth(String value) {\n    setProperty('text-overline-width', value, '');\n  }\n\n  /** Gets the value of \"text-rendering\" */\n  String get textRendering =>\n    getPropertyValue('text-rendering');\n\n  /** Sets the value of \"text-rendering\" */\n  void set textRendering(String value) {\n    setProperty('text-rendering', value, '');\n  }\n\n  /** Gets the value of \"text-security\" */\n  String get textSecurity =>\n    getPropertyValue('text-security');\n\n  /** Sets the value of \"text-security\" */\n  void set textSecurity(String value) {\n    setProperty('text-security', value, '');\n  }\n\n  /** Gets the value of \"text-shadow\" */\n  String get textShadow =>\n    getPropertyValue('text-shadow');\n\n  /** Sets the value of \"text-shadow\" */\n  void set textShadow(String value) {\n    setProperty('text-shadow', value, '');\n  }\n\n  /** Gets the value of \"text-stroke\" */\n  String get textStroke =>\n    getPropertyValue('text-stroke');\n\n  /** Sets the value of \"text-stroke\" */\n  void set textStroke(String value) {\n    setProperty('text-stroke', value, '');\n  }\n\n  /** Gets the value of \"text-stroke-color\" */\n  String get textStrokeColor =>\n    getPropertyValue('text-stroke-color');\n\n  /** Sets the value of \"text-stroke-color\" */\n  void set textStrokeColor(String value) {\n    setProperty('text-stroke-color', value, '');\n  }\n\n  /** Gets the value of \"text-stroke-width\" */\n  String get textStrokeWidth =>\n    getPropertyValue('text-stroke-width');\n\n  /** Sets the value of \"text-stroke-width\" */\n  void set textStrokeWidth(String value) {\n    setProperty('text-stroke-width', value, '');\n  }\n\n  /** Gets the value of \"text-transform\" */\n  String get textTransform =>\n    getPropertyValue('text-transform');\n\n  /** Sets the value of \"text-transform\" */\n  void set textTransform(String value) {\n    setProperty('text-transform', value, '');\n  }\n\n  /** Gets the value of \"text-underline-color\" */\n  String get textUnderlineColor =>\n    getPropertyValue('text-underline-color');\n\n  /** Sets the value of \"text-underline-color\" */\n  void set textUnderlineColor(String value) {\n    setProperty('text-underline-color', value, '');\n  }\n\n  /** Gets the value of \"text-underline-mode\" */\n  String get textUnderlineMode =>\n    getPropertyValue('text-underline-mode');\n\n  /** Sets the value of \"text-underline-mode\" */\n  void set textUnderlineMode(String value) {\n    setProperty('text-underline-mode', value, '');\n  }\n\n  /** Gets the value of \"text-underline-position\" */\n  String get textUnderlinePosition =>\n    getPropertyValue('text-underline-position');\n\n  /** Sets the value of \"text-underline-position\" */\n  void set textUnderlinePosition(String value) {\n    setProperty('text-underline-position', value, '');\n  }\n\n  /** Gets the value of \"text-underline-style\" */\n  String get textUnderlineStyle =>\n    getPropertyValue('text-underline-style');\n\n  /** Sets the value of \"text-underline-style\" */\n  void set textUnderlineStyle(String value) {\n    setProperty('text-underline-style', value, '');\n  }\n\n  /** Gets the value of \"text-underline-width\" */\n  String get textUnderlineWidth =>\n    getPropertyValue('text-underline-width');\n\n  /** Sets the value of \"text-underline-width\" */\n  void set textUnderlineWidth(String value) {\n    setProperty('text-underline-width', value, '');\n  }\n\n  /** Gets the value of \"top\" */\n  String get top =>\n    getPropertyValue('top');\n\n  /** Sets the value of \"top\" */\n  void set top(String value) {\n    setProperty('top', value, '');\n  }\n\n  /** Gets the value of \"touch-action\" */\n  String get touchAction =>\n    getPropertyValue('touch-action');\n\n  /** Sets the value of \"touch-action\" */\n  void set touchAction(String value) {\n    setProperty('touch-action', value, '');\n  }\n\n  /** Gets the value of \"touch-action-delay\" */\n  String get touchActionDelay =>\n    getPropertyValue('touch-action-delay');\n\n  /** Sets the value of \"touch-action-delay\" */\n  void set touchActionDelay(String value) {\n    setProperty('touch-action-delay', value, '');\n  }\n\n  /** Gets the value of \"transform\" */\n  String get transform =>\n    getPropertyValue('transform');\n\n  /** Sets the value of \"transform\" */\n  void set transform(String value) {\n    setProperty('transform', value, '');\n  }\n\n  /** Gets the value of \"transform-origin\" */\n  String get transformOrigin =>\n    getPropertyValue('transform-origin');\n\n  /** Sets the value of \"transform-origin\" */\n  void set transformOrigin(String value) {\n    setProperty('transform-origin', value, '');\n  }\n\n  /** Gets the value of \"transform-origin-x\" */\n  String get transformOriginX =>\n    getPropertyValue('transform-origin-x');\n\n  /** Sets the value of \"transform-origin-x\" */\n  void set transformOriginX(String value) {\n    setProperty('transform-origin-x', value, '');\n  }\n\n  /** Gets the value of \"transform-origin-y\" */\n  String get transformOriginY =>\n    getPropertyValue('transform-origin-y');\n\n  /** Sets the value of \"transform-origin-y\" */\n  void set transformOriginY(String value) {\n    setProperty('transform-origin-y', value, '');\n  }\n\n  /** Gets the value of \"transform-origin-z\" */\n  String get transformOriginZ =>\n    getPropertyValue('transform-origin-z');\n\n  /** Sets the value of \"transform-origin-z\" */\n  void set transformOriginZ(String value) {\n    setProperty('transform-origin-z', value, '');\n  }\n\n  /** Gets the value of \"transform-style\" */\n  String get transformStyle =>\n    getPropertyValue('transform-style');\n\n  /** Sets the value of \"transform-style\" */\n  void set transformStyle(String value) {\n    setProperty('transform-style', value, '');\n  }\n\n  /** Gets the value of \"transition\" */@SupportedBrowser(SupportedBrowser.CHROME)\n  @SupportedBrowser(SupportedBrowser.FIREFOX)\n  @SupportedBrowser(SupportedBrowser.IE, '10')\n  @SupportedBrowser(SupportedBrowser.SAFARI)\n  String get transition =>\n    getPropertyValue('transition');\n\n  /** Sets the value of \"transition\" */@SupportedBrowser(SupportedBrowser.CHROME)\n  @SupportedBrowser(SupportedBrowser.FIREFOX)\n  @SupportedBrowser(SupportedBrowser.IE, '10')\n  @SupportedBrowser(SupportedBrowser.SAFARI)\n  void set transition(String value) {\n    setProperty('transition', value, '');\n  }\n\n  /** Gets the value of \"transition-delay\" */\n  String get transitionDelay =>\n    getPropertyValue('transition-delay');\n\n  /** Sets the value of \"transition-delay\" */\n  void set transitionDelay(String value) {\n    setProperty('transition-delay', value, '');\n  }\n\n  /** Gets the value of \"transition-duration\" */\n  String get transitionDuration =>\n    getPropertyValue('transition-duration');\n\n  /** Sets the value of \"transition-duration\" */\n  void set transitionDuration(String value) {\n    setProperty('transition-duration', value, '');\n  }\n\n  /** Gets the value of \"transition-property\" */\n  String get transitionProperty =>\n    getPropertyValue('transition-property');\n\n  /** Sets the value of \"transition-property\" */\n  void set transitionProperty(String value) {\n    setProperty('transition-property', value, '');\n  }\n\n  /** Gets the value of \"transition-timing-function\" */\n  String get transitionTimingFunction =>\n    getPropertyValue('transition-timing-function');\n\n  /** Sets the value of \"transition-timing-function\" */\n  void set transitionTimingFunction(String value) {\n    setProperty('transition-timing-function', value, '');\n  }\n\n  /** Gets the value of \"unicode-bidi\" */\n  String get unicodeBidi =>\n    getPropertyValue('unicode-bidi');\n\n  /** Sets the value of \"unicode-bidi\" */\n  void set unicodeBidi(String value) {\n    setProperty('unicode-bidi', value, '');\n  }\n\n  /** Gets the value of \"unicode-range\" */\n  String get unicodeRange =>\n    getPropertyValue('unicode-range');\n\n  /** Sets the value of \"unicode-range\" */\n  void set unicodeRange(String value) {\n    setProperty('unicode-range', value, '');\n  }\n\n  /** Gets the value of \"user-drag\" */\n  String get userDrag =>\n    getPropertyValue('user-drag');\n\n  /** Sets the value of \"user-drag\" */\n  void set userDrag(String value) {\n    setProperty('user-drag', value, '');\n  }\n\n  /** Gets the value of \"user-modify\" */\n  String get userModify =>\n    getPropertyValue('user-modify');\n\n  /** Sets the value of \"user-modify\" */\n  void set userModify(String value) {\n    setProperty('user-modify', value, '');\n  }\n\n  /** Gets the value of \"user-select\" */\n  String get userSelect =>\n    getPropertyValue('user-select');\n\n  /** Sets the value of \"user-select\" */\n  void set userSelect(String value) {\n    setProperty('user-select', value, '');\n  }\n\n  /** Gets the value of \"user-zoom\" */\n  String get userZoom =>\n    getPropertyValue('user-zoom');\n\n  /** Sets the value of \"user-zoom\" */\n  void set userZoom(String value) {\n    setProperty('user-zoom', value, '');\n  }\n\n  /** Gets the value of \"vertical-align\" */\n  String get verticalAlign =>\n    getPropertyValue('vertical-align');\n\n  /** Sets the value of \"vertical-align\" */\n  void set verticalAlign(String value) {\n    setProperty('vertical-align', value, '');\n  }\n\n  /** Gets the value of \"visibility\" */\n  String get visibility =>\n    getPropertyValue('visibility');\n\n  /** Sets the value of \"visibility\" */\n  void set visibility(String value) {\n    setProperty('visibility', value, '');\n  }\n\n  /** Gets the value of \"white-space\" */\n  String get whiteSpace =>\n    getPropertyValue('white-space');\n\n  /** Sets the value of \"white-space\" */\n  void set whiteSpace(String value) {\n    setProperty('white-space', value, '');\n  }\n\n  /** Gets the value of \"widows\" */\n  String get widows =>\n    getPropertyValue('widows');\n\n  /** Sets the value of \"widows\" */\n  void set widows(String value) {\n    setProperty('widows', value, '');\n  }\n\n  /** Gets the value of \"width\" */\n  String get width =>\n    getPropertyValue('width');\n\n  /** Sets the value of \"width\" */\n  void set width(String value) {\n    setProperty('width', value, '');\n  }\n\n  /** Gets the value of \"will-change\" */\n  String get willChange =>\n    getPropertyValue('will-change');\n\n  /** Sets the value of \"will-change\" */\n  void set willChange(String value) {\n    setProperty('will-change', value, '');\n  }\n\n  /** Gets the value of \"word-break\" */\n  String get wordBreak =>\n    getPropertyValue('word-break');\n\n  /** Sets the value of \"word-break\" */\n  void set wordBreak(String value) {\n    setProperty('word-break', value, '');\n  }\n\n  /** Gets the value of \"word-spacing\" */\n  String get wordSpacing =>\n    getPropertyValue('word-spacing');\n\n  /** Sets the value of \"word-spacing\" */\n  void set wordSpacing(String value) {\n    setProperty('word-spacing', value, '');\n  }\n\n  /** Gets the value of \"word-wrap\" */\n  String get wordWrap =>\n    getPropertyValue('word-wrap');\n\n  /** Sets the value of \"word-wrap\" */\n  void set wordWrap(String value) {\n    setProperty('word-wrap', value, '');\n  }\n\n  /** Gets the value of \"wrap-flow\" */\n  String get wrapFlow =>\n    getPropertyValue('wrap-flow');\n\n  /** Sets the value of \"wrap-flow\" */\n  void set wrapFlow(String value) {\n    setProperty('wrap-flow', value, '');\n  }\n\n  /** Gets the value of \"wrap-through\" */\n  String get wrapThrough =>\n    getPropertyValue('wrap-through');\n\n  /** Sets the value of \"wrap-through\" */\n  void set wrapThrough(String value) {\n    setProperty('wrap-through', value, '');\n  }\n\n  /** Gets the value of \"writing-mode\" */\n  String get writingMode =>\n    getPropertyValue('writing-mode');\n\n  /** Sets the value of \"writing-mode\" */\n  void set writingMode(String value) {\n    setProperty('writing-mode', value, '');\n  }\n\n  /** Gets the value of \"z-index\" */\n  String get zIndex =>\n    getPropertyValue('z-index');\n\n  /** Sets the value of \"z-index\" */\n  void set zIndex(String value) {\n    setProperty('z-index', value, '');\n  }\n\n  /** Gets the value of \"zoom\" */\n  String get zoom =>\n    getPropertyValue('zoom');\n\n  /** Sets the value of \"zoom\" */\n  void set zoom(String value) {\n    setProperty('zoom', value, '');\n  }\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('CSSStyleRule')\n@Native(\"CSSStyleRule\")\nclass CssStyleRule extends CssRule {\n  // To suppress missing implicit constructor warnings.\n  factory CssStyleRule._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('CSSStyleRule.selectorText')\n  @DocsEditable()\n  String selectorText;\n\n  @DomName('CSSStyleRule.style')\n  @DocsEditable()\n  final CssStyleDeclaration style;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('CSSStyleSheet')\n@Native(\"CSSStyleSheet\")\nclass CssStyleSheet extends StyleSheet {\n  // To suppress missing implicit constructor warnings.\n  factory CssStyleSheet._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('CSSStyleSheet.cssRules')\n  @DocsEditable()\n  @Returns('_CssRuleList')\n  @Creates('_CssRuleList')\n  final List<CssRule> cssRules;\n\n  @DomName('CSSStyleSheet.ownerRule')\n  @DocsEditable()\n  final CssRule ownerRule;\n\n  @DomName('CSSStyleSheet.rules')\n  @DocsEditable()\n  @Experimental() // non-standard\n  @Returns('_CssRuleList')\n  @Creates('_CssRuleList')\n  final List<CssRule> rules;\n\n  @DomName('CSSStyleSheet.addRule')\n  @DocsEditable()\n  @Experimental() // non-standard\n  int addRule(String selector, String style, [int index]) native;\n\n  @DomName('CSSStyleSheet.deleteRule')\n  @DocsEditable()\n  void deleteRule(int index) native;\n\n  @DomName('CSSStyleSheet.insertRule')\n  @DocsEditable()\n  int insertRule(String rule, [int index]) native;\n\n  @DomName('CSSStyleSheet.removeRule')\n  @DocsEditable()\n  @Experimental() // non-standard\n  void removeRule(int index) native;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('CSSSupportsRule')\n@Native(\"CSSSupportsRule\")\nclass CssSupportsRule extends CssRule {\n  // To suppress missing implicit constructor warnings.\n  factory CssSupportsRule._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('CSSSupportsRule.conditionText')\n  @DocsEditable()\n  final String conditionText;\n\n  @DomName('CSSSupportsRule.cssRules')\n  @DocsEditable()\n  @Returns('_CssRuleList')\n  @Creates('_CssRuleList')\n  final List<CssRule> cssRules;\n\n  @DomName('CSSSupportsRule.deleteRule')\n  @DocsEditable()\n  void deleteRule(int index) native;\n\n  @DomName('CSSSupportsRule.insertRule')\n  @DocsEditable()\n  int insertRule(String rule, int index) native;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('CSSViewportRule')\n@Experimental() // untriaged\n@Native(\"CSSViewportRule\")\nclass CssViewportRule extends CssRule {\n  // To suppress missing implicit constructor warnings.\n  factory CssViewportRule._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('CSSViewportRule.style')\n  @DocsEditable()\n  @Experimental() // untriaged\n  final CssStyleDeclaration style;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n// WARNING: Do not edit - generated code.\n\n\n@DomName('CustomEvent')\n@Native(\"CustomEvent\")\nclass CustomEvent extends Event {\n    @Creates('Null')  // Set from Dart code; does not instantiate a native type.\n  var _dartDetail;\n\n  factory CustomEvent(String type,\n      {bool canBubble: true, bool cancelable: true, Object detail}) {\n\n    final CustomEvent e = document._createEvent('CustomEvent');\n\n    e._dartDetail = detail;\n\n    // Only try setting the detail if it's one of these types to avoid\n    // first-chance exceptions. Can expand this list in the future as needed.\n    if (detail is List || detail is Map || detail is String || detail is num) {\n      try {\n        detail = convertDartToNative_SerializedScriptValue(detail);\n        e._initCustomEvent(type, canBubble, cancelable, detail);\n      } catch(_) {\n        e._initCustomEvent(type, canBubble, cancelable, null);\n      }\n    } else {\n      e._initCustomEvent(type, canBubble, cancelable, null);\n    }\n\n    return e;\n  }\n\n  @DomName('CustomEvent.detail')\n  get detail {\n    if (_dartDetail != null) {\n      return _dartDetail;\n    }\n    return _detail;\n  }\n  // To suppress missing implicit constructor warnings.\n  factory CustomEvent._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('CustomEvent._detail')\n  @DocsEditable()\n  @Experimental() // untriaged\n  dynamic get _detail => convertNativeToDart_SerializedScriptValue(this._get__detail);\n  @JSName('detail')\n  @DomName('CustomEvent._detail')\n  @DocsEditable()\n  @Experimental() // untriaged\n  @Creates('Null')\n  final dynamic _get__detail;\n\n  @JSName('initCustomEvent')\n  @DomName('CustomEvent.initCustomEvent')\n  @DocsEditable()\n  void _initCustomEvent(String typeArg, bool canBubbleArg, bool cancelableArg, Object detailArg) native;\n\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('HTMLDListElement')\n@Native(\"HTMLDListElement\")\nclass DListElement extends HtmlElement {\n  // To suppress missing implicit constructor warnings.\n  factory DListElement._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('HTMLDListElement.HTMLDListElement')\n  @DocsEditable()\n  factory DListElement() => document.createElement(\"dl\");\n  /**\n   * Constructor instantiated by the DOM when a custom element has been created.\n   *\n   * This can only be called by subclasses from their created constructor.\n   */\n  DListElement.created() : super.created();\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('HTMLDataListElement')\n@SupportedBrowser(SupportedBrowser.CHROME)\n@SupportedBrowser(SupportedBrowser.FIREFOX)\n@SupportedBrowser(SupportedBrowser.IE, '10')\n@SupportedBrowser(SupportedBrowser.SAFARI)\n@Native(\"HTMLDataListElement\")\nclass DataListElement extends HtmlElement {\n  // To suppress missing implicit constructor warnings.\n  factory DataListElement._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('HTMLDataListElement.HTMLDataListElement')\n  @DocsEditable()\n  factory DataListElement() => document.createElement(\"datalist\");\n  /**\n   * Constructor instantiated by the DOM when a custom element has been created.\n   *\n   * This can only be called by subclasses from their created constructor.\n   */\n  DataListElement.created() : super.created();\n\n  /// Checks if this type is supported on the current platform.\n  static bool get supported => Element.isTagSupported('datalist');\n\n  @DomName('HTMLDataListElement.options')\n  @DocsEditable()\n  @Returns('HtmlCollection')\n  @Creates('HtmlCollection')\n  final List<Node> options;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('Clipboard')\n@Native(\"Clipboard,DataTransfer\")\nclass DataTransfer extends Interceptor {\n  // To suppress missing implicit constructor warnings.\n  factory DataTransfer._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('Clipboard.dropEffect')\n  @DocsEditable()\n  String dropEffect;\n\n  @DomName('Clipboard.effectAllowed')\n  @DocsEditable()\n  String effectAllowed;\n\n  @DomName('Clipboard.files')\n  @DocsEditable()\n  @Returns('FileList')\n  @Creates('FileList')\n  final List<File> files;\n\n  @DomName('Clipboard.items')\n  @DocsEditable()\n  final DataTransferItemList items;\n\n  @DomName('Clipboard.types')\n  @DocsEditable()\n  final List<String> types;\n\n  @DomName('Clipboard.clearData')\n  @DocsEditable()\n  void clearData([String type]) native;\n\n  /**\n   * Gets the data for the specified type.\n   *\n   * The data is only available from within a drop operation (such as an\n   * [Element.onDrop] event) and will return null before the event is\n   * triggered.\n   *\n   * Data transfer is prohibited across domains. If a drag originates\n   * from content from another domain or protocol (HTTP vs HTTPS) then the\n   * data cannot be accessed.\n   *\n   * The [type] can have values such as:\n   *\n   * * `'Text'`\n   * * `'URL'`\n   */\n  @DomName('Clipboard.getData')\n  @DocsEditable()\n  String getData(String type) native;\n\n  @DomName('Clipboard.setData')\n  @DocsEditable()\n  bool setData(String type, String data) native;\n\n  @DomName('Clipboard.setDragImage')\n  @DocsEditable()\n  void setDragImage(Element image, int x, int y) native;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('DataTransferItem')\n// http://www.w3.org/TR/2011/WD-html5-20110113/dnd.html#the-datatransferitem-interface\n@Experimental()\n@Native(\"DataTransferItem\")\nclass DataTransferItem extends Interceptor {\n  // To suppress missing implicit constructor warnings.\n  factory DataTransferItem._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('DataTransferItem.kind')\n  @DocsEditable()\n  final String kind;\n\n  @DomName('DataTransferItem.type')\n  @DocsEditable()\n  final String type;\n\n  @DomName('DataTransferItem.getAsFile')\n  @DocsEditable()\n  Blob getAsFile() native;\n\n  @JSName('getAsString')\n  @DomName('DataTransferItem.getAsString')\n  @DocsEditable()\n  void _getAsString(_StringCallback callback) native;\n\n  @JSName('getAsString')\n  @DomName('DataTransferItem.getAsString')\n  @DocsEditable()\n  Future<String> getAsString() {\n    var completer = new Completer<String>();\n    _getAsString(\n        (value) { completer.complete(value); });\n    return completer.future;\n  }\n\n  @JSName('webkitGetAsEntry')\n  @DomName('DataTransferItem.webkitGetAsEntry')\n  @DocsEditable()\n  @SupportedBrowser(SupportedBrowser.CHROME)\n  @SupportedBrowser(SupportedBrowser.SAFARI)\n  @Experimental()\n  Entry getAsEntry() native;\n}\n// Copyright (c) 2013, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('DataTransferItemList')\n// http://www.whatwg.org/specs/web-apps/current-work/multipage/dnd.html#the-datatransferitemlist-interface\n@Experimental()\n@Native(\"DataTransferItemList\")\nclass DataTransferItemList extends Interceptor {\n  // To suppress missing implicit constructor warnings.\n  factory DataTransferItemList._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('DataTransferItemList.length')\n  @DocsEditable()\n  final int length;\n\n  @DomName('DataTransferItemList.__getter__')\n  @DocsEditable()\n  @Experimental() // untriaged\n  DataTransferItem __getter__(int index) native;\n\n  @DomName('DataTransferItemList.add')\n  @DocsEditable()\n  DataTransferItem add(data_OR_file, [String type]) native;\n\n  @JSName('add')\n  @DomName('DataTransferItemList.add')\n  @DocsEditable()\n  DataTransferItem addData(String data, String type) native;\n\n  @JSName('add')\n  @DomName('DataTransferItemList.add')\n  @DocsEditable()\n  DataTransferItem addFile(File file) native;\n\n  @DomName('DataTransferItemList.clear')\n  @DocsEditable()\n  void clear() native;\n\n  @DomName('DataTransferItemList.remove')\n  @DocsEditable()\n  @Experimental() // untriaged\n  void remove(int index) native;\n\n\n  DataTransferItem operator[] (int index) {\n    return JS('DataTransferItem', '#[#]', this, index);\n  }\n\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n// WARNING: Do not edit - generated code.\n\n\n@DomName('DatabaseCallback')\n// http://www.w3.org/TR/webdatabase/#databasecallback\n@Experimental() // deprecated\ntypedef void DatabaseCallback(database);\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('DedicatedWorkerGlobalScope')\n@Experimental() // untriaged\n@Native(\"DedicatedWorkerGlobalScope\")\nclass DedicatedWorkerGlobalScope extends WorkerGlobalScope {\n  // To suppress missing implicit constructor warnings.\n  factory DedicatedWorkerGlobalScope._() { throw new UnsupportedError(\"Not supported\"); }\n\n  /**\n   * Static factory designed to expose `message` events to event\n   * handlers that are not necessarily instances of [DedicatedWorkerGlobalScope].\n   *\n   * See [EventStreamProvider] for usage information.\n   */\n  @DomName('DedicatedWorkerGlobalScope.messageEvent')\n  @DocsEditable()\n  @Experimental() // untriaged\n  static const EventStreamProvider<MessageEvent> messageEvent = const EventStreamProvider<MessageEvent>('message');\n\n  @DomName('DedicatedWorkerGlobalScope.postMessage')\n  @DocsEditable()\n  @Experimental() // untriaged\n  void postMessage(Object message, [List<MessagePort> messagePorts]) native;\n\n  /// Stream of `message` events handled by this [DedicatedWorkerGlobalScope].\n  @DomName('DedicatedWorkerGlobalScope.onmessage')\n  @DocsEditable()\n  @Experimental() // untriaged\n  Stream<MessageEvent> get onMessage => messageEvent.forTarget(this);\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('DeprecatedStorageInfo')\n@Experimental() // untriaged\n@Native(\"DeprecatedStorageInfo\")\nclass DeprecatedStorageInfo extends Interceptor {\n  // To suppress missing implicit constructor warnings.\n  factory DeprecatedStorageInfo._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('DeprecatedStorageInfo.PERSISTENT')\n  @DocsEditable()\n  @Experimental() // untriaged\n  static const int PERSISTENT = 1;\n\n  @DomName('DeprecatedStorageInfo.TEMPORARY')\n  @DocsEditable()\n  @Experimental() // untriaged\n  static const int TEMPORARY = 0;\n\n  @DomName('DeprecatedStorageInfo.queryUsageAndQuota')\n  @DocsEditable()\n  @Experimental() // untriaged\n  void queryUsageAndQuota(int storageType, [StorageUsageCallback usageCallback, StorageErrorCallback errorCallback]) native;\n\n  @DomName('DeprecatedStorageInfo.requestQuota')\n  @DocsEditable()\n  @Experimental() // untriaged\n  void requestQuota(int storageType, int newQuotaInBytes, [StorageQuotaCallback quotaCallback, StorageErrorCallback errorCallback]) native;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('DeprecatedStorageQuota')\n@Experimental() // untriaged\n@Native(\"DeprecatedStorageQuota\")\nclass DeprecatedStorageQuota extends Interceptor {\n  // To suppress missing implicit constructor warnings.\n  factory DeprecatedStorageQuota._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('DeprecatedStorageQuota.queryUsageAndQuota')\n  @DocsEditable()\n  @Experimental() // untriaged\n  void queryUsageAndQuota(StorageUsageCallback usageCallback, [StorageErrorCallback errorCallback]) native;\n\n  @DomName('DeprecatedStorageQuota.requestQuota')\n  @DocsEditable()\n  @Experimental() // untriaged\n  void requestQuota(int newQuotaInBytes, [StorageQuotaCallback quotaCallback, StorageErrorCallback errorCallback]) native;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('HTMLDetailsElement')\n@SupportedBrowser(SupportedBrowser.CHROME)\n@SupportedBrowser(SupportedBrowser.SAFARI)\n@Experimental()\n@Native(\"HTMLDetailsElement\")\nclass DetailsElement extends HtmlElement {\n  // To suppress missing implicit constructor warnings.\n  factory DetailsElement._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('HTMLDetailsElement.HTMLDetailsElement')\n  @DocsEditable()\n  factory DetailsElement() => document.createElement(\"details\");\n  /**\n   * Constructor instantiated by the DOM when a custom element has been created.\n   *\n   * This can only be called by subclasses from their created constructor.\n   */\n  DetailsElement.created() : super.created();\n\n  /// Checks if this type is supported on the current platform.\n  static bool get supported => Element.isTagSupported('details');\n\n  @DomName('HTMLDetailsElement.open')\n  @DocsEditable()\n  bool open;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('DeviceAcceleration')\n// http://dev.w3.org/geo/api/spec-source-orientation.html#devicemotion\n@Experimental()\n@Native(\"DeviceAcceleration\")\nclass DeviceAcceleration extends Interceptor {\n  // To suppress missing implicit constructor warnings.\n  factory DeviceAcceleration._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('DeviceAcceleration.x')\n  @DocsEditable()\n  final double x;\n\n  @DomName('DeviceAcceleration.y')\n  @DocsEditable()\n  final double y;\n\n  @DomName('DeviceAcceleration.z')\n  @DocsEditable()\n  final double z;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('DeviceMotionEvent')\n// http://dev.w3.org/geo/api/spec-source-orientation.html#devicemotion\n@Experimental()\n@Native(\"DeviceMotionEvent\")\nclass DeviceMotionEvent extends Event {\n  // To suppress missing implicit constructor warnings.\n  factory DeviceMotionEvent._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('DeviceMotionEvent.acceleration')\n  @DocsEditable()\n  final DeviceAcceleration acceleration;\n\n  @DomName('DeviceMotionEvent.accelerationIncludingGravity')\n  @DocsEditable()\n  final DeviceAcceleration accelerationIncludingGravity;\n\n  @DomName('DeviceMotionEvent.interval')\n  @DocsEditable()\n  final double interval;\n\n  @DomName('DeviceMotionEvent.rotationRate')\n  @DocsEditable()\n  final DeviceRotationRate rotationRate;\n\n  @DomName('DeviceMotionEvent.initDeviceMotionEvent')\n  @DocsEditable()\n  @Experimental() // untriaged\n  void initDeviceMotionEvent(String type, bool bubbles, bool cancelable, DeviceAcceleration acceleration, DeviceAcceleration accelerationIncludingGravity, DeviceRotationRate rotationRate, num interval) native;\n}\n// Copyright (c) 2013, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n// WARNING: Do not edit - generated code.\n\n@DomName('DeviceOrientationEvent')\n// http://dev.w3.org/geo/api/spec-source-orientation.html#devicemotion\n@Experimental()\n@Native(\"DeviceOrientationEvent\")\nclass DeviceOrientationEvent extends Event {\n  factory DeviceOrientationEvent(String type,\n      {bool canBubble: true, bool cancelable: true, num alpha: 0, num beta: 0,\n      num gamma: 0, bool absolute: false}) {\n    var e = document._createEvent(\"DeviceOrientationEvent\");\n    e._initDeviceOrientationEvent(type, canBubble, cancelable, alpha, beta,\n        gamma, absolute);\n    return e;\n  }\n  // To suppress missing implicit constructor warnings.\n  factory DeviceOrientationEvent._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('DeviceOrientationEvent.absolute')\n  @DocsEditable()\n  final bool absolute;\n\n  @DomName('DeviceOrientationEvent.alpha')\n  @DocsEditable()\n  final double alpha;\n\n  @DomName('DeviceOrientationEvent.beta')\n  @DocsEditable()\n  final double beta;\n\n  @DomName('DeviceOrientationEvent.gamma')\n  @DocsEditable()\n  final double gamma;\n\n  @JSName('initDeviceOrientationEvent')\n  @DomName('DeviceOrientationEvent.initDeviceOrientationEvent')\n  @DocsEditable()\n  void _initDeviceOrientationEvent(String type, bool bubbles, bool cancelable, num alpha, num beta, num gamma, bool absolute) native;\n\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('DeviceRotationRate')\n// http://dev.w3.org/geo/api/spec-source-orientation.html#devicemotion\n@Experimental()\n@Native(\"DeviceRotationRate\")\nclass DeviceRotationRate extends Interceptor {\n  // To suppress missing implicit constructor warnings.\n  factory DeviceRotationRate._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('DeviceRotationRate.alpha')\n  @DocsEditable()\n  final double alpha;\n\n  @DomName('DeviceRotationRate.beta')\n  @DocsEditable()\n  final double beta;\n\n  @DomName('DeviceRotationRate.gamma')\n  @DocsEditable()\n  final double gamma;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('HTMLDialogElement')\n@Unstable()\n@Native(\"HTMLDialogElement\")\nclass DialogElement extends HtmlElement {\n  // To suppress missing implicit constructor warnings.\n  factory DialogElement._() { throw new UnsupportedError(\"Not supported\"); }\n  /**\n   * Constructor instantiated by the DOM when a custom element has been created.\n   *\n   * This can only be called by subclasses from their created constructor.\n   */\n  DialogElement.created() : super.created();\n\n  @DomName('HTMLDialogElement.open')\n  @DocsEditable()\n  bool open;\n\n  @DomName('HTMLDialogElement.returnValue')\n  @DocsEditable()\n  @Experimental() // untriaged\n  String returnValue;\n\n  @DomName('HTMLDialogElement.close')\n  @DocsEditable()\n  void close(String returnValue) native;\n\n  @DomName('HTMLDialogElement.show')\n  @DocsEditable()\n  void show() native;\n\n  @DomName('HTMLDialogElement.showModal')\n  @DocsEditable()\n  void showModal() native;\n}\n// Copyright (c) 2013, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DomName('DirectoryEntry')\n// http://www.w3.org/TR/file-system-api/#the-directoryentry-interface\n@Experimental()\n@Native(\"DirectoryEntry\")\nclass DirectoryEntry extends Entry {\n\n  /**\n   * Create a new directory with the specified `path`. If `exclusive` is true,\n   * the returned Future will complete with an error if a directory already\n   * exists with the specified `path`.\n   */\n  Future<Entry> createDirectory(String path, {bool exclusive: false}) {\n    return _getDirectory(path, options:\n        {'create': true, 'exclusive': exclusive});\n  }\n\n  /**\n   * Retrieve an already existing directory entry. The returned future will\n   * result in an error if a directory at `path` does not exist or if the item\n   * at `path` is not a directory.\n   */\n  Future<Entry> getDirectory(String path) {\n    return _getDirectory(path);\n  }\n\n  /**\n   * Create a new file with the specified `path`. If `exclusive` is true,\n   * the returned Future will complete with an error if a file already\n   * exists at the specified `path`.\n   */\n  Future<Entry> createFile(String path, {bool exclusive: false}) {\n    return _getFile(path, options: {'create': true, 'exclusive': exclusive});\n  }\n\n  /**\n   * Retrieve an already existing file entry. The returned future will\n   * result in an error if a file at `path` does not exist or if the item at\n   * `path` is not a file.\n   */\n  Future<Entry> getFile(String path) {\n    return _getFile(path);\n  }\n  // To suppress missing implicit constructor warnings.\n  factory DirectoryEntry._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('DirectoryEntry.createReader')\n  @DocsEditable()\n  DirectoryReader createReader() native;\n\n  @DomName('DirectoryEntry.getDirectory')\n  @DocsEditable()\n  void __getDirectory(String path, {Map options, _EntryCallback successCallback, _ErrorCallback errorCallback}) {\n    if (errorCallback != null) {\n      var options_1 = convertDartToNative_Dictionary(options);\n      __getDirectory_1(path, options_1, successCallback, errorCallback);\n      return;\n    }\n    if (successCallback != null) {\n      var options_2 = convertDartToNative_Dictionary(options);\n      __getDirectory_2(path, options_2, successCallback);\n      return;\n    }\n    if (options != null) {\n      var options_3 = convertDartToNative_Dictionary(options);\n      __getDirectory_3(path, options_3);\n      return;\n    }\n    __getDirectory_4(path);\n    return;\n  }\n  @JSName('getDirectory')\n  @DomName('DirectoryEntry.getDirectory')\n  @DocsEditable()\n  void __getDirectory_1(path, options, _EntryCallback successCallback, _ErrorCallback errorCallback) native;\n  @JSName('getDirectory')\n  @DomName('DirectoryEntry.getDirectory')\n  @DocsEditable()\n  void __getDirectory_2(path, options, _EntryCallback successCallback) native;\n  @JSName('getDirectory')\n  @DomName('DirectoryEntry.getDirectory')\n  @DocsEditable()\n  void __getDirectory_3(path, options) native;\n  @JSName('getDirectory')\n  @DomName('DirectoryEntry.getDirectory')\n  @DocsEditable()\n  void __getDirectory_4(path) native;\n\n  @JSName('getDirectory')\n  @DomName('DirectoryEntry.getDirectory')\n  @DocsEditable()\n  Future<Entry> _getDirectory(String path, {Map options}) {\n    var completer = new Completer<Entry>();\n    __getDirectory(path, options : options,\n        successCallback : (value) { completer.complete(value); },\n        errorCallback : (error) { completer.completeError(error); });\n    return completer.future;\n  }\n\n  @DomName('DirectoryEntry.getFile')\n  @DocsEditable()\n  void __getFile(String path, {Map options, _EntryCallback successCallback, _ErrorCallback errorCallback}) {\n    if (errorCallback != null) {\n      var options_1 = convertDartToNative_Dictionary(options);\n      __getFile_1(path, options_1, successCallback, errorCallback);\n      return;\n    }\n    if (successCallback != null) {\n      var options_2 = convertDartToNative_Dictionary(options);\n      __getFile_2(path, options_2, successCallback);\n      return;\n    }\n    if (options != null) {\n      var options_3 = convertDartToNative_Dictionary(options);\n      __getFile_3(path, options_3);\n      return;\n    }\n    __getFile_4(path);\n    return;\n  }\n  @JSName('getFile')\n  @DomName('DirectoryEntry.getFile')\n  @DocsEditable()\n  void __getFile_1(path, options, _EntryCallback successCallback, _ErrorCallback errorCallback) native;\n  @JSName('getFile')\n  @DomName('DirectoryEntry.getFile')\n  @DocsEditable()\n  void __getFile_2(path, options, _EntryCallback successCallback) native;\n  @JSName('getFile')\n  @DomName('DirectoryEntry.getFile')\n  @DocsEditable()\n  void __getFile_3(path, options) native;\n  @JSName('getFile')\n  @DomName('DirectoryEntry.getFile')\n  @DocsEditable()\n  void __getFile_4(path) native;\n\n  @JSName('getFile')\n  @DomName('DirectoryEntry.getFile')\n  @DocsEditable()\n  Future<Entry> _getFile(String path, {Map options}) {\n    var completer = new Completer<Entry>();\n    __getFile(path, options : options,\n        successCallback : (value) { completer.complete(value); },\n        errorCallback : (error) { completer.completeError(error); });\n    return completer.future;\n  }\n\n  @JSName('removeRecursively')\n  @DomName('DirectoryEntry.removeRecursively')\n  @DocsEditable()\n  void _removeRecursively(VoidCallback successCallback, [_ErrorCallback errorCallback]) native;\n\n  @JSName('removeRecursively')\n  @DomName('DirectoryEntry.removeRecursively')\n  @DocsEditable()\n  Future removeRecursively() {\n    var completer = new Completer();\n    _removeRecursively(\n        () { completer.complete(); },\n        (error) { completer.completeError(error); });\n    return completer.future;\n  }\n\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('DirectoryReader')\n// http://www.w3.org/TR/file-system-api/#the-directoryreader-interface\n@Experimental()\n@Native(\"DirectoryReader\")\nclass DirectoryReader extends Interceptor {\n  // To suppress missing implicit constructor warnings.\n  factory DirectoryReader._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @JSName('readEntries')\n  @DomName('DirectoryReader.readEntries')\n  @DocsEditable()\n  void _readEntries(_EntriesCallback successCallback, [_ErrorCallback errorCallback]) native;\n\n  @JSName('readEntries')\n  @DomName('DirectoryReader.readEntries')\n  @DocsEditable()\n  Future<List<Entry>> readEntries() {\n    var completer = new Completer<List<Entry>>();\n    _readEntries(\n        (value) { completer.complete(value); },\n        (error) { completer.completeError(error); });\n    return completer.future;\n  }\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n/**\n * A generic container for content on an HTML page;\n * corresponds to the &lt;div&gt; tag.\n *\n * The [DivElement] is a generic container and does not have any semantic\n * significance. It is functionally similar to [SpanElement].\n *\n * The [DivElement] is a block-level element, as opposed to [SpanElement],\n * which is an inline-level element.\n *\n * Example usage:\n *\n *     DivElement div = new DivElement();\n *     div.text = 'Here's my new DivElem\n *     document.body.elements.add(elem);\n *\n * See also:\n *\n * * [HTML <div> element](http://www.w3.org/TR/html-markup/div.html) from W3C.\n * * [Block-level element](http://www.w3.org/TR/CSS2/visuren.html#block-boxes) from W3C.\n * * [Inline-level element](http://www.w3.org/TR/CSS2/visuren.html#inline-boxes) from W3C.\n */\n@DomName('HTMLDivElement')\n@Native(\"HTMLDivElement\")\nclass DivElement extends HtmlElement {\n  // To suppress missing implicit constructor warnings.\n  factory DivElement._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('HTMLDivElement.HTMLDivElement')\n  @DocsEditable()\n  factory DivElement() => document.createElement(\"div\");\n  /**\n   * Constructor instantiated by the DOM when a custom element has been created.\n   *\n   * This can only be called by subclasses from their created constructor.\n   */\n  DivElement.created() : super.created();\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n/**\n * The base class for all documents.\n *\n * Each web page loaded in the browser has its own [Document] object, which is\n * typically an [HtmlDocument].\n *\n * If you aren't comfortable with DOM concepts, see the Dart tutorial\n * [Target 2: Connect Dart & HTML](http://www.dartlang.org/docs/tutorials/connect-dart-html/).\n */\n@DomName('Document')\n@Native(\"Document\")\nclass Document extends Node\n{\n\n  // To suppress missing implicit constructor warnings.\n  factory Document._() { throw new UnsupportedError(\"Not supported\"); }\n\n  /**\n   * Static factory designed to expose `readystatechange` events to event\n   * handlers that are not necessarily instances of [Document].\n   *\n   * See [EventStreamProvider] for usage information.\n   */\n  @DomName('Document.readystatechangeEvent')\n  @DocsEditable()\n  static const EventStreamProvider<Event> readyStateChangeEvent = const EventStreamProvider<Event>('readystatechange');\n\n  /**\n   * Static factory designed to expose `securitypolicyviolation` events to event\n   * handlers that are not necessarily instances of [Document].\n   *\n   * See [EventStreamProvider] for usage information.\n   */\n  @DomName('Document.securitypolicyviolationEvent')\n  @DocsEditable()\n  // https://dvcs.w3.org/hg/content-security-policy/raw-file/tip/csp-specification.dev.html#widl-Document-onsecuritypolicyviolation\n  @Experimental()\n  static const EventStreamProvider<SecurityPolicyViolationEvent> securityPolicyViolationEvent = const EventStreamProvider<SecurityPolicyViolationEvent>('securitypolicyviolation');\n\n  /**\n   * Static factory designed to expose `selectionchange` events to event\n   * handlers that are not necessarily instances of [Document].\n   *\n   * See [EventStreamProvider] for usage information.\n   */\n  @DomName('Document.selectionchangeEvent')\n  @DocsEditable()\n  static const EventStreamProvider<Event> selectionChangeEvent = const EventStreamProvider<Event>('selectionchange');\n\n  /**\n   * Static factory designed to expose `pointerlockchange` events to event\n   * handlers that are not necessarily instances of [Document].\n   *\n   * See [EventStreamProvider] for usage information.\n   */\n  @DomName('Document.webkitpointerlockchangeEvent')\n  @DocsEditable()\n  @SupportedBrowser(SupportedBrowser.CHROME)\n  @SupportedBrowser(SupportedBrowser.SAFARI)\n  @Experimental()\n  // https://dvcs.w3.org/hg/pointerlock/raw-file/default/index.html#widl-Document-onpointerlockchange\n  static const EventStreamProvider<Event> pointerLockChangeEvent = const EventStreamProvider<Event>('webkitpointerlockchange');\n\n  /**\n   * Static factory designed to expose `pointerlockerror` events to event\n   * handlers that are not necessarily instances of [Document].\n   *\n   * See [EventStreamProvider] for usage information.\n   */\n  @DomName('Document.webkitpointerlockerrorEvent')\n  @DocsEditable()\n  @SupportedBrowser(SupportedBrowser.CHROME)\n  @SupportedBrowser(SupportedBrowser.SAFARI)\n  @Experimental()\n  // https://dvcs.w3.org/hg/pointerlock/raw-file/default/index.html#widl-Document-onpointerlockerror\n  static const EventStreamProvider<Event> pointerLockErrorEvent = const EventStreamProvider<Event>('webkitpointerlockerror');\n\n  @DomName('Document.activeElement')\n  @DocsEditable()\n  @Experimental() // untriaged\n  final Element activeElement;\n\n  @JSName('body')\n  @DomName('Document.body')\n  @DocsEditable()\n  HtmlElement _body;\n\n  @DomName('Document.cookie')\n  @DocsEditable()\n  String cookie;\n\n  @DomName('Document.currentScript')\n  @DocsEditable()\n  @Experimental() // untriaged\n  final ScriptElement currentScript;\n\n  @DomName('Document.window')\n  @DocsEditable()\n  @Experimental() // untriaged\n  WindowBase get window => _convertNativeToDart_Window(this._get_window);\n  @JSName('defaultView')\n  @DomName('Document.window')\n  @DocsEditable()\n  @Experimental() // untriaged\n  @Creates('Window|=Object')\n  @Returns('Window|=Object')\n  @Creates('Window|=Object|Null')\n  @Returns('Window|=Object|Null')\n  final dynamic _get_window;\n\n  @DomName('Document.documentElement')\n  @DocsEditable()\n  final Element documentElement;\n\n  @DomName('Document.domain')\n  @DocsEditable()\n  final String domain;\n\n  @DomName('Document.fonts')\n  @DocsEditable()\n  @Experimental() // untriaged\n  final FontFaceSet fonts;\n\n  @JSName('head')\n  @DomName('Document.head')\n  @DocsEditable()\n  final HeadElement _head;\n\n  @DomName('Document.hidden')\n  @DocsEditable()\n  @Experimental() // untriaged\n  final bool hidden;\n\n  @DomName('Document.implementation')\n  @DocsEditable()\n  final DomImplementation implementation;\n\n  @JSName('lastModified')\n  @DomName('Document.lastModified')\n  @DocsEditable()\n  final String _lastModified;\n\n  @JSName('preferredStylesheetSet')\n  @DomName('Document.preferredStylesheetSet')\n  @DocsEditable()\n  final String _preferredStylesheetSet;\n\n  @DomName('Document.readyState')\n  @DocsEditable()\n  final String readyState;\n\n  @JSName('referrer')\n  @DomName('Document.referrer')\n  @DocsEditable()\n  final String _referrer;\n\n  @DomName('Document.rootElement')\n  @DocsEditable()\n  @Experimental() // untriaged\n  final SvgSvgElement rootElement;\n\n  @JSName('selectedStylesheetSet')\n  @DomName('Document.selectedStylesheetSet')\n  @DocsEditable()\n  String _selectedStylesheetSet;\n\n  @JSName('styleSheets')\n  @DomName('Document.styleSheets')\n  @DocsEditable()\n  @Returns('_StyleSheetList')\n  @Creates('_StyleSheetList')\n  final List<StyleSheet> _styleSheets;\n\n  @DomName('Document.timeline')\n  @DocsEditable()\n  @Experimental() // untriaged\n  final Timeline timeline;\n\n  @JSName('title')\n  @DomName('Document.title')\n  @DocsEditable()\n  String _title;\n\n  @DomName('Document.visibilityState')\n  @DocsEditable()\n  @Experimental() // untriaged\n  final String visibilityState;\n\n  @JSName('webkitFullscreenElement')\n  @DomName('Document.webkitFullscreenElement')\n  @DocsEditable()\n  @SupportedBrowser(SupportedBrowser.CHROME)\n  @SupportedBrowser(SupportedBrowser.SAFARI)\n  @Experimental()\n  // https://dvcs.w3.org/hg/fullscreen/raw-file/tip/Overview.html#dom-document-fullscreenelement\n  final Element _webkitFullscreenElement;\n\n  @JSName('webkitFullscreenEnabled')\n  @DomName('Document.webkitFullscreenEnabled')\n  @DocsEditable()\n  @SupportedBrowser(SupportedBrowser.CHROME)\n  @SupportedBrowser(SupportedBrowser.SAFARI)\n  @Experimental()\n  // https://dvcs.w3.org/hg/fullscreen/raw-file/tip/Overview.html#dom-document-fullscreenenabled\n  final bool _webkitFullscreenEnabled;\n\n  @JSName('webkitHidden')\n  @DomName('Document.webkitHidden')\n  @DocsEditable()\n  @SupportedBrowser(SupportedBrowser.CHROME)\n  @SupportedBrowser(SupportedBrowser.SAFARI)\n  @Experimental()\n  // https://dvcs.w3.org/hg/webperf/raw-file/tip/specs/PageVisibility/Overview.html#document\n  final bool _webkitHidden;\n\n  @JSName('webkitPointerLockElement')\n  @DomName('Document.webkitPointerLockElement')\n  @DocsEditable()\n  @SupportedBrowser(SupportedBrowser.CHROME)\n  @SupportedBrowser(SupportedBrowser.SAFARI)\n  @Experimental()\n  // https://dvcs.w3.org/hg/pointerlock/raw-file/default/index.html#widl-Document-pointerLockElement\n  final Element _webkitPointerLockElement;\n\n  @JSName('webkitVisibilityState')\n  @DomName('Document.webkitVisibilityState')\n  @DocsEditable()\n  @SupportedBrowser(SupportedBrowser.CHROME)\n  @SupportedBrowser(SupportedBrowser.SAFARI)\n  @Experimental()\n  // https://dvcs.w3.org/hg/webperf/raw-file/tip/specs/PageVisibility/Overview.html#dom-document-visibilitystate\n  final String _webkitVisibilityState;\n\n  @DomName('Document.adoptNode')\n  @DocsEditable()\n  Node adoptNode(Node node) native;\n\n  @JSName('caretRangeFromPoint')\n  @DomName('Document.caretRangeFromPoint')\n  @DocsEditable()\n  // http://www.w3.org/TR/2009/WD-cssom-view-20090804/#dom-documentview-caretrangefrompoint\n  @Experimental()\n  Range _caretRangeFromPoint(int x, int y) native;\n\n  @DomName('Document.createDocumentFragment')\n  @DocsEditable()\n  DocumentFragment createDocumentFragment() native;\n\n  @JSName('createElement')\n  @DomName('Document.createElement')\n  @DocsEditable()\n  Element _createElement(String localName_OR_tagName, [String typeExtension]) native;\n\n  @DomName('Document.createElementNS')\n  @DocsEditable()\n  Element createElementNS(String namespaceURI, String qualifiedName, [String typeExtension]) native;\n\n  @JSName('createEvent')\n  @DomName('Document.createEvent')\n  @DocsEditable()\n  Event _createEvent([String eventType]) native;\n\n  @DomName('Document.createRange')\n  @DocsEditable()\n  Range createRange() native;\n\n  @JSName('createTextNode')\n  @DomName('Document.createTextNode')\n  @DocsEditable()\n  Text _createTextNode(String data) native;\n\n  @DomName('Document.createTouch')\n  @DocsEditable()\n  // http://www.w3.org/TR/touch-events/, http://www.chromestatus.com/features\n  @Experimental()\n  Touch _createTouch(Window window, EventTarget target, int identifier, int pageX, int pageY, int screenX, int screenY, int webkitRadiusX, int webkitRadiusY, num webkitRotationAngle, num webkitForce) {\n    var target_1 = _convertDartToNative_EventTarget(target);\n    return _createTouch_1(window, target_1, identifier, pageX, pageY, screenX, screenY, webkitRadiusX, webkitRadiusY, webkitRotationAngle, webkitForce);\n  }\n  @JSName('createTouch')\n  @DomName('Document.createTouch')\n  @DocsEditable()\n  // http://www.w3.org/TR/touch-events/, http://www.chromestatus.com/features\n  @Experimental()\n  Touch _createTouch_1(Window window, target, identifier, pageX, pageY, screenX, screenY, webkitRadiusX, webkitRadiusY, webkitRotationAngle, webkitForce) native;\n\n  @JSName('elementFromPoint')\n  @DomName('Document.elementFromPoint')\n  @DocsEditable()\n  Element _elementFromPoint(int x, int y) native;\n\n  @DomName('Document.execCommand')\n  @DocsEditable()\n  bool execCommand(String command, bool userInterface, String value) native;\n\n  @JSName('getCSSCanvasContext')\n  @DomName('Document.getCSSCanvasContext')\n  @DocsEditable()\n  // https://developer.apple.com/library/safari/#documentation/AppleApplications/Reference/SafariCSSRef/Articles/Functions.html\n  @Experimental() // non-standard\n  CanvasRenderingContext _getCssCanvasContext(String contextId, String name, int width, int height) native;\n\n  @DomName('Document.getElementById')\n  @DocsEditable()\n  Element getElementById(String elementId) native;\n\n  @DomName('Document.getElementsByClassName')\n  @DocsEditable()\n  @Creates('NodeList|HtmlCollection')\n  @Returns('NodeList|HtmlCollection')\n  List<Node> getElementsByClassName(String classNames) native;\n\n  @DomName('Document.getElementsByName')\n  @DocsEditable()\n  @Returns('NodeList')\n  @Creates('NodeList')\n  List<Node> getElementsByName(String elementName) native;\n\n  @DomName('Document.getElementsByTagName')\n  @DocsEditable()\n  @Creates('NodeList|HtmlCollection')\n  @Returns('NodeList|HtmlCollection')\n  List<Node> getElementsByTagName(String localName) native;\n\n  @DomName('Document.importNode')\n  @DocsEditable()\n  Node importNode(Node node, [bool deep]) native;\n\n  @DomName('Document.queryCommandEnabled')\n  @DocsEditable()\n  bool queryCommandEnabled(String command) native;\n\n  @DomName('Document.queryCommandIndeterm')\n  @DocsEditable()\n  bool queryCommandIndeterm(String command) native;\n\n  @DomName('Document.queryCommandState')\n  @DocsEditable()\n  bool queryCommandState(String command) native;\n\n  @DomName('Document.queryCommandSupported')\n  @DocsEditable()\n  bool queryCommandSupported(String command) native;\n\n  @DomName('Document.queryCommandValue')\n  @DocsEditable()\n  String queryCommandValue(String command) native;\n\n  /**\n   * Finds the first descendant element of this document that matches the\n   * specified group of selectors.\n   *\n   * Unless your webpage contains multiple documents, the top-level\n   * [querySelector]\n   * method behaves the same as this method, so you should use it instead to\n   * save typing a few characters.\n   *\n   * [selectors] should be a string using CSS selector syntax.\n   *\n   *     var element1 = document.querySelector('.className');\n   *     var element2 = document.querySelector('#id');\n   *\n   * For details about CSS selector syntax, see the\n   * [CSS selector specification](http://www.w3.org/TR/css3-selectors/).\n   */\n  @DomName('Document.querySelector')\n  @DocsEditable()\n  Element querySelector(String selectors) native;\n\n  @JSName('querySelectorAll')\n  @DomName('Document.querySelectorAll')\n  @DocsEditable()\n  @Returns('NodeList')\n  @Creates('NodeList')\n  List<Node> _querySelectorAll(String selectors) native;\n\n  @JSName('webkitExitFullscreen')\n  @DomName('Document.webkitExitFullscreen')\n  @DocsEditable()\n  @SupportedBrowser(SupportedBrowser.CHROME)\n  @SupportedBrowser(SupportedBrowser.SAFARI)\n  @Experimental()\n  // https://dvcs.w3.org/hg/fullscreen/raw-file/tip/Overview.html#dom-document-exitfullscreen\n  void _webkitExitFullscreen() native;\n\n  @JSName('webkitExitPointerLock')\n  @DomName('Document.webkitExitPointerLock')\n  @DocsEditable()\n  @SupportedBrowser(SupportedBrowser.CHROME)\n  @SupportedBrowser(SupportedBrowser.SAFARI)\n  @Experimental()\n  // https://dvcs.w3.org/hg/pointerlock/raw-file/default/index.html#widl-Document-exitPointerLock-void\n  void _webkitExitPointerLock() native;\n\n  // From ParentNode\n\n  @JSName('childElementCount')\n  @DomName('Document.childElementCount')\n  @DocsEditable()\n  final int _childElementCount;\n\n  @JSName('children')\n  @DomName('Document.children')\n  @DocsEditable()\n  @Returns('HtmlCollection')\n  @Creates('HtmlCollection')\n  final List<Node> _children;\n\n  @JSName('firstElementChild')\n  @DomName('Document.firstElementChild')\n  @DocsEditable()\n  final Element _firstElementChild;\n\n  @JSName('lastElementChild')\n  @DomName('Document.lastElementChild')\n  @DocsEditable()\n  final Element _lastElementChild;\n\n  /// Stream of `abort` events handled by this [Document].\n  @DomName('Document.onabort')\n  @DocsEditable()\n  Stream<Event> get onAbort => Element.abortEvent.forTarget(this);\n\n  /// Stream of `beforecopy` events handled by this [Document].\n  @DomName('Document.onbeforecopy')\n  @DocsEditable()\n  Stream<Event> get onBeforeCopy => Element.beforeCopyEvent.forTarget(this);\n\n  /// Stream of `beforecut` events handled by this [Document].\n  @DomName('Document.onbeforecut')\n  @DocsEditable()\n  Stream<Event> get onBeforeCut => Element.beforeCutEvent.forTarget(this);\n\n  /// Stream of `beforepaste` events handled by this [Document].\n  @DomName('Document.onbeforepaste')\n  @DocsEditable()\n  Stream<Event> get onBeforePaste => Element.beforePasteEvent.forTarget(this);\n\n  /// Stream of `blur` events handled by this [Document].\n  @DomName('Document.onblur')\n  @DocsEditable()\n  Stream<Event> get onBlur => Element.blurEvent.forTarget(this);\n\n  /// Stream of `change` events handled by this [Document].\n  @DomName('Document.onchange')\n  @DocsEditable()\n  Stream<Event> get onChange => Element.changeEvent.forTarget(this);\n\n  /// Stream of `click` events handled by this [Document].\n  @DomName('Document.onclick')\n  @DocsEditable()\n  Stream<MouseEvent> get onClick => Element.clickEvent.forTarget(this);\n\n  /// Stream of `contextmenu` events handled by this [Document].\n  @DomName('Document.oncontextmenu')\n  @DocsEditable()\n  Stream<MouseEvent> get onContextMenu => Element.contextMenuEvent.forTarget(this);\n\n  /// Stream of `copy` events handled by this [Document].\n  @DomName('Document.oncopy')\n  @DocsEditable()\n  Stream<Event> get onCopy => Element.copyEvent.forTarget(this);\n\n  /// Stream of `cut` events handled by this [Document].\n  @DomName('Document.oncut')\n  @DocsEditable()\n  Stream<Event> get onCut => Element.cutEvent.forTarget(this);\n\n  /// Stream of `doubleclick` events handled by this [Document].\n  @DomName('Document.ondblclick')\n  @DocsEditable()\n  Stream<Event> get onDoubleClick => Element.doubleClickEvent.forTarget(this);\n\n  /// Stream of `drag` events handled by this [Document].\n  @DomName('Document.ondrag')\n  @DocsEditable()\n  Stream<MouseEvent> get onDrag => Element.dragEvent.forTarget(this);\n\n  /// Stream of `dragend` events handled by this [Document].\n  @DomName('Document.ondragend')\n  @DocsEditable()\n  Stream<MouseEvent> get onDragEnd => Element.dragEndEvent.forTarget(this);\n\n  /// Stream of `dragenter` events handled by this [Document].\n  @DomName('Document.ondragenter')\n  @DocsEditable()\n  Stream<MouseEvent> get onDragEnter => Element.dragEnterEvent.forTarget(this);\n\n  /// Stream of `dragleave` events handled by this [Document].\n  @DomName('Document.ondragleave')\n  @DocsEditable()\n  Stream<MouseEvent> get onDragLeave => Element.dragLeaveEvent.forTarget(this);\n\n  /// Stream of `dragover` events handled by this [Document].\n  @DomName('Document.ondragover')\n  @DocsEditable()\n  Stream<MouseEvent> get onDragOver => Element.dragOverEvent.forTarget(this);\n\n  /// Stream of `dragstart` events handled by this [Document].\n  @DomName('Document.ondragstart')\n  @DocsEditable()\n  Stream<MouseEvent> get onDragStart => Element.dragStartEvent.forTarget(this);\n\n  /// Stream of `drop` events handled by this [Document].\n  @DomName('Document.ondrop')\n  @DocsEditable()\n  Stream<MouseEvent> get onDrop => Element.dropEvent.forTarget(this);\n\n  /// Stream of `error` events handled by this [Document].\n  @DomName('Document.onerror')\n  @DocsEditable()\n  Stream<Event> get onError => Element.errorEvent.forTarget(this);\n\n  /// Stream of `focus` events handled by this [Document].\n  @DomName('Document.onfocus')\n  @DocsEditable()\n  Stream<Event> get onFocus => Element.focusEvent.forTarget(this);\n\n  /// Stream of `input` events handled by this [Document].\n  @DomName('Document.oninput')\n  @DocsEditable()\n  Stream<Event> get onInput => Element.inputEvent.forTarget(this);\n\n  /// Stream of `invalid` events handled by this [Document].\n  @DomName('Document.oninvalid')\n  @DocsEditable()\n  Stream<Event> get onInvalid => Element.invalidEvent.forTarget(this);\n\n  /// Stream of `keydown` events handled by this [Document].\n  @DomName('Document.onkeydown')\n  @DocsEditable()\n  Stream<KeyboardEvent> get onKeyDown => Element.keyDownEvent.forTarget(this);\n\n  /// Stream of `keypress` events handled by this [Document].\n  @DomName('Document.onkeypress')\n  @DocsEditable()\n  Stream<KeyboardEvent> get onKeyPress => Element.keyPressEvent.forTarget(this);\n\n  /// Stream of `keyup` events handled by this [Document].\n  @DomName('Document.onkeyup')\n  @DocsEditable()\n  Stream<KeyboardEvent> get onKeyUp => Element.keyUpEvent.forTarget(this);\n\n  /// Stream of `load` events handled by this [Document].\n  @DomName('Document.onload')\n  @DocsEditable()\n  Stream<Event> get onLoad => Element.loadEvent.forTarget(this);\n\n  /// Stream of `mousedown` events handled by this [Document].\n  @DomName('Document.onmousedown')\n  @DocsEditable()\n  Stream<MouseEvent> get onMouseDown => Element.mouseDownEvent.forTarget(this);\n\n  /// Stream of `mouseenter` events handled by this [Document].\n  @DomName('Document.onmouseenter')\n  @DocsEditable()\n  @Experimental() // untriaged\n  Stream<MouseEvent> get onMouseEnter => Element.mouseEnterEvent.forTarget(this);\n\n  /// Stream of `mouseleave` events handled by this [Document].\n  @DomName('Document.onmouseleave')\n  @DocsEditable()\n  @Experimental() // untriaged\n  Stream<MouseEvent> get onMouseLeave => Element.mouseLeaveEvent.forTarget(this);\n\n  /// Stream of `mousemove` events handled by this [Document].\n  @DomName('Document.onmousemove')\n  @DocsEditable()\n  Stream<MouseEvent> get onMouseMove => Element.mouseMoveEvent.forTarget(this);\n\n  /// Stream of `mouseout` events handled by this [Document].\n  @DomName('Document.onmouseout')\n  @DocsEditable()\n  Stream<MouseEvent> get onMouseOut => Element.mouseOutEvent.forTarget(this);\n\n  /// Stream of `mouseover` events handled by this [Document].\n  @DomName('Document.onmouseover')\n  @DocsEditable()\n  Stream<MouseEvent> get onMouseOver => Element.mouseOverEvent.forTarget(this);\n\n  /// Stream of `mouseup` events handled by this [Document].\n  @DomName('Document.onmouseup')\n  @DocsEditable()\n  Stream<MouseEvent> get onMouseUp => Element.mouseUpEvent.forTarget(this);\n\n  /// Stream of `mousewheel` events handled by this [Document].\n  @DomName('Document.onmousewheel')\n  @DocsEditable()\n  Stream<WheelEvent> get onMouseWheel => Element.mouseWheelEvent.forTarget(this);\n\n  /// Stream of `paste` events handled by this [Document].\n  @DomName('Document.onpaste')\n  @DocsEditable()\n  Stream<Event> get onPaste => Element.pasteEvent.forTarget(this);\n\n  /// Stream of `readystatechange` events handled by this [Document].\n  @DomName('Document.onreadystatechange')\n  @DocsEditable()\n  Stream<Event> get onReadyStateChange => readyStateChangeEvent.forTarget(this);\n\n  /// Stream of `reset` events handled by this [Document].\n  @DomName('Document.onreset')\n  @DocsEditable()\n  Stream<Event> get onReset => Element.resetEvent.forTarget(this);\n\n  @DomName('Document.onresize')\n  @DocsEditable()\n  @Experimental() // untriaged\n  Stream<Event> get onResize => Element.resizeEvent.forTarget(this);\n\n  /// Stream of `scroll` events handled by this [Document].\n  @DomName('Document.onscroll')\n  @DocsEditable()\n  Stream<Event> get onScroll => Element.scrollEvent.forTarget(this);\n\n  /// Stream of `search` events handled by this [Document].\n  @DomName('Document.onsearch')\n  @DocsEditable()\n  // http://www.w3.org/TR/html-markup/input.search.html\n  @Experimental()\n  Stream<Event> get onSearch => Element.searchEvent.forTarget(this);\n\n  /// Stream of `securitypolicyviolation` events handled by this [Document].\n  @DomName('Document.onsecuritypolicyviolation')\n  @DocsEditable()\n  // https://dvcs.w3.org/hg/content-security-policy/raw-file/tip/csp-specification.dev.html#widl-Document-onsecuritypolicyviolation\n  @Experimental()\n  Stream<SecurityPolicyViolationEvent> get onSecurityPolicyViolation => securityPolicyViolationEvent.forTarget(this);\n\n  /// Stream of `select` events handled by this [Document].\n  @DomName('Document.onselect')\n  @DocsEditable()\n  Stream<Event> get onSelect => Element.selectEvent.forTarget(this);\n\n  /// Stream of `selectionchange` events handled by this [Document].\n  @DomName('Document.onselectionchange')\n  @DocsEditable()\n  Stream<Event> get onSelectionChange => selectionChangeEvent.forTarget(this);\n\n  /// Stream of `selectstart` events handled by this [Document].\n  @DomName('Document.onselectstart')\n  @DocsEditable()\n  Stream<Event> get onSelectStart => Element.selectStartEvent.forTarget(this);\n\n  /// Stream of `submit` events handled by this [Document].\n  @DomName('Document.onsubmit')\n  @DocsEditable()\n  Stream<Event> get onSubmit => Element.submitEvent.forTarget(this);\n\n  /// Stream of `touchcancel` events handled by this [Document].\n  @DomName('Document.ontouchcancel')\n  @DocsEditable()\n  // http://www.w3.org/TR/touch-events/, http://www.chromestatus.com/features\n  @Experimental()\n  Stream<TouchEvent> get onTouchCancel => Element.touchCancelEvent.forTarget(this);\n\n  /// Stream of `touchend` events handled by this [Document].\n  @DomName('Document.ontouchend')\n  @DocsEditable()\n  // http://www.w3.org/TR/touch-events/, http://www.chromestatus.com/features\n  @Experimental()\n  Stream<TouchEvent> get onTouchEnd => Element.touchEndEvent.forTarget(this);\n\n  /// Stream of `touchmove` events handled by this [Document].\n  @DomName('Document.ontouchmove')\n  @DocsEditable()\n  // http://www.w3.org/TR/touch-events/, http://www.chromestatus.com/features\n  @Experimental()\n  Stream<TouchEvent> get onTouchMove => Element.touchMoveEvent.forTarget(this);\n\n  /// Stream of `touchstart` events handled by this [Document].\n  @DomName('Document.ontouchstart')\n  @DocsEditable()\n  // http://www.w3.org/TR/touch-events/, http://www.chromestatus.com/features\n  @Experimental()\n  Stream<TouchEvent> get onTouchStart => Element.touchStartEvent.forTarget(this);\n\n  /// Stream of `fullscreenchange` events handled by this [Document].\n  @DomName('Document.onwebkitfullscreenchange')\n  @DocsEditable()\n  // https://dvcs.w3.org/hg/fullscreen/raw-file/tip/Overview.html\n  @Experimental()\n  Stream<Event> get onFullscreenChange => Element.fullscreenChangeEvent.forTarget(this);\n\n  /// Stream of `fullscreenerror` events handled by this [Document].\n  @DomName('Document.onwebkitfullscreenerror')\n  @DocsEditable()\n  // https://dvcs.w3.org/hg/fullscreen/raw-file/tip/Overview.html\n  @Experimental()\n  Stream<Event> get onFullscreenError => Element.fullscreenErrorEvent.forTarget(this);\n\n  /// Stream of `pointerlockchange` events handled by this [Document].\n  @DomName('Document.onwebkitpointerlockchange')\n  @DocsEditable()\n  // https://dvcs.w3.org/hg/pointerlock/raw-file/default/index.html#widl-Document-onpointerlockchange\n  @Experimental()\n  Stream<Event> get onPointerLockChange => pointerLockChangeEvent.forTarget(this);\n\n  /// Stream of `pointerlockerror` events handled by this [Document].\n  @DomName('Document.onwebkitpointerlockerror')\n  @DocsEditable()\n  // https://dvcs.w3.org/hg/pointerlock/raw-file/default/index.html#widl-Document-onpointerlockerror\n  @Experimental()\n  Stream<Event> get onPointerLockError => pointerLockErrorEvent.forTarget(this);\n\n  /**\n   * Finds all descendant elements of this document that match the specified\n   * group of selectors.\n   *\n   * Unless your webpage contains multiple documents, the top-level\n   * [querySelectorAll]\n   * method behaves the same as this method, so you should use it instead to\n   * save typing a few characters.\n   *\n   * [selectors] should be a string using CSS selector syntax.\n   *\n   *     var items = document.querySelectorAll('.itemClassName');\n   *\n   * For details about CSS selector syntax, see the\n   * [CSS selector specification](http://www.w3.org/TR/css3-selectors/).\n   */\n  ElementList querySelectorAll(String selectors) {\n    return new _FrozenElementList._wrap(_querySelectorAll(selectors));\n  }\n\n  /**\n   * Alias for [querySelector]. Note this function is deprecated because its\n   * semantics will be changing in the future.\n   */\n  @deprecated\n  @Experimental()\n  @DomName('Document.querySelector')\n  Element query(String relativeSelectors) => querySelector(relativeSelectors);\n\n  /**\n   * Alias for [querySelectorAll]. Note this function is deprecated because its\n   * semantics will be changing in the future.\n   */\n  @deprecated\n  @Experimental()\n  @DomName('Document.querySelectorAll')\n  ElementList queryAll(String relativeSelectors) =>\n      querySelectorAll(relativeSelectors);\n\n  /// Checks if [registerElement] is supported on the current platform.\n  bool get supportsRegisterElement {\n    return JS('bool', '(\"registerElement\" in #)', this);\n  }\n\n  /// *Deprecated*: use [supportsRegisterElement] instead.\n  @deprecated\n  bool get supportsRegister => supportsRegisterElement;\n\n  @DomName('Document.createElement')\n  Element createElement(String tagName, [String typeExtension]) {\n    return _createElement(tagName, typeExtension);\n  }\n\n  @DomName('Document.createNodeIterator')\n  NodeIterator _createNodeIterator(Node root,\n      [int whatToShow, NodeFilter filter])\n      => JS('NodeIterator', '#.createNodeIterator(#, #, #, false)',\n          this, root, whatToShow, filter);\n\n  @DomName('Document.createTreeWalker')\n  TreeWalker _createTreeWalker(Node root,\n      [int whatToShow, NodeFilter filter])\n      => JS('TreeWalker', '#.createTreeWalker(#, #, #, false)',\n          this, root, whatToShow, filter);\n}\n// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DomName('DocumentFragment')\n@Native(\"DocumentFragment\")\nclass DocumentFragment extends Node implements ParentNode {\n  factory DocumentFragment() => document.createDocumentFragment();\n\n  factory DocumentFragment.html(String html,\n      {NodeValidator validator, NodeTreeSanitizer treeSanitizer}) {\n\n    return document.body.createFragment(html,\n      validator: validator, treeSanitizer: treeSanitizer);\n  }\n\n  factory DocumentFragment.svg(String svgContent,\n      {NodeValidator validator, NodeTreeSanitizer treeSanitizer}) {\n\n    return new svg.SvgSvgElement().createFragment(svgContent,\n        validator: validator, treeSanitizer: treeSanitizer);\n  }\n\n  HtmlCollection get _children => throw new UnimplementedError(\n      'Use _docChildren instead');\n\n  // Native field is used only by Dart code so does not lead to instantiation\n  // of native classes\n  @Creates('Null')\n  List<Element> _docChildren;\n\n  List<Element> get children {\n    if (_docChildren == null) {\n      _docChildren = new FilteredElementList(this);\n    }\n    return _docChildren;\n  }\n\n  void set children(List<Element> value) {\n    // Copy list first since we don't want liveness during iteration.\n    List copy = new List.from(value);\n    var children = this.children;\n    children.clear();\n    children.addAll(copy);\n  }\n\n  /**\n   * Finds all descendant elements of this document fragment that match the\n   * specified group of selectors.\n   *\n   * [selectors] should be a string using CSS selector syntax.\n   *\n   *     var items = document.querySelectorAll('.itemClassName');\n   *\n   * For details about CSS selector syntax, see the\n   * [CSS selector specification](http://www.w3.org/TR/css3-selectors/).\n   */\n  ElementList querySelectorAll(String selectors) =>\n    new _FrozenElementList._wrap(_querySelectorAll(selectors));\n\n\n\n  String get innerHtml {\n    final e = new Element.tag(\"div\");\n    e.append(this.clone(true));\n    return e.innerHtml;\n  }\n\n  void set innerHtml(String value) {\n    this.setInnerHtml(value);\n  }\n\n  void setInnerHtml(String html,\n    {NodeValidator validator, NodeTreeSanitizer treeSanitizer}) {\n\n    this.nodes.clear();\n    append(document.body.createFragment(\n        html, validator: validator, treeSanitizer: treeSanitizer));\n  }\n\n  /**\n   * Adds the specified text as a text node after the last child of this\n   * document fragment.\n   */\n  void appendText(String text) {\n    this.append(new Text(text));\n  }\n\n\n  /**\n   * Parses the specified text as HTML and adds the resulting node after the\n   * last child of this document fragment.\n   */\n  void appendHtml(String text) {\n    this.append(new DocumentFragment.html(text));\n  }\n\n  /** \n   * Alias for [querySelector]. Note this function is deprecated because its\n   * semantics will be changing in the future.\n   */\n  @deprecated\n  @Experimental()\n  @DomName('DocumentFragment.querySelector')\n  Element query(String relativeSelectors) {\n    return querySelector(relativeSelectors);\n  }\n\n  /** \n   * Alias for [querySelectorAll]. Note this function is deprecated because its\n   * semantics will be changing in the future.\n   */\n  @deprecated\n  @Experimental()\n  @DomName('DocumentFragment.querySelectorAll')\n  ElementList queryAll(String relativeSelectors) {\n    return querySelectorAll(relativeSelectors);\n  }\n  // To suppress missing implicit constructor warnings.\n  factory DocumentFragment._() { throw new UnsupportedError(\"Not supported\"); }\n\n  /**\n   * Finds the first descendant element of this document fragment that matches\n   * the specified group of selectors.\n   *\n   * [selectors] should be a string using CSS selector syntax.\n   *\n   *     var element1 = fragment.querySelector('.className');\n   *     var element2 = fragment.querySelector('#id');\n   *\n   * For details about CSS selector syntax, see the\n   * [CSS selector specification](http://www.w3.org/TR/css3-selectors/).\n   */\n  @DomName('DocumentFragment.querySelector')\n  @DocsEditable()\n  Element querySelector(String selectors) native;\n\n  @JSName('querySelectorAll')\n  @DomName('DocumentFragment.querySelectorAll')\n  @DocsEditable()\n  @Returns('NodeList')\n  @Creates('NodeList')\n  List<Node> _querySelectorAll(String selectors) native;\n\n  // From ParentNode\n\n  @JSName('childElementCount')\n  @DomName('DocumentFragment.childElementCount')\n  @DocsEditable()\n  final int _childElementCount;\n\n  @JSName('firstElementChild')\n  @DomName('DocumentFragment.firstElementChild')\n  @DocsEditable()\n  final Element _firstElementChild;\n\n  @JSName('lastElementChild')\n  @DomName('DocumentFragment.lastElementChild')\n  @DocsEditable()\n  final Element _lastElementChild;\n\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('DOMError')\n@Native(\"DOMError\")\nclass DomError extends Interceptor {\n  // To suppress missing implicit constructor warnings.\n  factory DomError._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('DOMError.message')\n  @DocsEditable()\n  @Experimental() // untriaged\n  final String message;\n\n  @DomName('DOMError.name')\n  @DocsEditable()\n  final String name;\n}\n// Copyright (c) 2013, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DomName('DOMException')\n@Unstable()\n@Native(\"DOMException\")\nclass DomException extends Interceptor {\n\n  static const String INDEX_SIZE = 'IndexSizeError';\n  static const String HIERARCHY_REQUEST = 'HierarchyRequestError';\n  static const String WRONG_DOCUMENT = 'WrongDocumentError';\n  static const String INVALID_CHARACTER = 'InvalidCharacterError';\n  static const String NO_MODIFICATION_ALLOWED = 'NoModificationAllowedError';\n  static const String NOT_FOUND = 'NotFoundError';\n  static const String NOT_SUPPORTED = 'NotSupportedError';\n  static const String INVALID_STATE = 'InvalidStateError';\n  static const String SYNTAX = 'SyntaxError';\n  static const String INVALID_MODIFICATION = 'InvalidModificationError';\n  static const String NAMESPACE = 'NamespaceError';\n  static const String INVALID_ACCESS = 'InvalidAccessError';\n  static const String TYPE_MISMATCH = 'TypeMismatchError';\n  static const String SECURITY = 'SecurityError';\n  static const String NETWORK = 'NetworkError';\n  static const String ABORT = 'AbortError';\n  static const String URL_MISMATCH = 'URLMismatchError';\n  static const String QUOTA_EXCEEDED = 'QuotaExceededError';\n  static const String TIMEOUT = 'TimeoutError';\n  static const String INVALID_NODE_TYPE = 'InvalidNodeTypeError';\n  static const String DATA_CLONE = 'DataCloneError';\n\n  String get name {\n    var errorName = JS('String', '#.name', this);\n    // Although Safari nightly has updated the name to SecurityError, Safari 5\n    // and 6 still return SECURITY_ERR.\n    if (Device.isWebKit && errorName == 'SECURITY_ERR') return 'SecurityError';\n    // Chrome release still uses old string, remove this line when Chrome stable\n    // also prints out SyntaxError.\n    if (Device.isWebKit && errorName == 'SYNTAX_ERR') return 'SyntaxError';\n    return errorName;\n  }\n  // To suppress missing implicit constructor warnings.\n  factory DomException._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('DOMException.message')\n  @DocsEditable()\n  final String message;\n\n  @DomName('DOMException.toString')\n  @DocsEditable()\n  String toString() native;\n\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('DOMImplementation')\n@Native(\"DOMImplementation\")\nclass DomImplementation extends Interceptor {\n  // To suppress missing implicit constructor warnings.\n  factory DomImplementation._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('DOMImplementation.createDocument')\n  @DocsEditable()\n  XmlDocument createDocument(String namespaceURI, String qualifiedName, _DocumentType doctype) native;\n\n  @DomName('DOMImplementation.createDocumentType')\n  @DocsEditable()\n  _DocumentType createDocumentType(String qualifiedName, String publicId, String systemId) native;\n\n  @JSName('createHTMLDocument')\n  @DomName('DOMImplementation.createHTMLDocument')\n  @DocsEditable()\n  HtmlDocument createHtmlDocument(String title) native;\n\n  @DomName('DOMImplementation.hasFeature')\n  @DocsEditable()\n  bool hasFeature(String feature, String version) native;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('DOMParser')\n@Native(\"DOMParser\")\nclass DomParser extends Interceptor {\n  // To suppress missing implicit constructor warnings.\n  factory DomParser._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('DOMParser.DOMParser')\n  @DocsEditable()\n  factory DomParser() {\n    return DomParser._create_1();\n  }\n  static DomParser _create_1() => JS('DomParser', 'new DOMParser()');\n\n  @DomName('DOMParser.parseFromString')\n  @DocsEditable()\n  Document parseFromString(String str, String contentType) native;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('DOMSettableTokenList')\n@Native(\"DOMSettableTokenList\")\nclass DomSettableTokenList extends DomTokenList {\n  // To suppress missing implicit constructor warnings.\n  factory DomSettableTokenList._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('DOMSettableTokenList.value')\n  @DocsEditable()\n  String value;\n\n  @DomName('DOMSettableTokenList.__getter__')\n  @DocsEditable()\n  String __getter__(int index) native;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('DOMStringList')\n@Native(\"DOMStringList\")\nclass DomStringList extends Interceptor with ListMixin<String>, ImmutableListMixin<String> implements JavaScriptIndexingBehavior, List<String> {\n  // To suppress missing implicit constructor warnings.\n  factory DomStringList._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('DOMStringList.length')\n  @DocsEditable()\n  int get length => JS(\"int\", \"#.length\", this);\n\n  String operator[](int index) {\n    if (JS(\"bool\", \"# >>> 0 !== # || # >= #\", index,\n        index, index, length))\n      throw new RangeError.range(index, 0, length);\n    return JS(\"String\", \"#[#]\", this, index);\n  }\n  void operator[]=(int index, String value) {\n    throw new UnsupportedError(\"Cannot assign element of immutable List.\");\n  }\n  // -- start List<String> mixins.\n  // String is the element type.\n\n\n  void set length(int value) {\n    throw new UnsupportedError(\"Cannot resize immutable List.\");\n  }\n\n  String get first {\n    if (this.length > 0) {\n      return JS('String', '#[0]', this);\n    }\n    throw new StateError(\"No elements\");\n  }\n\n  String get last {\n    int len = this.length;\n    if (len > 0) {\n      return JS('String', '#[#]', this, len - 1);\n    }\n    throw new StateError(\"No elements\");\n  }\n\n  String get single {\n    int len = this.length;\n    if (len == 1) {\n      return JS('String', '#[0]', this);\n    }\n    if (len == 0) throw new StateError(\"No elements\");\n    throw new StateError(\"More than one element\");\n  }\n\n  String elementAt(int index) => this[index];\n  // -- end List<String> mixins.\n\n  @DomName('DOMStringList.contains')\n  @DocsEditable()\n  bool contains(String string) native;\n\n  @DomName('DOMStringList.item')\n  @DocsEditable()\n  String item(int index) native;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('DOMStringMap')\nabstract class DomStringMap extends Interceptor {\n  // To suppress missing implicit constructor warnings.\n  factory DomStringMap._() { throw new UnsupportedError(\"Not supported\"); }\n\n  bool __delete__(index_OR_name);\n\n  String __getter__(index_OR_name);\n\n  void __setter__(index_OR_name, String value);\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('DOMTokenList')\n@Native(\"DOMTokenList\")\nclass DomTokenList extends Interceptor {\n  // To suppress missing implicit constructor warnings.\n  factory DomTokenList._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('DOMTokenList.length')\n  @DocsEditable()\n  final int length;\n\n  @DomName('DOMTokenList.contains')\n  @DocsEditable()\n  bool contains(String token) native;\n\n  @DomName('DOMTokenList.item')\n  @DocsEditable()\n  String item(int index) native;\n\n  @DomName('DOMTokenList.toString')\n  @DocsEditable()\n  String toString() native;\n\n  @DomName('DOMTokenList.toggle')\n  @DocsEditable()\n  bool toggle(String token, [bool force]) native;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\nclass _ChildrenElementList extends ListBase<Element>\n    implements NodeListWrapper {\n  // Raw Element.\n  final Element _element;\n  final HtmlCollection _childElements;\n\n  _ChildrenElementList._wrap(Element element)\n    : _childElements = element._children,\n      _element = element;\n\n  bool contains(Object element) => _childElements.contains(element);\n\n\n  bool get isEmpty {\n    return _element._firstElementChild == null;\n  }\n\n  int get length {\n    return _childElements.length;\n  }\n\n  Element operator [](int index) {\n    return _childElements[index];\n  }\n\n  void operator []=(int index, Element value) {\n    _element._replaceChild(value, _childElements[index]);\n  }\n\n  void set length(int newLength) {\n    // TODO(jacobr): remove children when length is reduced.\n    throw new UnsupportedError('Cannot resize element lists');\n  }\n\n  Element add(Element value) {\n    _element.append(value);\n    return value;\n  }\n\n  Iterator<Element> get iterator => toList().iterator;\n\n  void addAll(Iterable<Element> iterable) {\n    if (iterable is _ChildNodeListLazy) {\n      iterable = new List.from(iterable);\n    }\n\n    for (Element element in iterable) {\n      _element.append(element);\n    }\n  }\n\n  void sort([int compare(Element a, Element b)]) {\n    throw new UnsupportedError('Cannot sort element lists');\n  }\n\n  void shuffle([Random random]) {\n    throw new UnsupportedError('Cannot shuffle element lists');\n  }\n\n  void removeWhere(bool test(Element element)) {\n    _filter(test, false);\n  }\n\n  void retainWhere(bool test(Element element)) {\n    _filter(test, true);\n  }\n\n  void _filter(bool test(var element), bool retainMatching) {\n    var removed;\n    if (retainMatching) {\n      removed = _element.children.where((e) => !test(e));\n    } else {\n      removed = _element.children.where(test);\n    }\n    for (var e in removed) e.remove();\n  }\n\n  void setRange(int start, int end, Iterable<Element> iterable,\n                [int skipCount = 0]) {\n    throw new UnimplementedError();\n  }\n\n  void replaceRange(int start, int end, Iterable<Element> iterable) {\n    throw new UnimplementedError();\n  }\n\n  void fillRange(int start, int end, [Element fillValue]) {\n    throw new UnimplementedError();\n  }\n\n  bool remove(Object object) {\n    if (object is Element) {\n      Element element = object;\n      if (identical(element.parentNode, _element)) {\n        _element._removeChild(element);\n        return true;\n      }\n    }\n    return false;\n  }\n\n  void insert(int index, Element element) {\n    if (index < 0 || index > length) {\n      throw new RangeError.range(index, 0, length);\n    }\n    if (index == length) {\n      _element.append(element);\n    } else {\n      _element.insertBefore(element, this[index]);\n    }\n  }\n\n  void setAll(int index, Iterable<Element> iterable) {\n    throw new UnimplementedError();\n  }\n\n  void clear() {\n    _element._clearChildren();\n  }\n\n  Element removeAt(int index) {\n    final result = this[index];\n    if (result != null) {\n      _element._removeChild(result);\n    }\n    return result;\n  }\n\n  Element removeLast() {\n    final result = this.last;\n    if (result != null) {\n      _element._removeChild(result);\n    }\n    return result;\n  }\n\n  Element get first {\n    Element result = _element._firstElementChild;\n    if (result == null) throw new StateError(\"No elements\");\n    return result;\n  }\n\n\n  Element get last {\n    Element result = _element._lastElementChild;\n    if (result == null) throw new StateError(\"No elements\");\n    return result;\n  }\n\n  Element get single {\n    if (length > 1) throw new StateError(\"More than one element\");\n    return first;\n  }\n\n  List<Node> get rawList => _childElements;\n}\n\n/**\n * An immutable list containing HTML elements. This list contains some\n * additional methods when compared to regular lists for ease of CSS\n * manipulation on a group of elements.\n */\nabstract class ElementList<T extends Element> extends ListBase<T> {\n  /**\n   * The union of all CSS classes applied to the elements in this list.\n   *\n   * This set makes it easy to add, remove or toggle (add if not present, remove\n   * if present) the classes applied to a collection of elements.\n   *\n   *     htmlList.classes.add('selected');\n   *     htmlList.classes.toggle('isOnline');\n   *     htmlList.classes.remove('selected');\n   */\n  CssClassSet get classes;\n\n  /** Replace the classes with `value` for every element in this list. */\n  set classes(Iterable<String> value);\n\n  /**\n   * Access the union of all [CssStyleDeclaration]s that are associated with an\n   * [ElementList].\n   *\n   * Grouping the style objects all together provides easy editing of specific\n   * properties of a collection of elements. Setting a specific property value\n   * will set that property in all [Element]s in the [ElementList]. Getting a\n   * specific property value will return the value of the property of the first\n   * element in the [ElementList].\n   */\n  CssStyleDeclarationBase get style;\n\n  /**\n   * Access dimensions and position of the Elements in this list.\n   *\n   * Setting the height or width properties will set the height or width\n   * property for all elements in the list. This returns a rectangle with the\n   * dimenions actually available for content\n   * in this element, in pixels, regardless of this element's box-sizing\n   * property. Getting the height or width returns the height or width of the\n   * first Element in this list.\n   *\n   * Unlike [getBoundingClientRect], the dimensions of this rectangle\n   * will return the same numerical height if the element is hidden or not.\n   */\n  @Experimental()\n  CssRect get contentEdge;\n\n  /**\n   * Access dimensions and position of the first Element's content + padding box\n   * in this list.\n   *\n   * This returns a rectangle with the dimenions actually available for content\n   * in this element, in pixels, regardless of this element's box-sizing\n   * property. Unlike [getBoundingClientRect], the dimensions of this rectangle\n   * will return the same numerical height if the element is hidden or not. This\n   * can be used to retrieve jQuery's `innerHeight` value for an element. This\n   * is also a rectangle equalling the dimensions of clientHeight and\n   * clientWidth.\n   */\n  @Experimental()\n  CssRect get paddingEdge;\n\n  /**\n   * Access dimensions and position of the first Element's content + padding +\n   * border box in this list.\n   *\n   * This returns a rectangle with the dimenions actually available for content\n   * in this element, in pixels, regardless of this element's box-sizing\n   * property. Unlike [getBoundingClientRect], the dimensions of this rectangle\n   * will return the same numerical height if the element is hidden or not. This\n   * can be used to retrieve jQuery's `outerHeight` value for an element.\n   */\n  @Experimental()\n  CssRect get borderEdge;\n\n  /**\n   * Access dimensions and position of the first Element's content + padding +\n   * border + margin box in this list.\n   *\n   * This returns a rectangle with the dimenions actually available for content\n   * in this element, in pixels, regardless of this element's box-sizing\n   * property. Unlike [getBoundingClientRect], the dimensions of this rectangle\n   * will return the same numerical height if the element is hidden or not. This\n   * can be used to retrieve jQuery's `outerHeight` value for an element.\n   */\n  @Experimental()\n  CssRect get marginEdge;\n\n  /// Stream of `abort` events handled by this [Element].\n  @DomName('Element.onabort')\n  @DocsEditable()\n  ElementStream<Event> get onAbort;\n\n  /// Stream of `beforecopy` events handled by this [Element].\n  @DomName('Element.onbeforecopy')\n  @DocsEditable()\n  ElementStream<Event> get onBeforeCopy;\n\n  /// Stream of `beforecut` events handled by this [Element].\n  @DomName('Element.onbeforecut')\n  @DocsEditable()\n  ElementStream<Event> get onBeforeCut;\n\n  /// Stream of `beforepaste` events handled by this [Element].\n  @DomName('Element.onbeforepaste')\n  @DocsEditable()\n  ElementStream<Event> get onBeforePaste;\n\n  /// Stream of `blur` events handled by this [Element].\n  @DomName('Element.onblur')\n  @DocsEditable()\n  ElementStream<Event> get onBlur;\n\n  /// Stream of `change` events handled by this [Element].\n  @DomName('Element.onchange')\n  @DocsEditable()\n  ElementStream<Event> get onChange;\n\n  /// Stream of `click` events handled by this [Element].\n  @DomName('Element.onclick')\n  @DocsEditable()\n  ElementStream<MouseEvent> get onClick;\n\n  /// Stream of `contextmenu` events handled by this [Element].\n  @DomName('Element.oncontextmenu')\n  @DocsEditable()\n  ElementStream<MouseEvent> get onContextMenu;\n\n  /// Stream of `copy` events handled by this [Element].\n  @DomName('Element.oncopy')\n  @DocsEditable()\n  ElementStream<Event> get onCopy;\n\n  /// Stream of `cut` events handled by this [Element].\n  @DomName('Element.oncut')\n  @DocsEditable()\n  ElementStream<Event> get onCut;\n\n  /// Stream of `doubleclick` events handled by this [Element].\n  @DomName('Element.ondblclick')\n  @DocsEditable()\n  ElementStream<Event> get onDoubleClick;\n\n  /**\n   * A stream of `drag` events fired when this element currently being dragged.\n   *\n   * A `drag` event is added to this stream as soon as the drag begins.\n   * A `drag` event is also added to this stream at intervals while the drag\n   * operation is still ongoing.\n   *\n   * ## Other resources\n   *\n   * * [Drag and drop sample]\n   * (https://github.com/dart-lang/dart-samples/tree/master/web/html5/dnd/basics)\n   * based on [the tutorial](http://www.html5rocks.com/en/tutorials/dnd/basics/)\n   * from HTML5Rocks.\n   * * [Drag and drop specification]\n   * (http://www.whatwg.org/specs/web-apps/current-work/multipage/dnd.html#dnd)\n   * from WHATWG.\n   */\n  @DomName('Element.ondrag')\n  @DocsEditable()\n  ElementStream<MouseEvent> get onDrag;\n\n  /**\n   * A stream of `dragend` events fired when this element completes a drag\n   * operation.\n   *\n   * ## Other resources\n   *\n   * * [Drag and drop sample]\n   * (https://github.com/dart-lang/dart-samples/tree/master/web/html5/dnd/basics)\n   * based on [the tutorial](http://www.html5rocks.com/en/tutorials/dnd/basics/)\n   * from HTML5Rocks.\n   * * [Drag and drop specification]\n   * (http://www.whatwg.org/specs/web-apps/current-work/multipage/dnd.html#dnd)\n   * from WHATWG.\n   */\n  @DomName('Element.ondragend')\n  @DocsEditable()\n  ElementStream<MouseEvent> get onDragEnd;\n\n  /**\n   * A stream of `dragenter` events fired when a dragged object is first dragged\n   * over this element.\n   *\n   * ## Other resources\n   *\n   * * [Drag and drop sample]\n   * (https://github.com/dart-lang/dart-samples/tree/master/web/html5/dnd/basics)\n   * based on [the tutorial](http://www.html5rocks.com/en/tutorials/dnd/basics/)\n   * from HTML5Rocks.\n   * * [Drag and drop specification]\n   * (http://www.whatwg.org/specs/web-apps/current-work/multipage/dnd.html#dnd)\n   * from WHATWG.\n   */\n  @DomName('Element.ondragenter')\n  @DocsEditable()\n  ElementStream<MouseEvent> get onDragEnter;\n\n  /**\n   * A stream of `dragleave` events fired when an object being dragged over this\n   * element leaves this element's target area.\n   *\n   * ## Other resources\n   *\n   * * [Drag and drop sample]\n   * (https://github.com/dart-lang/dart-samples/tree/master/web/html5/dnd/basics)\n   * based on [the tutorial](http://www.html5rocks.com/en/tutorials/dnd/basics/)\n   * from HTML5Rocks.\n   * * [Drag and drop specification]\n   * (http://www.whatwg.org/specs/web-apps/current-work/multipage/dnd.html#dnd)\n   * from WHATWG.\n   */\n  @DomName('Element.ondragleave')\n  @DocsEditable()\n  ElementStream<MouseEvent> get onDragLeave;\n\n  /**\n   * A stream of `dragover` events fired when a dragged object is currently\n   * being dragged over this element.\n   *\n   * ## Other resources\n   *\n   * * [Drag and drop sample]\n   * (https://github.com/dart-lang/dart-samples/tree/master/web/html5/dnd/basics)\n   * based on [the tutorial](http://www.html5rocks.com/en/tutorials/dnd/basics/)\n   * from HTML5Rocks.\n   * * [Drag and drop specification]\n   * (http://www.whatwg.org/specs/web-apps/current-work/multipage/dnd.html#dnd)\n   * from WHATWG.\n   */\n  @DomName('Element.ondragover')\n  @DocsEditable()\n  ElementStream<MouseEvent> get onDragOver;\n\n  /**\n   * A stream of `dragstart` events fired when this element starts being\n   * dragged.\n   *\n   * ## Other resources\n   *\n   * * [Drag and drop sample]\n   * (https://github.com/dart-lang/dart-samples/tree/master/web/html5/dnd/basics)\n   * based on [the tutorial](http://www.html5rocks.com/en/tutorials/dnd/basics/)\n   * from HTML5Rocks.\n   * * [Drag and drop specification]\n   * (http://www.whatwg.org/specs/web-apps/current-work/multipage/dnd.html#dnd)\n   * from WHATWG.\n   */\n  @DomName('Element.ondragstart')\n  @DocsEditable()\n  ElementStream<MouseEvent> get onDragStart;\n\n  /**\n   * A stream of `drop` events fired when a dragged object is dropped on this\n   * element.\n   *\n   * ## Other resources\n   *\n   * * [Drag and drop sample]\n   * (https://github.com/dart-lang/dart-samples/tree/master/web/html5/dnd/basics)\n   * based on [the tutorial](http://www.html5rocks.com/en/tutorials/dnd/basics/)\n   * from HTML5Rocks.\n   * * [Drag and drop specification]\n   * (http://www.whatwg.org/specs/web-apps/current-work/multipage/dnd.html#dnd)\n   * from WHATWG.\n   */\n  @DomName('Element.ondrop')\n  @DocsEditable()\n  ElementStream<MouseEvent> get onDrop;\n\n  /// Stream of `error` events handled by this [Element].\n  @DomName('Element.onerror')\n  @DocsEditable()\n  ElementStream<Event> get onError;\n\n  /// Stream of `focus` events handled by this [Element].\n  @DomName('Element.onfocus')\n  @DocsEditable()\n  ElementStream<Event> get onFocus;\n\n  /// Stream of `input` events handled by this [Element].\n  @DomName('Element.oninput')\n  @DocsEditable()\n  ElementStream<Event> get onInput;\n\n  /// Stream of `invalid` events handled by this [Element].\n  @DomName('Element.oninvalid')\n  @DocsEditable()\n  ElementStream<Event> get onInvalid;\n\n  /// Stream of `keydown` events handled by this [Element].\n  @DomName('Element.onkeydown')\n  @DocsEditable()\n  ElementStream<KeyboardEvent> get onKeyDown;\n\n  /// Stream of `keypress` events handled by this [Element].\n  @DomName('Element.onkeypress')\n  @DocsEditable()\n  ElementStream<KeyboardEvent> get onKeyPress;\n\n  /// Stream of `keyup` events handled by this [Element].\n  @DomName('Element.onkeyup')\n  @DocsEditable()\n  ElementStream<KeyboardEvent> get onKeyUp;\n\n  /// Stream of `load` events handled by this [Element].\n  @DomName('Element.onload')\n  @DocsEditable()\n  ElementStream<Event> get onLoad;\n\n  /// Stream of `mousedown` events handled by this [Element].\n  @DomName('Element.onmousedown')\n  @DocsEditable()\n  ElementStream<MouseEvent> get onMouseDown;\n\n  /// Stream of `mouseenter` events handled by this [Element].\n  @DomName('Element.onmouseenter')\n  @DocsEditable()\n  @Experimental() // untriaged\n  ElementStream<MouseEvent> get onMouseEnter;\n\n  /// Stream of `mouseleave` events handled by this [Element].\n  @DomName('Element.onmouseleave')\n  @DocsEditable()\n  @Experimental() // untriaged\n  ElementStream<MouseEvent> get onMouseLeave;\n\n  /// Stream of `mousemove` events handled by this [Element].\n  @DomName('Element.onmousemove')\n  @DocsEditable()\n  ElementStream<MouseEvent> get onMouseMove;\n\n  /// Stream of `mouseout` events handled by this [Element].\n  @DomName('Element.onmouseout')\n  @DocsEditable()\n  ElementStream<MouseEvent> get onMouseOut;\n\n  /// Stream of `mouseover` events handled by this [Element].\n  @DomName('Element.onmouseover')\n  @DocsEditable()\n  ElementStream<MouseEvent> get onMouseOver;\n\n  /// Stream of `mouseup` events handled by this [Element].\n  @DomName('Element.onmouseup')\n  @DocsEditable()\n  ElementStream<MouseEvent> get onMouseUp;\n\n  /// Stream of `mousewheel` events handled by this [Element].\n  @DomName('Element.onmousewheel')\n  @DocsEditable()\n  // http://www.w3.org/TR/DOM-Level-3-Events/#events-wheelevents\n  @Experimental() // non-standard\n  ElementStream<WheelEvent> get onMouseWheel;\n\n  /// Stream of `paste` events handled by this [Element].\n  @DomName('Element.onpaste')\n  @DocsEditable()\n  ElementStream<Event> get onPaste;\n\n  /// Stream of `reset` events handled by this [Element].\n  @DomName('Element.onreset')\n  @DocsEditable()\n  ElementStream<Event> get onReset;\n\n  @DomName('Element.onresize')\n  @DocsEditable()\n  @Experimental() // untriaged\n  ElementStream<Event> get onResize;\n\n  /// Stream of `scroll` events handled by this [Element].\n  @DomName('Element.onscroll')\n  @DocsEditable()\n  ElementStream<Event> get onScroll;\n\n  /// Stream of `search` events handled by this [Element].\n  @DomName('Element.onsearch')\n  @DocsEditable()\n  // http://www.w3.org/TR/html-markup/input.search.html\n  @Experimental()\n  ElementStream<Event> get onSearch;\n\n  /// Stream of `select` events handled by this [Element].\n  @DomName('Element.onselect')\n  @DocsEditable()\n  ElementStream<Event> get onSelect;\n\n  /// Stream of `selectstart` events handled by this [Element].\n  @DomName('Element.onselectstart')\n  @DocsEditable()\n  @Experimental() // nonstandard\n  ElementStream<Event> get onSelectStart;\n\n  /// Stream of `submit` events handled by this [Element].\n  @DomName('Element.onsubmit')\n  @DocsEditable()\n  ElementStream<Event> get onSubmit;\n\n  /// Stream of `touchcancel` events handled by this [Element].\n  @DomName('Element.ontouchcancel')\n  @DocsEditable()\n  // http://www.w3.org/TR/touch-events/, http://www.chromestatus.com/features\n  @Experimental()\n  ElementStream<TouchEvent> get onTouchCancel;\n\n  /// Stream of `touchend` events handled by this [Element].\n  @DomName('Element.ontouchend')\n  @DocsEditable()\n  // http://www.w3.org/TR/touch-events/, http://www.chromestatus.com/features\n  @Experimental()\n  ElementStream<TouchEvent> get onTouchEnd;\n\n  /// Stream of `touchenter` events handled by this [Element].\n  @DomName('Element.ontouchenter')\n  @DocsEditable()\n  // http://www.w3.org/TR/touch-events/, http://www.chromestatus.com/features\n  @Experimental()\n  ElementStream<TouchEvent> get onTouchEnter;\n\n  /// Stream of `touchleave` events handled by this [Element].\n  @DomName('Element.ontouchleave')\n  @DocsEditable()\n  // http://www.w3.org/TR/touch-events/, http://www.chromestatus.com/features\n  @Experimental()\n  ElementStream<TouchEvent> get onTouchLeave;\n\n  /// Stream of `touchmove` events handled by this [Element].\n  @DomName('Element.ontouchmove')\n  @DocsEditable()\n  // http://www.w3.org/TR/touch-events/, http://www.chromestatus.com/features\n  @Experimental()\n  ElementStream<TouchEvent> get onTouchMove;\n\n  /// Stream of `touchstart` events handled by this [Element].\n  @DomName('Element.ontouchstart')\n  @DocsEditable()\n  // http://www.w3.org/TR/touch-events/, http://www.chromestatus.com/features\n  @Experimental()\n  ElementStream<TouchEvent> get onTouchStart;\n\n  /// Stream of `transitionend` events handled by this [Element].\n  @DomName('Element.ontransitionend')\n  @DocsEditable()\n  @SupportedBrowser(SupportedBrowser.CHROME)\n  @SupportedBrowser(SupportedBrowser.FIREFOX)\n  @SupportedBrowser(SupportedBrowser.IE, '10')\n  @SupportedBrowser(SupportedBrowser.SAFARI)\n  ElementStream<TransitionEvent> get onTransitionEnd;\n\n  /// Stream of `fullscreenchange` events handled by this [Element].\n  @DomName('Element.onwebkitfullscreenchange')\n  @DocsEditable()\n  // https://dvcs.w3.org/hg/fullscreen/raw-file/tip/Overview.html\n  @Experimental()\n  ElementStream<Event> get onFullscreenChange;\n\n  /// Stream of `fullscreenerror` events handled by this [Element].\n  @DomName('Element.onwebkitfullscreenerror')\n  @DocsEditable()\n  // https://dvcs.w3.org/hg/fullscreen/raw-file/tip/Overview.html\n  @Experimental()\n  ElementStream<Event> get onFullscreenError;\n\n}\n\n// TODO(jacobr): this is an inefficient implementation but it is hard to see\n// a better option given that we cannot quite force NodeList to be an\n// ElementList as there are valid cases where a NodeList JavaScript object\n// contains Node objects that are not Elements.\nclass _FrozenElementList<T extends Element> extends ListBase<T>\n    implements ElementList<T>, NodeListWrapper {\n  final List<Node> _nodeList;\n  // The subset of _nodeList that are Elements.\n  List<Element> _elementList;\n\n  _FrozenElementList._wrap(this._nodeList) {\n    _elementList = _nodeList.where((e) => e is Element).toList();\n  }\n\n  int get length => _nodeList.length;\n\n  Element operator [](int index) => _nodeList[index];\n\n  void operator []=(int index, Element value) {\n    throw new UnsupportedError('Cannot modify list');\n  }\n\n  void set length(int newLength) {\n    throw new UnsupportedError('Cannot modify list');\n  }\n\n  void sort([Comparator<Element> compare]) {\n    throw new UnsupportedError('Cannot sort list');\n  }\n\n  void shuffle([Random random]) {\n    throw new UnsupportedError('Cannot shuffle list');\n  }\n\n  Element get first => _nodeList.first;\n\n  Element get last => _nodeList.last;\n\n  Element get single => _nodeList.single;\n\n  CssClassSet get classes => new _MultiElementCssClassSet(_elementList);\n\n  CssStyleDeclarationBase get style =>\n      new _CssStyleDeclarationSet(_elementList);\n\n  void set classes(Iterable<String> value) {\n    _elementList.forEach((e) => e.classes = value);\n  }\n\n  CssRect get contentEdge => new _ContentCssListRect(_elementList);\n\n  CssRect get paddingEdge => _elementList.first.paddingEdge;\n\n  CssRect get borderEdge => _elementList.first.borderEdge;\n\n  CssRect get marginEdge => _elementList.first.marginEdge;\n\n  List<Node> get rawList => _nodeList;\n\n\n  /// Stream of `abort` events handled by this [Element].\n  @DomName('Element.onabort')\n  @DocsEditable()\n  ElementStream<Event> get onAbort => Element.abortEvent._forElementList(this);\n\n  /// Stream of `beforecopy` events handled by this [Element].\n  @DomName('Element.onbeforecopy')\n  @DocsEditable()\n  ElementStream<Event> get onBeforeCopy => Element.beforeCopyEvent._forElementList(this);\n\n  /// Stream of `beforecut` events handled by this [Element].\n  @DomName('Element.onbeforecut')\n  @DocsEditable()\n  ElementStream<Event> get onBeforeCut => Element.beforeCutEvent._forElementList(this);\n\n  /// Stream of `beforepaste` events handled by this [Element].\n  @DomName('Element.onbeforepaste')\n  @DocsEditable()\n  ElementStream<Event> get onBeforePaste => Element.beforePasteEvent._forElementList(this);\n\n  /// Stream of `blur` events handled by this [Element].\n  @DomName('Element.onblur')\n  @DocsEditable()\n  ElementStream<Event> get onBlur => Element.blurEvent._forElementList(this);\n\n  /// Stream of `change` events handled by this [Element].\n  @DomName('Element.onchange')\n  @DocsEditable()\n  ElementStream<Event> get onChange => Element.changeEvent._forElementList(this);\n\n  /// Stream of `click` events handled by this [Element].\n  @DomName('Element.onclick')\n  @DocsEditable()\n  ElementStream<MouseEvent> get onClick => Element.clickEvent._forElementList(this);\n\n  /// Stream of `contextmenu` events handled by this [Element].\n  @DomName('Element.oncontextmenu')\n  @DocsEditable()\n  ElementStream<MouseEvent> get onContextMenu => Element.contextMenuEvent._forElementList(this);\n\n  /// Stream of `copy` events handled by this [Element].\n  @DomName('Element.oncopy')\n  @DocsEditable()\n  ElementStream<Event> get onCopy => Element.copyEvent._forElementList(this);\n\n  /// Stream of `cut` events handled by this [Element].\n  @DomName('Element.oncut')\n  @DocsEditable()\n  ElementStream<Event> get onCut => Element.cutEvent._forElementList(this);\n\n  /// Stream of `doubleclick` events handled by this [Element].\n  @DomName('Element.ondblclick')\n  @DocsEditable()\n  ElementStream<Event> get onDoubleClick => Element.doubleClickEvent._forElementList(this);\n\n  /**\n   * A stream of `drag` events fired when this element currently being dragged.\n   *\n   * A `drag` event is added to this stream as soon as the drag begins.\n   * A `drag` event is also added to this stream at intervals while the drag\n   * operation is still ongoing.\n   *\n   * ## Other resources\n   *\n   * * [Drag and drop sample]\n   * (https://github.com/dart-lang/dart-samples/tree/master/web/html5/dnd/basics)\n   * based on [the tutorial](http://www.html5rocks.com/en/tutorials/dnd/basics/)\n   * from HTML5Rocks.\n   * * [Drag and drop specification]\n   * (http://www.whatwg.org/specs/web-apps/current-work/multipage/dnd.html#dnd)\n   * from WHATWG.\n   */\n  @DomName('Element.ondrag')\n  @DocsEditable()\n  ElementStream<MouseEvent> get onDrag => Element.dragEvent._forElementList(this);\n\n  /**\n   * A stream of `dragend` events fired when this element completes a drag\n   * operation.\n   *\n   * ## Other resources\n   *\n   * * [Drag and drop sample]\n   * (https://github.com/dart-lang/dart-samples/tree/master/web/html5/dnd/basics)\n   * based on [the tutorial](http://www.html5rocks.com/en/tutorials/dnd/basics/)\n   * from HTML5Rocks.\n   * * [Drag and drop specification]\n   * (http://www.whatwg.org/specs/web-apps/current-work/multipage/dnd.html#dnd)\n   * from WHATWG.\n   */\n  @DomName('Element.ondragend')\n  @DocsEditable()\n  ElementStream<MouseEvent> get onDragEnd => Element.dragEndEvent._forElementList(this);\n\n  /**\n   * A stream of `dragenter` events fired when a dragged object is first dragged\n   * over this element.\n   *\n   * ## Other resources\n   *\n   * * [Drag and drop sample]\n   * (https://github.com/dart-lang/dart-samples/tree/master/web/html5/dnd/basics)\n   * based on [the tutorial](http://www.html5rocks.com/en/tutorials/dnd/basics/)\n   * from HTML5Rocks.\n   * * [Drag and drop specification]\n   * (http://www.whatwg.org/specs/web-apps/current-work/multipage/dnd.html#dnd)\n   * from WHATWG.\n   */\n  @DomName('Element.ondragenter')\n  @DocsEditable()\n  ElementStream<MouseEvent> get onDragEnter => Element.dragEnterEvent._forElementList(this);\n\n  /**\n   * A stream of `dragleave` events fired when an object being dragged over this\n   * element leaves this element's target area.\n   *\n   * ## Other resources\n   *\n   * * [Drag and drop sample]\n   * (https://github.com/dart-lang/dart-samples/tree/master/web/html5/dnd/basics)\n   * based on [the tutorial](http://www.html5rocks.com/en/tutorials/dnd/basics/)\n   * from HTML5Rocks.\n   * * [Drag and drop specification]\n   * (http://www.whatwg.org/specs/web-apps/current-work/multipage/dnd.html#dnd)\n   * from WHATWG.\n   */\n  @DomName('Element.ondragleave')\n  @DocsEditable()\n  ElementStream<MouseEvent> get onDragLeave => Element.dragLeaveEvent._forElementList(this);\n\n  /**\n   * A stream of `dragover` events fired when a dragged object is currently\n   * being dragged over this element.\n   *\n   * ## Other resources\n   *\n   * * [Drag and drop sample]\n   * (https://github.com/dart-lang/dart-samples/tree/master/web/html5/dnd/basics)\n   * based on [the tutorial](http://www.html5rocks.com/en/tutorials/dnd/basics/)\n   * from HTML5Rocks.\n   * * [Drag and drop specification]\n   * (http://www.whatwg.org/specs/web-apps/current-work/multipage/dnd.html#dnd)\n   * from WHATWG.\n   */\n  @DomName('Element.ondragover')\n  @DocsEditable()\n  ElementStream<MouseEvent> get onDragOver => Element.dragOverEvent._forElementList(this);\n\n  /**\n   * A stream of `dragstart` events fired when this element starts being\n   * dragged.\n   *\n   * ## Other resources\n   *\n   * * [Drag and drop sample]\n   * (https://github.com/dart-lang/dart-samples/tree/master/web/html5/dnd/basics)\n   * based on [the tutorial](http://www.html5rocks.com/en/tutorials/dnd/basics/)\n   * from HTML5Rocks.\n   * * [Drag and drop specification]\n   * (http://www.whatwg.org/specs/web-apps/current-work/multipage/dnd.html#dnd)\n   * from WHATWG.\n   */\n  @DomName('Element.ondragstart')\n  @DocsEditable()\n  ElementStream<MouseEvent> get onDragStart => Element.dragStartEvent._forElementList(this);\n\n  /**\n   * A stream of `drop` events fired when a dragged object is dropped on this\n   * element.\n   *\n   * ## Other resources\n   *\n   * * [Drag and drop sample]\n   * (https://github.com/dart-lang/dart-samples/tree/master/web/html5/dnd/basics)\n   * based on [the tutorial](http://www.html5rocks.com/en/tutorials/dnd/basics/)\n   * from HTML5Rocks.\n   * * [Drag and drop specification]\n   * (http://www.whatwg.org/specs/web-apps/current-work/multipage/dnd.html#dnd)\n   * from WHATWG.\n   */\n  @DomName('Element.ondrop')\n  @DocsEditable()\n  ElementStream<MouseEvent> get onDrop => Element.dropEvent._forElementList(this);\n\n  /// Stream of `error` events handled by this [Element].\n  @DomName('Element.onerror')\n  @DocsEditable()\n  ElementStream<Event> get onError => Element.errorEvent._forElementList(this);\n\n  /// Stream of `focus` events handled by this [Element].\n  @DomName('Element.onfocus')\n  @DocsEditable()\n  ElementStream<Event> get onFocus => Element.focusEvent._forElementList(this);\n\n  /// Stream of `input` events handled by this [Element].\n  @DomName('Element.oninput')\n  @DocsEditable()\n  ElementStream<Event> get onInput => Element.inputEvent._forElementList(this);\n\n  /// Stream of `invalid` events handled by this [Element].\n  @DomName('Element.oninvalid')\n  @DocsEditable()\n  ElementStream<Event> get onInvalid => Element.invalidEvent._forElementList(this);\n\n  /// Stream of `keydown` events handled by this [Element].\n  @DomName('Element.onkeydown')\n  @DocsEditable()\n  ElementStream<KeyboardEvent> get onKeyDown => Element.keyDownEvent._forElementList(this);\n\n  /// Stream of `keypress` events handled by this [Element].\n  @DomName('Element.onkeypress')\n  @DocsEditable()\n  ElementStream<KeyboardEvent> get onKeyPress => Element.keyPressEvent._forElementList(this);\n\n  /// Stream of `keyup` events handled by this [Element].\n  @DomName('Element.onkeyup')\n  @DocsEditable()\n  ElementStream<KeyboardEvent> get onKeyUp => Element.keyUpEvent._forElementList(this);\n\n  /// Stream of `load` events handled by this [Element].\n  @DomName('Element.onload')\n  @DocsEditable()\n  ElementStream<Event> get onLoad => Element.loadEvent._forElementList(this);\n\n  /// Stream of `mousedown` events handled by this [Element].\n  @DomName('Element.onmousedown')\n  @DocsEditable()\n  ElementStream<MouseEvent> get onMouseDown => Element.mouseDownEvent._forElementList(this);\n\n  /// Stream of `mouseenter` events handled by this [Element].\n  @DomName('Element.onmouseenter')\n  @DocsEditable()\n  @Experimental() // untriaged\n  ElementStream<MouseEvent> get onMouseEnter => Element.mouseEnterEvent._forElementList(this);\n\n  /// Stream of `mouseleave` events handled by this [Element].\n  @DomName('Element.onmouseleave')\n  @DocsEditable()\n  @Experimental() // untriaged\n  ElementStream<MouseEvent> get onMouseLeave => Element.mouseLeaveEvent._forElementList(this);\n\n  /// Stream of `mousemove` events handled by this [Element].\n  @DomName('Element.onmousemove')\n  @DocsEditable()\n  ElementStream<MouseEvent> get onMouseMove => Element.mouseMoveEvent._forElementList(this);\n\n  /// Stream of `mouseout` events handled by this [Element].\n  @DomName('Element.onmouseout')\n  @DocsEditable()\n  ElementStream<MouseEvent> get onMouseOut => Element.mouseOutEvent._forElementList(this);\n\n  /// Stream of `mouseover` events handled by this [Element].\n  @DomName('Element.onmouseover')\n  @DocsEditable()\n  ElementStream<MouseEvent> get onMouseOver => Element.mouseOverEvent._forElementList(this);\n\n  /// Stream of `mouseup` events handled by this [Element].\n  @DomName('Element.onmouseup')\n  @DocsEditable()\n  ElementStream<MouseEvent> get onMouseUp => Element.mouseUpEvent._forElementList(this);\n\n  /// Stream of `mousewheel` events handled by this [Element].\n  @DomName('Element.onmousewheel')\n  @DocsEditable()\n  // http://www.w3.org/TR/DOM-Level-3-Events/#events-wheelevents\n  @Experimental() // non-standard\n  ElementStream<WheelEvent> get onMouseWheel => Element.mouseWheelEvent._forElementList(this);\n\n  /// Stream of `paste` events handled by this [Element].\n  @DomName('Element.onpaste')\n  @DocsEditable()\n  ElementStream<Event> get onPaste => Element.pasteEvent._forElementList(this);\n\n  /// Stream of `reset` events handled by this [Element].\n  @DomName('Element.onreset')\n  @DocsEditable()\n  ElementStream<Event> get onReset => Element.resetEvent._forElementList(this);\n\n  @DomName('Element.onresize')\n  @DocsEditable()\n  @Experimental() // untriaged\n  ElementStream<Event> get onResize => Element.resizeEvent._forElementList(this);\n\n  /// Stream of `scroll` events handled by this [Element].\n  @DomName('Element.onscroll')\n  @DocsEditable()\n  ElementStream<Event> get onScroll => Element.scrollEvent._forElementList(this);\n\n  /// Stream of `search` events handled by this [Element].\n  @DomName('Element.onsearch')\n  @DocsEditable()\n  // http://www.w3.org/TR/html-markup/input.search.html\n  @Experimental()\n  ElementStream<Event> get onSearch => Element.searchEvent._forElementList(this);\n\n  /// Stream of `select` events handled by this [Element].\n  @DomName('Element.onselect')\n  @DocsEditable()\n  ElementStream<Event> get onSelect => Element.selectEvent._forElementList(this);\n\n  /// Stream of `selectstart` events handled by this [Element].\n  @DomName('Element.onselectstart')\n  @DocsEditable()\n  @Experimental() // nonstandard\n  ElementStream<Event> get onSelectStart => Element.selectStartEvent._forElementList(this);\n\n  /// Stream of `submit` events handled by this [Element].\n  @DomName('Element.onsubmit')\n  @DocsEditable()\n  ElementStream<Event> get onSubmit => Element.submitEvent._forElementList(this);\n\n  /// Stream of `touchcancel` events handled by this [Element].\n  @DomName('Element.ontouchcancel')\n  @DocsEditable()\n  // http://www.w3.org/TR/touch-events/, http://www.chromestatus.com/features\n  @Experimental()\n  ElementStream<TouchEvent> get onTouchCancel => Element.touchCancelEvent._forElementList(this);\n\n  /// Stream of `touchend` events handled by this [Element].\n  @DomName('Element.ontouchend')\n  @DocsEditable()\n  // http://www.w3.org/TR/touch-events/, http://www.chromestatus.com/features\n  @Experimental()\n  ElementStream<TouchEvent> get onTouchEnd => Element.touchEndEvent._forElementList(this);\n\n  /// Stream of `touchenter` events handled by this [Element].\n  @DomName('Element.ontouchenter')\n  @DocsEditable()\n  // http://www.w3.org/TR/touch-events/, http://www.chromestatus.com/features\n  @Experimental()\n  ElementStream<TouchEvent> get onTouchEnter => Element.touchEnterEvent._forElementList(this);\n\n  /// Stream of `touchleave` events handled by this [Element].\n  @DomName('Element.ontouchleave')\n  @DocsEditable()\n  // http://www.w3.org/TR/touch-events/, http://www.chromestatus.com/features\n  @Experimental()\n  ElementStream<TouchEvent> get onTouchLeave => Element.touchLeaveEvent._forElementList(this);\n\n  /// Stream of `touchmove` events handled by this [Element].\n  @DomName('Element.ontouchmove')\n  @DocsEditable()\n  // http://www.w3.org/TR/touch-events/, http://www.chromestatus.com/features\n  @Experimental()\n  ElementStream<TouchEvent> get onTouchMove => Element.touchMoveEvent._forElementList(this);\n\n  /// Stream of `touchstart` events handled by this [Element].\n  @DomName('Element.ontouchstart')\n  @DocsEditable()\n  // http://www.w3.org/TR/touch-events/, http://www.chromestatus.com/features\n  @Experimental()\n  ElementStream<TouchEvent> get onTouchStart => Element.touchStartEvent._forElementList(this);\n\n  /// Stream of `transitionend` events handled by this [Element].\n  @DomName('Element.ontransitionend')\n  @DocsEditable()\n  @SupportedBrowser(SupportedBrowser.CHROME)\n  @SupportedBrowser(SupportedBrowser.FIREFOX)\n  @SupportedBrowser(SupportedBrowser.IE, '10')\n  @SupportedBrowser(SupportedBrowser.SAFARI)\n  ElementStream<TransitionEvent> get onTransitionEnd => Element.transitionEndEvent._forElementList(this);\n\n  /// Stream of `fullscreenchange` events handled by this [Element].\n  @DomName('Element.onwebkitfullscreenchange')\n  @DocsEditable()\n  // https://dvcs.w3.org/hg/fullscreen/raw-file/tip/Overview.html\n  @Experimental()\n  ElementStream<Event> get onFullscreenChange => Element.fullscreenChangeEvent._forElementList(this);\n\n  /// Stream of `fullscreenerror` events handled by this [Element].\n  @DomName('Element.onwebkitfullscreenerror')\n  @DocsEditable()\n  // https://dvcs.w3.org/hg/fullscreen/raw-file/tip/Overview.html\n  @Experimental()\n  ElementStream<Event> get onFullscreenError => Element.fullscreenErrorEvent._forElementList(this);\n\n}\n\n@DocsEditable()\n/**\n * An abstract class, which all HTML elements extend.\n */\n@DomName('Element')\n@Native(\"Element\")\nabstract class Element extends Node implements GlobalEventHandlers, ParentNode, ChildNode {\n\n  /**\n   * Creates an HTML element from a valid fragment of HTML.\n   *\n   *     var element = new Element.html('<div class=\"foo\">content</div>');\n   *\n   * The HTML fragment should contain only one single root element, any\n   * leading or trailing text nodes will be removed.\n   *\n   * The HTML fragment is parsed as if it occurred within the context of a\n   * `<body>` tag, this means that special elements such as `<caption>` which\n   * must be parsed within the scope of a `<table>` element will be dropped. Use\n   * [createFragment] to parse contextual HTML fragments.\n   *\n   * Unless a validator is provided this will perform the default validation\n   * and remove all scriptable elements and attributes.\n   *\n   * See also:\n   *\n   * * [NodeValidator]\n   *\n   */\n  factory Element.html(String html,\n      {NodeValidator validator, NodeTreeSanitizer treeSanitizer}) {\n    var fragment = document.body.createFragment(html, validator: validator,\n        treeSanitizer: treeSanitizer);\n\n    return fragment.nodes.where((e) => e is Element).single;\n  }\n\n  /**\n   * Custom element creation constructor.\n   *\n   * This constructor is used by the DOM when a custom element has been\n   * created. It can only be invoked by subclasses of Element from\n   * that classes created constructor.\n   *\n   *     class CustomElement extends Element {\n   *       factory CustomElement() => new Element.tag('x-custom');\n   *\n   *       CustomElement.created() : super.created() {\n   *          // Perform any element initialization.\n   *       }\n   *     }\n   *     document.registerElement('x-custom', CustomElement);\n   */\n  Element.created() : super._created() {\n    // Validate that this is a custom element & perform any additional\n    // initialization.\n    _initializeCustomElement(this);\n  }\n\n  /**\n   * Creates the HTML element specified by the tag name.\n   *\n   * This is similar to [Document.createElement].\n   * [tag] should be a valid HTML tag name. If [tag] is an unknown tag then\n   * this will create an [UnknownElement].\n   *\n   *     var divElement = new Element.tag('div');\n   *     print(divElement is DivElement); // 'true'\n   *     var myElement = new Element.tag('unknownTag');\n   *     print(myElement is UnknownElement); // 'true'\n   *\n   * For standard elements it is more preferable to use the type constructors:\n   *     var element = new DivElement();\n   *\n   * See also:\n   *\n   * * [isTagSupported]\n   */\n  factory Element.tag(String tag, [String typeExtention]) =>\n      _ElementFactoryProvider.createElement_tag(tag, typeExtention);\n\n  /// Creates a new `<a>` element.\n  ///\n  /// This is identical to calling `new Element.tag('a')`.\n  factory Element.a() => new Element.tag('a');\n\n  /// Creates a new `<article>` element.\n  ///\n  /// This is identical to calling `new Element.tag('article')`.\n  factory Element.article() => new Element.tag('article');\n\n  /// Creates a new `<aside>` element.\n  ///\n  /// This is identical to calling `new Element.tag('aside')`.\n  factory Element.aside() => new Element.tag('aside');\n\n  /// Creates a new `<audio>` element.\n  ///\n  /// This is identical to calling `new Element.tag('audio')`.\n  factory Element.audio() => new Element.tag('audio');\n\n  /// Creates a new `<br>` element.\n  ///\n  /// This is identical to calling `new Element.tag('br')`.\n  factory Element.br() => new Element.tag('br');\n\n  /// Creates a new `<canvas>` element.\n  ///\n  /// This is identical to calling `new Element.tag('canvas')`.\n  factory Element.canvas() => new Element.tag('canvas');\n\n  /// Creates a new `<div>` element.\n  ///\n  /// This is identical to calling `new Element.tag('div')`.\n  factory Element.div() => new Element.tag('div');\n\n  /// Creates a new `<footer>` element.\n  ///\n  /// This is identical to calling `new Element.tag('footer')`.\n  factory Element.footer() => new Element.tag('footer');\n\n  /// Creates a new `<header>` element.\n  ///\n  /// This is identical to calling `new Element.tag('header')`.\n  factory Element.header() => new Element.tag('header');\n\n  /// Creates a new `<hr>` element.\n  ///\n  /// This is identical to calling `new Element.tag('hr')`.\n  factory Element.hr() => new Element.tag('hr');\n\n  /// Creates a new `<iframe>` element.\n  ///\n  /// This is identical to calling `new Element.tag('iframe')`.\n  factory Element.iframe() => new Element.tag('iframe');\n\n  /// Creates a new `<img>` element.\n  ///\n  /// This is identical to calling `new Element.tag('img')`.\n  factory Element.img() => new Element.tag('img');\n\n  /// Creates a new `<li>` element.\n  ///\n  /// This is identical to calling `new Element.tag('li')`.\n  factory Element.li() => new Element.tag('li');\n\n  /// Creates a new `<nav>` element.\n  ///\n  /// This is identical to calling `new Element.tag('nav')`.\n  factory Element.nav() => new Element.tag('nav');\n\n  /// Creates a new `<ol>` element.\n  ///\n  /// This is identical to calling `new Element.tag('ol')`.\n  factory Element.ol() => new Element.tag('ol');\n\n  /// Creates a new `<option>` element.\n  ///\n  /// This is identical to calling `new Element.tag('option')`.\n  factory Element.option() => new Element.tag('option');\n\n  /// Creates a new `<p>` element.\n  ///\n  /// This is identical to calling `new Element.tag('p')`.\n  factory Element.p() => new Element.tag('p');\n\n  /// Creates a new `<pre>` element.\n  ///\n  /// This is identical to calling `new Element.tag('pre')`.\n  factory Element.pre() => new Element.tag('pre');\n\n  /// Creates a new `<section>` element.\n  ///\n  /// This is identical to calling `new Element.tag('section')`.\n  factory Element.section() => new Element.tag('section');\n\n  /// Creates a new `<select>` element.\n  ///\n  /// This is identical to calling `new Element.tag('select')`.\n  factory Element.select() => new Element.tag('select');\n\n  /// Creates a new `<span>` element.\n  ///\n  /// This is identical to calling `new Element.tag('span')`.\n  factory Element.span() => new Element.tag('span');\n\n  /// Creates a new `<svg>` element.\n  ///\n  /// This is identical to calling `new Element.tag('svg')`.\n  factory Element.svg() => new Element.tag('svg');\n\n  /// Creates a new `<table>` element.\n  ///\n  /// This is identical to calling `new Element.tag('table')`.\n  factory Element.table() => new Element.tag('table');\n\n  /// Creates a new `<td>` element.\n  ///\n  /// This is identical to calling `new Element.tag('td')`.\n  factory Element.td() => new Element.tag('td');\n\n  /// Creates a new `<textarea>` element.\n  ///\n  /// This is identical to calling `new Element.tag('textarea')`.\n  factory Element.textarea() => new Element.tag('textarea');\n\n  /// Creates a new `<th>` element.\n  ///\n  /// This is identical to calling `new Element.tag('th')`.\n  factory Element.th() => new Element.tag('th');\n\n  /// Creates a new `<tr>` element.\n  ///\n  /// This is identical to calling `new Element.tag('tr')`.\n  factory Element.tr() => new Element.tag('tr');\n\n  /// Creates a new `<ul>` element.\n  ///\n  /// This is identical to calling `new Element.tag('ul')`.\n  factory Element.ul() => new Element.tag('ul');\n\n  /// Creates a new `<video>` element.\n  ///\n  /// This is identical to calling `new Element.tag('video')`.\n  factory Element.video() => new Element.tag('video');\n\n  /**\n   * All attributes on this element.\n   *\n   * Any modifications to the attribute map will automatically be applied to\n   * this element.\n   *\n   * This only includes attributes which are not in a namespace\n   * (such as 'xlink:href'), additional attributes can be accessed via\n   * [getNamespacedAttributes].\n   */\n  Map<String, String> get attributes => new _ElementAttributeMap(this);\n\n  void set attributes(Map<String, String> value) {\n    Map<String, String> attributes = this.attributes;\n    attributes.clear();\n    for (String key in value.keys) {\n      attributes[key] = value[key];\n    }\n  }\n\n  /**\n   * List of the direct children of this element.\n   *\n   * This collection can be used to add and remove elements from the document.\n   *\n   *     var item = new DivElement();\n   *     item.text = 'Something';\n   *     document.body.children.add(item) // Item is now displayed on the page.\n   *     for (var element in document.body.children) {\n   *       element.style.background = 'red'; // Turns every child of body red.\n   *     }\n   */\n  List<Element> get children => new _ChildrenElementList._wrap(this);\n\n  void set children(List<Element> value) {\n    // Copy list first since we don't want liveness during iteration.\n    List copy = new List.from(value);\n    var children = this.children;\n    children.clear();\n    children.addAll(copy);\n  }\n\n  /**\n   * Finds all descendent elements of this element that match the specified\n   * group of selectors.\n   *\n   * [selectors] should be a string using CSS selector syntax.\n   *\n   *     var items = element.querySelectorAll('.itemClassName');\n   *\n   * For details about CSS selector syntax, see the\n   * [CSS selector specification](http://www.w3.org/TR/css3-selectors/).\n   */\n  @DomName('Element.querySelectorAll')\n  ElementList querySelectorAll(String selectors) =>\n    new _FrozenElementList._wrap(_querySelectorAll(selectors));\n\n  /**\n   * Alias for [querySelector]. Note this function is deprecated because its\n   * semantics will be changing in the future.\n   */\n  @deprecated\n  @DomName('Element.querySelector')\n  @Experimental()\n  Element query(String relativeSelectors) => querySelector(relativeSelectors);\n\n  /**\n   * Alias for [querySelectorAll]. Note this function is deprecated because its\n   * semantics will be changing in the future.\n   */\n  @deprecated\n  @DomName('Element.querySelectorAll')\n  @Experimental()\n  ElementList queryAll(String relativeSelectors) =>\n      querySelectorAll(relativeSelectors);\n\n  /**\n   * The set of CSS classes applied to this element.\n   *\n   * This set makes it easy to add, remove or toggle the classes applied to\n   * this element.\n   *\n   *     element.classes.add('selected');\n   *     element.classes.toggle('isOnline');\n   *     element.classes.remove('selected');\n   */\n  CssClassSet get classes => new _ElementCssClassSet(this);\n\n  void set classes(Iterable<String> value) {\n    CssClassSet classSet = classes;\n    classSet.clear();\n    classSet.addAll(value);\n  }\n\n  /**\n   * Allows access to all custom data attributes (data-*) set on this element.\n   *\n   * The keys for the map must follow these rules:\n   *\n   * * The name must not begin with 'xml'.\n   * * The name cannot contain a semi-colon (';').\n   * * The name cannot contain any capital letters.\n   *\n   * Any keys from markup will be converted to camel-cased keys in the map.\n   *\n   * For example, HTML specified as:\n   *\n   *     <div data-my-random-value='value'></div>\n   *\n   * Would be accessed in Dart as:\n   *\n   *     var value = element.dataset['myRandomValue'];\n   *\n   * See also:\n   *\n   * * [Custom data attributes](http://www.w3.org/TR/html5/global-attributes.html#custom-data-attribute)\n   */\n  Map<String, String> get dataset =>\n    new _DataAttributeMap(attributes);\n\n  void set dataset(Map<String, String> value) {\n    final data = this.dataset;\n    data.clear();\n    for (String key in value.keys) {\n      data[key] = value[key];\n    }\n  }\n\n  /**\n   * Gets a map for manipulating the attributes of a particular namespace.\n   *\n   * This is primarily useful for SVG attributes such as xref:link.\n   */\n  Map<String, String> getNamespacedAttributes(String namespace) {\n    return new _NamespacedAttributeMap(this, namespace);\n  }\n\n  /**\n   * The set of all CSS values applied to this element, including inherited\n   * and default values.\n   *\n   * The computedStyle contains values that are inherited from other\n   * sources, such as parent elements or stylesheets. This differs from the\n   * [style] property, which contains only the values specified directly on this\n   * element.\n   *\n   * PseudoElement can be values such as `::after`, `::before`, `::marker`,\n   * `::line-marker`.\n   *\n   * See also:\n   *\n   * * [CSS Inheritance and Cascade](http://docs.webplatform.org/wiki/tutorials/inheritance_and_cascade)\n   * * [Pseudo-elements](http://docs.webplatform.org/wiki/css/selectors/pseudo-elements)\n   */\n  CssStyleDeclaration getComputedStyle([String pseudoElement]) {\n    if (pseudoElement == null) {\n      pseudoElement = '';\n    }\n    // TODO(jacobr): last param should be null, see b/5045788\n    return window._getComputedStyle(this, pseudoElement);\n  }\n\n  /**\n   * Gets the position of this element relative to the client area of the page.\n   */\n  Rectangle get client => new Rectangle(clientLeft, clientTop, clientWidth,\n      clientHeight);\n\n  /**\n   * Gets the offset of this element relative to its offsetParent.\n   */\n  Rectangle get offset => new Rectangle(offsetLeft, offsetTop, offsetWidth,\n      offsetHeight);\n\n  /**\n   * Adds the specified text after the last child of this element.\n   */\n  void appendText(String text) {\n    this.insertAdjacentText('beforeend', text);\n  }\n\n  /**\n   * Parses the specified text as HTML and adds the resulting node after the\n   * last child of this element.\n   */\n  void appendHtml(String text) {\n    this.insertAdjacentHtml('beforeend', text);\n  }\n\n  /**\n   * Checks to see if the tag name is supported by the current platform.\n   *\n   * The tag should be a valid HTML tag name.\n   */\n  static bool isTagSupported(String tag) {\n    var e = _ElementFactoryProvider.createElement_tag(tag, null);\n    return e is Element && !(e is UnknownElement);\n  }\n\n  /**\n   * Called by the DOM when this element has been inserted into the live\n   * document.\n   *\n   * More information can be found in the\n   * [Custom Elements](http://w3c.github.io/webcomponents/spec/custom/#dfn-attached-callback)\n   * draft specification.\n   */\n  @Experimental()\n  void attached() {\n    // For the deprecation period, call the old callback.\n    enteredView();\n  }\n\n  /**\n   * Called by the DOM when this element has been removed from the live\n   * document.\n   *\n   * More information can be found in the\n   * [Custom Elements](http://w3c.github.io/webcomponents/spec/custom/#dfn-detached-callback)\n   * draft specification.\n   */\n  @Experimental()\n  void detached() {\n    // For the deprecation period, call the old callback.\n    leftView();\n  }\n\n  /** *Deprecated*: override [attached] instead. */\n  @Experimental()\n  @deprecated\n  void enteredView() {}\n\n  /** *Deprecated*: override [detached] instead. */\n  @Experimental()\n  @deprecated\n  void leftView() {}\n\n  /**\n   * Called by the DOM whenever an attribute on this has been changed.\n   */\n  void attributeChanged(String name, String oldValue, String newValue) {}\n\n  // Hooks to support custom WebComponents.\n\n  @Creates('Null')  // Set from Dart code; does not instantiate a native type.\n  Element _xtag;\n\n  /**\n   * Experimental support for [web components][wc]. This field stores a\n   * reference to the component implementation. It was inspired by Mozilla's\n   * [x-tags][] project. Please note: in the future it may be possible to\n   * `extend Element` from your class, in which case this field will be\n   * deprecated.\n   *\n   * If xtag has not been set, it will simply return `this` [Element].\n   *\n   * [wc]: http://dvcs.w3.org/hg/webcomponents/raw-file/tip/explainer/index.html\n   * [x-tags]: http://x-tags.org/\n   */\n  // Note: return type is `dynamic` for convenience to suppress warnings when\n  // members of the component are used. The actual type is a subtype of Element.\n  get xtag => _xtag != null ? _xtag : this;\n\n  void set xtag(Element value) {\n    _xtag = value;\n  }\n\n  @DomName('Element.localName')\n  @DocsEditable()\n  String get localName => _localName;\n\n  /**\n   * A URI that identifies the XML namespace of this element.\n   *\n   * `null` if no namespace URI is specified.\n   *\n   * ## Other resources\n   *\n   * * [Node.namespaceURI]\n   * (http://www.w3.org/TR/DOM-Level-3-Core/core.html#ID-NodeNSname) from W3C.\n   */\n  @DomName('Element.namespaceUri')\n  String get namespaceUri => _namespaceUri;\n\n  /**\n   * The string representation of this element.\n   *\n   * This is equivalent to reading the [localName] property.\n   */\n  String toString() => localName;\n\n  /**\n   * Scrolls this element into view.\n   *\n   * Only one of of the alignment options may be specified at a time.\n   *\n   * If no options are specified then this will attempt to scroll the minimum\n   * amount needed to bring the element into view.\n   *\n   * Note that alignCenter is currently only supported on WebKit platforms. If\n   * alignCenter is specified but not supported then this will fall back to\n   * alignTop.\n   *\n   * See also:\n   *\n   * * [scrollIntoView](http://docs.webplatform.org/wiki/dom/methods/scrollIntoView)\n   * * [scrollIntoViewIfNeeded](http://docs.webplatform.org/wiki/dom/methods/scrollIntoViewIfNeeded)\n   */\n  void scrollIntoView([ScrollAlignment alignment]) {\n    var hasScrollIntoViewIfNeeded = true;\n    hasScrollIntoViewIfNeeded =\n        JS('bool', '!!(#.scrollIntoViewIfNeeded)', this);\n    if (alignment == ScrollAlignment.TOP) {\n      this._scrollIntoView(true);\n    } else if (alignment == ScrollAlignment.BOTTOM) {\n      this._scrollIntoView(false);\n    } else if (hasScrollIntoViewIfNeeded) {\n      if (alignment == ScrollAlignment.CENTER) {\n        this._scrollIntoViewIfNeeded(true);\n      } else {\n        this._scrollIntoViewIfNeeded();\n      }\n    } else {\n      this._scrollIntoView();\n    }\n  }\n\n  /**\n   * Static factory designed to expose `mousewheel` events to event\n   * handlers that are not necessarily instances of [Element].\n   *\n   * See [EventStreamProvider] for usage information.\n   */\n  @DomName('Element.mouseWheelEvent')\n  static const EventStreamProvider<WheelEvent> mouseWheelEvent =\n      const _CustomEventStreamProvider<WheelEvent>(\n        Element._determineMouseWheelEventType);\n\n  static String _determineMouseWheelEventType(EventTarget e) {\n    if (JS('bool', '#.onwheel !== undefined', e)) {\n      // W3C spec, and should be IE9+, but IE has a bug exposing onwheel.\n      return 'wheel';\n    } else if (JS('bool', '#.onmousewheel !== undefined', e)) {\n      // Chrome & IE\n      return 'mousewheel';\n    } else {\n      // Firefox\n      return 'DOMMouseScroll';\n    }\n  }\n\n  /**\n   * Static factory designed to expose `transitionend` events to event\n   * handlers that are not necessarily instances of [Element].\n   *\n   * See [EventStreamProvider] for usage information.\n   */\n  @DomName('Element.transitionEndEvent')\n  static const EventStreamProvider<TransitionEvent> transitionEndEvent =\n      const _CustomEventStreamProvider<TransitionEvent>(\n        Element._determineTransitionEventType);\n\n  static String _determineTransitionEventType(EventTarget e) {\n    // Unfortunately the normal 'ontransitionend' style checks don't work here.\n    if (Device.isWebKit) {\n      return 'webkitTransitionEnd';\n    } else if (Device.isOpera) {\n      return 'oTransitionEnd';\n    }\n    return 'transitionend';\n  }\n  /**\n   * Inserts text into the DOM at the specified location.\n   *\n   * To see the possible values for [where], read the doc for\n   * [insertAdjacentHtml].\n   *\n   * See also:\n   *\n   * * [insertAdjacentHtml]\n   */\n  void insertAdjacentText(String where, String text) {\n    if (JS('bool', '!!#.insertAdjacentText', this)) {\n      _insertAdjacentText(where, text);\n    } else {\n      _insertAdjacentNode(where, new Text(text));\n    }\n  }\n\n  @JSName('insertAdjacentText')\n  void _insertAdjacentText(String where, String text) native;\n\n  /**\n   * Parses text as an HTML fragment and inserts it into the DOM at the\n   * specified location.\n   *\n   * The [where] parameter indicates where to insert the HTML fragment:\n   *\n   * * 'beforeBegin': Immediately before this element.\n   * * 'afterBegin': As the first child of this element.\n   * * 'beforeEnd': As the last child of this element.\n   * * 'afterEnd': Immediately after this element.\n   *\n   *     var html = '<div class=\"something\">content</div>';\n   *     // Inserts as the first child\n   *     document.body.insertAdjacentHtml('afterBegin', html);\n   *     var createdElement = document.body.children[0];\n   *     print(createdElement.classes[0]); // Prints 'something'\n   *\n   * See also:\n   *\n   * * [insertAdjacentText]\n   * * [insertAdjacentElement]\n   */\n  void insertAdjacentHtml(String where, String html) {\n    if (JS('bool', '!!#.insertAdjacentHTML', this)) {\n      _insertAdjacentHtml(where, html);\n    } else {\n      _insertAdjacentNode(where, new DocumentFragment.html(html));\n    }\n  }\n\n  @JSName('insertAdjacentHTML')\n  void _insertAdjacentHtml(String where, String text) native;\n\n  /**\n   * Inserts [element] into the DOM at the specified location.\n   *\n   * To see the possible values for [where], read the doc for\n   * [insertAdjacentHtml].\n   *\n   * See also:\n   *\n   * * [insertAdjacentHtml]\n   */\n  Element insertAdjacentElement(String where, Element element) {\n    if (JS('bool', '!!#.insertAdjacentElement', this)) {\n      _insertAdjacentElement(where, element);\n    } else {\n      _insertAdjacentNode(where, element);\n    }\n    return element;\n  }\n\n  @JSName('insertAdjacentElement')\n  void _insertAdjacentElement(String where, Element element) native;\n\n  void _insertAdjacentNode(String where, Node node) {\n    switch (where.toLowerCase()) {\n      case 'beforebegin':\n        this.parentNode.insertBefore(node, this);\n        break;\n      case 'afterbegin':\n        var first = this.nodes.length > 0 ? this.nodes[0] : null;\n        this.insertBefore(node, first);\n        break;\n      case 'beforeend':\n        this.append(node);\n        break;\n      case 'afterend':\n        this.parentNode.insertBefore(node, this.nextNode);\n        break;\n      default:\n        throw new ArgumentError(\"Invalid position ${where}\");\n    }\n  }\n\n  /**\n   * Checks if this element matches the CSS selectors.\n   */\n  @Experimental()\n  bool matches(String selectors) {\n    if (JS('bool', '!!#.matches', this)) {\n      return JS('bool', '#.matches(#)', this, selectors);\n    } else if (JS('bool', '!!#.webkitMatchesSelector', this)) {\n      return JS('bool', '#.webkitMatchesSelector(#)', this, selectors);\n    } else if (JS('bool', '!!#.mozMatchesSelector', this)) {\n      return JS('bool', '#.mozMatchesSelector(#)', this, selectors);\n    } else if (JS('bool', '!!#.msMatchesSelector', this)) {\n      return JS('bool', '#.msMatchesSelector(#)', this, selectors);\n    } else if (JS('bool', '!!#.oMatchesSelector', this)) {\n      return JS('bool', '#.oMatchesSelector(#)', this, selectors);\n    } else {\n      throw new UnsupportedError(\"Not supported on this platform\");\n    }\n  }\n\n  /** Checks if this element or any of its parents match the CSS selectors. */\n  @Experimental()\n  bool matchesWithAncestors(String selectors) {\n    var elem = this;\n    do {\n      if (elem.matches(selectors)) return true;\n      elem = elem.parent;\n    } while(elem != null);\n    return false;\n  }\n\n  /**\n   * Creates a new shadow root for this shadow host.\n   *\n   * ## Other resources\n   *\n   * * [Shadow DOM 101]\n   * (http://www.html5rocks.com/en/tutorials/webcomponents/shadowdom/)\n   * from HTML5Rocks.\n   * * [Shadow DOM specification]\n   * (http://www.w3.org/TR/shadow-dom/) from W3C.\n   */\n  @DomName('Element.createShadowRoot')\n  @SupportedBrowser(SupportedBrowser.CHROME, '25')\n  @Experimental()\n  ShadowRoot createShadowRoot() {\n    return JS('ShadowRoot',\n      '(#.createShadowRoot || #.webkitCreateShadowRoot).call(#)',\n      this, this, this);\n  }\n\n  /**\n   * The shadow root of this shadow host.\n   *\n   * ## Other resources\n   *\n   * * [Shadow DOM 101]\n   * (http://www.html5rocks.com/en/tutorials/webcomponents/shadowdom/)\n   * from HTML5Rocks.\n   * * [Shadow DOM specification]\n   * (http://www.w3.org/TR/shadow-dom/) from W3C.\n   */\n  @DomName('Element.shadowRoot')\n  @SupportedBrowser(SupportedBrowser.CHROME, '25')\n  @Experimental()\n  ShadowRoot get shadowRoot =>\n      JS('ShadowRoot|Null', '#.shadowRoot || #.webkitShadowRoot', this, this);\n\n  /**\n   * Access this element's content position.\n   *\n   * This returns a rectangle with the dimenions actually available for content\n   * in this element, in pixels, regardless of this element's box-sizing\n   * property. Unlike [getBoundingClientRect], the dimensions of this rectangle\n   * will return the same numerical height if the element is hidden or not.\n   *\n   * _Important_ _note_: use of this method _will_ perform CSS calculations that\n   * can trigger a browser reflow. Therefore, use of this property _during_ an\n   * animation frame is discouraged. See also:\n   * [Browser Reflow](https://developers.google.com/speed/articles/reflow)\n   */\n  @Experimental()\n  CssRect get contentEdge => new _ContentCssRect(this);\n\n  /**\n   * Access the dimensions and position of this element's content + padding box.\n   *\n   * This returns a rectangle with the dimenions actually available for content\n   * in this element, in pixels, regardless of this element's box-sizing\n   * property. Unlike [getBoundingClientRect], the dimensions of this rectangle\n   * will return the same numerical height if the element is hidden or not. This\n   * can be used to retrieve jQuery's\n   * [innerHeight](http://api.jquery.com/innerHeight/) value for an element.\n   * This is also a rectangle equalling the dimensions of clientHeight and\n   * clientWidth.\n   *\n   * _Important_ _note_: use of this method _will_ perform CSS calculations that\n   * can trigger a browser reflow. Therefore, use of this property _during_ an\n   * animation frame is discouraged. See also:\n   * [Browser Reflow](https://developers.google.com/speed/articles/reflow)\n   */\n  @Experimental()\n  CssRect get paddingEdge => new _PaddingCssRect(this);\n\n  /**\n   * Access the dimensions and position of this element's content + padding +\n   * border box.\n   *\n   * This returns a rectangle with the dimenions actually available for content\n   * in this element, in pixels, regardless of this element's box-sizing\n   * property. Unlike [getBoundingClientRect], the dimensions of this rectangle\n   * will return the same numerical height if the element is hidden or not. This\n   * can be used to retrieve jQuery's\n   * [outerHeight](http://api.jquery.com/outerHeight/) value for an element.\n   *\n   * _Important_ _note_: use of this method _will_ perform CSS calculations that\n   * can trigger a browser reflow. Therefore, use of this property _during_ an\n   * animation frame is discouraged. See also:\n   * [Browser Reflow](https://developers.google.com/speed/articles/reflow)\n   */\n  @Experimental()\n  CssRect get borderEdge => new _BorderCssRect(this);\n\n  /**\n   * Access the dimensions and position of this element's content + padding +\n   * border + margin box.\n   *\n   * This returns a rectangle with the dimenions actually available for content\n   * in this element, in pixels, regardless of this element's box-sizing\n   * property. Unlike [getBoundingClientRect], the dimensions of this rectangle\n   * will return the same numerical height if the element is hidden or not. This\n   * can be used to retrieve jQuery's\n   * [outerHeight](http://api.jquery.com/outerHeight/) value for an element.\n   *\n   * _Important_ _note_: use of this method will perform CSS calculations that\n   * can trigger a browser reflow. Therefore, use of this property _during_ an\n   * animation frame is discouraged. See also:\n   * [Browser Reflow](https://developers.google.com/speed/articles/reflow)\n   */\n  @Experimental()\n  CssRect get marginEdge => new _MarginCssRect(this);\n\n  /**\n   * Provides the coordinates of the element relative to the top of the\n   * document.\n   *\n   * This method is the Dart equivalent to jQuery's\n   * [offset](http://api.jquery.com/offset/) method.\n   */\n  @Experimental()\n  Point get documentOffset => offsetTo(document.documentElement);\n\n  /**\n   * Provides the offset of this element's [borderEdge] relative to the\n   * specified [parent].\n   *\n   * This is the Dart equivalent of jQuery's\n   * [position](http://api.jquery.com/position/) method. Unlike jQuery's\n   * position, however, [parent] can be any parent element of `this`,\n   * rather than only `this`'s immediate [offsetParent]. If the specified\n   * element is _not_ an offset parent or transitive offset parent to this\n   * element, an [ArgumentError] is thrown.\n   */\n  @Experimental()\n  Point offsetTo(Element parent) {\n    return Element._offsetToHelper(this, parent);\n  }\n\n  static Point _offsetToHelper(Element current, Element parent) {\n    // We're hopping from _offsetParent_ to offsetParent (not just parent), so\n    // offsetParent, \"tops out\" at BODY. But people could conceivably pass in\n    // the document.documentElement and I want it to return an absolute offset,\n    // so we have the special case checking for HTML.\n    bool foundAsParent = identical(current, parent) || parent.tagName == 'HTML';\n    if (current == null || identical(current, parent)) {\n      if (foundAsParent) return new Point(0, 0);\n      throw new ArgumentError(\"Specified element is not a transitive offset \"\n          \"parent of this element.\");\n    }\n    Element parentOffset = current.offsetParent;\n    Point p = Element._offsetToHelper(parentOffset, parent);\n    return new Point(p.x + current.offsetLeft, p.y + current.offsetTop);\n  }\n\n  static HtmlDocument _parseDocument;\n  static Range _parseRange;\n  static NodeValidatorBuilder _defaultValidator;\n  static _ValidatingTreeSanitizer _defaultSanitizer;\n\n  /**\n   * Create a DocumentFragment from the HTML fragment and ensure that it follows\n   * the sanitization rules specified by the validator or treeSanitizer.\n   *\n   * If the default validation behavior is too restrictive then a new\n   * NodeValidator should be created, either extending or wrapping a default\n   * validator and overriding the validation APIs.\n   *\n   * The treeSanitizer is used to walk the generated node tree and sanitize it.\n   * A custom treeSanitizer can also be provided to perform special validation\n   * rules but since the API is more complex to implement this is discouraged.\n   *\n   * The returned tree is guaranteed to only contain nodes and attributes which\n   * are allowed by the provided validator.\n   *\n   * See also:\n   *\n   * * [NodeValidator]\n   * * [NodeTreeSanitizer]\n   */\n  DocumentFragment createFragment(String html,\n      {NodeValidator validator, NodeTreeSanitizer treeSanitizer}) {\n    if (treeSanitizer == null) {\n      if (validator == null) {\n        if (_defaultValidator == null) {\n          _defaultValidator = new NodeValidatorBuilder.common();\n        }\n        validator = _defaultValidator;\n      }\n      if (_defaultSanitizer == null) {\n        _defaultSanitizer = new _ValidatingTreeSanitizer(validator);\n      } else {\n        _defaultSanitizer.validator = validator;\n      }\n      treeSanitizer = _defaultSanitizer;\n    } else if (validator != null) {\n      throw new ArgumentError(\n          'validator can only be passed if treeSanitizer is null');\n    }\n\n    if (_parseDocument == null) {\n      _parseDocument = document.implementation.createHtmlDocument('');\n      _parseRange = _parseDocument.createRange();\n\n      // Workaround for Chrome bug 229142- URIs are not resolved in new doc.\n      var base = _parseDocument.createElement('base');\n      base.href = document.baseUri;\n      _parseDocument.head.append(base);\n    }\n    var contextElement;\n    if (this is BodyElement) {\n      contextElement = _parseDocument.body;\n    } else {\n      contextElement = _parseDocument.createElement(tagName);\n      _parseDocument.body.append(contextElement);\n    }\n    var fragment;\n    if (Range.supportsCreateContextualFragment) {\n      _parseRange.selectNodeContents(contextElement);\n      fragment = _parseRange.createContextualFragment(html);\n    } else {\n      contextElement._innerHtml = html;\n\n      fragment = _parseDocument.createDocumentFragment();\n      while (contextElement.firstChild != null) {\n        fragment.append(contextElement.firstChild);\n      }\n    }\n    if (contextElement != _parseDocument.body) {\n      contextElement.remove();\n    }\n\n    treeSanitizer.sanitizeTree(fragment);\n    // Copy the fragment over to the main document (fix for 14184)\n    document.adoptNode(fragment);\n\n    return fragment;\n  }\n\n  /**\n   * Parses the HTML fragment and sets it as the contents of this element.\n   *\n   * This uses the default sanitization behavior to sanitize the HTML fragment,\n   * use [setInnerHtml] to override the default behavior.\n   */\n  void set innerHtml(String html) {\n    this.setInnerHtml(html);\n  }\n\n  /**\n   * Parses the HTML fragment and sets it as the contents of this element.\n   * This ensures that the generated content follows the sanitization rules\n   * specified by the validator or treeSanitizer.\n   *\n   * If the default validation behavior is too restrictive then a new\n   * NodeValidator should be created, either extending or wrapping a default\n   * validator and overriding the validation APIs.\n   *\n   * The treeSanitizer is used to walk the generated node tree and sanitize it.\n   * A custom treeSanitizer can also be provided to perform special validation\n   * rules but since the API is more complex to implement this is discouraged.\n   *\n   * The resulting tree is guaranteed to only contain nodes and attributes which\n   * are allowed by the provided validator.\n   *\n   * See also:\n   *\n   * * [NodeValidator]\n   * * [NodeTreeSanitizer]\n   */\n  void setInnerHtml(String html,\n    {NodeValidator validator, NodeTreeSanitizer treeSanitizer}) {\n    text = null;\n    append(createFragment(\n        html, validator: validator, treeSanitizer: treeSanitizer));\n  }\n  String get innerHtml => _innerHtml;\n\n  /**\n   * This is an ease-of-use accessor for event streams which should only be\n   * used when an explicit accessor is not available.\n   */\n  ElementEvents get on => new ElementEvents(this);\n\n  @DomName('Element.offsetHeight')\n  @DocsEditable()\n  int get offsetHeight => JS('num', '#.offsetHeight', this).round();\n\n  @DomName('Element.offsetLeft')\n  @DocsEditable()\n  int get offsetLeft => JS('num', '#.offsetLeft', this).round();\n\n  @DomName('Element.offsetTop')\n  @DocsEditable()\n  int get offsetTop => JS('num', '#.offsetTop', this).round();\n\n  @DomName('Element.offsetWidth')\n  @DocsEditable()\n  int get offsetWidth => JS('num', '#.offsetWidth', this).round();\n\n  @DomName('Element.clientHeight')\n  @DocsEditable()\n  int get clientHeight => JS('num', '#.clientHeight', this).round();\n\n  @DomName('Element.clientLeft')\n  @DocsEditable()\n  int get clientLeft => JS('num', '#.clientLeft', this).round();\n\n  @DomName('Element.clientTop')\n  @DocsEditable()\n  int get clientTop => JS('num', '#.clientTop', this).round();\n\n  @DomName('Element.clientWidth')\n  @DocsEditable()\n  int get clientWidth => JS('num', '#.clientWidth', this).round();\n\n  @DomName('Element.scrollHeight')\n  @DocsEditable()\n  int get scrollHeight => JS('num', '#.scrollHeight', this).round();\n\n  @DomName('Element.scrollLeft')\n  @DocsEditable()\n  int get scrollLeft => JS('num', '#.scrollLeft', this).round();\n\n  @DomName('Element.scrollLeft')\n  @DocsEditable()\n  void set scrollLeft(int value) {\n    JS(\"void\", \"#.scrollLeft = #\", this, value.round());\n  }\n\n  @DomName('Element.scrollTop')\n  @DocsEditable()\n  int get scrollTop => JS('num', '#.scrollTop', this).round();\n\n  @DomName('Element.scrollTop')\n  @DocsEditable()\n  void set scrollTop(int value) {\n    JS(\"void\", \"#.scrollTop = #\", this, value.round());\n  }\n\n  @DomName('Element.scrollWidth')\n  @DocsEditable()\n  int get scrollWidth => JS('num', '#.scrollWidth', this).round();\n\n\n  // To suppress missing implicit constructor warnings.\n  factory Element._() { throw new UnsupportedError(\"Not supported\"); }\n\n  /**\n   * Static factory designed to expose `abort` events to event\n   * handlers that are not necessarily instances of [Element].\n   *\n   * See [EventStreamProvider] for usage information.\n   */\n  @DomName('Element.abortEvent')\n  @DocsEditable()\n  static const EventStreamProvider<Event> abortEvent = const EventStreamProvider<Event>('abort');\n\n  /**\n   * Static factory designed to expose `beforecopy` events to event\n   * handlers that are not necessarily instances of [Element].\n   *\n   * See [EventStreamProvider] for usage information.\n   */\n  @DomName('Element.beforecopyEvent')\n  @DocsEditable()\n  static const EventStreamProvider<Event> beforeCopyEvent = const EventStreamProvider<Event>('beforecopy');\n\n  /**\n   * Static factory designed to expose `beforecut` events to event\n   * handlers that are not necessarily instances of [Element].\n   *\n   * See [EventStreamProvider] for usage information.\n   */\n  @DomName('Element.beforecutEvent')\n  @DocsEditable()\n  static const EventStreamProvider<Event> beforeCutEvent = const EventStreamProvider<Event>('beforecut');\n\n  /**\n   * Static factory designed to expose `beforepaste` events to event\n   * handlers that are not necessarily instances of [Element].\n   *\n   * See [EventStreamProvider] for usage information.\n   */\n  @DomName('Element.beforepasteEvent')\n  @DocsEditable()\n  static const EventStreamProvider<Event> beforePasteEvent = const EventStreamProvider<Event>('beforepaste');\n\n  /**\n   * Static factory designed to expose `blur` events to event\n   * handlers that are not necessarily instances of [Element].\n   *\n   * See [EventStreamProvider] for usage information.\n   */\n  @DomName('Element.blurEvent')\n  @DocsEditable()\n  static const EventStreamProvider<Event> blurEvent = const EventStreamProvider<Event>('blur');\n\n  /**\n   * Static factory designed to expose `change` events to event\n   * handlers that are not necessarily instances of [Element].\n   *\n   * See [EventStreamProvider] for usage information.\n   */\n  @DomName('Element.changeEvent')\n  @DocsEditable()\n  static const EventStreamProvider<Event> changeEvent = const EventStreamProvider<Event>('change');\n\n  /**\n   * Static factory designed to expose `click` events to event\n   * handlers that are not necessarily instances of [Element].\n   *\n   * See [EventStreamProvider] for usage information.\n   */\n  @DomName('Element.clickEvent')\n  @DocsEditable()\n  static const EventStreamProvider<MouseEvent> clickEvent = const EventStreamProvider<MouseEvent>('click');\n\n  /**\n   * Static factory designed to expose `contextmenu` events to event\n   * handlers that are not necessarily instances of [Element].\n   *\n   * See [EventStreamProvider] for usage information.\n   */\n  @DomName('Element.contextmenuEvent')\n  @DocsEditable()\n  static const EventStreamProvider<MouseEvent> contextMenuEvent = const EventStreamProvider<MouseEvent>('contextmenu');\n\n  /**\n   * Static factory designed to expose `copy` events to event\n   * handlers that are not necessarily instances of [Element].\n   *\n   * See [EventStreamProvider] for usage information.\n   */\n  @DomName('Element.copyEvent')\n  @DocsEditable()\n  static const EventStreamProvider<Event> copyEvent = const EventStreamProvider<Event>('copy');\n\n  /**\n   * Static factory designed to expose `cut` events to event\n   * handlers that are not necessarily instances of [Element].\n   *\n   * See [EventStreamProvider] for usage information.\n   */\n  @DomName('Element.cutEvent')\n  @DocsEditable()\n  static const EventStreamProvider<Event> cutEvent = const EventStreamProvider<Event>('cut');\n\n  /**\n   * Static factory designed to expose `doubleclick` events to event\n   * handlers that are not necessarily instances of [Element].\n   *\n   * See [EventStreamProvider] for usage information.\n   */\n  @DomName('Element.dblclickEvent')\n  @DocsEditable()\n  static const EventStreamProvider<Event> doubleClickEvent = const EventStreamProvider<Event>('dblclick');\n\n  /**\n   * A stream of `drag` events fired when an element is currently being dragged.\n   *\n   * A `drag` event is added to this stream as soon as the drag begins.\n   * A `drag` event is also added to this stream at intervals while the drag\n   * operation is still ongoing.\n   *\n   * ## Other resources\n   *\n   * * [Drag and drop sample]\n   * (https://github.com/dart-lang/dart-samples/tree/master/web/html5/dnd/basics)\n   * based on [the tutorial](http://www.html5rocks.com/en/tutorials/dnd/basics/)\n   * from HTML5Rocks.\n   * * [Drag and drop specification]\n   * (http://www.whatwg.org/specs/web-apps/current-work/multipage/dnd.html#dnd)\n   * from WHATWG.\n   */\n  @DomName('Element.dragEvent')\n  @DocsEditable()\n  static const EventStreamProvider<MouseEvent> dragEvent = const EventStreamProvider<MouseEvent>('drag');\n\n  /**\n   * A stream of `dragend` events fired when an element completes a drag\n   * operation.\n   *\n   * ## Other resources\n   *\n   * * [Drag and drop sample]\n   * (https://github.com/dart-lang/dart-samples/tree/master/web/html5/dnd/basics)\n   * based on [the tutorial](http://www.html5rocks.com/en/tutorials/dnd/basics/)\n   * from HTML5Rocks.\n   * * [Drag and drop specification]\n   * (http://www.whatwg.org/specs/web-apps/current-work/multipage/dnd.html#dnd)\n   * from WHATWG.\n   */\n  @DomName('Element.dragendEvent')\n  @DocsEditable()\n  static const EventStreamProvider<MouseEvent> dragEndEvent = const EventStreamProvider<MouseEvent>('dragend');\n\n  /**\n   * A stream of `dragenter` events fired when a dragged object is first dragged\n   * over an element.\n   *\n   * ## Other resources\n   *\n   * * [Drag and drop sample]\n   * (https://github.com/dart-lang/dart-samples/tree/master/web/html5/dnd/basics)\n   * based on [the tutorial](http://www.html5rocks.com/en/tutorials/dnd/basics/)\n   * from HTML5Rocks.\n   * * [Drag and drop specification]\n   * (http://www.whatwg.org/specs/web-apps/current-work/multipage/dnd.html#dnd)\n   * from WHATWG.\n   */\n  @DomName('Element.dragenterEvent')\n  @DocsEditable()\n  static const EventStreamProvider<MouseEvent> dragEnterEvent = const EventStreamProvider<MouseEvent>('dragenter');\n\n  /**\n   * A stream of `dragleave` events fired when an object being dragged over an\n   * element leaves the element's target area.\n   *\n   * ## Other resources\n   *\n   * * [Drag and drop sample]\n   * (https://github.com/dart-lang/dart-samples/tree/master/web/html5/dnd/basics)\n   * based on [the tutorial](http://www.html5rocks.com/en/tutorials/dnd/basics/)\n   * from HTML5Rocks.\n   * * [Drag and drop specification]\n   * (http://www.whatwg.org/specs/web-apps/current-work/multipage/dnd.html#dnd)\n   * from WHATWG.\n   */\n  @DomName('Element.dragleaveEvent')\n  @DocsEditable()\n  static const EventStreamProvider<MouseEvent> dragLeaveEvent = const EventStreamProvider<MouseEvent>('dragleave');\n\n  /**\n   * A stream of `dragover` events fired when a dragged object is currently\n   * being dragged over an element.\n   *\n   * ## Other resources\n   *\n   * * [Drag and drop sample]\n   * (https://github.com/dart-lang/dart-samples/tree/master/web/html5/dnd/basics)\n   * based on [the tutorial](http://www.html5rocks.com/en/tutorials/dnd/basics/)\n   * from HTML5Rocks.\n   * * [Drag and drop specification]\n   * (http://www.whatwg.org/specs/web-apps/current-work/multipage/dnd.html#dnd)\n   * from WHATWG.\n   */\n  @DomName('Element.dragoverEvent')\n  @DocsEditable()\n  static const EventStreamProvider<MouseEvent> dragOverEvent = const EventStreamProvider<MouseEvent>('dragover');\n\n  /**\n   * A stream of `dragstart` events for a dragged element whose drag has begun.\n   *\n   * ## Other resources\n   *\n   * * [Drag and drop sample]\n   * (https://github.com/dart-lang/dart-samples/tree/master/web/html5/dnd/basics)\n   * based on [the tutorial](http://www.html5rocks.com/en/tutorials/dnd/basics/)\n   * from HTML5Rocks.\n   * * [Drag and drop specification]\n   * (http://www.whatwg.org/specs/web-apps/current-work/multipage/dnd.html#dnd)\n   * from WHATWG.\n   */\n  @DomName('Element.dragstartEvent')\n  @DocsEditable()\n  static const EventStreamProvider<MouseEvent> dragStartEvent = const EventStreamProvider<MouseEvent>('dragstart');\n\n  /**\n   * A stream of `drop` events fired when a dragged object is dropped on an\n   * element.\n   *\n   * ## Other resources\n   *\n   * * [Drag and drop sample]\n   * (https://github.com/dart-lang/dart-samples/tree/master/web/html5/dnd/basics)\n   * based on [the tutorial](http://www.html5rocks.com/en/tutorials/dnd/basics/)\n   * from HTML5Rocks.\n   * * [Drag and drop specification]\n   * (http://www.whatwg.org/specs/web-apps/current-work/multipage/dnd.html#dnd)\n   * from WHATWG.\n   */\n  @DomName('Element.dropEvent')\n  @DocsEditable()\n  static const EventStreamProvider<MouseEvent> dropEvent = const EventStreamProvider<MouseEvent>('drop');\n\n  /**\n   * Static factory designed to expose `error` events to event\n   * handlers that are not necessarily instances of [Element].\n   *\n   * See [EventStreamProvider] for usage information.\n   */\n  @DomName('Element.errorEvent')\n  @DocsEditable()\n  static const EventStreamProvider<Event> errorEvent = const EventStreamProvider<Event>('error');\n\n  /**\n   * Static factory designed to expose `focus` events to event\n   * handlers that are not necessarily instances of [Element].\n   *\n   * See [EventStreamProvider] for usage information.\n   */\n  @DomName('Element.focusEvent')\n  @DocsEditable()\n  static const EventStreamProvider<Event> focusEvent = const EventStreamProvider<Event>('focus');\n\n  /**\n   * Static factory designed to expose `input` events to event\n   * handlers that are not necessarily instances of [Element].\n   *\n   * See [EventStreamProvider] for usage information.\n   */\n  @DomName('Element.inputEvent')\n  @DocsEditable()\n  static const EventStreamProvider<Event> inputEvent = const EventStreamProvider<Event>('input');\n\n  /**\n   * Static factory designed to expose `invalid` events to event\n   * handlers that are not necessarily instances of [Element].\n   *\n   * See [EventStreamProvider] for usage information.\n   */\n  @DomName('Element.invalidEvent')\n  @DocsEditable()\n  static const EventStreamProvider<Event> invalidEvent = const EventStreamProvider<Event>('invalid');\n\n  /**\n   * Static factory designed to expose `keydown` events to event\n   * handlers that are not necessarily instances of [Element].\n   *\n   * See [EventStreamProvider] for usage information.\n   */\n  @DomName('Element.keydownEvent')\n  @DocsEditable()\n  static const EventStreamProvider<KeyboardEvent> keyDownEvent = const EventStreamProvider<KeyboardEvent>('keydown');\n\n  /**\n   * Static factory designed to expose `keypress` events to event\n   * handlers that are not necessarily instances of [Element].\n   *\n   * See [EventStreamProvider] for usage information.\n   */\n  @DomName('Element.keypressEvent')\n  @DocsEditable()\n  static const EventStreamProvider<KeyboardEvent> keyPressEvent = const EventStreamProvider<KeyboardEvent>('keypress');\n\n  /**\n   * Static factory designed to expose `keyup` events to event\n   * handlers that are not necessarily instances of [Element].\n   *\n   * See [EventStreamProvider] for usage information.\n   */\n  @DomName('Element.keyupEvent')\n  @DocsEditable()\n  static const EventStreamProvider<KeyboardEvent> keyUpEvent = const EventStreamProvider<KeyboardEvent>('keyup');\n\n  /**\n   * Static factory designed to expose `load` events to event\n   * handlers that are not necessarily instances of [Element].\n   *\n   * See [EventStreamProvider] for usage information.\n   */\n  @DomName('Element.loadEvent')\n  @DocsEditable()\n  static const EventStreamProvider<Event> loadEvent = const EventStreamProvider<Event>('load');\n\n  /**\n   * Static factory designed to expose `mousedown` events to event\n   * handlers that are not necessarily instances of [Element].\n   *\n   * See [EventStreamProvider] for usage information.\n   */\n  @DomName('Element.mousedownEvent')\n  @DocsEditable()\n  static const EventStreamProvider<MouseEvent> mouseDownEvent = const EventStreamProvider<MouseEvent>('mousedown');\n\n  /**\n   * Static factory designed to expose `mouseenter` events to event\n   * handlers that are not necessarily instances of [Element].\n   *\n   * See [EventStreamProvider] for usage information.\n   */\n  @DomName('Element.mouseenterEvent')\n  @DocsEditable()\n  @Experimental() // untriaged\n  static const EventStreamProvider<MouseEvent> mouseEnterEvent = const EventStreamProvider<MouseEvent>('mouseenter');\n\n  /**\n   * Static factory designed to expose `mouseleave` events to event\n   * handlers that are not necessarily instances of [Element].\n   *\n   * See [EventStreamProvider] for usage information.\n   */\n  @DomName('Element.mouseleaveEvent')\n  @DocsEditable()\n  @Experimental() // untriaged\n  static const EventStreamProvider<MouseEvent> mouseLeaveEvent = const EventStreamProvider<MouseEvent>('mouseleave');\n\n  /**\n   * Static factory designed to expose `mousemove` events to event\n   * handlers that are not necessarily instances of [Element].\n   *\n   * See [EventStreamProvider] for usage information.\n   */\n  @DomName('Element.mousemoveEvent')\n  @DocsEditable()\n  static const EventStreamProvider<MouseEvent> mouseMoveEvent = const EventStreamProvider<MouseEvent>('mousemove');\n\n  /**\n   * Static factory designed to expose `mouseout` events to event\n   * handlers that are not necessarily instances of [Element].\n   *\n   * See [EventStreamProvider] for usage information.\n   */\n  @DomName('Element.mouseoutEvent')\n  @DocsEditable()\n  static const EventStreamProvider<MouseEvent> mouseOutEvent = const EventStreamProvider<MouseEvent>('mouseout');\n\n  /**\n   * Static factory designed to expose `mouseover` events to event\n   * handlers that are not necessarily instances of [Element].\n   *\n   * See [EventStreamProvider] for usage information.\n   */\n  @DomName('Element.mouseoverEvent')\n  @DocsEditable()\n  static const EventStreamProvider<MouseEvent> mouseOverEvent = const EventStreamProvider<MouseEvent>('mouseover');\n\n  /**\n   * Static factory designed to expose `mouseup` events to event\n   * handlers that are not necessarily instances of [Element].\n   *\n   * See [EventStreamProvider] for usage information.\n   */\n  @DomName('Element.mouseupEvent')\n  @DocsEditable()\n  static const EventStreamProvider<MouseEvent> mouseUpEvent = const EventStreamProvider<MouseEvent>('mouseup');\n\n  /**\n   * Static factory designed to expose `paste` events to event\n   * handlers that are not necessarily instances of [Element].\n   *\n   * See [EventStreamProvider] for usage information.\n   */\n  @DomName('Element.pasteEvent')\n  @DocsEditable()\n  static const EventStreamProvider<Event> pasteEvent = const EventStreamProvider<Event>('paste');\n\n  /**\n   * Static factory designed to expose `reset` events to event\n   * handlers that are not necessarily instances of [Element].\n   *\n   * See [EventStreamProvider] for usage information.\n   */\n  @DomName('Element.resetEvent')\n  @DocsEditable()\n  static const EventStreamProvider<Event> resetEvent = const EventStreamProvider<Event>('reset');\n\n  @DomName('Element.resizeEvent')\n  @DocsEditable()\n  @Experimental() // untriaged\n  static const EventStreamProvider<Event> resizeEvent = const EventStreamProvider<Event>('resize');\n\n  /**\n   * Static factory designed to expose `scroll` events to event\n   * handlers that are not necessarily instances of [Element].\n   *\n   * See [EventStreamProvider] for usage information.\n   */\n  @DomName('Element.scrollEvent')\n  @DocsEditable()\n  static const EventStreamProvider<Event> scrollEvent = const EventStreamProvider<Event>('scroll');\n\n  /**\n   * Static factory designed to expose `search` events to event\n   * handlers that are not necessarily instances of [Element].\n   *\n   * See [EventStreamProvider] for usage information.\n   */\n  @DomName('Element.searchEvent')\n  @DocsEditable()\n  // http://www.w3.org/TR/html-markup/input.search.html\n  @Experimental()\n  static const EventStreamProvider<Event> searchEvent = const EventStreamProvider<Event>('search');\n\n  /**\n   * Static factory designed to expose `select` events to event\n   * handlers that are not necessarily instances of [Element].\n   *\n   * See [EventStreamProvider] for usage information.\n   */\n  @DomName('Element.selectEvent')\n  @DocsEditable()\n  static const EventStreamProvider<Event> selectEvent = const EventStreamProvider<Event>('select');\n\n  /**\n   * Static factory designed to expose `selectstart` events to event\n   * handlers that are not necessarily instances of [Element].\n   *\n   * See [EventStreamProvider] for usage information.\n   */\n  @DomName('Element.selectstartEvent')\n  @DocsEditable()\n  @Experimental() // nonstandard\n  static const EventStreamProvider<Event> selectStartEvent = const EventStreamProvider<Event>('selectstart');\n\n  /**\n   * Static factory designed to expose `submit` events to event\n   * handlers that are not necessarily instances of [Element].\n   *\n   * See [EventStreamProvider] for usage information.\n   */\n  @DomName('Element.submitEvent')\n  @DocsEditable()\n  static const EventStreamProvider<Event> submitEvent = const EventStreamProvider<Event>('submit');\n\n  /**\n   * Static factory designed to expose `touchcancel` events to event\n   * handlers that are not necessarily instances of [Element].\n   *\n   * See [EventStreamProvider] for usage information.\n   */\n  @DomName('Element.touchcancelEvent')\n  @DocsEditable()\n  // http://www.w3.org/TR/touch-events/, http://www.chromestatus.com/features\n  @Experimental()\n  static const EventStreamProvider<TouchEvent> touchCancelEvent = const EventStreamProvider<TouchEvent>('touchcancel');\n\n  /**\n   * Static factory designed to expose `touchend` events to event\n   * handlers that are not necessarily instances of [Element].\n   *\n   * See [EventStreamProvider] for usage information.\n   */\n  @DomName('Element.touchendEvent')\n  @DocsEditable()\n  // http://www.w3.org/TR/touch-events/, http://www.chromestatus.com/features\n  @Experimental()\n  static const EventStreamProvider<TouchEvent> touchEndEvent = const EventStreamProvider<TouchEvent>('touchend');\n\n  /**\n   * Static factory designed to expose `touchenter` events to event\n   * handlers that are not necessarily instances of [Element].\n   *\n   * See [EventStreamProvider] for usage information.\n   */\n  @DomName('Element.touchenterEvent')\n  @DocsEditable()\n  // http://www.w3.org/TR/touch-events/, http://www.chromestatus.com/features\n  @Experimental()\n  static const EventStreamProvider<TouchEvent> touchEnterEvent = const EventStreamProvider<TouchEvent>('touchenter');\n\n  /**\n   * Static factory designed to expose `touchleave` events to event\n   * handlers that are not necessarily instances of [Element].\n   *\n   * See [EventStreamProvider] for usage information.\n   */\n  @DomName('Element.touchleaveEvent')\n  @DocsEditable()\n  // http://www.w3.org/TR/touch-events/, http://www.chromestatus.com/features\n  @Experimental()\n  static const EventStreamProvider<TouchEvent> touchLeaveEvent = const EventStreamProvider<TouchEvent>('touchleave');\n\n  /**\n   * Static factory designed to expose `touchmove` events to event\n   * handlers that are not necessarily instances of [Element].\n   *\n   * See [EventStreamProvider] for usage information.\n   */\n  @DomName('Element.touchmoveEvent')\n  @DocsEditable()\n  // http://www.w3.org/TR/touch-events/, http://www.chromestatus.com/features\n  @Experimental()\n  static const EventStreamProvider<TouchEvent> touchMoveEvent = const EventStreamProvider<TouchEvent>('touchmove');\n\n  /**\n   * Static factory designed to expose `touchstart` events to event\n   * handlers that are not necessarily instances of [Element].\n   *\n   * See [EventStreamProvider] for usage information.\n   */\n  @DomName('Element.touchstartEvent')\n  @DocsEditable()\n  // http://www.w3.org/TR/touch-events/, http://www.chromestatus.com/features\n  @Experimental()\n  static const EventStreamProvider<TouchEvent> touchStartEvent = const EventStreamProvider<TouchEvent>('touchstart');\n\n  /**\n   * Static factory designed to expose `fullscreenchange` events to event\n   * handlers that are not necessarily instances of [Element].\n   *\n   * See [EventStreamProvider] for usage information.\n   */\n  @DomName('Element.webkitfullscreenchangeEvent')\n  @DocsEditable()\n  @SupportedBrowser(SupportedBrowser.CHROME)\n  @SupportedBrowser(SupportedBrowser.SAFARI)\n  @Experimental()\n  // https://dvcs.w3.org/hg/fullscreen/raw-file/tip/Overview.html\n  static const EventStreamProvider<Event> fullscreenChangeEvent = const EventStreamProvider<Event>('webkitfullscreenchange');\n\n  /**\n   * Static factory designed to expose `fullscreenerror` events to event\n   * handlers that are not necessarily instances of [Element].\n   *\n   * See [EventStreamProvider] for usage information.\n   */\n  @DomName('Element.webkitfullscreenerrorEvent')\n  @DocsEditable()\n  @SupportedBrowser(SupportedBrowser.CHROME)\n  @SupportedBrowser(SupportedBrowser.SAFARI)\n  @Experimental()\n  // https://dvcs.w3.org/hg/fullscreen/raw-file/tip/Overview.html\n  static const EventStreamProvider<Event> fullscreenErrorEvent = const EventStreamProvider<Event>('webkitfullscreenerror');\n\n  @DomName('Element.contentEditable')\n  @DocsEditable()\n  String contentEditable;\n\n  @DomName('Element.dir')\n  @DocsEditable()\n  String dir;\n\n  /**\n   * Indicates whether the element can be dragged and dropped.\n   *\n   * ## Other resources\n   *\n   * * [Drag and drop sample]\n   * (https://github.com/dart-lang/dart-samples/tree/master/web/html5/dnd/basics)\n   * based on [the tutorial](http://www.html5rocks.com/en/tutorials/dnd/basics/)\n   * from HTML5Rocks.\n   * * [Drag and drop specification]\n   * (http://www.whatwg.org/specs/web-apps/current-work/multipage/dnd.html#dnd)\n   * from WHATWG.\n   */\n  @DomName('Element.draggable')\n  @DocsEditable()\n  bool draggable;\n\n  /**\n   * Indicates whether the element is not relevant to the page's current state.\n   *\n   * ## Other resources\n   *\n   * * [Hidden attribute specification]\n   * (http://www.whatwg.org/specs/web-apps/current-work/multipage/editing.html#the-hidden-attribute)\n   * from WHATWG.\n   */\n  @DomName('Element.hidden')\n  @DocsEditable()\n  bool hidden;\n\n  @DomName('Element.isContentEditable')\n  @DocsEditable()\n  final bool isContentEditable;\n\n  @DomName('Element.lang')\n  @DocsEditable()\n  String lang;\n\n  @DomName('Element.spellcheck')\n  @DocsEditable()\n  // http://blog.whatwg.org/the-road-to-html-5-spellchecking\n  @Experimental() // nonstandard\n  bool spellcheck;\n\n  @DomName('Element.tabIndex')\n  @DocsEditable()\n  int tabIndex;\n\n  @DomName('Element.title')\n  @DocsEditable()\n  String title;\n\n  /**\n   * Specifies whether this element's text content changes when the page is\n   * localized.\n   *\n   * ## Other resources\n   *\n   * * [The translate attribute]\n   * (http://www.whatwg.org/specs/web-apps/current-work/multipage/elements.html#the-translate-attribute)\n   * from WHATWG.\n   */\n  @DomName('Element.translate')\n  @DocsEditable()\n  // http://www.whatwg.org/specs/web-apps/current-work/multipage/elements.html#the-translate-attribute\n  @Experimental()\n  bool translate;\n\n  @JSName('webkitdropzone')\n  /**\n   * A set of space-separated keywords that specify what kind of data this\n   * Element accepts on drop and what to do with that data.\n   *\n   * ## Other resources\n   *\n   * * [Drag and drop sample]\n   * (https://github.com/dart-lang/dart-samples/tree/master/web/html5/dnd/basics)\n   * based on [the tutorial](http://www.html5rocks.com/en/tutorials/dnd/basics/)\n   * from HTML5Rocks.\n   * * [Drag and drop specification]\n   * (http://www.whatwg.org/specs/web-apps/current-work/multipage/dnd.html#dnd)\n   * from WHATWG.\n   */\n  @DomName('Element.webkitdropzone')\n  @DocsEditable()\n  @SupportedBrowser(SupportedBrowser.CHROME)\n  @SupportedBrowser(SupportedBrowser.SAFARI)\n  @Experimental()\n  // http://www.whatwg.org/specs/web-apps/current-work/multipage/dnd.html#the-dropzone-attribute\n  String dropzone;\n\n  @DomName('Element.click')\n  @DocsEditable()\n  void click() native;\n\n  @JSName('attributes')\n  @DomName('Element.attributes')\n  @DocsEditable()\n  final _NamedNodeMap _attributes;\n\n  @DomName('Element.className')\n  @DocsEditable()\n  String className;\n\n  @JSName('clientHeight')\n  @DomName('Element.clientHeight')\n  @DocsEditable()\n  final int _clientHeight;\n\n  @JSName('clientLeft')\n  @DomName('Element.clientLeft')\n  @DocsEditable()\n  final int _clientLeft;\n\n  @JSName('clientTop')\n  @DomName('Element.clientTop')\n  @DocsEditable()\n  final int _clientTop;\n\n  @JSName('clientWidth')\n  @DomName('Element.clientWidth')\n  @DocsEditable()\n  final int _clientWidth;\n\n  @DomName('Element.id')\n  @DocsEditable()\n  String id;\n\n  @JSName('innerHTML')\n  @DomName('Element.innerHTML')\n  @DocsEditable()\n  String _innerHtml;\n\n  // Use implementation from Node.\n  // final String _localName;\n\n  // Use implementation from Node.\n  // final String _namespaceUri;\n\n  @JSName('offsetHeight')\n  @DomName('Element.offsetHeight')\n  @DocsEditable()\n  final int _offsetHeight;\n\n  @JSName('offsetLeft')\n  @DomName('Element.offsetLeft')\n  @DocsEditable()\n  final int _offsetLeft;\n\n  @DomName('Element.offsetParent')\n  @DocsEditable()\n  final Element offsetParent;\n\n  @JSName('offsetTop')\n  @DomName('Element.offsetTop')\n  @DocsEditable()\n  final int _offsetTop;\n\n  @JSName('offsetWidth')\n  @DomName('Element.offsetWidth')\n  @DocsEditable()\n  final int _offsetWidth;\n\n  @JSName('outerHTML')\n  @DomName('Element.outerHTML')\n  @DocsEditable()\n  final String outerHtml;\n\n  @JSName('scrollHeight')\n  @DomName('Element.scrollHeight')\n  @DocsEditable()\n  final int _scrollHeight;\n\n  @JSName('scrollLeft')\n  @DomName('Element.scrollLeft')\n  @DocsEditable()\n  int _scrollLeft;\n\n  @JSName('scrollTop')\n  @DomName('Element.scrollTop')\n  @DocsEditable()\n  int _scrollTop;\n\n  @JSName('scrollWidth')\n  @DomName('Element.scrollWidth')\n  @DocsEditable()\n  final int _scrollWidth;\n\n  @DomName('Element.style')\n  @DocsEditable()\n  final CssStyleDeclaration style;\n\n  @DomName('Element.tagName')\n  @DocsEditable()\n  final String tagName;\n\n  @DomName('Element.animate')\n  @DocsEditable()\n  @Experimental() // untriaged\n  Animation animate(List<Map> keyframes, [timingInput]) {\n    if ((timingInput is Map || timingInput == null)) {\n      var timingInput_1 = convertDartToNative_Dictionary(timingInput);\n      return _animate_1(keyframes, timingInput_1);\n    }\n    if ((timingInput is num || timingInput == null)) {\n      return _animate_2(keyframes, timingInput);\n    }\n    if (timingInput == null) {\n      return _animate_3(keyframes);\n    }\n    throw new ArgumentError(\"Incorrect number or type of arguments\");\n  }\n  @JSName('animate')\n  @DomName('Element.animate')\n  @DocsEditable()\n  @Experimental() // untriaged\n  Animation _animate_1(List<Map> keyframes, timingInput) native;\n  @JSName('animate')\n  @DomName('Element.animate')\n  @DocsEditable()\n  @Experimental() // untriaged\n  Animation _animate_2(List<Map> keyframes, num timingInput) native;\n  @JSName('animate')\n  @DomName('Element.animate')\n  @DocsEditable()\n  @Experimental() // untriaged\n  Animation _animate_3(List<Map> keyframes) native;\n\n  @DomName('Element.blur')\n  @DocsEditable()\n  void blur() native;\n\n  @DomName('Element.focus')\n  @DocsEditable()\n  void focus() native;\n\n  @DomName('Element.getAttribute')\n  @DocsEditable()\n  @Experimental() // untriaged\n  String getAttribute(String name) native;\n\n  @DomName('Element.getAttributeNS')\n  @DocsEditable()\n  @Experimental() // untriaged\n  String getAttributeNS(String namespaceURI, String localName) native;\n\n  /**\n   * Returns the smallest bounding rectangle that encompasses this element's\n   * padding, scrollbar, and border.\n   *\n   * ## Other resources\n   *\n   * * [Element.getBoundingClientRect]\n   * (https://developer.mozilla.org/en-US/docs/Web/API/Element.getBoundingClientRect)\n   * from MDN.\n   * * [The getBoundingClientRect() method]\n   * (http://www.w3.org/TR/cssom-view/#the-getclientrects-and-getboundingclientrect-methods)\n   * from W3C.\n   */\n  @DomName('Element.getBoundingClientRect')\n  @DocsEditable()\n  Rectangle getBoundingClientRect() native;\n\n  /**\n   * Returns a list of bounding rectangles for each box associated with this\n   * element.\n   *\n   * ## Other resources\n   *\n   * * [Element.getClientRects]\n   * (https://developer.mozilla.org/en-US/docs/Web/API/Element.getClientRects)\n   * from MDN.\n   * * [The getClientRects() method]\n   * (http://www.w3.org/TR/cssom-view/#the-getclientrects-and-getboundingclientrect-methods)\n   * from W3C.\n   */\n  @DomName('Element.getClientRects')\n  @DocsEditable()\n  @Returns('_ClientRectList')\n  @Creates('_ClientRectList')\n  List<Rectangle> getClientRects() native;\n\n  /**\n   * Returns a list of shadow DOM insertion points to which this element is\n   * distributed.\n   *\n   * ## Other resources\n   *\n   * * [Shadow DOM specification]\n   * (https://dvcs.w3.org/hg/webcomponents/raw-file/tip/spec/shadow/index.html)\n   * from W3C.\n   */\n  @DomName('Element.getDestinationInsertionPoints')\n  @DocsEditable()\n  @Experimental() // untriaged\n  @Returns('NodeList')\n  @Creates('NodeList')\n  List<Node> getDestinationInsertionPoints() native;\n\n  /**\n   * Returns a list of nodes with the given class name inside this element.\n   *\n   * ## Other resources\n   *\n   * * [getElementsByClassName]\n   * (https://developer.mozilla.org/en-US/docs/Web/API/document.getElementsByClassName)\n   * from MDN.\n   * * [DOM specification]\n   * (http://www.w3.org/TR/domcore/) from W3C.\n   */\n  @DomName('Element.getElementsByClassName')\n  @DocsEditable()\n  @Creates('NodeList|HtmlCollection')\n  @Returns('NodeList|HtmlCollection')\n  List<Node> getElementsByClassName(String classNames) native;\n\n  @JSName('getElementsByTagName')\n  @DomName('Element.getElementsByTagName')\n  @DocsEditable()\n  @Creates('NodeList|HtmlCollection')\n  @Returns('NodeList|HtmlCollection')\n  List<Node> _getElementsByTagName(String name) native;\n\n  @JSName('hasAttribute')\n  @DomName('Element.hasAttribute')\n  @DocsEditable()\n  bool _hasAttribute(String name) native;\n\n  @JSName('hasAttributeNS')\n  @DomName('Element.hasAttributeNS')\n  @DocsEditable()\n  bool _hasAttributeNS(String namespaceURI, String localName) native;\n\n  /**\n   * Finds the first descendant element of this element that matches the\n   * specified group of selectors.\n   *\n   * [selectors] should be a string using CSS selector syntax.\n   *\n   *     // Gets the first descendant with the class 'classname'\n   *     var element = element.querySelector('.className');\n   *     // Gets the element with id 'id'\n   *     var element = element.querySelector('#id');\n   *     // Gets the first descendant [ImageElement]\n   *     var img = element.querySelector('img');\n   *\n   * For details about CSS selector syntax, see the\n   * [CSS selector specification](http://www.w3.org/TR/css3-selectors/).\n   */\n  @DomName('Element.querySelector')\n  @DocsEditable()\n  Element querySelector(String selectors) native;\n\n  @JSName('querySelectorAll')\n  @DomName('Element.querySelectorAll')\n  @DocsEditable()\n  @Returns('NodeList')\n  @Creates('NodeList')\n  List<Node> _querySelectorAll(String selectors) native;\n\n  @JSName('removeAttribute')\n  @DomName('Element.removeAttribute')\n  @DocsEditable()\n  void _removeAttribute(String name) native;\n\n  @JSName('removeAttributeNS')\n  @DomName('Element.removeAttributeNS')\n  @DocsEditable()\n  void _removeAttributeNS(String namespaceURI, String localName) native;\n\n  /**\n   * Scrolls the element by a number of lines.\n   *\n   * ## Other resources\n   *\n   * * [scrollByLines]\n   * (http://docs.webplatform.org/wiki/dom/methods/scrollByLines) from WebPlatform.org.\n   */\n  @DomName('Element.scrollByLines')\n  @DocsEditable()\n  void scrollByLines(int lines) native;\n\n  /**\n   * Scrolls the element by a number of pages.\n   *\n   * ## Other resources\n   *\n   * * [scrollByPages]\n   * (http://docs.webplatform.org/wiki/dom/methods/scrollByPages) from WebPlatform.org.\n   */\n  @DomName('Element.scrollByPages')\n  @DocsEditable()\n  void scrollByPages(int pages) native;\n\n  @JSName('scrollIntoView')\n  @DomName('Element.scrollIntoView')\n  @DocsEditable()\n  void _scrollIntoView([bool alignWithTop]) native;\n\n  @JSName('scrollIntoViewIfNeeded')\n  @DomName('Element.scrollIntoViewIfNeeded')\n  @DocsEditable()\n  // http://docs.webplatform.org/wiki/dom/methods/scrollIntoViewIfNeeded\n  @Experimental() // non-standard\n  void _scrollIntoViewIfNeeded([bool centerIfNeeded]) native;\n\n  @DomName('Element.setAttribute')\n  @DocsEditable()\n  void setAttribute(String name, String value) native;\n\n  @DomName('Element.setAttributeNS')\n  @DocsEditable()\n  void setAttributeNS(String namespaceURI, String qualifiedName, String value) native;\n\n  @JSName('webkitRequestFullscreen')\n  /**\n   * Displays this element fullscreen.\n   *\n   * ## Other resources\n   *\n   * * [Using the fullscreen API]\n   * (http://docs.webplatform.org/wiki/tutorials/using_the_full-screen_api)\n   * tutorial from WebPlatform.org.\n   * * [Fullscreen specification]\n   * (http://www.w3.org/TR/fullscreen/) from W3C.\n   */\n  @DomName('Element.webkitRequestFullscreen')\n  @DocsEditable()\n  @SupportedBrowser(SupportedBrowser.CHROME)\n  @SupportedBrowser(SupportedBrowser.SAFARI)\n  @Experimental()\n  // https://dvcs.w3.org/hg/fullscreen/raw-file/tip/Overview.html#dom-element-requestfullscreen\n  void requestFullscreen() native;\n\n  @JSName('webkitRequestPointerLock')\n  /**\n   * Locks the mouse pointer to this element.\n   *\n   * ## Other resources\n   *\n   * * [Pointer lock and first person shooter controls]\n   * (http://www.html5rocks.com/en/tutorials/pointerlock/intro/) tutorial from\n   * HTML5Rocks.\n   *\n   * * [Pointer lock specification]\n   * (http://www.w3.org/TR/pointerlock/) from W3C.\n   */\n  @DomName('Element.webkitRequestPointerLock')\n  @DocsEditable()\n  @SupportedBrowser(SupportedBrowser.CHROME)\n  @SupportedBrowser(SupportedBrowser.SAFARI)\n  @Experimental()\n  // https://dvcs.w3.org/hg/pointerlock/raw-file/default/index.html#widl-Element-requestPointerLock-void\n  void requestPointerLock() native;\n\n  // From ChildNode\n\n  @DomName('Element.nextElementSibling')\n  @DocsEditable()\n  final Element nextElementSibling;\n\n  @DomName('Element.previousElementSibling')\n  @DocsEditable()\n  final Element previousElementSibling;\n\n  // From ParentNode\n\n  @JSName('childElementCount')\n  @DomName('Element.childElementCount')\n  @DocsEditable()\n  final int _childElementCount;\n\n  @JSName('children')\n  @DomName('Element.children')\n  @DocsEditable()\n  @Returns('HtmlCollection')\n  @Creates('HtmlCollection')\n  final List<Node> _children;\n\n  @JSName('firstElementChild')\n  @DomName('Element.firstElementChild')\n  @DocsEditable()\n  final Element _firstElementChild;\n\n  @JSName('lastElementChild')\n  @DomName('Element.lastElementChild')\n  @DocsEditable()\n  final Element _lastElementChild;\n\n  /// Stream of `abort` events handled by this [Element].\n  @DomName('Element.onabort')\n  @DocsEditable()\n  ElementStream<Event> get onAbort => abortEvent.forElement(this);\n\n  /// Stream of `beforecopy` events handled by this [Element].\n  @DomName('Element.onbeforecopy')\n  @DocsEditable()\n  ElementStream<Event> get onBeforeCopy => beforeCopyEvent.forElement(this);\n\n  /// Stream of `beforecut` events handled by this [Element].\n  @DomName('Element.onbeforecut')\n  @DocsEditable()\n  ElementStream<Event> get onBeforeCut => beforeCutEvent.forElement(this);\n\n  /// Stream of `beforepaste` events handled by this [Element].\n  @DomName('Element.onbeforepaste')\n  @DocsEditable()\n  ElementStream<Event> get onBeforePaste => beforePasteEvent.forElement(this);\n\n  /// Stream of `blur` events handled by this [Element].\n  @DomName('Element.onblur')\n  @DocsEditable()\n  ElementStream<Event> get onBlur => blurEvent.forElement(this);\n\n  /// Stream of `change` events handled by this [Element].\n  @DomName('Element.onchange')\n  @DocsEditable()\n  ElementStream<Event> get onChange => changeEvent.forElement(this);\n\n  /// Stream of `click` events handled by this [Element].\n  @DomName('Element.onclick')\n  @DocsEditable()\n  ElementStream<MouseEvent> get onClick => clickEvent.forElement(this);\n\n  /// Stream of `contextmenu` events handled by this [Element].\n  @DomName('Element.oncontextmenu')\n  @DocsEditable()\n  ElementStream<MouseEvent> get onContextMenu => contextMenuEvent.forElement(this);\n\n  /// Stream of `copy` events handled by this [Element].\n  @DomName('Element.oncopy')\n  @DocsEditable()\n  ElementStream<Event> get onCopy => copyEvent.forElement(this);\n\n  /// Stream of `cut` events handled by this [Element].\n  @DomName('Element.oncut')\n  @DocsEditable()\n  ElementStream<Event> get onCut => cutEvent.forElement(this);\n\n  /// Stream of `doubleclick` events handled by this [Element].\n  @DomName('Element.ondblclick')\n  @DocsEditable()\n  ElementStream<Event> get onDoubleClick => doubleClickEvent.forElement(this);\n\n  /**\n   * A stream of `drag` events fired when this element currently being dragged.\n   *\n   * A `drag` event is added to this stream as soon as the drag begins.\n   * A `drag` event is also added to this stream at intervals while the drag\n   * operation is still ongoing.\n   *\n   * ## Other resources\n   *\n   * * [Drag and drop sample]\n   * (https://github.com/dart-lang/dart-samples/tree/master/web/html5/dnd/basics)\n   * based on [the tutorial](http://www.html5rocks.com/en/tutorials/dnd/basics/)\n   * from HTML5Rocks.\n   * * [Drag and drop specification]\n   * (http://www.whatwg.org/specs/web-apps/current-work/multipage/dnd.html#dnd)\n   * from WHATWG.\n   */\n  @DomName('Element.ondrag')\n  @DocsEditable()\n  ElementStream<MouseEvent> get onDrag => dragEvent.forElement(this);\n\n  /**\n   * A stream of `dragend` events fired when this element completes a drag\n   * operation.\n   *\n   * ## Other resources\n   *\n   * * [Drag and drop sample]\n   * (https://github.com/dart-lang/dart-samples/tree/master/web/html5/dnd/basics)\n   * based on [the tutorial](http://www.html5rocks.com/en/tutorials/dnd/basics/)\n   * from HTML5Rocks.\n   * * [Drag and drop specification]\n   * (http://www.whatwg.org/specs/web-apps/current-work/multipage/dnd.html#dnd)\n   * from WHATWG.\n   */\n  @DomName('Element.ondragend')\n  @DocsEditable()\n  ElementStream<MouseEvent> get onDragEnd => dragEndEvent.forElement(this);\n\n  /**\n   * A stream of `dragenter` events fired when a dragged object is first dragged\n   * over this element.\n   *\n   * ## Other resources\n   *\n   * * [Drag and drop sample]\n   * (https://github.com/dart-lang/dart-samples/tree/master/web/html5/dnd/basics)\n   * based on [the tutorial](http://www.html5rocks.com/en/tutorials/dnd/basics/)\n   * from HTML5Rocks.\n   * * [Drag and drop specification]\n   * (http://www.whatwg.org/specs/web-apps/current-work/multipage/dnd.html#dnd)\n   * from WHATWG.\n   */\n  @DomName('Element.ondragenter')\n  @DocsEditable()\n  ElementStream<MouseEvent> get onDragEnter => dragEnterEvent.forElement(this);\n\n  /**\n   * A stream of `dragleave` events fired when an object being dragged over this\n   * element leaves this element's target area.\n   *\n   * ## Other resources\n   *\n   * * [Drag and drop sample]\n   * (https://github.com/dart-lang/dart-samples/tree/master/web/html5/dnd/basics)\n   * based on [the tutorial](http://www.html5rocks.com/en/tutorials/dnd/basics/)\n   * from HTML5Rocks.\n   * * [Drag and drop specification]\n   * (http://www.whatwg.org/specs/web-apps/current-work/multipage/dnd.html#dnd)\n   * from WHATWG.\n   */\n  @DomName('Element.ondragleave')\n  @DocsEditable()\n  ElementStream<MouseEvent> get onDragLeave => dragLeaveEvent.forElement(this);\n\n  /**\n   * A stream of `dragover` events fired when a dragged object is currently\n   * being dragged over this element.\n   *\n   * ## Other resources\n   *\n   * * [Drag and drop sample]\n   * (https://github.com/dart-lang/dart-samples/tree/master/web/html5/dnd/basics)\n   * based on [the tutorial](http://www.html5rocks.com/en/tutorials/dnd/basics/)\n   * from HTML5Rocks.\n   * * [Drag and drop specification]\n   * (http://www.whatwg.org/specs/web-apps/current-work/multipage/dnd.html#dnd)\n   * from WHATWG.\n   */\n  @DomName('Element.ondragover')\n  @DocsEditable()\n  ElementStream<MouseEvent> get onDragOver => dragOverEvent.forElement(this);\n\n  /**\n   * A stream of `dragstart` events fired when this element starts being\n   * dragged.\n   *\n   * ## Other resources\n   *\n   * * [Drag and drop sample]\n   * (https://github.com/dart-lang/dart-samples/tree/master/web/html5/dnd/basics)\n   * based on [the tutorial](http://www.html5rocks.com/en/tutorials/dnd/basics/)\n   * from HTML5Rocks.\n   * * [Drag and drop specification]\n   * (http://www.whatwg.org/specs/web-apps/current-work/multipage/dnd.html#dnd)\n   * from WHATWG.\n   */\n  @DomName('Element.ondragstart')\n  @DocsEditable()\n  ElementStream<MouseEvent> get onDragStart => dragStartEvent.forElement(this);\n\n  /**\n   * A stream of `drop` events fired when a dragged object is dropped on this\n   * element.\n   *\n   * ## Other resources\n   *\n   * * [Drag and drop sample]\n   * (https://github.com/dart-lang/dart-samples/tree/master/web/html5/dnd/basics)\n   * based on [the tutorial](http://www.html5rocks.com/en/tutorials/dnd/basics/)\n   * from HTML5Rocks.\n   * * [Drag and drop specification]\n   * (http://www.whatwg.org/specs/web-apps/current-work/multipage/dnd.html#dnd)\n   * from WHATWG.\n   */\n  @DomName('Element.ondrop')\n  @DocsEditable()\n  ElementStream<MouseEvent> get onDrop => dropEvent.forElement(this);\n\n  /// Stream of `error` events handled by this [Element].\n  @DomName('Element.onerror')\n  @DocsEditable()\n  ElementStream<Event> get onError => errorEvent.forElement(this);\n\n  /// Stream of `focus` events handled by this [Element].\n  @DomName('Element.onfocus')\n  @DocsEditable()\n  ElementStream<Event> get onFocus => focusEvent.forElement(this);\n\n  /// Stream of `input` events handled by this [Element].\n  @DomName('Element.oninput')\n  @DocsEditable()\n  ElementStream<Event> get onInput => inputEvent.forElement(this);\n\n  /// Stream of `invalid` events handled by this [Element].\n  @DomName('Element.oninvalid')\n  @DocsEditable()\n  ElementStream<Event> get onInvalid => invalidEvent.forElement(this);\n\n  /// Stream of `keydown` events handled by this [Element].\n  @DomName('Element.onkeydown')\n  @DocsEditable()\n  ElementStream<KeyboardEvent> get onKeyDown => keyDownEvent.forElement(this);\n\n  /// Stream of `keypress` events handled by this [Element].\n  @DomName('Element.onkeypress')\n  @DocsEditable()\n  ElementStream<KeyboardEvent> get onKeyPress => keyPressEvent.forElement(this);\n\n  /// Stream of `keyup` events handled by this [Element].\n  @DomName('Element.onkeyup')\n  @DocsEditable()\n  ElementStream<KeyboardEvent> get onKeyUp => keyUpEvent.forElement(this);\n\n  /// Stream of `load` events handled by this [Element].\n  @DomName('Element.onload')\n  @DocsEditable()\n  ElementStream<Event> get onLoad => loadEvent.forElement(this);\n\n  /// Stream of `mousedown` events handled by this [Element].\n  @DomName('Element.onmousedown')\n  @DocsEditable()\n  ElementStream<MouseEvent> get onMouseDown => mouseDownEvent.forElement(this);\n\n  /// Stream of `mouseenter` events handled by this [Element].\n  @DomName('Element.onmouseenter')\n  @DocsEditable()\n  @Experimental() // untriaged\n  ElementStream<MouseEvent> get onMouseEnter => mouseEnterEvent.forElement(this);\n\n  /// Stream of `mouseleave` events handled by this [Element].\n  @DomName('Element.onmouseleave')\n  @DocsEditable()\n  @Experimental() // untriaged\n  ElementStream<MouseEvent> get onMouseLeave => mouseLeaveEvent.forElement(this);\n\n  /// Stream of `mousemove` events handled by this [Element].\n  @DomName('Element.onmousemove')\n  @DocsEditable()\n  ElementStream<MouseEvent> get onMouseMove => mouseMoveEvent.forElement(this);\n\n  /// Stream of `mouseout` events handled by this [Element].\n  @DomName('Element.onmouseout')\n  @DocsEditable()\n  ElementStream<MouseEvent> get onMouseOut => mouseOutEvent.forElement(this);\n\n  /// Stream of `mouseover` events handled by this [Element].\n  @DomName('Element.onmouseover')\n  @DocsEditable()\n  ElementStream<MouseEvent> get onMouseOver => mouseOverEvent.forElement(this);\n\n  /// Stream of `mouseup` events handled by this [Element].\n  @DomName('Element.onmouseup')\n  @DocsEditable()\n  ElementStream<MouseEvent> get onMouseUp => mouseUpEvent.forElement(this);\n\n  /// Stream of `mousewheel` events handled by this [Element].\n  @DomName('Element.onmousewheel')\n  @DocsEditable()\n  // http://www.w3.org/TR/DOM-Level-3-Events/#events-wheelevents\n  @Experimental() // non-standard\n  ElementStream<WheelEvent> get onMouseWheel => mouseWheelEvent.forElement(this);\n\n  /// Stream of `paste` events handled by this [Element].\n  @DomName('Element.onpaste')\n  @DocsEditable()\n  ElementStream<Event> get onPaste => pasteEvent.forElement(this);\n\n  /// Stream of `reset` events handled by this [Element].\n  @DomName('Element.onreset')\n  @DocsEditable()\n  ElementStream<Event> get onReset => resetEvent.forElement(this);\n\n  @DomName('Element.onresize')\n  @DocsEditable()\n  @Experimental() // untriaged\n  ElementStream<Event> get onResize => resizeEvent.forElement(this);\n\n  /// Stream of `scroll` events handled by this [Element].\n  @DomName('Element.onscroll')\n  @DocsEditable()\n  ElementStream<Event> get onScroll => scrollEvent.forElement(this);\n\n  /// Stream of `search` events handled by this [Element].\n  @DomName('Element.onsearch')\n  @DocsEditable()\n  // http://www.w3.org/TR/html-markup/input.search.html\n  @Experimental()\n  ElementStream<Event> get onSearch => searchEvent.forElement(this);\n\n  /// Stream of `select` events handled by this [Element].\n  @DomName('Element.onselect')\n  @DocsEditable()\n  ElementStream<Event> get onSelect => selectEvent.forElement(this);\n\n  /// Stream of `selectstart` events handled by this [Element].\n  @DomName('Element.onselectstart')\n  @DocsEditable()\n  @Experimental() // nonstandard\n  ElementStream<Event> get onSelectStart => selectStartEvent.forElement(this);\n\n  /// Stream of `submit` events handled by this [Element].\n  @DomName('Element.onsubmit')\n  @DocsEditable()\n  ElementStream<Event> get onSubmit => submitEvent.forElement(this);\n\n  /// Stream of `touchcancel` events handled by this [Element].\n  @DomName('Element.ontouchcancel')\n  @DocsEditable()\n  // http://www.w3.org/TR/touch-events/, http://www.chromestatus.com/features\n  @Experimental()\n  ElementStream<TouchEvent> get onTouchCancel => touchCancelEvent.forElement(this);\n\n  /// Stream of `touchend` events handled by this [Element].\n  @DomName('Element.ontouchend')\n  @DocsEditable()\n  // http://www.w3.org/TR/touch-events/, http://www.chromestatus.com/features\n  @Experimental()\n  ElementStream<TouchEvent> get onTouchEnd => touchEndEvent.forElement(this);\n\n  /// Stream of `touchenter` events handled by this [Element].\n  @DomName('Element.ontouchenter')\n  @DocsEditable()\n  // http://www.w3.org/TR/touch-events/, http://www.chromestatus.com/features\n  @Experimental()\n  ElementStream<TouchEvent> get onTouchEnter => touchEnterEvent.forElement(this);\n\n  /// Stream of `touchleave` events handled by this [Element].\n  @DomName('Element.ontouchleave')\n  @DocsEditable()\n  // http://www.w3.org/TR/touch-events/, http://www.chromestatus.com/features\n  @Experimental()\n  ElementStream<TouchEvent> get onTouchLeave => touchLeaveEvent.forElement(this);\n\n  /// Stream of `touchmove` events handled by this [Element].\n  @DomName('Element.ontouchmove')\n  @DocsEditable()\n  // http://www.w3.org/TR/touch-events/, http://www.chromestatus.com/features\n  @Experimental()\n  ElementStream<TouchEvent> get onTouchMove => touchMoveEvent.forElement(this);\n\n  /// Stream of `touchstart` events handled by this [Element].\n  @DomName('Element.ontouchstart')\n  @DocsEditable()\n  // http://www.w3.org/TR/touch-events/, http://www.chromestatus.com/features\n  @Experimental()\n  ElementStream<TouchEvent> get onTouchStart => touchStartEvent.forElement(this);\n\n  /// Stream of `transitionend` events handled by this [Element].\n  @DomName('Element.ontransitionend')\n  @DocsEditable()\n  @SupportedBrowser(SupportedBrowser.CHROME)\n  @SupportedBrowser(SupportedBrowser.FIREFOX)\n  @SupportedBrowser(SupportedBrowser.IE, '10')\n  @SupportedBrowser(SupportedBrowser.SAFARI)\n  ElementStream<TransitionEvent> get onTransitionEnd => transitionEndEvent.forElement(this);\n\n  /// Stream of `fullscreenchange` events handled by this [Element].\n  @DomName('Element.onwebkitfullscreenchange')\n  @DocsEditable()\n  // https://dvcs.w3.org/hg/fullscreen/raw-file/tip/Overview.html\n  @Experimental()\n  ElementStream<Event> get onFullscreenChange => fullscreenChangeEvent.forElement(this);\n\n  /// Stream of `fullscreenerror` events handled by this [Element].\n  @DomName('Element.onwebkitfullscreenerror')\n  @DocsEditable()\n  // https://dvcs.w3.org/hg/fullscreen/raw-file/tip/Overview.html\n  @Experimental()\n  ElementStream<Event> get onFullscreenError => fullscreenErrorEvent.forElement(this);\n\n}\n\n\nclass _ElementFactoryProvider {\n\n  @DomName('Document.createElement')\n  // Optimization to improve performance until the dart2js compiler inlines this\n  // method.\n  static dynamic createElement_tag(String tag, String typeExtension) {\n    // Firefox may return a JS function for some types (Embed, Object).\n    if (typeExtension != null) {\n      return JS('Element|=Object', 'document.createElement(#, #)',\n          tag, typeExtension);\n    }\n    // Should be able to eliminate this and just call the two-arg version above\n    // with null typeExtension, but Chrome treats the tag as case-sensitive if\n    // typeExtension is null.\n    // https://code.google.com/p/chromium/issues/detail?id=282467\n    return JS('Element|=Object', 'document.createElement(#)', tag);\n  }\n\n}\n\n\n/**\n * Options for Element.scrollIntoView.\n */\nclass ScrollAlignment {\n  final _value;\n  const ScrollAlignment._internal(this._value);\n  toString() => 'ScrollAlignment.$_value';\n\n  /// Attempt to align the element to the top of the scrollable area.\n  static const TOP = const ScrollAlignment._internal('TOP');\n  /// Attempt to center the element in the scrollable area.\n  static const CENTER = const ScrollAlignment._internal('CENTER');\n  /// Attempt to align the element to the bottom of the scrollable area.\n  static const BOTTOM = const ScrollAlignment._internal('BOTTOM');\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('HTMLEmbedElement')\n@SupportedBrowser(SupportedBrowser.CHROME)\n@SupportedBrowser(SupportedBrowser.IE)\n@SupportedBrowser(SupportedBrowser.SAFARI)\n@Unstable()\n@Native(\"HTMLEmbedElement\")\nclass EmbedElement extends HtmlElement {\n  // To suppress missing implicit constructor warnings.\n  factory EmbedElement._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('HTMLEmbedElement.HTMLEmbedElement')\n  @DocsEditable()\n  factory EmbedElement() => document.createElement(\"embed\");\n  /**\n   * Constructor instantiated by the DOM when a custom element has been created.\n   *\n   * This can only be called by subclasses from their created constructor.\n   */\n  EmbedElement.created() : super.created();\n\n  /// Checks if this type is supported on the current platform.\n  static bool get supported => Element.isTagSupported('embed');\n\n  @DomName('HTMLEmbedElement.height')\n  @DocsEditable()\n  String height;\n\n  @DomName('HTMLEmbedElement.name')\n  @DocsEditable()\n  String name;\n\n  @DomName('HTMLEmbedElement.src')\n  @DocsEditable()\n  String src;\n\n  @DomName('HTMLEmbedElement.type')\n  @DocsEditable()\n  String type;\n\n  @DomName('HTMLEmbedElement.width')\n  @DocsEditable()\n  String width;\n\n  @DomName('HTMLEmbedElement.__getter__')\n  @DocsEditable()\n  bool __getter__(index_OR_name) native;\n\n  @DomName('HTMLEmbedElement.__setter__')\n  @DocsEditable()\n  void __setter__(index_OR_name, Node value) native;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n// WARNING: Do not edit - generated code.\n\n\n@DomName('EntriesCallback')\n// http://www.w3.org/TR/file-system-api/#the-entriescallback-interface\n@Experimental()\ntypedef void _EntriesCallback(List<Entry> entries);\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('Entry')\n// http://www.w3.org/TR/file-system-api/#the-entry-interface\n@Experimental()\n@Native(\"Entry\")\nclass Entry extends Interceptor {\n  // To suppress missing implicit constructor warnings.\n  factory Entry._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('Entry.filesystem')\n  @DocsEditable()\n  final FileSystem filesystem;\n\n  @DomName('Entry.fullPath')\n  @DocsEditable()\n  final String fullPath;\n\n  @DomName('Entry.isDirectory')\n  @DocsEditable()\n  final bool isDirectory;\n\n  @DomName('Entry.isFile')\n  @DocsEditable()\n  final bool isFile;\n\n  @DomName('Entry.name')\n  @DocsEditable()\n  final String name;\n\n  @JSName('copyTo')\n  @DomName('Entry.copyTo')\n  @DocsEditable()\n  void _copyTo(DirectoryEntry parent, {String name, _EntryCallback successCallback, _ErrorCallback errorCallback}) native;\n\n  @JSName('copyTo')\n  @DomName('Entry.copyTo')\n  @DocsEditable()\n  Future<Entry> copyTo(DirectoryEntry parent, {String name}) {\n    var completer = new Completer<Entry>();\n    _copyTo(parent, name : name,\n        successCallback : (value) { completer.complete(value); },\n        errorCallback : (error) { completer.completeError(error); });\n    return completer.future;\n  }\n\n  @JSName('getMetadata')\n  @DomName('Entry.getMetadata')\n  @DocsEditable()\n  void _getMetadata(MetadataCallback successCallback, [_ErrorCallback errorCallback]) native;\n\n  @JSName('getMetadata')\n  @DomName('Entry.getMetadata')\n  @DocsEditable()\n  Future<Metadata> getMetadata() {\n    var completer = new Completer<Metadata>();\n    _getMetadata(\n        (value) { completer.complete(value); },\n        (error) { completer.completeError(error); });\n    return completer.future;\n  }\n\n  @JSName('getParent')\n  @DomName('Entry.getParent')\n  @DocsEditable()\n  void _getParent([_EntryCallback successCallback, _ErrorCallback errorCallback]) native;\n\n  @JSName('getParent')\n  @DomName('Entry.getParent')\n  @DocsEditable()\n  Future<Entry> getParent() {\n    var completer = new Completer<Entry>();\n    _getParent(\n        (value) { completer.complete(value); },\n        (error) { completer.completeError(error); });\n    return completer.future;\n  }\n\n  @JSName('moveTo')\n  @DomName('Entry.moveTo')\n  @DocsEditable()\n  void _moveTo(DirectoryEntry parent, {String name, _EntryCallback successCallback, _ErrorCallback errorCallback}) native;\n\n  @JSName('moveTo')\n  @DomName('Entry.moveTo')\n  @DocsEditable()\n  Future<Entry> moveTo(DirectoryEntry parent, {String name}) {\n    var completer = new Completer<Entry>();\n    _moveTo(parent, name : name,\n        successCallback : (value) { completer.complete(value); },\n        errorCallback : (error) { completer.completeError(error); });\n    return completer.future;\n  }\n\n  @JSName('remove')\n  @DomName('Entry.remove')\n  @DocsEditable()\n  void _remove(VoidCallback successCallback, [_ErrorCallback errorCallback]) native;\n\n  @JSName('remove')\n  @DomName('Entry.remove')\n  @DocsEditable()\n  Future remove() {\n    var completer = new Completer();\n    _remove(\n        () { completer.complete(); },\n        (error) { completer.completeError(error); });\n    return completer.future;\n  }\n\n  @JSName('toURL')\n  @DomName('Entry.toURL')\n  @DocsEditable()\n  String toUrl() native;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n// WARNING: Do not edit - generated code.\n\n\n@DomName('EntryCallback')\n// http://www.w3.org/TR/file-system-api/#the-entrycallback-interface\n@Experimental()\ntypedef void _EntryCallback(Entry entry);\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n// WARNING: Do not edit - generated code.\n\n\n@DomName('ErrorCallback')\n// http://www.w3.org/TR/file-system-api/#the-errorcallback-interface\n@Experimental()\ntypedef void _ErrorCallback(FileError error);\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('ErrorEvent')\n@Unstable()\n@Native(\"ErrorEvent\")\nclass ErrorEvent extends Event {\n  // To suppress missing implicit constructor warnings.\n  factory ErrorEvent._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('ErrorEvent.colno')\n  @DocsEditable()\n  @Experimental() // untriaged\n  final int colno;\n\n  @DomName('ErrorEvent.error')\n  @DocsEditable()\n  @Experimental() // untriaged\n  @Creates('Null')\n  final Object error;\n\n  @DomName('ErrorEvent.filename')\n  @DocsEditable()\n  final String filename;\n\n  @DomName('ErrorEvent.lineno')\n  @DocsEditable()\n  final int lineno;\n\n  @DomName('ErrorEvent.message')\n  @DocsEditable()\n  final String message;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n// WARNING: Do not edit - generated code.\n\n\n@DomName('Event')\n@Native(\"Event,InputEvent,ClipboardEvent\")\nclass Event extends Interceptor {\n  // In JS, canBubble and cancelable are technically required parameters to\n  // init*Event. In practice, though, if they aren't provided they simply\n  // default to false (since that's Boolean(undefined)).\n  //\n  // Contrary to JS, we default canBubble and cancelable to true, since that's\n  // what people want most of the time anyway.\n  factory Event(String type,\n      {bool canBubble: true, bool cancelable: true}) {\n    return new Event.eventType('Event', type, canBubble: canBubble,\n        cancelable: cancelable);\n  }\n\n  /**\n   * Creates a new Event object of the specified type.\n   *\n   * This is analogous to document.createEvent.\n   * Normally events should be created via their constructors, if available.\n   *\n   *     var e = new Event.type('MouseEvent', 'mousedown', true, true);\n   */\n  factory Event.eventType(String type, String name, {bool canBubble: true,\n      bool cancelable: true}) {\n    final Event e = document._createEvent(type);\n    e._initEvent(name, canBubble, cancelable);\n    return e;\n  }\n  \n  /** The CSS selector involved with event delegation. */\n  String _selector;\n\n  /**\n   * A pointer to the element whose CSS selector matched within which an event\n   * was fired. If this Event was not associated with any Event delegation,\n   * accessing this value will throw an [UnsupportedError].\n   */\n  Element get matchingTarget {\n    if (_selector == null) {\n      throw new UnsupportedError('Cannot call matchingTarget if this Event did'\n          ' not arise as a result of event delegation.');\n    }\n    var currentTarget = this.currentTarget;\n    var target = this.target;\n    var matchedTarget;\n    do {\n      if (target.matches(_selector)) return target;\n      target = target.parent;\n    } while (target != null && target != currentTarget.parent);\n    throw new StateError('No selector matched for populating matchedTarget.');\n  }\n  // To suppress missing implicit constructor warnings.\n  factory Event._() { throw new UnsupportedError(\"Not supported\"); }\n\n  /**\n   * This event is being handled by the event target.\n   *\n   * ## Other resources\n   *\n   * * [Target phase] (http://www.w3.org/TR/DOM-Level-3-Events/#target-phase)\n   * from W3C.\n   */\n  @DomName('Event.AT_TARGET')\n  @DocsEditable()\n  static const int AT_TARGET = 2;\n\n  /**\n   * This event is bubbling up through the target's ancestors.\n   *\n   * ## Other resources\n   *\n   * * [Bubble phase] (http://www.w3.org/TR/DOM-Level-3-Events/#bubble-phase)\n   * from W3C.\n   */\n  @DomName('Event.BUBBLING_PHASE')\n  @DocsEditable()\n  static const int BUBBLING_PHASE = 3;\n\n  /**\n   * This event is propagating through the target's ancestors, starting from the\n   * document.\n   *\n   * ## Other resources\n   *\n   * * [Bubble phase] (http://www.w3.org/TR/DOM-Level-3-Events/#bubble-phase)\n   * from W3C.\n   */\n  @DomName('Event.CAPTURING_PHASE')\n  @DocsEditable()\n  static const int CAPTURING_PHASE = 1;\n\n  @DomName('Event.bubbles')\n  @DocsEditable()\n  final bool bubbles;\n\n  @DomName('Event.cancelable')\n  @DocsEditable()\n  final bool cancelable;\n\n  /**\n   * Access to the system's clipboard data during copy, cut, and paste events.\n   *\n   * ## Other resources\n   *\n   * * [clipboardData specification]\n   * (http://www.w3.org/TR/clipboard-apis/#attributes) from W3C.\n   */\n  @DomName('Event.clipboardData')\n  @DocsEditable()\n  @SupportedBrowser(SupportedBrowser.CHROME)\n  @SupportedBrowser(SupportedBrowser.FIREFOX)\n  @SupportedBrowser(SupportedBrowser.SAFARI)\n  @Experimental()\n  // Part of copy/paste\n  @Experimental() // nonstandard\n  final DataTransfer clipboardData;\n\n  @DomName('Event.currentTarget')\n  @DocsEditable()\n  EventTarget get currentTarget => _convertNativeToDart_EventTarget(this._get_currentTarget);\n  @JSName('currentTarget')\n  @DomName('Event.currentTarget')\n  @DocsEditable()\n  @Creates('Null')\n  @Returns('EventTarget|=Object')\n  final dynamic _get_currentTarget;\n\n  @DomName('Event.defaultPrevented')\n  @DocsEditable()\n  final bool defaultPrevented;\n\n  @DomName('Event.eventPhase')\n  @DocsEditable()\n  final int eventPhase;\n\n  /**\n   * This event's path, taking into account shadow DOM.\n   *\n   * ## Other resources\n   *\n   * * [Shadow DOM extensions to Event]\n   * (http://w3c.github.io/webcomponents/spec/shadow/#extensions-to-event) from\n   * W3C.\n   */\n  @DomName('Event.path')\n  @DocsEditable()\n  // https://dvcs.w3.org/hg/webcomponents/raw-file/tip/spec/shadow/index.html#extensions-to-event\n  @Experimental()\n  @Returns('NodeList')\n  @Creates('NodeList')\n  final List<Node> path;\n\n  @DomName('Event.target')\n  @DocsEditable()\n  EventTarget get target => _convertNativeToDart_EventTarget(this._get_target);\n  @JSName('target')\n  @DomName('Event.target')\n  @DocsEditable()\n  @Creates('Node')\n  @Returns('EventTarget|=Object')\n  final dynamic _get_target;\n\n  @DomName('Event.timeStamp')\n  @DocsEditable()\n  final int timeStamp;\n\n  @DomName('Event.type')\n  @DocsEditable()\n  final String type;\n\n  @JSName('initEvent')\n  @DomName('Event.initEvent')\n  @DocsEditable()\n  void _initEvent(String eventTypeArg, bool canBubbleArg, bool cancelableArg) native;\n\n  @DomName('Event.preventDefault')\n  @DocsEditable()\n  void preventDefault() native;\n\n  @DomName('Event.stopImmediatePropagation')\n  @DocsEditable()\n  void stopImmediatePropagation() native;\n\n  @DomName('Event.stopPropagation')\n  @DocsEditable()\n  void stopPropagation() native;\n\n}\n// Copyright (c) 2013, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DomName('EventSource')\n// http://www.w3.org/TR/eventsource/#the-eventsource-interface\n@Experimental() // stable\n@Native(\"EventSource\")\nclass EventSource extends EventTarget {\n  factory EventSource(String title, {withCredentials: false}) {\n    var parsedOptions = {\n      'withCredentials': withCredentials,\n    };\n    return EventSource._factoryEventSource(title, parsedOptions);\n  }\n  // To suppress missing implicit constructor warnings.\n  factory EventSource._() { throw new UnsupportedError(\"Not supported\"); }\n\n  /**\n   * Static factory designed to expose `error` events to event\n   * handlers that are not necessarily instances of [EventSource].\n   *\n   * See [EventStreamProvider] for usage information.\n   */\n  @DomName('EventSource.errorEvent')\n  @DocsEditable()\n  static const EventStreamProvider<Event> errorEvent = const EventStreamProvider<Event>('error');\n\n  /**\n   * Static factory designed to expose `message` events to event\n   * handlers that are not necessarily instances of [EventSource].\n   *\n   * See [EventStreamProvider] for usage information.\n   */\n  @DomName('EventSource.messageEvent')\n  @DocsEditable()\n  static const EventStreamProvider<MessageEvent> messageEvent = const EventStreamProvider<MessageEvent>('message');\n\n  /**\n   * Static factory designed to expose `open` events to event\n   * handlers that are not necessarily instances of [EventSource].\n   *\n   * See [EventStreamProvider] for usage information.\n   */\n  @DomName('EventSource.openEvent')\n  @DocsEditable()\n  static const EventStreamProvider<Event> openEvent = const EventStreamProvider<Event>('open');\n\n  @DomName('EventSource.EventSource')\n  @DocsEditable()\n  static EventSource _factoryEventSource(String url, [Map eventSourceInit]) {\n    if (eventSourceInit != null) {\n      return EventSource._create_1(url, eventSourceInit);\n    }\n    return EventSource._create_2(url);\n  }\n  static EventSource _create_1(url, eventSourceInit) => JS('EventSource', 'new EventSource(#,#)', url, eventSourceInit);\n  static EventSource _create_2(url) => JS('EventSource', 'new EventSource(#)', url);\n\n  @DomName('EventSource.CLOSED')\n  @DocsEditable()\n  static const int CLOSED = 2;\n\n  @DomName('EventSource.CONNECTING')\n  @DocsEditable()\n  static const int CONNECTING = 0;\n\n  @DomName('EventSource.OPEN')\n  @DocsEditable()\n  static const int OPEN = 1;\n\n  @DomName('EventSource.readyState')\n  @DocsEditable()\n  final int readyState;\n\n  @DomName('EventSource.url')\n  @DocsEditable()\n  final String url;\n\n  @DomName('EventSource.withCredentials')\n  @DocsEditable()\n  final bool withCredentials;\n\n  @DomName('EventSource.close')\n  @DocsEditable()\n  void close() native;\n\n  /// Stream of `error` events handled by this [EventSource].\n  @DomName('EventSource.onerror')\n  @DocsEditable()\n  Stream<Event> get onError => errorEvent.forTarget(this);\n\n  /// Stream of `message` events handled by this [EventSource].\n  @DomName('EventSource.onmessage')\n  @DocsEditable()\n  Stream<MessageEvent> get onMessage => messageEvent.forTarget(this);\n\n  /// Stream of `open` events handled by this [EventSource].\n  @DomName('EventSource.onopen')\n  @DocsEditable()\n  Stream<Event> get onOpen => openEvent.forTarget(this);\n\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n/**\n * Base class that supports listening for and dispatching browser events.\n *\n * Normally events are accessed via the Stream getter:\n *\n *     element.onMouseOver.listen((e) => print('Mouse over!'));\n *\n * To access bubbling events which are declared on one element, but may bubble\n * up to another element type (common for MediaElement events):\n *\n *     MediaElement.pauseEvent.forTarget(document.body).listen(...);\n *\n * To useCapture on events:\n *\n *     Element.keyDownEvent.forTarget(element, useCapture: true).listen(...);\n *\n * Custom events can be declared as:\n *\n *     class DataGenerator {\n *       static EventStreamProvider<Event> dataEvent =\n *           new EventStreamProvider('data');\n *     }\n *\n * Then listeners should access the event with:\n *\n *     DataGenerator.dataEvent.forTarget(element).listen(...);\n *\n * Custom events can also be accessed as:\n *\n *     element.on['some_event'].listen(...);\n *\n * This approach is generally discouraged as it loses the event typing and\n * some DOM events may have multiple platform-dependent event names under the\n * covers. By using the standard Stream getters you will get the platform\n * specific event name automatically.\n */\nclass Events {\n  /* Raw event target. */\n  final EventTarget _ptr;\n\n  Events(this._ptr);\n\n  Stream operator [](String type) {\n    return new _EventStream(_ptr, type, false);\n  }\n}\n\nclass ElementEvents extends Events {\n  /* Raw event target. */\n  final Element _ptr;\n  static final webkitEvents = {\n    'animationend' : 'webkitAnimationEnd', \n    'animationiteration' : 'webkitAnimationIteration', \n    'animationstart' : 'webkitAnimationStart', \n    'fullscreenchange' : 'webkitfullscreenchange', \n    'fullscreenerror' : 'webkitfullscreenerror',\n    'keyadded' : 'webkitkeyadded', \n    'keyerror' : 'webkitkeyerror', \n    'keymessage' : 'webkitkeymessage', \n    'needkey' : 'webkitneedkey', \n    'pointerlockchange' : 'webkitpointerlockchange', \n    'pointerlockerror' : 'webkitpointerlockerror', \n    'resourcetimingbufferfull' : 'webkitresourcetimingbufferfull', \n    'transitionend': 'webkitTransitionEnd',\n    'speechchange' : 'webkitSpeechChange'\n  };\n\n  ElementEvents(Element ptr) : this._ptr = ptr, super(ptr);\n\n  Stream operator [](String type) {\n    if (webkitEvents.keys.contains(type.toLowerCase())) {\n      if (Device.isWebKit) {\n        return new _ElementEventStreamImpl(\n            _ptr, webkitEvents[type.toLowerCase()], false);\n      }\n    }\n    return new _ElementEventStreamImpl(_ptr, type, false);\n  }\n}\n\n/**\n * Base class for all browser objects that support events.\n *\n * Use the [on] property to add, and remove events\n * for compile-time type checks and a more concise API.\n */\n@DomName('EventTarget')\n@Native(\"EventTarget\")\nclass EventTarget extends Interceptor {\n\n  // Custom element created callback.\n  EventTarget._created();\n\n  /**\n   * This is an ease-of-use accessor for event streams which should only be\n   * used when an explicit accessor is not available.\n   */\n  Events get on => new Events(this);\n  // To suppress missing implicit constructor warnings.\n  factory EventTarget._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('EventTarget.addEventListener')\n  @DocsEditable()\n  void addEventListener(String type, EventListener listener, [bool useCapture]) native;\n\n  @DomName('EventTarget.dispatchEvent')\n  @DocsEditable()\n  bool dispatchEvent(Event event) native;\n\n  @DomName('EventTarget.removeEventListener')\n  @DocsEditable()\n  void removeEventListener(String type, EventListener listener, [bool useCapture]) native;\n\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('HTMLFieldSetElement')\n@Unstable()\n@Native(\"HTMLFieldSetElement\")\nclass FieldSetElement extends HtmlElement {\n  // To suppress missing implicit constructor warnings.\n  factory FieldSetElement._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('HTMLFieldSetElement.HTMLFieldSetElement')\n  @DocsEditable()\n  factory FieldSetElement() => document.createElement(\"fieldset\");\n  /**\n   * Constructor instantiated by the DOM when a custom element has been created.\n   *\n   * This can only be called by subclasses from their created constructor.\n   */\n  FieldSetElement.created() : super.created();\n\n  @DomName('HTMLFieldSetElement.disabled')\n  @DocsEditable()\n  bool disabled;\n\n  @DomName('HTMLFieldSetElement.elements')\n  @DocsEditable()\n  @Returns('HtmlCollection')\n  @Creates('HtmlCollection')\n  final List<Node> elements;\n\n  @DomName('HTMLFieldSetElement.form')\n  @DocsEditable()\n  final FormElement form;\n\n  @DomName('HTMLFieldSetElement.name')\n  @DocsEditable()\n  String name;\n\n  @DomName('HTMLFieldSetElement.type')\n  @DocsEditable()\n  final String type;\n\n  @DomName('HTMLFieldSetElement.validationMessage')\n  @DocsEditable()\n  final String validationMessage;\n\n  @DomName('HTMLFieldSetElement.validity')\n  @DocsEditable()\n  final ValidityState validity;\n\n  @DomName('HTMLFieldSetElement.willValidate')\n  @DocsEditable()\n  final bool willValidate;\n\n  @DomName('HTMLFieldSetElement.checkValidity')\n  @DocsEditable()\n  bool checkValidity() native;\n\n  @DomName('HTMLFieldSetElement.setCustomValidity')\n  @DocsEditable()\n  void setCustomValidity(String error) native;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('File')\n@Native(\"File\")\nclass File extends Blob {\n  // To suppress missing implicit constructor warnings.\n  factory File._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('File.lastModified')\n  @DocsEditable()\n  @Experimental() // untriaged\n  final int lastModified;\n\n  @DomName('File.lastModifiedDate')\n  @DocsEditable()\n  DateTime get lastModifiedDate => convertNativeToDart_DateTime(this._get_lastModifiedDate);\n  @JSName('lastModifiedDate')\n  @DomName('File.lastModifiedDate')\n  @DocsEditable()\n  @Creates('Null')\n  final dynamic _get_lastModifiedDate;\n\n  @DomName('File.name')\n  @DocsEditable()\n  final String name;\n\n  @JSName('webkitRelativePath')\n  @DomName('File.webkitRelativePath')\n  @DocsEditable()\n  @SupportedBrowser(SupportedBrowser.CHROME)\n  @SupportedBrowser(SupportedBrowser.SAFARI)\n  @Experimental()\n  // https://plus.sandbox.google.com/+AddyOsmani/posts/Dk5UhZ6zfF3\n  final String relativePath;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n// WARNING: Do not edit - generated code.\n\n\n@DomName('FileCallback')\n// http://www.w3.org/TR/file-system-api/#the-filecallback-interface\n@Experimental()\ntypedef void _FileCallback(File file);\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('FileEntry')\n// http://www.w3.org/TR/file-system-api/#the-fileentry-interface\n@Experimental()\n@Native(\"FileEntry\")\nclass FileEntry extends Entry {\n  // To suppress missing implicit constructor warnings.\n  factory FileEntry._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @JSName('createWriter')\n  @DomName('FileEntry.createWriter')\n  @DocsEditable()\n  void _createWriter(_FileWriterCallback successCallback, [_ErrorCallback errorCallback]) native;\n\n  @JSName('createWriter')\n  @DomName('FileEntry.createWriter')\n  @DocsEditable()\n  Future<FileWriter> createWriter() {\n    var completer = new Completer<FileWriter>();\n    _createWriter(\n        (value) { completer.complete(value); },\n        (error) { completer.completeError(error); });\n    return completer.future;\n  }\n\n  @JSName('file')\n  @DomName('FileEntry.file')\n  @DocsEditable()\n  void _file(_FileCallback successCallback, [_ErrorCallback errorCallback]) native;\n\n  @JSName('file')\n  @DomName('FileEntry.file')\n  @DocsEditable()\n  Future<File> file() {\n    var completer = new Completer<File>();\n    _file(\n        (value) { completer.complete(value); },\n        (error) { completer.completeError(error); });\n    return completer.future;\n  }\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('FileError')\n// http://dev.w3.org/2009/dap/file-system/pub/FileSystem/\n@Experimental()\n@Native(\"FileError\")\nclass FileError extends DomError {\n  // To suppress missing implicit constructor warnings.\n  factory FileError._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('FileError.ABORT_ERR')\n  @DocsEditable()\n  static const int ABORT_ERR = 3;\n\n  @DomName('FileError.ENCODING_ERR')\n  @DocsEditable()\n  static const int ENCODING_ERR = 5;\n\n  @DomName('FileError.INVALID_MODIFICATION_ERR')\n  @DocsEditable()\n  static const int INVALID_MODIFICATION_ERR = 9;\n\n  @DomName('FileError.INVALID_STATE_ERR')\n  @DocsEditable()\n  static const int INVALID_STATE_ERR = 7;\n\n  @DomName('FileError.NOT_FOUND_ERR')\n  @DocsEditable()\n  static const int NOT_FOUND_ERR = 1;\n\n  @DomName('FileError.NOT_READABLE_ERR')\n  @DocsEditable()\n  static const int NOT_READABLE_ERR = 4;\n\n  @DomName('FileError.NO_MODIFICATION_ALLOWED_ERR')\n  @DocsEditable()\n  static const int NO_MODIFICATION_ALLOWED_ERR = 6;\n\n  @DomName('FileError.PATH_EXISTS_ERR')\n  @DocsEditable()\n  static const int PATH_EXISTS_ERR = 12;\n\n  @DomName('FileError.QUOTA_EXCEEDED_ERR')\n  @DocsEditable()\n  static const int QUOTA_EXCEEDED_ERR = 10;\n\n  @DomName('FileError.SECURITY_ERR')\n  @DocsEditable()\n  static const int SECURITY_ERR = 2;\n\n  @DomName('FileError.SYNTAX_ERR')\n  @DocsEditable()\n  static const int SYNTAX_ERR = 8;\n\n  @DomName('FileError.TYPE_MISMATCH_ERR')\n  @DocsEditable()\n  static const int TYPE_MISMATCH_ERR = 11;\n\n  @DomName('FileError.code')\n  @DocsEditable()\n  final int code;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('FileList')\n@Native(\"FileList\")\nclass FileList extends Interceptor with ListMixin<File>, ImmutableListMixin<File> implements JavaScriptIndexingBehavior, List<File> {\n  // To suppress missing implicit constructor warnings.\n  factory FileList._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('FileList.length')\n  @DocsEditable()\n  int get length => JS(\"int\", \"#.length\", this);\n\n  File operator[](int index) {\n    if (JS(\"bool\", \"# >>> 0 !== # || # >= #\", index,\n        index, index, length))\n      throw new RangeError.range(index, 0, length);\n    return JS(\"File\", \"#[#]\", this, index);\n  }\n  void operator[]=(int index, File value) {\n    throw new UnsupportedError(\"Cannot assign element of immutable List.\");\n  }\n  // -- start List<File> mixins.\n  // File is the element type.\n\n\n  void set length(int value) {\n    throw new UnsupportedError(\"Cannot resize immutable List.\");\n  }\n\n  File get first {\n    if (this.length > 0) {\n      return JS('File', '#[0]', this);\n    }\n    throw new StateError(\"No elements\");\n  }\n\n  File get last {\n    int len = this.length;\n    if (len > 0) {\n      return JS('File', '#[#]', this, len - 1);\n    }\n    throw new StateError(\"No elements\");\n  }\n\n  File get single {\n    int len = this.length;\n    if (len == 1) {\n      return JS('File', '#[0]', this);\n    }\n    if (len == 0) throw new StateError(\"No elements\");\n    throw new StateError(\"More than one element\");\n  }\n\n  File elementAt(int index) => this[index];\n  // -- end List<File> mixins.\n\n  @DomName('FileList.item')\n  @DocsEditable()\n  File item(int index) native;\n}\n// Copyright (c) 2014, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('FileReader')\n@Native(\"FileReader\")\nclass FileReader extends EventTarget {\n\n  @DomName('FileReader.result')\n  @DocsEditable()\n  Object get result {\n    var res = JS('Null|String|NativeByteBuffer', '#.result', this);\n    if (res is ByteBuffer) {\n      return new Uint8List.view(res);\n    }\n    return res;\n  }\n\n  // To suppress missing implicit constructor warnings.\n  factory FileReader._() { throw new UnsupportedError(\"Not supported\"); }\n\n  /**\n   * Static factory designed to expose `abort` events to event\n   * handlers that are not necessarily instances of [FileReader].\n   *\n   * See [EventStreamProvider] for usage information.\n   */\n  @DomName('FileReader.abortEvent')\n  @DocsEditable()\n  static const EventStreamProvider<ProgressEvent> abortEvent = const EventStreamProvider<ProgressEvent>('abort');\n\n  /**\n   * Static factory designed to expose `error` events to event\n   * handlers that are not necessarily instances of [FileReader].\n   *\n   * See [EventStreamProvider] for usage information.\n   */\n  @DomName('FileReader.errorEvent')\n  @DocsEditable()\n  static const EventStreamProvider<Event> errorEvent = const EventStreamProvider<Event>('error');\n\n  /**\n   * Static factory designed to expose `load` events to event\n   * handlers that are not necessarily instances of [FileReader].\n   *\n   * See [EventStreamProvider] for usage information.\n   */\n  @DomName('FileReader.loadEvent')\n  @DocsEditable()\n  static const EventStreamProvider<ProgressEvent> loadEvent = const EventStreamProvider<ProgressEvent>('load');\n\n  /**\n   * Static factory designed to expose `loadend` events to event\n   * handlers that are not necessarily instances of [FileReader].\n   *\n   * See [EventStreamProvider] for usage information.\n   */\n  @DomName('FileReader.loadendEvent')\n  @DocsEditable()\n  static const EventStreamProvider<ProgressEvent> loadEndEvent = const EventStreamProvider<ProgressEvent>('loadend');\n\n  /**\n   * Static factory designed to expose `loadstart` events to event\n   * handlers that are not necessarily instances of [FileReader].\n   *\n   * See [EventStreamProvider] for usage information.\n   */\n  @DomName('FileReader.loadstartEvent')\n  @DocsEditable()\n  static const EventStreamProvider<ProgressEvent> loadStartEvent = const EventStreamProvider<ProgressEvent>('loadstart');\n\n  /**\n   * Static factory designed to expose `progress` events to event\n   * handlers that are not necessarily instances of [FileReader].\n   *\n   * See [EventStreamProvider] for usage information.\n   */\n  @DomName('FileReader.progressEvent')\n  @DocsEditable()\n  static const EventStreamProvider<ProgressEvent> progressEvent = const EventStreamProvider<ProgressEvent>('progress');\n\n  @DomName('FileReader.FileReader')\n  @DocsEditable()\n  factory FileReader() {\n    return FileReader._create_1();\n  }\n  static FileReader _create_1() => JS('FileReader', 'new FileReader()');\n\n  @DomName('FileReader.DONE')\n  @DocsEditable()\n  static const int DONE = 2;\n\n  @DomName('FileReader.EMPTY')\n  @DocsEditable()\n  static const int EMPTY = 0;\n\n  @DomName('FileReader.LOADING')\n  @DocsEditable()\n  static const int LOADING = 1;\n\n  @DomName('FileReader.error')\n  @DocsEditable()\n  final FileError error;\n\n  @DomName('FileReader.readyState')\n  @DocsEditable()\n  final int readyState;\n\n  @DomName('FileReader.abort')\n  @DocsEditable()\n  void abort() native;\n\n  @DomName('FileReader.readAsArrayBuffer')\n  @DocsEditable()\n  void readAsArrayBuffer(Blob blob) native;\n\n  @JSName('readAsDataURL')\n  @DomName('FileReader.readAsDataURL')\n  @DocsEditable()\n  void readAsDataUrl(Blob blob) native;\n\n  @DomName('FileReader.readAsText')\n  @DocsEditable()\n  void readAsText(Blob blob, [String encoding]) native;\n\n  /// Stream of `abort` events handled by this [FileReader].\n  @DomName('FileReader.onabort')\n  @DocsEditable()\n  Stream<ProgressEvent> get onAbort => abortEvent.forTarget(this);\n\n  /// Stream of `error` events handled by this [FileReader].\n  @DomName('FileReader.onerror')\n  @DocsEditable()\n  Stream<Event> get onError => errorEvent.forTarget(this);\n\n  /// Stream of `load` events handled by this [FileReader].\n  @DomName('FileReader.onload')\n  @DocsEditable()\n  Stream<ProgressEvent> get onLoad => loadEvent.forTarget(this);\n\n  /// Stream of `loadend` events handled by this [FileReader].\n  @DomName('FileReader.onloadend')\n  @DocsEditable()\n  Stream<ProgressEvent> get onLoadEnd => loadEndEvent.forTarget(this);\n\n  /// Stream of `loadstart` events handled by this [FileReader].\n  @DomName('FileReader.onloadstart')\n  @DocsEditable()\n  Stream<ProgressEvent> get onLoadStart => loadStartEvent.forTarget(this);\n\n  /// Stream of `progress` events handled by this [FileReader].\n  @DomName('FileReader.onprogress')\n  @DocsEditable()\n  Stream<ProgressEvent> get onProgress => progressEvent.forTarget(this);\n\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('Stream')\n@Experimental() // untriaged\n@Native(\"Stream\")\nclass FileStream extends Interceptor {\n  // To suppress missing implicit constructor warnings.\n  factory FileStream._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('Stream.type')\n  @DocsEditable()\n  @Experimental() // untriaged\n  final String type;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('DOMFileSystem')\n@SupportedBrowser(SupportedBrowser.CHROME)\n@Experimental()\n// http://www.w3.org/TR/file-system-api/\n@Native(\"DOMFileSystem\")\nclass FileSystem extends Interceptor {\n  // To suppress missing implicit constructor warnings.\n  factory FileSystem._() { throw new UnsupportedError(\"Not supported\"); }\n\n  /// Checks if this type is supported on the current platform.\n  static bool get supported => JS('bool', '!!(window.webkitRequestFileSystem)');\n\n  @DomName('DOMFileSystem.name')\n  @DocsEditable()\n  final String name;\n\n  @DomName('DOMFileSystem.root')\n  @DocsEditable()\n  final DirectoryEntry root;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n// WARNING: Do not edit - generated code.\n\n\n@DomName('FileSystemCallback')\n// http://www.w3.org/TR/file-system-api/#the-filesystemcallback-interface\n@Experimental()\ntypedef void _FileSystemCallback(FileSystem fileSystem);\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('FileWriter')\n// http://www.w3.org/TR/file-writer-api/#the-filewriter-interface\n@Experimental()\n@Native(\"FileWriter\")\nclass FileWriter extends EventTarget {\n  // To suppress missing implicit constructor warnings.\n  factory FileWriter._() { throw new UnsupportedError(\"Not supported\"); }\n\n  /**\n   * Static factory designed to expose `abort` events to event\n   * handlers that are not necessarily instances of [FileWriter].\n   *\n   * See [EventStreamProvider] for usage information.\n   */\n  @DomName('FileWriter.abortEvent')\n  @DocsEditable()\n  static const EventStreamProvider<ProgressEvent> abortEvent = const EventStreamProvider<ProgressEvent>('abort');\n\n  /**\n   * Static factory designed to expose `error` events to event\n   * handlers that are not necessarily instances of [FileWriter].\n   *\n   * See [EventStreamProvider] for usage information.\n   */\n  @DomName('FileWriter.errorEvent')\n  @DocsEditable()\n  static const EventStreamProvider<Event> errorEvent = const EventStreamProvider<Event>('error');\n\n  /**\n   * Static factory designed to expose `progress` events to event\n   * handlers that are not necessarily instances of [FileWriter].\n   *\n   * See [EventStreamProvider] for usage information.\n   */\n  @DomName('FileWriter.progressEvent')\n  @DocsEditable()\n  static const EventStreamProvider<ProgressEvent> progressEvent = const EventStreamProvider<ProgressEvent>('progress');\n\n  /**\n   * Static factory designed to expose `write` events to event\n   * handlers that are not necessarily instances of [FileWriter].\n   *\n   * See [EventStreamProvider] for usage information.\n   */\n  @DomName('FileWriter.writeEvent')\n  @DocsEditable()\n  static const EventStreamProvider<ProgressEvent> writeEvent = const EventStreamProvider<ProgressEvent>('write');\n\n  /**\n   * Static factory designed to expose `writeend` events to event\n   * handlers that are not necessarily instances of [FileWriter].\n   *\n   * See [EventStreamProvider] for usage information.\n   */\n  @DomName('FileWriter.writeendEvent')\n  @DocsEditable()\n  static const EventStreamProvider<ProgressEvent> writeEndEvent = const EventStreamProvider<ProgressEvent>('writeend');\n\n  /**\n   * Static factory designed to expose `writestart` events to event\n   * handlers that are not necessarily instances of [FileWriter].\n   *\n   * See [EventStreamProvider] for usage information.\n   */\n  @DomName('FileWriter.writestartEvent')\n  @DocsEditable()\n  static const EventStreamProvider<ProgressEvent> writeStartEvent = const EventStreamProvider<ProgressEvent>('writestart');\n\n  @DomName('FileWriter.DONE')\n  @DocsEditable()\n  static const int DONE = 2;\n\n  @DomName('FileWriter.INIT')\n  @DocsEditable()\n  static const int INIT = 0;\n\n  @DomName('FileWriter.WRITING')\n  @DocsEditable()\n  static const int WRITING = 1;\n\n  @DomName('FileWriter.error')\n  @DocsEditable()\n  final FileError error;\n\n  @DomName('FileWriter.length')\n  @DocsEditable()\n  final int length;\n\n  @DomName('FileWriter.position')\n  @DocsEditable()\n  final int position;\n\n  @DomName('FileWriter.readyState')\n  @DocsEditable()\n  final int readyState;\n\n  @DomName('FileWriter.abort')\n  @DocsEditable()\n  void abort() native;\n\n  @DomName('FileWriter.seek')\n  @DocsEditable()\n  void seek(int position) native;\n\n  @DomName('FileWriter.truncate')\n  @DocsEditable()\n  void truncate(int size) native;\n\n  @DomName('FileWriter.write')\n  @DocsEditable()\n  void write(Blob data) native;\n\n  /// Stream of `abort` events handled by this [FileWriter].\n  @DomName('FileWriter.onabort')\n  @DocsEditable()\n  Stream<ProgressEvent> get onAbort => abortEvent.forTarget(this);\n\n  /// Stream of `error` events handled by this [FileWriter].\n  @DomName('FileWriter.onerror')\n  @DocsEditable()\n  Stream<Event> get onError => errorEvent.forTarget(this);\n\n  /// Stream of `progress` events handled by this [FileWriter].\n  @DomName('FileWriter.onprogress')\n  @DocsEditable()\n  Stream<ProgressEvent> get onProgress => progressEvent.forTarget(this);\n\n  /// Stream of `write` events handled by this [FileWriter].\n  @DomName('FileWriter.onwrite')\n  @DocsEditable()\n  Stream<ProgressEvent> get onWrite => writeEvent.forTarget(this);\n\n  /// Stream of `writeend` events handled by this [FileWriter].\n  @DomName('FileWriter.onwriteend')\n  @DocsEditable()\n  Stream<ProgressEvent> get onWriteEnd => writeEndEvent.forTarget(this);\n\n  /// Stream of `writestart` events handled by this [FileWriter].\n  @DomName('FileWriter.onwritestart')\n  @DocsEditable()\n  Stream<ProgressEvent> get onWriteStart => writeStartEvent.forTarget(this);\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n// WARNING: Do not edit - generated code.\n\n\n@DomName('FileWriterCallback')\n// http://www.w3.org/TR/file-writer-api/#idl-def-FileWriter\n@Experimental()\ntypedef void _FileWriterCallback(FileWriter fileWriter);\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('FocusEvent')\n@Native(\"FocusEvent\")\nclass FocusEvent extends UIEvent {\n  // To suppress missing implicit constructor warnings.\n  factory FocusEvent._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('FocusEvent.relatedTarget')\n  @DocsEditable()\n  EventTarget get relatedTarget => _convertNativeToDart_EventTarget(this._get_relatedTarget);\n  @JSName('relatedTarget')\n  @DomName('FocusEvent.relatedTarget')\n  @DocsEditable()\n  @Creates('Null')\n  final dynamic _get_relatedTarget;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('FontFace')\n@Experimental() // untriaged\n@Native(\"FontFace\")\nclass FontFace extends Interceptor {\n  // To suppress missing implicit constructor warnings.\n  factory FontFace._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('FontFace.FontFace')\n  @DocsEditable()\n  factory FontFace(String family, String source, Map descriptors) {\n    return FontFace._create_1(family, source, descriptors);\n  }\n  static FontFace _create_1(family, source, descriptors) => JS('FontFace', 'new FontFace(#,#,#)', family, source, descriptors);\n\n  @DomName('FontFace.family')\n  @DocsEditable()\n  @Experimental() // untriaged\n  String family;\n\n  @DomName('FontFace.featureSettings')\n  @DocsEditable()\n  @Experimental() // untriaged\n  String featureSettings;\n\n  @DomName('FontFace.status')\n  @DocsEditable()\n  @Experimental() // untriaged\n  final String status;\n\n  @DomName('FontFace.stretch')\n  @DocsEditable()\n  @Experimental() // untriaged\n  String stretch;\n\n  @DomName('FontFace.style')\n  @DocsEditable()\n  @Experimental() // untriaged\n  String style;\n\n  @DomName('FontFace.unicodeRange')\n  @DocsEditable()\n  @Experimental() // untriaged\n  String unicodeRange;\n\n  @DomName('FontFace.variant')\n  @DocsEditable()\n  @Experimental() // untriaged\n  String variant;\n\n  @DomName('FontFace.weight')\n  @DocsEditable()\n  @Experimental() // untriaged\n  String weight;\n\n  @DomName('FontFace.load')\n  @DocsEditable()\n  @Experimental() // untriaged\n  void load() native;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('FontFaceSet')\n@Experimental() // untriaged\n@Native(\"FontFaceSet\")\nclass FontFaceSet extends EventTarget {\n  // To suppress missing implicit constructor warnings.\n  factory FontFaceSet._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('FontFaceSet.size')\n  @DocsEditable()\n  @Experimental() // untriaged\n  final int size;\n\n  @DomName('FontFaceSet.status')\n  @DocsEditable()\n  @Experimental() // untriaged\n  final String status;\n\n  @DomName('FontFaceSet.add')\n  @DocsEditable()\n  @Experimental() // untriaged\n  void add(FontFace fontFace) native;\n\n  @DomName('FontFaceSet.check')\n  @DocsEditable()\n  @Experimental() // untriaged\n  bool check(String font, String text) native;\n\n  @DomName('FontFaceSet.clear')\n  @DocsEditable()\n  @Experimental() // untriaged\n  void clear() native;\n\n  @DomName('FontFaceSet.delete')\n  @DocsEditable()\n  @Experimental() // untriaged\n  bool delete(FontFace fontFace) native;\n\n  @DomName('FontFaceSet.forEach')\n  @DocsEditable()\n  @Experimental() // untriaged\n  void forEach(FontFaceSetForEachCallback callback, [Object thisArg]) native;\n\n  @DomName('FontFaceSet.has')\n  @DocsEditable()\n  @Experimental() // untriaged\n  bool has(FontFace fontFace) native;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n// WARNING: Do not edit - generated code.\n\n\n@DomName('FontFaceSetForEachCallback')\n@Experimental() // untriaged\ntypedef void FontFaceSetForEachCallback(FontFace fontFace, FontFace fontFaceAgain, FontFaceSet set);\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('FormData')\n@SupportedBrowser(SupportedBrowser.CHROME)\n@SupportedBrowser(SupportedBrowser.FIREFOX)\n@SupportedBrowser(SupportedBrowser.IE, '10')\n@SupportedBrowser(SupportedBrowser.SAFARI)\n@Native(\"FormData\")\nclass FormData extends Interceptor {\n  // To suppress missing implicit constructor warnings.\n  factory FormData._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('FormData.FormData')\n  @DocsEditable()\n  factory FormData([FormElement form]) {\n    if (form != null) {\n      return FormData._create_1(form);\n    }\n    return FormData._create_2();\n  }\n  static FormData _create_1(form) => JS('FormData', 'new FormData(#)', form);\n  static FormData _create_2() => JS('FormData', 'new FormData()');\n\n  /// Checks if this type is supported on the current platform.\n  static bool get supported => JS('bool', '!!(window.FormData)');\n\n  @DomName('FormData.append')\n  @DocsEditable()\n  void append(String name, String value) native;\n\n  @JSName('append')\n  @DomName('FormData.append')\n  @DocsEditable()\n  void appendBlob(String name, Blob value, [String filename]) native;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('HTMLFormElement')\n@Native(\"HTMLFormElement\")\nclass FormElement extends HtmlElement {\n  // To suppress missing implicit constructor warnings.\n  factory FormElement._() { throw new UnsupportedError(\"Not supported\"); }\n\n  /**\n   * Static factory designed to expose `autocomplete` events to event\n   * handlers that are not necessarily instances of [FormElement].\n   *\n   * See [EventStreamProvider] for usage information.\n   */\n  @DomName('HTMLFormElement.autocompleteEvent')\n  @DocsEditable()\n  // http://www.whatwg.org/specs/web-apps/current-work/multipage/association-of-controls-and-forms.html#autofilling-form-controls:-the-autocomplete-attribute\n  @Experimental()\n  static const EventStreamProvider<Event> autocompleteEvent = const EventStreamProvider<Event>('autocomplete');\n\n  /**\n   * Static factory designed to expose `autocompleteerror` events to event\n   * handlers that are not necessarily instances of [FormElement].\n   *\n   * See [EventStreamProvider] for usage information.\n   */\n  @DomName('HTMLFormElement.autocompleteerrorEvent')\n  @DocsEditable()\n  // http://www.whatwg.org/specs/web-apps/current-work/multipage/association-of-controls-and-forms.html#autofilling-form-controls:-the-autocomplete-attribute\n  @Experimental()\n  static const EventStreamProvider<AutocompleteErrorEvent> autocompleteErrorEvent = const EventStreamProvider<AutocompleteErrorEvent>('autocompleteerror');\n\n  @DomName('HTMLFormElement.HTMLFormElement')\n  @DocsEditable()\n  factory FormElement() => document.createElement(\"form\");\n  /**\n   * Constructor instantiated by the DOM when a custom element has been created.\n   *\n   * This can only be called by subclasses from their created constructor.\n   */\n  FormElement.created() : super.created();\n\n  @DomName('HTMLFormElement.acceptCharset')\n  @DocsEditable()\n  String acceptCharset;\n\n  @DomName('HTMLFormElement.action')\n  @DocsEditable()\n  String action;\n\n  @DomName('HTMLFormElement.autocomplete')\n  @DocsEditable()\n  // http://www.whatwg.org/specs/web-apps/current-work/multipage/association-of-controls-and-forms.html#autofilling-form-controls:-the-autocomplete-attribute\n  @Experimental()\n  String autocomplete;\n\n  @DomName('HTMLFormElement.encoding')\n  @DocsEditable()\n  String encoding;\n\n  @DomName('HTMLFormElement.enctype')\n  @DocsEditable()\n  String enctype;\n\n  @DomName('HTMLFormElement.length')\n  @DocsEditable()\n  final int length;\n\n  @DomName('HTMLFormElement.method')\n  @DocsEditable()\n  String method;\n\n  @DomName('HTMLFormElement.name')\n  @DocsEditable()\n  String name;\n\n  @DomName('HTMLFormElement.noValidate')\n  @DocsEditable()\n  bool noValidate;\n\n  @DomName('HTMLFormElement.target')\n  @DocsEditable()\n  String target;\n\n  @DomName('HTMLFormElement.__getter__')\n  @DocsEditable()\n  Element __getter__(int index) native;\n\n  @DomName('HTMLFormElement.checkValidity')\n  @DocsEditable()\n  bool checkValidity() native;\n\n  @DomName('HTMLFormElement.requestAutocomplete')\n  @DocsEditable()\n  // http://lists.whatwg.org/htdig.cgi/whatwg-whatwg.org/2012-October/037711.html\n  @Experimental()\n  void requestAutocomplete(Map details) {\n    var details_1 = convertDartToNative_Dictionary(details);\n    _requestAutocomplete_1(details_1);\n    return;\n  }\n  @JSName('requestAutocomplete')\n  @DomName('HTMLFormElement.requestAutocomplete')\n  @DocsEditable()\n  // http://lists.whatwg.org/htdig.cgi/whatwg-whatwg.org/2012-October/037711.html\n  @Experimental()\n  void _requestAutocomplete_1(details) native;\n\n  @DomName('HTMLFormElement.reset')\n  @DocsEditable()\n  void reset() native;\n\n  @DomName('HTMLFormElement.submit')\n  @DocsEditable()\n  void submit() native;\n\n  /// Stream of `autocomplete` events handled by this [FormElement].\n  @DomName('HTMLFormElement.onautocomplete')\n  @DocsEditable()\n  // http://www.whatwg.org/specs/web-apps/current-work/multipage/association-of-controls-and-forms.html#autofilling-form-controls:-the-autocomplete-attribute\n  @Experimental()\n  ElementStream<Event> get onAutocomplete => autocompleteEvent.forElement(this);\n\n  /// Stream of `autocompleteerror` events handled by this [FormElement].\n  @DomName('HTMLFormElement.onautocompleteerror')\n  @DocsEditable()\n  // http://www.whatwg.org/specs/web-apps/current-work/multipage/association-of-controls-and-forms.html#autofilling-form-controls:-the-autocomplete-attribute\n  @Experimental()\n  ElementStream<AutocompleteErrorEvent> get onAutocompleteError => autocompleteErrorEvent.forElement(this);\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('Gamepad')\n// https://dvcs.w3.org/hg/gamepad/raw-file/default/gamepad.html#gamepad-interface\n@Experimental()\n@Native(\"Gamepad\")\nclass Gamepad extends Interceptor {\n  // To suppress missing implicit constructor warnings.\n  factory Gamepad._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('Gamepad.axes')\n  @DocsEditable()\n  final List<num> axes;\n\n  @DomName('Gamepad.buttons')\n  @DocsEditable()\n  final List<num> buttons;\n\n  @DomName('Gamepad.id')\n  @DocsEditable()\n  final String id;\n\n  @DomName('Gamepad.index')\n  @DocsEditable()\n  final int index;\n\n  @DomName('Gamepad.timestamp')\n  @DocsEditable()\n  final int timestamp;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('Geolocation')\n@Unstable()\n@Native(\"Geolocation\")\nclass Geolocation extends Interceptor {\n\n  @DomName('Geolocation.getCurrentPosition')\n  Future<Geoposition> getCurrentPosition({bool enableHighAccuracy,\n      Duration timeout, Duration maximumAge}) {\n    var options = {};\n    if (enableHighAccuracy != null) {\n      options['enableHighAccuracy'] = enableHighAccuracy;\n    }\n    if (timeout != null) {\n      options['timeout'] = timeout.inMilliseconds;\n    }\n    if (maximumAge != null) {\n      options['maximumAge'] = maximumAge.inMilliseconds;\n    }\n    var completer = new Completer<Geoposition>();\n    try {\n      _getCurrentPosition(\n          (position) {\n            completer.complete(_ensurePosition(position));\n          },\n          (error) {\n            completer.completeError(error);\n          },\n          options);\n    } catch (e, stacktrace) {\n      completer.completeError(e, stacktrace);\n    }\n    return completer.future;\n  }\n\n  @DomName('Geolocation.watchPosition')\n  Stream<Geoposition> watchPosition({bool enableHighAccuracy,\n      Duration timeout, Duration maximumAge}) {\n\n    var options = {};\n    if (enableHighAccuracy != null) {\n      options['enableHighAccuracy'] = enableHighAccuracy;\n    }\n    if (timeout != null) {\n      options['timeout'] = timeout.inMilliseconds;\n    }\n    if (maximumAge != null) {\n      options['maximumAge'] = maximumAge.inMilliseconds;\n    }\n\n    int watchId;\n    var controller;\n    controller = new StreamController<Geoposition>(sync: true,\n      onListen: () {\n        assert(watchId == null);\n        watchId = _watchPosition(\n            (position) {\n              controller.add(_ensurePosition(position));\n            },\n            (error) {\n              controller.addError(error);\n            },\n            options);\n      },\n      onCancel: () {\n        assert(watchId != null);\n        _clearWatch(watchId);\n      });\n\n    return controller.stream;\n  }\n\n  Geoposition _ensurePosition(domPosition) {\n    try {\n      // Firefox may throw on this.\n      if (domPosition is Geoposition) {\n        return domPosition;\n      }\n    } catch(e) {}\n    return new _GeopositionWrapper(domPosition);\n  }\n\n  // To suppress missing implicit constructor warnings.\n  factory Geolocation._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @JSName('clearWatch')\n  @DomName('Geolocation.clearWatch')\n  @DocsEditable()\n  void _clearWatch(int watchID) native;\n\n  @JSName('getCurrentPosition')\n  @DomName('Geolocation.getCurrentPosition')\n  @DocsEditable()\n  void _getCurrentPosition(_PositionCallback successCallback, [_PositionErrorCallback errorCallback, Object options]) native;\n\n  @JSName('watchPosition')\n  @DomName('Geolocation.watchPosition')\n  @DocsEditable()\n  int _watchPosition(_PositionCallback successCallback, [_PositionErrorCallback errorCallback, Object options]) native;\n}\n\n/**\n * Wrapper for Firefox- it returns an object which we cannot map correctly.\n * Basically Firefox was returning a [xpconnect wrapped nsIDOMGeoPosition] but\n * which has further oddities.\n */\nclass _GeopositionWrapper implements Geoposition {\n  var _ptr;\n  _GeopositionWrapper(this._ptr);\n\n  Coordinates get coords => JS('Coordinates', '#.coords', _ptr);\n  int get timestamp => JS('int', '#.timestamp', _ptr);\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('Geoposition')\n@Unstable()\n@Native(\"Geoposition\")\nclass Geoposition extends Interceptor {\n  // To suppress missing implicit constructor warnings.\n  factory Geoposition._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('Geoposition.coords')\n  @DocsEditable()\n  final Coordinates coords;\n\n  @DomName('Geoposition.timestamp')\n  @DocsEditable()\n  final int timestamp;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('GlobalEventHandlers')\n@Experimental() // untriaged\nabstract class GlobalEventHandlers extends EventTarget {\n  // To suppress missing implicit constructor warnings.\n  factory GlobalEventHandlers._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('GlobalEventHandlers.abortEvent')\n  @DocsEditable()\n  @Experimental() // untriaged\n  static const EventStreamProvider<Event> abortEvent = const EventStreamProvider<Event>('abort');\n\n  @DomName('GlobalEventHandlers.blurEvent')\n  @DocsEditable()\n  @Experimental() // untriaged\n  static const EventStreamProvider<Event> blurEvent = const EventStreamProvider<Event>('blur');\n\n  @DomName('GlobalEventHandlers.changeEvent')\n  @DocsEditable()\n  @Experimental() // untriaged\n  static const EventStreamProvider<Event> changeEvent = const EventStreamProvider<Event>('change');\n\n  @DomName('GlobalEventHandlers.clickEvent')\n  @DocsEditable()\n  @Experimental() // untriaged\n  static const EventStreamProvider<MouseEvent> clickEvent = const EventStreamProvider<MouseEvent>('click');\n\n  @DomName('GlobalEventHandlers.contextmenuEvent')\n  @DocsEditable()\n  @Experimental() // untriaged\n  static const EventStreamProvider<MouseEvent> contextMenuEvent = const EventStreamProvider<MouseEvent>('contextmenu');\n\n  @DomName('GlobalEventHandlers.dblclickEvent')\n  @DocsEditable()\n  @Experimental() // untriaged\n  static const EventStreamProvider<Event> doubleClickEvent = const EventStreamProvider<Event>('dblclick');\n\n  @DomName('GlobalEventHandlers.dragEvent')\n  @DocsEditable()\n  @Experimental() // untriaged\n  static const EventStreamProvider<MouseEvent> dragEvent = const EventStreamProvider<MouseEvent>('drag');\n\n  @DomName('GlobalEventHandlers.dragendEvent')\n  @DocsEditable()\n  @Experimental() // untriaged\n  static const EventStreamProvider<MouseEvent> dragEndEvent = const EventStreamProvider<MouseEvent>('dragend');\n\n  @DomName('GlobalEventHandlers.dragenterEvent')\n  @DocsEditable()\n  @Experimental() // untriaged\n  static const EventStreamProvider<MouseEvent> dragEnterEvent = const EventStreamProvider<MouseEvent>('dragenter');\n\n  @DomName('GlobalEventHandlers.dragleaveEvent')\n  @DocsEditable()\n  @Experimental() // untriaged\n  static const EventStreamProvider<MouseEvent> dragLeaveEvent = const EventStreamProvider<MouseEvent>('dragleave');\n\n  @DomName('GlobalEventHandlers.dragoverEvent')\n  @DocsEditable()\n  @Experimental() // untriaged\n  static const EventStreamProvider<MouseEvent> dragOverEvent = const EventStreamProvider<MouseEvent>('dragover');\n\n  @DomName('GlobalEventHandlers.dragstartEvent')\n  @DocsEditable()\n  @Experimental() // untriaged\n  static const EventStreamProvider<MouseEvent> dragStartEvent = const EventStreamProvider<MouseEvent>('dragstart');\n\n  @DomName('GlobalEventHandlers.dropEvent')\n  @DocsEditable()\n  @Experimental() // untriaged\n  static const EventStreamProvider<MouseEvent> dropEvent = const EventStreamProvider<MouseEvent>('drop');\n\n  @DomName('GlobalEventHandlers.errorEvent')\n  @DocsEditable()\n  @Experimental() // untriaged\n  static const EventStreamProvider<Event> errorEvent = const EventStreamProvider<Event>('error');\n\n  @DomName('GlobalEventHandlers.focusEvent')\n  @DocsEditable()\n  @Experimental() // untriaged\n  static const EventStreamProvider<Event> focusEvent = const EventStreamProvider<Event>('focus');\n\n  @DomName('GlobalEventHandlers.inputEvent')\n  @DocsEditable()\n  @Experimental() // untriaged\n  static const EventStreamProvider<Event> inputEvent = const EventStreamProvider<Event>('input');\n\n  @DomName('GlobalEventHandlers.invalidEvent')\n  @DocsEditable()\n  @Experimental() // untriaged\n  static const EventStreamProvider<Event> invalidEvent = const EventStreamProvider<Event>('invalid');\n\n  @DomName('GlobalEventHandlers.keydownEvent')\n  @DocsEditable()\n  @Experimental() // untriaged\n  static const EventStreamProvider<KeyboardEvent> keyDownEvent = const EventStreamProvider<KeyboardEvent>('keydown');\n\n  @DomName('GlobalEventHandlers.keypressEvent')\n  @DocsEditable()\n  @Experimental() // untriaged\n  static const EventStreamProvider<KeyboardEvent> keyPressEvent = const EventStreamProvider<KeyboardEvent>('keypress');\n\n  @DomName('GlobalEventHandlers.keyupEvent')\n  @DocsEditable()\n  @Experimental() // untriaged\n  static const EventStreamProvider<KeyboardEvent> keyUpEvent = const EventStreamProvider<KeyboardEvent>('keyup');\n\n  @DomName('GlobalEventHandlers.loadEvent')\n  @DocsEditable()\n  @Experimental() // untriaged\n  static const EventStreamProvider<Event> loadEvent = const EventStreamProvider<Event>('load');\n\n  @DomName('GlobalEventHandlers.mousedownEvent')\n  @DocsEditable()\n  @Experimental() // untriaged\n  static const EventStreamProvider<MouseEvent> mouseDownEvent = const EventStreamProvider<MouseEvent>('mousedown');\n\n  @DomName('GlobalEventHandlers.mouseenterEvent')\n  @DocsEditable()\n  @Experimental() // untriaged\n  static const EventStreamProvider<MouseEvent> mouseEnterEvent = const EventStreamProvider<MouseEvent>('mouseenter');\n\n  @DomName('GlobalEventHandlers.mouseleaveEvent')\n  @DocsEditable()\n  @Experimental() // untriaged\n  static const EventStreamProvider<MouseEvent> mouseLeaveEvent = const EventStreamProvider<MouseEvent>('mouseleave');\n\n  @DomName('GlobalEventHandlers.mousemoveEvent')\n  @DocsEditable()\n  @Experimental() // untriaged\n  static const EventStreamProvider<MouseEvent> mouseMoveEvent = const EventStreamProvider<MouseEvent>('mousemove');\n\n  @DomName('GlobalEventHandlers.mouseoutEvent')\n  @DocsEditable()\n  @Experimental() // untriaged\n  static const EventStreamProvider<MouseEvent> mouseOutEvent = const EventStreamProvider<MouseEvent>('mouseout');\n\n  @DomName('GlobalEventHandlers.mouseoverEvent')\n  @DocsEditable()\n  @Experimental() // untriaged\n  static const EventStreamProvider<MouseEvent> mouseOverEvent = const EventStreamProvider<MouseEvent>('mouseover');\n\n  @DomName('GlobalEventHandlers.mouseupEvent')\n  @DocsEditable()\n  @Experimental() // untriaged\n  static const EventStreamProvider<MouseEvent> mouseUpEvent = const EventStreamProvider<MouseEvent>('mouseup');\n\n  @DomName('GlobalEventHandlers.mousewheelEvent')\n  @DocsEditable()\n  @Experimental() // untriaged\n  static const EventStreamProvider<WheelEvent> mouseWheelEvent = const EventStreamProvider<WheelEvent>('mousewheel');\n\n  @DomName('GlobalEventHandlers.resetEvent')\n  @DocsEditable()\n  @Experimental() // untriaged\n  static const EventStreamProvider<Event> resetEvent = const EventStreamProvider<Event>('reset');\n\n  @DomName('GlobalEventHandlers.resizeEvent')\n  @DocsEditable()\n  @Experimental() // untriaged\n  static const EventStreamProvider<Event> resizeEvent = const EventStreamProvider<Event>('resize');\n\n  @DomName('GlobalEventHandlers.scrollEvent')\n  @DocsEditable()\n  @Experimental() // untriaged\n  static const EventStreamProvider<Event> scrollEvent = const EventStreamProvider<Event>('scroll');\n\n  @DomName('GlobalEventHandlers.selectEvent')\n  @DocsEditable()\n  @Experimental() // untriaged\n  static const EventStreamProvider<Event> selectEvent = const EventStreamProvider<Event>('select');\n\n  @DomName('GlobalEventHandlers.submitEvent')\n  @DocsEditable()\n  @Experimental() // untriaged\n  static const EventStreamProvider<Event> submitEvent = const EventStreamProvider<Event>('submit');\n\n  @DomName('GlobalEventHandlers.onabort')\n  @DocsEditable()\n  @Experimental() // untriaged\n  Stream<Event> get onAbort => abortEvent.forTarget(this);\n\n  @DomName('GlobalEventHandlers.onblur')\n  @DocsEditable()\n  @Experimental() // untriaged\n  Stream<Event> get onBlur => blurEvent.forTarget(this);\n\n  @DomName('GlobalEventHandlers.onchange')\n  @DocsEditable()\n  @Experimental() // untriaged\n  Stream<Event> get onChange => changeEvent.forTarget(this);\n\n  @DomName('GlobalEventHandlers.onclick')\n  @DocsEditable()\n  @Experimental() // untriaged\n  Stream<MouseEvent> get onClick => clickEvent.forTarget(this);\n\n  @DomName('GlobalEventHandlers.oncontextmenu')\n  @DocsEditable()\n  @Experimental() // untriaged\n  Stream<MouseEvent> get onContextMenu => contextMenuEvent.forTarget(this);\n\n  @DomName('GlobalEventHandlers.ondblclick')\n  @DocsEditable()\n  @Experimental() // untriaged\n  Stream<Event> get onDoubleClick => doubleClickEvent.forTarget(this);\n\n  @DomName('GlobalEventHandlers.ondrag')\n  @DocsEditable()\n  @Experimental() // untriaged\n  Stream<MouseEvent> get onDrag => dragEvent.forTarget(this);\n\n  @DomName('GlobalEventHandlers.ondragend')\n  @DocsEditable()\n  @Experimental() // untriaged\n  Stream<MouseEvent> get onDragEnd => dragEndEvent.forTarget(this);\n\n  @DomName('GlobalEventHandlers.ondragenter')\n  @DocsEditable()\n  @Experimental() // untriaged\n  Stream<MouseEvent> get onDragEnter => dragEnterEvent.forTarget(this);\n\n  @DomName('GlobalEventHandlers.ondragleave')\n  @DocsEditable()\n  @Experimental() // untriaged\n  Stream<MouseEvent> get onDragLeave => dragLeaveEvent.forTarget(this);\n\n  @DomName('GlobalEventHandlers.ondragover')\n  @DocsEditable()\n  @Experimental() // untriaged\n  Stream<MouseEvent> get onDragOver => dragOverEvent.forTarget(this);\n\n  @DomName('GlobalEventHandlers.ondragstart')\n  @DocsEditable()\n  @Experimental() // untriaged\n  Stream<MouseEvent> get onDragStart => dragStartEvent.forTarget(this);\n\n  @DomName('GlobalEventHandlers.ondrop')\n  @DocsEditable()\n  @Experimental() // untriaged\n  Stream<MouseEvent> get onDrop => dropEvent.forTarget(this);\n\n  @DomName('GlobalEventHandlers.onerror')\n  @DocsEditable()\n  @Experimental() // untriaged\n  Stream<Event> get onError => errorEvent.forTarget(this);\n\n  @DomName('GlobalEventHandlers.onfocus')\n  @DocsEditable()\n  @Experimental() // untriaged\n  Stream<Event> get onFocus => focusEvent.forTarget(this);\n\n  @DomName('GlobalEventHandlers.oninput')\n  @DocsEditable()\n  @Experimental() // untriaged\n  Stream<Event> get onInput => inputEvent.forTarget(this);\n\n  @DomName('GlobalEventHandlers.oninvalid')\n  @DocsEditable()\n  @Experimental() // untriaged\n  Stream<Event> get onInvalid => invalidEvent.forTarget(this);\n\n  @DomName('GlobalEventHandlers.onkeydown')\n  @DocsEditable()\n  @Experimental() // untriaged\n  Stream<KeyboardEvent> get onKeyDown => keyDownEvent.forTarget(this);\n\n  @DomName('GlobalEventHandlers.onkeypress')\n  @DocsEditable()\n  @Experimental() // untriaged\n  Stream<KeyboardEvent> get onKeyPress => keyPressEvent.forTarget(this);\n\n  @DomName('GlobalEventHandlers.onkeyup')\n  @DocsEditable()\n  @Experimental() // untriaged\n  Stream<KeyboardEvent> get onKeyUp => keyUpEvent.forTarget(this);\n\n  @DomName('GlobalEventHandlers.onload')\n  @DocsEditable()\n  @Experimental() // untriaged\n  Stream<Event> get onLoad => loadEvent.forTarget(this);\n\n  @DomName('GlobalEventHandlers.onmousedown')\n  @DocsEditable()\n  @Experimental() // untriaged\n  Stream<MouseEvent> get onMouseDown => mouseDownEvent.forTarget(this);\n\n  @DomName('GlobalEventHandlers.onmouseenter')\n  @DocsEditable()\n  @Experimental() // untriaged\n  Stream<MouseEvent> get onMouseEnter => mouseEnterEvent.forTarget(this);\n\n  @DomName('GlobalEventHandlers.onmouseleave')\n  @DocsEditable()\n  @Experimental() // untriaged\n  Stream<MouseEvent> get onMouseLeave => mouseLeaveEvent.forTarget(this);\n\n  @DomName('GlobalEventHandlers.onmousemove')\n  @DocsEditable()\n  @Experimental() // untriaged\n  Stream<MouseEvent> get onMouseMove => mouseMoveEvent.forTarget(this);\n\n  @DomName('GlobalEventHandlers.onmouseout')\n  @DocsEditable()\n  @Experimental() // untriaged\n  Stream<MouseEvent> get onMouseOut => mouseOutEvent.forTarget(this);\n\n  @DomName('GlobalEventHandlers.onmouseover')\n  @DocsEditable()\n  @Experimental() // untriaged\n  Stream<MouseEvent> get onMouseOver => mouseOverEvent.forTarget(this);\n\n  @DomName('GlobalEventHandlers.onmouseup')\n  @DocsEditable()\n  @Experimental() // untriaged\n  Stream<MouseEvent> get onMouseUp => mouseUpEvent.forTarget(this);\n\n  @DomName('GlobalEventHandlers.onmousewheel')\n  @DocsEditable()\n  @Experimental() // untriaged\n  Stream<WheelEvent> get onMouseWheel => mouseWheelEvent.forTarget(this);\n\n  @DomName('GlobalEventHandlers.onreset')\n  @DocsEditable()\n  @Experimental() // untriaged\n  Stream<Event> get onReset => resetEvent.forTarget(this);\n\n  @DomName('GlobalEventHandlers.onresize')\n  @DocsEditable()\n  @Experimental() // untriaged\n  Stream<Event> get onResize => resizeEvent.forTarget(this);\n\n  @DomName('GlobalEventHandlers.onscroll')\n  @DocsEditable()\n  @Experimental() // untriaged\n  Stream<Event> get onScroll => scrollEvent.forTarget(this);\n\n  @DomName('GlobalEventHandlers.onselect')\n  @DocsEditable()\n  @Experimental() // untriaged\n  Stream<Event> get onSelect => selectEvent.forTarget(this);\n\n  @DomName('GlobalEventHandlers.onsubmit')\n  @DocsEditable()\n  @Experimental() // untriaged\n  Stream<Event> get onSubmit => submitEvent.forTarget(this);\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n/**\n * An `<hr>` tag.\n */\n@DomName('HTMLHRElement')\n@Native(\"HTMLHRElement\")\nclass HRElement extends HtmlElement {\n  // To suppress missing implicit constructor warnings.\n  factory HRElement._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('HTMLHRElement.HTMLHRElement')\n  @DocsEditable()\n  factory HRElement() => document.createElement(\"hr\");\n  /**\n   * Constructor instantiated by the DOM when a custom element has been created.\n   *\n   * This can only be called by subclasses from their created constructor.\n   */\n  HRElement.created() : super.created();\n\n  @DomName('HTMLHRElement.color')\n  @DocsEditable()\n  @Experimental() // untriaged\n  String color;\n}\n// Copyright (c) 2013, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n// WARNING: Do not edit - generated code.\n\n@DomName('HashChangeEvent')\n@SupportedBrowser(SupportedBrowser.CHROME)\n@SupportedBrowser(SupportedBrowser.FIREFOX)\n@SupportedBrowser(SupportedBrowser.SAFARI)\n@Unstable()\n@Native(\"HashChangeEvent\")\nclass HashChangeEvent extends Event {\n  factory HashChangeEvent(String type,\n      {bool canBubble: true, bool cancelable: true, String oldUrl,\n      String newUrl}) {\n    var event = document._createEvent(\"HashChangeEvent\");\n    event._initHashChangeEvent(type, canBubble, cancelable, oldUrl, newUrl);\n    return event;\n  }\n  // To suppress missing implicit constructor warnings.\n  factory HashChangeEvent._() { throw new UnsupportedError(\"Not supported\"); }\n\n  /// Checks if this type is supported on the current platform.\n  static bool get supported => Device.isEventTypeSupported('HashChangeEvent');\n\n  @JSName('newURL')\n  @DomName('HashChangeEvent.newURL')\n  @DocsEditable()\n  final String newUrl;\n\n  @JSName('oldURL')\n  @DomName('HashChangeEvent.oldURL')\n  @DocsEditable()\n  final String oldUrl;\n\n  @JSName('initHashChangeEvent')\n  @DomName('HashChangeEvent.initHashChangeEvent')\n  @DocsEditable()\n  void _initHashChangeEvent(String type, bool canBubble, bool cancelable, String oldURL, String newURL) native;\n\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('HTMLHeadElement')\n@Native(\"HTMLHeadElement\")\nclass HeadElement extends HtmlElement {\n  // To suppress missing implicit constructor warnings.\n  factory HeadElement._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('HTMLHeadElement.HTMLHeadElement')\n  @DocsEditable()\n  factory HeadElement() => document.createElement(\"head\");\n  /**\n   * Constructor instantiated by the DOM when a custom element has been created.\n   *\n   * This can only be called by subclasses from their created constructor.\n   */\n  HeadElement.created() : super.created();\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('HTMLHeadingElement')\n@Native(\"HTMLHeadingElement\")\nclass HeadingElement extends HtmlElement {\n  // To suppress missing implicit constructor warnings.\n  factory HeadingElement._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('HTMLHeadingElement.HTMLHeadingElement')\n  @DocsEditable()\n  factory HeadingElement.h1() => document.createElement(\"h1\");\n\n  @DomName('HTMLHeadingElement.HTMLHeadingElement')\n  @DocsEditable()\n  factory HeadingElement.h2() => document.createElement(\"h2\");\n\n  @DomName('HTMLHeadingElement.HTMLHeadingElement')\n  @DocsEditable()\n  factory HeadingElement.h3() => document.createElement(\"h3\");\n\n  @DomName('HTMLHeadingElement.HTMLHeadingElement')\n  @DocsEditable()\n  factory HeadingElement.h4() => document.createElement(\"h4\");\n\n  @DomName('HTMLHeadingElement.HTMLHeadingElement')\n  @DocsEditable()\n  factory HeadingElement.h5() => document.createElement(\"h5\");\n\n  @DomName('HTMLHeadingElement.HTMLHeadingElement')\n  @DocsEditable()\n  factory HeadingElement.h6() => document.createElement(\"h6\");\n  /**\n   * Constructor instantiated by the DOM when a custom element has been created.\n   *\n   * This can only be called by subclasses from their created constructor.\n   */\n  HeadingElement.created() : super.created();\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DomName('History')\n@Native(\"History\")\nclass History extends Interceptor implements HistoryBase {\n\n  /**\n   * Checks if the State APIs are supported on the current platform.\n   *\n   * See also:\n   *\n   * * [pushState]\n   * * [replaceState]\n   * * [state]\n   */\n  static bool get supportsState => JS('bool', '!!window.history.pushState');\n  // To suppress missing implicit constructor warnings.\n  factory History._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('History.length')\n  @DocsEditable()\n  final int length;\n\n  @DomName('History.state')\n  @DocsEditable()\n  dynamic get state => convertNativeToDart_SerializedScriptValue(this._get_state);\n  @JSName('state')\n  @DomName('History.state')\n  @DocsEditable()\n  @annotation_Creates_SerializedScriptValue\n  @annotation_Returns_SerializedScriptValue\n  final dynamic _get_state;\n\n  @DomName('History.back')\n  @DocsEditable()\n  void back() native;\n\n  @DomName('History.forward')\n  @DocsEditable()\n  void forward() native;\n\n  @DomName('History.go')\n  @DocsEditable()\n  void go(int distance) native;\n\n  @DomName('History.pushState')\n  @DocsEditable()\n  @SupportedBrowser(SupportedBrowser.CHROME)\n  @SupportedBrowser(SupportedBrowser.FIREFOX)\n  @SupportedBrowser(SupportedBrowser.IE, '10')\n  @SupportedBrowser(SupportedBrowser.SAFARI)\n  void pushState(Object data, String title, [String url]) native;\n\n  @DomName('History.replaceState')\n  @DocsEditable()\n  @SupportedBrowser(SupportedBrowser.CHROME)\n  @SupportedBrowser(SupportedBrowser.FIREFOX)\n  @SupportedBrowser(SupportedBrowser.IE, '10')\n  @SupportedBrowser(SupportedBrowser.SAFARI)\n  void replaceState(Object data, String title, [String url]) native;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('HTMLCollection')\n@Native(\"HTMLCollection\")\nclass HtmlCollection extends Interceptor with ListMixin<Node>, ImmutableListMixin<Node> implements JavaScriptIndexingBehavior, List<Node> {\n  // To suppress missing implicit constructor warnings.\n  factory HtmlCollection._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('HTMLCollection.length')\n  @DocsEditable()\n  int get length => JS(\"int\", \"#.length\", this);\n\n  Node operator[](int index) {\n    if (JS(\"bool\", \"# >>> 0 !== # || # >= #\", index,\n        index, index, length))\n      throw new RangeError.range(index, 0, length);\n    return JS(\"Node\", \"#[#]\", this, index);\n  }\n  void operator[]=(int index, Node value) {\n    throw new UnsupportedError(\"Cannot assign element of immutable List.\");\n  }\n  // -- start List<Node> mixins.\n  // Node is the element type.\n\n\n  void set length(int value) {\n    throw new UnsupportedError(\"Cannot resize immutable List.\");\n  }\n\n  Node get first {\n    if (this.length > 0) {\n      return JS('Node', '#[0]', this);\n    }\n    throw new StateError(\"No elements\");\n  }\n\n  Node get last {\n    int len = this.length;\n    if (len > 0) {\n      return JS('Node', '#[#]', this, len - 1);\n    }\n    throw new StateError(\"No elements\");\n  }\n\n  Node get single {\n    int len = this.length;\n    if (len == 1) {\n      return JS('Node', '#[0]', this);\n    }\n    if (len == 0) throw new StateError(\"No elements\");\n    throw new StateError(\"More than one element\");\n  }\n\n  Node elementAt(int index) => this[index];\n  // -- end List<Node> mixins.\n\n  @DomName('HTMLCollection.item')\n  @DocsEditable()\n  Element item(int index) native;\n\n  @DomName('HTMLCollection.namedItem')\n  @DocsEditable()\n  Element namedItem(String name) native;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n// WARNING: Do not edit - generated code.\n\n\n@DomName('HTMLDocument')\n@Native(\"HTMLDocument\")\nclass HtmlDocument extends Document {\n  // To suppress missing implicit constructor warnings.\n  factory HtmlDocument._() { throw new UnsupportedError(\"Not supported\"); }\n\n\n  @DomName('Document.body')\n  BodyElement body;\n\n  @DomName('Document.caretRangeFromPoint')\n  Range caretRangeFromPoint(int x, int y) {\n    return _caretRangeFromPoint(x, y);\n  }\n\n  @DomName('Document.elementFromPoint')\n  Element elementFromPoint(int x, int y) {\n    return _elementFromPoint(x, y);\n  }\n\n  /**\n   * Checks if the getCssCanvasContext API is supported on the current platform.\n   *\n   * See also:\n   *\n   * * [getCssCanvasContext]\n   */\n  static bool get supportsCssCanvasContext =>\n      JS('bool', '!!(document.getCSSCanvasContext)');\n\n\n  /**\n   * Gets a CanvasRenderingContext which can be used as the CSS background of an\n   * element.\n   *\n   * CSS:\n   *\n   *     background: -webkit-canvas(backgroundCanvas)\n   *\n   * Generate the canvas:\n   *\n   *     var context = document.getCssCanvasContext('2d', 'backgroundCanvas',\n   *         100, 100);\n   *     context.fillStyle = 'red';\n   *     context.fillRect(0, 0, 100, 100);\n   *\n   * See also:\n   *\n   * * [supportsCssCanvasContext]\n   * * [CanvasElement.getContext]\n   */\n  @SupportedBrowser(SupportedBrowser.CHROME)\n  @SupportedBrowser(SupportedBrowser.SAFARI)\n  @Experimental()\n  @DomName('Document.getCSSCanvasContext')\n  CanvasRenderingContext getCssCanvasContext(String contextId, String name,\n      int width, int height) {\n    return _getCssCanvasContext(contextId, name, width, height);\n  }\n\n  @DomName('Document.head')\n  HeadElement get head => _head;\n\n  @DomName('Document.lastModified')\n  String get lastModified => _lastModified;\n\n  @DomName('Document.preferredStylesheetSet')\n  String get preferredStylesheetSet => _preferredStylesheetSet;\n\n  @DomName('Document.referrer')\n  String get referrer => _referrer;\n\n  @DomName('Document.selectedStylesheetSet')\n  String get selectedStylesheetSet => _selectedStylesheetSet;\n  void set selectedStylesheetSet(String value) {\n    _selectedStylesheetSet = value;\n  }\n\n  @DomName('Document.styleSheets')\n  List<StyleSheet> get styleSheets => _styleSheets;\n\n  @DomName('Document.title')\n  String get title => _title;\n\n  @DomName('Document.title')\n  void set title(String value) {\n    _title = value;\n  }\n\n  /**\n   * Returns page to standard layout.\n   *\n   * Has no effect if the page is not in fullscreen mode.\n   *\n   * ## Other resources\n   *\n   * * [Using the fullscreen API]\n   * (http://docs.webplatform.org/wiki/tutorials/using_the_full-screen_api) from\n   * WebPlatform.org.\n   * * [Fullscreen specification]\n   * (http://www.w3.org/TR/fullscreen/) from W3C.\n   */\n  @DomName('Document.webkitExitFullscreen')\n  @SupportedBrowser(SupportedBrowser.CHROME)\n  @SupportedBrowser(SupportedBrowser.SAFARI)\n  @Experimental()\n  void exitFullscreen() {\n    _webkitExitFullscreen();\n  }\n\n  @DomName('Document.webkitExitPointerLock')\n  @SupportedBrowser(SupportedBrowser.CHROME)\n  @SupportedBrowser(SupportedBrowser.SAFARI)\n  @Experimental()\n  void exitPointerLock() {\n    _webkitExitPointerLock();\n  }\n\n  /**\n   * Returns the element, if any, that is currently displayed in fullscreen.\n   *\n   * Returns null if there is currently no fullscreen element. You can use\n   * this to determine if the page is in fullscreen mode.\n   *\n   *     myVideo = new VideoElement();\n   *     if (document.fullscreenElement == null) {\n   *       myVideo.requestFullscreen();\n   *       print(document.fullscreenElement == myVideo); // true\n   *     }\n   *\n   * ## Other resources\n   *\n   * * [Using the fullscreen API]\n   * (http://docs.webplatform.org/wiki/tutorials/using_the_full-screen_api) from\n   * WebPlatform.org.\n   * * [Fullscreen specification]\n   * (http://www.w3.org/TR/fullscreen/) from W3C.\n   */\n  @DomName('Document.webkitFullscreenElement')\n  @SupportedBrowser(SupportedBrowser.CHROME)\n  @SupportedBrowser(SupportedBrowser.SAFARI)\n  @Experimental()\n  Element get fullscreenElement => _webkitFullscreenElement;\n\n  /**\n   * Returns true if this document can display elements in fullscreen mode.\n   *\n   * ## Other resources\n   *\n   * * [Using the fullscreen API]\n   * (http://docs.webplatform.org/wiki/tutorials/using_the_full-screen_api) from\n   * WebPlatform.org.\n   * * [Fullscreen specification]\n   * (http://www.w3.org/TR/fullscreen/) from W3C.\n   */\n  @DomName('Document.webkitFullscreenEnabled')\n  @SupportedBrowser(SupportedBrowser.CHROME)\n  @SupportedBrowser(SupportedBrowser.SAFARI)\n  @Experimental()\n  bool get fullscreenEnabled => _webkitFullscreenEnabled;\n\n  @DomName('Document.webkitHidden')\n  @SupportedBrowser(SupportedBrowser.CHROME)\n  @SupportedBrowser(SupportedBrowser.SAFARI)\n  @Experimental()\n  bool get hidden => _webkitHidden;\n\n  @DomName('Document.webkitPointerLockElement')\n  @SupportedBrowser(SupportedBrowser.CHROME)\n  @SupportedBrowser(SupportedBrowser.SAFARI)\n  @Experimental()\n  Element get pointerLockElement =>\n      _webkitPointerLockElement;\n\n  @DomName('Document.visibilityState')\n  @SupportedBrowser(SupportedBrowser.CHROME)\n  @SupportedBrowser(SupportedBrowser.FIREFOX)\n  @SupportedBrowser(SupportedBrowser.IE, '10')\n  @Experimental()\n  String get visibilityState => JS('String',\n    '(#.visibilityState || #.mozVisibilityState || #.msVisibilityState ||'\n      '#.webkitVisibilityState)', this, this, this, this);\n\n  @Experimental()\n  /**\n   * Register a custom subclass of Element to be instantiatable by the DOM.\n   *\n   * This is necessary to allow the construction of any custom elements.\n   *\n   * The class being registered must either subclass HtmlElement or SvgElement.\n   * If they subclass these directly then they can be used as:\n   *\n   *     class FooElement extends HtmlElement{\n   *        void created() {\n   *          print('FooElement created!');\n   *        }\n   *     }\n   *\n   *     main() {\n   *       document.registerElement('x-foo', FooElement);\n   *       var myFoo = new Element.tag('x-foo');\n   *       // prints 'FooElement created!' to the console.\n   *     }\n   *\n   * The custom element can also be instantiated via HTML using the syntax\n   * `<x-foo></x-foo>`\n   *\n   * Other elements can be subclassed as well:\n   *\n   *     class BarElement extends InputElement{\n   *        void created() {\n   *          print('BarElement created!');\n   *        }\n   *     }\n   *\n   *     main() {\n   *       document.registerElement('x-bar', BarElement);\n   *       var myBar = new Element.tag('input', 'x-bar');\n   *       // prints 'BarElement created!' to the console.\n   *     }\n   *\n   * This custom element can also be instantiated via HTML using the syntax\n   * `<input is=\"x-bar\"></input>`\n   *\n   */\n  void registerElement(String tag, Type customElementClass,\n      {String extendsTag}) {\n    _registerCustomElement(JS('', 'window'), this, tag, customElementClass,\n        extendsTag);\n  }\n\n  /** *Deprecated*: use [registerElement] instead. */\n  @deprecated\n  @Experimental()\n  void register(String tag, Type customElementClass, {String extendsTag}) {\n    return registerElement(tag, customElementClass, extendsTag: extendsTag);\n  }\n\n  /**\n   * Static factory designed to expose `visibilitychange` events to event\n   * handlers that are not necessarily instances of [Document].\n   *\n   * See [EventStreamProvider] for usage information.\n   */\n  @DomName('Document.visibilityChange')\n  @SupportedBrowser(SupportedBrowser.CHROME)\n  @SupportedBrowser(SupportedBrowser.FIREFOX)\n  @SupportedBrowser(SupportedBrowser.IE, '10')\n  @Experimental()\n  static const EventStreamProvider<Event> visibilityChangeEvent =\n      const _CustomEventStreamProvider<Event>(\n        _determineVisibilityChangeEventType);\n\n  static String _determineVisibilityChangeEventType(EventTarget e) {\n    if (JS('bool', '(typeof #.hidden !== \"undefined\")', e)) {\n      // Opera 12.10 and Firefox 18 and later support\n      return 'visibilitychange';\n    } else if (JS('bool', '(typeof #.mozHidden !== \"undefined\")', e)) {\n      return 'mozvisibilitychange';\n    } else if (JS('bool', '(typeof #.msHidden !== \"undefined\")', e)) {\n      return 'msvisibilitychange';\n    } else if (JS('bool', '(typeof #.webkitHidden !== \"undefined\")', e)) {\n      return 'webkitvisibilitychange';\n    }\n    return 'visibilitychange';\n  }\n\n  @SupportedBrowser(SupportedBrowser.CHROME)\n  @SupportedBrowser(SupportedBrowser.FIREFOX)\n  @SupportedBrowser(SupportedBrowser.IE, '10')\n  @Experimental()\n  Stream<Event> get onVisibilityChange =>\n      visibilityChangeEvent.forTarget(this);\n\n  /// Creates an element upgrader which can be used to change the Dart wrapper\n  /// type for elements.\n  ///\n  /// The type specified must be a subclass of HtmlElement, when an element is\n  /// upgraded then the created constructor will be invoked on that element.\n  ///\n  /// If the type is not a direct subclass of HtmlElement then the extendsTag\n  /// parameter must be provided.\n  @Experimental()\n  ElementUpgrader createElementUpgrader(Type type, {String extendsTag}) {\n    return new _JSElementUpgrader(this, type, extendsTag);\n  }\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('HTMLFormControlsCollection')\n@Native(\"HTMLFormControlsCollection\")\nclass HtmlFormControlsCollection extends HtmlCollection {\n  // To suppress missing implicit constructor warnings.\n  factory HtmlFormControlsCollection._() { throw new UnsupportedError(\"Not supported\"); }\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('HTMLHtmlElement')\n@Native(\"HTMLHtmlElement\")\nclass HtmlHtmlElement extends HtmlElement {\n  // To suppress missing implicit constructor warnings.\n  factory HtmlHtmlElement._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('HTMLHtmlElement.HTMLHtmlElement')\n  @DocsEditable()\n  factory HtmlHtmlElement() => document.createElement(\"html\");\n  /**\n   * Constructor instantiated by the DOM when a custom element has been created.\n   *\n   * This can only be called by subclasses from their created constructor.\n   */\n  HtmlHtmlElement.created() : super.created();\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('HTMLOptionsCollection')\n@Native(\"HTMLOptionsCollection\")\nclass HtmlOptionsCollection extends HtmlCollection {\n  // To suppress missing implicit constructor warnings.\n  factory HtmlOptionsCollection._() { throw new UnsupportedError(\"Not supported\"); }\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n /**\n  * A client-side XHR request for getting data from a URL,\n  * formally known as XMLHttpRequest.\n  *\n  * HttpRequest can be used to obtain data from HTTP and FTP protocols,\n  * and is useful for AJAX-style page updates.\n  *\n  * The simplest way to get the contents of a text file, such as a\n  * JSON-formatted file, is with [getString].\n  * For example, the following code gets the contents of a JSON file\n  * and prints its length:\n  *\n  *     var path = 'myData.json';\n  *     HttpRequest.getString(path)\n  *         .then((String fileContents) {\n  *           print(fileContents.length);\n  *         })\n  *         .catchError((Error error) {\n  *           print(error.toString());\n  *         });\n  *\n  * ## Fetching data from other servers\n  *\n  * For security reasons, browsers impose restrictions on requests\n  * made by embedded apps.\n  * With the default behavior of this class,\n  * the code making the request must be served from the same origin\n  * (domain name, port, and application layer protocol)\n  * as the requested resource.\n  * In the example above, the myData.json file must be co-located with the\n  * app that uses it.\n  * You might be able to\n  * [get around this restriction](http://www.dartlang.org/articles/json-web-service/#a-note-on-cors-and-httprequest)\n  * by using CORS headers or JSONP.\n  *\n  * ## Other resources\n  *\n  * * [Fetch Data Dynamically](https://www.dartlang.org/docs/tutorials/fetchdata/),\n  * a tutorial from _A Game of Darts_,\n  * shows two different ways to use HttpRequest to get a JSON file.\n  * * [Get Input from a Form](https://www.dartlang.org/docs/tutorials/forms/),\n  * another tutorial from _A Game of Darts_,\n  * shows using HttpRequest with a custom server.\n  * * [Dart article on using HttpRequests](http://www.dartlang.org/articles/json-web-service/#getting-data)\n  * * [JS XMLHttpRequest](https://developer.mozilla.org/en-US/docs/DOM/XMLHttpRequest)\n  * * [Using XMLHttpRequest](https://developer.mozilla.org/en-US/docs/DOM/XMLHttpRequest/Using_XMLHttpRequest)\n */\n@DomName('XMLHttpRequest')\n@Native(\"XMLHttpRequest\")\nclass HttpRequest extends HttpRequestEventTarget {\n\n  /**\n   * Creates a GET request for the specified [url].\n   *\n   * The server response must be a `text/` mime type for this request to\n   * succeed.\n   *\n   * This is similar to [request] but specialized for HTTP GET requests which\n   * return text content.\n   *\n   * To add query parameters, append them to the [url] following a `?`,\n   * joining each key to its value with `=` and separating key-value pairs with\n   * `&`.\n   *\n   *     var name = Uri.encodeQueryComponent('John');\n   *     var id = Uri.encodeQueryComponent('42');\n   *     HttpRequest.getString('users.json?name=$name&id=$id')\n   *       .then((HttpRequest resp) {\n   *         // Do something with the response.\n   *     });\n   *\n   * See also:\n   *\n   * * [request]\n   */\n  static Future<String> getString(String url,\n      {bool withCredentials, void onProgress(ProgressEvent e)}) {\n    return request(url, withCredentials: withCredentials,\n        onProgress: onProgress).then((xhr) => xhr.responseText);\n  }\n\n  /**\n   * Makes a server POST request with the specified data encoded as form data.\n   *\n   * This is roughly the POST equivalent of getString. This method is similar\n   * to sending a FormData object with broader browser support but limited to\n   * String values.\n   *\n   * If [data] is supplied, the key/value pairs are URI encoded with\n   * [Uri.encodeQueryComponent] and converted into an HTTP query string.\n   *\n   * Unless otherwise specified, this method appends the following header:\n   *\n   *     Content-Type: application/x-www-form-urlencoded; charset=UTF-8\n   *\n   * Here's an example of using this method:\n   *\n   *     var data = { 'firstName' : 'John', 'lastName' : 'Doe' };\n   *     HttpRequest.postFormData('/send', data).then((HttpRequest resp) {\n   *       // Do something with the response.\n   *     });\n   *\n   * See also:\n   *\n   * * [request]\n   */\n  static Future<HttpRequest> postFormData(String url, Map<String, String> data,\n      {bool withCredentials, String responseType,\n      Map<String, String> requestHeaders,\n      void onProgress(ProgressEvent e)}) {\n\n    var parts = [];\n    data.forEach((key, value) {\n      parts.add('${Uri.encodeQueryComponent(key)}='\n          '${Uri.encodeQueryComponent(value)}');\n    });\n    var formData = parts.join('&');\n\n    if (requestHeaders == null) {\n      requestHeaders = <String, String>{};\n    }\n    requestHeaders.putIfAbsent('Content-Type',\n        () => 'application/x-www-form-urlencoded; charset=UTF-8');\n\n    return request(url, method: 'POST', withCredentials: withCredentials,\n        responseType: responseType,\n        requestHeaders: requestHeaders, sendData: formData,\n        onProgress: onProgress);\n  }\n\n  /**\n   * Creates and sends a URL request for the specified [url].\n   *\n   * By default `request` will perform an HTTP GET request, but a different\n   * method (`POST`, `PUT`, `DELETE`, etc) can be used by specifying the\n   * [method] parameter. (See also [HttpRequest.postFormData] for `POST` \n   * requests only.\n   *\n   * The Future is completed when the response is available.\n   *\n   * If specified, `sendData` will send data in the form of a [ByteBuffer],\n   * [Blob], [Document], [String], or [FormData] along with the HttpRequest.\n   *\n   * If specified, [responseType] sets the desired response format for the\n   * request. By default it is [String], but can also be 'arraybuffer', 'blob', \n   * 'document', 'json', or 'text'. See also [HttpRequest.responseType] \n   * for more information.\n   *\n   * The [withCredentials] parameter specified that credentials such as a cookie\n   * (already) set in the header or\n   * [authorization headers](http://tools.ietf.org/html/rfc1945#section-10.2)\n   * should be specified for the request. Details to keep in mind when using\n   * credentials:\n   *\n   * * Using credentials is only useful for cross-origin requests.\n   * * The `Access-Control-Allow-Origin` header of `url` cannot contain a wildcard (*).\n   * * The `Access-Control-Allow-Credentials` header of `url` must be set to true.\n   * * If `Access-Control-Expose-Headers` has not been set to true, only a subset of all the response headers will be returned when calling [getAllRequestHeaders].\n   *\n   * The following is equivalent to the [getString] sample above:\n   *\n   *     var name = Uri.encodeQueryComponent('John');\n   *     var id = Uri.encodeQueryComponent('42');\n   *     HttpRequest.request('users.json?name=$name&id=$id')\n   *       .then((HttpRequest resp) {\n   *         // Do something with the response.\n   *     });\n   *\n   * Here's an example of submitting an entire form with [FormData].\n   *\n   *     var myForm = querySelector('form#myForm');\n   *     var data = new FormData(myForm);\n   *     HttpRequest.request('/submit', method: 'POST', sendData: data)\n   *       .then((HttpRequest resp) {\n   *         // Do something with the response.\n   *     });\n   *\n   * Note that requests for file:// URIs are only supported by Chrome extensions\n   * with appropriate permissions in their manifest. Requests to file:// URIs\n   * will also never fail- the Future will always complete successfully, even\n   * when the file cannot be found.\n   *\n   * See also: [authorization headers](http://en.wikipedia.org/wiki/Basic_access_authentication).\n   */\n  static Future<HttpRequest> request(String url,\n      {String method, bool withCredentials, String responseType,\n      String mimeType, Map<String, String> requestHeaders, sendData,\n      void onProgress(ProgressEvent e)}) {\n    var completer = new Completer<HttpRequest>();\n\n    var xhr = new HttpRequest();\n    if (method == null) {\n      method = 'GET';\n    }\n    xhr.open(method, url, async: true);\n\n    if (withCredentials != null) {\n      xhr.withCredentials = withCredentials;\n    }\n\n    if (responseType != null) {\n      xhr.responseType = responseType;\n    }\n\n    if (mimeType != null) {\n      xhr.overrideMimeType(mimeType);\n    }\n\n    if (requestHeaders != null) {\n      requestHeaders.forEach((header, value) {\n        xhr.setRequestHeader(header, value);\n      });\n    }\n\n    if (onProgress != null) {\n      xhr.onProgress.listen(onProgress);\n    }\n\n    xhr.onLoad.listen((e) {\n      // Note: file:// URIs have status of 0.\n      if ((xhr.status >= 200 && xhr.status < 300) ||\n          xhr.status == 0 || xhr.status == 304) {\n        completer.complete(xhr);\n      } else {\n        completer.completeError(e);\n      }\n    });\n\n    xhr.onError.listen(completer.completeError);\n\n    if (sendData != null) {\n      xhr.send(sendData);\n    } else {\n      xhr.send();\n    }\n\n    return completer.future;\n  }\n\n  /**\n   * Checks to see if the Progress event is supported on the current platform.\n   */\n  static bool get supportsProgressEvent {\n    var xhr = new HttpRequest();\n    return JS('bool', '(\"onprogress\" in #)', xhr);\n  }\n\n  /**\n   * Checks to see if the current platform supports making cross origin\n   * requests.\n   *\n   * Note that even if cross origin requests are supported, they still may fail\n   * if the destination server does not support CORS requests.\n   */\n  static bool get supportsCrossOrigin {\n    var xhr = new HttpRequest();\n    return JS('bool', '(\"withCredentials\" in #)', xhr);\n  }\n\n  /**\n   * Checks to see if the LoadEnd event is supported on the current platform.\n   */\n  static bool get supportsLoadEndEvent {\n    var xhr = new HttpRequest();\n    return JS('bool', '(\"onloadend\" in #)', xhr);\n  }\n\n  /**\n   * Checks to see if the overrideMimeType method is supported on the current\n   * platform.\n   */\n  static bool get supportsOverrideMimeType {\n    var xhr = new HttpRequest();\n    return JS('bool', '(\"overrideMimeType\" in #)', xhr);\n  }\n\n  /**\n   * Makes a cross-origin request to the specified URL.\n   *\n   * This API provides a subset of [request] which works on IE9. If IE9\n   * cross-origin support is not required then [request] should be used instead.\n   */\n  @Experimental()\n  static Future<String> requestCrossOrigin(String url,\n      {String method, String sendData}) {\n    if (supportsCrossOrigin) {\n      return request(url, method: method, sendData: sendData).then((xhr) {\n        return xhr.responseText;\n      });\n    }\n    var completer = new Completer<String>();\n    if (method == null) {\n      method = 'GET';\n    }\n    var xhr = JS('var', 'new XDomainRequest()');\n    JS('', '#.open(#, #)', xhr, method, url);\n    JS('', '#.onload = #', xhr, convertDartClosureToJS((e) {\n      var response = JS('String', '#.responseText', xhr);\n      completer.complete(response);\n    }, 1));\n    JS('', '#.onerror = #', xhr, convertDartClosureToJS((e) {\n      completer.completeError(e);\n    }, 1));\n\n    // IE9 RTM - XDomainRequest issued requests may abort if all event handlers\n    // not specified\n    // http://social.msdn.microsoft.com/Forums/ie/en-US/30ef3add-767c-4436-b8a9-f1ca19b4812e/ie9-rtm-xdomainrequest-issued-requests-may-abort-if-all-event-handlers-not-specified\n    JS('', '#.onprogress = {}', xhr);\n    JS('', '#.ontimeout = {}', xhr);\n    JS('', '#.timeout = Number.MAX_VALUE', xhr);\n\n    if (sendData != null) {\n      JS('', '#.send(#)', xhr, sendData);\n    } else {\n      JS('', '#.send()', xhr);\n    }\n\n    return completer.future;\n  }\n\n  /**\n   * Returns all response headers as a key-value map.\n   *\n   * Multiple values for the same header key can be combined into one,\n   * separated by a comma and a space.\n   *\n   * See: http://www.w3.org/TR/XMLHttpRequest/#the-getresponseheader()-method\n   */\n  Map<String, String> get responseHeaders {\n    // from Closure's goog.net.Xhrio.getResponseHeaders.\n    var headers = <String, String>{};\n    var headersString = this.getAllResponseHeaders();\n    if (headersString == null) {\n      return headers;\n    }\n    var headersList = headersString.split('\\r\\n');\n    for (var header in headersList) {\n      if (header.isEmpty) {\n        continue;\n      }\n\n      var splitIdx = header.indexOf(': ');\n      if (splitIdx == -1) {\n        continue;\n      }\n      var key = header.substring(0, splitIdx).toLowerCase();\n      var value = header.substring(splitIdx + 2);\n      if (headers.containsKey(key)) {\n        headers[key] = '${headers[key]}, $value';\n      } else {\n        headers[key] = value;\n      }\n    }\n    return headers;\n  }\n\n  // To suppress missing implicit constructor warnings.\n  factory HttpRequest._() { throw new UnsupportedError(\"Not supported\"); }\n\n  /**\n   * Static factory designed to expose `readystatechange` events to event\n   * handlers that are not necessarily instances of [HttpRequest].\n   *\n   * See [EventStreamProvider] for usage information.\n   */\n  @DomName('XMLHttpRequest.readystatechangeEvent')\n  @DocsEditable()\n  static const EventStreamProvider<ProgressEvent> readyStateChangeEvent = const EventStreamProvider<ProgressEvent>('readystatechange');\n\n  /**\n   * General constructor for any type of request (GET, POST, etc).\n   *\n   * This call is used in conjunction with [open]:\n   *\n   *     var request = new HttpRequest();\n   *     request.open('GET', 'http://dartlang.org');\n   *     request.onLoad.listen((event) => print(\n   *         'Request complete ${event.target.reponseText}'));\n   *     request.send();\n   *\n   * is the (more verbose) equivalent of\n   *\n   *     HttpRequest.getString('http://dartlang.org').then(\n   *         (result) => print('Request complete: $result'));\n   */\n  @DomName('XMLHttpRequest.XMLHttpRequest')\n  @DocsEditable()\n  factory HttpRequest() {\n    return HttpRequest._create_1();\n  }\n  static HttpRequest _create_1() => JS('HttpRequest', 'new XMLHttpRequest()');\n\n  @DomName('XMLHttpRequest.DONE')\n  @DocsEditable()\n  static const int DONE = 4;\n\n  @DomName('XMLHttpRequest.HEADERS_RECEIVED')\n  @DocsEditable()\n  static const int HEADERS_RECEIVED = 2;\n\n  @DomName('XMLHttpRequest.LOADING')\n  @DocsEditable()\n  static const int LOADING = 3;\n\n  @DomName('XMLHttpRequest.OPENED')\n  @DocsEditable()\n  static const int OPENED = 1;\n\n  @DomName('XMLHttpRequest.UNSENT')\n  @DocsEditable()\n  static const int UNSENT = 0;\n\n  /**\n   * Indicator of the current state of the request:\n   *\n   * <table>\n   *   <tr>\n   *     <td>Value</td>\n   *     <td>State</td>\n   *     <td>Meaning</td>\n   *   </tr>\n   *   <tr>\n   *     <td>0</td>\n   *     <td>unsent</td>\n   *     <td><code>open()</code> has not yet been called</td>\n   *   </tr>\n   *   <tr>\n   *     <td>1</td>\n   *     <td>opened</td>\n   *     <td><code>send()</code> has not yet been called</td>\n   *   </tr>\n   *   <tr>\n   *     <td>2</td>\n   *     <td>headers received</td>\n   *     <td><code>sent()</code> has been called; response headers and <code>status</code> are available</td>\n   *   </tr>\n   *   <tr>\n   *     <td>3</td> <td>loading</td> <td><code>responseText</code> holds some data</td>\n   *   </tr>\n   *   <tr>\n   *     <td>4</td> <td>done</td> <td>request is complete</td>\n   *   </tr>\n   * </table>\n   */\n  @DomName('XMLHttpRequest.readyState')\n  @DocsEditable()\n  final int readyState;\n\n  /**\n   * The data received as a reponse from the request.\n   *\n   * The data could be in the\n   * form of a [String], [ByteBuffer], [Document], [Blob], or json (also a\n   * [String]). `null` indicates request failure.\n   */\n  @DomName('XMLHttpRequest.response')\n  @DocsEditable()\n  @SupportedBrowser(SupportedBrowser.CHROME)\n  @SupportedBrowser(SupportedBrowser.FIREFOX)\n  @SupportedBrowser(SupportedBrowser.IE, '10')\n  @SupportedBrowser(SupportedBrowser.SAFARI)\n  dynamic get response => _convertNativeToDart_XHR_Response(this._get_response);\n  @JSName('response')\n  /**\n   * The data received as a reponse from the request.\n   *\n   * The data could be in the\n   * form of a [String], [ByteBuffer], [Document], [Blob], or json (also a\n   * [String]). `null` indicates request failure.\n   */\n  @DomName('XMLHttpRequest.response')\n  @DocsEditable()\n  @SupportedBrowser(SupportedBrowser.CHROME)\n  @SupportedBrowser(SupportedBrowser.FIREFOX)\n  @SupportedBrowser(SupportedBrowser.IE, '10')\n  @SupportedBrowser(SupportedBrowser.SAFARI)\n  @Creates('NativeByteBuffer|Blob|Document|=Object|JSExtendableArray|String|num')\n  final dynamic _get_response;\n\n  /**\n   * The response in String form or empty String on failure.\n   */\n  @DomName('XMLHttpRequest.responseText')\n  @DocsEditable()\n  final String responseText;\n\n  /**\n   * [String] telling the server the desired response format.\n   *\n   * Default is `String`.\n   * Other options are one of 'arraybuffer', 'blob', 'document', 'json',\n   * 'text'. Some newer browsers will throw NS_ERROR_DOM_INVALID_ACCESS_ERR if\n   * `responseType` is set while performing a synchronous request.\n   *\n   * See also: [MDN responseType](https://developer.mozilla.org/en-US/docs/DOM/XMLHttpRequest#responseType)\n   */\n  @DomName('XMLHttpRequest.responseType')\n  @DocsEditable()\n  String responseType;\n\n  @JSName('responseXML')\n  /**\n   * The request response, or null on failure.\n   *\n   * The response is processed as\n   * `text/xml` stream, unless responseType = 'document' and the request is\n   * synchronous.\n   */\n  @DomName('XMLHttpRequest.responseXML')\n  @DocsEditable()\n  final Document responseXml;\n\n  /**\n   * The http result code from the request (200, 404, etc).\n   * See also: [Http Status Codes](http://en.wikipedia.org/wiki/List_of_HTTP_status_codes)\n   */\n  @DomName('XMLHttpRequest.status')\n  @DocsEditable()\n  final int status;\n\n  /**\n   * The request response string (such as \\\"200 OK\\\").\n   * See also: [Http Status Codes](http://en.wikipedia.org/wiki/List_of_HTTP_status_codes)\n   */\n  @DomName('XMLHttpRequest.statusText')\n  @DocsEditable()\n  final String statusText;\n\n  /**\n   * Length of time before a request is automatically terminated.\n   *\n   * When the time has passed, a [TimeoutEvent] is dispatched.\n   *\n   * If [timeout] is set to 0, then the request will not time out.\n   *\n   * ## Other resources\n   *\n   * * [XMLHttpRequest.timeout]\n   * (https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest#timeout)\n   * from MDN.\n   * * [The timeout attribute]\n   * (http://www.w3.org/TR/XMLHttpRequest/#the-timeout-attribute)\n   * from W3C.\n   */\n  @DomName('XMLHttpRequest.timeout')\n  @DocsEditable()\n  @Experimental() // untriaged\n  int timeout;\n\n  /**\n   * [EventTarget] that can hold listeners to track the progress of the request.\n   * The events fired will be members of [HttpRequestUploadEvents].\n   */\n  @DomName('XMLHttpRequest.upload')\n  @DocsEditable()\n  @Unstable()\n  final HttpRequestUpload upload;\n\n  /**\n   * True if cross-site requests should use credentials such as cookies\n   * or authorization headers; false otherwise.\n   *\n   * This value is ignored for same-site requests.\n   */\n  @DomName('XMLHttpRequest.withCredentials')\n  @DocsEditable()\n  bool withCredentials;\n\n  /**\n   * Stop the current request.\n   *\n   * The request can only be stopped if readyState is `HEADERS_RECIEVED` or\n   * `LOADING`. If this method is not in the process of being sent, the method\n   * has no effect.\n   */\n  @DomName('XMLHttpRequest.abort')\n  @DocsEditable()\n  void abort() native;\n\n  /**\n   * Retrieve all the response headers from a request.\n   *\n   * `null` if no headers have been received. For multipart requests,\n   * `getAllResponseHeaders` will return the response headers for the current\n   * part of the request.\n   *\n   * See also [HTTP response headers](http://en.wikipedia.org/wiki/List_of_HTTP_header_fields#Responses)\n   * for a list of common response headers.\n   */\n  @DomName('XMLHttpRequest.getAllResponseHeaders')\n  @DocsEditable()\n  @Unstable()\n  String getAllResponseHeaders() native;\n\n  /**\n   * Return the response header named `header`, or null if not found.\n   *\n   * See also [HTTP response headers](http://en.wikipedia.org/wiki/List_of_HTTP_header_fields#Responses)\n   * for a list of common response headers.\n   */\n  @DomName('XMLHttpRequest.getResponseHeader')\n  @DocsEditable()\n  @Unstable()\n  String getResponseHeader(String header) native;\n\n  /**\n   * Specify the desired `url`, and `method` to use in making the request.\n   *\n   * By default the request is done asyncronously, with no user or password\n   * authentication information. If `async` is false, the request will be send\n   * synchronously.\n   *\n   * Calling `open` again on a currently active request is equivalent to\n   * calling `abort`.\n   *\n   * Note: Most simple HTTP requests can be accomplished using the [getString],\n   * [request], [requestCrossOrigin], or [postFormData] methods. Use of this\n   * `open` method is intended only for more complext HTTP requests where\n   * finer-grained control is needed.\n   */\n  @DomName('XMLHttpRequest.open')\n  @DocsEditable()\n  void open(String method, String url, {bool async, String user, String password}) native;\n\n  /**\n   * Specify a particular MIME type (such as `text/xml`) desired for the\n   * response.\n   *\n   * This value must be set before the request has been sent. See also the list\n   * of [common MIME types](http://en.wikipedia.org/wiki/Internet_media_type#List_of_common_media_types)\n   */\n  @DomName('XMLHttpRequest.overrideMimeType')\n  @DocsEditable()\n  @SupportedBrowser(SupportedBrowser.CHROME)\n  @SupportedBrowser(SupportedBrowser.FIREFOX)\n  @SupportedBrowser(SupportedBrowser.SAFARI)\n  void overrideMimeType(String override) native;\n\n  /**\n   * Send the request with any given `data`.\n   *\n   * Note: Most simple HTTP requests can be accomplished using the [getString],\n   * [request], [requestCrossOrigin], or [postFormData] methods. Use of this\n   * `send` method is intended only for more complext HTTP requests where\n   * finer-grained control is needed.\n   *\n   * ## Other resources\n   *\n   * * [XMLHttpRequest.send]\n   * (https://developer.mozilla.org/en-US/docs/DOM/XMLHttpRequest#send%28%29)\n   * from MDN.\n   */\n  @DomName('XMLHttpRequest.send')\n  @DocsEditable()\n  void send([data]) native;\n\n  /**\n   * Sets the value of an HTTP requst header.\n   *\n   * This method should be called after the request is opened, but before\n   * the request is sent.\n   *\n   * Multiple calls with the same header will combine all their values into a\n   * single header.\n   *\n   * ## Other resources\n   *\n   * * [XMLHttpRequest.setRequestHeader]\n   * (https://developer.mozilla.org/en-US/docs/DOM/XMLHttpRequest#send%28%29)\n   * from MDN.\n   * * [The setRequestHeader() method]\n   * (http://www.w3.org/TR/XMLHttpRequest/#the-setrequestheader()-method) from\n   * W3C.\n   */\n  @DomName('XMLHttpRequest.setRequestHeader')\n  @DocsEditable()\n  void setRequestHeader(String header, String value) native;\n\n  /// Stream of `readystatechange` events handled by this [HttpRequest].\n/**\n   * Event listeners to be notified every time the [HttpRequest]\n   * object's `readyState` changes values.\n   */\n  @DomName('XMLHttpRequest.onreadystatechange')\n  @DocsEditable()\n  Stream<ProgressEvent> get onReadyStateChange => readyStateChangeEvent.forTarget(this);\n\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('XMLHttpRequestEventTarget')\n@Experimental() // untriaged\n@Native(\"XMLHttpRequestEventTarget\")\nclass HttpRequestEventTarget extends EventTarget {\n  // To suppress missing implicit constructor warnings.\n  factory HttpRequestEventTarget._() { throw new UnsupportedError(\"Not supported\"); }\n\n  /**\n   * Static factory designed to expose `abort` events to event\n   * handlers that are not necessarily instances of [HttpRequestEventTarget].\n   *\n   * See [EventStreamProvider] for usage information.\n   */\n  @DomName('XMLHttpRequestEventTarget.abortEvent')\n  @DocsEditable()\n  @Experimental() // untriaged\n  static const EventStreamProvider<ProgressEvent> abortEvent = const EventStreamProvider<ProgressEvent>('abort');\n\n  /**\n   * Static factory designed to expose `error` events to event\n   * handlers that are not necessarily instances of [HttpRequestEventTarget].\n   *\n   * See [EventStreamProvider] for usage information.\n   */\n  @DomName('XMLHttpRequestEventTarget.errorEvent')\n  @DocsEditable()\n  @Experimental() // untriaged\n  static const EventStreamProvider<ProgressEvent> errorEvent = const EventStreamProvider<ProgressEvent>('error');\n\n  /**\n   * Static factory designed to expose `load` events to event\n   * handlers that are not necessarily instances of [HttpRequestEventTarget].\n   *\n   * See [EventStreamProvider] for usage information.\n   */\n  @DomName('XMLHttpRequestEventTarget.loadEvent')\n  @DocsEditable()\n  @Experimental() // untriaged\n  static const EventStreamProvider<ProgressEvent> loadEvent = const EventStreamProvider<ProgressEvent>('load');\n\n  /**\n   * Static factory designed to expose `loadend` events to event\n   * handlers that are not necessarily instances of [HttpRequestEventTarget].\n   *\n   * See [EventStreamProvider] for usage information.\n   */\n  @DomName('XMLHttpRequestEventTarget.loadendEvent')\n  @DocsEditable()\n  @Experimental() // untriaged\n  static const EventStreamProvider<ProgressEvent> loadEndEvent = const EventStreamProvider<ProgressEvent>('loadend');\n\n  /**\n   * Static factory designed to expose `loadstart` events to event\n   * handlers that are not necessarily instances of [HttpRequestEventTarget].\n   *\n   * See [EventStreamProvider] for usage information.\n   */\n  @DomName('XMLHttpRequestEventTarget.loadstartEvent')\n  @DocsEditable()\n  @Experimental() // untriaged\n  static const EventStreamProvider<ProgressEvent> loadStartEvent = const EventStreamProvider<ProgressEvent>('loadstart');\n\n  /**\n   * Static factory designed to expose `progress` events to event\n   * handlers that are not necessarily instances of [HttpRequestEventTarget].\n   *\n   * See [EventStreamProvider] for usage information.\n   */\n  @DomName('XMLHttpRequestEventTarget.progressEvent')\n  @DocsEditable()\n  @Experimental() // untriaged\n  static const EventStreamProvider<ProgressEvent> progressEvent = const EventStreamProvider<ProgressEvent>('progress');\n\n  /**\n   * Static factory designed to expose `timeout` events to event\n   * handlers that are not necessarily instances of [HttpRequestEventTarget].\n   *\n   * See [EventStreamProvider] for usage information.\n   */\n  @DomName('XMLHttpRequestEventTarget.timeoutEvent')\n  @DocsEditable()\n  @Experimental() // untriaged\n  static const EventStreamProvider<ProgressEvent> timeoutEvent = const EventStreamProvider<ProgressEvent>('timeout');\n\n  /// Stream of `abort` events handled by this [HttpRequestEventTarget].\n  @DomName('XMLHttpRequestEventTarget.onabort')\n  @DocsEditable()\n  @Experimental() // untriaged\n  Stream<ProgressEvent> get onAbort => abortEvent.forTarget(this);\n\n  /// Stream of `error` events handled by this [HttpRequestEventTarget].\n  @DomName('XMLHttpRequestEventTarget.onerror')\n  @DocsEditable()\n  @Experimental() // untriaged\n  Stream<ProgressEvent> get onError => errorEvent.forTarget(this);\n\n  /// Stream of `load` events handled by this [HttpRequestEventTarget].\n  @DomName('XMLHttpRequestEventTarget.onload')\n  @DocsEditable()\n  @Experimental() // untriaged\n  Stream<ProgressEvent> get onLoad => loadEvent.forTarget(this);\n\n  /// Stream of `loadend` events handled by this [HttpRequestEventTarget].\n  @DomName('XMLHttpRequestEventTarget.onloadend')\n  @DocsEditable()\n  @SupportedBrowser(SupportedBrowser.CHROME)\n  @SupportedBrowser(SupportedBrowser.FIREFOX)\n  @SupportedBrowser(SupportedBrowser.IE, '10')\n  @SupportedBrowser(SupportedBrowser.SAFARI)\n  @Experimental() // untriaged\n  Stream<ProgressEvent> get onLoadEnd => loadEndEvent.forTarget(this);\n\n  /// Stream of `loadstart` events handled by this [HttpRequestEventTarget].\n  @DomName('XMLHttpRequestEventTarget.onloadstart')\n  @DocsEditable()\n  @Experimental() // untriaged\n  Stream<ProgressEvent> get onLoadStart => loadStartEvent.forTarget(this);\n\n  /// Stream of `progress` events handled by this [HttpRequestEventTarget].\n  @DomName('XMLHttpRequestEventTarget.onprogress')\n  @DocsEditable()\n  @SupportedBrowser(SupportedBrowser.CHROME)\n  @SupportedBrowser(SupportedBrowser.FIREFOX)\n  @SupportedBrowser(SupportedBrowser.IE, '10')\n  @SupportedBrowser(SupportedBrowser.SAFARI)\n  @Experimental() // untriaged\n  Stream<ProgressEvent> get onProgress => progressEvent.forTarget(this);\n\n  /// Stream of `timeout` events handled by this [HttpRequestEventTarget].\n  @DomName('XMLHttpRequestEventTarget.ontimeout')\n  @DocsEditable()\n  @Experimental() // untriaged\n  Stream<ProgressEvent> get onTimeout => timeoutEvent.forTarget(this);\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('XMLHttpRequestUpload')\n// http://xhr.spec.whatwg.org/#xmlhttprequestupload\n@Experimental()\n@Native(\"XMLHttpRequestUpload\")\nclass HttpRequestUpload extends HttpRequestEventTarget {\n  // To suppress missing implicit constructor warnings.\n  factory HttpRequestUpload._() { throw new UnsupportedError(\"Not supported\"); }\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('HTMLIFrameElement')\n@Native(\"HTMLIFrameElement\")\nclass IFrameElement extends HtmlElement {\n  // To suppress missing implicit constructor warnings.\n  factory IFrameElement._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('HTMLIFrameElement.HTMLIFrameElement')\n  @DocsEditable()\n  factory IFrameElement() => document.createElement(\"iframe\");\n  /**\n   * Constructor instantiated by the DOM when a custom element has been created.\n   *\n   * This can only be called by subclasses from their created constructor.\n   */\n  IFrameElement.created() : super.created();\n\n  @DomName('HTMLIFrameElement.contentWindow')\n  @DocsEditable()\n  WindowBase get contentWindow => _convertNativeToDart_Window(this._get_contentWindow);\n  @JSName('contentWindow')\n  @DomName('HTMLIFrameElement.contentWindow')\n  @DocsEditable()\n  @Creates('Window|=Object')\n  @Returns('Window|=Object')\n  final dynamic _get_contentWindow;\n\n  @DomName('HTMLIFrameElement.height')\n  @DocsEditable()\n  String height;\n\n  @DomName('HTMLIFrameElement.name')\n  @DocsEditable()\n  String name;\n\n  @DomName('HTMLIFrameElement.sandbox')\n  @DocsEditable()\n  String sandbox;\n\n  @DomName('HTMLIFrameElement.src')\n  @DocsEditable()\n  String src;\n\n  @DomName('HTMLIFrameElement.srcdoc')\n  @DocsEditable()\n  String srcdoc;\n\n  @DomName('HTMLIFrameElement.width')\n  @DocsEditable()\n  String width;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('ImageBitmap')\n@Experimental() // untriaged\n@Native(\"ImageBitmap\")\nclass ImageBitmap extends Interceptor {\n  // To suppress missing implicit constructor warnings.\n  factory ImageBitmap._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('ImageBitmap.height')\n  @DocsEditable()\n  @Experimental() // untriaged\n  final int height;\n\n  @DomName('ImageBitmap.width')\n  @DocsEditable()\n  @Experimental() // untriaged\n  final int width;\n}\n// Copyright (c) 2013, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n@DomName('ImageData')\n@Native(\"ImageData\")\nclass ImageData extends Interceptor {\n\n  // To suppress missing implicit constructor warnings.\n  factory ImageData._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('ImageData.data')\n  @DocsEditable()\n  @Creates('NativeUint8ClampedList')\n  @Returns('NativeUint8ClampedList')\n  final List<int> data;\n\n  @DomName('ImageData.height')\n  @DocsEditable()\n  final int height;\n\n  @DomName('ImageData.width')\n  @DocsEditable()\n  final int width;\n\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DomName('HTMLImageElement')\n@Native(\"HTMLImageElement\")\nclass ImageElement extends HtmlElement implements CanvasImageSource {\n  // To suppress missing implicit constructor warnings.\n  factory ImageElement._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('HTMLImageElement.HTMLImageElement')\n  @DocsEditable()\n  factory ImageElement({String src, int width, int height}) {\n    var e = document.createElement(\"img\");\n    if (src != null) e.src = src;\n    if (width != null) e.width = width;\n    if (height != null) e.height = height;\n    return e;\n  }\n  /**\n   * Constructor instantiated by the DOM when a custom element has been created.\n   *\n   * This can only be called by subclasses from their created constructor.\n   */\n  ImageElement.created() : super.created();\n\n  @DomName('HTMLImageElement.alt')\n  @DocsEditable()\n  String alt;\n\n  @DomName('HTMLImageElement.complete')\n  @DocsEditable()\n  final bool complete;\n\n  @DomName('HTMLImageElement.crossOrigin')\n  @DocsEditable()\n  String crossOrigin;\n\n  @DomName('HTMLImageElement.height')\n  @DocsEditable()\n  int height;\n\n  @DomName('HTMLImageElement.isMap')\n  @DocsEditable()\n  bool isMap;\n\n  @DomName('HTMLImageElement.naturalHeight')\n  @DocsEditable()\n  final int naturalHeight;\n\n  @DomName('HTMLImageElement.naturalWidth')\n  @DocsEditable()\n  final int naturalWidth;\n\n  @DomName('HTMLImageElement.src')\n  @DocsEditable()\n  String src;\n\n  @DomName('HTMLImageElement.srcset')\n  @DocsEditable()\n  @Experimental() // untriaged\n  String srcset;\n\n  @DomName('HTMLImageElement.useMap')\n  @DocsEditable()\n  String useMap;\n\n  @DomName('HTMLImageElement.width')\n  @DocsEditable()\n  int width;\n\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('InjectedScriptHost')\n@Experimental() // untriaged\n@Native(\"InjectedScriptHost\")\nclass InjectedScriptHost extends Interceptor {\n  // To suppress missing implicit constructor warnings.\n  factory InjectedScriptHost._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('InjectedScriptHost.inspect')\n  @DocsEditable()\n  @Experimental() // untriaged\n  void inspect(Object objectId, Object hints) native;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DomName('HTMLInputElement')\n@Native(\"HTMLInputElement\")\nclass InputElement extends HtmlElement implements\n    HiddenInputElement,\n    SearchInputElement,\n    TextInputElement,\n    UrlInputElement,\n    TelephoneInputElement,\n    EmailInputElement,\n    PasswordInputElement,\n    DateInputElement,\n    MonthInputElement,\n    WeekInputElement,\n    TimeInputElement,\n    LocalDateTimeInputElement,\n    NumberInputElement,\n    RangeInputElement,\n    CheckboxInputElement,\n    RadioButtonInputElement,\n    FileUploadInputElement,\n    SubmitButtonInputElement,\n    ImageButtonInputElement,\n    ResetButtonInputElement,\n    ButtonInputElement {\n\n  factory InputElement({String type}) {\n    var e = document.createElement(\"input\");\n    if (type != null) {\n      try {\n        // IE throws an exception for unknown types.\n        e.type = type;\n      } catch(_) {}\n    }\n    return e;\n  }\n\n  // To suppress missing implicit constructor warnings.\n  factory InputElement._() { throw new UnsupportedError(\"Not supported\"); }\n\n  /**\n   * Static factory designed to expose `speechchange` events to event\n   * handlers that are not necessarily instances of [InputElement].\n   *\n   * See [EventStreamProvider] for usage information.\n   */\n  @DomName('HTMLInputElement.webkitSpeechChangeEvent')\n  @DocsEditable()\n  @SupportedBrowser(SupportedBrowser.CHROME)\n  @SupportedBrowser(SupportedBrowser.SAFARI)\n  @Experimental()\n  // http://lists.w3.org/Archives/Public/public-xg-htmlspeech/2011Feb/att-0020/api-draft.html#extending_html_elements\n  static const EventStreamProvider<Event> speechChangeEvent = const EventStreamProvider<Event>('webkitSpeechChange');\n  /**\n   * Constructor instantiated by the DOM when a custom element has been created.\n   *\n   * This can only be called by subclasses from their created constructor.\n   */\n  InputElement.created() : super.created();\n\n  @DomName('HTMLInputElement.accept')\n  @DocsEditable()\n  String accept;\n\n  @DomName('HTMLInputElement.alt')\n  @DocsEditable()\n  String alt;\n\n  @DomName('HTMLInputElement.autocomplete')\n  @DocsEditable()\n  String autocomplete;\n\n  @DomName('HTMLInputElement.autofocus')\n  @DocsEditable()\n  bool autofocus;\n\n  @DomName('HTMLInputElement.checked')\n  @DocsEditable()\n  bool checked;\n\n  @DomName('HTMLInputElement.defaultChecked')\n  @DocsEditable()\n  bool defaultChecked;\n\n  @DomName('HTMLInputElement.defaultValue')\n  @DocsEditable()\n  String defaultValue;\n\n  @DomName('HTMLInputElement.dirName')\n  @DocsEditable()\n  String dirName;\n\n  @DomName('HTMLInputElement.disabled')\n  @DocsEditable()\n  bool disabled;\n\n  @DomName('HTMLInputElement.files')\n  @DocsEditable()\n  @Returns('FileList')\n  @Creates('FileList')\n  List<File> files;\n\n  @DomName('HTMLInputElement.form')\n  @DocsEditable()\n  final FormElement form;\n\n  @DomName('HTMLInputElement.formAction')\n  @DocsEditable()\n  String formAction;\n\n  @DomName('HTMLInputElement.formEnctype')\n  @DocsEditable()\n  String formEnctype;\n\n  @DomName('HTMLInputElement.formMethod')\n  @DocsEditable()\n  String formMethod;\n\n  @DomName('HTMLInputElement.formNoValidate')\n  @DocsEditable()\n  bool formNoValidate;\n\n  @DomName('HTMLInputElement.formTarget')\n  @DocsEditable()\n  String formTarget;\n\n  @DomName('HTMLInputElement.height')\n  @DocsEditable()\n  int height;\n\n  @DomName('HTMLInputElement.incremental')\n  @DocsEditable()\n  // http://www.w3.org/TR/html-markup/input.search.html\n  @Experimental()\n  bool incremental;\n\n  @DomName('HTMLInputElement.indeterminate')\n  @DocsEditable()\n  bool indeterminate;\n\n  @DomName('HTMLInputElement.inputMode')\n  @DocsEditable()\n  @Experimental() // untriaged\n  String inputMode;\n\n  @DomName('HTMLInputElement.labels')\n  @DocsEditable()\n  @Returns('NodeList')\n  @Creates('NodeList')\n  final List<Node> labels;\n\n  @DomName('HTMLInputElement.list')\n  @DocsEditable()\n  final HtmlElement list;\n\n  @DomName('HTMLInputElement.max')\n  @DocsEditable()\n  String max;\n\n  @DomName('HTMLInputElement.maxLength')\n  @DocsEditable()\n  int maxLength;\n\n  @DomName('HTMLInputElement.min')\n  @DocsEditable()\n  String min;\n\n  @DomName('HTMLInputElement.multiple')\n  @DocsEditable()\n  bool multiple;\n\n  @DomName('HTMLInputElement.name')\n  @DocsEditable()\n  String name;\n\n  @DomName('HTMLInputElement.pattern')\n  @DocsEditable()\n  String pattern;\n\n  @DomName('HTMLInputElement.placeholder')\n  @DocsEditable()\n  String placeholder;\n\n  @DomName('HTMLInputElement.readOnly')\n  @DocsEditable()\n  bool readOnly;\n\n  @DomName('HTMLInputElement.required')\n  @DocsEditable()\n  bool required;\n\n  @DomName('HTMLInputElement.selectionDirection')\n  @DocsEditable()\n  String selectionDirection;\n\n  @DomName('HTMLInputElement.selectionEnd')\n  @DocsEditable()\n  int selectionEnd;\n\n  @DomName('HTMLInputElement.selectionStart')\n  @DocsEditable()\n  int selectionStart;\n\n  @DomName('HTMLInputElement.size')\n  @DocsEditable()\n  int size;\n\n  @DomName('HTMLInputElement.src')\n  @DocsEditable()\n  String src;\n\n  @DomName('HTMLInputElement.step')\n  @DocsEditable()\n  String step;\n\n  @DomName('HTMLInputElement.type')\n  @DocsEditable()\n  String type;\n\n  @DomName('HTMLInputElement.validationMessage')\n  @DocsEditable()\n  final String validationMessage;\n\n  @DomName('HTMLInputElement.validity')\n  @DocsEditable()\n  final ValidityState validity;\n\n  @DomName('HTMLInputElement.value')\n  @DocsEditable()\n  String value;\n\n  @DomName('HTMLInputElement.valueAsDate')\n  @DocsEditable()\n  DateTime get valueAsDate => convertNativeToDart_DateTime(this._get_valueAsDate);\n  @JSName('valueAsDate')\n  @DomName('HTMLInputElement.valueAsDate')\n  @DocsEditable()\n  @Creates('Null')\n  final dynamic _get_valueAsDate;\n\n  void set valueAsDate(DateTime value) {\n    this._set_valueAsDate = convertDartToNative_DateTime(value);\n  }\n  void set _set_valueAsDate(/*dynamic*/ value) {\n    JS(\"void\", \"#.valueAsDate = #\", this, value);\n  }\n\n  @DomName('HTMLInputElement.valueAsNumber')\n  @DocsEditable()\n  num valueAsNumber;\n\n  @JSName('webkitEntries')\n  @DomName('HTMLInputElement.webkitEntries')\n  @DocsEditable()\n  @SupportedBrowser(SupportedBrowser.CHROME)\n  @SupportedBrowser(SupportedBrowser.SAFARI)\n  @Experimental()\n  // http://www.whatwg.org/specs/web-apps/current-work/multipage/states-of-the-type-attribute.html#concept-input-type-file-selected\n  final List<Entry> entries;\n\n  @JSName('webkitdirectory')\n  @DomName('HTMLInputElement.webkitdirectory')\n  @DocsEditable()\n  @SupportedBrowser(SupportedBrowser.CHROME)\n  @SupportedBrowser(SupportedBrowser.SAFARI)\n  @Experimental()\n  // https://plus.sandbox.google.com/+AddyOsmani/posts/Dk5UhZ6zfF3\n  bool directory;\n\n  @DomName('HTMLInputElement.width')\n  @DocsEditable()\n  int width;\n\n  @DomName('HTMLInputElement.willValidate')\n  @DocsEditable()\n  final bool willValidate;\n\n  @DomName('HTMLInputElement.checkValidity')\n  @DocsEditable()\n  bool checkValidity() native;\n\n  @DomName('HTMLInputElement.select')\n  @DocsEditable()\n  void select() native;\n\n  @DomName('HTMLInputElement.setCustomValidity')\n  @DocsEditable()\n  void setCustomValidity(String error) native;\n\n  @DomName('HTMLInputElement.setRangeText')\n  @DocsEditable()\n  // http://www.whatwg.org/specs/web-apps/current-work/multipage/association-of-controls-and-forms.html#dom-textarea/input-setrangetext\n  @Experimental() // experimental\n  void setRangeText(String replacement, {int start, int end, String selectionMode}) native;\n\n  @DomName('HTMLInputElement.setSelectionRange')\n  @DocsEditable()\n  void setSelectionRange(int start, int end, [String direction]) native;\n\n  @DomName('HTMLInputElement.stepDown')\n  @DocsEditable()\n  void stepDown([int n]) native;\n\n  @DomName('HTMLInputElement.stepUp')\n  @DocsEditable()\n  void stepUp([int n]) native;\n\n  /// Stream of `speechchange` events handled by this [InputElement].\n  @DomName('HTMLInputElement.onwebkitSpeechChange')\n  @DocsEditable()\n  // http://lists.w3.org/Archives/Public/public-xg-htmlspeech/2011Feb/att-0020/api-draft.html#extending_html_elements\n  @Experimental()\n  ElementStream<Event> get onSpeechChange => speechChangeEvent.forElement(this);\n\n}\n\n\n// Interfaces representing the InputElement APIs which are supported\n// for the various types of InputElement. From:\n// http://www.w3.org/html/wg/drafts/html/master/forms.html#the-input-element.\n\n/**\n * Exposes the functionality common between all InputElement types.\n */\nabstract class InputElementBase implements Element {\n  @DomName('HTMLInputElement.autofocus')\n  bool autofocus;\n\n  @DomName('HTMLInputElement.disabled')\n  bool disabled;\n\n  @DomName('HTMLInputElement.incremental')\n  bool incremental;\n\n  @DomName('HTMLInputElement.indeterminate')\n  bool indeterminate;\n\n  @DomName('HTMLInputElement.labels')\n  List<Node> get labels;\n\n  @DomName('HTMLInputElement.name')\n  String name;\n\n  @DomName('HTMLInputElement.validationMessage')\n  String get validationMessage;\n\n  @DomName('HTMLInputElement.validity')\n  ValidityState get validity;\n\n  @DomName('HTMLInputElement.value')\n  String value;\n\n  @DomName('HTMLInputElement.willValidate')\n  bool get willValidate;\n\n  @DomName('HTMLInputElement.checkValidity')\n  bool checkValidity();\n\n  @DomName('HTMLInputElement.setCustomValidity')\n  void setCustomValidity(String error);\n}\n\n/**\n * Hidden input which is not intended to be seen or edited by the user.\n */\nabstract class HiddenInputElement implements InputElementBase {\n  factory HiddenInputElement() => new InputElement(type: 'hidden');\n}\n\n\n/**\n * Base interface for all inputs which involve text editing.\n */\nabstract class TextInputElementBase implements InputElementBase {\n  @DomName('HTMLInputElement.autocomplete')\n  String autocomplete;\n\n  @DomName('HTMLInputElement.maxLength')\n  int maxLength;\n\n  @DomName('HTMLInputElement.pattern')\n  String pattern;\n\n  @DomName('HTMLInputElement.placeholder')\n  String placeholder;\n\n  @DomName('HTMLInputElement.readOnly')\n  bool readOnly;\n\n  @DomName('HTMLInputElement.required')\n  bool required;\n\n  @DomName('HTMLInputElement.size')\n  int size;\n\n  @DomName('HTMLInputElement.select')\n  void select();\n\n  @DomName('HTMLInputElement.selectionDirection')\n  String selectionDirection;\n\n  @DomName('HTMLInputElement.selectionEnd')\n  int selectionEnd;\n\n  @DomName('HTMLInputElement.selectionStart')\n  int selectionStart;\n\n  @DomName('HTMLInputElement.setSelectionRange')\n  void setSelectionRange(int start, int end, [String direction]);\n}\n\n/**\n * Similar to [TextInputElement], but on platforms where search is styled\n * differently this will get the search style.\n *\n * Use [supported] to check if this is supported on the current platform.\n */\n@SupportedBrowser(SupportedBrowser.CHROME)\n@SupportedBrowser(SupportedBrowser.FIREFOX)\n@SupportedBrowser(SupportedBrowser.IE, '10')\n@SupportedBrowser(SupportedBrowser.SAFARI)\nabstract class SearchInputElement implements TextInputElementBase {\n  factory SearchInputElement() => new InputElement(type: 'search');\n\n  @DomName('HTMLInputElement.dirName')\n  String dirName;\n\n  @DomName('HTMLInputElement.list')\n  Element get list;\n\n  /// Returns true if this input type is supported on the current platform.\n  static bool get supported {\n    return (new InputElement(type: 'search')).type == 'search';\n  }\n}\n\n/**\n * A basic text input editor control.\n */\nabstract class TextInputElement implements TextInputElementBase {\n  factory TextInputElement() => new InputElement(type: 'text');\n\n  @DomName('HTMLInputElement.dirName')\n  String dirName;\n\n  @DomName('HTMLInputElement.list')\n  Element get list;\n}\n\n/**\n * A control for editing an absolute URL.\n *\n * Use [supported] to check if this is supported on the current platform.\n */\n@SupportedBrowser(SupportedBrowser.CHROME)\n@SupportedBrowser(SupportedBrowser.FIREFOX)\n@SupportedBrowser(SupportedBrowser.IE, '10')\n@SupportedBrowser(SupportedBrowser.SAFARI)\nabstract class UrlInputElement implements TextInputElementBase {\n  factory UrlInputElement() => new InputElement(type: 'url');\n\n  @DomName('HTMLInputElement.list')\n  Element get list;\n\n  /// Returns true if this input type is supported on the current platform.\n  static bool get supported {\n    return (new InputElement(type: 'url')).type == 'url';\n  }\n}\n\n/**\n * Represents a control for editing a telephone number.\n *\n * This provides a single line of text with minimal formatting help since\n * there is a wide variety of telephone numbers.\n *\n * Use [supported] to check if this is supported on the current platform.\n */\n@SupportedBrowser(SupportedBrowser.CHROME)\n@SupportedBrowser(SupportedBrowser.FIREFOX)\n@SupportedBrowser(SupportedBrowser.IE, '10')\n@SupportedBrowser(SupportedBrowser.SAFARI)\nabstract class TelephoneInputElement implements TextInputElementBase {\n  factory TelephoneInputElement() => new InputElement(type: 'tel');\n\n  @DomName('HTMLInputElement.list')\n  Element get list;\n\n  /// Returns true if this input type is supported on the current platform.\n  static bool get supported {\n    return (new InputElement(type: 'tel')).type == 'tel';\n  }\n}\n\n/**\n * An e-mail address or list of e-mail addresses.\n *\n * Use [supported] to check if this is supported on the current platform.\n */\n@SupportedBrowser(SupportedBrowser.CHROME)\n@SupportedBrowser(SupportedBrowser.FIREFOX)\n@SupportedBrowser(SupportedBrowser.IE, '10')\n@SupportedBrowser(SupportedBrowser.SAFARI)\nabstract class EmailInputElement implements TextInputElementBase {\n  factory EmailInputElement() => new InputElement(type: 'email');\n\n  @DomName('HTMLInputElement.autocomplete')\n  String autocomplete;\n\n  @DomName('HTMLInputElement.autofocus')\n  bool autofocus;\n\n  @DomName('HTMLInputElement.list')\n  Element get list;\n\n  @DomName('HTMLInputElement.maxLength')\n  int maxLength;\n\n  @DomName('HTMLInputElement.multiple')\n  bool multiple;\n\n  @DomName('HTMLInputElement.pattern')\n  String pattern;\n\n  @DomName('HTMLInputElement.placeholder')\n  String placeholder;\n\n  @DomName('HTMLInputElement.readOnly')\n  bool readOnly;\n\n  @DomName('HTMLInputElement.required')\n  bool required;\n\n  @DomName('HTMLInputElement.size')\n  int size;\n\n  /// Returns true if this input type is supported on the current platform.\n  static bool get supported {\n    return (new InputElement(type: 'email')).type == 'email';\n  }\n}\n\n/**\n * Text with no line breaks (sensitive information).\n */\nabstract class PasswordInputElement implements TextInputElementBase {\n  factory PasswordInputElement() => new InputElement(type: 'password');\n}\n\n/**\n * Base interface for all input element types which involve ranges.\n */\nabstract class RangeInputElementBase implements InputElementBase {\n\n  @DomName('HTMLInputElement.list')\n  Element get list;\n\n  @DomName('HTMLInputElement.max')\n  String max;\n\n  @DomName('HTMLInputElement.min')\n  String min;\n\n  @DomName('HTMLInputElement.step')\n  String step;\n\n  @DomName('HTMLInputElement.valueAsNumber')\n  num valueAsNumber;\n\n  @DomName('HTMLInputElement.stepDown')\n  void stepDown([int n]);\n\n  @DomName('HTMLInputElement.stepUp')\n  void stepUp([int n]);\n}\n\n/**\n * A date (year, month, day) with no time zone.\n *\n * Use [supported] to check if this is supported on the current platform.\n */\n@SupportedBrowser(SupportedBrowser.CHROME, '25')\n@Experimental()\nabstract class DateInputElement implements RangeInputElementBase {\n  factory DateInputElement() => new InputElement(type: 'date');\n\n  @DomName('HTMLInputElement.valueAsDate')\n  DateTime valueAsDate;\n\n  @DomName('HTMLInputElement.readOnly')\n  bool readOnly;\n\n  @DomName('HTMLInputElement.required')\n  bool required;\n\n  /// Returns true if this input type is supported on the current platform.\n  static bool get supported {\n    return (new InputElement(type: 'date')).type == 'date';\n  }\n}\n\n/**\n * A date consisting of a year and a month with no time zone.\n *\n * Use [supported] to check if this is supported on the current platform.\n */\n@SupportedBrowser(SupportedBrowser.CHROME, '25')\n@Experimental()\nabstract class MonthInputElement implements RangeInputElementBase {\n  factory MonthInputElement() => new InputElement(type: 'month');\n\n  @DomName('HTMLInputElement.valueAsDate')\n  DateTime valueAsDate;\n\n  @DomName('HTMLInputElement.readOnly')\n  bool readOnly;\n\n  @DomName('HTMLInputElement.required')\n  bool required;\n\n  /// Returns true if this input type is supported on the current platform.\n  static bool get supported {\n    return (new InputElement(type: 'month')).type == 'month';\n  }\n}\n\n/**\n * A date consisting of a week-year number and a week number with no time zone.\n *\n * Use [supported] to check if this is supported on the current platform.\n */\n@SupportedBrowser(SupportedBrowser.CHROME, '25')\n@Experimental()\nabstract class WeekInputElement implements RangeInputElementBase {\n  factory WeekInputElement() => new InputElement(type: 'week');\n\n  @DomName('HTMLInputElement.valueAsDate')\n  DateTime valueAsDate;\n\n  @DomName('HTMLInputElement.readOnly')\n  bool readOnly;\n\n  @DomName('HTMLInputElement.required')\n  bool required;\n\n  /// Returns true if this input type is supported on the current platform.\n  static bool get supported {\n    return (new InputElement(type: 'week')).type == 'week';\n  }\n}\n\n/**\n * A time (hour, minute, seconds, fractional seconds) with no time zone.\n *\n * Use [supported] to check if this is supported on the current platform.\n */\n@SupportedBrowser(SupportedBrowser.CHROME)\n@Experimental()\nabstract class TimeInputElement implements RangeInputElementBase {\n  factory TimeInputElement() => new InputElement(type: 'time');\n\n  @DomName('HTMLInputElement.valueAsDate')\n  DateTime valueAsDate;\n\n  @DomName('HTMLInputElement.readOnly')\n  bool readOnly;\n\n  @DomName('HTMLInputElement.required')\n  bool required;\n\n  /// Returns true if this input type is supported on the current platform.\n  static bool get supported {\n    return (new InputElement(type: 'time')).type == 'time';\n  }\n}\n\n/**\n * A date and time (year, month, day, hour, minute, second, fraction of a\n * second) with no time zone.\n *\n * Use [supported] to check if this is supported on the current platform.\n */\n@SupportedBrowser(SupportedBrowser.CHROME, '25')\n@Experimental()\nabstract class LocalDateTimeInputElement implements RangeInputElementBase {\n  factory LocalDateTimeInputElement() =>\n      new InputElement(type: 'datetime-local');\n\n  @DomName('HTMLInputElement.readOnly')\n  bool readOnly;\n\n  @DomName('HTMLInputElement.required')\n  bool required;\n\n  /// Returns true if this input type is supported on the current platform.\n  static bool get supported {\n    return (new InputElement(type: 'datetime-local')).type == 'datetime-local';\n  }\n}\n\n/**\n * A numeric editor control.\n */\n@SupportedBrowser(SupportedBrowser.CHROME)\n@SupportedBrowser(SupportedBrowser.IE)\n@SupportedBrowser(SupportedBrowser.SAFARI)\n@Experimental()\nabstract class NumberInputElement implements RangeInputElementBase {\n  factory NumberInputElement() => new InputElement(type: 'number');\n\n  @DomName('HTMLInputElement.placeholder')\n  String placeholder;\n\n  @DomName('HTMLInputElement.readOnly')\n  bool readOnly;\n\n  @DomName('HTMLInputElement.required')\n  bool required;\n\n  /// Returns true if this input type is supported on the current platform.\n  static bool get supported {\n    return (new InputElement(type: 'number')).type == 'number';\n  }\n}\n\n/**\n * Similar to [NumberInputElement] but the browser may provide more optimal\n * styling (such as a slider control).\n *\n * Use [supported] to check if this is supported on the current platform.\n */\n@SupportedBrowser(SupportedBrowser.CHROME)\n@SupportedBrowser(SupportedBrowser.IE, '10')\n@Experimental()\nabstract class RangeInputElement implements RangeInputElementBase {\n  factory RangeInputElement() => new InputElement(type: 'range');\n\n  /// Returns true if this input type is supported on the current platform.\n  static bool get supported {\n    return (new InputElement(type: 'range')).type == 'range';\n  }\n}\n\n/**\n * A boolean editor control.\n *\n * Note that if [indeterminate] is set then this control is in a third\n * indeterminate state.\n */\nabstract class CheckboxInputElement implements InputElementBase {\n  factory CheckboxInputElement() => new InputElement(type: 'checkbox');\n\n  @DomName('HTMLInputElement.checked')\n  bool checked;\n\n  @DomName('HTMLInputElement.required')\n  bool required;\n}\n\n\n/**\n * A control that when used with other [ReadioButtonInputElement] controls\n * forms a radio button group in which only one control can be checked at a\n * time.\n *\n * Radio buttons are considered to be in the same radio button group if:\n *\n * * They are all of type 'radio'.\n * * They all have either the same [FormElement] owner, or no owner.\n * * Their name attributes contain the same name.\n */\nabstract class RadioButtonInputElement implements InputElementBase {\n  factory RadioButtonInputElement() => new InputElement(type: 'radio');\n\n  @DomName('HTMLInputElement.checked')\n  bool checked;\n\n  @DomName('HTMLInputElement.required')\n  bool required;\n}\n\n/**\n * A control for picking files from the user's computer.\n */\nabstract class FileUploadInputElement implements InputElementBase {\n  factory FileUploadInputElement() => new InputElement(type: 'file');\n\n  @DomName('HTMLInputElement.accept')\n  String accept;\n\n  @DomName('HTMLInputElement.multiple')\n  bool multiple;\n\n  @DomName('HTMLInputElement.required')\n  bool required;\n\n  @DomName('HTMLInputElement.files')\n  List<File> files;\n}\n\n/**\n * A button, which when clicked, submits the form.\n */\nabstract class SubmitButtonInputElement implements InputElementBase {\n  factory SubmitButtonInputElement() => new InputElement(type: 'submit');\n\n  @DomName('HTMLInputElement.formAction')\n  String formAction;\n\n  @DomName('HTMLInputElement.formEnctype')\n  String formEnctype;\n\n  @DomName('HTMLInputElement.formMethod')\n  String formMethod;\n\n  @DomName('HTMLInputElement.formNoValidate')\n  bool formNoValidate;\n\n  @DomName('HTMLInputElement.formTarget')\n  String formTarget;\n}\n\n/**\n * Either an image which the user can select a coordinate to or a form\n * submit button.\n */\nabstract class ImageButtonInputElement implements InputElementBase {\n  factory ImageButtonInputElement() => new InputElement(type: 'image');\n\n  @DomName('HTMLInputElement.alt')\n  String alt;\n\n  @DomName('HTMLInputElement.formAction')\n  String formAction;\n\n  @DomName('HTMLInputElement.formEnctype')\n  String formEnctype;\n\n  @DomName('HTMLInputElement.formMethod')\n  String formMethod;\n\n  @DomName('HTMLInputElement.formNoValidate')\n  bool formNoValidate;\n\n  @DomName('HTMLInputElement.formTarget')\n  String formTarget;\n\n  @DomName('HTMLInputElement.height')\n  int height;\n\n  @DomName('HTMLInputElement.src')\n  String src;\n\n  @DomName('HTMLInputElement.width')\n  int width;\n}\n\n/**\n * A button, which when clicked, resets the form.\n */\nabstract class ResetButtonInputElement implements InputElementBase {\n  factory ResetButtonInputElement() => new InputElement(type: 'reset');\n}\n\n/**\n * A button, with no default behavior.\n */\nabstract class ButtonInputElement implements InputElementBase {\n  factory ButtonInputElement() => new InputElement(type: 'button');\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('InputMethodContext')\n// http://www.w3.org/TR/ime-api/#idl-def-InputMethodContext\n@Experimental()\n@Native(\"InputMethodContext\")\nclass InputMethodContext extends EventTarget {\n  // To suppress missing implicit constructor warnings.\n  factory InputMethodContext._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('InputMethodContext.compositionEndOffset')\n  @DocsEditable()\n  @Experimental() // untriaged\n  final int compositionEndOffset;\n\n  @DomName('InputMethodContext.compositionStartOffset')\n  @DocsEditable()\n  @Experimental() // untriaged\n  final int compositionStartOffset;\n\n  @DomName('InputMethodContext.locale')\n  @DocsEditable()\n  final String locale;\n\n  @DomName('InputMethodContext.target')\n  @DocsEditable()\n  @Experimental() // untriaged\n  final HtmlElement target;\n\n  @DomName('InputMethodContext.confirmComposition')\n  @DocsEditable()\n  void confirmComposition() native;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('InstallEvent')\n@Experimental() // untriaged\n@Native(\"InstallEvent\")\nclass InstallEvent extends InstallPhaseEvent {\n  // To suppress missing implicit constructor warnings.\n  factory InstallEvent._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('InstallEvent.replace')\n  @DocsEditable()\n  @Experimental() // untriaged\n  void replace() native;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('InstallPhaseEvent')\n@Experimental() // untriaged\n@Native(\"InstallPhaseEvent\")\nclass InstallPhaseEvent extends Event {\n  // To suppress missing implicit constructor warnings.\n  factory InstallPhaseEvent._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('InstallPhaseEvent.waitUntil')\n  @DocsEditable()\n  @Experimental() // untriaged\n  void waitUntil(Object value) native;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('KeyPair')\n@Experimental() // untriaged\n@Native(\"KeyPair\")\nclass KeyPair extends Interceptor {\n  // To suppress missing implicit constructor warnings.\n  factory KeyPair._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('KeyPair.privateKey')\n  @DocsEditable()\n  @Experimental() // untriaged\n  final CryptoKey privateKey;\n\n  @DomName('KeyPair.publicKey')\n  @DocsEditable()\n  @Experimental() // untriaged\n  final CryptoKey publicKey;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n/**\n * An event that describes user interaction with the keyboard.\n *\n * The [type] of the event identifies what kind of interaction occurred.\n *\n * See also:\n *\n * * [KeyboardEvent](https://developer.mozilla.org/en/DOM/KeyboardEvent) at MDN.\n */\n@DomName('KeyboardEvent')\n@Native(\"KeyboardEvent\")\nclass KeyboardEvent extends UIEvent {\n\n  /** \n   * Programmatically create a KeyboardEvent. \n   *\n   * Due to browser differences, keyCode, charCode, or keyIdentifier values\n   * cannot be specified in this base level constructor. This constructor\n   * enables the user to programmatically create and dispatch a [KeyboardEvent],\n   * but it will not contain any particular key content. For programmatically\n   * creating keyboard events with specific key value contents, see the custom\n   * Event [KeyEvent]. \n   */\n  factory KeyboardEvent(String type,\n      {Window view, bool canBubble: true, bool cancelable: true,\n      int keyLocation: 1, bool ctrlKey: false,\n      bool altKey: false, bool shiftKey: false, bool metaKey: false,\n      bool altGraphKey: false}) {\n    if (view == null) {\n      view = window;\n    }\n    final e = document._createEvent(\"KeyboardEvent\");\n    e._initKeyboardEvent(type, canBubble, cancelable, view, \"\",\n        keyLocation, ctrlKey, altKey, shiftKey, metaKey, altGraphKey);\n    return e;\n  }\n\n  @DomName('KeyboardEvent.initKeyboardEvent')\n  void _initKeyboardEvent(String type, bool canBubble, bool cancelable,\n      Window view, String keyIdentifier, int keyLocation, bool ctrlKey,\n      bool altKey, bool shiftKey, bool metaKey, bool altGraphKey) {\n    if (JS('bool', 'typeof(#.initKeyEvent) == \"function\"', this)) {\n      // initKeyEvent is only in Firefox (instead of initKeyboardEvent). It has\n      // a slightly different signature, and allows you to specify keyCode and\n      // charCode as the last two arguments, but we just set them as the default\n      // since they can't be specified in other browsers.\n      JS('void', '#.initKeyEvent(#, #, #, #, #, #, #, #, 0, 0)', this,\n          type, canBubble, cancelable, view,\n          ctrlKey, altKey, shiftKey, metaKey);\n    } else {\n      // initKeyboardEvent is for all other browsers.\n      JS('void', '#.initKeyboardEvent(#, #, #, #, #, #, #, #, #, #, #)', this,\n          type, canBubble, cancelable, view, keyIdentifier, keyLocation,\n          ctrlKey, altKey, shiftKey, metaKey, altGraphKey);\n    }\n  }\n\n  @DomName('KeyboardEvent.keyCode')\n  int get keyCode => _keyCode;\n\n  @DomName('KeyboardEvent.charCode')\n  int get charCode => _charCode;\n  // To suppress missing implicit constructor warnings.\n  factory KeyboardEvent._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('KeyboardEvent.DOM_KEY_LOCATION_LEFT')\n  @DocsEditable()\n  @Experimental() // untriaged\n  static const int DOM_KEY_LOCATION_LEFT = 0x01;\n\n  @DomName('KeyboardEvent.DOM_KEY_LOCATION_NUMPAD')\n  @DocsEditable()\n  @Experimental() // untriaged\n  static const int DOM_KEY_LOCATION_NUMPAD = 0x03;\n\n  @DomName('KeyboardEvent.DOM_KEY_LOCATION_RIGHT')\n  @DocsEditable()\n  @Experimental() // untriaged\n  static const int DOM_KEY_LOCATION_RIGHT = 0x02;\n\n  @DomName('KeyboardEvent.DOM_KEY_LOCATION_STANDARD')\n  @DocsEditable()\n  @Experimental() // untriaged\n  static const int DOM_KEY_LOCATION_STANDARD = 0x00;\n\n  @DomName('KeyboardEvent.altGraphKey')\n  @DocsEditable()\n  @Experimental() // nonstandard\n  final bool altGraphKey;\n\n  @DomName('KeyboardEvent.altKey')\n  @DocsEditable()\n  final bool altKey;\n\n  @DomName('KeyboardEvent.ctrlKey')\n  @DocsEditable()\n  final bool ctrlKey;\n\n  @JSName('keyIdentifier')\n  @DomName('KeyboardEvent.keyIdentifier')\n  @DocsEditable()\n  @Experimental() // nonstandard\n  final String _keyIdentifier;\n\n  @DomName('KeyboardEvent.keyLocation')\n  @DocsEditable()\n  @Experimental() // nonstandard\n  final int keyLocation;\n\n  @DomName('KeyboardEvent.location')\n  @DocsEditable()\n  @Experimental() // untriaged\n  final int location;\n\n  @DomName('KeyboardEvent.metaKey')\n  @DocsEditable()\n  final bool metaKey;\n\n  @DomName('KeyboardEvent.repeat')\n  @DocsEditable()\n  @Experimental() // untriaged\n  final bool repeat;\n\n  @DomName('KeyboardEvent.shiftKey')\n  @DocsEditable()\n  final bool shiftKey;\n\n  @DomName('KeyboardEvent.getModifierState')\n  @DocsEditable()\n  @Experimental() // untriaged\n  bool getModifierState(String keyArgument) native;\n\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('HTMLKeygenElement')\n@SupportedBrowser(SupportedBrowser.CHROME)\n@SupportedBrowser(SupportedBrowser.SAFARI)\n@Experimental()\n// http://www.whatwg.org/specs/web-apps/current-work/multipage/the-button-element.html#the-keygen-element\n@Native(\"HTMLKeygenElement\")\nclass KeygenElement extends HtmlElement {\n  // To suppress missing implicit constructor warnings.\n  factory KeygenElement._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('HTMLKeygenElement.HTMLKeygenElement')\n  @DocsEditable()\n  factory KeygenElement() => document.createElement(\"keygen\");\n  /**\n   * Constructor instantiated by the DOM when a custom element has been created.\n   *\n   * This can only be called by subclasses from their created constructor.\n   */\n  KeygenElement.created() : super.created();\n\n  /// Checks if this type is supported on the current platform.\n  static bool get supported => Element.isTagSupported('keygen') && (new Element.tag('keygen') is KeygenElement);\n\n  @DomName('HTMLKeygenElement.autofocus')\n  @DocsEditable()\n  bool autofocus;\n\n  @DomName('HTMLKeygenElement.challenge')\n  @DocsEditable()\n  String challenge;\n\n  @DomName('HTMLKeygenElement.disabled')\n  @DocsEditable()\n  bool disabled;\n\n  @DomName('HTMLKeygenElement.form')\n  @DocsEditable()\n  final FormElement form;\n\n  @DomName('HTMLKeygenElement.keytype')\n  @DocsEditable()\n  String keytype;\n\n  @DomName('HTMLKeygenElement.labels')\n  @DocsEditable()\n  @Unstable()\n  @Returns('NodeList')\n  @Creates('NodeList')\n  final List<Node> labels;\n\n  @DomName('HTMLKeygenElement.name')\n  @DocsEditable()\n  String name;\n\n  @DomName('HTMLKeygenElement.type')\n  @DocsEditable()\n  final String type;\n\n  @DomName('HTMLKeygenElement.validationMessage')\n  @DocsEditable()\n  final String validationMessage;\n\n  @DomName('HTMLKeygenElement.validity')\n  @DocsEditable()\n  final ValidityState validity;\n\n  @DomName('HTMLKeygenElement.willValidate')\n  @DocsEditable()\n  final bool willValidate;\n\n  @DomName('HTMLKeygenElement.checkValidity')\n  @DocsEditable()\n  bool checkValidity() native;\n\n  @DomName('HTMLKeygenElement.setCustomValidity')\n  @DocsEditable()\n  void setCustomValidity(String error) native;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('HTMLLIElement')\n@Native(\"HTMLLIElement\")\nclass LIElement extends HtmlElement {\n  // To suppress missing implicit constructor warnings.\n  factory LIElement._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('HTMLLIElement.HTMLLIElement')\n  @DocsEditable()\n  factory LIElement() => document.createElement(\"li\");\n  /**\n   * Constructor instantiated by the DOM when a custom element has been created.\n   *\n   * This can only be called by subclasses from their created constructor.\n   */\n  LIElement.created() : super.created();\n\n  @DomName('HTMLLIElement.value')\n  @DocsEditable()\n  int value;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('HTMLLabelElement')\n@Native(\"HTMLLabelElement\")\nclass LabelElement extends HtmlElement {\n  // To suppress missing implicit constructor warnings.\n  factory LabelElement._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('HTMLLabelElement.HTMLLabelElement')\n  @DocsEditable()\n  factory LabelElement() => document.createElement(\"label\");\n  /**\n   * Constructor instantiated by the DOM when a custom element has been created.\n   *\n   * This can only be called by subclasses from their created constructor.\n   */\n  LabelElement.created() : super.created();\n\n  @DomName('HTMLLabelElement.control')\n  @DocsEditable()\n  final HtmlElement control;\n\n  @DomName('HTMLLabelElement.form')\n  @DocsEditable()\n  final FormElement form;\n\n  @DomName('HTMLLabelElement.htmlFor')\n  @DocsEditable()\n  String htmlFor;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('HTMLLegendElement')\n@Native(\"HTMLLegendElement\")\nclass LegendElement extends HtmlElement {\n  // To suppress missing implicit constructor warnings.\n  factory LegendElement._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('HTMLLegendElement.HTMLLegendElement')\n  @DocsEditable()\n  factory LegendElement() => document.createElement(\"legend\");\n  /**\n   * Constructor instantiated by the DOM when a custom element has been created.\n   *\n   * This can only be called by subclasses from their created constructor.\n   */\n  LegendElement.created() : super.created();\n\n  @DomName('HTMLLegendElement.form')\n  @DocsEditable()\n  final FormElement form;\n}\n// Copyright (c) 2014, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('HTMLLinkElement')\n@Native(\"HTMLLinkElement\")\nclass LinkElement extends HtmlElement {\n  // To suppress missing implicit constructor warnings.\n  factory LinkElement._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('HTMLLinkElement.HTMLLinkElement')\n  @DocsEditable()\n  factory LinkElement() => document.createElement(\"link\");\n  /**\n   * Constructor instantiated by the DOM when a custom element has been created.\n   *\n   * This can only be called by subclasses from their created constructor.\n   */\n  LinkElement.created() : super.created();\n\n  @DomName('HTMLLinkElement.crossOrigin')\n  @DocsEditable()\n  @Experimental() // untriaged\n  String crossOrigin;\n\n  @DomName('HTMLLinkElement.disabled')\n  @DocsEditable()\n  bool disabled;\n\n  @DomName('HTMLLinkElement.href')\n  @DocsEditable()\n  String href;\n\n  @DomName('HTMLLinkElement.hreflang')\n  @DocsEditable()\n  String hreflang;\n\n  @DomName('HTMLLinkElement.import')\n  @DocsEditable()\n  // https://dvcs.w3.org/hg/webcomponents/raw-file/tip/spec/imports/index.html#interface-import\n  @Experimental()\n  final Document import;\n\n  @DomName('HTMLLinkElement.media')\n  @DocsEditable()\n  String media;\n\n  @DomName('HTMLLinkElement.rel')\n  @DocsEditable()\n  String rel;\n\n  @DomName('HTMLLinkElement.sheet')\n  @DocsEditable()\n  final StyleSheet sheet;\n\n  @DomName('HTMLLinkElement.sizes')\n  @DocsEditable()\n  final DomSettableTokenList sizes;\n\n  @DomName('HTMLLinkElement.type')\n  @DocsEditable()\n  String type;\n\n\n    /// Checks if HTML imports are supported on the current platform.\n  bool get supportsImport {\n    return JS('bool', '(\"import\" in #)', this);\n  }\n}\n// Copyright (c) 2013, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('Location')\n@Native(\"Location\")\nclass Location extends Interceptor implements LocationBase {\n  // To suppress missing implicit constructor warnings.\n  factory Location._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('Location.ancestorOrigins')\n  @DocsEditable()\n  @Experimental() // nonstandard\n  @Returns('DomStringList')\n  @Creates('DomStringList')\n  final List<String> ancestorOrigins;\n\n  @DomName('Location.hash')\n  @DocsEditable()\n  String hash;\n\n  @DomName('Location.host')\n  @DocsEditable()\n  String host;\n\n  @DomName('Location.hostname')\n  @DocsEditable()\n  String hostname;\n\n  @DomName('Location.href')\n  @DocsEditable()\n  String href;\n\n  @DomName('Location.pathname')\n  @DocsEditable()\n  String pathname;\n\n  @DomName('Location.port')\n  @DocsEditable()\n  String port;\n\n  @DomName('Location.protocol')\n  @DocsEditable()\n  String protocol;\n\n  @DomName('Location.search')\n  @DocsEditable()\n  String search;\n\n  @DomName('Location.assign')\n  @DocsEditable()\n  void assign(String url) native;\n\n  @DomName('Location.reload')\n  @DocsEditable()\n  void reload() native;\n\n  @DomName('Location.replace')\n  @DocsEditable()\n  void replace(String url) native;\n\n  @DomName('Location.toString')\n  @DocsEditable()\n  String toString() native;\n\n\n  @DomName('Location.origin')\n  String get origin {\n    if (JS('bool', '(\"origin\" in #)', this)) {\n      return JS('String', '#.origin', this);\n    }\n    return '${this.protocol}//${this.host}';\n  }\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n// WARNING: Do not edit - generated code.\n\n\n@DomName('MIDIErrorCallback')\n// http://webaudio.github.io/web-midi-api/#midierrorcallback\n@Experimental()\ntypedef void MidiErrorCallback(DomError error);\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n// WARNING: Do not edit - generated code.\n\n\n@DomName('MIDISuccessCallback')\n@Experimental() // untriaged\ntypedef void MidiSuccessCallback(MidiAccess access, bool sysex);\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('HTMLMapElement')\n@Native(\"HTMLMapElement\")\nclass MapElement extends HtmlElement {\n  // To suppress missing implicit constructor warnings.\n  factory MapElement._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('HTMLMapElement.HTMLMapElement')\n  @DocsEditable()\n  factory MapElement() => document.createElement(\"map\");\n  /**\n   * Constructor instantiated by the DOM when a custom element has been created.\n   *\n   * This can only be called by subclasses from their created constructor.\n   */\n  MapElement.created() : super.created();\n\n  @DomName('HTMLMapElement.areas')\n  @DocsEditable()\n  @Returns('HtmlCollection')\n  @Creates('HtmlCollection')\n  final List<Node> areas;\n\n  @DomName('HTMLMapElement.name')\n  @DocsEditable()\n  String name;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('MediaController')\n// http://www.whatwg.org/specs/web-apps/current-work/multipage/the-video-element.html#mediacontroller\n@Experimental()\n@Native(\"MediaController\")\nclass MediaController extends EventTarget {\n  // To suppress missing implicit constructor warnings.\n  factory MediaController._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('MediaController.MediaController')\n  @DocsEditable()\n  factory MediaController() {\n    return MediaController._create_1();\n  }\n  static MediaController _create_1() => JS('MediaController', 'new MediaController()');\n\n  @DomName('MediaController.buffered')\n  @DocsEditable()\n  final TimeRanges buffered;\n\n  @DomName('MediaController.currentTime')\n  @DocsEditable()\n  num currentTime;\n\n  @DomName('MediaController.defaultPlaybackRate')\n  @DocsEditable()\n  num defaultPlaybackRate;\n\n  @DomName('MediaController.duration')\n  @DocsEditable()\n  final double duration;\n\n  @DomName('MediaController.muted')\n  @DocsEditable()\n  bool muted;\n\n  @DomName('MediaController.paused')\n  @DocsEditable()\n  final bool paused;\n\n  @DomName('MediaController.playbackRate')\n  @DocsEditable()\n  num playbackRate;\n\n  @DomName('MediaController.playbackState')\n  @DocsEditable()\n  final String playbackState;\n\n  @DomName('MediaController.played')\n  @DocsEditable()\n  final TimeRanges played;\n\n  @DomName('MediaController.seekable')\n  @DocsEditable()\n  final TimeRanges seekable;\n\n  @DomName('MediaController.volume')\n  @DocsEditable()\n  num volume;\n\n  @DomName('MediaController.pause')\n  @DocsEditable()\n  void pause() native;\n\n  @DomName('MediaController.play')\n  @DocsEditable()\n  void play() native;\n\n  @DomName('MediaController.unpause')\n  @DocsEditable()\n  void unpause() native;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('HTMLMediaElement')\n@Unstable()\n@Native(\"HTMLMediaElement\")\nclass MediaElement extends HtmlElement {\n  // To suppress missing implicit constructor warnings.\n  factory MediaElement._() { throw new UnsupportedError(\"Not supported\"); }\n\n  /**\n   * Static factory designed to expose `canplay` events to event\n   * handlers that are not necessarily instances of [MediaElement].\n   *\n   * See [EventStreamProvider] for usage information.\n   */\n  @DomName('HTMLMediaElement.canplayEvent')\n  @DocsEditable()\n  static const EventStreamProvider<Event> canPlayEvent = const EventStreamProvider<Event>('canplay');\n\n  /**\n   * Static factory designed to expose `canplaythrough` events to event\n   * handlers that are not necessarily instances of [MediaElement].\n   *\n   * See [EventStreamProvider] for usage information.\n   */\n  @DomName('HTMLMediaElement.canplaythroughEvent')\n  @DocsEditable()\n  static const EventStreamProvider<Event> canPlayThroughEvent = const EventStreamProvider<Event>('canplaythrough');\n\n  /**\n   * Static factory designed to expose `durationchange` events to event\n   * handlers that are not necessarily instances of [MediaElement].\n   *\n   * See [EventStreamProvider] for usage information.\n   */\n  @DomName('HTMLMediaElement.durationchangeEvent')\n  @DocsEditable()\n  static const EventStreamProvider<Event> durationChangeEvent = const EventStreamProvider<Event>('durationchange');\n\n  /**\n   * Static factory designed to expose `emptied` events to event\n   * handlers that are not necessarily instances of [MediaElement].\n   *\n   * See [EventStreamProvider] for usage information.\n   */\n  @DomName('HTMLMediaElement.emptiedEvent')\n  @DocsEditable()\n  static const EventStreamProvider<Event> emptiedEvent = const EventStreamProvider<Event>('emptied');\n\n  /**\n   * Static factory designed to expose `ended` events to event\n   * handlers that are not necessarily instances of [MediaElement].\n   *\n   * See [EventStreamProvider] for usage information.\n   */\n  @DomName('HTMLMediaElement.endedEvent')\n  @DocsEditable()\n  static const EventStreamProvider<Event> endedEvent = const EventStreamProvider<Event>('ended');\n\n  /**\n   * Static factory designed to expose `loadeddata` events to event\n   * handlers that are not necessarily instances of [MediaElement].\n   *\n   * See [EventStreamProvider] for usage information.\n   */\n  @DomName('HTMLMediaElement.loadeddataEvent')\n  @DocsEditable()\n  static const EventStreamProvider<Event> loadedDataEvent = const EventStreamProvider<Event>('loadeddata');\n\n  /**\n   * Static factory designed to expose `loadedmetadata` events to event\n   * handlers that are not necessarily instances of [MediaElement].\n   *\n   * See [EventStreamProvider] for usage information.\n   */\n  @DomName('HTMLMediaElement.loadedmetadataEvent')\n  @DocsEditable()\n  static const EventStreamProvider<Event> loadedMetadataEvent = const EventStreamProvider<Event>('loadedmetadata');\n\n  /**\n   * Static factory designed to expose `loadstart` events to event\n   * handlers that are not necessarily instances of [MediaElement].\n   *\n   * See [EventStreamProvider] for usage information.\n   */\n  @DomName('HTMLMediaElement.loadstartEvent')\n  @DocsEditable()\n  static const EventStreamProvider<Event> loadStartEvent = const EventStreamProvider<Event>('loadstart');\n\n  /**\n   * Static factory designed to expose `pause` events to event\n   * handlers that are not necessarily instances of [MediaElement].\n   *\n   * See [EventStreamProvider] for usage information.\n   */\n  @DomName('HTMLMediaElement.pauseEvent')\n  @DocsEditable()\n  static const EventStreamProvider<Event> pauseEvent = const EventStreamProvider<Event>('pause');\n\n  /**\n   * Static factory designed to expose `play` events to event\n   * handlers that are not necessarily instances of [MediaElement].\n   *\n   * See [EventStreamProvider] for usage information.\n   */\n  @DomName('HTMLMediaElement.playEvent')\n  @DocsEditable()\n  static const EventStreamProvider<Event> playEvent = const EventStreamProvider<Event>('play');\n\n  /**\n   * Static factory designed to expose `playing` events to event\n   * handlers that are not necessarily instances of [MediaElement].\n   *\n   * See [EventStreamProvider] for usage information.\n   */\n  @DomName('HTMLMediaElement.playingEvent')\n  @DocsEditable()\n  static const EventStreamProvider<Event> playingEvent = const EventStreamProvider<Event>('playing');\n\n  /**\n   * Static factory designed to expose `progress` events to event\n   * handlers that are not necessarily instances of [MediaElement].\n   *\n   * See [EventStreamProvider] for usage information.\n   */\n  @DomName('HTMLMediaElement.progressEvent')\n  @DocsEditable()\n  static const EventStreamProvider<Event> progressEvent = const EventStreamProvider<Event>('progress');\n\n  /**\n   * Static factory designed to expose `ratechange` events to event\n   * handlers that are not necessarily instances of [MediaElement].\n   *\n   * See [EventStreamProvider] for usage information.\n   */\n  @DomName('HTMLMediaElement.ratechangeEvent')\n  @DocsEditable()\n  static const EventStreamProvider<Event> rateChangeEvent = const EventStreamProvider<Event>('ratechange');\n\n  /**\n   * Static factory designed to expose `seeked` events to event\n   * handlers that are not necessarily instances of [MediaElement].\n   *\n   * See [EventStreamProvider] for usage information.\n   */\n  @DomName('HTMLMediaElement.seekedEvent')\n  @DocsEditable()\n  static const EventStreamProvider<Event> seekedEvent = const EventStreamProvider<Event>('seeked');\n\n  /**\n   * Static factory designed to expose `seeking` events to event\n   * handlers that are not necessarily instances of [MediaElement].\n   *\n   * See [EventStreamProvider] for usage information.\n   */\n  @DomName('HTMLMediaElement.seekingEvent')\n  @DocsEditable()\n  static const EventStreamProvider<Event> seekingEvent = const EventStreamProvider<Event>('seeking');\n\n  /**\n   * Static factory designed to expose `show` events to event\n   * handlers that are not necessarily instances of [MediaElement].\n   *\n   * See [EventStreamProvider] for usage information.\n   */\n  @DomName('HTMLMediaElement.showEvent')\n  @DocsEditable()\n  // http://www.whatwg.org/specs/web-apps/current-work/multipage/the-video-element.html#event-media-loadstart\n  @Experimental()\n  static const EventStreamProvider<Event> showEvent = const EventStreamProvider<Event>('show');\n\n  /**\n   * Static factory designed to expose `stalled` events to event\n   * handlers that are not necessarily instances of [MediaElement].\n   *\n   * See [EventStreamProvider] for usage information.\n   */\n  @DomName('HTMLMediaElement.stalledEvent')\n  @DocsEditable()\n  static const EventStreamProvider<Event> stalledEvent = const EventStreamProvider<Event>('stalled');\n\n  /**\n   * Static factory designed to expose `suspend` events to event\n   * handlers that are not necessarily instances of [MediaElement].\n   *\n   * See [EventStreamProvider] for usage information.\n   */\n  @DomName('HTMLMediaElement.suspendEvent')\n  @DocsEditable()\n  static const EventStreamProvider<Event> suspendEvent = const EventStreamProvider<Event>('suspend');\n\n  /**\n   * Static factory designed to expose `timeupdate` events to event\n   * handlers that are not necessarily instances of [MediaElement].\n   *\n   * See [EventStreamProvider] for usage information.\n   */\n  @DomName('HTMLMediaElement.timeupdateEvent')\n  @DocsEditable()\n  static const EventStreamProvider<Event> timeUpdateEvent = const EventStreamProvider<Event>('timeupdate');\n\n  /**\n   * Static factory designed to expose `volumechange` events to event\n   * handlers that are not necessarily instances of [MediaElement].\n   *\n   * See [EventStreamProvider] for usage information.\n   */\n  @DomName('HTMLMediaElement.volumechangeEvent')\n  @DocsEditable()\n  static const EventStreamProvider<Event> volumeChangeEvent = const EventStreamProvider<Event>('volumechange');\n\n  /**\n   * Static factory designed to expose `waiting` events to event\n   * handlers that are not necessarily instances of [MediaElement].\n   *\n   * See [EventStreamProvider] for usage information.\n   */\n  @DomName('HTMLMediaElement.waitingEvent')\n  @DocsEditable()\n  static const EventStreamProvider<Event> waitingEvent = const EventStreamProvider<Event>('waiting');\n\n  /**\n   * Static factory designed to expose `keyadded` events to event\n   * handlers that are not necessarily instances of [MediaElement].\n   *\n   * See [EventStreamProvider] for usage information.\n   */\n  @DomName('HTMLMediaElement.webkitkeyaddedEvent')\n  @DocsEditable()\n  @SupportedBrowser(SupportedBrowser.CHROME)\n  @SupportedBrowser(SupportedBrowser.SAFARI)\n  @Experimental()\n  // https://dvcs.w3.org/hg/html-media/raw-file/eme-v0.1/encrypted-media/encrypted-media.html#dom-keyadded\n  static const EventStreamProvider<MediaKeyEvent> keyAddedEvent = const EventStreamProvider<MediaKeyEvent>('webkitkeyadded');\n\n  /**\n   * Static factory designed to expose `keyerror` events to event\n   * handlers that are not necessarily instances of [MediaElement].\n   *\n   * See [EventStreamProvider] for usage information.\n   */\n  @DomName('HTMLMediaElement.webkitkeyerrorEvent')\n  @DocsEditable()\n  @SupportedBrowser(SupportedBrowser.CHROME)\n  @SupportedBrowser(SupportedBrowser.SAFARI)\n  @Experimental()\n  // https://dvcs.w3.org/hg/html-media/raw-file/eme-v0.1/encrypted-media/encrypted-media.html#dom-keyadded\n  static const EventStreamProvider<MediaKeyEvent> keyErrorEvent = const EventStreamProvider<MediaKeyEvent>('webkitkeyerror');\n\n  /**\n   * Static factory designed to expose `keymessage` events to event\n   * handlers that are not necessarily instances of [MediaElement].\n   *\n   * See [EventStreamProvider] for usage information.\n   */\n  @DomName('HTMLMediaElement.webkitkeymessageEvent')\n  @DocsEditable()\n  @SupportedBrowser(SupportedBrowser.CHROME)\n  @SupportedBrowser(SupportedBrowser.SAFARI)\n  @Experimental()\n  // https://dvcs.w3.org/hg/html-media/raw-file/eme-v0.1/encrypted-media/encrypted-media.html#dom-keyadded\n  static const EventStreamProvider<MediaKeyEvent> keyMessageEvent = const EventStreamProvider<MediaKeyEvent>('webkitkeymessage');\n\n  /**\n   * Static factory designed to expose `needkey` events to event\n   * handlers that are not necessarily instances of [MediaElement].\n   *\n   * See [EventStreamProvider] for usage information.\n   */\n  @DomName('HTMLMediaElement.webkitneedkeyEvent')\n  @DocsEditable()\n  @SupportedBrowser(SupportedBrowser.CHROME)\n  @SupportedBrowser(SupportedBrowser.SAFARI)\n  @Experimental()\n  // https://dvcs.w3.org/hg/html-media/raw-file/eme-v0.1/encrypted-media/encrypted-media.html#dom-keyadded\n  static const EventStreamProvider<MediaKeyEvent> needKeyEvent = const EventStreamProvider<MediaKeyEvent>('webkitneedkey');\n  /**\n   * Constructor instantiated by the DOM when a custom element has been created.\n   *\n   * This can only be called by subclasses from their created constructor.\n   */\n  MediaElement.created() : super.created();\n\n  @DomName('HTMLMediaElement.HAVE_CURRENT_DATA')\n  @DocsEditable()\n  static const int HAVE_CURRENT_DATA = 2;\n\n  @DomName('HTMLMediaElement.HAVE_ENOUGH_DATA')\n  @DocsEditable()\n  static const int HAVE_ENOUGH_DATA = 4;\n\n  @DomName('HTMLMediaElement.HAVE_FUTURE_DATA')\n  @DocsEditable()\n  static const int HAVE_FUTURE_DATA = 3;\n\n  @DomName('HTMLMediaElement.HAVE_METADATA')\n  @DocsEditable()\n  static const int HAVE_METADATA = 1;\n\n  @DomName('HTMLMediaElement.HAVE_NOTHING')\n  @DocsEditable()\n  static const int HAVE_NOTHING = 0;\n\n  @DomName('HTMLMediaElement.NETWORK_EMPTY')\n  @DocsEditable()\n  static const int NETWORK_EMPTY = 0;\n\n  @DomName('HTMLMediaElement.NETWORK_IDLE')\n  @DocsEditable()\n  static const int NETWORK_IDLE = 1;\n\n  @DomName('HTMLMediaElement.NETWORK_LOADING')\n  @DocsEditable()\n  static const int NETWORK_LOADING = 2;\n\n  @DomName('HTMLMediaElement.NETWORK_NO_SOURCE')\n  @DocsEditable()\n  static const int NETWORK_NO_SOURCE = 3;\n\n  @DomName('HTMLMediaElement.autoplay')\n  @DocsEditable()\n  bool autoplay;\n\n  @DomName('HTMLMediaElement.buffered')\n  @DocsEditable()\n  final TimeRanges buffered;\n\n  @DomName('HTMLMediaElement.controller')\n  @DocsEditable()\n  MediaController controller;\n\n  @DomName('HTMLMediaElement.controls')\n  @DocsEditable()\n  bool controls;\n\n  @DomName('HTMLMediaElement.crossOrigin')\n  @DocsEditable()\n  @Experimental() // untriaged\n  String crossOrigin;\n\n  @DomName('HTMLMediaElement.currentSrc')\n  @DocsEditable()\n  final String currentSrc;\n\n  @DomName('HTMLMediaElement.currentTime')\n  @DocsEditable()\n  num currentTime;\n\n  @DomName('HTMLMediaElement.defaultMuted')\n  @DocsEditable()\n  bool defaultMuted;\n\n  @DomName('HTMLMediaElement.defaultPlaybackRate')\n  @DocsEditable()\n  num defaultPlaybackRate;\n\n  @DomName('HTMLMediaElement.duration')\n  @DocsEditable()\n  final double duration;\n\n  @DomName('HTMLMediaElement.ended')\n  @DocsEditable()\n  final bool ended;\n\n  @DomName('HTMLMediaElement.error')\n  @DocsEditable()\n  final MediaError error;\n\n  @DomName('HTMLMediaElement.loop')\n  @DocsEditable()\n  bool loop;\n\n  @DomName('HTMLMediaElement.mediaGroup')\n  @DocsEditable()\n  String mediaGroup;\n\n  @DomName('HTMLMediaElement.mediaKeys')\n  @DocsEditable()\n  // https://dvcs.w3.org/hg/html-media/raw-file/eme-v0.1/encrypted-media/encrypted-media.html\n  @Experimental()\n  final MediaKeys mediaKeys;\n\n  @DomName('HTMLMediaElement.muted')\n  @DocsEditable()\n  bool muted;\n\n  @DomName('HTMLMediaElement.networkState')\n  @DocsEditable()\n  final int networkState;\n\n  @DomName('HTMLMediaElement.paused')\n  @DocsEditable()\n  final bool paused;\n\n  @DomName('HTMLMediaElement.playbackRate')\n  @DocsEditable()\n  num playbackRate;\n\n  @DomName('HTMLMediaElement.played')\n  @DocsEditable()\n  final TimeRanges played;\n\n  @DomName('HTMLMediaElement.preload')\n  @DocsEditable()\n  String preload;\n\n  @DomName('HTMLMediaElement.readyState')\n  @DocsEditable()\n  final int readyState;\n\n  @DomName('HTMLMediaElement.seekable')\n  @DocsEditable()\n  final TimeRanges seekable;\n\n  @DomName('HTMLMediaElement.seeking')\n  @DocsEditable()\n  final bool seeking;\n\n  @DomName('HTMLMediaElement.src')\n  @DocsEditable()\n  String src;\n\n  @DomName('HTMLMediaElement.textTracks')\n  @DocsEditable()\n  // http://www.whatwg.org/specs/web-apps/current-work/multipage/the-video-element.html#dom-media-texttracks\n  @Experimental()\n  final TextTrackList textTracks;\n\n  @DomName('HTMLMediaElement.volume')\n  @DocsEditable()\n  num volume;\n\n  @JSName('webkitAudioDecodedByteCount')\n  @DomName('HTMLMediaElement.webkitAudioDecodedByteCount')\n  @DocsEditable()\n  @SupportedBrowser(SupportedBrowser.CHROME)\n  @SupportedBrowser(SupportedBrowser.SAFARI)\n  @Experimental()\n  @Experimental() // nonstandard\n  final int audioDecodedByteCount;\n\n  @JSName('webkitVideoDecodedByteCount')\n  @DomName('HTMLMediaElement.webkitVideoDecodedByteCount')\n  @DocsEditable()\n  @SupportedBrowser(SupportedBrowser.CHROME)\n  @SupportedBrowser(SupportedBrowser.SAFARI)\n  @Experimental()\n  @Experimental() // nonstandard\n  final int videoDecodedByteCount;\n\n  @DomName('HTMLMediaElement.addTextTrack')\n  @DocsEditable()\n  // http://www.whatwg.org/specs/web-apps/current-work/multipage/the-video-element.html#dom-media-addtexttrack\n  @Experimental()\n  TextTrack addTextTrack(String kind, [String label, String language]) native;\n\n  @DomName('HTMLMediaElement.canPlayType')\n  @DocsEditable()\n  @Unstable()\n  String canPlayType(String type, [String keySystem]) native;\n\n  @DomName('HTMLMediaElement.load')\n  @DocsEditable()\n  void load() native;\n\n  @DomName('HTMLMediaElement.pause')\n  @DocsEditable()\n  void pause() native;\n\n  @DomName('HTMLMediaElement.play')\n  @DocsEditable()\n  void play() native;\n\n  @DomName('HTMLMediaElement.setMediaKeys')\n  @DocsEditable()\n  @Experimental() // untriaged\n  void setMediaKeys(MediaKeys mediaKeys) native;\n\n  @JSName('webkitAddKey')\n  @DomName('HTMLMediaElement.webkitAddKey')\n  @DocsEditable()\n  @SupportedBrowser(SupportedBrowser.CHROME)\n  @SupportedBrowser(SupportedBrowser.SAFARI)\n  @Experimental()\n  // https://dvcs.w3.org/hg/html-media/raw-file/eme-v0.1/encrypted-media/encrypted-media.html#extensions\n  void addKey(String keySystem, Uint8List key, [Uint8List initData, String sessionId]) native;\n\n  @JSName('webkitCancelKeyRequest')\n  @DomName('HTMLMediaElement.webkitCancelKeyRequest')\n  @DocsEditable()\n  @SupportedBrowser(SupportedBrowser.CHROME)\n  @SupportedBrowser(SupportedBrowser.SAFARI)\n  @Experimental()\n  // https://dvcs.w3.org/hg/html-media/raw-file/eme-v0.1/encrypted-media/encrypted-media.html#extensions\n  void cancelKeyRequest(String keySystem, String sessionId) native;\n\n  @JSName('webkitGenerateKeyRequest')\n  @DomName('HTMLMediaElement.webkitGenerateKeyRequest')\n  @DocsEditable()\n  @SupportedBrowser(SupportedBrowser.CHROME)\n  @SupportedBrowser(SupportedBrowser.SAFARI)\n  @Experimental()\n  // https://dvcs.w3.org/hg/html-media/raw-file/eme-v0.1/encrypted-media/encrypted-media.html#extensions\n  void generateKeyRequest(String keySystem, [Uint8List initData]) native;\n\n  /// Stream of `canplay` events handled by this [MediaElement].\n  @DomName('HTMLMediaElement.oncanplay')\n  @DocsEditable()\n  ElementStream<Event> get onCanPlay => canPlayEvent.forElement(this);\n\n  /// Stream of `canplaythrough` events handled by this [MediaElement].\n  @DomName('HTMLMediaElement.oncanplaythrough')\n  @DocsEditable()\n  ElementStream<Event> get onCanPlayThrough => canPlayThroughEvent.forElement(this);\n\n  /// Stream of `durationchange` events handled by this [MediaElement].\n  @DomName('HTMLMediaElement.ondurationchange')\n  @DocsEditable()\n  ElementStream<Event> get onDurationChange => durationChangeEvent.forElement(this);\n\n  /// Stream of `emptied` events handled by this [MediaElement].\n  @DomName('HTMLMediaElement.onemptied')\n  @DocsEditable()\n  ElementStream<Event> get onEmptied => emptiedEvent.forElement(this);\n\n  /// Stream of `ended` events handled by this [MediaElement].\n  @DomName('HTMLMediaElement.onended')\n  @DocsEditable()\n  ElementStream<Event> get onEnded => endedEvent.forElement(this);\n\n  /// Stream of `loadeddata` events handled by this [MediaElement].\n  @DomName('HTMLMediaElement.onloadeddata')\n  @DocsEditable()\n  ElementStream<Event> get onLoadedData => loadedDataEvent.forElement(this);\n\n  /// Stream of `loadedmetadata` events handled by this [MediaElement].\n  @DomName('HTMLMediaElement.onloadedmetadata')\n  @DocsEditable()\n  ElementStream<Event> get onLoadedMetadata => loadedMetadataEvent.forElement(this);\n\n  /// Stream of `loadstart` events handled by this [MediaElement].\n  @DomName('HTMLMediaElement.onloadstart')\n  @DocsEditable()\n  ElementStream<Event> get onLoadStart => loadStartEvent.forElement(this);\n\n  /// Stream of `pause` events handled by this [MediaElement].\n  @DomName('HTMLMediaElement.onpause')\n  @DocsEditable()\n  ElementStream<Event> get onPause => pauseEvent.forElement(this);\n\n  /// Stream of `play` events handled by this [MediaElement].\n  @DomName('HTMLMediaElement.onplay')\n  @DocsEditable()\n  ElementStream<Event> get onPlay => playEvent.forElement(this);\n\n  /// Stream of `playing` events handled by this [MediaElement].\n  @DomName('HTMLMediaElement.onplaying')\n  @DocsEditable()\n  ElementStream<Event> get onPlaying => playingEvent.forElement(this);\n\n  /// Stream of `progress` events handled by this [MediaElement].\n  @DomName('HTMLMediaElement.onprogress')\n  @DocsEditable()\n  ElementStream<Event> get onProgress => progressEvent.forElement(this);\n\n  /// Stream of `ratechange` events handled by this [MediaElement].\n  @DomName('HTMLMediaElement.onratechange')\n  @DocsEditable()\n  ElementStream<Event> get onRateChange => rateChangeEvent.forElement(this);\n\n  /// Stream of `seeked` events handled by this [MediaElement].\n  @DomName('HTMLMediaElement.onseeked')\n  @DocsEditable()\n  ElementStream<Event> get onSeeked => seekedEvent.forElement(this);\n\n  /// Stream of `seeking` events handled by this [MediaElement].\n  @DomName('HTMLMediaElement.onseeking')\n  @DocsEditable()\n  ElementStream<Event> get onSeeking => seekingEvent.forElement(this);\n\n  /// Stream of `show` events handled by this [MediaElement].\n  @DomName('HTMLMediaElement.onshow')\n  @DocsEditable()\n  // http://www.whatwg.org/specs/web-apps/current-work/multipage/the-video-element.html#event-media-loadstart\n  @Experimental()\n  ElementStream<Event> get onShow => showEvent.forElement(this);\n\n  /// Stream of `stalled` events handled by this [MediaElement].\n  @DomName('HTMLMediaElement.onstalled')\n  @DocsEditable()\n  ElementStream<Event> get onStalled => stalledEvent.forElement(this);\n\n  /// Stream of `suspend` events handled by this [MediaElement].\n  @DomName('HTMLMediaElement.onsuspend')\n  @DocsEditable()\n  ElementStream<Event> get onSuspend => suspendEvent.forElement(this);\n\n  /// Stream of `timeupdate` events handled by this [MediaElement].\n  @DomName('HTMLMediaElement.ontimeupdate')\n  @DocsEditable()\n  ElementStream<Event> get onTimeUpdate => timeUpdateEvent.forElement(this);\n\n  /// Stream of `volumechange` events handled by this [MediaElement].\n  @DomName('HTMLMediaElement.onvolumechange')\n  @DocsEditable()\n  ElementStream<Event> get onVolumeChange => volumeChangeEvent.forElement(this);\n\n  /// Stream of `waiting` events handled by this [MediaElement].\n  @DomName('HTMLMediaElement.onwaiting')\n  @DocsEditable()\n  ElementStream<Event> get onWaiting => waitingEvent.forElement(this);\n\n  /// Stream of `keyadded` events handled by this [MediaElement].\n  @DomName('HTMLMediaElement.onwebkitkeyadded')\n  @DocsEditable()\n  // https://dvcs.w3.org/hg/html-media/raw-file/eme-v0.1/encrypted-media/encrypted-media.html#dom-keyadded\n  @Experimental()\n  ElementStream<MediaKeyEvent> get onKeyAdded => keyAddedEvent.forElement(this);\n\n  /// Stream of `keyerror` events handled by this [MediaElement].\n  @DomName('HTMLMediaElement.onwebkitkeyerror')\n  @DocsEditable()\n  // https://dvcs.w3.org/hg/html-media/raw-file/eme-v0.1/encrypted-media/encrypted-media.html#dom-keyadded\n  @Experimental()\n  ElementStream<MediaKeyEvent> get onKeyError => keyErrorEvent.forElement(this);\n\n  /// Stream of `keymessage` events handled by this [MediaElement].\n  @DomName('HTMLMediaElement.onwebkitkeymessage')\n  @DocsEditable()\n  // https://dvcs.w3.org/hg/html-media/raw-file/eme-v0.1/encrypted-media/encrypted-media.html#dom-keyadded\n  @Experimental()\n  ElementStream<MediaKeyEvent> get onKeyMessage => keyMessageEvent.forElement(this);\n\n  /// Stream of `needkey` events handled by this [MediaElement].\n  @DomName('HTMLMediaElement.onwebkitneedkey')\n  @DocsEditable()\n  // https://dvcs.w3.org/hg/html-media/raw-file/eme-v0.1/encrypted-media/encrypted-media.html#dom-keyadded\n  @Experimental()\n  ElementStream<MediaKeyEvent> get onNeedKey => needKeyEvent.forElement(this);\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('MediaError')\n@Unstable()\n@Native(\"MediaError\")\nclass MediaError extends Interceptor {\n  // To suppress missing implicit constructor warnings.\n  factory MediaError._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('MediaError.MEDIA_ERR_ABORTED')\n  @DocsEditable()\n  static const int MEDIA_ERR_ABORTED = 1;\n\n  @DomName('MediaError.MEDIA_ERR_DECODE')\n  @DocsEditable()\n  static const int MEDIA_ERR_DECODE = 3;\n\n  @DomName('MediaError.MEDIA_ERR_ENCRYPTED')\n  @DocsEditable()\n  // https://dvcs.w3.org/hg/html-media/raw-file/eme-v0.1/encrypted-media/encrypted-media.html#error-codes\n  @Experimental()\n  static const int MEDIA_ERR_ENCRYPTED = 5;\n\n  @DomName('MediaError.MEDIA_ERR_NETWORK')\n  @DocsEditable()\n  static const int MEDIA_ERR_NETWORK = 2;\n\n  @DomName('MediaError.MEDIA_ERR_SRC_NOT_SUPPORTED')\n  @DocsEditable()\n  static const int MEDIA_ERR_SRC_NOT_SUPPORTED = 4;\n\n  @DomName('MediaError.code')\n  @DocsEditable()\n  final int code;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('MediaKeyError')\n// https://dvcs.w3.org/hg/html-media/raw-file/eme-v0.1/encrypted-media/encrypted-media.html#error-codes\n@Experimental()\n@Native(\"MediaKeyError\")\nclass MediaKeyError extends Interceptor {\n  // To suppress missing implicit constructor warnings.\n  factory MediaKeyError._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('MediaKeyError.MEDIA_KEYERR_CLIENT')\n  @DocsEditable()\n  static const int MEDIA_KEYERR_CLIENT = 2;\n\n  @DomName('MediaKeyError.MEDIA_KEYERR_DOMAIN')\n  @DocsEditable()\n  static const int MEDIA_KEYERR_DOMAIN = 6;\n\n  @DomName('MediaKeyError.MEDIA_KEYERR_HARDWARECHANGE')\n  @DocsEditable()\n  static const int MEDIA_KEYERR_HARDWARECHANGE = 5;\n\n  @DomName('MediaKeyError.MEDIA_KEYERR_OUTPUT')\n  @DocsEditable()\n  static const int MEDIA_KEYERR_OUTPUT = 4;\n\n  @DomName('MediaKeyError.MEDIA_KEYERR_SERVICE')\n  @DocsEditable()\n  static const int MEDIA_KEYERR_SERVICE = 3;\n\n  @DomName('MediaKeyError.MEDIA_KEYERR_UNKNOWN')\n  @DocsEditable()\n  static const int MEDIA_KEYERR_UNKNOWN = 1;\n\n  @DomName('MediaKeyError.code')\n  @DocsEditable()\n  final int code;\n\n  @DomName('MediaKeyError.systemCode')\n  @DocsEditable()\n  @Experimental() // non-standard\n  final int systemCode;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('MediaKeyEvent')\n// https://dvcs.w3.org/hg/html-media/raw-file/eme-v0.1/encrypted-media/encrypted-media.html#event-definitions\n@Experimental()\n@Native(\"MediaKeyEvent\")\nclass MediaKeyEvent extends Event {\n  // To suppress missing implicit constructor warnings.\n  factory MediaKeyEvent._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @JSName('defaultURL')\n  @DomName('MediaKeyEvent.defaultURL')\n  @DocsEditable()\n  final String defaultUrl;\n\n  @DomName('MediaKeyEvent.errorCode')\n  @DocsEditable()\n  final MediaKeyError errorCode;\n\n  @DomName('MediaKeyEvent.initData')\n  @DocsEditable()\n  final Uint8List initData;\n\n  @DomName('MediaKeyEvent.keySystem')\n  @DocsEditable()\n  final String keySystem;\n\n  @DomName('MediaKeyEvent.message')\n  @DocsEditable()\n  final Uint8List message;\n\n  @DomName('MediaKeyEvent.sessionId')\n  @DocsEditable()\n  final String sessionId;\n\n  @DomName('MediaKeyEvent.systemCode')\n  @DocsEditable()\n  final int systemCode;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('MediaKeyMessageEvent')\n// https://dvcs.w3.org/hg/html-media/raw-file/eme-v0.1/encrypted-media/encrypted-media.html#dom-mediakeymessageevent\n@Experimental()\n@Native(\"MediaKeyMessageEvent\")\nclass MediaKeyMessageEvent extends Event {\n  // To suppress missing implicit constructor warnings.\n  factory MediaKeyMessageEvent._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @JSName('destinationURL')\n  @DomName('MediaKeyMessageEvent.destinationURL')\n  @DocsEditable()\n  final String destinationUrl;\n\n  @DomName('MediaKeyMessageEvent.message')\n  @DocsEditable()\n  final Uint8List message;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('MediaKeyNeededEvent')\n// https://dvcs.w3.org/hg/html-media/raw-file/eme-v0.1/encrypted-media/encrypted-media.html#dom-mediakeyneededevent\n@Experimental()\n@Native(\"MediaKeyNeededEvent\")\nclass MediaKeyNeededEvent extends Event {\n  // To suppress missing implicit constructor warnings.\n  factory MediaKeyNeededEvent._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('MediaKeyNeededEvent.contentType')\n  @DocsEditable()\n  @Experimental() // untriaged\n  final String contentType;\n\n  @DomName('MediaKeyNeededEvent.initData')\n  @DocsEditable()\n  final Uint8List initData;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('MediaKeySession')\n// https://dvcs.w3.org/hg/html-media/raw-file/eme-v0.1/encrypted-media/encrypted-media.html#dom-mediakeysession\n@Experimental()\n@Native(\"MediaKeySession\")\nclass MediaKeySession extends EventTarget {\n  // To suppress missing implicit constructor warnings.\n  factory MediaKeySession._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('MediaKeySession.error')\n  @DocsEditable()\n  final MediaKeyError error;\n\n  @DomName('MediaKeySession.keySystem')\n  @DocsEditable()\n  final String keySystem;\n\n  @DomName('MediaKeySession.sessionId')\n  @DocsEditable()\n  final String sessionId;\n\n  @DomName('MediaKeySession.release')\n  @DocsEditable()\n  @Experimental() // untriaged\n  void release() native;\n\n  @DomName('MediaKeySession.update')\n  @DocsEditable()\n  void update(Uint8List response) native;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('MediaKeys')\n// https://dvcs.w3.org/hg/html-media/raw-file/eme-v0.1/encrypted-media/encrypted-media.html\n@Experimental()\n@Native(\"MediaKeys\")\nclass MediaKeys extends Interceptor {\n  // To suppress missing implicit constructor warnings.\n  factory MediaKeys._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('MediaKeys.MediaKeys')\n  @DocsEditable()\n  factory MediaKeys(String keySystem) {\n    return MediaKeys._create_1(keySystem);\n  }\n  static MediaKeys _create_1(keySystem) => JS('MediaKeys', 'new MediaKeys(#)', keySystem);\n\n  @DomName('MediaKeys.keySystem')\n  @DocsEditable()\n  final String keySystem;\n\n  @DomName('MediaKeys.createSession')\n  @DocsEditable()\n  MediaKeySession createSession(String type, Uint8List initData) native;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('MediaList')\n@Unstable()\n@Native(\"MediaList\")\nclass MediaList extends Interceptor {\n  // To suppress missing implicit constructor warnings.\n  factory MediaList._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('MediaList.length')\n  @DocsEditable()\n  final int length;\n\n  @DomName('MediaList.mediaText')\n  @DocsEditable()\n  String mediaText;\n\n  @DomName('MediaList.appendMedium')\n  @DocsEditable()\n  void appendMedium(String newMedium) native;\n\n  @DomName('MediaList.deleteMedium')\n  @DocsEditable()\n  void deleteMedium(String oldMedium) native;\n\n  @DomName('MediaList.item')\n  @DocsEditable()\n  String item(int index) native;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('MediaQueryList')\n@Unstable()\n@Native(\"MediaQueryList\")\nclass MediaQueryList extends Interceptor {\n  // To suppress missing implicit constructor warnings.\n  factory MediaQueryList._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('MediaQueryList.matches')\n  @DocsEditable()\n  final bool matches;\n\n  @DomName('MediaQueryList.media')\n  @DocsEditable()\n  final String media;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('MediaSource')\n// https://dvcs.w3.org/hg/html-media/raw-file/tip/media-source/media-source.html#mediasource\n@Experimental()\n@Native(\"MediaSource\")\nclass MediaSource extends EventTarget {\n  // To suppress missing implicit constructor warnings.\n  factory MediaSource._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('MediaSource.MediaSource')\n  @DocsEditable()\n  factory MediaSource() {\n    return MediaSource._create_1();\n  }\n  static MediaSource _create_1() => JS('MediaSource', 'new MediaSource()');\n\n  @DomName('MediaSource.activeSourceBuffers')\n  @DocsEditable()\n  final SourceBufferList activeSourceBuffers;\n\n  @DomName('MediaSource.duration')\n  @DocsEditable()\n  num duration;\n\n  @DomName('MediaSource.readyState')\n  @DocsEditable()\n  final String readyState;\n\n  @DomName('MediaSource.sourceBuffers')\n  @DocsEditable()\n  final SourceBufferList sourceBuffers;\n\n  @DomName('MediaSource.addSourceBuffer')\n  @DocsEditable()\n  SourceBuffer addSourceBuffer(String type) native;\n\n  @DomName('MediaSource.endOfStream')\n  @DocsEditable()\n  void endOfStream([String error]) native;\n\n  @DomName('MediaSource.isTypeSupported')\n  @DocsEditable()\n  static bool isTypeSupported(String type) native;\n\n  @DomName('MediaSource.removeSourceBuffer')\n  @DocsEditable()\n  void removeSourceBuffer(SourceBuffer buffer) native;\n}\n// Copyright (c) 2013, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DomName('MediaStream')\n@SupportedBrowser(SupportedBrowser.CHROME)\n@Experimental()\n// http://dev.w3.org/2011/webrtc/editor/getusermedia.html#mediastream\n@Native(\"MediaStream\")\nclass MediaStream extends EventTarget {\n  // To suppress missing implicit constructor warnings.\n  factory MediaStream._() { throw new UnsupportedError(\"Not supported\"); }\n\n  /**\n   * Static factory designed to expose `addtrack` events to event\n   * handlers that are not necessarily instances of [MediaStream].\n   *\n   * See [EventStreamProvider] for usage information.\n   */\n  @DomName('MediaStream.addtrackEvent')\n  @DocsEditable()\n  static const EventStreamProvider<Event> addTrackEvent = const EventStreamProvider<Event>('addtrack');\n\n  /**\n   * Static factory designed to expose `ended` events to event\n   * handlers that are not necessarily instances of [MediaStream].\n   *\n   * See [EventStreamProvider] for usage information.\n   */\n  @DomName('MediaStream.endedEvent')\n  @DocsEditable()\n  static const EventStreamProvider<Event> endedEvent = const EventStreamProvider<Event>('ended');\n\n  /**\n   * Static factory designed to expose `removetrack` events to event\n   * handlers that are not necessarily instances of [MediaStream].\n   *\n   * See [EventStreamProvider] for usage information.\n   */\n  @DomName('MediaStream.removetrackEvent')\n  @DocsEditable()\n  static const EventStreamProvider<Event> removeTrackEvent = const EventStreamProvider<Event>('removetrack');\n\n  @DomName('MediaStream.MediaStream')\n  @DocsEditable()\n  factory MediaStream([stream_OR_tracks]) {\n    if (stream_OR_tracks == null) {\n      return MediaStream._create_1();\n    }\n    if ((stream_OR_tracks is MediaStream || stream_OR_tracks == null)) {\n      return MediaStream._create_2(stream_OR_tracks);\n    }\n    if ((stream_OR_tracks is List<MediaStreamTrack> || stream_OR_tracks == null)) {\n      return MediaStream._create_3(stream_OR_tracks);\n    }\n    throw new ArgumentError(\"Incorrect number or type of arguments\");\n  }\n  static MediaStream _create_1() => JS('MediaStream', 'new MediaStream()');\n  static MediaStream _create_2(stream_OR_tracks) => JS('MediaStream', 'new MediaStream(#)', stream_OR_tracks);\n  static MediaStream _create_3(stream_OR_tracks) => JS('MediaStream', 'new MediaStream(#)', stream_OR_tracks);\n\n  @DomName('MediaStream.ended')\n  @DocsEditable()\n  final bool ended;\n\n  @DomName('MediaStream.id')\n  @DocsEditable()\n  final String id;\n\n  @DomName('MediaStream.label')\n  @DocsEditable()\n  @Experimental() // non-standard\n  final String label;\n\n  @DomName('MediaStream.addTrack')\n  @DocsEditable()\n  void addTrack(MediaStreamTrack track) native;\n\n  @DomName('MediaStream.getAudioTracks')\n  @DocsEditable()\n  @Creates('JSExtendableArray')\n  @Returns('JSExtendableArray')\n  List<MediaStreamTrack> getAudioTracks() native;\n\n  @DomName('MediaStream.getTrackById')\n  @DocsEditable()\n  MediaStreamTrack getTrackById(String trackId) native;\n\n  @DomName('MediaStream.getVideoTracks')\n  @DocsEditable()\n  @Creates('JSExtendableArray')\n  @Returns('JSExtendableArray')\n  List<MediaStreamTrack> getVideoTracks() native;\n\n  @DomName('MediaStream.removeTrack')\n  @DocsEditable()\n  void removeTrack(MediaStreamTrack track) native;\n\n  @DomName('MediaStream.stop')\n  @DocsEditable()\n  void stop() native;\n\n  /// Stream of `addtrack` events handled by this [MediaStream].\n  @DomName('MediaStream.onaddtrack')\n  @DocsEditable()\n  Stream<Event> get onAddTrack => addTrackEvent.forTarget(this);\n\n  /// Stream of `ended` events handled by this [MediaStream].\n  @DomName('MediaStream.onended')\n  @DocsEditable()\n  Stream<Event> get onEnded => endedEvent.forTarget(this);\n\n  /// Stream of `removetrack` events handled by this [MediaStream].\n  @DomName('MediaStream.onremovetrack')\n  @DocsEditable()\n  Stream<Event> get onRemoveTrack => removeTrackEvent.forTarget(this);\n\n\n  /**\n   * Checks if the MediaStream APIs are supported on the current platform.\n   *\n   * See also:\n   *\n   * * [Navigator.getUserMedia]\n   */\n  static bool get supported =>\n    JS('bool', '''!!(#.getUserMedia || #.webkitGetUserMedia ||\n        #.mozGetUserMedia || #.msGetUserMedia)''',\n        window.navigator,\n        window.navigator,\n        window.navigator,\n        window.navigator);\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('MediaStreamEvent')\n@SupportedBrowser(SupportedBrowser.CHROME)\n@Experimental()\n// http://dev.w3.org/2011/webrtc/editor/getusermedia.html\n@Native(\"MediaStreamEvent\")\nclass MediaStreamEvent extends Event {\n  // To suppress missing implicit constructor warnings.\n  factory MediaStreamEvent._() { throw new UnsupportedError(\"Not supported\"); }\n\n  /// Checks if this type is supported on the current platform.\n  static bool get supported => Device.isEventTypeSupported('MediaStreamEvent');\n\n  @DomName('MediaStreamEvent.stream')\n  @DocsEditable()\n  final MediaStream stream;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('MediaStreamTrack')\n@SupportedBrowser(SupportedBrowser.CHROME)\n@Experimental()\n// http://dev.w3.org/2011/webrtc/editor/getusermedia.html#mediastreamtrack\n@Native(\"MediaStreamTrack\")\nclass MediaStreamTrack extends EventTarget {\n  // To suppress missing implicit constructor warnings.\n  factory MediaStreamTrack._() { throw new UnsupportedError(\"Not supported\"); }\n\n  /**\n   * Static factory designed to expose `ended` events to event\n   * handlers that are not necessarily instances of [MediaStreamTrack].\n   *\n   * See [EventStreamProvider] for usage information.\n   */\n  @DomName('MediaStreamTrack.endedEvent')\n  @DocsEditable()\n  static const EventStreamProvider<Event> endedEvent = const EventStreamProvider<Event>('ended');\n\n  /**\n   * Static factory designed to expose `mute` events to event\n   * handlers that are not necessarily instances of [MediaStreamTrack].\n   *\n   * See [EventStreamProvider] for usage information.\n   */\n  @DomName('MediaStreamTrack.muteEvent')\n  @DocsEditable()\n  static const EventStreamProvider<Event> muteEvent = const EventStreamProvider<Event>('mute');\n\n  /**\n   * Static factory designed to expose `unmute` events to event\n   * handlers that are not necessarily instances of [MediaStreamTrack].\n   *\n   * See [EventStreamProvider] for usage information.\n   */\n  @DomName('MediaStreamTrack.unmuteEvent')\n  @DocsEditable()\n  static const EventStreamProvider<Event> unmuteEvent = const EventStreamProvider<Event>('unmute');\n\n  @DomName('MediaStreamTrack.enabled')\n  @DocsEditable()\n  bool enabled;\n\n  @DomName('MediaStreamTrack.id')\n  @DocsEditable()\n  final String id;\n\n  @DomName('MediaStreamTrack.kind')\n  @DocsEditable()\n  final String kind;\n\n  @DomName('MediaStreamTrack.label')\n  @DocsEditable()\n  final String label;\n\n  @DomName('MediaStreamTrack.readyState')\n  @DocsEditable()\n  final String readyState;\n\n  @JSName('getSources')\n  @DomName('MediaStreamTrack.getSources')\n  @DocsEditable()\n  @Experimental() // untriaged\n  static void _getSources(MediaStreamTrackSourcesCallback callback) native;\n\n  @JSName('getSources')\n  @DomName('MediaStreamTrack.getSources')\n  @DocsEditable()\n  @Experimental() // untriaged\n  static Future<List<SourceInfo>> getSources() {\n    var completer = new Completer<List<SourceInfo>>();\n    _getSources(\n        (value) { completer.complete(value); });\n    return completer.future;\n  }\n\n  @DomName('MediaStreamTrack.stop')\n  @DocsEditable()\n  @Experimental() // untriaged\n  void stop() native;\n\n  /// Stream of `ended` events handled by this [MediaStreamTrack].\n  @DomName('MediaStreamTrack.onended')\n  @DocsEditable()\n  Stream<Event> get onEnded => endedEvent.forTarget(this);\n\n  /// Stream of `mute` events handled by this [MediaStreamTrack].\n  @DomName('MediaStreamTrack.onmute')\n  @DocsEditable()\n  Stream<Event> get onMute => muteEvent.forTarget(this);\n\n  /// Stream of `unmute` events handled by this [MediaStreamTrack].\n  @DomName('MediaStreamTrack.onunmute')\n  @DocsEditable()\n  Stream<Event> get onUnmute => unmuteEvent.forTarget(this);\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('MediaStreamTrackEvent')\n@SupportedBrowser(SupportedBrowser.CHROME)\n@Experimental()\n// http://dev.w3.org/2011/webrtc/editor/getusermedia.html\n@Native(\"MediaStreamTrackEvent\")\nclass MediaStreamTrackEvent extends Event {\n  // To suppress missing implicit constructor warnings.\n  factory MediaStreamTrackEvent._() { throw new UnsupportedError(\"Not supported\"); }\n\n  /// Checks if this type is supported on the current platform.\n  static bool get supported => Device.isEventTypeSupported('MediaStreamTrackEvent');\n\n  @DomName('MediaStreamTrackEvent.track')\n  @DocsEditable()\n  final MediaStreamTrack track;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n// WARNING: Do not edit - generated code.\n\n\n@DomName('MediaStreamTrackSourcesCallback')\n@Experimental() // untriaged\ntypedef void MediaStreamTrackSourcesCallback(List<SourceInfo> sources);\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('MemoryInfo')\n@Experimental() // nonstandard\n@Native(\"MemoryInfo\")\nclass MemoryInfo extends Interceptor {\n  // To suppress missing implicit constructor warnings.\n  factory MemoryInfo._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('MemoryInfo.jsHeapSizeLimit')\n  @DocsEditable()\n  final int jsHeapSizeLimit;\n\n  @DomName('MemoryInfo.totalJSHeapSize')\n  @DocsEditable()\n  final int totalJSHeapSize;\n\n  @DomName('MemoryInfo.usedJSHeapSize')\n  @DocsEditable()\n  final int usedJSHeapSize;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n/**\n * An HTML <menu> element.\n *\n * A <menu> element represents an unordered list of menu commands.\n *\n * See also:\n *\n *  * [Menu Element](https://developer.mozilla.org/en-US/docs/HTML/Element/menu) from MDN.\n *  * [Menu Element](http://www.w3.org/TR/html5/the-menu-element.html#the-menu-element) from the W3C.\n */\n@DomName('HTMLMenuElement')\n@Native(\"HTMLMenuElement\")\nclass MenuElement extends HtmlElement {\n  // To suppress missing implicit constructor warnings.\n  factory MenuElement._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('HTMLMenuElement.HTMLMenuElement')\n  @DocsEditable()\n  factory MenuElement() => document.createElement(\"menu\");\n  /**\n   * Constructor instantiated by the DOM when a custom element has been created.\n   *\n   * This can only be called by subclasses from their created constructor.\n   */\n  MenuElement.created() : super.created();\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('MessageChannel')\n@Unstable()\n@Native(\"MessageChannel\")\nclass MessageChannel extends Interceptor {\n  // To suppress missing implicit constructor warnings.\n  factory MessageChannel._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('MessageChannel.port1')\n  @DocsEditable()\n  final MessagePort port1;\n\n  @DomName('MessageChannel.port2')\n  @DocsEditable()\n  final MessagePort port2;\n}\n// Copyright (c) 2013, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n// WARNING: Do not edit - generated code.\n\n\n@DomName('MessageEvent')\n@Native(\"MessageEvent\")\nclass MessageEvent extends Event {\n  factory MessageEvent(String type,\n      {bool canBubble: false, bool cancelable: false, Object data,\n      String origin, String lastEventId,\n      Window source, List messagePorts}) {\n    if (source == null) {\n      source = window;\n    }\n    if (!Device.isIE) { // TODO: This if check should be removed once IE\n      // implements the constructor.\n      return JS('MessageEvent', 'new MessageEvent(#, {bubbles: #, cancelable: #, data: #, origin: #, lastEventId: #, source: #, ports: #})',\n          type, canBubble, cancelable, data, origin, lastEventId, source,\n          messagePorts);\n    }\n    var event = document._createEvent(\"MessageEvent\");\n    event._initMessageEvent(type, canBubble, cancelable, data, origin,\n        lastEventId, source, messagePorts);\n    return event;\n  }\n  // To suppress missing implicit constructor warnings.\n  factory MessageEvent._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('MessageEvent.data')\n  @DocsEditable()\n  dynamic get data => convertNativeToDart_SerializedScriptValue(this._get_data);\n  @JSName('data')\n  @DomName('MessageEvent.data')\n  @DocsEditable()\n  @annotation_Creates_SerializedScriptValue\n  @annotation_Returns_SerializedScriptValue\n  final dynamic _get_data;\n\n  @DomName('MessageEvent.lastEventId')\n  @DocsEditable()\n  @Unstable()\n  final String lastEventId;\n\n  @DomName('MessageEvent.origin')\n  @DocsEditable()\n  final String origin;\n\n  @DomName('MessageEvent.source')\n  @DocsEditable()\n  EventTarget get source => _convertNativeToDart_EventTarget(this._get_source);\n  @JSName('source')\n  @DomName('MessageEvent.source')\n  @DocsEditable()\n  @Creates('Null')\n  @Returns('EventTarget|=Object')\n  final dynamic _get_source;\n\n  @JSName('initMessageEvent')\n  @DomName('MessageEvent.initMessageEvent')\n  @DocsEditable()\n  void _initMessageEvent(String typeArg, bool canBubbleArg, bool cancelableArg, Object dataArg, String originArg, String lastEventIdArg, Window sourceArg, List<MessagePort> messagePorts) native;\n\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('MessagePort')\n@Unstable()\n@Native(\"MessagePort\")\nclass MessagePort extends EventTarget {\n  // To suppress missing implicit constructor warnings.\n  factory MessagePort._() { throw new UnsupportedError(\"Not supported\"); }\n\n  /**\n   * Static factory designed to expose `message` events to event\n   * handlers that are not necessarily instances of [MessagePort].\n   *\n   * See [EventStreamProvider] for usage information.\n   */\n  @DomName('MessagePort.messageEvent')\n  @DocsEditable()\n  static const EventStreamProvider<MessageEvent> messageEvent = const EventStreamProvider<MessageEvent>('message');\n\n  @DomName('MessagePort.close')\n  @DocsEditable()\n  void close() native;\n\n  @DomName('MessagePort.postMessage')\n  @DocsEditable()\n  void postMessage(/*any*/ message, [List<MessagePort> messagePorts]) {\n    if (messagePorts != null) {\n      var message_1 = convertDartToNative_SerializedScriptValue(message);\n      _postMessage_1(message_1, messagePorts);\n      return;\n    }\n    var message_2 = convertDartToNative_SerializedScriptValue(message);\n    _postMessage_2(message_2);\n    return;\n  }\n  @JSName('postMessage')\n  @DomName('MessagePort.postMessage')\n  @DocsEditable()\n  void _postMessage_1(message, List<MessagePort> messagePorts) native;\n  @JSName('postMessage')\n  @DomName('MessagePort.postMessage')\n  @DocsEditable()\n  void _postMessage_2(message) native;\n\n  @DomName('MessagePort.start')\n  @DocsEditable()\n  void start() native;\n\n  /// Stream of `message` events handled by this [MessagePort].\n  @DomName('MessagePort.onmessage')\n  @DocsEditable()\n  Stream<MessageEvent> get onMessage => messageEvent.forTarget(this);\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('HTMLMetaElement')\n@Native(\"HTMLMetaElement\")\nclass MetaElement extends HtmlElement {\n  // To suppress missing implicit constructor warnings.\n  factory MetaElement._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('HTMLMetaElement.HTMLMetaElement')\n  @DocsEditable()\n  factory MetaElement() => document.createElement(\"meta\");\n  /**\n   * Constructor instantiated by the DOM when a custom element has been created.\n   *\n   * This can only be called by subclasses from their created constructor.\n   */\n  MetaElement.created() : super.created();\n\n  @DomName('HTMLMetaElement.content')\n  @DocsEditable()\n  String content;\n\n  @DomName('HTMLMetaElement.httpEquiv')\n  @DocsEditable()\n  String httpEquiv;\n\n  @DomName('HTMLMetaElement.name')\n  @DocsEditable()\n  String name;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('Metadata')\n// http://www.w3.org/TR/file-system-api/#the-metadata-interface\n@Experimental()\n@Native(\"Metadata\")\nclass Metadata extends Interceptor {\n  // To suppress missing implicit constructor warnings.\n  factory Metadata._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('Metadata.modificationTime')\n  @DocsEditable()\n  DateTime get modificationTime => convertNativeToDart_DateTime(this._get_modificationTime);\n  @JSName('modificationTime')\n  @DomName('Metadata.modificationTime')\n  @DocsEditable()\n  @Creates('Null')\n  final dynamic _get_modificationTime;\n\n  @DomName('Metadata.size')\n  @DocsEditable()\n  final int size;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n// WARNING: Do not edit - generated code.\n\n\n@DomName('MetadataCallback')\n// http://www.w3.org/TR/file-system-api/#idl-def-MetadataCallback\n@Experimental()\ntypedef void MetadataCallback(Metadata metadata);\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('HTMLMeterElement')\n@SupportedBrowser(SupportedBrowser.CHROME)\n@SupportedBrowser(SupportedBrowser.FIREFOX)\n@SupportedBrowser(SupportedBrowser.SAFARI)\n@Unstable()\n@Native(\"HTMLMeterElement\")\nclass MeterElement extends HtmlElement {\n  // To suppress missing implicit constructor warnings.\n  factory MeterElement._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('HTMLMeterElement.HTMLMeterElement')\n  @DocsEditable()\n  factory MeterElement() => document.createElement(\"meter\");\n  /**\n   * Constructor instantiated by the DOM when a custom element has been created.\n   *\n   * This can only be called by subclasses from their created constructor.\n   */\n  MeterElement.created() : super.created();\n\n  /// Checks if this type is supported on the current platform.\n  static bool get supported => Element.isTagSupported('meter');\n\n  @DomName('HTMLMeterElement.high')\n  @DocsEditable()\n  num high;\n\n  @DomName('HTMLMeterElement.labels')\n  @DocsEditable()\n  @Unstable()\n  @Returns('NodeList')\n  @Creates('NodeList')\n  final List<Node> labels;\n\n  @DomName('HTMLMeterElement.low')\n  @DocsEditable()\n  num low;\n\n  @DomName('HTMLMeterElement.max')\n  @DocsEditable()\n  num max;\n\n  @DomName('HTMLMeterElement.min')\n  @DocsEditable()\n  num min;\n\n  @DomName('HTMLMeterElement.optimum')\n  @DocsEditable()\n  num optimum;\n\n  @DomName('HTMLMeterElement.value')\n  @DocsEditable()\n  num value;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('MIDIAccess')\n// http://webaudio.github.io/web-midi-api/#midiaccess-interface\n@Experimental()\n@Native(\"MIDIAccess\")\nclass MidiAccess extends EventTarget {\n  // To suppress missing implicit constructor warnings.\n  factory MidiAccess._() { throw new UnsupportedError(\"Not supported\"); }\n\n  /**\n   * Static factory designed to expose `connect` events to event\n   * handlers that are not necessarily instances of [MidiAccess].\n   *\n   * See [EventStreamProvider] for usage information.\n   */\n  @DomName('MIDIAccess.connectEvent')\n  @DocsEditable()\n  static const EventStreamProvider<MidiConnectionEvent> connectEvent = const EventStreamProvider<MidiConnectionEvent>('connect');\n\n  /**\n   * Static factory designed to expose `disconnect` events to event\n   * handlers that are not necessarily instances of [MidiAccess].\n   *\n   * See [EventStreamProvider] for usage information.\n   */\n  @DomName('MIDIAccess.disconnectEvent')\n  @DocsEditable()\n  static const EventStreamProvider<MidiConnectionEvent> disconnectEvent = const EventStreamProvider<MidiConnectionEvent>('disconnect');\n\n  @DomName('MIDIAccess.inputs')\n  @DocsEditable()\n  List<MidiInput> inputs() native;\n\n  @DomName('MIDIAccess.outputs')\n  @DocsEditable()\n  List<MidiOutput> outputs() native;\n\n  /// Stream of `connect` events handled by this [MidiAccess].\n  @DomName('MIDIAccess.onconnect')\n  @DocsEditable()\n  Stream<MidiConnectionEvent> get onConnect => connectEvent.forTarget(this);\n\n  /// Stream of `disconnect` events handled by this [MidiAccess].\n  @DomName('MIDIAccess.ondisconnect')\n  @DocsEditable()\n  Stream<MidiConnectionEvent> get onDisconnect => disconnectEvent.forTarget(this);\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('MIDIAccessPromise')\n@Experimental() // untriaged\n@Native(\"MIDIAccessPromise\")\nclass MidiAccessPromise extends Interceptor {\n  // To suppress missing implicit constructor warnings.\n  factory MidiAccessPromise._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('MIDIAccessPromise.then')\n  @DocsEditable()\n  @Experimental() // untriaged\n  void then(MidiSuccessCallback successCallback, MidiErrorCallback errorCallback) native;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('MIDIConnectionEvent')\n// http://webaudio.github.io/web-midi-api/#midiconnectionevent-interface\n@Experimental()\n@Native(\"MIDIConnectionEvent\")\nclass MidiConnectionEvent extends Event {\n  // To suppress missing implicit constructor warnings.\n  factory MidiConnectionEvent._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('MIDIConnectionEvent.port')\n  @DocsEditable()\n  final MidiPort port;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('MIDIInput')\n// http://webaudio.github.io/web-midi-api/#idl-def-MIDIInput\n@Experimental()\n@Native(\"MIDIInput\")\nclass MidiInput extends MidiPort {\n  // To suppress missing implicit constructor warnings.\n  factory MidiInput._() { throw new UnsupportedError(\"Not supported\"); }\n\n  /**\n   * Static factory designed to expose `midimessage` events to event\n   * handlers that are not necessarily instances of [MidiInput].\n   *\n   * See [EventStreamProvider] for usage information.\n   */\n  @DomName('MIDIInput.midimessageEvent')\n  @DocsEditable()\n  static const EventStreamProvider<MidiMessageEvent> midiMessageEvent = const EventStreamProvider<MidiMessageEvent>('midimessage');\n\n  /// Stream of `midimessage` events handled by this [MidiInput].\n  @DomName('MIDIInput.onmidimessage')\n  @DocsEditable()\n  Stream<MidiMessageEvent> get onMidiMessage => midiMessageEvent.forTarget(this);\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('MIDIMessageEvent')\n// http://webaudio.github.io/web-midi-api/#midimessageevent-interface\n@Experimental()\n@Native(\"MIDIMessageEvent\")\nclass MidiMessageEvent extends Event {\n  // To suppress missing implicit constructor warnings.\n  factory MidiMessageEvent._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('MIDIMessageEvent.data')\n  @DocsEditable()\n  final Uint8List data;\n\n  @DomName('MIDIMessageEvent.receivedTime')\n  @DocsEditable()\n  final double receivedTime;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('MIDIOutput')\n// http://webaudio.github.io/web-midi-api/#midioutput-interface\n@Experimental()\n@Native(\"MIDIOutput\")\nclass MidiOutput extends MidiPort {\n  // To suppress missing implicit constructor warnings.\n  factory MidiOutput._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('MIDIOutput.send')\n  @DocsEditable()\n  void send(Uint8List data, [num timestamp]) native;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('MIDIPort')\n// http://webaudio.github.io/web-midi-api/#idl-def-MIDIPort\n@Experimental()\n@Native(\"MIDIPort\")\nclass MidiPort extends EventTarget {\n  // To suppress missing implicit constructor warnings.\n  factory MidiPort._() { throw new UnsupportedError(\"Not supported\"); }\n\n  /**\n   * Static factory designed to expose `disconnect` events to event\n   * handlers that are not necessarily instances of [MidiPort].\n   *\n   * See [EventStreamProvider] for usage information.\n   */\n  @DomName('MIDIPort.disconnectEvent')\n  @DocsEditable()\n  static const EventStreamProvider<MidiConnectionEvent> disconnectEvent = const EventStreamProvider<MidiConnectionEvent>('disconnect');\n\n  @DomName('MIDIPort.id')\n  @DocsEditable()\n  final String id;\n\n  @DomName('MIDIPort.manufacturer')\n  @DocsEditable()\n  final String manufacturer;\n\n  @DomName('MIDIPort.name')\n  @DocsEditable()\n  final String name;\n\n  @DomName('MIDIPort.type')\n  @DocsEditable()\n  final String type;\n\n  @DomName('MIDIPort.version')\n  @DocsEditable()\n  final String version;\n\n  /// Stream of `disconnect` events handled by this [MidiPort].\n  @DomName('MIDIPort.ondisconnect')\n  @DocsEditable()\n  Stream<MidiConnectionEvent> get onDisconnect => disconnectEvent.forTarget(this);\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('MimeType')\n@Experimental() // non-standard\n@Native(\"MimeType\")\nclass MimeType extends Interceptor {\n  // To suppress missing implicit constructor warnings.\n  factory MimeType._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('MimeType.description')\n  @DocsEditable()\n  final String description;\n\n  @DomName('MimeType.enabledPlugin')\n  @DocsEditable()\n  final Plugin enabledPlugin;\n\n  @DomName('MimeType.suffixes')\n  @DocsEditable()\n  final String suffixes;\n\n  @DomName('MimeType.type')\n  @DocsEditable()\n  final String type;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('MimeTypeArray')\n@Experimental() // non-standard\n@Native(\"MimeTypeArray\")\nclass MimeTypeArray extends Interceptor with ListMixin<MimeType>, ImmutableListMixin<MimeType> implements JavaScriptIndexingBehavior, List<MimeType> {\n  // To suppress missing implicit constructor warnings.\n  factory MimeTypeArray._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('MimeTypeArray.length')\n  @DocsEditable()\n  int get length => JS(\"int\", \"#.length\", this);\n\n  MimeType operator[](int index) {\n    if (JS(\"bool\", \"# >>> 0 !== # || # >= #\", index,\n        index, index, length))\n      throw new RangeError.range(index, 0, length);\n    return JS(\"MimeType\", \"#[#]\", this, index);\n  }\n  void operator[]=(int index, MimeType value) {\n    throw new UnsupportedError(\"Cannot assign element of immutable List.\");\n  }\n  // -- start List<MimeType> mixins.\n  // MimeType is the element type.\n\n\n  void set length(int value) {\n    throw new UnsupportedError(\"Cannot resize immutable List.\");\n  }\n\n  MimeType get first {\n    if (this.length > 0) {\n      return JS('MimeType', '#[0]', this);\n    }\n    throw new StateError(\"No elements\");\n  }\n\n  MimeType get last {\n    int len = this.length;\n    if (len > 0) {\n      return JS('MimeType', '#[#]', this, len - 1);\n    }\n    throw new StateError(\"No elements\");\n  }\n\n  MimeType get single {\n    int len = this.length;\n    if (len == 1) {\n      return JS('MimeType', '#[0]', this);\n    }\n    if (len == 0) throw new StateError(\"No elements\");\n    throw new StateError(\"More than one element\");\n  }\n\n  MimeType elementAt(int index) => this[index];\n  // -- end List<MimeType> mixins.\n\n  @DomName('MimeTypeArray.__getter__')\n  @DocsEditable()\n  MimeType __getter__(String name) native;\n\n  @DomName('MimeTypeArray.item')\n  @DocsEditable()\n  MimeType item(int index) native;\n\n  @DomName('MimeTypeArray.namedItem')\n  @DocsEditable()\n  MimeType namedItem(String name) native;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('HTMLModElement')\n@Unstable()\n@Native(\"HTMLModElement\")\nclass ModElement extends HtmlElement {\n  // To suppress missing implicit constructor warnings.\n  factory ModElement._() { throw new UnsupportedError(\"Not supported\"); }\n  /**\n   * Constructor instantiated by the DOM when a custom element has been created.\n   *\n   * This can only be called by subclasses from their created constructor.\n   */\n  ModElement.created() : super.created();\n\n  @DomName('HTMLModElement.cite')\n  @DocsEditable()\n  String cite;\n\n  @DomName('HTMLModElement.dateTime')\n  @DocsEditable()\n  String dateTime;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DomName('MouseEvent')\n@Native(\"MouseEvent,DragEvent,PointerEvent,MSPointerEvent\")\nclass MouseEvent extends UIEvent {\n  factory MouseEvent(String type,\n      {Window view, int detail: 0, int screenX: 0, int screenY: 0,\n      int clientX: 0, int clientY: 0, int button: 0, bool canBubble: true,\n      bool cancelable: true, bool ctrlKey: false, bool altKey: false,\n      bool shiftKey: false, bool metaKey: false, EventTarget relatedTarget}) {\n\n    if (view == null) {\n      view = window;\n    }\n    var event = document._createEvent('MouseEvent');\n    event._initMouseEvent(type, canBubble, cancelable, view, detail,\n        screenX, screenY, clientX, clientY, ctrlKey, altKey, shiftKey, metaKey,\n        button, relatedTarget);\n    return event;\n  }\n  // To suppress missing implicit constructor warnings.\n  factory MouseEvent._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('MouseEvent.altKey')\n  @DocsEditable()\n  final bool altKey;\n\n  @DomName('MouseEvent.button')\n  @DocsEditable()\n  final int button;\n\n  @JSName('clientX')\n  @DomName('MouseEvent.clientX')\n  @DocsEditable()\n  final int _clientX;\n\n  @JSName('clientY')\n  @DomName('MouseEvent.clientY')\n  @DocsEditable()\n  final int _clientY;\n\n  @DomName('MouseEvent.ctrlKey')\n  @DocsEditable()\n  final bool ctrlKey;\n\n  @DomName('MouseEvent.dataTransfer')\n  @DocsEditable()\n  @Unstable()\n  final DataTransfer dataTransfer;\n\n  /**\n   * The nonstandard way to access the element that the mouse comes\n   * from in the case of a `mouseover` event.\n   *\n   * This member is deprecated and not cross-browser compatible; use\n   * relatedTarget to get the same information in the standard way.\n   */\n  @DomName('MouseEvent.fromElement')\n  @DocsEditable()\n  @deprecated\n  final Node fromElement;\n\n  @DomName('MouseEvent.metaKey')\n  @DocsEditable()\n  final bool metaKey;\n\n  @DomName('MouseEvent.relatedTarget')\n  @DocsEditable()\n  EventTarget get relatedTarget => _convertNativeToDart_EventTarget(this._get_relatedTarget);\n  @JSName('relatedTarget')\n  @DomName('MouseEvent.relatedTarget')\n  @DocsEditable()\n  @Creates('Node')\n  @Returns('EventTarget|=Object')\n  final dynamic _get_relatedTarget;\n\n  @JSName('screenX')\n  @DomName('MouseEvent.screenX')\n  @DocsEditable()\n  final int _screenX;\n\n  @JSName('screenY')\n  @DomName('MouseEvent.screenY')\n  @DocsEditable()\n  final int _screenY;\n\n  @DomName('MouseEvent.shiftKey')\n  @DocsEditable()\n  final bool shiftKey;\n\n  /**\n   * The nonstandard way to access the element that the mouse goes\n   * to in the case of a `mouseout` event.\n   *\n   * This member is deprecated and not cross-browser compatible; use\n   * relatedTarget to get the same information in the standard way.\n   */\n  @DomName('MouseEvent.toElement')\n  @DocsEditable()\n  @deprecated\n  final Node toElement;\n\n  @JSName('webkitMovementX')\n  @DomName('MouseEvent.webkitMovementX')\n  @DocsEditable()\n  @SupportedBrowser(SupportedBrowser.CHROME)\n  @SupportedBrowser(SupportedBrowser.SAFARI)\n  @Experimental()\n  final int _webkitMovementX;\n\n  @JSName('webkitMovementY')\n  @DomName('MouseEvent.webkitMovementY')\n  @DocsEditable()\n  @SupportedBrowser(SupportedBrowser.CHROME)\n  @SupportedBrowser(SupportedBrowser.SAFARI)\n  @Experimental()\n  final int _webkitMovementY;\n\n  @DomName('MouseEvent.initMouseEvent')\n  @DocsEditable()\n  void _initMouseEvent(String type, bool canBubble, bool cancelable, Window view, int detail, int screenX, int screenY, int clientX, int clientY, bool ctrlKey, bool altKey, bool shiftKey, bool metaKey, int button, EventTarget relatedTarget) {\n    var relatedTarget_1 = _convertDartToNative_EventTarget(relatedTarget);\n    _initMouseEvent_1(type, canBubble, cancelable, view, detail, screenX, screenY, clientX, clientY, ctrlKey, altKey, shiftKey, metaKey, button, relatedTarget_1);\n    return;\n  }\n  @JSName('initMouseEvent')\n  @DomName('MouseEvent.initMouseEvent')\n  @DocsEditable()\n  void _initMouseEvent_1(type, canBubble, cancelable, Window view, detail, screenX, screenY, clientX, clientY, ctrlKey, altKey, shiftKey, metaKey, button, relatedTarget) native;\n\n\n  @DomName('MouseEvent.clientX')\n  @DomName('MouseEvent.clientY')\n  Point get client => new Point(_clientX, _clientY);\n\n  @DomName('MouseEvent.movementX')\n  @DomName('MouseEvent.movementY')\n  @SupportedBrowser(SupportedBrowser.CHROME)\n  @SupportedBrowser(SupportedBrowser.SAFARI)\n  @Experimental()\n  Point get movement => new Point(_webkitMovementX, _webkitMovementY);\n\n  /**\n   * The coordinates of the mouse pointer in target node coordinates.\n   *\n   * This value may vary between platforms if the target node moves\n   * after the event has fired or if the element has CSS transforms affecting\n   * it.\n   */\n  Point get offset {\n    if (JS('bool', '!!#.offsetX', this)) {\n      var x = JS('int', '#.offsetX', this);\n      var y = JS('int', '#.offsetY', this);\n      return new Point(x, y);\n    } else {\n      // Firefox does not support offsetX.\n      if (!(this.target is Element)) {\n        throw new UnsupportedError(\n            'offsetX is only supported on elements');\n      }\n      Element target = this.target;\n      var point = (this.client - target.getBoundingClientRect().topLeft);\n      return new Point(point.x.toInt(), point.y.toInt());\n    }\n  }\n\n  @DomName('MouseEvent.screenX')\n  @DomName('MouseEvent.screenY')\n  Point get screen => new Point(_screenX, _screenY);\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n// WARNING: Do not edit - generated code.\n\n\n@DomName('MutationCallback')\ntypedef void MutationCallback(List<MutationRecord> mutations, MutationObserver observer);\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DomName('MutationObserver')\n@SupportedBrowser(SupportedBrowser.CHROME)\n@SupportedBrowser(SupportedBrowser.FIREFOX)\n@SupportedBrowser(SupportedBrowser.SAFARI)\n@Experimental()\n@Native(\"MutationObserver,WebKitMutationObserver\")\nclass MutationObserver extends Interceptor {\n\n  @DomName('MutationObserver.disconnect')\n  @DocsEditable()\n  void disconnect() native;\n\n  @DomName('MutationObserver.observe')\n  @DocsEditable()\n  void _observe(Node target, Map options) {\n    var options_1 = convertDartToNative_Dictionary(options);\n    _observe_1(target, options_1);\n    return;\n  }\n  @JSName('observe')\n  @DomName('MutationObserver.observe')\n  @DocsEditable()\n  void _observe_1(Node target, options) native;\n\n  @DomName('MutationObserver.takeRecords')\n  @DocsEditable()\n  List<MutationRecord> takeRecords() native;\n\n  /**\n   * Checks to see if the mutation observer API is supported on the current\n   * platform.\n   */\n  static bool get supported {\n    return JS('bool',\n        '!!(window.MutationObserver || window.WebKitMutationObserver)');\n  }\n\n  /**\n   * Observes the target for the specified changes.\n   *\n   * Some requirements for the optional parameters:\n   *\n   * * Either childList, attributes or characterData must be true.\n   * * If attributeOldValue is true then attributes must also be true.\n   * * If attributeFilter is specified then attributes must be true.\n   * * If characterDataOldValue is true then characterData must be true.\n   */\n  void observe(Node target,\n               {bool childList,\n                bool attributes,\n                bool characterData,\n                bool subtree,\n                bool attributeOldValue,\n                bool characterDataOldValue,\n                List<String> attributeFilter}) {\n\n    // Parse options into map of known type.\n    var parsedOptions = _createDict();\n\n    // Override options passed in the map with named optional arguments.\n    override(key, value) {\n      if (value != null) _add(parsedOptions, key, value);\n    }\n\n    override('childList', childList);\n    override('attributes', attributes);\n    override('characterData', characterData);\n    override('subtree', subtree);\n    override('attributeOldValue', attributeOldValue);\n    override('characterDataOldValue', characterDataOldValue);\n    if (attributeFilter != null) {\n      override('attributeFilter', _fixupList(attributeFilter));\n    }\n\n    _call(target, parsedOptions);\n  }\n\n   // TODO: Change to a set when const Sets are available.\n  static final _boolKeys =\n    const {'childList': true,\n           'attributes': true,\n           'characterData': true,\n           'subtree': true,\n           'attributeOldValue': true,\n           'characterDataOldValue': true };\n\n\n  static _createDict() => JS('var', '{}');\n  static _add(m, String key, value) { JS('void', '#[#] = #', m, key, value); }\n  static _fixupList(list) => list;  // TODO: Ensure is a JavaScript Array.\n\n  // Call native function with no conversions.\n  @JSName('observe')\n  void _call(target, options) native;\n\n  factory MutationObserver(MutationCallback callback) {\n    // Dummy statement to mark types as instantiated.\n    JS('MutationObserver|MutationRecord', '0');\n\n    return JS('MutationObserver',\n        'new(window.MutationObserver||window.WebKitMutationObserver||'\n        'window.MozMutationObserver)(#)',\n        convertDartClosureToJS(_wrapBinaryZone(callback), 2));\n  }\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('MutationRecord')\n@Native(\"MutationRecord\")\nclass MutationRecord extends Interceptor {\n  // To suppress missing implicit constructor warnings.\n  factory MutationRecord._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('MutationRecord.addedNodes')\n  @DocsEditable()\n  @Returns('NodeList')\n  @Creates('NodeList')\n  final List<Node> addedNodes;\n\n  @DomName('MutationRecord.attributeName')\n  @DocsEditable()\n  final String attributeName;\n\n  @DomName('MutationRecord.attributeNamespace')\n  @DocsEditable()\n  final String attributeNamespace;\n\n  @DomName('MutationRecord.nextSibling')\n  @DocsEditable()\n  final Node nextSibling;\n\n  @DomName('MutationRecord.oldValue')\n  @DocsEditable()\n  final String oldValue;\n\n  @DomName('MutationRecord.previousSibling')\n  @DocsEditable()\n  final Node previousSibling;\n\n  @DomName('MutationRecord.removedNodes')\n  @DocsEditable()\n  @Returns('NodeList')\n  @Creates('NodeList')\n  final List<Node> removedNodes;\n\n  @DomName('MutationRecord.target')\n  @DocsEditable()\n  final Node target;\n\n  @DomName('MutationRecord.type')\n  @DocsEditable()\n  final String type;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DomName('Navigator')\n@Native(\"Navigator\")\nclass Navigator extends Interceptor implements NavigatorOnLine, NavigatorID {\n\n  @DomName('Navigator.language')\n  String get language => JS('String', '#.language || #.userLanguage', this,\n      this);\n\n  /**\n   * Gets a stream (video and or audio) from the local computer.\n   *\n   * Use [MediaStream.supported] to check if this is supported by the current\n   * platform. The arguments `audio` and `video` default to `false` (stream does\n   * not use audio or video, respectively).\n   *\n   * Simple example usage:\n   *\n   *     window.navigator.getUserMedia(audio: true, video: true).then((stream) {\n   *       var video = new VideoElement()\n   *         ..autoplay = true\n   *         ..src = Url.createObjectUrlFromStream(stream);\n   *       document.body.append(video);\n   *     });\n   *\n   * The user can also pass in Maps to the audio or video parameters to specify\n   * mandatory and optional constraints for the media stream. Not passing in a\n   * map, but passing in `true` will provide a MediaStream with audio or\n   * video capabilities, but without any additional constraints. The particular\n   * constraint names for audio and video are still in flux, but as of this\n   * writing, here is an example providing more constraints.\n   *\n   *     window.navigator.getUserMedia(\n   *         audio: true,\n   *         video: {'mandatory':\n   *                    { 'minAspectRatio': 1.333, 'maxAspectRatio': 1.334 },\n   *                 'optional':\n   *                    [{ 'minFrameRate': 60 },\n   *                     { 'maxWidth': 640 }]\n   *     });\n   *\n   * See also:\n   * * [MediaStream.supported]\n   */\n  @DomName('Navigator.webkitGetUserMedia')\n  @SupportedBrowser(SupportedBrowser.CHROME)\n  @Experimental()\n  Future<MediaStream> getUserMedia({audio: false, video: false}) {\n    var completer = new Completer<MediaStream>();\n    var options = {\n      'audio': audio,\n      'video': video\n    };\n    _ensureGetUserMedia();\n    this._getUserMedia(convertDartToNative_SerializedScriptValue(options),\n      (stream) {\n        completer.complete(stream);\n      },\n      (error) {\n        completer.completeError(error);\n      });\n    return completer.future;\n  }\n\n  _ensureGetUserMedia() {\n    if (JS('bool', '!(#.getUserMedia)', this)) {\n      JS('void', '#.getUserMedia = '\n          '(#.getUserMedia || #.webkitGetUserMedia || #.mozGetUserMedia ||'\n          '#.msGetUserMedia)', this, this, this, this, this);\n    }\n  }\n\n  @JSName('getUserMedia')\n  void _getUserMedia(options, _NavigatorUserMediaSuccessCallback success,\n      _NavigatorUserMediaErrorCallback error) native;\n\n  // To suppress missing implicit constructor warnings.\n  factory Navigator._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('Navigator.cookieEnabled')\n  @DocsEditable()\n  @Unstable()\n  final bool cookieEnabled;\n\n  @DomName('Navigator.doNotTrack')\n  @DocsEditable()\n  // http://www.w3.org/2011/tracking-protection/drafts/tracking-dnt.html#js-dom\n  @Experimental() // experimental\n  final String doNotTrack;\n\n  @DomName('Navigator.geolocation')\n  @DocsEditable()\n  @Unstable()\n  final Geolocation geolocation;\n\n  @DomName('Navigator.maxTouchPoints')\n  @DocsEditable()\n  @Experimental() // untriaged\n  final int maxTouchPoints;\n\n  @DomName('Navigator.mimeTypes')\n  @DocsEditable()\n  @Experimental() // nonstandard\n  final MimeTypeArray mimeTypes;\n\n  @DomName('Navigator.productSub')\n  @DocsEditable()\n  @Unstable()\n  final String productSub;\n\n  @DomName('Navigator.serviceWorker')\n  @DocsEditable()\n  @Experimental() // untriaged\n  final ServiceWorkerContainer serviceWorker;\n\n  @DomName('Navigator.storageQuota')\n  @DocsEditable()\n  @Experimental() // untriaged\n  final StorageQuota storageQuota;\n\n  @DomName('Navigator.vendor')\n  @DocsEditable()\n  @Unstable()\n  final String vendor;\n\n  @DomName('Navigator.vendorSub')\n  @DocsEditable()\n  @Unstable()\n  final String vendorSub;\n\n  @JSName('webkitPersistentStorage')\n  @DomName('Navigator.webkitPersistentStorage')\n  @DocsEditable()\n  @SupportedBrowser(SupportedBrowser.CHROME)\n  @SupportedBrowser(SupportedBrowser.SAFARI)\n  @Experimental()\n  // http://www.w3.org/TR/quota-api/#accessing-storagequota\n  final DeprecatedStorageQuota persistentStorage;\n\n  @JSName('webkitTemporaryStorage')\n  @DomName('Navigator.webkitTemporaryStorage')\n  @DocsEditable()\n  @SupportedBrowser(SupportedBrowser.CHROME)\n  @SupportedBrowser(SupportedBrowser.SAFARI)\n  @Experimental()\n  // http://www.w3.org/TR/quota-api/#accessing-storagequota\n  final DeprecatedStorageQuota temporaryStorage;\n\n  @DomName('Navigator.getStorageUpdates')\n  @DocsEditable()\n  // http://www.whatwg.org/specs/web-apps/current-work/multipage/timers.html#navigatorstorageutils\n  @Experimental()\n  void getStorageUpdates() native;\n\n  @DomName('Navigator.isProtocolHandlerRegistered')\n  @DocsEditable()\n  @Experimental() // untriaged\n  String isProtocolHandlerRegistered(String scheme, String url) native;\n\n  @DomName('Navigator.registerProtocolHandler')\n  @DocsEditable()\n  @Unstable()\n  void registerProtocolHandler(String scheme, String url, String title) native;\n\n  @DomName('Navigator.requestMIDIAccess')\n  @DocsEditable()\n  @Experimental() // untriaged\n  MidiAccessPromise requestMidiAccess([Map options]) {\n    if (options != null) {\n      var options_1 = convertDartToNative_Dictionary(options);\n      return _requestMidiAccess_1(options_1);\n    }\n    return _requestMidiAccess_2();\n  }\n  @JSName('requestMIDIAccess')\n  @DomName('Navigator.requestMIDIAccess')\n  @DocsEditable()\n  @Experimental() // untriaged\n  MidiAccessPromise _requestMidiAccess_1(options) native;\n  @JSName('requestMIDIAccess')\n  @DomName('Navigator.requestMIDIAccess')\n  @DocsEditable()\n  @Experimental() // untriaged\n  MidiAccessPromise _requestMidiAccess_2() native;\n\n  @DomName('Navigator.unregisterProtocolHandler')\n  @DocsEditable()\n  @Experimental() // untriaged\n  void unregisterProtocolHandler(String scheme, String url) native;\n\n  @JSName('webkitGetGamepads')\n  @DomName('Navigator.webkitGetGamepads')\n  @DocsEditable()\n  @SupportedBrowser(SupportedBrowser.CHROME)\n  @SupportedBrowser(SupportedBrowser.SAFARI)\n  @Experimental()\n  // https://dvcs.w3.org/hg/gamepad/raw-file/default/gamepad.html#widl-Navigator-getGamepads-Gamepad\n  @Returns('_GamepadList')\n  @Creates('_GamepadList')\n  List<Gamepad> getGamepads() native;\n\n  // From NavigatorID\n\n  @DomName('Navigator.appCodeName')\n  @DocsEditable()\n  @Experimental() // non-standard\n  final String appCodeName;\n\n  @DomName('Navigator.appName')\n  @DocsEditable()\n  final String appName;\n\n  @DomName('Navigator.appVersion')\n  @DocsEditable()\n  final String appVersion;\n\n  @DomName('Navigator.platform')\n  @DocsEditable()\n  final String platform;\n\n  @DomName('Navigator.product')\n  @DocsEditable()\n  @Unstable()\n  final String product;\n\n  @DomName('Navigator.userAgent')\n  @DocsEditable()\n  final String userAgent;\n\n  // From NavigatorOnLine\n\n  @DomName('Navigator.onLine')\n  @DocsEditable()\n  @Unstable()\n  final bool onLine;\n\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('NavigatorID')\n@Experimental() // untriaged\nabstract class NavigatorID extends Interceptor {\n  // To suppress missing implicit constructor warnings.\n  factory NavigatorID._() { throw new UnsupportedError(\"Not supported\"); }\n\n  final String appCodeName;\n\n  final String appName;\n\n  final String appVersion;\n\n  final String platform;\n\n  final String product;\n\n  final String userAgent;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('NavigatorOnLine')\n@Experimental() // untriaged\nabstract class NavigatorOnLine extends Interceptor {\n  // To suppress missing implicit constructor warnings.\n  factory NavigatorOnLine._() { throw new UnsupportedError(\"Not supported\"); }\n\n  final bool onLine;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('NavigatorUserMediaError')\n// http://dev.w3.org/2011/webrtc/editor/getusermedia.html#idl-def-NavigatorUserMediaError\n@Experimental()\n@Native(\"NavigatorUserMediaError\")\nclass NavigatorUserMediaError extends Interceptor {\n  // To suppress missing implicit constructor warnings.\n  factory NavigatorUserMediaError._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('NavigatorUserMediaError.constraintName')\n  @DocsEditable()\n  final String constraintName;\n\n  @DomName('NavigatorUserMediaError.message')\n  @DocsEditable()\n  final String message;\n\n  @DomName('NavigatorUserMediaError.name')\n  @DocsEditable()\n  final String name;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n// WARNING: Do not edit - generated code.\n\n\n@DomName('NavigatorUserMediaErrorCallback')\n// http://dev.w3.org/2011/webrtc/editor/getusermedia.html#idl-def-NavigatorUserMediaErrorCallback\n@Experimental()\ntypedef void _NavigatorUserMediaErrorCallback(NavigatorUserMediaError error);\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n// WARNING: Do not edit - generated code.\n\n\n@DomName('NavigatorUserMediaSuccessCallback')\n// http://dev.w3.org/2011/webrtc/editor/getusermedia.html#idl-def-NavigatorUserMediaSuccessCallback\n@Experimental()\ntypedef void _NavigatorUserMediaSuccessCallback(MediaStream stream);\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n/**\n * Lazy implementation of the child nodes of an element that does not request\n * the actual child nodes of an element until strictly necessary greatly\n * improving performance for the typical cases where it is not required.\n */\nclass _ChildNodeListLazy extends ListBase<Node> implements NodeListWrapper {\n  final Node _this;\n\n  _ChildNodeListLazy(this._this);\n\n\n  Node get first {\n    Node result = JS('Node|Null', '#.firstChild', _this);\n    if (result == null) throw new StateError(\"No elements\");\n    return result;\n  }\n  Node get last {\n    Node result = JS('Node|Null', '#.lastChild', _this);\n    if (result == null) throw new StateError(\"No elements\");\n    return result;\n  }\n  Node get single {\n    int l = this.length;\n    if (l == 0) throw new StateError(\"No elements\");\n    if (l > 1) throw new StateError(\"More than one element\");\n    return JS('Node|Null', '#.firstChild', _this);\n  }\n\n  void add(Node value) {\n    _this.append(value);\n  }\n\n  void addAll(Iterable<Node> iterable) {\n    if (iterable is _ChildNodeListLazy) {\n      _ChildNodeListLazy otherList = iterable;\n      if (!identical(otherList._this, _this)) {\n        // Optimized route for copying between nodes.\n        for (var i = 0, len = otherList.length; i < len; ++i) {\n          _this.append(otherList._this.firstChild);\n        }\n      }\n      return;\n    }\n    for (Node node in iterable) {\n      _this.append(node);\n    }\n  }\n\n  void insert(int index, Node node) {\n    if (index < 0 || index > length) {\n      throw new RangeError.range(index, 0, length);\n    }\n    if (index == length) {\n      _this.append(node);\n    } else {\n      _this.insertBefore(node, this[index]);\n    }\n  }\n\n  void insertAll(int index, Iterable<Node> iterable) {\n    var item = this[index];\n    _this.insertAllBefore(iterable, item);\n  }\n\n  void setAll(int index, Iterable<Node> iterable) {\n    throw new UnsupportedError(\"Cannot setAll on Node list\");\n  }\n\n  Node removeLast() {\n    final result = last;\n    if (result != null) {\n      _this._removeChild(result);\n    }\n    return result;\n  }\n\n  Node removeAt(int index) {\n    var result = this[index];\n    if (result != null) {\n      _this._removeChild(result);\n    }\n    return result;\n  }\n\n  bool remove(Object object) {\n    if (object is! Node) return false;\n    Node node = object;\n    if (!identical(_this, node.parentNode)) return false;\n    _this._removeChild(node);\n    return true;\n  }\n\n  void _filter(bool test(Node node), bool removeMatching) {\n    // This implementation of removeWhere/retainWhere is more efficient\n    // than the default in ListBase. Child nodes can be removed in constant\n    // time.\n    Node child = _this.firstChild;\n    while (child != null) {\n      Node nextChild = child.nextNode;\n      if (test(child) == removeMatching) {\n        _this._removeChild(child);\n      }\n      child = nextChild;\n    }\n  }\n\n  void removeWhere(bool test(Node node)) {\n    _filter(test, true);\n  }\n\n  void retainWhere(bool test(Node node)) {\n    _filter(test, false);\n  }\n\n  void clear() {\n    _this._clearChildren();\n  }\n\n  void operator []=(int index, Node value) {\n    _this._replaceChild(value, this[index]);\n  }\n\n  Iterator<Node> get iterator => _this.childNodes.iterator;\n\n  // From List<Node>:\n\n  // TODO(jacobr): this could be implemented for child node lists.\n  // The exception we throw here is misleading.\n  void sort([Comparator<Node> compare]) {\n    throw new UnsupportedError(\"Cannot sort Node list\");\n  }\n\n  void shuffle([Random random]) {\n    throw new UnsupportedError(\"Cannot shuffle Node list\");\n  }\n\n  // FIXME: implement these.\n  void setRange(int start, int end, Iterable<Node> iterable,\n                [int skipCount = 0]) {\n    throw new UnsupportedError(\"Cannot setRange on Node list\");\n  }\n\n  void fillRange(int start, int end, [Node fill]) {\n    throw new UnsupportedError(\"Cannot fillRange on Node list\");\n  }\n  // -- end List<Node> mixins.\n\n  // TODO(jacobr): benchmark whether this is more efficient or whether caching\n  // a local copy of childNodes is more efficient.\n  int get length => _this.childNodes.length;\n\n  void set length(int value) {\n    throw new UnsupportedError(\n        \"Cannot set length on immutable List.\");\n  }\n\n  Node operator[](int index) => _this.childNodes[index];\n\n  List<Node> get rawList => _this.childNodes;\n}\n\n\n@DomName('Node')\n@Native(\"Node\")\nclass Node extends EventTarget {\n\n  // Custom element created callback.\n  Node._created() : super._created();\n\n  /**\n   * A modifiable list of this node's children.\n   */\n  List<Node> get nodes {\n    return new _ChildNodeListLazy(this);\n  }\n\n  void set nodes(Iterable<Node> value) {\n    // Copy list first since we don't want liveness during iteration.\n    // TODO(jacobr): there is a better way to do this.\n    List copy = new List.from(value);\n    text = '';\n    for (Node node in copy) {\n      append(node);\n    }\n  }\n\n  /**\n   * Removes this node from the DOM.\n   */\n  @DomName('Node.removeChild')\n  void remove() {\n    // TODO(jacobr): should we throw an exception if parent is already null?\n    // TODO(vsm): Use the native remove when available.\n    if (this.parentNode != null) {\n      final Node parent = this.parentNode;\n      parentNode._removeChild(this);\n    }\n  }\n\n  /**\n   * Replaces this node with another node.\n   */\n  @DomName('Node.replaceChild')\n  Node replaceWith(Node otherNode) {\n    try {\n      final Node parent = this.parentNode;\n      parent._replaceChild(otherNode, this);\n    } catch (e) {\n\n    };\n    return this;\n  }\n\n  /**\n   * Inserts all of the nodes into this node directly before refChild.\n   *\n   * See also:\n   *\n   * * [insertBefore]\n   */\n  Node insertAllBefore(Iterable<Node> newNodes, Node refChild) {\n    if (newNodes is _ChildNodeListLazy) {\n      _ChildNodeListLazy otherList = newNodes;\n      if (identical(otherList._this, this)) {\n        throw new ArgumentError(newNodes);\n      }\n\n      // Optimized route for copying between nodes.\n      for (var i = 0, len = otherList.length; i < len; ++i) {\n        this.insertBefore(otherList._this.firstChild, refChild);\n      }\n    } else {\n      for (var node in newNodes) {\n        this.insertBefore(node, refChild);\n      }\n    }\n  }\n\n  void _clearChildren() {\n    while (firstChild != null) {\n      _removeChild(firstChild);\n    }\n  }\n\n  /**\n   * Print out a String representation of this Node.\n   */\n  String toString() => nodeValue == null ? super.toString() : nodeValue;\n  // To suppress missing implicit constructor warnings.\n  factory Node._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('Node.ATTRIBUTE_NODE')\n  @DocsEditable()\n  static const int ATTRIBUTE_NODE = 2;\n\n  @DomName('Node.CDATA_SECTION_NODE')\n  @DocsEditable()\n  static const int CDATA_SECTION_NODE = 4;\n\n  @DomName('Node.COMMENT_NODE')\n  @DocsEditable()\n  static const int COMMENT_NODE = 8;\n\n  @DomName('Node.DOCUMENT_FRAGMENT_NODE')\n  @DocsEditable()\n  static const int DOCUMENT_FRAGMENT_NODE = 11;\n\n  @DomName('Node.DOCUMENT_NODE')\n  @DocsEditable()\n  static const int DOCUMENT_NODE = 9;\n\n  @DomName('Node.DOCUMENT_TYPE_NODE')\n  @DocsEditable()\n  static const int DOCUMENT_TYPE_NODE = 10;\n\n  @DomName('Node.ELEMENT_NODE')\n  @DocsEditable()\n  static const int ELEMENT_NODE = 1;\n\n  @DomName('Node.ENTITY_NODE')\n  @DocsEditable()\n  static const int ENTITY_NODE = 6;\n\n  @DomName('Node.ENTITY_REFERENCE_NODE')\n  @DocsEditable()\n  static const int ENTITY_REFERENCE_NODE = 5;\n\n  @DomName('Node.NOTATION_NODE')\n  @DocsEditable()\n  static const int NOTATION_NODE = 12;\n\n  @DomName('Node.PROCESSING_INSTRUCTION_NODE')\n  @DocsEditable()\n  static const int PROCESSING_INSTRUCTION_NODE = 7;\n\n  @DomName('Node.TEXT_NODE')\n  @DocsEditable()\n  static const int TEXT_NODE = 3;\n\n  @JSName('baseURI')\n  @DomName('Node.baseURI')\n  @DocsEditable()\n  final String baseUri;\n\n  /**\n   * A list of this node's children.\n   *\n   * ## Other resources\n   *\n   * * [Node.childNodes]\n   * (https://developer.mozilla.org/en-US/docs/Web/API/Node.childNodes)\n   * from MDN.\n   */\n  @DomName('Node.childNodes')\n  @DocsEditable()\n  @Returns('NodeList')\n  @Creates('NodeList')\n  final List<Node> childNodes;\n\n  /**\n   * The first child of this node.\n   *\n   * ## Other resources\n   *\n   * * [Node.firstChild]\n   * (https://developer.mozilla.org/en-US/docs/Web/API/Node.firstChild)\n   * from MDN.\n   */\n  @DomName('Node.firstChild')\n  @DocsEditable()\n  final Node firstChild;\n\n  /**\n   * The last child of this node.\n   *\n   * ## Other resources\n   *\n   * * [Node.lastChild]\n   * (https://developer.mozilla.org/en-US/docs/Web/API/Node.lastChild)\n   * from MDN.\n   */\n  @DomName('Node.lastChild')\n  @DocsEditable()\n  final Node lastChild;\n\n  @JSName('localName')\n  @DomName('Node.localName')\n  @DocsEditable()\n  final String _localName;\n\n  @JSName('namespaceURI')\n  @DomName('Node.namespaceURI')\n  @DocsEditable()\n  final String _namespaceUri;\n\n  @JSName('nextSibling')\n  /**\n   * The next sibling node.\n   *\n   * ## Other resources\n   *\n   * * [Node.nextSibling]\n   * (https://developer.mozilla.org/en-US/docs/Web/API/Node.nextSibling)\n   * from MDN.\n   */\n  @DomName('Node.nextSibling')\n  @DocsEditable()\n  final Node nextNode;\n\n  /**\n   * The name of this node.\n   *\n   * This varies by this node's [nodeType].\n   *\n   * ## Other resources\n   *\n   * * [Node.nodeName]\n   * (https://developer.mozilla.org/en-US/docs/Web/API/Node.nodeName)\n   * from MDN. This page contains a table of [nodeName] values for each\n   * [nodeType].\n   */\n  @DomName('Node.nodeName')\n  @DocsEditable()\n  final String nodeName;\n\n  /**\n   * The type of node.\n   *\n   * This value is one of:\n   *\n   * * [ATTRIBUTE_NODE] if this node is an attribute.\n   * * [CDATA_SECTION_NODE] if this node is a [CDataSection].\n   * * [COMMENT_NODE] if this node is a [Comment].\n   * * [DOCUMENT_FRAGMENT_NODE] if this node is a [DocumentFragment].\n   * * [DOCUMENT_NODE] if this node is a [Document].\n   * * [DOCUMENT_TYPE_NODE] if this node is a [DocumentType] node.\n   * * [ELEMENT_NODE] if this node is an [Element].\n   * * [ENTITY_NODE] if this node is an entity.\n   * * [ENTITY_REFERENCE_NODE] if this node is an entity reference.\n   * * [NOTATION_NODE] if this node is a notation.\n   * * [PROCESSING_INSTRUCTION_NODE] if this node is a [ProcessingInstruction].\n   * * [TEXT_NODE] if this node is a [Text] node.\n   *\n   * ## Other resources\n   *\n   * * [Node.nodeType]\n   * (https://developer.mozilla.org/en-US/docs/Web/API/Node.nodeType) from MDN.\n   */\n  @DomName('Node.nodeType')\n  @DocsEditable()\n  final int nodeType;\n\n  /**\n   * The value of this node.\n   *\n   * This varies by this type's [nodeType].\n   *\n   * ## Other resources\n   *\n   * * [Node.nodeValue]\n   * (https://developer.mozilla.org/en-US/docs/Web/API/Node.nodeValue)\n   * from MDN. This page contains a table of [nodeValue] values for each\n   * [nodeType].\n   */\n  @DomName('Node.nodeValue')\n  @DocsEditable()\n  final String nodeValue;\n\n  /**\n   * The document this node belongs to.\n   *\n   * Returns null if this node does not belong to any document.\n   *\n   * ## Other resources\n   *\n   * * [Node.ownerDocument]\n   * (https://developer.mozilla.org/en-US/docs/Web/API/Node.ownerDocument) from\n   * MDN.\n   */\n  @DomName('Node.ownerDocument')\n  @DocsEditable()\n  final Document ownerDocument;\n\n  @JSName('parentElement')\n  /**\n   * The parent element of this node.\n   *\n   * Returns null if this node either does not have a parent or its parent is\n   * not an element.\n   *\n   * ## Other resources\n   *\n   * * [Node.parentElement]\n   * (https://developer.mozilla.org/en-US/docs/Web/API/Node.parentElement) from\n   * W3C.\n   */\n  @DomName('Node.parentElement')\n  @DocsEditable()\n  final Element parent;\n\n  /**\n   * The parent node of this node.\n   *\n   * ## Other resources\n   *\n   * * [Node.parentNode]\n   * (https://developer.mozilla.org/en-US/docs/Web/API/Node.parentNode) from\n   * MDN.\n   */\n  @DomName('Node.parentNode')\n  @DocsEditable()\n  final Node parentNode;\n\n  @JSName('previousSibling')\n  /**\n   * The previous sibling node.\n   *\n   * ## Other resources\n   *\n   * * [Node.previousSibling]\n   * (https://developer.mozilla.org/en-US/docs/Web/API/Node.previousSibling)\n   * from MDN.\n   */\n  @DomName('Node.previousSibling')\n  @DocsEditable()\n  final Node previousNode;\n\n  @JSName('textContent')\n  /**\n   * All text within this node and its decendents.\n   *\n   * ## Other resources\n   *\n   * * [Node.textContent]\n   * (https://developer.mozilla.org/en-US/docs/Web/API/Node.textContent) from\n   * MDN.\n   */\n  @DomName('Node.textContent')\n  @DocsEditable()\n  String text;\n\n  @JSName('appendChild')\n  /**\n   * Adds a node to the end of the child [nodes] list of this node.\n   *\n   * If the node already exists in this document, it will be removed from its\n   * current parent node, then added to this node.\n   *\n   * This method is more efficient than `nodes.add`, and is the preferred\n   * way of appending a child node.\n   */\n  @DomName('Node.appendChild')\n  @DocsEditable()\n  Node append(Node newChild) native;\n\n  @JSName('cloneNode')\n  /**\n   * Returns a copy of this node.\n   *\n   * If [deep] is `true`, then all of this node's children and decendents are\n   * copied as well. If [deep] is `false`, then only this node is copied.\n   *\n   * ## Other resources\n   *\n   * * [Node.cloneNode]\n   * (https://developer.mozilla.org/en-US/docs/Web/API/Node.cloneNode) from\n   * MDN.\n   */\n  @DomName('Node.cloneNode')\n  @DocsEditable()\n  Node clone(bool deep) native;\n\n  /**\n   * Returns true if this node contains the specified node.\n   *\n   * ## Other resources\n   *\n   * * [Node.contains]\n   * (https://developer.mozilla.org/en-US/docs/Web/API/Node.contains) from MDN.\n   */\n  @DomName('Node.contains')\n  @DocsEditable()\n  bool contains(Node other) native;\n\n  /**\n   * Returns true if this node has any children.\n   *\n   * ## Other resources\n   *\n   * * [Node.hasChildNodes]\n   * (https://developer.mozilla.org/en-US/docs/Web/API/Node.hasChildNodes) from\n   * MDN.\n   */\n  @DomName('Node.hasChildNodes')\n  @DocsEditable()\n  bool hasChildNodes() native;\n\n  /**\n   * Inserts all of the nodes into this node directly before refChild.\n   *\n   * ## Other resources\n   *\n   * * [Node.insertBefore]\n   * (https://developer.mozilla.org/en-US/docs/Web/API/Node.insertBefore) from\n   * MDN.\n   */\n  @DomName('Node.insertBefore')\n  @DocsEditable()\n  Node insertBefore(Node newChild, Node refChild) native;\n\n  @JSName('removeChild')\n  @DomName('Node.removeChild')\n  @DocsEditable()\n  Node _removeChild(Node oldChild) native;\n\n  @JSName('replaceChild')\n  @DomName('Node.replaceChild')\n  @DocsEditable()\n  Node _replaceChild(Node newChild, Node oldChild) native;\n\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('NodeFilter')\n@Unstable()\n@Native(\"NodeFilter\")\nclass NodeFilter extends Interceptor {\n  // To suppress missing implicit constructor warnings.\n  factory NodeFilter._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('NodeFilter.FILTER_ACCEPT')\n  @DocsEditable()\n  static const int FILTER_ACCEPT = 1;\n\n  @DomName('NodeFilter.FILTER_REJECT')\n  @DocsEditable()\n  static const int FILTER_REJECT = 2;\n\n  @DomName('NodeFilter.FILTER_SKIP')\n  @DocsEditable()\n  static const int FILTER_SKIP = 3;\n\n  @DomName('NodeFilter.SHOW_ALL')\n  @DocsEditable()\n  static const int SHOW_ALL = 0xFFFFFFFF;\n\n  @DomName('NodeFilter.SHOW_COMMENT')\n  @DocsEditable()\n  static const int SHOW_COMMENT = 0x00000080;\n\n  @DomName('NodeFilter.SHOW_DOCUMENT')\n  @DocsEditable()\n  static const int SHOW_DOCUMENT = 0x00000100;\n\n  @DomName('NodeFilter.SHOW_DOCUMENT_FRAGMENT')\n  @DocsEditable()\n  static const int SHOW_DOCUMENT_FRAGMENT = 0x00000400;\n\n  @DomName('NodeFilter.SHOW_DOCUMENT_TYPE')\n  @DocsEditable()\n  static const int SHOW_DOCUMENT_TYPE = 0x00000200;\n\n  @DomName('NodeFilter.SHOW_ELEMENT')\n  @DocsEditable()\n  static const int SHOW_ELEMENT = 0x00000001;\n\n  @DomName('NodeFilter.SHOW_PROCESSING_INSTRUCTION')\n  @DocsEditable()\n  static const int SHOW_PROCESSING_INSTRUCTION = 0x00000040;\n\n  @DomName('NodeFilter.SHOW_TEXT')\n  @DocsEditable()\n  static const int SHOW_TEXT = 0x00000004;\n}\n// Copyright (c) 2013, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DomName('NodeIterator')\n@Unstable()\n@Native(\"NodeIterator\")\nclass NodeIterator extends Interceptor {\n  factory NodeIterator(Node root, int whatToShow) {\n    return document._createNodeIterator(root, whatToShow, null);\n  }\n  // To suppress missing implicit constructor warnings.\n  factory NodeIterator._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('NodeIterator.pointerBeforeReferenceNode')\n  @DocsEditable()\n  final bool pointerBeforeReferenceNode;\n\n  @DomName('NodeIterator.referenceNode')\n  @DocsEditable()\n  final Node referenceNode;\n\n  @DomName('NodeIterator.root')\n  @DocsEditable()\n  final Node root;\n\n  @DomName('NodeIterator.whatToShow')\n  @DocsEditable()\n  final int whatToShow;\n\n  @DomName('NodeIterator.detach')\n  @DocsEditable()\n  void detach() native;\n\n  @DomName('NodeIterator.nextNode')\n  @DocsEditable()\n  Node nextNode() native;\n\n  @DomName('NodeIterator.previousNode')\n  @DocsEditable()\n  Node previousNode() native;\n\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('NodeList')\n@Native(\"NodeList,RadioNodeList\")\nclass NodeList extends Interceptor with ListMixin<Node>, ImmutableListMixin<Node> implements JavaScriptIndexingBehavior, List<Node> {\n  // To suppress missing implicit constructor warnings.\n  factory NodeList._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('NodeList.length')\n  @DocsEditable()\n  int get length => JS(\"int\", \"#.length\", this);\n\n  Node operator[](int index) {\n    if (JS(\"bool\", \"# >>> 0 !== # || # >= #\", index,\n        index, index, length))\n      throw new RangeError.range(index, 0, length);\n    return JS(\"Node\", \"#[#]\", this, index);\n  }\n  void operator[]=(int index, Node value) {\n    throw new UnsupportedError(\"Cannot assign element of immutable List.\");\n  }\n  // -- start List<Node> mixins.\n  // Node is the element type.\n\n\n  void set length(int value) {\n    throw new UnsupportedError(\"Cannot resize immutable List.\");\n  }\n\n  Node get first {\n    if (this.length > 0) {\n      return JS('Node', '#[0]', this);\n    }\n    throw new StateError(\"No elements\");\n  }\n\n  Node get last {\n    int len = this.length;\n    if (len > 0) {\n      return JS('Node', '#[#]', this, len - 1);\n    }\n    throw new StateError(\"No elements\");\n  }\n\n  Node get single {\n    int len = this.length;\n    if (len == 1) {\n      return JS('Node', '#[0]', this);\n    }\n    if (len == 0) throw new StateError(\"No elements\");\n    throw new StateError(\"More than one element\");\n  }\n\n  Node elementAt(int index) => this[index];\n  // -- end List<Node> mixins.\n\n  @JSName('item')\n  @DomName('NodeList.item')\n  @DocsEditable()\n  Node _item(int index) native;\n}\n// Copyright (c) 2013, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DomName('Notification')\n// http://www.w3.org/TR/notifications/#notification\n@Experimental() // experimental\n@Native(\"Notification\")\nclass Notification extends EventTarget {\n\n  factory Notification(String title, {String titleDir: null, String body: null,\n      String bodyDir: null, String tag: null, String iconUrl: null}) {\n\n    var parsedOptions = {};\n    if (titleDir != null) parsedOptions['titleDir'] = titleDir;\n    if (body != null) parsedOptions['body'] = body;\n    if (bodyDir != null) parsedOptions['bodyDir'] = bodyDir;\n    if (tag != null) parsedOptions['tag'] = tag;\n    if (iconUrl != null) parsedOptions['iconUrl'] = iconUrl;\n\n    return Notification._factoryNotification(title, parsedOptions);\n  }\n  // To suppress missing implicit constructor warnings.\n  factory Notification._() { throw new UnsupportedError(\"Not supported\"); }\n\n  /**\n   * Static factory designed to expose `click` events to event\n   * handlers that are not necessarily instances of [Notification].\n   *\n   * See [EventStreamProvider] for usage information.\n   */\n  @DomName('Notification.clickEvent')\n  @DocsEditable()\n  static const EventStreamProvider<Event> clickEvent = const EventStreamProvider<Event>('click');\n\n  /**\n   * Static factory designed to expose `close` events to event\n   * handlers that are not necessarily instances of [Notification].\n   *\n   * See [EventStreamProvider] for usage information.\n   */\n  @DomName('Notification.closeEvent')\n  @DocsEditable()\n  static const EventStreamProvider<Event> closeEvent = const EventStreamProvider<Event>('close');\n\n  /**\n   * Static factory designed to expose `error` events to event\n   * handlers that are not necessarily instances of [Notification].\n   *\n   * See [EventStreamProvider] for usage information.\n   */\n  @DomName('Notification.errorEvent')\n  @DocsEditable()\n  static const EventStreamProvider<Event> errorEvent = const EventStreamProvider<Event>('error');\n\n  /**\n   * Static factory designed to expose `show` events to event\n   * handlers that are not necessarily instances of [Notification].\n   *\n   * See [EventStreamProvider] for usage information.\n   */\n  @DomName('Notification.showEvent')\n  @DocsEditable()\n  static const EventStreamProvider<Event> showEvent = const EventStreamProvider<Event>('show');\n\n  @DomName('Notification.Notification')\n  @DocsEditable()\n  static Notification _factoryNotification(String title, [Map options]) {\n    if (options != null) {\n      return Notification._create_1(title, options);\n    }\n    return Notification._create_2(title);\n  }\n  static Notification _create_1(title, options) => JS('Notification', 'new Notification(#,#)', title, options);\n  static Notification _create_2(title) => JS('Notification', 'new Notification(#)', title);\n\n  @DomName('Notification.body')\n  @DocsEditable()\n  @Experimental() // untriaged\n  final String body;\n\n  @DomName('Notification.dir')\n  @DocsEditable()\n  @Experimental() // nonstandard\n  final String dir;\n\n  @DomName('Notification.icon')\n  @DocsEditable()\n  @Experimental() // untriaged\n  final String icon;\n\n  @DomName('Notification.lang')\n  @DocsEditable()\n  @Experimental() // untriaged\n  final String lang;\n\n  @DomName('Notification.permission')\n  @DocsEditable()\n  final String permission;\n\n  @DomName('Notification.tag')\n  @DocsEditable()\n  @Experimental() // nonstandard\n  final String tag;\n\n  @DomName('Notification.title')\n  @DocsEditable()\n  @Experimental() // untriaged\n  final String title;\n\n  @DomName('Notification.close')\n  @DocsEditable()\n  void close() native;\n\n  @JSName('requestPermission')\n  @DomName('Notification.requestPermission')\n  @DocsEditable()\n  static void _requestPermission([_NotificationPermissionCallback callback]) native;\n\n  @JSName('requestPermission')\n  @DomName('Notification.requestPermission')\n  @DocsEditable()\n  static Future<String> requestPermission() {\n    var completer = new Completer<String>();\n    _requestPermission(\n        (value) { completer.complete(value); });\n    return completer.future;\n  }\n\n  /// Stream of `click` events handled by this [Notification].\n  @DomName('Notification.onclick')\n  @DocsEditable()\n  Stream<Event> get onClick => clickEvent.forTarget(this);\n\n  /// Stream of `close` events handled by this [Notification].\n  @DomName('Notification.onclose')\n  @DocsEditable()\n  Stream<Event> get onClose => closeEvent.forTarget(this);\n\n  /// Stream of `error` events handled by this [Notification].\n  @DomName('Notification.onerror')\n  @DocsEditable()\n  Stream<Event> get onError => errorEvent.forTarget(this);\n\n  /// Stream of `show` events handled by this [Notification].\n  @DomName('Notification.onshow')\n  @DocsEditable()\n  Stream<Event> get onShow => showEvent.forTarget(this);\n\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n// WARNING: Do not edit - generated code.\n\n\n@DomName('NotificationPermissionCallback')\n// http://www.w3.org/TR/notifications/#notificationpermissioncallback\n@Experimental()\ntypedef void _NotificationPermissionCallback(String permission);\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('HTMLOListElement')\n@Native(\"HTMLOListElement\")\nclass OListElement extends HtmlElement {\n  // To suppress missing implicit constructor warnings.\n  factory OListElement._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('HTMLOListElement.HTMLOListElement')\n  @DocsEditable()\n  factory OListElement() => document.createElement(\"ol\");\n  /**\n   * Constructor instantiated by the DOM when a custom element has been created.\n   *\n   * This can only be called by subclasses from their created constructor.\n   */\n  OListElement.created() : super.created();\n\n  @DomName('HTMLOListElement.reversed')\n  @DocsEditable()\n  bool reversed;\n\n  @DomName('HTMLOListElement.start')\n  @DocsEditable()\n  int start;\n\n  @DomName('HTMLOListElement.type')\n  @DocsEditable()\n  String type;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('HTMLObjectElement')\n@SupportedBrowser(SupportedBrowser.CHROME)\n@SupportedBrowser(SupportedBrowser.IE)\n@SupportedBrowser(SupportedBrowser.SAFARI)\n@Unstable()\n@Native(\"HTMLObjectElement\")\nclass ObjectElement extends HtmlElement {\n  // To suppress missing implicit constructor warnings.\n  factory ObjectElement._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('HTMLObjectElement.HTMLObjectElement')\n  @DocsEditable()\n  factory ObjectElement() => document.createElement(\"object\");\n  /**\n   * Constructor instantiated by the DOM when a custom element has been created.\n   *\n   * This can only be called by subclasses from their created constructor.\n   */\n  ObjectElement.created() : super.created();\n\n  /// Checks if this type is supported on the current platform.\n  static bool get supported => Element.isTagSupported('object');\n\n  @DomName('HTMLObjectElement.data')\n  @DocsEditable()\n  String data;\n\n  @DomName('HTMLObjectElement.form')\n  @DocsEditable()\n  final FormElement form;\n\n  @DomName('HTMLObjectElement.height')\n  @DocsEditable()\n  String height;\n\n  @DomName('HTMLObjectElement.name')\n  @DocsEditable()\n  String name;\n\n  @DomName('HTMLObjectElement.type')\n  @DocsEditable()\n  String type;\n\n  @DomName('HTMLObjectElement.useMap')\n  @DocsEditable()\n  String useMap;\n\n  @DomName('HTMLObjectElement.validationMessage')\n  @DocsEditable()\n  final String validationMessage;\n\n  @DomName('HTMLObjectElement.validity')\n  @DocsEditable()\n  final ValidityState validity;\n\n  @DomName('HTMLObjectElement.width')\n  @DocsEditable()\n  String width;\n\n  @DomName('HTMLObjectElement.willValidate')\n  @DocsEditable()\n  final bool willValidate;\n\n  @DomName('HTMLObjectElement.__getter__')\n  @DocsEditable()\n  bool __getter__(index_OR_name) native;\n\n  @DomName('HTMLObjectElement.__setter__')\n  @DocsEditable()\n  void __setter__(index_OR_name, Node value) native;\n\n  @DomName('HTMLObjectElement.checkValidity')\n  @DocsEditable()\n  bool checkValidity() native;\n\n  @DomName('HTMLObjectElement.setCustomValidity')\n  @DocsEditable()\n  void setCustomValidity(String error) native;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('HTMLOptGroupElement')\n@Native(\"HTMLOptGroupElement\")\nclass OptGroupElement extends HtmlElement {\n  // To suppress missing implicit constructor warnings.\n  factory OptGroupElement._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('HTMLOptGroupElement.HTMLOptGroupElement')\n  @DocsEditable()\n  factory OptGroupElement() => document.createElement(\"optgroup\");\n  /**\n   * Constructor instantiated by the DOM when a custom element has been created.\n   *\n   * This can only be called by subclasses from their created constructor.\n   */\n  OptGroupElement.created() : super.created();\n\n  @DomName('HTMLOptGroupElement.disabled')\n  @DocsEditable()\n  bool disabled;\n\n  @DomName('HTMLOptGroupElement.label')\n  @DocsEditable()\n  String label;\n}\n// Copyright (c) 2013, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DomName('HTMLOptionElement')\n@Native(\"HTMLOptionElement\")\nclass OptionElement extends HtmlElement {\n  factory OptionElement({String data: '', String value : '', bool selected: false}) {\n    return new OptionElement._(data, value, null, selected);\n  }\n\n  @DomName('HTMLOptionElement.HTMLOptionElement')\n  @DocsEditable()\n  factory OptionElement._([String data, String value, bool defaultSelected, bool selected]) {\n    if (selected != null) {\n      return OptionElement._create_1(data, value, defaultSelected, selected);\n    }\n    if (defaultSelected != null) {\n      return OptionElement._create_2(data, value, defaultSelected);\n    }\n    if (value != null) {\n      return OptionElement._create_3(data, value);\n    }\n    if (data != null) {\n      return OptionElement._create_4(data);\n    }\n    return OptionElement._create_5();\n  }\n  static OptionElement _create_1(data, value, defaultSelected, selected) => JS('OptionElement', 'new Option(#,#,#,#)', data, value, defaultSelected, selected);\n  static OptionElement _create_2(data, value, defaultSelected) => JS('OptionElement', 'new Option(#,#,#)', data, value, defaultSelected);\n  static OptionElement _create_3(data, value) => JS('OptionElement', 'new Option(#,#)', data, value);\n  static OptionElement _create_4(data) => JS('OptionElement', 'new Option(#)', data);\n  static OptionElement _create_5() => JS('OptionElement', 'new Option()');\n  /**\n   * Constructor instantiated by the DOM when a custom element has been created.\n   *\n   * This can only be called by subclasses from their created constructor.\n   */\n  OptionElement.created() : super.created();\n\n  @DomName('HTMLOptionElement.defaultSelected')\n  @DocsEditable()\n  bool defaultSelected;\n\n  @DomName('HTMLOptionElement.disabled')\n  @DocsEditable()\n  bool disabled;\n\n  @DomName('HTMLOptionElement.form')\n  @DocsEditable()\n  final FormElement form;\n\n  @DomName('HTMLOptionElement.index')\n  @DocsEditable()\n  final int index;\n\n  @DomName('HTMLOptionElement.label')\n  @DocsEditable()\n  String label;\n\n  @DomName('HTMLOptionElement.selected')\n  @DocsEditable()\n  bool selected;\n\n  @DomName('HTMLOptionElement.value')\n  @DocsEditable()\n  String value;\n\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('HTMLOutputElement')\n@SupportedBrowser(SupportedBrowser.CHROME)\n@SupportedBrowser(SupportedBrowser.FIREFOX)\n@SupportedBrowser(SupportedBrowser.SAFARI)\n@Native(\"HTMLOutputElement\")\nclass OutputElement extends HtmlElement {\n  // To suppress missing implicit constructor warnings.\n  factory OutputElement._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('HTMLOutputElement.HTMLOutputElement')\n  @DocsEditable()\n  factory OutputElement() => document.createElement(\"output\");\n  /**\n   * Constructor instantiated by the DOM when a custom element has been created.\n   *\n   * This can only be called by subclasses from their created constructor.\n   */\n  OutputElement.created() : super.created();\n\n  /// Checks if this type is supported on the current platform.\n  static bool get supported => Element.isTagSupported('output');\n\n  @DomName('HTMLOutputElement.defaultValue')\n  @DocsEditable()\n  String defaultValue;\n\n  @DomName('HTMLOutputElement.form')\n  @DocsEditable()\n  final FormElement form;\n\n  @DomName('HTMLOutputElement.htmlFor')\n  @DocsEditable()\n  final DomSettableTokenList htmlFor;\n\n  @DomName('HTMLOutputElement.labels')\n  @DocsEditable()\n  @Unstable()\n  @Returns('NodeList')\n  @Creates('NodeList')\n  final List<Node> labels;\n\n  @DomName('HTMLOutputElement.name')\n  @DocsEditable()\n  String name;\n\n  @DomName('HTMLOutputElement.type')\n  @DocsEditable()\n  final String type;\n\n  @DomName('HTMLOutputElement.validationMessage')\n  @DocsEditable()\n  final String validationMessage;\n\n  @DomName('HTMLOutputElement.validity')\n  @DocsEditable()\n  final ValidityState validity;\n\n  @DomName('HTMLOutputElement.value')\n  @DocsEditable()\n  String value;\n\n  @DomName('HTMLOutputElement.willValidate')\n  @DocsEditable()\n  final bool willValidate;\n\n  @DomName('HTMLOutputElement.checkValidity')\n  @DocsEditable()\n  bool checkValidity() native;\n\n  @DomName('HTMLOutputElement.setCustomValidity')\n  @DocsEditable()\n  void setCustomValidity(String error) native;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('OverflowEvent')\n@Experimental() // nonstandard\n@Native(\"OverflowEvent\")\nclass OverflowEvent extends Event {\n  // To suppress missing implicit constructor warnings.\n  factory OverflowEvent._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('OverflowEvent.BOTH')\n  @DocsEditable()\n  static const int BOTH = 2;\n\n  @DomName('OverflowEvent.HORIZONTAL')\n  @DocsEditable()\n  static const int HORIZONTAL = 0;\n\n  @DomName('OverflowEvent.VERTICAL')\n  @DocsEditable()\n  static const int VERTICAL = 1;\n\n  @DomName('OverflowEvent.horizontalOverflow')\n  @DocsEditable()\n  final bool horizontalOverflow;\n\n  @DomName('OverflowEvent.orient')\n  @DocsEditable()\n  final int orient;\n\n  @DomName('OverflowEvent.verticalOverflow')\n  @DocsEditable()\n  final bool verticalOverflow;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('PageTransitionEvent')\n// http://www.whatwg.org/specs/web-apps/current-work/multipage/history.html#pagetransitionevent\n@Experimental()\n@Native(\"PageTransitionEvent\")\nclass PageTransitionEvent extends Event {\n  // To suppress missing implicit constructor warnings.\n  factory PageTransitionEvent._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('PageTransitionEvent.persisted')\n  @DocsEditable()\n  final bool persisted;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('HTMLParagraphElement')\n@Native(\"HTMLParagraphElement\")\nclass ParagraphElement extends HtmlElement {\n  // To suppress missing implicit constructor warnings.\n  factory ParagraphElement._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('HTMLParagraphElement.HTMLParagraphElement')\n  @DocsEditable()\n  factory ParagraphElement() => document.createElement(\"p\");\n  /**\n   * Constructor instantiated by the DOM when a custom element has been created.\n   *\n   * This can only be called by subclasses from their created constructor.\n   */\n  ParagraphElement.created() : super.created();\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('HTMLParamElement')\n@Unstable()\n@Native(\"HTMLParamElement\")\nclass ParamElement extends HtmlElement {\n  // To suppress missing implicit constructor warnings.\n  factory ParamElement._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('HTMLParamElement.HTMLParamElement')\n  @DocsEditable()\n  factory ParamElement() => document.createElement(\"param\");\n  /**\n   * Constructor instantiated by the DOM when a custom element has been created.\n   *\n   * This can only be called by subclasses from their created constructor.\n   */\n  ParamElement.created() : super.created();\n\n  @DomName('HTMLParamElement.name')\n  @DocsEditable()\n  String name;\n\n  @DomName('HTMLParamElement.value')\n  @DocsEditable()\n  String value;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('ParentNode')\n@Experimental() // untriaged\nabstract class ParentNode extends Interceptor {\n  // To suppress missing implicit constructor warnings.\n  factory ParentNode._() { throw new UnsupportedError(\"Not supported\"); }\n\n  final int _childElementCount;\n\n  final List<Node> _children;\n\n  final Element _firstElementChild;\n\n  final Element _lastElementChild;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('Path')\n// http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#path-objects\n@Experimental()\n@Native(\"Path\")\nclass Path extends Interceptor {\n  // To suppress missing implicit constructor warnings.\n  factory Path._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('Path.Path')\n  @DocsEditable()\n  factory Path([path_OR_text]) {\n    if (path_OR_text == null) {\n      return Path._create_1();\n    }\n    if ((path_OR_text is Path || path_OR_text == null)) {\n      return Path._create_2(path_OR_text);\n    }\n    if ((path_OR_text is String || path_OR_text == null)) {\n      return Path._create_3(path_OR_text);\n    }\n    throw new ArgumentError(\"Incorrect number or type of arguments\");\n  }\n  static Path _create_1() => JS('Path', 'new Path()');\n  static Path _create_2(path_OR_text) => JS('Path', 'new Path(#)', path_OR_text);\n  static Path _create_3(path_OR_text) => JS('Path', 'new Path(#)', path_OR_text);\n\n  @DomName('Path.arc')\n  @DocsEditable()\n  void arc(num x, num y, num radius, num startAngle, num endAngle, bool anticlockwise) native;\n\n  @DomName('Path.arcTo')\n  @DocsEditable()\n  void arcTo(num x1, num y1, num x2, num y2, num radius) native;\n\n  @DomName('Path.bezierCurveTo')\n  @DocsEditable()\n  void bezierCurveTo(num cp1x, num cp1y, num cp2x, num cp2y, num x, num y) native;\n\n  @DomName('Path.closePath')\n  @DocsEditable()\n  void closePath() native;\n\n  @DomName('Path.lineTo')\n  @DocsEditable()\n  void lineTo(num x, num y) native;\n\n  @DomName('Path.moveTo')\n  @DocsEditable()\n  void moveTo(num x, num y) native;\n\n  @DomName('Path.quadraticCurveTo')\n  @DocsEditable()\n  void quadraticCurveTo(num cpx, num cpy, num x, num y) native;\n\n  @DomName('Path.rect')\n  @DocsEditable()\n  void rect(num x, num y, num width, num height) native;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('Performance')\n@SupportedBrowser(SupportedBrowser.CHROME)\n@SupportedBrowser(SupportedBrowser.FIREFOX)\n@SupportedBrowser(SupportedBrowser.IE)\n@Native(\"Performance\")\nclass Performance extends EventTarget {\n  // To suppress missing implicit constructor warnings.\n  factory Performance._() { throw new UnsupportedError(\"Not supported\"); }\n\n  /**\n   * Static factory designed to expose `resourcetimingbufferfull` events to event\n   * handlers that are not necessarily instances of [Performance].\n   *\n   * See [EventStreamProvider] for usage information.\n   */\n  @DomName('Performance.webkitresourcetimingbufferfullEvent')\n  @DocsEditable()\n  @SupportedBrowser(SupportedBrowser.CHROME)\n  @SupportedBrowser(SupportedBrowser.SAFARI)\n  @Experimental()\n  // http://www.w3c-test.org/webperf/specs/ResourceTiming/#performanceresourcetiming-methods\n  static const EventStreamProvider<Event> resourceTimingBufferFullEvent = const EventStreamProvider<Event>('webkitresourcetimingbufferfull');\n\n  /// Checks if this type is supported on the current platform.\n  static bool get supported => JS('bool', '!!(window.performance)');\n\n  @DomName('Performance.memory')\n  @DocsEditable()\n  @Experimental() // nonstandard\n  final MemoryInfo memory;\n\n  @DomName('Performance.navigation')\n  @DocsEditable()\n  final PerformanceNavigation navigation;\n\n  @DomName('Performance.timing')\n  @DocsEditable()\n  final PerformanceTiming timing;\n\n  @DomName('Performance.clearMarks')\n  @DocsEditable()\n  // https://dvcs.w3.org/hg/webperf/raw-file/tip/specs/UserTiming/Overview.html#extensions-performance-interface\n  @Experimental()\n  void clearMarks(String markName) native;\n\n  @DomName('Performance.clearMeasures')\n  @DocsEditable()\n  // https://dvcs.w3.org/hg/webperf/raw-file/tip/specs/UserTiming/Overview.html#extensions-performance-interface\n  @Experimental()\n  void clearMeasures(String measureName) native;\n\n  @DomName('Performance.getEntries')\n  @DocsEditable()\n  // http://www.w3.org/TR/performance-timeline/#sec-window.performance-attribute\n  @Experimental()\n  List<PerformanceEntry> getEntries() native;\n\n  @DomName('Performance.getEntriesByName')\n  @DocsEditable()\n  // http://www.w3.org/TR/performance-timeline/#sec-window.performance-attribute\n  @Experimental()\n  List<PerformanceEntry> getEntriesByName(String name, String entryType) native;\n\n  @DomName('Performance.getEntriesByType')\n  @DocsEditable()\n  // http://www.w3.org/TR/performance-timeline/#sec-window.performance-attribute\n  @Experimental()\n  List<PerformanceEntry> getEntriesByType(String entryType) native;\n\n  @DomName('Performance.mark')\n  @DocsEditable()\n  // https://dvcs.w3.org/hg/webperf/raw-file/tip/specs/UserTiming/Overview.html#extensions-performance-interface\n  @Experimental()\n  void mark(String markName) native;\n\n  @DomName('Performance.measure')\n  @DocsEditable()\n  // https://dvcs.w3.org/hg/webperf/raw-file/tip/specs/UserTiming/Overview.html#extensions-performance-interface\n  @Experimental()\n  void measure(String measureName, String startMark, String endMark) native;\n\n  @DomName('Performance.now')\n  @DocsEditable()\n  double now() native;\n\n  @JSName('webkitClearResourceTimings')\n  @DomName('Performance.webkitClearResourceTimings')\n  @DocsEditable()\n  @SupportedBrowser(SupportedBrowser.CHROME)\n  @SupportedBrowser(SupportedBrowser.SAFARI)\n  @Experimental()\n  // http://www.w3c-test.org/webperf/specs/ResourceTiming/#extensions-performance-interface\n  void clearResourceTimings() native;\n\n  @JSName('webkitSetResourceTimingBufferSize')\n  @DomName('Performance.webkitSetResourceTimingBufferSize')\n  @DocsEditable()\n  @SupportedBrowser(SupportedBrowser.CHROME)\n  @SupportedBrowser(SupportedBrowser.SAFARI)\n  @Experimental()\n  // http://www.w3c-test.org/webperf/specs/ResourceTiming/#performanceresourcetiming-methods\n  void setResourceTimingBufferSize(int maxSize) native;\n\n  /// Stream of `resourcetimingbufferfull` events handled by this [Performance].\n  @DomName('Performance.onwebkitresourcetimingbufferfull')\n  @DocsEditable()\n  // http://www.w3c-test.org/webperf/specs/ResourceTiming/#performanceresourcetiming-methods\n  @Experimental()\n  Stream<Event> get onResourceTimingBufferFull => resourceTimingBufferFullEvent.forTarget(this);\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('PerformanceEntry')\n// http://www.w3.org/TR/performance-timeline/#sec-PerformanceEntry-interface\n@Experimental()\n@Native(\"PerformanceEntry\")\nclass PerformanceEntry extends Interceptor {\n  // To suppress missing implicit constructor warnings.\n  factory PerformanceEntry._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('PerformanceEntry.duration')\n  @DocsEditable()\n  final double duration;\n\n  @DomName('PerformanceEntry.entryType')\n  @DocsEditable()\n  final String entryType;\n\n  @DomName('PerformanceEntry.name')\n  @DocsEditable()\n  final String name;\n\n  @DomName('PerformanceEntry.startTime')\n  @DocsEditable()\n  final double startTime;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('PerformanceMark')\n// http://www.w3.org/TR/user-timing/#performancemark\n@Experimental()\n@Native(\"PerformanceMark\")\nclass PerformanceMark extends PerformanceEntry {\n  // To suppress missing implicit constructor warnings.\n  factory PerformanceMark._() { throw new UnsupportedError(\"Not supported\"); }\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('PerformanceMeasure')\n// http://www.w3.org/TR/user-timing/#performancemeasure\n@Experimental()\n@Native(\"PerformanceMeasure\")\nclass PerformanceMeasure extends PerformanceEntry {\n  // To suppress missing implicit constructor warnings.\n  factory PerformanceMeasure._() { throw new UnsupportedError(\"Not supported\"); }\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('PerformanceNavigation')\n@Unstable()\n@Native(\"PerformanceNavigation\")\nclass PerformanceNavigation extends Interceptor {\n  // To suppress missing implicit constructor warnings.\n  factory PerformanceNavigation._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('PerformanceNavigation.TYPE_BACK_FORWARD')\n  @DocsEditable()\n  static const int TYPE_BACK_FORWARD = 2;\n\n  @DomName('PerformanceNavigation.TYPE_NAVIGATE')\n  @DocsEditable()\n  static const int TYPE_NAVIGATE = 0;\n\n  @DomName('PerformanceNavigation.TYPE_RELOAD')\n  @DocsEditable()\n  static const int TYPE_RELOAD = 1;\n\n  @DomName('PerformanceNavigation.TYPE_RESERVED')\n  @DocsEditable()\n  static const int TYPE_RESERVED = 255;\n\n  @DomName('PerformanceNavigation.redirectCount')\n  @DocsEditable()\n  final int redirectCount;\n\n  @DomName('PerformanceNavigation.type')\n  @DocsEditable()\n  final int type;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('PerformanceResourceTiming')\n// http://www.w3c-test.org/webperf/specs/ResourceTiming/#performanceresourcetiming\n@Experimental()\n@Native(\"PerformanceResourceTiming\")\nclass PerformanceResourceTiming extends PerformanceEntry {\n  // To suppress missing implicit constructor warnings.\n  factory PerformanceResourceTiming._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('PerformanceResourceTiming.connectEnd')\n  @DocsEditable()\n  final double connectEnd;\n\n  @DomName('PerformanceResourceTiming.connectStart')\n  @DocsEditable()\n  final double connectStart;\n\n  @DomName('PerformanceResourceTiming.domainLookupEnd')\n  @DocsEditable()\n  final double domainLookupEnd;\n\n  @DomName('PerformanceResourceTiming.domainLookupStart')\n  @DocsEditable()\n  final double domainLookupStart;\n\n  @DomName('PerformanceResourceTiming.fetchStart')\n  @DocsEditable()\n  final double fetchStart;\n\n  @DomName('PerformanceResourceTiming.initiatorType')\n  @DocsEditable()\n  final String initiatorType;\n\n  @DomName('PerformanceResourceTiming.redirectEnd')\n  @DocsEditable()\n  final double redirectEnd;\n\n  @DomName('PerformanceResourceTiming.redirectStart')\n  @DocsEditable()\n  final double redirectStart;\n\n  @DomName('PerformanceResourceTiming.requestStart')\n  @DocsEditable()\n  @Experimental() // nonstandard\n  final double requestStart;\n\n  @DomName('PerformanceResourceTiming.responseEnd')\n  @DocsEditable()\n  @Experimental() // nonstandard\n  final double responseEnd;\n\n  @DomName('PerformanceResourceTiming.responseStart')\n  @DocsEditable()\n  @Experimental() // nonstandard\n  final double responseStart;\n\n  @DomName('PerformanceResourceTiming.secureConnectionStart')\n  @DocsEditable()\n  final double secureConnectionStart;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('PerformanceTiming')\n@Unstable()\n@Native(\"PerformanceTiming\")\nclass PerformanceTiming extends Interceptor {\n  // To suppress missing implicit constructor warnings.\n  factory PerformanceTiming._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('PerformanceTiming.connectEnd')\n  @DocsEditable()\n  final int connectEnd;\n\n  @DomName('PerformanceTiming.connectStart')\n  @DocsEditable()\n  final int connectStart;\n\n  @DomName('PerformanceTiming.domComplete')\n  @DocsEditable()\n  final int domComplete;\n\n  @DomName('PerformanceTiming.domContentLoadedEventEnd')\n  @DocsEditable()\n  final int domContentLoadedEventEnd;\n\n  @DomName('PerformanceTiming.domContentLoadedEventStart')\n  @DocsEditable()\n  final int domContentLoadedEventStart;\n\n  @DomName('PerformanceTiming.domInteractive')\n  @DocsEditable()\n  final int domInteractive;\n\n  @DomName('PerformanceTiming.domLoading')\n  @DocsEditable()\n  final int domLoading;\n\n  @DomName('PerformanceTiming.domainLookupEnd')\n  @DocsEditable()\n  final int domainLookupEnd;\n\n  @DomName('PerformanceTiming.domainLookupStart')\n  @DocsEditable()\n  final int domainLookupStart;\n\n  @DomName('PerformanceTiming.fetchStart')\n  @DocsEditable()\n  final int fetchStart;\n\n  @DomName('PerformanceTiming.loadEventEnd')\n  @DocsEditable()\n  final int loadEventEnd;\n\n  @DomName('PerformanceTiming.loadEventStart')\n  @DocsEditable()\n  final int loadEventStart;\n\n  @DomName('PerformanceTiming.navigationStart')\n  @DocsEditable()\n  final int navigationStart;\n\n  @DomName('PerformanceTiming.redirectEnd')\n  @DocsEditable()\n  final int redirectEnd;\n\n  @DomName('PerformanceTiming.redirectStart')\n  @DocsEditable()\n  final int redirectStart;\n\n  @DomName('PerformanceTiming.requestStart')\n  @DocsEditable()\n  final int requestStart;\n\n  @DomName('PerformanceTiming.responseEnd')\n  @DocsEditable()\n  final int responseEnd;\n\n  @DomName('PerformanceTiming.responseStart')\n  @DocsEditable()\n  final int responseStart;\n\n  @DomName('PerformanceTiming.secureConnectionStart')\n  @DocsEditable()\n  final int secureConnectionStart;\n\n  @DomName('PerformanceTiming.unloadEventEnd')\n  @DocsEditable()\n  final int unloadEventEnd;\n\n  @DomName('PerformanceTiming.unloadEventStart')\n  @DocsEditable()\n  final int unloadEventStart;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('Player')\n@Experimental() // untriaged\n@Native(\"Player\")\nclass Player extends Interceptor {\n  // To suppress missing implicit constructor warnings.\n  factory Player._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('Player.currentTime')\n  @DocsEditable()\n  @Experimental() // untriaged\n  num currentTime;\n\n  @DomName('Player.finished')\n  @DocsEditable()\n  @Experimental() // untriaged\n  final bool finished;\n\n  @DomName('Player.paused')\n  @DocsEditable()\n  @Experimental() // untriaged\n  final bool paused;\n\n  @DomName('Player.playbackRate')\n  @DocsEditable()\n  @Experimental() // untriaged\n  num playbackRate;\n\n  @DomName('Player.source')\n  @DocsEditable()\n  @Experimental() // untriaged\n  TimedItem source;\n\n  @DomName('Player.startTime')\n  @DocsEditable()\n  @Experimental() // untriaged\n  num startTime;\n\n  @DomName('Player.timeLag')\n  @DocsEditable()\n  @Experimental() // untriaged\n  final double timeLag;\n\n  @DomName('Player.cancel')\n  @DocsEditable()\n  @Experimental() // untriaged\n  void cancel() native;\n\n  @DomName('Player.finish')\n  @DocsEditable()\n  @Experimental() // untriaged\n  void finish() native;\n\n  @DomName('Player.pause')\n  @DocsEditable()\n  @Experimental() // untriaged\n  void pause() native;\n\n  @DomName('Player.play')\n  @DocsEditable()\n  @Experimental() // untriaged\n  void play() native;\n\n  @DomName('Player.reverse')\n  @DocsEditable()\n  @Experimental() // untriaged\n  void reverse() native;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('Plugin')\n@Experimental() // non-standard\n@Native(\"Plugin\")\nclass Plugin extends Interceptor {\n  // To suppress missing implicit constructor warnings.\n  factory Plugin._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('Plugin.description')\n  @DocsEditable()\n  final String description;\n\n  @DomName('Plugin.filename')\n  @DocsEditable()\n  final String filename;\n\n  @DomName('Plugin.length')\n  @DocsEditable()\n  final int length;\n\n  @DomName('Plugin.name')\n  @DocsEditable()\n  final String name;\n\n  @DomName('Plugin.__getter__')\n  @DocsEditable()\n  MimeType __getter__(String name) native;\n\n  @DomName('Plugin.item')\n  @DocsEditable()\n  MimeType item(int index) native;\n\n  @DomName('Plugin.namedItem')\n  @DocsEditable()\n  MimeType namedItem(String name) native;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('PluginArray')\n@Experimental() // non-standard\n@Native(\"PluginArray\")\nclass PluginArray extends Interceptor with ListMixin<Plugin>, ImmutableListMixin<Plugin> implements JavaScriptIndexingBehavior, List<Plugin> {\n  // To suppress missing implicit constructor warnings.\n  factory PluginArray._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('PluginArray.length')\n  @DocsEditable()\n  int get length => JS(\"int\", \"#.length\", this);\n\n  Plugin operator[](int index) {\n    if (JS(\"bool\", \"# >>> 0 !== # || # >= #\", index,\n        index, index, length))\n      throw new RangeError.range(index, 0, length);\n    return JS(\"Plugin\", \"#[#]\", this, index);\n  }\n  void operator[]=(int index, Plugin value) {\n    throw new UnsupportedError(\"Cannot assign element of immutable List.\");\n  }\n  // -- start List<Plugin> mixins.\n  // Plugin is the element type.\n\n\n  void set length(int value) {\n    throw new UnsupportedError(\"Cannot resize immutable List.\");\n  }\n\n  Plugin get first {\n    if (this.length > 0) {\n      return JS('Plugin', '#[0]', this);\n    }\n    throw new StateError(\"No elements\");\n  }\n\n  Plugin get last {\n    int len = this.length;\n    if (len > 0) {\n      return JS('Plugin', '#[#]', this, len - 1);\n    }\n    throw new StateError(\"No elements\");\n  }\n\n  Plugin get single {\n    int len = this.length;\n    if (len == 1) {\n      return JS('Plugin', '#[0]', this);\n    }\n    if (len == 0) throw new StateError(\"No elements\");\n    throw new StateError(\"More than one element\");\n  }\n\n  Plugin elementAt(int index) => this[index];\n  // -- end List<Plugin> mixins.\n\n  @DomName('PluginArray.__getter__')\n  @DocsEditable()\n  Plugin __getter__(String name) native;\n\n  @DomName('PluginArray.item')\n  @DocsEditable()\n  Plugin item(int index) native;\n\n  @DomName('PluginArray.namedItem')\n  @DocsEditable()\n  Plugin namedItem(String name) native;\n\n  @DomName('PluginArray.refresh')\n  @DocsEditable()\n  void refresh(bool reload) native;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('PopStateEvent')\n@SupportedBrowser(SupportedBrowser.CHROME)\n@SupportedBrowser(SupportedBrowser.FIREFOX)\n@SupportedBrowser(SupportedBrowser.IE, '10')\n@SupportedBrowser(SupportedBrowser.SAFARI)\n@Native(\"PopStateEvent\")\nclass PopStateEvent extends Event {\n  // To suppress missing implicit constructor warnings.\n  factory PopStateEvent._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('PopStateEvent.state')\n  @DocsEditable()\n  dynamic get state => convertNativeToDart_SerializedScriptValue(this._get_state);\n  @JSName('state')\n  @DomName('PopStateEvent.state')\n  @DocsEditable()\n  @annotation_Creates_SerializedScriptValue\n  @annotation_Returns_SerializedScriptValue\n  final dynamic _get_state;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n// WARNING: Do not edit - generated code.\n\n\n@DomName('PositionCallback')\n@Unstable()\ntypedef void _PositionCallback(Geoposition position);\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('PositionError')\n@Unstable()\n@Native(\"PositionError\")\nclass PositionError extends Interceptor {\n  // To suppress missing implicit constructor warnings.\n  factory PositionError._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('PositionError.PERMISSION_DENIED')\n  @DocsEditable()\n  static const int PERMISSION_DENIED = 1;\n\n  @DomName('PositionError.POSITION_UNAVAILABLE')\n  @DocsEditable()\n  static const int POSITION_UNAVAILABLE = 2;\n\n  @DomName('PositionError.TIMEOUT')\n  @DocsEditable()\n  static const int TIMEOUT = 3;\n\n  @DomName('PositionError.code')\n  @DocsEditable()\n  final int code;\n\n  @DomName('PositionError.message')\n  @DocsEditable()\n  final String message;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n// WARNING: Do not edit - generated code.\n\n\n@DomName('PositionErrorCallback')\n@Unstable()\ntypedef void _PositionErrorCallback(PositionError error);\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('HTMLPreElement')\n@Native(\"HTMLPreElement\")\nclass PreElement extends HtmlElement {\n  // To suppress missing implicit constructor warnings.\n  factory PreElement._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('HTMLPreElement.HTMLPreElement')\n  @DocsEditable()\n  factory PreElement() => document.createElement(\"pre\");\n  /**\n   * Constructor instantiated by the DOM when a custom element has been created.\n   *\n   * This can only be called by subclasses from their created constructor.\n   */\n  PreElement.created() : super.created();\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('ProcessingInstruction')\n@Unstable()\n@Native(\"ProcessingInstruction\")\nclass ProcessingInstruction extends CharacterData {\n  // To suppress missing implicit constructor warnings.\n  factory ProcessingInstruction._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('ProcessingInstruction.sheet')\n  @DocsEditable()\n  @Experimental() // non-standard\n  final StyleSheet sheet;\n\n  @DomName('ProcessingInstruction.target')\n  @DocsEditable()\n  final String target;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('HTMLProgressElement')\n@SupportedBrowser(SupportedBrowser.CHROME)\n@SupportedBrowser(SupportedBrowser.FIREFOX)\n@SupportedBrowser(SupportedBrowser.IE, '10')\n@SupportedBrowser(SupportedBrowser.SAFARI)\n@Native(\"HTMLProgressElement\")\nclass ProgressElement extends HtmlElement {\n  // To suppress missing implicit constructor warnings.\n  factory ProgressElement._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('HTMLProgressElement.HTMLProgressElement')\n  @DocsEditable()\n  factory ProgressElement() => document.createElement(\"progress\");\n  /**\n   * Constructor instantiated by the DOM when a custom element has been created.\n   *\n   * This can only be called by subclasses from their created constructor.\n   */\n  ProgressElement.created() : super.created();\n\n  /// Checks if this type is supported on the current platform.\n  static bool get supported => Element.isTagSupported('progress');\n\n  @DomName('HTMLProgressElement.labels')\n  @DocsEditable()\n  @Unstable()\n  @Returns('NodeList')\n  @Creates('NodeList')\n  final List<Node> labels;\n\n  @DomName('HTMLProgressElement.max')\n  @DocsEditable()\n  num max;\n\n  @DomName('HTMLProgressElement.position')\n  @DocsEditable()\n  final double position;\n\n  @DomName('HTMLProgressElement.value')\n  @DocsEditable()\n  num value;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('ProgressEvent')\n@Native(\"ProgressEvent\")\nclass ProgressEvent extends Event {\n  // To suppress missing implicit constructor warnings.\n  factory ProgressEvent._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('ProgressEvent.lengthComputable')\n  @DocsEditable()\n  final bool lengthComputable;\n\n  @DomName('ProgressEvent.loaded')\n  @DocsEditable()\n  final int loaded;\n\n  @DomName('ProgressEvent.total')\n  @DocsEditable()\n  final int total;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('HTMLQuoteElement')\n@Native(\"HTMLQuoteElement\")\nclass QuoteElement extends HtmlElement {\n  // To suppress missing implicit constructor warnings.\n  factory QuoteElement._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('HTMLQuoteElement.HTMLQuoteElement')\n  @DocsEditable()\n  factory QuoteElement() => document.createElement(\"q\");\n  /**\n   * Constructor instantiated by the DOM when a custom element has been created.\n   *\n   * This can only be called by subclasses from their created constructor.\n   */\n  QuoteElement.created() : super.created();\n\n  @DomName('HTMLQuoteElement.cite')\n  @DocsEditable()\n  String cite;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n// WARNING: Do not edit - generated code.\n\n\n@DomName('RTCErrorCallback')\n// http://dev.w3.org/2011/webrtc/editor/webrtc.html#rtcerror\n@Experimental()\ntypedef void _RtcErrorCallback(String errorInformation);\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n// WARNING: Do not edit - generated code.\n\n\n@DomName('RTCSessionDescriptionCallback')\n// http://dev.w3.org/2011/webrtc/editor/webrtc.html#idl-def-RTCSessionDescription\n@Experimental()\ntypedef void _RtcSessionDescriptionCallback(RtcSessionDescription sdp);\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n// WARNING: Do not edit - generated code.\n\n\n@DomName('RTCStatsCallback')\n// http://dev.w3.org/2011/webrtc/editor/webrtc.html#idl-def-RTCStatsCallback\n@Experimental()\ntypedef void RtcStatsCallback(RtcStatsResponse response);\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n// WARNING: Do not edit - generated code.\n\n\n@DomName('Range')\n@Unstable()\n@Native(\"Range\")\nclass Range extends Interceptor {\n  factory Range() => document.createRange();\n\n  factory Range.fromPoint(Point point) =>\n      document._caretRangeFromPoint(point.x, point.y);\n  // To suppress missing implicit constructor warnings.\n  factory Range._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('Range.END_TO_END')\n  @DocsEditable()\n  static const int END_TO_END = 2;\n\n  @DomName('Range.END_TO_START')\n  @DocsEditable()\n  static const int END_TO_START = 3;\n\n  @DomName('Range.NODE_AFTER')\n  @DocsEditable()\n  @Experimental() // nonstandard\n  static const int NODE_AFTER = 1;\n\n  @DomName('Range.NODE_BEFORE')\n  @DocsEditable()\n  @Experimental() // nonstandard\n  static const int NODE_BEFORE = 0;\n\n  @DomName('Range.NODE_BEFORE_AND_AFTER')\n  @DocsEditable()\n  @Experimental() // nonstandard\n  static const int NODE_BEFORE_AND_AFTER = 2;\n\n  @DomName('Range.NODE_INSIDE')\n  @DocsEditable()\n  @Experimental() // nonstandard\n  static const int NODE_INSIDE = 3;\n\n  @DomName('Range.START_TO_END')\n  @DocsEditable()\n  static const int START_TO_END = 1;\n\n  @DomName('Range.START_TO_START')\n  @DocsEditable()\n  static const int START_TO_START = 0;\n\n  @DomName('Range.collapsed')\n  @DocsEditable()\n  final bool collapsed;\n\n  @DomName('Range.commonAncestorContainer')\n  @DocsEditable()\n  final Node commonAncestorContainer;\n\n  @DomName('Range.endContainer')\n  @DocsEditable()\n  final Node endContainer;\n\n  @DomName('Range.endOffset')\n  @DocsEditable()\n  final int endOffset;\n\n  @DomName('Range.startContainer')\n  @DocsEditable()\n  final Node startContainer;\n\n  @DomName('Range.startOffset')\n  @DocsEditable()\n  final int startOffset;\n\n  @DomName('Range.cloneContents')\n  @DocsEditable()\n  DocumentFragment cloneContents() native;\n\n  @DomName('Range.cloneRange')\n  @DocsEditable()\n  Range cloneRange() native;\n\n  @DomName('Range.collapse')\n  @DocsEditable()\n  void collapse(bool toStart) native;\n\n  @DomName('Range.comparePoint')\n  @DocsEditable()\n  int comparePoint(Node refNode, int offset) native;\n\n  @DomName('Range.createContextualFragment')\n  @DocsEditable()\n  DocumentFragment createContextualFragment(String html) native;\n\n  @DomName('Range.deleteContents')\n  @DocsEditable()\n  void deleteContents() native;\n\n  @DomName('Range.detach')\n  @DocsEditable()\n  void detach() native;\n\n  @DomName('Range.expand')\n  @DocsEditable()\n  @Experimental() // non-standard\n  void expand(String unit) native;\n\n  @DomName('Range.extractContents')\n  @DocsEditable()\n  DocumentFragment extractContents() native;\n\n  @DomName('Range.getBoundingClientRect')\n  @DocsEditable()\n  Rectangle getBoundingClientRect() native;\n\n  @DomName('Range.getClientRects')\n  @DocsEditable()\n  @Returns('_ClientRectList')\n  @Creates('_ClientRectList')\n  List<Rectangle> getClientRects() native;\n\n  @DomName('Range.insertNode')\n  @DocsEditable()\n  void insertNode(Node newNode) native;\n\n  @DomName('Range.isPointInRange')\n  @DocsEditable()\n  bool isPointInRange(Node refNode, int offset) native;\n\n  @DomName('Range.selectNode')\n  @DocsEditable()\n  void selectNode(Node refNode) native;\n\n  @DomName('Range.selectNodeContents')\n  @DocsEditable()\n  void selectNodeContents(Node refNode) native;\n\n  @DomName('Range.setEnd')\n  @DocsEditable()\n  void setEnd(Node refNode, int offset) native;\n\n  @DomName('Range.setEndAfter')\n  @DocsEditable()\n  void setEndAfter(Node refNode) native;\n\n  @DomName('Range.setEndBefore')\n  @DocsEditable()\n  void setEndBefore(Node refNode) native;\n\n  @DomName('Range.setStart')\n  @DocsEditable()\n  void setStart(Node refNode, int offset) native;\n\n  @DomName('Range.setStartAfter')\n  @DocsEditable()\n  void setStartAfter(Node refNode) native;\n\n  @DomName('Range.setStartBefore')\n  @DocsEditable()\n  void setStartBefore(Node refNode) native;\n\n  @DomName('Range.surroundContents')\n  @DocsEditable()\n  void surroundContents(Node newParent) native;\n\n  @DomName('Range.toString')\n  @DocsEditable()\n  String toString() native;\n\n\n  /**\n   * Checks if createContextualFragment is supported.\n   *\n   * See also:\n   *\n   * * [createContextualFragment]\n   */\n  static bool get supportsCreateContextualFragment =>\n      JS('bool', '(\"createContextualFragment\" in window.Range.prototype)');\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n// WARNING: Do not edit - generated code.\n\n\n@DomName('RequestAnimationFrameCallback')\ntypedef void RequestAnimationFrameCallback(num highResTime);\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('ResourceProgressEvent')\n// https://chromiumcodereview.appspot.com/14773025/\n@deprecated // experimental\n@Native(\"ResourceProgressEvent\")\nclass ResourceProgressEvent extends ProgressEvent {\n  // To suppress missing implicit constructor warnings.\n  factory ResourceProgressEvent._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('ResourceProgressEvent.url')\n  @DocsEditable()\n  final String url;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('RTCDataChannel')\n// http://dev.w3.org/2011/webrtc/editor/webrtc.html#idl-def-RTCDataChannel\n@Experimental()\n@Native(\"RTCDataChannel,DataChannel\")\nclass RtcDataChannel extends EventTarget {\n  // To suppress missing implicit constructor warnings.\n  factory RtcDataChannel._() { throw new UnsupportedError(\"Not supported\"); }\n\n  /**\n   * Static factory designed to expose `close` events to event\n   * handlers that are not necessarily instances of [RtcDataChannel].\n   *\n   * See [EventStreamProvider] for usage information.\n   */\n  @DomName('RTCDataChannel.closeEvent')\n  @DocsEditable()\n  static const EventStreamProvider<Event> closeEvent = const EventStreamProvider<Event>('close');\n\n  /**\n   * Static factory designed to expose `error` events to event\n   * handlers that are not necessarily instances of [RtcDataChannel].\n   *\n   * See [EventStreamProvider] for usage information.\n   */\n  @DomName('RTCDataChannel.errorEvent')\n  @DocsEditable()\n  static const EventStreamProvider<Event> errorEvent = const EventStreamProvider<Event>('error');\n\n  /**\n   * Static factory designed to expose `message` events to event\n   * handlers that are not necessarily instances of [RtcDataChannel].\n   *\n   * See [EventStreamProvider] for usage information.\n   */\n  @DomName('RTCDataChannel.messageEvent')\n  @DocsEditable()\n  static const EventStreamProvider<MessageEvent> messageEvent = const EventStreamProvider<MessageEvent>('message');\n\n  /**\n   * Static factory designed to expose `open` events to event\n   * handlers that are not necessarily instances of [RtcDataChannel].\n   *\n   * See [EventStreamProvider] for usage information.\n   */\n  @DomName('RTCDataChannel.openEvent')\n  @DocsEditable()\n  static const EventStreamProvider<Event> openEvent = const EventStreamProvider<Event>('open');\n\n  @DomName('RTCDataChannel.binaryType')\n  @DocsEditable()\n  String binaryType;\n\n  @DomName('RTCDataChannel.bufferedAmount')\n  @DocsEditable()\n  final int bufferedAmount;\n\n  @DomName('RTCDataChannel.id')\n  @DocsEditable()\n  @Experimental() // untriaged\n  final int id;\n\n  @DomName('RTCDataChannel.label')\n  @DocsEditable()\n  final String label;\n\n  @DomName('RTCDataChannel.maxRetransmitTime')\n  @DocsEditable()\n  @Experimental() // untriaged\n  final int maxRetransmitTime;\n\n  @DomName('RTCDataChannel.maxRetransmits')\n  @DocsEditable()\n  @Experimental() // untriaged\n  final int maxRetransmits;\n\n  @DomName('RTCDataChannel.negotiated')\n  @DocsEditable()\n  @Experimental() // untriaged\n  final bool negotiated;\n\n  @DomName('RTCDataChannel.ordered')\n  @DocsEditable()\n  @Experimental() // untriaged\n  final bool ordered;\n\n  @DomName('RTCDataChannel.protocol')\n  @DocsEditable()\n  @Experimental() // untriaged\n  final String protocol;\n\n  @DomName('RTCDataChannel.readyState')\n  @DocsEditable()\n  final String readyState;\n\n  @DomName('RTCDataChannel.reliable')\n  @DocsEditable()\n  final bool reliable;\n\n  @DomName('RTCDataChannel.close')\n  @DocsEditable()\n  void close() native;\n\n  @DomName('RTCDataChannel.send')\n  @DocsEditable()\n  void send(data) native;\n\n  @JSName('send')\n  @DomName('RTCDataChannel.send')\n  @DocsEditable()\n  void sendBlob(Blob data) native;\n\n  @JSName('send')\n  @DomName('RTCDataChannel.send')\n  @DocsEditable()\n  void sendByteBuffer(ByteBuffer data) native;\n\n  @JSName('send')\n  @DomName('RTCDataChannel.send')\n  @DocsEditable()\n  void sendString(String data) native;\n\n  @JSName('send')\n  @DomName('RTCDataChannel.send')\n  @DocsEditable()\n  void sendTypedData(TypedData data) native;\n\n  /// Stream of `close` events handled by this [RtcDataChannel].\n  @DomName('RTCDataChannel.onclose')\n  @DocsEditable()\n  Stream<Event> get onClose => closeEvent.forTarget(this);\n\n  /// Stream of `error` events handled by this [RtcDataChannel].\n  @DomName('RTCDataChannel.onerror')\n  @DocsEditable()\n  Stream<Event> get onError => errorEvent.forTarget(this);\n\n  /// Stream of `message` events handled by this [RtcDataChannel].\n  @DomName('RTCDataChannel.onmessage')\n  @DocsEditable()\n  Stream<MessageEvent> get onMessage => messageEvent.forTarget(this);\n\n  /// Stream of `open` events handled by this [RtcDataChannel].\n  @DomName('RTCDataChannel.onopen')\n  @DocsEditable()\n  Stream<Event> get onOpen => openEvent.forTarget(this);\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('RTCDataChannelEvent')\n// http://dev.w3.org/2011/webrtc/editor/webrtc.html#rtcdatachannelevent\n@Experimental()\n@Native(\"RTCDataChannelEvent\")\nclass RtcDataChannelEvent extends Event {\n  // To suppress missing implicit constructor warnings.\n  factory RtcDataChannelEvent._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('RTCDataChannelEvent.channel')\n  @DocsEditable()\n  final RtcDataChannel channel;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('RTCDTMFSender')\n// http://dev.w3.org/2011/webrtc/editor/webrtc.html#idl-def-RTCDTMFSender\n@Experimental()\n@Native(\"RTCDTMFSender\")\nclass RtcDtmfSender extends EventTarget {\n  // To suppress missing implicit constructor warnings.\n  factory RtcDtmfSender._() { throw new UnsupportedError(\"Not supported\"); }\n\n  /**\n   * Static factory designed to expose `tonechange` events to event\n   * handlers that are not necessarily instances of [RtcDtmfSender].\n   *\n   * See [EventStreamProvider] for usage information.\n   */\n  @DomName('RTCDTMFSender.tonechangeEvent')\n  @DocsEditable()\n  static const EventStreamProvider<RtcDtmfToneChangeEvent> toneChangeEvent = const EventStreamProvider<RtcDtmfToneChangeEvent>('tonechange');\n\n  @JSName('canInsertDTMF')\n  @DomName('RTCDTMFSender.canInsertDTMF')\n  @DocsEditable()\n  final bool canInsertDtmf;\n\n  @DomName('RTCDTMFSender.duration')\n  @DocsEditable()\n  final int duration;\n\n  @DomName('RTCDTMFSender.interToneGap')\n  @DocsEditable()\n  final int interToneGap;\n\n  @DomName('RTCDTMFSender.toneBuffer')\n  @DocsEditable()\n  final String toneBuffer;\n\n  @DomName('RTCDTMFSender.track')\n  @DocsEditable()\n  final MediaStreamTrack track;\n\n  @JSName('insertDTMF')\n  @DomName('RTCDTMFSender.insertDTMF')\n  @DocsEditable()\n  void insertDtmf(String tones, [int duration, int interToneGap]) native;\n\n  /// Stream of `tonechange` events handled by this [RtcDtmfSender].\n  @DomName('RTCDTMFSender.ontonechange')\n  @DocsEditable()\n  Stream<RtcDtmfToneChangeEvent> get onToneChange => toneChangeEvent.forTarget(this);\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('RTCDTMFToneChangeEvent')\n// http://dev.w3.org/2011/webrtc/editor/webrtc.html#idl-def-RTCDTMFToneChangeEvent\n@Experimental()\n@Native(\"RTCDTMFToneChangeEvent\")\nclass RtcDtmfToneChangeEvent extends Event {\n  // To suppress missing implicit constructor warnings.\n  factory RtcDtmfToneChangeEvent._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('RTCDTMFToneChangeEvent.tone')\n  @DocsEditable()\n  final String tone;\n}\n// Copyright (c) 2013, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DomName('RTCIceCandidate')\n@SupportedBrowser(SupportedBrowser.CHROME)\n@Experimental()\n// http://dev.w3.org/2011/webrtc/editor/webrtc.html#idl-def-RTCIceCandidate\n@Native(\"RTCIceCandidate,mozRTCIceCandidate\")\nclass RtcIceCandidate extends Interceptor {\n  factory RtcIceCandidate(Map dictionary) {\n    // TODO(efortuna): Remove this check if when you can actually construct with\n    // the unprefixed RTCIceCandidate in Firefox (currently both are defined,\n    // but one can't be used as a constructor).\n    var constructorName = JS('', 'window[#]',\n        Device.isFirefox ? '${Device.propertyPrefix}RTCIceCandidate' :\n        'RTCIceCandidate');\n    return JS('RtcIceCandidate', 'new #(#)', constructorName,\n        convertDartToNative_SerializedScriptValue(dictionary));\n  }\n  // To suppress missing implicit constructor warnings.\n  factory RtcIceCandidate._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('RTCIceCandidate.candidate')\n  @DocsEditable()\n  final String candidate;\n\n  @DomName('RTCIceCandidate.sdpMLineIndex')\n  @DocsEditable()\n  final int sdpMLineIndex;\n\n  @DomName('RTCIceCandidate.sdpMid')\n  @DocsEditable()\n  final String sdpMid;\n\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('RTCIceCandidateEvent')\n// http://dev.w3.org/2011/webrtc/editor/webrtc.html#rtcicecandidate-type\n@Experimental()\n@Native(\"RTCIceCandidateEvent\")\nclass RtcIceCandidateEvent extends Event {\n  // To suppress missing implicit constructor warnings.\n  factory RtcIceCandidateEvent._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('RTCIceCandidateEvent.candidate')\n  @DocsEditable()\n  final RtcIceCandidate candidate;\n}\n// Copyright (c) 2013, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DomName('RTCPeerConnection')\n@SupportedBrowser(SupportedBrowser.CHROME)\n@Experimental()\n// http://dev.w3.org/2011/webrtc/editor/webrtc.html#idl-def-RTCPeerConnection\n@Native(\"RTCPeerConnection,mozRTCPeerConnection\")\nclass RtcPeerConnection extends EventTarget {\n  factory RtcPeerConnection(Map rtcIceServers, [Map mediaConstraints]) {\n    var constructorName = JS('RtcPeerConnection', 'window[#]',\n        '${Device.propertyPrefix}RTCPeerConnection');\n    if (mediaConstraints != null) {\n      return JS('RtcPeerConnection', 'new #(#,#)', constructorName,\n          convertDartToNative_SerializedScriptValue(rtcIceServers),\n          convertDartToNative_SerializedScriptValue(mediaConstraints));\n    } else {\n      return JS('RtcPeerConnection', 'new #(#)', constructorName,\n          convertDartToNative_SerializedScriptValue(rtcIceServers));\n    }\n  }\n\n  /**\n   * Checks if Real Time Communication (RTC) APIs are supported and enabled on\n   * the current platform.\n   */\n  static bool get supported {\n    // Currently in Firefox some of the RTC elements are defined but throw an\n    // error unless the user has specifically enabled them in their\n    // about:config. So we have to construct an element to actually test if RTC\n    // is supported at the given time.\n    try {\n      new RtcPeerConnection(\n          {\"iceServers\": [ {\"url\":\"stun:localhost\"}]});\n      return true;\n    } catch (_) { return false;}\n    return false;\n  }\n  Future<RtcSessionDescription> createOffer([Map mediaConstraints]) {\n    var completer = new Completer<RtcSessionDescription>();\n    _createOffer(\n        (value) { completer.complete(value); },\n        (error) { completer.completeError(error); }, mediaConstraints);\n    return completer.future;\n  }\n\n  Future<RtcSessionDescription> createAnswer([Map mediaConstraints]) {\n    var completer = new Completer<RtcSessionDescription>();\n    _createAnswer(\n        (value) { completer.complete(value); },\n        (error) { completer.completeError(error); }, mediaConstraints);\n    return completer.future;\n  }\n\n  @DomName('RTCPeerConnection.getStats')\n  Future<RtcStatsResponse> getStats(MediaStreamTrack selector) {\n    var completer = new Completer<RtcStatsResponse>();\n    _getStats((value) { completer.complete(value); }, selector);\n    return completer.future;\n  }\n  // To suppress missing implicit constructor warnings.\n  factory RtcPeerConnection._() { throw new UnsupportedError(\"Not supported\"); }\n\n  /**\n   * Static factory designed to expose `addstream` events to event\n   * handlers that are not necessarily instances of [RtcPeerConnection].\n   *\n   * See [EventStreamProvider] for usage information.\n   */\n  @DomName('RTCPeerConnection.addstreamEvent')\n  @DocsEditable()\n  static const EventStreamProvider<MediaStreamEvent> addStreamEvent = const EventStreamProvider<MediaStreamEvent>('addstream');\n\n  /**\n   * Static factory designed to expose `datachannel` events to event\n   * handlers that are not necessarily instances of [RtcPeerConnection].\n   *\n   * See [EventStreamProvider] for usage information.\n   */\n  @DomName('RTCPeerConnection.datachannelEvent')\n  @DocsEditable()\n  static const EventStreamProvider<RtcDataChannelEvent> dataChannelEvent = const EventStreamProvider<RtcDataChannelEvent>('datachannel');\n\n  /**\n   * Static factory designed to expose `icecandidate` events to event\n   * handlers that are not necessarily instances of [RtcPeerConnection].\n   *\n   * See [EventStreamProvider] for usage information.\n   */\n  @DomName('RTCPeerConnection.icecandidateEvent')\n  @DocsEditable()\n  static const EventStreamProvider<RtcIceCandidateEvent> iceCandidateEvent = const EventStreamProvider<RtcIceCandidateEvent>('icecandidate');\n\n  /**\n   * Static factory designed to expose `iceconnectionstatechange` events to event\n   * handlers that are not necessarily instances of [RtcPeerConnection].\n   *\n   * See [EventStreamProvider] for usage information.\n   */\n  @DomName('RTCPeerConnection.iceconnectionstatechangeEvent')\n  @DocsEditable()\n  static const EventStreamProvider<Event> iceConnectionStateChangeEvent = const EventStreamProvider<Event>('iceconnectionstatechange');\n\n  /**\n   * Static factory designed to expose `negotiationneeded` events to event\n   * handlers that are not necessarily instances of [RtcPeerConnection].\n   *\n   * See [EventStreamProvider] for usage information.\n   */\n  @DomName('RTCPeerConnection.negotiationneededEvent')\n  @DocsEditable()\n  static const EventStreamProvider<Event> negotiationNeededEvent = const EventStreamProvider<Event>('negotiationneeded');\n\n  /**\n   * Static factory designed to expose `removestream` events to event\n   * handlers that are not necessarily instances of [RtcPeerConnection].\n   *\n   * See [EventStreamProvider] for usage information.\n   */\n  @DomName('RTCPeerConnection.removestreamEvent')\n  @DocsEditable()\n  static const EventStreamProvider<MediaStreamEvent> removeStreamEvent = const EventStreamProvider<MediaStreamEvent>('removestream');\n\n  /**\n   * Static factory designed to expose `signalingstatechange` events to event\n   * handlers that are not necessarily instances of [RtcPeerConnection].\n   *\n   * See [EventStreamProvider] for usage information.\n   */\n  @DomName('RTCPeerConnection.signalingstatechangeEvent')\n  @DocsEditable()\n  static const EventStreamProvider<Event> signalingStateChangeEvent = const EventStreamProvider<Event>('signalingstatechange');\n\n  @DomName('RTCPeerConnection.iceConnectionState')\n  @DocsEditable()\n  final String iceConnectionState;\n\n  @DomName('RTCPeerConnection.iceGatheringState')\n  @DocsEditable()\n  final String iceGatheringState;\n\n  @DomName('RTCPeerConnection.localDescription')\n  @DocsEditable()\n  final RtcSessionDescription localDescription;\n\n  @DomName('RTCPeerConnection.remoteDescription')\n  @DocsEditable()\n  final RtcSessionDescription remoteDescription;\n\n  @DomName('RTCPeerConnection.signalingState')\n  @DocsEditable()\n  final String signalingState;\n\n  @DomName('RTCPeerConnection.addIceCandidate')\n  @DocsEditable()\n  void addIceCandidate(RtcIceCandidate candidate, VoidCallback successCallback, _RtcErrorCallback failureCallback) native;\n\n  @DomName('RTCPeerConnection.addStream')\n  @DocsEditable()\n  void addStream(MediaStream stream, [Map mediaConstraints]) {\n    if (mediaConstraints != null) {\n      var mediaConstraints_1 = convertDartToNative_Dictionary(mediaConstraints);\n      _addStream_1(stream, mediaConstraints_1);\n      return;\n    }\n    _addStream_2(stream);\n    return;\n  }\n  @JSName('addStream')\n  @DomName('RTCPeerConnection.addStream')\n  @DocsEditable()\n  void _addStream_1(MediaStream stream, mediaConstraints) native;\n  @JSName('addStream')\n  @DomName('RTCPeerConnection.addStream')\n  @DocsEditable()\n  void _addStream_2(MediaStream stream) native;\n\n  @DomName('RTCPeerConnection.close')\n  @DocsEditable()\n  void close() native;\n\n  @DomName('RTCPeerConnection.createAnswer')\n  @DocsEditable()\n  void _createAnswer(_RtcSessionDescriptionCallback successCallback, [_RtcErrorCallback failureCallback, Map mediaConstraints]) {\n    if (mediaConstraints != null) {\n      var mediaConstraints_1 = convertDartToNative_Dictionary(mediaConstraints);\n      _createAnswer_1(successCallback, failureCallback, mediaConstraints_1);\n      return;\n    }\n    _createAnswer_2(successCallback, failureCallback);\n    return;\n  }\n  @JSName('createAnswer')\n  @DomName('RTCPeerConnection.createAnswer')\n  @DocsEditable()\n  void _createAnswer_1(_RtcSessionDescriptionCallback successCallback, _RtcErrorCallback failureCallback, mediaConstraints) native;\n  @JSName('createAnswer')\n  @DomName('RTCPeerConnection.createAnswer')\n  @DocsEditable()\n  void _createAnswer_2(_RtcSessionDescriptionCallback successCallback, _RtcErrorCallback failureCallback) native;\n\n  @JSName('createDTMFSender')\n  @DomName('RTCPeerConnection.createDTMFSender')\n  @DocsEditable()\n  RtcDtmfSender createDtmfSender(MediaStreamTrack track) native;\n\n  @DomName('RTCPeerConnection.createDataChannel')\n  @DocsEditable()\n  RtcDataChannel createDataChannel(String label, [Map options]) {\n    if (options != null) {\n      var options_1 = convertDartToNative_Dictionary(options);\n      return _createDataChannel_1(label, options_1);\n    }\n    return _createDataChannel_2(label);\n  }\n  @JSName('createDataChannel')\n  @DomName('RTCPeerConnection.createDataChannel')\n  @DocsEditable()\n  RtcDataChannel _createDataChannel_1(label, options) native;\n  @JSName('createDataChannel')\n  @DomName('RTCPeerConnection.createDataChannel')\n  @DocsEditable()\n  RtcDataChannel _createDataChannel_2(label) native;\n\n  @DomName('RTCPeerConnection.createOffer')\n  @DocsEditable()\n  void _createOffer(_RtcSessionDescriptionCallback successCallback, [_RtcErrorCallback failureCallback, Map mediaConstraints]) {\n    if (mediaConstraints != null) {\n      var mediaConstraints_1 = convertDartToNative_Dictionary(mediaConstraints);\n      _createOffer_1(successCallback, failureCallback, mediaConstraints_1);\n      return;\n    }\n    _createOffer_2(successCallback, failureCallback);\n    return;\n  }\n  @JSName('createOffer')\n  @DomName('RTCPeerConnection.createOffer')\n  @DocsEditable()\n  void _createOffer_1(_RtcSessionDescriptionCallback successCallback, _RtcErrorCallback failureCallback, mediaConstraints) native;\n  @JSName('createOffer')\n  @DomName('RTCPeerConnection.createOffer')\n  @DocsEditable()\n  void _createOffer_2(_RtcSessionDescriptionCallback successCallback, _RtcErrorCallback failureCallback) native;\n\n  @DomName('RTCPeerConnection.getLocalStreams')\n  @DocsEditable()\n  List<MediaStream> getLocalStreams() native;\n\n  @DomName('RTCPeerConnection.getRemoteStreams')\n  @DocsEditable()\n  List<MediaStream> getRemoteStreams() native;\n\n  @JSName('getStats')\n  @DomName('RTCPeerConnection.getStats')\n  @DocsEditable()\n  void _getStats(RtcStatsCallback successCallback, MediaStreamTrack selector) native;\n\n  @DomName('RTCPeerConnection.getStreamById')\n  @DocsEditable()\n  MediaStream getStreamById(String streamId) native;\n\n  @DomName('RTCPeerConnection.removeStream')\n  @DocsEditable()\n  void removeStream(MediaStream stream) native;\n\n  @JSName('setLocalDescription')\n  @DomName('RTCPeerConnection.setLocalDescription')\n  @DocsEditable()\n  void _setLocalDescription(RtcSessionDescription description, [VoidCallback successCallback, _RtcErrorCallback failureCallback]) native;\n\n  @JSName('setLocalDescription')\n  @DomName('RTCPeerConnection.setLocalDescription')\n  @DocsEditable()\n  Future setLocalDescription(RtcSessionDescription description) {\n    var completer = new Completer();\n    _setLocalDescription(description,\n        () { completer.complete(); },\n        (error) { completer.completeError(error); });\n    return completer.future;\n  }\n\n  @JSName('setRemoteDescription')\n  @DomName('RTCPeerConnection.setRemoteDescription')\n  @DocsEditable()\n  void _setRemoteDescription(RtcSessionDescription description, [VoidCallback successCallback, _RtcErrorCallback failureCallback]) native;\n\n  @JSName('setRemoteDescription')\n  @DomName('RTCPeerConnection.setRemoteDescription')\n  @DocsEditable()\n  Future setRemoteDescription(RtcSessionDescription description) {\n    var completer = new Completer();\n    _setRemoteDescription(description,\n        () { completer.complete(); },\n        (error) { completer.completeError(error); });\n    return completer.future;\n  }\n\n  @DomName('RTCPeerConnection.updateIce')\n  @DocsEditable()\n  void updateIce([Map configuration, Map mediaConstraints]) {\n    if (mediaConstraints != null) {\n      var configuration_1 = convertDartToNative_Dictionary(configuration);\n      var mediaConstraints_2 = convertDartToNative_Dictionary(mediaConstraints);\n      _updateIce_1(configuration_1, mediaConstraints_2);\n      return;\n    }\n    if (configuration != null) {\n      var configuration_3 = convertDartToNative_Dictionary(configuration);\n      _updateIce_2(configuration_3);\n      return;\n    }\n    _updateIce_3();\n    return;\n  }\n  @JSName('updateIce')\n  @DomName('RTCPeerConnection.updateIce')\n  @DocsEditable()\n  void _updateIce_1(configuration, mediaConstraints) native;\n  @JSName('updateIce')\n  @DomName('RTCPeerConnection.updateIce')\n  @DocsEditable()\n  void _updateIce_2(configuration) native;\n  @JSName('updateIce')\n  @DomName('RTCPeerConnection.updateIce')\n  @DocsEditable()\n  void _updateIce_3() native;\n\n  /// Stream of `addstream` events handled by this [RtcPeerConnection].\n  @DomName('RTCPeerConnection.onaddstream')\n  @DocsEditable()\n  Stream<MediaStreamEvent> get onAddStream => addStreamEvent.forTarget(this);\n\n  /// Stream of `datachannel` events handled by this [RtcPeerConnection].\n  @DomName('RTCPeerConnection.ondatachannel')\n  @DocsEditable()\n  Stream<RtcDataChannelEvent> get onDataChannel => dataChannelEvent.forTarget(this);\n\n  /// Stream of `icecandidate` events handled by this [RtcPeerConnection].\n  @DomName('RTCPeerConnection.onicecandidate')\n  @DocsEditable()\n  Stream<RtcIceCandidateEvent> get onIceCandidate => iceCandidateEvent.forTarget(this);\n\n  /// Stream of `iceconnectionstatechange` events handled by this [RtcPeerConnection].\n  @DomName('RTCPeerConnection.oniceconnectionstatechange')\n  @DocsEditable()\n  Stream<Event> get onIceConnectionStateChange => iceConnectionStateChangeEvent.forTarget(this);\n\n  /// Stream of `negotiationneeded` events handled by this [RtcPeerConnection].\n  @DomName('RTCPeerConnection.onnegotiationneeded')\n  @DocsEditable()\n  Stream<Event> get onNegotiationNeeded => negotiationNeededEvent.forTarget(this);\n\n  /// Stream of `removestream` events handled by this [RtcPeerConnection].\n  @DomName('RTCPeerConnection.onremovestream')\n  @DocsEditable()\n  Stream<MediaStreamEvent> get onRemoveStream => removeStreamEvent.forTarget(this);\n\n  /// Stream of `signalingstatechange` events handled by this [RtcPeerConnection].\n  @DomName('RTCPeerConnection.onsignalingstatechange')\n  @DocsEditable()\n  Stream<Event> get onSignalingStateChange => signalingStateChangeEvent.forTarget(this);\n\n}\n// Copyright (c) 2013, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DomName('RTCSessionDescription')\n@SupportedBrowser(SupportedBrowser.CHROME)\n@Experimental()\n// http://dev.w3.org/2011/webrtc/editor/webrtc.html#idl-def-RTCSessionDescription\n@Native(\"RTCSessionDescription,mozRTCSessionDescription\")\nclass RtcSessionDescription extends Interceptor {\n  factory RtcSessionDescription(Map dictionary) {\n    // TODO(efortuna): Remove this check if when you can actually construct with\n    // the unprefixed RTCIceCandidate in Firefox (currently both are defined,\n    // but one can't be used as a constructor).\n    var constructorName = JS('', 'window[#]',\n        Device.isFirefox ? '${Device.propertyPrefix}RTCSessionDescription' :\n       'RTCSessionDescription');\n    return JS('RtcSessionDescription',\n        'new #(#)', constructorName,\n        convertDartToNative_SerializedScriptValue(dictionary));\n  }\n  // To suppress missing implicit constructor warnings.\n  factory RtcSessionDescription._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('RTCSessionDescription.sdp')\n  @DocsEditable()\n  String sdp;\n\n  @DomName('RTCSessionDescription.type')\n  @DocsEditable()\n  String type;\n\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('RTCStatsReport')\n// http://dev.w3.org/2011/webrtc/editor/webrtc.html#idl-def-RTCStatsReport\n@Experimental()\n@Native(\"RTCStatsReport\")\nclass RtcStatsReport extends Interceptor {\n  // To suppress missing implicit constructor warnings.\n  factory RtcStatsReport._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('RTCStatsReport.id')\n  @DocsEditable()\n  final String id;\n\n  @DomName('RTCStatsReport.local')\n  @DocsEditable()\n  final RtcStatsReport local;\n\n  @DomName('RTCStatsReport.remote')\n  @DocsEditable()\n  final RtcStatsReport remote;\n\n  @DomName('RTCStatsReport.timestamp')\n  @DocsEditable()\n  DateTime get timestamp => convertNativeToDart_DateTime(this._get_timestamp);\n  @JSName('timestamp')\n  @DomName('RTCStatsReport.timestamp')\n  @DocsEditable()\n  @Creates('Null')\n  final dynamic _get_timestamp;\n\n  @DomName('RTCStatsReport.type')\n  @DocsEditable()\n  final String type;\n\n  @DomName('RTCStatsReport.names')\n  @DocsEditable()\n  List<String> names() native;\n\n  @DomName('RTCStatsReport.stat')\n  @DocsEditable()\n  String stat(String name) native;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('RTCStatsResponse')\n// http://dev.w3.org/2011/webrtc/editor/webrtc.html#widl-RTCStatsReport-RTCStats-getter-DOMString-id\n@Experimental()\n@Native(\"RTCStatsResponse\")\nclass RtcStatsResponse extends Interceptor {\n  // To suppress missing implicit constructor warnings.\n  factory RtcStatsResponse._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('RTCStatsResponse.__getter__')\n  @DocsEditable()\n  RtcStatsReport __getter__(String name) native;\n\n  @DomName('RTCStatsResponse.namedItem')\n  @DocsEditable()\n  RtcStatsReport namedItem(String name) native;\n\n  @DomName('RTCStatsResponse.result')\n  @DocsEditable()\n  List<RtcStatsReport> result() native;\n}\n// Copyright (c) 2013, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('Screen')\n@Native(\"Screen\")\nclass Screen extends EventTarget {\n\n  @DomName('Screen.availHeight')\n  @DomName('Screen.availLeft')\n  @DomName('Screen.availTop')\n  @DomName('Screen.availWidth')\n  Rectangle get available => new Rectangle(_availLeft, _availTop, _availWidth,\n      _availHeight);\n  // To suppress missing implicit constructor warnings.\n  factory Screen._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @JSName('availHeight')\n  @DomName('Screen.availHeight')\n  @DocsEditable()\n  final int _availHeight;\n\n  @JSName('availLeft')\n  @DomName('Screen.availLeft')\n  @DocsEditable()\n  @Experimental() // nonstandard\n  final int _availLeft;\n\n  @JSName('availTop')\n  @DomName('Screen.availTop')\n  @DocsEditable()\n  @Experimental() // nonstandard\n  final int _availTop;\n\n  @JSName('availWidth')\n  @DomName('Screen.availWidth')\n  @DocsEditable()\n  final int _availWidth;\n\n  @DomName('Screen.colorDepth')\n  @DocsEditable()\n  final int colorDepth;\n\n  @DomName('Screen.height')\n  @DocsEditable()\n  final int height;\n\n  @DomName('Screen.orientation')\n  @DocsEditable()\n  @Experimental() // untriaged\n  final String orientation;\n\n  @DomName('Screen.pixelDepth')\n  @DocsEditable()\n  final int pixelDepth;\n\n  @DomName('Screen.width')\n  @DocsEditable()\n  final int width;\n\n  @DomName('Screen.lockOrientation')\n  @DocsEditable()\n  @Experimental() // untriaged\n  bool lockOrientation(String orientation) native;\n\n  @DomName('Screen.unlockOrientation')\n  @DocsEditable()\n  @Experimental() // untriaged\n  void unlockOrientation() native;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('HTMLScriptElement')\n@Native(\"HTMLScriptElement\")\nclass ScriptElement extends HtmlElement {\n  // To suppress missing implicit constructor warnings.\n  factory ScriptElement._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('HTMLScriptElement.HTMLScriptElement')\n  @DocsEditable()\n  factory ScriptElement() => document.createElement(\"script\");\n  /**\n   * Constructor instantiated by the DOM when a custom element has been created.\n   *\n   * This can only be called by subclasses from their created constructor.\n   */\n  ScriptElement.created() : super.created();\n\n  @DomName('HTMLScriptElement.async')\n  @DocsEditable()\n  bool async;\n\n  @DomName('HTMLScriptElement.charset')\n  @DocsEditable()\n  String charset;\n\n  @DomName('HTMLScriptElement.crossOrigin')\n  @DocsEditable()\n  // http://www.whatwg.org/specs/web-apps/current-work/multipage/scripting-1.html#attr-script-crossorigin\n  @Experimental()\n  String crossOrigin;\n\n  @DomName('HTMLScriptElement.defer')\n  @DocsEditable()\n  bool defer;\n\n  @DomName('HTMLScriptElement.nonce')\n  @DocsEditable()\n  // https://dvcs.w3.org/hg/content-security-policy/raw-file/tip/csp-specification.dev.html#interaction-with-the-script-src-directive\n  @Experimental()\n  String nonce;\n\n  @DomName('HTMLScriptElement.src')\n  @DocsEditable()\n  String src;\n\n  @DomName('HTMLScriptElement.type')\n  @DocsEditable()\n  String type;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('SecurityPolicyViolationEvent')\n// https://dvcs.w3.org/hg/content-security-policy/raw-file/tip/csp-specification.dev.html#securitypolicyviolationevent-events\n@Experimental()\n@Native(\"SecurityPolicyViolationEvent\")\nclass SecurityPolicyViolationEvent extends Event {\n  // To suppress missing implicit constructor warnings.\n  factory SecurityPolicyViolationEvent._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @JSName('blockedURI')\n  @DomName('SecurityPolicyViolationEvent.blockedURI')\n  @DocsEditable()\n  final String blockedUri;\n\n  @DomName('SecurityPolicyViolationEvent.columnNumber')\n  @DocsEditable()\n  final int columnNumber;\n\n  @JSName('documentURI')\n  @DomName('SecurityPolicyViolationEvent.documentURI')\n  @DocsEditable()\n  final String documentUri;\n\n  @DomName('SecurityPolicyViolationEvent.effectiveDirective')\n  @DocsEditable()\n  final String effectiveDirective;\n\n  @DomName('SecurityPolicyViolationEvent.lineNumber')\n  @DocsEditable()\n  final int lineNumber;\n\n  @DomName('SecurityPolicyViolationEvent.originalPolicy')\n  @DocsEditable()\n  final String originalPolicy;\n\n  @DomName('SecurityPolicyViolationEvent.referrer')\n  @DocsEditable()\n  final String referrer;\n\n  @DomName('SecurityPolicyViolationEvent.sourceFile')\n  @DocsEditable()\n  final String sourceFile;\n\n  @DomName('SecurityPolicyViolationEvent.statusCode')\n  @DocsEditable()\n  @Experimental() // untriaged\n  final int statusCode;\n\n  @DomName('SecurityPolicyViolationEvent.violatedDirective')\n  @DocsEditable()\n  final String violatedDirective;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DomName('HTMLSelectElement')\n@Native(\"HTMLSelectElement\")\nclass SelectElement extends HtmlElement {\n  // To suppress missing implicit constructor warnings.\n  factory SelectElement._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('HTMLSelectElement.HTMLSelectElement')\n  @DocsEditable()\n  factory SelectElement() => document.createElement(\"select\");\n  /**\n   * Constructor instantiated by the DOM when a custom element has been created.\n   *\n   * This can only be called by subclasses from their created constructor.\n   */\n  SelectElement.created() : super.created();\n\n  @DomName('HTMLSelectElement.autofocus')\n  @DocsEditable()\n  bool autofocus;\n\n  @DomName('HTMLSelectElement.disabled')\n  @DocsEditable()\n  bool disabled;\n\n  @DomName('HTMLSelectElement.form')\n  @DocsEditable()\n  final FormElement form;\n\n  @DomName('HTMLSelectElement.labels')\n  @DocsEditable()\n  @Unstable()\n  @Returns('NodeList')\n  @Creates('NodeList')\n  final List<Node> labels;\n\n  @DomName('HTMLSelectElement.length')\n  @DocsEditable()\n  int length;\n\n  @DomName('HTMLSelectElement.multiple')\n  @DocsEditable()\n  bool multiple;\n\n  @DomName('HTMLSelectElement.name')\n  @DocsEditable()\n  String name;\n\n  @DomName('HTMLSelectElement.required')\n  @DocsEditable()\n  bool required;\n\n  @DomName('HTMLSelectElement.selectedIndex')\n  @DocsEditable()\n  int selectedIndex;\n\n  @DomName('HTMLSelectElement.size')\n  @DocsEditable()\n  int size;\n\n  @DomName('HTMLSelectElement.type')\n  @DocsEditable()\n  final String type;\n\n  @DomName('HTMLSelectElement.validationMessage')\n  @DocsEditable()\n  final String validationMessage;\n\n  @DomName('HTMLSelectElement.validity')\n  @DocsEditable()\n  final ValidityState validity;\n\n  @DomName('HTMLSelectElement.value')\n  @DocsEditable()\n  String value;\n\n  @DomName('HTMLSelectElement.willValidate')\n  @DocsEditable()\n  final bool willValidate;\n\n  @DomName('HTMLSelectElement.__setter__')\n  @DocsEditable()\n  void __setter__(int index, OptionElement value) native;\n\n  @DomName('HTMLSelectElement.checkValidity')\n  @DocsEditable()\n  bool checkValidity() native;\n\n  @DomName('HTMLSelectElement.item')\n  @DocsEditable()\n  Element item(int index) native;\n\n  @DomName('HTMLSelectElement.namedItem')\n  @DocsEditable()\n  Element namedItem(String name) native;\n\n  @DomName('HTMLSelectElement.setCustomValidity')\n  @DocsEditable()\n  void setCustomValidity(String error) native;\n\n\n  // Override default options, since IE returns SelectElement itself and it\n  // does not operate as a List.\n  List<OptionElement> get options {\n    var options = this.querySelectorAll('option').where(\n        (e) => e is OptionElement).toList();\n    return new UnmodifiableListView(options);\n  }\n\n  List<OptionElement> get selectedOptions {\n    // IE does not change the selected flag for single-selection items.\n    if (this.multiple) {\n      var options = this.options.where((o) => o.selected).toList();\n      return new UnmodifiableListView(options);\n    } else {\n      return [this.options[this.selectedIndex]];\n    }\n  }\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('Selection')\n@Native(\"Selection\")\nclass Selection extends Interceptor {\n  // To suppress missing implicit constructor warnings.\n  factory Selection._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('Selection.anchorNode')\n  @DocsEditable()\n  final Node anchorNode;\n\n  @DomName('Selection.anchorOffset')\n  @DocsEditable()\n  final int anchorOffset;\n\n  @DomName('Selection.baseNode')\n  @DocsEditable()\n  @Experimental() // non-standard\n  final Node baseNode;\n\n  @DomName('Selection.baseOffset')\n  @DocsEditable()\n  @Experimental() // non-standard\n  final int baseOffset;\n\n  @DomName('Selection.extentNode')\n  @DocsEditable()\n  @Experimental() // non-standard\n  final Node extentNode;\n\n  @DomName('Selection.extentOffset')\n  @DocsEditable()\n  @Experimental() // non-standard\n  final int extentOffset;\n\n  @DomName('Selection.focusNode')\n  @DocsEditable()\n  final Node focusNode;\n\n  @DomName('Selection.focusOffset')\n  @DocsEditable()\n  final int focusOffset;\n\n  @DomName('Selection.isCollapsed')\n  @DocsEditable()\n  final bool isCollapsed;\n\n  @DomName('Selection.rangeCount')\n  @DocsEditable()\n  final int rangeCount;\n\n  @DomName('Selection.type')\n  @DocsEditable()\n  @Experimental() // non-standard\n  final String type;\n\n  @DomName('Selection.addRange')\n  @DocsEditable()\n  void addRange(Range range) native;\n\n  @DomName('Selection.collapse')\n  @DocsEditable()\n  void collapse(Node node, int index) native;\n\n  @DomName('Selection.collapseToEnd')\n  @DocsEditable()\n  void collapseToEnd() native;\n\n  @DomName('Selection.collapseToStart')\n  @DocsEditable()\n  void collapseToStart() native;\n\n  @DomName('Selection.containsNode')\n  @DocsEditable()\n  @Experimental() // non-standard\n  bool containsNode(Node node, bool allowPartial) native;\n\n  @DomName('Selection.deleteFromDocument')\n  @DocsEditable()\n  void deleteFromDocument() native;\n\n  @DomName('Selection.empty')\n  @DocsEditable()\n  @Experimental() // non-standard\n  void empty() native;\n\n  @DomName('Selection.extend')\n  @DocsEditable()\n  void extend(Node node, int offset) native;\n\n  @DomName('Selection.getRangeAt')\n  @DocsEditable()\n  Range getRangeAt(int index) native;\n\n  @DomName('Selection.modify')\n  @DocsEditable()\n  @Experimental() // non-standard\n  void modify(String alter, String direction, String granularity) native;\n\n  @DomName('Selection.removeAllRanges')\n  @DocsEditable()\n  void removeAllRanges() native;\n\n  @DomName('Selection.selectAllChildren')\n  @DocsEditable()\n  void selectAllChildren(Node node) native;\n\n  @DomName('Selection.setBaseAndExtent')\n  @DocsEditable()\n  @Experimental() // non-standard\n  void setBaseAndExtent(Node baseNode, int baseOffset, Node extentNode, int extentOffset) native;\n\n  @DomName('Selection.setPosition')\n  @DocsEditable()\n  @Experimental() // non-standard\n  void setPosition(Node node, int offset) native;\n\n  @DomName('Selection.toString')\n  @DocsEditable()\n  String toString() native;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('ServiceWorkerContainer')\n@Experimental() // untriaged\n@Native(\"ServiceWorkerContainer\")\nclass ServiceWorkerContainer extends Interceptor {\n  // To suppress missing implicit constructor warnings.\n  factory ServiceWorkerContainer._() { throw new UnsupportedError(\"Not supported\"); }\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('ServiceWorkerGlobalScope')\n@Experimental() // untriaged\n@Native(\"ServiceWorkerGlobalScope\")\nclass ServiceWorkerGlobalScope extends WorkerGlobalScope {\n  // To suppress missing implicit constructor warnings.\n  factory ServiceWorkerGlobalScope._() { throw new UnsupportedError(\"Not supported\"); }\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('HTMLShadowElement')\n@SupportedBrowser(SupportedBrowser.CHROME, '26')\n@Experimental()\n// https://dvcs.w3.org/hg/webcomponents/raw-file/tip/spec/shadow/index.html#shadow-element\n@Native(\"HTMLShadowElement\")\nclass ShadowElement extends HtmlElement {\n  // To suppress missing implicit constructor warnings.\n  factory ShadowElement._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('HTMLShadowElement.HTMLShadowElement')\n  @DocsEditable()\n  factory ShadowElement() => document.createElement(\"shadow\");\n  /**\n   * Constructor instantiated by the DOM when a custom element has been created.\n   *\n   * This can only be called by subclasses from their created constructor.\n   */\n  ShadowElement.created() : super.created();\n\n  /// Checks if this type is supported on the current platform.\n  static bool get supported => Element.isTagSupported('shadow');\n\n  @DomName('HTMLShadowElement.resetStyleInheritance')\n  @DocsEditable()\n  bool resetStyleInheritance;\n\n  @DomName('HTMLShadowElement.getDistributedNodes')\n  @DocsEditable()\n  @Experimental() // untriaged\n  @Returns('NodeList')\n  @Creates('NodeList')\n  List<Node> getDistributedNodes() native;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n// WARNING: Do not edit - generated code.\n\n\n@DomName('ShadowRoot')\n@SupportedBrowser(SupportedBrowser.CHROME, '26')\n@Experimental()\n// https://dvcs.w3.org/hg/webcomponents/raw-file/tip/spec/shadow/index.html#api-shadow-root\n@Native(\"ShadowRoot\")\nclass ShadowRoot extends DocumentFragment {\n  // To suppress missing implicit constructor warnings.\n  factory ShadowRoot._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('ShadowRoot.activeElement')\n  @DocsEditable()\n  final Element activeElement;\n\n  @DomName('ShadowRoot.host')\n  @DocsEditable()\n  @Experimental() // untriaged\n  final Element host;\n\n  @JSName('innerHTML')\n  @DomName('ShadowRoot.innerHTML')\n  @DocsEditable()\n  String innerHtml;\n\n  @DomName('ShadowRoot.olderShadowRoot')\n  @DocsEditable()\n  @Experimental() // untriaged\n  final ShadowRoot olderShadowRoot;\n\n  @JSName('resetStyleInheritance')\n  @DomName('ShadowRoot.resetStyleInheritance')\n  @DocsEditable()\n  bool _resetStyleInheritance;\n\n  @DomName('ShadowRoot.styleSheets')\n  @DocsEditable()\n  @Experimental() // untriaged\n  @Returns('_StyleSheetList')\n  @Creates('_StyleSheetList')\n  final List<StyleSheet> styleSheets;\n\n  @JSName('cloneNode')\n  @DomName('ShadowRoot.cloneNode')\n  @DocsEditable()\n  Node clone(bool deep) native;\n\n  @DomName('ShadowRoot.elementFromPoint')\n  @DocsEditable()\n  Element elementFromPoint(int x, int y) native;\n\n  @DomName('ShadowRoot.getElementById')\n  @DocsEditable()\n  Element getElementById(String elementId) native;\n\n  @DomName('ShadowRoot.getElementsByClassName')\n  @DocsEditable()\n  @Creates('NodeList|HtmlCollection')\n  @Returns('NodeList|HtmlCollection')\n  List<Node> getElementsByClassName(String className) native;\n\n  @DomName('ShadowRoot.getElementsByTagName')\n  @DocsEditable()\n  @Creates('NodeList|HtmlCollection')\n  @Returns('NodeList|HtmlCollection')\n  List<Node> getElementsByTagName(String tagName) native;\n\n  @DomName('ShadowRoot.getSelection')\n  @DocsEditable()\n  Selection getSelection() native;\n\n  static bool get supported =>\n      JS('bool', '!!(Element.prototype.createShadowRoot||'\n                 'Element.prototype.webkitCreateShadowRoot)');\n\n  static bool _shadowRootDeprecationReported = false;\n  static void _shadowRootDeprecationReport() {\n    if (!_shadowRootDeprecationReported) {\n      window.console.warn('''\nShadowRoot.resetStyleInheritance and ShadowRoot.applyAuthorStyles now deprecated in dart:html.\nPlease remove them from your code.\n''');\n      _shadowRootDeprecationReported = true;\n    }\n  }\n\n  @deprecated\n  bool get resetStyleInheritance {\n    _shadowRootDeprecationReport();\n    // Default value from when it was specified.\n    return false;\n  }\n\n  @deprecated\n  void set resetStyleInheritance(bool value) {\n    _shadowRootDeprecationReport();\n  }\n\n  @deprecated\n  bool get applyAuthorStyles {\n    _shadowRootDeprecationReport();\n    // Default value from when it was specified.\n    return false;\n  }\n\n  @deprecated\n  void set applyAuthorStyles(bool value) {\n    _shadowRootDeprecationReport();\n  }\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('SharedWorker')\n// http://www.whatwg.org/specs/web-apps/current-work/multipage/workers.html#shared-workers-and-the-sharedworker-interface\n@Experimental()\n@Native(\"SharedWorker\")\nclass SharedWorker extends EventTarget implements AbstractWorker {\n  // To suppress missing implicit constructor warnings.\n  factory SharedWorker._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('SharedWorker.errorEvent')\n  @DocsEditable()\n  @Experimental() // untriaged\n  static const EventStreamProvider<Event> errorEvent = const EventStreamProvider<Event>('error');\n\n  @DomName('SharedWorker.SharedWorker')\n  @DocsEditable()\n  factory SharedWorker(String scriptURL, [String name]) {\n    if (name != null) {\n      return SharedWorker._create_1(scriptURL, name);\n    }\n    return SharedWorker._create_2(scriptURL);\n  }\n  static SharedWorker _create_1(scriptURL, name) => JS('SharedWorker', 'new SharedWorker(#,#)', scriptURL, name);\n  static SharedWorker _create_2(scriptURL) => JS('SharedWorker', 'new SharedWorker(#)', scriptURL);\n\n  @DomName('SharedWorker.port')\n  @DocsEditable()\n  final MessagePort port;\n\n  @DomName('SharedWorker.workerStart')\n  @DocsEditable()\n  @Experimental() // untriaged\n  final double workerStart;\n\n  @DomName('SharedWorker.onerror')\n  @DocsEditable()\n  @Experimental() // untriaged\n  Stream<Event> get onError => errorEvent.forTarget(this);\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('SharedWorkerGlobalScope')\n@Experimental() // untriaged\n@Native(\"SharedWorkerGlobalScope\")\nclass SharedWorkerGlobalScope extends WorkerGlobalScope {\n  // To suppress missing implicit constructor warnings.\n  factory SharedWorkerGlobalScope._() { throw new UnsupportedError(\"Not supported\"); }\n\n  /**\n   * Static factory designed to expose `connect` events to event\n   * handlers that are not necessarily instances of [SharedWorkerGlobalScope].\n   *\n   * See [EventStreamProvider] for usage information.\n   */\n  @DomName('SharedWorkerGlobalScope.connectEvent')\n  @DocsEditable()\n  @Experimental() // untriaged\n  static const EventStreamProvider<Event> connectEvent = const EventStreamProvider<Event>('connect');\n\n  @DomName('SharedWorkerGlobalScope.name')\n  @DocsEditable()\n  @Experimental() // untriaged\n  final String name;\n\n  /// Stream of `connect` events handled by this [SharedWorkerGlobalScope].\n  @DomName('SharedWorkerGlobalScope.onconnect')\n  @DocsEditable()\n  @Experimental() // untriaged\n  Stream<Event> get onConnect => connectEvent.forTarget(this);\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('SourceBuffer')\n// https://dvcs.w3.org/hg/html-media/raw-file/tip/media-source/media-source.html#sourcebuffer\n@Experimental()\n@Native(\"SourceBuffer\")\nclass SourceBuffer extends EventTarget {\n  // To suppress missing implicit constructor warnings.\n  factory SourceBuffer._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('SourceBuffer.appendWindowEnd')\n  @DocsEditable()\n  @Experimental() // untriaged\n  num appendWindowEnd;\n\n  @DomName('SourceBuffer.appendWindowStart')\n  @DocsEditable()\n  @Experimental() // untriaged\n  num appendWindowStart;\n\n  @DomName('SourceBuffer.buffered')\n  @DocsEditable()\n  final TimeRanges buffered;\n\n  @DomName('SourceBuffer.mode')\n  @DocsEditable()\n  @Experimental() // untriaged\n  String mode;\n\n  @DomName('SourceBuffer.timestampOffset')\n  @DocsEditable()\n  num timestampOffset;\n\n  @DomName('SourceBuffer.updating')\n  @DocsEditable()\n  @Experimental() // untriaged\n  final bool updating;\n\n  @DomName('SourceBuffer.abort')\n  @DocsEditable()\n  void abort() native;\n\n  @DomName('SourceBuffer.appendBuffer')\n  @DocsEditable()\n  @Experimental() // untriaged\n  void appendBuffer(ByteBuffer data) native;\n\n  @DomName('SourceBuffer.appendStream')\n  @DocsEditable()\n  @Experimental() // untriaged\n  void appendStream(FileStream stream, [int maxSize]) native;\n\n  @JSName('appendBuffer')\n  @DomName('SourceBuffer.appendBuffer')\n  @DocsEditable()\n  @Experimental() // untriaged\n  void appendTypedData(TypedData data) native;\n\n  @DomName('SourceBuffer.remove')\n  @DocsEditable()\n  @Experimental() // untriaged\n  void remove(num start, num end) native;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('SourceBufferList')\n// https://dvcs.w3.org/hg/html-media/raw-file/tip/media-source/media-source.html#sourcebufferlist\n@Experimental()\n@Native(\"SourceBufferList\")\nclass SourceBufferList extends EventTarget with ListMixin<SourceBuffer>, ImmutableListMixin<SourceBuffer> implements JavaScriptIndexingBehavior, List<SourceBuffer> {\n  // To suppress missing implicit constructor warnings.\n  factory SourceBufferList._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('SourceBufferList.length')\n  @DocsEditable()\n  int get length => JS(\"int\", \"#.length\", this);\n\n  SourceBuffer operator[](int index) {\n    if (JS(\"bool\", \"# >>> 0 !== # || # >= #\", index,\n        index, index, length))\n      throw new RangeError.range(index, 0, length);\n    return JS(\"SourceBuffer\", \"#[#]\", this, index);\n  }\n  void operator[]=(int index, SourceBuffer value) {\n    throw new UnsupportedError(\"Cannot assign element of immutable List.\");\n  }\n  // -- start List<SourceBuffer> mixins.\n  // SourceBuffer is the element type.\n\n\n  void set length(int value) {\n    throw new UnsupportedError(\"Cannot resize immutable List.\");\n  }\n\n  SourceBuffer get first {\n    if (this.length > 0) {\n      return JS('SourceBuffer', '#[0]', this);\n    }\n    throw new StateError(\"No elements\");\n  }\n\n  SourceBuffer get last {\n    int len = this.length;\n    if (len > 0) {\n      return JS('SourceBuffer', '#[#]', this, len - 1);\n    }\n    throw new StateError(\"No elements\");\n  }\n\n  SourceBuffer get single {\n    int len = this.length;\n    if (len == 1) {\n      return JS('SourceBuffer', '#[0]', this);\n    }\n    if (len == 0) throw new StateError(\"No elements\");\n    throw new StateError(\"More than one element\");\n  }\n\n  SourceBuffer elementAt(int index) => this[index];\n  // -- end List<SourceBuffer> mixins.\n\n  @DomName('SourceBufferList.item')\n  @DocsEditable()\n  SourceBuffer item(int index) native;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('HTMLSourceElement')\n@Native(\"HTMLSourceElement\")\nclass SourceElement extends HtmlElement {\n  // To suppress missing implicit constructor warnings.\n  factory SourceElement._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('HTMLSourceElement.HTMLSourceElement')\n  @DocsEditable()\n  factory SourceElement() => document.createElement(\"source\");\n  /**\n   * Constructor instantiated by the DOM when a custom element has been created.\n   *\n   * This can only be called by subclasses from their created constructor.\n   */\n  SourceElement.created() : super.created();\n\n  @DomName('HTMLSourceElement.media')\n  @DocsEditable()\n  String media;\n\n  @DomName('HTMLSourceElement.src')\n  @DocsEditable()\n  String src;\n\n  @DomName('HTMLSourceElement.type')\n  @DocsEditable()\n  String type;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('SourceInfo')\n@Experimental() // untriaged\n@Native(\"SourceInfo\")\nclass SourceInfo extends Interceptor {\n  // To suppress missing implicit constructor warnings.\n  factory SourceInfo._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('SourceInfo.facing')\n  @DocsEditable()\n  @Experimental() // untriaged\n  final String facing;\n\n  @DomName('SourceInfo.id')\n  @DocsEditable()\n  @Experimental() // untriaged\n  final String id;\n\n  @DomName('SourceInfo.kind')\n  @DocsEditable()\n  @Experimental() // untriaged\n  final String kind;\n\n  @DomName('SourceInfo.label')\n  @DocsEditable()\n  @Experimental() // untriaged\n  final String label;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('HTMLSpanElement')\n@Native(\"HTMLSpanElement\")\nclass SpanElement extends HtmlElement {\n  // To suppress missing implicit constructor warnings.\n  factory SpanElement._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('HTMLSpanElement.HTMLSpanElement')\n  @DocsEditable()\n  factory SpanElement() => document.createElement(\"span\");\n  /**\n   * Constructor instantiated by the DOM when a custom element has been created.\n   *\n   * This can only be called by subclasses from their created constructor.\n   */\n  SpanElement.created() : super.created();\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('SpeechGrammar')\n// https://dvcs.w3.org/hg/speech-api/raw-file/tip/speechapi.html#dfn-speechgrammar\n@Experimental()\n@Native(\"SpeechGrammar\")\nclass SpeechGrammar extends Interceptor {\n  // To suppress missing implicit constructor warnings.\n  factory SpeechGrammar._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('SpeechGrammar.SpeechGrammar')\n  @DocsEditable()\n  factory SpeechGrammar() {\n    return SpeechGrammar._create_1();\n  }\n  static SpeechGrammar _create_1() => JS('SpeechGrammar', 'new SpeechGrammar()');\n\n  @DomName('SpeechGrammar.src')\n  @DocsEditable()\n  String src;\n\n  @DomName('SpeechGrammar.weight')\n  @DocsEditable()\n  num weight;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('SpeechGrammarList')\n// https://dvcs.w3.org/hg/speech-api/raw-file/tip/speechapi.html#dfn-speechgrammarlist\n@Experimental()\n@Native(\"SpeechGrammarList\")\nclass SpeechGrammarList extends Interceptor with ListMixin<SpeechGrammar>, ImmutableListMixin<SpeechGrammar> implements JavaScriptIndexingBehavior, List<SpeechGrammar> {\n  // To suppress missing implicit constructor warnings.\n  factory SpeechGrammarList._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('SpeechGrammarList.SpeechGrammarList')\n  @DocsEditable()\n  factory SpeechGrammarList() {\n    return SpeechGrammarList._create_1();\n  }\n  static SpeechGrammarList _create_1() => JS('SpeechGrammarList', 'new SpeechGrammarList()');\n\n  @DomName('SpeechGrammarList.length')\n  @DocsEditable()\n  int get length => JS(\"int\", \"#.length\", this);\n\n  SpeechGrammar operator[](int index) {\n    if (JS(\"bool\", \"# >>> 0 !== # || # >= #\", index,\n        index, index, length))\n      throw new RangeError.range(index, 0, length);\n    return JS(\"SpeechGrammar\", \"#[#]\", this, index);\n  }\n  void operator[]=(int index, SpeechGrammar value) {\n    throw new UnsupportedError(\"Cannot assign element of immutable List.\");\n  }\n  // -- start List<SpeechGrammar> mixins.\n  // SpeechGrammar is the element type.\n\n\n  void set length(int value) {\n    throw new UnsupportedError(\"Cannot resize immutable List.\");\n  }\n\n  SpeechGrammar get first {\n    if (this.length > 0) {\n      return JS('SpeechGrammar', '#[0]', this);\n    }\n    throw new StateError(\"No elements\");\n  }\n\n  SpeechGrammar get last {\n    int len = this.length;\n    if (len > 0) {\n      return JS('SpeechGrammar', '#[#]', this, len - 1);\n    }\n    throw new StateError(\"No elements\");\n  }\n\n  SpeechGrammar get single {\n    int len = this.length;\n    if (len == 1) {\n      return JS('SpeechGrammar', '#[0]', this);\n    }\n    if (len == 0) throw new StateError(\"No elements\");\n    throw new StateError(\"More than one element\");\n  }\n\n  SpeechGrammar elementAt(int index) => this[index];\n  // -- end List<SpeechGrammar> mixins.\n\n  @DomName('SpeechGrammarList.addFromString')\n  @DocsEditable()\n  void addFromString(String string, [num weight]) native;\n\n  @DomName('SpeechGrammarList.addFromUri')\n  @DocsEditable()\n  void addFromUri(String src, [num weight]) native;\n\n  @DomName('SpeechGrammarList.item')\n  @DocsEditable()\n  SpeechGrammar item(int index) native;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('SpeechInputEvent')\n// http://lists.w3.org/Archives/Public/public-xg-htmlspeech/2011Feb/att-0020/api-draft.html#speech_input_event_interface\n@Experimental()\n@Native(\"SpeechInputEvent\")\nclass SpeechInputEvent extends Event {\n  // To suppress missing implicit constructor warnings.\n  factory SpeechInputEvent._() { throw new UnsupportedError(\"Not supported\"); }\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('SpeechInputResult')\n// http://lists.w3.org/Archives/Public/public-xg-htmlspeech/2011Feb/att-0020/api-draft.html#speech_input_result_interface\n@Experimental()\n@Native(\"SpeechInputResult\")\nclass SpeechInputResult extends Interceptor {\n  // To suppress missing implicit constructor warnings.\n  factory SpeechInputResult._() { throw new UnsupportedError(\"Not supported\"); }\n}\n// Copyright (c) 2013, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DomName('SpeechRecognition')\n@SupportedBrowser(SupportedBrowser.CHROME, '25')\n@Experimental()\n// https://dvcs.w3.org/hg/speech-api/raw-file/tip/speechapi.html#speechreco-section\n@Native(\"SpeechRecognition\")\nclass SpeechRecognition extends EventTarget {\n  // To suppress missing implicit constructor warnings.\n  factory SpeechRecognition._() { throw new UnsupportedError(\"Not supported\"); }\n\n  /**\n   * Static factory designed to expose `audioend` events to event\n   * handlers that are not necessarily instances of [SpeechRecognition].\n   *\n   * See [EventStreamProvider] for usage information.\n   */\n  @DomName('SpeechRecognition.audioendEvent')\n  @DocsEditable()\n  static const EventStreamProvider<Event> audioEndEvent = const EventStreamProvider<Event>('audioend');\n\n  /**\n   * Static factory designed to expose `audiostart` events to event\n   * handlers that are not necessarily instances of [SpeechRecognition].\n   *\n   * See [EventStreamProvider] for usage information.\n   */\n  @DomName('SpeechRecognition.audiostartEvent')\n  @DocsEditable()\n  static const EventStreamProvider<Event> audioStartEvent = const EventStreamProvider<Event>('audiostart');\n\n  /**\n   * Static factory designed to expose `end` events to event\n   * handlers that are not necessarily instances of [SpeechRecognition].\n   *\n   * See [EventStreamProvider] for usage information.\n   */\n  @DomName('SpeechRecognition.endEvent')\n  @DocsEditable()\n  static const EventStreamProvider<Event> endEvent = const EventStreamProvider<Event>('end');\n\n  /**\n   * Static factory designed to expose `error` events to event\n   * handlers that are not necessarily instances of [SpeechRecognition].\n   *\n   * See [EventStreamProvider] for usage information.\n   */\n  @DomName('SpeechRecognition.errorEvent')\n  @DocsEditable()\n  static const EventStreamProvider<SpeechRecognitionError> errorEvent = const EventStreamProvider<SpeechRecognitionError>('error');\n\n  /**\n   * Static factory designed to expose `nomatch` events to event\n   * handlers that are not necessarily instances of [SpeechRecognition].\n   *\n   * See [EventStreamProvider] for usage information.\n   */\n  @DomName('SpeechRecognition.nomatchEvent')\n  @DocsEditable()\n  static const EventStreamProvider<SpeechRecognitionEvent> noMatchEvent = const EventStreamProvider<SpeechRecognitionEvent>('nomatch');\n\n  /**\n   * Static factory designed to expose `result` events to event\n   * handlers that are not necessarily instances of [SpeechRecognition].\n   *\n   * See [EventStreamProvider] for usage information.\n   */\n  @DomName('SpeechRecognition.resultEvent')\n  @DocsEditable()\n  static const EventStreamProvider<SpeechRecognitionEvent> resultEvent = const EventStreamProvider<SpeechRecognitionEvent>('result');\n\n  /**\n   * Static factory designed to expose `soundend` events to event\n   * handlers that are not necessarily instances of [SpeechRecognition].\n   *\n   * See [EventStreamProvider] for usage information.\n   */\n  @DomName('SpeechRecognition.soundendEvent')\n  @DocsEditable()\n  static const EventStreamProvider<Event> soundEndEvent = const EventStreamProvider<Event>('soundend');\n\n  /**\n   * Static factory designed to expose `soundstart` events to event\n   * handlers that are not necessarily instances of [SpeechRecognition].\n   *\n   * See [EventStreamProvider] for usage information.\n   */\n  @DomName('SpeechRecognition.soundstartEvent')\n  @DocsEditable()\n  static const EventStreamProvider<Event> soundStartEvent = const EventStreamProvider<Event>('soundstart');\n\n  /**\n   * Static factory designed to expose `speechend` events to event\n   * handlers that are not necessarily instances of [SpeechRecognition].\n   *\n   * See [EventStreamProvider] for usage information.\n   */\n  @DomName('SpeechRecognition.speechendEvent')\n  @DocsEditable()\n  static const EventStreamProvider<Event> speechEndEvent = const EventStreamProvider<Event>('speechend');\n\n  /**\n   * Static factory designed to expose `speechstart` events to event\n   * handlers that are not necessarily instances of [SpeechRecognition].\n   *\n   * See [EventStreamProvider] for usage information.\n   */\n  @DomName('SpeechRecognition.speechstartEvent')\n  @DocsEditable()\n  static const EventStreamProvider<Event> speechStartEvent = const EventStreamProvider<Event>('speechstart');\n\n  /**\n   * Static factory designed to expose `start` events to event\n   * handlers that are not necessarily instances of [SpeechRecognition].\n   *\n   * See [EventStreamProvider] for usage information.\n   */\n  @DomName('SpeechRecognition.startEvent')\n  @DocsEditable()\n  static const EventStreamProvider<Event> startEvent = const EventStreamProvider<Event>('start');\n\n  /// Checks if this type is supported on the current platform.\n  static bool get supported => JS('bool', '!!(window.SpeechRecognition || window.webkitSpeechRecognition)');\n\n  @DomName('SpeechRecognition.continuous')\n  @DocsEditable()\n  bool continuous;\n\n  @DomName('SpeechRecognition.grammars')\n  @DocsEditable()\n  SpeechGrammarList grammars;\n\n  @DomName('SpeechRecognition.interimResults')\n  @DocsEditable()\n  bool interimResults;\n\n  @DomName('SpeechRecognition.lang')\n  @DocsEditable()\n  String lang;\n\n  @DomName('SpeechRecognition.maxAlternatives')\n  @DocsEditable()\n  int maxAlternatives;\n\n  @DomName('SpeechRecognition.abort')\n  @DocsEditable()\n  void abort() native;\n\n  @DomName('SpeechRecognition.start')\n  @DocsEditable()\n  void start() native;\n\n  @DomName('SpeechRecognition.stop')\n  @DocsEditable()\n  void stop() native;\n\n  /// Stream of `audioend` events handled by this [SpeechRecognition].\n  @DomName('SpeechRecognition.onaudioend')\n  @DocsEditable()\n  Stream<Event> get onAudioEnd => audioEndEvent.forTarget(this);\n\n  /// Stream of `audiostart` events handled by this [SpeechRecognition].\n  @DomName('SpeechRecognition.onaudiostart')\n  @DocsEditable()\n  Stream<Event> get onAudioStart => audioStartEvent.forTarget(this);\n\n  /// Stream of `end` events handled by this [SpeechRecognition].\n  @DomName('SpeechRecognition.onend')\n  @DocsEditable()\n  Stream<Event> get onEnd => endEvent.forTarget(this);\n\n  /// Stream of `error` events handled by this [SpeechRecognition].\n  @DomName('SpeechRecognition.onerror')\n  @DocsEditable()\n  Stream<SpeechRecognitionError> get onError => errorEvent.forTarget(this);\n\n  /// Stream of `nomatch` events handled by this [SpeechRecognition].\n  @DomName('SpeechRecognition.onnomatch')\n  @DocsEditable()\n  Stream<SpeechRecognitionEvent> get onNoMatch => noMatchEvent.forTarget(this);\n\n  /// Stream of `result` events handled by this [SpeechRecognition].\n  @DomName('SpeechRecognition.onresult')\n  @DocsEditable()\n  Stream<SpeechRecognitionEvent> get onResult => resultEvent.forTarget(this);\n\n  /// Stream of `soundend` events handled by this [SpeechRecognition].\n  @DomName('SpeechRecognition.onsoundend')\n  @DocsEditable()\n  Stream<Event> get onSoundEnd => soundEndEvent.forTarget(this);\n\n  /// Stream of `soundstart` events handled by this [SpeechRecognition].\n  @DomName('SpeechRecognition.onsoundstart')\n  @DocsEditable()\n  Stream<Event> get onSoundStart => soundStartEvent.forTarget(this);\n\n  /// Stream of `speechend` events handled by this [SpeechRecognition].\n  @DomName('SpeechRecognition.onspeechend')\n  @DocsEditable()\n  Stream<Event> get onSpeechEnd => speechEndEvent.forTarget(this);\n\n  /// Stream of `speechstart` events handled by this [SpeechRecognition].\n  @DomName('SpeechRecognition.onspeechstart')\n  @DocsEditable()\n  Stream<Event> get onSpeechStart => speechStartEvent.forTarget(this);\n\n  /// Stream of `start` events handled by this [SpeechRecognition].\n  @DomName('SpeechRecognition.onstart')\n  @DocsEditable()\n  Stream<Event> get onStart => startEvent.forTarget(this);\n\n  factory SpeechRecognition() {\n    return JS('SpeechRecognition',\n        'new (window.SpeechRecognition || window.webkitSpeechRecognition)()');\n  }\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('SpeechRecognitionAlternative')\n@SupportedBrowser(SupportedBrowser.CHROME, '25')\n@Experimental()\n// https://dvcs.w3.org/hg/speech-api/raw-file/tip/speechapi.html#speechrecognitionalternative\n@Native(\"SpeechRecognitionAlternative\")\nclass SpeechRecognitionAlternative extends Interceptor {\n  // To suppress missing implicit constructor warnings.\n  factory SpeechRecognitionAlternative._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('SpeechRecognitionAlternative.confidence')\n  @DocsEditable()\n  final double confidence;\n\n  @DomName('SpeechRecognitionAlternative.transcript')\n  @DocsEditable()\n  final String transcript;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('SpeechRecognitionError')\n@SupportedBrowser(SupportedBrowser.CHROME, '25')\n@Experimental()\n// https://dvcs.w3.org/hg/speech-api/raw-file/tip/speechapi.html#speechreco-error\n@Native(\"SpeechRecognitionError\")\nclass SpeechRecognitionError extends Event {\n  // To suppress missing implicit constructor warnings.\n  factory SpeechRecognitionError._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('SpeechRecognitionError.error')\n  @DocsEditable()\n  final String error;\n\n  @DomName('SpeechRecognitionError.message')\n  @DocsEditable()\n  final String message;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('SpeechRecognitionEvent')\n@SupportedBrowser(SupportedBrowser.CHROME, '25')\n@Experimental()\n// https://dvcs.w3.org/hg/speech-api/raw-file/tip/speechapi.html#speechreco-event\n@Native(\"SpeechRecognitionEvent\")\nclass SpeechRecognitionEvent extends Event {\n  // To suppress missing implicit constructor warnings.\n  factory SpeechRecognitionEvent._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('SpeechRecognitionEvent.emma')\n  @DocsEditable()\n  final Document emma;\n\n  @DomName('SpeechRecognitionEvent.interpretation')\n  @DocsEditable()\n  final Document interpretation;\n\n  @DomName('SpeechRecognitionEvent.resultIndex')\n  @DocsEditable()\n  final int resultIndex;\n\n  @DomName('SpeechRecognitionEvent.results')\n  @DocsEditable()\n  @Returns('_SpeechRecognitionResultList')\n  @Creates('_SpeechRecognitionResultList')\n  final List<SpeechRecognitionResult> results;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('SpeechRecognitionResult')\n@SupportedBrowser(SupportedBrowser.CHROME, '25')\n@Experimental()\n// https://dvcs.w3.org/hg/speech-api/raw-file/tip/speechapi.html#speechrecognitionresult\n@Native(\"SpeechRecognitionResult\")\nclass SpeechRecognitionResult extends Interceptor {\n  // To suppress missing implicit constructor warnings.\n  factory SpeechRecognitionResult._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('SpeechRecognitionResult.isFinal')\n  @DocsEditable()\n  final bool isFinal;\n\n  @DomName('SpeechRecognitionResult.length')\n  @DocsEditable()\n  final int length;\n\n  @DomName('SpeechRecognitionResult.item')\n  @DocsEditable()\n  SpeechRecognitionAlternative item(int index) native;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('SpeechSynthesis')\n// https://dvcs.w3.org/hg/speech-api/raw-file/tip/speechapi.html#tts-section\n@Experimental()\n@Native(\"SpeechSynthesis\")\nclass SpeechSynthesis extends EventTarget {\n  // To suppress missing implicit constructor warnings.\n  factory SpeechSynthesis._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('SpeechSynthesis.paused')\n  @DocsEditable()\n  final bool paused;\n\n  @DomName('SpeechSynthesis.pending')\n  @DocsEditable()\n  final bool pending;\n\n  @DomName('SpeechSynthesis.speaking')\n  @DocsEditable()\n  final bool speaking;\n\n  @DomName('SpeechSynthesis.cancel')\n  @DocsEditable()\n  void cancel() native;\n\n  @DomName('SpeechSynthesis.getVoices')\n  @DocsEditable()\n  List<SpeechSynthesisVoice> getVoices() native;\n\n  @DomName('SpeechSynthesis.pause')\n  @DocsEditable()\n  void pause() native;\n\n  @DomName('SpeechSynthesis.resume')\n  @DocsEditable()\n  void resume() native;\n\n  @DomName('SpeechSynthesis.speak')\n  @DocsEditable()\n  void speak(SpeechSynthesisUtterance utterance) native;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('SpeechSynthesisEvent')\n// https://dvcs.w3.org/hg/speech-api/raw-file/tip/speechapi.html#tts-section\n@Experimental()\n@Native(\"SpeechSynthesisEvent\")\nclass SpeechSynthesisEvent extends Event {\n  // To suppress missing implicit constructor warnings.\n  factory SpeechSynthesisEvent._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('SpeechSynthesisEvent.charIndex')\n  @DocsEditable()\n  final int charIndex;\n\n  @DomName('SpeechSynthesisEvent.elapsedTime')\n  @DocsEditable()\n  final double elapsedTime;\n\n  @DomName('SpeechSynthesisEvent.name')\n  @DocsEditable()\n  final String name;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('SpeechSynthesisUtterance')\n// https://dvcs.w3.org/hg/speech-api/raw-file/tip/speechapi.html#tts-section\n@Experimental()\n@Native(\"SpeechSynthesisUtterance\")\nclass SpeechSynthesisUtterance extends EventTarget {\n  // To suppress missing implicit constructor warnings.\n  factory SpeechSynthesisUtterance._() { throw new UnsupportedError(\"Not supported\"); }\n\n  /**\n   * Static factory designed to expose `boundary` events to event\n   * handlers that are not necessarily instances of [SpeechSynthesisUtterance].\n   *\n   * See [EventStreamProvider] for usage information.\n   */\n  @DomName('SpeechSynthesisUtterance.boundaryEvent')\n  @DocsEditable()\n  static const EventStreamProvider<SpeechSynthesisEvent> boundaryEvent = const EventStreamProvider<SpeechSynthesisEvent>('boundary');\n\n  /**\n   * Static factory designed to expose `end` events to event\n   * handlers that are not necessarily instances of [SpeechSynthesisUtterance].\n   *\n   * See [EventStreamProvider] for usage information.\n   */\n  @DomName('SpeechSynthesisUtterance.endEvent')\n  @DocsEditable()\n  static const EventStreamProvider<SpeechSynthesisEvent> endEvent = const EventStreamProvider<SpeechSynthesisEvent>('end');\n\n  /**\n   * Static factory designed to expose `error` events to event\n   * handlers that are not necessarily instances of [SpeechSynthesisUtterance].\n   *\n   * See [EventStreamProvider] for usage information.\n   */\n  @DomName('SpeechSynthesisUtterance.errorEvent')\n  @DocsEditable()\n  static const EventStreamProvider<Event> errorEvent = const EventStreamProvider<Event>('error');\n\n  /**\n   * Static factory designed to expose `mark` events to event\n   * handlers that are not necessarily instances of [SpeechSynthesisUtterance].\n   *\n   * See [EventStreamProvider] for usage information.\n   */\n  @DomName('SpeechSynthesisUtterance.markEvent')\n  @DocsEditable()\n  static const EventStreamProvider<SpeechSynthesisEvent> markEvent = const EventStreamProvider<SpeechSynthesisEvent>('mark');\n\n  /**\n   * Static factory designed to expose `pause` events to event\n   * handlers that are not necessarily instances of [SpeechSynthesisUtterance].\n   *\n   * See [EventStreamProvider] for usage information.\n   */\n  @DomName('SpeechSynthesisUtterance.pauseEvent')\n  @DocsEditable()\n  static const EventStreamProvider<Event> pauseEvent = const EventStreamProvider<Event>('pause');\n\n  /**\n   * Static factory designed to expose `resume` events to event\n   * handlers that are not necessarily instances of [SpeechSynthesisUtterance].\n   *\n   * See [EventStreamProvider] for usage information.\n   */\n  @DomName('SpeechSynthesisUtterance.resumeEvent')\n  @DocsEditable()\n  static const EventStreamProvider<SpeechSynthesisEvent> resumeEvent = const EventStreamProvider<SpeechSynthesisEvent>('resume');\n\n  /**\n   * Static factory designed to expose `start` events to event\n   * handlers that are not necessarily instances of [SpeechSynthesisUtterance].\n   *\n   * See [EventStreamProvider] for usage information.\n   */\n  @DomName('SpeechSynthesisUtterance.startEvent')\n  @DocsEditable()\n  static const EventStreamProvider<SpeechSynthesisEvent> startEvent = const EventStreamProvider<SpeechSynthesisEvent>('start');\n\n  @DomName('SpeechSynthesisUtterance.SpeechSynthesisUtterance')\n  @DocsEditable()\n  factory SpeechSynthesisUtterance([String text]) {\n    if (text != null) {\n      return SpeechSynthesisUtterance._create_1(text);\n    }\n    return SpeechSynthesisUtterance._create_2();\n  }\n  static SpeechSynthesisUtterance _create_1(text) => JS('SpeechSynthesisUtterance', 'new SpeechSynthesisUtterance(#)', text);\n  static SpeechSynthesisUtterance _create_2() => JS('SpeechSynthesisUtterance', 'new SpeechSynthesisUtterance()');\n\n  @DomName('SpeechSynthesisUtterance.lang')\n  @DocsEditable()\n  String lang;\n\n  @DomName('SpeechSynthesisUtterance.pitch')\n  @DocsEditable()\n  num pitch;\n\n  @DomName('SpeechSynthesisUtterance.rate')\n  @DocsEditable()\n  num rate;\n\n  @DomName('SpeechSynthesisUtterance.text')\n  @DocsEditable()\n  String text;\n\n  @DomName('SpeechSynthesisUtterance.voice')\n  @DocsEditable()\n  SpeechSynthesisVoice voice;\n\n  @DomName('SpeechSynthesisUtterance.volume')\n  @DocsEditable()\n  num volume;\n\n  /// Stream of `boundary` events handled by this [SpeechSynthesisUtterance].\n  @DomName('SpeechSynthesisUtterance.onboundary')\n  @DocsEditable()\n  Stream<SpeechSynthesisEvent> get onBoundary => boundaryEvent.forTarget(this);\n\n  /// Stream of `end` events handled by this [SpeechSynthesisUtterance].\n  @DomName('SpeechSynthesisUtterance.onend')\n  @DocsEditable()\n  Stream<SpeechSynthesisEvent> get onEnd => endEvent.forTarget(this);\n\n  /// Stream of `error` events handled by this [SpeechSynthesisUtterance].\n  @DomName('SpeechSynthesisUtterance.onerror')\n  @DocsEditable()\n  Stream<Event> get onError => errorEvent.forTarget(this);\n\n  /// Stream of `mark` events handled by this [SpeechSynthesisUtterance].\n  @DomName('SpeechSynthesisUtterance.onmark')\n  @DocsEditable()\n  Stream<SpeechSynthesisEvent> get onMark => markEvent.forTarget(this);\n\n  /// Stream of `pause` events handled by this [SpeechSynthesisUtterance].\n  @DomName('SpeechSynthesisUtterance.onpause')\n  @DocsEditable()\n  Stream<Event> get onPause => pauseEvent.forTarget(this);\n\n  /// Stream of `resume` events handled by this [SpeechSynthesisUtterance].\n  @DomName('SpeechSynthesisUtterance.onresume')\n  @DocsEditable()\n  Stream<SpeechSynthesisEvent> get onResume => resumeEvent.forTarget(this);\n\n  /// Stream of `start` events handled by this [SpeechSynthesisUtterance].\n  @DomName('SpeechSynthesisUtterance.onstart')\n  @DocsEditable()\n  Stream<SpeechSynthesisEvent> get onStart => startEvent.forTarget(this);\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('SpeechSynthesisVoice')\n// https://dvcs.w3.org/hg/speech-api/raw-file/tip/speechapi.html#tts-section\n@Experimental()\n@Native(\"SpeechSynthesisVoice\")\nclass SpeechSynthesisVoice extends Interceptor {\n  // To suppress missing implicit constructor warnings.\n  factory SpeechSynthesisVoice._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @JSName('default')\n  @DomName('SpeechSynthesisVoice.default')\n  @DocsEditable()\n  final bool defaultValue;\n\n  @DomName('SpeechSynthesisVoice.lang')\n  @DocsEditable()\n  final String lang;\n\n  @DomName('SpeechSynthesisVoice.localService')\n  @DocsEditable()\n  final bool localService;\n\n  @DomName('SpeechSynthesisVoice.name')\n  @DocsEditable()\n  final String name;\n\n  @JSName('voiceURI')\n  @DomName('SpeechSynthesisVoice.voiceURI')\n  @DocsEditable()\n  final String voiceUri;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n/**\n * The type used by the\n * [Window.localStorage] and [Window.sessionStorage] properties.\n * Storage is implemented as a Map&lt;String, String>.\n *\n * To store and get values, use Dart's built-in map syntax:\n *\n *     window.localStorage['key1'] = 'val1';\n *     window.localStorage['key2'] = 'val2';\n *     window.localStorage['key3'] = 'val3';\n *     assert(window.localStorage['key3'] == 'val3');\n *\n * You can use [Map](http://api.dartlang.org/dart_core/Map.html) APIs\n * such as containsValue(), clear(), and length:\n *\n *     assert(window.localStorage.containsValue('does not exist') == false);\n *     window.localStorage.clear();\n *     assert(window.localStorage.length == 0);\n *\n * For more examples of using this API, see\n * [localstorage_test.dart](http://code.google.com/p/dart/source/browse/branches/bleeding_edge/dart/tests/html/localstorage_test.dart).\n * For details on using the Map API, see the\n * [Maps](http://www.dartlang.org/docs/library-tour/#maps-aka-dictionaries-or-hashes)\n * section of the library tour.\n */\n@DomName('Storage')\n@Unstable()\n@Native(\"Storage\")\nclass Storage extends Interceptor\n    implements Map<String, String> {\n\n  void addAll(Map<String, String> other) {\n    other.forEach((k, v) { this[k] = v; });\n  }\n\n  // TODO(nweiz): update this when maps support lazy iteration\n  bool containsValue(String value) => values.any((e) => e == value);\n\n  bool containsKey(String key) => _getItem(key) != null;\n\n  String operator [](String key) => _getItem(key);\n\n  void operator []=(String key, String value) { _setItem(key, value); }\n\n  String putIfAbsent(String key, String ifAbsent()) {\n    if (!containsKey(key)) this[key] = ifAbsent();\n    return this[key];\n  }\n\n  String remove(String key) {\n    final value = this[key];\n    _removeItem(key);\n    return value;\n  }\n\n  void clear() => _clear();\n\n  void forEach(void f(String key, String value)) {\n    for (var i = 0; true; i++) {\n      final key = _key(i);\n      if (key == null) return;\n\n      f(key, this[key]);\n    }\n  }\n\n  Iterable<String> get keys {\n    final keys = [];\n    forEach((k, v) => keys.add(k));\n    return keys;\n  }\n\n  Iterable<String> get values {\n    final values = [];\n    forEach((k, v) => values.add(v));\n    return values;\n  }\n\n  int get length => _length;\n\n  bool get isEmpty => _key(0) == null;\n\n  bool get isNotEmpty => !isEmpty;\n  // To suppress missing implicit constructor warnings.\n  factory Storage._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @JSName('length')\n  @DomName('Storage.length')\n  @DocsEditable()\n  final int _length;\n\n  @DomName('Storage.__delete__')\n  @DocsEditable()\n  bool __delete__(index_OR_name) native;\n\n  @DomName('Storage.__getter__')\n  @DocsEditable()\n  String __getter__(index_OR_name) native;\n\n  @DomName('Storage.__setter__')\n  @DocsEditable()\n  void __setter__(index_OR_name, String value) native;\n\n  @JSName('clear')\n  @DomName('Storage.clear')\n  @DocsEditable()\n  void _clear() native;\n\n  @JSName('getItem')\n  @DomName('Storage.getItem')\n  @DocsEditable()\n  String _getItem(String key) native;\n\n  @JSName('key')\n  @DomName('Storage.key')\n  @DocsEditable()\n  String _key(int index) native;\n\n  @JSName('removeItem')\n  @DomName('Storage.removeItem')\n  @DocsEditable()\n  void _removeItem(String key) native;\n\n  @JSName('setItem')\n  @DomName('Storage.setItem')\n  @DocsEditable()\n  void _setItem(String key, String data) native;\n\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n// WARNING: Do not edit - generated code.\n\n\n@DomName('StorageErrorCallback')\n// http://www.w3.org/TR/quota-api/#storageerrorcallback-callback\n@Experimental()\ntypedef void StorageErrorCallback(DomError error);\n// Copyright (c) 2013, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n// WARNING: Do not edit - generated code.\n\n\n@DomName('StorageEvent')\n@Unstable()\n@Native(\"StorageEvent\")\nclass StorageEvent extends Event {\n  factory StorageEvent(String type,\n    {bool canBubble: false, bool cancelable: false, String key, String oldValue,\n    String newValue, String url, Storage storageArea}) {\n\n    var e = document._createEvent(\"StorageEvent\");\n    e._initStorageEvent(type, canBubble, cancelable, key, oldValue,\n        newValue, url, storageArea);\n    return e;\n  }\n  // To suppress missing implicit constructor warnings.\n  factory StorageEvent._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('StorageEvent.key')\n  @DocsEditable()\n  final String key;\n\n  @DomName('StorageEvent.newValue')\n  @DocsEditable()\n  final String newValue;\n\n  @DomName('StorageEvent.oldValue')\n  @DocsEditable()\n  final String oldValue;\n\n  @DomName('StorageEvent.storageArea')\n  @DocsEditable()\n  final Storage storageArea;\n\n  @DomName('StorageEvent.url')\n  @DocsEditable()\n  final String url;\n\n  @JSName('initStorageEvent')\n  @DomName('StorageEvent.initStorageEvent')\n  @DocsEditable()\n  void _initStorageEvent(String typeArg, bool canBubbleArg, bool cancelableArg, String keyArg, String oldValueArg, String newValueArg, String urlArg, Storage storageAreaArg) native;\n\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('StorageInfo')\n// http://www.w3.org/TR/file-system-api/\n@Experimental()\n@Native(\"StorageInfo\")\nclass StorageInfo extends Interceptor {\n  // To suppress missing implicit constructor warnings.\n  factory StorageInfo._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('StorageInfo.quota')\n  @DocsEditable()\n  @Experimental() // untriaged\n  final int quota;\n\n  @DomName('StorageInfo.usage')\n  @DocsEditable()\n  @Experimental() // untriaged\n  final int usage;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('StorageQuota')\n// http://www.w3.org/TR/quota-api/#idl-def-StorageQuota\n@Experimental()\n@Native(\"StorageQuota\")\nclass StorageQuota extends Interceptor {\n  // To suppress missing implicit constructor warnings.\n  factory StorageQuota._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('StorageQuota.supportedTypes')\n  @DocsEditable()\n  @Experimental() // untriaged\n  final List<String> supportedTypes;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n// WARNING: Do not edit - generated code.\n\n\n@DomName('StorageQuotaCallback')\n// http://www.w3.org/TR/quota-api/#idl-def-StorageQuotaCallback\n@Experimental()\ntypedef void StorageQuotaCallback(int grantedQuotaInBytes);\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n// WARNING: Do not edit - generated code.\n\n\n@DomName('StorageUsageCallback')\n// http://www.w3.org/TR/quota-api/#idl-def-StorageUsageCallback\n@Experimental()\ntypedef void StorageUsageCallback(int currentUsageInBytes, int currentQuotaInBytes);\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n// WARNING: Do not edit - generated code.\n\n\n@DomName('StringCallback')\n// http://www.w3.org/TR/2011/WD-html5-20110113/dnd.html#the-datatransferitem-interface\n@Experimental()\ntypedef void _StringCallback(String data);\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('HTMLStyleElement')\n@Native(\"HTMLStyleElement\")\nclass StyleElement extends HtmlElement {\n  // To suppress missing implicit constructor warnings.\n  factory StyleElement._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('HTMLStyleElement.HTMLStyleElement')\n  @DocsEditable()\n  factory StyleElement() => document.createElement(\"style\");\n  /**\n   * Constructor instantiated by the DOM when a custom element has been created.\n   *\n   * This can only be called by subclasses from their created constructor.\n   */\n  StyleElement.created() : super.created();\n\n  @DomName('HTMLStyleElement.disabled')\n  @DocsEditable()\n  bool disabled;\n\n  @DomName('HTMLStyleElement.media')\n  @DocsEditable()\n  String media;\n\n  @DomName('HTMLStyleElement.scoped')\n  @DocsEditable()\n  bool scoped;\n\n  @DomName('HTMLStyleElement.sheet')\n  @DocsEditable()\n  final StyleSheet sheet;\n\n  @DomName('HTMLStyleElement.type')\n  @DocsEditable()\n  String type;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('StyleMedia')\n// http://developer.apple.com/library/safari/#documentation/SafariDOMAdditions/Reference/StyleMedia/StyleMedia/StyleMedia.html\n@Experimental() // nonstandard\n@Native(\"StyleMedia\")\nclass StyleMedia extends Interceptor {\n  // To suppress missing implicit constructor warnings.\n  factory StyleMedia._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('StyleMedia.type')\n  @DocsEditable()\n  final String type;\n\n  @DomName('StyleMedia.matchMedium')\n  @DocsEditable()\n  bool matchMedium(String mediaquery) native;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('StyleSheet')\n@Native(\"StyleSheet\")\nclass StyleSheet extends Interceptor {\n  // To suppress missing implicit constructor warnings.\n  factory StyleSheet._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('StyleSheet.disabled')\n  @DocsEditable()\n  bool disabled;\n\n  @DomName('StyleSheet.href')\n  @DocsEditable()\n  final String href;\n\n  @DomName('StyleSheet.media')\n  @DocsEditable()\n  final MediaList media;\n\n  @DomName('StyleSheet.ownerNode')\n  @DocsEditable()\n  final Node ownerNode;\n\n  @DomName('StyleSheet.parentStyleSheet')\n  @DocsEditable()\n  final StyleSheet parentStyleSheet;\n\n  @DomName('StyleSheet.title')\n  @DocsEditable()\n  final String title;\n\n  @DomName('StyleSheet.type')\n  @DocsEditable()\n  final String type;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('HTMLTableCaptionElement')\n@Native(\"HTMLTableCaptionElement\")\nclass TableCaptionElement extends HtmlElement {\n  // To suppress missing implicit constructor warnings.\n  factory TableCaptionElement._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('HTMLTableCaptionElement.HTMLTableCaptionElement')\n  @DocsEditable()\n  factory TableCaptionElement() => document.createElement(\"caption\");\n  /**\n   * Constructor instantiated by the DOM when a custom element has been created.\n   *\n   * This can only be called by subclasses from their created constructor.\n   */\n  TableCaptionElement.created() : super.created();\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('HTMLTableCellElement')\n@Native(\"HTMLTableCellElement,HTMLTableDataCellElement,HTMLTableHeaderCellElement\")\nclass TableCellElement extends HtmlElement {\n  // To suppress missing implicit constructor warnings.\n  factory TableCellElement._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('HTMLTableCellElement.HTMLTableCellElement')\n  @DocsEditable()\n  factory TableCellElement() => document.createElement(\"td\");\n  /**\n   * Constructor instantiated by the DOM when a custom element has been created.\n   *\n   * This can only be called by subclasses from their created constructor.\n   */\n  TableCellElement.created() : super.created();\n\n  @DomName('HTMLTableCellElement.cellIndex')\n  @DocsEditable()\n  final int cellIndex;\n\n  @DomName('HTMLTableCellElement.colSpan')\n  @DocsEditable()\n  int colSpan;\n\n  @DomName('HTMLTableCellElement.headers')\n  @DocsEditable()\n  String headers;\n\n  @DomName('HTMLTableCellElement.rowSpan')\n  @DocsEditable()\n  int rowSpan;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('HTMLTableColElement')\n@Native(\"HTMLTableColElement\")\nclass TableColElement extends HtmlElement {\n  // To suppress missing implicit constructor warnings.\n  factory TableColElement._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('HTMLTableColElement.HTMLTableColElement')\n  @DocsEditable()\n  factory TableColElement() => document.createElement(\"col\");\n  /**\n   * Constructor instantiated by the DOM when a custom element has been created.\n   *\n   * This can only be called by subclasses from their created constructor.\n   */\n  TableColElement.created() : super.created();\n\n  @DomName('HTMLTableColElement.span')\n  @DocsEditable()\n  int span;\n}\n// Copyright (c) 2013, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('HTMLTableElement')\n@Native(\"HTMLTableElement\")\nclass TableElement extends HtmlElement {\n\n  @DomName('HTMLTableElement.tBodies')\n  List<TableSectionElement> get tBodies =>\n  new _WrappedList<TableSectionElement>(_tBodies);\n\n  @DomName('HTMLTableElement.rows')\n  List<TableRowElement> get rows =>\n      new _WrappedList<TableRowElement>(_rows);\n\n  TableRowElement addRow() {\n    return insertRow(-1);\n  }\n\n  TableCaptionElement createCaption() => _createCaption();\n  TableSectionElement createTBody() => _createTBody();\n  TableSectionElement createTFoot() => _createTFoot();\n  TableSectionElement createTHead() => _createTHead();\n  TableRowElement insertRow(int index) => _insertRow(index);\n\n  TableSectionElement _createTBody() {\n    if (JS('bool', '!!#.createTBody', this)) {\n      return this._nativeCreateTBody();\n    }\n    var tbody = new Element.tag('tbody');\n    this.children.add(tbody);\n    return tbody;\n  }\n\n  @JSName('createTBody')\n  TableSectionElement _nativeCreateTBody() native;\n\n  DocumentFragment createFragment(String html,\n      {NodeValidator validator, NodeTreeSanitizer treeSanitizer}) {\n    if (Range.supportsCreateContextualFragment) {\n      return super.createFragment(\n          html, validator: validator, treeSanitizer: treeSanitizer);\n    }\n    // IE9 workaround which does not support innerHTML on Table elements.\n    var contextualHtml = '<table>$html</table>';\n    var table = new Element.html(contextualHtml, validator: validator,\n        treeSanitizer: treeSanitizer);\n    var fragment = new DocumentFragment();\n    fragment.nodes.addAll(table.nodes);\n\n    return fragment;\n  }\n\n  // To suppress missing implicit constructor warnings.\n  factory TableElement._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('HTMLTableElement.HTMLTableElement')\n  @DocsEditable()\n  factory TableElement() => document.createElement(\"table\");\n  /**\n   * Constructor instantiated by the DOM when a custom element has been created.\n   *\n   * This can only be called by subclasses from their created constructor.\n   */\n  TableElement.created() : super.created();\n\n  @DomName('HTMLTableElement.caption')\n  @DocsEditable()\n  TableCaptionElement caption;\n\n  @JSName('rows')\n  @DomName('HTMLTableElement.rows')\n  @DocsEditable()\n  @Returns('HtmlCollection')\n  @Creates('HtmlCollection')\n  final List<Node> _rows;\n\n  @JSName('tBodies')\n  @DomName('HTMLTableElement.tBodies')\n  @DocsEditable()\n  @Returns('HtmlCollection')\n  @Creates('HtmlCollection')\n  final List<Node> _tBodies;\n\n  @DomName('HTMLTableElement.tFoot')\n  @DocsEditable()\n  TableSectionElement tFoot;\n\n  @DomName('HTMLTableElement.tHead')\n  @DocsEditable()\n  TableSectionElement tHead;\n\n  @JSName('createCaption')\n  @DomName('HTMLTableElement.createCaption')\n  @DocsEditable()\n  HtmlElement _createCaption() native;\n\n  @JSName('createTFoot')\n  @DomName('HTMLTableElement.createTFoot')\n  @DocsEditable()\n  HtmlElement _createTFoot() native;\n\n  @JSName('createTHead')\n  @DomName('HTMLTableElement.createTHead')\n  @DocsEditable()\n  HtmlElement _createTHead() native;\n\n  @DomName('HTMLTableElement.deleteCaption')\n  @DocsEditable()\n  void deleteCaption() native;\n\n  @DomName('HTMLTableElement.deleteRow')\n  @DocsEditable()\n  void deleteRow(int index) native;\n\n  @DomName('HTMLTableElement.deleteTFoot')\n  @DocsEditable()\n  void deleteTFoot() native;\n\n  @DomName('HTMLTableElement.deleteTHead')\n  @DocsEditable()\n  void deleteTHead() native;\n\n  @JSName('insertRow')\n  @DomName('HTMLTableElement.insertRow')\n  @DocsEditable()\n  HtmlElement _insertRow(int index) native;\n}\n// Copyright (c) 2013, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('HTMLTableRowElement')\n@Native(\"HTMLTableRowElement\")\nclass TableRowElement extends HtmlElement {\n\n  @DomName('HTMLTableRowElement.cells')\n  List<TableCellElement> get cells =>\n      new _WrappedList<TableCellElement>(_cells);\n\n  TableCellElement addCell() {\n    return insertCell(-1);\n  }\n\n  TableCellElement insertCell(int index) => _insertCell(index);\n\n  DocumentFragment createFragment(String html,\n      {NodeValidator validator, NodeTreeSanitizer treeSanitizer}) {\n    if (Range.supportsCreateContextualFragment) {\n      return super.createFragment(\n          html, validator: validator, treeSanitizer: treeSanitizer);\n    }\n    // IE9 workaround which does not support innerHTML on Table elements.\n    var fragment = new DocumentFragment();\n    var section = new TableElement().createFragment(\n        html, validator: validator, treeSanitizer: treeSanitizer).nodes.single;\n    var row = section.nodes.single;\n    fragment.nodes.addAll(row.nodes);\n    return fragment;\n  }\n\n  // To suppress missing implicit constructor warnings.\n  factory TableRowElement._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('HTMLTableRowElement.HTMLTableRowElement')\n  @DocsEditable()\n  factory TableRowElement() => document.createElement(\"tr\");\n  /**\n   * Constructor instantiated by the DOM when a custom element has been created.\n   *\n   * This can only be called by subclasses from their created constructor.\n   */\n  TableRowElement.created() : super.created();\n\n  @JSName('cells')\n  @DomName('HTMLTableRowElement.cells')\n  @DocsEditable()\n  @Returns('HtmlCollection')\n  @Creates('HtmlCollection')\n  final List<Node> _cells;\n\n  @DomName('HTMLTableRowElement.rowIndex')\n  @DocsEditable()\n  final int rowIndex;\n\n  @DomName('HTMLTableRowElement.sectionRowIndex')\n  @DocsEditable()\n  final int sectionRowIndex;\n\n  @DomName('HTMLTableRowElement.deleteCell')\n  @DocsEditable()\n  void deleteCell(int index) native;\n\n  @JSName('insertCell')\n  @DomName('HTMLTableRowElement.insertCell')\n  @DocsEditable()\n  HtmlElement _insertCell(int index) native;\n}\n// Copyright (c) 2013, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('HTMLTableSectionElement')\n@Native(\"HTMLTableSectionElement\")\nclass TableSectionElement extends HtmlElement {\n\n  @DomName('HTMLTableSectionElement.rows')\n  List<TableRowElement> get rows =>\n    new _WrappedList<TableRowElement>(_rows);\n\n  TableRowElement addRow() {\n    return insertRow(-1);\n  }\n\n  TableRowElement insertRow(int index) => _insertRow(index);\n\n  DocumentFragment createFragment(String html,\n      {NodeValidator validator, NodeTreeSanitizer treeSanitizer}) {\n    if (Range.supportsCreateContextualFragment) {\n      return super.createFragment(\n          html, validator: validator, treeSanitizer: treeSanitizer);\n    }\n    // IE9 workaround which does not support innerHTML on Table elements.\n    var fragment = new DocumentFragment();\n    var section = new TableElement().createFragment(\n        html, validator: validator, treeSanitizer: treeSanitizer).nodes.single;\n    fragment.nodes.addAll(section.nodes);\n    return fragment;\n  }\n\n  // To suppress missing implicit constructor warnings.\n  factory TableSectionElement._() { throw new UnsupportedError(\"Not supported\"); }\n  /**\n   * Constructor instantiated by the DOM when a custom element has been created.\n   *\n   * This can only be called by subclasses from their created constructor.\n   */\n  TableSectionElement.created() : super.created();\n\n  @JSName('rows')\n  @DomName('HTMLTableSectionElement.rows')\n  @DocsEditable()\n  @Returns('HtmlCollection')\n  @Creates('HtmlCollection')\n  final List<Node> _rows;\n\n  @DomName('HTMLTableSectionElement.deleteRow')\n  @DocsEditable()\n  void deleteRow(int index) native;\n\n  @JSName('insertRow')\n  @DomName('HTMLTableSectionElement.insertRow')\n  @DocsEditable()\n  HtmlElement _insertRow(int index) native;\n}\n// Copyright (c) 2013, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n// WARNING: Do not edit - generated code.\n\n\n@Experimental()\n@DomName('HTMLTemplateElement')\n@SupportedBrowser(SupportedBrowser.CHROME)\n@Experimental()\n// https://dvcs.w3.org/hg/webcomponents/raw-file/tip/spec/templates/index.html#template-element\n@Native(\"HTMLTemplateElement\")\nclass TemplateElement extends HtmlElement {\n  // To suppress missing implicit constructor warnings.\n  factory TemplateElement._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('HTMLTemplateElement.HTMLTemplateElement')\n  @DocsEditable()\n  factory TemplateElement() => document.createElement(\"template\");\n  /**\n   * Constructor instantiated by the DOM when a custom element has been created.\n   *\n   * This can only be called by subclasses from their created constructor.\n   */\n  TemplateElement.created() : super.created();\n\n  /// Checks if this type is supported on the current platform.\n  static bool get supported => Element.isTagSupported('template');\n\n  @DomName('HTMLTemplateElement.content')\n  @DocsEditable()\n  final DocumentFragment content;\n\n\n  /**\n   * An override to place the contents into content rather than as child nodes.\n   *\n   * See also:\n   *\n   * * <https://dvcs.w3.org/hg/webcomponents/raw-file/tip/spec/templates/index.html#innerhtml-on-templates>\n   */\n  void setInnerHtml(String html,\n    {NodeValidator validator, NodeTreeSanitizer treeSanitizer}) {\n    text = null;\n    var fragment = createFragment(\n        html, validator: validator, treeSanitizer: treeSanitizer);\n\n    content.append(fragment);\n  }\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n// WARNING: Do not edit - generated code.\n\n\n@DomName('Text')\n@Native(\"Text\")\nclass Text extends CharacterData {\n  factory Text(String data) => document._createTextNode(data);\n  // To suppress missing implicit constructor warnings.\n  factory Text._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('Text.wholeText')\n  @DocsEditable()\n  final String wholeText;\n\n  @DomName('Text.getDestinationInsertionPoints')\n  @DocsEditable()\n  @Experimental() // untriaged\n  @Returns('NodeList')\n  @Creates('NodeList')\n  List<Node> getDestinationInsertionPoints() native;\n\n  @DomName('Text.splitText')\n  @DocsEditable()\n  Text splitText(int offset) native;\n\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('HTMLTextAreaElement')\n@Native(\"HTMLTextAreaElement\")\nclass TextAreaElement extends HtmlElement {\n  // To suppress missing implicit constructor warnings.\n  factory TextAreaElement._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('HTMLTextAreaElement.HTMLTextAreaElement')\n  @DocsEditable()\n  factory TextAreaElement() => document.createElement(\"textarea\");\n  /**\n   * Constructor instantiated by the DOM when a custom element has been created.\n   *\n   * This can only be called by subclasses from their created constructor.\n   */\n  TextAreaElement.created() : super.created();\n\n  @DomName('HTMLTextAreaElement.autofocus')\n  @DocsEditable()\n  bool autofocus;\n\n  @DomName('HTMLTextAreaElement.cols')\n  @DocsEditable()\n  int cols;\n\n  @DomName('HTMLTextAreaElement.defaultValue')\n  @DocsEditable()\n  String defaultValue;\n\n  @DomName('HTMLTextAreaElement.dirName')\n  @DocsEditable()\n  // http://www.whatwg.org/specs/web-apps/current-work/multipage/the-button-element.html#dom-textarea-dirname\n  @Experimental()\n  String dirName;\n\n  @DomName('HTMLTextAreaElement.disabled')\n  @DocsEditable()\n  bool disabled;\n\n  @DomName('HTMLTextAreaElement.form')\n  @DocsEditable()\n  final FormElement form;\n\n  @DomName('HTMLTextAreaElement.inputMode')\n  @DocsEditable()\n  @Experimental() // untriaged\n  String inputMode;\n\n  @DomName('HTMLTextAreaElement.labels')\n  @DocsEditable()\n  @Unstable()\n  @Returns('NodeList')\n  @Creates('NodeList')\n  final List<Node> labels;\n\n  @DomName('HTMLTextAreaElement.maxLength')\n  @DocsEditable()\n  int maxLength;\n\n  @DomName('HTMLTextAreaElement.name')\n  @DocsEditable()\n  String name;\n\n  @DomName('HTMLTextAreaElement.placeholder')\n  @DocsEditable()\n  String placeholder;\n\n  @DomName('HTMLTextAreaElement.readOnly')\n  @DocsEditable()\n  bool readOnly;\n\n  @DomName('HTMLTextAreaElement.required')\n  @DocsEditable()\n  bool required;\n\n  @DomName('HTMLTextAreaElement.rows')\n  @DocsEditable()\n  int rows;\n\n  @DomName('HTMLTextAreaElement.selectionDirection')\n  @DocsEditable()\n  String selectionDirection;\n\n  @DomName('HTMLTextAreaElement.selectionEnd')\n  @DocsEditable()\n  int selectionEnd;\n\n  @DomName('HTMLTextAreaElement.selectionStart')\n  @DocsEditable()\n  int selectionStart;\n\n  @DomName('HTMLTextAreaElement.textLength')\n  @DocsEditable()\n  final int textLength;\n\n  @DomName('HTMLTextAreaElement.type')\n  @DocsEditable()\n  final String type;\n\n  @DomName('HTMLTextAreaElement.validationMessage')\n  @DocsEditable()\n  final String validationMessage;\n\n  @DomName('HTMLTextAreaElement.validity')\n  @DocsEditable()\n  final ValidityState validity;\n\n  @DomName('HTMLTextAreaElement.value')\n  @DocsEditable()\n  String value;\n\n  @DomName('HTMLTextAreaElement.willValidate')\n  @DocsEditable()\n  final bool willValidate;\n\n  @DomName('HTMLTextAreaElement.wrap')\n  @DocsEditable()\n  String wrap;\n\n  @DomName('HTMLTextAreaElement.checkValidity')\n  @DocsEditable()\n  bool checkValidity() native;\n\n  @DomName('HTMLTextAreaElement.select')\n  @DocsEditable()\n  void select() native;\n\n  @DomName('HTMLTextAreaElement.setCustomValidity')\n  @DocsEditable()\n  void setCustomValidity(String error) native;\n\n  @DomName('HTMLTextAreaElement.setRangeText')\n  @DocsEditable()\n  // http://www.whatwg.org/specs/web-apps/current-work/multipage/association-of-controls-and-forms.html#dom-textarea/input-setrangetext\n  @Experimental()\n  void setRangeText(String replacement, {int start, int end, String selectionMode}) native;\n\n  @DomName('HTMLTextAreaElement.setSelectionRange')\n  @DocsEditable()\n  void setSelectionRange(int start, int end, [String direction]) native;\n}\n// Copyright (c) 2013, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n// WARNING: Do not edit - generated code.\n\n\n@DomName('TextEvent')\n@Unstable()\n@Native(\"TextEvent\")\nclass TextEvent extends UIEvent {\n  factory TextEvent(String type,\n    {bool canBubble: false, bool cancelable: false, Window view, String data}) {\n    if (view == null) {\n      view = window;\n    }\n    var e = document._createEvent(\"TextEvent\");\n    e._initTextEvent(type, canBubble, cancelable, view, data);\n    return e;\n  }\n  // To suppress missing implicit constructor warnings.\n  factory TextEvent._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('TextEvent.data')\n  @DocsEditable()\n  final String data;\n\n  @JSName('initTextEvent')\n  @DomName('TextEvent.initTextEvent')\n  @DocsEditable()\n  void _initTextEvent(String typeArg, bool canBubbleArg, bool cancelableArg, Window viewArg, String dataArg) native;\n\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('TextMetrics')\n@Native(\"TextMetrics\")\nclass TextMetrics extends Interceptor {\n  // To suppress missing implicit constructor warnings.\n  factory TextMetrics._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('TextMetrics.width')\n  @DocsEditable()\n  final double width;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('TextTrack')\n// http://www.whatwg.org/specs/web-apps/current-work/multipage/the-video-element.html#texttrack\n@Experimental()\n@Native(\"TextTrack\")\nclass TextTrack extends EventTarget {\n  // To suppress missing implicit constructor warnings.\n  factory TextTrack._() { throw new UnsupportedError(\"Not supported\"); }\n\n  /**\n   * Static factory designed to expose `cuechange` events to event\n   * handlers that are not necessarily instances of [TextTrack].\n   *\n   * See [EventStreamProvider] for usage information.\n   */\n  @DomName('TextTrack.cuechangeEvent')\n  @DocsEditable()\n  static const EventStreamProvider<Event> cueChangeEvent = const EventStreamProvider<Event>('cuechange');\n\n  @DomName('TextTrack.activeCues')\n  @DocsEditable()\n  final TextTrackCueList activeCues;\n\n  @DomName('TextTrack.cues')\n  @DocsEditable()\n  final TextTrackCueList cues;\n\n  @DomName('TextTrack.id')\n  @DocsEditable()\n  @Experimental() // untriaged\n  final String id;\n\n  @DomName('TextTrack.kind')\n  @DocsEditable()\n  final String kind;\n\n  @DomName('TextTrack.label')\n  @DocsEditable()\n  final String label;\n\n  @DomName('TextTrack.language')\n  @DocsEditable()\n  final String language;\n\n  @DomName('TextTrack.mode')\n  @DocsEditable()\n  String mode;\n\n  @DomName('TextTrack.regions')\n  @DocsEditable()\n  @Experimental() // untriaged\n  final VttRegionList regions;\n\n  @DomName('TextTrack.addCue')\n  @DocsEditable()\n  void addCue(TextTrackCue cue) native;\n\n  @DomName('TextTrack.addRegion')\n  @DocsEditable()\n  @Experimental() // untriaged\n  void addRegion(VttRegion region) native;\n\n  @DomName('TextTrack.removeCue')\n  @DocsEditable()\n  void removeCue(TextTrackCue cue) native;\n\n  @DomName('TextTrack.removeRegion')\n  @DocsEditable()\n  @Experimental() // untriaged\n  void removeRegion(VttRegion region) native;\n\n  /// Stream of `cuechange` events handled by this [TextTrack].\n  @DomName('TextTrack.oncuechange')\n  @DocsEditable()\n  Stream<Event> get onCueChange => cueChangeEvent.forTarget(this);\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('TextTrackCue')\n// http://www.whatwg.org/specs/web-apps/current-work/multipage/the-video-element.html#texttrackcue\n@Experimental()\n@Native(\"TextTrackCue\")\nclass TextTrackCue extends EventTarget {\n  // To suppress missing implicit constructor warnings.\n  factory TextTrackCue._() { throw new UnsupportedError(\"Not supported\"); }\n\n  /**\n   * Static factory designed to expose `enter` events to event\n   * handlers that are not necessarily instances of [TextTrackCue].\n   *\n   * See [EventStreamProvider] for usage information.\n   */\n  @DomName('TextTrackCue.enterEvent')\n  @DocsEditable()\n  static const EventStreamProvider<Event> enterEvent = const EventStreamProvider<Event>('enter');\n\n  /**\n   * Static factory designed to expose `exit` events to event\n   * handlers that are not necessarily instances of [TextTrackCue].\n   *\n   * See [EventStreamProvider] for usage information.\n   */\n  @DomName('TextTrackCue.exitEvent')\n  @DocsEditable()\n  static const EventStreamProvider<Event> exitEvent = const EventStreamProvider<Event>('exit');\n\n  @DomName('TextTrackCue.endTime')\n  @DocsEditable()\n  num endTime;\n\n  @DomName('TextTrackCue.id')\n  @DocsEditable()\n  String id;\n\n  @DomName('TextTrackCue.pauseOnExit')\n  @DocsEditable()\n  bool pauseOnExit;\n\n  @DomName('TextTrackCue.startTime')\n  @DocsEditable()\n  num startTime;\n\n  @DomName('TextTrackCue.track')\n  @DocsEditable()\n  final TextTrack track;\n\n  /// Stream of `enter` events handled by this [TextTrackCue].\n  @DomName('TextTrackCue.onenter')\n  @DocsEditable()\n  Stream<Event> get onEnter => enterEvent.forTarget(this);\n\n  /// Stream of `exit` events handled by this [TextTrackCue].\n  @DomName('TextTrackCue.onexit')\n  @DocsEditable()\n  Stream<Event> get onExit => exitEvent.forTarget(this);\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('TextTrackCueList')\n// http://www.whatwg.org/specs/web-apps/current-work/multipage/the-video-element.html#texttrackcuelist\n@Experimental()\n@Native(\"TextTrackCueList\")\nclass TextTrackCueList extends Interceptor with ListMixin<TextTrackCue>, ImmutableListMixin<TextTrackCue> implements List<TextTrackCue>, JavaScriptIndexingBehavior {\n  // To suppress missing implicit constructor warnings.\n  factory TextTrackCueList._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('TextTrackCueList.length')\n  @DocsEditable()\n  int get length => JS(\"int\", \"#.length\", this);\n\n  TextTrackCue operator[](int index) {\n    if (JS(\"bool\", \"# >>> 0 !== # || # >= #\", index,\n        index, index, length))\n      throw new RangeError.range(index, 0, length);\n    return JS(\"TextTrackCue\", \"#[#]\", this, index);\n  }\n  void operator[]=(int index, TextTrackCue value) {\n    throw new UnsupportedError(\"Cannot assign element of immutable List.\");\n  }\n  // -- start List<TextTrackCue> mixins.\n  // TextTrackCue is the element type.\n\n\n  void set length(int value) {\n    throw new UnsupportedError(\"Cannot resize immutable List.\");\n  }\n\n  TextTrackCue get first {\n    if (this.length > 0) {\n      return JS('TextTrackCue', '#[0]', this);\n    }\n    throw new StateError(\"No elements\");\n  }\n\n  TextTrackCue get last {\n    int len = this.length;\n    if (len > 0) {\n      return JS('TextTrackCue', '#[#]', this, len - 1);\n    }\n    throw new StateError(\"No elements\");\n  }\n\n  TextTrackCue get single {\n    int len = this.length;\n    if (len == 1) {\n      return JS('TextTrackCue', '#[0]', this);\n    }\n    if (len == 0) throw new StateError(\"No elements\");\n    throw new StateError(\"More than one element\");\n  }\n\n  TextTrackCue elementAt(int index) => this[index];\n  // -- end List<TextTrackCue> mixins.\n\n  @DomName('TextTrackCueList.getCueById')\n  @DocsEditable()\n  TextTrackCue getCueById(String id) native;\n\n  @DomName('TextTrackCueList.item')\n  @DocsEditable()\n  TextTrackCue item(int index) native;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('TextTrackList')\n// http://www.whatwg.org/specs/web-apps/current-work/multipage/the-video-element.html#texttracklist\n@Experimental()\n@Native(\"TextTrackList\")\nclass TextTrackList extends EventTarget with ListMixin<TextTrack>, ImmutableListMixin<TextTrack> implements JavaScriptIndexingBehavior, List<TextTrack> {\n  // To suppress missing implicit constructor warnings.\n  factory TextTrackList._() { throw new UnsupportedError(\"Not supported\"); }\n\n  /**\n   * Static factory designed to expose `addtrack` events to event\n   * handlers that are not necessarily instances of [TextTrackList].\n   *\n   * See [EventStreamProvider] for usage information.\n   */\n  @DomName('TextTrackList.addtrackEvent')\n  @DocsEditable()\n  static const EventStreamProvider<TrackEvent> addTrackEvent = const EventStreamProvider<TrackEvent>('addtrack');\n\n  @DomName('TextTrackList.changeEvent')\n  @DocsEditable()\n  @Experimental() // untriaged\n  static const EventStreamProvider<Event> changeEvent = const EventStreamProvider<Event>('change');\n\n  @DomName('TextTrackList.length')\n  @DocsEditable()\n  int get length => JS(\"int\", \"#.length\", this);\n\n  TextTrack operator[](int index) {\n    if (JS(\"bool\", \"# >>> 0 !== # || # >= #\", index,\n        index, index, length))\n      throw new RangeError.range(index, 0, length);\n    return JS(\"TextTrack\", \"#[#]\", this, index);\n  }\n  void operator[]=(int index, TextTrack value) {\n    throw new UnsupportedError(\"Cannot assign element of immutable List.\");\n  }\n  // -- start List<TextTrack> mixins.\n  // TextTrack is the element type.\n\n\n  void set length(int value) {\n    throw new UnsupportedError(\"Cannot resize immutable List.\");\n  }\n\n  TextTrack get first {\n    if (this.length > 0) {\n      return JS('TextTrack', '#[0]', this);\n    }\n    throw new StateError(\"No elements\");\n  }\n\n  TextTrack get last {\n    int len = this.length;\n    if (len > 0) {\n      return JS('TextTrack', '#[#]', this, len - 1);\n    }\n    throw new StateError(\"No elements\");\n  }\n\n  TextTrack get single {\n    int len = this.length;\n    if (len == 1) {\n      return JS('TextTrack', '#[0]', this);\n    }\n    if (len == 0) throw new StateError(\"No elements\");\n    throw new StateError(\"More than one element\");\n  }\n\n  TextTrack elementAt(int index) => this[index];\n  // -- end List<TextTrack> mixins.\n\n  @DomName('TextTrackList.getTrackById')\n  @DocsEditable()\n  @Experimental() // untriaged\n  TextTrack getTrackById(String id) native;\n\n  @DomName('TextTrackList.item')\n  @DocsEditable()\n  TextTrack item(int index) native;\n\n  /// Stream of `addtrack` events handled by this [TextTrackList].\n  @DomName('TextTrackList.onaddtrack')\n  @DocsEditable()\n  Stream<TrackEvent> get onAddTrack => addTrackEvent.forTarget(this);\n\n  @DomName('TextTrackList.onchange')\n  @DocsEditable()\n  @Experimental() // untriaged\n  Stream<Event> get onChange => changeEvent.forTarget(this);\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('TimeRanges')\n@Unstable()\n@Native(\"TimeRanges\")\nclass TimeRanges extends Interceptor {\n  // To suppress missing implicit constructor warnings.\n  factory TimeRanges._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('TimeRanges.length')\n  @DocsEditable()\n  final int length;\n\n  @DomName('TimeRanges.end')\n  @DocsEditable()\n  double end(int index) native;\n\n  @DomName('TimeRanges.start')\n  @DocsEditable()\n  double start(int index) native;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('TimedItem')\n@Experimental() // untriaged\n@Native(\"TimedItem\")\nclass TimedItem extends Interceptor {\n  // To suppress missing implicit constructor warnings.\n  factory TimedItem._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('TimedItem.activeDuration')\n  @DocsEditable()\n  @Experimental() // untriaged\n  final double activeDuration;\n\n  @DomName('TimedItem.currentIteration')\n  @DocsEditable()\n  @Experimental() // untriaged\n  final int currentIteration;\n\n  @DomName('TimedItem.duration')\n  @DocsEditable()\n  @Experimental() // untriaged\n  final double duration;\n\n  @DomName('TimedItem.endTime')\n  @DocsEditable()\n  @Experimental() // untriaged\n  final double endTime;\n\n  @DomName('TimedItem.localTime')\n  @DocsEditable()\n  @Experimental() // untriaged\n  final double localTime;\n\n  @DomName('TimedItem.player')\n  @DocsEditable()\n  @Experimental() // untriaged\n  final Player player;\n\n  @DomName('TimedItem.startTime')\n  @DocsEditable()\n  @Experimental() // untriaged\n  final double startTime;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('Timeline')\n@Experimental() // untriaged\n@Native(\"Timeline\")\nclass Timeline extends Interceptor {\n  // To suppress missing implicit constructor warnings.\n  factory Timeline._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('Timeline.play')\n  @DocsEditable()\n  @Experimental() // untriaged\n  Player play(TimedItem source) native;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n// WARNING: Do not edit - generated code.\n\n\n@DomName('TimeoutHandler')\ntypedef void TimeoutHandler();\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('Timing')\n@Experimental() // untriaged\n@Native(\"Timing\")\nclass Timing extends Interceptor {\n  // To suppress missing implicit constructor warnings.\n  factory Timing._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('Timing.delay')\n  @DocsEditable()\n  @Experimental() // untriaged\n  num delay;\n\n  @DomName('Timing.direction')\n  @DocsEditable()\n  @Experimental() // untriaged\n  String direction;\n\n  @DomName('Timing.easing')\n  @DocsEditable()\n  @Experimental() // untriaged\n  String easing;\n\n  @DomName('Timing.endDelay')\n  @DocsEditable()\n  @Experimental() // untriaged\n  num endDelay;\n\n  @DomName('Timing.fill')\n  @DocsEditable()\n  @Experimental() // untriaged\n  String fill;\n\n  @DomName('Timing.iterationStart')\n  @DocsEditable()\n  @Experimental() // untriaged\n  num iterationStart;\n\n  @DomName('Timing.iterations')\n  @DocsEditable()\n  @Experimental() // untriaged\n  num iterations;\n\n  @DomName('Timing.playbackRate')\n  @DocsEditable()\n  @Experimental() // untriaged\n  num playbackRate;\n\n  @DomName('Timing.__setter__')\n  @DocsEditable()\n  @Experimental() // untriaged\n  void __setter__(String name, num duration) native;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('HTMLTitleElement')\n@Native(\"HTMLTitleElement\")\nclass TitleElement extends HtmlElement {\n  // To suppress missing implicit constructor warnings.\n  factory TitleElement._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('HTMLTitleElement.HTMLTitleElement')\n  @DocsEditable()\n  factory TitleElement() => document.createElement(\"title\");\n  /**\n   * Constructor instantiated by the DOM when a custom element has been created.\n   *\n   * This can only be called by subclasses from their created constructor.\n   */\n  TitleElement.created() : super.created();\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('Touch')\n// http://www.w3.org/TR/touch-events/, http://www.chromestatus.com/features\n@Experimental()\n@Native(\"Touch\")\nclass Touch extends Interceptor {\n  // To suppress missing implicit constructor warnings.\n  factory Touch._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @JSName('clientX')\n  @DomName('Touch.clientX')\n  @DocsEditable()\n  final int _clientX;\n\n  @JSName('clientY')\n  @DomName('Touch.clientY')\n  @DocsEditable()\n  final int _clientY;\n\n  @DomName('Touch.identifier')\n  @DocsEditable()\n  final int identifier;\n\n  @JSName('pageX')\n  @DomName('Touch.pageX')\n  @DocsEditable()\n  final int _pageX;\n\n  @JSName('pageY')\n  @DomName('Touch.pageY')\n  @DocsEditable()\n  final int _pageY;\n\n  @JSName('screenX')\n  @DomName('Touch.screenX')\n  @DocsEditable()\n  final int _screenX;\n\n  @JSName('screenY')\n  @DomName('Touch.screenY')\n  @DocsEditable()\n  final int _screenY;\n\n  @DomName('Touch.target')\n  @DocsEditable()\n  EventTarget get target => _convertNativeToDart_EventTarget(this._get_target);\n  @JSName('target')\n  @DomName('Touch.target')\n  @DocsEditable()\n  @Creates('Element|Document')\n  @Returns('Element|Document')\n  final dynamic _get_target;\n\n  @JSName('webkitForce')\n  @DomName('Touch.webkitForce')\n  @DocsEditable()\n  @SupportedBrowser(SupportedBrowser.CHROME)\n  @SupportedBrowser(SupportedBrowser.SAFARI)\n  @Experimental()\n  final double force;\n\n  @JSName('webkitRadiusX')\n  @DomName('Touch.webkitRadiusX')\n  @DocsEditable()\n  @SupportedBrowser(SupportedBrowser.CHROME)\n  @SupportedBrowser(SupportedBrowser.SAFARI)\n  @Experimental()\n  final int radiusX;\n\n  @JSName('webkitRadiusY')\n  @DomName('Touch.webkitRadiusY')\n  @DocsEditable()\n  @SupportedBrowser(SupportedBrowser.CHROME)\n  @SupportedBrowser(SupportedBrowser.SAFARI)\n  @Experimental()\n  final int radiusY;\n\n  @JSName('webkitRotationAngle')\n  @DomName('Touch.webkitRotationAngle')\n  @DocsEditable()\n  @SupportedBrowser(SupportedBrowser.CHROME)\n  @SupportedBrowser(SupportedBrowser.SAFARI)\n  @Experimental()\n  final double rotationAngle;\n\n\n  @DomName('Touch.clientX')\n  @DomName('Touch.clientY')\n  Point get client => new Point(_clientX, _clientY);\n\n  @DomName('Touch.pageX')\n  @DomName('Touch.pageY')\n  Point get page => new Point(_pageX, _pageY);\n\n  @DomName('Touch.screenX')\n  @DomName('Touch.screenY')\n  Point get screen => new Point(_screenX, _screenY);\n}\n// Copyright (c) 2013, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n// WARNING: Do not edit - generated code.\n\n\n@DomName('TouchEvent')\n// http://www.w3.org/TR/touch-events/, http://www.chromestatus.com/features\n@Experimental()\n@Native(\"TouchEvent\")\nclass TouchEvent extends UIEvent {\n  factory TouchEvent(TouchList touches, TouchList targetTouches,\n      TouchList changedTouches, String type,\n      {Window view, int screenX: 0, int screenY: 0, int clientX: 0,\n      int clientY: 0, bool ctrlKey: false, bool altKey: false,\n      bool shiftKey: false, bool metaKey: false}) {\n    if (view == null) {\n      view = window;\n    }\n    var e = document._createEvent(\"TouchEvent\");\n    e._initTouchEvent(touches, targetTouches, changedTouches, type, view,\n        screenX, screenY, clientX, clientY, ctrlKey, altKey, shiftKey, metaKey);\n    return e;\n  }\n  // To suppress missing implicit constructor warnings.\n  factory TouchEvent._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('TouchEvent.altKey')\n  @DocsEditable()\n  final bool altKey;\n\n  @DomName('TouchEvent.changedTouches')\n  @DocsEditable()\n  final TouchList changedTouches;\n\n  @DomName('TouchEvent.ctrlKey')\n  @DocsEditable()\n  final bool ctrlKey;\n\n  @DomName('TouchEvent.metaKey')\n  @DocsEditable()\n  final bool metaKey;\n\n  @DomName('TouchEvent.shiftKey')\n  @DocsEditable()\n  final bool shiftKey;\n\n  @DomName('TouchEvent.targetTouches')\n  @DocsEditable()\n  final TouchList targetTouches;\n\n  @DomName('TouchEvent.touches')\n  @DocsEditable()\n  final TouchList touches;\n\n  @JSName('initTouchEvent')\n  @DomName('TouchEvent.initTouchEvent')\n  @DocsEditable()\n  void _initTouchEvent(TouchList touches, TouchList targetTouches, TouchList changedTouches, String type, Window view, int screenX, int screenY, int clientX, int clientY, bool ctrlKey, bool altKey, bool shiftKey, bool metaKey) native;\n\n\n  /**\n   * Checks if touch events supported on the current platform.\n   *\n   * Note that touch events are only supported if the user is using a touch\n   * device.\n   */\n  static bool get supported => Device.isEventTypeSupported('TouchEvent');\n}\n// Copyright (c) 2013, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n// WARNING: Do not edit - generated code.\n\n\n@DomName('TouchList')\n// http://www.w3.org/TR/touch-events/, http://www.chromestatus.com/features\n@Experimental()\n@Native(\"TouchList\")\nclass TouchList extends Interceptor with ListMixin<Touch>, ImmutableListMixin<Touch> implements JavaScriptIndexingBehavior, List<Touch> {\n  /// NB: This constructor likely does not work as you might expect it to! This\n  /// constructor will simply fail (returning null) if you are not on a device\n  /// with touch enabled. See dartbug.com/8314.\n  // TODO(5760): createTouchList now uses varargs.\n  factory TouchList() => null;//document._createTouchList();\n  // To suppress missing implicit constructor warnings.\n  factory TouchList._() { throw new UnsupportedError(\"Not supported\"); }\n\n  /// Checks if this type is supported on the current platform.\n  static bool get supported => JS('bool', '!!document.createTouchList');\n\n  @DomName('TouchList.length')\n  @DocsEditable()\n  int get length => JS(\"int\", \"#.length\", this);\n\n  Touch operator[](int index) {\n    if (JS(\"bool\", \"# >>> 0 !== # || # >= #\", index,\n        index, index, length))\n      throw new RangeError.range(index, 0, length);\n    return JS(\"Touch\", \"#[#]\", this, index);\n  }\n  void operator[]=(int index, Touch value) {\n    throw new UnsupportedError(\"Cannot assign element of immutable List.\");\n  }\n  // -- start List<Touch> mixins.\n  // Touch is the element type.\n\n\n  void set length(int value) {\n    throw new UnsupportedError(\"Cannot resize immutable List.\");\n  }\n\n  Touch get first {\n    if (this.length > 0) {\n      return JS('Touch', '#[0]', this);\n    }\n    throw new StateError(\"No elements\");\n  }\n\n  Touch get last {\n    int len = this.length;\n    if (len > 0) {\n      return JS('Touch', '#[#]', this, len - 1);\n    }\n    throw new StateError(\"No elements\");\n  }\n\n  Touch get single {\n    int len = this.length;\n    if (len == 1) {\n      return JS('Touch', '#[0]', this);\n    }\n    if (len == 0) throw new StateError(\"No elements\");\n    throw new StateError(\"More than one element\");\n  }\n\n  Touch elementAt(int index) => this[index];\n  // -- end List<Touch> mixins.\n\n  @DomName('TouchList.item')\n  @DocsEditable()\n  Touch item(int index) native;\n\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('HTMLTrackElement')\n@SupportedBrowser(SupportedBrowser.CHROME)\n@SupportedBrowser(SupportedBrowser.IE, '10')\n@SupportedBrowser(SupportedBrowser.SAFARI)\n// http://www.whatwg.org/specs/web-apps/current-work/multipage/the-video-element.html#the-track-element\n@Experimental()\n@Native(\"HTMLTrackElement\")\nclass TrackElement extends HtmlElement {\n  // To suppress missing implicit constructor warnings.\n  factory TrackElement._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('HTMLTrackElement.HTMLTrackElement')\n  @DocsEditable()\n  factory TrackElement() => document.createElement(\"track\");\n  /**\n   * Constructor instantiated by the DOM when a custom element has been created.\n   *\n   * This can only be called by subclasses from their created constructor.\n   */\n  TrackElement.created() : super.created();\n\n  /// Checks if this type is supported on the current platform.\n  static bool get supported => Element.isTagSupported('track');\n\n  @DomName('HTMLTrackElement.ERROR')\n  @DocsEditable()\n  static const int ERROR = 3;\n\n  @DomName('HTMLTrackElement.LOADED')\n  @DocsEditable()\n  static const int LOADED = 2;\n\n  @DomName('HTMLTrackElement.LOADING')\n  @DocsEditable()\n  static const int LOADING = 1;\n\n  @DomName('HTMLTrackElement.NONE')\n  @DocsEditable()\n  static const int NONE = 0;\n\n  @JSName('default')\n  @DomName('HTMLTrackElement.default')\n  @DocsEditable()\n  bool defaultValue;\n\n  @DomName('HTMLTrackElement.kind')\n  @DocsEditable()\n  String kind;\n\n  @DomName('HTMLTrackElement.label')\n  @DocsEditable()\n  String label;\n\n  @DomName('HTMLTrackElement.readyState')\n  @DocsEditable()\n  final int readyState;\n\n  @DomName('HTMLTrackElement.src')\n  @DocsEditable()\n  String src;\n\n  @DomName('HTMLTrackElement.srclang')\n  @DocsEditable()\n  String srclang;\n\n  @DomName('HTMLTrackElement.track')\n  @DocsEditable()\n  final TextTrack track;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('TrackEvent')\n@Unstable()\n@Native(\"TrackEvent\")\nclass TrackEvent extends Event {\n  // To suppress missing implicit constructor warnings.\n  factory TrackEvent._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('TrackEvent.track')\n  @DocsEditable()\n  @Creates('Null')\n  final Object track;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('TransitionEvent')\n@Native(\"TransitionEvent,WebKitTransitionEvent\")\nclass TransitionEvent extends Event {\n  // To suppress missing implicit constructor warnings.\n  factory TransitionEvent._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('TransitionEvent.elapsedTime')\n  @DocsEditable()\n  final double elapsedTime;\n\n  @DomName('TransitionEvent.propertyName')\n  @DocsEditable()\n  final String propertyName;\n\n  @DomName('TransitionEvent.pseudoElement')\n  @DocsEditable()\n  final String pseudoElement;\n}\n// Copyright (c) 2013, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DomName('TreeWalker')\n@Unstable()\n@Native(\"TreeWalker\")\nclass TreeWalker extends Interceptor {\n  factory TreeWalker(Node root, int whatToShow) {\n    return document._createTreeWalker(root, whatToShow, null);\n  }\n  // To suppress missing implicit constructor warnings.\n  factory TreeWalker._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('TreeWalker.currentNode')\n  @DocsEditable()\n  Node currentNode;\n\n  @DomName('TreeWalker.filter')\n  @DocsEditable()\n  final NodeFilter filter;\n\n  @DomName('TreeWalker.root')\n  @DocsEditable()\n  final Node root;\n\n  @DomName('TreeWalker.whatToShow')\n  @DocsEditable()\n  final int whatToShow;\n\n  @DomName('TreeWalker.firstChild')\n  @DocsEditable()\n  Node firstChild() native;\n\n  @DomName('TreeWalker.lastChild')\n  @DocsEditable()\n  Node lastChild() native;\n\n  @DomName('TreeWalker.nextNode')\n  @DocsEditable()\n  Node nextNode() native;\n\n  @DomName('TreeWalker.nextSibling')\n  @DocsEditable()\n  Node nextSibling() native;\n\n  @DomName('TreeWalker.parentNode')\n  @DocsEditable()\n  Node parentNode() native;\n\n  @DomName('TreeWalker.previousNode')\n  @DocsEditable()\n  Node previousNode() native;\n\n  @DomName('TreeWalker.previousSibling')\n  @DocsEditable()\n  Node previousSibling() native;\n\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n// WARNING: Do not edit - generated code.\n\n\n@DomName('UIEvent')\n@Native(\"UIEvent\")\nclass UIEvent extends Event {\n  // In JS, canBubble and cancelable are technically required parameters to\n  // init*Event. In practice, though, if they aren't provided they simply\n  // default to false (since that's Boolean(undefined)).\n  //\n  // Contrary to JS, we default canBubble and cancelable to true, since that's\n  // what people want most of the time anyway.\n  factory UIEvent(String type,\n      {Window view, int detail: 0, bool canBubble: true,\n      bool cancelable: true}) {\n    if (view == null) {\n      view = window;\n    }\n    final e = document._createEvent(\"UIEvent\");\n    e._initUIEvent(type, canBubble, cancelable, view, detail);\n    return e;\n  }\n  // To suppress missing implicit constructor warnings.\n  factory UIEvent._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @JSName('charCode')\n  @DomName('UIEvent.charCode')\n  @DocsEditable()\n  @Unstable()\n  final int _charCode;\n\n  @DomName('UIEvent.detail')\n  @DocsEditable()\n  final int detail;\n\n  @JSName('keyCode')\n  @DomName('UIEvent.keyCode')\n  @DocsEditable()\n  @Unstable()\n  final int _keyCode;\n\n  @JSName('layerX')\n  @DomName('UIEvent.layerX')\n  @DocsEditable()\n  // http://dev.w3.org/2006/webapi/DOM-Level-3-Events/html/DOM3-Events.html#events-mouseevents\n  @Experimental() // nonstandard\n  final int _layerX;\n\n  @JSName('layerY')\n  @DomName('UIEvent.layerY')\n  @DocsEditable()\n  // http://dev.w3.org/2006/webapi/DOM-Level-3-Events/html/DOM3-Events.html#events-mouseevents\n  @Experimental() // nonstandard\n  final int _layerY;\n\n  @JSName('pageX')\n  @DomName('UIEvent.pageX')\n  @DocsEditable()\n  // http://dev.w3.org/2006/webapi/DOM-Level-3-Events/html/DOM3-Events.html#events-mouseevents\n  @Experimental() // nonstandard\n  final int _pageX;\n\n  @JSName('pageY')\n  @DomName('UIEvent.pageY')\n  @DocsEditable()\n  // http://dev.w3.org/2006/webapi/DOM-Level-3-Events/html/DOM3-Events.html#events-mouseevents\n  @Experimental() // nonstandard\n  final int _pageY;\n\n  @DomName('UIEvent.view')\n  @DocsEditable()\n  WindowBase get view => _convertNativeToDart_Window(this._get_view);\n  @JSName('view')\n  @DomName('UIEvent.view')\n  @DocsEditable()\n  @Creates('Window|=Object')\n  @Returns('Window|=Object')\n  final dynamic _get_view;\n\n  @DomName('UIEvent.which')\n  @DocsEditable()\n  @Unstable()\n  final int which;\n\n  @JSName('initUIEvent')\n  @DomName('UIEvent.initUIEvent')\n  @DocsEditable()\n  void _initUIEvent(String type, bool canBubble, bool cancelable, Window view, int detail) native;\n\n\n  @DomName('UIEvent.layerX')\n  @DomName('UIEvent.layerY')\n  Point get layer => new Point(_layerX, _layerY);\n\n  @DomName('UIEvent.pageX')\n  @DomName('UIEvent.pageY')\n  Point get page => new Point(_pageX, _pageY);\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('HTMLUListElement')\n@Native(\"HTMLUListElement\")\nclass UListElement extends HtmlElement {\n  // To suppress missing implicit constructor warnings.\n  factory UListElement._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('HTMLUListElement.HTMLUListElement')\n  @DocsEditable()\n  factory UListElement() => document.createElement(\"ul\");\n  /**\n   * Constructor instantiated by the DOM when a custom element has been created.\n   *\n   * This can only be called by subclasses from their created constructor.\n   */\n  UListElement.created() : super.created();\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('HTMLUnknownElement')\n@Native(\"HTMLUnknownElement\")\nclass UnknownElement extends HtmlElement {\n  // To suppress missing implicit constructor warnings.\n  factory UnknownElement._() { throw new UnsupportedError(\"Not supported\"); }\n  /**\n   * Constructor instantiated by the DOM when a custom element has been created.\n   *\n   * This can only be called by subclasses from their created constructor.\n   */\n  UnknownElement.created() : super.created();\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DomName('URL')\n@Native(\"URL\")\nclass Url extends Interceptor implements UrlUtils {\n\n  static String createObjectUrl(blob_OR_source_OR_stream) =>\n      JS('String',\n         '(self.URL || self.webkitURL).createObjectURL(#)',\n          blob_OR_source_OR_stream);\n\n  static String createObjectUrlFromSource(MediaSource source) =>\n      JS('String', '(self.URL || self.webkitURL).createObjectURL(#)', source);\n  \n  static String createObjectUrlFromStream(MediaStream stream) =>\n      JS('String', '(self.URL || self.webkitURL).createObjectURL(#)', stream);\n  \n  static String createObjectUrlFromBlob(Blob blob) =>\n      JS('String', '(self.URL || self.webkitURL).createObjectURL(#)', blob);\n\n  static void revokeObjectUrl(String url) =>\n      JS('void',\n         '(self.URL || self.webkitURL).revokeObjectURL(#)', url);\n  // To suppress missing implicit constructor warnings.\n  factory Url._() { throw new UnsupportedError(\"Not supported\"); }\n\n  // From URLUtils\n\n  @DomName('URL.hash')\n  @DocsEditable()\n  @Experimental() // untriaged\n  String hash;\n\n  @DomName('URL.host')\n  @DocsEditable()\n  @Experimental() // untriaged\n  String host;\n\n  @DomName('URL.hostname')\n  @DocsEditable()\n  @Experimental() // untriaged\n  String hostname;\n\n  @DomName('URL.href')\n  @DocsEditable()\n  @Experimental() // untriaged\n  String href;\n\n  @DomName('URL.origin')\n  @DocsEditable()\n  @Experimental() // untriaged\n  final String origin;\n\n  @DomName('URL.password')\n  @DocsEditable()\n  @Experimental() // untriaged\n  String password;\n\n  @DomName('URL.pathname')\n  @DocsEditable()\n  @Experimental() // untriaged\n  String pathname;\n\n  @DomName('URL.port')\n  @DocsEditable()\n  @Experimental() // untriaged\n  String port;\n\n  @DomName('URL.protocol')\n  @DocsEditable()\n  @Experimental() // untriaged\n  String protocol;\n\n  @DomName('URL.search')\n  @DocsEditable()\n  @Experimental() // untriaged\n  String search;\n\n  @DomName('URL.username')\n  @DocsEditable()\n  @Experimental() // untriaged\n  String username;\n\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('URLUtils')\n@Experimental() // untriaged\nabstract class UrlUtils extends Interceptor {\n  // To suppress missing implicit constructor warnings.\n  factory UrlUtils._() { throw new UnsupportedError(\"Not supported\"); }\n\n  String hash;\n\n  String host;\n\n  String hostname;\n\n  String href;\n\n  final String origin;\n\n  String password;\n\n  String pathname;\n\n  String port;\n\n  String protocol;\n\n  String search;\n\n  String username;\n\n  String toString();\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('URLUtilsReadOnly')\n@Experimental() // untriaged\nabstract class UrlUtilsReadOnly extends Interceptor {\n  // To suppress missing implicit constructor warnings.\n  factory UrlUtilsReadOnly._() { throw new UnsupportedError(\"Not supported\"); }\n\n  final String hash;\n\n  final String host;\n\n  final String hostname;\n\n  final String href;\n\n  final String pathname;\n\n  final String port;\n\n  final String protocol;\n\n  final String search;\n\n  String toString();\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('ValidityState')\n@Native(\"ValidityState\")\nclass ValidityState extends Interceptor {\n  // To suppress missing implicit constructor warnings.\n  factory ValidityState._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('ValidityState.badInput')\n  @DocsEditable()\n  final bool badInput;\n\n  @DomName('ValidityState.customError')\n  @DocsEditable()\n  final bool customError;\n\n  @DomName('ValidityState.patternMismatch')\n  @DocsEditable()\n  final bool patternMismatch;\n\n  @DomName('ValidityState.rangeOverflow')\n  @DocsEditable()\n  final bool rangeOverflow;\n\n  @DomName('ValidityState.rangeUnderflow')\n  @DocsEditable()\n  final bool rangeUnderflow;\n\n  @DomName('ValidityState.stepMismatch')\n  @DocsEditable()\n  final bool stepMismatch;\n\n  @DomName('ValidityState.tooLong')\n  @DocsEditable()\n  final bool tooLong;\n\n  @DomName('ValidityState.typeMismatch')\n  @DocsEditable()\n  final bool typeMismatch;\n\n  @DomName('ValidityState.valid')\n  @DocsEditable()\n  final bool valid;\n\n  @DomName('ValidityState.valueMissing')\n  @DocsEditable()\n  final bool valueMissing;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DomName('HTMLVideoElement')\n@Native(\"HTMLVideoElement\")\nclass VideoElement extends MediaElement implements CanvasImageSource {\n  // To suppress missing implicit constructor warnings.\n  factory VideoElement._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('HTMLVideoElement.HTMLVideoElement')\n  @DocsEditable()\n  factory VideoElement() => document.createElement(\"video\");\n  /**\n   * Constructor instantiated by the DOM when a custom element has been created.\n   *\n   * This can only be called by subclasses from their created constructor.\n   */\n  VideoElement.created() : super.created();\n\n  @DomName('HTMLVideoElement.height')\n  @DocsEditable()\n  int height;\n\n  @DomName('HTMLVideoElement.poster')\n  @DocsEditable()\n  String poster;\n\n  @DomName('HTMLVideoElement.videoHeight')\n  @DocsEditable()\n  final int videoHeight;\n\n  @DomName('HTMLVideoElement.videoWidth')\n  @DocsEditable()\n  final int videoWidth;\n\n  @JSName('webkitDecodedFrameCount')\n  @DomName('HTMLVideoElement.webkitDecodedFrameCount')\n  @DocsEditable()\n  @SupportedBrowser(SupportedBrowser.CHROME)\n  @SupportedBrowser(SupportedBrowser.SAFARI)\n  @Experimental()\n  final int decodedFrameCount;\n\n  @JSName('webkitDroppedFrameCount')\n  @DomName('HTMLVideoElement.webkitDroppedFrameCount')\n  @DocsEditable()\n  @SupportedBrowser(SupportedBrowser.CHROME)\n  @SupportedBrowser(SupportedBrowser.SAFARI)\n  @Experimental()\n  final int droppedFrameCount;\n\n  @DomName('HTMLVideoElement.width')\n  @DocsEditable()\n  int width;\n\n  @DomName('HTMLVideoElement.getVideoPlaybackQuality')\n  @DocsEditable()\n  @Experimental() // untriaged\n  VideoPlaybackQuality getVideoPlaybackQuality() native;\n\n  @JSName('webkitEnterFullscreen')\n  @DomName('HTMLVideoElement.webkitEnterFullscreen')\n  @DocsEditable()\n  @SupportedBrowser(SupportedBrowser.CHROME)\n  @SupportedBrowser(SupportedBrowser.SAFARI)\n  @Experimental()\n  // https://dvcs.w3.org/hg/fullscreen/raw-file/tip/Overview.html\n  void enterFullscreen() native;\n\n  @JSName('webkitExitFullscreen')\n  @DomName('HTMLVideoElement.webkitExitFullscreen')\n  @DocsEditable()\n  @SupportedBrowser(SupportedBrowser.CHROME)\n  @SupportedBrowser(SupportedBrowser.SAFARI)\n  @Experimental()\n  // https://dvcs.w3.org/hg/fullscreen/raw-file/tip/Overview.html#dom-document-exitfullscreen\n  void exitFullscreen() native;\n\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('VideoPlaybackQuality')\n@Experimental() // untriaged\n@Native(\"VideoPlaybackQuality\")\nclass VideoPlaybackQuality extends Interceptor {\n  // To suppress missing implicit constructor warnings.\n  factory VideoPlaybackQuality._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('VideoPlaybackQuality.corruptedVideoFrames')\n  @DocsEditable()\n  @Experimental() // untriaged\n  final int corruptedVideoFrames;\n\n  @DomName('VideoPlaybackQuality.creationTime')\n  @DocsEditable()\n  @Experimental() // untriaged\n  final double creationTime;\n\n  @DomName('VideoPlaybackQuality.droppedVideoFrames')\n  @DocsEditable()\n  @Experimental() // untriaged\n  final int droppedVideoFrames;\n\n  @DomName('VideoPlaybackQuality.totalVideoFrames')\n  @DocsEditable()\n  @Experimental() // untriaged\n  final int totalVideoFrames;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n// WARNING: Do not edit - generated code.\n\n\n@DomName('VoidCallback')\n// http://www.w3.org/TR/file-system-api/#the-voidcallback-interface\n@Experimental()\ntypedef void VoidCallback();\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('VTTCue')\n@Experimental() // untriaged\n@Native(\"VTTCue\")\nclass VttCue extends TextTrackCue {\n  // To suppress missing implicit constructor warnings.\n  factory VttCue._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('VTTCue.VTTCue')\n  @DocsEditable()\n  factory VttCue(num startTime, num endTime, String text) {\n    return VttCue._create_1(startTime, endTime, text);\n  }\n  static VttCue _create_1(startTime, endTime, text) => JS('VttCue', 'new VTTCue(#,#,#)', startTime, endTime, text);\n\n  @DomName('VTTCue.align')\n  @DocsEditable()\n  @Experimental() // untriaged\n  String align;\n\n  @DomName('VTTCue.line')\n  @DocsEditable()\n  @Experimental() // untriaged\n  int line;\n\n  @DomName('VTTCue.position')\n  @DocsEditable()\n  @Experimental() // untriaged\n  int position;\n\n  @DomName('VTTCue.regionId')\n  @DocsEditable()\n  @Experimental() // untriaged\n  String regionId;\n\n  @DomName('VTTCue.size')\n  @DocsEditable()\n  @Experimental() // untriaged\n  int size;\n\n  @DomName('VTTCue.snapToLines')\n  @DocsEditable()\n  @Experimental() // untriaged\n  bool snapToLines;\n\n  @DomName('VTTCue.text')\n  @DocsEditable()\n  @Experimental() // untriaged\n  String text;\n\n  @DomName('VTTCue.vertical')\n  @DocsEditable()\n  @Experimental() // untriaged\n  String vertical;\n\n  @JSName('getCueAsHTML')\n  @DomName('VTTCue.getCueAsHTML')\n  @DocsEditable()\n  @Experimental() // untriaged\n  DocumentFragment getCueAsHtml() native;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('VTTRegion')\n@Experimental() // untriaged\n@Native(\"VTTRegion\")\nclass VttRegion extends Interceptor {\n  // To suppress missing implicit constructor warnings.\n  factory VttRegion._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('VTTRegion.VTTRegion')\n  @DocsEditable()\n  factory VttRegion() {\n    return VttRegion._create_1();\n  }\n  static VttRegion _create_1() => JS('VttRegion', 'new VTTRegion()');\n\n  @DomName('VTTRegion.height')\n  @DocsEditable()\n  @Experimental() // untriaged\n  int height;\n\n  @DomName('VTTRegion.id')\n  @DocsEditable()\n  @Experimental() // untriaged\n  String id;\n\n  @DomName('VTTRegion.regionAnchorX')\n  @DocsEditable()\n  @Experimental() // untriaged\n  num regionAnchorX;\n\n  @DomName('VTTRegion.regionAnchorY')\n  @DocsEditable()\n  @Experimental() // untriaged\n  num regionAnchorY;\n\n  @DomName('VTTRegion.scroll')\n  @DocsEditable()\n  @Experimental() // untriaged\n  String scroll;\n\n  @DomName('VTTRegion.track')\n  @DocsEditable()\n  @Experimental() // untriaged\n  final TextTrack track;\n\n  @DomName('VTTRegion.viewportAnchorX')\n  @DocsEditable()\n  @Experimental() // untriaged\n  num viewportAnchorX;\n\n  @DomName('VTTRegion.viewportAnchorY')\n  @DocsEditable()\n  @Experimental() // untriaged\n  num viewportAnchorY;\n\n  @DomName('VTTRegion.width')\n  @DocsEditable()\n  @Experimental() // untriaged\n  num width;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('VTTRegionList')\n@Experimental() // untriaged\n@Native(\"VTTRegionList\")\nclass VttRegionList extends Interceptor {\n  // To suppress missing implicit constructor warnings.\n  factory VttRegionList._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('VTTRegionList.length')\n  @DocsEditable()\n  @Experimental() // untriaged\n  final int length;\n\n  @DomName('VTTRegionList.getRegionById')\n  @DocsEditable()\n  @Experimental() // untriaged\n  VttRegion getRegionById(String id) native;\n\n  @DomName('VTTRegionList.item')\n  @DocsEditable()\n  @Experimental() // untriaged\n  VttRegion item(int index) native;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n/**\n * Use the WebSocket interface to connect to a WebSocket,\n * and to send and receive data on that WebSocket.\n *\n * To use a WebSocket in your web app, first create a WebSocket object,\n * passing the WebSocket URL as an argument to the constructor.\n *\n *     var webSocket = new WebSocket('ws://127.0.0.1:1337/ws');\n *\n * To send data on the WebSocket, use the [send] method.\n *\n *     if (webSocket != null && webSocket.readyState == WebSocket.OPEN) {\n *       webSocket.send(data);\n *     } else {\n *       print('WebSocket not connected, message $data not sent');\n *     }\n *\n * To receive data on the WebSocket, register a listener for message events.\n *\n *     webSocket.onMessage.listen((MessageEvent e) {\n *       receivedData(e.data);\n *     });\n *\n * The message event handler receives a [MessageEvent] object\n * as its sole argument.\n * You can also define open, close, and error handlers,\n * as specified by [WebSocketEvents].\n *\n * For more information, see the\n * [WebSockets](http://www.dartlang.org/docs/library-tour/#html-websockets)\n * section of the library tour and\n * [Introducing WebSockets](http://www.html5rocks.com/en/tutorials/websockets/basics/),\n * an HTML5Rocks.com tutorial.\n */\n@DomName('WebSocket')\n@SupportedBrowser(SupportedBrowser.CHROME)\n@SupportedBrowser(SupportedBrowser.FIREFOX)\n@SupportedBrowser(SupportedBrowser.IE, '10')\n@SupportedBrowser(SupportedBrowser.SAFARI)\n@Unstable()\n@Native(\"WebSocket\")\nclass WebSocket extends EventTarget {\n  // To suppress missing implicit constructor warnings.\n  factory WebSocket._() { throw new UnsupportedError(\"Not supported\"); }\n\n  /**\n   * Static factory designed to expose `close` events to event\n   * handlers that are not necessarily instances of [WebSocket].\n   *\n   * See [EventStreamProvider] for usage information.\n   */\n  @DomName('WebSocket.closeEvent')\n  @DocsEditable()\n  static const EventStreamProvider<CloseEvent> closeEvent = const EventStreamProvider<CloseEvent>('close');\n\n  /**\n   * Static factory designed to expose `error` events to event\n   * handlers that are not necessarily instances of [WebSocket].\n   *\n   * See [EventStreamProvider] for usage information.\n   */\n  @DomName('WebSocket.errorEvent')\n  @DocsEditable()\n  static const EventStreamProvider<Event> errorEvent = const EventStreamProvider<Event>('error');\n\n  /**\n   * Static factory designed to expose `message` events to event\n   * handlers that are not necessarily instances of [WebSocket].\n   *\n   * See [EventStreamProvider] for usage information.\n   */\n  @DomName('WebSocket.messageEvent')\n  @DocsEditable()\n  static const EventStreamProvider<MessageEvent> messageEvent = const EventStreamProvider<MessageEvent>('message');\n\n  /**\n   * Static factory designed to expose `open` events to event\n   * handlers that are not necessarily instances of [WebSocket].\n   *\n   * See [EventStreamProvider] for usage information.\n   */\n  @DomName('WebSocket.openEvent')\n  @DocsEditable()\n  static const EventStreamProvider<Event> openEvent = const EventStreamProvider<Event>('open');\n\n  @DomName('WebSocket.WebSocket')\n  @DocsEditable()\n  factory WebSocket(String url, [protocol_OR_protocols]) {\n    if ((url is String || url == null) && protocol_OR_protocols == null) {\n      return WebSocket._create_1(url);\n    }\n    if ((protocol_OR_protocols is List<String> || protocol_OR_protocols == null) && (url is String || url == null)) {\n      return WebSocket._create_2(url, protocol_OR_protocols);\n    }\n    if ((protocol_OR_protocols is String || protocol_OR_protocols == null) && (url is String || url == null)) {\n      return WebSocket._create_3(url, protocol_OR_protocols);\n    }\n    throw new ArgumentError(\"Incorrect number or type of arguments\");\n  }\n  static WebSocket _create_1(url) => JS('WebSocket', 'new WebSocket(#)', url);\n  static WebSocket _create_2(url, protocol_OR_protocols) => JS('WebSocket', 'new WebSocket(#,#)', url, protocol_OR_protocols);\n  static WebSocket _create_3(url, protocol_OR_protocols) => JS('WebSocket', 'new WebSocket(#,#)', url, protocol_OR_protocols);\n\n  /// Checks if this type is supported on the current platform.\n  static bool get supported => JS('bool', 'typeof window.WebSocket != \"undefined\"');\n\n  @DomName('WebSocket.CLOSED')\n  @DocsEditable()\n  static const int CLOSED = 3;\n\n  @DomName('WebSocket.CLOSING')\n  @DocsEditable()\n  static const int CLOSING = 2;\n\n  @DomName('WebSocket.CONNECTING')\n  @DocsEditable()\n  static const int CONNECTING = 0;\n\n  @DomName('WebSocket.OPEN')\n  @DocsEditable()\n  static const int OPEN = 1;\n\n  @DomName('WebSocket.binaryType')\n  @DocsEditable()\n  String binaryType;\n\n  @DomName('WebSocket.bufferedAmount')\n  @DocsEditable()\n  final int bufferedAmount;\n\n  @DomName('WebSocket.extensions')\n  @DocsEditable()\n  final String extensions;\n\n  @DomName('WebSocket.protocol')\n  @DocsEditable()\n  final String protocol;\n\n  @DomName('WebSocket.readyState')\n  @DocsEditable()\n  final int readyState;\n\n  @DomName('WebSocket.url')\n  @DocsEditable()\n  final String url;\n\n  @DomName('WebSocket.close')\n  @DocsEditable()\n  void close([int code, String reason]) native;\n\n  /**\n   * Transmit data to the server over this connection.\n   *\n   * This method accepts data of type [Blob], [ByteBuffer], [String], or\n   * [TypedData]. Named variants [sendBlob], [sendByteBuffer], [sendString],\n   * or [sendTypedData], in constrast, only accept data of the specified type.\n   */\n  @DomName('WebSocket.send')\n  @DocsEditable()\n  void send(data) native;\n\n  @JSName('send')\n  /**\n   * Transmit data to the server over this connection.\n   *\n   * This method accepts data of type [Blob], [ByteBuffer], [String], or\n   * [TypedData]. Named variants [sendBlob], [sendByteBuffer], [sendString],\n   * or [sendTypedData], in constrast, only accept data of the specified type.\n   */\n  @DomName('WebSocket.send')\n  @DocsEditable()\n  void sendBlob(Blob data) native;\n\n  @JSName('send')\n  /**\n   * Transmit data to the server over this connection.\n   *\n   * This method accepts data of type [Blob], [ByteBuffer], [String], or\n   * [TypedData]. Named variants [sendBlob], [sendByteBuffer], [sendString],\n   * or [sendTypedData], in constrast, only accept data of the specified type.\n   */\n  @DomName('WebSocket.send')\n  @DocsEditable()\n  void sendByteBuffer(ByteBuffer data) native;\n\n  @JSName('send')\n  /**\n   * Transmit data to the server over this connection.\n   *\n   * This method accepts data of type [Blob], [ByteBuffer], [String], or\n   * [TypedData]. Named variants [sendBlob], [sendByteBuffer], [sendString],\n   * or [sendTypedData], in constrast, only accept data of the specified type.\n   */\n  @DomName('WebSocket.send')\n  @DocsEditable()\n  void sendString(String data) native;\n\n  @JSName('send')\n  /**\n   * Transmit data to the server over this connection.\n   *\n   * This method accepts data of type [Blob], [ByteBuffer], [String], or\n   * [TypedData]. Named variants [sendBlob], [sendByteBuffer], [sendString],\n   * or [sendTypedData], in constrast, only accept data of the specified type.\n   */\n  @DomName('WebSocket.send')\n  @DocsEditable()\n  void sendTypedData(TypedData data) native;\n\n  /// Stream of `close` events handled by this [WebSocket].\n  @DomName('WebSocket.onclose')\n  @DocsEditable()\n  Stream<CloseEvent> get onClose => closeEvent.forTarget(this);\n\n  /// Stream of `error` events handled by this [WebSocket].\n  @DomName('WebSocket.onerror')\n  @DocsEditable()\n  Stream<Event> get onError => errorEvent.forTarget(this);\n\n  /// Stream of `message` events handled by this [WebSocket].\n  @DomName('WebSocket.onmessage')\n  @DocsEditable()\n  Stream<MessageEvent> get onMessage => messageEvent.forTarget(this);\n\n  /// Stream of `open` events handled by this [WebSocket].\n  @DomName('WebSocket.onopen')\n  @DocsEditable()\n  Stream<Event> get onOpen => openEvent.forTarget(this);\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DomName('WheelEvent')\n@Native(\"WheelEvent,MouseWheelEvent,MouseScrollEvent\")\nclass WheelEvent extends MouseEvent {\n\n  factory WheelEvent(String type,\n      {Window view, int deltaX: 0, int deltaY: 0,\n      int detail: 0, int screenX: 0, int screenY: 0, int clientX: 0,\n      int clientY: 0, int button: 0, bool canBubble: true,\n      bool cancelable: true, bool ctrlKey: false, bool altKey: false,\n      bool shiftKey: false, bool metaKey: false, EventTarget relatedTarget}) {\n\n    if (view == null) {\n      view = window;\n    }\n    var eventType = 'WheelEvent';\n    if (Device.isFirefox) {\n      eventType = 'MouseScrollEvents';\n    }\n    final event = document._createEvent(eventType);\n    // If polyfilling, then flip these because we'll flip them back to match\n    // the W3C standard:\n    // http://dev.w3.org/2006/webapi/DOM-Level-3-Events/html/DOM3-Events.html#events-WheelEvent-deltaY\n    if (JS('bool', '#.deltaY === undefined', event)) {\n      deltaX = -deltaX;\n      deltaY = -deltaY;\n    }\n    if (event._hasInitWheelEvent) {\n      var modifiers = [];\n      if (ctrlKey) {\n        modifiers.push('Control');\n      }\n      if (altKey) {\n        modifiers.push('Alt');\n      }\n      if (shiftKey) {\n        modifiers.push('Shift');\n      }\n      if (metaKey) {\n        modifiers.push('Meta');\n      }\n      event._initWheelEvent(type, canBubble, cancelable, view, detail, screenX,\n          screenY, clientX, clientY, button, relatedTarget, modifiers.join(' '),\n          deltaX, deltaY, 0, 0);\n    } else if (event._hasInitMouseScrollEvent) {\n      var axis = 0;\n      var detail = 0;\n      if (deltaX != 0 && deltaY != 0) {\n        throw new UnsupportedError(\n            'Cannot modify deltaX and deltaY simultaneously');\n      }\n      if (deltaY != 0) {\n        detail = deltaY;\n        axis = JS('int', 'MouseScrollEvent.VERTICAL_AXIS');\n      } else if (deltaX != 0) {\n        detail = deltaX;\n        axis = JS('int', 'MouseScrollEvent.HORIZONTAL_AXIS');\n      }\n      event._initMouseScrollEvent(type, canBubble, cancelable, view, detail,\n          screenX, screenY, clientX, clientY, ctrlKey, altKey, shiftKey,\n          metaKey, button, relatedTarget, axis);\n    } else {\n      // Chrome does an auto-convert to pixels.\n      deltaY = deltaY ~/ 120;\n      // Fallthrough for Dartium.\n      event._initMouseEvent(type, canBubble, cancelable, view, detail,\n          screenX, screenY, clientX, clientY, ctrlKey, altKey, shiftKey,\n          metaKey, button, relatedTarget);\n      event._initWebKitWheelEvent(deltaX, deltaY,\n          view, screenX, screenY, clientX, clientY, ctrlKey, altKey, shiftKey,\n          metaKey);\n    }\n\n    return event;\n  }\n\n  // To suppress missing implicit constructor warnings.\n  factory WheelEvent._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('WheelEvent.DOM_DELTA_LINE')\n  @DocsEditable()\n  static const int DOM_DELTA_LINE = 0x01;\n\n  @DomName('WheelEvent.DOM_DELTA_PAGE')\n  @DocsEditable()\n  static const int DOM_DELTA_PAGE = 0x02;\n\n  @DomName('WheelEvent.DOM_DELTA_PIXEL')\n  @DocsEditable()\n  static const int DOM_DELTA_PIXEL = 0x00;\n\n  @JSName('deltaX')\n  @DomName('WheelEvent.deltaX')\n  @DocsEditable()\n  @Experimental() // untriaged\n  final double _deltaX;\n\n  @JSName('deltaY')\n  @DomName('WheelEvent.deltaY')\n  @DocsEditable()\n  @Experimental() // untriaged\n  final double _deltaY;\n\n  @DomName('WheelEvent.deltaZ')\n  @DocsEditable()\n  @Experimental() // untriaged\n  final double deltaZ;\n\n  @JSName('webkitDirectionInvertedFromDevice')\n  @DomName('WheelEvent.webkitDirectionInvertedFromDevice')\n  @DocsEditable()\n  @SupportedBrowser(SupportedBrowser.CHROME)\n  @SupportedBrowser(SupportedBrowser.SAFARI)\n  @Experimental()\n  final bool directionInvertedFromDevice;\n\n  @JSName('initWebKitWheelEvent')\n  @DomName('WheelEvent.initWebKitWheelEvent')\n  @DocsEditable()\n  @Experimental()\n  void _initWebKitWheelEvent(int wheelDeltaX, int wheelDeltaY, Window view, int screenX, int screenY, int clientX, int clientY, bool ctrlKey, bool altKey, bool shiftKey, bool metaKey) native;\n\n\n  /**\n   * The amount that is expected to scroll vertically, in units determined by\n   * [deltaMode].\n   *\n   * See also:\n   *\n   * * [WheelEvent.deltaY](http://dev.w3.org/2006/webapi/DOM-Level-3-Events/html/DOM3-Events.html#events-WheelEvent-deltaY) from the W3C.\n   */\n  @DomName('WheelEvent.deltaY')\n  num get deltaY {\n    if (JS('bool', '#.deltaY !== undefined', this)) {\n      // W3C WheelEvent\n      return this._deltaY;\n    } else if (JS('bool', '#.wheelDelta !== undefined', this)) {\n      // Chrome and IE\n      return -this._wheelDelta;\n    } else if (JS('bool', '#.detail !== undefined', this)) {\n      // Firefox\n\n      // Handle DOMMouseScroll case where it uses detail and the axis to\n      // differentiate.\n      if (JS('bool', '#.axis == MouseScrollEvent.VERTICAL_AXIS', this)) {\n        var detail = this._detail;\n        // Firefox is normally the number of lines to scale (normally 3)\n        // so multiply it by 40 to get pixels to move, matching IE & WebKit.\n        if (detail.abs() < 100) {\n          return -detail * 40;\n        }\n        return -detail;\n      }\n      return 0;\n    }\n    throw new UnsupportedError(\n        'deltaY is not supported');\n  }\n\n  /**\n   * The amount that is expected to scroll horizontally, in units determined by\n   * [deltaMode].\n   *\n   * See also:\n   *\n   * * [WheelEvent.deltaX](http://dev.w3.org/2006/webapi/DOM-Level-3-Events/html/DOM3-Events.html#events-WheelEvent-deltaX) from the W3C.\n   */\n  @DomName('WheelEvent.deltaX')\n  num get deltaX {\n    if (JS('bool', '#.deltaX !== undefined', this)) {\n      // W3C WheelEvent\n      return this._deltaX;\n    } else if (JS('bool', '#.wheelDeltaX !== undefined', this)) {\n      // Chrome\n      return -this._wheelDeltaX;\n    } else if (JS('bool', '#.detail !== undefined', this)) {\n      // Firefox and IE.\n      // IE will have detail set but will not set axis.\n\n      // Handle DOMMouseScroll case where it uses detail and the axis to\n      // differentiate.\n      if (JS('bool', '#.axis !== undefined && '\n        '#.axis == MouseScrollEvent.HORIZONTAL_AXIS', this, this)) {\n        var detail = this._detail;\n        // Firefox is normally the number of lines to scale (normally 3)\n        // so multiply it by 40 to get pixels to move, matching IE & WebKit.\n        if (detail < 100) {\n          return -detail * 40;\n        }\n        return -detail;\n      }\n      return 0;\n    }\n    throw new UnsupportedError(\n        'deltaX is not supported');\n  }\n\n  @DomName('WheelEvent.deltaMode')\n  int get deltaMode {\n    if (JS('bool', '!!(#.deltaMode)', this)) {\n      return JS('int', '#.deltaMode', this);\n    }\n    // If not available then we're poly-filling and doing pixel scroll.\n    return 0;\n  }\n\n  num get _wheelDelta => JS('num', '#.wheelDelta', this);\n  num get _wheelDeltaX => JS('num', '#.wheelDeltaX', this);\n  num get _detail => JS('num', '#.detail', this);\n\n  bool get _hasInitMouseScrollEvent =>\n      JS('bool', '!!(#.initMouseScrollEvent)', this);\n\n  @JSName('initMouseScrollEvent')\n  void _initMouseScrollEvent(\n      String type,\n      bool canBubble,\n      bool cancelable,\n      Window view,\n      int detail,\n      int screenX,\n      int screenY,\n      int clientX,\n      int clientY,\n      bool ctrlKey,\n      bool altKey,\n      bool shiftKey,\n      bool metaKey,\n      int button,\n      EventTarget relatedTarget,\n      int axis) native;\n\n  bool get _hasInitWheelEvent =>\n      JS('bool', '!!(#.initWheelEvent)', this);\n  @JSName('initWheelEvent')\n  void _initWheelEvent(\n      String eventType,\n      bool canBubble,\n      bool cancelable,\n      Window view,\n      int detail,\n      int screenX,\n      int screenY,\n      int clientX,\n      int clientY,\n      int button,\n      EventTarget relatedTarget,\n      String modifiersList,\n      int deltaX,\n      int deltaY,\n      int deltaZ,\n      int deltaMode) native;\n\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n/**\n * Top-level container for the current browser tab or window.\n *\n * In a web browser, each window has a [Window] object, but within the context\n * of a script, this object represents only the current window.\n * Each other window, tab, and iframe has its own [Window] object.\n *\n * Each window contains a [Document] object, which contains all of the window's\n * content.\n *\n * Use the top-level `window` object to access the current window.\n * For example:\n *\n *     // Draw a scene when the window repaints.\n *     drawScene(num delta) {...}\n *     window.animationFrame.then(drawScene);.\n *\n *     // Write to the console.\n *     window.console.log('Jinkies!');\n *     window.console.error('Jeepers!');\n *\n * **Note:** This class represents only the current window, while [WindowBase]\n * is a representation of any window, including other tabs, windows, and frames.\n *\n * ## See also\n *\n * * [WindowBase]\n *\n * ## Other resources\n *\n * * [DOM Window](https://developer.mozilla.org/en-US/docs/DOM/window) from MDN.\n * * [Window](http://www.w3.org/TR/Window/) from the W3C.\n */\n@DomName('Window')\n@Native(\"Window,DOMWindow\")\nclass Window extends EventTarget implements WindowEventHandlers, WindowBase, GlobalEventHandlers, _WindowTimers, WindowBase64 {\n\n  /**\n   * Returns a Future that completes just before the window is about to\n   * repaint so the user can draw an animation frame.\n   *\n   * If you need to later cancel this animation, use [requestAnimationFrame]\n   * instead.\n   *\n   * The [Future] completes to a timestamp that represents a floating\n   * point value of the number of milliseconds that have elapsed since the page\n   * started to load (which is also the timestamp at this call to\n   * animationFrame).\n   *\n   * Note: The code that runs when the future completes should call\n   * [animationFrame] again for the animation to continue.\n   */\n  Future<num> get animationFrame {\n    var completer = new Completer<num>.sync();\n    requestAnimationFrame((time) {\n      completer.complete(time);\n    });\n    return completer.future;\n  }\n\n  /**\n   * The newest document in this window.\n   *\n   * ## Other resources\n   *\n   * * [Loading web pages]\n   * (http://www.whatwg.org/specs/web-apps/current-work/multipage/browsers.html)\n   * from WHATWG.\n   */\n  Document get document => JS('Document', '#.document', this);\n\n  WindowBase _open2(url, name) => JS('Window', '#.open(#,#)', this, url, name);\n\n  WindowBase _open3(url, name, options) =>\n      JS('Window', '#.open(#,#,#)', this, url, name, options);\n\n  /**\n   * Opens a new window.\n   *\n   * ## Other resources\n   *\n   * * [Window.open]\n   * (https://developer.mozilla.org/en-US/docs/Web/API/Window.open) from MDN.\n   * * [Window open]\n   * (http://docs.webplatform.org/wiki/dom/methods/open) from WebPlatform.org.\n   */\n  WindowBase open(String url, String name, [String options]) {\n    if (options == null) {\n      return _DOMWindowCrossFrame._createSafe(_open2(url, name));\n    } else {\n      return _DOMWindowCrossFrame._createSafe(_open3(url, name, options));\n    }\n  }\n\n  // API level getter and setter for Location.\n  // TODO: The cross domain safe wrapper can be inserted here.\n  /**\n   * The current location of this window.\n   *\n   *     Location currentLocation = window.location;\n   *     print(currentLocation.href); // 'http://www.example.com:80/'\n   */\n  Location get location => _location;\n\n  // TODO: consider forcing users to do: window.location.assign('string').\n  /**\n   * Sets the window's location, which causes the browser to navigate to the new\n   * location. [value] may be a Location object or a String.\n   */\n  void set location(value) {\n    _location = value;\n  }\n\n  // Native getter and setter to access raw Location object.\n  dynamic get _location => JS('Location|Null', '#.location', this);\n  void set _location(value) {\n    JS('void', '#.location = #', this, value);\n  }\n\n  /**\n   * Called to draw an animation frame and then request the window to repaint\n   * after [callback] has finished (creating the animation).\n   *\n   * Use this method only if you need to later call [cancelAnimationFrame]. If\n   * not, the preferred Dart idiom is to set animation frames by calling\n   * [animationFrame], which returns a Future.\n   *\n   * Returns a non-zero valued integer to represent the request id for this\n   * request. This value only needs to be saved if you intend to call\n   * [cancelAnimationFrame] so you can specify the particular animation to\n   * cancel.\n   *\n   * Note: The supplied [callback] needs to call [requestAnimationFrame] again\n   * for the animation to continue.\n   */\n  @DomName('Window.requestAnimationFrame')\n  int requestAnimationFrame(RequestAnimationFrameCallback callback) {\n    _ensureRequestAnimationFrame();\n    return _requestAnimationFrame(_wrapZone(callback));\n  }\n\n  /**\n   * Cancels an animation frame request.\n   *\n   * ## Other resources\n   *\n   * * [Window.cancelAnimationFrame]\n   * (https://developer.mozilla.org/en-US/docs/Web/API/Window.cancelAnimationFrame) from MDN.\n   */\n  void cancelAnimationFrame(int id) {\n    _ensureRequestAnimationFrame();\n    _cancelAnimationFrame(id);\n  }\n\n  @JSName('requestAnimationFrame')\n  int _requestAnimationFrame(RequestAnimationFrameCallback callback) native;\n\n  @JSName('cancelAnimationFrame')\n  void _cancelAnimationFrame(int id) native;\n\n  _ensureRequestAnimationFrame() {\n    if (JS('bool',\n           '!!(#.requestAnimationFrame && #.cancelAnimationFrame)', this, this))\n      return;\n\n    JS('void',\n       r\"\"\"\n  (function($this) {\n   var vendors = ['ms', 'moz', 'webkit', 'o'];\n   for (var i = 0; i < vendors.length && !$this.requestAnimationFrame; ++i) {\n     $this.requestAnimationFrame = $this[vendors[i] + 'RequestAnimationFrame'];\n     $this.cancelAnimationFrame =\n         $this[vendors[i]+'CancelAnimationFrame'] ||\n         $this[vendors[i]+'CancelRequestAnimationFrame'];\n   }\n   if ($this.requestAnimationFrame && $this.cancelAnimationFrame) return;\n   $this.requestAnimationFrame = function(callback) {\n      return window.setTimeout(function() {\n        callback(Date.now());\n      }, 16 /* 16ms ~= 60fps */);\n   };\n   $this.cancelAnimationFrame = function(id) { clearTimeout(id); }\n  })(#)\"\"\",\n       this);\n  }\n\n  /**\n   * Gets an instance of the Indexed DB factory to being using Indexed DB.\n   *\n   * Use [indexed_db.IdbFactory.supported] to check if Indexed DB is supported on the\n   * current platform.\n   */\n  @SupportedBrowser(SupportedBrowser.CHROME, '23.0')\n  @SupportedBrowser(SupportedBrowser.FIREFOX, '15.0')\n  @SupportedBrowser(SupportedBrowser.IE, '10.0')\n  @Experimental()\n  IdbFactory get indexedDB =>\n      JS('IdbFactory|Null',  // If not supported, returns null.\n         '#.indexedDB || #.webkitIndexedDB || #.mozIndexedDB',\n         this, this, this);\n\n  /// The debugging console for this window.\n  @DomName('Window.console')\n  Console get console => Console._safeConsole;\n\n\n  /**\n   * Access a sandboxed file system of the specified `size`. If `persistent` is\n   * true, the application will request permission from the user to create\n   * lasting storage. This storage cannot be freed without the user's\n   * permission. Returns a [Future] whose value stores a reference to the\n   * sandboxed file system for use. Because the file system is sandboxed,\n   * applications cannot access file systems created in other web pages.\n   */\n  Future<FileSystem> requestFileSystem(int size, {bool persistent: false}) {\n    return _requestFileSystem(persistent? 1 : 0, size);\n  }\n\n  /**\n   * Converts a point from node coordinates to this window's coordinates.\n   *\n   * ## Other resources\n   *\n   * * [webkitConvertPointFromPageToNode]\n   * (https://developer.apple.com/library/safari/documentation/DataManagement/Reference/DOMWindowAdditionsReference/DOMWindowAdditions/DOMWindowAdditions.html#//apple_ref/javascript/instm/DOMWindow/webkitConvertPointFromNodeToPage)\n   * from Safari Development Library.\n   */\n  @DomName('Window.convertPointFromNodeToPage')\n  @SupportedBrowser(SupportedBrowser.CHROME)\n  @SupportedBrowser(SupportedBrowser.SAFARI)\n  @Experimental()\n  Point convertPointFromNodeToPage(Node node, Point point) {\n    var result = _convertPointFromNodeToPage(node,\n        new _DomPoint(point.x, point.y));\n    return new Point(result.x, result.y);\n  }\n\n  /**\n   * Converts a point from this window's coordinates to node coordinates.\n   *\n   * ## Other resources\n   *\n   * * [webkitConvertPointFromPageToNode]\n   * (https://developer.apple.com/library/safari/documentation/DataManagement/Reference/DOMWindowAdditionsReference/DOMWindowAdditions/DOMWindowAdditions.html#//apple_ref/javascript/instm/DOMWindow/webkitConvertPointFromPageToNode)\n   * from Safari Development Library.\n   */\n  @DomName('Window.convertPointFromPageToNode')\n  @SupportedBrowser(SupportedBrowser.CHROME)\n  @SupportedBrowser(SupportedBrowser.SAFARI)\n  @Experimental()\n  Point convertPointFromPageToNode(Node node, Point point) {\n    var result = _convertPointFromPageToNode(node,\n        new _DomPoint(point.x, point.y));\n    return new Point(result.x, result.y);\n  }\n\n  /**\n   * Checks whether [convertPointFromNodeToPage] and\n   * [convertPointFromPageToNode] are supported on the current platform.\n   */\n  static bool get supportsPointConversions => _DomPoint.supported;\n  // To suppress missing implicit constructor warnings.\n  factory Window._() { throw new UnsupportedError(\"Not supported\"); }\n\n  /**\n   * Static factory designed to expose `contentloaded` events to event\n   * handlers that are not necessarily instances of [Window].\n   *\n   * See [EventStreamProvider] for usage information.\n   */\n  @DomName('Window.DOMContentLoadedEvent')\n  @DocsEditable()\n  static const EventStreamProvider<Event> contentLoadedEvent = const EventStreamProvider<Event>('DOMContentLoaded');\n\n  /**\n   * Static factory designed to expose `devicemotion` events to event\n   * handlers that are not necessarily instances of [Window].\n   *\n   * See [EventStreamProvider] for usage information.\n   */\n  @DomName('Window.devicemotionEvent')\n  @DocsEditable()\n  // http://dev.w3.org/geo/api/spec-source-orientation.html#devicemotion\n  @Experimental()\n  static const EventStreamProvider<DeviceMotionEvent> deviceMotionEvent = const EventStreamProvider<DeviceMotionEvent>('devicemotion');\n\n  /**\n   * Static factory designed to expose `deviceorientation` events to event\n   * handlers that are not necessarily instances of [Window].\n   *\n   * See [EventStreamProvider] for usage information.\n   */\n  @DomName('Window.deviceorientationEvent')\n  @DocsEditable()\n  // http://dev.w3.org/geo/api/spec-source-orientation.html#devicemotion\n  @Experimental()\n  static const EventStreamProvider<DeviceOrientationEvent> deviceOrientationEvent = const EventStreamProvider<DeviceOrientationEvent>('deviceorientation');\n\n  /**\n   * Static factory designed to expose `hashchange` events to event\n   * handlers that are not necessarily instances of [Window].\n   *\n   * See [EventStreamProvider] for usage information.\n   */\n  @DomName('Window.hashchangeEvent')\n  @DocsEditable()\n  static const EventStreamProvider<Event> hashChangeEvent = const EventStreamProvider<Event>('hashchange');\n\n  /**\n   * Static factory designed to expose `message` events to event\n   * handlers that are not necessarily instances of [Window].\n   *\n   * See [EventStreamProvider] for usage information.\n   */\n  @DomName('Window.messageEvent')\n  @DocsEditable()\n  static const EventStreamProvider<MessageEvent> messageEvent = const EventStreamProvider<MessageEvent>('message');\n\n  /**\n   * Static factory designed to expose `offline` events to event\n   * handlers that are not necessarily instances of [Window].\n   *\n   * See [EventStreamProvider] for usage information.\n   */\n  @DomName('Window.offlineEvent')\n  @DocsEditable()\n  static const EventStreamProvider<Event> offlineEvent = const EventStreamProvider<Event>('offline');\n\n  /**\n   * Static factory designed to expose `online` events to event\n   * handlers that are not necessarily instances of [Window].\n   *\n   * See [EventStreamProvider] for usage information.\n   */\n  @DomName('Window.onlineEvent')\n  @DocsEditable()\n  static const EventStreamProvider<Event> onlineEvent = const EventStreamProvider<Event>('online');\n\n  /**\n   * Static factory designed to expose `pagehide` events to event\n   * handlers that are not necessarily instances of [Window].\n   *\n   * See [EventStreamProvider] for usage information.\n   */\n  @DomName('Window.pagehideEvent')\n  @DocsEditable()\n  static const EventStreamProvider<Event> pageHideEvent = const EventStreamProvider<Event>('pagehide');\n\n  /**\n   * Static factory designed to expose `pageshow` events to event\n   * handlers that are not necessarily instances of [Window].\n   *\n   * See [EventStreamProvider] for usage information.\n   */\n  @DomName('Window.pageshowEvent')\n  @DocsEditable()\n  static const EventStreamProvider<Event> pageShowEvent = const EventStreamProvider<Event>('pageshow');\n\n  /**\n   * Static factory designed to expose `popstate` events to event\n   * handlers that are not necessarily instances of [Window].\n   *\n   * See [EventStreamProvider] for usage information.\n   */\n  @DomName('Window.popstateEvent')\n  @DocsEditable()\n  static const EventStreamProvider<PopStateEvent> popStateEvent = const EventStreamProvider<PopStateEvent>('popstate');\n\n  /**\n   * Static factory designed to expose `storage` events to event\n   * handlers that are not necessarily instances of [Window].\n   *\n   * See [EventStreamProvider] for usage information.\n   */\n  @DomName('Window.storageEvent')\n  @DocsEditable()\n  static const EventStreamProvider<StorageEvent> storageEvent = const EventStreamProvider<StorageEvent>('storage');\n\n  /**\n   * Static factory designed to expose `unload` events to event\n   * handlers that are not necessarily instances of [Window].\n   *\n   * See [EventStreamProvider] for usage information.\n   */\n  @DomName('Window.unloadEvent')\n  @DocsEditable()\n  static const EventStreamProvider<Event> unloadEvent = const EventStreamProvider<Event>('unload');\n\n  /**\n   * Static factory designed to expose `animationend` events to event\n   * handlers that are not necessarily instances of [Window].\n   *\n   * See [EventStreamProvider] for usage information.\n   */\n  @DomName('Window.webkitAnimationEndEvent')\n  @DocsEditable()\n  @SupportedBrowser(SupportedBrowser.CHROME)\n  @SupportedBrowser(SupportedBrowser.SAFARI)\n  @Experimental()\n  static const EventStreamProvider<AnimationEvent> animationEndEvent = const EventStreamProvider<AnimationEvent>('webkitAnimationEnd');\n\n  /**\n   * Static factory designed to expose `animationiteration` events to event\n   * handlers that are not necessarily instances of [Window].\n   *\n   * See [EventStreamProvider] for usage information.\n   */\n  @DomName('Window.webkitAnimationIterationEvent')\n  @DocsEditable()\n  @SupportedBrowser(SupportedBrowser.CHROME)\n  @SupportedBrowser(SupportedBrowser.SAFARI)\n  @Experimental()\n  static const EventStreamProvider<AnimationEvent> animationIterationEvent = const EventStreamProvider<AnimationEvent>('webkitAnimationIteration');\n\n  /**\n   * Static factory designed to expose `animationstart` events to event\n   * handlers that are not necessarily instances of [Window].\n   *\n   * See [EventStreamProvider] for usage information.\n   */\n  @DomName('Window.webkitAnimationStartEvent')\n  @DocsEditable()\n  @SupportedBrowser(SupportedBrowser.CHROME)\n  @SupportedBrowser(SupportedBrowser.SAFARI)\n  @Experimental()\n  static const EventStreamProvider<AnimationEvent> animationStartEvent = const EventStreamProvider<AnimationEvent>('webkitAnimationStart');\n\n  /**\n   * Indicates that file system data cannot be cleared unless given user\n   * permission.\n   *\n   * ## Other resources\n   *\n   * * [Exploring the FileSystem APIs]\n   * (http://www.html5rocks.com/en/tutorials/file/filesystem/) from HTML5Rocks.\n   * * [File API]\n   * (http://www.w3.org/TR/file-system-api/#idl-def-LocalFileSystem) from W3C.\n   */\n  @DomName('Window.PERSISTENT')\n  @DocsEditable()\n  // http://www.w3.org/TR/file-system-api/#idl-def-LocalFileSystem\n  @Experimental()\n  static const int PERSISTENT = 1;\n\n  /**\n   * Indicates that file system data can be cleared at any time.\n   *\n   * ## Other resources\n   *\n   * * [Exploring the FileSystem APIs]\n   * (http://www.html5rocks.com/en/tutorials/file/filesystem/) from HTML5Rocks.\n   * * [File API]\n   * (http://www.w3.org/TR/file-system-api/#idl-def-LocalFileSystem) from W3C.\n   */\n  @DomName('Window.TEMPORARY')\n  @DocsEditable()\n  // http://www.w3.org/TR/file-system-api/#idl-def-LocalFileSystem\n  @Experimental()\n  static const int TEMPORARY = 0;\n\n  @JSName('CSS')\n  /**\n   * Entrypoint for CSS-related functions.\n   *\n   * ## Other resources\n   *\n   * * [The CSS interface](http://dev.w3.org/csswg/css-conditional/#the-css-interface) from W3C.\n   */\n  @DomName('Window.CSS')\n  @DocsEditable()\n  final Css css;\n\n  /**\n   * The application cache for this window.\n   *\n   * ## Other resources\n   *\n   * * [A beginner's guide to using the application cache]\n   * (http://www.html5rocks.com/en/tutorials/appcache/beginner) from HTML5Rocks.\n   * * [Application cache API]\n   * (http://www.whatwg.org/specs/web-apps/current-work/multipage/offline.html#application-cache-api)\n   * from WHATWG.\n   */\n  @DomName('Window.applicationCache')\n  @DocsEditable()\n  final ApplicationCache applicationCache;\n\n  @DomName('Window.closed')\n  @DocsEditable()\n  final bool closed;\n\n  /**\n   * Entrypoint for the browser's cryptographic functions.\n   *\n   * ## Other resources\n   *\n   * * [Web cryptography API](http://www.w3.org/TR/WebCryptoAPI/) from W3C.\n   */\n  @DomName('Window.crypto')\n  @DocsEditable()\n  // http://www.w3.org/TR/WebCryptoAPI/\n  @Experimental()\n  final Crypto crypto;\n\n  /// *Deprecated*.\n  @DomName('Window.defaultStatus')\n  @DocsEditable()\n  @Experimental() // non-standard\n  String defaultStatus;\n\n  /// *Deprecated*.\n  @DomName('Window.defaultstatus')\n  @DocsEditable()\n  @Experimental() // non-standard\n  String defaultstatus;\n\n  /**\n   * The ratio between physical pixels and logical CSS pixels.\n   *\n   * ## Other resources\n   *\n   * * [devicePixelRatio]\n   * (http://www.quirksmode.org/blog/archives/2012/06/devicepixelrati.html) from\n   * quirksmode.\n   * * [More about devicePixelRatio]\n   * (http://www.quirksmode.org/blog/archives/2012/07/more_about_devi.html) from\n   * quirksmode.\n   */\n  @DomName('Window.devicePixelRatio')\n  @DocsEditable()\n  // http://www.quirksmode.org/blog/archives/2012/06/devicepixelrati.html\n  @Experimental() // non-standard\n  final double devicePixelRatio;\n\n  /**\n   * The current session history for this window's newest document.\n   *\n   * ## Other resources\n   *\n   * * [Loading web pages]\n   * (http://www.whatwg.org/specs/web-apps/current-work/multipage/browsers.html)\n   * from WHATWG.\n   */\n  @DomName('Window.history')\n  @DocsEditable()\n  final History history;\n\n  /**\n   * The height of the viewport including scrollbars.\n   *\n   * ## Other resources\n   *\n   * * [innerHeight]\n   * (http://docs.webplatform.org/wiki/css/cssom/properties/innerHeight) from\n   * WebPlatform.org.\n   */\n  @DomName('Window.innerHeight')\n  @DocsEditable()\n  final int innerHeight;\n\n  /**\n   * The width of the viewport including scrollbars.\n   *\n   * ## Other resources\n   *\n   * * [innerWidth]\n   * (http://docs.webplatform.org/wiki/css/cssom/properties/innerWidth) from\n   * WebPlatform.org.\n   */\n  @DomName('Window.innerWidth')\n  @DocsEditable()\n  final int innerWidth;\n\n  /**\n   * Storage for this window that persists across sessions.\n   *\n   * ## Other resources\n   *\n   * * [DOM storage guide]\n   * (https://developer.mozilla.org/en-US/docs/Web/Guide/API/DOM/Storage) from\n   * MDN.\n   * * [The past, present & future of local storage for web applications]\n   * (http://diveintohtml5.info/storage.html) from Dive Into HTML5.\n   * * [Local storage specification]\n   * (http://www.w3.org/TR/webstorage/#the-localstorage-attribute) from W3C.\n   */\n  @DomName('Window.localStorage')\n  @DocsEditable()\n  final Storage localStorage;\n\n  /**\n   * This window's location bar, which displays the URL.\n   *\n   * ## Other resources\n   *\n   * * [Browser interface elements]\n   * (http://www.whatwg.org/specs/web-apps/current-work/multipage/browsers.html#browser-interface-elements)\n   * from WHATWG.\n   */\n  @DomName('Window.locationbar')\n  @DocsEditable()\n  final BarProp locationbar;\n\n  /**\n   * This window's menu bar, which displays menu commands.\n   *\n   * ## Other resources\n   *\n   * * [Browser interface elements]\n   * (http://www.whatwg.org/specs/web-apps/current-work/multipage/browsers.html#browser-interface-elements)\n   * from WHATWG.\n   */\n  @DomName('Window.menubar')\n  @DocsEditable()\n  final BarProp menubar;\n\n  /**\n   * The name of this window.\n   *\n   * ## Other resources\n   *\n   * * [Window name]\n   * (http://docs.webplatform.org/wiki/html/attributes/name_(window)) from\n   * WebPlatform.org.\n   */\n  @DomName('Window.name')\n  @DocsEditable()\n  String name;\n\n  /**\n   * The user agent accessing this window.\n   *\n   * ## Other resources\n   *\n   * * [The navigator object]\n   * (http://www.whatwg.org/specs/web-apps/current-work/multipage/timers.html#the-navigator-object)\n   * from WHATWG.\n   */\n  @DomName('Window.navigator')\n  @DocsEditable()\n  final Navigator navigator;\n\n  /**\n   * Whether objects are drawn offscreen before being displayed.\n   *\n   * ## Other resources\n   *\n   * * [offscreenBuffering]\n   * (http://docs.webplatform.org/wiki/dom/properties/offscreenBuffering) from\n   * WebPlatform.org.\n   */\n  @DomName('Window.offscreenBuffering')\n  @DocsEditable()\n  @Experimental() // non-standard\n  final bool offscreenBuffering;\n\n  @DomName('Window.opener')\n  @DocsEditable()\n  WindowBase get opener => _convertNativeToDart_Window(this._get_opener);\n  @JSName('opener')\n  @DomName('Window.opener')\n  @DocsEditable()\n  @Creates('Window|=Object')\n  @Returns('Window|=Object')\n  final dynamic _get_opener;\n\n  void set opener(Window value) {\n    JS(\"void\", \"#.opener = #\", this, value);\n  }\n\n  @DomName('Window.orientation')\n  @DocsEditable()\n  @Experimental() // untriaged\n  final int orientation;\n\n  /**\n   * The height of this window including all user interface elements.\n   *\n   * ## Other resources\n   *\n   * * [outerHeight]\n   * (http://docs.webplatform.org/wiki/css/cssom/properties/outerHeight) from\n   * WebPlatform.org.\n   */\n  @DomName('Window.outerHeight')\n  @DocsEditable()\n  final int outerHeight;\n\n  /**\n   * The width of the window including all user interface elements.\n   *\n   * ## Other resources\n   *\n   * * [outerWidth]\n   * (http://docs.webplatform.org/wiki/css/cssom/properties/outerWidth) from\n   * WebPlatform.org.\n   */\n  @DomName('Window.outerWidth')\n  @DocsEditable()\n  final int outerWidth;\n\n  /**\n   * The distance this window has been scrolled horizontally.\n   *\n   * This attribute is an alias for [scrollX].\n   *\n   * ## Other resources\n   *\n   * * [The Screen interface specification]\n   * (http://www.w3.org/TR/cssom-view/#screen) from W3C.\n   * * [scrollX and pageXOffset]\n   * (https://developer.mozilla.org/en-US/docs/Web/API/Window.scrollX) from MDN.\n   */\n  @DomName('Window.pageXOffset')\n  @DocsEditable()\n  final int pageXOffset;\n\n  /**\n   * The distance this window has been scrolled vertically.\n   *\n   * This attribute is an alias for [scrollY].\n   *\n   * ## Other resources\n   *\n   * * [The Screen interface specification]\n   * (http://www.w3.org/TR/cssom-view/#screen) from W3C.\n   * * [scrollY and pageYOffset]\n   * (https://developer.mozilla.org/en-US/docs/Web/API/Window.scrollY) from MDN.\n   */\n  @DomName('Window.pageYOffset')\n  @DocsEditable()\n  final int pageYOffset;\n\n  @DomName('Window.parent')\n  @DocsEditable()\n  WindowBase get parent => _convertNativeToDart_Window(this._get_parent);\n  @JSName('parent')\n  @DomName('Window.parent')\n  @DocsEditable()\n  @Creates('Window|=Object')\n  @Returns('Window|=Object')\n  final dynamic _get_parent;\n\n  /**\n   * Timing and navigation data for this window.\n   *\n   * ## Other resources\n   *\n   * * [Measuring page load speed with navigation timeing]\n   * (http://www.html5rocks.com/en/tutorials/webperformance/basics/) from\n   * HTML5Rocks.\n   * * [Navigation timing specification]\n   * (http://www.w3.org/TR/navigation-timing/) from W3C.\n   */\n  @DomName('Window.performance')\n  @DocsEditable()\n  @SupportedBrowser(SupportedBrowser.CHROME)\n  @SupportedBrowser(SupportedBrowser.FIREFOX)\n  @SupportedBrowser(SupportedBrowser.IE)\n  final Performance performance;\n\n  /**\n   * Information about the screen displaying this window.\n   *\n   * ## Other resources\n   *\n   * * [The Screen interface specification]\n   * (http://www.w3.org/TR/cssom-view/#screen) from W3C.\n   */\n  @DomName('Window.screen')\n  @DocsEditable()\n  final Screen screen;\n\n  /**\n   * The distance from the left side of the screen to the left side of this\n   * window.\n   *\n   * ## Other resources\n   *\n   * * [The Screen interface specification]\n   * (http://www.w3.org/TR/cssom-view/#screen) from W3C.\n   */\n  @DomName('Window.screenLeft')\n  @DocsEditable()\n  final int screenLeft;\n\n  /**\n   * The distance from the top of the screen to the top of this window.\n   *\n   * ## Other resources\n   *\n   * * [The Screen interface specification]\n   * (http://www.w3.org/TR/cssom-view/#screen) from W3C.\n   */\n  @DomName('Window.screenTop')\n  @DocsEditable()\n  final int screenTop;\n\n  /**\n   * The distance from the left side of the screen to the mouse pointer.\n   *\n   * ## Other resources\n   *\n   * * [The Screen interface specification]\n   * (http://www.w3.org/TR/cssom-view/#screen) from W3C.\n   */\n  @DomName('Window.screenX')\n  @DocsEditable()\n  final int screenX;\n\n  /**\n   * The distance from the top of the screen to the mouse pointer.\n   *\n   * ## Other resources\n   *\n   * * [The Screen interface specification]\n   * (http://www.w3.org/TR/cssom-view/#screen) from W3C.\n   */\n  @DomName('Window.screenY')\n  @DocsEditable()\n  final int screenY;\n\n  /**\n   * This window's scroll bars.\n   *\n   * ## Other resources\n   *\n   * * [Browser interface elements]\n   * (http://www.whatwg.org/specs/web-apps/current-work/multipage/browsers.html#browser-interface-elements)\n   * from WHATWG.\n   */\n  @DomName('Window.scrollbars')\n  @DocsEditable()\n  final BarProp scrollbars;\n\n  /**\n   * The current window.\n   *\n   * ## Other resources\n   *\n   * * [Window.self]\n   * (https://developer.mozilla.org/en-US/docs/Web/API/Window.self) from MDN.\n   */\n  @DomName('Window.self')\n  @DocsEditable()\n  WindowBase get self => _convertNativeToDart_Window(this._get_self);\n  @JSName('self')\n  /**\n   * The current window.\n   *\n   * ## Other resources\n   *\n   * * [Window.self]\n   * (https://developer.mozilla.org/en-US/docs/Web/API/Window.self) from MDN.\n   */\n  @DomName('Window.self')\n  @DocsEditable()\n  @Creates('Window|=Object')\n  @Returns('Window|=Object')\n  final dynamic _get_self;\n\n  /**\n   * Storage for this window that is cleared when this session ends.\n   *\n   * ## Other resources\n   *\n   * * [DOM storage guide]\n   * (https://developer.mozilla.org/en-US/docs/Web/Guide/API/DOM/Storage) from\n   * MDN.\n   * * [The past, present & future of local storage for web applications]\n   * (http://diveintohtml5.info/storage.html) from Dive Into HTML5.\n   * * [Local storage specification]\n   * (http://www.w3.org/TR/webstorage/#dom-sessionstorage) from W3C.\n   */\n  @DomName('Window.sessionStorage')\n  @DocsEditable()\n  final Storage sessionStorage;\n\n  /**\n   * Access to speech synthesis in the browser.\n   *\n   * ## Other resources\n   *\n   * * [Web speech specification]\n   * (https://dvcs.w3.org/hg/speech-api/raw-file/tip/speechapi.html#tts-section)\n   * from W3C.\n   */\n  @DomName('Window.speechSynthesis')\n  @DocsEditable()\n  // https://dvcs.w3.org/hg/speech-api/raw-file/tip/speechapi.html#tts-section\n  @Experimental()\n  final SpeechSynthesis speechSynthesis;\n\n  /// *Deprecated*.\n  @DomName('Window.status')\n  @DocsEditable()\n  String status;\n\n  /**\n   * This window's status bar.\n   *\n   * ## Other resources\n   *\n   * * [Browser interface elements]\n   * (http://www.whatwg.org/specs/web-apps/current-work/multipage/browsers.html#browser-interface-elements)\n   * from WHATWG.\n   */\n  @DomName('Window.statusbar')\n  @DocsEditable()\n  final BarProp statusbar;\n\n  /**\n   * Access to CSS media queries.\n   *\n   * ## Other resources\n   *\n   * * [StyleMedia class reference]\n   * (https://developer.apple.com/library/safari/documentation/SafariDOMAdditions/Reference/StyleMedia/StyleMedia/StyleMedia.html)\n   * from Safari Developer Library.\n   */\n  @DomName('Window.styleMedia')\n  @DocsEditable()\n  // http://developer.apple.com/library/safari/#documentation/SafariDOMAdditions/Reference/StyleMedia/StyleMedia/StyleMedia.html\n  @Experimental() // nonstandard\n  final StyleMedia styleMedia;\n\n  /**\n   * This window's tool bar.\n   *\n   * ## Other resources\n   *\n   * * [Browser interface elements]\n   * (http://www.whatwg.org/specs/web-apps/current-work/multipage/browsers.html#browser-interface-elements)\n   * from WHATWG.\n   */\n  @DomName('Window.toolbar')\n  @DocsEditable()\n  final BarProp toolbar;\n\n  @DomName('Window.top')\n  @DocsEditable()\n  WindowBase get top => _convertNativeToDart_Window(this._get_top);\n  @JSName('top')\n  @DomName('Window.top')\n  @DocsEditable()\n  @Creates('Window|=Object')\n  @Returns('Window|=Object')\n  final dynamic _get_top;\n\n  /**\n   * The current window.\n   *\n   * ## Other resources\n   *\n   * * [Window.window]\n   * (https://developer.mozilla.org/en-US/docs/Web/API/Window.window) from MDN.\n   */\n  @DomName('Window.window')\n  @DocsEditable()\n  WindowBase get window => _convertNativeToDart_Window(this._get_window);\n  @JSName('window')\n  /**\n   * The current window.\n   *\n   * ## Other resources\n   *\n   * * [Window.window]\n   * (https://developer.mozilla.org/en-US/docs/Web/API/Window.window) from MDN.\n   */\n  @DomName('Window.window')\n  @DocsEditable()\n  @Creates('Window|=Object')\n  @Returns('Window|=Object')\n  final dynamic _get_window;\n\n  @DomName('Window.__getter__')\n  @DocsEditable()\n  @Creates('Window|=Object')\n  @Returns('Window|=Object')\n  WindowBase __getter__(index_OR_name) {\n    if ((index_OR_name is int || index_OR_name == null)) {\n      return _convertNativeToDart_Window(__getter___1(index_OR_name));\n    }\n    if ((index_OR_name is String || index_OR_name == null)) {\n      return _convertNativeToDart_Window(__getter___2(index_OR_name));\n    }\n    throw new ArgumentError(\"Incorrect number or type of arguments\");\n  }\n  @JSName('__getter__')\n  @DomName('Window.__getter__')\n  @DocsEditable()\n  @Creates('Window|=Object')\n  @Returns('Window|=Object')\n  __getter___1(int index) native;\n  @JSName('__getter__')\n  @DomName('Window.__getter__')\n  @DocsEditable()\n  @Creates('Window|=Object')\n  @Returns('Window|=Object')\n  __getter___2(String name) native;\n\n  /**\n   * Displays a modal alert to the user.\n   *\n   * ## Other resources\n   *\n   * * [User prompts]\n   * (http://www.whatwg.org/specs/web-apps/current-work/multipage/timers.html#user-prompts)\n   * from WHATWG.\n   */\n  @DomName('Window.alert')\n  @DocsEditable()\n  void alert(String message) native;\n\n  @DomName('Window.close')\n  @DocsEditable()\n  void close() native;\n\n  /**\n   * Displays a modal OK/Cancel prompt to the user.\n   *\n   * ## Other resources\n   *\n   * * [User prompts]\n   * (http://www.whatwg.org/specs/web-apps/current-work/multipage/timers.html#user-prompts)\n   * from WHATWG.\n   */\n  @DomName('Window.confirm')\n  @DocsEditable()\n  bool confirm(String message) native;\n\n  /**\n   * Finds text in this window.\n   *\n   * ## Other resources\n   *\n   * * [Window.find]\n   * (https://developer.mozilla.org/en-US/docs/Web/API/Window.find) from MDN.\n   */\n  @DomName('Window.find')\n  @DocsEditable()\n  @Experimental() // non-standard\n  bool find(String string, bool caseSensitive, bool backwards, bool wrap, bool wholeWord, bool searchInFrames, bool showDialog) native;\n\n  @JSName('getComputedStyle')\n  @DomName('Window.getComputedStyle')\n  @DocsEditable()\n  CssStyleDeclaration _getComputedStyle(Element element, String pseudoElement) native;\n\n  @JSName('getMatchedCSSRules')\n  /**\n   * Returns all CSS rules that apply to the element's pseudo-element.\n   */\n  @DomName('Window.getMatchedCSSRules')\n  @DocsEditable()\n  @Experimental() // non-standard\n  @Returns('_CssRuleList')\n  @Creates('_CssRuleList')\n  List<CssRule> getMatchedCssRules(Element element, String pseudoElement) native;\n\n  /**\n   * Returns the currently selected text.\n   *\n   * ## Other resources\n   *\n   * * [Window.getSelection]\n   * (https://developer.mozilla.org/en-US/docs/Web/API/Window.getSelection)\n   * from MDN.\n   */\n  @DomName('Window.getSelection')\n  @DocsEditable()\n  Selection getSelection() native;\n\n  /**\n   * Returns a list of media queries for the given query string.\n   *\n   * ## Other resources\n   *\n   * * [Testing media queries]\n   * (https://developer.mozilla.org/en-US/docs/Web/Guide/CSS/Testing_media_queries)\n   * from MDN.\n   * * [The MediaQueryList specification]\n   * (http://www.w3.org/TR/cssom-view/#the-mediaquerylist-interface) from W3C.\n   */\n  @DomName('Window.matchMedia')\n  @DocsEditable()\n  MediaQueryList matchMedia(String query) native;\n\n  /**\n   * Moves this window.\n   *\n   * x and y can be negative.\n   *\n   * ## Other resources\n   *\n   * * [Window.moveBy]\n   * (https://developer.mozilla.org/en-US/docs/Web/API/Window.moveBy) from MDN.\n   * * [Window.moveBy]\n   * (http://dev.w3.org/csswg/cssom-view/#dom-window-moveby) from W3C.\n   */\n  @DomName('Window.moveBy')\n  @DocsEditable()\n  void moveBy(num x, num y) native;\n\n  @JSName('moveTo')\n  @DomName('Window.moveTo')\n  @DocsEditable()\n  void _moveTo(num x, num y) native;\n\n  /// *Deprecated.*\n  @DomName('Window.openDatabase')\n  @DocsEditable()\n  @SupportedBrowser(SupportedBrowser.CHROME)\n  @SupportedBrowser(SupportedBrowser.SAFARI)\n  @Experimental()\n  // http://www.w3.org/TR/webdatabase/\n  @Experimental() // deprecated\n  @Creates('SqlDatabase')\n  SqlDatabase openDatabase(String name, String version, String displayName, int estimatedSize, [DatabaseCallback creationCallback]) native;\n\n  @DomName('Window.postMessage')\n  @DocsEditable()\n  void postMessage(/*SerializedScriptValue*/ message, String targetOrigin, [List<MessagePort> messagePorts]) {\n    if (messagePorts != null) {\n      var message_1 = convertDartToNative_SerializedScriptValue(message);\n      _postMessage_1(message_1, targetOrigin, messagePorts);\n      return;\n    }\n    var message_2 = convertDartToNative_SerializedScriptValue(message);\n    _postMessage_2(message_2, targetOrigin);\n    return;\n  }\n  @JSName('postMessage')\n  @DomName('Window.postMessage')\n  @DocsEditable()\n  void _postMessage_1(message, targetOrigin, List<MessagePort> messagePorts) native;\n  @JSName('postMessage')\n  @DomName('Window.postMessage')\n  @DocsEditable()\n  void _postMessage_2(message, targetOrigin) native;\n\n  /**\n   * Opens the print dialog for this window.\n   *\n   * ## Other resources\n   *\n   * * [Window.print]\n   * (https://developer.mozilla.org/en-US/docs/Web/API/Window.print) from MDN.\n   */\n  @DomName('Window.print')\n  @DocsEditable()\n  void print() native;\n\n  /**\n   * Resizes this window by an offset.\n   *\n   * ## Other resources\n   *\n   * * [Window resizeBy] (http://docs.webplatform.org/wiki/dom/methods/resizeBy)\n   * from WebPlatform.org.\n   */\n  @DomName('Window.resizeBy')\n  @DocsEditable()\n  void resizeBy(num x, num y) native;\n\n  /**\n   * Resizes this window to a specific width and height.\n   *\n   * ## Other resources\n   *\n   * * [Window resizeTo] (http://docs.webplatform.org/wiki/dom/methods/resizeTo)\n   * from WebPlatform.org.\n   */\n  @DomName('Window.resizeTo')\n  @DocsEditable()\n  void resizeTo(num width, num height) native;\n\n  /**\n   * Scrolls the page horizontally and vertically to a specific point.\n   *\n   * This method is identical to [scrollTo].\n   *\n   * ## Other resources\n   *\n   * * [Window scroll] (http://docs.webplatform.org/wiki/dom/methods/scroll)\n   * from WebPlatform.org.\n   */\n  @DomName('Window.scroll')\n  @DocsEditable()\n  void scroll(int x, int y, [Map scrollOptions]) {\n    if (scrollOptions != null) {\n      var scrollOptions_1 = convertDartToNative_Dictionary(scrollOptions);\n      _scroll_1(x, y, scrollOptions_1);\n      return;\n    }\n    _scroll_2(x, y);\n    return;\n  }\n  @JSName('scroll')\n  /**\n   * Scrolls the page horizontally and vertically to a specific point.\n   *\n   * This method is identical to [scrollTo].\n   *\n   * ## Other resources\n   *\n   * * [Window scroll] (http://docs.webplatform.org/wiki/dom/methods/scroll)\n   * from WebPlatform.org.\n   */\n  @DomName('Window.scroll')\n  @DocsEditable()\n  void _scroll_1(x, y, scrollOptions) native;\n  @JSName('scroll')\n  /**\n   * Scrolls the page horizontally and vertically to a specific point.\n   *\n   * This method is identical to [scrollTo].\n   *\n   * ## Other resources\n   *\n   * * [Window scroll] (http://docs.webplatform.org/wiki/dom/methods/scroll)\n   * from WebPlatform.org.\n   */\n  @DomName('Window.scroll')\n  @DocsEditable()\n  void _scroll_2(x, y) native;\n\n  /**\n   * Scrolls the page horizontally and vertically by an offset.\n   *\n   * ## Other resources\n   *\n   * * [Window scrollBy] (http://docs.webplatform.org/wiki/dom/methods/scrollBy)\n   * from WebPlatform.org.\n   */\n  @DomName('Window.scrollBy')\n  @DocsEditable()\n  void scrollBy(int x, int y, [Map scrollOptions]) {\n    if (scrollOptions != null) {\n      var scrollOptions_1 = convertDartToNative_Dictionary(scrollOptions);\n      _scrollBy_1(x, y, scrollOptions_1);\n      return;\n    }\n    _scrollBy_2(x, y);\n    return;\n  }\n  @JSName('scrollBy')\n  /**\n   * Scrolls the page horizontally and vertically by an offset.\n   *\n   * ## Other resources\n   *\n   * * [Window scrollBy] (http://docs.webplatform.org/wiki/dom/methods/scrollBy)\n   * from WebPlatform.org.\n   */\n  @DomName('Window.scrollBy')\n  @DocsEditable()\n  void _scrollBy_1(x, y, scrollOptions) native;\n  @JSName('scrollBy')\n  /**\n   * Scrolls the page horizontally and vertically by an offset.\n   *\n   * ## Other resources\n   *\n   * * [Window scrollBy] (http://docs.webplatform.org/wiki/dom/methods/scrollBy)\n   * from WebPlatform.org.\n   */\n  @DomName('Window.scrollBy')\n  @DocsEditable()\n  void _scrollBy_2(x, y) native;\n\n  /**\n   * Scrolls the page horizontally and vertically to a specific point.\n   *\n   * This method is identical to [scroll].\n   *\n   * ## Other resources\n   *\n   * * [Window scrollTo] (http://docs.webplatform.org/wiki/dom/methods/scrollTo)\n   * from WebPlatform.org.\n   */\n  @DomName('Window.scrollTo')\n  @DocsEditable()\n  void scrollTo(int x, int y, [Map scrollOptions]) {\n    if (scrollOptions != null) {\n      var scrollOptions_1 = convertDartToNative_Dictionary(scrollOptions);\n      _scrollTo_1(x, y, scrollOptions_1);\n      return;\n    }\n    _scrollTo_2(x, y);\n    return;\n  }\n  @JSName('scrollTo')\n  /**\n   * Scrolls the page horizontally and vertically to a specific point.\n   *\n   * This method is identical to [scroll].\n   *\n   * ## Other resources\n   *\n   * * [Window scrollTo] (http://docs.webplatform.org/wiki/dom/methods/scrollTo)\n   * from WebPlatform.org.\n   */\n  @DomName('Window.scrollTo')\n  @DocsEditable()\n  void _scrollTo_1(x, y, scrollOptions) native;\n  @JSName('scrollTo')\n  /**\n   * Scrolls the page horizontally and vertically to a specific point.\n   *\n   * This method is identical to [scroll].\n   *\n   * ## Other resources\n   *\n   * * [Window scrollTo] (http://docs.webplatform.org/wiki/dom/methods/scrollTo)\n   * from WebPlatform.org.\n   */\n  @DomName('Window.scrollTo')\n  @DocsEditable()\n  void _scrollTo_2(x, y) native;\n\n  /**\n   * Opens a new page as a modal dialog.\n   *\n   * ## Other resources\n   *\n   * * [Dialogs implemented using separate documents]\n   * (http://www.w3.org/html/wg/drafts/html/master/webappapis.html#dialogs-implemented-using-separate-documents)\n   * from W3C.\n   */\n  @DomName('Window.showModalDialog')\n  @DocsEditable()\n  @Creates('Null')\n  Object showModalDialog(String url, [Object dialogArgs, String featureArgs]) native;\n\n  /**\n   * Stops the window from loading.\n   *\n   * ## Other resources\n   *\n   * * [The Window object]\n   * (http://www.w3.org/html/wg/drafts/html/master/browsers.html#the-window-object)\n   * from W3C.\n   */\n  @DomName('Window.stop')\n  @DocsEditable()\n  void stop() native;\n\n  @DomName('Window.toString')\n  @DocsEditable()\n  String toString() native;\n\n  @JSName('webkitConvertPointFromNodeToPage')\n  @DomName('Window.webkitConvertPointFromNodeToPage')\n  @DocsEditable()\n  @SupportedBrowser(SupportedBrowser.CHROME)\n  @SupportedBrowser(SupportedBrowser.SAFARI)\n  @Experimental()\n  // http://developer.apple.com/library/safari/#documentation/DataManagement/Reference/DOMWindowAdditionsReference/DOMWindowAdditions/DOMWindowAdditions.html\n  _DomPoint _convertPointFromNodeToPage(Node node, _DomPoint p) native;\n\n  @JSName('webkitConvertPointFromPageToNode')\n  @DomName('Window.webkitConvertPointFromPageToNode')\n  @DocsEditable()\n  @SupportedBrowser(SupportedBrowser.CHROME)\n  @SupportedBrowser(SupportedBrowser.SAFARI)\n  @Experimental()\n  // http://developer.apple.com/library/safari/#documentation/DataManagement/Reference/DOMWindowAdditionsReference/DOMWindowAdditions/DOMWindowAdditions.html\n  _DomPoint _convertPointFromPageToNode(Node node, _DomPoint p) native;\n\n  @JSName('webkitRequestFileSystem')\n  @DomName('Window.webkitRequestFileSystem')\n  @DocsEditable()\n  @SupportedBrowser(SupportedBrowser.CHROME)\n  @Experimental()\n  // http://www.w3.org/TR/file-system-api/#idl-def-LocalFileSystem\n  void __requestFileSystem(int type, int size, _FileSystemCallback successCallback, [_ErrorCallback errorCallback]) native;\n\n  @JSName('webkitRequestFileSystem')\n  @DomName('Window.webkitRequestFileSystem')\n  @DocsEditable()\n  @SupportedBrowser(SupportedBrowser.CHROME)\n  @Experimental()\n  // http://www.w3.org/TR/file-system-api/#idl-def-LocalFileSystem\n  Future<FileSystem> _requestFileSystem(int type, int size) {\n    var completer = new Completer<FileSystem>();\n    __requestFileSystem(type, size,\n        (value) { completer.complete(value); },\n        (error) { completer.completeError(error); });\n    return completer.future;\n  }\n\n  @JSName('webkitResolveLocalFileSystemURL')\n  /**\n   * Asynchronously retrieves a local filesystem entry.\n   *\n   * ## Other resources\n   *\n   * * [Obtaining access to file system entry points]\n   * (http://www.w3.org/TR/file-system-api/#obtaining-access-to-file-system-entry-points)\n   * from W3C.\n   */\n  @DomName('Window.webkitResolveLocalFileSystemURL')\n  @DocsEditable()\n  @SupportedBrowser(SupportedBrowser.CHROME)\n  @Experimental()\n  // http://www.w3.org/TR/file-system-api/#idl-def-LocalFileSystem\n  void _resolveLocalFileSystemUrl(String url, _EntryCallback successCallback, [_ErrorCallback errorCallback]) native;\n\n  @JSName('webkitResolveLocalFileSystemURL')\n  /**\n   * Asynchronously retrieves a local filesystem entry.\n   *\n   * ## Other resources\n   *\n   * * [Obtaining access to file system entry points]\n   * (http://www.w3.org/TR/file-system-api/#obtaining-access-to-file-system-entry-points)\n   * from W3C.\n   */\n  @DomName('Window.webkitResolveLocalFileSystemURL')\n  @DocsEditable()\n  @SupportedBrowser(SupportedBrowser.CHROME)\n  @Experimental()\n  // http://www.w3.org/TR/file-system-api/#idl-def-LocalFileSystem\n  Future<Entry> resolveLocalFileSystemUrl(String url) {\n    var completer = new Completer<Entry>();\n    _resolveLocalFileSystemUrl(url,\n        (value) { completer.complete(value); },\n        (error) { completer.completeError(error); });\n    return completer.future;\n  }\n\n  // From WindowBase64\n\n  @DomName('Window.atob')\n  @DocsEditable()\n  String atob(String string) native;\n\n  @DomName('Window.btoa')\n  @DocsEditable()\n  String btoa(String string) native;\n\n  // From WindowTimers\n\n  @JSName('clearInterval')\n  @DomName('Window.clearInterval')\n  @DocsEditable()\n  void _clearInterval(int handle) native;\n\n  @JSName('clearTimeout')\n  @DomName('Window.clearTimeout')\n  @DocsEditable()\n  void _clearTimeout(int handle) native;\n\n  @JSName('setInterval')\n  @DomName('Window.setInterval')\n  @DocsEditable()\n  int _setInterval(Object handler, int timeout) native;\n\n  @JSName('setTimeout')\n  @DomName('Window.setTimeout')\n  @DocsEditable()\n  int _setTimeout(Object handler, int timeout) native;\n\n  /// Stream of `contentloaded` events handled by this [Window].\n  @DomName('Window.onDOMContentLoaded')\n  @DocsEditable()\n  Stream<Event> get onContentLoaded => contentLoadedEvent.forTarget(this);\n\n  /// Stream of `abort` events handled by this [Window].\n  @DomName('Window.onabort')\n  @DocsEditable()\n  Stream<Event> get onAbort => Element.abortEvent.forTarget(this);\n\n  /// Stream of `blur` events handled by this [Window].\n  @DomName('Window.onblur')\n  @DocsEditable()\n  Stream<Event> get onBlur => Element.blurEvent.forTarget(this);\n\n  /// Stream of `change` events handled by this [Window].\n  @DomName('Window.onchange')\n  @DocsEditable()\n  Stream<Event> get onChange => Element.changeEvent.forTarget(this);\n\n  /// Stream of `click` events handled by this [Window].\n  @DomName('Window.onclick')\n  @DocsEditable()\n  Stream<MouseEvent> get onClick => Element.clickEvent.forTarget(this);\n\n  /// Stream of `contextmenu` events handled by this [Window].\n  @DomName('Window.oncontextmenu')\n  @DocsEditable()\n  Stream<MouseEvent> get onContextMenu => Element.contextMenuEvent.forTarget(this);\n\n  /// Stream of `doubleclick` events handled by this [Window].\n  @DomName('Window.ondblclick')\n  @DocsEditable()\n  Stream<Event> get onDoubleClick => Element.doubleClickEvent.forTarget(this);\n\n  /// Stream of `devicemotion` events handled by this [Window].\n  @DomName('Window.ondevicemotion')\n  @DocsEditable()\n  // http://dev.w3.org/geo/api/spec-source-orientation.html#devicemotion\n  @Experimental()\n  Stream<DeviceMotionEvent> get onDeviceMotion => deviceMotionEvent.forTarget(this);\n\n  /// Stream of `deviceorientation` events handled by this [Window].\n  @DomName('Window.ondeviceorientation')\n  @DocsEditable()\n  // http://dev.w3.org/geo/api/spec-source-orientation.html#devicemotion\n  @Experimental()\n  Stream<DeviceOrientationEvent> get onDeviceOrientation => deviceOrientationEvent.forTarget(this);\n\n  /// Stream of `drag` events handled by this [Window].\n  @DomName('Window.ondrag')\n  @DocsEditable()\n  Stream<MouseEvent> get onDrag => Element.dragEvent.forTarget(this);\n\n  /// Stream of `dragend` events handled by this [Window].\n  @DomName('Window.ondragend')\n  @DocsEditable()\n  Stream<MouseEvent> get onDragEnd => Element.dragEndEvent.forTarget(this);\n\n  /// Stream of `dragenter` events handled by this [Window].\n  @DomName('Window.ondragenter')\n  @DocsEditable()\n  Stream<MouseEvent> get onDragEnter => Element.dragEnterEvent.forTarget(this);\n\n  /// Stream of `dragleave` events handled by this [Window].\n  @DomName('Window.ondragleave')\n  @DocsEditable()\n  Stream<MouseEvent> get onDragLeave => Element.dragLeaveEvent.forTarget(this);\n\n  /// Stream of `dragover` events handled by this [Window].\n  @DomName('Window.ondragover')\n  @DocsEditable()\n  Stream<MouseEvent> get onDragOver => Element.dragOverEvent.forTarget(this);\n\n  /// Stream of `dragstart` events handled by this [Window].\n  @DomName('Window.ondragstart')\n  @DocsEditable()\n  Stream<MouseEvent> get onDragStart => Element.dragStartEvent.forTarget(this);\n\n  /// Stream of `drop` events handled by this [Window].\n  @DomName('Window.ondrop')\n  @DocsEditable()\n  Stream<MouseEvent> get onDrop => Element.dropEvent.forTarget(this);\n\n  /// Stream of `error` events handled by this [Window].\n  @DomName('Window.onerror')\n  @DocsEditable()\n  Stream<Event> get onError => Element.errorEvent.forTarget(this);\n\n  /// Stream of `focus` events handled by this [Window].\n  @DomName('Window.onfocus')\n  @DocsEditable()\n  Stream<Event> get onFocus => Element.focusEvent.forTarget(this);\n\n  /// Stream of `hashchange` events handled by this [Window].\n  @DomName('Window.onhashchange')\n  @DocsEditable()\n  Stream<Event> get onHashChange => hashChangeEvent.forTarget(this);\n\n  /// Stream of `input` events handled by this [Window].\n  @DomName('Window.oninput')\n  @DocsEditable()\n  Stream<Event> get onInput => Element.inputEvent.forTarget(this);\n\n  /// Stream of `invalid` events handled by this [Window].\n  @DomName('Window.oninvalid')\n  @DocsEditable()\n  Stream<Event> get onInvalid => Element.invalidEvent.forTarget(this);\n\n  /// Stream of `keydown` events handled by this [Window].\n  @DomName('Window.onkeydown')\n  @DocsEditable()\n  Stream<KeyboardEvent> get onKeyDown => Element.keyDownEvent.forTarget(this);\n\n  /// Stream of `keypress` events handled by this [Window].\n  @DomName('Window.onkeypress')\n  @DocsEditable()\n  Stream<KeyboardEvent> get onKeyPress => Element.keyPressEvent.forTarget(this);\n\n  /// Stream of `keyup` events handled by this [Window].\n  @DomName('Window.onkeyup')\n  @DocsEditable()\n  Stream<KeyboardEvent> get onKeyUp => Element.keyUpEvent.forTarget(this);\n\n  /// Stream of `load` events handled by this [Window].\n  @DomName('Window.onload')\n  @DocsEditable()\n  Stream<Event> get onLoad => Element.loadEvent.forTarget(this);\n\n  /// Stream of `message` events handled by this [Window].\n  @DomName('Window.onmessage')\n  @DocsEditable()\n  Stream<MessageEvent> get onMessage => messageEvent.forTarget(this);\n\n  /// Stream of `mousedown` events handled by this [Window].\n  @DomName('Window.onmousedown')\n  @DocsEditable()\n  Stream<MouseEvent> get onMouseDown => Element.mouseDownEvent.forTarget(this);\n\n  /// Stream of `mouseenter` events handled by this [Window].\n  @DomName('Window.onmouseenter')\n  @DocsEditable()\n  @Experimental() // untriaged\n  Stream<MouseEvent> get onMouseEnter => Element.mouseEnterEvent.forTarget(this);\n\n  /// Stream of `mouseleave` events handled by this [Window].\n  @DomName('Window.onmouseleave')\n  @DocsEditable()\n  @Experimental() // untriaged\n  Stream<MouseEvent> get onMouseLeave => Element.mouseLeaveEvent.forTarget(this);\n\n  /// Stream of `mousemove` events handled by this [Window].\n  @DomName('Window.onmousemove')\n  @DocsEditable()\n  Stream<MouseEvent> get onMouseMove => Element.mouseMoveEvent.forTarget(this);\n\n  /// Stream of `mouseout` events handled by this [Window].\n  @DomName('Window.onmouseout')\n  @DocsEditable()\n  Stream<MouseEvent> get onMouseOut => Element.mouseOutEvent.forTarget(this);\n\n  /// Stream of `mouseover` events handled by this [Window].\n  @DomName('Window.onmouseover')\n  @DocsEditable()\n  Stream<MouseEvent> get onMouseOver => Element.mouseOverEvent.forTarget(this);\n\n  /// Stream of `mouseup` events handled by this [Window].\n  @DomName('Window.onmouseup')\n  @DocsEditable()\n  Stream<MouseEvent> get onMouseUp => Element.mouseUpEvent.forTarget(this);\n\n  /// Stream of `mousewheel` events handled by this [Window].\n  @DomName('Window.onmousewheel')\n  @DocsEditable()\n  Stream<WheelEvent> get onMouseWheel => Element.mouseWheelEvent.forTarget(this);\n\n  /// Stream of `offline` events handled by this [Window].\n  @DomName('Window.onoffline')\n  @DocsEditable()\n  Stream<Event> get onOffline => offlineEvent.forTarget(this);\n\n  /// Stream of `online` events handled by this [Window].\n  @DomName('Window.ononline')\n  @DocsEditable()\n  Stream<Event> get onOnline => onlineEvent.forTarget(this);\n\n  /// Stream of `pagehide` events handled by this [Window].\n  @DomName('Window.onpagehide')\n  @DocsEditable()\n  Stream<Event> get onPageHide => pageHideEvent.forTarget(this);\n\n  /// Stream of `pageshow` events handled by this [Window].\n  @DomName('Window.onpageshow')\n  @DocsEditable()\n  Stream<Event> get onPageShow => pageShowEvent.forTarget(this);\n\n  /// Stream of `popstate` events handled by this [Window].\n  @DomName('Window.onpopstate')\n  @DocsEditable()\n  Stream<PopStateEvent> get onPopState => popStateEvent.forTarget(this);\n\n  /// Stream of `reset` events handled by this [Window].\n  @DomName('Window.onreset')\n  @DocsEditable()\n  Stream<Event> get onReset => Element.resetEvent.forTarget(this);\n\n  /// Stream of `resize` events handled by this [Window].\n  @DomName('Window.onresize')\n  @DocsEditable()\n  Stream<Event> get onResize => Element.resizeEvent.forTarget(this);\n\n  /// Stream of `scroll` events handled by this [Window].\n  @DomName('Window.onscroll')\n  @DocsEditable()\n  Stream<Event> get onScroll => Element.scrollEvent.forTarget(this);\n\n  /// Stream of `search` events handled by this [Window].\n  @DomName('Window.onsearch')\n  @DocsEditable()\n  // http://www.w3.org/TR/html-markup/input.search.html\n  @Experimental()\n  Stream<Event> get onSearch => Element.searchEvent.forTarget(this);\n\n  /// Stream of `select` events handled by this [Window].\n  @DomName('Window.onselect')\n  @DocsEditable()\n  Stream<Event> get onSelect => Element.selectEvent.forTarget(this);\n\n  /// Stream of `storage` events handled by this [Window].\n  @DomName('Window.onstorage')\n  @DocsEditable()\n  Stream<StorageEvent> get onStorage => storageEvent.forTarget(this);\n\n  /// Stream of `submit` events handled by this [Window].\n  @DomName('Window.onsubmit')\n  @DocsEditable()\n  Stream<Event> get onSubmit => Element.submitEvent.forTarget(this);\n\n  /// Stream of `touchcancel` events handled by this [Window].\n  @DomName('Window.ontouchcancel')\n  @DocsEditable()\n  // http://www.w3.org/TR/touch-events/, http://www.chromestatus.com/features\n  @Experimental()\n  Stream<TouchEvent> get onTouchCancel => Element.touchCancelEvent.forTarget(this);\n\n  /// Stream of `touchend` events handled by this [Window].\n  @DomName('Window.ontouchend')\n  @DocsEditable()\n  // http://www.w3.org/TR/touch-events/, http://www.chromestatus.com/features\n  @Experimental()\n  Stream<TouchEvent> get onTouchEnd => Element.touchEndEvent.forTarget(this);\n\n  /// Stream of `touchmove` events handled by this [Window].\n  @DomName('Window.ontouchmove')\n  @DocsEditable()\n  // http://www.w3.org/TR/touch-events/, http://www.chromestatus.com/features\n  @Experimental()\n  Stream<TouchEvent> get onTouchMove => Element.touchMoveEvent.forTarget(this);\n\n  /// Stream of `touchstart` events handled by this [Window].\n  @DomName('Window.ontouchstart')\n  @DocsEditable()\n  // http://www.w3.org/TR/touch-events/, http://www.chromestatus.com/features\n  @Experimental()\n  Stream<TouchEvent> get onTouchStart => Element.touchStartEvent.forTarget(this);\n\n  /// Stream of `transitionend` events handled by this [Window].\n  @DomName('Window.ontransitionend')\n  @DocsEditable()\n  Stream<TransitionEvent> get onTransitionEnd => Element.transitionEndEvent.forTarget(this);\n\n  /// Stream of `unload` events handled by this [Window].\n  @DomName('Window.onunload')\n  @DocsEditable()\n  Stream<Event> get onUnload => unloadEvent.forTarget(this);\n\n  /// Stream of `animationend` events handled by this [Window].\n  @DomName('Window.onwebkitAnimationEnd')\n  @DocsEditable()\n  @Experimental()\n  Stream<AnimationEvent> get onAnimationEnd => animationEndEvent.forTarget(this);\n\n  /// Stream of `animationiteration` events handled by this [Window].\n  @DomName('Window.onwebkitAnimationIteration')\n  @DocsEditable()\n  @Experimental()\n  Stream<AnimationEvent> get onAnimationIteration => animationIterationEvent.forTarget(this);\n\n  /// Stream of `animationstart` events handled by this [Window].\n  @DomName('Window.onwebkitAnimationStart')\n  @DocsEditable()\n  @Experimental()\n  Stream<AnimationEvent> get onAnimationStart => animationStartEvent.forTarget(this);\n\n\n  /**\n   * Static factory designed to expose `beforeunload` events to event\n   * handlers that are not necessarily instances of [Window].\n   *\n   * See [EventStreamProvider] for usage information.\n   */\n  @DomName('Window.beforeunloadEvent')\n  static const EventStreamProvider<BeforeUnloadEvent> beforeUnloadEvent =\n      const _BeforeUnloadEventStreamProvider('beforeunload');\n\n  /// Stream of `beforeunload` events handled by this [Window].\n  @DomName('Window.onbeforeunload')\n  Stream<Event> get onBeforeUnload => beforeUnloadEvent.forTarget(this);\n\n  /**\n   * Moves this window to a specific position.\n   *\n   * x and y can be negative.\n   *\n   * ## Other resources\n   *\n   * * [Window.moveTo]\n   * (https://developer.mozilla.org/en-US/docs/Web/API/Window.moveTo) from MDN.\n   * * [Window.moveTo]\n   * (http://dev.w3.org/csswg/cssom-view/#dom-window-moveto) from W3C.\n   */\n  void moveTo(Point p) {\n    _moveTo(p.x, p.y);\n  }\n\n  /**\n   * The distance this window has been scrolled horizontally.\n   *\n   * ## Other resources\n   *\n   * * [The Screen interface specification]\n   * (http://www.w3.org/TR/cssom-view/#screen) from W3C.\n   * * [scrollX]\n   * (https://developer.mozilla.org/en-US/docs/Web/API/Window.scrollX) from MDN.\n   */\n  int get scrollX => JS('bool', '(\"scrollX\" in #)', this) ? JS('int',\n      '#.scrollX', this) : document.documentElement.scrollLeft;\n\n  /**\n   * The distance this window has been scrolled vertically.\n   *\n   * ## Other resources\n   *\n   * * [The Screen interface specification]\n   * (http://www.w3.org/TR/cssom-view/#screen) from W3C.\n   * * [scrollY]\n   * (https://developer.mozilla.org/en-US/docs/Web/API/Window.scrollY) from MDN.\n   */\n  int get scrollY => JS('bool', '(\"scrollY\" in #)', this) ? JS('int',\n      '#.scrollY', this) : document.documentElement.scrollTop;\n}\n\nclass _BeforeUnloadEvent extends _WrappedEvent implements BeforeUnloadEvent {\n  String _returnValue;\n\n  _BeforeUnloadEvent(Event base): super(base);\n\n  String get returnValue => _returnValue;\n\n  void set returnValue(String value) {\n    _returnValue = value;\n    // FF and IE use the value as the return value, Chrome will return this from\n    // the event callback function.\n    if (JS('bool', '(\"returnValue\" in #)', wrapped)) {\n      JS('void', '#.returnValue = #', wrapped, value);\n    }\n  }\n}\n\nclass _BeforeUnloadEventStreamProvider implements\n    EventStreamProvider<BeforeUnloadEvent> {\n  final String _eventType;\n\n  const _BeforeUnloadEventStreamProvider(this._eventType);\n\n  Stream<BeforeUnloadEvent> forTarget(EventTarget e, {bool useCapture: false}) {\n    var stream = new _EventStream(e, _eventType, useCapture);\n    var controller = new StreamController(sync: true);\n\n    stream.listen((event) {\n      var wrapped = new _BeforeUnloadEvent(event);\n      controller.add(wrapped);\n      return wrapped.returnValue;\n    });\n\n    return controller.stream;\n  }\n\n  String getEventType(EventTarget target) {\n    return _eventType;\n  }\n\n  ElementStream<BeforeUnloadEvent> forElement(Element e, {bool useCapture: false}) {\n    return new _ElementEventStreamImpl(e, _eventType, useCapture);\n  }\n\n  ElementStream<BeforeUnloadEvent> _forElementList(ElementList e,\n      {bool useCapture: false}) {\n    return new _ElementListEventStreamImpl(e, _eventType, useCapture);\n  }\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('WindowBase64')\n@Experimental() // untriaged\nabstract class WindowBase64 extends Interceptor {\n  // To suppress missing implicit constructor warnings.\n  factory WindowBase64._() { throw new UnsupportedError(\"Not supported\"); }\n\n  String atob(String string);\n\n  String btoa(String string);\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('WindowEventHandlers')\n@Experimental() // untriaged\nabstract class WindowEventHandlers extends EventTarget {\n  // To suppress missing implicit constructor warnings.\n  factory WindowEventHandlers._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('WindowEventHandlers.hashchangeEvent')\n  @DocsEditable()\n  @Experimental() // untriaged\n  static const EventStreamProvider<Event> hashChangeEvent = const EventStreamProvider<Event>('hashchange');\n\n  @DomName('WindowEventHandlers.messageEvent')\n  @DocsEditable()\n  @Experimental() // untriaged\n  static const EventStreamProvider<MessageEvent> messageEvent = const EventStreamProvider<MessageEvent>('message');\n\n  @DomName('WindowEventHandlers.offlineEvent')\n  @DocsEditable()\n  @Experimental() // untriaged\n  static const EventStreamProvider<Event> offlineEvent = const EventStreamProvider<Event>('offline');\n\n  @DomName('WindowEventHandlers.onlineEvent')\n  @DocsEditable()\n  @Experimental() // untriaged\n  static const EventStreamProvider<Event> onlineEvent = const EventStreamProvider<Event>('online');\n\n  @DomName('WindowEventHandlers.popstateEvent')\n  @DocsEditable()\n  @Experimental() // untriaged\n  static const EventStreamProvider<PopStateEvent> popStateEvent = const EventStreamProvider<PopStateEvent>('popstate');\n\n  @DomName('WindowEventHandlers.storageEvent')\n  @DocsEditable()\n  @Experimental() // untriaged\n  static const EventStreamProvider<StorageEvent> storageEvent = const EventStreamProvider<StorageEvent>('storage');\n\n  @DomName('WindowEventHandlers.unloadEvent')\n  @DocsEditable()\n  @Experimental() // untriaged\n  static const EventStreamProvider<Event> unloadEvent = const EventStreamProvider<Event>('unload');\n\n  @DomName('WindowEventHandlers.onhashchange')\n  @DocsEditable()\n  @Experimental() // untriaged\n  Stream<Event> get onHashChange => hashChangeEvent.forTarget(this);\n\n  @DomName('WindowEventHandlers.onmessage')\n  @DocsEditable()\n  @Experimental() // untriaged\n  Stream<MessageEvent> get onMessage => messageEvent.forTarget(this);\n\n  @DomName('WindowEventHandlers.onoffline')\n  @DocsEditable()\n  @Experimental() // untriaged\n  Stream<Event> get onOffline => offlineEvent.forTarget(this);\n\n  @DomName('WindowEventHandlers.ononline')\n  @DocsEditable()\n  @Experimental() // untriaged\n  Stream<Event> get onOnline => onlineEvent.forTarget(this);\n\n  @DomName('WindowEventHandlers.onpopstate')\n  @DocsEditable()\n  @Experimental() // untriaged\n  Stream<PopStateEvent> get onPopState => popStateEvent.forTarget(this);\n\n  @DomName('WindowEventHandlers.onstorage')\n  @DocsEditable()\n  @Experimental() // untriaged\n  Stream<StorageEvent> get onStorage => storageEvent.forTarget(this);\n\n  @DomName('WindowEventHandlers.onunload')\n  @DocsEditable()\n  @Experimental() // untriaged\n  Stream<Event> get onUnload => unloadEvent.forTarget(this);\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('Worker')\n@SupportedBrowser(SupportedBrowser.CHROME)\n@SupportedBrowser(SupportedBrowser.FIREFOX)\n@SupportedBrowser(SupportedBrowser.IE, '10')\n@SupportedBrowser(SupportedBrowser.SAFARI)\n// http://www.whatwg.org/specs/web-apps/current-work/multipage/workers.html#worker\n@Experimental() // stable\n@Native(\"Worker\")\nclass Worker extends EventTarget implements AbstractWorker {\n  // To suppress missing implicit constructor warnings.\n  factory Worker._() { throw new UnsupportedError(\"Not supported\"); }\n\n  /**\n   * Static factory designed to expose `error` events to event\n   * handlers that are not necessarily instances of [Worker].\n   *\n   * See [EventStreamProvider] for usage information.\n   */\n  @DomName('Worker.errorEvent')\n  @DocsEditable()\n  @Experimental() // untriaged\n  static const EventStreamProvider<Event> errorEvent = const EventStreamProvider<Event>('error');\n\n  /**\n   * Static factory designed to expose `message` events to event\n   * handlers that are not necessarily instances of [Worker].\n   *\n   * See [EventStreamProvider] for usage information.\n   */\n  @DomName('Worker.messageEvent')\n  @DocsEditable()\n  static const EventStreamProvider<MessageEvent> messageEvent = const EventStreamProvider<MessageEvent>('message');\n\n  @DomName('Worker.Worker')\n  @DocsEditable()\n  factory Worker(String scriptUrl) {\n    return Worker._create_1(scriptUrl);\n  }\n  static Worker _create_1(scriptUrl) => JS('Worker', 'new Worker(#)', scriptUrl);\n\n  /// Checks if this type is supported on the current platform.\n  static bool get supported => JS('bool', '(typeof window.Worker != \"undefined\")');\n\n  @DomName('Worker.postMessage')\n  @DocsEditable()\n  void postMessage(/*SerializedScriptValue*/ message, [List<MessagePort> messagePorts]) native;\n\n  @DomName('Worker.terminate')\n  @DocsEditable()\n  void terminate() native;\n\n  /// Stream of `error` events handled by this [Worker].\n  @DomName('Worker.onerror')\n  @DocsEditable()\n  @Experimental() // untriaged\n  Stream<Event> get onError => errorEvent.forTarget(this);\n\n  /// Stream of `message` events handled by this [Worker].\n  @DomName('Worker.onmessage')\n  @DocsEditable()\n  Stream<MessageEvent> get onMessage => messageEvent.forTarget(this);\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('WorkerConsole')\n@Experimental() // untriaged\n@Native(\"WorkerConsole\")\nclass WorkerConsole extends ConsoleBase {\n  // To suppress missing implicit constructor warnings.\n  factory WorkerConsole._() { throw new UnsupportedError(\"Not supported\"); }\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('WorkerCrypto')\n@Experimental() // untriaged\n@Native(\"WorkerCrypto\")\nclass WorkerCrypto extends Interceptor {\n  // To suppress missing implicit constructor warnings.\n  factory WorkerCrypto._() { throw new UnsupportedError(\"Not supported\"); }\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('WorkerGlobalScope')\n@Experimental() // untriaged\n@Native(\"WorkerGlobalScope\")\nclass WorkerGlobalScope extends EventTarget implements _WindowTimers, WindowBase64 {\n  // To suppress missing implicit constructor warnings.\n  factory WorkerGlobalScope._() { throw new UnsupportedError(\"Not supported\"); }\n\n  /**\n   * Static factory designed to expose `error` events to event\n   * handlers that are not necessarily instances of [WorkerGlobalScope].\n   *\n   * See [EventStreamProvider] for usage information.\n   */\n  @DomName('WorkerGlobalScope.errorEvent')\n  @DocsEditable()\n  @Experimental() // untriaged\n  static const EventStreamProvider<Event> errorEvent = const EventStreamProvider<Event>('error');\n\n  @DomName('WorkerGlobalScope.PERSISTENT')\n  @DocsEditable()\n  @Experimental() // untriaged\n  static const int PERSISTENT = 1;\n\n  @DomName('WorkerGlobalScope.TEMPORARY')\n  @DocsEditable()\n  @Experimental() // untriaged\n  static const int TEMPORARY = 0;\n\n  @DomName('WorkerGlobalScope.console')\n  @DocsEditable()\n  @Experimental() // untriaged\n  final WorkerConsole console;\n\n  @DomName('WorkerGlobalScope.crypto')\n  @DocsEditable()\n  @Experimental() // untriaged\n  final WorkerCrypto crypto;\n\n  @DomName('WorkerGlobalScope.indexedDB')\n  @DocsEditable()\n  @Experimental() // untriaged\n  final IdbFactory indexedDB;\n\n  @DomName('WorkerGlobalScope.location')\n  @DocsEditable()\n  @Experimental() // untriaged\n  final _WorkerLocation location;\n\n  @DomName('WorkerGlobalScope.navigator')\n  @DocsEditable()\n  @Experimental() // untriaged\n  final _WorkerNavigator navigator;\n\n  @DomName('WorkerGlobalScope.performance')\n  @DocsEditable()\n  @Experimental() // untriaged\n  final WorkerPerformance performance;\n\n  @DomName('WorkerGlobalScope.self')\n  @DocsEditable()\n  @Experimental() // untriaged\n  final WorkerGlobalScope self;\n\n  @DomName('WorkerGlobalScope.close')\n  @DocsEditable()\n  @Experimental() // untriaged\n  void close() native;\n\n  @DomName('WorkerGlobalScope.openDatabase')\n  @DocsEditable()\n  @Experimental() // untriaged\n  SqlDatabase openDatabase(String name, String version, String displayName, int estimatedSize, [DatabaseCallback creationCallback]) native;\n\n  @DomName('WorkerGlobalScope.openDatabaseSync')\n  @DocsEditable()\n  @Experimental() // untriaged\n  _DatabaseSync openDatabaseSync(String name, String version, String displayName, int estimatedSize, [DatabaseCallback creationCallback]) native;\n\n  @JSName('webkitRequestFileSystem')\n  @DomName('WorkerGlobalScope.webkitRequestFileSystem')\n  @DocsEditable()\n  @Experimental() // untriaged\n  void _webkitRequestFileSystem(int type, int size, [_FileSystemCallback successCallback, _ErrorCallback errorCallback]) native;\n\n  @JSName('webkitRequestFileSystem')\n  @DomName('WorkerGlobalScope.webkitRequestFileSystem')\n  @DocsEditable()\n  @Experimental() // untriaged\n  Future<FileSystem> webkitRequestFileSystem(int type, int size) {\n    var completer = new Completer<FileSystem>();\n    _webkitRequestFileSystem(type, size,\n        (value) { completer.complete(value); },\n        (error) { completer.completeError(error); });\n    return completer.future;\n  }\n\n  @JSName('webkitRequestFileSystemSync')\n  @DomName('WorkerGlobalScope.webkitRequestFileSystemSync')\n  @DocsEditable()\n  @SupportedBrowser(SupportedBrowser.CHROME)\n  @SupportedBrowser(SupportedBrowser.SAFARI)\n  @Experimental()\n  @Experimental() // untriaged\n  _DOMFileSystemSync requestFileSystemSync(int type, int size) native;\n\n  @JSName('webkitResolveLocalFileSystemSyncURL')\n  @DomName('WorkerGlobalScope.webkitResolveLocalFileSystemSyncURL')\n  @DocsEditable()\n  @SupportedBrowser(SupportedBrowser.CHROME)\n  @SupportedBrowser(SupportedBrowser.SAFARI)\n  @Experimental()\n  @Experimental() // untriaged\n  _EntrySync resolveLocalFileSystemSyncUrl(String url) native;\n\n  @JSName('webkitResolveLocalFileSystemURL')\n  @DomName('WorkerGlobalScope.webkitResolveLocalFileSystemURL')\n  @DocsEditable()\n  @Experimental() // untriaged\n  void _webkitResolveLocalFileSystemUrl(String url, _EntryCallback successCallback, [_ErrorCallback errorCallback]) native;\n\n  @JSName('webkitResolveLocalFileSystemURL')\n  @DomName('WorkerGlobalScope.webkitResolveLocalFileSystemURL')\n  @DocsEditable()\n  @Experimental() // untriaged\n  Future<Entry> webkitResolveLocalFileSystemUrl(String url) {\n    var completer = new Completer<Entry>();\n    _webkitResolveLocalFileSystemUrl(url,\n        (value) { completer.complete(value); },\n        (error) { completer.completeError(error); });\n    return completer.future;\n  }\n\n  // From WindowBase64\n\n  @DomName('WorkerGlobalScope.atob')\n  @DocsEditable()\n  @Experimental() // untriaged\n  String atob(String string) native;\n\n  @DomName('WorkerGlobalScope.btoa')\n  @DocsEditable()\n  @Experimental() // untriaged\n  String btoa(String string) native;\n\n  // From WindowTimers\n\n  @JSName('clearInterval')\n  @DomName('WorkerGlobalScope.clearInterval')\n  @DocsEditable()\n  @Experimental() // untriaged\n  void _clearInterval(int handle) native;\n\n  @JSName('clearTimeout')\n  @DomName('WorkerGlobalScope.clearTimeout')\n  @DocsEditable()\n  @Experimental() // untriaged\n  void _clearTimeout(int handle) native;\n\n  @JSName('setInterval')\n  @DomName('WorkerGlobalScope.setInterval')\n  @DocsEditable()\n  @Experimental() // untriaged\n  int _setInterval(Object handler, int timeout) native;\n\n  @JSName('setTimeout')\n  @DomName('WorkerGlobalScope.setTimeout')\n  @DocsEditable()\n  @Experimental() // untriaged\n  int _setTimeout(Object handler, int timeout) native;\n\n  /// Stream of `error` events handled by this [WorkerGlobalScope].\n  @DomName('WorkerGlobalScope.onerror')\n  @DocsEditable()\n  @Experimental() // untriaged\n  Stream<Event> get onError => errorEvent.forTarget(this);\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('WorkerPerformance')\n@Experimental() // untriaged\n@Native(\"WorkerPerformance\")\nclass WorkerPerformance extends Interceptor {\n  // To suppress missing implicit constructor warnings.\n  factory WorkerPerformance._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('WorkerPerformance.now')\n  @DocsEditable()\n  @Experimental() // untriaged\n  double now() native;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('XPathEvaluator')\n// http://www.w3.org/TR/DOM-Level-3-XPath/xpath.html#XPathEvaluator\n@deprecated // experimental\n@Native(\"XPathEvaluator\")\nclass XPathEvaluator extends Interceptor {\n  // To suppress missing implicit constructor warnings.\n  factory XPathEvaluator._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('XPathEvaluator.XPathEvaluator')\n  @DocsEditable()\n  factory XPathEvaluator() {\n    return XPathEvaluator._create_1();\n  }\n  static XPathEvaluator _create_1() => JS('XPathEvaluator', 'new XPathEvaluator()');\n\n  @DomName('XPathEvaluator.createExpression')\n  @DocsEditable()\n  XPathExpression createExpression(String expression, XPathNSResolver resolver) native;\n\n  @DomName('XPathEvaluator.createNSResolver')\n  @DocsEditable()\n  XPathNSResolver createNSResolver(Node nodeResolver) native;\n\n  @DomName('XPathEvaluator.evaluate')\n  @DocsEditable()\n  XPathResult evaluate(String expression, Node contextNode, XPathNSResolver resolver, int type, XPathResult inResult) native;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('XPathExpression')\n// http://www.w3.org/TR/DOM-Level-3-XPath/xpath.html#XPathExpression\n@deprecated // experimental\n@Native(\"XPathExpression\")\nclass XPathExpression extends Interceptor {\n  // To suppress missing implicit constructor warnings.\n  factory XPathExpression._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('XPathExpression.evaluate')\n  @DocsEditable()\n  XPathResult evaluate(Node contextNode, int type, XPathResult inResult) native;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('XPathNSResolver')\n// http://www.w3.org/TR/DOM-Level-3-XPath/xpath.html#XPathNSResolver\n@deprecated // experimental\n@Native(\"XPathNSResolver\")\nclass XPathNSResolver extends Interceptor {\n  // To suppress missing implicit constructor warnings.\n  factory XPathNSResolver._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @JSName('lookupNamespaceURI')\n  @DomName('XPathNSResolver.lookupNamespaceURI')\n  @DocsEditable()\n  String lookupNamespaceUri(String prefix) native;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('XPathResult')\n// http://www.w3.org/TR/DOM-Level-3-XPath/xpath.html#XPathResult\n@deprecated // experimental\n@Native(\"XPathResult\")\nclass XPathResult extends Interceptor {\n  // To suppress missing implicit constructor warnings.\n  factory XPathResult._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('XPathResult.ANY_TYPE')\n  @DocsEditable()\n  static const int ANY_TYPE = 0;\n\n  @DomName('XPathResult.ANY_UNORDERED_NODE_TYPE')\n  @DocsEditable()\n  static const int ANY_UNORDERED_NODE_TYPE = 8;\n\n  @DomName('XPathResult.BOOLEAN_TYPE')\n  @DocsEditable()\n  static const int BOOLEAN_TYPE = 3;\n\n  @DomName('XPathResult.FIRST_ORDERED_NODE_TYPE')\n  @DocsEditable()\n  static const int FIRST_ORDERED_NODE_TYPE = 9;\n\n  @DomName('XPathResult.NUMBER_TYPE')\n  @DocsEditable()\n  static const int NUMBER_TYPE = 1;\n\n  @DomName('XPathResult.ORDERED_NODE_ITERATOR_TYPE')\n  @DocsEditable()\n  static const int ORDERED_NODE_ITERATOR_TYPE = 5;\n\n  @DomName('XPathResult.ORDERED_NODE_SNAPSHOT_TYPE')\n  @DocsEditable()\n  static const int ORDERED_NODE_SNAPSHOT_TYPE = 7;\n\n  @DomName('XPathResult.STRING_TYPE')\n  @DocsEditable()\n  static const int STRING_TYPE = 2;\n\n  @DomName('XPathResult.UNORDERED_NODE_ITERATOR_TYPE')\n  @DocsEditable()\n  static const int UNORDERED_NODE_ITERATOR_TYPE = 4;\n\n  @DomName('XPathResult.UNORDERED_NODE_SNAPSHOT_TYPE')\n  @DocsEditable()\n  static const int UNORDERED_NODE_SNAPSHOT_TYPE = 6;\n\n  @DomName('XPathResult.booleanValue')\n  @DocsEditable()\n  final bool booleanValue;\n\n  @DomName('XPathResult.invalidIteratorState')\n  @DocsEditable()\n  final bool invalidIteratorState;\n\n  @DomName('XPathResult.numberValue')\n  @DocsEditable()\n  final double numberValue;\n\n  @DomName('XPathResult.resultType')\n  @DocsEditable()\n  final int resultType;\n\n  @DomName('XPathResult.singleNodeValue')\n  @DocsEditable()\n  final Node singleNodeValue;\n\n  @DomName('XPathResult.snapshotLength')\n  @DocsEditable()\n  final int snapshotLength;\n\n  @DomName('XPathResult.stringValue')\n  @DocsEditable()\n  final String stringValue;\n\n  @DomName('XPathResult.iterateNext')\n  @DocsEditable()\n  Node iterateNext() native;\n\n  @DomName('XPathResult.snapshotItem')\n  @DocsEditable()\n  Node snapshotItem(int index) native;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('XMLDocument')\n@Experimental() // untriaged\n@Native(\"XMLDocument\")\nclass XmlDocument extends Document {\n  // To suppress missing implicit constructor warnings.\n  factory XmlDocument._() { throw new UnsupportedError(\"Not supported\"); }\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('XMLSerializer')\n// http://domparsing.spec.whatwg.org/#the-xmlserializer-interface\n@deprecated // stable\n@Native(\"XMLSerializer\")\nclass XmlSerializer extends Interceptor {\n  // To suppress missing implicit constructor warnings.\n  factory XmlSerializer._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('XMLSerializer.XMLSerializer')\n  @DocsEditable()\n  factory XmlSerializer() {\n    return XmlSerializer._create_1();\n  }\n  static XmlSerializer _create_1() => JS('XmlSerializer', 'new XMLSerializer()');\n\n  @DomName('XMLSerializer.serializeToString')\n  @DocsEditable()\n  String serializeToString(Node node) native;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('XSLTProcessor')\n@SupportedBrowser(SupportedBrowser.CHROME)\n@SupportedBrowser(SupportedBrowser.FIREFOX)\n@SupportedBrowser(SupportedBrowser.SAFARI)\n@deprecated // nonstandard\n@Native(\"XSLTProcessor\")\nclass XsltProcessor extends Interceptor {\n  // To suppress missing implicit constructor warnings.\n  factory XsltProcessor._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('XSLTProcessor.XSLTProcessor')\n  @DocsEditable()\n  factory XsltProcessor() {\n    return XsltProcessor._create_1();\n  }\n  static XsltProcessor _create_1() => JS('XsltProcessor', 'new XSLTProcessor()');\n\n  /// Checks if this type is supported on the current platform.\n  static bool get supported => JS('bool', '!!(window.XSLTProcessor)');\n\n  @DomName('XSLTProcessor.clearParameters')\n  @DocsEditable()\n  void clearParameters() native;\n\n  @DomName('XSLTProcessor.getParameter')\n  @DocsEditable()\n  String getParameter(String namespaceURI, String localName) native;\n\n  @DomName('XSLTProcessor.importStylesheet')\n  @DocsEditable()\n  void importStylesheet(Node stylesheet) native;\n\n  @DomName('XSLTProcessor.removeParameter')\n  @DocsEditable()\n  void removeParameter(String namespaceURI, String localName) native;\n\n  @DomName('XSLTProcessor.reset')\n  @DocsEditable()\n  void reset() native;\n\n  @DomName('XSLTProcessor.setParameter')\n  @DocsEditable()\n  void setParameter(String namespaceURI, String localName, String value) native;\n\n  @DomName('XSLTProcessor.transformToDocument')\n  @DocsEditable()\n  Document transformToDocument(Node source) native;\n\n  @DomName('XSLTProcessor.transformToFragment')\n  @DocsEditable()\n  DocumentFragment transformToFragment(Node source, Document docVal) native;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('Attr')\n@Native(\"Attr\")\nclass _Attr extends Node {\n  // To suppress missing implicit constructor warnings.\n  factory _Attr._() { throw new UnsupportedError(\"Not supported\"); }\n\n  // Use implementation from Node.\n  // final String _localName;\n\n  @DomName('Attr.name')\n  @DocsEditable()\n  final String name;\n\n  // Use implementation from Node.\n  // final String _namespaceUri;\n\n  @DomName('Attr.value')\n  @DocsEditable()\n  String value;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('CSSPrimitiveValue')\n// http://dev.w3.org/csswg/cssom/#the-cssstyledeclaration-interface\n@deprecated // deprecated\n@Native(\"CSSPrimitiveValue\")\nabstract class _CSSPrimitiveValue extends _CSSValue {\n  // To suppress missing implicit constructor warnings.\n  factory _CSSPrimitiveValue._() { throw new UnsupportedError(\"Not supported\"); }\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('CSSUnknownRule')\n// http://dev.w3.org/csswg/cssom/#the-cssstylesheet-interface\n@deprecated // deprecated\n@Native(\"CSSUnknownRule\")\nabstract class _CSSUnknownRule extends CssRule {\n  // To suppress missing implicit constructor warnings.\n  factory _CSSUnknownRule._() { throw new UnsupportedError(\"Not supported\"); }\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('CSSValue')\n// http://dev.w3.org/csswg/cssom/\n@deprecated // deprecated\n@Native(\"CSSValue\")\nabstract class _CSSValue extends Interceptor {\n  // To suppress missing implicit constructor warnings.\n  factory _CSSValue._() { throw new UnsupportedError(\"Not supported\"); }\n}\n// Copyright (c) 2013, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('ClientRect')\n@Native(\"ClientRect,DOMRect\")\nclass _ClientRect extends Interceptor implements Rectangle {\n\n  // NOTE! All code below should be common with RectangleBase.\n   String toString() {\n    return 'Rectangle ($left, $top) $width x $height';\n  }\n\n  bool operator ==(other) {\n    if (other is !Rectangle) return false;\n    return left == other.left && top == other.top && width == other.width &&\n        height == other.height;\n  }\n\n  int get hashCode => _JenkinsSmiHash.hash4(left.hashCode, top.hashCode,\n      width.hashCode, height.hashCode);\n\n  /**\n   * Computes the intersection of `this` and [other].\n   *\n   * The intersection of two axis-aligned rectangles, if any, is always another\n   * axis-aligned rectangle.\n   *\n   * Returns the intersection of this and `other`, or null if they don't\n   * intersect.\n   */\n  Rectangle intersection(Rectangle other) {\n    var x0 = max(left, other.left);\n    var x1 = min(left + width, other.left + other.width);\n\n    if (x0 <= x1) {\n      var y0 = max(top, other.top);\n      var y1 = min(top + height, other.top + other.height);\n\n      if (y0 <= y1) {\n        return new Rectangle(x0, y0, x1 - x0, y1 - y0);\n      }\n    }\n    return null;\n  }\n\n\n  /**\n   * Returns true if `this` intersects [other].\n   */\n  bool intersects(Rectangle<num> other) {\n    return (left <= other.left + other.width &&\n        other.left <= left + width &&\n        top <= other.top + other.height &&\n        other.top <= top + height);\n  }\n\n  /**\n   * Returns a new rectangle which completely contains `this` and [other].\n   */\n  Rectangle boundingBox(Rectangle other) {\n    var right = max(this.left + this.width, other.left + other.width);\n    var bottom = max(this.top + this.height, other.top + other.height);\n\n    var left = min(this.left, other.left);\n    var top = min(this.top, other.top);\n\n    return new Rectangle(left, top, right - left, bottom - top);\n  }\n\n  /**\n   * Tests whether `this` entirely contains [another].\n   */\n  bool containsRectangle(Rectangle<num> another) {\n    return left <= another.left &&\n           left + width >= another.left + another.width &&\n           top <= another.top &&\n           top + height >= another.top + another.height;\n  }\n\n  /**\n   * Tests whether [another] is inside or along the edges of `this`.\n   */\n  bool containsPoint(Point<num> another) {\n    return another.x >= left &&\n           another.x <= left + width &&\n           another.y >= top &&\n           another.y <= top + height;\n  }\n\n  Point get topLeft => new Point(this.left, this.top);\n  Point get topRight => new Point(this.left + this.width, this.top);\n  Point get bottomRight => new Point(this.left + this.width,\n      this.top + this.height);\n  Point get bottomLeft => new Point(this.left,\n      this.top + this.height);\n\n    // To suppress missing implicit constructor warnings.\n  factory _ClientRect._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('ClientRect.bottom')\n  @DocsEditable()\n  final double bottom;\n\n  @DomName('ClientRect.height')\n  @DocsEditable()\n  final double height;\n\n  @DomName('ClientRect.left')\n  @DocsEditable()\n  final double left;\n\n  @DomName('ClientRect.right')\n  @DocsEditable()\n  final double right;\n\n  @DomName('ClientRect.top')\n  @DocsEditable()\n  final double top;\n\n  @DomName('ClientRect.width')\n  @DocsEditable()\n  final double width;\n}\n\n/**\n * This is the [Jenkins hash function][1] but using masking to keep\n * values in SMI range.\n *\n * [1]: http://en.wikipedia.org/wiki/Jenkins_hash_function\n *\n * Use:\n * Hash each value with the hash of the previous value, then get the final\n * hash by calling finish.\n *\n *     var hash = 0;\n *     for (var value in values) {\n *       hash = JenkinsSmiHash.combine(hash, value.hashCode);\n *     }\n *     hash = JenkinsSmiHash.finish(hash);\n */\nclass _JenkinsSmiHash {\n  // TODO(11617): This class should be optimized and standardized elsewhere.\n\n  static int combine(int hash, int value) {\n    hash = 0x1fffffff & (hash + value);\n    hash = 0x1fffffff & (hash + ((0x0007ffff & hash) << 10));\n    return hash ^ (hash >> 6);\n  }\n\n  static int finish(int hash) {\n    hash = 0x1fffffff & (hash + ((0x03ffffff & hash) <<  3));\n    hash = hash ^ (hash >> 11);\n    return 0x1fffffff & (hash + ((0x00003fff & hash) << 15));\n  }\n\n  static int hash2(a, b) => finish(combine(combine(0, a), b));\n\n  static int hash4(a, b, c, d) =>\n      finish(combine(combine(combine(combine(0, a), b), c), d));\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('ClientRectList')\n@Native(\"ClientRectList,DOMRectList\")\nclass _ClientRectList extends Interceptor with ListMixin<Rectangle>, ImmutableListMixin<Rectangle> implements List<Rectangle>, JavaScriptIndexingBehavior {\n  // To suppress missing implicit constructor warnings.\n  factory _ClientRectList._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('ClientRectList.length')\n  @DocsEditable()\n  int get length => JS(\"int\", \"#.length\", this);\n\n  Rectangle operator[](int index) {\n    if (JS(\"bool\", \"# >>> 0 !== # || # >= #\", index,\n        index, index, length))\n      throw new RangeError.range(index, 0, length);\n    return JS(\"Rectangle\", \"#[#]\", this, index);\n  }\n  void operator[]=(int index, Rectangle value) {\n    throw new UnsupportedError(\"Cannot assign element of immutable List.\");\n  }\n  // -- start List<Rectangle> mixins.\n  // Rectangle is the element type.\n\n\n  void set length(int value) {\n    throw new UnsupportedError(\"Cannot resize immutable List.\");\n  }\n\n  Rectangle get first {\n    if (this.length > 0) {\n      return JS('Rectangle', '#[0]', this);\n    }\n    throw new StateError(\"No elements\");\n  }\n\n  Rectangle get last {\n    int len = this.length;\n    if (len > 0) {\n      return JS('Rectangle', '#[#]', this, len - 1);\n    }\n    throw new StateError(\"No elements\");\n  }\n\n  Rectangle get single {\n    int len = this.length;\n    if (len == 1) {\n      return JS('Rectangle', '#[0]', this);\n    }\n    if (len == 0) throw new StateError(\"No elements\");\n    throw new StateError(\"More than one element\");\n  }\n\n  Rectangle elementAt(int index) => this[index];\n  // -- end List<Rectangle> mixins.\n\n  @DomName('ClientRectList.item')\n  @DocsEditable()\n  Rectangle item(int index) native;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('Counter')\n// http://dev.w3.org/csswg/cssom/\n@deprecated // deprecated\n@Native(\"Counter\")\nabstract class _Counter extends Interceptor {\n  // To suppress missing implicit constructor warnings.\n  factory _Counter._() { throw new UnsupportedError(\"Not supported\"); }\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('CSSRuleList')\n@Native(\"CSSRuleList\")\nclass _CssRuleList extends Interceptor with ListMixin<CssRule>, ImmutableListMixin<CssRule> implements JavaScriptIndexingBehavior, List<CssRule> {\n  // To suppress missing implicit constructor warnings.\n  factory _CssRuleList._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('CSSRuleList.length')\n  @DocsEditable()\n  int get length => JS(\"int\", \"#.length\", this);\n\n  CssRule operator[](int index) {\n    if (JS(\"bool\", \"# >>> 0 !== # || # >= #\", index,\n        index, index, length))\n      throw new RangeError.range(index, 0, length);\n    return JS(\"CssRule\", \"#[#]\", this, index);\n  }\n  void operator[]=(int index, CssRule value) {\n    throw new UnsupportedError(\"Cannot assign element of immutable List.\");\n  }\n  // -- start List<CssRule> mixins.\n  // CssRule is the element type.\n\n\n  void set length(int value) {\n    throw new UnsupportedError(\"Cannot resize immutable List.\");\n  }\n\n  CssRule get first {\n    if (this.length > 0) {\n      return JS('CssRule', '#[0]', this);\n    }\n    throw new StateError(\"No elements\");\n  }\n\n  CssRule get last {\n    int len = this.length;\n    if (len > 0) {\n      return JS('CssRule', '#[#]', this, len - 1);\n    }\n    throw new StateError(\"No elements\");\n  }\n\n  CssRule get single {\n    int len = this.length;\n    if (len == 1) {\n      return JS('CssRule', '#[0]', this);\n    }\n    if (len == 0) throw new StateError(\"No elements\");\n    throw new StateError(\"More than one element\");\n  }\n\n  CssRule elementAt(int index) => this[index];\n  // -- end List<CssRule> mixins.\n\n  @DomName('CSSRuleList.item')\n  @DocsEditable()\n  CssRule item(int index) native;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('CSSValueList')\n// http://dev.w3.org/csswg/cssom/\n@deprecated // deprecated\n@Native(\"CSSValueList\")\nclass _CssValueList extends _CSSValue with ListMixin<_CSSValue>, ImmutableListMixin<_CSSValue> implements JavaScriptIndexingBehavior, List<_CSSValue> {\n  // To suppress missing implicit constructor warnings.\n  factory _CssValueList._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('CSSValueList.length')\n  @DocsEditable()\n  int get length => JS(\"int\", \"#.length\", this);\n\n  _CSSValue operator[](int index) {\n    if (JS(\"bool\", \"# >>> 0 !== # || # >= #\", index,\n        index, index, length))\n      throw new RangeError.range(index, 0, length);\n    return JS(\"_CSSValue\", \"#[#]\", this, index);\n  }\n  void operator[]=(int index, _CSSValue value) {\n    throw new UnsupportedError(\"Cannot assign element of immutable List.\");\n  }\n  // -- start List<_CSSValue> mixins.\n  // _CSSValue is the element type.\n\n\n  void set length(int value) {\n    throw new UnsupportedError(\"Cannot resize immutable List.\");\n  }\n\n  _CSSValue get first {\n    if (this.length > 0) {\n      return JS('_CSSValue', '#[0]', this);\n    }\n    throw new StateError(\"No elements\");\n  }\n\n  _CSSValue get last {\n    int len = this.length;\n    if (len > 0) {\n      return JS('_CSSValue', '#[#]', this, len - 1);\n    }\n    throw new StateError(\"No elements\");\n  }\n\n  _CSSValue get single {\n    int len = this.length;\n    if (len == 1) {\n      return JS('_CSSValue', '#[0]', this);\n    }\n    if (len == 0) throw new StateError(\"No elements\");\n    throw new StateError(\"More than one element\");\n  }\n\n  _CSSValue elementAt(int index) => this[index];\n  // -- end List<_CSSValue> mixins.\n\n  @DomName('CSSValueList.item')\n  @DocsEditable()\n  _CSSValue item(int index) native;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('DOMFileSystemSync')\n@SupportedBrowser(SupportedBrowser.CHROME)\n@Experimental()\n// http://www.w3.org/TR/file-system-api/#the-filesystemsync-interface\n@Native(\"DOMFileSystemSync\")\nabstract class _DOMFileSystemSync extends Interceptor {\n  // To suppress missing implicit constructor warnings.\n  factory _DOMFileSystemSync._() { throw new UnsupportedError(\"Not supported\"); }\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('DatabaseSync')\n@SupportedBrowser(SupportedBrowser.CHROME)\n@SupportedBrowser(SupportedBrowser.SAFARI)\n@Experimental()\n// http://www.w3.org/TR/webdatabase/#databasesync\n@deprecated // deprecated\n@Native(\"DatabaseSync\")\nabstract class _DatabaseSync extends Interceptor {\n  // To suppress missing implicit constructor warnings.\n  factory _DatabaseSync._() { throw new UnsupportedError(\"Not supported\"); }\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('DirectoryEntrySync')\n// http://www.w3.org/TR/file-system-api/#the-directoryentrysync-interface\n@Experimental()\n@Native(\"DirectoryEntrySync\")\nabstract class _DirectoryEntrySync extends _EntrySync {\n  // To suppress missing implicit constructor warnings.\n  factory _DirectoryEntrySync._() { throw new UnsupportedError(\"Not supported\"); }\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('DirectoryReaderSync')\n// http://www.w3.org/TR/file-system-api/#idl-def-DirectoryReaderSync\n@Experimental()\n@Native(\"DirectoryReaderSync\")\nabstract class _DirectoryReaderSync extends Interceptor {\n  // To suppress missing implicit constructor warnings.\n  factory _DirectoryReaderSync._() { throw new UnsupportedError(\"Not supported\"); }\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('DocumentType')\n// http://www.w3.org/TR/DOM-Level-3-Core/core.html#ID-412266927\n@deprecated // stable\n@Native(\"DocumentType\")\nabstract class _DocumentType extends Node implements ChildNode {\n  // To suppress missing implicit constructor warnings.\n  factory _DocumentType._() { throw new UnsupportedError(\"Not supported\"); }\n\n  // From ChildNode\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('WebKitPoint')\n@SupportedBrowser(SupportedBrowser.CHROME)\n@SupportedBrowser(SupportedBrowser.SAFARI)\n@Experimental()\n// http://developer.apple.com/library/safari/#documentation/DataManagement/Reference/DOMWindowAdditionsReference/DOMWindowAdditions/DOMWindowAdditions.html\n@Experimental() // non-standard\n@Native(\"WebKitPoint\")\nclass _DomPoint extends Interceptor {\n  // To suppress missing implicit constructor warnings.\n  factory _DomPoint._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('WebKitPoint.WebKitPoint')\n  @DocsEditable()\n  factory _DomPoint(num x, num y) {\n    return _DomPoint._create_1(x, y);\n  }\n  static _DomPoint _create_1(x, y) => JS('_DomPoint', 'new WebKitPoint(#,#)', x, y);\n\n  /// Checks if this type is supported on the current platform.\n  static bool get supported => JS('bool', '!!(window.WebKitPoint)');\n\n  @DomName('WebKitPoint.x')\n  @DocsEditable()\n  num x;\n\n  @DomName('WebKitPoint.y')\n  @DocsEditable()\n  num y;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('EntrySync')\n// http://www.w3.org/TR/file-system-api/#idl-def-EntrySync\n@Experimental()\n@Native(\"EntrySync\")\nabstract class _EntrySync extends Interceptor {\n  // To suppress missing implicit constructor warnings.\n  factory _EntrySync._() { throw new UnsupportedError(\"Not supported\"); }\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('FileEntrySync')\n// http://www.w3.org/TR/file-system-api/#the-fileentrysync-interface\n@Experimental()\n@Native(\"FileEntrySync\")\nabstract class _FileEntrySync extends _EntrySync {\n  // To suppress missing implicit constructor warnings.\n  factory _FileEntrySync._() { throw new UnsupportedError(\"Not supported\"); }\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('FileReaderSync')\n// http://www.w3.org/TR/FileAPI/#FileReaderSync\n@Experimental()\n@Native(\"FileReaderSync\")\nabstract class _FileReaderSync extends Interceptor {\n  // To suppress missing implicit constructor warnings.\n  factory _FileReaderSync._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('FileReaderSync.FileReaderSync')\n  @DocsEditable()\n  factory _FileReaderSync() {\n    return _FileReaderSync._create_1();\n  }\n  static _FileReaderSync _create_1() => JS('_FileReaderSync', 'new FileReaderSync()');\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('FileWriterSync')\n// http://www.w3.org/TR/file-writer-api/#idl-def-FileWriterSync\n@Experimental()\n@Native(\"FileWriterSync\")\nabstract class _FileWriterSync extends Interceptor {\n  // To suppress missing implicit constructor warnings.\n  factory _FileWriterSync._() { throw new UnsupportedError(\"Not supported\"); }\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('GamepadList')\n// https://dvcs.w3.org/hg/gamepad/raw-file/default/gamepad.html\n@Experimental()\n@Native(\"GamepadList\")\nclass _GamepadList extends Interceptor with ListMixin<Gamepad>, ImmutableListMixin<Gamepad> implements JavaScriptIndexingBehavior, List<Gamepad> {\n  // To suppress missing implicit constructor warnings.\n  factory _GamepadList._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('GamepadList.length')\n  @DocsEditable()\n  int get length => JS(\"int\", \"#.length\", this);\n\n  Gamepad operator[](int index) {\n    if (JS(\"bool\", \"# >>> 0 !== # || # >= #\", index,\n        index, index, length))\n      throw new RangeError.range(index, 0, length);\n    return JS(\"Gamepad\", \"#[#]\", this, index);\n  }\n  void operator[]=(int index, Gamepad value) {\n    throw new UnsupportedError(\"Cannot assign element of immutable List.\");\n  }\n  // -- start List<Gamepad> mixins.\n  // Gamepad is the element type.\n\n\n  void set length(int value) {\n    throw new UnsupportedError(\"Cannot resize immutable List.\");\n  }\n\n  Gamepad get first {\n    if (this.length > 0) {\n      return JS('Gamepad', '#[0]', this);\n    }\n    throw new StateError(\"No elements\");\n  }\n\n  Gamepad get last {\n    int len = this.length;\n    if (len > 0) {\n      return JS('Gamepad', '#[#]', this, len - 1);\n    }\n    throw new StateError(\"No elements\");\n  }\n\n  Gamepad get single {\n    int len = this.length;\n    if (len == 1) {\n      return JS('Gamepad', '#[0]', this);\n    }\n    if (len == 0) throw new StateError(\"No elements\");\n    throw new StateError(\"More than one element\");\n  }\n\n  Gamepad elementAt(int index) => this[index];\n  // -- end List<Gamepad> mixins.\n\n  @DomName('GamepadList.item')\n  @DocsEditable()\n  Gamepad item(int index) native;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('HTMLAllCollection')\n// http://www.whatwg.org/specs/web-apps/current-work/multipage/obsolete.html#dom-document-all\n@deprecated // deprecated\n@Native(\"HTMLAllCollection\")\nabstract class _HTMLAllCollection extends Interceptor {\n  // To suppress missing implicit constructor warnings.\n  factory _HTMLAllCollection._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @JSName('item')\n  @DomName('HTMLAllCollection.item')\n  @DocsEditable()\n  Element _item(int index) native;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('HTMLAppletElement')\n// http://www.whatwg.org/specs/web-apps/current-work/multipage/obsolete.html#the-applet-element\n@deprecated // deprecated\n@Native(\"HTMLAppletElement\")\nabstract class _HTMLAppletElement extends HtmlElement {\n  // To suppress missing implicit constructor warnings.\n  factory _HTMLAppletElement._() { throw new UnsupportedError(\"Not supported\"); }\n  /**\n   * Constructor instantiated by the DOM when a custom element has been created.\n   *\n   * This can only be called by subclasses from their created constructor.\n   */\n  _HTMLAppletElement.created() : super.created();\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('HTMLDirectoryElement')\n// http://www.whatwg.org/specs/web-apps/current-work/multipage/obsolete.html#dir\n@deprecated // deprecated\n@Native(\"HTMLDirectoryElement\")\nabstract class _HTMLDirectoryElement extends HtmlElement {\n  // To suppress missing implicit constructor warnings.\n  factory _HTMLDirectoryElement._() { throw new UnsupportedError(\"Not supported\"); }\n  /**\n   * Constructor instantiated by the DOM when a custom element has been created.\n   *\n   * This can only be called by subclasses from their created constructor.\n   */\n  _HTMLDirectoryElement.created() : super.created();\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('HTMLFontElement')\n// http://www.whatwg.org/specs/web-apps/current-work/multipage/obsolete.html#htmlfontelement\n@deprecated // deprecated\n@Native(\"HTMLFontElement\")\nabstract class _HTMLFontElement extends HtmlElement {\n  // To suppress missing implicit constructor warnings.\n  factory _HTMLFontElement._() { throw new UnsupportedError(\"Not supported\"); }\n  /**\n   * Constructor instantiated by the DOM when a custom element has been created.\n   *\n   * This can only be called by subclasses from their created constructor.\n   */\n  _HTMLFontElement.created() : super.created();\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('HTMLFrameElement')\n// http://www.whatwg.org/specs/web-apps/current-work/multipage/obsolete.html#htmlframeelement\n@deprecated // deprecated\n@Native(\"HTMLFrameElement\")\nabstract class _HTMLFrameElement extends HtmlElement {\n  // To suppress missing implicit constructor warnings.\n  factory _HTMLFrameElement._() { throw new UnsupportedError(\"Not supported\"); }\n  /**\n   * Constructor instantiated by the DOM when a custom element has been created.\n   *\n   * This can only be called by subclasses from their created constructor.\n   */\n  _HTMLFrameElement.created() : super.created();\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('HTMLFrameSetElement')\n// http://www.whatwg.org/specs/web-apps/current-work/multipage/obsolete.html#frameset\n@deprecated // deprecated\n@Native(\"HTMLFrameSetElement\")\nabstract class _HTMLFrameSetElement extends HtmlElement implements WindowEventHandlers {\n  // To suppress missing implicit constructor warnings.\n  factory _HTMLFrameSetElement._() { throw new UnsupportedError(\"Not supported\"); }\n  /**\n   * Constructor instantiated by the DOM when a custom element has been created.\n   *\n   * This can only be called by subclasses from their created constructor.\n   */\n  _HTMLFrameSetElement.created() : super.created();\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('HTMLMarqueeElement')\n// http://www.whatwg.org/specs/web-apps/current-work/multipage/obsolete.html#the-marquee-element\n@deprecated // deprecated\n@Native(\"HTMLMarqueeElement\")\nabstract class _HTMLMarqueeElement extends HtmlElement {\n  // To suppress missing implicit constructor warnings.\n  factory _HTMLMarqueeElement._() { throw new UnsupportedError(\"Not supported\"); }\n  /**\n   * Constructor instantiated by the DOM when a custom element has been created.\n   *\n   * This can only be called by subclasses from their created constructor.\n   */\n  _HTMLMarqueeElement.created() : super.created();\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DomName('MutationEvent')\n// http://www.w3.org/TR/DOM-Level-3-Events/#events-mutationevents\n@deprecated\n@Native(\"MutationEvent\")\nabstract class _MutationEvent extends Event {\n  factory _MutationEvent(String type,\n      {bool canBubble: false, bool cancelable: false, Node relatedNode,\n      String prevValue, String newValue, String attrName, int attrChange: 0}) {\n\n    var event = document._createEvent('MutationEvent');\n    event._initMutationEvent(type, canBubble, cancelable, relatedNode,\n        prevValue, newValue, attrName, attrChange);\n    return event;\n  }\n  // To suppress missing implicit constructor warnings.\n  factory _MutationEvent._() { throw new UnsupportedError(\"Not supported\"); }\n\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('NamedNodeMap')\n// http://dom.spec.whatwg.org/#namednodemap\n@deprecated // deprecated\n@Native(\"NamedNodeMap,MozNamedAttrMap\")\nclass _NamedNodeMap extends Interceptor with ListMixin<Node>, ImmutableListMixin<Node> implements JavaScriptIndexingBehavior, List<Node> {\n  // To suppress missing implicit constructor warnings.\n  factory _NamedNodeMap._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('NamedNodeMap.length')\n  @DocsEditable()\n  int get length => JS(\"int\", \"#.length\", this);\n\n  Node operator[](int index) {\n    if (JS(\"bool\", \"# >>> 0 !== # || # >= #\", index,\n        index, index, length))\n      throw new RangeError.range(index, 0, length);\n    return JS(\"Node\", \"#[#]\", this, index);\n  }\n  void operator[]=(int index, Node value) {\n    throw new UnsupportedError(\"Cannot assign element of immutable List.\");\n  }\n  // -- start List<Node> mixins.\n  // Node is the element type.\n\n\n  void set length(int value) {\n    throw new UnsupportedError(\"Cannot resize immutable List.\");\n  }\n\n  Node get first {\n    if (this.length > 0) {\n      return JS('Node', '#[0]', this);\n    }\n    throw new StateError(\"No elements\");\n  }\n\n  Node get last {\n    int len = this.length;\n    if (len > 0) {\n      return JS('Node', '#[#]', this, len - 1);\n    }\n    throw new StateError(\"No elements\");\n  }\n\n  Node get single {\n    int len = this.length;\n    if (len == 1) {\n      return JS('Node', '#[0]', this);\n    }\n    if (len == 0) throw new StateError(\"No elements\");\n    throw new StateError(\"More than one element\");\n  }\n\n  Node elementAt(int index) => this[index];\n  // -- end List<Node> mixins.\n\n  @DomName('NamedNodeMap.__getter__')\n  @DocsEditable()\n  Node __getter__(String name) native;\n\n  @DomName('NamedNodeMap.getNamedItem')\n  @DocsEditable()\n  Node getNamedItem(String name) native;\n\n  @DomName('NamedNodeMap.getNamedItemNS')\n  @DocsEditable()\n  Node getNamedItemNS(String namespaceURI, String localName) native;\n\n  @DomName('NamedNodeMap.item')\n  @DocsEditable()\n  Node item(int index) native;\n\n  @DomName('NamedNodeMap.removeNamedItem')\n  @DocsEditable()\n  Node removeNamedItem(String name) native;\n\n  @DomName('NamedNodeMap.removeNamedItemNS')\n  @DocsEditable()\n  Node removeNamedItemNS(String namespaceURI, String localName) native;\n\n  @DomName('NamedNodeMap.setNamedItem')\n  @DocsEditable()\n  Node setNamedItem(Node node) native;\n\n  @DomName('NamedNodeMap.setNamedItemNS')\n  @DocsEditable()\n  Node setNamedItemNS(Node node) native;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('Notation')\n// http://dom.spec.whatwg.org/#notation\n@deprecated // deprecated\n@Native(\"Notation\")\nabstract class _Notation extends Node {\n  // To suppress missing implicit constructor warnings.\n  factory _Notation._() { throw new UnsupportedError(\"Not supported\"); }\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('NotificationCenter')\n@SupportedBrowser(SupportedBrowser.CHROME)\n@SupportedBrowser(SupportedBrowser.SAFARI)\n@Experimental()\n// http://www.w3.org/TR/notifications/#showing-a-notification\n@deprecated // deprecated\n@Native(\"NotificationCenter\")\nabstract class _NotificationCenter extends Interceptor {\n  // To suppress missing implicit constructor warnings.\n  factory _NotificationCenter._() { throw new UnsupportedError(\"Not supported\"); }\n\n  /// Checks if this type is supported on the current platform.\n  static bool get supported => JS('bool', '!!(window.webkitNotifications)');\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('PagePopupController')\n@deprecated // nonstandard\n@Native(\"PagePopupController\")\nabstract class _PagePopupController extends Interceptor {\n  // To suppress missing implicit constructor warnings.\n  factory _PagePopupController._() { throw new UnsupportedError(\"Not supported\"); }\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('RGBColor')\n// http://dev.w3.org/csswg/cssom/\n@deprecated // deprecated\n@Native(\"RGBColor\")\nabstract class _RGBColor extends Interceptor {\n  // To suppress missing implicit constructor warnings.\n  factory _RGBColor._() { throw new UnsupportedError(\"Not supported\"); }\n}\n// Copyright (c) 2013, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n// Omit RadioNodeList for dart2js.  The Dart Form and FieldSet APIs don't\n// currently expose an API the returns RadioNodeList.  The only use of a\n// RadioNodeList is to get the selected value and it will be cleaner to\n// introduce a different API for that purpose.\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('Rect')\n// http://dev.w3.org/csswg/cssom/\n@deprecated // deprecated\n@Native(\"Rect\")\nabstract class _Rect extends Interceptor {\n  // To suppress missing implicit constructor warnings.\n  factory _Rect._() { throw new UnsupportedError(\"Not supported\"); }\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('ServiceWorker')\n@Experimental() // untriaged\n@Native(\"ServiceWorker\")\nabstract class _ServiceWorker extends Interceptor {\n  // To suppress missing implicit constructor warnings.\n  factory _ServiceWorker._() { throw new UnsupportedError(\"Not supported\"); }\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('SpeechInputResultList')\n// http://lists.w3.org/Archives/Public/public-xg-htmlspeech/2011Feb/att-0020/api-draft.html#speech_input_result_list_interface\n@Experimental()\n@Native(\"SpeechInputResultList\")\nclass _SpeechInputResultList extends Interceptor with ListMixin<SpeechInputResult>, ImmutableListMixin<SpeechInputResult> implements JavaScriptIndexingBehavior, List<SpeechInputResult> {\n  // To suppress missing implicit constructor warnings.\n  factory _SpeechInputResultList._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('SpeechInputResultList.length')\n  @DocsEditable()\n  int get length => JS(\"int\", \"#.length\", this);\n\n  SpeechInputResult operator[](int index) {\n    if (JS(\"bool\", \"# >>> 0 !== # || # >= #\", index,\n        index, index, length))\n      throw new RangeError.range(index, 0, length);\n    return JS(\"SpeechInputResult\", \"#[#]\", this, index);\n  }\n  void operator[]=(int index, SpeechInputResult value) {\n    throw new UnsupportedError(\"Cannot assign element of immutable List.\");\n  }\n  // -- start List<SpeechInputResult> mixins.\n  // SpeechInputResult is the element type.\n\n\n  void set length(int value) {\n    throw new UnsupportedError(\"Cannot resize immutable List.\");\n  }\n\n  SpeechInputResult get first {\n    if (this.length > 0) {\n      return JS('SpeechInputResult', '#[0]', this);\n    }\n    throw new StateError(\"No elements\");\n  }\n\n  SpeechInputResult get last {\n    int len = this.length;\n    if (len > 0) {\n      return JS('SpeechInputResult', '#[#]', this, len - 1);\n    }\n    throw new StateError(\"No elements\");\n  }\n\n  SpeechInputResult get single {\n    int len = this.length;\n    if (len == 1) {\n      return JS('SpeechInputResult', '#[0]', this);\n    }\n    if (len == 0) throw new StateError(\"No elements\");\n    throw new StateError(\"More than one element\");\n  }\n\n  SpeechInputResult elementAt(int index) => this[index];\n  // -- end List<SpeechInputResult> mixins.\n\n  @DomName('SpeechInputResultList.item')\n  @DocsEditable()\n  SpeechInputResult item(int index) native;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('SpeechRecognitionResultList')\n// https://dvcs.w3.org/hg/speech-api/raw-file/tip/speechapi.html#speechrecognitionresultlist\n@Experimental()\n@Native(\"SpeechRecognitionResultList\")\nclass _SpeechRecognitionResultList extends Interceptor with ListMixin<SpeechRecognitionResult>, ImmutableListMixin<SpeechRecognitionResult> implements JavaScriptIndexingBehavior, List<SpeechRecognitionResult> {\n  // To suppress missing implicit constructor warnings.\n  factory _SpeechRecognitionResultList._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('SpeechRecognitionResultList.length')\n  @DocsEditable()\n  int get length => JS(\"int\", \"#.length\", this);\n\n  SpeechRecognitionResult operator[](int index) {\n    if (JS(\"bool\", \"# >>> 0 !== # || # >= #\", index,\n        index, index, length))\n      throw new RangeError.range(index, 0, length);\n    return JS(\"SpeechRecognitionResult\", \"#[#]\", this, index);\n  }\n  void operator[]=(int index, SpeechRecognitionResult value) {\n    throw new UnsupportedError(\"Cannot assign element of immutable List.\");\n  }\n  // -- start List<SpeechRecognitionResult> mixins.\n  // SpeechRecognitionResult is the element type.\n\n\n  void set length(int value) {\n    throw new UnsupportedError(\"Cannot resize immutable List.\");\n  }\n\n  SpeechRecognitionResult get first {\n    if (this.length > 0) {\n      return JS('SpeechRecognitionResult', '#[0]', this);\n    }\n    throw new StateError(\"No elements\");\n  }\n\n  SpeechRecognitionResult get last {\n    int len = this.length;\n    if (len > 0) {\n      return JS('SpeechRecognitionResult', '#[#]', this, len - 1);\n    }\n    throw new StateError(\"No elements\");\n  }\n\n  SpeechRecognitionResult get single {\n    int len = this.length;\n    if (len == 1) {\n      return JS('SpeechRecognitionResult', '#[0]', this);\n    }\n    if (len == 0) throw new StateError(\"No elements\");\n    throw new StateError(\"More than one element\");\n  }\n\n  SpeechRecognitionResult elementAt(int index) => this[index];\n  // -- end List<SpeechRecognitionResult> mixins.\n\n  @DomName('SpeechRecognitionResultList.item')\n  @DocsEditable()\n  SpeechRecognitionResult item(int index) native;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('StyleSheetList')\n@Native(\"StyleSheetList\")\nclass _StyleSheetList extends Interceptor with ListMixin<StyleSheet>, ImmutableListMixin<StyleSheet> implements JavaScriptIndexingBehavior, List<StyleSheet> {\n  // To suppress missing implicit constructor warnings.\n  factory _StyleSheetList._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('StyleSheetList.length')\n  @DocsEditable()\n  int get length => JS(\"int\", \"#.length\", this);\n\n  StyleSheet operator[](int index) {\n    if (JS(\"bool\", \"# >>> 0 !== # || # >= #\", index,\n        index, index, length))\n      throw new RangeError.range(index, 0, length);\n    return JS(\"StyleSheet\", \"#[#]\", this, index);\n  }\n  void operator[]=(int index, StyleSheet value) {\n    throw new UnsupportedError(\"Cannot assign element of immutable List.\");\n  }\n  // -- start List<StyleSheet> mixins.\n  // StyleSheet is the element type.\n\n\n  void set length(int value) {\n    throw new UnsupportedError(\"Cannot resize immutable List.\");\n  }\n\n  StyleSheet get first {\n    if (this.length > 0) {\n      return JS('StyleSheet', '#[0]', this);\n    }\n    throw new StateError(\"No elements\");\n  }\n\n  StyleSheet get last {\n    int len = this.length;\n    if (len > 0) {\n      return JS('StyleSheet', '#[#]', this, len - 1);\n    }\n    throw new StateError(\"No elements\");\n  }\n\n  StyleSheet get single {\n    int len = this.length;\n    if (len == 1) {\n      return JS('StyleSheet', '#[0]', this);\n    }\n    if (len == 0) throw new StateError(\"No elements\");\n    throw new StateError(\"More than one element\");\n  }\n\n  StyleSheet elementAt(int index) => this[index];\n  // -- end List<StyleSheet> mixins.\n\n  @DomName('StyleSheetList.__getter__')\n  @DocsEditable()\n  CssStyleSheet __getter__(String name) native;\n\n  @DomName('StyleSheetList.item')\n  @DocsEditable()\n  StyleSheet item(int index) native;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('SubtleCrypto')\n@Experimental() // untriaged\n@Native(\"SubtleCrypto\")\nabstract class _SubtleCrypto extends Interceptor {\n  // To suppress missing implicit constructor warnings.\n  factory _SubtleCrypto._() { throw new UnsupportedError(\"Not supported\"); }\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('WebKitCSSFilterValue')\n// http://dev.w3.org/csswg/cssom/\n@deprecated // deprecated\n@Native(\"WebKitCSSFilterValue\")\nabstract class _WebKitCSSFilterValue extends _CssValueList {\n  // To suppress missing implicit constructor warnings.\n  factory _WebKitCSSFilterValue._() { throw new UnsupportedError(\"Not supported\"); }\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('WebKitCSSMatrix')\n@SupportedBrowser(SupportedBrowser.CHROME)\n@SupportedBrowser(SupportedBrowser.SAFARI)\n@Experimental()\n// http://dev.w3.org/csswg/cssom/\n@deprecated // deprecated\n@Native(\"WebKitCSSMatrix\")\nabstract class _WebKitCSSMatrix extends Interceptor {\n  // To suppress missing implicit constructor warnings.\n  factory _WebKitCSSMatrix._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('WebKitCSSMatrix.WebKitCSSMatrix')\n  @DocsEditable()\n  factory _WebKitCSSMatrix([String cssValue]) {\n    if (cssValue != null) {\n      return _WebKitCSSMatrix._create_1(cssValue);\n    }\n    return _WebKitCSSMatrix._create_2();\n  }\n  static _WebKitCSSMatrix _create_1(cssValue) => JS('_WebKitCSSMatrix', 'new WebKitCSSMatrix(#)', cssValue);\n  static _WebKitCSSMatrix _create_2() => JS('_WebKitCSSMatrix', 'new WebKitCSSMatrix()');\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('WebKitCSSTransformValue')\n// http://dev.w3.org/csswg/cssom/\n@deprecated // deprecated\n@Native(\"WebKitCSSTransformValue\")\nabstract class _WebKitCSSTransformValue extends _CssValueList {\n  // To suppress missing implicit constructor warnings.\n  factory _WebKitCSSTransformValue._() { throw new UnsupportedError(\"Not supported\"); }\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('WebKitMediaSource')\n@Experimental() // untriaged\n@Native(\"WebKitMediaSource\")\nabstract class _WebKitMediaSource extends EventTarget {\n  // To suppress missing implicit constructor warnings.\n  factory _WebKitMediaSource._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('WebKitMediaSource.WebKitMediaSource')\n  @DocsEditable()\n  factory _WebKitMediaSource() {\n    return _WebKitMediaSource._create_1();\n  }\n  static _WebKitMediaSource _create_1() => JS('_WebKitMediaSource', 'new WebKitMediaSource()');\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('WebKitNotification')\n@Experimental() // untriaged\n@Native(\"WebKitNotification\")\nabstract class _WebKitNotification extends EventTarget {\n  // To suppress missing implicit constructor warnings.\n  factory _WebKitNotification._() { throw new UnsupportedError(\"Not supported\"); }\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('WebKitSourceBuffer')\n@Experimental() // untriaged\n@Native(\"WebKitSourceBuffer\")\nabstract class _WebKitSourceBuffer extends Interceptor {\n  // To suppress missing implicit constructor warnings.\n  factory _WebKitSourceBuffer._() { throw new UnsupportedError(\"Not supported\"); }\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('WebKitSourceBufferList')\n@Experimental() // untriaged\n@Native(\"WebKitSourceBufferList\")\nabstract class _WebKitSourceBufferList extends EventTarget {\n  // To suppress missing implicit constructor warnings.\n  factory _WebKitSourceBufferList._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @JSName('item')\n  @DomName('WebKitSourceBufferList.item')\n  @DocsEditable()\n  @Experimental() // untriaged\n  _WebKitSourceBuffer _item(int index) native;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('WindowTimers')\n@Experimental() // untriaged\nabstract class _WindowTimers extends Interceptor {\n  // To suppress missing implicit constructor warnings.\n  factory _WindowTimers._() { throw new UnsupportedError(\"Not supported\"); }\n\n  void _clearInterval(int handle);\n\n  void _clearTimeout(int handle);\n\n  int _setInterval(Object handler, int timeout);\n\n  int _setTimeout(Object handler, int timeout);\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('WorkerLocation')\n// http://www.whatwg.org/specs/web-apps/current-work/multipage/workers.html#workerlocation\n@Experimental()\n@Native(\"WorkerLocation\")\nabstract class _WorkerLocation extends Interceptor implements UrlUtilsReadOnly {\n  // To suppress missing implicit constructor warnings.\n  factory _WorkerLocation._() { throw new UnsupportedError(\"Not supported\"); }\n\n  // From URLUtilsReadOnly\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('WorkerNavigator')\n// http://www.whatwg.org/specs/web-apps/current-work/multipage/workers.html#workernavigator\n@Experimental()\n@Native(\"WorkerNavigator\")\nabstract class _WorkerNavigator extends Interceptor implements NavigatorOnLine, NavigatorID {\n  // To suppress missing implicit constructor warnings.\n  factory _WorkerNavigator._() { throw new UnsupportedError(\"Not supported\"); }\n\n  // From NavigatorID\n\n  // From NavigatorOnLine\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('XMLHttpRequestProgressEvent')\n@Experimental() // nonstandard\n@Native(\"XMLHttpRequestProgressEvent\")\nabstract class _XMLHttpRequestProgressEvent extends ProgressEvent {\n  // To suppress missing implicit constructor warnings.\n  factory _XMLHttpRequestProgressEvent._() { throw new UnsupportedError(\"Not supported\"); }\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\nabstract class _AttributeMap implements Map<String, String> {\n  final Element _element;\n\n  _AttributeMap(this._element);\n\n  void addAll(Map<String, String> other) {\n    other.forEach((k, v) { this[k] = v; });\n  }\n\n  bool containsValue(String value) {\n    for (var v in this.values) {\n      if (value == v) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  String putIfAbsent(String key, String ifAbsent()) {\n    if (!containsKey(key)) {\n      this[key] = ifAbsent();\n    }\n    return this[key];\n  }\n\n  void clear() {\n    for (var key in keys) {\n      remove(key);\n    }\n  }\n\n  void forEach(void f(String key, String value)) {\n    for (var key in keys) {\n      var value = this[key];\n      f(key, value);\n    }\n  }\n\n  Iterable<String> get keys {\n    // TODO: generate a lazy collection instead.\n    var attributes = _element._attributes;\n    var keys = new List<String>();\n    for (int i = 0, len = attributes.length; i < len; i++) {\n      if (_matches(attributes[i])) {\n        keys.add(attributes[i].name);\n      }\n    }\n    return keys;\n  }\n\n  Iterable<String> get values {\n    // TODO: generate a lazy collection instead.\n    var attributes = _element._attributes;\n    var values = new List<String>();\n    for (int i = 0, len = attributes.length; i < len; i++) {\n      if (_matches(attributes[i])) {\n        values.add(attributes[i].value);\n      }\n    }\n    return values;\n  }\n\n  /**\n   * Returns true if there is no {key, value} pair in the map.\n   */\n  bool get isEmpty {\n    return length == 0;\n  }\n\n  /**\n   * Returns true if there is at least one {key, value} pair in the map.\n   */\n  bool get isNotEmpty => !isEmpty;\n\n  /**\n   * Checks to see if the node should be included in this map.\n   */\n  bool _matches(Node node);\n}\n\n/**\n * Wrapper to expose [Element.attributes] as a typed map.\n */\nclass _ElementAttributeMap extends _AttributeMap {\n\n  _ElementAttributeMap(Element element): super(element);\n\n  bool containsKey(String key) {\n    return _element._hasAttribute(key);\n  }\n\n  String operator [](String key) {\n    return _element.getAttribute(key);\n  }\n\n  void operator []=(String key, String value) {\n    _element.setAttribute(key, value);\n  }\n\n  String remove(String key) {\n    String value = _element.getAttribute(key);\n    _element._removeAttribute(key);\n    return value;\n  }\n\n  /**\n   * The number of {key, value} pairs in the map.\n   */\n  int get length {\n    return keys.length;\n  }\n\n  bool _matches(Node node) => node._namespaceUri == null;\n}\n\n/**\n * Wrapper to expose namespaced attributes as a typed map.\n */\nclass _NamespacedAttributeMap extends _AttributeMap {\n\n  final String _namespace;\n\n  _NamespacedAttributeMap(Element element, this._namespace): super(element);\n\n  bool containsKey(String key) {\n    return _element._hasAttributeNS(_namespace, key);\n  }\n\n  String operator [](String key) {\n    return _element.getAttributeNS(_namespace, key);\n  }\n\n  void operator []=(String key, String value) {\n    _element.setAttributeNS(_namespace, key, value);\n  }\n\n  String remove(String key) {\n    String value = this[key];\n    _element._removeAttributeNS(_namespace, key);\n    return value;\n  }\n\n  /**\n   * The number of {key, value} pairs in the map.\n   */\n  int get length {\n    return keys.length;\n  }\n\n  bool _matches(Node node) => node._namespaceUri == _namespace;\n}\n\n\n/**\n * Provides a Map abstraction on top of data-* attributes, similar to the\n * dataSet in the old DOM.\n */\nclass _DataAttributeMap implements Map<String, String> {\n\n  final Map<String, String> _attributes;\n\n  _DataAttributeMap(this._attributes);\n\n  // interface Map\n\n  void addAll(Map<String, String> other) {\n    other.forEach((k, v) { this[k] = v; });\n  }\n\n  // TODO: Use lazy iterator when it is available on Map.\n  bool containsValue(String value) => values.any((v) => v == value);\n\n  bool containsKey(String key) => _attributes.containsKey(_attr(key));\n\n  String operator [](String key) => _attributes[_attr(key)];\n\n  void operator []=(String key, String value) {\n    _attributes[_attr(key)] = value;\n  }\n\n  String putIfAbsent(String key, String ifAbsent()) =>\n    _attributes.putIfAbsent(_attr(key), ifAbsent);\n\n  String remove(String key) => _attributes.remove(_attr(key));\n\n  void clear() {\n    // Needs to operate on a snapshot since we are mutating the collection.\n    for (String key in keys) {\n      remove(key);\n    }\n  }\n\n  void forEach(void f(String key, String value)) {\n    _attributes.forEach((String key, String value) {\n      if (_matches(key)) {\n        f(_strip(key), value);\n      }\n    });\n  }\n\n  Iterable<String> get keys {\n    final keys = new List<String>();\n    _attributes.forEach((String key, String value) {\n      if (_matches(key)) {\n        keys.add(_strip(key));\n      }\n    });\n    return keys;\n  }\n\n  Iterable<String> get values {\n    final values = new List<String>();\n    _attributes.forEach((String key, String value) {\n      if (_matches(key)) {\n        values.add(value);\n      }\n    });\n    return values;\n  }\n\n  int get length => keys.length;\n\n  // TODO: Use lazy iterator when it is available on Map.\n  bool get isEmpty => length == 0;\n\n  bool get isNotEmpty => !isEmpty;\n\n  // Helpers.\n  String _attr(String key) => 'data-${_toHyphenedName(key)}';\n  bool _matches(String key) => key.startsWith('data-');\n  String _strip(String key) => _toCamelCase(key.substring(5));\n\n  /**\n   * Converts a string name with hyphens into an identifier, by removing hyphens\n   * and capitalizing the following letter. Optionally [startUppercase] to\n   * captialize the first letter.\n   */\n  String _toCamelCase(String hyphenedName, {bool startUppercase: false}) {\n    var segments = hyphenedName.split('-');\n    int start = startUppercase ? 0 : 1;\n    for (int i = start; i < segments.length; i++) {\n      var segment = segments[i];\n      if (segment.length > 0) {\n        // Character between 'a'..'z' mapped to 'A'..'Z'\n        segments[i] = '${segment[0].toUpperCase()}${segment.substring(1)}';\n      }\n    }\n    return segments.join('');\n  }\n\n  /** Reverse of [toCamelCase]. */\n  String _toHyphenedName(String word) {\n    var sb = new StringBuffer();\n    for (int i = 0; i < word.length; i++) {\n      var lower = word[i].toLowerCase();\n      if (word[i] != lower && i > 0) sb.write('-');\n      sb.write(lower);\n    }\n    return sb.toString();\n  }\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n/**\n * An object that can be drawn to a 2D canvas rendering context.\n *\n * The image drawn to the canvas depends on the type of this object:\n *\n * * If this object is an [ImageElement], then this element's image is\n * drawn to the canvas. If this element is an animated image, then this\n * element's poster frame is drawn. If this element has no poster frame, then\n * the first frame of animation is drawn.\n *\n * * If this object is a [VideoElement], then the frame at this element's current\n * playback position is drawn to the canvas.\n *\n * * If this object is a [CanvasElement], then this element's bitmap is drawn to\n * the canvas.\n *\n * **Note:** Currently all versions of Internet Explorer do not support\n * drawing a video element to a canvas. You may also encounter problems drawing\n * a video to a canvas in Firefox if the source of the video is a data URL.\n *\n * ## See also\n *\n * * [CanvasRenderingContext2D.drawImage]\n * * [CanvasRenderingContext2D.drawImageToRect]\n * * [CanvasRenderingContext2D.drawImageScaled]\n * * [CanvasRenderingContext2D.drawImageScaledFromSource]\n *\n * ## Other resources\n *\n * * [Image sources for 2D rendering contexts]\n * (http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#image-sources-for-2d-rendering-contexts)\n * from WHATWG.\n * * [Drawing images]\n * (http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#dom-context-2d-drawimage)\n * from WHATWG.\n */\nabstract class CanvasImageSource {}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n/**\n * Top-level container for a browser tab or window.\n *\n * In a web browser, a [WindowBase] object represents any browser window. This\n * object contains the window's state and its relation to other\n * windows, such as which window opened this window.\n *\n * **Note:** This class represents any window, while [Window] is\n * used to access the properties and content of the current window or tab.\n *\n * ## See also\n *\n * * [Window]\n *\n * ## Other resources\n *\n * * [DOM Window](https://developer.mozilla.org/en-US/docs/DOM/window) from MDN.\n * * [Window](http://www.w3.org/TR/Window/) from the W3C.\n */\nabstract class WindowBase implements EventTarget {\n  // Fields.\n\n  /**\n   * The current location of this window.\n   *\n   *     Location currentLocation = window.location;\n   *     print(currentLocation.href); // 'http://www.example.com:80/'\n   */\n  LocationBase get location;\n\n  /**\n   * The current session history for this window.\n   *\n   * ## Other resources\n   *\n   * * [Session history and navigation specification]\n   * (http://www.whatwg.org/specs/web-apps/current-work/multipage/history.html)\n   * from WHATWG.\n   */\n  HistoryBase get history;\n\n  /**\n   * Indicates whether this window has been closed.\n   *\n   *     print(window.closed); // 'false'\n   *     window.close();\n   *     print(window.closed); // 'true'\n   */\n  bool get closed;\n\n  /**\n   * A reference to the window that opened this one.\n   *\n   *     Window thisWindow = window;\n   *     WindowBase otherWindow = thisWindow.open('http://www.example.com/', 'foo');\n   *     print(otherWindow.opener == thisWindow); // 'true'\n   */\n  WindowBase get opener;\n\n  /**\n   * A reference to the parent of this window.\n   *\n   * If this [WindowBase] has no parent, [parent] will return a reference to\n   * the [WindowBase] itself.\n   *\n   *     IFrameElement myIFrame = new IFrameElement();\n   *     window.document.body.elements.add(myIFrame);\n   *     print(myIframe.contentWindow.parent == window) // 'true'\n   *\n   *     print(window.parent == window) // 'true'\n   */\n  WindowBase get parent;\n\n  /**\n   * A reference to the topmost window in the window hierarchy.\n   *\n   * If this [WindowBase] is the topmost [WindowBase], [top] will return a\n   * reference to the [WindowBase] itself.\n   *\n   *     // Add an IFrame to the current window.\n   *     IFrameElement myIFrame = new IFrameElement();\n   *     window.document.body.elements.add(myIFrame);\n   *\n   *     // Add an IFrame inside of the other IFrame.\n   *     IFrameElement innerIFrame = new IFrameElement();\n   *     myIFrame.elements.add(innerIFrame);\n   *\n   *     print(myIframe.contentWindow.top == window) // 'true'\n   *     print(innerIFrame.contentWindow.top == window) // 'true'\n   *\n   *     print(window.top == window) // 'true'\n   */\n  WindowBase get top;\n\n  // Methods.\n  /**\n   * Closes the window.\n   *\n   * This method should only succeed if the [WindowBase] object is\n   * **script-closeable** and the window calling [close] is allowed to navigate\n   * the window.\n   *\n   * A window is script-closeable if it is either a window\n   * that was opened by another window, or if it is a window with only one\n   * document in its history.\n   *\n   * A window might not be allowed to navigate, and therefore close, another\n   * window due to browser security features.\n   *\n   *     var other = window.open('http://www.example.com', 'foo');\n   *     // Closes other window, as it is script-closeable.\n   *     other.close();\n   *     print(other.closed()); // 'true'\n   *\n   *     window.location('http://www.mysite.com', 'foo');\n   *     // Does not close this window, as the history has changed.\n   *     window.close();\n   *     print(window.closed()); // 'false'\n   *\n   * See also:\n   *\n   * * [Window close discussion](http://www.w3.org/TR/html5/browsers.html#dom-window-close) from the W3C\n   */\n  void close();\n\n  /**\n   * Sends a cross-origin message.\n   *\n   * ## Other resources\n   *\n   * * [window.postMessage]\n   * (https://developer.mozilla.org/en-US/docs/Web/API/Window.postMessage) from\n   * MDN.\n   * * [Cross-document messaging]\n   * (http://www.whatwg.org/specs/web-apps/current-work/multipage/web-messaging.html)\n   * from WHATWG.\n   */\n  void postMessage(var message, String targetOrigin, [List messagePorts]);\n}\n\nabstract class LocationBase {\n  void set href(String val);\n}\n\nabstract class HistoryBase {\n  void back();\n  void forward();\n  void go(int distance);\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n/** A Set that stores the CSS class names for an element. */\nabstract class CssClassSet implements Set<String> {\n\n  /**\n   * Adds the class [value] to the element if it is not on it, removes it if it\n   * is.\n   *\n   * If [shouldAdd] is true, then we always add that [value] to the element. If\n   * [shouldAdd] is false then we always remove [value] from the element.\n   */\n  bool toggle(String value, [bool shouldAdd]);\n\n  /**\n   * Returns [:true:] if classes cannot be added or removed from this\n   * [:CssClassSet:].\n   */\n  bool get frozen;\n\n  /**\n   * Determine if this element contains the class [value].\n   *\n   * This is the Dart equivalent of jQuery's\n   * [hasClass](http://api.jquery.com/hasClass/).\n   */\n  bool contains(String value);\n\n  /**\n   * Add the class [value] to element.\n   *\n   * This is the Dart equivalent of jQuery's\n   * [addClass](http://api.jquery.com/addClass/).\n   *\n   * If this corresponds to one element. Returns true if [value] was added to\n   * the set, otherwise false.\n   *\n   * If this corresponds to many elements, null is always returned.\n   */\n  bool add(String value);\n\n  /**\n   * Remove the class [value] from element, and return true on successful\n   * removal.\n   *\n   * This is the Dart equivalent of jQuery's\n   * [removeClass](http://api.jquery.com/removeClass/).\n   */\n  bool remove(Object value);\n\n  /**\n   * Add all classes specified in [iterable] to element.\n   *\n   * This is the Dart equivalent of jQuery's\n   * [addClass](http://api.jquery.com/addClass/).\n   */\n  void addAll(Iterable<String> iterable);\n\n  /**\n   * Remove all classes specified in [iterable] from element.\n   *\n   * This is the Dart equivalent of jQuery's\n   * [removeClass](http://api.jquery.com/removeClass/).\n   */\n  void removeAll(Iterable<String> iterable);\n\n  /**\n   * Toggles all classes specified in [iterable] on element.\n   *\n   * Iterate through [iterable]'s items, and add it if it is not on it, or\n   * remove it if it is. This is the Dart equivalent of jQuery's\n   * [toggleClass](http://api.jquery.com/toggleClass/).\n   * If [shouldAdd] is true, then we always add all the classes in [iterable]\n   * element. If [shouldAdd] is false then we always remove all the classes in\n   * [iterable] from the element.\n   */\n  void toggleAll(Iterable<String> iterable, [bool shouldAdd]);\n}\n\n/**\n * A set (union) of the CSS classes that are present in a set of elements.\n * Implemented separately from _ElementCssClassSet for performance.\n */\nclass _MultiElementCssClassSet extends CssClassSetImpl {\n  final Iterable<Element> _elementIterable;\n  Iterable<_ElementCssClassSet> _elementCssClassSetIterable;\n\n  _MultiElementCssClassSet(this._elementIterable) {\n    _elementCssClassSetIterable = new List.from(_elementIterable).map(\n        (e) => new _ElementCssClassSet(e));\n  }\n\n  Set<String> readClasses() {\n    var s = new LinkedHashSet<String>();\n    _elementCssClassSetIterable.forEach((e) => s.addAll(e.readClasses()));\n    return s;\n  }\n\n  void writeClasses(Set<String> s) {\n    var classes = new List.from(s).join(' ');\n    for (Element e in _elementIterable) {\n      e.className = classes;\n    }\n  }\n\n  /**\n   * Helper method used to modify the set of css classes on this element.\n   *\n   *   f - callback with:\n   *   s - a Set of all the css class name currently on this element.\n   *\n   *   After f returns, the modified set is written to the\n   *       className property of this element.\n   */\n  modify( f(Set<String> s)) {\n    _elementCssClassSetIterable.forEach((e) => e.modify(f));\n  }\n\n  /**\n   * Adds the class [value] to the element if it is not on it, removes it if it\n   * is.\n   */\n  bool toggle(String value, [bool shouldAdd]) =>\n      _modifyWithReturnValue((e) => e.toggle(value, shouldAdd));\n\n  /**\n   * Remove the class [value] from element, and return true on successful\n   * removal.\n   *\n   * This is the Dart equivalent of jQuery's\n   * [removeClass](http://api.jquery.com/removeClass/).\n   */\n  bool remove(Object value) => _modifyWithReturnValue((e) => e.remove(value));\n\n  bool _modifyWithReturnValue(f) => _elementCssClassSetIterable.fold(\n      false, (prevValue, element) => f(element) || prevValue);\n}\n\nclass _ElementCssClassSet extends CssClassSetImpl {\n\n  final Element _element;\n\n  _ElementCssClassSet(this._element);\n\n  Set<String> readClasses() {\n    var s = new LinkedHashSet<String>();\n    var classname = _element.className;\n\n    for (String name in classname.split(' ')) {\n      String trimmed = name.trim();\n      if (!trimmed.isEmpty) {\n        s.add(trimmed);\n      }\n    }\n    return s;\n  }\n\n  void writeClasses(Set<String> s) {\n    List list = new List.from(s);\n    _element.className = s.join(' ');\n  }\n}\n// Copyright (c) 2013, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n/**\n * A rectangle representing all the content of the element in the\n * [box model](http://www.w3.org/TR/CSS2/box.html).\n */\nclass _ContentCssRect extends CssRect {\n\n  _ContentCssRect(element) : super(element);\n\n  num get height => _element.offsetHeight +\n      _addOrSubtractToBoxModel(_HEIGHT, _CONTENT);\n\n  num get width => _element.offsetWidth +\n      _addOrSubtractToBoxModel(_WIDTH, _CONTENT);\n\n  /**\n   * Set the height to `newHeight`.\n   *\n   * newHeight can be either a [num] representing the height in pixels or a\n   * [Dimension] object. Values of newHeight that are less than zero are\n   * converted to effectively setting the height to 0. This is equivalent to the\n   * `height` function in jQuery and the calculated `height` CSS value,\n   * converted to a num in pixels.\n   */\n  void set height(newHeight) {\n    if (newHeight is Dimension) {\n      if (newHeight.value < 0) newHeight = new Dimension.px(0);\n      _element.style.height = newHeight.toString();\n    } else {\n      if (newHeight < 0) newHeight = 0;\n      _element.style.height = '${newHeight}px';\n    }\n  }\n\n  /**\n   * Set the current computed width in pixels of this element.\n   *\n   * newWidth can be either a [num] representing the width in pixels or a\n   * [Dimension] object. This is equivalent to the `width` function in jQuery\n   * and the calculated\n   * `width` CSS value, converted to a dimensionless num in pixels.\n   */\n  void set width(newWidth) {\n    if (newWidth is Dimension) {\n      if (newWidth.value < 0) newWidth = new Dimension.px(0);\n      _element.style.width = newWidth.toString();\n    } else {\n      if (newWidth < 0) newWidth = 0;\n      _element.style.width = '${newWidth}px';\n    }\n  }\n\n  num get left => _element.getBoundingClientRect().left -\n      _addOrSubtractToBoxModel(['left'], _CONTENT);\n  num get top => _element.getBoundingClientRect().top -\n      _addOrSubtractToBoxModel(['top'], _CONTENT);\n}\n\n/**\n * A list of element content rectangles in the\n * [box model](http://www.w3.org/TR/CSS2/box.html).\n */\nclass _ContentCssListRect extends _ContentCssRect {\n  List<Element> _elementList;\n\n  _ContentCssListRect(elementList) : super(elementList.first) {\n    _elementList = elementList;\n  }\n\n  /**\n   * Set the height to `newHeight`.\n   *\n   * Values of newHeight that are less than zero are converted to effectively\n   * setting the height to 0. This is equivalent to the `height`\n   * function in jQuery and the calculated `height` CSS value, converted to a\n   * num in pixels.\n   */\n  void set height(newHeight) {\n    _elementList.forEach((e) => e.contentEdge.height = newHeight);\n  }\n\n  /**\n   * Set the current computed width in pixels of this element.\n   *\n   * This is equivalent to the `width` function in jQuery and the calculated\n   * `width` CSS value, converted to a dimensionless num in pixels.\n   */\n  void set width(newWidth) {\n    _elementList.forEach((e) => e.contentEdge.width = newWidth);\n  }\n}\n\n/**\n * A rectangle representing the dimensions of the space occupied by the\n * element's content + padding in the\n * [box model](http://www.w3.org/TR/CSS2/box.html).\n */\nclass _PaddingCssRect extends CssRect {\n  _PaddingCssRect(element) : super(element);\n  num get height => _element.offsetHeight +\n      _addOrSubtractToBoxModel(_HEIGHT, _PADDING);\n  num get width => _element.offsetWidth +\n      _addOrSubtractToBoxModel(_WIDTH, _PADDING);\n\n  num get left => _element.getBoundingClientRect().left -\n      _addOrSubtractToBoxModel(['left'], _PADDING);\n  num get top => _element.getBoundingClientRect().top -\n      _addOrSubtractToBoxModel(['top'], _PADDING);\n}\n\n/**\n * A rectangle representing the dimensions of the space occupied by the\n * element's content + padding + border in the\n * [box model](http://www.w3.org/TR/CSS2/box.html).\n */\nclass _BorderCssRect extends CssRect {\n  _BorderCssRect(element) : super(element);\n  num get height => _element.offsetHeight;\n  num get width => _element.offsetWidth;\n\n  num get left => _element.getBoundingClientRect().left;\n  num get top => _element.getBoundingClientRect().top;\n}\n\n/**\n * A rectangle representing the dimensions of the space occupied by the\n * element's content + padding + border + margin in the\n * [box model](http://www.w3.org/TR/CSS2/box.html).\n */\nclass _MarginCssRect extends CssRect {\n  _MarginCssRect(element) : super(element);\n  num get height => _element.offsetHeight +\n      _addOrSubtractToBoxModel(_HEIGHT, _MARGIN);\n  num get width =>\n      _element.offsetWidth + _addOrSubtractToBoxModel(_WIDTH, _MARGIN);\n\n  num get left => _element.getBoundingClientRect().left -\n      _addOrSubtractToBoxModel(['left'], _MARGIN);\n  num get top => _element.getBoundingClientRect().top -\n      _addOrSubtractToBoxModel(['top'], _MARGIN);\n}\n\n/**\n * A class for representing CSS dimensions.\n *\n * In contrast to the more general purpose [Rectangle] class, this class's\n * values are mutable, so one can change the height of an element\n * programmatically.\n *\n * _Important_ _note_: use of these methods will perform CSS calculations that\n * can trigger a browser reflow. Therefore, use of these properties _during_ an\n * animation frame is discouraged. See also:\n * [Browser Reflow](https://developers.google.com/speed/articles/reflow)\n */\nabstract class CssRect extends MutableRectangle<num> {\n  Element _element;\n\n  CssRect(this._element) : super(0, 0, 0, 0);\n\n  num get left;\n\n  num get top;\n\n  /**\n   * The height of this rectangle.\n   *\n   * This is equivalent to the `height` function in jQuery and the calculated\n   * `height` CSS value, converted to a dimensionless num in pixels. Unlike\n   * [getBoundingClientRect], `height` will return the same numerical width if\n   * the element is hidden or not.\n   */\n  num get height;\n\n  /**\n   * The width of this rectangle.\n   *\n   * This is equivalent to the `width` function in jQuery and the calculated\n   * `width` CSS value, converted to a dimensionless num in pixels. Unlike\n   * [getBoundingClientRect], `width` will return the same numerical width if\n   * the element is hidden or not.\n   */\n  num get width;\n\n  /**\n   * Set the height to `newHeight`.\n   *\n   * newHeight can be either a [num] representing the height in pixels or a\n   * [Dimension] object. Values of newHeight that are less than zero are\n   * converted to effectively setting the height to 0. This is equivalent to the\n   * `height` function in jQuery and the calculated `height` CSS value,\n   * converted to a num in pixels.\n   *\n   * Note that only the content height can actually be set via this method.\n   */\n  void set height(newHeight) {\n    throw new UnsupportedError(\"Can only set height for content rect.\");\n  }\n\n  /**\n   * Set the current computed width in pixels of this element.\n   *\n   * newWidth can be either a [num] representing the width in pixels or a\n   * [Dimension] object. This is equivalent to the `width` function in jQuery\n   * and the calculated\n   * `width` CSS value, converted to a dimensionless num in pixels.\n   *\n   * Note that only the content width can be set via this method.\n   */\n  void set width(newWidth) {\n    throw new UnsupportedError(\"Can only set width for content rect.\");\n  }\n\n  /**\n   * Return a value that is used to modify the initial height or width\n   * measurement of an element. Depending on the value (ideally an enum) passed\n   * to augmentingMeasurement, we may need to add or subtract margin, padding,\n   * or border values, depending on the measurement we're trying to obtain.\n   */\n  num _addOrSubtractToBoxModel(List<String> dimensions,\n      String augmentingMeasurement) {\n    // getComputedStyle always returns pixel values (hence, computed), so we're\n    // always dealing with pixels in this method.\n    var styles = _element.getComputedStyle();\n\n    var val = 0;\n\n    for (String measurement in dimensions) {\n      // The border-box and default box model both exclude margin in the regular\n      // height/width calculation, so add it if we want it for this measurement.\n      if (augmentingMeasurement == _MARGIN) {\n        val += new Dimension.css(styles.getPropertyValue(\n            '$augmentingMeasurement-$measurement')).value;\n      }\n\n      // The border-box includes padding and border, so remove it if we want\n      // just the content itself.\n      if (augmentingMeasurement == _CONTENT) {\n      \tval -= new Dimension.css(\n            styles.getPropertyValue('${_PADDING}-$measurement')).value;\n      }\n\n      // At this point, we don't wan't to augment with border or margin,\n      // so remove border.\n      if (augmentingMeasurement != _MARGIN) {\n\t      val -= new Dimension.css(styles.getPropertyValue(\n            'border-${measurement}-width')).value;\n      }\n    }\n    return val;\n  }\n}\n\nfinal _HEIGHT = ['top', 'bottom'];\nfinal _WIDTH = ['right', 'left'];\nfinal _CONTENT = 'content';\nfinal _PADDING = 'padding';\nfinal _MARGIN = 'margin';\n\n/**\n * Class representing a\n * [length measurement](https://developer.mozilla.org/en-US/docs/Web/CSS/length)\n * in CSS.\n */\n@Experimental()\nclass Dimension {\n  num _value;\n  String _unit;\n\n  /** Set this CSS Dimension to a percentage `value`. */\n  Dimension.percent(this._value) : _unit = '%';\n\n  /** Set this CSS Dimension to a pixel `value`. */\n  Dimension.px(this._value) : _unit = 'px';\n\n  /** Set this CSS Dimension to a pica `value`. */\n  Dimension.pc(this._value) : _unit = 'pc';\n\n  /** Set this CSS Dimension to a point `value`. */\n  Dimension.pt(this._value) : _unit = 'pt';\n\n  /** Set this CSS Dimension to an inch `value`. */\n  Dimension.inch(this._value) : _unit = 'in';\n\n  /** Set this CSS Dimension to a centimeter `value`. */\n  Dimension.cm(this._value) : _unit = 'cm';\n\n  /** Set this CSS Dimension to a millimeter `value`. */\n  Dimension.mm(this._value) : _unit = 'mm';\n\n  /**\n   * Set this CSS Dimension to the specified number of ems.\n   *\n   * 1em is equal to the current font size. (So 2ems is equal to double the font\n   * size). This is useful for producing website layouts that scale nicely with\n   * the user's desired font size.\n   */\n  Dimension.em(this._value) : _unit = 'em';\n\n  /**\n   * Set this CSS Dimension to the specified number of x-heights.\n   *\n   * One ex is equal to the the x-height of a font's baseline to its mean line,\n   * generally the height of the letter \"x\" in the font, which is usually about\n   * half the font-size.\n   */\n  Dimension.ex(this._value) : _unit = 'ex';\n\n  /**\n   * Construct a Dimension object from the valid, simple CSS string `cssValue`\n   * that represents a distance measurement.\n   *\n   * This constructor is intended as a convenience method for working with\n   * simplistic CSS length measurements. Non-numeric values such as `auto` or\n   * `inherit` or invalid CSS will cause this constructor to throw a\n   * FormatError.\n   */\n  Dimension.css(String cssValue) {\n    if (cssValue == '') cssValue = '0px';\n    if (cssValue.endsWith('%')) {\n      _unit = '%';\n    } else {\n      _unit = cssValue.substring(cssValue.length - 2);\n    }\n    if (cssValue.contains('.')) {\n      _value = double.parse(cssValue.substring(0,\n          cssValue.length - _unit.length));\n    } else {\n      _value = int.parse(cssValue.substring(0, cssValue.length - _unit.length));\n    }\n  }\n\n  /** Print out the CSS String representation of this value. */\n  String toString() {\n    return '${_value}${_unit}';\n  }\n\n  /** Return a unitless, numerical value of this CSS value. */\n  num get value => this._value;\n}\n// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\ntypedef EventListener(Event event);\n// Copyright (c) 2013, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n/**\n * A factory to expose DOM events as Streams.\n */\nclass EventStreamProvider<T extends Event> {\n  final String _eventType;\n\n  const EventStreamProvider(this._eventType);\n\n  /**\n   * Gets a [Stream] for this event type, on the specified target.\n   *\n   * This will always return a broadcast stream so multiple listeners can be\n   * used simultaneously.\n   *\n   * This may be used to capture DOM events:\n   *\n   *     Element.keyDownEvent.forTarget(element, useCapture: true).listen(...);\n   *\n   *     // Alternate method:\n   *     Element.keyDownEvent.forTarget(element).capture(...);\n   *\n   * Or for listening to an event which will bubble through the DOM tree:\n   *\n   *     MediaElement.pauseEvent.forTarget(document.body).listen(...);\n   *\n   * See also:\n   *\n   * [addEventListener](http://docs.webplatform.org/wiki/dom/methods/addEventListener)\n   */\n  Stream<T> forTarget(EventTarget e, {bool useCapture: false}) =>\n    new _EventStream(e, _eventType, useCapture);\n\n  /**\n   * Gets an [ElementEventStream] for this event type, on the specified element.\n   *\n   * This will always return a broadcast stream so multiple listeners can be\n   * used simultaneously.\n   *\n   * This may be used to capture DOM events:\n   *\n   *     Element.keyDownEvent.forElement(element, useCapture: true).listen(...);\n   *\n   *     // Alternate method:\n   *     Element.keyDownEvent.forElement(element).capture(...);\n   *\n   * Or for listening to an event which will bubble through the DOM tree:\n   *\n   *     MediaElement.pauseEvent.forElement(document.body).listen(...);\n   *\n   * See also:\n   *\n   * [addEventListener](http://docs.webplatform.org/wiki/dom/methods/addEventListener)\n   */\n  ElementStream<T> forElement(Element e, {bool useCapture: false}) {\n    return new _ElementEventStreamImpl(e, _eventType, useCapture);\n  }\n\n  /**\n   * Gets an [ElementEventStream] for this event type, on the list of elements.\n   *\n   * This will always return a broadcast stream so multiple listeners can be\n   * used simultaneously.\n   *\n   * This may be used to capture DOM events:\n   *\n   *     Element.keyDownEvent._forElementList(element, useCapture: true).listen(...);\n   *\n   * See also:\n   *\n   * [addEventListener](http://docs.webplatform.org/wiki/dom/methods/addEventListener)\n   */\n  ElementStream<T> _forElementList(ElementList e, {bool useCapture: false}) {\n    return new _ElementListEventStreamImpl(e, _eventType, useCapture);\n  }\n\n  /**\n   * Gets the type of the event which this would listen for on the specified\n   * event target.\n   *\n   * The target is necessary because some browsers may use different event names\n   * for the same purpose and the target allows differentiating browser support.\n   */\n  String getEventType(EventTarget target) {\n    return _eventType;\n  }\n}\n\n/** A specialized Stream available to [Element]s to enable event delegation. */\nabstract class ElementStream<T extends Event> implements Stream<T> {\n  /**\n   * Return a stream that only fires when the particular event fires for\n   * elements matching the specified CSS selector.\n   *\n   * This is the Dart equivalent to jQuery's\n   * [delegate](http://api.jquery.com/delegate/).\n   */\n  Stream<T> matches(String selector);\n\n  /**\n   * Adds a capturing subscription to this stream.\n   *\n   * If the target of the event is a descendant of the element from which this\n   * stream derives then [onData] is called before the event propagates down to\n   * the target. This is the opposite of bubbling behavior, where the event\n   * is first processed for the event target and then bubbles upward.\n   *\n   * ## Other resources\n   *\n   * * [Event Capture]\n   * (http://www.w3.org/TR/DOM-Level-2-Events/events.html#Events-flow-capture)\n   * from the W3C DOM Events specification.\n   */\n  StreamSubscription<T> capture(void onData(T event));\n}\n\n/**\n * Adapter for exposing DOM events as Dart streams.\n */\nclass _EventStream<T extends Event> extends Stream<T> {\n  final EventTarget _target;\n  final String _eventType;\n  final bool _useCapture;\n\n  _EventStream(this._target, this._eventType, this._useCapture);\n\n  // DOM events are inherently multi-subscribers.\n  Stream<T> asBroadcastStream({void onListen(StreamSubscription subscription),\n                               void onCancel(StreamSubscription subscription)})\n      => this;\n  bool get isBroadcast => true;\n\n  StreamSubscription<T> listen(void onData(T event),\n      { Function onError,\n        void onDone(),\n        bool cancelOnError}) {\n\n    return new _EventStreamSubscription<T>(\n        this._target, this._eventType, onData, this._useCapture);\n  }\n}\n\n/**\n * Adapter for exposing DOM Element events as streams, while also allowing\n * event delegation.\n */\nclass _ElementEventStreamImpl<T extends Event> extends _EventStream<T>\n    implements ElementStream<T> {\n  _ElementEventStreamImpl(target, eventType, useCapture) :\n      super(target, eventType, useCapture);\n\n  Stream<T> matches(String selector) => this.where(\n      (event) => event.target.matchesWithAncestors(selector)).map((e) {\n        e._selector = selector;\n        return e;\n      });\n\n  StreamSubscription<T> capture(void onData(T event)) =>\n    new _EventStreamSubscription<T>(\n        this._target, this._eventType, onData, true);\n}\n\n/**\n * Adapter for exposing events on a collection of DOM Elements as streams,\n * while also allowing event delegation.\n */\nclass _ElementListEventStreamImpl<T extends Event> extends Stream<T>\n    implements ElementStream<T> {\n  final Iterable<Element> _targetList;\n  final bool _useCapture;\n  final String _eventType;\n\n  _ElementListEventStreamImpl(\n      this._targetList, this._eventType, this._useCapture);\n\n  Stream<T> matches(String selector) => this.where(\n      (event) => event.target.matchesWithAncestors(selector)).map((e) {\n        e._selector = selector;\n        return e;\n      });\n\n  // Delegate all regular Stream behavior to a wrapped Stream.\n  StreamSubscription<T> listen(void onData(T event),\n      { Function onError,\n        void onDone(),\n        bool cancelOnError}) {\n    var pool = new _StreamPool.broadcast();\n    for (var target in _targetList) {\n      pool.add(new _EventStream(target, _eventType, _useCapture));\n    }\n    return pool.stream.listen(onData, onError: onError, onDone: onDone,\n          cancelOnError: cancelOnError);\n  }\n\n  StreamSubscription<T> capture(void onData(T event)) {\n    var pool = new _StreamPool.broadcast();\n    for (var target in _targetList) {\n      pool.add(new _EventStream(target, _eventType, true));\n    }\n    return pool.stream.listen(onData);\n  }\n\n  Stream<T> asBroadcastStream({void onListen(StreamSubscription subscription),\n                               void onCancel(StreamSubscription subscription)})\n      => this;\n  bool get isBroadcast => true;\n}\n\nclass _EventStreamSubscription<T extends Event> extends StreamSubscription<T> {\n  int _pauseCount = 0;\n  EventTarget _target;\n  final String _eventType;\n  var _onData;\n  final bool _useCapture;\n\n  _EventStreamSubscription(this._target, this._eventType, onData,\n      this._useCapture) : _onData = _wrapZone(onData) {\n    _tryResume();\n  }\n\n  Future cancel() {\n    if (_canceled) return null;\n\n    _unlisten();\n    // Clear out the target to indicate this is complete.\n    _target = null;\n    _onData = null;\n    return null;\n  }\n\n  bool get _canceled => _target == null;\n\n  void onData(void handleData(T event)) {\n    if (_canceled) {\n      throw new StateError(\"Subscription has been canceled.\");\n    }\n    // Remove current event listener.\n    _unlisten();\n\n    _onData = _wrapZone(handleData);\n    _tryResume();\n  }\n\n  /// Has no effect.\n  void onError(Function handleError) {}\n\n  /// Has no effect.\n  void onDone(void handleDone()) {}\n\n  void pause([Future resumeSignal]) {\n    if (_canceled) return;\n    ++_pauseCount;\n    _unlisten();\n\n    if (resumeSignal != null) {\n      resumeSignal.whenComplete(resume);\n    }\n  }\n\n  bool get isPaused => _pauseCount > 0;\n\n  void resume() {\n    if (_canceled || !isPaused) return;\n    --_pauseCount;\n    _tryResume();\n  }\n\n  void _tryResume() {\n    if (_onData != null && !isPaused) {\n      _target.addEventListener(_eventType, _onData, _useCapture);\n    }\n  }\n\n  void _unlisten() {\n    if (_onData != null) {\n      _target.removeEventListener(_eventType, _onData, _useCapture);\n    }\n  }\n\n  Future asFuture([var futureValue]) {\n    // We just need a future that will never succeed or fail.\n    Completer completer = new Completer();\n    return completer.future;\n  }\n}\n\n/**\n * A stream of custom events, which enables the user to \"fire\" (add) their own\n * custom events to a stream.\n */\nabstract class CustomStream<T extends Event> implements Stream<T> {\n  /**\n   * Add the following custom event to the stream for dispatching to interested\n   * listeners.\n   */\n  void add(T event);\n}\n\nclass _CustomEventStreamImpl<T extends Event> extends Stream<T>\n    implements CustomStream<T> {\n  StreamController<T> _streamController;\n  /** The type of event this stream is providing (e.g. \"keydown\"). */\n  String _type;\n\n  _CustomEventStreamImpl(String type) {\n    _type = type;\n    _streamController = new StreamController.broadcast(sync: true);\n  }\n\n  // Delegate all regular Stream behavior to our wrapped Stream.\n  StreamSubscription<T> listen(void onData(T event),\n      { Function onError,\n        void onDone(),\n        bool cancelOnError}) {\n    return _streamController.stream.listen(onData, onError: onError,\n        onDone: onDone, cancelOnError: cancelOnError);\n  }\n\n  Stream<T> asBroadcastStream({void onListen(StreamSubscription subscription),\n                               void onCancel(StreamSubscription subscription)})\n      => _streamController.stream;\n\n  bool get isBroadcast => true;\n\n  void add(T event) {\n    if (event.type == _type) _streamController.add(event);\n  }\n}\n\nclass _CustomKeyEventStreamImpl extends _CustomEventStreamImpl<KeyEvent>\n    implements CustomStream<KeyEvent> {\n  _CustomKeyEventStreamImpl(String type) : super(type);\n\n  void add(KeyEvent event) {\n    if (event.type == _type) {\n      event.currentTarget.dispatchEvent(event._parent);\n      _streamController.add(event);\n    }\n  }\n}\n\n/**\n * A pool of streams whose events are unified and emitted through a central\n * stream.\n */\n// TODO (efortuna): Remove this when Issue 12218 is addressed.\nclass _StreamPool<T> {\n  StreamController<T> _controller;\n\n  /// Subscriptions to the streams that make up the pool.\n  var _subscriptions = new Map<Stream<T>, StreamSubscription<T>>();\n\n  /**\n   * Creates a new stream pool where [stream] can be listened to more than\n   * once.\n   *\n   * Any events from buffered streams in the pool will be emitted immediately,\n   * regardless of whether [stream] has any subscribers.\n   */\n  _StreamPool.broadcast() {\n    _controller = new StreamController<T>.broadcast(sync: true,\n        onCancel: close);\n  }\n\n  /**\n   * The stream through which all events from streams in the pool are emitted.\n   */\n  Stream<T> get stream => _controller.stream;\n\n  /**\n   * Adds [stream] as a member of this pool.\n   *\n   * Any events from [stream] will be emitted through [this.stream]. If\n   * [stream] is sync, they'll be emitted synchronously; if [stream] is async,\n   * they'll be emitted asynchronously.\n   */\n  void add(Stream<T> stream) {\n    if (_subscriptions.containsKey(stream)) return;\n    _subscriptions[stream] = stream.listen(_controller.add,\n        onError: _controller.addError,\n        onDone: () => remove(stream));\n  }\n\n  /** Removes [stream] as a member of this pool. */\n  void remove(Stream<T> stream) {\n    var subscription = _subscriptions.remove(stream);\n    if (subscription != null) subscription.cancel();\n  }\n\n  /** Removes all streams from this pool and closes [stream]. */\n  void close() {\n    for (var subscription in _subscriptions.values) {\n      subscription.cancel();\n    }\n    _subscriptions.clear();\n    _controller.close();\n  }\n}\n\n/**\n * A factory to expose DOM events as streams, where the DOM event name has to\n * be determined on the fly (for example, mouse wheel events).\n */\nclass _CustomEventStreamProvider<T extends Event>\n    implements EventStreamProvider<T> {\n\n  final _eventTypeGetter;\n  const _CustomEventStreamProvider(this._eventTypeGetter);\n\n  Stream<T> forTarget(EventTarget e, {bool useCapture: false}) {\n    return new _EventStream(e, _eventTypeGetter(e), useCapture);\n  }\n\n  ElementStream<T> forElement(Element e, {bool useCapture: false}) {\n    return new _ElementEventStreamImpl(e, _eventTypeGetter(e), useCapture);\n  }\n\n  ElementStream<T> _forElementList(ElementList e,\n      {bool useCapture: false}) {\n    return new _ElementListEventStreamImpl(e, _eventTypeGetter(e), useCapture);\n  }\n\n  String getEventType(EventTarget target) {\n    return _eventTypeGetter(target);\n  }\n\n  String get _eventType =>\n      throw new UnsupportedError('Access type through getEventType method.');\n}\n// DO NOT EDIT- this file is generated from running tool/generator.sh.\n\n// Copyright (c) 2013, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n/**\n * A Dart DOM validator generated from Caja whitelists.\n *\n * This contains a whitelist of known HTML tagNames and attributes and will only\n * accept known good values.\n *\n * See also:\n *\n * * <https://code.google.com/p/google-caja/wiki/CajaWhitelists>\n */\nclass _Html5NodeValidator implements NodeValidator {\n\n  static final Set<String> _allowedElements = new Set.from([\n    'A',\n    'ABBR',\n    'ACRONYM',\n    'ADDRESS',\n    'AREA',\n    'ARTICLE',\n    'ASIDE',\n    'AUDIO',\n    'B',\n    'BDI',\n    'BDO',\n    'BIG',\n    'BLOCKQUOTE',\n    'BR',\n    'BUTTON',\n    'CANVAS',\n    'CAPTION',\n    'CENTER',\n    'CITE',\n    'CODE',\n    'COL',\n    'COLGROUP',\n    'COMMAND',\n    'DATA',\n    'DATALIST',\n    'DD',\n    'DEL',\n    'DETAILS',\n    'DFN',\n    'DIR',\n    'DIV',\n    'DL',\n    'DT',\n    'EM',\n    'FIELDSET',\n    'FIGCAPTION',\n    'FIGURE',\n    'FONT',\n    'FOOTER',\n    'FORM',\n    'H1',\n    'H2',\n    'H3',\n    'H4',\n    'H5',\n    'H6',\n    'HEADER',\n    'HGROUP',\n    'HR',\n    'I',\n    'IFRAME',\n    'IMG',\n    'INPUT',\n    'INS',\n    'KBD',\n    'LABEL',\n    'LEGEND',\n    'LI',\n    'MAP',\n    'MARK',\n    'MENU',\n    'METER',\n    'NAV',\n    'NOBR',\n    'OL',\n    'OPTGROUP',\n    'OPTION',\n    'OUTPUT',\n    'P',\n    'PRE',\n    'PROGRESS',\n    'Q',\n    'S',\n    'SAMP',\n    'SECTION',\n    'SELECT',\n    'SMALL',\n    'SOURCE',\n    'SPAN',\n    'STRIKE',\n    'STRONG',\n    'SUB',\n    'SUMMARY',\n    'SUP',\n    'TABLE',\n    'TBODY',\n    'TD',\n    'TEXTAREA',\n    'TFOOT',\n    'TH',\n    'THEAD',\n    'TIME',\n    'TR',\n    'TRACK',\n    'TT',\n    'U',\n    'UL',\n    'VAR',\n    'VIDEO',\n    'WBR',\n  ]);\n\n  static const _standardAttributes = const <String>[\n    '*::class',\n    '*::dir',\n    '*::draggable',\n    '*::hidden',\n    '*::id',\n    '*::inert',\n    '*::itemprop',\n    '*::itemref',\n    '*::itemscope',\n    '*::lang',\n    '*::spellcheck',\n    '*::title',\n    '*::translate',\n    'A::accesskey',\n    'A::coords',\n    'A::hreflang',\n    'A::name',\n    'A::shape',\n    'A::tabindex',\n    'A::target',\n    'A::type',\n    'AREA::accesskey',\n    'AREA::alt',\n    'AREA::coords',\n    'AREA::nohref',\n    'AREA::shape',\n    'AREA::tabindex',\n    'AREA::target',\n    'AUDIO::controls',\n    'AUDIO::loop',\n    'AUDIO::mediagroup',\n    'AUDIO::muted',\n    'AUDIO::preload',\n    'BDO::dir',\n    'BODY::alink',\n    'BODY::bgcolor',\n    'BODY::link',\n    'BODY::text',\n    'BODY::vlink',\n    'BR::clear',\n    'BUTTON::accesskey',\n    'BUTTON::disabled',\n    'BUTTON::name',\n    'BUTTON::tabindex',\n    'BUTTON::type',\n    'BUTTON::value',\n    'CANVAS::height',\n    'CANVAS::width',\n    'CAPTION::align',\n    'COL::align',\n    'COL::char',\n    'COL::charoff',\n    'COL::span',\n    'COL::valign',\n    'COL::width',\n    'COLGROUP::align',\n    'COLGROUP::char',\n    'COLGROUP::charoff',\n    'COLGROUP::span',\n    'COLGROUP::valign',\n    'COLGROUP::width',\n    'COMMAND::checked',\n    'COMMAND::command',\n    'COMMAND::disabled',\n    'COMMAND::label',\n    'COMMAND::radiogroup',\n    'COMMAND::type',\n    'DATA::value',\n    'DEL::datetime',\n    'DETAILS::open',\n    'DIR::compact',\n    'DIV::align',\n    'DL::compact',\n    'FIELDSET::disabled',\n    'FONT::color',\n    'FONT::face',\n    'FONT::size',\n    'FORM::accept',\n    'FORM::autocomplete',\n    'FORM::enctype',\n    'FORM::method',\n    'FORM::name',\n    'FORM::novalidate',\n    'FORM::target',\n    'FRAME::name',\n    'H1::align',\n    'H2::align',\n    'H3::align',\n    'H4::align',\n    'H5::align',\n    'H6::align',\n    'HR::align',\n    'HR::noshade',\n    'HR::size',\n    'HR::width',\n    'HTML::version',\n    'IFRAME::align',\n    'IFRAME::frameborder',\n    'IFRAME::height',\n    'IFRAME::marginheight',\n    'IFRAME::marginwidth',\n    'IFRAME::width',\n    'IMG::align',\n    'IMG::alt',\n    'IMG::border',\n    'IMG::height',\n    'IMG::hspace',\n    'IMG::ismap',\n    'IMG::name',\n    'IMG::usemap',\n    'IMG::vspace',\n    'IMG::width',\n    'INPUT::accept',\n    'INPUT::accesskey',\n    'INPUT::align',\n    'INPUT::alt',\n    'INPUT::autocomplete',\n    'INPUT::checked',\n    'INPUT::disabled',\n    'INPUT::inputmode',\n    'INPUT::ismap',\n    'INPUT::list',\n    'INPUT::max',\n    'INPUT::maxlength',\n    'INPUT::min',\n    'INPUT::multiple',\n    'INPUT::name',\n    'INPUT::placeholder',\n    'INPUT::readonly',\n    'INPUT::required',\n    'INPUT::size',\n    'INPUT::step',\n    'INPUT::tabindex',\n    'INPUT::type',\n    'INPUT::usemap',\n    'INPUT::value',\n    'INS::datetime',\n    'KEYGEN::disabled',\n    'KEYGEN::keytype',\n    'KEYGEN::name',\n    'LABEL::accesskey',\n    'LABEL::for',\n    'LEGEND::accesskey',\n    'LEGEND::align',\n    'LI::type',\n    'LI::value',\n    'LINK::sizes',\n    'MAP::name',\n    'MENU::compact',\n    'MENU::label',\n    'MENU::type',\n    'METER::high',\n    'METER::low',\n    'METER::max',\n    'METER::min',\n    'METER::value',\n    'OBJECT::typemustmatch',\n    'OL::compact',\n    'OL::reversed',\n    'OL::start',\n    'OL::type',\n    'OPTGROUP::disabled',\n    'OPTGROUP::label',\n    'OPTION::disabled',\n    'OPTION::label',\n    'OPTION::selected',\n    'OPTION::value',\n    'OUTPUT::for',\n    'OUTPUT::name',\n    'P::align',\n    'PRE::width',\n    'PROGRESS::max',\n    'PROGRESS::min',\n    'PROGRESS::value',\n    'SELECT::autocomplete',\n    'SELECT::disabled',\n    'SELECT::multiple',\n    'SELECT::name',\n    'SELECT::required',\n    'SELECT::size',\n    'SELECT::tabindex',\n    'SOURCE::type',\n    'TABLE::align',\n    'TABLE::bgcolor',\n    'TABLE::border',\n    'TABLE::cellpadding',\n    'TABLE::cellspacing',\n    'TABLE::frame',\n    'TABLE::rules',\n    'TABLE::summary',\n    'TABLE::width',\n    'TBODY::align',\n    'TBODY::char',\n    'TBODY::charoff',\n    'TBODY::valign',\n    'TD::abbr',\n    'TD::align',\n    'TD::axis',\n    'TD::bgcolor',\n    'TD::char',\n    'TD::charoff',\n    'TD::colspan',\n    'TD::headers',\n    'TD::height',\n    'TD::nowrap',\n    'TD::rowspan',\n    'TD::scope',\n    'TD::valign',\n    'TD::width',\n    'TEXTAREA::accesskey',\n    'TEXTAREA::autocomplete',\n    'TEXTAREA::cols',\n    'TEXTAREA::disabled',\n    'TEXTAREA::inputmode',\n    'TEXTAREA::name',\n    'TEXTAREA::placeholder',\n    'TEXTAREA::readonly',\n    'TEXTAREA::required',\n    'TEXTAREA::rows',\n    'TEXTAREA::tabindex',\n    'TEXTAREA::wrap',\n    'TFOOT::align',\n    'TFOOT::char',\n    'TFOOT::charoff',\n    'TFOOT::valign',\n    'TH::abbr',\n    'TH::align',\n    'TH::axis',\n    'TH::bgcolor',\n    'TH::char',\n    'TH::charoff',\n    'TH::colspan',\n    'TH::headers',\n    'TH::height',\n    'TH::nowrap',\n    'TH::rowspan',\n    'TH::scope',\n    'TH::valign',\n    'TH::width',\n    'THEAD::align',\n    'THEAD::char',\n    'THEAD::charoff',\n    'THEAD::valign',\n    'TR::align',\n    'TR::bgcolor',\n    'TR::char',\n    'TR::charoff',\n    'TR::valign',\n    'TRACK::default',\n    'TRACK::kind',\n    'TRACK::label',\n    'TRACK::srclang',\n    'UL::compact',\n    'UL::type',\n    'VIDEO::controls',\n    'VIDEO::height',\n    'VIDEO::loop',\n    'VIDEO::mediagroup',\n    'VIDEO::muted',\n    'VIDEO::preload',\n    'VIDEO::width',\n  ];\n\n  static const _uriAttributes = const <String>[\n    'A::href',\n    'AREA::href',\n    'BLOCKQUOTE::cite',\n    'BODY::background',\n    'COMMAND::icon',\n    'DEL::cite',\n    'FORM::action',\n    'IMG::src',\n    'INPUT::src',\n    'INS::cite',\n    'Q::cite',\n    'VIDEO::poster',\n  ];\n\n  final UriPolicy uriPolicy;\n\n  static final Map<String, Function> _attributeValidators = {};\n\n  /**\n   * All known URI attributes will be validated against the UriPolicy, if\n   * [uriPolicy] is null then a default UriPolicy will be used.\n   */\n  _Html5NodeValidator({UriPolicy uriPolicy})\n      :uriPolicy = uriPolicy != null ? uriPolicy : new UriPolicy() {\n\n    if (_attributeValidators.isEmpty) {\n      for (var attr in _standardAttributes) {\n        _attributeValidators[attr] = _standardAttributeValidator;\n      }\n\n      for (var attr in _uriAttributes) {\n        _attributeValidators[attr] = _uriAttributeValidator;\n      }\n    }\n  }\n\n  bool allowsElement(Element element) {\n    return _allowedElements.contains(element.tagName);\n  }\n\n  bool allowsAttribute(Element element, String attributeName, String value) {\n    var tagName = element.tagName;\n    var validator = _attributeValidators['$tagName::$attributeName'];\n    if (validator == null) {\n      validator = _attributeValidators['*::$attributeName'];\n    }\n    if (validator == null) {\n      return false;\n    }\n    return validator(element, attributeName, value, this);\n  }\n\n  static bool _standardAttributeValidator(Element element, String attributeName,\n      String value, _Html5NodeValidator context) {\n    return true;\n  }\n\n  static bool _uriAttributeValidator(Element element, String attributeName,\n      String value, _Html5NodeValidator context) {\n    return context.uriPolicy.allowsUri(value);\n  }\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\nabstract class ImmutableListMixin<E> implements List<E> {\n  // From Iterable<$E>:\n  Iterator<E> get iterator {\n    // Note: NodeLists are not fixed size. And most probably length shouldn't\n    // be cached in both iterator _and_ forEach method. For now caching it\n    // for consistency.\n    return new FixedSizeListIterator<E>(this);\n  }\n\n  // From Collection<E>:\n  void add(E value) {\n    throw new UnsupportedError(\"Cannot add to immutable List.\");\n  }\n\n  void addAll(Iterable<E> iterable) {\n    throw new UnsupportedError(\"Cannot add to immutable List.\");\n  }\n\n  // From List<E>:\n  void sort([int compare(E a, E b)]) {\n    throw new UnsupportedError(\"Cannot sort immutable List.\");\n  }\n\n  void shuffle([Random random]) {\n    throw new UnsupportedError(\"Cannot shuffle immutable List.\");\n  }\n\n  void insert(int index, E element) {\n    throw new UnsupportedError(\"Cannot add to immutable List.\");\n  }\n\n  void insertAll(int index, Iterable<E> iterable) {\n    throw new UnsupportedError(\"Cannot add to immutable List.\");\n  }\n\n  void setAll(int index, Iterable<E> iterable) {\n    throw new UnsupportedError(\"Cannot modify an immutable List.\");\n  }\n\n  E removeAt(int pos) {\n    throw new UnsupportedError(\"Cannot remove from immutable List.\");\n  }\n\n  E removeLast() {\n    throw new UnsupportedError(\"Cannot remove from immutable List.\");\n  }\n\n  bool remove(Object object) {\n    throw new UnsupportedError(\"Cannot remove from immutable List.\");\n  }\n\n  void removeWhere(bool test(E element)) {\n    throw new UnsupportedError(\"Cannot remove from immutable List.\");\n  }\n\n  void retainWhere(bool test(E element)) {\n    throw new UnsupportedError(\"Cannot remove from immutable List.\");\n  }\n\n  void setRange(int start, int end, Iterable<E> iterable, [int skipCount = 0]) {\n    throw new UnsupportedError(\"Cannot setRange on immutable List.\");\n  }\n\n  void removeRange(int start, int end) {\n    throw new UnsupportedError(\"Cannot removeRange on immutable List.\");\n  }\n\n  void replaceRange(int start, int end, Iterable<E> iterable) {\n    throw new UnsupportedError(\"Cannot modify an immutable List.\");\n  }\n\n  void fillRange(int start, int end, [E fillValue]) {\n    throw new UnsupportedError(\"Cannot modify an immutable List.\");\n  }\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n/**\n * Defines the keycode values for keys that are returned by\n * KeyboardEvent.keyCode.\n *\n * Important note: There is substantial divergence in how different browsers\n * handle keycodes and their variants in different locales/keyboard layouts. We\n * provide these constants to help make code processing keys more readable.\n */\nabstract class KeyCode {\n  // These constant names were borrowed from Closure's Keycode enumeration\n  // class.\n  // http://closure-library.googlecode.com/svn/docs/closure_goog_events_keycodes.js.source.html\n  static const int WIN_KEY_FF_LINUX = 0;\n  static const int MAC_ENTER = 3;\n  static const int BACKSPACE = 8;\n  static const int TAB = 9;\n  /** NUM_CENTER is also NUMLOCK for FF and Safari on Mac. */\n  static const int NUM_CENTER = 12;\n  static const int ENTER = 13;\n  static const int SHIFT = 16;\n  static const int CTRL = 17;\n  static const int ALT = 18;\n  static const int PAUSE = 19;\n  static const int CAPS_LOCK = 20;\n  static const int ESC = 27;\n  static const int SPACE = 32;\n  static const int PAGE_UP = 33;\n  static const int PAGE_DOWN = 34;\n  static const int END = 35;\n  static const int HOME = 36;\n  static const int LEFT = 37;\n  static const int UP = 38;\n  static const int RIGHT = 39;\n  static const int DOWN = 40;\n  static const int NUM_NORTH_EAST = 33;\n  static const int NUM_SOUTH_EAST = 34;\n  static const int NUM_SOUTH_WEST = 35;\n  static const int NUM_NORTH_WEST = 36;\n  static const int NUM_WEST = 37;\n  static const int NUM_NORTH = 38;\n  static const int NUM_EAST = 39;\n  static const int NUM_SOUTH = 40;\n  static const int PRINT_SCREEN = 44;\n  static const int INSERT = 45;\n  static const int NUM_INSERT = 45;\n  static const int DELETE = 46;\n  static const int NUM_DELETE = 46;\n  static const int ZERO = 48;\n  static const int ONE = 49;\n  static const int TWO = 50;\n  static const int THREE = 51;\n  static const int FOUR = 52;\n  static const int FIVE = 53;\n  static const int SIX = 54;\n  static const int SEVEN = 55;\n  static const int EIGHT = 56;\n  static const int NINE = 57;\n  static const int FF_SEMICOLON = 59;\n  static const int FF_EQUALS = 61;\n  /**\n   * CAUTION: The question mark is for US-keyboard layouts. It varies\n   * for other locales and keyboard layouts.\n   */\n  static const int QUESTION_MARK = 63;\n  static const int A = 65;\n  static const int B = 66;\n  static const int C = 67;\n  static const int D = 68;\n  static const int E = 69;\n  static const int F = 70;\n  static const int G = 71;\n  static const int H = 72;\n  static const int I = 73;\n  static const int J = 74;\n  static const int K = 75;\n  static const int L = 76;\n  static const int M = 77;\n  static const int N = 78;\n  static const int O = 79;\n  static const int P = 80;\n  static const int Q = 81;\n  static const int R = 82;\n  static const int S = 83;\n  static const int T = 84;\n  static const int U = 85;\n  static const int V = 86;\n  static const int W = 87;\n  static const int X = 88;\n  static const int Y = 89;\n  static const int Z = 90;\n  static const int META = 91;\n  static const int WIN_KEY_LEFT = 91;\n  static const int WIN_KEY_RIGHT = 92;\n  static const int CONTEXT_MENU = 93;\n  static const int NUM_ZERO = 96;\n  static const int NUM_ONE = 97;\n  static const int NUM_TWO = 98;\n  static const int NUM_THREE = 99;\n  static const int NUM_FOUR = 100;\n  static const int NUM_FIVE = 101;\n  static const int NUM_SIX = 102;\n  static const int NUM_SEVEN = 103;\n  static const int NUM_EIGHT = 104;\n  static const int NUM_NINE = 105;\n  static const int NUM_MULTIPLY = 106;\n  static const int NUM_PLUS = 107;\n  static const int NUM_MINUS = 109;\n  static const int NUM_PERIOD = 110;\n  static const int NUM_DIVISION = 111;\n  static const int F1 = 112;\n  static const int F2 = 113;\n  static const int F3 = 114;\n  static const int F4 = 115;\n  static const int F5 = 116;\n  static const int F6 = 117;\n  static const int F7 = 118;\n  static const int F8 = 119;\n  static const int F9 = 120;\n  static const int F10 = 121;\n  static const int F11 = 122;\n  static const int F12 = 123;\n  static const int NUMLOCK = 144;\n  static const int SCROLL_LOCK = 145;\n\n  // OS-specific media keys like volume controls and browser controls.\n  static const int FIRST_MEDIA_KEY = 166;\n  static const int LAST_MEDIA_KEY = 183;\n\n  /**\n   * CAUTION: This constant requires localization for other locales and keyboard\n   * layouts.\n   */\n  static const int SEMICOLON = 186;\n  /**\n   * CAUTION: This constant requires localization for other locales and keyboard\n   * layouts.\n   */\n  static const int DASH = 189;\n  /**\n   * CAUTION: This constant requires localization for other locales and keyboard\n   * layouts.\n   */\n  static const int EQUALS = 187;\n  /**\n   * CAUTION: This constant requires localization for other locales and keyboard\n   * layouts.\n   */\n  static const int COMMA = 188;\n  /**\n   * CAUTION: This constant requires localization for other locales and keyboard\n   * layouts.\n   */\n  static const int PERIOD = 190;\n  /**\n   * CAUTION: This constant requires localization for other locales and keyboard\n   * layouts.\n   */\n  static const int SLASH = 191;\n  /**\n   * CAUTION: This constant requires localization for other locales and keyboard\n   * layouts.\n   */\n  static const int APOSTROPHE = 192;\n  /**\n   * CAUTION: This constant requires localization for other locales and keyboard\n   * layouts.\n   */\n  static const int TILDE = 192;\n  /**\n   * CAUTION: This constant requires localization for other locales and keyboard\n   * layouts.\n   */\n  static const int SINGLE_QUOTE = 222;\n  /**\n   * CAUTION: This constant requires localization for other locales and keyboard\n   * layouts.\n   */\n  static const int OPEN_SQUARE_BRACKET = 219;\n  /**\n   * CAUTION: This constant requires localization for other locales and keyboard\n   * layouts.\n   */\n  static const int BACKSLASH = 220;\n  /**\n   * CAUTION: This constant requires localization for other locales and keyboard\n   * layouts.\n   */\n  static const int CLOSE_SQUARE_BRACKET = 221;\n  static const int WIN_KEY = 224;\n  static const int MAC_FF_META = 224;\n  static const int WIN_IME = 229;\n\n  /** A sentinel value if the keycode could not be determined. */\n  static const int UNKNOWN = -1;\n\n  /**\n   * Returns true if the keyCode produces a (US keyboard) character.\n   * Note: This does not (yet) cover characters on non-US keyboards (Russian,\n   * Hebrew, etc.).\n   */\n  static bool isCharacterKey(int keyCode) {\n    if ((keyCode >= ZERO && keyCode <= NINE) ||\n        (keyCode >= NUM_ZERO && keyCode <= NUM_MULTIPLY) ||\n        (keyCode >= A && keyCode <= Z)) {\n      return true;\n    }\n\n    // Safari sends zero key code for non-latin characters.\n    if (Device.isWebKit && keyCode == 0) {\n      return true;\n    }\n\n    return (keyCode == SPACE || keyCode == QUESTION_MARK || keyCode == NUM_PLUS\n        || keyCode == NUM_MINUS || keyCode == NUM_PERIOD ||\n        keyCode == NUM_DIVISION || keyCode == SEMICOLON ||\n        keyCode == FF_SEMICOLON || keyCode == DASH || keyCode == EQUALS ||\n        keyCode == FF_EQUALS || keyCode == COMMA || keyCode == PERIOD ||\n        keyCode == SLASH || keyCode == APOSTROPHE || keyCode == SINGLE_QUOTE ||\n        keyCode == OPEN_SQUARE_BRACKET || keyCode == BACKSLASH ||\n        keyCode == CLOSE_SQUARE_BRACKET);\n  }\n\n  /**\n   * Experimental helper function for converting keyCodes to keyNames for the\n   * keyIdentifier attribute still used in browsers not updated with current\n   * spec. This is an imperfect conversion! It will need to be refined, but\n   * hopefully it can just completely go away once all the browsers update to\n   * follow the DOM3 spec.\n   */\n  static String _convertKeyCodeToKeyName(int keyCode) {\n    switch(keyCode) {\n      case KeyCode.ALT: return _KeyName.ALT;\n      case KeyCode.BACKSPACE: return _KeyName.BACKSPACE;\n      case KeyCode.CAPS_LOCK: return _KeyName.CAPS_LOCK;\n      case KeyCode.CTRL: return _KeyName.CONTROL;\n      case KeyCode.DELETE: return _KeyName.DEL;\n      case KeyCode.DOWN: return _KeyName.DOWN;\n      case KeyCode.END: return _KeyName.END;\n      case KeyCode.ENTER: return _KeyName.ENTER;\n      case KeyCode.ESC: return _KeyName.ESC;\n      case KeyCode.F1: return _KeyName.F1;\n      case KeyCode.F2: return _KeyName.F2;\n      case KeyCode.F3: return _KeyName.F3;\n      case KeyCode.F4: return _KeyName.F4;\n      case KeyCode.F5: return _KeyName.F5;\n      case KeyCode.F6: return _KeyName.F6;\n      case KeyCode.F7: return _KeyName.F7;\n      case KeyCode.F8: return _KeyName.F8;\n      case KeyCode.F9: return _KeyName.F9;\n      case KeyCode.F10: return _KeyName.F10;\n      case KeyCode.F11: return _KeyName.F11;\n      case KeyCode.F12: return _KeyName.F12;\n      case KeyCode.HOME: return _KeyName.HOME;\n      case KeyCode.INSERT: return _KeyName.INSERT;\n      case KeyCode.LEFT: return _KeyName.LEFT;\n      case KeyCode.META: return _KeyName.META;\n      case KeyCode.NUMLOCK: return _KeyName.NUM_LOCK;\n      case KeyCode.PAGE_DOWN: return _KeyName.PAGE_DOWN;\n      case KeyCode.PAGE_UP: return _KeyName.PAGE_UP;\n      case KeyCode.PAUSE: return _KeyName.PAUSE;\n      case KeyCode.PRINT_SCREEN: return _KeyName.PRINT_SCREEN;\n      case KeyCode.RIGHT: return _KeyName.RIGHT;\n      case KeyCode.SCROLL_LOCK: return _KeyName.SCROLL;\n      case KeyCode.SHIFT: return _KeyName.SHIFT;\n      case KeyCode.SPACE: return _KeyName.SPACEBAR;\n      case KeyCode.TAB: return _KeyName.TAB;\n      case KeyCode.UP: return _KeyName.UP;\n      case KeyCode.WIN_IME:\n      case KeyCode.WIN_KEY:\n      case KeyCode.WIN_KEY_LEFT:\n      case KeyCode.WIN_KEY_RIGHT:\n        return _KeyName.WIN;\n      default: return _KeyName.UNIDENTIFIED;\n    }\n    return _KeyName.UNIDENTIFIED;\n  }\n}\n// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n/**\n * Defines the standard key locations returned by\n * KeyboardEvent.getKeyLocation.\n */\nabstract class KeyLocation {\n\n  /**\n   * The event key is not distinguished as the left or right version\n   * of the key, and did not originate from the numeric keypad (or did not\n   * originate with a virtual key corresponding to the numeric keypad).\n   */\n  static const int STANDARD = 0;\n\n  /**\n   * The event key is in the left key location.\n   */\n  static const int LEFT = 1;\n\n  /**\n   * The event key is in the right key location.\n   */\n  static const int RIGHT = 2;\n\n  /**\n   * The event key originated on the numeric keypad or with a virtual key\n   * corresponding to the numeric keypad.\n   */\n  static const int NUMPAD = 3;\n\n  /**\n   * The event key originated on a mobile device, either on a physical\n   * keypad or a virtual keyboard.\n   */\n  static const int MOBILE = 4;\n\n  /**\n   * The event key originated on a game controller or a joystick on a mobile\n   * device.\n   */\n  static const int JOYSTICK = 5;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n/**\n * Defines the standard keyboard identifier names for keys that are returned\n * by KeyboardEvent.getKeyboardIdentifier when the key does not have a direct\n * unicode mapping.\n */\nabstract class _KeyName {\n\n  /** The Accept (Commit, OK) key */\n  static const String ACCEPT = \"Accept\";\n\n  /** The Add key */\n  static const String ADD = \"Add\";\n\n  /** The Again key */\n  static const String AGAIN = \"Again\";\n\n  /** The All Candidates key */\n  static const String ALL_CANDIDATES = \"AllCandidates\";\n\n  /** The Alphanumeric key */\n  static const String ALPHANUMERIC = \"Alphanumeric\";\n\n  /** The Alt (Menu) key */\n  static const String ALT = \"Alt\";\n\n  /** The Alt-Graph key */\n  static const String ALT_GRAPH = \"AltGraph\";\n\n  /** The Application key */\n  static const String APPS = \"Apps\";\n\n  /** The ATTN key */\n  static const String ATTN = \"Attn\";\n\n  /** The Browser Back key */\n  static const String BROWSER_BACK = \"BrowserBack\";\n\n  /** The Browser Favorites key */\n  static const String BROWSER_FAVORTIES = \"BrowserFavorites\";\n\n  /** The Browser Forward key */\n  static const String BROWSER_FORWARD = \"BrowserForward\";\n\n  /** The Browser Home key */\n  static const String BROWSER_NAME = \"BrowserHome\";\n\n  /** The Browser Refresh key */\n  static const String BROWSER_REFRESH = \"BrowserRefresh\";\n\n  /** The Browser Search key */\n  static const String BROWSER_SEARCH = \"BrowserSearch\";\n\n  /** The Browser Stop key */\n  static const String BROWSER_STOP = \"BrowserStop\";\n\n  /** The Camera key */\n  static const String CAMERA = \"Camera\";\n\n  /** The Caps Lock (Capital) key */\n  static const String CAPS_LOCK = \"CapsLock\";\n\n  /** The Clear key */\n  static const String CLEAR = \"Clear\";\n\n  /** The Code Input key */\n  static const String CODE_INPUT = \"CodeInput\";\n\n  /** The Compose key */\n  static const String COMPOSE = \"Compose\";\n\n  /** The Control (Ctrl) key */\n  static const String CONTROL = \"Control\";\n\n  /** The Crsel key */\n  static const String CRSEL = \"Crsel\";\n\n  /** The Convert key */\n  static const String CONVERT = \"Convert\";\n\n  /** The Copy key */\n  static const String COPY = \"Copy\";\n\n  /** The Cut key */\n  static const String CUT = \"Cut\";\n\n  /** The Decimal key */\n  static const String DECIMAL = \"Decimal\";\n\n  /** The Divide key */\n  static const String DIVIDE = \"Divide\";\n\n  /** The Down Arrow key */\n  static const String DOWN = \"Down\";\n\n  /** The diagonal Down-Left Arrow key */\n  static const String DOWN_LEFT = \"DownLeft\";\n\n  /** The diagonal Down-Right Arrow key */\n  static const String DOWN_RIGHT = \"DownRight\";\n\n  /** The Eject key */\n  static const String EJECT = \"Eject\";\n\n  /** The End key */\n  static const String END = \"End\";\n\n  /**\n   * The Enter key. Note: This key value must also be used for the Return\n   *  (Macintosh numpad) key\n   */\n  static const String ENTER = \"Enter\";\n\n  /** The Erase EOF key */\n  static const String ERASE_EOF= \"EraseEof\";\n\n  /** The Execute key */\n  static const String EXECUTE = \"Execute\";\n\n  /** The Exsel key */\n  static const String EXSEL = \"Exsel\";\n\n  /** The Function switch key */\n  static const String FN = \"Fn\";\n\n  /** The F1 key */\n  static const String F1 = \"F1\";\n\n  /** The F2 key */\n  static const String F2 = \"F2\";\n\n  /** The F3 key */\n  static const String F3 = \"F3\";\n\n  /** The F4 key */\n  static const String F4 = \"F4\";\n\n  /** The F5 key */\n  static const String F5 = \"F5\";\n\n  /** The F6 key */\n  static const String F6 = \"F6\";\n\n  /** The F7 key */\n  static const String F7 = \"F7\";\n\n  /** The F8 key */\n  static const String F8 = \"F8\";\n\n  /** The F9 key */\n  static const String F9 = \"F9\";\n\n  /** The F10 key */\n  static const String F10 = \"F10\";\n\n  /** The F11 key */\n  static const String F11 = \"F11\";\n\n  /** The F12 key */\n  static const String F12 = \"F12\";\n\n  /** The F13 key */\n  static const String F13 = \"F13\";\n\n  /** The F14 key */\n  static const String F14 = \"F14\";\n\n  /** The F15 key */\n  static const String F15 = \"F15\";\n\n  /** The F16 key */\n  static const String F16 = \"F16\";\n\n  /** The F17 key */\n  static const String F17 = \"F17\";\n\n  /** The F18 key */\n  static const String F18 = \"F18\";\n\n  /** The F19 key */\n  static const String F19 = \"F19\";\n\n  /** The F20 key */\n  static const String F20 = \"F20\";\n\n  /** The F21 key */\n  static const String F21 = \"F21\";\n\n  /** The F22 key */\n  static const String F22 = \"F22\";\n\n  /** The F23 key */\n  static const String F23 = \"F23\";\n\n  /** The F24 key */\n  static const String F24 = \"F24\";\n\n  /** The Final Mode (Final) key used on some asian keyboards */\n  static const String FINAL_MODE = \"FinalMode\";\n\n  /** The Find key */\n  static const String FIND = \"Find\";\n\n  /** The Full-Width Characters key */\n  static const String FULL_WIDTH = \"FullWidth\";\n\n  /** The Half-Width Characters key */\n  static const String HALF_WIDTH = \"HalfWidth\";\n\n  /** The Hangul (Korean characters) Mode key */\n  static const String HANGUL_MODE = \"HangulMode\";\n\n  /** The Hanja (Korean characters) Mode key */\n  static const String HANJA_MODE = \"HanjaMode\";\n\n  /** The Help key */\n  static const String HELP = \"Help\";\n\n  /** The Hiragana (Japanese Kana characters) key */\n  static const String HIRAGANA = \"Hiragana\";\n\n  /** The Home key */\n  static const String HOME = \"Home\";\n\n  /** The Insert (Ins) key */\n  static const String INSERT = \"Insert\";\n\n  /** The Japanese-Hiragana key */\n  static const String JAPANESE_HIRAGANA = \"JapaneseHiragana\";\n\n  /** The Japanese-Katakana key */\n  static const String JAPANESE_KATAKANA = \"JapaneseKatakana\";\n\n  /** The Japanese-Romaji key */\n  static const String JAPANESE_ROMAJI = \"JapaneseRomaji\";\n\n  /** The Junja Mode key */\n  static const String JUNJA_MODE = \"JunjaMode\";\n\n  /** The Kana Mode (Kana Lock) key */\n  static const String KANA_MODE = \"KanaMode\";\n\n  /**\n   * The Kanji (Japanese name for ideographic characters of Chinese origin)\n   * Mode key\n   */\n  static const String KANJI_MODE = \"KanjiMode\";\n\n  /** The Katakana (Japanese Kana characters) key */\n  static const String KATAKANA = \"Katakana\";\n\n  /** The Start Application One key */\n  static const String LAUNCH_APPLICATION_1 = \"LaunchApplication1\";\n\n  /** The Start Application Two key */\n  static const String LAUNCH_APPLICATION_2 = \"LaunchApplication2\";\n\n  /** The Start Mail key */\n  static const String LAUNCH_MAIL = \"LaunchMail\";\n\n  /** The Left Arrow key */\n  static const String LEFT = \"Left\";\n\n  /** The Menu key */\n  static const String MENU = \"Menu\";\n\n  /**\n   * The Meta key. Note: This key value shall be also used for the Apple\n   * Command key\n   */\n  static const String META = \"Meta\";\n\n  /** The Media Next Track key */\n  static const String MEDIA_NEXT_TRACK = \"MediaNextTrack\";\n\n  /** The Media Play Pause key */\n  static const String MEDIA_PAUSE_PLAY = \"MediaPlayPause\";\n\n  /** The Media Previous Track key */\n  static const String MEDIA_PREVIOUS_TRACK = \"MediaPreviousTrack\";\n\n  /** The Media Stop key */\n  static const String MEDIA_STOP = \"MediaStop\";\n\n  /** The Mode Change key */\n  static const String MODE_CHANGE = \"ModeChange\";\n\n  /** The Next Candidate function key */\n  static const String NEXT_CANDIDATE = \"NextCandidate\";\n\n  /** The Nonconvert (Don't Convert) key */\n  static const String NON_CONVERT = \"Nonconvert\";\n\n  /** The Number Lock key */\n  static const String NUM_LOCK = \"NumLock\";\n\n  /** The Page Down (Next) key */\n  static const String PAGE_DOWN = \"PageDown\";\n\n  /** The Page Up key */\n  static const String PAGE_UP = \"PageUp\";\n\n  /** The Paste key */\n  static const String PASTE = \"Paste\";\n\n  /** The Pause key */\n  static const String PAUSE = \"Pause\";\n\n  /** The Play key */\n  static const String PLAY = \"Play\";\n\n  /**\n   * The Power key. Note: Some devices may not expose this key to the\n   * operating environment\n   */\n  static const String POWER = \"Power\";\n\n  /** The Previous Candidate function key */\n  static const String PREVIOUS_CANDIDATE = \"PreviousCandidate\";\n\n  /** The Print Screen (PrintScrn, SnapShot) key */\n  static const String PRINT_SCREEN = \"PrintScreen\";\n\n  /** The Process key */\n  static const String PROCESS = \"Process\";\n\n  /** The Props key */\n  static const String PROPS = \"Props\";\n\n  /** The Right Arrow key */\n  static const String RIGHT = \"Right\";\n\n  /** The Roman Characters function key */\n  static const String ROMAN_CHARACTERS = \"RomanCharacters\";\n\n  /** The Scroll Lock key */\n  static const String SCROLL = \"Scroll\";\n\n  /** The Select key */\n  static const String SELECT = \"Select\";\n\n  /** The Select Media key */\n  static const String SELECT_MEDIA = \"SelectMedia\";\n\n  /** The Separator key */\n  static const String SEPARATOR = \"Separator\";\n\n  /** The Shift key */\n  static const String SHIFT = \"Shift\";\n\n  /** The Soft1 key */\n  static const String SOFT_1 = \"Soft1\";\n\n  /** The Soft2 key */\n  static const String SOFT_2 = \"Soft2\";\n\n  /** The Soft3 key */\n  static const String SOFT_3 = \"Soft3\";\n\n  /** The Soft4 key */\n  static const String SOFT_4 = \"Soft4\";\n\n  /** The Stop key */\n  static const String STOP = \"Stop\";\n\n  /** The Subtract key */\n  static const String SUBTRACT = \"Subtract\";\n\n  /** The Symbol Lock key */\n  static const String SYMBOL_LOCK = \"SymbolLock\";\n\n  /** The Up Arrow key */\n  static const String UP = \"Up\";\n\n  /** The diagonal Up-Left Arrow key */\n  static const String UP_LEFT = \"UpLeft\";\n\n  /** The diagonal Up-Right Arrow key */\n  static const String UP_RIGHT = \"UpRight\";\n\n  /** The Undo key */\n  static const String UNDO = \"Undo\";\n\n  /** The Volume Down key */\n  static const String VOLUME_DOWN = \"VolumeDown\";\n\n  /** The Volume Mute key */\n  static const String VOLUMN_MUTE = \"VolumeMute\";\n\n  /** The Volume Up key */\n  static const String VOLUMN_UP = \"VolumeUp\";\n\n  /** The Windows Logo key */\n  static const String WIN = \"Win\";\n\n  /** The Zoom key */\n  static const String ZOOM = \"Zoom\";\n\n  /**\n   * The Backspace (Back) key. Note: This key value shall be also used for the\n   * key labeled 'delete' MacOS keyboards when not modified by the 'Fn' key\n   */\n  static const String BACKSPACE = \"Backspace\";\n\n  /** The Horizontal Tabulation (Tab) key */\n  static const String TAB = \"Tab\";\n\n  /** The Cancel key */\n  static const String CANCEL = \"Cancel\";\n\n  /** The Escape (Esc) key */\n  static const String ESC = \"Esc\";\n\n  /** The Space (Spacebar) key:   */\n  static const String SPACEBAR = \"Spacebar\";\n\n  /**\n   * The Delete (Del) Key. Note: This key value shall be also used for the key\n   * labeled 'delete' MacOS keyboards when modified by the 'Fn' key\n   */\n  static const String DEL = \"Del\";\n\n  /** The Combining Grave Accent (Greek Varia, Dead Grave) key */\n  static const String DEAD_GRAVE = \"DeadGrave\";\n\n  /**\n   * The Combining Acute Accent (Stress Mark, Greek Oxia, Tonos, Dead Eacute)\n   * key\n   */\n  static const String DEAD_EACUTE = \"DeadEacute\";\n\n  /** The Combining Circumflex Accent (Hat, Dead Circumflex) key */\n  static const String DEAD_CIRCUMFLEX = \"DeadCircumflex\";\n\n  /** The Combining Tilde (Dead Tilde) key */\n  static const String DEAD_TILDE = \"DeadTilde\";\n\n  /** The Combining Macron (Long, Dead Macron) key */\n  static const String DEAD_MACRON = \"DeadMacron\";\n\n  /** The Combining Breve (Short, Dead Breve) key */\n  static const String DEAD_BREVE = \"DeadBreve\";\n\n  /** The Combining Dot Above (Derivative, Dead Above Dot) key */\n  static const String DEAD_ABOVE_DOT = \"DeadAboveDot\";\n\n  /**\n   * The Combining Diaeresis (Double Dot Abode, Umlaut, Greek Dialytika,\n   * Double Derivative, Dead Diaeresis) key\n   */\n  static const String DEAD_UMLAUT = \"DeadUmlaut\";\n\n  /** The Combining Ring Above (Dead Above Ring) key */\n  static const String DEAD_ABOVE_RING = \"DeadAboveRing\";\n\n  /** The Combining Double Acute Accent (Dead Doubleacute) key */\n  static const String DEAD_DOUBLEACUTE = \"DeadDoubleacute\";\n\n  /** The Combining Caron (Hacek, V Above, Dead Caron) key */\n  static const String DEAD_CARON = \"DeadCaron\";\n\n  /** The Combining Cedilla (Dead Cedilla) key */\n  static const String DEAD_CEDILLA = \"DeadCedilla\";\n\n  /** The Combining Ogonek (Nasal Hook, Dead Ogonek) key */\n  static const String DEAD_OGONEK = \"DeadOgonek\";\n\n  /**\n   * The Combining Greek Ypogegrammeni (Greek Non-Spacing Iota Below, Iota\n   * Subscript, Dead Iota) key\n   */\n  static const String DEAD_IOTA = \"DeadIota\";\n\n  /**\n   * The Combining Katakana-Hiragana Voiced Sound Mark (Dead Voiced Sound) key\n   */\n  static const String DEAD_VOICED_SOUND = \"DeadVoicedSound\";\n\n  /**\n   * The Combining Katakana-Hiragana Semi-Voiced Sound Mark (Dead Semivoiced\n   * Sound) key\n   */\n  static const String DEC_SEMIVOICED_SOUND= \"DeadSemivoicedSound\";\n\n  /**\n   * Key value used when an implementation is unable to identify another key\n   * value, due to either hardware, platform, or software constraints\n   */\n  static const String UNIDENTIFIED = \"Unidentified\";\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n/**\n * Internal class that does the actual calculations to determine keyCode and\n * charCode for keydown, keypress, and keyup events for all browsers.\n */\nclass _KeyboardEventHandler extends EventStreamProvider<KeyEvent> {\n  // This code inspired by Closure's KeyHandling library.\n  // http://closure-library.googlecode.com/svn/docs/closure_goog_events_keyhandler.js.source.html\n\n  /**\n   * The set of keys that have been pressed down without seeing their\n   * corresponding keyup event.\n   */\n  final List<KeyboardEvent> _keyDownList = <KeyboardEvent>[];\n\n  /** The type of KeyEvent we are tracking (keyup, keydown, keypress). */\n  final String _type;\n\n  /** The element we are watching for events to happen on. */\n  final EventTarget _target;\n\n  // The distance to shift from upper case alphabet Roman letters to lower case.\n  static final int _ROMAN_ALPHABET_OFFSET = \"a\".codeUnits[0] - \"A\".codeUnits[0];\n\n  /** Custom Stream (Controller) to produce KeyEvents for the stream. */\n  _CustomKeyEventStreamImpl _stream;\n\n  static const _EVENT_TYPE = 'KeyEvent';\n\n  /**\n   * An enumeration of key identifiers currently part of the W3C draft for DOM3\n   * and their mappings to keyCodes.\n   * http://www.w3.org/TR/DOM-Level-3-Events/keyset.html#KeySet-Set\n   */\n  static const Map<String, int> _keyIdentifier = const {\n    'Up': KeyCode.UP,\n    'Down': KeyCode.DOWN,\n    'Left': KeyCode.LEFT,\n    'Right': KeyCode.RIGHT,\n    'Enter': KeyCode.ENTER,\n    'F1': KeyCode.F1,\n    'F2': KeyCode.F2,\n    'F3': KeyCode.F3,\n    'F4': KeyCode.F4,\n    'F5': KeyCode.F5,\n    'F6': KeyCode.F6,\n    'F7': KeyCode.F7,\n    'F8': KeyCode.F8,\n    'F9': KeyCode.F9,\n    'F10': KeyCode.F10,\n    'F11': KeyCode.F11,\n    'F12': KeyCode.F12,\n    'U+007F': KeyCode.DELETE,\n    'Home': KeyCode.HOME,\n    'End': KeyCode.END,\n    'PageUp': KeyCode.PAGE_UP,\n    'PageDown': KeyCode.PAGE_DOWN,\n    'Insert': KeyCode.INSERT\n  };\n\n  /** Return a stream for KeyEvents for the specified target. */\n  // Note: this actually functions like a factory constructor.\n  CustomStream<KeyEvent> forTarget(EventTarget e, {bool useCapture: false}) {\n    var handler = new _KeyboardEventHandler.initializeAllEventListeners(\n        _type, e);\n    return handler._stream;\n  }\n\n  /**\n   * General constructor, performs basic initialization for our improved\n   * KeyboardEvent controller.\n   */\n  _KeyboardEventHandler(this._type): super(_EVENT_TYPE),\n      _stream = new _CustomKeyEventStreamImpl('event'), _target = null;\n\n  /**\n   * Hook up all event listeners under the covers so we can estimate keycodes\n   * and charcodes when they are not provided.\n   */\n  _KeyboardEventHandler.initializeAllEventListeners(this._type, this._target) :\n      super(_EVENT_TYPE) {\n    Element.keyDownEvent.forTarget(_target, useCapture: true).listen(\n        processKeyDown);\n    Element.keyPressEvent.forTarget(_target, useCapture: true).listen(\n        processKeyPress);\n    Element.keyUpEvent.forTarget(_target, useCapture: true).listen(\n        processKeyUp);\n    _stream = new _CustomKeyEventStreamImpl(_type);\n  }\n\n  /** Determine if caps lock is one of the currently depressed keys. */\n  bool get _capsLockOn =>\n      _keyDownList.any((var element) => element.keyCode == KeyCode.CAPS_LOCK);\n\n  /**\n   * Given the previously recorded keydown key codes, see if we can determine\n   * the keycode of this keypress [event]. (Generally browsers only provide\n   * charCode information for keypress events, but with a little\n   * reverse-engineering, we can also determine the keyCode.) Returns\n   * KeyCode.UNKNOWN if the keycode could not be determined.\n   */\n  int _determineKeyCodeForKeypress(KeyboardEvent event) {\n    // Note: This function is a work in progress. We'll expand this function\n    // once we get more information about other keyboards.\n    for (var prevEvent in _keyDownList) {\n      if (prevEvent._shadowCharCode == event.charCode) {\n        return prevEvent.keyCode;\n      }\n      if ((event.shiftKey || _capsLockOn) && event.charCode >= \"A\".codeUnits[0]\n          && event.charCode <= \"Z\".codeUnits[0] && event.charCode +\n          _ROMAN_ALPHABET_OFFSET == prevEvent._shadowCharCode) {\n        return prevEvent.keyCode;\n      }\n    }\n    return KeyCode.UNKNOWN;\n  }\n\n  /**\n   * Given the charater code returned from a keyDown [event], try to ascertain\n   * and return the corresponding charCode for the character that was pressed.\n   * This information is not shown to the user, but used to help polyfill\n   * keypress events.\n   */\n  int _findCharCodeKeyDown(KeyboardEvent event) {\n    if (event.keyLocation == 3) { // Numpad keys.\n      switch (event.keyCode) {\n        case KeyCode.NUM_ZERO:\n          // Even though this function returns _charCodes_, for some cases the\n          // KeyCode == the charCode we want, in which case we use the keycode\n          // constant for readability.\n          return KeyCode.ZERO;\n        case KeyCode.NUM_ONE:\n          return KeyCode.ONE;\n        case KeyCode.NUM_TWO:\n          return KeyCode.TWO;\n        case KeyCode.NUM_THREE:\n          return KeyCode.THREE;\n        case KeyCode.NUM_FOUR:\n          return KeyCode.FOUR;\n        case KeyCode.NUM_FIVE:\n          return KeyCode.FIVE;\n        case KeyCode.NUM_SIX:\n          return KeyCode.SIX;\n        case KeyCode.NUM_SEVEN:\n          return KeyCode.SEVEN;\n        case KeyCode.NUM_EIGHT:\n          return KeyCode.EIGHT;\n        case KeyCode.NUM_NINE:\n          return KeyCode.NINE;\n        case KeyCode.NUM_MULTIPLY:\n          return 42; // Char code for *\n        case KeyCode.NUM_PLUS:\n          return 43; // +\n        case KeyCode.NUM_MINUS:\n          return 45; // -\n        case KeyCode.NUM_PERIOD:\n          return 46; // .\n        case KeyCode.NUM_DIVISION:\n          return 47; // /\n      }\n    } else if (event.keyCode >= 65 && event.keyCode <= 90) {\n      // Set the \"char code\" for key down as the lower case letter. Again, this\n      // will not show up for the user, but will be helpful in estimating\n      // keyCode locations and other information during the keyPress event.\n      return event.keyCode + _ROMAN_ALPHABET_OFFSET;\n    }\n    switch(event.keyCode) {\n      case KeyCode.SEMICOLON:\n        return KeyCode.FF_SEMICOLON;\n      case KeyCode.EQUALS:\n        return KeyCode.FF_EQUALS;\n      case KeyCode.COMMA:\n        return 44; // Ascii value for ,\n      case KeyCode.DASH:\n        return 45; // -\n      case KeyCode.PERIOD:\n        return 46; // .\n      case KeyCode.SLASH:\n        return 47; // /\n      case KeyCode.APOSTROPHE:\n        return 96; // `\n      case KeyCode.OPEN_SQUARE_BRACKET:\n        return 91; // [\n      case KeyCode.BACKSLASH:\n        return 92; // \\\n      case KeyCode.CLOSE_SQUARE_BRACKET:\n        return 93; // ]\n      case KeyCode.SINGLE_QUOTE:\n        return 39; // '\n    }\n    return event.keyCode;\n  }\n\n  /**\n   * Returns true if the key fires a keypress event in the current browser.\n   */\n  bool _firesKeyPressEvent(KeyEvent event) {\n    if (!Device.isIE && !Device.isWebKit) {\n      return true;\n    }\n\n    if (Device.userAgent.contains('Mac') && event.altKey) {\n      return KeyCode.isCharacterKey(event.keyCode);\n    }\n\n    // Alt but not AltGr which is represented as Alt+Ctrl.\n    if (event.altKey && !event.ctrlKey) {\n      return false;\n    }\n\n    // Saves Ctrl or Alt + key for IE and WebKit, which won't fire keypress.\n    if (!event.shiftKey &&\n        (_keyDownList.last.keyCode == KeyCode.CTRL ||\n         _keyDownList.last.keyCode == KeyCode.ALT ||\n         Device.userAgent.contains('Mac') &&\n         _keyDownList.last.keyCode == KeyCode.META)) {\n      return false;\n    }\n\n    // Some keys with Ctrl/Shift do not issue keypress in WebKit.\n    if (Device.isWebKit && event.ctrlKey && event.shiftKey && (\n        event.keyCode == KeyCode.BACKSLASH ||\n        event.keyCode == KeyCode.OPEN_SQUARE_BRACKET ||\n        event.keyCode == KeyCode.CLOSE_SQUARE_BRACKET ||\n        event.keyCode == KeyCode.TILDE ||\n        event.keyCode == KeyCode.SEMICOLON || event.keyCode == KeyCode.DASH ||\n        event.keyCode == KeyCode.EQUALS || event.keyCode == KeyCode.COMMA ||\n        event.keyCode == KeyCode.PERIOD || event.keyCode == KeyCode.SLASH ||\n        event.keyCode == KeyCode.APOSTROPHE ||\n        event.keyCode == KeyCode.SINGLE_QUOTE)) {\n      return false;\n    }\n\n    switch (event.keyCode) {\n      case KeyCode.ENTER:\n        // IE9 does not fire keypress on ENTER.\n        return !Device.isIE;\n      case KeyCode.ESC:\n        return !Device.isWebKit;\n    }\n\n    return KeyCode.isCharacterKey(event.keyCode);\n  }\n\n  /**\n   * Normalize the keycodes to the IE KeyCodes (this is what Chrome, IE, and\n   * Opera all use).\n   */\n  int _normalizeKeyCodes(KeyboardEvent event) {\n    // Note: This may change once we get input about non-US keyboards.\n    if (Device.isFirefox) {\n      switch(event.keyCode) {\n        case KeyCode.FF_EQUALS:\n          return KeyCode.EQUALS;\n        case KeyCode.FF_SEMICOLON:\n          return KeyCode.SEMICOLON;\n        case KeyCode.MAC_FF_META:\n          return KeyCode.META;\n        case KeyCode.WIN_KEY_FF_LINUX:\n          return KeyCode.WIN_KEY;\n      }\n    }\n    return event.keyCode;\n  }\n\n  /** Handle keydown events. */\n  void processKeyDown(KeyboardEvent e) {\n    // Ctrl-Tab and Alt-Tab can cause the focus to be moved to another window\n    // before we've caught a key-up event.  If the last-key was one of these\n    // we reset the state.\n    if (_keyDownList.length > 0 &&\n        (_keyDownList.last.keyCode == KeyCode.CTRL && !e.ctrlKey ||\n         _keyDownList.last.keyCode == KeyCode.ALT && !e.altKey ||\n         Device.userAgent.contains('Mac') &&\n         _keyDownList.last.keyCode == KeyCode.META && !e.metaKey)) {\n      _keyDownList.clear();\n    }\n\n    var event = new KeyEvent.wrap(e);\n    event._shadowKeyCode = _normalizeKeyCodes(event);\n    // Technically a \"keydown\" event doesn't have a charCode. This is\n    // calculated nonetheless to provide us with more information in giving\n    // as much information as possible on keypress about keycode and also\n    // charCode.\n    event._shadowCharCode = _findCharCodeKeyDown(event);\n    if (_keyDownList.length > 0 && event.keyCode != _keyDownList.last.keyCode &&\n        !_firesKeyPressEvent(event)) {\n      // Some browsers have quirks not firing keypress events where all other\n      // browsers do. This makes them more consistent.\n      processKeyPress(e);\n    }\n    _keyDownList.add(event);\n    _stream.add(event);\n  }\n\n  /** Handle keypress events. */\n  void processKeyPress(KeyboardEvent event) {\n    var e = new KeyEvent.wrap(event);\n    // IE reports the character code in the keyCode field for keypress events.\n    // There are two exceptions however, Enter and Escape.\n    if (Device.isIE) {\n      if (e.keyCode == KeyCode.ENTER || e.keyCode == KeyCode.ESC) {\n        e._shadowCharCode = 0;\n      } else {\n        e._shadowCharCode = e.keyCode;\n      }\n    } else if (Device.isOpera) {\n      // Opera reports the character code in the keyCode field.\n      e._shadowCharCode = KeyCode.isCharacterKey(e.keyCode) ? e.keyCode : 0;\n    }\n    // Now we guestimate about what the keycode is that was actually\n    // pressed, given previous keydown information.\n    e._shadowKeyCode = _determineKeyCodeForKeypress(e);\n\n    // Correct the key value for certain browser-specific quirks.\n    if (e._shadowKeyIdentifier != null &&\n        _keyIdentifier.containsKey(e._shadowKeyIdentifier)) {\n      // This is needed for Safari Windows because it currently doesn't give a\n      // keyCode/which for non printable keys.\n      e._shadowKeyCode = _keyIdentifier[e._shadowKeyIdentifier];\n    }\n    e._shadowAltKey = _keyDownList.any((var element) => element.altKey);\n    _stream.add(e);\n  }\n\n  /** Handle keyup events. */\n  void processKeyUp(KeyboardEvent event) {\n    var e = new KeyEvent.wrap(event);\n    KeyboardEvent toRemove = null;\n    for (var key in _keyDownList) {\n      if (key.keyCode == e.keyCode) {\n        toRemove = key;\n      }\n    }\n    if (toRemove != null) {\n      _keyDownList.removeWhere((element) => element == toRemove);\n    } else if (_keyDownList.length > 0) {\n      // This happens when we've reached some international keyboard case we\n      // haven't accounted for or we haven't correctly eliminated all browser\n      // inconsistencies. Filing bugs on when this is reached is welcome!\n      _keyDownList.removeLast();\n    }\n    _stream.add(e);\n  }\n}\n\n\n/**\n * Records KeyboardEvents that occur on a particular element, and provides a\n * stream of outgoing KeyEvents with cross-browser consistent keyCode and\n * charCode values despite the fact that a multitude of browsers that have\n * varying keyboard default behavior.\n *\n * Example usage:\n *\n *     KeyboardEventStream.onKeyDown(document.body).listen(\n *         keydownHandlerTest);\n *\n * This class is very much a work in progress, and we'd love to get information\n * on how we can make this class work with as many international keyboards as\n * possible. Bugs welcome!\n */\nclass KeyboardEventStream {\n\n  /** Named constructor to produce a stream for onKeyPress events. */\n  static CustomStream<KeyEvent> onKeyPress(EventTarget target) =>\n      new _KeyboardEventHandler('keypress').forTarget(target);\n\n  /** Named constructor to produce a stream for onKeyUp events. */\n  static CustomStream<KeyEvent> onKeyUp(EventTarget target) =>\n      new _KeyboardEventHandler('keyup').forTarget(target);\n\n  /** Named constructor to produce a stream for onKeyDown events. */\n  static CustomStream<KeyEvent> onKeyDown(EventTarget target) =>\n      new _KeyboardEventHandler('keydown').forTarget(target);\n}\n// Copyright (c) 2013, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n\n/**\n * Class which helps construct standard node validation policies.\n *\n * By default this will not accept anything, but the 'allow*' functions can be\n * used to expand what types of elements or attributes are allowed.\n *\n * All allow functions are additive- elements will be accepted if they are\n * accepted by any specific rule.\n *\n * It is important to remember that sanitization is not just intended to prevent\n * cross-site scripting attacks, but also to prevent information from being\n * displayed in unexpected ways. For example something displaying basic\n * formatted text may not expect `<video>` tags to appear. In this case an\n * empty NodeValidatorBuilder with just [allowTextElements] might be\n * appropriate.\n */\nclass NodeValidatorBuilder implements NodeValidator {\n\n  final List<NodeValidator> _validators = <NodeValidator>[];\n\n  NodeValidatorBuilder() {\n  }\n\n  /**\n   * Creates a new NodeValidatorBuilder which accepts common constructs.\n   *\n   * By default this will accept HTML5 elements and attributes with the default\n   * [UriPolicy] and templating elements.\n   *\n   * Notable syntax which is filtered:\n   *\n   * * Only known-good HTML5 elements and attributes are allowed.\n   * * All URLs must be same-origin, use [allowNavigation] and [allowImages] to\n   * specify additional URI policies.\n   * * Inline-styles are not allowed.\n   * * Custom element tags are disallowed, use [allowCustomElement].\n   * * Custom tags extensions are disallowed, use [allowTagExtension].\n   * * SVG Elements are not allowed, use [allowSvg].\n   *\n   * For scenarios where the HTML should only contain formatted text\n   * [allowTextElements] is more appropriate.\n   *\n   * Use [allowSvg] to allow SVG elements.\n   */\n  NodeValidatorBuilder.common() {\n    allowHtml5();\n    allowTemplating();\n  }\n\n  /**\n   * Allows navigation elements- Form and Anchor tags, along with common\n   * attributes.\n   *\n   * The UriPolicy can be used to restrict the locations the navigation elements\n   * are allowed to direct to. By default this will use the default [UriPolicy].\n   */\n  void allowNavigation([UriPolicy uriPolicy]) {\n    if (uriPolicy == null) {\n      uriPolicy = new UriPolicy();\n    }\n    add(new _SimpleNodeValidator.allowNavigation(uriPolicy));\n  }\n\n  /**\n   * Allows image elements.\n   *\n   * The UriPolicy can be used to restrict the locations the images may be\n   * loaded from. By default this will use the default [UriPolicy].\n   */\n  void allowImages([UriPolicy uriPolicy]) {\n    if (uriPolicy == null) {\n      uriPolicy = new UriPolicy();\n    }\n    add(new _SimpleNodeValidator.allowImages(uriPolicy));\n  }\n\n  /**\n   * Allow basic text elements.\n   *\n   * This allows a subset of HTML5 elements, specifically just these tags and\n   * no attributes.\n   *\n   * * B\n   * * BLOCKQUOTE\n   * * BR\n   * * EM\n   * * H1\n   * * H2\n   * * H3\n   * * H4\n   * * H5\n   * * H6\n   * * HR\n   * * I\n   * * LI\n   * * OL\n   * * P\n   * * SPAN\n   * * UL\n   */\n  void allowTextElements() {\n    add(new _SimpleNodeValidator.allowTextElements());\n  }\n\n  /**\n   * Allow inline styles on elements.\n   *\n   * If [tagName] is not specified then this allows inline styles on all\n   * elements. Otherwise tagName limits the styles to the specified elements.\n   */\n  void allowInlineStyles({String tagName}) {\n    if (tagName == null) {\n      tagName = '*';\n    } else {\n      tagName = tagName.toUpperCase();\n    }\n    add(new _SimpleNodeValidator(null, allowedAttributes: ['$tagName::style']));\n  }\n\n  /**\n   * Allow common safe HTML5 elements and attributes.\n   *\n   * This list is based off of the Caja whitelists at:\n   * https://code.google.com/p/google-caja/wiki/CajaWhitelists.\n   *\n   * Common things which are not allowed are script elements, style attributes\n   * and any script handlers.\n   */\n  void allowHtml5({UriPolicy uriPolicy}) {\n    add(new _Html5NodeValidator(uriPolicy: uriPolicy));\n  }\n\n  /**\n   * Allow SVG elements and attributes except for known bad ones.\n   */\n  void allowSvg() {\n    add(new _SvgNodeValidator());\n  }\n\n  /**\n   * Allow custom elements with the specified tag name and specified attributes.\n   *\n   * This will allow the elements as custom tags (such as <x-foo></x-foo>),\n   * but will not allow tag extensions. Use [allowTagExtension] to allow\n   * tag extensions.\n   */\n  void allowCustomElement(String tagName,\n      {UriPolicy uriPolicy,\n      Iterable<String> attributes,\n      Iterable<String> uriAttributes}) {\n\n    var tagNameUpper = tagName.toUpperCase();\n    var attrs;\n    if (attributes != null) {\n      attrs =\n          attributes.map((name) => '$tagNameUpper::${name.toLowerCase()}');\n    }\n    var uriAttrs;\n    if (uriAttributes != null) {\n      uriAttrs =\n          uriAttributes.map((name) => '$tagNameUpper::${name.toLowerCase()}');\n    }\n    if (uriPolicy == null) {\n      uriPolicy = new UriPolicy();\n    }\n\n    add(new _CustomElementNodeValidator(\n        uriPolicy,\n        [tagNameUpper],\n        attrs,\n        uriAttrs,\n        false,\n        true));\n  }\n\n  /**\n   * Allow custom tag extensions with the specified type name and specified\n   * attributes.\n   *\n   * This will allow tag extensions (such as <div is=\"x-foo\"></div>),\n   * but will not allow custom tags. Use [allowCustomElement] to allow\n   * custom tags.\n   */\n  void allowTagExtension(String tagName, String baseName,\n      {UriPolicy uriPolicy,\n      Iterable<String> attributes,\n      Iterable<String> uriAttributes}) {\n\n    var baseNameUpper = baseName.toUpperCase();\n    var tagNameUpper = tagName.toUpperCase();\n    var attrs;\n    if (attributes != null) {\n      attrs =\n          attributes.map((name) => '$baseNameUpper::${name.toLowerCase()}');\n    }\n    var uriAttrs;\n    if (uriAttributes != null) {\n      uriAttrs =\n          uriAttributes.map((name) => '$baseNameUpper::${name.toLowerCase()}');\n    }\n    if (uriPolicy == null) {\n      uriPolicy = new UriPolicy();\n    }\n\n    add(new _CustomElementNodeValidator(\n        uriPolicy,\n        [tagNameUpper, baseNameUpper],\n        attrs,\n        uriAttrs,\n        true,\n        false));\n  }\n\n  void allowElement(String tagName, {UriPolicy uriPolicy,\n    Iterable<String> attributes,\n    Iterable<String> uriAttributes}) {\n\n    allowCustomElement(tagName, uriPolicy: uriPolicy,\n        attributes: attributes,\n        uriAttributes: uriAttributes);\n  }\n\n  /**\n   * Allow templating elements (such as <template> and template-related\n   * attributes.\n   *\n   * This still requires other validators to allow regular attributes to be\n   * bound (such as [allowHtml5]).\n   */\n  void allowTemplating() {\n    add(new _TemplatingNodeValidator());\n  }\n\n  /**\n   * Add an additional validator to the current list of validators.\n   *\n   * Elements and attributes will be accepted if they are accepted by any\n   * validators.\n   */\n  void add(NodeValidator validator) {\n    _validators.add(validator);\n  }\n\n  bool allowsElement(Element element) {\n    return _validators.any((v) => v.allowsElement(element));\n  }\n\n  bool allowsAttribute(Element element, String attributeName, String value) {\n    return _validators.any(\n        (v) => v.allowsAttribute(element, attributeName, value));\n  }\n}\n\nclass _SimpleNodeValidator implements NodeValidator {\n  final Set<String> allowedElements;\n  final Set<String> allowedAttributes;\n  final Set<String> allowedUriAttributes;\n  final UriPolicy uriPolicy;\n\n  factory _SimpleNodeValidator.allowNavigation(UriPolicy uriPolicy) {\n    return new _SimpleNodeValidator(uriPolicy,\n      allowedElements: [\n        'A',\n        'FORM'],\n      allowedAttributes: [\n        'A::accesskey',\n        'A::coords',\n        'A::hreflang',\n        'A::name',\n        'A::shape',\n        'A::tabindex',\n        'A::target',\n        'A::type',\n        'FORM::accept',\n        'FORM::autocomplete',\n        'FORM::enctype',\n        'FORM::method',\n        'FORM::name',\n        'FORM::novalidate',\n        'FORM::target',\n      ],\n      allowedUriAttributes: [\n        'A::href',\n        'FORM::action',\n      ]);\n  }\n\n  factory _SimpleNodeValidator.allowImages(UriPolicy uriPolicy) {\n    return new _SimpleNodeValidator(uriPolicy,\n      allowedElements: [\n        'IMG'\n      ],\n      allowedAttributes: [\n        'IMG::align',\n        'IMG::alt',\n        'IMG::border',\n        'IMG::height',\n        'IMG::hspace',\n        'IMG::ismap',\n        'IMG::name',\n        'IMG::usemap',\n        'IMG::vspace',\n        'IMG::width',\n      ],\n      allowedUriAttributes: [\n        'IMG::src',\n      ]);\n  }\n\n  factory _SimpleNodeValidator.allowTextElements() {\n    return new _SimpleNodeValidator(null,\n      allowedElements: [\n        'B',\n        'BLOCKQUOTE',\n        'BR',\n        'EM',\n        'H1',\n        'H2',\n        'H3',\n        'H4',\n        'H5',\n        'H6',\n        'HR',\n        'I',\n        'LI',\n        'OL',\n        'P',\n        'SPAN',\n        'UL',\n      ]);\n  }\n\n  /**\n   * Elements must be uppercased tag names. For example `'IMG'`.\n   * Attributes must be uppercased tag name followed by :: followed by\n   * lowercase attribute name. For example `'IMG:src'`.\n   */\n  _SimpleNodeValidator(this.uriPolicy,\n      {Iterable<String> allowedElements, Iterable<String> allowedAttributes,\n      Iterable<String> allowedUriAttributes}):\n      this.allowedElements = allowedElements != null ?\n          new Set.from(allowedElements) : new Set(),\n      this.allowedAttributes = allowedAttributes != null ?\n          new Set.from(allowedAttributes) : new Set(),\n      this.allowedUriAttributes = allowedUriAttributes != null ?\n          new Set.from(allowedUriAttributes) : new Set();\n\n  bool allowsElement(Element element) {\n    return allowedElements.contains(element.tagName);\n  }\n\n  bool allowsAttribute(Element element, String attributeName, String value) {\n    var tagName = element.tagName;\n    if (allowedUriAttributes.contains('$tagName::$attributeName')) {\n      return uriPolicy.allowsUri(value);\n    } else if (allowedUriAttributes.contains('*::$attributeName')) {\n      return uriPolicy.allowsUri(value);\n    } else if (allowedAttributes.contains('$tagName::$attributeName')) {\n      return true;\n    } else if (allowedAttributes.contains('*::$attributeName')) {\n      return true;\n    } else if (allowedAttributes.contains('$tagName::*')) {\n      return true;\n    } else if (allowedAttributes.contains('*::*')) {\n      return true;\n    }\n    return false;\n  }\n}\n\nclass _CustomElementNodeValidator extends _SimpleNodeValidator {\n  final bool allowTypeExtension;\n  final bool allowCustomTag;\n\n  _CustomElementNodeValidator(UriPolicy uriPolicy,\n      Iterable<String> allowedElements,\n      Iterable<String> allowedAttributes,\n      Iterable<String> allowedUriAttributes,\n      bool allowTypeExtension,\n      bool allowCustomTag):\n\n      super(uriPolicy,\n          allowedElements: allowedElements,\n          allowedAttributes: allowedAttributes,\n          allowedUriAttributes: allowedUriAttributes),\n      this.allowTypeExtension = allowTypeExtension == true,\n      this.allowCustomTag = allowCustomTag == true;\n\n  bool allowsElement(Element element) {\n    if (allowTypeExtension) {\n      var isAttr = element.attributes['is'];\n      if (isAttr != null) {\n        return allowedElements.contains(isAttr.toUpperCase()) &&\n          allowedElements.contains(element.tagName);\n      }\n    }\n    return allowCustomTag && allowedElements.contains(element.tagName);\n  }\n\n  bool allowsAttribute(Element element, String attributeName, String value) {\n   if (allowsElement(element)) {\n      if (allowTypeExtension && attributeName == 'is' &&\n          allowedElements.contains(value.toUpperCase())) {\n        return true;\n      }\n      return super.allowsAttribute(element, attributeName, value);\n    }\n    return false;\n  }\n}\n\nclass _TemplatingNodeValidator extends _SimpleNodeValidator {\n  static const _TEMPLATE_ATTRS =\n      const <String>['bind', 'if', 'ref', 'repeat', 'syntax'];\n\n  final Set<String> _templateAttrs;\n\n  _TemplatingNodeValidator():\n      super(null,\n          allowedElements: [\n            'TEMPLATE'\n          ],\n          allowedAttributes: _TEMPLATE_ATTRS.map((attr) => 'TEMPLATE::$attr')),\n      _templateAttrs = new Set<String>.from(_TEMPLATE_ATTRS) {\n  }\n\n  bool allowsAttribute(Element element, String attributeName, String value) {\n    if (super.allowsAttribute(element, attributeName, value)) {\n      return true;\n    }\n\n    if (attributeName == 'template' && value == \"\") {\n      return true;\n    }\n\n    if (element.attributes['template'] == \"\" ) {\n      return _templateAttrs.contains(attributeName);\n    }\n    return false;\n  }\n}\n\n\nclass _SvgNodeValidator implements NodeValidator {\n  bool allowsElement(Element element) {\n    if (element is svg.ScriptElement) {\n      return false;\n    }\n    if (element is svg.SvgElement) {\n      return true;\n    }\n    return false;\n  }\n\n  bool allowsAttribute(Element element, String attributeName, String value) {\n    if (attributeName == 'is' || attributeName.startsWith('on')) {\n      return false;\n    }\n    return allowsElement(element);\n  }\n}\n// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n/**\n * Contains the set of standard values returned by HTMLDocument.getReadyState.\n */\nabstract class ReadyState {\n  /**\n   * Indicates the document is still loading and parsing.\n   */\n  static const String LOADING = \"loading\";\n\n  /**\n   * Indicates the document is finished parsing but is still loading\n   * subresources.\n   */\n  static const String INTERACTIVE = \"interactive\";\n\n  /**\n   * Indicates the document and all subresources have been loaded.\n   */\n  static const String COMPLETE = \"complete\";\n}\n// Copyright (c) 2013, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n/**\n * A list which just wraps another list, for either intercepting list calls or\n * retyping the list (for example, from List<A> to List<B> where B extends A).\n */\nclass _WrappedList<E extends Node> extends ListBase<E>\n    implements NodeListWrapper {\n  final List _list;\n\n  _WrappedList(this._list);\n\n  // Iterable APIs\n\n  Iterator<E> get iterator => new _WrappedIterator(_list.iterator);\n\n  int get length => _list.length;\n\n  // Collection APIs\n\n  void add(E element) { _list.add(element); }\n\n  bool remove(Object element) => _list.remove(element);\n\n  void clear() { _list.clear(); }\n\n  // List APIs\n\n  E operator [](int index) => _list[index];\n\n  void operator []=(int index, E value) { _list[index] = value; }\n\n  void set length(int newLength) { _list.length = newLength; }\n\n  void sort([int compare(E a, E b)]) { _list.sort(compare); }\n\n  int indexOf(Object element, [int start = 0]) => _list.indexOf(element, start);\n\n  int lastIndexOf(Object element, [int start]) => _list.lastIndexOf(element, start);\n\n  void insert(int index, E element) => _list.insert(index, element);\n\n  E removeAt(int index) => _list.removeAt(index);\n\n  void setRange(int start, int end, Iterable<E> iterable, [int skipCount = 0]) {\n    _list.setRange(start, end, iterable, skipCount);\n  }\n\n  void removeRange(int start, int end) { _list.removeRange(start, end); }\n\n  void replaceRange(int start, int end, Iterable<E> iterable) {\n    _list.replaceRange(start, end, iterable);\n  }\n\n  void fillRange(int start, int end, [E fillValue]) {\n    _list.fillRange(start, end, fillValue);\n  }\n\n  List<Node> get rawList => _list;\n}\n\n/**\n * Iterator wrapper for _WrappedList.\n */\nclass _WrappedIterator<E> implements Iterator<E> {\n  Iterator _iterator;\n\n  _WrappedIterator(this._iterator);\n\n  bool moveNext() {\n    return _iterator.moveNext();\n  }\n\n  E get current => _iterator.current;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\nclass _HttpRequestUtils {\n\n  // Helper for factory HttpRequest.get\n  static HttpRequest get(String url,\n                            onComplete(HttpRequest request),\n                            bool withCredentials) {\n    final request = new HttpRequest();\n    request.open('GET', url, async: true);\n\n    request.withCredentials = withCredentials;\n\n    request.onReadyStateChange.listen((e) {\n      if (request.readyState == HttpRequest.DONE) {\n        onComplete(request);\n      }\n    });\n\n    request.send();\n\n    return request;\n  }\n}\n// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n// Iterator for arrays with fixed size.\nclass FixedSizeListIterator<T> implements Iterator<T> {\n  final List<T> _array;\n  final int _length;  // Cache array length for faster access.\n  int _position;\n  T _current;\n  \n  FixedSizeListIterator(List<T> array)\n      : _array = array,\n        _position = -1,\n        _length = array.length;\n\n  bool moveNext() {\n    int nextPosition = _position + 1;\n    if (nextPosition < _length) {\n      _current = _array[nextPosition];\n      _position = nextPosition;\n      return true;\n    }\n    _current = null;\n    _position = _length;\n    return false;\n  }\n\n  T get current => _current;\n}\n\n// Iterator for arrays with variable size.\nclass _VariableSizeListIterator<T> implements Iterator<T> {\n  final List<T> _array;\n  int _position;\n  T _current;\n\n  _VariableSizeListIterator(List<T> array)\n      : _array = array,\n        _position = -1;\n\n  bool moveNext() {\n    int nextPosition = _position + 1;\n    if (nextPosition < _array.length) {\n      _current = _array[nextPosition];\n      _position = nextPosition;\n      return true;\n    }\n    _current = null;\n    _position = _array.length;\n    return false;\n  }\n\n  T get current => _current;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n// Conversions for Window.  These check if the window is the local\n// window, and if it's not, wraps or unwraps it with a secure wrapper.\n// We need to test for EventTarget here as well as it's a base type.\n// We omit an unwrapper for Window as no methods take a non-local\n// window as a parameter.\n\n\nWindowBase _convertNativeToDart_Window(win) {\n  if (win == null) return null;\n  return _DOMWindowCrossFrame._createSafe(win);\n}\n\nEventTarget _convertNativeToDart_EventTarget(e) {\n  if (e == null) {\n    return null;\n  }\n  // Assume it's a Window if it contains the postMessage property.  It may be\n  // from a different frame - without a patched prototype - so we cannot\n  // rely on Dart type checking.\n  if (JS('bool', r'\"postMessage\" in #', e)) {\n    var window = _DOMWindowCrossFrame._createSafe(e);\n    // If it's a native window.\n    if (window is EventTarget) {\n      return window;\n    }\n    return null;\n  }\n  else\n    return e;\n}\n\nEventTarget _convertDartToNative_EventTarget(e) {\n  if (e is _DOMWindowCrossFrame) {\n    return e._window;\n  } else {\n    return e;\n  }\n}\n\n_convertNativeToDart_XHR_Response(o) {\n  if (o is Document) {\n    return o;\n  }\n  return convertNativeToDart_SerializedScriptValue(o);\n}\n// Copyright (c) 2013, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n_callConstructor(constructor, interceptor) {\n  return (receiver) {\n    setNativeSubclassDispatchRecord(receiver, interceptor);\n\n    // Mirrors uses the constructor property to cache lookups, so we need it to\n    // be set correctly, including on IE where it is not automatically picked\n    // up from the __proto__.\n    JS('', '#.constructor = #.__proto__.constructor', receiver, receiver);\n    return JS('', '#(#)', constructor, receiver);\n  };\n}\n\n_callAttached(receiver) {\n  return receiver.attached();\n}\n\n_callDetached(receiver) {\n  return receiver.detached();\n}\n _callAttributeChanged(receiver, name, oldValue, newValue) {\n  return receiver.attributeChanged(name, oldValue, newValue);\n}\n\n_makeCallbackMethod(callback) {\n  return JS('',\n      '''((function(invokeCallback) {\n             return function() {\n               return invokeCallback(this);\n             };\n          })(#))''',\n      convertDartClosureToJS(callback, 1));\n}\n\n_makeCallbackMethod3(callback) {\n  return JS('',\n      '''((function(invokeCallback) {\n             return function(arg1, arg2, arg3) {\n               return invokeCallback(this, arg1, arg2, arg3);\n             };\n          })(#))''',\n      convertDartClosureToJS(callback, 4));\n}\n\nvoid _registerCustomElement(context, document, String tag, Type type,\n    String extendsTagName) {\n  // Function follows the same pattern as the following JavaScript code for\n  // registering a custom element.\n  //\n  //    var proto = Object.create(HTMLElement.prototype, {\n  //        createdCallback: {\n  //          value: function() {\n  //            window.console.log('here');\n  //          }\n  //        }\n  //    });\n  //    document.registerElement('x-foo', { prototype: proto });\n  //    ...\n  //    var e = document.createElement('x-foo');\n\n  var interceptorClass = findInterceptorConstructorForType(type);\n  if (interceptorClass == null) {\n    throw new ArgumentError(type);\n  }\n\n  var interceptor = JS('=Object', '#.prototype', interceptorClass);\n\n  var constructor = findConstructorForNativeSubclassType(type, 'created');\n  if (constructor == null) {\n    throw new ArgumentError(\"$type has no constructor called 'created'\");\n  }\n\n  // Workaround for 13190- use an article element to ensure that HTMLElement's\n  // interceptor is resolved correctly.\n  getNativeInterceptor(new Element.tag('article'));\n\n  String baseClassName = findDispatchTagForInterceptorClass(interceptorClass);\n  if (baseClassName == null) {\n    throw new ArgumentError(type);\n  }\n\n  if (extendsTagName == null) {\n    if (baseClassName != 'HTMLElement') {\n      throw new UnsupportedError('Class must provide extendsTag if base '\n          'native class is not HtmlElement');\n    }\n  } else {\n    if (!JS('bool', '(#.createElement(#) instanceof window[#])',\n        document, extendsTagName, baseClassName)) {\n      throw new UnsupportedError('extendsTag does not match base native class');\n    }\n  }\n\n  var baseConstructor = JS('=Object', '#[#]', context, baseClassName);\n\n  var properties = JS('=Object', '{}');\n\n  JS('void', '#.createdCallback = #', properties,\n      JS('=Object', '{value: #}',\n          _makeCallbackMethod(_callConstructor(constructor, interceptor))));\n  JS('void', '#.attachedCallback = #', properties,\n      JS('=Object', '{value: #}', _makeCallbackMethod(_callAttached)));\n  JS('void', '#.detachedCallback = #', properties,\n      JS('=Object', '{value: #}', _makeCallbackMethod(_callDetached)));\n  JS('void', '#.attributeChangedCallback = #', properties,\n      JS('=Object', '{value: #}', _makeCallbackMethod3(_callAttributeChanged)));\n\n  var baseProto = JS('=Object', '#.prototype', baseConstructor);\n  var proto = JS('=Object', 'Object.create(#, #)', baseProto, properties);\n\n  setNativeSubclassDispatchRecord(proto, interceptor);\n\n  var options = JS('=Object', '{prototype: #}', proto);\n\n  if (extendsTagName != null) {\n    JS('=Object', '#.extends = #', options, extendsTagName);\n  }\n\n  JS('void', '#.registerElement(#, #)', document, tag, options);\n}\n\n//// Called by Element.created to do validation & initialization.\nvoid _initializeCustomElement(Element e) {\n  // TODO(blois): Add validation that this is only in response to an upgrade.\n}\n\n/// Dart2JS implementation of ElementUpgrader\nclass _JSElementUpgrader implements ElementUpgrader {\n  var _interceptor;\n  var _constructor;\n  var _nativeType;\n\n  _JSElementUpgrader(Document document, Type type, String extendsTag) {\n    var interceptorClass = findInterceptorConstructorForType(type);\n    if (interceptorClass == null) {\n      throw new ArgumentError(type);\n    }\n\n    _constructor = findConstructorForNativeSubclassType(type, 'created');\n    if (_constructor == null) {\n      throw new ArgumentError(\"$type has no constructor called 'created'\");\n    }\n\n    // Workaround for 13190- use an article element to ensure that HTMLElement's\n    // interceptor is resolved correctly.\n    getNativeInterceptor(new Element.tag('article'));\n\n    var baseClassName = findDispatchTagForInterceptorClass(interceptorClass);\n    if (baseClassName == null) {\n      throw new ArgumentError(type);\n    }\n\n    if (extendsTag == null) {\n      if (baseClassName != 'HTMLElement') {\n        throw new UnsupportedError('Class must provide extendsTag if base '\n            'native class is not HtmlElement');\n      }\n      _nativeType = HtmlElement;\n    } else {\n      var element = document.createElement(extendsTag);\n      if (!JS('bool', '(# instanceof window[#])',\n          element, baseClassName)) {\n        throw new UnsupportedError(\n            'extendsTag does not match base native class');\n      }\n      _nativeType = element.runtimeType;\n    }\n\n    _interceptor = JS('=Object', '#.prototype', interceptorClass);\n  }\n\n  Element upgrade(Element element) {\n    // Only exact type matches are supported- cannot be a subclass.\n    if (element.runtimeType != _nativeType) {\n      throw new ArgumentError('element is not subclass of $_nativeType');\n    }\n\n    setNativeSubclassDispatchRecord(element, _interceptor);\n    JS('', '#(#)', _constructor, element);\n    return element;\n  }\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n// TODO(vsm): Unify with Dartium version.\nclass _DOMWindowCrossFrame implements WindowBase {\n  // Private window.  Note, this is a window in another frame, so it\n  // cannot be typed as \"Window\" as its prototype is not patched\n  // properly.  Its fields and methods can only be accessed via JavaScript.\n  final _window;\n\n  // Fields.\n  HistoryBase get history =>\n    _HistoryCrossFrame._createSafe(JS('HistoryBase', '#.history', _window));\n  LocationBase get location =>\n    _LocationCrossFrame._createSafe(JS('LocationBase', '#.location', _window));\n\n  // TODO(vsm): Add frames to navigate subframes.  See 2312.\n\n  bool get closed => JS('bool', '#.closed', _window);\n\n  WindowBase get opener => _createSafe(JS('WindowBase', '#.opener', _window));\n\n  WindowBase get parent => _createSafe(JS('WindowBase', '#.parent', _window));\n\n  WindowBase get top => _createSafe(JS('WindowBase', '#.top', _window));\n\n  // Methods.\n  void close() => JS('void', '#.close()', _window);\n\n  void postMessage(var message, String targetOrigin, [List messagePorts = null]) {\n    if (messagePorts == null) {\n      JS('void', '#.postMessage(#,#)', _window,\n          convertDartToNative_SerializedScriptValue(message), targetOrigin);\n    } else {\n      JS('void', '#.postMessage(#,#,#)', _window,\n          convertDartToNative_SerializedScriptValue(message), targetOrigin,\n          messagePorts);\n    }\n  }\n\n  // Implementation support.\n  _DOMWindowCrossFrame(this._window);\n\n  static WindowBase _createSafe(w) {\n    if (identical(w, window)) {\n      return w;\n    } else {\n      // TODO(vsm): Cache or implement equality.\n      return new _DOMWindowCrossFrame(w);\n    }\n  }\n\n  // TODO(efortuna): Remove this method. dartbug.com/16814\n  Events get on => throw new UnsupportedError(\n    'You can only attach EventListeners to your own window.');\n  // TODO(efortuna): Remove this method. dartbug.com/16814\n  void addEventListener(String type, EventListener listener, [bool useCapture])\n      => throw new UnsupportedError(\n        'You can only attach EventListeners to your own window.');\n  // TODO(efortuna): Remove this method. dartbug.com/16814\n  bool dispatchEvent(Event event) => throw new UnsupportedError(\n    'You can only attach EventListeners to your own window.');\n  // TODO(efortuna): Remove this method. dartbug.com/16814\n  void removeEventListener(String type, EventListener listener,\n      [bool useCapture]) => throw new UnsupportedError(\n          'You can only attach EventListeners to your own window.');\n}\n\nclass _LocationCrossFrame implements LocationBase {\n  // Private location.  Note, this is a location object in another frame, so it\n  // cannot be typed as \"Location\" as its prototype is not patched\n  // properly.  Its fields and methods can only be accessed via JavaScript.\n  var _location;\n\n  void set href(String val) => _setHref(_location, val);\n  static void _setHref(location, val) {\n    JS('void', '#.href = #', location, val);\n  }\n\n  // Implementation support.\n  _LocationCrossFrame(this._location);\n\n  static LocationBase _createSafe(location) {\n    if (identical(location, window.location)) {\n      return location;\n    } else {\n      // TODO(vsm): Cache or implement equality.\n      return new _LocationCrossFrame(location);\n    }\n  }\n}\n\nclass _HistoryCrossFrame implements HistoryBase {\n  // Private history.  Note, this is a history object in another frame, so it\n  // cannot be typed as \"History\" as its prototype is not patched\n  // properly.  Its fields and methods can only be accessed via JavaScript.\n  var _history;\n\n  void back() => JS('void', '#.back()', _history);\n\n  void forward() => JS('void', '#.forward()', _history);\n\n  void go(int distance) => JS('void', '#.go(#)', _history, distance);\n\n  // Implementation support.\n  _HistoryCrossFrame(this._history);\n\n  static HistoryBase _createSafe(h) {\n    if (identical(h, window.history)) {\n      return h;\n    } else {\n      // TODO(vsm): Cache or implement equality.\n      return new _HistoryCrossFrame(h);\n    }\n  }\n}\n/**\n * A custom KeyboardEvent that attempts to eliminate cross-browser\n * inconsistencies, and also provide both keyCode and charCode information\n * for all key events (when such information can be determined).\n *\n * KeyEvent tries to provide a higher level, more polished keyboard event\n * information on top of the \"raw\" [KeyboardEvent].\n *\n * The mechanics of using KeyEvents is a little different from the underlying\n * [KeyboardEvent]. To use KeyEvents, you need to create a stream and then add\n * KeyEvents to the stream, rather than using the [EventTarget.dispatchEvent].\n * Here's an example usage:\n *\n *     // Initialize a stream for the KeyEvents:\n *     var stream = KeyEvent.keyPressEvent.forTarget(document.body);\n *     // Start listening to the stream of KeyEvents.\n *     stream.listen((keyEvent) =>\n *         window.console.log('KeyPress event detected ${keyEvent.charCode}'));\n *     ...\n *     // Add a new KeyEvent of someone pressing the 'A' key to the stream so\n *     // listeners can know a KeyEvent happened.\n *     stream.add(new KeyEvent('keypress', keyCode: 65, charCode: 97));\n *\n * This class is very much a work in progress, and we'd love to get information\n * on how we can make this class work with as many international keyboards as\n * possible. Bugs welcome!\n */\n@Experimental()\nclass KeyEvent extends _WrappedEvent implements KeyboardEvent {\n  /** The parent KeyboardEvent that this KeyEvent is wrapping and \"fixing\". */\n  KeyboardEvent _parent;\n\n  /** The \"fixed\" value of whether the alt key is being pressed. */\n  bool _shadowAltKey;\n\n  /** Caculated value of what the estimated charCode is for this event. */\n  int _shadowCharCode;\n\n  /** Caculated value of what the estimated keyCode is for this event. */\n  int _shadowKeyCode;\n\n  /** Caculated value of what the estimated keyCode is for this event. */\n  int get keyCode => _shadowKeyCode;\n\n  /** Caculated value of what the estimated charCode is for this event. */\n  int get charCode => this.type == 'keypress' ? _shadowCharCode : 0;\n\n  /** Caculated value of whether the alt key is pressed is for this event. */\n  bool get altKey => _shadowAltKey;\n\n  /** Caculated value of what the estimated keyCode is for this event. */\n  int get which => keyCode;\n\n  /** Accessor to the underlying keyCode value is the parent event. */\n  int get _realKeyCode => JS('int', '#.keyCode', _parent);\n\n  /** Accessor to the underlying charCode value is the parent event. */\n  int get _realCharCode => JS('int', '#.charCode', _parent);\n\n  /** Accessor to the underlying altKey value is the parent event. */\n  bool get _realAltKey => JS('bool', '#.altKey', _parent);\n\n  /** Shadows on top of the parent's currentTarget. */\n  EventTarget _currentTarget;\n\n  /**\n   * The value we want to use for this object's dispatch. Created here so it is\n   * only invoked once.\n   */\n  static final _keyboardEventDispatchRecord = _makeRecord();\n\n  /** Helper to statically create the dispatch record. */\n  static _makeRecord() {\n    var interceptor = JS_INTERCEPTOR_CONSTANT(KeyboardEvent);\n    return makeLeafDispatchRecord(interceptor);\n  }\n\n  /** Construct a KeyEvent with [parent] as the event we're emulating. */\n  KeyEvent.wrap(KeyboardEvent parent): super(parent) {\n    _parent = parent;\n    _shadowAltKey = _realAltKey;\n    _shadowCharCode = _realCharCode;\n    _shadowKeyCode = _realKeyCode;\n    _currentTarget = _parent.currentTarget;\n  }\n\n  /** Programmatically create a new KeyEvent (and KeyboardEvent). */\n  factory KeyEvent(String type,\n      {Window view, bool canBubble: true, bool cancelable: true, int keyCode: 0,\n      int charCode: 0, int keyLocation: 1, bool ctrlKey: false,\n      bool altKey: false, bool shiftKey: false, bool metaKey: false,\n      bool altGraphKey: false, EventTarget currentTarget}) {\n    if (view == null) {\n      view = window;\n    }\n\n    var eventObj;\n    // In these two branches we create an underlying native KeyboardEvent, but\n    // we set it with our specified values. Because we are doing custom setting\n    // of certain values (charCode/keyCode, etc) only in this class (as opposed\n    // to KeyboardEvent) and the way we set these custom values depends on the\n    // type of underlying JS object, we do all the contruction for the\n    // underlying KeyboardEvent here.\n    if (canUseDispatchEvent) {\n      // Currently works in everything but Internet Explorer.\n      eventObj = new Event.eventType('Event', type,\n          canBubble: canBubble, cancelable: cancelable);\n\n      JS('void', '#.keyCode = #', eventObj, keyCode);\n      JS('void', '#.which = #', eventObj, keyCode);\n      JS('void', '#.charCode = #', eventObj, charCode);\n\n      JS('void', '#.keyLocation = #', eventObj, keyLocation);\n      JS('void', '#.ctrlKey = #', eventObj, ctrlKey);\n      JS('void', '#.altKey = #', eventObj, altKey);\n      JS('void', '#.shiftKey = #', eventObj, shiftKey);\n      JS('void', '#.metaKey = #', eventObj, metaKey);\n      JS('void', '#.altGraphKey = #', eventObj, altGraphKey);\n    } else {\n      // Currently this works on everything but Safari. Safari throws an\n      // \"Attempting to change access mechanism for an unconfigurable property\"\n      // TypeError when trying to do the Object.defineProperty hack, so we avoid\n      // this branch if possible.\n      // Also, if we want this branch to work in FF, we also need to modify\n      // _initKeyboardEvent to also take charCode and keyCode values to\n      // initialize initKeyEvent.\n\n      eventObj = new Event.eventType('KeyboardEvent', type,\n          canBubble: canBubble, cancelable: cancelable);\n\n      // Chromium Hack\n      JS('void', \"Object.defineProperty(#, 'keyCode', {\"\n          \"  get : function() { return this.keyCodeVal; } })\",  eventObj);\n      JS('void', \"Object.defineProperty(#, 'which', {\"\n          \"  get : function() { return this.keyCodeVal; } })\",  eventObj);\n      JS('void', \"Object.defineProperty(#, 'charCode', {\"\n          \"  get : function() { return this.charCodeVal; } })\",  eventObj);\n\n      var keyIdentifier = _convertToHexString(charCode, keyCode);\n      eventObj._initKeyboardEvent(type, canBubble, cancelable, view,\n          keyIdentifier, keyLocation, ctrlKey, altKey, shiftKey, metaKey,\n          altGraphKey);\n      JS('void', '#.keyCodeVal = #', eventObj, keyCode);\n      JS('void', '#.charCodeVal = #', eventObj, charCode);\n    }\n    // Tell dart2js that it smells like a KeyboardEvent!\n    setDispatchProperty(eventObj, _keyboardEventDispatchRecord);\n\n    var keyEvent = new KeyEvent.wrap(eventObj);\n    if (keyEvent._currentTarget == null) {\n      keyEvent._currentTarget = currentTarget == null ? window : currentTarget;\n    }\n    return keyEvent;\n  }\n\n  // Currently known to work on all browsers but IE.\n  static bool get canUseDispatchEvent =>\n      JS('bool',\n         '(typeof document.body.dispatchEvent == \"function\")'\n         '&& document.body.dispatchEvent.length > 0');\n\n  /** The currently registered target for this event. */\n  EventTarget get currentTarget => _currentTarget;\n\n  // This is an experimental method to be sure.\n  static String _convertToHexString(int charCode, int keyCode) {\n    if (charCode != -1) {\n      var hex = charCode.toRadixString(16); // Convert to hexadecimal.\n      StringBuffer sb = new StringBuffer('U+');\n      for (int i = 0; i < 4 - hex.length; i++) sb.write('0');\n      sb.write(hex);\n      return sb.toString();\n    } else {\n      return KeyCode._convertKeyCodeToKeyName(keyCode);\n    }\n  }\n\n  // TODO(efortuna): If KeyEvent is sufficiently successful that we want to make\n  // it the default keyboard event handling, move these methods over to Element.\n  /** Accessor to provide a stream of KeyEvents on the desired target. */\n  static EventStreamProvider<KeyEvent> keyDownEvent =\n      new _KeyboardEventHandler('keydown');\n  /** Accessor to provide a stream of KeyEvents on the desired target. */\n  static EventStreamProvider<KeyEvent> keyUpEvent =\n      new _KeyboardEventHandler('keyup');\n  /** Accessor to provide a stream of KeyEvents on the desired target. */\n  static EventStreamProvider<KeyEvent> keyPressEvent =\n      new _KeyboardEventHandler('keypress');\n\n  /** True if the altGraphKey is pressed during this event. */\n  bool get altGraphKey => _parent.altGraphKey;\n  /** Accessor to the clipboardData available for this event. */\n  DataTransfer get clipboardData => _parent.clipboardData;\n  /** True if the ctrl key is pressed during this event. */\n  bool get ctrlKey => _parent.ctrlKey;\n  int get detail => _parent.detail;\n  /**\n   * Accessor to the part of the keyboard that the key was pressed from (one of\n   * KeyLocation.STANDARD, KeyLocation.RIGHT, KeyLocation.LEFT,\n   * KeyLocation.NUMPAD, KeyLocation.MOBILE, KeyLocation.JOYSTICK).\n   */\n  int get keyLocation => _parent.keyLocation;\n  Point get layer => _parent.layer;\n  /** True if the Meta (or Mac command) key is pressed during this event. */\n  bool get metaKey => _parent.metaKey;\n  Point get page => _parent.page;\n  /** True if the shift key was pressed during this event. */\n  bool get shiftKey => _parent.shiftKey;\n  Window get view => _parent.view;\n  void _initUIEvent(String type, bool canBubble, bool cancelable,\n      Window view, int detail) {\n    throw new UnsupportedError(\"Cannot initialize a UI Event from a KeyEvent.\");\n  }\n  String get _shadowKeyIdentifier => JS('String', '#.keyIdentifier', _parent);\n\n  int get _charCode => charCode;\n  int get _keyCode => keyCode;\n  String get _keyIdentifier {\n    throw new UnsupportedError(\"keyIdentifier is unsupported.\");\n  }\n  void _initKeyboardEvent(String type, bool canBubble, bool cancelable,\n      Window view, String keyIdentifier, int keyLocation, bool ctrlKey,\n      bool altKey, bool shiftKey, bool metaKey,\n      bool altGraphKey) {\n    throw new UnsupportedError(\n        \"Cannot initialize a KeyboardEvent from a KeyEvent.\");\n  }\n  int get _layerX => throw new UnsupportedError('Not applicable to KeyEvent');\n  int get _layerY => throw new UnsupportedError('Not applicable to KeyEvent');\n  int get _pageX => throw new UnsupportedError('Not applicable to KeyEvent');\n  int get _pageY => throw new UnsupportedError('Not applicable to KeyEvent');\n  @Experimental() // untriaged\n  bool getModifierState(String keyArgument) => throw new UnimplementedError();\n  @Experimental() // untriaged\n  int get location => throw new UnimplementedError();\n  @Experimental() // untriaged\n  bool get repeat => throw new UnimplementedError();\n  dynamic get _get_view => throw new UnimplementedError();\n}\n// Copyright (c) 2013, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\nclass Platform {\n  /**\n   * Returns true if dart:typed_data types are supported on this\n   * browser.  If false, using these types will generate a runtime\n   * error.\n   */\n  static final supportsTypedData = JS('bool', '!!(window.ArrayBuffer)');\n\n  /**\n   * Returns true if SIMD types in dart:typed_data types are supported\n   * on this browser.  If false, using these types will generate a runtime\n   * error.\n   */\n  static final supportsSimd = false;\n}\n// Copyright (c) 2013, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n/**\n * Helper class to implement custom events which wrap DOM events.\n */\nclass _WrappedEvent implements Event {\n  final Event wrapped;\n\n  /** The CSS selector involved with event delegation. */\n  String _selector;\n\n  _WrappedEvent(this.wrapped);\n\n  bool get bubbles => wrapped.bubbles;\n\n  bool get cancelable => wrapped.cancelable;\n\n  DataTransfer get clipboardData => wrapped.clipboardData;\n\n  EventTarget get currentTarget => wrapped.currentTarget;\n\n  bool get defaultPrevented => wrapped.defaultPrevented;\n\n  int get eventPhase => wrapped.eventPhase;\n\n  EventTarget get target => wrapped.target;\n\n  int get timeStamp => wrapped.timeStamp;\n\n  String get type => wrapped.type;\n\n  void _initEvent(String eventTypeArg, bool canBubbleArg,\n      bool cancelableArg) {\n    throw new UnsupportedError(\n        'Cannot initialize this Event.');\n  }\n\n  void preventDefault() {\n    wrapped.preventDefault();\n  }\n\n  void stopImmediatePropagation() {\n    wrapped.stopImmediatePropagation();\n  }\n\n  void stopPropagation() {\n    wrapped.stopPropagation();\n  }\n\n  /**\n   * A pointer to the element whose CSS selector matched within which an event\n   * was fired. If this Event was not associated with any Event delegation,\n   * accessing this value will throw an [UnsupportedError].\n   */\n  Element get matchingTarget {\n    if (_selector == null) {\n      throw new UnsupportedError('Cannot call matchingTarget if this Event did'\n          ' not arise as a result of event delegation.');\n    }\n    var currentTarget = this.currentTarget;\n    var target = this.target;\n    var matchedTarget;\n    do {\n      if (target.matches(_selector)) return target;\n      target = target.parent;\n    } while (target != null && target != currentTarget.parent);\n    throw new StateError('No selector matched for populating matchedTarget.');\n  }\n\n  /**\n   * This event's path, taking into account shadow DOM.\n   *\n   * ## Other resources\n   *\n   * * [Shadow DOM extensions to Event]\n   * (http://w3c.github.io/webcomponents/spec/shadow/#extensions-to-event) from\n   * W3C.\n   */\n  // https://dvcs.w3.org/hg/webcomponents/raw-file/tip/spec/shadow/index.html#extensions-to-event\n  @Experimental()\n  List<Node> get path => wrapped.path;\n\n  dynamic get _get_currentTarget => wrapped._get_currentTarget;\n\n  dynamic get _get_target => wrapped._get_target;\n}\n// Copyright (c) 2013, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n_wrapZone(callback(arg)) {\n  // For performance reasons avoid wrapping if we are in the root zone.\n  if (Zone.current == Zone.ROOT) return callback;\n  if (callback == null) return null;\n  return Zone.current.bindUnaryCallback(callback, runGuarded: true);\n}\n\n_wrapBinaryZone(callback(arg1, arg2)) {\n  if (Zone.current == Zone.ROOT) return callback;\n  if (callback == null) return null;\n  return Zone.current.bindBinaryCallback(callback, runGuarded: true);\n}\n\n/**\n * Alias for [querySelector]. Note this function is deprecated because its\n * semantics will be changing in the future.\n */\n@deprecated\n@Experimental()\nElement query(String relativeSelectors) => document.query(relativeSelectors);\n/**\n * Alias for [querySelectorAll]. Note this function is deprecated because its\n * semantics will be changing in the future.\n */\n@deprecated\n@Experimental()\nElementList queryAll(String relativeSelectors) => document.queryAll(relativeSelectors);\n\n/**\n * Finds the first descendant element of this document that matches the\n * specified group of selectors.\n *\n * Unless your webpage contains multiple documents, the top-level\n * [querySelector]\n * method behaves the same as this method, so you should use it instead to\n * save typing a few characters.\n *\n * [selectors] should be a string using CSS selector syntax.\n *\n *     var element1 = document.querySelector('.className');\n *     var element2 = document.querySelector('#id');\n *\n * For details about CSS selector syntax, see the\n * [CSS selector specification](http://www.w3.org/TR/css3-selectors/).\n */\nElement querySelector(String selectors) => document.querySelector(selectors);\n\n/**\n * Finds all descendant elements of this document that match the specified\n * group of selectors.\n *\n * Unless your webpage contains multiple documents, the top-level\n * [querySelectorAll]\n * method behaves the same as this method, so you should use it instead to\n * save typing a few characters.\n *\n * [selectors] should be a string using CSS selector syntax.\n *\n *     var items = document.querySelectorAll('.itemClassName');\n *\n * For details about CSS selector syntax, see the\n * [CSS selector specification](http://www.w3.org/TR/css3-selectors/).\n */\nElementList querySelectorAll(String selectors) => document.querySelectorAll(selectors);\n\n/// A utility for changing the Dart wrapper type for elements.\nabstract class ElementUpgrader {\n  /// Upgrade the specified element to be of the Dart type this was created for.\n  ///\n  /// After upgrading the element passed in is invalid and the returned value\n  /// should be used instead.\n  Element upgrade(Element element);\n}\n// Copyright (c) 2013, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n\n/**\n * Interface used to validate that only accepted elements and attributes are\n * allowed while parsing HTML strings into DOM nodes.\n *\n * In general, customization of validation behavior should be done via the\n * [NodeValidatorBuilder] class to mitigate the chances of incorrectly\n * implementing validation rules.\n */\nabstract class NodeValidator {\n\n  /**\n   * Construct a default NodeValidator which only accepts whitelisted HTML5\n   * elements and attributes.\n   *\n   * If a uriPolicy is not specified then the default uriPolicy will be used.\n   */\n  factory NodeValidator({UriPolicy uriPolicy}) =>\n      new _Html5NodeValidator(uriPolicy: uriPolicy);\n\n  factory NodeValidator.throws(NodeValidator base) =>\n      new _ThrowsNodeValidator(base);\n\n  /**\n   * Returns true if the tagName is an accepted type.\n   */\n  bool allowsElement(Element element);\n\n  /**\n   * Returns true if the attribute is allowed.\n   *\n   * The attributeName parameter will always be in lowercase.\n   *\n   * See [allowsElement] for format of tagName.\n   */\n  bool allowsAttribute(Element element, String attributeName, String value);\n}\n\n/**\n * Performs sanitization of a node tree after construction to ensure that it\n * does not contain any disallowed elements or attributes.\n *\n * In general custom implementations of this class should not be necessary and\n * all validation customization should be done in custom NodeValidators, but\n * custom implementations of this class can be created to perform more complex\n * tree sanitization.\n */\nabstract class NodeTreeSanitizer {\n\n  /**\n   * Constructs a default tree sanitizer which will remove all elements and\n   * attributes which are not allowed by the provided validator.\n   */\n  factory NodeTreeSanitizer(NodeValidator validator) =>\n      new _ValidatingTreeSanitizer(validator);\n\n  /**\n   * Called with the root of the tree which is to be sanitized.\n   *\n   * This method needs to walk the entire tree and either remove elements and\n   * attributes which are not recognized as safe or throw an exception which\n   * will mark the entire tree as unsafe.\n   */\n  void sanitizeTree(Node node);\n}\n\n/**\n * Defines the policy for what types of uris are allowed for particular\n * attribute values.\n *\n * This can be used to provide custom rules such as allowing all http:// URIs\n * for image attributes but only same-origin URIs for anchor tags.\n */\nabstract class UriPolicy {\n  /**\n   * Constructs the default UriPolicy which is to only allow Uris to the same\n   * origin as the application was launched from.\n   *\n   * This will block all ftp: mailto: URIs. It will also block accessing\n   * https://example.com if the app is running from http://example.com.\n   */\n  factory UriPolicy() => new _SameOriginUriPolicy();\n\n  /**\n   * Checks if the uri is allowed on the specified attribute.\n   *\n   * The uri provided may or may not be a relative path.\n   */\n  bool allowsUri(String uri);\n}\n\n/**\n * Allows URIs to the same origin as the current application was loaded from\n * (such as https://example.com:80).\n */\nclass _SameOriginUriPolicy implements UriPolicy {\n  final AnchorElement _hiddenAnchor = new AnchorElement();\n  final Location _loc = window.location;\n\n  bool allowsUri(String uri) {\n    _hiddenAnchor.href = uri;\n    // IE leaves an empty hostname for same-origin URIs.\n    return (_hiddenAnchor.hostname == _loc.hostname &&\n        _hiddenAnchor.port == _loc.port &&\n        _hiddenAnchor.protocol == _loc.protocol) ||\n        (_hiddenAnchor.hostname == '' &&\n        _hiddenAnchor.port == '' &&\n        _hiddenAnchor.protocol == ':');\n  }\n}\n\n\nclass _ThrowsNodeValidator implements NodeValidator {\n  final NodeValidator validator;\n\n  _ThrowsNodeValidator(this.validator) {}\n\n  bool allowsElement(Element element) {\n    if (!validator.allowsElement(element)) {\n      throw new ArgumentError(element.tagName);\n    }\n    return true;\n  }\n\n  bool allowsAttribute(Element element, String attributeName, String value) {\n    if (!validator.allowsAttribute(element, attributeName, value)) {\n      throw new ArgumentError('${element.tagName}[$attributeName=\"$value\"]');\n    }\n  }\n}\n\n\n/**\n * Standard tree sanitizer which validates a node tree against the provided\n * validator and removes any nodes or attributes which are not allowed.\n */\nclass _ValidatingTreeSanitizer implements NodeTreeSanitizer {\n  NodeValidator validator;\n  _ValidatingTreeSanitizer(this.validator) {}\n\n  void sanitizeTree(Node node) {\n    void walk(Node node) {\n      sanitizeNode(node);\n\n      var child = node.lastChild;\n      while (child != null) {\n        // Child may be removed during the walk.\n        var nextChild = child.previousNode;\n        walk(child);\n        child = nextChild;\n      }\n    }\n    walk(node);\n  }\n\n  void sanitizeNode(Node node) {\n    switch (node.nodeType) {\n      case Node.ELEMENT_NODE:\n        Element element = node;\n        var attrs = element.attributes;\n        if (!validator.allowsElement(element)) {\n          window.console.warn(\n              'Removing disallowed element <${element.tagName}>');\n          element.remove();\n          break;\n        }\n\n        var isAttr = attrs['is'];\n        if (isAttr != null) {\n          if (!validator.allowsAttribute(element, 'is', isAttr)) {\n            window.console.warn('Removing disallowed type extension '\n                '<${element.tagName} is=\"$isAttr\">');\n            element.remove();\n            break;\n          }\n        }\n\n        // TODO(blois): Need to be able to get all attributes, irrespective of\n        // XMLNS.\n        var keys = attrs.keys.toList();\n        for (var i = attrs.length - 1; i >= 0; --i) {\n          var name = keys[i];\n          if (!validator.allowsAttribute(element, name.toLowerCase(),\n              attrs[name])) {\n            window.console.warn('Removing disallowed attribute '\n                '<${element.tagName} $name=\"${attrs[name]}\">');\n            attrs.remove(name);\n          }\n        }\n\n        if (element is TemplateElement) {\n          TemplateElement template = element;\n          sanitizeTree(template.content);\n        }\n        break;\n      case Node.COMMENT_NODE:\n      case Node.DOCUMENT_FRAGMENT_NODE:\n      case Node.TEXT_NODE:\n      case Node.CDATA_SECTION_NODE:\n        break;\n      default:\n        node.remove();\n    }\n  }\n}\n\u0000","sdk:/sdk/lib/html/html_common/lists.dart":"// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\npart of html_common;\n\nclass Lists {\n\n  /**\n   * Returns the index in the array [a] of the given [element], starting\n   * the search at index [startIndex] to [endIndex] (exclusive).\n   * Returns -1 if [element] is not found.\n   */\n  static int indexOf(List a,\n                     Object element,\n                     int startIndex,\n                     int endIndex) {\n    if (startIndex >= a.length) {\n      return -1;\n    }\n    if (startIndex < 0) {\n      startIndex = 0;\n    }\n    for (int i = startIndex; i < endIndex; i++) {\n      if (a[i] == element) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Returns the last index in the array [a] of the given [element], starting\n   * the search at index [startIndex] to 0.\n   * Returns -1 if [element] is not found.\n   */\n  static int lastIndexOf(List a, Object element, int startIndex) {\n    if (startIndex < 0) {\n      return -1;\n    }\n    if (startIndex >= a.length) {\n      startIndex = a.length - 1;\n    }\n    for (int i = startIndex; i >= 0; i--) {\n      if (a[i] == element) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Returns a sub list copy of this list, from [start] to\n   * [end] ([end] not inclusive).\n   * Returns an empty list if [length] is 0.\n   * It is an error if indices are not valid for the list, or\n   * if [end] is before [start].\n   */\n  static List getRange(List a, int start, int end, List accumulator) {\n    if (start < 0) throw new RangeError.value(start);\n    if (end < start) throw new RangeError.value(end);\n    if (end > a.length) throw new RangeError.value(end);\n    for (int i = start; i < end; i++) {\n      accumulator.add(a[i]);\n    }\n    return accumulator;\n  }\n}\n\n/**\n * For accessing underlying node lists, for dart:js interop.\n */\nabstract class NodeListWrapper {\n  List<Node> get rawList;\n}\n\u0000","sdk:/sdk/lib/html/html_common/filtered_element_list.dart":"// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\npart of html_common;\n\n/**\n * An indexable collection of a node's descendants in the document tree,\n * filtered so that only elements are in the collection.\n */\nclass FilteredElementList<T extends Element> extends ListBase<T>\n    implements NodeListWrapper{\n  final Node _node;\n  final List<Node> _childNodes;\n\n  /**\n   * Creates a collection of the elements that descend from a node.\n   *\n   * Example usage:\n   *\n   *     var filteredElements = new FilteredElementList(query(\"#container\"));\n   *     // filteredElements is [a, b, c].\n   */\n  FilteredElementList(Node node): _childNodes = node.nodes, _node = node;\n\n  // We can't memoize this, since it's possible that children will be messed\n  // with externally to this class.\n  //\n  // TODO(nweiz): we don't always need to create a new list. For example\n  // forEach, every, any, ... could directly work on the _childNodes.\n  List<Element> get _filtered =>\n    new List<Element>.from(_childNodes.where((n) => n is Element));\n\n  void forEach(void f(Element element)) {\n    _filtered.forEach(f);\n  }\n\n  void operator []=(int index, Element value) {\n    this[index].replaceWith(value);\n  }\n\n  void set length(int newLength) {\n    final len = this.length;\n    if (newLength >= len) {\n      return;\n    } else if (newLength < 0) {\n      throw new ArgumentError(\"Invalid list length\");\n    }\n\n    removeRange(newLength, len);\n  }\n\n  void add(Element value) {\n    _childNodes.add(value);\n  }\n\n  void addAll(Iterable<Element> iterable) {\n    for (Element element in iterable) {\n      add(element);\n    }\n  }\n\n  bool contains(Object needle) {\n    if (needle is! Element) return false;\n    Element element = needle;\n    return element.parentNode == _node;\n  }\n\n  Iterable<Element> get reversed => _filtered.reversed;\n\n  void sort([int compare(Element a, Element b)]) {\n    throw new UnsupportedError('Cannot sort filtered list');\n  }\n\n  void setRange(int start, int end, Iterable<Element> iterable,\n                [int skipCount = 0]) {\n    throw new UnsupportedError('Cannot setRange on filtered list');\n  }\n\n  void fillRange(int start, int end, [Element fillValue]) {\n    throw new UnsupportedError('Cannot fillRange on filtered list');\n  }\n\n  void replaceRange(int start, int end, Iterable<Element> iterable) {\n    throw new UnsupportedError('Cannot replaceRange on filtered list');\n  }\n\n  void removeRange(int start, int end) {\n    _filtered.sublist(start, end).forEach((el) => el.remove());\n  }\n\n  void clear() {\n    // Currently, ElementList#clear clears even non-element nodes, so we follow\n    // that behavior.\n    _childNodes.clear();\n  }\n\n  Element removeLast() {\n    final result = this.last;\n    if (result != null) {\n      result.remove();\n    }\n    return result;\n  }\n\n  void insert(int index, Element value) {\n    _childNodes.insert(index, value);\n  }\n\n  void insertAll(int index, Iterable<Element> iterable) {\n    _childNodes.insertAll(index, iterable);\n  }\n\n  Element removeAt(int index) {\n    final result = this[index];\n    result.remove();\n    return result;\n  }\n\n  bool remove(Object element) {\n    if (element is! Element) return false;\n    for (int i = 0; i < length; i++) {\n      Element indexElement = this[i];\n      if (identical(indexElement, element)) {\n        indexElement.remove();\n        return true;\n      }\n    }\n    return false;\n  }\n\n  int get length => _filtered.length;\n  Element operator [](int index) => _filtered[index];\n  Iterator<Element> get iterator => _filtered.iterator;\n\n  List<Node> get rawList => _node.childNodes;\n}\n\u0000","sdk:/sdk/lib/html/html_common/device.dart":"// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\npart of html_common;\n\n/**\n * Utils for device detection.\n */\nclass Device {\n  static bool _isOpera;\n  static bool _isIE;\n  static bool _isFirefox;\n  static bool _isWebKit;\n  static String _cachedCssPrefix;\n  static String _cachedPropertyPrefix;\n\n  /**\n   * Gets the browser's user agent. Using this function allows tests to inject\n   * the user agent.\n * Returns the user agent.\n   */\n  static String get userAgent => window.navigator.userAgent;\n\n  /**\n   * Determines if the current device is running Opera.\n   */\n  static bool get isOpera {\n    if (_isOpera == null) {\n      _isOpera = userAgent.contains(\"Opera\", 0);\n    }\n    return _isOpera;\n  }\n\n  /**\n   * Determines if the current device is running Internet Explorer.\n   */\n  static bool get isIE {\n    if (_isIE == null) {\n      _isIE = !isOpera && userAgent.contains(\"Trident/\", 0);\n    }\n    return _isIE;\n  }\n\n  /**\n   * Determines if the current device is running Firefox.\n   */\n  static bool get isFirefox {\n    if (_isFirefox == null) {\n      _isFirefox = userAgent.contains(\"Firefox\", 0);\n    }\n    return _isFirefox;\n  }\n\n  /**\n   * Determines if the current device is running WebKit.\n   */\n  static bool get isWebKit {\n    if (_isWebKit == null) {\n      _isWebKit = !isOpera && userAgent.contains(\"WebKit\", 0);\n    }\n    return _isWebKit;\n  }\n\n  /**\n   * Gets the CSS property prefix for the current platform.\n   */\n  static String get cssPrefix {\n    if (_cachedCssPrefix == null) {\n      if (isFirefox) {\n        _cachedCssPrefix = '-moz-';\n      } else if (isIE) {\n        _cachedCssPrefix = '-ms-';\n      } else if (isOpera) {\n        _cachedCssPrefix = '-o-';\n      } else {\n        _cachedCssPrefix = '-webkit-';\n      }\n    }\n    return _cachedCssPrefix;\n  }\n\n  /**\n   * Prefix as used for JS property names.\n   */\n  static String get propertyPrefix {\n    if (_cachedPropertyPrefix == null) {\n      if (isFirefox) {\n        _cachedPropertyPrefix = 'moz';\n      } else if (isIE) {\n        _cachedPropertyPrefix = 'ms';\n      } else if (isOpera) {\n        _cachedPropertyPrefix = 'o';\n      } else {\n        _cachedPropertyPrefix = 'webkit';\n      }\n    }\n    return _cachedPropertyPrefix;\n  }\n\n  /**\n   * Checks to see if the event class is supported by the current platform.\n   */\n  static bool isEventTypeSupported(String eventType) {\n    // Browsers throw for unsupported event names.\n    try {\n      var e = new Event.eventType(eventType, '');\n      return e is Event;\n    } catch (_) { }\n    return false;\n  }\n}\n\u0000","sdk:/sdk/lib/html/html_common/conversions.dart":"// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n// Conversions for IDBKey.\n//\n// Per http://www.w3.org/TR/IndexedDB/#key-construct\n//\n// \"A value is said to be a valid key if it is one of the following types: Array\n// JavaScript objects [ECMA-262], DOMString [WEBIDL], Date [ECMA-262] or float\n// [WEBIDL]. However Arrays are only valid keys if every item in the array is\n// defined and is a valid key (i.e. sparse arrays can not be valid keys) and if\n// the Array doesn't directly or indirectly contain itself. Any non-numeric\n// properties are ignored, and thus does not affect whether the Array is a valid\n// key. Additionally, if the value is of type float, it is only a valid key if\n// it is not NaN, and if the value is of type Date it is only a valid key if its\n// [[PrimitiveValue]] internal property, as defined by [ECMA-262], is not NaN.\"\n\n// What is required is to ensure that an Lists in the key are actually\n// JavaScript arrays, and any Dates are JavaScript Dates.\n\n// Conversions for Window.  These check if the window is the local\n// window, and if it's not, wraps or unwraps it with a secure wrapper.\n// We need to test for EventTarget here as well as it's a base type.\n// We omit an unwrapper for Window as no methods take a non-local\n// window as a parameter.\n\npart of html_common;\n\n\n/// Converts a JavaScript object with properties into a Dart Map.\n/// Not suitable for nested objects.\nMap convertNativeToDart_Dictionary(object) {\n  if (object == null) return null;\n  var dict = {};\n  var keys = JS('JSExtendableArray', 'Object.getOwnPropertyNames(#)', object);\n  for (final key in keys) {\n    dict[key] = JS('var', '#[#]', object, key);\n  }\n  return dict;\n}\n\n/// Converts a flat Dart map into a JavaScript object with properties.\nconvertDartToNative_Dictionary(Map dict) {\n  if (dict == null) return null;\n  var object = JS('var', '{}');\n  dict.forEach((String key, value) {\n      JS('void', '#[#] = #', object, key, value);\n    });\n  return object;\n}\n\n\n/**\n * Ensures that the input is a JavaScript Array.\n *\n * Creates a new JavaScript array if necessary, otherwise returns the original.\n */\nList convertDartToNative_StringArray(List<String> input) {\n  // TODO(sra).  Implement this.\n  return input;\n}\n\nDateTime convertNativeToDart_DateTime(date) {\n  var millisSinceEpoch = JS('int', '#.getTime()', date);\n  return new DateTime.fromMillisecondsSinceEpoch(millisSinceEpoch, isUtc: true);\n}\n\nconvertDartToNative_DateTime(DateTime date) {\n  return JS('', 'new Date(#)', date.millisecondsSinceEpoch);\n}\n\n\n// -----------------------------------------------------------------------------\n\n/// Converts a Dart value into a JavaScript SerializedScriptValue.\nconvertDartToNative_SerializedScriptValue(value) {\n  return _convertDartToNative_PrepareForStructuredClone(value);\n}\n\n/// Since the source object may be viewed via a JavaScript event listener the\n/// original may not be modified.\nconvertNativeToDart_SerializedScriptValue(object) {\n  return convertNativeToDart_AcceptStructuredClone(object, mustCopy: true);\n}\n\n\n/**\n * Converts a Dart value into a JavaScript SerializedScriptValue.  Returns the\n * original input or a functional 'copy'.  Does not mutate the original.\n *\n * The main transformation is the translation of Dart Maps are converted to\n * JavaScript Objects.\n *\n * The algorithm is essentially a dry-run of the structured clone algorithm\n * described at\n * http://www.whatwg.org/specs/web-apps/current-work/multipage/common-dom-interfaces.html#structured-clone\n * https://www.khronos.org/registry/typedarray/specs/latest/#9\n *\n * Since the result of this function is expected to be passed only to JavaScript\n * operations that perform the structured clone algorithm which does not mutate\n * its output, the result may share structure with the input [value].\n */\n_convertDartToNative_PrepareForStructuredClone(value) {\n\n  // TODO(sra): Replace slots with identity hash table.\n  var values = [];\n  var copies = [];  // initially 'null', 'true' during initial DFS, then a copy.\n\n  int findSlot(value) {\n    int length = values.length;\n    for (int i = 0; i < length; i++) {\n      if (identical(values[i], value)) return i;\n    }\n    values.add(value);\n    copies.add(null);\n    return length;\n  }\n  readSlot(int i) => copies[i];\n  writeSlot(int i, x) { copies[i] = x; }\n  cleanupSlots() {}  // Will be needed if we mark objects with a property.\n\n  // Returns the input, or a clone of the input.\n  walk(e) {\n    if (e == null) return e;\n    if (e is bool) return e;\n    if (e is num) return e;\n    if (e is String) return e;\n    if (e is DateTime) {\n      return convertDartToNative_DateTime(e);\n    }\n    if (e is RegExp) {\n      // TODO(sra).\n      throw new UnimplementedError('structured clone of RegExp');\n    }\n\n    // The browser's internal structured cloning algorithm will copy certain\n    // types of object, but it will copy only its own implementations and not\n    // just any Dart implementations of the interface.\n\n    // TODO(sra): The JavaScript objects suitable for direct cloning by the\n    // structured clone algorithm could be tagged with an private interface.\n\n    if (e is File) return e;\n    if (e is Blob) return e;\n    if (e is FileList) return e;\n\n    // TODO(sra): Firefox: How to convert _TypedImageData on the other end?\n    if (e is ImageData) return e;\n    if (e is NativeByteBuffer) return e;\n\n    if (e is NativeTypedData) return e;\n\n    if (e is Map) {\n      var slot = findSlot(e);\n      var copy = readSlot(slot);\n      if (copy != null) return copy;\n      copy = JS('var', '{}');\n      writeSlot(slot, copy);\n      e.forEach((key, value) {\n          JS('void', '#[#] = #', copy, key, walk(value));\n        });\n      return copy;\n    }\n\n    if (e is List) {\n      // Since a JavaScript Array is an instance of Dart List it is possible to\n      // avoid making a copy of the list if there is no need to copy anything\n      // reachable from the array.  We defer creating a new array until a cycle\n      // is detected or a subgraph was copied.\n      int length = e.length;\n      var slot = findSlot(e);\n      var copy = readSlot(slot);\n      if (copy != null) {\n        if (true == copy) {  // Cycle, so commit to making a copy.\n          copy = JS('JSExtendableArray', 'new Array(#)', length);\n          writeSlot(slot, copy);\n        }\n        return copy;\n      }\n\n      int i = 0;\n\n      // Always clone the list, as it may have non-native properties or methods\n      // from interceptors and such.\n      copy = JS('JSExtendableArray', 'new Array(#)', length);\n      writeSlot(slot, copy);\n\n      for ( ; i < length; i++) {\n        copy[i] = walk(e[i]);\n      }\n      return copy;\n    }\n\n    throw new UnimplementedError('structured clone of other type');\n  }\n\n  var copy = walk(value);\n  cleanupSlots();\n  return copy;\n}\n\n/**\n * Converts a native value into a Dart object.\n *\n * If [mustCopy] is [:false:], may return the original input.  May mutate the\n * original input (but will be idempotent if mutation occurs).  It is assumed\n * that this conversion happens on native serializable script values such values\n * from native DOM calls.\n *\n * [object] is the result of a structured clone operation.\n *\n * If necessary, JavaScript Dates are converted into Dart Dates.\n *\n * If [mustCopy] is [:true:], the entire object is copied and the original input\n * is not mutated.  This should be the case where Dart and JavaScript code can\n * access the value, for example, via multiple event listeners for\n * MessageEvents.  Mutating the object to make it more 'Dart-like' would corrupt\n * the value as seen from the JavaScript listeners.\n */\nconvertNativeToDart_AcceptStructuredClone(object, {mustCopy: false}) {\n\n  // TODO(sra): Replace slots with identity hash table that works on non-dart\n  // objects.\n  var values = [];\n  var copies = [];\n\n  int findSlot(value) {\n    int length = values.length;\n    for (int i = 0; i < length; i++) {\n      if (identical(values[i], value)) return i;\n    }\n    values.add(value);\n    copies.add(null);\n    return length;\n  }\n  readSlot(int i) => copies[i];\n  writeSlot(int i, x) { copies[i] = x; }\n\n  walk(e) {\n    if (e == null) return e;\n    if (e is bool) return e;\n    if (e is num) return e;\n    if (e is String) return e;\n\n    if (isJavaScriptDate(e)) {\n      return convertNativeToDart_DateTime(e);\n    }\n\n    if (isJavaScriptRegExp(e)) {\n      // TODO(sra).\n      throw new UnimplementedError('structured clone of RegExp');\n    }\n\n    if (isJavaScriptSimpleObject(e)) {\n      // TODO(sra): If mustCopy is false, swizzle the prototype for one of a Map\n      // implementation that uses the properies as storage.\n      var slot = findSlot(e);\n      var copy = readSlot(slot);\n      if (copy != null) return copy;\n      copy = {};\n\n      writeSlot(slot, copy);\n      for (final key in JS('JSExtendableArray', 'Object.keys(#)', e)) {\n        copy[key] = walk(JS('var', '#[#]', e, key));\n      }\n      return copy;\n    }\n\n    if (isJavaScriptArray(e)) {\n      var slot = findSlot(e);\n      var copy = readSlot(slot);\n      if (copy != null) return copy;\n\n      int length = e.length;\n      // Since a JavaScript Array is an instance of Dart List, we can modify it\n      // in-place unless we must copy.\n      copy = mustCopy ? JS('JSExtendableArray', 'new Array(#)', length) : e;\n      writeSlot(slot, copy);\n\n      for (int i = 0; i < length; i++) {\n        copy[i] = walk(e[i]);\n      }\n      return copy;\n    }\n\n    // Assume anything else is already a valid Dart object, either by having\n    // already been processed, or e.g. a clonable native class.\n    return e;\n  }\n\n  var copy = walk(object);\n  return copy;\n}\n\n// Conversions for ContextAttributes.\n//\n// On Firefox, the returned ContextAttributes is a plain object.\nclass _TypedContextAttributes implements gl.ContextAttributes {\n  bool alpha;\n  bool antialias;\n  bool depth;\n  bool premultipliedAlpha;\n  bool preserveDrawingBuffer;\n  bool stencil;\n  bool failIfMajorPerformanceCaveat;\n\n  _TypedContextAttributes(this.alpha, this.antialias, this.depth,\n      this.failIfMajorPerformanceCaveat, this.premultipliedAlpha,\n      this.preserveDrawingBuffer, this.stencil);\n}\n\ngl.ContextAttributes convertNativeToDart_ContextAttributes(\n    nativeContextAttributes) {\n  if (nativeContextAttributes is gl.ContextAttributes) {\n    return nativeContextAttributes;\n  }\n\n  // On Firefox the above test fails because ContextAttributes is a plain\n  // object so we create a _TypedContextAttributes.\n\n  return new _TypedContextAttributes(\n      JS('var', '#.alpha', nativeContextAttributes),\n      JS('var', '#.antialias', nativeContextAttributes),\n      JS('var', '#.depth', nativeContextAttributes),\n      JS('var', '#.failIfMajorPerformanceCaveat', nativeContextAttributes),\n      JS('var', '#.premultipliedAlpha', nativeContextAttributes),\n      JS('var', '#.preserveDrawingBuffer', nativeContextAttributes),\n      JS('var', '#.stencil', nativeContextAttributes));\n}\n\n// Conversions for ImageData\n//\n// On Firefox, the returned ImageData is a plain object.\n\nclass _TypedImageData implements ImageData {\n  final NativeUint8ClampedList data;\n  final int height;\n  final int width;\n\n  _TypedImageData(this.data, this.height, this.width);\n}\n\nImageData convertNativeToDart_ImageData(nativeImageData) {\n\n  // None of the native getters that return ImageData are declared as returning\n  // [ImageData] since that is incorrect for FireFox, which returns a plain\n  // Object.  So we need something that tells the compiler that the ImageData\n  // class has been instantiated.\n  // TODO(sra): Remove this when all the ImageData returning APIs have been\n  // annotated as returning the union ImageData + Object.\n  JS('ImageData', '0');\n\n  if (nativeImageData is ImageData) {\n\n    // Fix for Issue 16069: on IE, the `data` field is a CanvasPixelArray which\n    // has Array as the constructor property.  This interferes with finding the\n    // correct interceptor.  Fix it by overwriting the constructor property.\n    var data = nativeImageData.data;\n    if (JS('bool', '#.constructor === Array', data)) {\n      if (JS('bool', 'typeof CanvasPixelArray !== \"undefined\"')) {\n        JS('void', '#.constructor = CanvasPixelArray', data);\n        // This TypedArray property is missing from CanvasPixelArray.\n        JS('void', '#.BYTES_PER_ELEMENT = 1', data);\n      }\n    }\n\n    return nativeImageData;\n  }\n\n  // On Firefox the above test fails because [nativeImageData] is a plain\n  // object.  So we create a _TypedImageData.\n\n  return new _TypedImageData(\n      JS('NativeUint8ClampedList', '#.data', nativeImageData),\n      JS('var', '#.height', nativeImageData),\n      JS('var', '#.width', nativeImageData));\n}\n\n// We can get rid of this conversion if _TypedImageData implements the fields\n// with native names.\nconvertDartToNative_ImageData(ImageData imageData) {\n  if (imageData is _TypedImageData) {\n    return JS('', '{data: #, height: #, width: #}',\n        imageData.data, imageData.height, imageData.width);\n  }\n  return imageData;\n}\n\n\nbool isJavaScriptDate(value) => JS('bool', '# instanceof Date', value);\nbool isJavaScriptRegExp(value) => JS('bool', '# instanceof RegExp', value);\nbool isJavaScriptArray(value) => JS('bool', '# instanceof Array', value);\nbool isJavaScriptSimpleObject(value) =>\n    JS('bool', 'Object.getPrototypeOf(#) === Object.prototype', value);\nbool isImmutableJavaScriptArray(value) =>\n    JS('bool', r'!!(#.immutable$list)', value);\n\n\n\nconst String _serializedScriptValue =\n    'num|String|bool|'\n    'JSExtendableArray|=Object|'\n    'Blob|File|NativeByteBuffer|NativeTypedData'\n    // TODO(sra): Add Date, RegExp.\n    ;\nconst annotation_Creates_SerializedScriptValue =\n    const Creates(_serializedScriptValue);\nconst annotation_Returns_SerializedScriptValue =\n    const Returns(_serializedScriptValue);\n\u0000","sdk:/sdk/lib/html/html_common/css_class_set.dart":"// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\npart of html_common;\n\nabstract class CssClassSetImpl implements CssClassSet {\n\n  String toString() {\n    return readClasses().join(' ');\n  }\n\n  /**\n   * Adds the class [value] to the element if it is not on it, removes it if it\n   * is.\n   *\n   * If [shouldAdd] is true, then we always add that [value] to the element. If\n   * [shouldAdd] is false then we always remove [value] from the element.\n   */\n  bool toggle(String value, [bool shouldAdd]) {\n    Set<String> s = readClasses();\n    bool result = false;\n    if (shouldAdd == null) shouldAdd = !s.contains(value);\n    if (shouldAdd) {\n      s.add(value);\n      result = true;\n    } else {\n      s.remove(value);\n    }\n    writeClasses(s);\n    return result;\n  }\n\n  /**\n   * Returns [:true:] if classes cannot be added or removed from this\n   * [:CssClassSet:].\n   */\n  bool get frozen => false;\n\n  // interface Iterable - BEGIN\n  Iterator<String> get iterator => readClasses().iterator;\n  // interface Iterable - END\n\n  // interface Collection - BEGIN\n  void forEach(void f(String element)) {\n    readClasses().forEach(f);\n  }\n\n  String join([String separator = \"\"]) => readClasses().join(separator);\n\n  Iterable map(f(String element)) => readClasses().map(f);\n\n  Iterable<String> where(bool f(String element)) => readClasses().where(f);\n\n  Iterable expand(Iterable f(String element)) => readClasses().expand(f);\n\n  bool every(bool f(String element)) => readClasses().every(f);\n\n  bool any(bool f(String element)) => readClasses().any(f);\n\n  bool get isEmpty => readClasses().isEmpty;\n\n  bool get isNotEmpty => readClasses().isNotEmpty;\n\n  int get length => readClasses().length;\n\n  String reduce(String combine(String value, String element)) {\n    return readClasses().reduce(combine);\n  }\n\n  dynamic fold(dynamic initialValue,\n      dynamic combine(dynamic previousValue, String element)) {\n    return readClasses().fold(initialValue, combine);\n  }\n  // interface Collection - END\n\n  // interface Set - BEGIN\n  /**\n   * Determine if this element contains the class [value].\n   *\n   * This is the Dart equivalent of jQuery's\n   * [hasClass](http://api.jquery.com/hasClass/).\n   */\n  bool contains(String value) => readClasses().contains(value);\n\n  /** Lookup from the Set interface. Not interesting for a String set. */\n  String lookup(String value) => contains(value) ? value : null;\n\n  /**\n   * Add the class [value] to element.\n   *\n   * This is the Dart equivalent of jQuery's\n   * [addClass](http://api.jquery.com/addClass/).\n   */\n  bool add(String value) {\n    // TODO - figure out if we need to do any validation here\n    // or if the browser natively does enough.\n    return modify((s) => s.add(value));\n  }\n\n  /**\n   * Remove the class [value] from element, and return true on successful\n   * removal.\n   *\n   * This is the Dart equivalent of jQuery's\n   * [removeClass](http://api.jquery.com/removeClass/).\n   */\n  bool remove(Object value) {\n    if (value is! String) return false;\n    Set<String> s = readClasses();\n    bool result = s.remove(value);\n    writeClasses(s);\n    return result;\n  }\n\n  /**\n   * Add all classes specified in [iterable] to element.\n   *\n   * This is the Dart equivalent of jQuery's\n   * [addClass](http://api.jquery.com/addClass/).\n   */\n  void addAll(Iterable<String> iterable) {\n    // TODO - see comment above about validation.\n    modify((s) => s.addAll(iterable));\n  }\n\n  /**\n   * Remove all classes specified in [iterable] from element.\n   *\n   * This is the Dart equivalent of jQuery's\n   * [removeClass](http://api.jquery.com/removeClass/).\n   */\n  void removeAll(Iterable<String> iterable) {\n    modify((s) => s.removeAll(iterable));\n  }\n\n  /**\n   * Toggles all classes specified in [iterable] on element.\n   *\n   * Iterate through [iterable]'s items, and add it if it is not on it, or\n   * remove it if it is. This is the Dart equivalent of jQuery's\n   * [toggleClass](http://api.jquery.com/toggleClass/).\n   * If [shouldAdd] is true, then we always add all the classes in [iterable]\n   * element. If [shouldAdd] is false then we always remove all the classes in\n   * [iterable] from the element.\n   */\n  void toggleAll(Iterable<String> iterable, [bool shouldAdd]) {\n    iterable.forEach((e) => toggle(e, shouldAdd));\n  }\n\n  void retainAll(Iterable<String> iterable) {\n    modify((s) => s.retainAll(iterable));\n  }\n\n  void removeWhere(bool test(String name)) {\n    modify((s) => s.removeWhere(test));\n  }\n\n  void retainWhere(bool test(String name)) {\n    modify((s) => s.retainWhere(test));\n  }\n\n  bool containsAll(Iterable<String> collection) =>\n    readClasses().containsAll(collection);\n\n  Set<String> intersection(Set<String> other) =>\n    readClasses().intersection(other);\n\n  Set<String> union(Set<String> other) =>\n    readClasses().union(other);\n\n  Set<String> difference(Set<String> other) =>\n    readClasses().difference(other);\n\n  String get first => readClasses().first;\n  String get last => readClasses().last;\n  String get single => readClasses().single;\n  List<String> toList({ bool growable: true }) =>\n      readClasses().toList(growable: growable);\n  Set<String> toSet() => readClasses().toSet();\n  Iterable<String> take(int n) => readClasses().take(n);\n  Iterable<String> takeWhile(bool test(String value)) =>\n      readClasses().takeWhile(test);\n  Iterable<String> skip(int n) => readClasses().skip(n);\n  Iterable<String> skipWhile(bool test(String value)) =>\n      readClasses().skipWhile(test);\n  dynamic firstWhere(bool test(String value), { Object orElse() }) =>\n      readClasses().firstWhere(test, orElse: orElse);\n  dynamic lastWhere(bool test(String value), { Object orElse()}) =>\n      readClasses().lastWhere(test, orElse: orElse);\n  String singleWhere(bool test(String value)) =>\n      readClasses().singleWhere(test);\n  String elementAt(int index) => readClasses().elementAt(index);\n\n  void clear() {\n    modify((s) => s.clear());\n  }\n  // interface Set - END\n\n  /**\n   * Helper method used to modify the set of css classes on this element.\n   *\n   *   f - callback with:\n   *   s - a Set of all the css class name currently on this element.\n   *\n   *   After f returns, the modified set is written to the\n   *       className property of this element.\n   */\n  modify( f(Set<String> s)) {\n    Set<String> s = readClasses();\n    var ret = f(s);\n    writeClasses(s);\n    return ret;\n  }\n\n  /**\n   * Read the class names from the Element class property,\n   * and put them into a set (duplicates are discarded).\n   * This is intended to be overridden by specific implementations.\n   */\n  Set<String> readClasses();\n\n  /**\n   * Join all the elements of a set into one string and write\n   * back to the element.\n   * This is intended to be overridden by specific implementations.\n   */\n  void writeClasses(Set<String> s);\n}\n\u0000","sdk:/sdk/lib/html/html_common/html_common_dart2js.dart":"// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\nlibrary html_common;\n\nimport 'dart:collection';\nimport 'dart:html';\nimport 'dart:web_gl' as gl;\nimport 'dart:_native_typed_data';\nimport 'dart:_js_helper' show Creates, Returns;\nimport 'dart:_foreign_helper' show JS;\nimport 'dart:_interceptors' show Interceptor, JSExtendableArray;\n\nimport 'metadata.dart';\nexport 'metadata.dart';\n\npart 'css_class_set.dart';\npart 'conversions.dart';\npart 'device.dart';\npart 'filtered_element_list.dart';\npart 'lists.dart';\n\u0000","sdk:/sdk/lib/web_gl/dart2js/web_gl_dart2js.dart":"/**\n * 3D programming in the browser.\n */\nlibrary dart.dom.web_gl;\n\nimport 'dart:collection';\nimport 'dart:_internal' hide deprecated;\nimport 'dart:html';\nimport 'dart:html_common';\nimport 'dart:_native_typed_data';\nimport 'dart:typed_data';\nimport 'dart:_js_helper' show Creates, JSName, Native, Null, Returns, convertDartClosureToJS;\nimport 'dart:_foreign_helper' show JS;\nimport 'dart:_interceptors' show Interceptor, JSExtendableArray;\n// DO NOT EDIT - unless you are editing documentation as per:\n// https://code.google.com/p/dart/wiki/ContributingHTMLDocumentation\n// Auto-generated dart:web_gl library.\n\n\n\n\n\n// Copyright (c) 2013, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\nconst int ACTIVE_ATTRIBUTES = RenderingContext.ACTIVE_ATTRIBUTES;\nconst int ACTIVE_TEXTURE = RenderingContext.ACTIVE_TEXTURE;\nconst int ACTIVE_UNIFORMS = RenderingContext.ACTIVE_UNIFORMS;\nconst int ALIASED_LINE_WIDTH_RANGE = RenderingContext.ALIASED_LINE_WIDTH_RANGE;\nconst int ALIASED_POINT_SIZE_RANGE = RenderingContext.ALIASED_POINT_SIZE_RANGE;\nconst int ALPHA = RenderingContext.ALPHA;\nconst int ALPHA_BITS = RenderingContext.ALPHA_BITS;\nconst int ALWAYS = RenderingContext.ALWAYS;\nconst int ARRAY_BUFFER = RenderingContext.ARRAY_BUFFER;\nconst int ARRAY_BUFFER_BINDING = RenderingContext.ARRAY_BUFFER_BINDING;\nconst int ATTACHED_SHADERS = RenderingContext.ATTACHED_SHADERS;\nconst int BACK = RenderingContext.BACK;\nconst int BLEND = RenderingContext.BLEND;\nconst int BLEND_COLOR = RenderingContext.BLEND_COLOR;\nconst int BLEND_DST_ALPHA = RenderingContext.BLEND_DST_ALPHA;\nconst int BLEND_DST_RGB = RenderingContext.BLEND_DST_RGB;\nconst int BLEND_EQUATION = RenderingContext.BLEND_EQUATION;\nconst int BLEND_EQUATION_ALPHA = RenderingContext.BLEND_EQUATION_ALPHA;\nconst int BLEND_EQUATION_RGB = RenderingContext.BLEND_EQUATION_RGB;\nconst int BLEND_SRC_ALPHA = RenderingContext.BLEND_SRC_ALPHA;\nconst int BLEND_SRC_RGB = RenderingContext.BLEND_SRC_RGB;\nconst int BLUE_BITS = RenderingContext.BLUE_BITS;\nconst int BOOL = RenderingContext.BOOL;\nconst int BOOL_VEC2 = RenderingContext.BOOL_VEC2;\nconst int BOOL_VEC3 = RenderingContext.BOOL_VEC3;\nconst int BOOL_VEC4 = RenderingContext.BOOL_VEC4;\nconst int BROWSER_DEFAULT_WEBGL = RenderingContext.BROWSER_DEFAULT_WEBGL;\nconst int BUFFER_SIZE = RenderingContext.BUFFER_SIZE;\nconst int BUFFER_USAGE = RenderingContext.BUFFER_USAGE;\nconst int BYTE = RenderingContext.BYTE;\nconst int CCW = RenderingContext.CCW;\nconst int CLAMP_TO_EDGE = RenderingContext.CLAMP_TO_EDGE;\nconst int COLOR_ATTACHMENT0 = RenderingContext.COLOR_ATTACHMENT0;\nconst int COLOR_BUFFER_BIT = RenderingContext.COLOR_BUFFER_BIT;\nconst int COLOR_CLEAR_VALUE = RenderingContext.COLOR_CLEAR_VALUE;\nconst int COLOR_WRITEMASK = RenderingContext.COLOR_WRITEMASK;\nconst int COMPILE_STATUS = RenderingContext.COMPILE_STATUS;\nconst int COMPRESSED_TEXTURE_FORMATS = RenderingContext.COMPRESSED_TEXTURE_FORMATS;\nconst int CONSTANT_ALPHA = RenderingContext.CONSTANT_ALPHA;\nconst int CONSTANT_COLOR = RenderingContext.CONSTANT_COLOR;\nconst int CONTEXT_LOST_WEBGL = RenderingContext.CONTEXT_LOST_WEBGL;\nconst int CULL_FACE = RenderingContext.CULL_FACE;\nconst int CULL_FACE_MODE = RenderingContext.CULL_FACE_MODE;\nconst int CURRENT_PROGRAM = RenderingContext.CURRENT_PROGRAM;\nconst int CURRENT_VERTEX_ATTRIB = RenderingContext.CURRENT_VERTEX_ATTRIB;\nconst int CW = RenderingContext.CW;\nconst int DECR = RenderingContext.DECR;\nconst int DECR_WRAP = RenderingContext.DECR_WRAP;\nconst int DELETE_STATUS = RenderingContext.DELETE_STATUS;\nconst int DEPTH_ATTACHMENT = RenderingContext.DEPTH_ATTACHMENT;\nconst int DEPTH_BITS = RenderingContext.DEPTH_BITS;\nconst int DEPTH_BUFFER_BIT = RenderingContext.DEPTH_BUFFER_BIT;\nconst int DEPTH_CLEAR_VALUE = RenderingContext.DEPTH_CLEAR_VALUE;\nconst int DEPTH_COMPONENT = RenderingContext.DEPTH_COMPONENT;\nconst int DEPTH_COMPONENT16 = RenderingContext.DEPTH_COMPONENT16;\nconst int DEPTH_FUNC = RenderingContext.DEPTH_FUNC;\nconst int DEPTH_RANGE = RenderingContext.DEPTH_RANGE;\nconst int DEPTH_STENCIL = RenderingContext.DEPTH_STENCIL;\nconst int DEPTH_STENCIL_ATTACHMENT = RenderingContext.DEPTH_STENCIL_ATTACHMENT;\nconst int DEPTH_TEST = RenderingContext.DEPTH_TEST;\nconst int DEPTH_WRITEMASK = RenderingContext.DEPTH_WRITEMASK;\nconst int DITHER = RenderingContext.DITHER;\nconst int DONT_CARE = RenderingContext.DONT_CARE;\nconst int DST_ALPHA = RenderingContext.DST_ALPHA;\nconst int DST_COLOR = RenderingContext.DST_COLOR;\nconst int DYNAMIC_DRAW = RenderingContext.DYNAMIC_DRAW;\nconst int ELEMENT_ARRAY_BUFFER = RenderingContext.ELEMENT_ARRAY_BUFFER;\nconst int ELEMENT_ARRAY_BUFFER_BINDING = RenderingContext.ELEMENT_ARRAY_BUFFER_BINDING;\nconst int EQUAL = RenderingContext.EQUAL;\nconst int FASTEST = RenderingContext.FASTEST;\nconst int FLOAT = RenderingContext.FLOAT;\nconst int FLOAT_MAT2 = RenderingContext.FLOAT_MAT2;\nconst int FLOAT_MAT3 = RenderingContext.FLOAT_MAT3;\nconst int FLOAT_MAT4 = RenderingContext.FLOAT_MAT4;\nconst int FLOAT_VEC2 = RenderingContext.FLOAT_VEC2;\nconst int FLOAT_VEC3 = RenderingContext.FLOAT_VEC3;\nconst int FLOAT_VEC4 = RenderingContext.FLOAT_VEC4;\nconst int FRAGMENT_SHADER = RenderingContext.FRAGMENT_SHADER;\nconst int FRAMEBUFFER = RenderingContext.FRAMEBUFFER;\nconst int FRAMEBUFFER_ATTACHMENT_OBJECT_NAME = RenderingContext.FRAMEBUFFER_ATTACHMENT_OBJECT_NAME;\nconst int FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE = RenderingContext.FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE;\nconst int FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE = RenderingContext.FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE;\nconst int FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL = RenderingContext.FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL;\nconst int FRAMEBUFFER_BINDING = RenderingContext.FRAMEBUFFER_BINDING;\nconst int FRAMEBUFFER_COMPLETE = RenderingContext.FRAMEBUFFER_COMPLETE;\nconst int FRAMEBUFFER_INCOMPLETE_ATTACHMENT = RenderingContext.FRAMEBUFFER_INCOMPLETE_ATTACHMENT;\nconst int FRAMEBUFFER_INCOMPLETE_DIMENSIONS = RenderingContext.FRAMEBUFFER_INCOMPLETE_DIMENSIONS;\nconst int FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT = RenderingContext.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT;\nconst int FRAMEBUFFER_UNSUPPORTED = RenderingContext.FRAMEBUFFER_UNSUPPORTED;\nconst int FRONT = RenderingContext.FRONT;\nconst int FRONT_AND_BACK = RenderingContext.FRONT_AND_BACK;\nconst int FRONT_FACE = RenderingContext.FRONT_FACE;\nconst int FUNC_ADD = RenderingContext.FUNC_ADD;\nconst int FUNC_REVERSE_SUBTRACT = RenderingContext.FUNC_REVERSE_SUBTRACT;\nconst int FUNC_SUBTRACT = RenderingContext.FUNC_SUBTRACT;\nconst int GENERATE_MIPMAP_HINT = RenderingContext.GENERATE_MIPMAP_HINT;\nconst int GEQUAL = RenderingContext.GEQUAL;\nconst int GREATER = RenderingContext.GREATER;\nconst int GREEN_BITS = RenderingContext.GREEN_BITS;\nconst int HALF_FLOAT_OES = OesTextureHalfFloat.HALF_FLOAT_OES;\nconst int HIGH_FLOAT = RenderingContext.HIGH_FLOAT;\nconst int HIGH_INT = RenderingContext.HIGH_INT;\nconst int INCR = RenderingContext.INCR;\nconst int INCR_WRAP = RenderingContext.INCR_WRAP;\nconst int INT = RenderingContext.INT;\nconst int INT_VEC2 = RenderingContext.INT_VEC2;\nconst int INT_VEC3 = RenderingContext.INT_VEC3;\nconst int INT_VEC4 = RenderingContext.INT_VEC4;\nconst int INVALID_ENUM = RenderingContext.INVALID_ENUM;\nconst int INVALID_FRAMEBUFFER_OPERATION = RenderingContext.INVALID_FRAMEBUFFER_OPERATION;\nconst int INVALID_OPERATION = RenderingContext.INVALID_OPERATION;\nconst int INVALID_VALUE = RenderingContext.INVALID_VALUE;\nconst int INVERT = RenderingContext.INVERT;\nconst int KEEP = RenderingContext.KEEP;\nconst int LEQUAL = RenderingContext.LEQUAL;\nconst int LESS = RenderingContext.LESS;\nconst int LINEAR = RenderingContext.LINEAR;\nconst int LINEAR_MIPMAP_LINEAR = RenderingContext.LINEAR_MIPMAP_LINEAR;\nconst int LINEAR_MIPMAP_NEAREST = RenderingContext.LINEAR_MIPMAP_NEAREST;\nconst int LINES = RenderingContext.LINES;\nconst int LINE_LOOP = RenderingContext.LINE_LOOP;\nconst int LINE_STRIP = RenderingContext.LINE_STRIP;\nconst int LINE_WIDTH = RenderingContext.LINE_WIDTH;\nconst int LINK_STATUS = RenderingContext.LINK_STATUS;\nconst int LOW_FLOAT = RenderingContext.LOW_FLOAT;\nconst int LOW_INT = RenderingContext.LOW_INT;\nconst int LUMINANCE = RenderingContext.LUMINANCE;\nconst int LUMINANCE_ALPHA = RenderingContext.LUMINANCE_ALPHA;\nconst int MAX_COMBINED_TEXTURE_IMAGE_UNITS = RenderingContext.MAX_COMBINED_TEXTURE_IMAGE_UNITS;\nconst int MAX_CUBE_MAP_TEXTURE_SIZE = RenderingContext.MAX_CUBE_MAP_TEXTURE_SIZE;\nconst int MAX_FRAGMENT_UNIFORM_VECTORS = RenderingContext.MAX_FRAGMENT_UNIFORM_VECTORS;\nconst int MAX_RENDERBUFFER_SIZE = RenderingContext.MAX_RENDERBUFFER_SIZE;\nconst int MAX_TEXTURE_IMAGE_UNITS = RenderingContext.MAX_TEXTURE_IMAGE_UNITS;\nconst int MAX_TEXTURE_SIZE = RenderingContext.MAX_TEXTURE_SIZE;\nconst int MAX_VARYING_VECTORS = RenderingContext.MAX_VARYING_VECTORS;\nconst int MAX_VERTEX_ATTRIBS = RenderingContext.MAX_VERTEX_ATTRIBS;\nconst int MAX_VERTEX_TEXTURE_IMAGE_UNITS = RenderingContext.MAX_VERTEX_TEXTURE_IMAGE_UNITS;\nconst int MAX_VERTEX_UNIFORM_VECTORS = RenderingContext.MAX_VERTEX_UNIFORM_VECTORS;\nconst int MAX_VIEWPORT_DIMS = RenderingContext.MAX_VIEWPORT_DIMS;\nconst int MEDIUM_FLOAT = RenderingContext.MEDIUM_FLOAT;\nconst int MEDIUM_INT = RenderingContext.MEDIUM_INT;\nconst int MIRRORED_REPEAT = RenderingContext.MIRRORED_REPEAT;\nconst int NEAREST = RenderingContext.NEAREST;\nconst int NEAREST_MIPMAP_LINEAR = RenderingContext.NEAREST_MIPMAP_LINEAR;\nconst int NEAREST_MIPMAP_NEAREST = RenderingContext.NEAREST_MIPMAP_NEAREST;\nconst int NEVER = RenderingContext.NEVER;\nconst int NICEST = RenderingContext.NICEST;\nconst int NONE = RenderingContext.NONE;\nconst int NOTEQUAL = RenderingContext.NOTEQUAL;\nconst int NO_ERROR = RenderingContext.NO_ERROR;\nconst int ONE = RenderingContext.ONE;\nconst int ONE_MINUS_CONSTANT_ALPHA = RenderingContext.ONE_MINUS_CONSTANT_ALPHA;\nconst int ONE_MINUS_CONSTANT_COLOR = RenderingContext.ONE_MINUS_CONSTANT_COLOR;\nconst int ONE_MINUS_DST_ALPHA = RenderingContext.ONE_MINUS_DST_ALPHA;\nconst int ONE_MINUS_DST_COLOR = RenderingContext.ONE_MINUS_DST_COLOR;\nconst int ONE_MINUS_SRC_ALPHA = RenderingContext.ONE_MINUS_SRC_ALPHA;\nconst int ONE_MINUS_SRC_COLOR = RenderingContext.ONE_MINUS_SRC_COLOR;\nconst int OUT_OF_MEMORY = RenderingContext.OUT_OF_MEMORY;\nconst int PACK_ALIGNMENT = RenderingContext.PACK_ALIGNMENT;\nconst int POINTS = RenderingContext.POINTS;\nconst int POLYGON_OFFSET_FACTOR = RenderingContext.POLYGON_OFFSET_FACTOR;\nconst int POLYGON_OFFSET_FILL = RenderingContext.POLYGON_OFFSET_FILL;\nconst int POLYGON_OFFSET_UNITS = RenderingContext.POLYGON_OFFSET_UNITS;\nconst int RED_BITS = RenderingContext.RED_BITS;\nconst int RENDERBUFFER = RenderingContext.RENDERBUFFER;\nconst int RENDERBUFFER_ALPHA_SIZE = RenderingContext.RENDERBUFFER_ALPHA_SIZE;\nconst int RENDERBUFFER_BINDING = RenderingContext.RENDERBUFFER_BINDING;\nconst int RENDERBUFFER_BLUE_SIZE = RenderingContext.RENDERBUFFER_BLUE_SIZE;\nconst int RENDERBUFFER_DEPTH_SIZE = RenderingContext.RENDERBUFFER_DEPTH_SIZE;\nconst int RENDERBUFFER_GREEN_SIZE = RenderingContext.RENDERBUFFER_GREEN_SIZE;\nconst int RENDERBUFFER_HEIGHT = RenderingContext.RENDERBUFFER_HEIGHT;\nconst int RENDERBUFFER_INTERNAL_FORMAT = RenderingContext.RENDERBUFFER_INTERNAL_FORMAT;\nconst int RENDERBUFFER_RED_SIZE = RenderingContext.RENDERBUFFER_RED_SIZE;\nconst int RENDERBUFFER_STENCIL_SIZE = RenderingContext.RENDERBUFFER_STENCIL_SIZE;\nconst int RENDERBUFFER_WIDTH = RenderingContext.RENDERBUFFER_WIDTH;\nconst int RENDERER = RenderingContext.RENDERER;\nconst int REPEAT = RenderingContext.REPEAT;\nconst int REPLACE = RenderingContext.REPLACE;\nconst int RGB = RenderingContext.RGB;\nconst int RGB565 = RenderingContext.RGB565;\nconst int RGB5_A1 = RenderingContext.RGB5_A1;\nconst int RGBA = RenderingContext.RGBA;\nconst int RGBA4 = RenderingContext.RGBA4;\nconst int SAMPLER_2D = RenderingContext.SAMPLER_2D;\nconst int SAMPLER_CUBE = RenderingContext.SAMPLER_CUBE;\nconst int SAMPLES = RenderingContext.SAMPLES;\nconst int SAMPLE_ALPHA_TO_COVERAGE = RenderingContext.SAMPLE_ALPHA_TO_COVERAGE;\nconst int SAMPLE_BUFFERS = RenderingContext.SAMPLE_BUFFERS;\nconst int SAMPLE_COVERAGE = RenderingContext.SAMPLE_COVERAGE;\nconst int SAMPLE_COVERAGE_INVERT = RenderingContext.SAMPLE_COVERAGE_INVERT;\nconst int SAMPLE_COVERAGE_VALUE = RenderingContext.SAMPLE_COVERAGE_VALUE;\nconst int SCISSOR_BOX = RenderingContext.SCISSOR_BOX;\nconst int SCISSOR_TEST = RenderingContext.SCISSOR_TEST;\nconst int SHADER_TYPE = RenderingContext.SHADER_TYPE;\nconst int SHADING_LANGUAGE_VERSION = RenderingContext.SHADING_LANGUAGE_VERSION;\nconst int SHORT = RenderingContext.SHORT;\nconst int SRC_ALPHA = RenderingContext.SRC_ALPHA;\nconst int SRC_ALPHA_SATURATE = RenderingContext.SRC_ALPHA_SATURATE;\nconst int SRC_COLOR = RenderingContext.SRC_COLOR;\nconst int STATIC_DRAW = RenderingContext.STATIC_DRAW;\nconst int STENCIL_ATTACHMENT = RenderingContext.STENCIL_ATTACHMENT;\nconst int STENCIL_BACK_FAIL = RenderingContext.STENCIL_BACK_FAIL;\nconst int STENCIL_BACK_FUNC = RenderingContext.STENCIL_BACK_FUNC;\nconst int STENCIL_BACK_PASS_DEPTH_FAIL = RenderingContext.STENCIL_BACK_PASS_DEPTH_FAIL;\nconst int STENCIL_BACK_PASS_DEPTH_PASS = RenderingContext.STENCIL_BACK_PASS_DEPTH_PASS;\nconst int STENCIL_BACK_REF = RenderingContext.STENCIL_BACK_REF;\nconst int STENCIL_BACK_VALUE_MASK = RenderingContext.STENCIL_BACK_VALUE_MASK;\nconst int STENCIL_BACK_WRITEMASK = RenderingContext.STENCIL_BACK_WRITEMASK;\nconst int STENCIL_BITS = RenderingContext.STENCIL_BITS;\nconst int STENCIL_BUFFER_BIT = RenderingContext.STENCIL_BUFFER_BIT;\nconst int STENCIL_CLEAR_VALUE = RenderingContext.STENCIL_CLEAR_VALUE;\nconst int STENCIL_FAIL = RenderingContext.STENCIL_FAIL;\nconst int STENCIL_FUNC = RenderingContext.STENCIL_FUNC;\nconst int STENCIL_INDEX = RenderingContext.STENCIL_INDEX;\nconst int STENCIL_INDEX8 = RenderingContext.STENCIL_INDEX8;\nconst int STENCIL_PASS_DEPTH_FAIL = RenderingContext.STENCIL_PASS_DEPTH_FAIL;\nconst int STENCIL_PASS_DEPTH_PASS = RenderingContext.STENCIL_PASS_DEPTH_PASS;\nconst int STENCIL_REF = RenderingContext.STENCIL_REF;\nconst int STENCIL_TEST = RenderingContext.STENCIL_TEST;\nconst int STENCIL_VALUE_MASK = RenderingContext.STENCIL_VALUE_MASK;\nconst int STENCIL_WRITEMASK = RenderingContext.STENCIL_WRITEMASK;\nconst int STREAM_DRAW = RenderingContext.STREAM_DRAW;\nconst int SUBPIXEL_BITS = RenderingContext.SUBPIXEL_BITS;\nconst int TEXTURE = RenderingContext.TEXTURE;\nconst int TEXTURE0 = RenderingContext.TEXTURE0;\nconst int TEXTURE1 = RenderingContext.TEXTURE1;\nconst int TEXTURE10 = RenderingContext.TEXTURE10;\nconst int TEXTURE11 = RenderingContext.TEXTURE11;\nconst int TEXTURE12 = RenderingContext.TEXTURE12;\nconst int TEXTURE13 = RenderingContext.TEXTURE13;\nconst int TEXTURE14 = RenderingContext.TEXTURE14;\nconst int TEXTURE15 = RenderingContext.TEXTURE15;\nconst int TEXTURE16 = RenderingContext.TEXTURE16;\nconst int TEXTURE17 = RenderingContext.TEXTURE17;\nconst int TEXTURE18 = RenderingContext.TEXTURE18;\nconst int TEXTURE19 = RenderingContext.TEXTURE19;\nconst int TEXTURE2 = RenderingContext.TEXTURE2;\nconst int TEXTURE20 = RenderingContext.TEXTURE20;\nconst int TEXTURE21 = RenderingContext.TEXTURE21;\nconst int TEXTURE22 = RenderingContext.TEXTURE22;\nconst int TEXTURE23 = RenderingContext.TEXTURE23;\nconst int TEXTURE24 = RenderingContext.TEXTURE24;\nconst int TEXTURE25 = RenderingContext.TEXTURE25;\nconst int TEXTURE26 = RenderingContext.TEXTURE26;\nconst int TEXTURE27 = RenderingContext.TEXTURE27;\nconst int TEXTURE28 = RenderingContext.TEXTURE28;\nconst int TEXTURE29 = RenderingContext.TEXTURE29;\nconst int TEXTURE3 = RenderingContext.TEXTURE3;\nconst int TEXTURE30 = RenderingContext.TEXTURE30;\nconst int TEXTURE31 = RenderingContext.TEXTURE31;\nconst int TEXTURE4 = RenderingContext.TEXTURE4;\nconst int TEXTURE5 = RenderingContext.TEXTURE5;\nconst int TEXTURE6 = RenderingContext.TEXTURE6;\nconst int TEXTURE7 = RenderingContext.TEXTURE7;\nconst int TEXTURE8 = RenderingContext.TEXTURE8;\nconst int TEXTURE9 = RenderingContext.TEXTURE9;\nconst int TEXTURE_2D = RenderingContext.TEXTURE_2D;\nconst int TEXTURE_BINDING_2D = RenderingContext.TEXTURE_BINDING_2D;\nconst int TEXTURE_BINDING_CUBE_MAP = RenderingContext.TEXTURE_BINDING_CUBE_MAP;\nconst int TEXTURE_CUBE_MAP = RenderingContext.TEXTURE_CUBE_MAP;\nconst int TEXTURE_CUBE_MAP_NEGATIVE_X = RenderingContext.TEXTURE_CUBE_MAP_NEGATIVE_X;\nconst int TEXTURE_CUBE_MAP_NEGATIVE_Y = RenderingContext.TEXTURE_CUBE_MAP_NEGATIVE_Y;\nconst int TEXTURE_CUBE_MAP_NEGATIVE_Z = RenderingContext.TEXTURE_CUBE_MAP_NEGATIVE_Z;\nconst int TEXTURE_CUBE_MAP_POSITIVE_X = RenderingContext.TEXTURE_CUBE_MAP_POSITIVE_X;\nconst int TEXTURE_CUBE_MAP_POSITIVE_Y = RenderingContext.TEXTURE_CUBE_MAP_POSITIVE_Y;\nconst int TEXTURE_CUBE_MAP_POSITIVE_Z = RenderingContext.TEXTURE_CUBE_MAP_POSITIVE_Z;\nconst int TEXTURE_MAG_FILTER = RenderingContext.TEXTURE_MAG_FILTER;\nconst int TEXTURE_MIN_FILTER = RenderingContext.TEXTURE_MIN_FILTER;\nconst int TEXTURE_WRAP_S = RenderingContext.TEXTURE_WRAP_S;\nconst int TEXTURE_WRAP_T = RenderingContext.TEXTURE_WRAP_T;\nconst int TRIANGLES = RenderingContext.TRIANGLES;\nconst int TRIANGLE_FAN = RenderingContext.TRIANGLE_FAN;\nconst int TRIANGLE_STRIP = RenderingContext.TRIANGLE_STRIP;\nconst int UNPACK_ALIGNMENT = RenderingContext.UNPACK_ALIGNMENT;\nconst int UNPACK_COLORSPACE_CONVERSION_WEBGL = RenderingContext.UNPACK_COLORSPACE_CONVERSION_WEBGL;\nconst int UNPACK_FLIP_Y_WEBGL = RenderingContext.UNPACK_FLIP_Y_WEBGL;\nconst int UNPACK_PREMULTIPLY_ALPHA_WEBGL = RenderingContext.UNPACK_PREMULTIPLY_ALPHA_WEBGL;\nconst int UNSIGNED_BYTE = RenderingContext.UNSIGNED_BYTE;\nconst int UNSIGNED_INT = RenderingContext.UNSIGNED_INT;\nconst int UNSIGNED_SHORT = RenderingContext.UNSIGNED_SHORT;\nconst int UNSIGNED_SHORT_4_4_4_4 = RenderingContext.UNSIGNED_SHORT_4_4_4_4;\nconst int UNSIGNED_SHORT_5_5_5_1 = RenderingContext.UNSIGNED_SHORT_5_5_5_1;\nconst int UNSIGNED_SHORT_5_6_5 = RenderingContext.UNSIGNED_SHORT_5_6_5;\nconst int VALIDATE_STATUS = RenderingContext.VALIDATE_STATUS;\nconst int VENDOR = RenderingContext.VENDOR;\nconst int VERSION = RenderingContext.VERSION;\nconst int VERTEX_ATTRIB_ARRAY_BUFFER_BINDING = RenderingContext.VERTEX_ATTRIB_ARRAY_BUFFER_BINDING;\nconst int VERTEX_ATTRIB_ARRAY_ENABLED = RenderingContext.VERTEX_ATTRIB_ARRAY_ENABLED;\nconst int VERTEX_ATTRIB_ARRAY_NORMALIZED = RenderingContext.VERTEX_ATTRIB_ARRAY_NORMALIZED;\nconst int VERTEX_ATTRIB_ARRAY_POINTER = RenderingContext.VERTEX_ATTRIB_ARRAY_POINTER;\nconst int VERTEX_ATTRIB_ARRAY_SIZE = RenderingContext.VERTEX_ATTRIB_ARRAY_SIZE;\nconst int VERTEX_ATTRIB_ARRAY_STRIDE = RenderingContext.VERTEX_ATTRIB_ARRAY_STRIDE;\nconst int VERTEX_ATTRIB_ARRAY_TYPE = RenderingContext.VERTEX_ATTRIB_ARRAY_TYPE;\nconst int VERTEX_SHADER = RenderingContext.VERTEX_SHADER;\nconst int VIEWPORT = RenderingContext.VIEWPORT;\nconst int ZERO = RenderingContext.ZERO;\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('WebGLActiveInfo')\n@Unstable()\n@Native(\"WebGLActiveInfo\")\nclass ActiveInfo extends Interceptor {\n  // To suppress missing implicit constructor warnings.\n  factory ActiveInfo._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('WebGLActiveInfo.name')\n  @DocsEditable()\n  final String name;\n\n  @DomName('WebGLActiveInfo.size')\n  @DocsEditable()\n  final int size;\n\n  @DomName('WebGLActiveInfo.type')\n  @DocsEditable()\n  final int type;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('ANGLEInstancedArrays')\n@Experimental() // untriaged\n@Native(\"ANGLEInstancedArrays\")\nclass AngleInstancedArrays extends Interceptor {\n  // To suppress missing implicit constructor warnings.\n  factory AngleInstancedArrays._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('ANGLEInstancedArrays.VERTEX_ATTRIB_ARRAY_DIVISOR_ANGLE')\n  @DocsEditable()\n  @Experimental() // untriaged\n  static const int VERTEX_ATTRIB_ARRAY_DIVISOR_ANGLE = 0x88FE;\n\n  @JSName('drawArraysInstancedANGLE')\n  @DomName('ANGLEInstancedArrays.drawArraysInstancedANGLE')\n  @DocsEditable()\n  @Experimental() // untriaged\n  void drawArraysInstancedAngle(int mode, int first, int count, int primcount) native;\n\n  @JSName('drawElementsInstancedANGLE')\n  @DomName('ANGLEInstancedArrays.drawElementsInstancedANGLE')\n  @DocsEditable()\n  @Experimental() // untriaged\n  void drawElementsInstancedAngle(int mode, int count, int type, int offset, int primcount) native;\n\n  @JSName('vertexAttribDivisorANGLE')\n  @DomName('ANGLEInstancedArrays.vertexAttribDivisorANGLE')\n  @DocsEditable()\n  @Experimental() // untriaged\n  void vertexAttribDivisorAngle(int index, int divisor) native;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('WebGLBuffer')\n@Unstable()\n@Native(\"WebGLBuffer\")\nclass Buffer extends Interceptor {\n  // To suppress missing implicit constructor warnings.\n  factory Buffer._() { throw new UnsupportedError(\"Not supported\"); }\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('WebGLCompressedTextureATC')\n// http://www.khronos.org/registry/webgl/extensions/WEBGL_compressed_texture_atc/\n@Experimental()\n@Native(\"WebGLCompressedTextureATC\")\nclass CompressedTextureAtc extends Interceptor {\n  // To suppress missing implicit constructor warnings.\n  factory CompressedTextureAtc._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('WebGLCompressedTextureATC.COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL')\n  @DocsEditable()\n  static const int COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL = 0x8C93;\n\n  @DomName('WebGLCompressedTextureATC.COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL')\n  @DocsEditable()\n  static const int COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL = 0x87EE;\n\n  @DomName('WebGLCompressedTextureATC.COMPRESSED_RGB_ATC_WEBGL')\n  @DocsEditable()\n  static const int COMPRESSED_RGB_ATC_WEBGL = 0x8C92;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('WebGLCompressedTexturePVRTC')\n// http://www.khronos.org/registry/webgl/extensions/WEBGL_compressed_texture_pvrtc/\n@Experimental() // experimental\n@Native(\"WebGLCompressedTexturePVRTC\")\nclass CompressedTexturePvrtc extends Interceptor {\n  // To suppress missing implicit constructor warnings.\n  factory CompressedTexturePvrtc._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('WebGLCompressedTexturePVRTC.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG')\n  @DocsEditable()\n  static const int COMPRESSED_RGBA_PVRTC_2BPPV1_IMG = 0x8C03;\n\n  @DomName('WebGLCompressedTexturePVRTC.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG')\n  @DocsEditable()\n  static const int COMPRESSED_RGBA_PVRTC_4BPPV1_IMG = 0x8C02;\n\n  @DomName('WebGLCompressedTexturePVRTC.COMPRESSED_RGB_PVRTC_2BPPV1_IMG')\n  @DocsEditable()\n  static const int COMPRESSED_RGB_PVRTC_2BPPV1_IMG = 0x8C01;\n\n  @DomName('WebGLCompressedTexturePVRTC.COMPRESSED_RGB_PVRTC_4BPPV1_IMG')\n  @DocsEditable()\n  static const int COMPRESSED_RGB_PVRTC_4BPPV1_IMG = 0x8C00;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('WebGLCompressedTextureS3TC')\n// http://www.khronos.org/registry/webgl/extensions/WEBGL_compressed_texture_s3tc/\n@Experimental() // experimental\n@Native(\"WebGLCompressedTextureS3TC\")\nclass CompressedTextureS3TC extends Interceptor {\n  // To suppress missing implicit constructor warnings.\n  factory CompressedTextureS3TC._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('WebGLCompressedTextureS3TC.COMPRESSED_RGBA_S3TC_DXT1_EXT')\n  @DocsEditable()\n  static const int COMPRESSED_RGBA_S3TC_DXT1_EXT = 0x83F1;\n\n  @DomName('WebGLCompressedTextureS3TC.COMPRESSED_RGBA_S3TC_DXT3_EXT')\n  @DocsEditable()\n  static const int COMPRESSED_RGBA_S3TC_DXT3_EXT = 0x83F2;\n\n  @DomName('WebGLCompressedTextureS3TC.COMPRESSED_RGBA_S3TC_DXT5_EXT')\n  @DocsEditable()\n  static const int COMPRESSED_RGBA_S3TC_DXT5_EXT = 0x83F3;\n\n  @DomName('WebGLCompressedTextureS3TC.COMPRESSED_RGB_S3TC_DXT1_EXT')\n  @DocsEditable()\n  static const int COMPRESSED_RGB_S3TC_DXT1_EXT = 0x83F0;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n/**\n * The properties of a WebGL rendering context.\n *\n * If [alpha] is `true`, then the context has an alpha channel.\n *\n * If [antialias] is `true`, then antialiasing is performed by the browser, but\n * only if the browser's implementation of WebGL supports antialiasing.\n *\n * If [depth] is `true`, then the context has a depth buffer of at least 16\n * bits.\n *\n * If [premultipliedAlpha] is `true`, then the context's colors are assumed to\n * be premultiplied. This means that color values are assumed to have  been\n * multiplied by their alpha values. If [alpha] is `false`, then this flag is\n * ignored.\n *\n * If [preserveDrawingBuffer] is `false`, then all contents of the context are\n * cleared. If `true`, then all values will remain until changed or cleared.\n *\n * If [stencil] is `true`, then the context has a stencil buffer of at least 8\n * bits.\n */\n@DomName('WebGLContextAttributes')\n@Unstable()\n@Native(\"WebGLContextAttributes\")\nclass ContextAttributes extends Interceptor {\n  // To suppress missing implicit constructor warnings.\n  factory ContextAttributes._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('WebGLContextAttributes.alpha')\n  @DocsEditable()\n  bool alpha;\n\n  @DomName('WebGLContextAttributes.antialias')\n  @DocsEditable()\n  bool antialias;\n\n  @DomName('WebGLContextAttributes.depth')\n  @DocsEditable()\n  bool depth;\n\n  @DomName('WebGLContextAttributes.failIfMajorPerformanceCaveat')\n  @DocsEditable()\n  @Experimental() // untriaged\n  bool failIfMajorPerformanceCaveat;\n\n  @DomName('WebGLContextAttributes.premultipliedAlpha')\n  @DocsEditable()\n  bool premultipliedAlpha;\n\n  @DomName('WebGLContextAttributes.preserveDrawingBuffer')\n  @DocsEditable()\n  bool preserveDrawingBuffer;\n\n  @DomName('WebGLContextAttributes.stencil')\n  @DocsEditable()\n  bool stencil;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('WebGLContextEvent')\n@Unstable()\n@Native(\"WebGLContextEvent\")\nclass ContextEvent extends Event {\n  // To suppress missing implicit constructor warnings.\n  factory ContextEvent._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('WebGLContextEvent.statusMessage')\n  @DocsEditable()\n  final String statusMessage;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('WebGLDebugRendererInfo')\n// http://www.khronos.org/registry/webgl/extensions/WEBGL_debug_renderer_info/\n@Experimental() // experimental\n@Native(\"WebGLDebugRendererInfo\")\nclass DebugRendererInfo extends Interceptor {\n  // To suppress missing implicit constructor warnings.\n  factory DebugRendererInfo._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('WebGLDebugRendererInfo.UNMASKED_RENDERER_WEBGL')\n  @DocsEditable()\n  static const int UNMASKED_RENDERER_WEBGL = 0x9246;\n\n  @DomName('WebGLDebugRendererInfo.UNMASKED_VENDOR_WEBGL')\n  @DocsEditable()\n  static const int UNMASKED_VENDOR_WEBGL = 0x9245;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('WebGLDebugShaders')\n// http://www.khronos.org/registry/webgl/extensions/WEBGL_debug_shaders/\n@Experimental() // experimental\n@Native(\"WebGLDebugShaders\")\nclass DebugShaders extends Interceptor {\n  // To suppress missing implicit constructor warnings.\n  factory DebugShaders._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('WebGLDebugShaders.getTranslatedShaderSource')\n  @DocsEditable()\n  String getTranslatedShaderSource(Shader shader) native;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('WebGLDepthTexture')\n// http://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/\n@Experimental() // experimental\n@Native(\"WebGLDepthTexture\")\nclass DepthTexture extends Interceptor {\n  // To suppress missing implicit constructor warnings.\n  factory DepthTexture._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('WebGLDepthTexture.UNSIGNED_INT_24_8_WEBGL')\n  @DocsEditable()\n  static const int UNSIGNED_INT_24_8_WEBGL = 0x84FA;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('WebGLDrawBuffers')\n// http://www.khronos.org/registry/webgl/specs/latest/\n@Experimental() // stable\n@Native(\"WebGLDrawBuffers\")\nclass DrawBuffers extends Interceptor {\n  // To suppress missing implicit constructor warnings.\n  factory DrawBuffers._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('WebGLDrawBuffers.COLOR_ATTACHMENT0_WEBGL')\n  @DocsEditable()\n  static const int COLOR_ATTACHMENT0_WEBGL = 0x8CE0;\n\n  @DomName('WebGLDrawBuffers.COLOR_ATTACHMENT10_WEBGL')\n  @DocsEditable()\n  static const int COLOR_ATTACHMENT10_WEBGL = 0x8CEA;\n\n  @DomName('WebGLDrawBuffers.COLOR_ATTACHMENT11_WEBGL')\n  @DocsEditable()\n  static const int COLOR_ATTACHMENT11_WEBGL = 0x8CEB;\n\n  @DomName('WebGLDrawBuffers.COLOR_ATTACHMENT12_WEBGL')\n  @DocsEditable()\n  static const int COLOR_ATTACHMENT12_WEBGL = 0x8CEC;\n\n  @DomName('WebGLDrawBuffers.COLOR_ATTACHMENT13_WEBGL')\n  @DocsEditable()\n  static const int COLOR_ATTACHMENT13_WEBGL = 0x8CED;\n\n  @DomName('WebGLDrawBuffers.COLOR_ATTACHMENT14_WEBGL')\n  @DocsEditable()\n  static const int COLOR_ATTACHMENT14_WEBGL = 0x8CEE;\n\n  @DomName('WebGLDrawBuffers.COLOR_ATTACHMENT15_WEBGL')\n  @DocsEditable()\n  static const int COLOR_ATTACHMENT15_WEBGL = 0x8CEF;\n\n  @DomName('WebGLDrawBuffers.COLOR_ATTACHMENT1_WEBGL')\n  @DocsEditable()\n  static const int COLOR_ATTACHMENT1_WEBGL = 0x8CE1;\n\n  @DomName('WebGLDrawBuffers.COLOR_ATTACHMENT2_WEBGL')\n  @DocsEditable()\n  static const int COLOR_ATTACHMENT2_WEBGL = 0x8CE2;\n\n  @DomName('WebGLDrawBuffers.COLOR_ATTACHMENT3_WEBGL')\n  @DocsEditable()\n  static const int COLOR_ATTACHMENT3_WEBGL = 0x8CE3;\n\n  @DomName('WebGLDrawBuffers.COLOR_ATTACHMENT4_WEBGL')\n  @DocsEditable()\n  static const int COLOR_ATTACHMENT4_WEBGL = 0x8CE4;\n\n  @DomName('WebGLDrawBuffers.COLOR_ATTACHMENT5_WEBGL')\n  @DocsEditable()\n  static const int COLOR_ATTACHMENT5_WEBGL = 0x8CE5;\n\n  @DomName('WebGLDrawBuffers.COLOR_ATTACHMENT6_WEBGL')\n  @DocsEditable()\n  static const int COLOR_ATTACHMENT6_WEBGL = 0x8CE6;\n\n  @DomName('WebGLDrawBuffers.COLOR_ATTACHMENT7_WEBGL')\n  @DocsEditable()\n  static const int COLOR_ATTACHMENT7_WEBGL = 0x8CE7;\n\n  @DomName('WebGLDrawBuffers.COLOR_ATTACHMENT8_WEBGL')\n  @DocsEditable()\n  static const int COLOR_ATTACHMENT8_WEBGL = 0x8CE8;\n\n  @DomName('WebGLDrawBuffers.COLOR_ATTACHMENT9_WEBGL')\n  @DocsEditable()\n  static const int COLOR_ATTACHMENT9_WEBGL = 0x8CE9;\n\n  @DomName('WebGLDrawBuffers.DRAW_BUFFER0_WEBGL')\n  @DocsEditable()\n  static const int DRAW_BUFFER0_WEBGL = 0x8825;\n\n  @DomName('WebGLDrawBuffers.DRAW_BUFFER10_WEBGL')\n  @DocsEditable()\n  static const int DRAW_BUFFER10_WEBGL = 0x882F;\n\n  @DomName('WebGLDrawBuffers.DRAW_BUFFER11_WEBGL')\n  @DocsEditable()\n  static const int DRAW_BUFFER11_WEBGL = 0x8830;\n\n  @DomName('WebGLDrawBuffers.DRAW_BUFFER12_WEBGL')\n  @DocsEditable()\n  static const int DRAW_BUFFER12_WEBGL = 0x8831;\n\n  @DomName('WebGLDrawBuffers.DRAW_BUFFER13_WEBGL')\n  @DocsEditable()\n  static const int DRAW_BUFFER13_WEBGL = 0x8832;\n\n  @DomName('WebGLDrawBuffers.DRAW_BUFFER14_WEBGL')\n  @DocsEditable()\n  static const int DRAW_BUFFER14_WEBGL = 0x8833;\n\n  @DomName('WebGLDrawBuffers.DRAW_BUFFER15_WEBGL')\n  @DocsEditable()\n  static const int DRAW_BUFFER15_WEBGL = 0x8834;\n\n  @DomName('WebGLDrawBuffers.DRAW_BUFFER1_WEBGL')\n  @DocsEditable()\n  static const int DRAW_BUFFER1_WEBGL = 0x8826;\n\n  @DomName('WebGLDrawBuffers.DRAW_BUFFER2_WEBGL')\n  @DocsEditable()\n  static const int DRAW_BUFFER2_WEBGL = 0x8827;\n\n  @DomName('WebGLDrawBuffers.DRAW_BUFFER3_WEBGL')\n  @DocsEditable()\n  static const int DRAW_BUFFER3_WEBGL = 0x8828;\n\n  @DomName('WebGLDrawBuffers.DRAW_BUFFER4_WEBGL')\n  @DocsEditable()\n  static const int DRAW_BUFFER4_WEBGL = 0x8829;\n\n  @DomName('WebGLDrawBuffers.DRAW_BUFFER5_WEBGL')\n  @DocsEditable()\n  static const int DRAW_BUFFER5_WEBGL = 0x882A;\n\n  @DomName('WebGLDrawBuffers.DRAW_BUFFER6_WEBGL')\n  @DocsEditable()\n  static const int DRAW_BUFFER6_WEBGL = 0x882B;\n\n  @DomName('WebGLDrawBuffers.DRAW_BUFFER7_WEBGL')\n  @DocsEditable()\n  static const int DRAW_BUFFER7_WEBGL = 0x882C;\n\n  @DomName('WebGLDrawBuffers.DRAW_BUFFER8_WEBGL')\n  @DocsEditable()\n  static const int DRAW_BUFFER8_WEBGL = 0x882D;\n\n  @DomName('WebGLDrawBuffers.DRAW_BUFFER9_WEBGL')\n  @DocsEditable()\n  static const int DRAW_BUFFER9_WEBGL = 0x882E;\n\n  @DomName('WebGLDrawBuffers.MAX_COLOR_ATTACHMENTS_WEBGL')\n  @DocsEditable()\n  static const int MAX_COLOR_ATTACHMENTS_WEBGL = 0x8CDF;\n\n  @DomName('WebGLDrawBuffers.MAX_DRAW_BUFFERS_WEBGL')\n  @DocsEditable()\n  static const int MAX_DRAW_BUFFERS_WEBGL = 0x8824;\n\n  @JSName('drawBuffersWEBGL')\n  @DomName('WebGLDrawBuffers.drawBuffersWEBGL')\n  @DocsEditable()\n  void drawBuffersWebgl(List<int> buffers) native;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('EXTFragDepth')\n// http://www.khronos.org/registry/webgl/extensions/EXT_frag_depth/\n@Experimental()\n@Native(\"EXTFragDepth\")\nclass ExtFragDepth extends Interceptor {\n  // To suppress missing implicit constructor warnings.\n  factory ExtFragDepth._() { throw new UnsupportedError(\"Not supported\"); }\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('EXTTextureFilterAnisotropic')\n// http://www.khronos.org/registry/webgl/extensions/EXT_texture_filter_anisotropic/\n@Experimental()\n@Native(\"EXTTextureFilterAnisotropic\")\nclass ExtTextureFilterAnisotropic extends Interceptor {\n  // To suppress missing implicit constructor warnings.\n  factory ExtTextureFilterAnisotropic._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('EXTTextureFilterAnisotropic.MAX_TEXTURE_MAX_ANISOTROPY_EXT')\n  @DocsEditable()\n  static const int MAX_TEXTURE_MAX_ANISOTROPY_EXT = 0x84FF;\n\n  @DomName('EXTTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT')\n  @DocsEditable()\n  static const int TEXTURE_MAX_ANISOTROPY_EXT = 0x84FE;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('WebGLFramebuffer')\n@Unstable()\n@Native(\"WebGLFramebuffer\")\nclass Framebuffer extends Interceptor {\n  // To suppress missing implicit constructor warnings.\n  factory Framebuffer._() { throw new UnsupportedError(\"Not supported\"); }\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('WebGLLoseContext')\n// http://www.khronos.org/registry/webgl/extensions/WEBGL_lose_context/\n@Experimental()\n@Native(\"WebGLLoseContext,WebGLExtensionLoseContext\")\nclass LoseContext extends Interceptor {\n  // To suppress missing implicit constructor warnings.\n  factory LoseContext._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('WebGLLoseContext.loseContext')\n  @DocsEditable()\n  void loseContext() native;\n\n  @DomName('WebGLLoseContext.restoreContext')\n  @DocsEditable()\n  void restoreContext() native;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('OESElementIndexUint')\n// http://www.khronos.org/registry/webgl/extensions/OES_element_index_uint/\n@Experimental() // experimental\n@Native(\"OESElementIndexUint\")\nclass OesElementIndexUint extends Interceptor {\n  // To suppress missing implicit constructor warnings.\n  factory OesElementIndexUint._() { throw new UnsupportedError(\"Not supported\"); }\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('OESStandardDerivatives')\n// http://www.khronos.org/registry/webgl/extensions/OES_standard_derivatives/\n@Experimental() // experimental\n@Native(\"OESStandardDerivatives\")\nclass OesStandardDerivatives extends Interceptor {\n  // To suppress missing implicit constructor warnings.\n  factory OesStandardDerivatives._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('OESStandardDerivatives.FRAGMENT_SHADER_DERIVATIVE_HINT_OES')\n  @DocsEditable()\n  static const int FRAGMENT_SHADER_DERIVATIVE_HINT_OES = 0x8B8B;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('OESTextureFloat')\n// http://www.khronos.org/registry/webgl/extensions/OES_texture_float/\n@Experimental() // experimental\n@Native(\"OESTextureFloat\")\nclass OesTextureFloat extends Interceptor {\n  // To suppress missing implicit constructor warnings.\n  factory OesTextureFloat._() { throw new UnsupportedError(\"Not supported\"); }\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('OESTextureFloatLinear')\n// http://www.khronos.org/registry/webgl/extensions/OES_texture_float_linear/\n@Experimental()\n@Native(\"OESTextureFloatLinear\")\nclass OesTextureFloatLinear extends Interceptor {\n  // To suppress missing implicit constructor warnings.\n  factory OesTextureFloatLinear._() { throw new UnsupportedError(\"Not supported\"); }\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('OESTextureHalfFloat')\n// http://www.khronos.org/registry/webgl/extensions/OES_texture_half_float/\n@Experimental() // experimental\n@Native(\"OESTextureHalfFloat\")\nclass OesTextureHalfFloat extends Interceptor {\n  // To suppress missing implicit constructor warnings.\n  factory OesTextureHalfFloat._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('OESTextureHalfFloat.HALF_FLOAT_OES')\n  @DocsEditable()\n  static const int HALF_FLOAT_OES = 0x8D61;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('OESTextureHalfFloatLinear')\n// http://www.khronos.org/registry/webgl/extensions/OES_texture_half_float_linear/\n@Experimental()\n@Native(\"OESTextureHalfFloatLinear\")\nclass OesTextureHalfFloatLinear extends Interceptor {\n  // To suppress missing implicit constructor warnings.\n  factory OesTextureHalfFloatLinear._() { throw new UnsupportedError(\"Not supported\"); }\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('OESVertexArrayObject')\n// http://www.khronos.org/registry/webgl/extensions/OES_vertex_array_object/\n@Experimental() // experimental\n@Native(\"OESVertexArrayObject\")\nclass OesVertexArrayObject extends Interceptor {\n  // To suppress missing implicit constructor warnings.\n  factory OesVertexArrayObject._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('OESVertexArrayObject.VERTEX_ARRAY_BINDING_OES')\n  @DocsEditable()\n  static const int VERTEX_ARRAY_BINDING_OES = 0x85B5;\n\n  @JSName('bindVertexArrayOES')\n  @DomName('OESVertexArrayObject.bindVertexArrayOES')\n  @DocsEditable()\n  void bindVertexArray(VertexArrayObject arrayObject) native;\n\n  @JSName('createVertexArrayOES')\n  @DomName('OESVertexArrayObject.createVertexArrayOES')\n  @DocsEditable()\n  VertexArrayObject createVertexArray() native;\n\n  @JSName('deleteVertexArrayOES')\n  @DomName('OESVertexArrayObject.deleteVertexArrayOES')\n  @DocsEditable()\n  void deleteVertexArray(VertexArrayObject arrayObject) native;\n\n  @JSName('isVertexArrayOES')\n  @DomName('OESVertexArrayObject.isVertexArrayOES')\n  @DocsEditable()\n  bool isVertexArray(VertexArrayObject arrayObject) native;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('WebGLProgram')\n@Unstable()\n@Native(\"WebGLProgram\")\nclass Program extends Interceptor {\n  // To suppress missing implicit constructor warnings.\n  factory Program._() { throw new UnsupportedError(\"Not supported\"); }\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('WebGLRenderbuffer')\n@Unstable()\n@Native(\"WebGLRenderbuffer\")\nclass Renderbuffer extends Interceptor {\n  // To suppress missing implicit constructor warnings.\n  factory Renderbuffer._() { throw new UnsupportedError(\"Not supported\"); }\n}\n// Copyright (c) 2013, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DomName('WebGLRenderingContext')\n@SupportedBrowser(SupportedBrowser.CHROME)\n@SupportedBrowser(SupportedBrowser.FIREFOX)\n@Experimental()\n@Unstable()\n@Native(\"WebGLRenderingContext\")\nclass RenderingContext extends CanvasRenderingContext {\n  // To suppress missing implicit constructor warnings.\n  factory RenderingContext._() { throw new UnsupportedError(\"Not supported\"); }\n\n  /// Checks if this type is supported on the current platform.\n  static bool get supported => JS('bool', '!!(window.WebGLRenderingContext)');\n\n  @DomName('WebGLRenderingContext.ACTIVE_ATTRIBUTES')\n  @DocsEditable()\n  static const int ACTIVE_ATTRIBUTES = 0x8B89;\n\n  @DomName('WebGLRenderingContext.ACTIVE_TEXTURE')\n  @DocsEditable()\n  static const int ACTIVE_TEXTURE = 0x84E0;\n\n  @DomName('WebGLRenderingContext.ACTIVE_UNIFORMS')\n  @DocsEditable()\n  static const int ACTIVE_UNIFORMS = 0x8B86;\n\n  @DomName('WebGLRenderingContext.ALIASED_LINE_WIDTH_RANGE')\n  @DocsEditable()\n  static const int ALIASED_LINE_WIDTH_RANGE = 0x846E;\n\n  @DomName('WebGLRenderingContext.ALIASED_POINT_SIZE_RANGE')\n  @DocsEditable()\n  static const int ALIASED_POINT_SIZE_RANGE = 0x846D;\n\n  @DomName('WebGLRenderingContext.ALPHA')\n  @DocsEditable()\n  static const int ALPHA = 0x1906;\n\n  @DomName('WebGLRenderingContext.ALPHA_BITS')\n  @DocsEditable()\n  static const int ALPHA_BITS = 0x0D55;\n\n  @DomName('WebGLRenderingContext.ALWAYS')\n  @DocsEditable()\n  static const int ALWAYS = 0x0207;\n\n  @DomName('WebGLRenderingContext.ARRAY_BUFFER')\n  @DocsEditable()\n  static const int ARRAY_BUFFER = 0x8892;\n\n  @DomName('WebGLRenderingContext.ARRAY_BUFFER_BINDING')\n  @DocsEditable()\n  static const int ARRAY_BUFFER_BINDING = 0x8894;\n\n  @DomName('WebGLRenderingContext.ATTACHED_SHADERS')\n  @DocsEditable()\n  static const int ATTACHED_SHADERS = 0x8B85;\n\n  @DomName('WebGLRenderingContext.BACK')\n  @DocsEditable()\n  static const int BACK = 0x0405;\n\n  @DomName('WebGLRenderingContext.BLEND')\n  @DocsEditable()\n  static const int BLEND = 0x0BE2;\n\n  @DomName('WebGLRenderingContext.BLEND_COLOR')\n  @DocsEditable()\n  static const int BLEND_COLOR = 0x8005;\n\n  @DomName('WebGLRenderingContext.BLEND_DST_ALPHA')\n  @DocsEditable()\n  static const int BLEND_DST_ALPHA = 0x80CA;\n\n  @DomName('WebGLRenderingContext.BLEND_DST_RGB')\n  @DocsEditable()\n  static const int BLEND_DST_RGB = 0x80C8;\n\n  @DomName('WebGLRenderingContext.BLEND_EQUATION')\n  @DocsEditable()\n  static const int BLEND_EQUATION = 0x8009;\n\n  @DomName('WebGLRenderingContext.BLEND_EQUATION_ALPHA')\n  @DocsEditable()\n  static const int BLEND_EQUATION_ALPHA = 0x883D;\n\n  @DomName('WebGLRenderingContext.BLEND_EQUATION_RGB')\n  @DocsEditable()\n  static const int BLEND_EQUATION_RGB = 0x8009;\n\n  @DomName('WebGLRenderingContext.BLEND_SRC_ALPHA')\n  @DocsEditable()\n  static const int BLEND_SRC_ALPHA = 0x80CB;\n\n  @DomName('WebGLRenderingContext.BLEND_SRC_RGB')\n  @DocsEditable()\n  static const int BLEND_SRC_RGB = 0x80C9;\n\n  @DomName('WebGLRenderingContext.BLUE_BITS')\n  @DocsEditable()\n  static const int BLUE_BITS = 0x0D54;\n\n  @DomName('WebGLRenderingContext.BOOL')\n  @DocsEditable()\n  static const int BOOL = 0x8B56;\n\n  @DomName('WebGLRenderingContext.BOOL_VEC2')\n  @DocsEditable()\n  static const int BOOL_VEC2 = 0x8B57;\n\n  @DomName('WebGLRenderingContext.BOOL_VEC3')\n  @DocsEditable()\n  static const int BOOL_VEC3 = 0x8B58;\n\n  @DomName('WebGLRenderingContext.BOOL_VEC4')\n  @DocsEditable()\n  static const int BOOL_VEC4 = 0x8B59;\n\n  @DomName('WebGLRenderingContext.BROWSER_DEFAULT_WEBGL')\n  @DocsEditable()\n  static const int BROWSER_DEFAULT_WEBGL = 0x9244;\n\n  @DomName('WebGLRenderingContext.BUFFER_SIZE')\n  @DocsEditable()\n  static const int BUFFER_SIZE = 0x8764;\n\n  @DomName('WebGLRenderingContext.BUFFER_USAGE')\n  @DocsEditable()\n  static const int BUFFER_USAGE = 0x8765;\n\n  @DomName('WebGLRenderingContext.BYTE')\n  @DocsEditable()\n  static const int BYTE = 0x1400;\n\n  @DomName('WebGLRenderingContext.CCW')\n  @DocsEditable()\n  static const int CCW = 0x0901;\n\n  @DomName('WebGLRenderingContext.CLAMP_TO_EDGE')\n  @DocsEditable()\n  static const int CLAMP_TO_EDGE = 0x812F;\n\n  @DomName('WebGLRenderingContext.COLOR_ATTACHMENT0')\n  @DocsEditable()\n  static const int COLOR_ATTACHMENT0 = 0x8CE0;\n\n  @DomName('WebGLRenderingContext.COLOR_BUFFER_BIT')\n  @DocsEditable()\n  static const int COLOR_BUFFER_BIT = 0x00004000;\n\n  @DomName('WebGLRenderingContext.COLOR_CLEAR_VALUE')\n  @DocsEditable()\n  static const int COLOR_CLEAR_VALUE = 0x0C22;\n\n  @DomName('WebGLRenderingContext.COLOR_WRITEMASK')\n  @DocsEditable()\n  static const int COLOR_WRITEMASK = 0x0C23;\n\n  @DomName('WebGLRenderingContext.COMPILE_STATUS')\n  @DocsEditable()\n  static const int COMPILE_STATUS = 0x8B81;\n\n  @DomName('WebGLRenderingContext.COMPRESSED_TEXTURE_FORMATS')\n  @DocsEditable()\n  static const int COMPRESSED_TEXTURE_FORMATS = 0x86A3;\n\n  @DomName('WebGLRenderingContext.CONSTANT_ALPHA')\n  @DocsEditable()\n  static const int CONSTANT_ALPHA = 0x8003;\n\n  @DomName('WebGLRenderingContext.CONSTANT_COLOR')\n  @DocsEditable()\n  static const int CONSTANT_COLOR = 0x8001;\n\n  @DomName('WebGLRenderingContext.CONTEXT_LOST_WEBGL')\n  @DocsEditable()\n  static const int CONTEXT_LOST_WEBGL = 0x9242;\n\n  @DomName('WebGLRenderingContext.CULL_FACE')\n  @DocsEditable()\n  static const int CULL_FACE = 0x0B44;\n\n  @DomName('WebGLRenderingContext.CULL_FACE_MODE')\n  @DocsEditable()\n  static const int CULL_FACE_MODE = 0x0B45;\n\n  @DomName('WebGLRenderingContext.CURRENT_PROGRAM')\n  @DocsEditable()\n  static const int CURRENT_PROGRAM = 0x8B8D;\n\n  @DomName('WebGLRenderingContext.CURRENT_VERTEX_ATTRIB')\n  @DocsEditable()\n  static const int CURRENT_VERTEX_ATTRIB = 0x8626;\n\n  @DomName('WebGLRenderingContext.CW')\n  @DocsEditable()\n  static const int CW = 0x0900;\n\n  @DomName('WebGLRenderingContext.DECR')\n  @DocsEditable()\n  static const int DECR = 0x1E03;\n\n  @DomName('WebGLRenderingContext.DECR_WRAP')\n  @DocsEditable()\n  static const int DECR_WRAP = 0x8508;\n\n  @DomName('WebGLRenderingContext.DELETE_STATUS')\n  @DocsEditable()\n  static const int DELETE_STATUS = 0x8B80;\n\n  @DomName('WebGLRenderingContext.DEPTH_ATTACHMENT')\n  @DocsEditable()\n  static const int DEPTH_ATTACHMENT = 0x8D00;\n\n  @DomName('WebGLRenderingContext.DEPTH_BITS')\n  @DocsEditable()\n  static const int DEPTH_BITS = 0x0D56;\n\n  @DomName('WebGLRenderingContext.DEPTH_BUFFER_BIT')\n  @DocsEditable()\n  static const int DEPTH_BUFFER_BIT = 0x00000100;\n\n  @DomName('WebGLRenderingContext.DEPTH_CLEAR_VALUE')\n  @DocsEditable()\n  static const int DEPTH_CLEAR_VALUE = 0x0B73;\n\n  @DomName('WebGLRenderingContext.DEPTH_COMPONENT')\n  @DocsEditable()\n  static const int DEPTH_COMPONENT = 0x1902;\n\n  @DomName('WebGLRenderingContext.DEPTH_COMPONENT16')\n  @DocsEditable()\n  static const int DEPTH_COMPONENT16 = 0x81A5;\n\n  @DomName('WebGLRenderingContext.DEPTH_FUNC')\n  @DocsEditable()\n  static const int DEPTH_FUNC = 0x0B74;\n\n  @DomName('WebGLRenderingContext.DEPTH_RANGE')\n  @DocsEditable()\n  static const int DEPTH_RANGE = 0x0B70;\n\n  @DomName('WebGLRenderingContext.DEPTH_STENCIL')\n  @DocsEditable()\n  static const int DEPTH_STENCIL = 0x84F9;\n\n  @DomName('WebGLRenderingContext.DEPTH_STENCIL_ATTACHMENT')\n  @DocsEditable()\n  static const int DEPTH_STENCIL_ATTACHMENT = 0x821A;\n\n  @DomName('WebGLRenderingContext.DEPTH_TEST')\n  @DocsEditable()\n  static const int DEPTH_TEST = 0x0B71;\n\n  @DomName('WebGLRenderingContext.DEPTH_WRITEMASK')\n  @DocsEditable()\n  static const int DEPTH_WRITEMASK = 0x0B72;\n\n  @DomName('WebGLRenderingContext.DITHER')\n  @DocsEditable()\n  static const int DITHER = 0x0BD0;\n\n  @DomName('WebGLRenderingContext.DONT_CARE')\n  @DocsEditable()\n  static const int DONT_CARE = 0x1100;\n\n  @DomName('WebGLRenderingContext.DST_ALPHA')\n  @DocsEditable()\n  static const int DST_ALPHA = 0x0304;\n\n  @DomName('WebGLRenderingContext.DST_COLOR')\n  @DocsEditable()\n  static const int DST_COLOR = 0x0306;\n\n  @DomName('WebGLRenderingContext.DYNAMIC_DRAW')\n  @DocsEditable()\n  static const int DYNAMIC_DRAW = 0x88E8;\n\n  @DomName('WebGLRenderingContext.ELEMENT_ARRAY_BUFFER')\n  @DocsEditable()\n  static const int ELEMENT_ARRAY_BUFFER = 0x8893;\n\n  @DomName('WebGLRenderingContext.ELEMENT_ARRAY_BUFFER_BINDING')\n  @DocsEditable()\n  static const int ELEMENT_ARRAY_BUFFER_BINDING = 0x8895;\n\n  @DomName('WebGLRenderingContext.EQUAL')\n  @DocsEditable()\n  static const int EQUAL = 0x0202;\n\n  @DomName('WebGLRenderingContext.FASTEST')\n  @DocsEditable()\n  static const int FASTEST = 0x1101;\n\n  @DomName('WebGLRenderingContext.FLOAT')\n  @DocsEditable()\n  static const int FLOAT = 0x1406;\n\n  @DomName('WebGLRenderingContext.FLOAT_MAT2')\n  @DocsEditable()\n  static const int FLOAT_MAT2 = 0x8B5A;\n\n  @DomName('WebGLRenderingContext.FLOAT_MAT3')\n  @DocsEditable()\n  static const int FLOAT_MAT3 = 0x8B5B;\n\n  @DomName('WebGLRenderingContext.FLOAT_MAT4')\n  @DocsEditable()\n  static const int FLOAT_MAT4 = 0x8B5C;\n\n  @DomName('WebGLRenderingContext.FLOAT_VEC2')\n  @DocsEditable()\n  static const int FLOAT_VEC2 = 0x8B50;\n\n  @DomName('WebGLRenderingContext.FLOAT_VEC3')\n  @DocsEditable()\n  static const int FLOAT_VEC3 = 0x8B51;\n\n  @DomName('WebGLRenderingContext.FLOAT_VEC4')\n  @DocsEditable()\n  static const int FLOAT_VEC4 = 0x8B52;\n\n  @DomName('WebGLRenderingContext.FRAGMENT_SHADER')\n  @DocsEditable()\n  static const int FRAGMENT_SHADER = 0x8B30;\n\n  @DomName('WebGLRenderingContext.FRAMEBUFFER')\n  @DocsEditable()\n  static const int FRAMEBUFFER = 0x8D40;\n\n  @DomName('WebGLRenderingContext.FRAMEBUFFER_ATTACHMENT_OBJECT_NAME')\n  @DocsEditable()\n  static const int FRAMEBUFFER_ATTACHMENT_OBJECT_NAME = 0x8CD1;\n\n  @DomName('WebGLRenderingContext.FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE')\n  @DocsEditable()\n  static const int FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE = 0x8CD0;\n\n  @DomName('WebGLRenderingContext.FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE')\n  @DocsEditable()\n  static const int FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE = 0x8CD3;\n\n  @DomName('WebGLRenderingContext.FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL')\n  @DocsEditable()\n  static const int FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL = 0x8CD2;\n\n  @DomName('WebGLRenderingContext.FRAMEBUFFER_BINDING')\n  @DocsEditable()\n  static const int FRAMEBUFFER_BINDING = 0x8CA6;\n\n  @DomName('WebGLRenderingContext.FRAMEBUFFER_COMPLETE')\n  @DocsEditable()\n  static const int FRAMEBUFFER_COMPLETE = 0x8CD5;\n\n  @DomName('WebGLRenderingContext.FRAMEBUFFER_INCOMPLETE_ATTACHMENT')\n  @DocsEditable()\n  static const int FRAMEBUFFER_INCOMPLETE_ATTACHMENT = 0x8CD6;\n\n  @DomName('WebGLRenderingContext.FRAMEBUFFER_INCOMPLETE_DIMENSIONS')\n  @DocsEditable()\n  static const int FRAMEBUFFER_INCOMPLETE_DIMENSIONS = 0x8CD9;\n\n  @DomName('WebGLRenderingContext.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT')\n  @DocsEditable()\n  static const int FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT = 0x8CD7;\n\n  @DomName('WebGLRenderingContext.FRAMEBUFFER_UNSUPPORTED')\n  @DocsEditable()\n  static const int FRAMEBUFFER_UNSUPPORTED = 0x8CDD;\n\n  @DomName('WebGLRenderingContext.FRONT')\n  @DocsEditable()\n  static const int FRONT = 0x0404;\n\n  @DomName('WebGLRenderingContext.FRONT_AND_BACK')\n  @DocsEditable()\n  static const int FRONT_AND_BACK = 0x0408;\n\n  @DomName('WebGLRenderingContext.FRONT_FACE')\n  @DocsEditable()\n  static const int FRONT_FACE = 0x0B46;\n\n  @DomName('WebGLRenderingContext.FUNC_ADD')\n  @DocsEditable()\n  static const int FUNC_ADD = 0x8006;\n\n  @DomName('WebGLRenderingContext.FUNC_REVERSE_SUBTRACT')\n  @DocsEditable()\n  static const int FUNC_REVERSE_SUBTRACT = 0x800B;\n\n  @DomName('WebGLRenderingContext.FUNC_SUBTRACT')\n  @DocsEditable()\n  static const int FUNC_SUBTRACT = 0x800A;\n\n  @DomName('WebGLRenderingContext.GENERATE_MIPMAP_HINT')\n  @DocsEditable()\n  static const int GENERATE_MIPMAP_HINT = 0x8192;\n\n  @DomName('WebGLRenderingContext.GEQUAL')\n  @DocsEditable()\n  static const int GEQUAL = 0x0206;\n\n  @DomName('WebGLRenderingContext.GREATER')\n  @DocsEditable()\n  static const int GREATER = 0x0204;\n\n  @DomName('WebGLRenderingContext.GREEN_BITS')\n  @DocsEditable()\n  static const int GREEN_BITS = 0x0D53;\n\n  @DomName('WebGLRenderingContext.HIGH_FLOAT')\n  @DocsEditable()\n  static const int HIGH_FLOAT = 0x8DF2;\n\n  @DomName('WebGLRenderingContext.HIGH_INT')\n  @DocsEditable()\n  static const int HIGH_INT = 0x8DF5;\n\n  @DomName('WebGLRenderingContext.INCR')\n  @DocsEditable()\n  static const int INCR = 0x1E02;\n\n  @DomName('WebGLRenderingContext.INCR_WRAP')\n  @DocsEditable()\n  static const int INCR_WRAP = 0x8507;\n\n  @DomName('WebGLRenderingContext.INT')\n  @DocsEditable()\n  static const int INT = 0x1404;\n\n  @DomName('WebGLRenderingContext.INT_VEC2')\n  @DocsEditable()\n  static const int INT_VEC2 = 0x8B53;\n\n  @DomName('WebGLRenderingContext.INT_VEC3')\n  @DocsEditable()\n  static const int INT_VEC3 = 0x8B54;\n\n  @DomName('WebGLRenderingContext.INT_VEC4')\n  @DocsEditable()\n  static const int INT_VEC4 = 0x8B55;\n\n  @DomName('WebGLRenderingContext.INVALID_ENUM')\n  @DocsEditable()\n  static const int INVALID_ENUM = 0x0500;\n\n  @DomName('WebGLRenderingContext.INVALID_FRAMEBUFFER_OPERATION')\n  @DocsEditable()\n  static const int INVALID_FRAMEBUFFER_OPERATION = 0x0506;\n\n  @DomName('WebGLRenderingContext.INVALID_OPERATION')\n  @DocsEditable()\n  static const int INVALID_OPERATION = 0x0502;\n\n  @DomName('WebGLRenderingContext.INVALID_VALUE')\n  @DocsEditable()\n  static const int INVALID_VALUE = 0x0501;\n\n  @DomName('WebGLRenderingContext.INVERT')\n  @DocsEditable()\n  static const int INVERT = 0x150A;\n\n  @DomName('WebGLRenderingContext.KEEP')\n  @DocsEditable()\n  static const int KEEP = 0x1E00;\n\n  @DomName('WebGLRenderingContext.LEQUAL')\n  @DocsEditable()\n  static const int LEQUAL = 0x0203;\n\n  @DomName('WebGLRenderingContext.LESS')\n  @DocsEditable()\n  static const int LESS = 0x0201;\n\n  @DomName('WebGLRenderingContext.LINEAR')\n  @DocsEditable()\n  static const int LINEAR = 0x2601;\n\n  @DomName('WebGLRenderingContext.LINEAR_MIPMAP_LINEAR')\n  @DocsEditable()\n  static const int LINEAR_MIPMAP_LINEAR = 0x2703;\n\n  @DomName('WebGLRenderingContext.LINEAR_MIPMAP_NEAREST')\n  @DocsEditable()\n  static const int LINEAR_MIPMAP_NEAREST = 0x2701;\n\n  @DomName('WebGLRenderingContext.LINES')\n  @DocsEditable()\n  static const int LINES = 0x0001;\n\n  @DomName('WebGLRenderingContext.LINE_LOOP')\n  @DocsEditable()\n  static const int LINE_LOOP = 0x0002;\n\n  @DomName('WebGLRenderingContext.LINE_STRIP')\n  @DocsEditable()\n  static const int LINE_STRIP = 0x0003;\n\n  @DomName('WebGLRenderingContext.LINE_WIDTH')\n  @DocsEditable()\n  static const int LINE_WIDTH = 0x0B21;\n\n  @DomName('WebGLRenderingContext.LINK_STATUS')\n  @DocsEditable()\n  static const int LINK_STATUS = 0x8B82;\n\n  @DomName('WebGLRenderingContext.LOW_FLOAT')\n  @DocsEditable()\n  static const int LOW_FLOAT = 0x8DF0;\n\n  @DomName('WebGLRenderingContext.LOW_INT')\n  @DocsEditable()\n  static const int LOW_INT = 0x8DF3;\n\n  @DomName('WebGLRenderingContext.LUMINANCE')\n  @DocsEditable()\n  static const int LUMINANCE = 0x1909;\n\n  @DomName('WebGLRenderingContext.LUMINANCE_ALPHA')\n  @DocsEditable()\n  static const int LUMINANCE_ALPHA = 0x190A;\n\n  @DomName('WebGLRenderingContext.MAX_COMBINED_TEXTURE_IMAGE_UNITS')\n  @DocsEditable()\n  static const int MAX_COMBINED_TEXTURE_IMAGE_UNITS = 0x8B4D;\n\n  @DomName('WebGLRenderingContext.MAX_CUBE_MAP_TEXTURE_SIZE')\n  @DocsEditable()\n  static const int MAX_CUBE_MAP_TEXTURE_SIZE = 0x851C;\n\n  @DomName('WebGLRenderingContext.MAX_FRAGMENT_UNIFORM_VECTORS')\n  @DocsEditable()\n  static const int MAX_FRAGMENT_UNIFORM_VECTORS = 0x8DFD;\n\n  @DomName('WebGLRenderingContext.MAX_RENDERBUFFER_SIZE')\n  @DocsEditable()\n  static const int MAX_RENDERBUFFER_SIZE = 0x84E8;\n\n  @DomName('WebGLRenderingContext.MAX_TEXTURE_IMAGE_UNITS')\n  @DocsEditable()\n  static const int MAX_TEXTURE_IMAGE_UNITS = 0x8872;\n\n  @DomName('WebGLRenderingContext.MAX_TEXTURE_SIZE')\n  @DocsEditable()\n  static const int MAX_TEXTURE_SIZE = 0x0D33;\n\n  @DomName('WebGLRenderingContext.MAX_VARYING_VECTORS')\n  @DocsEditable()\n  static const int MAX_VARYING_VECTORS = 0x8DFC;\n\n  @DomName('WebGLRenderingContext.MAX_VERTEX_ATTRIBS')\n  @DocsEditable()\n  static const int MAX_VERTEX_ATTRIBS = 0x8869;\n\n  @DomName('WebGLRenderingContext.MAX_VERTEX_TEXTURE_IMAGE_UNITS')\n  @DocsEditable()\n  static const int MAX_VERTEX_TEXTURE_IMAGE_UNITS = 0x8B4C;\n\n  @DomName('WebGLRenderingContext.MAX_VERTEX_UNIFORM_VECTORS')\n  @DocsEditable()\n  static const int MAX_VERTEX_UNIFORM_VECTORS = 0x8DFB;\n\n  @DomName('WebGLRenderingContext.MAX_VIEWPORT_DIMS')\n  @DocsEditable()\n  static const int MAX_VIEWPORT_DIMS = 0x0D3A;\n\n  @DomName('WebGLRenderingContext.MEDIUM_FLOAT')\n  @DocsEditable()\n  static const int MEDIUM_FLOAT = 0x8DF1;\n\n  @DomName('WebGLRenderingContext.MEDIUM_INT')\n  @DocsEditable()\n  static const int MEDIUM_INT = 0x8DF4;\n\n  @DomName('WebGLRenderingContext.MIRRORED_REPEAT')\n  @DocsEditable()\n  static const int MIRRORED_REPEAT = 0x8370;\n\n  @DomName('WebGLRenderingContext.NEAREST')\n  @DocsEditable()\n  static const int NEAREST = 0x2600;\n\n  @DomName('WebGLRenderingContext.NEAREST_MIPMAP_LINEAR')\n  @DocsEditable()\n  static const int NEAREST_MIPMAP_LINEAR = 0x2702;\n\n  @DomName('WebGLRenderingContext.NEAREST_MIPMAP_NEAREST')\n  @DocsEditable()\n  static const int NEAREST_MIPMAP_NEAREST = 0x2700;\n\n  @DomName('WebGLRenderingContext.NEVER')\n  @DocsEditable()\n  static const int NEVER = 0x0200;\n\n  @DomName('WebGLRenderingContext.NICEST')\n  @DocsEditable()\n  static const int NICEST = 0x1102;\n\n  @DomName('WebGLRenderingContext.NONE')\n  @DocsEditable()\n  static const int NONE = 0;\n\n  @DomName('WebGLRenderingContext.NOTEQUAL')\n  @DocsEditable()\n  static const int NOTEQUAL = 0x0205;\n\n  @DomName('WebGLRenderingContext.NO_ERROR')\n  @DocsEditable()\n  static const int NO_ERROR = 0;\n\n  @DomName('WebGLRenderingContext.ONE')\n  @DocsEditable()\n  static const int ONE = 1;\n\n  @DomName('WebGLRenderingContext.ONE_MINUS_CONSTANT_ALPHA')\n  @DocsEditable()\n  static const int ONE_MINUS_CONSTANT_ALPHA = 0x8004;\n\n  @DomName('WebGLRenderingContext.ONE_MINUS_CONSTANT_COLOR')\n  @DocsEditable()\n  static const int ONE_MINUS_CONSTANT_COLOR = 0x8002;\n\n  @DomName('WebGLRenderingContext.ONE_MINUS_DST_ALPHA')\n  @DocsEditable()\n  static const int ONE_MINUS_DST_ALPHA = 0x0305;\n\n  @DomName('WebGLRenderingContext.ONE_MINUS_DST_COLOR')\n  @DocsEditable()\n  static const int ONE_MINUS_DST_COLOR = 0x0307;\n\n  @DomName('WebGLRenderingContext.ONE_MINUS_SRC_ALPHA')\n  @DocsEditable()\n  static const int ONE_MINUS_SRC_ALPHA = 0x0303;\n\n  @DomName('WebGLRenderingContext.ONE_MINUS_SRC_COLOR')\n  @DocsEditable()\n  static const int ONE_MINUS_SRC_COLOR = 0x0301;\n\n  @DomName('WebGLRenderingContext.OUT_OF_MEMORY')\n  @DocsEditable()\n  static const int OUT_OF_MEMORY = 0x0505;\n\n  @DomName('WebGLRenderingContext.PACK_ALIGNMENT')\n  @DocsEditable()\n  static const int PACK_ALIGNMENT = 0x0D05;\n\n  @DomName('WebGLRenderingContext.POINTS')\n  @DocsEditable()\n  static const int POINTS = 0x0000;\n\n  @DomName('WebGLRenderingContext.POLYGON_OFFSET_FACTOR')\n  @DocsEditable()\n  static const int POLYGON_OFFSET_FACTOR = 0x8038;\n\n  @DomName('WebGLRenderingContext.POLYGON_OFFSET_FILL')\n  @DocsEditable()\n  static const int POLYGON_OFFSET_FILL = 0x8037;\n\n  @DomName('WebGLRenderingContext.POLYGON_OFFSET_UNITS')\n  @DocsEditable()\n  static const int POLYGON_OFFSET_UNITS = 0x2A00;\n\n  @DomName('WebGLRenderingContext.RED_BITS')\n  @DocsEditable()\n  static const int RED_BITS = 0x0D52;\n\n  @DomName('WebGLRenderingContext.RENDERBUFFER')\n  @DocsEditable()\n  static const int RENDERBUFFER = 0x8D41;\n\n  @DomName('WebGLRenderingContext.RENDERBUFFER_ALPHA_SIZE')\n  @DocsEditable()\n  static const int RENDERBUFFER_ALPHA_SIZE = 0x8D53;\n\n  @DomName('WebGLRenderingContext.RENDERBUFFER_BINDING')\n  @DocsEditable()\n  static const int RENDERBUFFER_BINDING = 0x8CA7;\n\n  @DomName('WebGLRenderingContext.RENDERBUFFER_BLUE_SIZE')\n  @DocsEditable()\n  static const int RENDERBUFFER_BLUE_SIZE = 0x8D52;\n\n  @DomName('WebGLRenderingContext.RENDERBUFFER_DEPTH_SIZE')\n  @DocsEditable()\n  static const int RENDERBUFFER_DEPTH_SIZE = 0x8D54;\n\n  @DomName('WebGLRenderingContext.RENDERBUFFER_GREEN_SIZE')\n  @DocsEditable()\n  static const int RENDERBUFFER_GREEN_SIZE = 0x8D51;\n\n  @DomName('WebGLRenderingContext.RENDERBUFFER_HEIGHT')\n  @DocsEditable()\n  static const int RENDERBUFFER_HEIGHT = 0x8D43;\n\n  @DomName('WebGLRenderingContext.RENDERBUFFER_INTERNAL_FORMAT')\n  @DocsEditable()\n  static const int RENDERBUFFER_INTERNAL_FORMAT = 0x8D44;\n\n  @DomName('WebGLRenderingContext.RENDERBUFFER_RED_SIZE')\n  @DocsEditable()\n  static const int RENDERBUFFER_RED_SIZE = 0x8D50;\n\n  @DomName('WebGLRenderingContext.RENDERBUFFER_STENCIL_SIZE')\n  @DocsEditable()\n  static const int RENDERBUFFER_STENCIL_SIZE = 0x8D55;\n\n  @DomName('WebGLRenderingContext.RENDERBUFFER_WIDTH')\n  @DocsEditable()\n  static const int RENDERBUFFER_WIDTH = 0x8D42;\n\n  @DomName('WebGLRenderingContext.RENDERER')\n  @DocsEditable()\n  static const int RENDERER = 0x1F01;\n\n  @DomName('WebGLRenderingContext.REPEAT')\n  @DocsEditable()\n  static const int REPEAT = 0x2901;\n\n  @DomName('WebGLRenderingContext.REPLACE')\n  @DocsEditable()\n  static const int REPLACE = 0x1E01;\n\n  @DomName('WebGLRenderingContext.RGB')\n  @DocsEditable()\n  static const int RGB = 0x1907;\n\n  @DomName('WebGLRenderingContext.RGB565')\n  @DocsEditable()\n  static const int RGB565 = 0x8D62;\n\n  @DomName('WebGLRenderingContext.RGB5_A1')\n  @DocsEditable()\n  static const int RGB5_A1 = 0x8057;\n\n  @DomName('WebGLRenderingContext.RGBA')\n  @DocsEditable()\n  static const int RGBA = 0x1908;\n\n  @DomName('WebGLRenderingContext.RGBA4')\n  @DocsEditable()\n  static const int RGBA4 = 0x8056;\n\n  @DomName('WebGLRenderingContext.SAMPLER_2D')\n  @DocsEditable()\n  static const int SAMPLER_2D = 0x8B5E;\n\n  @DomName('WebGLRenderingContext.SAMPLER_CUBE')\n  @DocsEditable()\n  static const int SAMPLER_CUBE = 0x8B60;\n\n  @DomName('WebGLRenderingContext.SAMPLES')\n  @DocsEditable()\n  static const int SAMPLES = 0x80A9;\n\n  @DomName('WebGLRenderingContext.SAMPLE_ALPHA_TO_COVERAGE')\n  @DocsEditable()\n  static const int SAMPLE_ALPHA_TO_COVERAGE = 0x809E;\n\n  @DomName('WebGLRenderingContext.SAMPLE_BUFFERS')\n  @DocsEditable()\n  static const int SAMPLE_BUFFERS = 0x80A8;\n\n  @DomName('WebGLRenderingContext.SAMPLE_COVERAGE')\n  @DocsEditable()\n  static const int SAMPLE_COVERAGE = 0x80A0;\n\n  @DomName('WebGLRenderingContext.SAMPLE_COVERAGE_INVERT')\n  @DocsEditable()\n  static const int SAMPLE_COVERAGE_INVERT = 0x80AB;\n\n  @DomName('WebGLRenderingContext.SAMPLE_COVERAGE_VALUE')\n  @DocsEditable()\n  static const int SAMPLE_COVERAGE_VALUE = 0x80AA;\n\n  @DomName('WebGLRenderingContext.SCISSOR_BOX')\n  @DocsEditable()\n  static const int SCISSOR_BOX = 0x0C10;\n\n  @DomName('WebGLRenderingContext.SCISSOR_TEST')\n  @DocsEditable()\n  static const int SCISSOR_TEST = 0x0C11;\n\n  @DomName('WebGLRenderingContext.SHADER_TYPE')\n  @DocsEditable()\n  static const int SHADER_TYPE = 0x8B4F;\n\n  @DomName('WebGLRenderingContext.SHADING_LANGUAGE_VERSION')\n  @DocsEditable()\n  static const int SHADING_LANGUAGE_VERSION = 0x8B8C;\n\n  @DomName('WebGLRenderingContext.SHORT')\n  @DocsEditable()\n  static const int SHORT = 0x1402;\n\n  @DomName('WebGLRenderingContext.SRC_ALPHA')\n  @DocsEditable()\n  static const int SRC_ALPHA = 0x0302;\n\n  @DomName('WebGLRenderingContext.SRC_ALPHA_SATURATE')\n  @DocsEditable()\n  static const int SRC_ALPHA_SATURATE = 0x0308;\n\n  @DomName('WebGLRenderingContext.SRC_COLOR')\n  @DocsEditable()\n  static const int SRC_COLOR = 0x0300;\n\n  @DomName('WebGLRenderingContext.STATIC_DRAW')\n  @DocsEditable()\n  static const int STATIC_DRAW = 0x88E4;\n\n  @DomName('WebGLRenderingContext.STENCIL_ATTACHMENT')\n  @DocsEditable()\n  static const int STENCIL_ATTACHMENT = 0x8D20;\n\n  @DomName('WebGLRenderingContext.STENCIL_BACK_FAIL')\n  @DocsEditable()\n  static const int STENCIL_BACK_FAIL = 0x8801;\n\n  @DomName('WebGLRenderingContext.STENCIL_BACK_FUNC')\n  @DocsEditable()\n  static const int STENCIL_BACK_FUNC = 0x8800;\n\n  @DomName('WebGLRenderingContext.STENCIL_BACK_PASS_DEPTH_FAIL')\n  @DocsEditable()\n  static const int STENCIL_BACK_PASS_DEPTH_FAIL = 0x8802;\n\n  @DomName('WebGLRenderingContext.STENCIL_BACK_PASS_DEPTH_PASS')\n  @DocsEditable()\n  static const int STENCIL_BACK_PASS_DEPTH_PASS = 0x8803;\n\n  @DomName('WebGLRenderingContext.STENCIL_BACK_REF')\n  @DocsEditable()\n  static const int STENCIL_BACK_REF = 0x8CA3;\n\n  @DomName('WebGLRenderingContext.STENCIL_BACK_VALUE_MASK')\n  @DocsEditable()\n  static const int STENCIL_BACK_VALUE_MASK = 0x8CA4;\n\n  @DomName('WebGLRenderingContext.STENCIL_BACK_WRITEMASK')\n  @DocsEditable()\n  static const int STENCIL_BACK_WRITEMASK = 0x8CA5;\n\n  @DomName('WebGLRenderingContext.STENCIL_BITS')\n  @DocsEditable()\n  static const int STENCIL_BITS = 0x0D57;\n\n  @DomName('WebGLRenderingContext.STENCIL_BUFFER_BIT')\n  @DocsEditable()\n  static const int STENCIL_BUFFER_BIT = 0x00000400;\n\n  @DomName('WebGLRenderingContext.STENCIL_CLEAR_VALUE')\n  @DocsEditable()\n  static const int STENCIL_CLEAR_VALUE = 0x0B91;\n\n  @DomName('WebGLRenderingContext.STENCIL_FAIL')\n  @DocsEditable()\n  static const int STENCIL_FAIL = 0x0B94;\n\n  @DomName('WebGLRenderingContext.STENCIL_FUNC')\n  @DocsEditable()\n  static const int STENCIL_FUNC = 0x0B92;\n\n  @DomName('WebGLRenderingContext.STENCIL_INDEX')\n  @DocsEditable()\n  static const int STENCIL_INDEX = 0x1901;\n\n  @DomName('WebGLRenderingContext.STENCIL_INDEX8')\n  @DocsEditable()\n  static const int STENCIL_INDEX8 = 0x8D48;\n\n  @DomName('WebGLRenderingContext.STENCIL_PASS_DEPTH_FAIL')\n  @DocsEditable()\n  static const int STENCIL_PASS_DEPTH_FAIL = 0x0B95;\n\n  @DomName('WebGLRenderingContext.STENCIL_PASS_DEPTH_PASS')\n  @DocsEditable()\n  static const int STENCIL_PASS_DEPTH_PASS = 0x0B96;\n\n  @DomName('WebGLRenderingContext.STENCIL_REF')\n  @DocsEditable()\n  static const int STENCIL_REF = 0x0B97;\n\n  @DomName('WebGLRenderingContext.STENCIL_TEST')\n  @DocsEditable()\n  static const int STENCIL_TEST = 0x0B90;\n\n  @DomName('WebGLRenderingContext.STENCIL_VALUE_MASK')\n  @DocsEditable()\n  static const int STENCIL_VALUE_MASK = 0x0B93;\n\n  @DomName('WebGLRenderingContext.STENCIL_WRITEMASK')\n  @DocsEditable()\n  static const int STENCIL_WRITEMASK = 0x0B98;\n\n  @DomName('WebGLRenderingContext.STREAM_DRAW')\n  @DocsEditable()\n  static const int STREAM_DRAW = 0x88E0;\n\n  @DomName('WebGLRenderingContext.SUBPIXEL_BITS')\n  @DocsEditable()\n  static const int SUBPIXEL_BITS = 0x0D50;\n\n  @DomName('WebGLRenderingContext.TEXTURE')\n  @DocsEditable()\n  static const int TEXTURE = 0x1702;\n\n  @DomName('WebGLRenderingContext.TEXTURE0')\n  @DocsEditable()\n  static const int TEXTURE0 = 0x84C0;\n\n  @DomName('WebGLRenderingContext.TEXTURE1')\n  @DocsEditable()\n  static const int TEXTURE1 = 0x84C1;\n\n  @DomName('WebGLRenderingContext.TEXTURE10')\n  @DocsEditable()\n  static const int TEXTURE10 = 0x84CA;\n\n  @DomName('WebGLRenderingContext.TEXTURE11')\n  @DocsEditable()\n  static const int TEXTURE11 = 0x84CB;\n\n  @DomName('WebGLRenderingContext.TEXTURE12')\n  @DocsEditable()\n  static const int TEXTURE12 = 0x84CC;\n\n  @DomName('WebGLRenderingContext.TEXTURE13')\n  @DocsEditable()\n  static const int TEXTURE13 = 0x84CD;\n\n  @DomName('WebGLRenderingContext.TEXTURE14')\n  @DocsEditable()\n  static const int TEXTURE14 = 0x84CE;\n\n  @DomName('WebGLRenderingContext.TEXTURE15')\n  @DocsEditable()\n  static const int TEXTURE15 = 0x84CF;\n\n  @DomName('WebGLRenderingContext.TEXTURE16')\n  @DocsEditable()\n  static const int TEXTURE16 = 0x84D0;\n\n  @DomName('WebGLRenderingContext.TEXTURE17')\n  @DocsEditable()\n  static const int TEXTURE17 = 0x84D1;\n\n  @DomName('WebGLRenderingContext.TEXTURE18')\n  @DocsEditable()\n  static const int TEXTURE18 = 0x84D2;\n\n  @DomName('WebGLRenderingContext.TEXTURE19')\n  @DocsEditable()\n  static const int TEXTURE19 = 0x84D3;\n\n  @DomName('WebGLRenderingContext.TEXTURE2')\n  @DocsEditable()\n  static const int TEXTURE2 = 0x84C2;\n\n  @DomName('WebGLRenderingContext.TEXTURE20')\n  @DocsEditable()\n  static const int TEXTURE20 = 0x84D4;\n\n  @DomName('WebGLRenderingContext.TEXTURE21')\n  @DocsEditable()\n  static const int TEXTURE21 = 0x84D5;\n\n  @DomName('WebGLRenderingContext.TEXTURE22')\n  @DocsEditable()\n  static const int TEXTURE22 = 0x84D6;\n\n  @DomName('WebGLRenderingContext.TEXTURE23')\n  @DocsEditable()\n  static const int TEXTURE23 = 0x84D7;\n\n  @DomName('WebGLRenderingContext.TEXTURE24')\n  @DocsEditable()\n  static const int TEXTURE24 = 0x84D8;\n\n  @DomName('WebGLRenderingContext.TEXTURE25')\n  @DocsEditable()\n  static const int TEXTURE25 = 0x84D9;\n\n  @DomName('WebGLRenderingContext.TEXTURE26')\n  @DocsEditable()\n  static const int TEXTURE26 = 0x84DA;\n\n  @DomName('WebGLRenderingContext.TEXTURE27')\n  @DocsEditable()\n  static const int TEXTURE27 = 0x84DB;\n\n  @DomName('WebGLRenderingContext.TEXTURE28')\n  @DocsEditable()\n  static const int TEXTURE28 = 0x84DC;\n\n  @DomName('WebGLRenderingContext.TEXTURE29')\n  @DocsEditable()\n  static const int TEXTURE29 = 0x84DD;\n\n  @DomName('WebGLRenderingContext.TEXTURE3')\n  @DocsEditable()\n  static const int TEXTURE3 = 0x84C3;\n\n  @DomName('WebGLRenderingContext.TEXTURE30')\n  @DocsEditable()\n  static const int TEXTURE30 = 0x84DE;\n\n  @DomName('WebGLRenderingContext.TEXTURE31')\n  @DocsEditable()\n  static const int TEXTURE31 = 0x84DF;\n\n  @DomName('WebGLRenderingContext.TEXTURE4')\n  @DocsEditable()\n  static const int TEXTURE4 = 0x84C4;\n\n  @DomName('WebGLRenderingContext.TEXTURE5')\n  @DocsEditable()\n  static const int TEXTURE5 = 0x84C5;\n\n  @DomName('WebGLRenderingContext.TEXTURE6')\n  @DocsEditable()\n  static const int TEXTURE6 = 0x84C6;\n\n  @DomName('WebGLRenderingContext.TEXTURE7')\n  @DocsEditable()\n  static const int TEXTURE7 = 0x84C7;\n\n  @DomName('WebGLRenderingContext.TEXTURE8')\n  @DocsEditable()\n  static const int TEXTURE8 = 0x84C8;\n\n  @DomName('WebGLRenderingContext.TEXTURE9')\n  @DocsEditable()\n  static const int TEXTURE9 = 0x84C9;\n\n  @DomName('WebGLRenderingContext.TEXTURE_2D')\n  @DocsEditable()\n  static const int TEXTURE_2D = 0x0DE1;\n\n  @DomName('WebGLRenderingContext.TEXTURE_BINDING_2D')\n  @DocsEditable()\n  static const int TEXTURE_BINDING_2D = 0x8069;\n\n  @DomName('WebGLRenderingContext.TEXTURE_BINDING_CUBE_MAP')\n  @DocsEditable()\n  static const int TEXTURE_BINDING_CUBE_MAP = 0x8514;\n\n  @DomName('WebGLRenderingContext.TEXTURE_CUBE_MAP')\n  @DocsEditable()\n  static const int TEXTURE_CUBE_MAP = 0x8513;\n\n  @DomName('WebGLRenderingContext.TEXTURE_CUBE_MAP_NEGATIVE_X')\n  @DocsEditable()\n  static const int TEXTURE_CUBE_MAP_NEGATIVE_X = 0x8516;\n\n  @DomName('WebGLRenderingContext.TEXTURE_CUBE_MAP_NEGATIVE_Y')\n  @DocsEditable()\n  static const int TEXTURE_CUBE_MAP_NEGATIVE_Y = 0x8518;\n\n  @DomName('WebGLRenderingContext.TEXTURE_CUBE_MAP_NEGATIVE_Z')\n  @DocsEditable()\n  static const int TEXTURE_CUBE_MAP_NEGATIVE_Z = 0x851A;\n\n  @DomName('WebGLRenderingContext.TEXTURE_CUBE_MAP_POSITIVE_X')\n  @DocsEditable()\n  static const int TEXTURE_CUBE_MAP_POSITIVE_X = 0x8515;\n\n  @DomName('WebGLRenderingContext.TEXTURE_CUBE_MAP_POSITIVE_Y')\n  @DocsEditable()\n  static const int TEXTURE_CUBE_MAP_POSITIVE_Y = 0x8517;\n\n  @DomName('WebGLRenderingContext.TEXTURE_CUBE_MAP_POSITIVE_Z')\n  @DocsEditable()\n  static const int TEXTURE_CUBE_MAP_POSITIVE_Z = 0x8519;\n\n  @DomName('WebGLRenderingContext.TEXTURE_MAG_FILTER')\n  @DocsEditable()\n  static const int TEXTURE_MAG_FILTER = 0x2800;\n\n  @DomName('WebGLRenderingContext.TEXTURE_MIN_FILTER')\n  @DocsEditable()\n  static const int TEXTURE_MIN_FILTER = 0x2801;\n\n  @DomName('WebGLRenderingContext.TEXTURE_WRAP_S')\n  @DocsEditable()\n  static const int TEXTURE_WRAP_S = 0x2802;\n\n  @DomName('WebGLRenderingContext.TEXTURE_WRAP_T')\n  @DocsEditable()\n  static const int TEXTURE_WRAP_T = 0x2803;\n\n  @DomName('WebGLRenderingContext.TRIANGLES')\n  @DocsEditable()\n  static const int TRIANGLES = 0x0004;\n\n  @DomName('WebGLRenderingContext.TRIANGLE_FAN')\n  @DocsEditable()\n  static const int TRIANGLE_FAN = 0x0006;\n\n  @DomName('WebGLRenderingContext.TRIANGLE_STRIP')\n  @DocsEditable()\n  static const int TRIANGLE_STRIP = 0x0005;\n\n  @DomName('WebGLRenderingContext.UNPACK_ALIGNMENT')\n  @DocsEditable()\n  static const int UNPACK_ALIGNMENT = 0x0CF5;\n\n  @DomName('WebGLRenderingContext.UNPACK_COLORSPACE_CONVERSION_WEBGL')\n  @DocsEditable()\n  static const int UNPACK_COLORSPACE_CONVERSION_WEBGL = 0x9243;\n\n  @DomName('WebGLRenderingContext.UNPACK_FLIP_Y_WEBGL')\n  @DocsEditable()\n  static const int UNPACK_FLIP_Y_WEBGL = 0x9240;\n\n  @DomName('WebGLRenderingContext.UNPACK_PREMULTIPLY_ALPHA_WEBGL')\n  @DocsEditable()\n  static const int UNPACK_PREMULTIPLY_ALPHA_WEBGL = 0x9241;\n\n  @DomName('WebGLRenderingContext.UNSIGNED_BYTE')\n  @DocsEditable()\n  static const int UNSIGNED_BYTE = 0x1401;\n\n  @DomName('WebGLRenderingContext.UNSIGNED_INT')\n  @DocsEditable()\n  static const int UNSIGNED_INT = 0x1405;\n\n  @DomName('WebGLRenderingContext.UNSIGNED_SHORT')\n  @DocsEditable()\n  static const int UNSIGNED_SHORT = 0x1403;\n\n  @DomName('WebGLRenderingContext.UNSIGNED_SHORT_4_4_4_4')\n  @DocsEditable()\n  static const int UNSIGNED_SHORT_4_4_4_4 = 0x8033;\n\n  @DomName('WebGLRenderingContext.UNSIGNED_SHORT_5_5_5_1')\n  @DocsEditable()\n  static const int UNSIGNED_SHORT_5_5_5_1 = 0x8034;\n\n  @DomName('WebGLRenderingContext.UNSIGNED_SHORT_5_6_5')\n  @DocsEditable()\n  static const int UNSIGNED_SHORT_5_6_5 = 0x8363;\n\n  @DomName('WebGLRenderingContext.VALIDATE_STATUS')\n  @DocsEditable()\n  static const int VALIDATE_STATUS = 0x8B83;\n\n  @DomName('WebGLRenderingContext.VENDOR')\n  @DocsEditable()\n  static const int VENDOR = 0x1F00;\n\n  @DomName('WebGLRenderingContext.VERSION')\n  @DocsEditable()\n  static const int VERSION = 0x1F02;\n\n  @DomName('WebGLRenderingContext.VERTEX_ATTRIB_ARRAY_BUFFER_BINDING')\n  @DocsEditable()\n  static const int VERTEX_ATTRIB_ARRAY_BUFFER_BINDING = 0x889F;\n\n  @DomName('WebGLRenderingContext.VERTEX_ATTRIB_ARRAY_ENABLED')\n  @DocsEditable()\n  static const int VERTEX_ATTRIB_ARRAY_ENABLED = 0x8622;\n\n  @DomName('WebGLRenderingContext.VERTEX_ATTRIB_ARRAY_NORMALIZED')\n  @DocsEditable()\n  static const int VERTEX_ATTRIB_ARRAY_NORMALIZED = 0x886A;\n\n  @DomName('WebGLRenderingContext.VERTEX_ATTRIB_ARRAY_POINTER')\n  @DocsEditable()\n  static const int VERTEX_ATTRIB_ARRAY_POINTER = 0x8645;\n\n  @DomName('WebGLRenderingContext.VERTEX_ATTRIB_ARRAY_SIZE')\n  @DocsEditable()\n  static const int VERTEX_ATTRIB_ARRAY_SIZE = 0x8623;\n\n  @DomName('WebGLRenderingContext.VERTEX_ATTRIB_ARRAY_STRIDE')\n  @DocsEditable()\n  static const int VERTEX_ATTRIB_ARRAY_STRIDE = 0x8624;\n\n  @DomName('WebGLRenderingContext.VERTEX_ATTRIB_ARRAY_TYPE')\n  @DocsEditable()\n  static const int VERTEX_ATTRIB_ARRAY_TYPE = 0x8625;\n\n  @DomName('WebGLRenderingContext.VERTEX_SHADER')\n  @DocsEditable()\n  static const int VERTEX_SHADER = 0x8B31;\n\n  @DomName('WebGLRenderingContext.VIEWPORT')\n  @DocsEditable()\n  static const int VIEWPORT = 0x0BA2;\n\n  @DomName('WebGLRenderingContext.ZERO')\n  @DocsEditable()\n  static const int ZERO = 0;\n\n  @DomName('WebGLRenderingContext.drawingBufferHeight')\n  @DocsEditable()\n  final int drawingBufferHeight;\n\n  @DomName('WebGLRenderingContext.drawingBufferWidth')\n  @DocsEditable()\n  final int drawingBufferWidth;\n\n  @DomName('WebGLRenderingContext.activeTexture')\n  @DocsEditable()\n  void activeTexture(int texture) native;\n\n  @DomName('WebGLRenderingContext.attachShader')\n  @DocsEditable()\n  void attachShader(Program program, Shader shader) native;\n\n  @DomName('WebGLRenderingContext.bindAttribLocation')\n  @DocsEditable()\n  void bindAttribLocation(Program program, int index, String name) native;\n\n  @DomName('WebGLRenderingContext.bindBuffer')\n  @DocsEditable()\n  void bindBuffer(int target, Buffer buffer) native;\n\n  @DomName('WebGLRenderingContext.bindFramebuffer')\n  @DocsEditable()\n  void bindFramebuffer(int target, Framebuffer framebuffer) native;\n\n  @DomName('WebGLRenderingContext.bindRenderbuffer')\n  @DocsEditable()\n  void bindRenderbuffer(int target, Renderbuffer renderbuffer) native;\n\n  @DomName('WebGLRenderingContext.bindTexture')\n  @DocsEditable()\n  void bindTexture(int target, Texture texture) native;\n\n  @DomName('WebGLRenderingContext.blendColor')\n  @DocsEditable()\n  void blendColor(num red, num green, num blue, num alpha) native;\n\n  @DomName('WebGLRenderingContext.blendEquation')\n  @DocsEditable()\n  void blendEquation(int mode) native;\n\n  @DomName('WebGLRenderingContext.blendEquationSeparate')\n  @DocsEditable()\n  void blendEquationSeparate(int modeRGB, int modeAlpha) native;\n\n  @DomName('WebGLRenderingContext.blendFunc')\n  @DocsEditable()\n  void blendFunc(int sfactor, int dfactor) native;\n\n  @DomName('WebGLRenderingContext.blendFuncSeparate')\n  @DocsEditable()\n  void blendFuncSeparate(int srcRGB, int dstRGB, int srcAlpha, int dstAlpha) native;\n\n  @JSName('bufferData')\n  /**\n   * Buffers the specified data.\n   *\n   * The [bufferData] method is provided for WebGL API compatibility reasons, but\n   * it is highly recommended that you use [bufferDataTyped] or [bufferByteData]\n   * depending on your purposes.\n   */\n  @DomName('WebGLRenderingContext.bufferData')\n  @DocsEditable()\n  void bufferByteData(int target, ByteBuffer data, int usage) native;\n\n  /**\n   * Buffers the specified data.\n   *\n   * The [bufferData] method is provided for WebGL API compatibility reasons, but\n   * it is highly recommended that you use [bufferDataTyped] or [bufferByteData]\n   * depending on your purposes.\n   */\n  @DomName('WebGLRenderingContext.bufferData')\n  @DocsEditable()\n  void bufferData(int target, data_OR_size, int usage) native;\n\n  @JSName('bufferData')\n  /**\n   * Buffers the specified data.\n   *\n   * The [bufferData] method is provided for WebGL API compatibility reasons, but\n   * it is highly recommended that you use [bufferDataTyped] or [bufferByteData]\n   * depending on your purposes.\n   */\n  @DomName('WebGLRenderingContext.bufferData')\n  @DocsEditable()\n  void bufferDataTyped(int target, TypedData data, int usage) native;\n\n  @JSName('bufferSubData')\n  /**\n   * Buffers the specified subset of data.\n   *\n   * The [bufferSubData] method is provided for WebGL API compatibility reasons, but\n   * it is highly recommended that you use [bufferSubDataTyped] or [bufferSubByteData]\n   * depending on your purposes.\n   */\n  @DomName('WebGLRenderingContext.bufferSubData')\n  @DocsEditable()\n  void bufferSubByteData(int target, int offset, ByteBuffer data) native;\n\n  /**\n   * Buffers the specified subset of data.\n   *\n   * The [bufferSubData] method is provided for WebGL API compatibility reasons, but\n   * it is highly recommended that you use [bufferSubDataTyped] or [bufferSubByteData]\n   * depending on your purposes.\n   */\n  @DomName('WebGLRenderingContext.bufferSubData')\n  @DocsEditable()\n  void bufferSubData(int target, int offset, data) native;\n\n  @JSName('bufferSubData')\n  /**\n   * Buffers the specified subset of data.\n   *\n   * The [bufferSubData] method is provided for WebGL API compatibility reasons, but\n   * it is highly recommended that you use [bufferSubDataTyped] or [bufferSubByteData]\n   * depending on your purposes.\n   */\n  @DomName('WebGLRenderingContext.bufferSubData')\n  @DocsEditable()\n  void bufferSubDataTyped(int target, int offset, TypedData data) native;\n\n  @DomName('WebGLRenderingContext.checkFramebufferStatus')\n  @DocsEditable()\n  int checkFramebufferStatus(int target) native;\n\n  @DomName('WebGLRenderingContext.clear')\n  @DocsEditable()\n  void clear(int mask) native;\n\n  @DomName('WebGLRenderingContext.clearColor')\n  @DocsEditable()\n  void clearColor(num red, num green, num blue, num alpha) native;\n\n  @DomName('WebGLRenderingContext.clearDepth')\n  @DocsEditable()\n  void clearDepth(num depth) native;\n\n  @DomName('WebGLRenderingContext.clearStencil')\n  @DocsEditable()\n  void clearStencil(int s) native;\n\n  @DomName('WebGLRenderingContext.colorMask')\n  @DocsEditable()\n  void colorMask(bool red, bool green, bool blue, bool alpha) native;\n\n  @DomName('WebGLRenderingContext.compileShader')\n  @DocsEditable()\n  void compileShader(Shader shader) native;\n\n  @DomName('WebGLRenderingContext.compressedTexImage2D')\n  @DocsEditable()\n  void compressedTexImage2D(int target, int level, int internalformat, int width, int height, int border, TypedData data) native;\n\n  @DomName('WebGLRenderingContext.compressedTexSubImage2D')\n  @DocsEditable()\n  void compressedTexSubImage2D(int target, int level, int xoffset, int yoffset, int width, int height, int format, TypedData data) native;\n\n  @DomName('WebGLRenderingContext.copyTexImage2D')\n  @DocsEditable()\n  void copyTexImage2D(int target, int level, int internalformat, int x, int y, int width, int height, int border) native;\n\n  @DomName('WebGLRenderingContext.copyTexSubImage2D')\n  @DocsEditable()\n  void copyTexSubImage2D(int target, int level, int xoffset, int yoffset, int x, int y, int width, int height) native;\n\n  @DomName('WebGLRenderingContext.createBuffer')\n  @DocsEditable()\n  Buffer createBuffer() native;\n\n  @DomName('WebGLRenderingContext.createFramebuffer')\n  @DocsEditable()\n  Framebuffer createFramebuffer() native;\n\n  @DomName('WebGLRenderingContext.createProgram')\n  @DocsEditable()\n  Program createProgram() native;\n\n  @DomName('WebGLRenderingContext.createRenderbuffer')\n  @DocsEditable()\n  Renderbuffer createRenderbuffer() native;\n\n  @DomName('WebGLRenderingContext.createShader')\n  @DocsEditable()\n  Shader createShader(int type) native;\n\n  @DomName('WebGLRenderingContext.createTexture')\n  @DocsEditable()\n  Texture createTexture() native;\n\n  @DomName('WebGLRenderingContext.cullFace')\n  @DocsEditable()\n  void cullFace(int mode) native;\n\n  @DomName('WebGLRenderingContext.deleteBuffer')\n  @DocsEditable()\n  void deleteBuffer(Buffer buffer) native;\n\n  @DomName('WebGLRenderingContext.deleteFramebuffer')\n  @DocsEditable()\n  void deleteFramebuffer(Framebuffer framebuffer) native;\n\n  @DomName('WebGLRenderingContext.deleteProgram')\n  @DocsEditable()\n  void deleteProgram(Program program) native;\n\n  @DomName('WebGLRenderingContext.deleteRenderbuffer')\n  @DocsEditable()\n  void deleteRenderbuffer(Renderbuffer renderbuffer) native;\n\n  @DomName('WebGLRenderingContext.deleteShader')\n  @DocsEditable()\n  void deleteShader(Shader shader) native;\n\n  @DomName('WebGLRenderingContext.deleteTexture')\n  @DocsEditable()\n  void deleteTexture(Texture texture) native;\n\n  @DomName('WebGLRenderingContext.depthFunc')\n  @DocsEditable()\n  void depthFunc(int func) native;\n\n  @DomName('WebGLRenderingContext.depthMask')\n  @DocsEditable()\n  void depthMask(bool flag) native;\n\n  @DomName('WebGLRenderingContext.depthRange')\n  @DocsEditable()\n  void depthRange(num zNear, num zFar) native;\n\n  @DomName('WebGLRenderingContext.detachShader')\n  @DocsEditable()\n  void detachShader(Program program, Shader shader) native;\n\n  @DomName('WebGLRenderingContext.disable')\n  @DocsEditable()\n  void disable(int cap) native;\n\n  @DomName('WebGLRenderingContext.disableVertexAttribArray')\n  @DocsEditable()\n  void disableVertexAttribArray(int index) native;\n\n  @DomName('WebGLRenderingContext.drawArrays')\n  @DocsEditable()\n  void drawArrays(int mode, int first, int count) native;\n\n  @DomName('WebGLRenderingContext.drawElements')\n  @DocsEditable()\n  void drawElements(int mode, int count, int type, int offset) native;\n\n  @DomName('WebGLRenderingContext.enable')\n  @DocsEditable()\n  void enable(int cap) native;\n\n  @DomName('WebGLRenderingContext.enableVertexAttribArray')\n  @DocsEditable()\n  void enableVertexAttribArray(int index) native;\n\n  @DomName('WebGLRenderingContext.finish')\n  @DocsEditable()\n  void finish() native;\n\n  @DomName('WebGLRenderingContext.flush')\n  @DocsEditable()\n  void flush() native;\n\n  @DomName('WebGLRenderingContext.framebufferRenderbuffer')\n  @DocsEditable()\n  void framebufferRenderbuffer(int target, int attachment, int renderbuffertarget, Renderbuffer renderbuffer) native;\n\n  @DomName('WebGLRenderingContext.framebufferTexture2D')\n  @DocsEditable()\n  void framebufferTexture2D(int target, int attachment, int textarget, Texture texture, int level) native;\n\n  @DomName('WebGLRenderingContext.frontFace')\n  @DocsEditable()\n  void frontFace(int mode) native;\n\n  @DomName('WebGLRenderingContext.generateMipmap')\n  @DocsEditable()\n  void generateMipmap(int target) native;\n\n  @DomName('WebGLRenderingContext.getActiveAttrib')\n  @DocsEditable()\n  ActiveInfo getActiveAttrib(Program program, int index) native;\n\n  @DomName('WebGLRenderingContext.getActiveUniform')\n  @DocsEditable()\n  ActiveInfo getActiveUniform(Program program, int index) native;\n\n  @DomName('WebGLRenderingContext.getAttachedShaders')\n  @DocsEditable()\n  void getAttachedShaders(Program program) native;\n\n  @DomName('WebGLRenderingContext.getAttribLocation')\n  @DocsEditable()\n  int getAttribLocation(Program program, String name) native;\n\n  @DomName('WebGLRenderingContext.getBufferParameter')\n  @DocsEditable()\n  @Creates('int|Null')\n  @Returns('int|Null')\n  Object getBufferParameter(int target, int pname) native;\n\n  @DomName('WebGLRenderingContext.getContextAttributes')\n  @DocsEditable()\n  @Creates('ContextAttributes|=Object')\n  ContextAttributes getContextAttributes() {\n    return convertNativeToDart_ContextAttributes(_getContextAttributes_1());\n  }\n  @JSName('getContextAttributes')\n  @DomName('WebGLRenderingContext.getContextAttributes')\n  @DocsEditable()\n  @Creates('ContextAttributes|=Object')\n  _getContextAttributes_1() native;\n\n  @DomName('WebGLRenderingContext.getError')\n  @DocsEditable()\n  int getError() native;\n\n  @DomName('WebGLRenderingContext.getExtension')\n  @DocsEditable()\n  Object getExtension(String name) native;\n\n  @DomName('WebGLRenderingContext.getFramebufferAttachmentParameter')\n  @DocsEditable()\n  @Creates('int|Renderbuffer|Texture|Null')\n  @Returns('int|Renderbuffer|Texture|Null')\n  Object getFramebufferAttachmentParameter(int target, int attachment, int pname) native;\n\n  @DomName('WebGLRenderingContext.getParameter')\n  @DocsEditable()\n  @Creates('Null|num|String|bool|JSExtendableArray|NativeFloat32List|NativeInt32List|NativeUint32List|Framebuffer|Renderbuffer|Texture')\n  @Returns('Null|num|String|bool|JSExtendableArray|NativeFloat32List|NativeInt32List|NativeUint32List|Framebuffer|Renderbuffer|Texture')\n  Object getParameter(int pname) native;\n\n  @DomName('WebGLRenderingContext.getProgramInfoLog')\n  @DocsEditable()\n  String getProgramInfoLog(Program program) native;\n\n  @DomName('WebGLRenderingContext.getProgramParameter')\n  @DocsEditable()\n  @Creates('int|bool|Null')\n  @Returns('int|bool|Null')\n  Object getProgramParameter(Program program, int pname) native;\n\n  @DomName('WebGLRenderingContext.getRenderbufferParameter')\n  @DocsEditable()\n  @Creates('int|Null')\n  @Returns('int|Null')\n  Object getRenderbufferParameter(int target, int pname) native;\n\n  @DomName('WebGLRenderingContext.getShaderInfoLog')\n  @DocsEditable()\n  String getShaderInfoLog(Shader shader) native;\n\n  @DomName('WebGLRenderingContext.getShaderParameter')\n  @DocsEditable()\n  @Creates('int|bool|Null')\n  @Returns('int|bool|Null')\n  Object getShaderParameter(Shader shader, int pname) native;\n\n  @DomName('WebGLRenderingContext.getShaderPrecisionFormat')\n  @DocsEditable()\n  ShaderPrecisionFormat getShaderPrecisionFormat(int shadertype, int precisiontype) native;\n\n  @DomName('WebGLRenderingContext.getShaderSource')\n  @DocsEditable()\n  String getShaderSource(Shader shader) native;\n\n  @DomName('WebGLRenderingContext.getSupportedExtensions')\n  @DocsEditable()\n  List<String> getSupportedExtensions() native;\n\n  @DomName('WebGLRenderingContext.getTexParameter')\n  @DocsEditable()\n  @Creates('int|Null')\n  @Returns('int|Null')\n  Object getTexParameter(int target, int pname) native;\n\n  @DomName('WebGLRenderingContext.getUniform')\n  @DocsEditable()\n  @Creates('Null|num|String|bool|JSExtendableArray|NativeFloat32List|NativeInt32List|NativeUint32List')\n  @Returns('Null|num|String|bool|JSExtendableArray|NativeFloat32List|NativeInt32List|NativeUint32List')\n  Object getUniform(Program program, UniformLocation location) native;\n\n  @DomName('WebGLRenderingContext.getUniformLocation')\n  @DocsEditable()\n  UniformLocation getUniformLocation(Program program, String name) native;\n\n  @DomName('WebGLRenderingContext.getVertexAttrib')\n  @DocsEditable()\n  @Creates('Null|num|bool|NativeFloat32List|Buffer')\n  @Returns('Null|num|bool|NativeFloat32List|Buffer')\n  Object getVertexAttrib(int index, int pname) native;\n\n  @DomName('WebGLRenderingContext.getVertexAttribOffset')\n  @DocsEditable()\n  int getVertexAttribOffset(int index, int pname) native;\n\n  @DomName('WebGLRenderingContext.hint')\n  @DocsEditable()\n  void hint(int target, int mode) native;\n\n  @DomName('WebGLRenderingContext.isBuffer')\n  @DocsEditable()\n  bool isBuffer(Buffer buffer) native;\n\n  @DomName('WebGLRenderingContext.isContextLost')\n  @DocsEditable()\n  bool isContextLost() native;\n\n  @DomName('WebGLRenderingContext.isEnabled')\n  @DocsEditable()\n  bool isEnabled(int cap) native;\n\n  @DomName('WebGLRenderingContext.isFramebuffer')\n  @DocsEditable()\n  bool isFramebuffer(Framebuffer framebuffer) native;\n\n  @DomName('WebGLRenderingContext.isProgram')\n  @DocsEditable()\n  bool isProgram(Program program) native;\n\n  @DomName('WebGLRenderingContext.isRenderbuffer')\n  @DocsEditable()\n  bool isRenderbuffer(Renderbuffer renderbuffer) native;\n\n  @DomName('WebGLRenderingContext.isShader')\n  @DocsEditable()\n  bool isShader(Shader shader) native;\n\n  @DomName('WebGLRenderingContext.isTexture')\n  @DocsEditable()\n  bool isTexture(Texture texture) native;\n\n  @DomName('WebGLRenderingContext.lineWidth')\n  @DocsEditable()\n  void lineWidth(num width) native;\n\n  @DomName('WebGLRenderingContext.linkProgram')\n  @DocsEditable()\n  void linkProgram(Program program) native;\n\n  @DomName('WebGLRenderingContext.pixelStorei')\n  @DocsEditable()\n  void pixelStorei(int pname, int param) native;\n\n  @DomName('WebGLRenderingContext.polygonOffset')\n  @DocsEditable()\n  void polygonOffset(num factor, num units) native;\n\n  @DomName('WebGLRenderingContext.readPixels')\n  @DocsEditable()\n  void readPixels(int x, int y, int width, int height, int format, int type, TypedData pixels) native;\n\n  @DomName('WebGLRenderingContext.renderbufferStorage')\n  @DocsEditable()\n  void renderbufferStorage(int target, int internalformat, int width, int height) native;\n\n  @DomName('WebGLRenderingContext.sampleCoverage')\n  @DocsEditable()\n  void sampleCoverage(num value, bool invert) native;\n\n  @DomName('WebGLRenderingContext.scissor')\n  @DocsEditable()\n  void scissor(int x, int y, int width, int height) native;\n\n  @DomName('WebGLRenderingContext.shaderSource')\n  @DocsEditable()\n  void shaderSource(Shader shader, String string) native;\n\n  @DomName('WebGLRenderingContext.stencilFunc')\n  @DocsEditable()\n  void stencilFunc(int func, int ref, int mask) native;\n\n  @DomName('WebGLRenderingContext.stencilFuncSeparate')\n  @DocsEditable()\n  void stencilFuncSeparate(int face, int func, int ref, int mask) native;\n\n  @DomName('WebGLRenderingContext.stencilMask')\n  @DocsEditable()\n  void stencilMask(int mask) native;\n\n  @DomName('WebGLRenderingContext.stencilMaskSeparate')\n  @DocsEditable()\n  void stencilMaskSeparate(int face, int mask) native;\n\n  @DomName('WebGLRenderingContext.stencilOp')\n  @DocsEditable()\n  void stencilOp(int fail, int zfail, int zpass) native;\n\n  @DomName('WebGLRenderingContext.stencilOpSeparate')\n  @DocsEditable()\n  void stencilOpSeparate(int face, int fail, int zfail, int zpass) native;\n\n  /**\n   * Updates the currently bound texture to [data].\n   *\n   * The [texImage2D] method is provided for WebGL API compatibility reasons, but it\n   * is highly recommended that you use [texImage2DUntyped] or [texImage2DTyped]\n   * (or for more specificity, the more specialized [texImage2DImageData],\n   * [texImage2DCanvas], [texImage2DVideo]).\n   */\n  @DomName('WebGLRenderingContext.texImage2D')\n  @DocsEditable()\n  void texImage2D(int target, int level, int internalformat, int format_OR_width, int height_OR_type, border_OR_canvas_OR_image_OR_pixels_OR_video, [int format, int type, TypedData pixels]) {\n    if (pixels != null && type != null && format != null && (border_OR_canvas_OR_image_OR_pixels_OR_video is int || border_OR_canvas_OR_image_OR_pixels_OR_video == null)) {\n      _texImage2D_1(target, level, internalformat, format_OR_width, height_OR_type, border_OR_canvas_OR_image_OR_pixels_OR_video, format, type, pixels);\n      return;\n    }\n    if ((border_OR_canvas_OR_image_OR_pixels_OR_video is ImageData || border_OR_canvas_OR_image_OR_pixels_OR_video == null) && format == null && type == null && pixels == null) {\n      var pixels_1 = convertDartToNative_ImageData(border_OR_canvas_OR_image_OR_pixels_OR_video);\n      _texImage2D_2(target, level, internalformat, format_OR_width, height_OR_type, pixels_1);\n      return;\n    }\n    if ((border_OR_canvas_OR_image_OR_pixels_OR_video is ImageElement || border_OR_canvas_OR_image_OR_pixels_OR_video == null) && format == null && type == null && pixels == null) {\n      _texImage2D_3(target, level, internalformat, format_OR_width, height_OR_type, border_OR_canvas_OR_image_OR_pixels_OR_video);\n      return;\n    }\n    if ((border_OR_canvas_OR_image_OR_pixels_OR_video is CanvasElement || border_OR_canvas_OR_image_OR_pixels_OR_video == null) && format == null && type == null && pixels == null) {\n      _texImage2D_4(target, level, internalformat, format_OR_width, height_OR_type, border_OR_canvas_OR_image_OR_pixels_OR_video);\n      return;\n    }\n    if ((border_OR_canvas_OR_image_OR_pixels_OR_video is VideoElement || border_OR_canvas_OR_image_OR_pixels_OR_video == null) && format == null && type == null && pixels == null) {\n      _texImage2D_5(target, level, internalformat, format_OR_width, height_OR_type, border_OR_canvas_OR_image_OR_pixels_OR_video);\n      return;\n    }\n    throw new ArgumentError(\"Incorrect number or type of arguments\");\n  }\n  @JSName('texImage2D')\n  /**\n   * Updates the currently bound texture to [data].\n   *\n   * The [texImage2D] method is provided for WebGL API compatibility reasons, but it\n   * is highly recommended that you use [texImage2DUntyped] or [texImage2DTyped]\n   * (or for more specificity, the more specialized [texImage2DImageData],\n   * [texImage2DCanvas], [texImage2DVideo]).\n   */\n  @DomName('WebGLRenderingContext.texImage2D')\n  @DocsEditable()\n  void _texImage2D_1(target, level, internalformat, width, height, int border, format, type, TypedData pixels) native;\n  @JSName('texImage2D')\n  /**\n   * Updates the currently bound texture to [data].\n   *\n   * The [texImage2D] method is provided for WebGL API compatibility reasons, but it\n   * is highly recommended that you use [texImage2DUntyped] or [texImage2DTyped]\n   * (or for more specificity, the more specialized [texImage2DImageData],\n   * [texImage2DCanvas], [texImage2DVideo]).\n   */\n  @DomName('WebGLRenderingContext.texImage2D')\n  @DocsEditable()\n  void _texImage2D_2(target, level, internalformat, format, type, pixels) native;\n  @JSName('texImage2D')\n  /**\n   * Updates the currently bound texture to [data].\n   *\n   * The [texImage2D] method is provided for WebGL API compatibility reasons, but it\n   * is highly recommended that you use [texImage2DUntyped] or [texImage2DTyped]\n   * (or for more specificity, the more specialized [texImage2DImageData],\n   * [texImage2DCanvas], [texImage2DVideo]).\n   */\n  @DomName('WebGLRenderingContext.texImage2D')\n  @DocsEditable()\n  void _texImage2D_3(target, level, internalformat, format, type, ImageElement image) native;\n  @JSName('texImage2D')\n  /**\n   * Updates the currently bound texture to [data].\n   *\n   * The [texImage2D] method is provided for WebGL API compatibility reasons, but it\n   * is highly recommended that you use [texImage2DUntyped] or [texImage2DTyped]\n   * (or for more specificity, the more specialized [texImage2DImageData],\n   * [texImage2DCanvas], [texImage2DVideo]).\n   */\n  @DomName('WebGLRenderingContext.texImage2D')\n  @DocsEditable()\n  void _texImage2D_4(target, level, internalformat, format, type, CanvasElement canvas) native;\n  @JSName('texImage2D')\n  /**\n   * Updates the currently bound texture to [data].\n   *\n   * The [texImage2D] method is provided for WebGL API compatibility reasons, but it\n   * is highly recommended that you use [texImage2DUntyped] or [texImage2DTyped]\n   * (or for more specificity, the more specialized [texImage2DImageData],\n   * [texImage2DCanvas], [texImage2DVideo]).\n   */\n  @DomName('WebGLRenderingContext.texImage2D')\n  @DocsEditable()\n  void _texImage2D_5(target, level, internalformat, format, type, VideoElement video) native;\n\n  @JSName('texImage2D')\n  /**\n   * Updates the currently bound texture to [data].\n   *\n   * The [texImage2D] method is provided for WebGL API compatibility reasons, but it\n   * is highly recommended that you use [texImage2DUntyped] or [texImage2DTyped]\n   * (or for more specificity, the more specialized [texImage2DImageData],\n   * [texImage2DCanvas], [texImage2DVideo]).\n   */\n  @DomName('WebGLRenderingContext.texImage2D')\n  @DocsEditable()\n  void texImage2DCanvas(int target, int level, int internalformat, int format, int type, CanvasElement canvas) native;\n\n  @JSName('texImage2D')\n  /**\n   * Updates the currently bound texture to [data].\n   *\n   * The [texImage2D] method is provided for WebGL API compatibility reasons, but it\n   * is highly recommended that you use [texImage2DUntyped] or [texImage2DTyped]\n   * (or for more specificity, the more specialized [texImage2DImageData],\n   * [texImage2DCanvas], [texImage2DVideo]).\n   */\n  @DomName('WebGLRenderingContext.texImage2D')\n  @DocsEditable()\n  void texImage2DImage(int target, int level, int internalformat, int format, int type, ImageElement image) native;\n\n  /**\n   * Updates the currently bound texture to [data].\n   *\n   * The [texImage2D] method is provided for WebGL API compatibility reasons, but it\n   * is highly recommended that you use [texImage2DUntyped] or [texImage2DTyped]\n   * (or for more specificity, the more specialized [texImage2DImageData],\n   * [texImage2DCanvas], [texImage2DVideo]).\n   */\n  @DomName('WebGLRenderingContext.texImage2D')\n  @DocsEditable()\n  void texImage2DImageData(int target, int level, int internalformat, int format, int type, ImageData pixels) {\n    var pixels_1 = convertDartToNative_ImageData(pixels);\n    _texImage2DImageData_1(target, level, internalformat, format, type, pixels_1);\n    return;\n  }\n  @JSName('texImage2D')\n  /**\n   * Updates the currently bound texture to [data].\n   *\n   * The [texImage2D] method is provided for WebGL API compatibility reasons, but it\n   * is highly recommended that you use [texImage2DUntyped] or [texImage2DTyped]\n   * (or for more specificity, the more specialized [texImage2DImageData],\n   * [texImage2DCanvas], [texImage2DVideo]).\n   */\n  @DomName('WebGLRenderingContext.texImage2D')\n  @DocsEditable()\n  void _texImage2DImageData_1(target, level, internalformat, format, type, pixels) native;\n\n  @JSName('texImage2D')\n  /**\n   * Updates the currently bound texture to [data].\n   *\n   * The [texImage2D] method is provided for WebGL API compatibility reasons, but it\n   * is highly recommended that you use [texImage2DUntyped] or [texImage2DTyped]\n   * (or for more specificity, the more specialized [texImage2DImageData],\n   * [texImage2DCanvas], [texImage2DVideo]).\n   */\n  @DomName('WebGLRenderingContext.texImage2D')\n  @DocsEditable()\n  void texImage2DVideo(int target, int level, int internalformat, int format, int type, VideoElement video) native;\n\n  @DomName('WebGLRenderingContext.texParameterf')\n  @DocsEditable()\n  void texParameterf(int target, int pname, num param) native;\n\n  @DomName('WebGLRenderingContext.texParameteri')\n  @DocsEditable()\n  void texParameteri(int target, int pname, int param) native;\n\n  /**\n   * Updates a sub-rectangle of the currently bound texture to [data].\n   *\n   * The [texSubImage2D] method is provided for WebGL API compatibility reasons, but it\n   * is highly recommended that you use [texSubImage2DUntyped] or [texSubImage2DTyped]\n   * (or for more specificity, the more specialized [texSubImage2DImageData],\n   * [texSubImage2DCanvas], [texSubImage2DVideo]).\n   */\n  @DomName('WebGLRenderingContext.texSubImage2D')\n  @DocsEditable()\n  void texSubImage2D(int target, int level, int xoffset, int yoffset, int format_OR_width, int height_OR_type, canvas_OR_format_OR_image_OR_pixels_OR_video, [int type, TypedData pixels]) {\n    if (pixels != null && type != null && (canvas_OR_format_OR_image_OR_pixels_OR_video is int || canvas_OR_format_OR_image_OR_pixels_OR_video == null)) {\n      _texSubImage2D_1(target, level, xoffset, yoffset, format_OR_width, height_OR_type, canvas_OR_format_OR_image_OR_pixels_OR_video, type, pixels);\n      return;\n    }\n    if ((canvas_OR_format_OR_image_OR_pixels_OR_video is ImageData || canvas_OR_format_OR_image_OR_pixels_OR_video == null) && type == null && pixels == null) {\n      var pixels_1 = convertDartToNative_ImageData(canvas_OR_format_OR_image_OR_pixels_OR_video);\n      _texSubImage2D_2(target, level, xoffset, yoffset, format_OR_width, height_OR_type, pixels_1);\n      return;\n    }\n    if ((canvas_OR_format_OR_image_OR_pixels_OR_video is ImageElement || canvas_OR_format_OR_image_OR_pixels_OR_video == null) && type == null && pixels == null) {\n      _texSubImage2D_3(target, level, xoffset, yoffset, format_OR_width, height_OR_type, canvas_OR_format_OR_image_OR_pixels_OR_video);\n      return;\n    }\n    if ((canvas_OR_format_OR_image_OR_pixels_OR_video is CanvasElement || canvas_OR_format_OR_image_OR_pixels_OR_video == null) && type == null && pixels == null) {\n      _texSubImage2D_4(target, level, xoffset, yoffset, format_OR_width, height_OR_type, canvas_OR_format_OR_image_OR_pixels_OR_video);\n      return;\n    }\n    if ((canvas_OR_format_OR_image_OR_pixels_OR_video is VideoElement || canvas_OR_format_OR_image_OR_pixels_OR_video == null) && type == null && pixels == null) {\n      _texSubImage2D_5(target, level, xoffset, yoffset, format_OR_width, height_OR_type, canvas_OR_format_OR_image_OR_pixels_OR_video);\n      return;\n    }\n    throw new ArgumentError(\"Incorrect number or type of arguments\");\n  }\n  @JSName('texSubImage2D')\n  /**\n   * Updates a sub-rectangle of the currently bound texture to [data].\n   *\n   * The [texSubImage2D] method is provided for WebGL API compatibility reasons, but it\n   * is highly recommended that you use [texSubImage2DUntyped] or [texSubImage2DTyped]\n   * (or for more specificity, the more specialized [texSubImage2DImageData],\n   * [texSubImage2DCanvas], [texSubImage2DVideo]).\n   */\n  @DomName('WebGLRenderingContext.texSubImage2D')\n  @DocsEditable()\n  void _texSubImage2D_1(target, level, xoffset, yoffset, width, height, int format, type, TypedData pixels) native;\n  @JSName('texSubImage2D')\n  /**\n   * Updates a sub-rectangle of the currently bound texture to [data].\n   *\n   * The [texSubImage2D] method is provided for WebGL API compatibility reasons, but it\n   * is highly recommended that you use [texSubImage2DUntyped] or [texSubImage2DTyped]\n   * (or for more specificity, the more specialized [texSubImage2DImageData],\n   * [texSubImage2DCanvas], [texSubImage2DVideo]).\n   */\n  @DomName('WebGLRenderingContext.texSubImage2D')\n  @DocsEditable()\n  void _texSubImage2D_2(target, level, xoffset, yoffset, format, type, pixels) native;\n  @JSName('texSubImage2D')\n  /**\n   * Updates a sub-rectangle of the currently bound texture to [data].\n   *\n   * The [texSubImage2D] method is provided for WebGL API compatibility reasons, but it\n   * is highly recommended that you use [texSubImage2DUntyped] or [texSubImage2DTyped]\n   * (or for more specificity, the more specialized [texSubImage2DImageData],\n   * [texSubImage2DCanvas], [texSubImage2DVideo]).\n   */\n  @DomName('WebGLRenderingContext.texSubImage2D')\n  @DocsEditable()\n  void _texSubImage2D_3(target, level, xoffset, yoffset, format, type, ImageElement image) native;\n  @JSName('texSubImage2D')\n  /**\n   * Updates a sub-rectangle of the currently bound texture to [data].\n   *\n   * The [texSubImage2D] method is provided for WebGL API compatibility reasons, but it\n   * is highly recommended that you use [texSubImage2DUntyped] or [texSubImage2DTyped]\n   * (or for more specificity, the more specialized [texSubImage2DImageData],\n   * [texSubImage2DCanvas], [texSubImage2DVideo]).\n   */\n  @DomName('WebGLRenderingContext.texSubImage2D')\n  @DocsEditable()\n  void _texSubImage2D_4(target, level, xoffset, yoffset, format, type, CanvasElement canvas) native;\n  @JSName('texSubImage2D')\n  /**\n   * Updates a sub-rectangle of the currently bound texture to [data].\n   *\n   * The [texSubImage2D] method is provided for WebGL API compatibility reasons, but it\n   * is highly recommended that you use [texSubImage2DUntyped] or [texSubImage2DTyped]\n   * (or for more specificity, the more specialized [texSubImage2DImageData],\n   * [texSubImage2DCanvas], [texSubImage2DVideo]).\n   */\n  @DomName('WebGLRenderingContext.texSubImage2D')\n  @DocsEditable()\n  void _texSubImage2D_5(target, level, xoffset, yoffset, format, type, VideoElement video) native;\n\n  @JSName('texSubImage2D')\n  /**\n   * Updates a sub-rectangle of the currently bound texture to [data].\n   *\n   * The [texSubImage2D] method is provided for WebGL API compatibility reasons, but it\n   * is highly recommended that you use [texSubImage2DUntyped] or [texSubImage2DTyped]\n   * (or for more specificity, the more specialized [texSubImage2DImageData],\n   * [texSubImage2DCanvas], [texSubImage2DVideo]).\n   */\n  @DomName('WebGLRenderingContext.texSubImage2D')\n  @DocsEditable()\n  void texSubImage2DCanvas(int target, int level, int xoffset, int yoffset, int format, int type, CanvasElement canvas) native;\n\n  @JSName('texSubImage2D')\n  /**\n   * Updates a sub-rectangle of the currently bound texture to [data].\n   *\n   * The [texSubImage2D] method is provided for WebGL API compatibility reasons, but it\n   * is highly recommended that you use [texSubImage2DUntyped] or [texSubImage2DTyped]\n   * (or for more specificity, the more specialized [texSubImage2DImageData],\n   * [texSubImage2DCanvas], [texSubImage2DVideo]).\n   */\n  @DomName('WebGLRenderingContext.texSubImage2D')\n  @DocsEditable()\n  void texSubImage2DImage(int target, int level, int xoffset, int yoffset, int format, int type, ImageElement image) native;\n\n  /**\n   * Updates a sub-rectangle of the currently bound texture to [data].\n   *\n   * The [texSubImage2D] method is provided for WebGL API compatibility reasons, but it\n   * is highly recommended that you use [texSubImage2DUntyped] or [texSubImage2DTyped]\n   * (or for more specificity, the more specialized [texSubImage2DImageData],\n   * [texSubImage2DCanvas], [texSubImage2DVideo]).\n   */\n  @DomName('WebGLRenderingContext.texSubImage2D')\n  @DocsEditable()\n  void texSubImage2DImageData(int target, int level, int xoffset, int yoffset, int format, int type, ImageData pixels) {\n    var pixels_1 = convertDartToNative_ImageData(pixels);\n    _texSubImage2DImageData_1(target, level, xoffset, yoffset, format, type, pixels_1);\n    return;\n  }\n  @JSName('texSubImage2D')\n  /**\n   * Updates a sub-rectangle of the currently bound texture to [data].\n   *\n   * The [texSubImage2D] method is provided for WebGL API compatibility reasons, but it\n   * is highly recommended that you use [texSubImage2DUntyped] or [texSubImage2DTyped]\n   * (or for more specificity, the more specialized [texSubImage2DImageData],\n   * [texSubImage2DCanvas], [texSubImage2DVideo]).\n   */\n  @DomName('WebGLRenderingContext.texSubImage2D')\n  @DocsEditable()\n  void _texSubImage2DImageData_1(target, level, xoffset, yoffset, format, type, pixels) native;\n\n  @JSName('texSubImage2D')\n  /**\n   * Updates a sub-rectangle of the currently bound texture to [data].\n   *\n   * The [texSubImage2D] method is provided for WebGL API compatibility reasons, but it\n   * is highly recommended that you use [texSubImage2DUntyped] or [texSubImage2DTyped]\n   * (or for more specificity, the more specialized [texSubImage2DImageData],\n   * [texSubImage2DCanvas], [texSubImage2DVideo]).\n   */\n  @DomName('WebGLRenderingContext.texSubImage2D')\n  @DocsEditable()\n  void texSubImage2DVideo(int target, int level, int xoffset, int yoffset, int format, int type, VideoElement video) native;\n\n  @DomName('WebGLRenderingContext.uniform1f')\n  @DocsEditable()\n  void uniform1f(UniformLocation location, num x) native;\n\n  @DomName('WebGLRenderingContext.uniform1fv')\n  @DocsEditable()\n  void uniform1fv(UniformLocation location, Float32List v) native;\n\n  @DomName('WebGLRenderingContext.uniform1i')\n  @DocsEditable()\n  void uniform1i(UniformLocation location, int x) native;\n\n  @DomName('WebGLRenderingContext.uniform1iv')\n  @DocsEditable()\n  void uniform1iv(UniformLocation location, Int32List v) native;\n\n  @DomName('WebGLRenderingContext.uniform2f')\n  @DocsEditable()\n  void uniform2f(UniformLocation location, num x, num y) native;\n\n  @DomName('WebGLRenderingContext.uniform2fv')\n  @DocsEditable()\n  void uniform2fv(UniformLocation location, Float32List v) native;\n\n  @DomName('WebGLRenderingContext.uniform2i')\n  @DocsEditable()\n  void uniform2i(UniformLocation location, int x, int y) native;\n\n  @DomName('WebGLRenderingContext.uniform2iv')\n  @DocsEditable()\n  void uniform2iv(UniformLocation location, Int32List v) native;\n\n  @DomName('WebGLRenderingContext.uniform3f')\n  @DocsEditable()\n  void uniform3f(UniformLocation location, num x, num y, num z) native;\n\n  @DomName('WebGLRenderingContext.uniform3fv')\n  @DocsEditable()\n  void uniform3fv(UniformLocation location, Float32List v) native;\n\n  @DomName('WebGLRenderingContext.uniform3i')\n  @DocsEditable()\n  void uniform3i(UniformLocation location, int x, int y, int z) native;\n\n  @DomName('WebGLRenderingContext.uniform3iv')\n  @DocsEditable()\n  void uniform3iv(UniformLocation location, Int32List v) native;\n\n  @DomName('WebGLRenderingContext.uniform4f')\n  @DocsEditable()\n  void uniform4f(UniformLocation location, num x, num y, num z, num w) native;\n\n  @DomName('WebGLRenderingContext.uniform4fv')\n  @DocsEditable()\n  void uniform4fv(UniformLocation location, Float32List v) native;\n\n  @DomName('WebGLRenderingContext.uniform4i')\n  @DocsEditable()\n  void uniform4i(UniformLocation location, int x, int y, int z, int w) native;\n\n  @DomName('WebGLRenderingContext.uniform4iv')\n  @DocsEditable()\n  void uniform4iv(UniformLocation location, Int32List v) native;\n\n  @DomName('WebGLRenderingContext.uniformMatrix2fv')\n  @DocsEditable()\n  void uniformMatrix2fv(UniformLocation location, bool transpose, Float32List array) native;\n\n  @DomName('WebGLRenderingContext.uniformMatrix3fv')\n  @DocsEditable()\n  void uniformMatrix3fv(UniformLocation location, bool transpose, Float32List array) native;\n\n  @DomName('WebGLRenderingContext.uniformMatrix4fv')\n  @DocsEditable()\n  void uniformMatrix4fv(UniformLocation location, bool transpose, Float32List array) native;\n\n  @DomName('WebGLRenderingContext.useProgram')\n  @DocsEditable()\n  void useProgram(Program program) native;\n\n  @DomName('WebGLRenderingContext.validateProgram')\n  @DocsEditable()\n  void validateProgram(Program program) native;\n\n  @DomName('WebGLRenderingContext.vertexAttrib1f')\n  @DocsEditable()\n  void vertexAttrib1f(int indx, num x) native;\n\n  @DomName('WebGLRenderingContext.vertexAttrib1fv')\n  @DocsEditable()\n  void vertexAttrib1fv(int indx, Float32List values) native;\n\n  @DomName('WebGLRenderingContext.vertexAttrib2f')\n  @DocsEditable()\n  void vertexAttrib2f(int indx, num x, num y) native;\n\n  @DomName('WebGLRenderingContext.vertexAttrib2fv')\n  @DocsEditable()\n  void vertexAttrib2fv(int indx, Float32List values) native;\n\n  @DomName('WebGLRenderingContext.vertexAttrib3f')\n  @DocsEditable()\n  void vertexAttrib3f(int indx, num x, num y, num z) native;\n\n  @DomName('WebGLRenderingContext.vertexAttrib3fv')\n  @DocsEditable()\n  void vertexAttrib3fv(int indx, Float32List values) native;\n\n  @DomName('WebGLRenderingContext.vertexAttrib4f')\n  @DocsEditable()\n  void vertexAttrib4f(int indx, num x, num y, num z, num w) native;\n\n  @DomName('WebGLRenderingContext.vertexAttrib4fv')\n  @DocsEditable()\n  void vertexAttrib4fv(int indx, Float32List values) native;\n\n  @DomName('WebGLRenderingContext.vertexAttribPointer')\n  @DocsEditable()\n  void vertexAttribPointer(int indx, int size, int type, bool normalized, int stride, int offset) native;\n\n  @DomName('WebGLRenderingContext.viewport')\n  @DocsEditable()\n  void viewport(int x, int y, int width, int height) native;\n\n\n  /**\n   * Sets the currently bound texture to [data].\n   *\n   * [data] can be either an [ImageElement], a\n   * [CanvasElement], a [VideoElement], or an [ImageData] object.\n   *\n   * To use [texImage2d] with a TypedData object, use [texImage2dTyped].\n   *\n   */\n  @JSName('texImage2D')\n  void texImage2DUntyped(int targetTexture, int levelOfDetail, \n      int internalFormat, int format, int type, data) native;\n\n  /**\n   * Sets the currently bound texture to [data].\n   */\n  @JSName('texImage2D')\n  void texImage2DTyped(int targetTexture, int levelOfDetail,\n      int internalFormat, int width, int height, int border, int format,\n      int type, TypedData data) native;\n\n  /**\n   * Updates a sub-rectangle of the currently bound texture to [data].\n   *\n   * [data] can be either an [ImageElement], a\n   * [CanvasElement], a [VideoElement], or an [ImageData] object.\n   *\n   * To use [texSubImage2d] with a TypedData object, use [texSubImage2dTyped].\n   *\n   */\n  @JSName('texSubImage2D')\n  void texSubImage2DUntyped(int targetTexture, int levelOfDetail,\n      int xOffset, int yOffset, int format, int type, data) native;\n\n  /**\n   * Updates a sub-rectangle of the currently bound texture to [data].\n   */\n  @JSName('texSubImage2D')\n  void texSubImage2DTyped(int targetTexture, int levelOfDetail,\n      int xOffset, int yOffset, int width, int height, int border, int format,\n      int type, TypedData data) native;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('WebGLShader')\n@Native(\"WebGLShader\")\nclass Shader extends Interceptor {\n  // To suppress missing implicit constructor warnings.\n  factory Shader._() { throw new UnsupportedError(\"Not supported\"); }\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('WebGLShaderPrecisionFormat')\n@Native(\"WebGLShaderPrecisionFormat\")\nclass ShaderPrecisionFormat extends Interceptor {\n  // To suppress missing implicit constructor warnings.\n  factory ShaderPrecisionFormat._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('WebGLShaderPrecisionFormat.precision')\n  @DocsEditable()\n  final int precision;\n\n  @DomName('WebGLShaderPrecisionFormat.rangeMax')\n  @DocsEditable()\n  final int rangeMax;\n\n  @DomName('WebGLShaderPrecisionFormat.rangeMin')\n  @DocsEditable()\n  final int rangeMin;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('WebGLTexture')\n@Native(\"WebGLTexture\")\nclass Texture extends Interceptor {\n  // To suppress missing implicit constructor warnings.\n  factory Texture._() { throw new UnsupportedError(\"Not supported\"); }\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('WebGLUniformLocation')\n@Native(\"WebGLUniformLocation\")\nclass UniformLocation extends Interceptor {\n  // To suppress missing implicit constructor warnings.\n  factory UniformLocation._() { throw new UnsupportedError(\"Not supported\"); }\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('WebGLVertexArrayObjectOES')\n// http://www.khronos.org/registry/webgl/extensions/OES_vertex_array_object/\n@Experimental() // experimental\n@Native(\"WebGLVertexArrayObjectOES\")\nclass VertexArrayObject extends Interceptor {\n  // To suppress missing implicit constructor warnings.\n  factory VertexArrayObject._() { throw new UnsupportedError(\"Not supported\"); }\n}\n\u0000","sdk:/sdk/lib/_internal/lib/native_typed_data.dart":"// Copyright (c) 2013, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n/**\n * Specialized integers and floating point numbers,\n * with SIMD support and efficient lists.\n */\nlibrary dart.typed_data.implementation;\n\nimport 'dart:collection';\nimport 'dart:_internal';\nimport 'dart:_interceptors' show JSIndexable, JSUInt32, JSUInt31;\nimport 'dart:_js_helper'\nshow Creates, JavaScriptIndexingBehavior, JSName, Native, Null, Returns;\nimport 'dart:_foreign_helper' show JS;\nimport 'dart:math' as Math;\n\nimport 'dart:typed_data';\n\n@Native(\"ArrayBuffer\")\nclass NativeByteBuffer implements ByteBuffer {\n  @JSName('byteLength')\n  final int lengthInBytes;\n\n  Type get runtimeType => ByteBuffer;\n\n  Uint8List asUint8List([int offsetInBytes = 0, int length]) {\n    return new NativeUint8List.view(this, offsetInBytes, length);\n  }\n\n  Int8List asInt8List([int offsetInBytes = 0, int length]) {\n    return new NativeInt8List.view(this, offsetInBytes, length);\n  }\n\n  Uint8ClampedList asUint8ClampedList([int offsetInBytes = 0, int length]) {\n    return new NativeUint8ClampedList.view(this, offsetInBytes, length);\n  }\n\n  Uint16List asUint16List([int offsetInBytes = 0, int length]) {\n    return new NativeUint16List.view(this, offsetInBytes, length);\n  }\n  Int16List asInt16List([int offsetInBytes = 0, int length]) {\n    return new NativeInt16List.view(this, offsetInBytes, length);\n  }\n\n  Uint32List asUint32List([int offsetInBytes = 0, int length]) {\n    return new NativeUint32List.view(this, offsetInBytes, length);\n  }\n\n  Int32List asInt32List([int offsetInBytes = 0, int length]) {\n    return new NativeInt32List.view(this, offsetInBytes, length);\n  }\n\n  Uint64List asUint64List([int offsetInBytes = 0, int length]) {\n    throw new UnsupportedError(\"Uint64List not supported by dart2js.\");\n  }\n\n  Int64List asInt64List([int offsetInBytes = 0, int length]) {\n    throw new UnsupportedError(\"Int64List not supported by dart2js.\");\n  }\n\n  Int32x4List asInt32x4List([int offsetInBytes = 0, int length]) {\n    NativeInt32List storage =\n        this.asInt32List(offsetInBytes, length != null ? length * 4 : null);\n    return new NativeInt32x4List._externalStorage(storage);\n  }\n\n  Float32List asFloat32List([int offsetInBytes = 0, int length]) {\n    return new NativeFloat32List.view(this, offsetInBytes, length);\n  }\n\n  Float64List asFloat64List([int offsetInBytes = 0, int length]) {\n    return new NativeFloat64List.view(this, offsetInBytes, length);\n  }\n\n  Float32x4List asFloat32x4List([int offsetInBytes = 0, int length]) {\n    NativeFloat32List storage =\n        this.asFloat32List(offsetInBytes, length != null ? length * 4 : null);\n    return new NativeFloat32x4List._externalStorage(storage);\n  }\n\n  Float64x2List asFloat64x2List([int offsetInBytes = 0, int length]) {\n    NativeFloat64List storage =\n        this.asFloat64List(offsetInBytes, length != null ? length * 2 : null);\n    return new NativeFloat64x2List._externalStorage(storage);\n  }\n\n  ByteData asByteData([int offsetInBytes = 0, int length]) {\n    return new NativeByteData.view(this, offsetInBytes, length);\n  }\n}\n\n\n\n/**\n * A fixed-length list of Float32x4 numbers that is viewable as a\n * [TypedData]. For long lists, this implementation will be considerably more\n * space- and time-efficient than the default [List] implementation.\n */\nclass NativeFloat32x4List\n    extends Object with ListMixin<Float32x4>, FixedLengthListMixin<Float32x4>\n    implements Float32x4List {\n\n  final NativeFloat32List _storage;\n\n  /**\n   * Creates a [Float32x4List] of the specified length (in elements),\n   * all of whose elements are initially zero.\n   */\n  NativeFloat32x4List(int length)\n      : _storage = new NativeFloat32List(length * 4);\n\n  NativeFloat32x4List._externalStorage(this._storage);\n\n  NativeFloat32x4List._slowFromList(List<Float32x4> list)\n      : _storage = new NativeFloat32List(list.length * 4) {\n    for (int i = 0; i < list.length; i++) {\n      var e = list[i];\n      _storage[(i * 4) + 0] = e.x;\n      _storage[(i * 4) + 1] = e.y;\n      _storage[(i * 4) + 2] = e.z;\n      _storage[(i * 4) + 3] = e.w;\n    }\n  }\n\n  Type get runtimeType => Float32x4List;\n\n  /**\n   * Creates a [Float32x4List] with the same size as the [elements] list\n   * and copies over the elements.\n   */\n  factory NativeFloat32x4List.fromList(List<Float32x4> list) {\n    if (list is NativeFloat32x4List) {\n      return new NativeFloat32x4List._externalStorage(\n          new NativeFloat32List.fromList(list._storage));\n    } else {\n      return new NativeFloat32x4List._slowFromList(list);\n    }\n  }\n\n  ByteBuffer get buffer => _storage.buffer;\n\n  int get lengthInBytes => _storage.lengthInBytes;\n\n  int get offsetInBytes => _storage.offsetInBytes;\n\n  int get elementSizeInBytes => Float32x4List.BYTES_PER_ELEMENT;\n\n  void _invalidIndex(int index, int length) {\n    if (index < 0 || index >= length) {\n      throw new RangeError.range(index, 0, length);\n    } else {\n      throw new ArgumentError('Invalid list index $index');\n    }\n  }\n\n  void _checkIndex(int index, int length) {\n    if (JS('bool', '(# >>> 0 != #)', index, index) || index >= length) {\n      _invalidIndex(index, length);\n    }\n  }\n\n  int _checkSublistArguments(int start, int end, int length) {\n    // For `sublist` the [start] and [end] indices are allowed to be equal to\n    // [length]. However, [_checkIndex] only allows indices in the range\n    // 0 .. length - 1. We therefore increment the [length] argument by one\n    // for the [_checkIndex] checks.\n    _checkIndex(start, length + 1);\n    if (end == null) return length;\n    _checkIndex(end, length + 1);\n    if (start > end) throw new RangeError.range(start, 0, end);\n    return end;\n  }\n\n  int get length => _storage.length ~/ 4;\n\n  Float32x4 operator[](int index) {\n    _checkIndex(index, length);\n    double _x = _storage[(index * 4) + 0];\n    double _y = _storage[(index * 4) + 1];\n    double _z = _storage[(index * 4) + 2];\n    double _w = _storage[(index * 4) + 3];\n    return new NativeFloat32x4._truncated(_x, _y, _z, _w);\n  }\n\n  void operator[]=(int index, Float32x4 value) {\n    _checkIndex(index, length);\n    _storage[(index * 4) + 0] = value.x;\n    _storage[(index * 4) + 1] = value.y;\n    _storage[(index * 4) + 2] = value.z;\n    _storage[(index * 4) + 3] = value.w;\n  }\n\n  List<Float32x4> sublist(int start, [int end]) {\n    end = _checkSublistArguments(start, end, length);\n    return new NativeFloat32x4List._externalStorage(\n        _storage.sublist(start * 4, end * 4));\n  }\n}\n\n\n/**\n * A fixed-length list of Int32x4 numbers that is viewable as a\n * [TypedData]. For long lists, this implementation will be considerably more\n * space- and time-efficient than the default [List] implementation.\n */\nclass NativeInt32x4List\n    extends Object with ListMixin<Int32x4>, FixedLengthListMixin<Int32x4>\n    implements Int32x4List {\n\n  final Int32List _storage;\n\n  /**\n   * Creates a [Int32x4List] of the specified length (in elements),\n   * all of whose elements are initially zero.\n   */\n  NativeInt32x4List(int length) : _storage = new NativeInt32List(length * 4);\n\n  NativeInt32x4List._externalStorage(Int32List storage) : _storage = storage;\n\n  NativeInt32x4List._slowFromList(List<Int32x4> list)\n      : _storage = new NativeInt32List(list.length * 4) {\n    for (int i = 0; i < list.length; i++) {\n      var e = list[i];\n      _storage[(i * 4) + 0] = e.x;\n      _storage[(i * 4) + 1] = e.y;\n      _storage[(i * 4) + 2] = e.z;\n      _storage[(i * 4) + 3] = e.w;\n    }\n  }\n\n  Type get runtimeType => Int32x4List;\n\n  /**\n   * Creates a [Int32x4List] with the same size as the [elements] list\n   * and copies over the elements.\n   */\n  factory NativeInt32x4List.fromList(List<Int32x4> list) {\n    if (list is NativeInt32x4List) {\n      return new NativeInt32x4List._externalStorage(\n          new NativeInt32List.fromList(list._storage));\n    } else {\n      return new NativeInt32x4List._slowFromList(list);\n    }\n  }\n\n  ByteBuffer get buffer => _storage.buffer;\n\n  int get lengthInBytes => _storage.lengthInBytes;\n\n  int get offsetInBytes => _storage.offsetInBytes;\n\n  int get elementSizeInBytes => Int32x4List.BYTES_PER_ELEMENT;\n\n  void _invalidIndex(int index, int length) {\n    if (index < 0 || index >= length) {\n      throw new RangeError.range(index, 0, length);\n    } else {\n      throw new ArgumentError('Invalid list index $index');\n    }\n  }\n\n  void _checkIndex(int index, int length) {\n    if (JS('bool', '(# >>> 0 != #)', index, index)\n        || JS('bool', '# >= #', index, length)) {\n      _invalidIndex(index, length);\n    }\n  }\n\n  int _checkSublistArguments(int start, int end, int length) {\n    // For `sublist` the [start] and [end] indices are allowed to be equal to\n    // [length]. However, [_checkIndex] only allows indices in the range\n    // 0 .. length - 1. We therefore increment the [length] argument by one\n    // for the [_checkIndex] checks.\n    _checkIndex(start, length + 1);\n    if (end == null) return length;\n    _checkIndex(end, length + 1);\n    if (start > end) throw new RangeError.range(start, 0, end);\n    return end;\n  }\n\n  int get length => _storage.length ~/ 4;\n\n  Int32x4 operator[](int index) {\n    _checkIndex(index, length);\n    int _x = _storage[(index * 4) + 0];\n    int _y = _storage[(index * 4) + 1];\n    int _z = _storage[(index * 4) + 2];\n    int _w = _storage[(index * 4) + 3];\n    return new NativeInt32x4._truncated(_x, _y, _z, _w);\n  }\n\n  void operator[]=(int index, Int32x4 value) {\n    _checkIndex(index, length);\n    _storage[(index * 4) + 0] = value.x;\n    _storage[(index * 4) + 1] = value.y;\n    _storage[(index * 4) + 2] = value.z;\n    _storage[(index * 4) + 3] = value.w;\n  }\n\n  List<Int32x4> sublist(int start, [int end]) {\n    end = _checkSublistArguments(start, end, length);\n    return new NativeInt32x4List._externalStorage(\n        _storage.sublist(start * 4, end * 4));\n  }\n}\n\n\n/**\n * A fixed-length list of Float64x2 numbers that is viewable as a\n * [TypedData]. For long lists, this implementation will be considerably more\n * space- and time-efficient than the default [List] implementation.\n */\nclass NativeFloat64x2List\n    extends Object with ListMixin<Float64x2>, FixedLengthListMixin<Float64x2>\n    implements Float64x2List {\n\n  final NativeFloat64List _storage;\n\n  /**\n   * Creates a [Float64x2List] of the specified length (in elements),\n   * all of whose elements are initially zero.\n   */\n  NativeFloat64x2List(int length)\n      : _storage = new NativeFloat64List(length * 2);\n\n  NativeFloat64x2List._externalStorage(this._storage);\n\n  NativeFloat64x2List._slowFromList(List<Float64x2> list)\n      : _storage = new NativeFloat64List(list.length * 2) {\n    for (int i = 0; i < list.length; i++) {\n      var e = list[i];\n      _storage[(i * 2) + 0] = e.x;\n      _storage[(i * 2) + 1] = e.y;\n    }\n  }\n\n  /**\n   * Creates a [Float64x2List] with the same size as the [elements] list\n   * and copies over the elements.\n   */\n  factory NativeFloat64x2List.fromList(List<Float64x2> list) {\n    if (list is NativeFloat64x2List) {\n      return new NativeFloat64x2List._externalStorage(\n          new NativeFloat64List.fromList(list._storage));\n    } else {\n      return new NativeFloat64x2List._slowFromList(list);\n    }\n  }\n\n  Type get runtimeType => Float64x2List;\n\n  ByteBuffer get buffer => _storage.buffer;\n\n  int get lengthInBytes => _storage.lengthInBytes;\n\n  int get offsetInBytes => _storage.offsetInBytes;\n\n  int get elementSizeInBytes => Float64x2List.BYTES_PER_ELEMENT;\n\n  void _invalidIndex(int index, int length) {\n    if (index < 0 || index >= length) {\n      throw new RangeError.range(index, 0, length);\n    } else {\n      throw new ArgumentError('Invalid list index $index');\n    }\n  }\n\n  void _checkIndex(int index, int length) {\n    if (JS('bool', '(# >>> 0 != #)', index, index) || index >= length) {\n      _invalidIndex(index, length);\n    }\n  }\n\n  int _checkSublistArguments(int start, int end, int length) {\n    // For `sublist` the [start] and [end] indices are allowed to be equal to\n    // [length]. However, [_checkIndex] only allows indices in the range\n    // 0 .. length - 1. We therefore increment the [length] argument by one\n    // for the [_checkIndex] checks.\n    _checkIndex(start, length + 1);\n    if (end == null) return length;\n    _checkIndex(end, length + 1);\n    if (start > end) throw new RangeError.range(start, 0, end);\n    return end;\n  }\n\n  int get length => _storage.length ~/ 2;\n\n  Float64x2 operator[](int index) {\n    _checkIndex(index, length);\n    double _x = _storage[(index * 2) + 0];\n    double _y = _storage[(index * 2) + 1];\n    return new Float64x2(_x, _y);\n  }\n\n  void operator[]=(int index, Float64x2 value) {\n    _checkIndex(index, length);\n    _storage[(index * 2) + 0] = value.x;\n    _storage[(index * 2) + 1] = value.y;\n  }\n\n  List<Float64x2> sublist(int start, [int end]) {\n    end = _checkSublistArguments(start, end, length);\n    return new NativeFloat64x2List._externalStorage(\n        _storage.sublist(start * 2, end * 2));\n  }\n}\n\n@Native(\"ArrayBufferView\")\nclass NativeTypedData implements TypedData {\n  /**\n   * Returns the byte buffer associated with this object.\n   */\n  @Creates('NativeByteBuffer')\n  // May be Null for IE's CanvasPixelArray.\n  @Returns('NativeByteBuffer|Null')\n  final ByteBuffer buffer;\n\n  /**\n   * Returns the length of this view, in bytes.\n   */\n  @JSName('byteLength')\n  final int lengthInBytes;\n\n  /**\n   * Returns the offset in bytes into the underlying byte buffer of this view.\n   */\n  @JSName('byteOffset')\n  final int offsetInBytes;\n\n  /**\n   * Returns the number of bytes in the representation of each element in this\n   * list.\n   */\n  @JSName('BYTES_PER_ELEMENT')\n  final int elementSizeInBytes;\n\n  void _invalidIndex(int index, int length) {\n    if (index < 0 || index >= length) {\n      throw new RangeError.range(index, 0, length);\n    } else {\n      throw new ArgumentError('Invalid list index $index');\n    }\n  }\n\n  void _checkIndex(int index, int length) {\n    if (JS('bool', '(# >>> 0) !== #', index, index) ||\n        JS('int', '#', index) >= length) {  // 'int' guaranteed by above test.\n      _invalidIndex(index, length);\n    }\n  }\n\n  int _checkSublistArguments(int start, int end, int length) {\n    // For `sublist` the [start] and [end] indices are allowed to be equal to\n    // [length]. However, [_checkIndex] only allows indices in the range\n    // 0 .. length - 1. We therefore increment the [length] argument by one\n    // for the [_checkIndex] checks.\n    _checkIndex(start, length + 1);\n    if (end == null) return length;\n    _checkIndex(end, length + 1);\n    if (start > end) throw new RangeError.range(start, 0, end);\n    return end;\n  }\n}\n\n\n// Validates the unnamed constructor length argument.  Checking is necessary\n// because passing unvalidated values to the native constructors can cause\n// conversions or create views.\nint _checkLength(length) {\n  if (length is! int) throw new ArgumentError('Invalid length $length');\n  return length;\n}\n\n// Validates `.view` constructor arguments.  Checking is necessary because\n// passing unvalidated values to the native constructors can cause conversions\n// (e.g. String arguments) or create typed data objects that are not actually\n// views of the input.\nvoid _checkViewArguments(buffer, offsetInBytes, length) {\n  if (buffer is! NativeByteBuffer) {\n    throw new ArgumentError('Invalid view buffer');\n  }\n  if (offsetInBytes is! int) {\n    throw new ArgumentError('Invalid view offsetInBytes $offsetInBytes');\n  }\n  if (length != null && length is! int) {\n    throw new ArgumentError('Invalid view length $length');\n  }\n}\n\n// Ensures that [list] is a JavaScript Array or a typed array.  If necessary,\n// returns a copy of the list.\nList _ensureNativeList(List list) {\n  if (list is JSIndexable) return list;\n  List result = new List(list.length);\n  for (int i = 0; i < list.length; i++) {\n    result[i] = list[i];\n  }\n  return result;\n}\n\n\n@Native(\"DataView\")\nclass NativeByteData extends NativeTypedData implements ByteData {\n  /**\n   * Creates a [ByteData] of the specified length (in elements), all of\n   * whose elements are initially zero.\n   */\n  factory NativeByteData(int length) => _create1(_checkLength(length));\n\n  /**\n   * Creates an [ByteData] _view_ of the specified region in the specified\n   * byte buffer. Changes in the [ByteData] will be visible in the byte\n   * buffer and vice versa. If the [offsetInBytes] index of the region is not\n   * specified, it defaults to zero (the first byte in the byte buffer).\n   * If the length is not specified, it defaults to null, which indicates\n   * that the view extends to the end of the byte buffer.\n   *\n   * Throws [RangeError] if [offsetInBytes] or [length] are negative, or\n   * if [offsetInBytes] + ([length] * elementSizeInBytes) is greater than\n   * the length of [buffer].\n   */\n  factory NativeByteData.view(ByteBuffer buffer,\n                              int offsetInBytes, int length) {\n    _checkViewArguments(buffer, offsetInBytes, length);\n    return length == null\n        ? _create2(buffer, offsetInBytes)\n        : _create3(buffer, offsetInBytes, length);\n  }\n\n  Type get runtimeType => ByteData;\n\n  int get elementSizeInBytes => 1;\n\n  /**\n   * Returns the floating point number represented by the four bytes at\n   * the specified [byteOffset] in this object, in IEEE 754\n   * single-precision binary floating-point format (binary32).\n   *\n   * Throws [RangeError] if [byteOffset] is negative, or\n   * `byteOffset + 4` is greater than the length of this object.\n   */\n  num getFloat32(int byteOffset, [Endianness endian=Endianness.BIG_ENDIAN]) =>\n      _getFloat32(byteOffset, Endianness.LITTLE_ENDIAN == endian);\n\n  @JSName('getFloat32')\n  @Returns('num')\n  num _getFloat32(int byteOffset, [bool littleEndian]) native;\n\n  /**\n   * Returns the floating point number represented by the eight bytes at\n   * the specified [byteOffset] in this object, in IEEE 754\n   * double-precision binary floating-point format (binary64).\n   *\n   * Throws [RangeError] if [byteOffset] is negative, or\n   * `byteOffset + 8` is greater than the length of this object.\n   */\n  num getFloat64(int byteOffset, [Endianness endian=Endianness.BIG_ENDIAN]) =>\n      _getFloat64(byteOffset, Endianness.LITTLE_ENDIAN == endian);\n\n  @JSName('getFloat64')\n  @Returns('num')\n  num _getFloat64(int byteOffset, [bool littleEndian]) native;\n\n  /**\n   * Returns the (possibly negative) integer represented by the two bytes at\n   * the specified [byteOffset] in this object, in two's complement binary\n   * form.\n   * The return value will be between 2<sup>15</sup> and 2<sup>15</sup> - 1,\n   * inclusive.\n   *\n   * Throws [RangeError] if [byteOffset] is negative, or\n   * `byteOffset + 2` is greater than the length of this object.\n   */\n  int getInt16(int byteOffset, [Endianness endian=Endianness.BIG_ENDIAN]) =>\n      _getInt16(byteOffset, Endianness.LITTLE_ENDIAN == endian);\n\n  @JSName('getInt16')\n  @Returns('int')\n  int _getInt16(int byteOffset, [bool littleEndian]) native;\n\n  /**\n   * Returns the (possibly negative) integer represented by the four bytes at\n   * the specified [byteOffset] in this object, in two's complement binary\n   * form.\n   * The return value will be between 2<sup>31</sup> and 2<sup>31</sup> - 1,\n   * inclusive.\n   *\n   * Throws [RangeError] if [byteOffset] is negative, or\n   * `byteOffset + 4` is greater than the length of this object.\n   */\n  int getInt32(int byteOffset, [Endianness endian=Endianness.BIG_ENDIAN]) =>\n      _getInt32(byteOffset, Endianness.LITTLE_ENDIAN == endian);\n\n  @JSName('getInt32')\n  @Returns('int')\n  int _getInt32(int byteOffset, [bool littleEndian]) native;\n\n  /**\n   * Returns the (possibly negative) integer represented by the eight bytes at\n   * the specified [byteOffset] in this object, in two's complement binary\n   * form.\n   * The return value will be between 2<sup>63</sup> and 2<sup>63</sup> - 1,\n   * inclusive.\n   *\n   * Throws [RangeError] if [byteOffset] is negative, or\n   * `byteOffset + 8` is greater than the length of this object.\n   */\n  int getInt64(int byteOffset, [Endianness endian=Endianness.BIG_ENDIAN]) {\n    throw new UnsupportedError('Int64 accessor not supported by dart2js.');\n  }\n\n  /**\n   * Returns the (possibly negative) integer represented by the byte at the\n   * specified [byteOffset] in this object, in two's complement binary\n   * representation. The return value will be between -128 and 127, inclusive.\n   *\n   * Throws [RangeError] if [byteOffset] is negative, or\n   * greater than or equal to the length of this object.\n   */\n  int getInt8(int byteOffset) native;\n\n  /**\n   * Returns the positive integer represented by the two bytes starting\n   * at the specified [byteOffset] in this object, in unsigned binary\n   * form.\n   * The return value will be between 0 and  2<sup>16</sup> - 1, inclusive.\n   *\n   * Throws [RangeError] if [byteOffset] is negative, or\n   * `byteOffset + 2` is greater than the length of this object.\n   */\n  int getUint16(int byteOffset, [Endianness endian=Endianness.BIG_ENDIAN]) =>\n      _getUint16(byteOffset, Endianness.LITTLE_ENDIAN == endian);\n\n  @JSName('getUint16')\n  @Returns('JSUInt31')\n  int _getUint16(int byteOffset, [bool littleEndian]) native;\n\n  /**\n   * Returns the positive integer represented by the four bytes starting\n   * at the specified [byteOffset] in this object, in unsigned binary\n   * form.\n   * The return value will be between 0 and  2<sup>32</sup> - 1, inclusive.\n   *\n   * Throws [RangeError] if [byteOffset] is negative, or\n   * `byteOffset + 4` is greater than the length of this object.\n   */\n  int getUint32(int byteOffset, [Endianness endian=Endianness.BIG_ENDIAN]) =>\n      _getUint32(byteOffset, Endianness.LITTLE_ENDIAN == endian);\n\n  @JSName('getUint32')\n  @Returns('JSUInt32')\n  int _getUint32(int byteOffset, [bool littleEndian]) native;\n\n  /**\n   * Returns the positive integer represented by the eight bytes starting\n   * at the specified [byteOffset] in this object, in unsigned binary\n   * form.\n   * The return value will be between 0 and  2<sup>64</sup> - 1, inclusive.\n   *\n   * Throws [RangeError] if [byteOffset] is negative, or\n   * `byteOffset + 8` is greater than the length of this object.\n   */\n  int getUint64(int byteOffset, [Endianness endian=Endianness.BIG_ENDIAN]) {\n    throw new UnsupportedError('Uint64 accessor not supported by dart2js.');\n  }\n\n  /**\n   * Returns the positive integer represented by the byte at the specified\n   * [byteOffset] in this object, in unsigned binary form. The\n   * return value will be between 0 and 255, inclusive.\n   *\n   * Throws [RangeError] if [byteOffset] is negative, or\n   * greater than or equal to the length of this object.\n   */\n  int getUint8(int byteOffset) native;\n\n  /**\n   * Sets the four bytes starting at the specified [byteOffset] in this\n   * object to the IEEE 754 single-precision binary floating-point\n   * (binary32) representation of the specified [value].\n   *\n   * **Note that this method can lose precision.** The input [value] is\n   * a 64-bit floating point value, which will be converted to 32-bit\n   * floating point value by IEEE 754 rounding rules before it is stored.\n   * If [value] cannot be represented exactly as a binary32, it will be\n   * converted to the nearest binary32 value.  If two binary32 values are\n   * equally close, the one whose least significant bit is zero will be used.\n   * Note that finite (but large) values can be converted to infinity, and\n   * small non-zero values can be converted to zero.\n   *\n   * Throws [RangeError] if [byteOffset] is negative, or\n   * `byteOffset + 4` is greater than the length of this object.\n   */\n  void setFloat32(int byteOffset, num value,\n                  [Endianness endian=Endianness.BIG_ENDIAN]) =>\n      _setFloat32(byteOffset, value, Endianness.LITTLE_ENDIAN == endian);\n\n  @JSName('setFloat32')\n  void _setFloat32(int byteOffset, num value, [bool littleEndian]) native;\n\n  /**\n   * Sets the eight bytes starting at the specified [byteOffset] in this\n   * object to the IEEE 754 double-precision binary floating-point\n   * (binary64) representation of the specified [value].\n   *\n   * Throws [RangeError] if [byteOffset] is negative, or\n   * `byteOffset + 8` is greater than the length of this object.\n   */\n  void setFloat64(int byteOffset, num value,\n                  [Endianness endian=Endianness.BIG_ENDIAN]) =>\n      _setFloat64(byteOffset, value, Endianness.LITTLE_ENDIAN == endian);\n\n  @JSName('setFloat64')\n  void _setFloat64(int byteOffset, num value, [bool littleEndian]) native;\n\n  /**\n   * Sets the two bytes starting at the specified [byteOffset] in this\n   * object to the two's complement binary representation of the specified\n   * [value], which must fit in two bytes. In other words, [value] must lie\n   * between 2<sup>15</sup> and 2<sup>15</sup> - 1, inclusive.\n   *\n   * Throws [RangeError] if [byteOffset] is negative, or\n   * `byteOffset + 2` is greater than the length of this object.\n   */\n  void setInt16(int byteOffset, int value,\n                [Endianness endian=Endianness.BIG_ENDIAN]) =>\n      _setInt16(byteOffset, value, Endianness.LITTLE_ENDIAN == endian);\n\n  @JSName('setInt16')\n  void _setInt16(int byteOffset, int value, [bool littleEndian]) native;\n\n  /**\n   * Sets the four bytes starting at the specified [byteOffset] in this\n   * object to the two's complement binary representation of the specified\n   * [value], which must fit in four bytes. In other words, [value] must lie\n   * between 2<sup>31</sup> and 2<sup>31</sup> - 1, inclusive.\n   *\n   * Throws [RangeError] if [byteOffset] is negative, or\n   * `byteOffset + 4` is greater than the length of this object.\n   */\n  void setInt32(int byteOffset, int value,\n                [Endianness endian=Endianness.BIG_ENDIAN]) =>\n      _setInt32(byteOffset, value, Endianness.LITTLE_ENDIAN == endian);\n\n  @JSName('setInt32')\n  void _setInt32(int byteOffset, int value, [bool littleEndian]) native;\n\n  /**\n   * Sets the eight bytes starting at the specified [byteOffset] in this\n   * object to the two's complement binary representation of the specified\n   * [value], which must fit in eight bytes. In other words, [value] must lie\n   * between 2<sup>63</sup> and 2<sup>63</sup> - 1, inclusive.\n   *\n   * Throws [RangeError] if [byteOffset] is negative, or\n   * `byteOffset + 8` is greater than the length of this object.\n   */\n  void setInt64(int byteOffset, int value,\n                [Endianness endian=Endianness.BIG_ENDIAN]) {\n    throw new UnsupportedError('Int64 accessor not supported by dart2js.');\n  }\n\n  /**\n   * Sets the byte at the specified [byteOffset] in this object to the\n   * two's complement binary representation of the specified [value], which\n   * must fit in a single byte. In other words, [value] must be between\n   * -128 and 127, inclusive.\n   *\n   * Throws [RangeError] if [byteOffset] is negative, or\n   * greater than or equal to the length of this object.\n   */\n  void setInt8(int byteOffset, int value) native;\n\n  /**\n   * Sets the two bytes starting at the specified [byteOffset] in this object\n   * to the unsigned binary representation of the specified [value],\n   * which must fit in two bytes. in other words, [value] must be between\n   * 0 and 2<sup>16</sup> - 1, inclusive.\n   *\n   * Throws [RangeError] if [byteOffset] is negative, or\n   * `byteOffset + 2` is greater than the length of this object.\n   */\n  void setUint16(int byteOffset, int value,\n                 [Endianness endian=Endianness.BIG_ENDIAN]) =>\n      _setUint16(byteOffset, value, Endianness.LITTLE_ENDIAN == endian);\n\n  @JSName('setUint16')\n  void _setUint16(int byteOffset, int value, [bool littleEndian]) native;\n\n  /**\n   * Sets the four bytes starting at the specified [byteOffset] in this object\n   * to the unsigned binary representation of the specified [value],\n   * which must fit in four bytes. in other words, [value] must be between\n   * 0 and 2<sup>32</sup> - 1, inclusive.\n   *\n   * Throws [RangeError] if [byteOffset] is negative, or\n   * `byteOffset + 4` is greater than the length of this object.\n   */\n  void setUint32(int byteOffset, int value,\n                 [Endianness endian=Endianness.BIG_ENDIAN]) =>\n      _setUint32(byteOffset, value, Endianness.LITTLE_ENDIAN == endian);\n\n  @JSName('setUint32')\n  void _setUint32(int byteOffset, int value, [bool littleEndian]) native;\n\n  /**\n   * Sets the eight bytes starting at the specified [byteOffset] in this object\n   * to the unsigned binary representation of the specified [value],\n   * which must fit in eight bytes. in other words, [value] must be between\n   * 0 and 2<sup>64</sup> - 1, inclusive.\n   *\n   * Throws [RangeError] if [byteOffset] is negative, or\n   * `byteOffset + 8` is greater than the length of this object.\n   */\n  void setUint64(int byteOffset, int value,\n                 [Endianness endian=Endianness.BIG_ENDIAN]) {\n    throw new UnsupportedError('Uint64 accessor not supported by dart2js.');\n  }\n\n  /**\n   * Sets the byte at the specified [byteOffset] in this object to the\n   * unsigned binary representation of the specified [value], which must fit\n   * in a single byte. in other words, [value] must be between 0 and 255,\n   * inclusive.\n   *\n   * Throws [RangeError] if [byteOffset] is negative,\n   * or greater than or equal to the length of this object.\n   */\n  void setUint8(int byteOffset, int value) native;\n\n  static NativeByteData _create1(arg) =>\n      JS('NativeByteData', 'new DataView(new ArrayBuffer(#))', arg);\n\n  static NativeByteData _create2(arg1, arg2) =>\n      JS('NativeByteData', 'new DataView(#, #)', arg1, arg2);\n\n  static NativeByteData _create3(arg1, arg2, arg3) =>\n      JS('NativeByteData', 'new DataView(#, #, #)', arg1, arg2, arg3);\n}\n\n\nabstract class NativeTypedArray extends NativeTypedData\n    implements JavaScriptIndexingBehavior {\n  int get length => JS('JSUInt32', '#.length', this);\n\n  void _setRangeFast(int start, int end,\n      NativeTypedArray source, int skipCount) {\n    int targetLength = this.length;\n    _checkIndex(start, targetLength + 1);\n    _checkIndex(end, targetLength + 1);\n    if (start > end) throw new RangeError.range(start, 0, end);\n    int count = end - start;\n\n    if (skipCount < 0) throw new ArgumentError(skipCount);\n\n    int sourceLength = source.length;\n    if (sourceLength - skipCount < count)  {\n      throw new StateError('Not enough elements');\n    }\n\n    if (skipCount != 0 || sourceLength != count) {\n      // Create a view of the exact subrange that is copied from the source.\n      source = JS('', '#.subarray(#, #)',\n          source, skipCount, skipCount + count);\n    }\n    JS('void', '#.set(#, #)', this, source, start);\n  }\n}\n\nabstract class NativeTypedArrayOfDouble\n    extends NativeTypedArray\n        with ListMixin<double>, FixedLengthListMixin<double> {\n\n  num operator[](int index) {\n    _checkIndex(index, length);\n    return JS('num', '#[#]', this, index);\n  }\n\n  void operator[]=(int index, num value) {\n    _checkIndex(index, length);\n    JS('void', '#[#] = #', this, index, value);\n  }\n\n  void setRange(int start, int end, Iterable<double> iterable,\n                [int skipCount = 0]) {\n    if (iterable is NativeTypedArrayOfDouble) {\n      _setRangeFast(start, end, iterable, skipCount);\n      return;\n    }\n    super.setRange(start, end, iterable, skipCount);\n  }\n}\n\nabstract class NativeTypedArrayOfInt\n    extends NativeTypedArray\n        with ListMixin<int>, FixedLengthListMixin<int>\n    implements List<int> {\n\n  // operator[]() is not here since different versions have different return\n  // types\n\n  void operator[]=(int index, int value) {\n    _checkIndex(index, length);\n    JS('void', '#[#] = #', this, index, value);\n  }\n\n  void setRange(int start, int end, Iterable<int> iterable,\n                [int skipCount = 0]) {\n    if (iterable is NativeTypedArrayOfInt) {\n      _setRangeFast(start, end, iterable, skipCount);\n      return;\n    }\n    super.setRange(start, end, iterable, skipCount);\n  }\n}\n\n\n@Native(\"Float32Array\")\nclass NativeFloat32List\n    extends NativeTypedArrayOfDouble\n    implements Float32List {\n\n  factory NativeFloat32List(int length) => _create1(_checkLength(length));\n\n  factory NativeFloat32List.fromList(List<double> elements) =>\n      _create1(_ensureNativeList(elements));\n\n  factory NativeFloat32List.view(ByteBuffer buffer,\n                                 int offsetInBytes, int length) {\n    _checkViewArguments(buffer, offsetInBytes, length);\n    return length == null\n        ? _create2(buffer, offsetInBytes)\n        : _create3(buffer, offsetInBytes, length);\n  }\n\n  Type get runtimeType => Float32List;\n\n  List<double> sublist(int start, [int end]) {\n    end = _checkSublistArguments(start, end, length);\n    var source = JS('NativeFloat32List', '#.subarray(#, #)', this, start, end);\n    return _create1(source);\n  }\n\n  static NativeFloat32List _create1(arg) =>\n      JS('NativeFloat32List', 'new Float32Array(#)', arg);\n\n  static NativeFloat32List _create2(arg1, arg2) =>\n      JS('NativeFloat32List', 'new Float32Array(#, #)', arg1, arg2);\n\n  static NativeFloat32List _create3(arg1, arg2, arg3) =>\n      JS('NativeFloat32List', 'new Float32Array(#, #, #)', arg1, arg2, arg3);\n}\n\n\n@Native(\"Float64Array\")\nclass NativeFloat64List\n    extends NativeTypedArrayOfDouble\n    implements Float64List {\n\n  factory NativeFloat64List(int length) => _create1(_checkLength(length));\n\n  factory NativeFloat64List.fromList(List<double> elements) =>\n      _create1(_ensureNativeList(elements));\n\n  factory NativeFloat64List.view(ByteBuffer buffer,\n                                 int offsetInBytes, int length) {\n    _checkViewArguments(buffer, offsetInBytes, length);\n    return length == null\n        ? _create2(buffer, offsetInBytes)\n        : _create3(buffer, offsetInBytes, length);\n  }\n\n  Type get runtimeType => Float64List;\n\n  List<double> sublist(int start, [int end]) {\n    end = _checkSublistArguments(start, end, length);\n    var source = JS('NativeFloat64List', '#.subarray(#, #)', this, start, end);\n    return _create1(source);\n  }\n\n  static NativeFloat64List _create1(arg) =>\n      JS('NativeFloat64List', 'new Float64Array(#)', arg);\n\n  static NativeFloat64List _create2(arg1, arg2) =>\n      JS('NativeFloat64List', 'new Float64Array(#, #)', arg1, arg2);\n\n  static NativeFloat64List _create3(arg1, arg2, arg3) =>\n      JS('NativeFloat64List', 'new Float64Array(#, #, #)', arg1, arg2, arg3);\n}\n\n\n@Native(\"Int16Array\")\nclass NativeInt16List\n    extends NativeTypedArrayOfInt\n    implements Int16List {\n\n  factory NativeInt16List(int length) => _create1(_checkLength(length));\n\n  factory NativeInt16List.fromList(List<int> elements) =>\n      _create1(_ensureNativeList(elements));\n\n  factory NativeInt16List.view(NativeByteBuffer buffer,\n                               int offsetInBytes, int length) {\n    _checkViewArguments(buffer, offsetInBytes, length);\n    return length == null\n        ? _create2(buffer, offsetInBytes)\n        : _create3(buffer, offsetInBytes, length);\n  }\n\n  Type get runtimeType => Int16List;\n\n  int operator[](int index) {\n    _checkIndex(index, length);\n    return JS('int', '#[#]', this, index);\n  }\n\n  List<int> sublist(int start, [int end]) {\n    end = _checkSublistArguments(start, end, length);\n    var source = JS('NativeInt16List', '#.subarray(#, #)', this, start, end);\n    return _create1(source);\n  }\n\n  static NativeInt16List _create1(arg) =>\n      JS('NativeInt16List', 'new Int16Array(#)', arg);\n\n  static NativeInt16List _create2(arg1, arg2) =>\n      JS('NativeInt16List', 'new Int16Array(#, #)', arg1, arg2);\n\n  static NativeInt16List _create3(arg1, arg2, arg3) =>\n      JS('NativeInt16List', 'new Int16Array(#, #, #)', arg1, arg2, arg3);\n}\n\n\n@Native(\"Int32Array\")\nclass NativeInt32List extends NativeTypedArrayOfInt implements Int32List {\n\n  factory NativeInt32List(int length) => _create1(_checkLength(length));\n\n  factory NativeInt32List.fromList(List<int> elements) =>\n      _create1(_ensureNativeList(elements));\n\n  factory NativeInt32List.view(ByteBuffer buffer,\n                               int offsetInBytes, int length) {\n    _checkViewArguments(buffer, offsetInBytes, length);\n    return length == null\n        ? _create2(buffer, offsetInBytes)\n        : _create3(buffer, offsetInBytes, length);\n  }\n\n  Type get runtimeType => Int32List;\n\n  int operator[](int index) {\n    _checkIndex(index, length);\n    return JS('int', '#[#]', this, index);\n  }\n\n  List<int> sublist(int start, [int end]) {\n    end = _checkSublistArguments(start, end, length);\n    var source = JS('NativeInt32List', '#.subarray(#, #)', this, start, end);\n    return _create1(source);\n  }\n\n  static NativeInt32List _create1(arg) =>\n      JS('NativeInt32List', 'new Int32Array(#)', arg);\n\n  static NativeInt32List _create2(arg1, arg2) =>\n      JS('NativeInt32List', 'new Int32Array(#, #)', arg1, arg2);\n\n  static NativeInt32List _create3(arg1, arg2, arg3) =>\n      JS('NativeInt32List', 'new Int32Array(#, #, #)', arg1, arg2, arg3);\n}\n\n\n@Native(\"Int8Array\")\nclass NativeInt8List extends NativeTypedArrayOfInt implements Int8List {\n\n  factory NativeInt8List(int length) => _create1(_checkLength(length));\n\n  factory NativeInt8List.fromList(List<int> elements) =>\n      _create1(_ensureNativeList(elements));\n\n  factory NativeInt8List.view(ByteBuffer buffer,\n                               int offsetInBytes, int length) {\n    _checkViewArguments(buffer, offsetInBytes, length);\n    return length == null\n        ? _create2(buffer, offsetInBytes)\n        : _create3(buffer, offsetInBytes, length);\n  }\n\n  Type get runtimeType => Int8List;\n\n  int operator[](int index) {\n    _checkIndex(index, length);\n    return JS('int', '#[#]', this, index);\n  }\n\n  List<int> sublist(int start, [int end]) {\n    end = _checkSublistArguments(start, end, length);\n    var source = JS('NativeInt8List', '#.subarray(#, #)', this, start, end);\n    return _create1(source);\n  }\n\n  static NativeInt8List _create1(arg) =>\n      JS('NativeInt8List', 'new Int8Array(#)', arg);\n\n  static NativeInt8List _create2(arg1, arg2) =>\n      JS('NativeInt8List', 'new Int8Array(#, #)', arg1, arg2);\n\n  static Int8List _create3(arg1, arg2, arg3) =>\n      JS('NativeInt8List', 'new Int8Array(#, #, #)', arg1, arg2, arg3);\n}\n\n\n@Native(\"Uint16Array\")\nclass NativeUint16List extends NativeTypedArrayOfInt implements Uint16List {\n\n  factory NativeUint16List(int length) => _create1(_checkLength(length));\n\n  factory NativeUint16List.fromList(List<int> list) =>\n      _create1(_ensureNativeList(list));\n\n  factory NativeUint16List.view(ByteBuffer buffer,\n                                int offsetInBytes, int length) {\n    _checkViewArguments(buffer, offsetInBytes, length);\n    return length == null\n        ? _create2(buffer, offsetInBytes)\n        : _create3(buffer, offsetInBytes, length);\n  }\n\n  Type get runtimeType => Uint16List;\n\n  int operator[](int index) {\n    _checkIndex(index, length);\n    return JS('JSUInt31', '#[#]', this, index);\n  }\n\n  List<int> sublist(int start, [int end]) {\n    end = _checkSublistArguments(start, end, length);\n    var source = JS('NativeUint16List', '#.subarray(#, #)', this, start, end);\n    return _create1(source);\n  }\n\n  static NativeUint16List _create1(arg) =>\n      JS('NativeUint16List', 'new Uint16Array(#)', arg);\n\n  static NativeUint16List _create2(arg1, arg2) =>\n      JS('NativeUint16List', 'new Uint16Array(#, #)', arg1, arg2);\n\n  static NativeUint16List _create3(arg1, arg2, arg3) =>\n      JS('NativeUint16List', 'new Uint16Array(#, #, #)', arg1, arg2, arg3);\n}\n\n\n@Native(\"Uint32Array\")\nclass NativeUint32List extends NativeTypedArrayOfInt implements Uint32List {\n\n  factory NativeUint32List(int length) => _create1(_checkLength(length));\n\n  factory NativeUint32List.fromList(List<int> elements) =>\n      _create1(_ensureNativeList(elements));\n\n  factory NativeUint32List.view(ByteBuffer buffer,\n                                int offsetInBytes, int length) {\n    _checkViewArguments(buffer, offsetInBytes, length);\n    return length == null\n        ? _create2(buffer, offsetInBytes)\n        : _create3(buffer, offsetInBytes, length);\n  }\n\n  Type get runtimeType => Uint32List;\n\n  int operator[](int index) {\n    _checkIndex(index, length);\n    return JS('JSUInt32', '#[#]', this, index);\n  }\n\n  List<int> sublist(int start, [int end]) {\n    end = _checkSublistArguments(start, end, length);\n    var source = JS('NativeUint32List', '#.subarray(#, #)', this, start, end);\n    return _create1(source);\n  }\n\n  static NativeUint32List _create1(arg) =>\n      JS('NativeUint32List', 'new Uint32Array(#)', arg);\n\n  static NativeUint32List _create2(arg1, arg2) =>\n      JS('NativeUint32List', 'new Uint32Array(#, #)', arg1, arg2);\n\n  static NativeUint32List _create3(arg1, arg2, arg3) =>\n      JS('NativeUint32List', 'new Uint32Array(#, #, #)', arg1, arg2, arg3);\n}\n\n\n@Native(\"Uint8ClampedArray,CanvasPixelArray\")\nclass NativeUint8ClampedList\n    extends NativeTypedArrayOfInt\n    implements Uint8ClampedList {\n\n  factory NativeUint8ClampedList(int length) => _create1(_checkLength(length));\n\n  factory NativeUint8ClampedList.fromList(List<int> elements) =>\n      _create1(_ensureNativeList(elements));\n\n  factory NativeUint8ClampedList.view(ByteBuffer buffer,\n                                      int offsetInBytes, int length) {\n    _checkViewArguments(buffer, offsetInBytes, length);\n    return length == null\n        ? _create2(buffer, offsetInBytes)\n        : _create3(buffer, offsetInBytes, length);\n  }\n\n  Type get runtimeType => Uint8ClampedList;\n\n  int get length => JS('JSUInt32', '#.length', this);\n\n  int operator[](int index) {\n    _checkIndex(index, length);\n    return JS('JSUInt31', '#[#]', this, index);\n  }\n\n  List<int> sublist(int start, [int end]) {\n    end = _checkSublistArguments(start, end, length);\n    var source = JS('NativeUint8ClampedList', '#.subarray(#, #)',\n        this, start, end);\n    return _create1(source);\n  }\n\n  static NativeUint8ClampedList _create1(arg) =>\n      JS('NativeUint8ClampedList', 'new Uint8ClampedArray(#)', arg);\n\n  static NativeUint8ClampedList _create2(arg1, arg2) =>\n      JS('NativeUint8ClampedList', 'new Uint8ClampedArray(#, #)', arg1, arg2);\n\n  static NativeUint8ClampedList _create3(arg1, arg2, arg3) =>\n      JS('NativeUint8ClampedList', 'new Uint8ClampedArray(#, #, #)',\n         arg1, arg2, arg3);\n}\n\n\n// On some browsers Uint8ClampedArray is a subtype of Uint8Array.  Marking\n// Uint8List as !nonleaf ensures that the native dispatch correctly handles\n// the potential for Uint8ClampedArray to 'accidentally' pick up the\n// dispatch record for Uint8List.\n@Native(\"Uint8Array,!nonleaf\")\nclass NativeUint8List extends NativeTypedArrayOfInt implements Uint8List {\n\n  factory NativeUint8List(int length) => _create1(_checkLength(length));\n\n  factory NativeUint8List.fromList(List<int> elements) =>\n      _create1(_ensureNativeList(elements));\n\n  factory NativeUint8List.view(ByteBuffer buffer,\n                               int offsetInBytes, int length) {\n    _checkViewArguments(buffer, offsetInBytes, length);\n    return length == null\n        ? _create2(buffer, offsetInBytes)\n        : _create3(buffer, offsetInBytes, length);\n  }\n\n  Type get runtimeType => Uint8List;\n\n  int get length => JS('JSUInt32', '#.length', this);\n\n  int operator[](int index) {\n    _checkIndex(index, length);\n    return JS('JSUInt31', '#[#]', this, index);\n  }\n\n  List<int> sublist(int start, [int end]) {\n    end = _checkSublistArguments(start, end, length);\n    var source = JS('NativeUint8List', '#.subarray(#, #)', this, start, end);\n    return _create1(source);\n  }\n\n  static NativeUint8List _create1(arg) =>\n      JS('NativeUint8List', 'new Uint8Array(#)', arg);\n\n  static NativeUint8List _create2(arg1, arg2) =>\n      JS('NativeUint8List', 'new Uint8Array(#, #)', arg1, arg2);\n\n  static NativeUint8List _create3(arg1, arg2, arg3) =>\n      JS('NativeUint8List', 'new Uint8Array(#, #, #)', arg1, arg2, arg3);\n}\n\n\n/**\n * Implementation of Dart Float32x4 immutable value type and operations.\n * Float32x4 stores 4 32-bit floating point values in \"lanes\".\n * The lanes are \"x\", \"y\", \"z\", and \"w\" respectively.\n */\nclass NativeFloat32x4 implements Float32x4 {\n  final double x;\n  final double y;\n  final double z;\n  final double w;\n\n  static final NativeFloat32List _list = new NativeFloat32List(4);\n  static final Uint32List _uint32view = _list.buffer.asUint32List();\n\n  static _truncate(x) {\n    _list[0] = x;\n    return _list[0];\n  }\n\n  NativeFloat32x4(double x, double y, double z, double w)\n    : this.x = _truncate(x),\n      this.y = _truncate(y),\n      this.z = _truncate(z),\n      this.w = _truncate(w) {\n    // We would prefer to check for `double` but in dart2js we can't see the\n    // difference anyway.\n    if (x is! num) throw new ArgumentError(x);\n    if (y is! num) throw new ArgumentError(y);\n    if (z is! num) throw new ArgumentError(z);\n    if (w is! num) throw new ArgumentError(w);\n  }\n\n  NativeFloat32x4.splat(double v) : this(v, v, v, v);\n  NativeFloat32x4.zero() : this._truncated(0.0, 0.0, 0.0, 0.0);\n\n  /// Returns a bit-wise copy of [i] as a Float32x4.\n  factory NativeFloat32x4.fromInt32x4Bits(Int32x4 i) {\n    _uint32view[0] = i.x;\n    _uint32view[1] = i.y;\n    _uint32view[2] = i.z;\n    _uint32view[3] = i.w;\n    return new NativeFloat32x4._truncated(_list[0], _list[1], _list[2], _list[3]);\n  }\n\n  NativeFloat32x4.fromFloat64x2(Float64x2 v)\n    : this._truncated(_truncate(v.x), _truncate(v.y), 0.0, 0.0);\n\n  /// Creates a new NativeFloat32x4.\n  ///\n  /// Does not verify if the given arguments are non-null.\n  NativeFloat32x4._doubles(double x, double y, double z, double w)\n    : this.x = _truncate(x),\n      this.y = _truncate(y),\n      this.z = _truncate(z),\n      this.w = _truncate(w);\n\n  /// Creates a new NativeFloat32x4.\n  ///\n  /// The constructor does not truncate the arguments. They must already be in\n  /// the correct range. It does not verify the type of the given arguments,\n  /// either.\n  NativeFloat32x4._truncated(this.x, this.y, this.z, this.w);\n\n  String toString() {\n    return '[$x, $y, $z, $w]';\n  }\n\n   /// Addition operator.\n  Float32x4 operator+(Float32x4 other) {\n    double _x = x + other.x;\n    double _y = y + other.y;\n    double _z = z + other.z;\n    double _w = w + other.w;\n    return new NativeFloat32x4._doubles(_x, _y, _z, _w);\n  }\n\n  /// Negate operator.\n  Float32x4 operator-() {\n    return new NativeFloat32x4._truncated(-x, -y, -z, -w);\n  }\n\n  /// Subtraction operator.\n  Float32x4 operator-(Float32x4 other) {\n    double _x = x - other.x;\n    double _y = y - other.y;\n    double _z = z - other.z;\n    double _w = w - other.w;\n    return new NativeFloat32x4._doubles(_x, _y, _z, _w);\n  }\n\n  /// Multiplication operator.\n  Float32x4 operator*(Float32x4 other) {\n    double _x = x * other.x;\n    double _y = y * other.y;\n    double _z = z * other.z;\n    double _w = w * other.w;\n    return new NativeFloat32x4._doubles(_x, _y, _z, _w);\n  }\n\n  /// Division operator.\n  Float32x4 operator/(Float32x4 other) {\n    double _x = x / other.x;\n    double _y = y / other.y;\n    double _z = z / other.z;\n    double _w = w / other.w;\n    return new NativeFloat32x4._doubles(_x, _y, _z, _w);\n  }\n\n  /// Relational less than.\n  Int32x4 lessThan(Float32x4 other) {\n    bool _cx = x < other.x;\n    bool _cy = y < other.y;\n    bool _cz = z < other.z;\n    bool _cw = w < other.w;\n    return new NativeInt32x4._truncated(_cx ? -1 : 0,\n                                        _cy ? -1 : 0,\n                                        _cz ? -1 : 0,\n                                        _cw ? -1 : 0);\n  }\n\n  /// Relational less than or equal.\n  Int32x4 lessThanOrEqual(Float32x4 other) {\n    bool _cx = x <= other.x;\n    bool _cy = y <= other.y;\n    bool _cz = z <= other.z;\n    bool _cw = w <= other.w;\n    return new NativeInt32x4._truncated(_cx ? -1 : 0,\n                                        _cy ? -1 : 0,\n                                        _cz ? -1 : 0,\n                                        _cw ? -1 : 0);\n  }\n\n  /// Relational greater than.\n  Int32x4 greaterThan(Float32x4 other) {\n    bool _cx = x > other.x;\n    bool _cy = y > other.y;\n    bool _cz = z > other.z;\n    bool _cw = w > other.w;\n    return new NativeInt32x4._truncated(_cx ? -1 : 0,\n                                        _cy ? -1 : 0,\n                                        _cz ? -1 : 0,\n                                        _cw ? -1 : 0);\n  }\n\n  /// Relational greater than or equal.\n  Int32x4 greaterThanOrEqual(Float32x4 other) {\n    bool _cx = x >= other.x;\n    bool _cy = y >= other.y;\n    bool _cz = z >= other.z;\n    bool _cw = w >= other.w;\n    return new NativeInt32x4._truncated(_cx ? -1 : 0,\n                                        _cy ? -1 : 0,\n                                        _cz ? -1 : 0,\n                                        _cw ? -1 : 0);\n  }\n\n  /// Relational equal.\n  Int32x4 equal(Float32x4 other) {\n    bool _cx = x == other.x;\n    bool _cy = y == other.y;\n    bool _cz = z == other.z;\n    bool _cw = w == other.w;\n    return new NativeInt32x4._truncated(_cx ? -1 : 0,\n                                        _cy ? -1 : 0,\n                                        _cz ? -1 : 0,\n                                        _cw ? -1 : 0);\n  }\n\n  /// Relational not-equal.\n  Int32x4 notEqual(Float32x4 other) {\n    bool _cx = x != other.x;\n    bool _cy = y != other.y;\n    bool _cz = z != other.z;\n    bool _cw = w != other.w;\n    return new NativeInt32x4._truncated(_cx ? -1 : 0,\n                                        _cy ? -1 : 0,\n                                        _cz ? -1 : 0,\n                                        _cw ? -1 : 0);\n  }\n\n  /// Returns a copy of [this] each lane being scaled by [s].\n  Float32x4 scale(double s) {\n    double _x = s * x;\n    double _y = s * y;\n    double _z = s * z;\n    double _w = s * w;\n    return new NativeFloat32x4._doubles(_x, _y, _z, _w);\n  }\n\n  /// Returns the absolute value of this [Float32x4].\n  Float32x4 abs() {\n    double _x = x.abs();\n    double _y = y.abs();\n    double _z = z.abs();\n    double _w = w.abs();\n    return new NativeFloat32x4._truncated(_x, _y, _z, _w);\n  }\n\n  /// Clamps [this] to be in the range [lowerLimit]-[upperLimit].\n  Float32x4 clamp(Float32x4 lowerLimit, Float32x4 upperLimit) {\n    double _lx = lowerLimit.x;\n    double _ly = lowerLimit.y;\n    double _lz = lowerLimit.z;\n    double _lw = lowerLimit.w;\n    double _ux = upperLimit.x;\n    double _uy = upperLimit.y;\n    double _uz = upperLimit.z;\n    double _uw = upperLimit.w;\n    double _x = x;\n    double _y = y;\n    double _z = z;\n    double _w = w;\n    // MAX(MIN(self, upper), lower).\n    _x = _x > _ux ? _ux : _x;\n    _y = _y > _uy ? _uy : _y;\n    _z = _z > _uz ? _uz : _z;\n    _w = _w > _uw ? _uw : _w;\n    _x = _x < _lx ? _lx : _x;\n    _y = _y < _ly ? _ly : _y;\n    _z = _z < _lz ? _lz : _z;\n    _w = _w < _lw ? _lw : _w;\n    return new NativeFloat32x4._truncated(_x, _y, _z, _w);\n  }\n\n  /// Extract the sign bit from each lane return them in the first 4 bits.\n  int get signMask {\n    var view = _uint32view;\n    var mx, my, mz, mw;\n    _list[0] = x;\n    _list[1] = y;\n    _list[2] = z;\n    _list[3] = w;\n    // This is correct because dart2js uses the unsigned right shift.\n    mx = (view[0] & 0x80000000) >> 31;\n    my = (view[1] & 0x80000000) >> 30;\n    mz = (view[2] & 0x80000000) >> 29;\n    mw = (view[3] & 0x80000000) >> 28;\n    return mx | my | mz | mw;\n  }\n\n  /// Shuffle the lane values. [mask] must be one of the 256 shuffle constants.\n  Float32x4 shuffle(int m) {\n    if ((m < 0) || (m > 255)) {\n      throw new RangeError('mask $m must be in the range [0..256)');\n    }\n    _list[0] = x;\n    _list[1] = y;\n    _list[2] = z;\n    _list[3] = w;\n\n    double _x = _list[m & 0x3];\n    double _y = _list[(m >> 2) & 0x3];\n    double _z = _list[(m >> 4) & 0x3];\n    double _w = _list[(m >> 6) & 0x3];\n    return new NativeFloat32x4._truncated(_x, _y, _z, _w);\n  }\n\n  /// Shuffle the lane values in [this] and [other]. The returned\n  /// Float32x4 will have XY lanes from [this] and ZW lanes from [other].\n  /// Uses the same [mask] as [shuffle].\n  Float32x4 shuffleMix(Float32x4 other, int m) {\n    if ((m < 0) || (m > 255)) {\n      throw new RangeError('mask $m must be in the range [0..256)');\n    }\n    _list[0] = x;\n    _list[1] = y;\n    _list[2] = z;\n    _list[3] = w;\n    double _x = _list[m & 0x3];\n    double _y = _list[(m >> 2) & 0x3];\n\n    _list[0] = other.x;\n    _list[1] = other.y;\n    _list[2] = other.z;\n    _list[3] = other.w;\n    double _z = _list[(m >> 4) & 0x3];\n    double _w = _list[(m >> 6) & 0x3];\n    return new NativeFloat32x4._truncated(_x, _y, _z, _w);\n  }\n\n  /// Copy [this] and replace the [x] lane.\n  Float32x4 withX(double newX) {\n    return new NativeFloat32x4._truncated(_truncate(newX), y, z, w);\n  }\n\n  /// Copy [this] and replace the [y] lane.\n  Float32x4 withY(double newY) {\n    return new NativeFloat32x4._truncated(x, _truncate(newY), z, w);\n  }\n\n  /// Copy [this] and replace the [z] lane.\n  Float32x4 withZ(double newZ) {\n    return new NativeFloat32x4._truncated(x, y, _truncate(newZ), w);\n  }\n\n  /// Copy [this] and replace the [w] lane.\n  Float32x4 withW(double newW) {\n    return new NativeFloat32x4._truncated(x, y, z, _truncate(newW));\n  }\n\n  /// Returns the lane-wise minimum value in [this] or [other].\n  Float32x4 min(Float32x4 other) {\n    double _x = x < other.x ? x : other.x;\n    double _y = y < other.y ? y : other.y;\n    double _z = z < other.z ? z : other.z;\n    double _w = w < other.w ? w : other.w;\n    return new NativeFloat32x4._truncated(_x, _y, _z, _w);\n  }\n\n  /// Returns the lane-wise maximum value in [this] or [other].\n  Float32x4 max(Float32x4 other) {\n    double _x = x > other.x ? x : other.x;\n    double _y = y > other.y ? y : other.y;\n    double _z = z > other.z ? z : other.z;\n    double _w = w > other.w ? w : other.w;\n    return new NativeFloat32x4._truncated(_x, _y, _z, _w);\n  }\n\n  /// Returns the square root of [this].\n  Float32x4 sqrt() {\n    double _x = Math.sqrt(x);\n    double _y = Math.sqrt(y);\n    double _z = Math.sqrt(z);\n    double _w = Math.sqrt(w);\n    return new NativeFloat32x4._doubles(_x, _y, _z, _w);\n  }\n\n  /// Returns the reciprocal of [this].\n  Float32x4 reciprocal() {\n    double _x = 1.0 / x;\n    double _y = 1.0 / y;\n    double _z = 1.0 / z;\n    double _w = 1.0 / w;\n    return new NativeFloat32x4._doubles(_x, _y, _z, _w);\n  }\n\n  /// Returns the square root of the reciprocal of [this].\n  Float32x4 reciprocalSqrt() {\n    double _x = Math.sqrt(1.0 / x);\n    double _y = Math.sqrt(1.0 / y);\n    double _z = Math.sqrt(1.0 / z);\n    double _w = Math.sqrt(1.0 / w);\n    return new NativeFloat32x4._doubles(_x, _y, _z, _w);\n  }\n}\n\n\n/**\n * Interface of Dart Int32x4 and operations.\n * Int32x4 stores 4 32-bit bit-masks in \"lanes\".\n * The lanes are \"x\", \"y\", \"z\", and \"w\" respectively.\n */\nclass NativeInt32x4 implements Int32x4 {\n  final int x;\n  final int y;\n  final int z;\n  final int w;\n\n  static final _list = new NativeInt32List(4);\n\n  static _truncate(x) {\n    _list[0] = x;\n    return _list[0];\n  }\n\n  NativeInt32x4(int x, int y, int z, int w)\n    : this.x = _truncate(x),\n      this.y = _truncate(y),\n      this.z = _truncate(z),\n      this.w = _truncate(w) {\n    if (x != this.x && x is! int) throw new ArgumentError(x);\n    if (y != this.y && y is! int) throw new ArgumentError(y);\n    if (z != this.z && z is! int) throw new ArgumentError(z);\n    if (w != this.w && w is! int) throw new ArgumentError(w);\n  }\n\n  NativeInt32x4.bool(bool x, bool y, bool z, bool w)\n    : this.x = x ? -1 : 0,\n      this.y = y ? -1 : 0,\n      this.z = z ? -1 : 0,\n      this.w = w ? -1 : 0;\n\n  /// Returns a bit-wise copy of [f] as a Int32x4.\n  factory NativeInt32x4.fromFloat32x4Bits(Float32x4 f) {\n    NativeFloat32List floatList = NativeFloat32x4._list;\n    floatList[0] = f.x;\n    floatList[1] = f.y;\n    floatList[2] = f.z;\n    floatList[3] = f.w;\n    NativeInt32List view = floatList.buffer.asInt32List();\n    return new NativeInt32x4._truncated(view[0], view[1], view[2], view[3]);\n  }\n\n  NativeInt32x4._truncated(this.x, this.y, this.z, this.w);\n\n  String toString() => '[$x, $y, $z, $w]';\n\n\n  /// The bit-wise or operator.\n  Int32x4 operator|(Int32x4 other) {\n    // Dart2js uses unsigned results for bit-operations.\n    // We use \"JS\" to fall back to the signed versions.\n    return new NativeInt32x4._truncated(JS(\"int\", \"# | #\", x, other.x),\n                                        JS(\"int\", \"# | #\", y, other.y),\n                                        JS(\"int\", \"# | #\", z, other.z),\n                                        JS(\"int\", \"# | #\", w, other.w));\n  }\n\n  /// The bit-wise and operator.\n  Int32x4 operator&(Int32x4 other) {\n    // Dart2js uses unsigned results for bit-operations.\n    // We use \"JS\" to fall back to the signed versions.\n    return new NativeInt32x4._truncated(JS(\"int\", \"# & #\", x, other.x),\n                                        JS(\"int\", \"# & #\", y, other.y),\n                                        JS(\"int\", \"# & #\", z, other.z),\n                                        JS(\"int\", \"# & #\", w, other.w));\n  }\n\n  /// The bit-wise xor operator.\n  Int32x4 operator^(Int32x4 other) {\n    // Dart2js uses unsigned results for bit-operations.\n    // We use \"JS\" to fall back to the signed versions.\n    return new NativeInt32x4._truncated(JS(\"int\", \"# ^ #\", x, other.x),\n                                        JS(\"int\", \"# ^ #\", y, other.y),\n                                        JS(\"int\", \"# ^ #\", z, other.z),\n                                        JS(\"int\", \"# ^ #\", w, other.w));\n  }\n\n  Int32x4 operator+(Int32x4 other) {\n    // Avoid going through the typed array by \"| 0\" the result.\n    return new NativeInt32x4._truncated(JS(\"int\", \"(# + #) | 0\", x, other.x),\n                                        JS(\"int\", \"(# + #) | 0\", y, other.y),\n                                        JS(\"int\", \"(# + #) | 0\", z, other.z),\n                                        JS(\"int\", \"(# + #) | 0\", w, other.w));\n  }\n\n  Int32x4 operator-(Int32x4 other) {\n    // Avoid going through the typed array by \"| 0\" the result.\n    return new NativeInt32x4._truncated(JS(\"int\", \"(# - #) | 0\", x, other.x),\n                                        JS(\"int\", \"(# - #) | 0\", y, other.y),\n                                        JS(\"int\", \"(# - #) | 0\", z, other.z),\n                                        JS(\"int\", \"(# - #) | 0\", w, other.w));\n  }\n\n  Int32x4 operator-() {\n    // Avoid going through the typed array by \"| 0\" the result.\n    return new NativeInt32x4._truncated(JS(\"int\", \"(-#) | 0\", x),\n                                        JS(\"int\", \"(-#) | 0\", y),\n                                        JS(\"int\", \"(-#) | 0\", z),\n                                        JS(\"int\", \"(-#) | 0\", w));\n  }\n\n  /// Extract the top bit from each lane return them in the first 4 bits.\n  int get signMask {\n    int mx = (x & 0x80000000) >> 31;\n    int my = (y & 0x80000000) >> 31;\n    int mz = (z & 0x80000000) >> 31;\n    int mw = (w & 0x80000000) >> 31;\n    return mx | my << 1 | mz << 2 | mw << 3;\n  }\n\n  /// Shuffle the lane values. [mask] must be one of the 256 shuffle constants.\n  Int32x4 shuffle(int mask) {\n    if ((mask < 0) || (mask > 255)) {\n      throw new RangeError('mask $mask must be in the range [0..256)');\n    }\n    _list[0] = x;\n    _list[1] = y;\n    _list[2] = z;\n    _list[3] = w;\n    int _x = _list[mask & 0x3];\n    int _y = _list[(mask >> 2) & 0x3];\n    int _z = _list[(mask >> 4) & 0x3];\n    int _w = _list[(mask >> 6) & 0x3];\n    return new NativeInt32x4._truncated(_x, _y, _z, _w);\n  }\n\n  /// Shuffle the lane values in [this] and [other]. The returned\n  /// Int32x4 will have XY lanes from [this] and ZW lanes from [other].\n  /// Uses the same [mask] as [shuffle].\n  Int32x4 shuffleMix(Int32x4 other, int mask) {\n    if ((mask < 0) || (mask > 255)) {\n      throw new RangeError('mask $mask must be in the range [0..256)');\n    }\n    _list[0] = x;\n    _list[1] = y;\n    _list[2] = z;\n    _list[3] = w;\n    int _x = _list[mask & 0x3];\n    int _y = _list[(mask >> 2) & 0x3];\n\n    _list[0] = other.x;\n    _list[1] = other.y;\n    _list[2] = other.z;\n    _list[3] = other.w;\n    int _z = _list[(mask >> 4) & 0x3];\n    int _w = _list[(mask >> 6) & 0x3];\n    return new NativeInt32x4._truncated(_x, _y, _z, _w);\n  }\n\n  /// Returns a new [Int32x4] copied from [this] with a new x value.\n  Int32x4 withX(int x) {\n    int _x = _truncate(x);\n    return new NativeInt32x4._truncated(_x, y, z, w);\n  }\n\n  /// Returns a new [Int32x4] copied from [this] with a new y value.\n  Int32x4 withY(int y) {\n    int _y = _truncate(y);\n    return new NativeInt32x4._truncated(x, _y, z, w);\n  }\n\n  /// Returns a new [Int32x4] copied from [this] with a new z value.\n  Int32x4 withZ(int z) {\n    int _z = _truncate(z);\n    return new NativeInt32x4._truncated(x, y, _z, w);\n  }\n\n  /// Returns a new [Int32x4] copied from [this] with a new w value.\n  Int32x4 withW(int w) {\n    int _w = _truncate(w);\n    return new NativeInt32x4._truncated(x, y, z, _w);\n  }\n\n  /// Extracted x value. Returns `false` for 0, `true` for any other value.\n  bool get flagX => x != 0;\n  /// Extracted y value. Returns `false` for 0, `true` for any other value.\n  bool get flagY => y != 0;\n  /// Extracted z value. Returns `false` for 0, `true` for any other value.\n  bool get flagZ => z != 0;\n  /// Extracted w value. Returns `false` for 0, `true` for any other value.\n  bool get flagW => w != 0;\n\n  /// Returns a new [Int32x4] copied from [this] with a new x value.\n  Int32x4 withFlagX(bool flagX) {\n    int _x = flagX ? -1 : 0;\n    return new NativeInt32x4._truncated(_x, y, z, w);\n  }\n\n  /// Returns a new [Int32x4] copied from [this] with a new y value.\n  Int32x4 withFlagY(bool flagY) {\n    int _y = flagY ? -1 : 0;\n    return new NativeInt32x4._truncated(x, _y, z, w);\n  }\n\n  /// Returns a new [Int32x4] copied from [this] with a new z value.\n  Int32x4 withFlagZ(bool flagZ) {\n    int _z = flagZ ? -1 : 0;\n    return new NativeInt32x4._truncated(x, y, _z, w);\n  }\n\n  /// Returns a new [Int32x4] copied from [this] with a new w value.\n  Int32x4 withFlagW(bool flagW) {\n    int _w = flagW ? -1 : 0;\n    return new NativeInt32x4._truncated(x, y, z, _w);\n  }\n\n  /// Merge [trueValue] and [falseValue] based on [this]' bit mask:\n  /// Select bit from [trueValue] when bit in [this] is on.\n  /// Select bit from [falseValue] when bit in [this] is off.\n  Float32x4 select(Float32x4 trueValue, Float32x4 falseValue) {\n    var floatList = NativeFloat32x4._list;\n    var intView = NativeFloat32x4._uint32view;\n\n    floatList[0] = trueValue.x;\n    floatList[1] = trueValue.y;\n    floatList[2] = trueValue.z;\n    floatList[3] = trueValue.w;\n    int stx = intView[0];\n    int sty = intView[1];\n    int stz = intView[2];\n    int stw = intView[3];\n\n    floatList[0] = falseValue.x;\n    floatList[1] = falseValue.y;\n    floatList[2] = falseValue.z;\n    floatList[3] = falseValue.w;\n    int sfx = intView[0];\n    int sfy = intView[1];\n    int sfz = intView[2];\n    int sfw = intView[3];\n    int _x = (x & stx) | (~x & sfx);\n    int _y = (y & sty) | (~y & sfy);\n    int _z = (z & stz) | (~z & sfz);\n    int _w = (w & stw) | (~w & sfw);\n    intView[0] = _x;\n    intView[1] = _y;\n    intView[2] = _z;\n    intView[3] = _w;\n    return new NativeFloat32x4._truncated(\n        floatList[0], floatList[1], floatList[2], floatList[3]);\n  }\n}\n\nclass NativeFloat64x2 implements Float64x2 {\n  final double x;\n  final double y;\n\n  static NativeFloat64List _list = new NativeFloat64List(2);\n  static NativeUint32List _uint32View = _list.buffer.asUint32List();\n\n  NativeFloat64x2(this.x, this.y) {\n    if (x is! num) throw new ArgumentError(x);\n    if (y is! num) throw new ArgumentError(y);\n  }\n\n  NativeFloat64x2.splat(double v) : this(v, v);\n\n  NativeFloat64x2.zero() : this.splat(0.0);\n\n  NativeFloat64x2.fromFloat32x4(Float32x4 v) : this(v.x, v.y);\n\n  /// Arguments [x] and [y] must be doubles.\n  NativeFloat64x2._doubles(this.x, this.y);\n\n  String toString() => '[$x, $y]';\n\n  /// Addition operator.\n  Float64x2 operator+(Float64x2 other) {\n    return new NativeFloat64x2._doubles(x + other.x, y + other.y);\n  }\n\n  /// Negate operator.\n  Float64x2 operator-() {\n    return new NativeFloat64x2._doubles(-x, -y);\n  }\n\n  /// Subtraction operator.\n  Float64x2 operator-(Float64x2 other) {\n    return new NativeFloat64x2._doubles(x - other.x, y - other.y);\n  }\n  /// Multiplication operator.\n  Float64x2 operator*(Float64x2 other) {\n    return new NativeFloat64x2._doubles(x * other.x, y * other.y);\n  }\n  /// Division operator.\n  Float64x2 operator/(Float64x2 other) {\n    return new NativeFloat64x2._doubles(x / other.x, y / other.y);\n  }\n\n  /// Returns a copy of [this] each lane being scaled by [s].\n  Float64x2 scale(double s) {\n    return new NativeFloat64x2._doubles(x * s, y * s);\n  }\n\n  /// Returns the absolute value of this [Float64x2].\n  Float64x2 abs() {\n    return new NativeFloat64x2._doubles(x.abs(), y.abs());\n  }\n\n  /// Clamps [this] to be in the range [lowerLimit]-[upperLimit].\n  Float64x2 clamp(Float64x2 lowerLimit,\n                  Float64x2 upperLimit) {\n    double _lx = lowerLimit.x;\n    double _ly = lowerLimit.y;\n    double _ux = upperLimit.x;\n    double _uy = upperLimit.y;\n    double _x = x;\n    double _y = y;\n    // MAX(MIN(self, upper), lower).\n    _x = _x > _ux ? _ux : _x;\n    _y = _y > _uy ? _uy : _y;\n    _x = _x < _lx ? _lx : _x;\n    _y = _y < _ly ? _ly : _y;\n    return new NativeFloat64x2._doubles(_x, _y);\n  }\n\n  /// Extract the sign bits from each lane return them in the first 2 bits.\n  int get signMask {\n    var view = _uint32View;\n    _list[0] = x;\n    _list[1] = y;\n    var mx = (view[1] & 0x80000000) >> 31;\n    var my = (view[3] & 0x80000000) >> 31;\n    return mx | my << 1;\n  }\n\n  /// Returns a new [Float64x2] copied from [this] with a new x value.\n  Float64x2 withX(double x) {\n    if (x is! num) throw new ArgumentError(x);\n    return new NativeFloat64x2._doubles(x, y);\n  }\n\n  /// Returns a new [Float64x2] copied from [this] with a new y value.\n  Float64x2 withY(double y) {\n    if (y is! num) throw new ArgumentError(y);\n    return new NativeFloat64x2._doubles(x, y);\n  }\n\n  /// Returns the lane-wise minimum value in [this] or [other].\n  Float64x2 min(Float64x2 other) {\n    return new NativeFloat64x2._doubles(x < other.x ? x : other.x,\n                                        y < other.y ? y : other.y);\n\n  }\n\n  /// Returns the lane-wise maximum value in [this] or [other].\n  Float64x2 max(Float64x2 other) {\n    return new NativeFloat64x2._doubles(x > other.x ? x : other.x,\n                                        y > other.y ? y : other.y);\n  }\n\n  /// Returns the lane-wise square root of [this].\n  Float64x2 sqrt() {\n      return new NativeFloat64x2._doubles(Math.sqrt(x), Math.sqrt(y));\n  }\n}\n\u0000","sdk:/sdk/lib/typed_data/typed_data.dart":"// Copyright (c) 2013, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\nlibrary dart.typed_data;\n\nimport 'dart:collection';\n\n/**\n * A sequence of bytes underlying a typed data object.\n * Used to process large quantities of binary or numerical data\n * more efficiently using a typed view.\n */\nabstract class ByteBuffer {\n  /**\n   * Returns the length of this byte buffer, in bytes.\n   */\n  int get lengthInBytes;\n\n  /**\n   * Creates a new [Uint8List] view of this buffer.\n   */\n  Uint8List asUint8List([int offsetInBytes = 0, int length]);\n  /**\n   * Creates a new [Int8List] view of this buffer.\n   */\n  Int8List asInt8List([int offsetInBytes = 0, int length]);\n  /**\n   * Creates a new [Uint8Clamped] view of this buffer.\n   */\n  Uint8ClampedList asUint8ClampedList([int offsetInBytes = 0, int length]);\n  /**\n   * Creates a new [Uint16List] view of this buffer.\n   */\n  Uint16List asUint16List([int offsetInBytes = 0, int length]);\n  /**\n   * Creates a new [Int16List] view of this buffer.\n   */\n  Int16List asInt16List([int offsetInBytes = 0, int length]);\n  /**\n   * Creates a new [Uint32List] view of this buffer.\n   */\n  Uint32List asUint32List([int offsetInBytes = 0, int length]);\n  /**\n   * Creates a new [Int32List] view of this buffer.\n   */\n  Int32List asInt32List([int offsetInBytes = 0, int length]);\n  /**\n   * Creates a new [Uint64List] view of this buffer.\n   */\n  Uint64List asUint64List([int offsetInBytes = 0, int length]);\n  /**\n   * Creates a new [Int64List] view of this buffer.\n   */\n  Int64List asInt64List([int offsetInBytes = 0, int length]);\n  /**\n   * Creates a new [Int32x4List] view of this buffer.\n   */\n  Int32x4List asInt32x4List([int offsetInBytes = 0, int length]);\n  /**\n   * Creates a new [Float32List] view of this buffer.\n   */\n  Float32List asFloat32List([int offsetInBytes = 0, int length]);\n  /**\n   * Creates a new [Float64List] view of this buffer.\n   */\n  Float64List asFloat64List([int offsetInBytes = 0, int length]);\n  /**\n   * Creates a new [Float32x4List] view of this buffer.\n   */\n  Float32x4List asFloat32x4List([int offsetInBytes = 0, int length]);\n  /**\n   * Creates a new [Float64x2List] view of this buffer.\n   */\n  Float64x2List asFloat64x2List([int offsetInBytes = 0, int length]);\n  /**\n   * Creates a new [ByteData] view of this buffer.\n   */\n  ByteData asByteData([int offsetInBytes = 0, int length]);\n}\n\n\n/**\n * A typed view of a sequence of bytes.\n */\nabstract class TypedData {\n  /**\n   * Returns the number of bytes in the representation of each element in this\n   * list.\n   */\n  int get elementSizeInBytes;\n\n  /**\n   * Returns the offset in bytes into the underlying byte buffer of this view.\n   */\n  int get offsetInBytes;\n\n  /**\n   * Returns the length of this view, in bytes.\n   */\n  int get lengthInBytes;\n\n  /**\n   * Returns the byte buffer associated with this object.\n   */\n  ByteBuffer get buffer;\n}\n\n\n/**\n * Describes endianness to be used when accessing or updating a\n * sequence of bytes.\n */\nclass Endianness {\n  const Endianness._(this._littleEndian);\n\n  static const Endianness BIG_ENDIAN = const Endianness._(false);\n  static const Endianness LITTLE_ENDIAN = const Endianness._(true);\n  static final Endianness HOST_ENDIAN =\n    (new ByteData.view(new Uint16List.fromList([1]).buffer)).getInt8(0) == 1 ?\n    LITTLE_ENDIAN : BIG_ENDIAN;\n\n  final bool _littleEndian;\n}\n\n\n/**\n * A fixed-length, random-access sequence of bytes that also provides random\n * and unaligned access to the fixed-width integers and floating point\n * numbers represented by those bytes.\n * ByteData may be used to pack and unpack data from external sources\n * (such as networks or files systems), and to process large quantities\n * of numerical data more efficiently than would be possible\n * with ordinary [List] implementations. ByteData can save space, by\n * eliminating the need for object headers, and time, by eliminating the\n * need for data copies. Finally, ByteData may be used to intentionally\n * reinterpret the bytes representing one arithmetic type as another.\n * For example this code fragment determine what 32-bit signed integer\n * is represented by the bytes of a 32-bit floating point number:\n *\n *     var buffer = new Uint8List(8).buffer;\n *     var bdata = new ByteData.view(buffer);\n *     bdata.setFloat32(0, 3.04);\n *     int huh = bdata.getInt32(0);\n */\nabstract class ByteData implements TypedData {\n  /**\n   * Creates a [ByteData] of the specified length (in elements), all of\n   * whose elements are initially zero.\n   */\n  external factory ByteData(int length);\n\n  /**\n   * Creates an [ByteData] _view_ of the specified region in the specified\n   * byte buffer. Changes in the [ByteData] will be visible in the byte\n   * buffer and vice versa. If the [offsetInBytes] index of the region is not\n   * specified, it defaults to zero (the first byte in the byte buffer).\n   * If the length is not specified, it defaults to null, which indicates\n   * that the view extends to the end of the byte buffer.\n   *\n   * Throws [RangeError] if [offsetInBytes] or [length] are negative, or\n   * if [offsetInBytes] + ([length] * elementSizeInBytes) is greater than\n   * the length of [buffer].\n   */\n  factory ByteData.view(ByteBuffer buffer,\n                        [int offsetInBytes = 0, int length]) {\n    return buffer.asByteData(offsetInBytes, length);\n  }\n\n  /**\n   * Returns the (possibly negative) integer represented by the byte at the\n   * specified [byteOffset] in this object, in two's complement binary\n   * representation. The return value will be between -128 and 127, inclusive.\n   *\n   * Throws [RangeError] if [byteOffset] is negative, or\n   * greater than or equal to the length of this object.\n   */\n  int getInt8(int byteOffset);\n\n  /**\n   * Sets the byte at the specified [byteOffset] in this object to the\n   * two's complement binary representation of the specified [value], which\n   * must fit in a single byte. In other words, [value] must be between\n   * -128 and 127, inclusive.\n   *\n   * Throws [RangeError] if [byteOffset] is negative, or\n   * greater than or equal to the length of this object.\n   */\n  void setInt8(int byteOffset, int value);\n\n  /**\n   * Returns the positive integer represented by the byte at the specified\n   * [byteOffset] in this object, in unsigned binary form. The\n   * return value will be between 0 and 255, inclusive.\n   *\n   * Throws [RangeError] if [byteOffset] is negative, or\n   * greater than or equal to the length of this object.\n   */\n  int getUint8(int byteOffset);\n\n  /**\n   * Sets the byte at the specified [byteOffset] in this object to the\n   * unsigned binary representation of the specified [value], which must fit\n   * in a single byte. in other words, [value] must be between 0 and 255,\n   * inclusive.\n   *\n   * Throws [RangeError] if [byteOffset] is negative,\n   * or greater than or equal to the length of this object.\n   */\n  void setUint8(int byteOffset, int value);\n\n  /**\n   * Returns the (possibly negative) integer represented by the two bytes at\n   * the specified [byteOffset] in this object, in two's complement binary\n   * form.\n   * The return value will be between 2<sup>15</sup> and 2<sup>15</sup> - 1,\n   * inclusive.\n   *\n   * Throws [RangeError] if [byteOffset] is negative, or\n   * `byteOffset + 2` is greater than the length of this object.\n   */\n  int getInt16(int byteOffset, [Endianness endian = Endianness.BIG_ENDIAN]);\n\n  /**\n   * Sets the two bytes starting at the specified [byteOffset] in this\n   * object to the two's complement binary representation of the specified\n   * [value], which must fit in two bytes. In other words, [value] must lie\n   * between 2<sup>15</sup> and 2<sup>15</sup> - 1, inclusive.\n   *\n   * Throws [RangeError] if [byteOffset] is negative, or\n   * `byteOffset + 2` is greater than the length of this object.\n   */\n  void setInt16(int byteOffset,\n                int value,\n                [Endianness endian = Endianness.BIG_ENDIAN]);\n\n  /**\n   * Returns the positive integer represented by the two bytes starting\n   * at the specified [byteOffset] in this object, in unsigned binary\n   * form.\n   * The return value will be between 0 and  2<sup>16</sup> - 1, inclusive.\n   *\n   * Throws [RangeError] if [byteOffset] is negative, or\n   * `byteOffset + 2` is greater than the length of this object.\n   */\n  int getUint16(int byteOffset, [Endianness endian = Endianness.BIG_ENDIAN]);\n\n  /**\n   * Sets the two bytes starting at the specified [byteOffset] in this object\n   * to the unsigned binary representation of the specified [value],\n   * which must fit in two bytes. in other words, [value] must be between\n   * 0 and 2<sup>16</sup> - 1, inclusive.\n   *\n   * Throws [RangeError] if [byteOffset] is negative, or\n   * `byteOffset + 2` is greater than the length of this object.\n   */\n  void setUint16(int byteOffset,\n                 int value,\n                 [Endianness endian = Endianness.BIG_ENDIAN]);\n\n  /**\n   * Returns the (possibly negative) integer represented by the four bytes at\n   * the specified [byteOffset] in this object, in two's complement binary\n   * form.\n   * The return value will be between 2<sup>31</sup> and 2<sup>31</sup> - 1,\n   * inclusive.\n   *\n   * Throws [RangeError] if [byteOffset] is negative, or\n   * `byteOffset + 4` is greater than the length of this object.\n   */\n  int getInt32(int byteOffset, [Endianness endian = Endianness.BIG_ENDIAN]);\n\n  /**\n   * Sets the four bytes starting at the specified [byteOffset] in this\n   * object to the two's complement binary representation of the specified\n   * [value], which must fit in four bytes. In other words, [value] must lie\n   * between 2<sup>31</sup> and 2<sup>31</sup> - 1, inclusive.\n   *\n   * Throws [RangeError] if [byteOffset] is negative, or\n   * `byteOffset + 4` is greater than the length of this object.\n   */\n  void setInt32(int byteOffset,\n                int value,\n                [Endianness endian = Endianness.BIG_ENDIAN]);\n\n  /**\n   * Returns the positive integer represented by the four bytes starting\n   * at the specified [byteOffset] in this object, in unsigned binary\n   * form.\n   * The return value will be between 0 and  2<sup>32</sup> - 1, inclusive.\n   *\n   * Throws [RangeError] if [byteOffset] is negative, or\n   * `byteOffset + 4` is greater than the length of this object.\n   */\n  int getUint32(int byteOffset, [Endianness endian = Endianness.BIG_ENDIAN]);\n\n  /**\n   * Sets the four bytes starting at the specified [byteOffset] in this object\n   * to the unsigned binary representation of the specified [value],\n   * which must fit in four bytes. in other words, [value] must be between\n   * 0 and 2<sup>32</sup> - 1, inclusive.\n   *\n   * Throws [RangeError] if [byteOffset] is negative, or\n   * `byteOffset + 4` is greater than the length of this object.\n   */\n  void setUint32(int byteOffset,\n                 int value,\n                 [Endianness endian = Endianness.BIG_ENDIAN]);\n\n  /**\n   * Returns the (possibly negative) integer represented by the eight bytes at\n   * the specified [byteOffset] in this object, in two's complement binary\n   * form.\n   * The return value will be between 2<sup>63</sup> and 2<sup>63</sup> - 1,\n   * inclusive.\n   *\n   * Throws [RangeError] if [byteOffset] is negative, or\n   * `byteOffset + 8` is greater than the length of this object.\n   */\n  int getInt64(int byteOffset, [Endianness endian = Endianness.BIG_ENDIAN]);\n\n  /**\n   * Sets the eight bytes starting at the specified [byteOffset] in this\n   * object to the two's complement binary representation of the specified\n   * [value], which must fit in eight bytes. In other words, [value] must lie\n   * between 2<sup>63</sup> and 2<sup>63</sup> - 1, inclusive.\n   *\n   * Throws [RangeError] if [byteOffset] is negative, or\n   * `byteOffset + 8` is greater than the length of this object.\n   */\n  void setInt64(int byteOffset,\n                int value,\n                [Endianness endian = Endianness.BIG_ENDIAN]);\n\n  /**\n   * Returns the positive integer represented by the eight bytes starting\n   * at the specified [byteOffset] in this object, in unsigned binary\n   * form.\n   * The return value will be between 0 and  2<sup>64</sup> - 1, inclusive.\n   *\n   * Throws [RangeError] if [byteOffset] is negative, or\n   * `byteOffset + 8` is greater than the length of this object.\n   */\n  int getUint64(int byteOffset, [Endianness endian = Endianness.BIG_ENDIAN]);\n\n  /**\n   * Sets the eight bytes starting at the specified [byteOffset] in this object\n   * to the unsigned binary representation of the specified [value],\n   * which must fit in eight bytes. in other words, [value] must be between\n   * 0 and 2<sup>64</sup> - 1, inclusive.\n   *\n   * Throws [RangeError] if [byteOffset] is negative, or\n   * `byteOffset + 8` is greater than the length of this object.\n   */\n  void setUint64(int byteOffset,\n                 int value,\n                 [Endianness endian = Endianness.BIG_ENDIAN]);\n\n  /**\n   * Returns the floating point number represented by the four bytes at\n   * the specified [byteOffset] in this object, in IEEE 754\n   * single-precision binary floating-point format (binary32).\n   *\n   * Throws [RangeError] if [byteOffset] is negative, or\n   * `byteOffset + 4` is greater than the length of this object.\n   */\n  double getFloat32(int byteOffset,\n                    [Endianness endian = Endianness.BIG_ENDIAN]);\n\n  /**\n   * Sets the four bytes starting at the specified [byteOffset] in this\n   * object to the IEEE 754 single-precision binary floating-point\n   * (binary32) representation of the specified [value].\n   *\n   * **Note that this method can lose precision.** The input [value] is\n   * a 64-bit floating point value, which will be converted to 32-bit\n   * floating point value by IEEE 754 rounding rules before it is stored.\n   * If [value] cannot be represented exactly as a binary32, it will be\n   * converted to the nearest binary32 value.  If two binary32 values are\n   * equally close, the one whose least significant bit is zero will be used.\n   * Note that finite (but large) values can be converted to infinity, and\n   * small non-zero values can be converted to zero.\n   *\n   * Throws [RangeError] if [byteOffset] is negative, or\n   * `byteOffset + 4` is greater than the length of this object.\n   */\n  void setFloat32(int byteOffset,\n                  double value,\n                  [Endianness endian = Endianness.BIG_ENDIAN]);\n\n  /**\n   * Returns the floating point number represented by the eight bytes at\n   * the specified [byteOffset] in this object, in IEEE 754\n   * double-precision binary floating-point format (binary64).\n   *\n   * Throws [RangeError] if [byteOffset] is negative, or\n   * `byteOffset + 8` is greater than the length of this object.\n   */\n  double getFloat64(int byteOffset,\n                    [Endianness endian = Endianness.BIG_ENDIAN]);\n\n  /**\n   * Sets the eight bytes starting at the specified [byteOffset] in this\n   * object to the IEEE 754 double-precision binary floating-point\n   * (binary64) representation of the specified [value].\n   *\n   * Throws [RangeError] if [byteOffset] is negative, or\n   * `byteOffset + 8` is greater than the length of this object.\n   */\n  void setFloat64(int byteOffset,\n                  double value,\n                  [Endianness endian = Endianness.BIG_ENDIAN]);\n}\n\n\n/**\n * A fixed-length list of 8-bit signed integers.\n * For long lists, this implementation can be considerably\n * more space- and time-efficient than the default [List] implementation.\n */\nabstract class Int8List implements List<int>, TypedData {\n  /**\n   * Creates an [Int8List] of the specified length (in elements), all of\n   * whose elements are initially zero.\n   */\n  external factory Int8List(int length);\n\n  /**\n   * Creates a [Int8List] with the same length as the [elements] list\n   * and copies over the elements.\n   */\n  external factory Int8List.fromList(List<int> elements);\n\n  /**\n   * Creates an [Int8List] _view_ of the specified region in the specified\n   * byte buffer. Changes in the [Int8List] will be visible in the byte\n   * buffer and vice versa. If the [offsetInBytes] index of the region is not\n   * specified, it defaults to zero (the first byte in the byte buffer).\n   * If the length is not specified, it defaults to null, which indicates\n   * that the view extends to the end of the byte buffer.\n   *\n   * Throws [RangeError] if [offsetInBytes] or [length] are negative, or\n   * if [offsetInBytes] + ([length] * elementSizeInBytes) is greater than\n   * the length of [buffer].\n   */\n  factory Int8List.view(ByteBuffer buffer,\n                        [int offsetInBytes = 0, int length]) {\n    return buffer.asInt8List(offsetInBytes, length);\n  }\n\n  static const int BYTES_PER_ELEMENT = 1;\n}\n\n\n/**\n * A fixed-length list of 8-bit unsigned integers.\n * For long lists, this implementation can be considerably\n * more space- and time-efficient than the default [List] implementation.\n */\nabstract class Uint8List implements List<int>, TypedData {\n  /**\n   * Creates a [Uint8List] of the specified length (in elements), all of\n   * whose elements are initially zero.\n   */\n  external factory Uint8List(int length);\n\n  /**\n   * Creates a [Uint8List] with the same length as the [elements] list\n   * and copies over the elements.\n   */\n  external factory Uint8List.fromList(List<int> elements);\n\n  /**\n   * Creates a [Uint8List] _view_ of the specified region in the specified\n   * byte buffer. Changes in the [Uint8List] will be visible in the byte\n   * buffer and vice versa. If the [offsetInBytes] index of the region is not\n   * specified, it defaults to zero (the first byte in the byte buffer).\n   * If the length is not specified, it defaults to null, which indicates\n   * that the view extends to the end of the byte buffer.\n   *\n   * Throws [RangeError] if [offsetInBytes] or [length] are negative, or\n   * if [offsetInBytes] + ([length] * elementSizeInBytes) is greater than\n   * the length of [buffer].\n   */\n  factory Uint8List.view(ByteBuffer buffer,\n                         [int offsetInBytes = 0, int length]) {\n    return buffer.asUint8List(offsetInBytes, length);\n  }\n\n  static const int BYTES_PER_ELEMENT = 1;\n}\n\n\n/**\n * A fixed-length list of 8-bit unsigned integers.\n * For long lists, this implementation can be considerably\n * more space- and time-efficient than the default [List] implementation.\n * Indexed store clamps the value to range 0..0xFF.\n */\nabstract class Uint8ClampedList implements List<int>, TypedData {\n  /**\n   * Creates a [Uint8ClampedList] of the specified length (in elements), all of\n   * whose elements are initially zero.\n   */\n  external factory Uint8ClampedList(int length);\n\n  /**\n   * Creates a [Uint8ClampedList] of the same size as the [elements]\n   * list and copies over the values clamping when needed.\n   */\n  external factory Uint8ClampedList.fromList(List<int> elements);\n\n  /**\n   * Creates a [Uint8ClampedList] _view_ of the specified region in the\n   * specified byte [buffer]. Changes in the [Uint8List] will be visible in the\n   * byte buffer and vice versa. If the [offsetInBytes] index of the region is\n   * not specified, it defaults to zero (the first byte in the byte buffer).\n   * If the length is not specified, it defaults to null, which indicates that\n   * the view extends to the end of the byte buffer.\n   *\n   * Throws [RangeError] if [offsetInBytes] or [length] are negative, or\n   * if [offsetInBytes] + ([length] * elementSizeInBytes) is greater than\n   * the length of [buffer].\n   */\n  factory Uint8ClampedList.view(ByteBuffer buffer,\n                                [int offsetInBytes = 0, int length]) {\n    return buffer.asUint8ClampedList(offsetInBytes, length);\n  }\n\n  static const int BYTES_PER_ELEMENT = 1;\n}\n\n\n/**\n * A fixed-length list of 16-bit signed integers that is viewable as a\n * [TypedData]. For long lists, this implementation can be considerably\n * more space- and time-efficient than the default [List] implementation.\n */\nabstract class Int16List implements List<int>, TypedData {\n  /**\n   * Creates an [Int16List] of the specified length (in elements), all of\n   * whose elements are initially zero.\n   */\n  external factory Int16List(int length);\n\n  /**\n   * Creates a [Int16List] with the same length as the [elements] list\n   * and copies over the elements.\n   */\n  external factory Int16List.fromList(List<int> elements);\n\n  /**\n   * Creates an [Int16List] _view_ of the specified region in the specified\n   * byte buffer. Changes in the [Int16List] will be visible in the byte\n   * buffer and vice versa. If the [offsetInBytes] index of the region is not\n   * specified, it defaults to zero (the first byte in the byte buffer).\n   * If the length is not specified, it defaults to null, which indicates\n   * that the view extends to the end of the byte buffer.\n   *\n   * Throws [RangeError] if [offsetInBytes] or [length] are negative, or\n   * if [offsetInBytes] + ([length] * elementSizeInBytes) is greater than\n   * the length of [buffer].\n   *\n   * Throws [ArgumentError] if [offsetInBytes] is not a multiple of\n   * [BYTES_PER_ELEMENT].\n   */\n  factory Int16List.view(ByteBuffer buffer,\n                         [int offsetInBytes = 0, int length]) {\n    return buffer.asInt16List(offsetInBytes, length);\n  }\n\n  static const int BYTES_PER_ELEMENT = 2;\n}\n\n\n/**\n * A fixed-length list of 16-bit unsigned integers that is viewable as a\n * [TypedData]. For long lists, this implementation can be considerably\n * more space- and time-efficient than the default [List] implementation.\n */\nabstract class Uint16List implements List<int>, TypedData {\n  /**\n   * Creates a [Uint16List] of the specified length (in elements), all\n   * of whose elements are initially zero.\n   */\n  external factory Uint16List(int length);\n\n  /**\n   * Creates a [Uint16List] with the same length as the [elements] list\n   * and copies over the elements.\n   */\n  external factory Uint16List.fromList(List<int> elements);\n\n  /**\n   * Creates a [Uint16List] _view_ of the specified region in\n   * the specified byte buffer. Changes in the [Uint16List] will be\n   * visible in the byte buffer and vice versa. If the [offsetInBytes] index\n   * of the region is not specified, it defaults to zero (the first byte in\n   * the byte buffer). If the length is not specified, it defaults to null,\n   * which indicates that the view extends to the end of the byte buffer.\n   *\n   * Throws [RangeError] if [offsetInBytes] or [length] are negative, or\n   * if [offsetInBytes] + ([length] * elementSizeInBytes) is greater than\n   * the length of [buffer].\n   *\n   * Throws [ArgumentError] if [offsetInBytes] is not a multiple of\n   * [BYTES_PER_ELEMENT].\n   */\n  factory Uint16List.view(ByteBuffer buffer,\n                          [int offsetInBytes = 0, int length]) {\n    return buffer.asUint16List(offsetInBytes, length);\n  }\n\n  static const int BYTES_PER_ELEMENT = 2;\n}\n\n\n/**\n * A fixed-length list of 32-bit signed integers that is viewable as a\n * [TypedData]. For long lists, this implementation can be considerably\n * more space- and time-efficient than the default [List] implementation.\n */\nabstract class Int32List implements List<int>, TypedData {\n  /**\n   * Creates an [Int32List] of the specified length (in elements), all of\n   * whose elements are initially zero.\n   */\n  external factory Int32List(int length);\n\n  /**\n   * Creates a [Int32List] with the same length as the [elements] list\n   * and copies over the elements.\n   */\n  external factory Int32List.fromList(List<int> elements);\n\n  /**\n   * Creates an [Int32List] _view_ of the specified region in the specified\n   * byte buffer. Changes in the [Int32List] will be visible in the byte\n   * buffer and vice versa. If the [offsetInBytes] index of the region is not\n   * specified, it defaults to zero (the first byte in the byte buffer).\n   * If the length is not specified, it defaults to null, which indicates\n   * that the view extends to the end of the byte buffer.\n   *\n   * Throws [RangeError] if [offsetInBytes] or [length] are negative, or\n   * if [offsetInBytes] + ([length] * elementSizeInBytes) is greater than\n   * the length of [buffer].\n   *\n   * Throws [ArgumentError] if [offsetInBytes] is not a multiple of\n   * [BYTES_PER_ELEMENT].\n   */\n  factory Int32List.view(ByteBuffer buffer,\n                         [int offsetInBytes = 0, int length]) {\n    return buffer.asInt32List(offsetInBytes, length);\n  }\n\n  static const int BYTES_PER_ELEMENT = 4;\n}\n\n\n/**\n * A fixed-length list of 32-bit unsigned integers that is viewable as a\n * [TypedData]. For long lists, this implementation can be considerably\n * more space- and time-efficient than the default [List] implementation.\n */\nabstract class Uint32List implements List<int>, TypedData {\n  /**\n   * Creates a [Uint32List] of the specified length (in elements), all\n   * of whose elements are initially zero.\n   */\n  external factory Uint32List(int length);\n\n  /**\n   * Creates a [Uint32List] with the same length as the [elements] list\n   * and copies over the elements.\n   */\n  external factory Uint32List.fromList(List<int> elements);\n\n  /**\n   * Creates a [Uint32List] _view_ of the specified region in\n   * the specified byte buffer. Changes in the [Uint32] will be\n   * visible in the byte buffer and vice versa. If the [offsetInBytes] index\n   * of the region is not specified, it defaults to zero (the first byte in\n   * the byte buffer). If the length is not specified, it defaults to null,\n   * which indicates that the view extends to the end of the byte buffer.\n   *\n   * Throws [RangeError] if [offsetInBytes] or [length] are negative, or\n   * if [offsetInBytes] + ([length] * elementSizeInBytes) is greater than\n   * the length of [buffer].\n   *\n   * Throws [ArgumentError] if [offsetInBytes] is not a multiple of\n   * [BYTES_PER_ELEMENT].\n   */\n  factory Uint32List.view(ByteBuffer buffer,\n                          [int offsetInBytes = 0, int length]) {\n    return buffer.asUint32List(offsetInBytes, length);\n  }\n\n  static const int BYTES_PER_ELEMENT = 4;\n}\n\n\n/**\n * A fixed-length list of 64-bit signed integers that is viewable as a\n * [TypedData]. For long lists, this implementation can be considerably\n * more space- and time-efficient than the default [List] implementation.\n */\nabstract class Int64List implements List<int>, TypedData {\n  /**\n   * Creates an [Int64List] of the specified length (in elements), all of\n   * whose elements are initially zero.\n   */\n  external factory Int64List(int length);\n\n  /**\n   * Creates a [Int64List] with the same length as the [elements] list\n   * and copies over the elements.\n   */\n  external factory Int64List.fromList(List<int> elements);\n\n  /**\n   * Creates an [Int64List] _view_ of the specified region in the specified\n   * byte buffer. Changes in the [Int64List] will be visible in the byte buffer\n   * and vice versa. If the [offsetInBytes] index of the region is not\n   * specified, it defaults to zero (the first byte in the byte buffer).\n   * If the length is not specified, it defaults to null, which indicates that\n   * the view extends to the end of the byte buffer.\n   *\n   * Throws [RangeError] if [offsetInBytes] or [length] are negative, or\n   * if [offsetInBytes] + ([length] * elementSizeInBytes) is greater than\n   * the length of [buffer].\n   *\n   * Throws [ArgumentError] if [offsetInBytes] is not a multiple of\n   * [BYTES_PER_ELEMENT].\n   */\n  factory Int64List.view(ByteBuffer buffer,\n                         [int offsetInBytes = 0, int length]) {\n    return buffer.asInt64List(offsetInBytes, length);\n  }\n\n  static const int BYTES_PER_ELEMENT = 8;\n}\n\n\n/**\n * A fixed-length list of 64-bit unsigned integers that is viewable as a\n * [TypedData]. For long lists, this implementation can be considerably\n * more space- and time-efficient than the default [List] implementation.\n */\nabstract class Uint64List implements List<int>, TypedData {\n  /**\n   * Creates a [Uint64List] of the specified length (in elements), all\n   * of whose elements are initially zero.\n   */\n  external factory Uint64List(int length);\n\n  /**\n   * Creates a [Uint64List] with the same length as the [elements] list\n   * and copies over the elements.\n   */\n  external factory Uint64List.fromList(List<int> elements);\n\n  /**\n   * Creates an [Uint64List] _view_ of the specified region in\n   * the specified byte buffer. Changes in the [Uint64List] will be\n   * visible in the byte buffer and vice versa. If the [offsetInBytes]\n   * index of the region is not specified, it defaults to zero (the first\n   * byte in the byte buffer). If the length is not specified, it defaults\n   * to null, which indicates that the view extends to the end of the byte\n   * buffer.\n   *\n   * Throws [RangeError] if [offsetInBytes] or [length] are negative, or\n   * if [offsetInBytes] + ([length] * elementSizeInBytes) is greater than\n   * the length of [buffer].\n   *\n   * Throws [ArgumentError] if [offsetInBytes] is not a multiple of\n   * [BYTES_PER_ELEMENT].\n   */\n  factory Uint64List.view(ByteBuffer buffer,\n                          [int offsetInBytes = 0, int length]) {\n    return buffer.asUint64List(offsetInBytes, length);\n  }\n\n  static const int BYTES_PER_ELEMENT = 8;\n}\n\n\n/**\n * A fixed-length list of IEEE 754 single-precision binary floating-point\n * numbers  that is viewable as a [TypedData]. For long lists, this\n * implementation can be considerably more space- and time-efficient than\n * the default [List] implementation.\n */\nabstract class Float32List implements List<double>, TypedData {\n  /**\n   * Creates a [Float32List] of the specified length (in elements), all of\n   * whose elements are initially zero.\n   */\n  external factory Float32List(int length);\n\n  /**\n   * Creates a [Float32List] with the same length as the [elements] list\n   * and copies over the elements.\n   */\n  external factory Float32List.fromList(List<double> elements);\n\n  /**\n   * Creates a [Float32List] _view_ of the specified region in the specified\n   * byte buffer. Changes in the [Float32List] will be visible in the byte\n   * buffer and vice versa. If the [offsetInBytes] index of the region is not\n   * specified, it defaults to zero (the first byte in the byte buffer).\n   * If the length is not specified, it defaults to null, which indicates\n   * that the view extends to the end of the byte buffer.\n   *\n   * Throws [RangeError] if [offsetInBytes] or [length] are negative, or\n   * if [offsetInBytes] + ([length] * elementSizeInBytes) is greater than\n   * the length of [buffer].\n   *\n   * Throws [ArgumentError] if [offsetInBytes] is not a multiple of\n   * [BYTES_PER_ELEMENT].\n   */\n  factory Float32List.view(ByteBuffer buffer,\n                           [int offsetInBytes = 0, int length]) {\n    return buffer.asFloat32List(offsetInBytes, length);\n  }\n\n  static const int BYTES_PER_ELEMENT = 4;\n}\n\n\n/**\n * A fixed-length list of IEEE 754 double-precision binary floating-point\n * numbers  that is viewable as a [TypedData]. For long lists, this\n * implementation can be considerably more space- and time-efficient than\n * the default [List] implementation.\n */\nabstract class Float64List implements List<double>, TypedData {\n  /**\n   * Creates a [Float64List] of the specified length (in elements), all of\n   * whose elements are initially zero.\n   */\n  external factory Float64List(int length);\n\n  /**\n   * Creates a [Float64List] with the same length as the [elements] list\n   * and copies over the elements.\n   */\n  external factory Float64List.fromList(List<double> elements);\n\n  /**\n   * Creates a [Float64List] _view_ of the specified region in the specified\n   * byte buffer. Changes in the [Float64List] will be visible in the byte\n   * buffer and vice versa. If the [offsetInBytes] index of the region is not\n   * specified, it defaults to zero (the first byte in the byte buffer).\n   * If the length is not specified, it defaults to null, which indicates\n   * that the view extends to the end of the byte buffer.\n   *\n   * Throws [RangeError] if [offsetInBytes] or [length] are negative, or\n   * if [offsetInBytes] + ([length] * elementSizeInBytes) is greater than\n   * the length of [buffer].\n   *\n   * Throws [ArgumentError] if [offsetInBytes] is not a multiple of\n   * [BYTES_PER_ELEMENT].\n   */\n  factory Float64List.view(ByteBuffer buffer,\n                           [int offsetInBytes = 0, int length]) {\n    return buffer.asFloat64List(offsetInBytes, length);\n  }\n\n  static const int BYTES_PER_ELEMENT = 8;\n}\n\n\n/**\n * A fixed-length list of Float32x4 numbers that is viewable as a\n * [TypedData]. For long lists, this implementation will be considerably more\n * space- and time-efficient than the default [List] implementation.\n */\nabstract class Float32x4List implements List<Float32x4>, TypedData {\n  /**\n   * Creates a [Float32x4List] of the specified length (in elements),\n   * all of whose elements are initially zero.\n   */\n  external factory Float32x4List(int length);\n\n  /**\n   * Creates a [Float32x4List] with the same length as the [elements] list\n   * and copies over the elements.\n   */\n  external factory Float32x4List.fromList(List<Float32x4> elements);\n\n  /**\n   * Creates a [Float32x4List] _view_ of the specified region in the specified\n   * byte buffer. Changes in the [Float32x4List] will be visible in the byte\n   * buffer and vice versa. If the [offsetInBytes] index of the region is not\n   * specified, it defaults to zero (the first byte in the byte buffer).\n   * If the length is not specified, it defaults to null, which indicates\n   * that the view extends to the end of the byte buffer.\n   *\n   * Throws [RangeError] if [offsetInBytes] or [length] are negative, or\n   * if [offsetInBytes] + ([length] * elementSizeInBytes) is greater than\n   * the length of [buffer].\n   *\n   * Throws [ArgumentError] if [offsetInBytes] is not a multiple of\n   * [BYTES_PER_ELEMENT].\n   */\n  factory Float32x4List.view(ByteBuffer buffer,\n                             [int offsetInBytes = 0, int length]) {\n    return buffer.asFloat32x4List(offsetInBytes, length);\n  }\n\n  static const int BYTES_PER_ELEMENT = 16;\n}\n\n\n/**\n * A fixed-length list of Int32x4 numbers that is viewable as a\n * [TypedData]. For long lists, this implementation will be considerably more\n * space- and time-efficient than the default [List] implementation.\n */\nabstract class Int32x4List implements List<Int32x4>, TypedData {\n  /**\n   * Creates a [Int32x4List] of the specified length (in elements),\n   * all of whose elements are initially zero.\n   */\n  external factory Int32x4List(int length);\n\n  /**\n   * Creates a [Int32x4List] with the same length as the [elements] list\n   * and copies over the elements.\n   */\n  external factory Int32x4List.fromList(List<Int32x4> elements);\n\n  /**\n   * Creates a [Int32x4List] _view_ of the specified region in the specified\n   * byte buffer. Changes in the [Int32x4List] will be visible in the byte\n   * buffer and vice versa. If the [offsetInBytes] index of the region is not\n   * specified, it defaults to zero (the first byte in the byte buffer).\n   * If the length is not specified, it defaults to null, which indicates\n   * that the view extends to the end of the byte buffer.\n   *\n   * Throws [RangeError] if [offsetInBytes] or [length] are negative, or\n   * if [offsetInBytes] + ([length] * elementSizeInBytes) is greater than\n   * the length of [buffer].\n   *\n   * Throws [ArgumentError] if [offsetInBytes] is not a multiple of\n   * [BYTES_PER_ELEMENT].\n   */\n  factory Int32x4List.view(ByteBuffer buffer,\n                             [int offsetInBytes = 0, int length]) {\n    return buffer.asInt32x4List(offsetInBytes, length);\n  }\n\n  static const int BYTES_PER_ELEMENT = 16;\n}\n\n\n/**\n * A fixed-length list of Float64x2 numbers that is viewable as a\n * [TypedData]. For long lists, this implementation will be considerably more\n * space- and time-efficient than the default [List] implementation.\n */\nabstract class Float64x2List implements List<Float64x2>, TypedData {\n  /**\n   * Creates a [Float64x2List] of the specified length (in elements),\n   * all of whose elements have all lanes set to zero.\n   */\n  external factory Float64x2List(int length);\n\n  /**\n   * Creates a [Float64x2List] with the same length as the [elements] list\n   * and copies over the elements.\n   */\n  external factory Float64x2List.fromList(List<Float64x2> elements);\n\n  /**\n   * Creates a [Float64x2List] _view_ of the specified region in the specified\n   * byte buffer. Changes in the [Float64x2List] will be visible in the byte\n   * buffer and vice versa. If the [offsetInBytes] index of the region is not\n   * specified, it defaults to zero (the first byte in the byte buffer).\n   * If the length is not specified, it defaults to null, which indicates\n   * that the view extends to the end of the byte buffer.\n   *\n   * Throws [RangeError] if [offsetInBytes] or [length] are negative, or\n   * if [offsetInBytes] + ([length] * elementSizeInBytes) is greater than\n   * the length of [buffer].\n   *\n   * Throws [ArgumentError] if [offsetInBytes] is not a multiple of\n   * [BYTES_PER_ELEMENT].\n   */\n  factory Float64x2List.view(ByteBuffer buffer,\n                             [int offsetInBytes = 0, int length]) {\n    return buffer.asFloat64x2List(offsetInBytes, length);\n  }\n\n  static const int BYTES_PER_ELEMENT = 16;\n}\n\n\n/**\n * Float32x4 immutable value type and operations.\n * Float32x4 stores 4 32-bit floating point values in \"lanes\".\n * The lanes are \"x\", \"y\", \"z\", and \"w\" respectively.\n */\nabstract class Float32x4 {\n  external factory Float32x4(double x, double y, double z, double w);\n  external factory Float32x4.splat(double v);\n  external factory Float32x4.zero();\n  external factory Float32x4.fromInt32x4Bits(Int32x4 x);\n  /// Sets the x and y lanes to their respective values in [v] and sets the z\n  /// and w lanes to 0.0.\n  external factory Float32x4.fromFloat64x2(Float64x2 v);\n\n  /// Addition operator.\n  Float32x4 operator+(Float32x4 other);\n  /// Negate operator.\n  Float32x4 operator-();\n  /// Subtraction operator.\n  Float32x4 operator-(Float32x4 other);\n  /// Multiplication operator.\n  Float32x4 operator*(Float32x4 other);\n  /// Division operator.\n  Float32x4 operator/(Float32x4 other);\n\n  /// Relational less than.\n  Int32x4 lessThan(Float32x4 other);\n  /// Relational less than or equal.\n  Int32x4 lessThanOrEqual(Float32x4 other);\n  /// Relational greater than.\n  Int32x4 greaterThan(Float32x4 other);\n  /// Relational greater than or equal.\n  Int32x4 greaterThanOrEqual(Float32x4 other);\n  /// Relational equal.\n  Int32x4 equal(Float32x4 other);\n  /// Relational not-equal.\n  Int32x4 notEqual(Float32x4 other);\n\n  /// Returns a copy of [this] each lane being scaled by [s].\n  /// Equivalent to this * new Float32x4.splat(s)\n  Float32x4 scale(double s);\n  /// Returns the lane-wise absolute value of this [Float32x4].\n  Float32x4 abs();\n  /// Lane-wise clamp [this] to be in the range [lowerLimit]-[upperLimit].\n  Float32x4 clamp(Float32x4 lowerLimit, Float32x4 upperLimit);\n\n  /// Extracted x value.\n  double get x;\n  /// Extracted y value.\n  double get y;\n  /// Extracted z value.\n  double get z;\n  /// Extracted w value.\n  double get w;\n\n  /// Extract the sign bits from each lane return them in the first 4 bits.\n  /// \"x\" lane is bit 0.\n  /// \"y\" lane is bit 1.\n  /// \"z\" lane is bit 2.\n  /// \"w\" lane is bit 3.\n  int get signMask;\n\n  /// Mask passed to [shuffle] or [shuffleMix].\n  static const int XXXX = 0x0;\n  static const int XXXY = 0x40;\n  static const int XXXZ = 0x80;\n  static const int XXXW = 0xC0;\n  static const int XXYX = 0x10;\n  static const int XXYY = 0x50;\n  static const int XXYZ = 0x90;\n  static const int XXYW = 0xD0;\n  static const int XXZX = 0x20;\n  static const int XXZY = 0x60;\n  static const int XXZZ = 0xA0;\n  static const int XXZW = 0xE0;\n  static const int XXWX = 0x30;\n  static const int XXWY = 0x70;\n  static const int XXWZ = 0xB0;\n  static const int XXWW = 0xF0;\n  static const int XYXX = 0x4;\n  static const int XYXY = 0x44;\n  static const int XYXZ = 0x84;\n  static const int XYXW = 0xC4;\n  static const int XYYX = 0x14;\n  static const int XYYY = 0x54;\n  static const int XYYZ = 0x94;\n  static const int XYYW = 0xD4;\n  static const int XYZX = 0x24;\n  static const int XYZY = 0x64;\n  static const int XYZZ = 0xA4;\n  static const int XYZW = 0xE4;\n  static const int XYWX = 0x34;\n  static const int XYWY = 0x74;\n  static const int XYWZ = 0xB4;\n  static const int XYWW = 0xF4;\n  static const int XZXX = 0x8;\n  static const int XZXY = 0x48;\n  static const int XZXZ = 0x88;\n  static const int XZXW = 0xC8;\n  static const int XZYX = 0x18;\n  static const int XZYY = 0x58;\n  static const int XZYZ = 0x98;\n  static const int XZYW = 0xD8;\n  static const int XZZX = 0x28;\n  static const int XZZY = 0x68;\n  static const int XZZZ = 0xA8;\n  static const int XZZW = 0xE8;\n  static const int XZWX = 0x38;\n  static const int XZWY = 0x78;\n  static const int XZWZ = 0xB8;\n  static const int XZWW = 0xF8;\n  static const int XWXX = 0xC;\n  static const int XWXY = 0x4C;\n  static const int XWXZ = 0x8C;\n  static const int XWXW = 0xCC;\n  static const int XWYX = 0x1C;\n  static const int XWYY = 0x5C;\n  static const int XWYZ = 0x9C;\n  static const int XWYW = 0xDC;\n  static const int XWZX = 0x2C;\n  static const int XWZY = 0x6C;\n  static const int XWZZ = 0xAC;\n  static const int XWZW = 0xEC;\n  static const int XWWX = 0x3C;\n  static const int XWWY = 0x7C;\n  static const int XWWZ = 0xBC;\n  static const int XWWW = 0xFC;\n  static const int YXXX = 0x1;\n  static const int YXXY = 0x41;\n  static const int YXXZ = 0x81;\n  static const int YXXW = 0xC1;\n  static const int YXYX = 0x11;\n  static const int YXYY = 0x51;\n  static const int YXYZ = 0x91;\n  static const int YXYW = 0xD1;\n  static const int YXZX = 0x21;\n  static const int YXZY = 0x61;\n  static const int YXZZ = 0xA1;\n  static const int YXZW = 0xE1;\n  static const int YXWX = 0x31;\n  static const int YXWY = 0x71;\n  static const int YXWZ = 0xB1;\n  static const int YXWW = 0xF1;\n  static const int YYXX = 0x5;\n  static const int YYXY = 0x45;\n  static const int YYXZ = 0x85;\n  static const int YYXW = 0xC5;\n  static const int YYYX = 0x15;\n  static const int YYYY = 0x55;\n  static const int YYYZ = 0x95;\n  static const int YYYW = 0xD5;\n  static const int YYZX = 0x25;\n  static const int YYZY = 0x65;\n  static const int YYZZ = 0xA5;\n  static const int YYZW = 0xE5;\n  static const int YYWX = 0x35;\n  static const int YYWY = 0x75;\n  static const int YYWZ = 0xB5;\n  static const int YYWW = 0xF5;\n  static const int YZXX = 0x9;\n  static const int YZXY = 0x49;\n  static const int YZXZ = 0x89;\n  static const int YZXW = 0xC9;\n  static const int YZYX = 0x19;\n  static const int YZYY = 0x59;\n  static const int YZYZ = 0x99;\n  static const int YZYW = 0xD9;\n  static const int YZZX = 0x29;\n  static const int YZZY = 0x69;\n  static const int YZZZ = 0xA9;\n  static const int YZZW = 0xE9;\n  static const int YZWX = 0x39;\n  static const int YZWY = 0x79;\n  static const int YZWZ = 0xB9;\n  static const int YZWW = 0xF9;\n  static const int YWXX = 0xD;\n  static const int YWXY = 0x4D;\n  static const int YWXZ = 0x8D;\n  static const int YWXW = 0xCD;\n  static const int YWYX = 0x1D;\n  static const int YWYY = 0x5D;\n  static const int YWYZ = 0x9D;\n  static const int YWYW = 0xDD;\n  static const int YWZX = 0x2D;\n  static const int YWZY = 0x6D;\n  static const int YWZZ = 0xAD;\n  static const int YWZW = 0xED;\n  static const int YWWX = 0x3D;\n  static const int YWWY = 0x7D;\n  static const int YWWZ = 0xBD;\n  static const int YWWW = 0xFD;\n  static const int ZXXX = 0x2;\n  static const int ZXXY = 0x42;\n  static const int ZXXZ = 0x82;\n  static const int ZXXW = 0xC2;\n  static const int ZXYX = 0x12;\n  static const int ZXYY = 0x52;\n  static const int ZXYZ = 0x92;\n  static const int ZXYW = 0xD2;\n  static const int ZXZX = 0x22;\n  static const int ZXZY = 0x62;\n  static const int ZXZZ = 0xA2;\n  static const int ZXZW = 0xE2;\n  static const int ZXWX = 0x32;\n  static const int ZXWY = 0x72;\n  static const int ZXWZ = 0xB2;\n  static const int ZXWW = 0xF2;\n  static const int ZYXX = 0x6;\n  static const int ZYXY = 0x46;\n  static const int ZYXZ = 0x86;\n  static const int ZYXW = 0xC6;\n  static const int ZYYX = 0x16;\n  static const int ZYYY = 0x56;\n  static const int ZYYZ = 0x96;\n  static const int ZYYW = 0xD6;\n  static const int ZYZX = 0x26;\n  static const int ZYZY = 0x66;\n  static const int ZYZZ = 0xA6;\n  static const int ZYZW = 0xE6;\n  static const int ZYWX = 0x36;\n  static const int ZYWY = 0x76;\n  static const int ZYWZ = 0xB6;\n  static const int ZYWW = 0xF6;\n  static const int ZZXX = 0xA;\n  static const int ZZXY = 0x4A;\n  static const int ZZXZ = 0x8A;\n  static const int ZZXW = 0xCA;\n  static const int ZZYX = 0x1A;\n  static const int ZZYY = 0x5A;\n  static const int ZZYZ = 0x9A;\n  static const int ZZYW = 0xDA;\n  static const int ZZZX = 0x2A;\n  static const int ZZZY = 0x6A;\n  static const int ZZZZ = 0xAA;\n  static const int ZZZW = 0xEA;\n  static const int ZZWX = 0x3A;\n  static const int ZZWY = 0x7A;\n  static const int ZZWZ = 0xBA;\n  static const int ZZWW = 0xFA;\n  static const int ZWXX = 0xE;\n  static const int ZWXY = 0x4E;\n  static const int ZWXZ = 0x8E;\n  static const int ZWXW = 0xCE;\n  static const int ZWYX = 0x1E;\n  static const int ZWYY = 0x5E;\n  static const int ZWYZ = 0x9E;\n  static const int ZWYW = 0xDE;\n  static const int ZWZX = 0x2E;\n  static const int ZWZY = 0x6E;\n  static const int ZWZZ = 0xAE;\n  static const int ZWZW = 0xEE;\n  static const int ZWWX = 0x3E;\n  static const int ZWWY = 0x7E;\n  static const int ZWWZ = 0xBE;\n  static const int ZWWW = 0xFE;\n  static const int WXXX = 0x3;\n  static const int WXXY = 0x43;\n  static const int WXXZ = 0x83;\n  static const int WXXW = 0xC3;\n  static const int WXYX = 0x13;\n  static const int WXYY = 0x53;\n  static const int WXYZ = 0x93;\n  static const int WXYW = 0xD3;\n  static const int WXZX = 0x23;\n  static const int WXZY = 0x63;\n  static const int WXZZ = 0xA3;\n  static const int WXZW = 0xE3;\n  static const int WXWX = 0x33;\n  static const int WXWY = 0x73;\n  static const int WXWZ = 0xB3;\n  static const int WXWW = 0xF3;\n  static const int WYXX = 0x7;\n  static const int WYXY = 0x47;\n  static const int WYXZ = 0x87;\n  static const int WYXW = 0xC7;\n  static const int WYYX = 0x17;\n  static const int WYYY = 0x57;\n  static const int WYYZ = 0x97;\n  static const int WYYW = 0xD7;\n  static const int WYZX = 0x27;\n  static const int WYZY = 0x67;\n  static const int WYZZ = 0xA7;\n  static const int WYZW = 0xE7;\n  static const int WYWX = 0x37;\n  static const int WYWY = 0x77;\n  static const int WYWZ = 0xB7;\n  static const int WYWW = 0xF7;\n  static const int WZXX = 0xB;\n  static const int WZXY = 0x4B;\n  static const int WZXZ = 0x8B;\n  static const int WZXW = 0xCB;\n  static const int WZYX = 0x1B;\n  static const int WZYY = 0x5B;\n  static const int WZYZ = 0x9B;\n  static const int WZYW = 0xDB;\n  static const int WZZX = 0x2B;\n  static const int WZZY = 0x6B;\n  static const int WZZZ = 0xAB;\n  static const int WZZW = 0xEB;\n  static const int WZWX = 0x3B;\n  static const int WZWY = 0x7B;\n  static const int WZWZ = 0xBB;\n  static const int WZWW = 0xFB;\n  static const int WWXX = 0xF;\n  static const int WWXY = 0x4F;\n  static const int WWXZ = 0x8F;\n  static const int WWXW = 0xCF;\n  static const int WWYX = 0x1F;\n  static const int WWYY = 0x5F;\n  static const int WWYZ = 0x9F;\n  static const int WWYW = 0xDF;\n  static const int WWZX = 0x2F;\n  static const int WWZY = 0x6F;\n  static const int WWZZ = 0xAF;\n  static const int WWZW = 0xEF;\n  static const int WWWX = 0x3F;\n  static const int WWWY = 0x7F;\n  static const int WWWZ = 0xBF;\n  static const int WWWW = 0xFF;\n\n  /// Shuffle the lane values. [mask] must be one of the 256 shuffle constants.\n  Float32x4 shuffle(int mask);\n\n  /// Shuffle the lane values in [this] and [other]. The returned\n  /// Float32x4 will have XY lanes from [this] and ZW lanes from [other].\n  /// Uses the same [mask] as [shuffle].\n  Float32x4 shuffleMix(Float32x4 other, int mask);\n\n  /// Returns a new [Float32x4] copied from [this] with a new x value.\n  Float32x4 withX(double x);\n  /// Returns a new [Float32x4] copied from [this] with a new y value.\n  Float32x4 withY(double y);\n  /// Returns a new [Float32x4] copied from [this] with a new z value.\n  Float32x4 withZ(double z);\n  /// Returns a new [Float32x4] copied from [this] with a new w value.\n  Float32x4 withW(double w);\n\n  /// Returns the lane-wise minimum value in [this] or [other].\n  Float32x4 min(Float32x4 other);\n\n  /// Returns the lane-wise maximum value in [this] or [other].\n  Float32x4 max(Float32x4 other);\n\n  /// Returns the square root of [this].\n  Float32x4 sqrt();\n\n  /// Returns the reciprocal of [this].\n  Float32x4 reciprocal();\n\n  /// Returns the square root of the reciprocal of [this].\n  Float32x4 reciprocalSqrt();\n}\n\n\n/**\n * Int32x4 and operations.\n * Int32x4 stores 4 32-bit bit-masks in \"lanes\".\n * The lanes are \"x\", \"y\", \"z\", and \"w\" respectively.\n */\nabstract class Int32x4 {\n  external factory Int32x4(int x, int y, int z, int w);\n  external factory Int32x4.bool(bool x, bool y, bool z, bool w);\n  external factory Int32x4.fromFloat32x4Bits(Float32x4 x);\n\n  /// The bit-wise or operator.\n  Int32x4 operator|(Int32x4 other);\n  /// The bit-wise and operator.\n  Int32x4 operator&(Int32x4 other);\n  /// The bit-wise xor operator.\n  Int32x4 operator^(Int32x4 other);\n  /// Addition operator.\n  Int32x4 operator+(Int32x4 other);\n  /// Subtraction operator.\n  Int32x4 operator-(Int32x4 other);\n\n  /// Extract 32-bit mask from x lane.\n  int get x;\n  /// Extract 32-bit mask from y lane.\n  int get y;\n  /// Extract 32-bit mask from z lane.\n  int get z;\n  /// Extract 32-bit mask from w lane.\n  int get w;\n\n  /// Extract the top bit from each lane return them in the first 4 bits.\n  /// \"x\" lane is bit 0.\n  /// \"y\" lane is bit 1.\n  /// \"z\" lane is bit 2.\n  /// \"w\" lane is bit 3.\n  int get signMask;\n\n  /// Mask passed to [shuffle] or [shuffleMix].\n  static const int XXXX = 0x0;\n  static const int XXXY = 0x40;\n  static const int XXXZ = 0x80;\n  static const int XXXW = 0xC0;\n  static const int XXYX = 0x10;\n  static const int XXYY = 0x50;\n  static const int XXYZ = 0x90;\n  static const int XXYW = 0xD0;\n  static const int XXZX = 0x20;\n  static const int XXZY = 0x60;\n  static const int XXZZ = 0xA0;\n  static const int XXZW = 0xE0;\n  static const int XXWX = 0x30;\n  static const int XXWY = 0x70;\n  static const int XXWZ = 0xB0;\n  static const int XXWW = 0xF0;\n  static const int XYXX = 0x4;\n  static const int XYXY = 0x44;\n  static const int XYXZ = 0x84;\n  static const int XYXW = 0xC4;\n  static const int XYYX = 0x14;\n  static const int XYYY = 0x54;\n  static const int XYYZ = 0x94;\n  static const int XYYW = 0xD4;\n  static const int XYZX = 0x24;\n  static const int XYZY = 0x64;\n  static const int XYZZ = 0xA4;\n  static const int XYZW = 0xE4;\n  static const int XYWX = 0x34;\n  static const int XYWY = 0x74;\n  static const int XYWZ = 0xB4;\n  static const int XYWW = 0xF4;\n  static const int XZXX = 0x8;\n  static const int XZXY = 0x48;\n  static const int XZXZ = 0x88;\n  static const int XZXW = 0xC8;\n  static const int XZYX = 0x18;\n  static const int XZYY = 0x58;\n  static const int XZYZ = 0x98;\n  static const int XZYW = 0xD8;\n  static const int XZZX = 0x28;\n  static const int XZZY = 0x68;\n  static const int XZZZ = 0xA8;\n  static const int XZZW = 0xE8;\n  static const int XZWX = 0x38;\n  static const int XZWY = 0x78;\n  static const int XZWZ = 0xB8;\n  static const int XZWW = 0xF8;\n  static const int XWXX = 0xC;\n  static const int XWXY = 0x4C;\n  static const int XWXZ = 0x8C;\n  static const int XWXW = 0xCC;\n  static const int XWYX = 0x1C;\n  static const int XWYY = 0x5C;\n  static const int XWYZ = 0x9C;\n  static const int XWYW = 0xDC;\n  static const int XWZX = 0x2C;\n  static const int XWZY = 0x6C;\n  static const int XWZZ = 0xAC;\n  static const int XWZW = 0xEC;\n  static const int XWWX = 0x3C;\n  static const int XWWY = 0x7C;\n  static const int XWWZ = 0xBC;\n  static const int XWWW = 0xFC;\n  static const int YXXX = 0x1;\n  static const int YXXY = 0x41;\n  static const int YXXZ = 0x81;\n  static const int YXXW = 0xC1;\n  static const int YXYX = 0x11;\n  static const int YXYY = 0x51;\n  static const int YXYZ = 0x91;\n  static const int YXYW = 0xD1;\n  static const int YXZX = 0x21;\n  static const int YXZY = 0x61;\n  static const int YXZZ = 0xA1;\n  static const int YXZW = 0xE1;\n  static const int YXWX = 0x31;\n  static const int YXWY = 0x71;\n  static const int YXWZ = 0xB1;\n  static const int YXWW = 0xF1;\n  static const int YYXX = 0x5;\n  static const int YYXY = 0x45;\n  static const int YYXZ = 0x85;\n  static const int YYXW = 0xC5;\n  static const int YYYX = 0x15;\n  static const int YYYY = 0x55;\n  static const int YYYZ = 0x95;\n  static const int YYYW = 0xD5;\n  static const int YYZX = 0x25;\n  static const int YYZY = 0x65;\n  static const int YYZZ = 0xA5;\n  static const int YYZW = 0xE5;\n  static const int YYWX = 0x35;\n  static const int YYWY = 0x75;\n  static const int YYWZ = 0xB5;\n  static const int YYWW = 0xF5;\n  static const int YZXX = 0x9;\n  static const int YZXY = 0x49;\n  static const int YZXZ = 0x89;\n  static const int YZXW = 0xC9;\n  static const int YZYX = 0x19;\n  static const int YZYY = 0x59;\n  static const int YZYZ = 0x99;\n  static const int YZYW = 0xD9;\n  static const int YZZX = 0x29;\n  static const int YZZY = 0x69;\n  static const int YZZZ = 0xA9;\n  static const int YZZW = 0xE9;\n  static const int YZWX = 0x39;\n  static const int YZWY = 0x79;\n  static const int YZWZ = 0xB9;\n  static const int YZWW = 0xF9;\n  static const int YWXX = 0xD;\n  static const int YWXY = 0x4D;\n  static const int YWXZ = 0x8D;\n  static const int YWXW = 0xCD;\n  static const int YWYX = 0x1D;\n  static const int YWYY = 0x5D;\n  static const int YWYZ = 0x9D;\n  static const int YWYW = 0xDD;\n  static const int YWZX = 0x2D;\n  static const int YWZY = 0x6D;\n  static const int YWZZ = 0xAD;\n  static const int YWZW = 0xED;\n  static const int YWWX = 0x3D;\n  static const int YWWY = 0x7D;\n  static const int YWWZ = 0xBD;\n  static const int YWWW = 0xFD;\n  static const int ZXXX = 0x2;\n  static const int ZXXY = 0x42;\n  static const int ZXXZ = 0x82;\n  static const int ZXXW = 0xC2;\n  static const int ZXYX = 0x12;\n  static const int ZXYY = 0x52;\n  static const int ZXYZ = 0x92;\n  static const int ZXYW = 0xD2;\n  static const int ZXZX = 0x22;\n  static const int ZXZY = 0x62;\n  static const int ZXZZ = 0xA2;\n  static const int ZXZW = 0xE2;\n  static const int ZXWX = 0x32;\n  static const int ZXWY = 0x72;\n  static const int ZXWZ = 0xB2;\n  static const int ZXWW = 0xF2;\n  static const int ZYXX = 0x6;\n  static const int ZYXY = 0x46;\n  static const int ZYXZ = 0x86;\n  static const int ZYXW = 0xC6;\n  static const int ZYYX = 0x16;\n  static const int ZYYY = 0x56;\n  static const int ZYYZ = 0x96;\n  static const int ZYYW = 0xD6;\n  static const int ZYZX = 0x26;\n  static const int ZYZY = 0x66;\n  static const int ZYZZ = 0xA6;\n  static const int ZYZW = 0xE6;\n  static const int ZYWX = 0x36;\n  static const int ZYWY = 0x76;\n  static const int ZYWZ = 0xB6;\n  static const int ZYWW = 0xF6;\n  static const int ZZXX = 0xA;\n  static const int ZZXY = 0x4A;\n  static const int ZZXZ = 0x8A;\n  static const int ZZXW = 0xCA;\n  static const int ZZYX = 0x1A;\n  static const int ZZYY = 0x5A;\n  static const int ZZYZ = 0x9A;\n  static const int ZZYW = 0xDA;\n  static const int ZZZX = 0x2A;\n  static const int ZZZY = 0x6A;\n  static const int ZZZZ = 0xAA;\n  static const int ZZZW = 0xEA;\n  static const int ZZWX = 0x3A;\n  static const int ZZWY = 0x7A;\n  static const int ZZWZ = 0xBA;\n  static const int ZZWW = 0xFA;\n  static const int ZWXX = 0xE;\n  static const int ZWXY = 0x4E;\n  static const int ZWXZ = 0x8E;\n  static const int ZWXW = 0xCE;\n  static const int ZWYX = 0x1E;\n  static const int ZWYY = 0x5E;\n  static const int ZWYZ = 0x9E;\n  static const int ZWYW = 0xDE;\n  static const int ZWZX = 0x2E;\n  static const int ZWZY = 0x6E;\n  static const int ZWZZ = 0xAE;\n  static const int ZWZW = 0xEE;\n  static const int ZWWX = 0x3E;\n  static const int ZWWY = 0x7E;\n  static const int ZWWZ = 0xBE;\n  static const int ZWWW = 0xFE;\n  static const int WXXX = 0x3;\n  static const int WXXY = 0x43;\n  static const int WXXZ = 0x83;\n  static const int WXXW = 0xC3;\n  static const int WXYX = 0x13;\n  static const int WXYY = 0x53;\n  static const int WXYZ = 0x93;\n  static const int WXYW = 0xD3;\n  static const int WXZX = 0x23;\n  static const int WXZY = 0x63;\n  static const int WXZZ = 0xA3;\n  static const int WXZW = 0xE3;\n  static const int WXWX = 0x33;\n  static const int WXWY = 0x73;\n  static const int WXWZ = 0xB3;\n  static const int WXWW = 0xF3;\n  static const int WYXX = 0x7;\n  static const int WYXY = 0x47;\n  static const int WYXZ = 0x87;\n  static const int WYXW = 0xC7;\n  static const int WYYX = 0x17;\n  static const int WYYY = 0x57;\n  static const int WYYZ = 0x97;\n  static const int WYYW = 0xD7;\n  static const int WYZX = 0x27;\n  static const int WYZY = 0x67;\n  static const int WYZZ = 0xA7;\n  static const int WYZW = 0xE7;\n  static const int WYWX = 0x37;\n  static const int WYWY = 0x77;\n  static const int WYWZ = 0xB7;\n  static const int WYWW = 0xF7;\n  static const int WZXX = 0xB;\n  static const int WZXY = 0x4B;\n  static const int WZXZ = 0x8B;\n  static const int WZXW = 0xCB;\n  static const int WZYX = 0x1B;\n  static const int WZYY = 0x5B;\n  static const int WZYZ = 0x9B;\n  static const int WZYW = 0xDB;\n  static const int WZZX = 0x2B;\n  static const int WZZY = 0x6B;\n  static const int WZZZ = 0xAB;\n  static const int WZZW = 0xEB;\n  static const int WZWX = 0x3B;\n  static const int WZWY = 0x7B;\n  static const int WZWZ = 0xBB;\n  static const int WZWW = 0xFB;\n  static const int WWXX = 0xF;\n  static const int WWXY = 0x4F;\n  static const int WWXZ = 0x8F;\n  static const int WWXW = 0xCF;\n  static const int WWYX = 0x1F;\n  static const int WWYY = 0x5F;\n  static const int WWYZ = 0x9F;\n  static const int WWYW = 0xDF;\n  static const int WWZX = 0x2F;\n  static const int WWZY = 0x6F;\n  static const int WWZZ = 0xAF;\n  static const int WWZW = 0xEF;\n  static const int WWWX = 0x3F;\n  static const int WWWY = 0x7F;\n  static const int WWWZ = 0xBF;\n  static const int WWWW = 0xFF;\n\n  /// Shuffle the lane values. [mask] must be one of the 256 shuffle constants.\n  Int32x4 shuffle(int mask);\n\n  /// Shuffle the lane values in [this] and [other]. The returned\n  /// Int32x4 will have XY lanes from [this] and ZW lanes from [other].\n  /// Uses the same [mask] as [shuffle].\n  Int32x4 shuffleMix(Int32x4 other, int mask);\n\n  /// Returns a new [Int32x4] copied from [this] with a new x value.\n  Int32x4 withX(int x);\n  /// Returns a new [Int32x4] copied from [this] with a new y value.\n  Int32x4 withY(int y);\n  /// Returns a new [Int32x4] copied from [this] with a new z value.\n  Int32x4 withZ(int z);\n  /// Returns a new [Int32x4] copied from [this] with a new w value.\n  Int32x4 withW(int w);\n\n  /// Extracted x value. Returns false for 0, true for any other value.\n  bool get flagX;\n  /// Extracted y value. Returns false for 0, true for any other value.\n  bool get flagY;\n  /// Extracted z value. Returns false for 0, true for any other value.\n  bool get flagZ;\n  /// Extracted w value. Returns false for 0, true for any other value.\n  bool get flagW;\n\n  /// Returns a new [Int32x4] copied from [this] with a new x value.\n  Int32x4 withFlagX(bool x);\n  /// Returns a new [Int32x4] copied from [this] with a new y value.\n  Int32x4 withFlagY(bool y);\n  /// Returns a new [Int32x4] copied from [this] with a new z value.\n  Int32x4 withFlagZ(bool z);\n  /// Returns a new [Int32x4] copied from [this] with a new w value.\n  Int32x4 withFlagW(bool w);\n\n  /// Merge [trueValue] and [falseValue] based on [this]' bit mask:\n  /// Select bit from [trueValue] when bit in [this] is on.\n  /// Select bit from [falseValue] when bit in [this] is off.\n  Float32x4 select(Float32x4 trueValue, Float32x4 falseValue);\n}\n\n/**\n * Float64x2 immutable value type and operations.\n * Float64x2 stores 2 64-bit floating point values in \"lanes\".\n * The lanes are \"x\" and \"y\" respectively.\n */\nabstract class Float64x2 {\n  external factory Float64x2(double x, double y);\n  external factory Float64x2.splat(double v);\n  external factory Float64x2.zero();\n  /// Uses the \"x\" and \"y\" lanes from [v].\n  external factory Float64x2.fromFloat32x4(Float32x4 v);\n\n  /// Addition operator.\n  Float64x2 operator+(Float64x2 other);\n  /// Negate operator.\n  Float64x2 operator-();\n  /// Subtraction operator.\n  Float64x2 operator-(Float64x2 other);\n  /// Multiplication operator.\n  Float64x2 operator*(Float64x2 other);\n  /// Division operator.\n  Float64x2 operator/(Float64x2 other);\n\n  /// Returns a copy of [this] each lane being scaled by [s].\n  /// Equivalent to this * new Float64x2.splat(s)\n  Float64x2 scale(double s);\n  /// Returns the lane-wise absolute value of this [Float64x2].\n  Float64x2 abs();\n\n  /// Lane-wise clamp [this] to be in the range [lowerLimit]-[upperLimit].\n  Float64x2 clamp(Float64x2 lowerLimit,\n                  Float64x2 upperLimit);\n\n  /// Extracted x value.\n  double get x;\n  /// Extracted y value.\n  double get y;\n\n  /// Extract the sign bits from each lane return them in the first 2 bits.\n  /// \"x\" lane is bit 0.\n  /// \"y\" lane is bit 1.\n  int get signMask;\n\n  /// Returns a new [Float64x2] copied from [this] with a new x value.\n  Float64x2 withX(double x);\n  /// Returns a new [Float64x2] copied from [this] with a new y value.\n  Float64x2 withY(double y);\n\n  /// Returns the lane-wise minimum value in [this] or [other].\n  Float64x2 min(Float64x2 other);\n\n  /// Returns the lane-wise maximum value in [this] or [other].\n  Float64x2 max(Float64x2 other);\n\n  /// Returns the lane-wise square root of [this].\n  Float64x2 sqrt();\n}\n\u0000","sdk:/sdk/lib/html/html_common/metadata.dart":"// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\nlibrary metadata;\n\n/**\n * An annotation used to mark a feature as only being supported by a subset\n * of the browsers that Dart supports by default.\n *\n * If an API is not annotated with [SupportedBrowser] then it is assumed to\n * work on all browsers Dart supports.\n */\nclass SupportedBrowser {\n  static const String CHROME = \"Chrome\";\n  static const String FIREFOX = \"Firefox\";\n  static const String IE = \"Internet Explorer\";\n  static const String OPERA = \"Opera\";\n  static const String SAFARI = \"Safari\";\n\n  /// The name of the browser.\n  final String browserName;\n  /// The minimum version of the browser that supports the feature, or null\n  /// if supported on all versions.\n  final String minimumVersion;\n\n  const SupportedBrowser(this.browserName, [this.minimumVersion]);\n}\n\n\n/**\n * An annotation used to mark an API as being experimental.\n *\n * An API is considered to be experimental if it is still going through the\n * process of stabilizing and is subject to change or removal.\n *\n * See also:\n *\n * * [W3C recommendation](http://en.wikipedia.org/wiki/W3C_recommendation)\n */\nclass Experimental {\n  const Experimental();\n}\n\n\n/**\n * Annotation that specifies that a member is editable through generate files.\n *\n * This is used for API generation.\n *\n * [name] should be formatted as `interface.member`.\n */\nclass DomName {\n  final String name;\n  const DomName(this.name);\n}\n\n\n/**\n * Metadata that specifies that that member is editable through generated\n * files.\n */\nclass DocsEditable {\n  const DocsEditable();\n}\n\n\n/**\n * Annotation that indicates that an API is not expected to change but has\n * not undergone enough testing to be considered stable.\n */\nclass Unstable {\n  const Unstable();\n}\n\u0000","sdk:/sdk/lib/indexed_db/dart2js/indexed_db_dart2js.dart":"/**\n * A client-side key-value store with support for indexes.\n *\n * Many browsers support IndexedDB&mdash;a web standard for\n * an indexed database.\n * By storing data on the client in an IndexedDB,\n * a web app gets some advantages, such as faster performance and persistence.\n * To find out which browsers support IndexedDB,\n * refer to [Can I Use?](http://caniuse.com/#feat=indexeddb)\n *\n * In IndexedDB, each record is identified by a unique index or key,\n * making data retrieval speedy.\n * You can store structured data,\n * such as images, arrays, and maps using IndexedDB.\n * The standard does not specify size limits for individual data items\n * or for the database itself, but browsers may impose storage limits.\n *\n * ## Using indexed_db\n *\n * The classes in this library provide an interface\n * to the browser's IndexedDB, if it has one.\n * To use this library in your code:\n *\n *     import 'dart:indexed_db';\n *\n * A web app can determine if the browser supports\n * IndexedDB with [IdbFactory.supported]:\n *\n *     if (IdbFactory.supported)\n *       // Use indexeddb.\n *     else\n *       // Find an alternative.\n *\n * Access to the browser's IndexedDB is provided by the app's top-level\n * [Window] object, which your code can refer to with `window.indexedDB`.\n * So, for example,\n * here's how to use window.indexedDB to open a database:\n *\n *     Future open() {\n *       return window.indexedDB.open('myIndexedDB',\n *           version: 1,\n *           onUpgradeNeeded: _initializeDatabase)\n *         .then(_loadFromDB);\n *     }\n *     void _initializeDatabase(VersionChangeEvent e) {\n *       ...\n *     }\n *     Future _loadFromDB(Database db) {\n *       ...\n *     }\n *\n *\n * All data in an IndexedDB is stored within an [ObjectStore].\n * To manipulate the database use [Transaction]s.\n *\n * ## Other resources\n *\n * Other options for client-side data storage include:\n *\n * * [Window.localStorage]&mdash;a\n * basic mechanism that stores data as a [Map],\n * and where both the keys and the values are strings.\n *\n * * [dart:web_sql]&mdash;a database that can be queried with SQL.\n * \n * For a tutorial about using the indexed_db library with Dart,\n * check out\n * [Use IndexedDB](http://www.dartlang.org/docs/tutorials/indexeddb/).\n *\n * [IndexedDB reference](http://docs.webplatform.org/wiki/apis/indexeddb)\n * provides wiki-style docs about indexedDB\n */\nlibrary dart.dom.indexed_db;\n\nimport 'dart:async';\nimport 'dart:html';\nimport 'dart:html_common';\nimport 'dart:_native_typed_data';\nimport 'dart:typed_data';\nimport 'dart:_js_helper' show Creates, Returns, JSName, Native, Null;\nimport 'dart:_foreign_helper' show JS;\nimport 'dart:_interceptors' show Interceptor, JSExtendableArray;\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n// DO NOT EDIT - unless you are editing documentation as per:\n// https://code.google.com/p/dart/wiki/ContributingHTMLDocumentation\n// Auto-generated dart:svg library.\n\n\n\n\n\nclass _KeyRangeFactoryProvider {\n\n  static KeyRange createKeyRange_only(/*Key*/ value) =>\n      _only(_class(), _translateKey(value));\n\n  static KeyRange createKeyRange_lowerBound(\n      /*Key*/ bound, [bool open = false]) =>\n      _lowerBound(_class(), _translateKey(bound), open);\n\n  static KeyRange createKeyRange_upperBound(\n      /*Key*/ bound, [bool open = false]) =>\n      _upperBound(_class(), _translateKey(bound), open);\n\n  static KeyRange createKeyRange_bound(/*Key*/ lower, /*Key*/ upper,\n      [bool lowerOpen = false, bool upperOpen = false]) =>\n      _bound(_class(), _translateKey(lower), _translateKey(upper),\n             lowerOpen, upperOpen);\n\n  static var _cachedClass;\n\n  static _class() {\n    if (_cachedClass != null) return _cachedClass;\n    return _cachedClass = _uncachedClass();\n  }\n\n  static _uncachedClass() =>\n    JS('var',\n       '''window.webkitIDBKeyRange || window.mozIDBKeyRange ||\n          window.msIDBKeyRange || window.IDBKeyRange''');\n\n  static _translateKey(idbkey) => idbkey;  // TODO: fixme.\n\n  static KeyRange _only(cls, value) =>\n       JS('KeyRange', '#.only(#)', cls, value);\n\n  static KeyRange _lowerBound(cls, bound, open) =>\n       JS('KeyRange', '#.lowerBound(#, #)', cls, bound, open);\n\n  static KeyRange _upperBound(cls, bound, open) =>\n       JS('KeyRange', '#.upperBound(#, #)', cls, bound, open);\n\n  static KeyRange _bound(cls, lower, upper, lowerOpen, upperOpen) =>\n       JS('KeyRange', '#.bound(#, #, #, #)',\n          cls, lower, upper, lowerOpen, upperOpen);\n}\n\n// Conversions for IDBKey.\n//\n// Per http://www.w3.org/TR/IndexedDB/#key-construct\n//\n// \"A value is said to be a valid key if it is one of the following types: Array\n// JavaScript objects [ECMA-262], DOMString [WEBIDL], Date [ECMA-262] or float\n// [WEBIDL]. However Arrays are only valid keys if every item in the array is\n// defined and is a valid key (i.e. sparse arrays can not be valid keys) and if\n// the Array doesn't directly or indirectly contain itself. Any non-numeric\n// properties are ignored, and thus does not affect whether the Array is a valid\n// key. Additionally, if the value is of type float, it is only a valid key if\n// it is not NaN, and if the value is of type Date it is only a valid key if its\n// [[PrimitiveValue]] internal property, as defined by [ECMA-262], is not NaN.\"\n\n// What is required is to ensure that an Lists in the key are actually\n// JavaScript arrays, and any Dates are JavaScript Dates.\n\n\n/**\n * Converts a native IDBKey into a Dart object.\n *\n * May return the original input.  May mutate the original input (but will be\n * idempotent if mutation occurs).  It is assumed that this conversion happens\n * on native IDBKeys on all paths that return IDBKeys from native DOM calls.\n *\n * If necessary, JavaScript Dates are converted into Dart Dates.\n */\n_convertNativeToDart_IDBKey(nativeKey) {\n  containsDate(object) {\n    if (isJavaScriptDate(object)) return true;\n    if (object is List) {\n      for (int i = 0; i < object.length; i++) {\n        if (containsDate(object[i])) return true;\n      }\n    }\n    return false;  // number, string.\n  }\n  if (containsDate(nativeKey)) {\n    throw new UnimplementedError('Key containing DateTime');\n  }\n  // TODO: Cache conversion somewhere?\n  return nativeKey;\n}\n\n/**\n * Converts a Dart object into a valid IDBKey.\n *\n * May return the original input.  Does not mutate input.\n *\n * If necessary, [dartKey] may be copied to ensure all lists are converted into\n * JavaScript Arrays and Dart Dates into JavaScript Dates.\n */\n_convertDartToNative_IDBKey(dartKey) {\n  // TODO: Implement.\n  return dartKey;\n}\n\n\n\n/// May modify original.  If so, action is idempotent.\n_convertNativeToDart_IDBAny(object) {\n  return convertNativeToDart_AcceptStructuredClone(object, mustCopy: false);\n}\n\n// TODO(sra): Add DateTime.\nconst String _idbKey = 'JSExtendableArray|=Object|num|String';\nconst _annotation_Creates_IDBKey = const Creates(_idbKey);\nconst _annotation_Returns_IDBKey = const Returns(_idbKey);\n// Copyright (c) 2013, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DomName('IDBCursor')\n@Unstable()\n@Native(\"IDBCursor\")\nclass Cursor extends Interceptor {\n  @DomName('IDBCursor.delete')\n  Future delete() {\n   try {\n      return _completeRequest(_delete());\n    } catch (e, stacktrace) {\n      return new Future.error(e, stacktrace);\n    }\n  }\n\n  @DomName('IDBCursor.value')\n  Future update(value) {\n   try {\n      return _completeRequest(_update(value));\n    } catch (e, stacktrace) {\n      return new Future.error(e, stacktrace);\n    }\n  }\n\n  @JSName('continue')\n  @DomName('IDBCursor.continue')\n  void next([Object key]) {\n    if (key == null) {\n      JS('void', '#.continue()', this);\n    } else {\n      JS('void', '#.continue(#)', this, key);\n    }\n  }\n    // To suppress missing implicit constructor warnings.\n  factory Cursor._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('IDBCursor.direction')\n  @DocsEditable()\n  final String direction;\n\n  @DomName('IDBCursor.key')\n  @DocsEditable()\n  @_annotation_Creates_IDBKey\n  @_annotation_Returns_IDBKey\n  final Object key;\n\n  @DomName('IDBCursor.primaryKey')\n  @DocsEditable()\n  @_annotation_Creates_IDBKey\n  @_annotation_Returns_IDBKey\n  final Object primaryKey;\n\n  @DomName('IDBCursor.source')\n  @DocsEditable()\n  @Creates('Null')\n  @Returns('ObjectStore|Index|Null')\n  final Object source;\n\n  @DomName('IDBCursor.advance')\n  @DocsEditable()\n  void advance(int count) native;\n\n  @DomName('IDBCursor.continuePrimaryKey')\n  @DocsEditable()\n  @Experimental() // untriaged\n  void continuePrimaryKey(Object key, Object primaryKey) native;\n\n  @JSName('delete')\n  @DomName('IDBCursor.delete')\n  @DocsEditable()\n  Request _delete() native;\n\n  @DomName('IDBCursor.update')\n  @DocsEditable()\n  Request _update(/*any*/ value) {\n    var value_1 = convertDartToNative_SerializedScriptValue(value);\n    return _update_1(value_1);\n  }\n  @JSName('update')\n  @DomName('IDBCursor.update')\n  @DocsEditable()\n  Request _update_1(value) native;\n\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('IDBCursorWithValue')\n@Unstable()\n@Native(\"IDBCursorWithValue\")\nclass CursorWithValue extends Cursor {\n  // To suppress missing implicit constructor warnings.\n  factory CursorWithValue._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('IDBCursorWithValue.value')\n  @DocsEditable()\n  dynamic get value => _convertNativeToDart_IDBAny(this._get_value);\n  @JSName('value')\n  @DomName('IDBCursorWithValue.value')\n  @DocsEditable()\n  @annotation_Creates_SerializedScriptValue\n  @annotation_Returns_SerializedScriptValue\n  final dynamic _get_value;\n}\n// Copyright (c) 2013, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n/**\n * An indexed database object for storing client-side data\n * in web apps.\n */\n@DomName('IDBDatabase')\n@SupportedBrowser(SupportedBrowser.CHROME)\n@SupportedBrowser(SupportedBrowser.FIREFOX, '15')\n@SupportedBrowser(SupportedBrowser.IE, '10')\n@Experimental()\n@Unstable()\n@Native(\"IDBDatabase\")\nclass Database extends EventTarget {\n  @DomName('IDBDatabase.createObjectStore')\n  @DocsEditable()\n  ObjectStore createObjectStore(String name,\n      {String keyPath, bool autoIncrement}) {\n    var options = {};\n    if (keyPath != null) {\n      options['keyPath'] = keyPath;\n    }\n    if (autoIncrement != null) {\n      options['autoIncrement'] = autoIncrement;\n    }\n\n    return _createObjectStore(name, options);\n  }\n\n  Transaction transaction(storeName_OR_storeNames, String mode) {\n    if (mode != 'readonly' && mode != 'readwrite') {\n      throw new ArgumentError(mode);\n    }\n\n    // TODO(sra): Ensure storeName_OR_storeNames is a string or List<String>,\n    // and copy to JavaScript array if necessary.\n\n    // Try and create a transaction with a string mode.  Browsers that expect a\n    // numeric mode tend to convert the string into a number.  This fails\n    // silently, resulting in zero ('readonly').\n    return _transaction(storeName_OR_storeNames, mode);\n  }\n\n  Transaction transactionStore(String storeName, String mode) {\n    if (mode != 'readonly' && mode != 'readwrite') {\n      throw new ArgumentError(mode);\n    }\n    // Try and create a transaction with a string mode.  Browsers that expect a\n    // numeric mode tend to convert the string into a number.  This fails\n    // silently, resulting in zero ('readonly').\n    return _transaction(storeName, mode);\n  }\n\n  Transaction transactionList(List<String> storeNames, String mode) {\n    if (mode != 'readonly' && mode != 'readwrite') {\n      throw new ArgumentError(mode);\n    }\n    List storeNames_1 = convertDartToNative_StringArray(storeNames);\n    return _transaction(storeNames_1, mode);\n  }\n  \n  Transaction transactionStores(DomStringList storeNames, String mode) {\n    if (mode != 'readonly' && mode != 'readwrite') {\n      throw new ArgumentError(mode);\n    }\n    return _transaction(storeNames, mode);\n  }\n\n  @JSName('transaction')\n  Transaction _transaction(stores, mode) native;\n\n  // To suppress missing implicit constructor warnings.\n  factory Database._() { throw new UnsupportedError(\"Not supported\"); }\n\n  /**\n   * Static factory designed to expose `abort` events to event\n   * handlers that are not necessarily instances of [Database].\n   *\n   * See [EventStreamProvider] for usage information.\n   */\n  @DomName('IDBDatabase.abortEvent')\n  @DocsEditable()\n  static const EventStreamProvider<Event> abortEvent = const EventStreamProvider<Event>('abort');\n\n  /**\n   * Static factory designed to expose `close` events to event\n   * handlers that are not necessarily instances of [Database].\n   *\n   * See [EventStreamProvider] for usage information.\n   */\n  @DomName('IDBDatabase.closeEvent')\n  @DocsEditable()\n  // https://www.w3.org/Bugs/Public/show_bug.cgi?id=22540\n  @Experimental()\n  static const EventStreamProvider<Event> closeEvent = const EventStreamProvider<Event>('close');\n\n  /**\n   * Static factory designed to expose `error` events to event\n   * handlers that are not necessarily instances of [Database].\n   *\n   * See [EventStreamProvider] for usage information.\n   */\n  @DomName('IDBDatabase.errorEvent')\n  @DocsEditable()\n  static const EventStreamProvider<Event> errorEvent = const EventStreamProvider<Event>('error');\n\n  /**\n   * Static factory designed to expose `versionchange` events to event\n   * handlers that are not necessarily instances of [Database].\n   *\n   * See [EventStreamProvider] for usage information.\n   */\n  @DomName('IDBDatabase.versionchangeEvent')\n  @DocsEditable()\n  static const EventStreamProvider<VersionChangeEvent> versionChangeEvent = const EventStreamProvider<VersionChangeEvent>('versionchange');\n\n  @DomName('IDBDatabase.name')\n  @DocsEditable()\n  final String name;\n\n  @DomName('IDBDatabase.objectStoreNames')\n  @DocsEditable()\n  @Returns('DomStringList')\n  @Creates('DomStringList')\n  final List<String> objectStoreNames;\n\n  @DomName('IDBDatabase.version')\n  @DocsEditable()\n  @Creates('int|String|Null')\n  @Returns('int|String|Null')\n  final Object version;\n\n  @DomName('IDBDatabase.close')\n  @DocsEditable()\n  void close() native;\n\n  @DomName('IDBDatabase.createObjectStore')\n  @DocsEditable()\n  ObjectStore _createObjectStore(String name, [Map options]) {\n    if (options != null) {\n      var options_1 = convertDartToNative_Dictionary(options);\n      return _createObjectStore_1(name, options_1);\n    }\n    return _createObjectStore_2(name);\n  }\n  @JSName('createObjectStore')\n  @DomName('IDBDatabase.createObjectStore')\n  @DocsEditable()\n  ObjectStore _createObjectStore_1(name, options) native;\n  @JSName('createObjectStore')\n  @DomName('IDBDatabase.createObjectStore')\n  @DocsEditable()\n  ObjectStore _createObjectStore_2(name) native;\n\n  @DomName('IDBDatabase.deleteObjectStore')\n  @DocsEditable()\n  void deleteObjectStore(String name) native;\n\n  /// Stream of `abort` events handled by this [Database].\n  @DomName('IDBDatabase.onabort')\n  @DocsEditable()\n  Stream<Event> get onAbort => abortEvent.forTarget(this);\n\n  /// Stream of `close` events handled by this [Database].\n  @DomName('IDBDatabase.onclose')\n  @DocsEditable()\n  // https://www.w3.org/Bugs/Public/show_bug.cgi?id=22540\n  @Experimental()\n  Stream<Event> get onClose => closeEvent.forTarget(this);\n\n  /// Stream of `error` events handled by this [Database].\n  @DomName('IDBDatabase.onerror')\n  @DocsEditable()\n  Stream<Event> get onError => errorEvent.forTarget(this);\n\n  /// Stream of `versionchange` events handled by this [Database].\n  @DomName('IDBDatabase.onversionchange')\n  @DocsEditable()\n  Stream<VersionChangeEvent> get onVersionChange => versionChangeEvent.forTarget(this);\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DomName('IDBFactory')\n@SupportedBrowser(SupportedBrowser.CHROME)\n@SupportedBrowser(SupportedBrowser.FIREFOX, '15')\n@SupportedBrowser(SupportedBrowser.IE, '10')\n@Experimental()\n@Unstable()\n@Native(\"IDBFactory\")\nclass IdbFactory extends Interceptor {\n  /**\n   * Checks to see if Indexed DB is supported on the current platform.\n   */\n  static bool get supported {\n    return JS('bool',\n        '!!(window.indexedDB || '\n        'window.webkitIndexedDB || '\n        'window.mozIndexedDB)');\n  }\n\n  @DomName('IDBFactory.open')\n  Future<Database> open(String name,\n      {int version, void onUpgradeNeeded(VersionChangeEvent),\n      void onBlocked(Event)}) {\n    if ((version == null) != (onUpgradeNeeded == null)) {\n      return new Future.error(new ArgumentError(\n          'version and onUpgradeNeeded must be specified together'));\n    }\n    try {\n      var request;\n      if (version != null) {\n        request = _open(name, version);\n      } else {\n        request = _open(name);\n      }\n\n      if (onUpgradeNeeded != null) {\n        request.onUpgradeNeeded.listen(onUpgradeNeeded);\n      }\n      if (onBlocked != null) {\n        request.onBlocked.listen(onBlocked);\n      }\n      return _completeRequest(request);\n    } catch (e, stacktrace) {\n      return new Future.error(e, stacktrace);\n    }\n  }\n\n  @DomName('IDBFactory.deleteDatabase')\n  Future<IdbFactory> deleteDatabase(String name,\n      {void onBlocked(Event)}) {\n    try {\n      var request = _deleteDatabase(name);\n\n      if (onBlocked != null) {\n        request.onBlocked.listen(onBlocked);\n      }\n      var completer = new Completer.sync();\n      request.onSuccess.listen((e) {\n        completer.complete(this);\n      });\n      request.onError.listen(completer.completeError);\n      return completer.future;\n    } catch (e, stacktrace) {\n      return new Future.error(e, stacktrace);\n    }\n  }\n\n  @DomName('IDBFactory.getDatabaseNames')\n  @SupportedBrowser(SupportedBrowser.CHROME)\n  @Experimental()\n  Future<List<String>> getDatabaseNames() {\n    try {\n      var request = _webkitGetDatabaseNames();\n\n      return _completeRequest(request);\n    } catch (e, stacktrace) {\n      return new Future.error(e, stacktrace);\n    }\n  }\n\n  /**\n   * Checks to see if getDatabaseNames is supported by the current platform.\n   */\n  bool get supportsDatabaseNames {\n    return supported && JS('bool',\n        '!!(#.getDatabaseNames || #.webkitGetDatabaseNames)', this, this);\n  }\n\n  // To suppress missing implicit constructor warnings.\n  factory IdbFactory._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('IDBFactory.cmp')\n  @DocsEditable()\n  int cmp(Object first, Object second) native;\n\n  @JSName('deleteDatabase')\n  @DomName('IDBFactory.deleteDatabase')\n  @DocsEditable()\n  OpenDBRequest _deleteDatabase(String name) native;\n\n  @JSName('open')\n  @DomName('IDBFactory.open')\n  @DocsEditable()\n  @Returns('Request')\n  @Creates('Request')\n  @Creates('Database')\n  OpenDBRequest _open(String name, [int version]) native;\n\n  @JSName('webkitGetDatabaseNames')\n  @DomName('IDBFactory.webkitGetDatabaseNames')\n  @DocsEditable()\n  @SupportedBrowser(SupportedBrowser.CHROME)\n  @SupportedBrowser(SupportedBrowser.SAFARI)\n  @Experimental()\n  @Returns('Request')\n  @Creates('Request')\n  @Creates('DomStringList')\n  Request _webkitGetDatabaseNames() native;\n\n}\n\n\n/**\n * Ties a request to a completer, so the completer is completed when it succeeds\n * and errors out when the request errors.\n */\nFuture _completeRequest(Request request) {\n  var completer = new Completer.sync();\n  // TODO: make sure that completer.complete is synchronous as transactions\n  // may be committed if the result is not processed immediately.\n  request.onSuccess.listen((e) {\n    completer.complete(request.result);\n  });\n  request.onError.listen(completer.completeError);\n  return completer.future;\n}\n// Copyright (c) 2013, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DomName('IDBIndex')\n@Unstable()\n@Native(\"IDBIndex\")\nclass Index extends Interceptor {\n  @DomName('IDBIndex.count')\n  Future<int> count([key_OR_range]) {\n   try {\n      var request = _count(key_OR_range);\n      return _completeRequest(request);\n    } catch (e, stacktrace) {\n      return new Future.error(e, stacktrace);\n    }\n  }\n\n  @DomName('IDBIndex.get')\n  Future get(key) {\n    try {\n      var request = _get(key);\n\n      return _completeRequest(request);\n    } catch (e, stacktrace) {\n      return new Future.error(e, stacktrace);\n    }\n  }\n\n  @DomName('IDBIndex.getKey')\n  Future getKey(key) {\n    try {\n      var request = _getKey(key);\n\n      return _completeRequest(request);\n    } catch (e, stacktrace) {\n      return new Future.error(e, stacktrace);\n    }\n  }\n\n  /**\n   * Creates a stream of cursors over the records in this object store.\n   *\n   * See also:\n   *\n   * * [ObjectStore.openCursor]\n   */\n  Stream<CursorWithValue> openCursor({key, KeyRange range, String direction,\n      bool autoAdvance}) {\n    var key_OR_range = null;\n    if (key != null) {\n      if (range != null) {\n        throw new ArgumentError('Cannot specify both key and range.');\n      }\n      key_OR_range = key;\n    } else {\n      key_OR_range = range;\n    }\n    var request;\n    if (direction == null) {\n      request = _openCursor(key_OR_range);\n    } else {\n      request = _openCursor(key_OR_range, direction);\n    }\n    return ObjectStore._cursorStreamFromResult(request, autoAdvance);\n  }\n\n  /**\n   * Creates a stream of cursors over the records in this object store.\n   *\n   * See also:\n   *\n   * * [ObjectStore.openCursor]\n   */\n  Stream<Cursor> openKeyCursor({key, KeyRange range, String direction,\n      bool autoAdvance}) {\n    var key_OR_range = null;\n    if (key != null) {\n      if (range != null) {\n        throw new ArgumentError('Cannot specify both key and range.');\n      }\n      key_OR_range = key;\n    } else {\n      key_OR_range = range;\n    }\n    var request;\n    if (direction == null) {\n      request = _openKeyCursor(key_OR_range);\n    } else {\n      request = _openKeyCursor(key_OR_range, direction);\n    }\n    return ObjectStore._cursorStreamFromResult(request, autoAdvance);\n  }\n\n    // To suppress missing implicit constructor warnings.\n  factory Index._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('IDBIndex.keyPath')\n  @DocsEditable()\n  @annotation_Creates_SerializedScriptValue\n  final Object keyPath;\n\n  @DomName('IDBIndex.multiEntry')\n  @DocsEditable()\n  final bool multiEntry;\n\n  @DomName('IDBIndex.name')\n  @DocsEditable()\n  final String name;\n\n  @DomName('IDBIndex.objectStore')\n  @DocsEditable()\n  final ObjectStore objectStore;\n\n  @DomName('IDBIndex.unique')\n  @DocsEditable()\n  final bool unique;\n\n  @JSName('count')\n  @DomName('IDBIndex.count')\n  @DocsEditable()\n  Request _count(Object key) native;\n\n  @JSName('get')\n  @DomName('IDBIndex.get')\n  @DocsEditable()\n  @Returns('Request')\n  @Creates('Request')\n  @annotation_Creates_SerializedScriptValue\n  Request _get(Object key) native;\n\n  @JSName('getKey')\n  @DomName('IDBIndex.getKey')\n  @DocsEditable()\n  @Returns('Request')\n  @Creates('Request')\n  @annotation_Creates_SerializedScriptValue\n  @Creates('ObjectStore')\n  Request _getKey(Object key) native;\n\n  @JSName('openCursor')\n  @DomName('IDBIndex.openCursor')\n  @DocsEditable()\n  @Returns('Request')\n  @Creates('Request')\n  @Creates('Cursor')\n  Request _openCursor(Object key, [String direction]) native;\n\n  @JSName('openKeyCursor')\n  @DomName('IDBIndex.openKeyCursor')\n  @DocsEditable()\n  @Returns('Request')\n  @Creates('Request')\n  @Creates('Cursor')\n  Request _openKeyCursor(Object key, [String direction]) native;\n\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DomName('IDBKeyRange')\n@Unstable()\n@Native(\"IDBKeyRange\")\nclass KeyRange extends Interceptor {\n  @DomName('IDBKeyRange.only')\n  factory KeyRange.only(/*Key*/ value) =>\n      _KeyRangeFactoryProvider.createKeyRange_only(value);\n\n  @DomName('IDBKeyRange.lowerBound')\n  factory KeyRange.lowerBound(/*Key*/ bound, [bool open = false]) =>\n      _KeyRangeFactoryProvider.createKeyRange_lowerBound(bound, open);\n\n  @DomName('IDBKeyRange.upperBound')\n  factory KeyRange.upperBound(/*Key*/ bound, [bool open = false]) =>\n      _KeyRangeFactoryProvider.createKeyRange_upperBound(bound, open);\n\n  @DomName('KeyRange.bound')\n  factory KeyRange.bound(/*Key*/ lower, /*Key*/ upper,\n                            [bool lowerOpen = false, bool upperOpen = false]) =>\n      _KeyRangeFactoryProvider.createKeyRange_bound(\n          lower, upper, lowerOpen, upperOpen);\n\n  // To suppress missing implicit constructor warnings.\n  factory KeyRange._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('IDBKeyRange.lower')\n  @DocsEditable()\n  @annotation_Creates_SerializedScriptValue\n  final Object lower;\n\n  @DomName('IDBKeyRange.lowerOpen')\n  @DocsEditable()\n  final bool lowerOpen;\n\n  @DomName('IDBKeyRange.upper')\n  @DocsEditable()\n  @annotation_Creates_SerializedScriptValue\n  final Object upper;\n\n  @DomName('IDBKeyRange.upperOpen')\n  @DocsEditable()\n  final bool upperOpen;\n\n  @JSName('bound')\n  @DomName('IDBKeyRange.bound')\n  @DocsEditable()\n  static KeyRange bound_(Object lower, Object upper, [bool lowerOpen, bool upperOpen]) native;\n\n  @JSName('lowerBound')\n  @DomName('IDBKeyRange.lowerBound')\n  @DocsEditable()\n  static KeyRange lowerBound_(Object bound, [bool open]) native;\n\n  @JSName('only')\n  @DomName('IDBKeyRange.only')\n  @DocsEditable()\n  static KeyRange only_(Object value) native;\n\n  @JSName('upperBound')\n  @DomName('IDBKeyRange.upperBound')\n  @DocsEditable()\n  static KeyRange upperBound_(Object bound, [bool open]) native;\n\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DomName('IDBObjectStore')\n@Unstable()\n@Native(\"IDBObjectStore\")\nclass ObjectStore extends Interceptor {\n\n  @DomName('IDBObjectStore.add')\n  Future add(value, [key]) {\n    try {\n      var request;\n      if (key != null) {\n        request = _add(value, key);\n      } else {\n        request = _add(value);\n      }\n      return _completeRequest(request);\n    } catch (e, stacktrace) {\n      return new Future.error(e, stacktrace);\n    }\n  }\n\n  @DomName('IDBObjectStore.clear')\n  Future clear() {\n    try {\n      return _completeRequest(_clear());\n    } catch (e, stacktrace) {\n      return new Future.error(e, stacktrace);\n    }\n  }\n\n  @DomName('IDBObjectStore.delete')\n  Future delete(key_OR_keyRange){\n    try {\n      return _completeRequest(_delete(key_OR_keyRange));\n    } catch (e, stacktrace) {\n      return new Future.error(e, stacktrace);\n    }\n  }\n\n  @DomName('IDBObjectStore.count')\n  Future<int> count([key_OR_range]) {\n   try {\n      var request = _count(key_OR_range);\n      return _completeRequest(request);\n    } catch (e, stacktrace) {\n      return new Future.error(e, stacktrace);\n    }\n  }\n\n  @DomName('IDBObjectStore.put')\n  Future put(value, [key]) {\n    try {\n      var request;\n      if (key != null) {\n        request = _put(value, key);\n      } else {\n        request = _put(value);\n      }\n      return _completeRequest(request);\n    } catch (e, stacktrace) {\n      return new Future.error(e, stacktrace);\n    }\n  }\n\n  @DomName('IDBObjectStore.get')\n  Future getObject(key) {\n    try {\n      var request = _get(key);\n\n      return _completeRequest(request);\n    } catch (e, stacktrace) {\n      return new Future.error(e, stacktrace);\n    }\n  }\n\n  /**\n   * Creates a stream of cursors over the records in this object store.\n   *\n   * **The stream must be manually advanced by calling [Cursor.next] after\n   * each item or by specifying autoAdvance to be true.**\n   *\n   *     var cursors = objectStore.openCursor().listen(\n   *       (cursor) {\n   *         // ...some processing with the cursor\n   *         cursor.next(); // advance onto the next cursor.\n   *       },\n   *       onDone: () {\n   *         // called when there are no more cursors.\n   *         print('all done!');\n   *       });\n   *\n   * Asynchronous operations which are not related to the current transaction\n   * will cause the transaction to automatically be committed-- all processing\n   * must be done synchronously unless they are additional async requests to\n   * the current transaction.\n   */\n  @DomName('IDBObjectStore.openCursor')\n  Stream<CursorWithValue> openCursor({key, KeyRange range, String direction,\n      bool autoAdvance}) {\n    var key_OR_range = null;\n    if (key != null) {\n      if (range != null) {\n        throw new ArgumentError('Cannot specify both key and range.');\n      }\n      key_OR_range = key;\n    } else {\n      key_OR_range = range;\n    }\n\n    // TODO: try/catch this and return a stream with an immediate error.\n    var request;\n    if (direction == null) {\n      request = _openCursor(key_OR_range);\n    } else {\n      request = _openCursor(key_OR_range, direction);\n    }\n    return _cursorStreamFromResult(request, autoAdvance);\n  }\n\n  @DomName('IDBObjectStore.createIndex')\n  Index createIndex(String name, keyPath, {bool unique, bool multiEntry}) {\n    var options = {};\n    if (unique != null) {\n      options['unique'] = unique;\n    }\n    if (multiEntry != null) {\n      options['multiEntry'] = multiEntry;\n    }\n\n    return _createIndex(name, keyPath, options);\n  }\n\n  // To suppress missing implicit constructor warnings.\n  factory ObjectStore._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('IDBObjectStore.autoIncrement')\n  @DocsEditable()\n  final bool autoIncrement;\n\n  @DomName('IDBObjectStore.indexNames')\n  @DocsEditable()\n  @Returns('DomStringList')\n  @Creates('DomStringList')\n  final List<String> indexNames;\n\n  @DomName('IDBObjectStore.keyPath')\n  @DocsEditable()\n  @annotation_Creates_SerializedScriptValue\n  final Object keyPath;\n\n  @DomName('IDBObjectStore.name')\n  @DocsEditable()\n  final String name;\n\n  @DomName('IDBObjectStore.transaction')\n  @DocsEditable()\n  final Transaction transaction;\n\n  @DomName('IDBObjectStore.add')\n  @DocsEditable()\n  @Returns('Request')\n  @Creates('Request')\n  @_annotation_Creates_IDBKey\n  Request _add(/*any*/ value, [/*any*/ key]) {\n    if (key != null) {\n      var value_1 = convertDartToNative_SerializedScriptValue(value);\n      var key_2 = convertDartToNative_SerializedScriptValue(key);\n      return _add_1(value_1, key_2);\n    }\n    var value_3 = convertDartToNative_SerializedScriptValue(value);\n    return _add_2(value_3);\n  }\n  @JSName('add')\n  @DomName('IDBObjectStore.add')\n  @DocsEditable()\n  @Returns('Request')\n  @Creates('Request')\n  @_annotation_Creates_IDBKey\n  Request _add_1(value, key) native;\n  @JSName('add')\n  @DomName('IDBObjectStore.add')\n  @DocsEditable()\n  @Returns('Request')\n  @Creates('Request')\n  @_annotation_Creates_IDBKey\n  Request _add_2(value) native;\n\n  @JSName('clear')\n  @DomName('IDBObjectStore.clear')\n  @DocsEditable()\n  Request _clear() native;\n\n  @JSName('count')\n  @DomName('IDBObjectStore.count')\n  @DocsEditable()\n  Request _count(Object key) native;\n\n  @DomName('IDBObjectStore.createIndex')\n  @DocsEditable()\n  Index _createIndex(String name, keyPath, [Map options]) {\n    if ((keyPath is List<String> || keyPath == null) && options == null) {\n      List keyPath_1 = convertDartToNative_StringArray(keyPath);\n      return _createIndex_1(name, keyPath_1);\n    }\n    if (options != null && (keyPath is List<String> || keyPath == null)) {\n      List keyPath_2 = convertDartToNative_StringArray(keyPath);\n      var options_3 = convertDartToNative_Dictionary(options);\n      return _createIndex_2(name, keyPath_2, options_3);\n    }\n    if ((keyPath is String || keyPath == null) && options == null) {\n      return _createIndex_3(name, keyPath);\n    }\n    if (options != null && (keyPath is String || keyPath == null)) {\n      var options_4 = convertDartToNative_Dictionary(options);\n      return _createIndex_4(name, keyPath, options_4);\n    }\n    throw new ArgumentError(\"Incorrect number or type of arguments\");\n  }\n  @JSName('createIndex')\n  @DomName('IDBObjectStore.createIndex')\n  @DocsEditable()\n  Index _createIndex_1(name, List keyPath) native;\n  @JSName('createIndex')\n  @DomName('IDBObjectStore.createIndex')\n  @DocsEditable()\n  Index _createIndex_2(name, List keyPath, options) native;\n  @JSName('createIndex')\n  @DomName('IDBObjectStore.createIndex')\n  @DocsEditable()\n  Index _createIndex_3(name, String keyPath) native;\n  @JSName('createIndex')\n  @DomName('IDBObjectStore.createIndex')\n  @DocsEditable()\n  Index _createIndex_4(name, String keyPath, options) native;\n\n  @JSName('delete')\n  @DomName('IDBObjectStore.delete')\n  @DocsEditable()\n  Request _delete(Object key) native;\n\n  @DomName('IDBObjectStore.deleteIndex')\n  @DocsEditable()\n  void deleteIndex(String name) native;\n\n  @JSName('get')\n  @DomName('IDBObjectStore.get')\n  @DocsEditable()\n  @Returns('Request')\n  @Creates('Request')\n  @annotation_Creates_SerializedScriptValue\n  Request _get(Object key) native;\n\n  @DomName('IDBObjectStore.index')\n  @DocsEditable()\n  Index index(String name) native;\n\n  @JSName('openCursor')\n  @DomName('IDBObjectStore.openCursor')\n  @DocsEditable()\n  @Returns('Request')\n  @Creates('Request')\n  @Creates('Cursor')\n  Request _openCursor(Object key, [String direction]) native;\n\n  @DomName('IDBObjectStore.openKeyCursor')\n  @DocsEditable()\n  @Experimental() // untriaged\n  Request openKeyCursor(Object range, String direction) native;\n\n  @DomName('IDBObjectStore.put')\n  @DocsEditable()\n  @Returns('Request')\n  @Creates('Request')\n  @_annotation_Creates_IDBKey\n  Request _put(/*any*/ value, [/*any*/ key]) {\n    if (key != null) {\n      var value_1 = convertDartToNative_SerializedScriptValue(value);\n      var key_2 = convertDartToNative_SerializedScriptValue(key);\n      return _put_1(value_1, key_2);\n    }\n    var value_3 = convertDartToNative_SerializedScriptValue(value);\n    return _put_2(value_3);\n  }\n  @JSName('put')\n  @DomName('IDBObjectStore.put')\n  @DocsEditable()\n  @Returns('Request')\n  @Creates('Request')\n  @_annotation_Creates_IDBKey\n  Request _put_1(value, key) native;\n  @JSName('put')\n  @DomName('IDBObjectStore.put')\n  @DocsEditable()\n  @Returns('Request')\n  @Creates('Request')\n  @_annotation_Creates_IDBKey\n  Request _put_2(value) native;\n\n\n  /**\n   * Helper for iterating over cursors in a request.\n   */\n  static Stream<Cursor> _cursorStreamFromResult(Request request,\n      bool autoAdvance) {\n    // TODO: need to guarantee that the controller provides the values\n    // immediately as waiting until the next tick will cause the transaction to\n    // close.\n    var controller = new StreamController(sync: true);\n\n    //TODO: Report stacktrace once issue 4061 is resolved.\n    request.onError.listen(controller.addError);\n\n    request.onSuccess.listen((e) {\n      Cursor cursor = request.result;\n      if (cursor == null) {\n        controller.close();\n      } else {\n        controller.add(cursor);\n        if (autoAdvance == true && controller.hasListener) {\n          cursor.next();\n        }\n      }\n    });\n    return controller.stream;\n  }\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('IDBOpenDBRequest')\n@Unstable()\n@Native(\"IDBOpenDBRequest,IDBVersionChangeRequest\")\nclass OpenDBRequest extends Request {\n  // To suppress missing implicit constructor warnings.\n  factory OpenDBRequest._() { throw new UnsupportedError(\"Not supported\"); }\n\n  /**\n   * Static factory designed to expose `blocked` events to event\n   * handlers that are not necessarily instances of [OpenDBRequest].\n   *\n   * See [EventStreamProvider] for usage information.\n   */\n  @DomName('IDBOpenDBRequest.blockedEvent')\n  @DocsEditable()\n  static const EventStreamProvider<Event> blockedEvent = const EventStreamProvider<Event>('blocked');\n\n  /**\n   * Static factory designed to expose `upgradeneeded` events to event\n   * handlers that are not necessarily instances of [OpenDBRequest].\n   *\n   * See [EventStreamProvider] for usage information.\n   */\n  @DomName('IDBOpenDBRequest.upgradeneededEvent')\n  @DocsEditable()\n  static const EventStreamProvider<VersionChangeEvent> upgradeNeededEvent = const EventStreamProvider<VersionChangeEvent>('upgradeneeded');\n\n  /// Stream of `blocked` events handled by this [OpenDBRequest].\n  @DomName('IDBOpenDBRequest.onblocked')\n  @DocsEditable()\n  Stream<Event> get onBlocked => blockedEvent.forTarget(this);\n\n  /// Stream of `upgradeneeded` events handled by this [OpenDBRequest].\n  @DomName('IDBOpenDBRequest.onupgradeneeded')\n  @DocsEditable()\n  Stream<VersionChangeEvent> get onUpgradeNeeded => upgradeNeededEvent.forTarget(this);\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('IDBRequest')\n@Unstable()\n@Native(\"IDBRequest\")\nclass Request extends EventTarget {\n  // To suppress missing implicit constructor warnings.\n  factory Request._() { throw new UnsupportedError(\"Not supported\"); }\n\n  /**\n   * Static factory designed to expose `error` events to event\n   * handlers that are not necessarily instances of [Request].\n   *\n   * See [EventStreamProvider] for usage information.\n   */\n  @DomName('IDBRequest.errorEvent')\n  @DocsEditable()\n  static const EventStreamProvider<Event> errorEvent = const EventStreamProvider<Event>('error');\n\n  /**\n   * Static factory designed to expose `success` events to event\n   * handlers that are not necessarily instances of [Request].\n   *\n   * See [EventStreamProvider] for usage information.\n   */\n  @DomName('IDBRequest.successEvent')\n  @DocsEditable()\n  static const EventStreamProvider<Event> successEvent = const EventStreamProvider<Event>('success');\n\n  @DomName('IDBRequest.error')\n  @DocsEditable()\n  final DomError error;\n\n  @DomName('IDBRequest.readyState')\n  @DocsEditable()\n  final String readyState;\n\n  @DomName('IDBRequest.result')\n  @DocsEditable()\n  dynamic get result => _convertNativeToDart_IDBAny(this._get_result);\n  @JSName('result')\n  @DomName('IDBRequest.result')\n  @DocsEditable()\n  @Creates('Null')\n  final dynamic _get_result;\n\n  @DomName('IDBRequest.source')\n  @DocsEditable()\n  @Creates('Null')\n  final Object source;\n\n  @DomName('IDBRequest.transaction')\n  @DocsEditable()\n  final Transaction transaction;\n\n  /// Stream of `error` events handled by this [Request].\n  @DomName('IDBRequest.onerror')\n  @DocsEditable()\n  Stream<Event> get onError => errorEvent.forTarget(this);\n\n  /// Stream of `success` events handled by this [Request].\n  @DomName('IDBRequest.onsuccess')\n  @DocsEditable()\n  Stream<Event> get onSuccess => successEvent.forTarget(this);\n}\n// Copyright (c) 2013, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DomName('IDBTransaction')\n@Unstable()\n@Native(\"IDBTransaction\")\nclass Transaction extends EventTarget {\n\n  /**\n   * Provides a Future which will be completed once the transaction has\n   * completed.\n   *\n   * The future will error if an error occurrs on the transaction or if the\n   * transaction is aborted.\n   */\n  Future<Database> get completed {\n    var completer = new Completer<Database>();\n\n    this.onComplete.first.then((_) {\n      completer.complete(db);\n    });\n\n    this.onError.first.then((e) {\n      completer.completeError(e);\n    });\n\n    this.onAbort.first.then((e) {\n      // Avoid completing twice if an error occurs.\n      if (!completer.isCompleted) {\n        completer.completeError(e);\n      }\n    });\n\n    return completer.future;\n  }\n\n  // To suppress missing implicit constructor warnings.\n  factory Transaction._() { throw new UnsupportedError(\"Not supported\"); }\n\n  /**\n   * Static factory designed to expose `abort` events to event\n   * handlers that are not necessarily instances of [Transaction].\n   *\n   * See [EventStreamProvider] for usage information.\n   */\n  @DomName('IDBTransaction.abortEvent')\n  @DocsEditable()\n  static const EventStreamProvider<Event> abortEvent = const EventStreamProvider<Event>('abort');\n\n  /**\n   * Static factory designed to expose `complete` events to event\n   * handlers that are not necessarily instances of [Transaction].\n   *\n   * See [EventStreamProvider] for usage information.\n   */\n  @DomName('IDBTransaction.completeEvent')\n  @DocsEditable()\n  static const EventStreamProvider<Event> completeEvent = const EventStreamProvider<Event>('complete');\n\n  /**\n   * Static factory designed to expose `error` events to event\n   * handlers that are not necessarily instances of [Transaction].\n   *\n   * See [EventStreamProvider] for usage information.\n   */\n  @DomName('IDBTransaction.errorEvent')\n  @DocsEditable()\n  static const EventStreamProvider<Event> errorEvent = const EventStreamProvider<Event>('error');\n\n  @DomName('IDBTransaction.db')\n  @DocsEditable()\n  final Database db;\n\n  @DomName('IDBTransaction.error')\n  @DocsEditable()\n  final DomError error;\n\n  @DomName('IDBTransaction.mode')\n  @DocsEditable()\n  final String mode;\n\n  @DomName('IDBTransaction.abort')\n  @DocsEditable()\n  void abort() native;\n\n  @DomName('IDBTransaction.objectStore')\n  @DocsEditable()\n  ObjectStore objectStore(String name) native;\n\n  /// Stream of `abort` events handled by this [Transaction].\n  @DomName('IDBTransaction.onabort')\n  @DocsEditable()\n  Stream<Event> get onAbort => abortEvent.forTarget(this);\n\n  /// Stream of `complete` events handled by this [Transaction].\n  @DomName('IDBTransaction.oncomplete')\n  @DocsEditable()\n  Stream<Event> get onComplete => completeEvent.forTarget(this);\n\n  /// Stream of `error` events handled by this [Transaction].\n  @DomName('IDBTransaction.onerror')\n  @DocsEditable()\n  Stream<Event> get onError => errorEvent.forTarget(this);\n\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('IDBVersionChangeEvent')\n@Unstable()\n@Native(\"IDBVersionChangeEvent\")\nclass VersionChangeEvent extends Event {\n  // To suppress missing implicit constructor warnings.\n  factory VersionChangeEvent._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('IDBVersionChangeEvent.dataLoss')\n  @DocsEditable()\n  @Experimental() // untriaged\n  final String dataLoss;\n\n  @DomName('IDBVersionChangeEvent.dataLossMessage')\n  @DocsEditable()\n  @Experimental() // untriaged\n  final String dataLossMessage;\n\n  @DomName('IDBVersionChangeEvent.newVersion')\n  @DocsEditable()\n  @Creates('int|String|Null')\n  @Returns('int|String|Null')\n  final Object newVersion;\n\n  @DomName('IDBVersionChangeEvent.oldVersion')\n  @DocsEditable()\n  @Creates('int|String|Null')\n  @Returns('int|String|Null')\n  final Object oldVersion;\n}\n\u0000","sdk:/sdk/lib/svg/dart2js/svg_dart2js.dart":"/**\n * Scalable Vector Graphics:\n * Two-dimensional vector graphics with support for events and animation.\n *\n * For details about the features and syntax of SVG, a W3C standard,\n * refer to the\n * [Scalable Vector Graphics Specification](http://www.w3.org/TR/SVG/).\n */\nlibrary dart.dom.svg;\n\nimport 'dart:async';\nimport 'dart:collection';\nimport 'dart:_internal' hide deprecated;\nimport 'dart:html';\nimport 'dart:html_common';\nimport 'dart:_js_helper' show Creates, Returns, JSName, Native;\nimport 'dart:_foreign_helper' show JS;\nimport 'dart:_interceptors' show Interceptor;\n// DO NOT EDIT - unless you are editing documentation as per:\n// https://code.google.com/p/dart/wiki/ContributingHTMLDocumentation\n// Auto-generated dart:svg library.\n\n\n\n\n\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\nclass _SvgElementFactoryProvider {\n  static SvgElement createSvgElement_tag(String tag) {\n    final Element temp =\n      document.createElementNS(\"http://www.w3.org/2000/svg\", tag);\n    return temp;\n  }\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('SVGAElement')\n@Unstable()\n@Native(\"SVGAElement\")\nclass AElement extends GraphicsElement implements UriReference {\n  // To suppress missing implicit constructor warnings.\n  factory AElement._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('SVGAElement.SVGAElement')\n  @DocsEditable()\n  factory AElement() => _SvgElementFactoryProvider.createSvgElement_tag(\"a\");\n  /**\n   * Constructor instantiated by the DOM when a custom element has been created.\n   *\n   * This can only be called by subclasses from their created constructor.\n   */\n  AElement.created() : super.created();\n\n  @DomName('SVGAElement.target')\n  @DocsEditable()\n  final AnimatedString target;\n\n  // From SVGURIReference\n\n  @DomName('SVGAElement.href')\n  @DocsEditable()\n  final AnimatedString href;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('SVGAltGlyphElement')\n@SupportedBrowser(SupportedBrowser.CHROME)\n@SupportedBrowser(SupportedBrowser.FIREFOX)\n@SupportedBrowser(SupportedBrowser.SAFARI)\n@Unstable()\n@Native(\"SVGAltGlyphElement\")\nclass AltGlyphElement extends TextPositioningElement implements UriReference {\n  // To suppress missing implicit constructor warnings.\n  factory AltGlyphElement._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('SVGAltGlyphElement.SVGAltGlyphElement')\n  @DocsEditable()\n  factory AltGlyphElement() => _SvgElementFactoryProvider.createSvgElement_tag(\"altGlyph\");\n  /**\n   * Constructor instantiated by the DOM when a custom element has been created.\n   *\n   * This can only be called by subclasses from their created constructor.\n   */\n  AltGlyphElement.created() : super.created();\n\n  /// Checks if this type is supported on the current platform.\n  static bool get supported => SvgElement.isTagSupported('altGlyph') && (new SvgElement.tag('altGlyph') is AltGlyphElement);\n\n  @DomName('SVGAltGlyphElement.format')\n  @DocsEditable()\n  String format;\n\n  @DomName('SVGAltGlyphElement.glyphRef')\n  @DocsEditable()\n  String glyphRef;\n\n  // From SVGURIReference\n\n  @DomName('SVGAltGlyphElement.href')\n  @DocsEditable()\n  final AnimatedString href;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('SVGAngle')\n@Unstable()\n@Native(\"SVGAngle\")\nclass Angle extends Interceptor {\n  // To suppress missing implicit constructor warnings.\n  factory Angle._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('SVGAngle.SVG_ANGLETYPE_DEG')\n  @DocsEditable()\n  static const int SVG_ANGLETYPE_DEG = 2;\n\n  @DomName('SVGAngle.SVG_ANGLETYPE_GRAD')\n  @DocsEditable()\n  static const int SVG_ANGLETYPE_GRAD = 4;\n\n  @DomName('SVGAngle.SVG_ANGLETYPE_RAD')\n  @DocsEditable()\n  static const int SVG_ANGLETYPE_RAD = 3;\n\n  @DomName('SVGAngle.SVG_ANGLETYPE_UNKNOWN')\n  @DocsEditable()\n  static const int SVG_ANGLETYPE_UNKNOWN = 0;\n\n  @DomName('SVGAngle.SVG_ANGLETYPE_UNSPECIFIED')\n  @DocsEditable()\n  static const int SVG_ANGLETYPE_UNSPECIFIED = 1;\n\n  @DomName('SVGAngle.unitType')\n  @DocsEditable()\n  final int unitType;\n\n  @DomName('SVGAngle.value')\n  @DocsEditable()\n  num value;\n\n  @DomName('SVGAngle.valueAsString')\n  @DocsEditable()\n  String valueAsString;\n\n  @DomName('SVGAngle.valueInSpecifiedUnits')\n  @DocsEditable()\n  num valueInSpecifiedUnits;\n\n  @DomName('SVGAngle.convertToSpecifiedUnits')\n  @DocsEditable()\n  void convertToSpecifiedUnits(int unitType) native;\n\n  @DomName('SVGAngle.newValueSpecifiedUnits')\n  @DocsEditable()\n  void newValueSpecifiedUnits(int unitType, num valueInSpecifiedUnits) native;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('SVGAnimateElement')\n@SupportedBrowser(SupportedBrowser.CHROME)\n@SupportedBrowser(SupportedBrowser.FIREFOX)\n@SupportedBrowser(SupportedBrowser.SAFARI)\n@Unstable()\n@Native(\"SVGAnimateElement\")\nclass AnimateElement extends AnimationElement {\n  // To suppress missing implicit constructor warnings.\n  factory AnimateElement._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('SVGAnimateElement.SVGAnimateElement')\n  @DocsEditable()\n  factory AnimateElement() => _SvgElementFactoryProvider.createSvgElement_tag(\"animate\");\n  /**\n   * Constructor instantiated by the DOM when a custom element has been created.\n   *\n   * This can only be called by subclasses from their created constructor.\n   */\n  AnimateElement.created() : super.created();\n\n  /// Checks if this type is supported on the current platform.\n  static bool get supported => SvgElement.isTagSupported('animate') && (new SvgElement.tag('animate') is AnimateElement);\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('SVGAnimateMotionElement')\n@SupportedBrowser(SupportedBrowser.CHROME)\n@SupportedBrowser(SupportedBrowser.FIREFOX)\n@SupportedBrowser(SupportedBrowser.SAFARI)\n@Unstable()\n@Native(\"SVGAnimateMotionElement\")\nclass AnimateMotionElement extends AnimationElement {\n  // To suppress missing implicit constructor warnings.\n  factory AnimateMotionElement._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('SVGAnimateMotionElement.SVGAnimateMotionElement')\n  @DocsEditable()\n  factory AnimateMotionElement() => _SvgElementFactoryProvider.createSvgElement_tag(\"animateMotion\");\n  /**\n   * Constructor instantiated by the DOM when a custom element has been created.\n   *\n   * This can only be called by subclasses from their created constructor.\n   */\n  AnimateMotionElement.created() : super.created();\n\n  /// Checks if this type is supported on the current platform.\n  static bool get supported => SvgElement.isTagSupported('animateMotion') && (new SvgElement.tag('animateMotion') is AnimateMotionElement);\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('SVGAnimateTransformElement')\n@SupportedBrowser(SupportedBrowser.CHROME)\n@SupportedBrowser(SupportedBrowser.FIREFOX)\n@SupportedBrowser(SupportedBrowser.SAFARI)\n@Unstable()\n@Native(\"SVGAnimateTransformElement\")\nclass AnimateTransformElement extends AnimationElement {\n  // To suppress missing implicit constructor warnings.\n  factory AnimateTransformElement._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('SVGAnimateTransformElement.SVGAnimateTransformElement')\n  @DocsEditable()\n  factory AnimateTransformElement() => _SvgElementFactoryProvider.createSvgElement_tag(\"animateTransform\");\n  /**\n   * Constructor instantiated by the DOM when a custom element has been created.\n   *\n   * This can only be called by subclasses from their created constructor.\n   */\n  AnimateTransformElement.created() : super.created();\n\n  /// Checks if this type is supported on the current platform.\n  static bool get supported => SvgElement.isTagSupported('animateTransform') && (new SvgElement.tag('animateTransform') is AnimateTransformElement);\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('SVGAnimatedAngle')\n@Unstable()\n@Native(\"SVGAnimatedAngle\")\nclass AnimatedAngle extends Interceptor {\n  // To suppress missing implicit constructor warnings.\n  factory AnimatedAngle._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('SVGAnimatedAngle.animVal')\n  @DocsEditable()\n  final Angle animVal;\n\n  @DomName('SVGAnimatedAngle.baseVal')\n  @DocsEditable()\n  final Angle baseVal;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('SVGAnimatedBoolean')\n@Unstable()\n@Native(\"SVGAnimatedBoolean\")\nclass AnimatedBoolean extends Interceptor {\n  // To suppress missing implicit constructor warnings.\n  factory AnimatedBoolean._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('SVGAnimatedBoolean.animVal')\n  @DocsEditable()\n  final bool animVal;\n\n  @DomName('SVGAnimatedBoolean.baseVal')\n  @DocsEditable()\n  bool baseVal;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('SVGAnimatedEnumeration')\n@Unstable()\n@Native(\"SVGAnimatedEnumeration\")\nclass AnimatedEnumeration extends Interceptor {\n  // To suppress missing implicit constructor warnings.\n  factory AnimatedEnumeration._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('SVGAnimatedEnumeration.animVal')\n  @DocsEditable()\n  final int animVal;\n\n  @DomName('SVGAnimatedEnumeration.baseVal')\n  @DocsEditable()\n  int baseVal;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('SVGAnimatedInteger')\n@Unstable()\n@Native(\"SVGAnimatedInteger\")\nclass AnimatedInteger extends Interceptor {\n  // To suppress missing implicit constructor warnings.\n  factory AnimatedInteger._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('SVGAnimatedInteger.animVal')\n  @DocsEditable()\n  final int animVal;\n\n  @DomName('SVGAnimatedInteger.baseVal')\n  @DocsEditable()\n  int baseVal;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('SVGAnimatedLength')\n@Unstable()\n@Native(\"SVGAnimatedLength\")\nclass AnimatedLength extends Interceptor {\n  // To suppress missing implicit constructor warnings.\n  factory AnimatedLength._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('SVGAnimatedLength.animVal')\n  @DocsEditable()\n  final Length animVal;\n\n  @DomName('SVGAnimatedLength.baseVal')\n  @DocsEditable()\n  final Length baseVal;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('SVGAnimatedLengthList')\n@Unstable()\n@Native(\"SVGAnimatedLengthList\")\nclass AnimatedLengthList extends Interceptor {\n  // To suppress missing implicit constructor warnings.\n  factory AnimatedLengthList._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('SVGAnimatedLengthList.animVal')\n  @DocsEditable()\n  final LengthList animVal;\n\n  @DomName('SVGAnimatedLengthList.baseVal')\n  @DocsEditable()\n  final LengthList baseVal;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('SVGAnimatedNumber')\n@Unstable()\n@Native(\"SVGAnimatedNumber\")\nclass AnimatedNumber extends Interceptor {\n  // To suppress missing implicit constructor warnings.\n  factory AnimatedNumber._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('SVGAnimatedNumber.animVal')\n  @DocsEditable()\n  final double animVal;\n\n  @DomName('SVGAnimatedNumber.baseVal')\n  @DocsEditable()\n  num baseVal;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('SVGAnimatedNumberList')\n@Unstable()\n@Native(\"SVGAnimatedNumberList\")\nclass AnimatedNumberList extends Interceptor {\n  // To suppress missing implicit constructor warnings.\n  factory AnimatedNumberList._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('SVGAnimatedNumberList.animVal')\n  @DocsEditable()\n  final NumberList animVal;\n\n  @DomName('SVGAnimatedNumberList.baseVal')\n  @DocsEditable()\n  final NumberList baseVal;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('SVGAnimatedPreserveAspectRatio')\n@Unstable()\n@Native(\"SVGAnimatedPreserveAspectRatio\")\nclass AnimatedPreserveAspectRatio extends Interceptor {\n  // To suppress missing implicit constructor warnings.\n  factory AnimatedPreserveAspectRatio._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('SVGAnimatedPreserveAspectRatio.animVal')\n  @DocsEditable()\n  final PreserveAspectRatio animVal;\n\n  @DomName('SVGAnimatedPreserveAspectRatio.baseVal')\n  @DocsEditable()\n  final PreserveAspectRatio baseVal;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('SVGAnimatedRect')\n@Unstable()\n@Native(\"SVGAnimatedRect\")\nclass AnimatedRect extends Interceptor {\n  // To suppress missing implicit constructor warnings.\n  factory AnimatedRect._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('SVGAnimatedRect.animVal')\n  @DocsEditable()\n  final Rect animVal;\n\n  @DomName('SVGAnimatedRect.baseVal')\n  @DocsEditable()\n  final Rect baseVal;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('SVGAnimatedString')\n@Unstable()\n@Native(\"SVGAnimatedString\")\nclass AnimatedString extends Interceptor {\n  // To suppress missing implicit constructor warnings.\n  factory AnimatedString._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('SVGAnimatedString.animVal')\n  @DocsEditable()\n  final String animVal;\n\n  @DomName('SVGAnimatedString.baseVal')\n  @DocsEditable()\n  String baseVal;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('SVGAnimatedTransformList')\n@Unstable()\n@Native(\"SVGAnimatedTransformList\")\nclass AnimatedTransformList extends Interceptor {\n  // To suppress missing implicit constructor warnings.\n  factory AnimatedTransformList._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('SVGAnimatedTransformList.animVal')\n  @DocsEditable()\n  final TransformList animVal;\n\n  @DomName('SVGAnimatedTransformList.baseVal')\n  @DocsEditable()\n  final TransformList baseVal;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('SVGAnimationElement')\n@Unstable()\n@Native(\"SVGAnimationElement\")\nclass AnimationElement extends SvgElement implements Tests {\n  // To suppress missing implicit constructor warnings.\n  factory AnimationElement._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('SVGAnimationElement.SVGAnimationElement')\n  @DocsEditable()\n  factory AnimationElement() => _SvgElementFactoryProvider.createSvgElement_tag(\"animation\");\n  /**\n   * Constructor instantiated by the DOM when a custom element has been created.\n   *\n   * This can only be called by subclasses from their created constructor.\n   */\n  AnimationElement.created() : super.created();\n\n  @DomName('SVGAnimationElement.targetElement')\n  @DocsEditable()\n  final SvgElement targetElement;\n\n  @DomName('SVGAnimationElement.beginElement')\n  @DocsEditable()\n  void beginElement() native;\n\n  @DomName('SVGAnimationElement.beginElementAt')\n  @DocsEditable()\n  void beginElementAt(num offset) native;\n\n  @DomName('SVGAnimationElement.endElement')\n  @DocsEditable()\n  void endElement() native;\n\n  @DomName('SVGAnimationElement.endElementAt')\n  @DocsEditable()\n  void endElementAt(num offset) native;\n\n  @DomName('SVGAnimationElement.getCurrentTime')\n  @DocsEditable()\n  double getCurrentTime() native;\n\n  @DomName('SVGAnimationElement.getSimpleDuration')\n  @DocsEditable()\n  double getSimpleDuration() native;\n\n  @DomName('SVGAnimationElement.getStartTime')\n  @DocsEditable()\n  double getStartTime() native;\n\n  // From SVGTests\n\n  @DomName('SVGAnimationElement.requiredExtensions')\n  @DocsEditable()\n  final StringList requiredExtensions;\n\n  @DomName('SVGAnimationElement.requiredFeatures')\n  @DocsEditable()\n  final StringList requiredFeatures;\n\n  @DomName('SVGAnimationElement.systemLanguage')\n  @DocsEditable()\n  final StringList systemLanguage;\n\n  @DomName('SVGAnimationElement.hasExtension')\n  @DocsEditable()\n  bool hasExtension(String extension) native;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('SVGCircleElement')\n@Unstable()\n@Native(\"SVGCircleElement\")\nclass CircleElement extends GeometryElement {\n  // To suppress missing implicit constructor warnings.\n  factory CircleElement._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('SVGCircleElement.SVGCircleElement')\n  @DocsEditable()\n  factory CircleElement() => _SvgElementFactoryProvider.createSvgElement_tag(\"circle\");\n  /**\n   * Constructor instantiated by the DOM when a custom element has been created.\n   *\n   * This can only be called by subclasses from their created constructor.\n   */\n  CircleElement.created() : super.created();\n\n  @DomName('SVGCircleElement.cx')\n  @DocsEditable()\n  final AnimatedLength cx;\n\n  @DomName('SVGCircleElement.cy')\n  @DocsEditable()\n  final AnimatedLength cy;\n\n  @DomName('SVGCircleElement.r')\n  @DocsEditable()\n  final AnimatedLength r;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('SVGClipPathElement')\n@Unstable()\n@Native(\"SVGClipPathElement\")\nclass ClipPathElement extends GraphicsElement {\n  // To suppress missing implicit constructor warnings.\n  factory ClipPathElement._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('SVGClipPathElement.SVGClipPathElement')\n  @DocsEditable()\n  factory ClipPathElement() => _SvgElementFactoryProvider.createSvgElement_tag(\"clipPath\");\n  /**\n   * Constructor instantiated by the DOM when a custom element has been created.\n   *\n   * This can only be called by subclasses from their created constructor.\n   */\n  ClipPathElement.created() : super.created();\n\n  @DomName('SVGClipPathElement.clipPathUnits')\n  @DocsEditable()\n  final AnimatedEnumeration clipPathUnits;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('SVGDefsElement')\n@Unstable()\n@Native(\"SVGDefsElement\")\nclass DefsElement extends GraphicsElement {\n  // To suppress missing implicit constructor warnings.\n  factory DefsElement._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('SVGDefsElement.SVGDefsElement')\n  @DocsEditable()\n  factory DefsElement() => _SvgElementFactoryProvider.createSvgElement_tag(\"defs\");\n  /**\n   * Constructor instantiated by the DOM when a custom element has been created.\n   *\n   * This can only be called by subclasses from their created constructor.\n   */\n  DefsElement.created() : super.created();\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('SVGDescElement')\n@Unstable()\n@Native(\"SVGDescElement\")\nclass DescElement extends SvgElement {\n  // To suppress missing implicit constructor warnings.\n  factory DescElement._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('SVGDescElement.SVGDescElement')\n  @DocsEditable()\n  factory DescElement() => _SvgElementFactoryProvider.createSvgElement_tag(\"desc\");\n  /**\n   * Constructor instantiated by the DOM when a custom element has been created.\n   *\n   * This can only be called by subclasses from their created constructor.\n   */\n  DescElement.created() : super.created();\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('SVGDiscardElement')\n@Experimental() // untriaged\n@Native(\"SVGDiscardElement\")\nclass DiscardElement extends SvgElement {\n  // To suppress missing implicit constructor warnings.\n  factory DiscardElement._() { throw new UnsupportedError(\"Not supported\"); }\n  /**\n   * Constructor instantiated by the DOM when a custom element has been created.\n   *\n   * This can only be called by subclasses from their created constructor.\n   */\n  DiscardElement.created() : super.created();\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('SVGElementInstance')\n@Unstable()\n@Native(\"SVGElementInstance\")\nclass ElementInstance extends EventTarget {\n  // To suppress missing implicit constructor warnings.\n  factory ElementInstance._() { throw new UnsupportedError(\"Not supported\"); }\n\n  /**\n   * Static factory designed to expose `abort` events to event\n   * handlers that are not necessarily instances of [ElementInstance].\n   *\n   * See [EventStreamProvider] for usage information.\n   */\n  @DomName('SVGElementInstance.abortEvent')\n  @DocsEditable()\n  static const EventStreamProvider<Event> abortEvent = const EventStreamProvider<Event>('abort');\n\n  /**\n   * Static factory designed to expose `beforecopy` events to event\n   * handlers that are not necessarily instances of [ElementInstance].\n   *\n   * See [EventStreamProvider] for usage information.\n   */\n  @DomName('SVGElementInstance.beforecopyEvent')\n  @DocsEditable()\n  static const EventStreamProvider<Event> beforeCopyEvent = const EventStreamProvider<Event>('beforecopy');\n\n  /**\n   * Static factory designed to expose `beforecut` events to event\n   * handlers that are not necessarily instances of [ElementInstance].\n   *\n   * See [EventStreamProvider] for usage information.\n   */\n  @DomName('SVGElementInstance.beforecutEvent')\n  @DocsEditable()\n  static const EventStreamProvider<Event> beforeCutEvent = const EventStreamProvider<Event>('beforecut');\n\n  /**\n   * Static factory designed to expose `beforepaste` events to event\n   * handlers that are not necessarily instances of [ElementInstance].\n   *\n   * See [EventStreamProvider] for usage information.\n   */\n  @DomName('SVGElementInstance.beforepasteEvent')\n  @DocsEditable()\n  static const EventStreamProvider<Event> beforePasteEvent = const EventStreamProvider<Event>('beforepaste');\n\n  /**\n   * Static factory designed to expose `blur` events to event\n   * handlers that are not necessarily instances of [ElementInstance].\n   *\n   * See [EventStreamProvider] for usage information.\n   */\n  @DomName('SVGElementInstance.blurEvent')\n  @DocsEditable()\n  static const EventStreamProvider<Event> blurEvent = const EventStreamProvider<Event>('blur');\n\n  /**\n   * Static factory designed to expose `change` events to event\n   * handlers that are not necessarily instances of [ElementInstance].\n   *\n   * See [EventStreamProvider] for usage information.\n   */\n  @DomName('SVGElementInstance.changeEvent')\n  @DocsEditable()\n  static const EventStreamProvider<Event> changeEvent = const EventStreamProvider<Event>('change');\n\n  /**\n   * Static factory designed to expose `click` events to event\n   * handlers that are not necessarily instances of [ElementInstance].\n   *\n   * See [EventStreamProvider] for usage information.\n   */\n  @DomName('SVGElementInstance.clickEvent')\n  @DocsEditable()\n  static const EventStreamProvider<MouseEvent> clickEvent = const EventStreamProvider<MouseEvent>('click');\n\n  /**\n   * Static factory designed to expose `contextmenu` events to event\n   * handlers that are not necessarily instances of [ElementInstance].\n   *\n   * See [EventStreamProvider] for usage information.\n   */\n  @DomName('SVGElementInstance.contextmenuEvent')\n  @DocsEditable()\n  static const EventStreamProvider<MouseEvent> contextMenuEvent = const EventStreamProvider<MouseEvent>('contextmenu');\n\n  /**\n   * Static factory designed to expose `copy` events to event\n   * handlers that are not necessarily instances of [ElementInstance].\n   *\n   * See [EventStreamProvider] for usage information.\n   */\n  @DomName('SVGElementInstance.copyEvent')\n  @DocsEditable()\n  static const EventStreamProvider<Event> copyEvent = const EventStreamProvider<Event>('copy');\n\n  /**\n   * Static factory designed to expose `cut` events to event\n   * handlers that are not necessarily instances of [ElementInstance].\n   *\n   * See [EventStreamProvider] for usage information.\n   */\n  @DomName('SVGElementInstance.cutEvent')\n  @DocsEditable()\n  static const EventStreamProvider<Event> cutEvent = const EventStreamProvider<Event>('cut');\n\n  /**\n   * Static factory designed to expose `doubleclick` events to event\n   * handlers that are not necessarily instances of [ElementInstance].\n   *\n   * See [EventStreamProvider] for usage information.\n   */\n  @DomName('SVGElementInstance.dblclickEvent')\n  @DocsEditable()\n  static const EventStreamProvider<Event> doubleClickEvent = const EventStreamProvider<Event>('dblclick');\n\n  /**\n   * Static factory designed to expose `drag` events to event\n   * handlers that are not necessarily instances of [ElementInstance].\n   *\n   * See [EventStreamProvider] for usage information.\n   */\n  @DomName('SVGElementInstance.dragEvent')\n  @DocsEditable()\n  static const EventStreamProvider<MouseEvent> dragEvent = const EventStreamProvider<MouseEvent>('drag');\n\n  /**\n   * Static factory designed to expose `dragend` events to event\n   * handlers that are not necessarily instances of [ElementInstance].\n   *\n   * See [EventStreamProvider] for usage information.\n   */\n  @DomName('SVGElementInstance.dragendEvent')\n  @DocsEditable()\n  static const EventStreamProvider<MouseEvent> dragEndEvent = const EventStreamProvider<MouseEvent>('dragend');\n\n  /**\n   * Static factory designed to expose `dragenter` events to event\n   * handlers that are not necessarily instances of [ElementInstance].\n   *\n   * See [EventStreamProvider] for usage information.\n   */\n  @DomName('SVGElementInstance.dragenterEvent')\n  @DocsEditable()\n  static const EventStreamProvider<MouseEvent> dragEnterEvent = const EventStreamProvider<MouseEvent>('dragenter');\n\n  /**\n   * Static factory designed to expose `dragleave` events to event\n   * handlers that are not necessarily instances of [ElementInstance].\n   *\n   * See [EventStreamProvider] for usage information.\n   */\n  @DomName('SVGElementInstance.dragleaveEvent')\n  @DocsEditable()\n  static const EventStreamProvider<MouseEvent> dragLeaveEvent = const EventStreamProvider<MouseEvent>('dragleave');\n\n  /**\n   * Static factory designed to expose `dragover` events to event\n   * handlers that are not necessarily instances of [ElementInstance].\n   *\n   * See [EventStreamProvider] for usage information.\n   */\n  @DomName('SVGElementInstance.dragoverEvent')\n  @DocsEditable()\n  static const EventStreamProvider<MouseEvent> dragOverEvent = const EventStreamProvider<MouseEvent>('dragover');\n\n  /**\n   * Static factory designed to expose `dragstart` events to event\n   * handlers that are not necessarily instances of [ElementInstance].\n   *\n   * See [EventStreamProvider] for usage information.\n   */\n  @DomName('SVGElementInstance.dragstartEvent')\n  @DocsEditable()\n  static const EventStreamProvider<MouseEvent> dragStartEvent = const EventStreamProvider<MouseEvent>('dragstart');\n\n  /**\n   * Static factory designed to expose `drop` events to event\n   * handlers that are not necessarily instances of [ElementInstance].\n   *\n   * See [EventStreamProvider] for usage information.\n   */\n  @DomName('SVGElementInstance.dropEvent')\n  @DocsEditable()\n  static const EventStreamProvider<MouseEvent> dropEvent = const EventStreamProvider<MouseEvent>('drop');\n\n  /**\n   * Static factory designed to expose `error` events to event\n   * handlers that are not necessarily instances of [ElementInstance].\n   *\n   * See [EventStreamProvider] for usage information.\n   */\n  @DomName('SVGElementInstance.errorEvent')\n  @DocsEditable()\n  static const EventStreamProvider<Event> errorEvent = const EventStreamProvider<Event>('error');\n\n  /**\n   * Static factory designed to expose `focus` events to event\n   * handlers that are not necessarily instances of [ElementInstance].\n   *\n   * See [EventStreamProvider] for usage information.\n   */\n  @DomName('SVGElementInstance.focusEvent')\n  @DocsEditable()\n  static const EventStreamProvider<Event> focusEvent = const EventStreamProvider<Event>('focus');\n\n  /**\n   * Static factory designed to expose `input` events to event\n   * handlers that are not necessarily instances of [ElementInstance].\n   *\n   * See [EventStreamProvider] for usage information.\n   */\n  @DomName('SVGElementInstance.inputEvent')\n  @DocsEditable()\n  static const EventStreamProvider<Event> inputEvent = const EventStreamProvider<Event>('input');\n\n  /**\n   * Static factory designed to expose `keydown` events to event\n   * handlers that are not necessarily instances of [ElementInstance].\n   *\n   * See [EventStreamProvider] for usage information.\n   */\n  @DomName('SVGElementInstance.keydownEvent')\n  @DocsEditable()\n  static const EventStreamProvider<KeyboardEvent> keyDownEvent = const EventStreamProvider<KeyboardEvent>('keydown');\n\n  /**\n   * Static factory designed to expose `keypress` events to event\n   * handlers that are not necessarily instances of [ElementInstance].\n   *\n   * See [EventStreamProvider] for usage information.\n   */\n  @DomName('SVGElementInstance.keypressEvent')\n  @DocsEditable()\n  static const EventStreamProvider<KeyboardEvent> keyPressEvent = const EventStreamProvider<KeyboardEvent>('keypress');\n\n  /**\n   * Static factory designed to expose `keyup` events to event\n   * handlers that are not necessarily instances of [ElementInstance].\n   *\n   * See [EventStreamProvider] for usage information.\n   */\n  @DomName('SVGElementInstance.keyupEvent')\n  @DocsEditable()\n  static const EventStreamProvider<KeyboardEvent> keyUpEvent = const EventStreamProvider<KeyboardEvent>('keyup');\n\n  /**\n   * Static factory designed to expose `load` events to event\n   * handlers that are not necessarily instances of [ElementInstance].\n   *\n   * See [EventStreamProvider] for usage information.\n   */\n  @DomName('SVGElementInstance.loadEvent')\n  @DocsEditable()\n  static const EventStreamProvider<Event> loadEvent = const EventStreamProvider<Event>('load');\n\n  /**\n   * Static factory designed to expose `mousedown` events to event\n   * handlers that are not necessarily instances of [ElementInstance].\n   *\n   * See [EventStreamProvider] for usage information.\n   */\n  @DomName('SVGElementInstance.mousedownEvent')\n  @DocsEditable()\n  static const EventStreamProvider<MouseEvent> mouseDownEvent = const EventStreamProvider<MouseEvent>('mousedown');\n\n  /**\n   * Static factory designed to expose `mouseenter` events to event\n   * handlers that are not necessarily instances of [ElementInstance].\n   *\n   * See [EventStreamProvider] for usage information.\n   */\n  @DomName('SVGElementInstance.mouseenterEvent')\n  @DocsEditable()\n  @Experimental() // untriaged\n  static const EventStreamProvider<MouseEvent> mouseEnterEvent = const EventStreamProvider<MouseEvent>('mouseenter');\n\n  /**\n   * Static factory designed to expose `mouseleave` events to event\n   * handlers that are not necessarily instances of [ElementInstance].\n   *\n   * See [EventStreamProvider] for usage information.\n   */\n  @DomName('SVGElementInstance.mouseleaveEvent')\n  @DocsEditable()\n  @Experimental() // untriaged\n  static const EventStreamProvider<MouseEvent> mouseLeaveEvent = const EventStreamProvider<MouseEvent>('mouseleave');\n\n  /**\n   * Static factory designed to expose `mousemove` events to event\n   * handlers that are not necessarily instances of [ElementInstance].\n   *\n   * See [EventStreamProvider] for usage information.\n   */\n  @DomName('SVGElementInstance.mousemoveEvent')\n  @DocsEditable()\n  static const EventStreamProvider<MouseEvent> mouseMoveEvent = const EventStreamProvider<MouseEvent>('mousemove');\n\n  /**\n   * Static factory designed to expose `mouseout` events to event\n   * handlers that are not necessarily instances of [ElementInstance].\n   *\n   * See [EventStreamProvider] for usage information.\n   */\n  @DomName('SVGElementInstance.mouseoutEvent')\n  @DocsEditable()\n  static const EventStreamProvider<MouseEvent> mouseOutEvent = const EventStreamProvider<MouseEvent>('mouseout');\n\n  /**\n   * Static factory designed to expose `mouseover` events to event\n   * handlers that are not necessarily instances of [ElementInstance].\n   *\n   * See [EventStreamProvider] for usage information.\n   */\n  @DomName('SVGElementInstance.mouseoverEvent')\n  @DocsEditable()\n  static const EventStreamProvider<MouseEvent> mouseOverEvent = const EventStreamProvider<MouseEvent>('mouseover');\n\n  /**\n   * Static factory designed to expose `mouseup` events to event\n   * handlers that are not necessarily instances of [ElementInstance].\n   *\n   * See [EventStreamProvider] for usage information.\n   */\n  @DomName('SVGElementInstance.mouseupEvent')\n  @DocsEditable()\n  static const EventStreamProvider<MouseEvent> mouseUpEvent = const EventStreamProvider<MouseEvent>('mouseup');\n\n  /**\n   * Static factory designed to expose `mousewheel` events to event\n   * handlers that are not necessarily instances of [ElementInstance].\n   *\n   * See [EventStreamProvider] for usage information.\n   */\n  @DomName('SVGElementInstance.mousewheelEvent')\n  @DocsEditable()\n  static const EventStreamProvider<WheelEvent> mouseWheelEvent = const EventStreamProvider<WheelEvent>('mousewheel');\n\n  /**\n   * Static factory designed to expose `paste` events to event\n   * handlers that are not necessarily instances of [ElementInstance].\n   *\n   * See [EventStreamProvider] for usage information.\n   */\n  @DomName('SVGElementInstance.pasteEvent')\n  @DocsEditable()\n  static const EventStreamProvider<Event> pasteEvent = const EventStreamProvider<Event>('paste');\n\n  /**\n   * Static factory designed to expose `reset` events to event\n   * handlers that are not necessarily instances of [ElementInstance].\n   *\n   * See [EventStreamProvider] for usage information.\n   */\n  @DomName('SVGElementInstance.resetEvent')\n  @DocsEditable()\n  static const EventStreamProvider<Event> resetEvent = const EventStreamProvider<Event>('reset');\n\n  /**\n   * Static factory designed to expose `resize` events to event\n   * handlers that are not necessarily instances of [ElementInstance].\n   *\n   * See [EventStreamProvider] for usage information.\n   */\n  @DomName('SVGElementInstance.resizeEvent')\n  @DocsEditable()\n  static const EventStreamProvider<Event> resizeEvent = const EventStreamProvider<Event>('resize');\n\n  /**\n   * Static factory designed to expose `scroll` events to event\n   * handlers that are not necessarily instances of [ElementInstance].\n   *\n   * See [EventStreamProvider] for usage information.\n   */\n  @DomName('SVGElementInstance.scrollEvent')\n  @DocsEditable()\n  static const EventStreamProvider<Event> scrollEvent = const EventStreamProvider<Event>('scroll');\n\n  /**\n   * Static factory designed to expose `search` events to event\n   * handlers that are not necessarily instances of [ElementInstance].\n   *\n   * See [EventStreamProvider] for usage information.\n   */\n  @DomName('SVGElementInstance.searchEvent')\n  @DocsEditable()\n  // http://www.w3.org/TR/html-markup/input.search.html\n  @Experimental()\n  static const EventStreamProvider<Event> searchEvent = const EventStreamProvider<Event>('search');\n\n  /**\n   * Static factory designed to expose `select` events to event\n   * handlers that are not necessarily instances of [ElementInstance].\n   *\n   * See [EventStreamProvider] for usage information.\n   */\n  @DomName('SVGElementInstance.selectEvent')\n  @DocsEditable()\n  static const EventStreamProvider<Event> selectEvent = const EventStreamProvider<Event>('select');\n\n  /**\n   * Static factory designed to expose `selectstart` events to event\n   * handlers that are not necessarily instances of [ElementInstance].\n   *\n   * See [EventStreamProvider] for usage information.\n   */\n  @DomName('SVGElementInstance.selectstartEvent')\n  @DocsEditable()\n  static const EventStreamProvider<Event> selectStartEvent = const EventStreamProvider<Event>('selectstart');\n\n  /**\n   * Static factory designed to expose `submit` events to event\n   * handlers that are not necessarily instances of [ElementInstance].\n   *\n   * See [EventStreamProvider] for usage information.\n   */\n  @DomName('SVGElementInstance.submitEvent')\n  @DocsEditable()\n  static const EventStreamProvider<Event> submitEvent = const EventStreamProvider<Event>('submit');\n\n  /**\n   * Static factory designed to expose `unload` events to event\n   * handlers that are not necessarily instances of [ElementInstance].\n   *\n   * See [EventStreamProvider] for usage information.\n   */\n  @DomName('SVGElementInstance.unloadEvent')\n  @DocsEditable()\n  static const EventStreamProvider<Event> unloadEvent = const EventStreamProvider<Event>('unload');\n\n  @DomName('SVGElementInstance.correspondingElement')\n  @DocsEditable()\n  final SvgElement correspondingElement;\n\n  @DomName('SVGElementInstance.correspondingUseElement')\n  @DocsEditable()\n  final UseElement correspondingUseElement;\n\n  @DomName('SVGElementInstance.firstChild')\n  @DocsEditable()\n  final ElementInstance firstChild;\n\n  @DomName('SVGElementInstance.lastChild')\n  @DocsEditable()\n  final ElementInstance lastChild;\n\n  @DomName('SVGElementInstance.nextSibling')\n  @DocsEditable()\n  final ElementInstance nextSibling;\n\n  @DomName('SVGElementInstance.parentNode')\n  @DocsEditable()\n  final ElementInstance parentNode;\n\n  @DomName('SVGElementInstance.previousSibling')\n  @DocsEditable()\n  final ElementInstance previousSibling;\n\n  /// Stream of `abort` events handled by this [ElementInstance].\n  @DomName('SVGElementInstance.onabort')\n  @DocsEditable()\n  Stream<Event> get onAbort => abortEvent.forTarget(this);\n\n  /// Stream of `beforecopy` events handled by this [ElementInstance].\n  @DomName('SVGElementInstance.onbeforecopy')\n  @DocsEditable()\n  Stream<Event> get onBeforeCopy => beforeCopyEvent.forTarget(this);\n\n  /// Stream of `beforecut` events handled by this [ElementInstance].\n  @DomName('SVGElementInstance.onbeforecut')\n  @DocsEditable()\n  Stream<Event> get onBeforeCut => beforeCutEvent.forTarget(this);\n\n  /// Stream of `beforepaste` events handled by this [ElementInstance].\n  @DomName('SVGElementInstance.onbeforepaste')\n  @DocsEditable()\n  Stream<Event> get onBeforePaste => beforePasteEvent.forTarget(this);\n\n  /// Stream of `blur` events handled by this [ElementInstance].\n  @DomName('SVGElementInstance.onblur')\n  @DocsEditable()\n  Stream<Event> get onBlur => blurEvent.forTarget(this);\n\n  /// Stream of `change` events handled by this [ElementInstance].\n  @DomName('SVGElementInstance.onchange')\n  @DocsEditable()\n  Stream<Event> get onChange => changeEvent.forTarget(this);\n\n  /// Stream of `click` events handled by this [ElementInstance].\n  @DomName('SVGElementInstance.onclick')\n  @DocsEditable()\n  Stream<MouseEvent> get onClick => clickEvent.forTarget(this);\n\n  /// Stream of `contextmenu` events handled by this [ElementInstance].\n  @DomName('SVGElementInstance.oncontextmenu')\n  @DocsEditable()\n  Stream<MouseEvent> get onContextMenu => contextMenuEvent.forTarget(this);\n\n  /// Stream of `copy` events handled by this [ElementInstance].\n  @DomName('SVGElementInstance.oncopy')\n  @DocsEditable()\n  Stream<Event> get onCopy => copyEvent.forTarget(this);\n\n  /// Stream of `cut` events handled by this [ElementInstance].\n  @DomName('SVGElementInstance.oncut')\n  @DocsEditable()\n  Stream<Event> get onCut => cutEvent.forTarget(this);\n\n  /// Stream of `doubleclick` events handled by this [ElementInstance].\n  @DomName('SVGElementInstance.ondblclick')\n  @DocsEditable()\n  Stream<Event> get onDoubleClick => doubleClickEvent.forTarget(this);\n\n  /// Stream of `drag` events handled by this [ElementInstance].\n  @DomName('SVGElementInstance.ondrag')\n  @DocsEditable()\n  Stream<MouseEvent> get onDrag => dragEvent.forTarget(this);\n\n  /// Stream of `dragend` events handled by this [ElementInstance].\n  @DomName('SVGElementInstance.ondragend')\n  @DocsEditable()\n  Stream<MouseEvent> get onDragEnd => dragEndEvent.forTarget(this);\n\n  /// Stream of `dragenter` events handled by this [ElementInstance].\n  @DomName('SVGElementInstance.ondragenter')\n  @DocsEditable()\n  Stream<MouseEvent> get onDragEnter => dragEnterEvent.forTarget(this);\n\n  /// Stream of `dragleave` events handled by this [ElementInstance].\n  @DomName('SVGElementInstance.ondragleave')\n  @DocsEditable()\n  Stream<MouseEvent> get onDragLeave => dragLeaveEvent.forTarget(this);\n\n  /// Stream of `dragover` events handled by this [ElementInstance].\n  @DomName('SVGElementInstance.ondragover')\n  @DocsEditable()\n  Stream<MouseEvent> get onDragOver => dragOverEvent.forTarget(this);\n\n  /// Stream of `dragstart` events handled by this [ElementInstance].\n  @DomName('SVGElementInstance.ondragstart')\n  @DocsEditable()\n  Stream<MouseEvent> get onDragStart => dragStartEvent.forTarget(this);\n\n  /// Stream of `drop` events handled by this [ElementInstance].\n  @DomName('SVGElementInstance.ondrop')\n  @DocsEditable()\n  Stream<MouseEvent> get onDrop => dropEvent.forTarget(this);\n\n  /// Stream of `error` events handled by this [ElementInstance].\n  @DomName('SVGElementInstance.onerror')\n  @DocsEditable()\n  Stream<Event> get onError => errorEvent.forTarget(this);\n\n  /// Stream of `focus` events handled by this [ElementInstance].\n  @DomName('SVGElementInstance.onfocus')\n  @DocsEditable()\n  Stream<Event> get onFocus => focusEvent.forTarget(this);\n\n  /// Stream of `input` events handled by this [ElementInstance].\n  @DomName('SVGElementInstance.oninput')\n  @DocsEditable()\n  Stream<Event> get onInput => inputEvent.forTarget(this);\n\n  /// Stream of `keydown` events handled by this [ElementInstance].\n  @DomName('SVGElementInstance.onkeydown')\n  @DocsEditable()\n  Stream<KeyboardEvent> get onKeyDown => keyDownEvent.forTarget(this);\n\n  /// Stream of `keypress` events handled by this [ElementInstance].\n  @DomName('SVGElementInstance.onkeypress')\n  @DocsEditable()\n  Stream<KeyboardEvent> get onKeyPress => keyPressEvent.forTarget(this);\n\n  /// Stream of `keyup` events handled by this [ElementInstance].\n  @DomName('SVGElementInstance.onkeyup')\n  @DocsEditable()\n  Stream<KeyboardEvent> get onKeyUp => keyUpEvent.forTarget(this);\n\n  /// Stream of `load` events handled by this [ElementInstance].\n  @DomName('SVGElementInstance.onload')\n  @DocsEditable()\n  Stream<Event> get onLoad => loadEvent.forTarget(this);\n\n  /// Stream of `mousedown` events handled by this [ElementInstance].\n  @DomName('SVGElementInstance.onmousedown')\n  @DocsEditable()\n  Stream<MouseEvent> get onMouseDown => mouseDownEvent.forTarget(this);\n\n  /// Stream of `mouseenter` events handled by this [ElementInstance].\n  @DomName('SVGElementInstance.onmouseenter')\n  @DocsEditable()\n  @Experimental() // untriaged\n  Stream<MouseEvent> get onMouseEnter => mouseEnterEvent.forTarget(this);\n\n  /// Stream of `mouseleave` events handled by this [ElementInstance].\n  @DomName('SVGElementInstance.onmouseleave')\n  @DocsEditable()\n  @Experimental() // untriaged\n  Stream<MouseEvent> get onMouseLeave => mouseLeaveEvent.forTarget(this);\n\n  /// Stream of `mousemove` events handled by this [ElementInstance].\n  @DomName('SVGElementInstance.onmousemove')\n  @DocsEditable()\n  Stream<MouseEvent> get onMouseMove => mouseMoveEvent.forTarget(this);\n\n  /// Stream of `mouseout` events handled by this [ElementInstance].\n  @DomName('SVGElementInstance.onmouseout')\n  @DocsEditable()\n  Stream<MouseEvent> get onMouseOut => mouseOutEvent.forTarget(this);\n\n  /// Stream of `mouseover` events handled by this [ElementInstance].\n  @DomName('SVGElementInstance.onmouseover')\n  @DocsEditable()\n  Stream<MouseEvent> get onMouseOver => mouseOverEvent.forTarget(this);\n\n  /// Stream of `mouseup` events handled by this [ElementInstance].\n  @DomName('SVGElementInstance.onmouseup')\n  @DocsEditable()\n  Stream<MouseEvent> get onMouseUp => mouseUpEvent.forTarget(this);\n\n  /// Stream of `mousewheel` events handled by this [ElementInstance].\n  @DomName('SVGElementInstance.onmousewheel')\n  @DocsEditable()\n  Stream<WheelEvent> get onMouseWheel => mouseWheelEvent.forTarget(this);\n\n  /// Stream of `paste` events handled by this [ElementInstance].\n  @DomName('SVGElementInstance.onpaste')\n  @DocsEditable()\n  Stream<Event> get onPaste => pasteEvent.forTarget(this);\n\n  /// Stream of `reset` events handled by this [ElementInstance].\n  @DomName('SVGElementInstance.onreset')\n  @DocsEditable()\n  Stream<Event> get onReset => resetEvent.forTarget(this);\n\n  /// Stream of `resize` events handled by this [ElementInstance].\n  @DomName('SVGElementInstance.onresize')\n  @DocsEditable()\n  Stream<Event> get onResize => resizeEvent.forTarget(this);\n\n  /// Stream of `scroll` events handled by this [ElementInstance].\n  @DomName('SVGElementInstance.onscroll')\n  @DocsEditable()\n  Stream<Event> get onScroll => scrollEvent.forTarget(this);\n\n  /// Stream of `search` events handled by this [ElementInstance].\n  @DomName('SVGElementInstance.onsearch')\n  @DocsEditable()\n  // http://www.w3.org/TR/html-markup/input.search.html\n  @Experimental()\n  Stream<Event> get onSearch => searchEvent.forTarget(this);\n\n  /// Stream of `select` events handled by this [ElementInstance].\n  @DomName('SVGElementInstance.onselect')\n  @DocsEditable()\n  Stream<Event> get onSelect => selectEvent.forTarget(this);\n\n  /// Stream of `selectstart` events handled by this [ElementInstance].\n  @DomName('SVGElementInstance.onselectstart')\n  @DocsEditable()\n  Stream<Event> get onSelectStart => selectStartEvent.forTarget(this);\n\n  /// Stream of `submit` events handled by this [ElementInstance].\n  @DomName('SVGElementInstance.onsubmit')\n  @DocsEditable()\n  Stream<Event> get onSubmit => submitEvent.forTarget(this);\n\n  /// Stream of `unload` events handled by this [ElementInstance].\n  @DomName('SVGElementInstance.onunload')\n  @DocsEditable()\n  Stream<Event> get onUnload => unloadEvent.forTarget(this);\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('SVGEllipseElement')\n@Unstable()\n@Native(\"SVGEllipseElement\")\nclass EllipseElement extends GeometryElement {\n  // To suppress missing implicit constructor warnings.\n  factory EllipseElement._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('SVGEllipseElement.SVGEllipseElement')\n  @DocsEditable()\n  factory EllipseElement() => _SvgElementFactoryProvider.createSvgElement_tag(\"ellipse\");\n  /**\n   * Constructor instantiated by the DOM when a custom element has been created.\n   *\n   * This can only be called by subclasses from their created constructor.\n   */\n  EllipseElement.created() : super.created();\n\n  @DomName('SVGEllipseElement.cx')\n  @DocsEditable()\n  final AnimatedLength cx;\n\n  @DomName('SVGEllipseElement.cy')\n  @DocsEditable()\n  final AnimatedLength cy;\n\n  @DomName('SVGEllipseElement.rx')\n  @DocsEditable()\n  final AnimatedLength rx;\n\n  @DomName('SVGEllipseElement.ry')\n  @DocsEditable()\n  final AnimatedLength ry;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('SVGFEBlendElement')\n@SupportedBrowser(SupportedBrowser.CHROME)\n@SupportedBrowser(SupportedBrowser.FIREFOX)\n@SupportedBrowser(SupportedBrowser.IE, '10')\n@SupportedBrowser(SupportedBrowser.SAFARI)\n@Unstable()\n@Native(\"SVGFEBlendElement\")\nclass FEBlendElement extends SvgElement implements FilterPrimitiveStandardAttributes {\n  // To suppress missing implicit constructor warnings.\n  factory FEBlendElement._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('SVGFEBlendElement.SVGFEBlendElement')\n  @DocsEditable()\n  factory FEBlendElement() => _SvgElementFactoryProvider.createSvgElement_tag(\"feBlend\");\n  /**\n   * Constructor instantiated by the DOM when a custom element has been created.\n   *\n   * This can only be called by subclasses from their created constructor.\n   */\n  FEBlendElement.created() : super.created();\n\n  /// Checks if this type is supported on the current platform.\n  static bool get supported => SvgElement.isTagSupported('feBlend') && (new SvgElement.tag('feBlend') is FEBlendElement);\n\n  @DomName('SVGFEBlendElement.SVG_FEBLEND_MODE_DARKEN')\n  @DocsEditable()\n  static const int SVG_FEBLEND_MODE_DARKEN = 4;\n\n  @DomName('SVGFEBlendElement.SVG_FEBLEND_MODE_LIGHTEN')\n  @DocsEditable()\n  static const int SVG_FEBLEND_MODE_LIGHTEN = 5;\n\n  @DomName('SVGFEBlendElement.SVG_FEBLEND_MODE_MULTIPLY')\n  @DocsEditable()\n  static const int SVG_FEBLEND_MODE_MULTIPLY = 2;\n\n  @DomName('SVGFEBlendElement.SVG_FEBLEND_MODE_NORMAL')\n  @DocsEditable()\n  static const int SVG_FEBLEND_MODE_NORMAL = 1;\n\n  @DomName('SVGFEBlendElement.SVG_FEBLEND_MODE_SCREEN')\n  @DocsEditable()\n  static const int SVG_FEBLEND_MODE_SCREEN = 3;\n\n  @DomName('SVGFEBlendElement.SVG_FEBLEND_MODE_UNKNOWN')\n  @DocsEditable()\n  static const int SVG_FEBLEND_MODE_UNKNOWN = 0;\n\n  @DomName('SVGFEBlendElement.in1')\n  @DocsEditable()\n  final AnimatedString in1;\n\n  @DomName('SVGFEBlendElement.in2')\n  @DocsEditable()\n  final AnimatedString in2;\n\n  @DomName('SVGFEBlendElement.mode')\n  @DocsEditable()\n  final AnimatedEnumeration mode;\n\n  // From SVGFilterPrimitiveStandardAttributes\n\n  @DomName('SVGFEBlendElement.height')\n  @DocsEditable()\n  final AnimatedLength height;\n\n  @DomName('SVGFEBlendElement.result')\n  @DocsEditable()\n  final AnimatedString result;\n\n  @DomName('SVGFEBlendElement.width')\n  @DocsEditable()\n  final AnimatedLength width;\n\n  @DomName('SVGFEBlendElement.x')\n  @DocsEditable()\n  final AnimatedLength x;\n\n  @DomName('SVGFEBlendElement.y')\n  @DocsEditable()\n  final AnimatedLength y;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('SVGFEColorMatrixElement')\n@SupportedBrowser(SupportedBrowser.CHROME)\n@SupportedBrowser(SupportedBrowser.FIREFOX)\n@SupportedBrowser(SupportedBrowser.IE, '10')\n@SupportedBrowser(SupportedBrowser.SAFARI)\n@Unstable()\n@Native(\"SVGFEColorMatrixElement\")\nclass FEColorMatrixElement extends SvgElement implements FilterPrimitiveStandardAttributes {\n  // To suppress missing implicit constructor warnings.\n  factory FEColorMatrixElement._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('SVGFEColorMatrixElement.SVGFEColorMatrixElement')\n  @DocsEditable()\n  factory FEColorMatrixElement() => _SvgElementFactoryProvider.createSvgElement_tag(\"feColorMatrix\");\n  /**\n   * Constructor instantiated by the DOM when a custom element has been created.\n   *\n   * This can only be called by subclasses from their created constructor.\n   */\n  FEColorMatrixElement.created() : super.created();\n\n  /// Checks if this type is supported on the current platform.\n  static bool get supported => SvgElement.isTagSupported('feColorMatrix') && (new SvgElement.tag('feColorMatrix') is FEColorMatrixElement);\n\n  @DomName('SVGFEColorMatrixElement.SVG_FECOLORMATRIX_TYPE_HUEROTATE')\n  @DocsEditable()\n  static const int SVG_FECOLORMATRIX_TYPE_HUEROTATE = 3;\n\n  @DomName('SVGFEColorMatrixElement.SVG_FECOLORMATRIX_TYPE_LUMINANCETOALPHA')\n  @DocsEditable()\n  static const int SVG_FECOLORMATRIX_TYPE_LUMINANCETOALPHA = 4;\n\n  @DomName('SVGFEColorMatrixElement.SVG_FECOLORMATRIX_TYPE_MATRIX')\n  @DocsEditable()\n  static const int SVG_FECOLORMATRIX_TYPE_MATRIX = 1;\n\n  @DomName('SVGFEColorMatrixElement.SVG_FECOLORMATRIX_TYPE_SATURATE')\n  @DocsEditable()\n  static const int SVG_FECOLORMATRIX_TYPE_SATURATE = 2;\n\n  @DomName('SVGFEColorMatrixElement.SVG_FECOLORMATRIX_TYPE_UNKNOWN')\n  @DocsEditable()\n  static const int SVG_FECOLORMATRIX_TYPE_UNKNOWN = 0;\n\n  @DomName('SVGFEColorMatrixElement.in1')\n  @DocsEditable()\n  final AnimatedString in1;\n\n  @DomName('SVGFEColorMatrixElement.type')\n  @DocsEditable()\n  final AnimatedEnumeration type;\n\n  @DomName('SVGFEColorMatrixElement.values')\n  @DocsEditable()\n  final AnimatedNumberList values;\n\n  // From SVGFilterPrimitiveStandardAttributes\n\n  @DomName('SVGFEColorMatrixElement.height')\n  @DocsEditable()\n  final AnimatedLength height;\n\n  @DomName('SVGFEColorMatrixElement.result')\n  @DocsEditable()\n  final AnimatedString result;\n\n  @DomName('SVGFEColorMatrixElement.width')\n  @DocsEditable()\n  final AnimatedLength width;\n\n  @DomName('SVGFEColorMatrixElement.x')\n  @DocsEditable()\n  final AnimatedLength x;\n\n  @DomName('SVGFEColorMatrixElement.y')\n  @DocsEditable()\n  final AnimatedLength y;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('SVGFEComponentTransferElement')\n@SupportedBrowser(SupportedBrowser.CHROME)\n@SupportedBrowser(SupportedBrowser.FIREFOX)\n@SupportedBrowser(SupportedBrowser.IE, '10')\n@SupportedBrowser(SupportedBrowser.SAFARI)\n@Unstable()\n@Native(\"SVGFEComponentTransferElement\")\nclass FEComponentTransferElement extends SvgElement implements FilterPrimitiveStandardAttributes {\n  // To suppress missing implicit constructor warnings.\n  factory FEComponentTransferElement._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('SVGFEComponentTransferElement.SVGFEComponentTransferElement')\n  @DocsEditable()\n  factory FEComponentTransferElement() => _SvgElementFactoryProvider.createSvgElement_tag(\"feComponentTransfer\");\n  /**\n   * Constructor instantiated by the DOM when a custom element has been created.\n   *\n   * This can only be called by subclasses from their created constructor.\n   */\n  FEComponentTransferElement.created() : super.created();\n\n  /// Checks if this type is supported on the current platform.\n  static bool get supported => SvgElement.isTagSupported('feComponentTransfer') && (new SvgElement.tag('feComponentTransfer') is FEComponentTransferElement);\n\n  @DomName('SVGFEComponentTransferElement.in1')\n  @DocsEditable()\n  final AnimatedString in1;\n\n  // From SVGFilterPrimitiveStandardAttributes\n\n  @DomName('SVGFEComponentTransferElement.height')\n  @DocsEditable()\n  final AnimatedLength height;\n\n  @DomName('SVGFEComponentTransferElement.result')\n  @DocsEditable()\n  final AnimatedString result;\n\n  @DomName('SVGFEComponentTransferElement.width')\n  @DocsEditable()\n  final AnimatedLength width;\n\n  @DomName('SVGFEComponentTransferElement.x')\n  @DocsEditable()\n  final AnimatedLength x;\n\n  @DomName('SVGFEComponentTransferElement.y')\n  @DocsEditable()\n  final AnimatedLength y;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('SVGFECompositeElement')\n@Unstable()\n@Native(\"SVGFECompositeElement\")\nclass FECompositeElement extends SvgElement implements FilterPrimitiveStandardAttributes {\n  // To suppress missing implicit constructor warnings.\n  factory FECompositeElement._() { throw new UnsupportedError(\"Not supported\"); }\n  /**\n   * Constructor instantiated by the DOM when a custom element has been created.\n   *\n   * This can only be called by subclasses from their created constructor.\n   */\n  FECompositeElement.created() : super.created();\n\n  @DomName('SVGFECompositeElement.SVG_FECOMPOSITE_OPERATOR_ARITHMETIC')\n  @DocsEditable()\n  static const int SVG_FECOMPOSITE_OPERATOR_ARITHMETIC = 6;\n\n  @DomName('SVGFECompositeElement.SVG_FECOMPOSITE_OPERATOR_ATOP')\n  @DocsEditable()\n  static const int SVG_FECOMPOSITE_OPERATOR_ATOP = 4;\n\n  @DomName('SVGFECompositeElement.SVG_FECOMPOSITE_OPERATOR_IN')\n  @DocsEditable()\n  static const int SVG_FECOMPOSITE_OPERATOR_IN = 2;\n\n  @DomName('SVGFECompositeElement.SVG_FECOMPOSITE_OPERATOR_OUT')\n  @DocsEditable()\n  static const int SVG_FECOMPOSITE_OPERATOR_OUT = 3;\n\n  @DomName('SVGFECompositeElement.SVG_FECOMPOSITE_OPERATOR_OVER')\n  @DocsEditable()\n  static const int SVG_FECOMPOSITE_OPERATOR_OVER = 1;\n\n  @DomName('SVGFECompositeElement.SVG_FECOMPOSITE_OPERATOR_UNKNOWN')\n  @DocsEditable()\n  static const int SVG_FECOMPOSITE_OPERATOR_UNKNOWN = 0;\n\n  @DomName('SVGFECompositeElement.SVG_FECOMPOSITE_OPERATOR_XOR')\n  @DocsEditable()\n  static const int SVG_FECOMPOSITE_OPERATOR_XOR = 5;\n\n  @DomName('SVGFECompositeElement.in1')\n  @DocsEditable()\n  final AnimatedString in1;\n\n  @DomName('SVGFECompositeElement.in2')\n  @DocsEditable()\n  final AnimatedString in2;\n\n  @DomName('SVGFECompositeElement.k1')\n  @DocsEditable()\n  final AnimatedNumber k1;\n\n  @DomName('SVGFECompositeElement.k2')\n  @DocsEditable()\n  final AnimatedNumber k2;\n\n  @DomName('SVGFECompositeElement.k3')\n  @DocsEditable()\n  final AnimatedNumber k3;\n\n  @DomName('SVGFECompositeElement.k4')\n  @DocsEditable()\n  final AnimatedNumber k4;\n\n  @DomName('SVGFECompositeElement.operator')\n  @DocsEditable()\n  final AnimatedEnumeration operator;\n\n  // From SVGFilterPrimitiveStandardAttributes\n\n  @DomName('SVGFECompositeElement.height')\n  @DocsEditable()\n  final AnimatedLength height;\n\n  @DomName('SVGFECompositeElement.result')\n  @DocsEditable()\n  final AnimatedString result;\n\n  @DomName('SVGFECompositeElement.width')\n  @DocsEditable()\n  final AnimatedLength width;\n\n  @DomName('SVGFECompositeElement.x')\n  @DocsEditable()\n  final AnimatedLength x;\n\n  @DomName('SVGFECompositeElement.y')\n  @DocsEditable()\n  final AnimatedLength y;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('SVGFEConvolveMatrixElement')\n@SupportedBrowser(SupportedBrowser.CHROME)\n@SupportedBrowser(SupportedBrowser.FIREFOX)\n@SupportedBrowser(SupportedBrowser.IE, '10')\n@SupportedBrowser(SupportedBrowser.SAFARI)\n@Unstable()\n@Native(\"SVGFEConvolveMatrixElement\")\nclass FEConvolveMatrixElement extends SvgElement implements FilterPrimitiveStandardAttributes {\n  // To suppress missing implicit constructor warnings.\n  factory FEConvolveMatrixElement._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('SVGFEConvolveMatrixElement.SVGFEConvolveMatrixElement')\n  @DocsEditable()\n  factory FEConvolveMatrixElement() => _SvgElementFactoryProvider.createSvgElement_tag(\"feConvolveMatrix\");\n  /**\n   * Constructor instantiated by the DOM when a custom element has been created.\n   *\n   * This can only be called by subclasses from their created constructor.\n   */\n  FEConvolveMatrixElement.created() : super.created();\n\n  /// Checks if this type is supported on the current platform.\n  static bool get supported => SvgElement.isTagSupported('feConvolveMatrix') && (new SvgElement.tag('feConvolveMatrix') is FEConvolveMatrixElement);\n\n  @DomName('SVGFEConvolveMatrixElement.SVG_EDGEMODE_DUPLICATE')\n  @DocsEditable()\n  static const int SVG_EDGEMODE_DUPLICATE = 1;\n\n  @DomName('SVGFEConvolveMatrixElement.SVG_EDGEMODE_NONE')\n  @DocsEditable()\n  static const int SVG_EDGEMODE_NONE = 3;\n\n  @DomName('SVGFEConvolveMatrixElement.SVG_EDGEMODE_UNKNOWN')\n  @DocsEditable()\n  static const int SVG_EDGEMODE_UNKNOWN = 0;\n\n  @DomName('SVGFEConvolveMatrixElement.SVG_EDGEMODE_WRAP')\n  @DocsEditable()\n  static const int SVG_EDGEMODE_WRAP = 2;\n\n  @DomName('SVGFEConvolveMatrixElement.bias')\n  @DocsEditable()\n  final AnimatedNumber bias;\n\n  @DomName('SVGFEConvolveMatrixElement.divisor')\n  @DocsEditable()\n  final AnimatedNumber divisor;\n\n  @DomName('SVGFEConvolveMatrixElement.edgeMode')\n  @DocsEditable()\n  final AnimatedEnumeration edgeMode;\n\n  @DomName('SVGFEConvolveMatrixElement.in1')\n  @DocsEditable()\n  final AnimatedString in1;\n\n  @DomName('SVGFEConvolveMatrixElement.kernelMatrix')\n  @DocsEditable()\n  final AnimatedNumberList kernelMatrix;\n\n  @DomName('SVGFEConvolveMatrixElement.kernelUnitLengthX')\n  @DocsEditable()\n  final AnimatedNumber kernelUnitLengthX;\n\n  @DomName('SVGFEConvolveMatrixElement.kernelUnitLengthY')\n  @DocsEditable()\n  final AnimatedNumber kernelUnitLengthY;\n\n  @DomName('SVGFEConvolveMatrixElement.orderX')\n  @DocsEditable()\n  final AnimatedInteger orderX;\n\n  @DomName('SVGFEConvolveMatrixElement.orderY')\n  @DocsEditable()\n  final AnimatedInteger orderY;\n\n  @DomName('SVGFEConvolveMatrixElement.preserveAlpha')\n  @DocsEditable()\n  final AnimatedBoolean preserveAlpha;\n\n  @DomName('SVGFEConvolveMatrixElement.targetX')\n  @DocsEditable()\n  final AnimatedInteger targetX;\n\n  @DomName('SVGFEConvolveMatrixElement.targetY')\n  @DocsEditable()\n  final AnimatedInteger targetY;\n\n  // From SVGFilterPrimitiveStandardAttributes\n\n  @DomName('SVGFEConvolveMatrixElement.height')\n  @DocsEditable()\n  final AnimatedLength height;\n\n  @DomName('SVGFEConvolveMatrixElement.result')\n  @DocsEditable()\n  final AnimatedString result;\n\n  @DomName('SVGFEConvolveMatrixElement.width')\n  @DocsEditable()\n  final AnimatedLength width;\n\n  @DomName('SVGFEConvolveMatrixElement.x')\n  @DocsEditable()\n  final AnimatedLength x;\n\n  @DomName('SVGFEConvolveMatrixElement.y')\n  @DocsEditable()\n  final AnimatedLength y;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('SVGFEDiffuseLightingElement')\n@SupportedBrowser(SupportedBrowser.CHROME)\n@SupportedBrowser(SupportedBrowser.FIREFOX)\n@SupportedBrowser(SupportedBrowser.IE, '10')\n@SupportedBrowser(SupportedBrowser.SAFARI)\n@Unstable()\n@Native(\"SVGFEDiffuseLightingElement\")\nclass FEDiffuseLightingElement extends SvgElement implements FilterPrimitiveStandardAttributes {\n  // To suppress missing implicit constructor warnings.\n  factory FEDiffuseLightingElement._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('SVGFEDiffuseLightingElement.SVGFEDiffuseLightingElement')\n  @DocsEditable()\n  factory FEDiffuseLightingElement() => _SvgElementFactoryProvider.createSvgElement_tag(\"feDiffuseLighting\");\n  /**\n   * Constructor instantiated by the DOM when a custom element has been created.\n   *\n   * This can only be called by subclasses from their created constructor.\n   */\n  FEDiffuseLightingElement.created() : super.created();\n\n  /// Checks if this type is supported on the current platform.\n  static bool get supported => SvgElement.isTagSupported('feDiffuseLighting') && (new SvgElement.tag('feDiffuseLighting') is FEDiffuseLightingElement);\n\n  @DomName('SVGFEDiffuseLightingElement.diffuseConstant')\n  @DocsEditable()\n  final AnimatedNumber diffuseConstant;\n\n  @DomName('SVGFEDiffuseLightingElement.in1')\n  @DocsEditable()\n  final AnimatedString in1;\n\n  @DomName('SVGFEDiffuseLightingElement.kernelUnitLengthX')\n  @DocsEditable()\n  final AnimatedNumber kernelUnitLengthX;\n\n  @DomName('SVGFEDiffuseLightingElement.kernelUnitLengthY')\n  @DocsEditable()\n  final AnimatedNumber kernelUnitLengthY;\n\n  @DomName('SVGFEDiffuseLightingElement.surfaceScale')\n  @DocsEditable()\n  final AnimatedNumber surfaceScale;\n\n  // From SVGFilterPrimitiveStandardAttributes\n\n  @DomName('SVGFEDiffuseLightingElement.height')\n  @DocsEditable()\n  final AnimatedLength height;\n\n  @DomName('SVGFEDiffuseLightingElement.result')\n  @DocsEditable()\n  final AnimatedString result;\n\n  @DomName('SVGFEDiffuseLightingElement.width')\n  @DocsEditable()\n  final AnimatedLength width;\n\n  @DomName('SVGFEDiffuseLightingElement.x')\n  @DocsEditable()\n  final AnimatedLength x;\n\n  @DomName('SVGFEDiffuseLightingElement.y')\n  @DocsEditable()\n  final AnimatedLength y;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('SVGFEDisplacementMapElement')\n@SupportedBrowser(SupportedBrowser.CHROME)\n@SupportedBrowser(SupportedBrowser.FIREFOX)\n@SupportedBrowser(SupportedBrowser.IE, '10')\n@SupportedBrowser(SupportedBrowser.SAFARI)\n@Unstable()\n@Native(\"SVGFEDisplacementMapElement\")\nclass FEDisplacementMapElement extends SvgElement implements FilterPrimitiveStandardAttributes {\n  // To suppress missing implicit constructor warnings.\n  factory FEDisplacementMapElement._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('SVGFEDisplacementMapElement.SVGFEDisplacementMapElement')\n  @DocsEditable()\n  factory FEDisplacementMapElement() => _SvgElementFactoryProvider.createSvgElement_tag(\"feDisplacementMap\");\n  /**\n   * Constructor instantiated by the DOM when a custom element has been created.\n   *\n   * This can only be called by subclasses from their created constructor.\n   */\n  FEDisplacementMapElement.created() : super.created();\n\n  /// Checks if this type is supported on the current platform.\n  static bool get supported => SvgElement.isTagSupported('feDisplacementMap') && (new SvgElement.tag('feDisplacementMap') is FEDisplacementMapElement);\n\n  @DomName('SVGFEDisplacementMapElement.SVG_CHANNEL_A')\n  @DocsEditable()\n  static const int SVG_CHANNEL_A = 4;\n\n  @DomName('SVGFEDisplacementMapElement.SVG_CHANNEL_B')\n  @DocsEditable()\n  static const int SVG_CHANNEL_B = 3;\n\n  @DomName('SVGFEDisplacementMapElement.SVG_CHANNEL_G')\n  @DocsEditable()\n  static const int SVG_CHANNEL_G = 2;\n\n  @DomName('SVGFEDisplacementMapElement.SVG_CHANNEL_R')\n  @DocsEditable()\n  static const int SVG_CHANNEL_R = 1;\n\n  @DomName('SVGFEDisplacementMapElement.SVG_CHANNEL_UNKNOWN')\n  @DocsEditable()\n  static const int SVG_CHANNEL_UNKNOWN = 0;\n\n  @DomName('SVGFEDisplacementMapElement.in1')\n  @DocsEditable()\n  final AnimatedString in1;\n\n  @DomName('SVGFEDisplacementMapElement.in2')\n  @DocsEditable()\n  final AnimatedString in2;\n\n  @DomName('SVGFEDisplacementMapElement.scale')\n  @DocsEditable()\n  final AnimatedNumber scale;\n\n  @DomName('SVGFEDisplacementMapElement.xChannelSelector')\n  @DocsEditable()\n  final AnimatedEnumeration xChannelSelector;\n\n  @DomName('SVGFEDisplacementMapElement.yChannelSelector')\n  @DocsEditable()\n  final AnimatedEnumeration yChannelSelector;\n\n  // From SVGFilterPrimitiveStandardAttributes\n\n  @DomName('SVGFEDisplacementMapElement.height')\n  @DocsEditable()\n  final AnimatedLength height;\n\n  @DomName('SVGFEDisplacementMapElement.result')\n  @DocsEditable()\n  final AnimatedString result;\n\n  @DomName('SVGFEDisplacementMapElement.width')\n  @DocsEditable()\n  final AnimatedLength width;\n\n  @DomName('SVGFEDisplacementMapElement.x')\n  @DocsEditable()\n  final AnimatedLength x;\n\n  @DomName('SVGFEDisplacementMapElement.y')\n  @DocsEditable()\n  final AnimatedLength y;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('SVGFEDistantLightElement')\n@SupportedBrowser(SupportedBrowser.CHROME)\n@SupportedBrowser(SupportedBrowser.FIREFOX)\n@SupportedBrowser(SupportedBrowser.IE, '10')\n@SupportedBrowser(SupportedBrowser.SAFARI)\n@Unstable()\n@Native(\"SVGFEDistantLightElement\")\nclass FEDistantLightElement extends SvgElement {\n  // To suppress missing implicit constructor warnings.\n  factory FEDistantLightElement._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('SVGFEDistantLightElement.SVGFEDistantLightElement')\n  @DocsEditable()\n  factory FEDistantLightElement() => _SvgElementFactoryProvider.createSvgElement_tag(\"feDistantLight\");\n  /**\n   * Constructor instantiated by the DOM when a custom element has been created.\n   *\n   * This can only be called by subclasses from their created constructor.\n   */\n  FEDistantLightElement.created() : super.created();\n\n  /// Checks if this type is supported on the current platform.\n  static bool get supported => SvgElement.isTagSupported('feDistantLight') && (new SvgElement.tag('feDistantLight') is FEDistantLightElement);\n\n  @DomName('SVGFEDistantLightElement.azimuth')\n  @DocsEditable()\n  final AnimatedNumber azimuth;\n\n  @DomName('SVGFEDistantLightElement.elevation')\n  @DocsEditable()\n  final AnimatedNumber elevation;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('SVGFEFloodElement')\n@SupportedBrowser(SupportedBrowser.CHROME)\n@SupportedBrowser(SupportedBrowser.FIREFOX)\n@SupportedBrowser(SupportedBrowser.IE, '10')\n@SupportedBrowser(SupportedBrowser.SAFARI)\n@Unstable()\n@Native(\"SVGFEFloodElement\")\nclass FEFloodElement extends SvgElement implements FilterPrimitiveStandardAttributes {\n  // To suppress missing implicit constructor warnings.\n  factory FEFloodElement._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('SVGFEFloodElement.SVGFEFloodElement')\n  @DocsEditable()\n  factory FEFloodElement() => _SvgElementFactoryProvider.createSvgElement_tag(\"feFlood\");\n  /**\n   * Constructor instantiated by the DOM when a custom element has been created.\n   *\n   * This can only be called by subclasses from their created constructor.\n   */\n  FEFloodElement.created() : super.created();\n\n  /// Checks if this type is supported on the current platform.\n  static bool get supported => SvgElement.isTagSupported('feFlood') && (new SvgElement.tag('feFlood') is FEFloodElement);\n\n  // From SVGFilterPrimitiveStandardAttributes\n\n  @DomName('SVGFEFloodElement.height')\n  @DocsEditable()\n  final AnimatedLength height;\n\n  @DomName('SVGFEFloodElement.result')\n  @DocsEditable()\n  final AnimatedString result;\n\n  @DomName('SVGFEFloodElement.width')\n  @DocsEditable()\n  final AnimatedLength width;\n\n  @DomName('SVGFEFloodElement.x')\n  @DocsEditable()\n  final AnimatedLength x;\n\n  @DomName('SVGFEFloodElement.y')\n  @DocsEditable()\n  final AnimatedLength y;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('SVGFEFuncAElement')\n@SupportedBrowser(SupportedBrowser.CHROME)\n@SupportedBrowser(SupportedBrowser.FIREFOX)\n@SupportedBrowser(SupportedBrowser.IE, '10')\n@SupportedBrowser(SupportedBrowser.SAFARI)\n@Unstable()\n@Native(\"SVGFEFuncAElement\")\nclass FEFuncAElement extends _SVGComponentTransferFunctionElement {\n  // To suppress missing implicit constructor warnings.\n  factory FEFuncAElement._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('SVGFEFuncAElement.SVGFEFuncAElement')\n  @DocsEditable()\n  factory FEFuncAElement() => _SvgElementFactoryProvider.createSvgElement_tag(\"feFuncA\");\n  /**\n   * Constructor instantiated by the DOM when a custom element has been created.\n   *\n   * This can only be called by subclasses from their created constructor.\n   */\n  FEFuncAElement.created() : super.created();\n\n  /// Checks if this type is supported on the current platform.\n  static bool get supported => SvgElement.isTagSupported('feFuncA') && (new SvgElement.tag('feFuncA') is FEFuncAElement);\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('SVGFEFuncBElement')\n@SupportedBrowser(SupportedBrowser.CHROME)\n@SupportedBrowser(SupportedBrowser.FIREFOX)\n@SupportedBrowser(SupportedBrowser.IE, '10')\n@SupportedBrowser(SupportedBrowser.SAFARI)\n@Unstable()\n@Native(\"SVGFEFuncBElement\")\nclass FEFuncBElement extends _SVGComponentTransferFunctionElement {\n  // To suppress missing implicit constructor warnings.\n  factory FEFuncBElement._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('SVGFEFuncBElement.SVGFEFuncBElement')\n  @DocsEditable()\n  factory FEFuncBElement() => _SvgElementFactoryProvider.createSvgElement_tag(\"feFuncB\");\n  /**\n   * Constructor instantiated by the DOM when a custom element has been created.\n   *\n   * This can only be called by subclasses from their created constructor.\n   */\n  FEFuncBElement.created() : super.created();\n\n  /// Checks if this type is supported on the current platform.\n  static bool get supported => SvgElement.isTagSupported('feFuncB') && (new SvgElement.tag('feFuncB') is FEFuncBElement);\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('SVGFEFuncGElement')\n@SupportedBrowser(SupportedBrowser.CHROME)\n@SupportedBrowser(SupportedBrowser.FIREFOX)\n@SupportedBrowser(SupportedBrowser.IE, '10')\n@SupportedBrowser(SupportedBrowser.SAFARI)\n@Unstable()\n@Native(\"SVGFEFuncGElement\")\nclass FEFuncGElement extends _SVGComponentTransferFunctionElement {\n  // To suppress missing implicit constructor warnings.\n  factory FEFuncGElement._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('SVGFEFuncGElement.SVGFEFuncGElement')\n  @DocsEditable()\n  factory FEFuncGElement() => _SvgElementFactoryProvider.createSvgElement_tag(\"feFuncG\");\n  /**\n   * Constructor instantiated by the DOM when a custom element has been created.\n   *\n   * This can only be called by subclasses from their created constructor.\n   */\n  FEFuncGElement.created() : super.created();\n\n  /// Checks if this type is supported on the current platform.\n  static bool get supported => SvgElement.isTagSupported('feFuncG') && (new SvgElement.tag('feFuncG') is FEFuncGElement);\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('SVGFEFuncRElement')\n@SupportedBrowser(SupportedBrowser.CHROME)\n@SupportedBrowser(SupportedBrowser.FIREFOX)\n@SupportedBrowser(SupportedBrowser.IE, '10')\n@SupportedBrowser(SupportedBrowser.SAFARI)\n@Unstable()\n@Native(\"SVGFEFuncRElement\")\nclass FEFuncRElement extends _SVGComponentTransferFunctionElement {\n  // To suppress missing implicit constructor warnings.\n  factory FEFuncRElement._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('SVGFEFuncRElement.SVGFEFuncRElement')\n  @DocsEditable()\n  factory FEFuncRElement() => _SvgElementFactoryProvider.createSvgElement_tag(\"feFuncR\");\n  /**\n   * Constructor instantiated by the DOM when a custom element has been created.\n   *\n   * This can only be called by subclasses from their created constructor.\n   */\n  FEFuncRElement.created() : super.created();\n\n  /// Checks if this type is supported on the current platform.\n  static bool get supported => SvgElement.isTagSupported('feFuncR') && (new SvgElement.tag('feFuncR') is FEFuncRElement);\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('SVGFEGaussianBlurElement')\n@SupportedBrowser(SupportedBrowser.CHROME)\n@SupportedBrowser(SupportedBrowser.FIREFOX)\n@SupportedBrowser(SupportedBrowser.IE, '10')\n@SupportedBrowser(SupportedBrowser.SAFARI)\n@Unstable()\n@Native(\"SVGFEGaussianBlurElement\")\nclass FEGaussianBlurElement extends SvgElement implements FilterPrimitiveStandardAttributes {\n  // To suppress missing implicit constructor warnings.\n  factory FEGaussianBlurElement._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('SVGFEGaussianBlurElement.SVGFEGaussianBlurElement')\n  @DocsEditable()\n  factory FEGaussianBlurElement() => _SvgElementFactoryProvider.createSvgElement_tag(\"feGaussianBlur\");\n  /**\n   * Constructor instantiated by the DOM when a custom element has been created.\n   *\n   * This can only be called by subclasses from their created constructor.\n   */\n  FEGaussianBlurElement.created() : super.created();\n\n  /// Checks if this type is supported on the current platform.\n  static bool get supported => SvgElement.isTagSupported('feGaussianBlur') && (new SvgElement.tag('feGaussianBlur') is FEGaussianBlurElement);\n\n  @DomName('SVGFEGaussianBlurElement.in1')\n  @DocsEditable()\n  final AnimatedString in1;\n\n  @DomName('SVGFEGaussianBlurElement.stdDeviationX')\n  @DocsEditable()\n  final AnimatedNumber stdDeviationX;\n\n  @DomName('SVGFEGaussianBlurElement.stdDeviationY')\n  @DocsEditable()\n  final AnimatedNumber stdDeviationY;\n\n  @DomName('SVGFEGaussianBlurElement.setStdDeviation')\n  @DocsEditable()\n  void setStdDeviation(num stdDeviationX, num stdDeviationY) native;\n\n  // From SVGFilterPrimitiveStandardAttributes\n\n  @DomName('SVGFEGaussianBlurElement.height')\n  @DocsEditable()\n  final AnimatedLength height;\n\n  @DomName('SVGFEGaussianBlurElement.result')\n  @DocsEditable()\n  final AnimatedString result;\n\n  @DomName('SVGFEGaussianBlurElement.width')\n  @DocsEditable()\n  final AnimatedLength width;\n\n  @DomName('SVGFEGaussianBlurElement.x')\n  @DocsEditable()\n  final AnimatedLength x;\n\n  @DomName('SVGFEGaussianBlurElement.y')\n  @DocsEditable()\n  final AnimatedLength y;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('SVGFEImageElement')\n@SupportedBrowser(SupportedBrowser.CHROME)\n@SupportedBrowser(SupportedBrowser.FIREFOX)\n@SupportedBrowser(SupportedBrowser.IE, '10')\n@SupportedBrowser(SupportedBrowser.SAFARI)\n@Unstable()\n@Native(\"SVGFEImageElement\")\nclass FEImageElement extends SvgElement implements FilterPrimitiveStandardAttributes, UriReference {\n  // To suppress missing implicit constructor warnings.\n  factory FEImageElement._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('SVGFEImageElement.SVGFEImageElement')\n  @DocsEditable()\n  factory FEImageElement() => _SvgElementFactoryProvider.createSvgElement_tag(\"feImage\");\n  /**\n   * Constructor instantiated by the DOM when a custom element has been created.\n   *\n   * This can only be called by subclasses from their created constructor.\n   */\n  FEImageElement.created() : super.created();\n\n  /// Checks if this type is supported on the current platform.\n  static bool get supported => SvgElement.isTagSupported('feImage') && (new SvgElement.tag('feImage') is FEImageElement);\n\n  @DomName('SVGFEImageElement.preserveAspectRatio')\n  @DocsEditable()\n  final AnimatedPreserveAspectRatio preserveAspectRatio;\n\n  // From SVGFilterPrimitiveStandardAttributes\n\n  @DomName('SVGFEImageElement.height')\n  @DocsEditable()\n  final AnimatedLength height;\n\n  @DomName('SVGFEImageElement.result')\n  @DocsEditable()\n  final AnimatedString result;\n\n  @DomName('SVGFEImageElement.width')\n  @DocsEditable()\n  final AnimatedLength width;\n\n  @DomName('SVGFEImageElement.x')\n  @DocsEditable()\n  final AnimatedLength x;\n\n  @DomName('SVGFEImageElement.y')\n  @DocsEditable()\n  final AnimatedLength y;\n\n  // From SVGURIReference\n\n  @DomName('SVGFEImageElement.href')\n  @DocsEditable()\n  final AnimatedString href;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('SVGFEMergeElement')\n@SupportedBrowser(SupportedBrowser.CHROME)\n@SupportedBrowser(SupportedBrowser.FIREFOX)\n@SupportedBrowser(SupportedBrowser.IE, '10')\n@SupportedBrowser(SupportedBrowser.SAFARI)\n@Unstable()\n@Native(\"SVGFEMergeElement\")\nclass FEMergeElement extends SvgElement implements FilterPrimitiveStandardAttributes {\n  // To suppress missing implicit constructor warnings.\n  factory FEMergeElement._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('SVGFEMergeElement.SVGFEMergeElement')\n  @DocsEditable()\n  factory FEMergeElement() => _SvgElementFactoryProvider.createSvgElement_tag(\"feMerge\");\n  /**\n   * Constructor instantiated by the DOM when a custom element has been created.\n   *\n   * This can only be called by subclasses from their created constructor.\n   */\n  FEMergeElement.created() : super.created();\n\n  /// Checks if this type is supported on the current platform.\n  static bool get supported => SvgElement.isTagSupported('feMerge') && (new SvgElement.tag('feMerge') is FEMergeElement);\n\n  // From SVGFilterPrimitiveStandardAttributes\n\n  @DomName('SVGFEMergeElement.height')\n  @DocsEditable()\n  final AnimatedLength height;\n\n  @DomName('SVGFEMergeElement.result')\n  @DocsEditable()\n  final AnimatedString result;\n\n  @DomName('SVGFEMergeElement.width')\n  @DocsEditable()\n  final AnimatedLength width;\n\n  @DomName('SVGFEMergeElement.x')\n  @DocsEditable()\n  final AnimatedLength x;\n\n  @DomName('SVGFEMergeElement.y')\n  @DocsEditable()\n  final AnimatedLength y;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('SVGFEMergeNodeElement')\n@SupportedBrowser(SupportedBrowser.CHROME)\n@SupportedBrowser(SupportedBrowser.FIREFOX)\n@SupportedBrowser(SupportedBrowser.IE, '10')\n@SupportedBrowser(SupportedBrowser.SAFARI)\n@Unstable()\n@Native(\"SVGFEMergeNodeElement\")\nclass FEMergeNodeElement extends SvgElement {\n  // To suppress missing implicit constructor warnings.\n  factory FEMergeNodeElement._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('SVGFEMergeNodeElement.SVGFEMergeNodeElement')\n  @DocsEditable()\n  factory FEMergeNodeElement() => _SvgElementFactoryProvider.createSvgElement_tag(\"feMergeNode\");\n  /**\n   * Constructor instantiated by the DOM when a custom element has been created.\n   *\n   * This can only be called by subclasses from their created constructor.\n   */\n  FEMergeNodeElement.created() : super.created();\n\n  /// Checks if this type is supported on the current platform.\n  static bool get supported => SvgElement.isTagSupported('feMergeNode') && (new SvgElement.tag('feMergeNode') is FEMergeNodeElement);\n\n  @DomName('SVGFEMergeNodeElement.in1')\n  @DocsEditable()\n  final AnimatedString in1;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('SVGFEMorphologyElement')\n@SupportedBrowser(SupportedBrowser.CHROME)\n@SupportedBrowser(SupportedBrowser.FIREFOX)\n@SupportedBrowser(SupportedBrowser.IE, '10')\n@SupportedBrowser(SupportedBrowser.SAFARI)\n@Unstable()\n@Native(\"SVGFEMorphologyElement\")\nclass FEMorphologyElement extends SvgElement implements FilterPrimitiveStandardAttributes {\n  // To suppress missing implicit constructor warnings.\n  factory FEMorphologyElement._() { throw new UnsupportedError(\"Not supported\"); }\n  /**\n   * Constructor instantiated by the DOM when a custom element has been created.\n   *\n   * This can only be called by subclasses from their created constructor.\n   */\n  FEMorphologyElement.created() : super.created();\n\n  @DomName('SVGFEMorphologyElement.SVG_MORPHOLOGY_OPERATOR_DILATE')\n  @DocsEditable()\n  static const int SVG_MORPHOLOGY_OPERATOR_DILATE = 2;\n\n  @DomName('SVGFEMorphologyElement.SVG_MORPHOLOGY_OPERATOR_ERODE')\n  @DocsEditable()\n  static const int SVG_MORPHOLOGY_OPERATOR_ERODE = 1;\n\n  @DomName('SVGFEMorphologyElement.SVG_MORPHOLOGY_OPERATOR_UNKNOWN')\n  @DocsEditable()\n  static const int SVG_MORPHOLOGY_OPERATOR_UNKNOWN = 0;\n\n  @DomName('SVGFEMorphologyElement.in1')\n  @DocsEditable()\n  final AnimatedString in1;\n\n  @DomName('SVGFEMorphologyElement.operator')\n  @DocsEditable()\n  final AnimatedEnumeration operator;\n\n  @DomName('SVGFEMorphologyElement.radiusX')\n  @DocsEditable()\n  final AnimatedNumber radiusX;\n\n  @DomName('SVGFEMorphologyElement.radiusY')\n  @DocsEditable()\n  final AnimatedNumber radiusY;\n\n  @DomName('SVGFEMorphologyElement.setRadius')\n  @DocsEditable()\n  void setRadius(num radiusX, num radiusY) native;\n\n  // From SVGFilterPrimitiveStandardAttributes\n\n  @DomName('SVGFEMorphologyElement.height')\n  @DocsEditable()\n  final AnimatedLength height;\n\n  @DomName('SVGFEMorphologyElement.result')\n  @DocsEditable()\n  final AnimatedString result;\n\n  @DomName('SVGFEMorphologyElement.width')\n  @DocsEditable()\n  final AnimatedLength width;\n\n  @DomName('SVGFEMorphologyElement.x')\n  @DocsEditable()\n  final AnimatedLength x;\n\n  @DomName('SVGFEMorphologyElement.y')\n  @DocsEditable()\n  final AnimatedLength y;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('SVGFEOffsetElement')\n@SupportedBrowser(SupportedBrowser.CHROME)\n@SupportedBrowser(SupportedBrowser.FIREFOX)\n@SupportedBrowser(SupportedBrowser.IE, '10')\n@SupportedBrowser(SupportedBrowser.SAFARI)\n@Unstable()\n@Native(\"SVGFEOffsetElement\")\nclass FEOffsetElement extends SvgElement implements FilterPrimitiveStandardAttributes {\n  // To suppress missing implicit constructor warnings.\n  factory FEOffsetElement._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('SVGFEOffsetElement.SVGFEOffsetElement')\n  @DocsEditable()\n  factory FEOffsetElement() => _SvgElementFactoryProvider.createSvgElement_tag(\"feOffset\");\n  /**\n   * Constructor instantiated by the DOM when a custom element has been created.\n   *\n   * This can only be called by subclasses from their created constructor.\n   */\n  FEOffsetElement.created() : super.created();\n\n  /// Checks if this type is supported on the current platform.\n  static bool get supported => SvgElement.isTagSupported('feOffset') && (new SvgElement.tag('feOffset') is FEOffsetElement);\n\n  @DomName('SVGFEOffsetElement.dx')\n  @DocsEditable()\n  final AnimatedNumber dx;\n\n  @DomName('SVGFEOffsetElement.dy')\n  @DocsEditable()\n  final AnimatedNumber dy;\n\n  @DomName('SVGFEOffsetElement.in1')\n  @DocsEditable()\n  final AnimatedString in1;\n\n  // From SVGFilterPrimitiveStandardAttributes\n\n  @DomName('SVGFEOffsetElement.height')\n  @DocsEditable()\n  final AnimatedLength height;\n\n  @DomName('SVGFEOffsetElement.result')\n  @DocsEditable()\n  final AnimatedString result;\n\n  @DomName('SVGFEOffsetElement.width')\n  @DocsEditable()\n  final AnimatedLength width;\n\n  @DomName('SVGFEOffsetElement.x')\n  @DocsEditable()\n  final AnimatedLength x;\n\n  @DomName('SVGFEOffsetElement.y')\n  @DocsEditable()\n  final AnimatedLength y;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('SVGFEPointLightElement')\n@SupportedBrowser(SupportedBrowser.CHROME)\n@SupportedBrowser(SupportedBrowser.FIREFOX)\n@SupportedBrowser(SupportedBrowser.IE, '10')\n@SupportedBrowser(SupportedBrowser.SAFARI)\n@Unstable()\n@Native(\"SVGFEPointLightElement\")\nclass FEPointLightElement extends SvgElement {\n  // To suppress missing implicit constructor warnings.\n  factory FEPointLightElement._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('SVGFEPointLightElement.SVGFEPointLightElement')\n  @DocsEditable()\n  factory FEPointLightElement() => _SvgElementFactoryProvider.createSvgElement_tag(\"fePointLight\");\n  /**\n   * Constructor instantiated by the DOM when a custom element has been created.\n   *\n   * This can only be called by subclasses from their created constructor.\n   */\n  FEPointLightElement.created() : super.created();\n\n  /// Checks if this type is supported on the current platform.\n  static bool get supported => SvgElement.isTagSupported('fePointLight') && (new SvgElement.tag('fePointLight') is FEPointLightElement);\n\n  @DomName('SVGFEPointLightElement.x')\n  @DocsEditable()\n  final AnimatedNumber x;\n\n  @DomName('SVGFEPointLightElement.y')\n  @DocsEditable()\n  final AnimatedNumber y;\n\n  @DomName('SVGFEPointLightElement.z')\n  @DocsEditable()\n  final AnimatedNumber z;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('SVGFESpecularLightingElement')\n@SupportedBrowser(SupportedBrowser.CHROME)\n@SupportedBrowser(SupportedBrowser.FIREFOX)\n@SupportedBrowser(SupportedBrowser.IE, '10')\n@SupportedBrowser(SupportedBrowser.SAFARI)\n@Unstable()\n@Native(\"SVGFESpecularLightingElement\")\nclass FESpecularLightingElement extends SvgElement implements FilterPrimitiveStandardAttributes {\n  // To suppress missing implicit constructor warnings.\n  factory FESpecularLightingElement._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('SVGFESpecularLightingElement.SVGFESpecularLightingElement')\n  @DocsEditable()\n  factory FESpecularLightingElement() => _SvgElementFactoryProvider.createSvgElement_tag(\"feSpecularLighting\");\n  /**\n   * Constructor instantiated by the DOM when a custom element has been created.\n   *\n   * This can only be called by subclasses from their created constructor.\n   */\n  FESpecularLightingElement.created() : super.created();\n\n  /// Checks if this type is supported on the current platform.\n  static bool get supported => SvgElement.isTagSupported('feSpecularLighting') && (new SvgElement.tag('feSpecularLighting') is FESpecularLightingElement);\n\n  @DomName('SVGFESpecularLightingElement.in1')\n  @DocsEditable()\n  final AnimatedString in1;\n\n  @DomName('SVGFESpecularLightingElement.specularConstant')\n  @DocsEditable()\n  final AnimatedNumber specularConstant;\n\n  @DomName('SVGFESpecularLightingElement.specularExponent')\n  @DocsEditable()\n  final AnimatedNumber specularExponent;\n\n  @DomName('SVGFESpecularLightingElement.surfaceScale')\n  @DocsEditable()\n  final AnimatedNumber surfaceScale;\n\n  // From SVGFilterPrimitiveStandardAttributes\n\n  @DomName('SVGFESpecularLightingElement.height')\n  @DocsEditable()\n  final AnimatedLength height;\n\n  @DomName('SVGFESpecularLightingElement.result')\n  @DocsEditable()\n  final AnimatedString result;\n\n  @DomName('SVGFESpecularLightingElement.width')\n  @DocsEditable()\n  final AnimatedLength width;\n\n  @DomName('SVGFESpecularLightingElement.x')\n  @DocsEditable()\n  final AnimatedLength x;\n\n  @DomName('SVGFESpecularLightingElement.y')\n  @DocsEditable()\n  final AnimatedLength y;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('SVGFESpotLightElement')\n@SupportedBrowser(SupportedBrowser.CHROME)\n@SupportedBrowser(SupportedBrowser.FIREFOX)\n@SupportedBrowser(SupportedBrowser.IE, '10')\n@SupportedBrowser(SupportedBrowser.SAFARI)\n@Unstable()\n@Native(\"SVGFESpotLightElement\")\nclass FESpotLightElement extends SvgElement {\n  // To suppress missing implicit constructor warnings.\n  factory FESpotLightElement._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('SVGFESpotLightElement.SVGFESpotLightElement')\n  @DocsEditable()\n  factory FESpotLightElement() => _SvgElementFactoryProvider.createSvgElement_tag(\"feSpotLight\");\n  /**\n   * Constructor instantiated by the DOM when a custom element has been created.\n   *\n   * This can only be called by subclasses from their created constructor.\n   */\n  FESpotLightElement.created() : super.created();\n\n  /// Checks if this type is supported on the current platform.\n  static bool get supported => SvgElement.isTagSupported('feSpotLight') && (new SvgElement.tag('feSpotLight') is FESpotLightElement);\n\n  @DomName('SVGFESpotLightElement.limitingConeAngle')\n  @DocsEditable()\n  final AnimatedNumber limitingConeAngle;\n\n  @DomName('SVGFESpotLightElement.pointsAtX')\n  @DocsEditable()\n  final AnimatedNumber pointsAtX;\n\n  @DomName('SVGFESpotLightElement.pointsAtY')\n  @DocsEditable()\n  final AnimatedNumber pointsAtY;\n\n  @DomName('SVGFESpotLightElement.pointsAtZ')\n  @DocsEditable()\n  final AnimatedNumber pointsAtZ;\n\n  @DomName('SVGFESpotLightElement.specularExponent')\n  @DocsEditable()\n  final AnimatedNumber specularExponent;\n\n  @DomName('SVGFESpotLightElement.x')\n  @DocsEditable()\n  final AnimatedNumber x;\n\n  @DomName('SVGFESpotLightElement.y')\n  @DocsEditable()\n  final AnimatedNumber y;\n\n  @DomName('SVGFESpotLightElement.z')\n  @DocsEditable()\n  final AnimatedNumber z;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('SVGFETileElement')\n@SupportedBrowser(SupportedBrowser.CHROME)\n@SupportedBrowser(SupportedBrowser.FIREFOX)\n@SupportedBrowser(SupportedBrowser.IE, '10')\n@SupportedBrowser(SupportedBrowser.SAFARI)\n@Unstable()\n@Native(\"SVGFETileElement\")\nclass FETileElement extends SvgElement implements FilterPrimitiveStandardAttributes {\n  // To suppress missing implicit constructor warnings.\n  factory FETileElement._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('SVGFETileElement.SVGFETileElement')\n  @DocsEditable()\n  factory FETileElement() => _SvgElementFactoryProvider.createSvgElement_tag(\"feTile\");\n  /**\n   * Constructor instantiated by the DOM when a custom element has been created.\n   *\n   * This can only be called by subclasses from their created constructor.\n   */\n  FETileElement.created() : super.created();\n\n  /// Checks if this type is supported on the current platform.\n  static bool get supported => SvgElement.isTagSupported('feTile') && (new SvgElement.tag('feTile') is FETileElement);\n\n  @DomName('SVGFETileElement.in1')\n  @DocsEditable()\n  final AnimatedString in1;\n\n  // From SVGFilterPrimitiveStandardAttributes\n\n  @DomName('SVGFETileElement.height')\n  @DocsEditable()\n  final AnimatedLength height;\n\n  @DomName('SVGFETileElement.result')\n  @DocsEditable()\n  final AnimatedString result;\n\n  @DomName('SVGFETileElement.width')\n  @DocsEditable()\n  final AnimatedLength width;\n\n  @DomName('SVGFETileElement.x')\n  @DocsEditable()\n  final AnimatedLength x;\n\n  @DomName('SVGFETileElement.y')\n  @DocsEditable()\n  final AnimatedLength y;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('SVGFETurbulenceElement')\n@SupportedBrowser(SupportedBrowser.CHROME)\n@SupportedBrowser(SupportedBrowser.FIREFOX)\n@SupportedBrowser(SupportedBrowser.IE, '10')\n@SupportedBrowser(SupportedBrowser.SAFARI)\n@Unstable()\n@Native(\"SVGFETurbulenceElement\")\nclass FETurbulenceElement extends SvgElement implements FilterPrimitiveStandardAttributes {\n  // To suppress missing implicit constructor warnings.\n  factory FETurbulenceElement._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('SVGFETurbulenceElement.SVGFETurbulenceElement')\n  @DocsEditable()\n  factory FETurbulenceElement() => _SvgElementFactoryProvider.createSvgElement_tag(\"feTurbulence\");\n  /**\n   * Constructor instantiated by the DOM when a custom element has been created.\n   *\n   * This can only be called by subclasses from their created constructor.\n   */\n  FETurbulenceElement.created() : super.created();\n\n  /// Checks if this type is supported on the current platform.\n  static bool get supported => SvgElement.isTagSupported('feTurbulence') && (new SvgElement.tag('feTurbulence') is FETurbulenceElement);\n\n  @DomName('SVGFETurbulenceElement.SVG_STITCHTYPE_NOSTITCH')\n  @DocsEditable()\n  static const int SVG_STITCHTYPE_NOSTITCH = 2;\n\n  @DomName('SVGFETurbulenceElement.SVG_STITCHTYPE_STITCH')\n  @DocsEditable()\n  static const int SVG_STITCHTYPE_STITCH = 1;\n\n  @DomName('SVGFETurbulenceElement.SVG_STITCHTYPE_UNKNOWN')\n  @DocsEditable()\n  static const int SVG_STITCHTYPE_UNKNOWN = 0;\n\n  @DomName('SVGFETurbulenceElement.SVG_TURBULENCE_TYPE_FRACTALNOISE')\n  @DocsEditable()\n  static const int SVG_TURBULENCE_TYPE_FRACTALNOISE = 1;\n\n  @DomName('SVGFETurbulenceElement.SVG_TURBULENCE_TYPE_TURBULENCE')\n  @DocsEditable()\n  static const int SVG_TURBULENCE_TYPE_TURBULENCE = 2;\n\n  @DomName('SVGFETurbulenceElement.SVG_TURBULENCE_TYPE_UNKNOWN')\n  @DocsEditable()\n  static const int SVG_TURBULENCE_TYPE_UNKNOWN = 0;\n\n  @DomName('SVGFETurbulenceElement.baseFrequencyX')\n  @DocsEditable()\n  final AnimatedNumber baseFrequencyX;\n\n  @DomName('SVGFETurbulenceElement.baseFrequencyY')\n  @DocsEditable()\n  final AnimatedNumber baseFrequencyY;\n\n  @DomName('SVGFETurbulenceElement.numOctaves')\n  @DocsEditable()\n  final AnimatedInteger numOctaves;\n\n  @DomName('SVGFETurbulenceElement.seed')\n  @DocsEditable()\n  final AnimatedNumber seed;\n\n  @DomName('SVGFETurbulenceElement.stitchTiles')\n  @DocsEditable()\n  final AnimatedEnumeration stitchTiles;\n\n  @DomName('SVGFETurbulenceElement.type')\n  @DocsEditable()\n  final AnimatedEnumeration type;\n\n  // From SVGFilterPrimitiveStandardAttributes\n\n  @DomName('SVGFETurbulenceElement.height')\n  @DocsEditable()\n  final AnimatedLength height;\n\n  @DomName('SVGFETurbulenceElement.result')\n  @DocsEditable()\n  final AnimatedString result;\n\n  @DomName('SVGFETurbulenceElement.width')\n  @DocsEditable()\n  final AnimatedLength width;\n\n  @DomName('SVGFETurbulenceElement.x')\n  @DocsEditable()\n  final AnimatedLength x;\n\n  @DomName('SVGFETurbulenceElement.y')\n  @DocsEditable()\n  final AnimatedLength y;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('SVGFilterElement')\n@SupportedBrowser(SupportedBrowser.CHROME)\n@SupportedBrowser(SupportedBrowser.FIREFOX)\n@SupportedBrowser(SupportedBrowser.IE, '10')\n@SupportedBrowser(SupportedBrowser.SAFARI)\n@Unstable()\n@Native(\"SVGFilterElement\")\nclass FilterElement extends SvgElement implements UriReference {\n  // To suppress missing implicit constructor warnings.\n  factory FilterElement._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('SVGFilterElement.SVGFilterElement')\n  @DocsEditable()\n  factory FilterElement() => _SvgElementFactoryProvider.createSvgElement_tag(\"filter\");\n  /**\n   * Constructor instantiated by the DOM when a custom element has been created.\n   *\n   * This can only be called by subclasses from their created constructor.\n   */\n  FilterElement.created() : super.created();\n\n  /// Checks if this type is supported on the current platform.\n  static bool get supported => SvgElement.isTagSupported('filter') && (new SvgElement.tag('filter') is FilterElement);\n\n  @DomName('SVGFilterElement.filterResX')\n  @DocsEditable()\n  final AnimatedInteger filterResX;\n\n  @DomName('SVGFilterElement.filterResY')\n  @DocsEditable()\n  final AnimatedInteger filterResY;\n\n  @DomName('SVGFilterElement.filterUnits')\n  @DocsEditable()\n  final AnimatedEnumeration filterUnits;\n\n  @DomName('SVGFilterElement.height')\n  @DocsEditable()\n  final AnimatedLength height;\n\n  @DomName('SVGFilterElement.primitiveUnits')\n  @DocsEditable()\n  final AnimatedEnumeration primitiveUnits;\n\n  @DomName('SVGFilterElement.width')\n  @DocsEditable()\n  final AnimatedLength width;\n\n  @DomName('SVGFilterElement.x')\n  @DocsEditable()\n  final AnimatedLength x;\n\n  @DomName('SVGFilterElement.y')\n  @DocsEditable()\n  final AnimatedLength y;\n\n  @DomName('SVGFilterElement.setFilterRes')\n  @DocsEditable()\n  void setFilterRes(int filterResX, int filterResY) native;\n\n  // From SVGURIReference\n\n  @DomName('SVGFilterElement.href')\n  @DocsEditable()\n  final AnimatedString href;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('SVGFilterPrimitiveStandardAttributes')\n@Unstable()\nabstract class FilterPrimitiveStandardAttributes extends Interceptor {\n  // To suppress missing implicit constructor warnings.\n  factory FilterPrimitiveStandardAttributes._() { throw new UnsupportedError(\"Not supported\"); }\n\n  final AnimatedLength height;\n\n  final AnimatedString result;\n\n  final AnimatedLength width;\n\n  final AnimatedLength x;\n\n  final AnimatedLength y;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('SVGFitToViewBox')\n@Unstable()\nabstract class FitToViewBox extends Interceptor {\n  // To suppress missing implicit constructor warnings.\n  factory FitToViewBox._() { throw new UnsupportedError(\"Not supported\"); }\n\n  final AnimatedPreserveAspectRatio preserveAspectRatio;\n\n  final AnimatedRect viewBox;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('SVGForeignObjectElement')\n@SupportedBrowser(SupportedBrowser.CHROME)\n@SupportedBrowser(SupportedBrowser.FIREFOX)\n@SupportedBrowser(SupportedBrowser.SAFARI)\n@Unstable()\n@Native(\"SVGForeignObjectElement\")\nclass ForeignObjectElement extends GraphicsElement {\n  // To suppress missing implicit constructor warnings.\n  factory ForeignObjectElement._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('SVGForeignObjectElement.SVGForeignObjectElement')\n  @DocsEditable()\n  factory ForeignObjectElement() => _SvgElementFactoryProvider.createSvgElement_tag(\"foreignObject\");\n  /**\n   * Constructor instantiated by the DOM when a custom element has been created.\n   *\n   * This can only be called by subclasses from their created constructor.\n   */\n  ForeignObjectElement.created() : super.created();\n\n  /// Checks if this type is supported on the current platform.\n  static bool get supported => SvgElement.isTagSupported('foreignObject') && (new SvgElement.tag('foreignObject') is ForeignObjectElement);\n\n  @DomName('SVGForeignObjectElement.height')\n  @DocsEditable()\n  final AnimatedLength height;\n\n  @DomName('SVGForeignObjectElement.width')\n  @DocsEditable()\n  final AnimatedLength width;\n\n  @DomName('SVGForeignObjectElement.x')\n  @DocsEditable()\n  final AnimatedLength x;\n\n  @DomName('SVGForeignObjectElement.y')\n  @DocsEditable()\n  final AnimatedLength y;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('SVGGElement')\n@Unstable()\n@Native(\"SVGGElement\")\nclass GElement extends GraphicsElement {\n  // To suppress missing implicit constructor warnings.\n  factory GElement._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('SVGGElement.SVGGElement')\n  @DocsEditable()\n  factory GElement() => _SvgElementFactoryProvider.createSvgElement_tag(\"g\");\n  /**\n   * Constructor instantiated by the DOM when a custom element has been created.\n   *\n   * This can only be called by subclasses from their created constructor.\n   */\n  GElement.created() : super.created();\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('SVGGeometryElement')\n@Experimental() // untriaged\n@Native(\"SVGGeometryElement\")\nclass GeometryElement extends GraphicsElement {\n  // To suppress missing implicit constructor warnings.\n  factory GeometryElement._() { throw new UnsupportedError(\"Not supported\"); }\n  /**\n   * Constructor instantiated by the DOM when a custom element has been created.\n   *\n   * This can only be called by subclasses from their created constructor.\n   */\n  GeometryElement.created() : super.created();\n\n  @DomName('SVGGeometryElement.isPointInFill')\n  @DocsEditable()\n  @Experimental() // untriaged\n  bool isPointInFill(Point point) native;\n\n  @DomName('SVGGeometryElement.isPointInStroke')\n  @DocsEditable()\n  @Experimental() // untriaged\n  bool isPointInStroke(Point point) native;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('SVGGraphicsElement')\n@Experimental() // untriaged\n@Native(\"SVGGraphicsElement\")\nclass GraphicsElement extends SvgElement implements Tests {\n  // To suppress missing implicit constructor warnings.\n  factory GraphicsElement._() { throw new UnsupportedError(\"Not supported\"); }\n  /**\n   * Constructor instantiated by the DOM when a custom element has been created.\n   *\n   * This can only be called by subclasses from their created constructor.\n   */\n  GraphicsElement.created() : super.created();\n\n  @DomName('SVGGraphicsElement.farthestViewportElement')\n  @DocsEditable()\n  @Experimental() // untriaged\n  final SvgElement farthestViewportElement;\n\n  @DomName('SVGGraphicsElement.nearestViewportElement')\n  @DocsEditable()\n  @Experimental() // untriaged\n  final SvgElement nearestViewportElement;\n\n  @DomName('SVGGraphicsElement.transform')\n  @DocsEditable()\n  @Experimental() // untriaged\n  final AnimatedTransformList transform;\n\n  @DomName('SVGGraphicsElement.getBBox')\n  @DocsEditable()\n  @Experimental() // untriaged\n  Rect getBBox() native;\n\n  @JSName('getCTM')\n  @DomName('SVGGraphicsElement.getCTM')\n  @DocsEditable()\n  @Experimental() // untriaged\n  Matrix getCtm() native;\n\n  @JSName('getScreenCTM')\n  @DomName('SVGGraphicsElement.getScreenCTM')\n  @DocsEditable()\n  @Experimental() // untriaged\n  Matrix getScreenCtm() native;\n\n  @DomName('SVGGraphicsElement.getTransformToElement')\n  @DocsEditable()\n  @Experimental() // untriaged\n  Matrix getTransformToElement(SvgElement element) native;\n\n  // From SVGTests\n\n  @DomName('SVGGraphicsElement.requiredExtensions')\n  @DocsEditable()\n  @Experimental() // untriaged\n  final StringList requiredExtensions;\n\n  @DomName('SVGGraphicsElement.requiredFeatures')\n  @DocsEditable()\n  @Experimental() // untriaged\n  final StringList requiredFeatures;\n\n  @DomName('SVGGraphicsElement.systemLanguage')\n  @DocsEditable()\n  @Experimental() // untriaged\n  final StringList systemLanguage;\n\n  @DomName('SVGGraphicsElement.hasExtension')\n  @DocsEditable()\n  @Experimental() // untriaged\n  bool hasExtension(String extension) native;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('SVGImageElement')\n@Unstable()\n@Native(\"SVGImageElement\")\nclass ImageElement extends GraphicsElement implements UriReference {\n  // To suppress missing implicit constructor warnings.\n  factory ImageElement._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('SVGImageElement.SVGImageElement')\n  @DocsEditable()\n  factory ImageElement() => _SvgElementFactoryProvider.createSvgElement_tag(\"image\");\n  /**\n   * Constructor instantiated by the DOM when a custom element has been created.\n   *\n   * This can only be called by subclasses from their created constructor.\n   */\n  ImageElement.created() : super.created();\n\n  @DomName('SVGImageElement.height')\n  @DocsEditable()\n  final AnimatedLength height;\n\n  @DomName('SVGImageElement.preserveAspectRatio')\n  @DocsEditable()\n  final AnimatedPreserveAspectRatio preserveAspectRatio;\n\n  @DomName('SVGImageElement.width')\n  @DocsEditable()\n  final AnimatedLength width;\n\n  @DomName('SVGImageElement.x')\n  @DocsEditable()\n  final AnimatedLength x;\n\n  @DomName('SVGImageElement.y')\n  @DocsEditable()\n  final AnimatedLength y;\n\n  // From SVGURIReference\n\n  @DomName('SVGImageElement.href')\n  @DocsEditable()\n  final AnimatedString href;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('SVGLength')\n@Unstable()\n@Native(\"SVGLength\")\nclass Length extends Interceptor {\n  // To suppress missing implicit constructor warnings.\n  factory Length._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('SVGLength.SVG_LENGTHTYPE_CM')\n  @DocsEditable()\n  static const int SVG_LENGTHTYPE_CM = 6;\n\n  @DomName('SVGLength.SVG_LENGTHTYPE_EMS')\n  @DocsEditable()\n  static const int SVG_LENGTHTYPE_EMS = 3;\n\n  @DomName('SVGLength.SVG_LENGTHTYPE_EXS')\n  @DocsEditable()\n  static const int SVG_LENGTHTYPE_EXS = 4;\n\n  @DomName('SVGLength.SVG_LENGTHTYPE_IN')\n  @DocsEditable()\n  static const int SVG_LENGTHTYPE_IN = 8;\n\n  @DomName('SVGLength.SVG_LENGTHTYPE_MM')\n  @DocsEditable()\n  static const int SVG_LENGTHTYPE_MM = 7;\n\n  @DomName('SVGLength.SVG_LENGTHTYPE_NUMBER')\n  @DocsEditable()\n  static const int SVG_LENGTHTYPE_NUMBER = 1;\n\n  @DomName('SVGLength.SVG_LENGTHTYPE_PC')\n  @DocsEditable()\n  static const int SVG_LENGTHTYPE_PC = 10;\n\n  @DomName('SVGLength.SVG_LENGTHTYPE_PERCENTAGE')\n  @DocsEditable()\n  static const int SVG_LENGTHTYPE_PERCENTAGE = 2;\n\n  @DomName('SVGLength.SVG_LENGTHTYPE_PT')\n  @DocsEditable()\n  static const int SVG_LENGTHTYPE_PT = 9;\n\n  @DomName('SVGLength.SVG_LENGTHTYPE_PX')\n  @DocsEditable()\n  static const int SVG_LENGTHTYPE_PX = 5;\n\n  @DomName('SVGLength.SVG_LENGTHTYPE_UNKNOWN')\n  @DocsEditable()\n  static const int SVG_LENGTHTYPE_UNKNOWN = 0;\n\n  @DomName('SVGLength.unitType')\n  @DocsEditable()\n  final int unitType;\n\n  @DomName('SVGLength.value')\n  @DocsEditable()\n  num value;\n\n  @DomName('SVGLength.valueAsString')\n  @DocsEditable()\n  String valueAsString;\n\n  @DomName('SVGLength.valueInSpecifiedUnits')\n  @DocsEditable()\n  num valueInSpecifiedUnits;\n\n  @DomName('SVGLength.convertToSpecifiedUnits')\n  @DocsEditable()\n  void convertToSpecifiedUnits(int unitType) native;\n\n  @DomName('SVGLength.newValueSpecifiedUnits')\n  @DocsEditable()\n  void newValueSpecifiedUnits(int unitType, num valueInSpecifiedUnits) native;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('SVGLengthList')\n@Unstable()\n@Native(\"SVGLengthList\")\nclass LengthList extends Interceptor with ListMixin<Length>, ImmutableListMixin<Length> implements List<Length> {\n  // To suppress missing implicit constructor warnings.\n  factory LengthList._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('SVGLengthList.numberOfItems')\n  @DocsEditable()\n  final int numberOfItems;\n\n  Length operator[](int index) {\n    if (JS(\"bool\", \"# >>> 0 !== # || # >= #\", index,\n        index, index, length))\n      throw new RangeError.range(index, 0, length);\n    return this.getItem(index);\n  }\n  void operator[]=(int index, Length value) {\n    throw new UnsupportedError(\"Cannot assign element of immutable List.\");\n  }\n  // -- start List<Length> mixins.\n  // Length is the element type.\n\n  // SVG Collections expose numberOfItems rather than length.\n  int get length => numberOfItems;\n\n  void set length(int value) {\n    throw new UnsupportedError(\"Cannot resize immutable List.\");\n  }\n\n  Length get first {\n    if (this.length > 0) {\n      return JS('Length', '#[0]', this);\n    }\n    throw new StateError(\"No elements\");\n  }\n\n  Length get last {\n    int len = this.length;\n    if (len > 0) {\n      return JS('Length', '#[#]', this, len - 1);\n    }\n    throw new StateError(\"No elements\");\n  }\n\n  Length get single {\n    int len = this.length;\n    if (len == 1) {\n      return JS('Length', '#[0]', this);\n    }\n    if (len == 0) throw new StateError(\"No elements\");\n    throw new StateError(\"More than one element\");\n  }\n\n  Length elementAt(int index) => this[index];\n  // -- end List<Length> mixins.\n\n  @DomName('SVGLengthList.appendItem')\n  @DocsEditable()\n  Length appendItem(Length item) native;\n\n  @DomName('SVGLengthList.clear')\n  @DocsEditable()\n  void clear() native;\n\n  @DomName('SVGLengthList.getItem')\n  @DocsEditable()\n  Length getItem(int index) native;\n\n  @DomName('SVGLengthList.initialize')\n  @DocsEditable()\n  Length initialize(Length item) native;\n\n  @DomName('SVGLengthList.insertItemBefore')\n  @DocsEditable()\n  Length insertItemBefore(Length item, int index) native;\n\n  @DomName('SVGLengthList.removeItem')\n  @DocsEditable()\n  Length removeItem(int index) native;\n\n  @DomName('SVGLengthList.replaceItem')\n  @DocsEditable()\n  Length replaceItem(Length item, int index) native;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('SVGLineElement')\n@Unstable()\n@Native(\"SVGLineElement\")\nclass LineElement extends GeometryElement {\n  // To suppress missing implicit constructor warnings.\n  factory LineElement._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('SVGLineElement.SVGLineElement')\n  @DocsEditable()\n  factory LineElement() => _SvgElementFactoryProvider.createSvgElement_tag(\"line\");\n  /**\n   * Constructor instantiated by the DOM when a custom element has been created.\n   *\n   * This can only be called by subclasses from their created constructor.\n   */\n  LineElement.created() : super.created();\n\n  @DomName('SVGLineElement.x1')\n  @DocsEditable()\n  final AnimatedLength x1;\n\n  @DomName('SVGLineElement.x2')\n  @DocsEditable()\n  final AnimatedLength x2;\n\n  @DomName('SVGLineElement.y1')\n  @DocsEditable()\n  final AnimatedLength y1;\n\n  @DomName('SVGLineElement.y2')\n  @DocsEditable()\n  final AnimatedLength y2;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('SVGLinearGradientElement')\n@Unstable()\n@Native(\"SVGLinearGradientElement\")\nclass LinearGradientElement extends _GradientElement {\n  // To suppress missing implicit constructor warnings.\n  factory LinearGradientElement._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('SVGLinearGradientElement.SVGLinearGradientElement')\n  @DocsEditable()\n  factory LinearGradientElement() => _SvgElementFactoryProvider.createSvgElement_tag(\"linearGradient\");\n  /**\n   * Constructor instantiated by the DOM when a custom element has been created.\n   *\n   * This can only be called by subclasses from their created constructor.\n   */\n  LinearGradientElement.created() : super.created();\n\n  @DomName('SVGLinearGradientElement.x1')\n  @DocsEditable()\n  final AnimatedLength x1;\n\n  @DomName('SVGLinearGradientElement.x2')\n  @DocsEditable()\n  final AnimatedLength x2;\n\n  @DomName('SVGLinearGradientElement.y1')\n  @DocsEditable()\n  final AnimatedLength y1;\n\n  @DomName('SVGLinearGradientElement.y2')\n  @DocsEditable()\n  final AnimatedLength y2;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('SVGMarkerElement')\n@Unstable()\n@Native(\"SVGMarkerElement\")\nclass MarkerElement extends SvgElement implements FitToViewBox {\n  // To suppress missing implicit constructor warnings.\n  factory MarkerElement._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('SVGMarkerElement.SVGMarkerElement')\n  @DocsEditable()\n  factory MarkerElement() => _SvgElementFactoryProvider.createSvgElement_tag(\"marker\");\n  /**\n   * Constructor instantiated by the DOM when a custom element has been created.\n   *\n   * This can only be called by subclasses from their created constructor.\n   */\n  MarkerElement.created() : super.created();\n\n  @DomName('SVGMarkerElement.SVG_MARKERUNITS_STROKEWIDTH')\n  @DocsEditable()\n  static const int SVG_MARKERUNITS_STROKEWIDTH = 2;\n\n  @DomName('SVGMarkerElement.SVG_MARKERUNITS_UNKNOWN')\n  @DocsEditable()\n  static const int SVG_MARKERUNITS_UNKNOWN = 0;\n\n  @DomName('SVGMarkerElement.SVG_MARKERUNITS_USERSPACEONUSE')\n  @DocsEditable()\n  static const int SVG_MARKERUNITS_USERSPACEONUSE = 1;\n\n  @DomName('SVGMarkerElement.SVG_MARKER_ORIENT_ANGLE')\n  @DocsEditable()\n  static const int SVG_MARKER_ORIENT_ANGLE = 2;\n\n  @DomName('SVGMarkerElement.SVG_MARKER_ORIENT_AUTO')\n  @DocsEditable()\n  static const int SVG_MARKER_ORIENT_AUTO = 1;\n\n  @DomName('SVGMarkerElement.SVG_MARKER_ORIENT_UNKNOWN')\n  @DocsEditable()\n  static const int SVG_MARKER_ORIENT_UNKNOWN = 0;\n\n  @DomName('SVGMarkerElement.markerHeight')\n  @DocsEditable()\n  final AnimatedLength markerHeight;\n\n  @DomName('SVGMarkerElement.markerUnits')\n  @DocsEditable()\n  final AnimatedEnumeration markerUnits;\n\n  @DomName('SVGMarkerElement.markerWidth')\n  @DocsEditable()\n  final AnimatedLength markerWidth;\n\n  @DomName('SVGMarkerElement.orientAngle')\n  @DocsEditable()\n  final AnimatedAngle orientAngle;\n\n  @DomName('SVGMarkerElement.orientType')\n  @DocsEditable()\n  final AnimatedEnumeration orientType;\n\n  @DomName('SVGMarkerElement.refX')\n  @DocsEditable()\n  final AnimatedLength refX;\n\n  @DomName('SVGMarkerElement.refY')\n  @DocsEditable()\n  final AnimatedLength refY;\n\n  @DomName('SVGMarkerElement.setOrientToAngle')\n  @DocsEditable()\n  void setOrientToAngle(Angle angle) native;\n\n  @DomName('SVGMarkerElement.setOrientToAuto')\n  @DocsEditable()\n  void setOrientToAuto() native;\n\n  // From SVGFitToViewBox\n\n  @DomName('SVGMarkerElement.preserveAspectRatio')\n  @DocsEditable()\n  final AnimatedPreserveAspectRatio preserveAspectRatio;\n\n  @DomName('SVGMarkerElement.viewBox')\n  @DocsEditable()\n  final AnimatedRect viewBox;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('SVGMaskElement')\n@Unstable()\n@Native(\"SVGMaskElement\")\nclass MaskElement extends SvgElement implements Tests {\n  // To suppress missing implicit constructor warnings.\n  factory MaskElement._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('SVGMaskElement.SVGMaskElement')\n  @DocsEditable()\n  factory MaskElement() => _SvgElementFactoryProvider.createSvgElement_tag(\"mask\");\n  /**\n   * Constructor instantiated by the DOM when a custom element has been created.\n   *\n   * This can only be called by subclasses from their created constructor.\n   */\n  MaskElement.created() : super.created();\n\n  @DomName('SVGMaskElement.height')\n  @DocsEditable()\n  final AnimatedLength height;\n\n  @DomName('SVGMaskElement.maskContentUnits')\n  @DocsEditable()\n  final AnimatedEnumeration maskContentUnits;\n\n  @DomName('SVGMaskElement.maskUnits')\n  @DocsEditable()\n  final AnimatedEnumeration maskUnits;\n\n  @DomName('SVGMaskElement.width')\n  @DocsEditable()\n  final AnimatedLength width;\n\n  @DomName('SVGMaskElement.x')\n  @DocsEditable()\n  final AnimatedLength x;\n\n  @DomName('SVGMaskElement.y')\n  @DocsEditable()\n  final AnimatedLength y;\n\n  // From SVGTests\n\n  @DomName('SVGMaskElement.requiredExtensions')\n  @DocsEditable()\n  final StringList requiredExtensions;\n\n  @DomName('SVGMaskElement.requiredFeatures')\n  @DocsEditable()\n  final StringList requiredFeatures;\n\n  @DomName('SVGMaskElement.systemLanguage')\n  @DocsEditable()\n  final StringList systemLanguage;\n\n  @DomName('SVGMaskElement.hasExtension')\n  @DocsEditable()\n  bool hasExtension(String extension) native;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('SVGMatrix')\n@Unstable()\n@Native(\"SVGMatrix\")\nclass Matrix extends Interceptor {\n  // To suppress missing implicit constructor warnings.\n  factory Matrix._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('SVGMatrix.a')\n  @DocsEditable()\n  num a;\n\n  @DomName('SVGMatrix.b')\n  @DocsEditable()\n  num b;\n\n  @DomName('SVGMatrix.c')\n  @DocsEditable()\n  num c;\n\n  @DomName('SVGMatrix.d')\n  @DocsEditable()\n  num d;\n\n  @DomName('SVGMatrix.e')\n  @DocsEditable()\n  num e;\n\n  @DomName('SVGMatrix.f')\n  @DocsEditable()\n  num f;\n\n  @DomName('SVGMatrix.flipX')\n  @DocsEditable()\n  Matrix flipX() native;\n\n  @DomName('SVGMatrix.flipY')\n  @DocsEditable()\n  Matrix flipY() native;\n\n  @DomName('SVGMatrix.inverse')\n  @DocsEditable()\n  Matrix inverse() native;\n\n  @DomName('SVGMatrix.multiply')\n  @DocsEditable()\n  Matrix multiply(Matrix secondMatrix) native;\n\n  @DomName('SVGMatrix.rotate')\n  @DocsEditable()\n  Matrix rotate(num angle) native;\n\n  @DomName('SVGMatrix.rotateFromVector')\n  @DocsEditable()\n  Matrix rotateFromVector(num x, num y) native;\n\n  @DomName('SVGMatrix.scale')\n  @DocsEditable()\n  Matrix scale(num scaleFactor) native;\n\n  @DomName('SVGMatrix.scaleNonUniform')\n  @DocsEditable()\n  Matrix scaleNonUniform(num scaleFactorX, num scaleFactorY) native;\n\n  @DomName('SVGMatrix.skewX')\n  @DocsEditable()\n  Matrix skewX(num angle) native;\n\n  @DomName('SVGMatrix.skewY')\n  @DocsEditable()\n  Matrix skewY(num angle) native;\n\n  @DomName('SVGMatrix.translate')\n  @DocsEditable()\n  Matrix translate(num x, num y) native;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('SVGMetadataElement')\n@Unstable()\n@Native(\"SVGMetadataElement\")\nclass MetadataElement extends SvgElement {\n  // To suppress missing implicit constructor warnings.\n  factory MetadataElement._() { throw new UnsupportedError(\"Not supported\"); }\n  /**\n   * Constructor instantiated by the DOM when a custom element has been created.\n   *\n   * This can only be called by subclasses from their created constructor.\n   */\n  MetadataElement.created() : super.created();\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('SVGNumber')\n@Unstable()\n@Native(\"SVGNumber\")\nclass Number extends Interceptor {\n  // To suppress missing implicit constructor warnings.\n  factory Number._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('SVGNumber.value')\n  @DocsEditable()\n  num value;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('SVGNumberList')\n@Unstable()\n@Native(\"SVGNumberList\")\nclass NumberList extends Interceptor with ListMixin<Number>, ImmutableListMixin<Number> implements List<Number> {\n  // To suppress missing implicit constructor warnings.\n  factory NumberList._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('SVGNumberList.numberOfItems')\n  @DocsEditable()\n  final int numberOfItems;\n\n  Number operator[](int index) {\n    if (JS(\"bool\", \"# >>> 0 !== # || # >= #\", index,\n        index, index, length))\n      throw new RangeError.range(index, 0, length);\n    return this.getItem(index);\n  }\n  void operator[]=(int index, Number value) {\n    throw new UnsupportedError(\"Cannot assign element of immutable List.\");\n  }\n  // -- start List<Number> mixins.\n  // Number is the element type.\n\n  // SVG Collections expose numberOfItems rather than length.\n  int get length => numberOfItems;\n\n  void set length(int value) {\n    throw new UnsupportedError(\"Cannot resize immutable List.\");\n  }\n\n  Number get first {\n    if (this.length > 0) {\n      return JS('Number', '#[0]', this);\n    }\n    throw new StateError(\"No elements\");\n  }\n\n  Number get last {\n    int len = this.length;\n    if (len > 0) {\n      return JS('Number', '#[#]', this, len - 1);\n    }\n    throw new StateError(\"No elements\");\n  }\n\n  Number get single {\n    int len = this.length;\n    if (len == 1) {\n      return JS('Number', '#[0]', this);\n    }\n    if (len == 0) throw new StateError(\"No elements\");\n    throw new StateError(\"More than one element\");\n  }\n\n  Number elementAt(int index) => this[index];\n  // -- end List<Number> mixins.\n\n  @DomName('SVGNumberList.appendItem')\n  @DocsEditable()\n  Number appendItem(Number item) native;\n\n  @DomName('SVGNumberList.clear')\n  @DocsEditable()\n  void clear() native;\n\n  @DomName('SVGNumberList.getItem')\n  @DocsEditable()\n  Number getItem(int index) native;\n\n  @DomName('SVGNumberList.initialize')\n  @DocsEditable()\n  Number initialize(Number item) native;\n\n  @DomName('SVGNumberList.insertItemBefore')\n  @DocsEditable()\n  Number insertItemBefore(Number item, int index) native;\n\n  @DomName('SVGNumberList.removeItem')\n  @DocsEditable()\n  Number removeItem(int index) native;\n\n  @DomName('SVGNumberList.replaceItem')\n  @DocsEditable()\n  Number replaceItem(Number item, int index) native;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('SVGPathElement')\n@Unstable()\n@Native(\"SVGPathElement\")\nclass PathElement extends GeometryElement {\n  // To suppress missing implicit constructor warnings.\n  factory PathElement._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('SVGPathElement.SVGPathElement')\n  @DocsEditable()\n  factory PathElement() => _SvgElementFactoryProvider.createSvgElement_tag(\"path\");\n  /**\n   * Constructor instantiated by the DOM when a custom element has been created.\n   *\n   * This can only be called by subclasses from their created constructor.\n   */\n  PathElement.created() : super.created();\n\n  @DomName('SVGPathElement.animatedNormalizedPathSegList')\n  @DocsEditable()\n  final PathSegList animatedNormalizedPathSegList;\n\n  @DomName('SVGPathElement.animatedPathSegList')\n  @DocsEditable()\n  final PathSegList animatedPathSegList;\n\n  @DomName('SVGPathElement.normalizedPathSegList')\n  @DocsEditable()\n  final PathSegList normalizedPathSegList;\n\n  @DomName('SVGPathElement.pathLength')\n  @DocsEditable()\n  final AnimatedNumber pathLength;\n\n  @DomName('SVGPathElement.pathSegList')\n  @DocsEditable()\n  final PathSegList pathSegList;\n\n  @JSName('createSVGPathSegArcAbs')\n  @DomName('SVGPathElement.createSVGPathSegArcAbs')\n  @DocsEditable()\n  PathSegArcAbs createSvgPathSegArcAbs(num x, num y, num r1, num r2, num angle, bool largeArcFlag, bool sweepFlag) native;\n\n  @JSName('createSVGPathSegArcRel')\n  @DomName('SVGPathElement.createSVGPathSegArcRel')\n  @DocsEditable()\n  PathSegArcRel createSvgPathSegArcRel(num x, num y, num r1, num r2, num angle, bool largeArcFlag, bool sweepFlag) native;\n\n  @JSName('createSVGPathSegClosePath')\n  @DomName('SVGPathElement.createSVGPathSegClosePath')\n  @DocsEditable()\n  PathSegClosePath createSvgPathSegClosePath() native;\n\n  @JSName('createSVGPathSegCurvetoCubicAbs')\n  @DomName('SVGPathElement.createSVGPathSegCurvetoCubicAbs')\n  @DocsEditable()\n  PathSegCurvetoCubicAbs createSvgPathSegCurvetoCubicAbs(num x, num y, num x1, num y1, num x2, num y2) native;\n\n  @JSName('createSVGPathSegCurvetoCubicRel')\n  @DomName('SVGPathElement.createSVGPathSegCurvetoCubicRel')\n  @DocsEditable()\n  PathSegCurvetoCubicRel createSvgPathSegCurvetoCubicRel(num x, num y, num x1, num y1, num x2, num y2) native;\n\n  @JSName('createSVGPathSegCurvetoCubicSmoothAbs')\n  @DomName('SVGPathElement.createSVGPathSegCurvetoCubicSmoothAbs')\n  @DocsEditable()\n  PathSegCurvetoCubicSmoothAbs createSvgPathSegCurvetoCubicSmoothAbs(num x, num y, num x2, num y2) native;\n\n  @JSName('createSVGPathSegCurvetoCubicSmoothRel')\n  @DomName('SVGPathElement.createSVGPathSegCurvetoCubicSmoothRel')\n  @DocsEditable()\n  PathSegCurvetoCubicSmoothRel createSvgPathSegCurvetoCubicSmoothRel(num x, num y, num x2, num y2) native;\n\n  @JSName('createSVGPathSegCurvetoQuadraticAbs')\n  @DomName('SVGPathElement.createSVGPathSegCurvetoQuadraticAbs')\n  @DocsEditable()\n  PathSegCurvetoQuadraticAbs createSvgPathSegCurvetoQuadraticAbs(num x, num y, num x1, num y1) native;\n\n  @JSName('createSVGPathSegCurvetoQuadraticRel')\n  @DomName('SVGPathElement.createSVGPathSegCurvetoQuadraticRel')\n  @DocsEditable()\n  PathSegCurvetoQuadraticRel createSvgPathSegCurvetoQuadraticRel(num x, num y, num x1, num y1) native;\n\n  @JSName('createSVGPathSegCurvetoQuadraticSmoothAbs')\n  @DomName('SVGPathElement.createSVGPathSegCurvetoQuadraticSmoothAbs')\n  @DocsEditable()\n  PathSegCurvetoQuadraticSmoothAbs createSvgPathSegCurvetoQuadraticSmoothAbs(num x, num y) native;\n\n  @JSName('createSVGPathSegCurvetoQuadraticSmoothRel')\n  @DomName('SVGPathElement.createSVGPathSegCurvetoQuadraticSmoothRel')\n  @DocsEditable()\n  PathSegCurvetoQuadraticSmoothRel createSvgPathSegCurvetoQuadraticSmoothRel(num x, num y) native;\n\n  @JSName('createSVGPathSegLinetoAbs')\n  @DomName('SVGPathElement.createSVGPathSegLinetoAbs')\n  @DocsEditable()\n  PathSegLinetoAbs createSvgPathSegLinetoAbs(num x, num y) native;\n\n  @JSName('createSVGPathSegLinetoHorizontalAbs')\n  @DomName('SVGPathElement.createSVGPathSegLinetoHorizontalAbs')\n  @DocsEditable()\n  PathSegLinetoHorizontalAbs createSvgPathSegLinetoHorizontalAbs(num x) native;\n\n  @JSName('createSVGPathSegLinetoHorizontalRel')\n  @DomName('SVGPathElement.createSVGPathSegLinetoHorizontalRel')\n  @DocsEditable()\n  PathSegLinetoHorizontalRel createSvgPathSegLinetoHorizontalRel(num x) native;\n\n  @JSName('createSVGPathSegLinetoRel')\n  @DomName('SVGPathElement.createSVGPathSegLinetoRel')\n  @DocsEditable()\n  PathSegLinetoRel createSvgPathSegLinetoRel(num x, num y) native;\n\n  @JSName('createSVGPathSegLinetoVerticalAbs')\n  @DomName('SVGPathElement.createSVGPathSegLinetoVerticalAbs')\n  @DocsEditable()\n  PathSegLinetoVerticalAbs createSvgPathSegLinetoVerticalAbs(num y) native;\n\n  @JSName('createSVGPathSegLinetoVerticalRel')\n  @DomName('SVGPathElement.createSVGPathSegLinetoVerticalRel')\n  @DocsEditable()\n  PathSegLinetoVerticalRel createSvgPathSegLinetoVerticalRel(num y) native;\n\n  @JSName('createSVGPathSegMovetoAbs')\n  @DomName('SVGPathElement.createSVGPathSegMovetoAbs')\n  @DocsEditable()\n  PathSegMovetoAbs createSvgPathSegMovetoAbs(num x, num y) native;\n\n  @JSName('createSVGPathSegMovetoRel')\n  @DomName('SVGPathElement.createSVGPathSegMovetoRel')\n  @DocsEditable()\n  PathSegMovetoRel createSvgPathSegMovetoRel(num x, num y) native;\n\n  @DomName('SVGPathElement.getPathSegAtLength')\n  @DocsEditable()\n  int getPathSegAtLength(num distance) native;\n\n  @DomName('SVGPathElement.getPointAtLength')\n  @DocsEditable()\n  Point getPointAtLength(num distance) native;\n\n  @DomName('SVGPathElement.getTotalLength')\n  @DocsEditable()\n  double getTotalLength() native;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('SVGPathSeg')\n@Unstable()\n@Native(\"SVGPathSeg\")\nclass PathSeg extends Interceptor {\n  // To suppress missing implicit constructor warnings.\n  factory PathSeg._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('SVGPathSeg.PATHSEG_ARC_ABS')\n  @DocsEditable()\n  static const int PATHSEG_ARC_ABS = 10;\n\n  @DomName('SVGPathSeg.PATHSEG_ARC_REL')\n  @DocsEditable()\n  static const int PATHSEG_ARC_REL = 11;\n\n  @DomName('SVGPathSeg.PATHSEG_CLOSEPATH')\n  @DocsEditable()\n  static const int PATHSEG_CLOSEPATH = 1;\n\n  @DomName('SVGPathSeg.PATHSEG_CURVETO_CUBIC_ABS')\n  @DocsEditable()\n  static const int PATHSEG_CURVETO_CUBIC_ABS = 6;\n\n  @DomName('SVGPathSeg.PATHSEG_CURVETO_CUBIC_REL')\n  @DocsEditable()\n  static const int PATHSEG_CURVETO_CUBIC_REL = 7;\n\n  @DomName('SVGPathSeg.PATHSEG_CURVETO_CUBIC_SMOOTH_ABS')\n  @DocsEditable()\n  static const int PATHSEG_CURVETO_CUBIC_SMOOTH_ABS = 16;\n\n  @DomName('SVGPathSeg.PATHSEG_CURVETO_CUBIC_SMOOTH_REL')\n  @DocsEditable()\n  static const int PATHSEG_CURVETO_CUBIC_SMOOTH_REL = 17;\n\n  @DomName('SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_ABS')\n  @DocsEditable()\n  static const int PATHSEG_CURVETO_QUADRATIC_ABS = 8;\n\n  @DomName('SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_REL')\n  @DocsEditable()\n  static const int PATHSEG_CURVETO_QUADRATIC_REL = 9;\n\n  @DomName('SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_SMOOTH_ABS')\n  @DocsEditable()\n  static const int PATHSEG_CURVETO_QUADRATIC_SMOOTH_ABS = 18;\n\n  @DomName('SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_SMOOTH_REL')\n  @DocsEditable()\n  static const int PATHSEG_CURVETO_QUADRATIC_SMOOTH_REL = 19;\n\n  @DomName('SVGPathSeg.PATHSEG_LINETO_ABS')\n  @DocsEditable()\n  static const int PATHSEG_LINETO_ABS = 4;\n\n  @DomName('SVGPathSeg.PATHSEG_LINETO_HORIZONTAL_ABS')\n  @DocsEditable()\n  static const int PATHSEG_LINETO_HORIZONTAL_ABS = 12;\n\n  @DomName('SVGPathSeg.PATHSEG_LINETO_HORIZONTAL_REL')\n  @DocsEditable()\n  static const int PATHSEG_LINETO_HORIZONTAL_REL = 13;\n\n  @DomName('SVGPathSeg.PATHSEG_LINETO_REL')\n  @DocsEditable()\n  static const int PATHSEG_LINETO_REL = 5;\n\n  @DomName('SVGPathSeg.PATHSEG_LINETO_VERTICAL_ABS')\n  @DocsEditable()\n  static const int PATHSEG_LINETO_VERTICAL_ABS = 14;\n\n  @DomName('SVGPathSeg.PATHSEG_LINETO_VERTICAL_REL')\n  @DocsEditable()\n  static const int PATHSEG_LINETO_VERTICAL_REL = 15;\n\n  @DomName('SVGPathSeg.PATHSEG_MOVETO_ABS')\n  @DocsEditable()\n  static const int PATHSEG_MOVETO_ABS = 2;\n\n  @DomName('SVGPathSeg.PATHSEG_MOVETO_REL')\n  @DocsEditable()\n  static const int PATHSEG_MOVETO_REL = 3;\n\n  @DomName('SVGPathSeg.PATHSEG_UNKNOWN')\n  @DocsEditable()\n  static const int PATHSEG_UNKNOWN = 0;\n\n  @DomName('SVGPathSeg.pathSegType')\n  @DocsEditable()\n  final int pathSegType;\n\n  @DomName('SVGPathSeg.pathSegTypeAsLetter')\n  @DocsEditable()\n  final String pathSegTypeAsLetter;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('SVGPathSegArcAbs')\n@Unstable()\n@Native(\"SVGPathSegArcAbs\")\nclass PathSegArcAbs extends PathSeg {\n  // To suppress missing implicit constructor warnings.\n  factory PathSegArcAbs._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('SVGPathSegArcAbs.angle')\n  @DocsEditable()\n  num angle;\n\n  @DomName('SVGPathSegArcAbs.largeArcFlag')\n  @DocsEditable()\n  bool largeArcFlag;\n\n  @DomName('SVGPathSegArcAbs.r1')\n  @DocsEditable()\n  num r1;\n\n  @DomName('SVGPathSegArcAbs.r2')\n  @DocsEditable()\n  num r2;\n\n  @DomName('SVGPathSegArcAbs.sweepFlag')\n  @DocsEditable()\n  bool sweepFlag;\n\n  @DomName('SVGPathSegArcAbs.x')\n  @DocsEditable()\n  num x;\n\n  @DomName('SVGPathSegArcAbs.y')\n  @DocsEditable()\n  num y;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('SVGPathSegArcRel')\n@Unstable()\n@Native(\"SVGPathSegArcRel\")\nclass PathSegArcRel extends PathSeg {\n  // To suppress missing implicit constructor warnings.\n  factory PathSegArcRel._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('SVGPathSegArcRel.angle')\n  @DocsEditable()\n  num angle;\n\n  @DomName('SVGPathSegArcRel.largeArcFlag')\n  @DocsEditable()\n  bool largeArcFlag;\n\n  @DomName('SVGPathSegArcRel.r1')\n  @DocsEditable()\n  num r1;\n\n  @DomName('SVGPathSegArcRel.r2')\n  @DocsEditable()\n  num r2;\n\n  @DomName('SVGPathSegArcRel.sweepFlag')\n  @DocsEditable()\n  bool sweepFlag;\n\n  @DomName('SVGPathSegArcRel.x')\n  @DocsEditable()\n  num x;\n\n  @DomName('SVGPathSegArcRel.y')\n  @DocsEditable()\n  num y;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('SVGPathSegClosePath')\n@Unstable()\n@Native(\"SVGPathSegClosePath\")\nclass PathSegClosePath extends PathSeg {\n  // To suppress missing implicit constructor warnings.\n  factory PathSegClosePath._() { throw new UnsupportedError(\"Not supported\"); }\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('SVGPathSegCurvetoCubicAbs')\n@Unstable()\n@Native(\"SVGPathSegCurvetoCubicAbs\")\nclass PathSegCurvetoCubicAbs extends PathSeg {\n  // To suppress missing implicit constructor warnings.\n  factory PathSegCurvetoCubicAbs._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('SVGPathSegCurvetoCubicAbs.x')\n  @DocsEditable()\n  num x;\n\n  @DomName('SVGPathSegCurvetoCubicAbs.x1')\n  @DocsEditable()\n  num x1;\n\n  @DomName('SVGPathSegCurvetoCubicAbs.x2')\n  @DocsEditable()\n  num x2;\n\n  @DomName('SVGPathSegCurvetoCubicAbs.y')\n  @DocsEditable()\n  num y;\n\n  @DomName('SVGPathSegCurvetoCubicAbs.y1')\n  @DocsEditable()\n  num y1;\n\n  @DomName('SVGPathSegCurvetoCubicAbs.y2')\n  @DocsEditable()\n  num y2;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('SVGPathSegCurvetoCubicRel')\n@Unstable()\n@Native(\"SVGPathSegCurvetoCubicRel\")\nclass PathSegCurvetoCubicRel extends PathSeg {\n  // To suppress missing implicit constructor warnings.\n  factory PathSegCurvetoCubicRel._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('SVGPathSegCurvetoCubicRel.x')\n  @DocsEditable()\n  num x;\n\n  @DomName('SVGPathSegCurvetoCubicRel.x1')\n  @DocsEditable()\n  num x1;\n\n  @DomName('SVGPathSegCurvetoCubicRel.x2')\n  @DocsEditable()\n  num x2;\n\n  @DomName('SVGPathSegCurvetoCubicRel.y')\n  @DocsEditable()\n  num y;\n\n  @DomName('SVGPathSegCurvetoCubicRel.y1')\n  @DocsEditable()\n  num y1;\n\n  @DomName('SVGPathSegCurvetoCubicRel.y2')\n  @DocsEditable()\n  num y2;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('SVGPathSegCurvetoCubicSmoothAbs')\n@Unstable()\n@Native(\"SVGPathSegCurvetoCubicSmoothAbs\")\nclass PathSegCurvetoCubicSmoothAbs extends PathSeg {\n  // To suppress missing implicit constructor warnings.\n  factory PathSegCurvetoCubicSmoothAbs._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('SVGPathSegCurvetoCubicSmoothAbs.x')\n  @DocsEditable()\n  num x;\n\n  @DomName('SVGPathSegCurvetoCubicSmoothAbs.x2')\n  @DocsEditable()\n  num x2;\n\n  @DomName('SVGPathSegCurvetoCubicSmoothAbs.y')\n  @DocsEditable()\n  num y;\n\n  @DomName('SVGPathSegCurvetoCubicSmoothAbs.y2')\n  @DocsEditable()\n  num y2;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('SVGPathSegCurvetoCubicSmoothRel')\n@Unstable()\n@Native(\"SVGPathSegCurvetoCubicSmoothRel\")\nclass PathSegCurvetoCubicSmoothRel extends PathSeg {\n  // To suppress missing implicit constructor warnings.\n  factory PathSegCurvetoCubicSmoothRel._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('SVGPathSegCurvetoCubicSmoothRel.x')\n  @DocsEditable()\n  num x;\n\n  @DomName('SVGPathSegCurvetoCubicSmoothRel.x2')\n  @DocsEditable()\n  num x2;\n\n  @DomName('SVGPathSegCurvetoCubicSmoothRel.y')\n  @DocsEditable()\n  num y;\n\n  @DomName('SVGPathSegCurvetoCubicSmoothRel.y2')\n  @DocsEditable()\n  num y2;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('SVGPathSegCurvetoQuadraticAbs')\n@Unstable()\n@Native(\"SVGPathSegCurvetoQuadraticAbs\")\nclass PathSegCurvetoQuadraticAbs extends PathSeg {\n  // To suppress missing implicit constructor warnings.\n  factory PathSegCurvetoQuadraticAbs._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('SVGPathSegCurvetoQuadraticAbs.x')\n  @DocsEditable()\n  num x;\n\n  @DomName('SVGPathSegCurvetoQuadraticAbs.x1')\n  @DocsEditable()\n  num x1;\n\n  @DomName('SVGPathSegCurvetoQuadraticAbs.y')\n  @DocsEditable()\n  num y;\n\n  @DomName('SVGPathSegCurvetoQuadraticAbs.y1')\n  @DocsEditable()\n  num y1;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('SVGPathSegCurvetoQuadraticRel')\n@Unstable()\n@Native(\"SVGPathSegCurvetoQuadraticRel\")\nclass PathSegCurvetoQuadraticRel extends PathSeg {\n  // To suppress missing implicit constructor warnings.\n  factory PathSegCurvetoQuadraticRel._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('SVGPathSegCurvetoQuadraticRel.x')\n  @DocsEditable()\n  num x;\n\n  @DomName('SVGPathSegCurvetoQuadraticRel.x1')\n  @DocsEditable()\n  num x1;\n\n  @DomName('SVGPathSegCurvetoQuadraticRel.y')\n  @DocsEditable()\n  num y;\n\n  @DomName('SVGPathSegCurvetoQuadraticRel.y1')\n  @DocsEditable()\n  num y1;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('SVGPathSegCurvetoQuadraticSmoothAbs')\n@Unstable()\n@Native(\"SVGPathSegCurvetoQuadraticSmoothAbs\")\nclass PathSegCurvetoQuadraticSmoothAbs extends PathSeg {\n  // To suppress missing implicit constructor warnings.\n  factory PathSegCurvetoQuadraticSmoothAbs._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('SVGPathSegCurvetoQuadraticSmoothAbs.x')\n  @DocsEditable()\n  num x;\n\n  @DomName('SVGPathSegCurvetoQuadraticSmoothAbs.y')\n  @DocsEditable()\n  num y;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('SVGPathSegCurvetoQuadraticSmoothRel')\n@Unstable()\n@Native(\"SVGPathSegCurvetoQuadraticSmoothRel\")\nclass PathSegCurvetoQuadraticSmoothRel extends PathSeg {\n  // To suppress missing implicit constructor warnings.\n  factory PathSegCurvetoQuadraticSmoothRel._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('SVGPathSegCurvetoQuadraticSmoothRel.x')\n  @DocsEditable()\n  num x;\n\n  @DomName('SVGPathSegCurvetoQuadraticSmoothRel.y')\n  @DocsEditable()\n  num y;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('SVGPathSegLinetoAbs')\n@Unstable()\n@Native(\"SVGPathSegLinetoAbs\")\nclass PathSegLinetoAbs extends PathSeg {\n  // To suppress missing implicit constructor warnings.\n  factory PathSegLinetoAbs._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('SVGPathSegLinetoAbs.x')\n  @DocsEditable()\n  num x;\n\n  @DomName('SVGPathSegLinetoAbs.y')\n  @DocsEditable()\n  num y;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('SVGPathSegLinetoHorizontalAbs')\n@Unstable()\n@Native(\"SVGPathSegLinetoHorizontalAbs\")\nclass PathSegLinetoHorizontalAbs extends PathSeg {\n  // To suppress missing implicit constructor warnings.\n  factory PathSegLinetoHorizontalAbs._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('SVGPathSegLinetoHorizontalAbs.x')\n  @DocsEditable()\n  num x;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('SVGPathSegLinetoHorizontalRel')\n@Unstable()\n@Native(\"SVGPathSegLinetoHorizontalRel\")\nclass PathSegLinetoHorizontalRel extends PathSeg {\n  // To suppress missing implicit constructor warnings.\n  factory PathSegLinetoHorizontalRel._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('SVGPathSegLinetoHorizontalRel.x')\n  @DocsEditable()\n  num x;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('SVGPathSegLinetoRel')\n@Unstable()\n@Native(\"SVGPathSegLinetoRel\")\nclass PathSegLinetoRel extends PathSeg {\n  // To suppress missing implicit constructor warnings.\n  factory PathSegLinetoRel._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('SVGPathSegLinetoRel.x')\n  @DocsEditable()\n  num x;\n\n  @DomName('SVGPathSegLinetoRel.y')\n  @DocsEditable()\n  num y;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('SVGPathSegLinetoVerticalAbs')\n@Unstable()\n@Native(\"SVGPathSegLinetoVerticalAbs\")\nclass PathSegLinetoVerticalAbs extends PathSeg {\n  // To suppress missing implicit constructor warnings.\n  factory PathSegLinetoVerticalAbs._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('SVGPathSegLinetoVerticalAbs.y')\n  @DocsEditable()\n  num y;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('SVGPathSegLinetoVerticalRel')\n@Unstable()\n@Native(\"SVGPathSegLinetoVerticalRel\")\nclass PathSegLinetoVerticalRel extends PathSeg {\n  // To suppress missing implicit constructor warnings.\n  factory PathSegLinetoVerticalRel._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('SVGPathSegLinetoVerticalRel.y')\n  @DocsEditable()\n  num y;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('SVGPathSegList')\n@Unstable()\n@Native(\"SVGPathSegList\")\nclass PathSegList extends Interceptor with ListMixin<PathSeg>, ImmutableListMixin<PathSeg> implements List<PathSeg> {\n  // To suppress missing implicit constructor warnings.\n  factory PathSegList._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('SVGPathSegList.numberOfItems')\n  @DocsEditable()\n  final int numberOfItems;\n\n  PathSeg operator[](int index) {\n    if (JS(\"bool\", \"# >>> 0 !== # || # >= #\", index,\n        index, index, length))\n      throw new RangeError.range(index, 0, length);\n    return this.getItem(index);\n  }\n  void operator[]=(int index, PathSeg value) {\n    throw new UnsupportedError(\"Cannot assign element of immutable List.\");\n  }\n  // -- start List<PathSeg> mixins.\n  // PathSeg is the element type.\n\n  // SVG Collections expose numberOfItems rather than length.\n  int get length => numberOfItems;\n\n  void set length(int value) {\n    throw new UnsupportedError(\"Cannot resize immutable List.\");\n  }\n\n  PathSeg get first {\n    if (this.length > 0) {\n      return JS('PathSeg', '#[0]', this);\n    }\n    throw new StateError(\"No elements\");\n  }\n\n  PathSeg get last {\n    int len = this.length;\n    if (len > 0) {\n      return JS('PathSeg', '#[#]', this, len - 1);\n    }\n    throw new StateError(\"No elements\");\n  }\n\n  PathSeg get single {\n    int len = this.length;\n    if (len == 1) {\n      return JS('PathSeg', '#[0]', this);\n    }\n    if (len == 0) throw new StateError(\"No elements\");\n    throw new StateError(\"More than one element\");\n  }\n\n  PathSeg elementAt(int index) => this[index];\n  // -- end List<PathSeg> mixins.\n\n  @DomName('SVGPathSegList.appendItem')\n  @DocsEditable()\n  PathSeg appendItem(PathSeg newItem) native;\n\n  @DomName('SVGPathSegList.clear')\n  @DocsEditable()\n  void clear() native;\n\n  @DomName('SVGPathSegList.getItem')\n  @DocsEditable()\n  PathSeg getItem(int index) native;\n\n  @DomName('SVGPathSegList.initialize')\n  @DocsEditable()\n  PathSeg initialize(PathSeg newItem) native;\n\n  @DomName('SVGPathSegList.insertItemBefore')\n  @DocsEditable()\n  PathSeg insertItemBefore(PathSeg newItem, int index) native;\n\n  @DomName('SVGPathSegList.removeItem')\n  @DocsEditable()\n  PathSeg removeItem(int index) native;\n\n  @DomName('SVGPathSegList.replaceItem')\n  @DocsEditable()\n  PathSeg replaceItem(PathSeg newItem, int index) native;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('SVGPathSegMovetoAbs')\n@Unstable()\n@Native(\"SVGPathSegMovetoAbs\")\nclass PathSegMovetoAbs extends PathSeg {\n  // To suppress missing implicit constructor warnings.\n  factory PathSegMovetoAbs._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('SVGPathSegMovetoAbs.x')\n  @DocsEditable()\n  num x;\n\n  @DomName('SVGPathSegMovetoAbs.y')\n  @DocsEditable()\n  num y;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('SVGPathSegMovetoRel')\n@Unstable()\n@Native(\"SVGPathSegMovetoRel\")\nclass PathSegMovetoRel extends PathSeg {\n  // To suppress missing implicit constructor warnings.\n  factory PathSegMovetoRel._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('SVGPathSegMovetoRel.x')\n  @DocsEditable()\n  num x;\n\n  @DomName('SVGPathSegMovetoRel.y')\n  @DocsEditable()\n  num y;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('SVGPatternElement')\n@Unstable()\n@Native(\"SVGPatternElement\")\nclass PatternElement extends SvgElement implements FitToViewBox, UriReference, Tests {\n  // To suppress missing implicit constructor warnings.\n  factory PatternElement._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('SVGPatternElement.SVGPatternElement')\n  @DocsEditable()\n  factory PatternElement() => _SvgElementFactoryProvider.createSvgElement_tag(\"pattern\");\n  /**\n   * Constructor instantiated by the DOM when a custom element has been created.\n   *\n   * This can only be called by subclasses from their created constructor.\n   */\n  PatternElement.created() : super.created();\n\n  @DomName('SVGPatternElement.height')\n  @DocsEditable()\n  final AnimatedLength height;\n\n  @DomName('SVGPatternElement.patternContentUnits')\n  @DocsEditable()\n  final AnimatedEnumeration patternContentUnits;\n\n  @DomName('SVGPatternElement.patternTransform')\n  @DocsEditable()\n  final AnimatedTransformList patternTransform;\n\n  @DomName('SVGPatternElement.patternUnits')\n  @DocsEditable()\n  final AnimatedEnumeration patternUnits;\n\n  @DomName('SVGPatternElement.width')\n  @DocsEditable()\n  final AnimatedLength width;\n\n  @DomName('SVGPatternElement.x')\n  @DocsEditable()\n  final AnimatedLength x;\n\n  @DomName('SVGPatternElement.y')\n  @DocsEditable()\n  final AnimatedLength y;\n\n  // From SVGFitToViewBox\n\n  @DomName('SVGPatternElement.preserveAspectRatio')\n  @DocsEditable()\n  final AnimatedPreserveAspectRatio preserveAspectRatio;\n\n  @DomName('SVGPatternElement.viewBox')\n  @DocsEditable()\n  final AnimatedRect viewBox;\n\n  // From SVGTests\n\n  @DomName('SVGPatternElement.requiredExtensions')\n  @DocsEditable()\n  final StringList requiredExtensions;\n\n  @DomName('SVGPatternElement.requiredFeatures')\n  @DocsEditable()\n  final StringList requiredFeatures;\n\n  @DomName('SVGPatternElement.systemLanguage')\n  @DocsEditable()\n  final StringList systemLanguage;\n\n  @DomName('SVGPatternElement.hasExtension')\n  @DocsEditable()\n  bool hasExtension(String extension) native;\n\n  // From SVGURIReference\n\n  @DomName('SVGPatternElement.href')\n  @DocsEditable()\n  final AnimatedString href;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('SVGPoint')\n@Unstable()\n@Native(\"SVGPoint\")\nclass Point extends Interceptor {\n  // To suppress missing implicit constructor warnings.\n  factory Point._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('SVGPoint.x')\n  @DocsEditable()\n  num x;\n\n  @DomName('SVGPoint.y')\n  @DocsEditable()\n  num y;\n\n  @DomName('SVGPoint.matrixTransform')\n  @DocsEditable()\n  Point matrixTransform(Matrix matrix) native;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('SVGPointList')\n@Unstable()\n@Native(\"SVGPointList\")\nclass PointList extends Interceptor {\n  // To suppress missing implicit constructor warnings.\n  factory PointList._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('SVGPointList.numberOfItems')\n  @DocsEditable()\n  final int numberOfItems;\n\n  @DomName('SVGPointList.appendItem')\n  @DocsEditable()\n  Point appendItem(Point item) native;\n\n  @DomName('SVGPointList.clear')\n  @DocsEditable()\n  void clear() native;\n\n  @DomName('SVGPointList.getItem')\n  @DocsEditable()\n  Point getItem(int index) native;\n\n  @DomName('SVGPointList.initialize')\n  @DocsEditable()\n  Point initialize(Point item) native;\n\n  @DomName('SVGPointList.insertItemBefore')\n  @DocsEditable()\n  Point insertItemBefore(Point item, int index) native;\n\n  @DomName('SVGPointList.removeItem')\n  @DocsEditable()\n  Point removeItem(int index) native;\n\n  @DomName('SVGPointList.replaceItem')\n  @DocsEditable()\n  Point replaceItem(Point item, int index) native;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('SVGPolygonElement')\n@Unstable()\n@Native(\"SVGPolygonElement\")\nclass PolygonElement extends GeometryElement {\n  // To suppress missing implicit constructor warnings.\n  factory PolygonElement._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('SVGPolygonElement.SVGPolygonElement')\n  @DocsEditable()\n  factory PolygonElement() => _SvgElementFactoryProvider.createSvgElement_tag(\"polygon\");\n  /**\n   * Constructor instantiated by the DOM when a custom element has been created.\n   *\n   * This can only be called by subclasses from their created constructor.\n   */\n  PolygonElement.created() : super.created();\n\n  @DomName('SVGPolygonElement.animatedPoints')\n  @DocsEditable()\n  final PointList animatedPoints;\n\n  @DomName('SVGPolygonElement.points')\n  @DocsEditable()\n  final PointList points;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('SVGPolylineElement')\n@Unstable()\n@Native(\"SVGPolylineElement\")\nclass PolylineElement extends GeometryElement {\n  // To suppress missing implicit constructor warnings.\n  factory PolylineElement._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('SVGPolylineElement.SVGPolylineElement')\n  @DocsEditable()\n  factory PolylineElement() => _SvgElementFactoryProvider.createSvgElement_tag(\"polyline\");\n  /**\n   * Constructor instantiated by the DOM when a custom element has been created.\n   *\n   * This can only be called by subclasses from their created constructor.\n   */\n  PolylineElement.created() : super.created();\n\n  @DomName('SVGPolylineElement.animatedPoints')\n  @DocsEditable()\n  final PointList animatedPoints;\n\n  @DomName('SVGPolylineElement.points')\n  @DocsEditable()\n  final PointList points;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('SVGPreserveAspectRatio')\n@Unstable()\n@Native(\"SVGPreserveAspectRatio\")\nclass PreserveAspectRatio extends Interceptor {\n  // To suppress missing implicit constructor warnings.\n  factory PreserveAspectRatio._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('SVGPreserveAspectRatio.SVG_MEETORSLICE_MEET')\n  @DocsEditable()\n  static const int SVG_MEETORSLICE_MEET = 1;\n\n  @DomName('SVGPreserveAspectRatio.SVG_MEETORSLICE_SLICE')\n  @DocsEditable()\n  static const int SVG_MEETORSLICE_SLICE = 2;\n\n  @DomName('SVGPreserveAspectRatio.SVG_MEETORSLICE_UNKNOWN')\n  @DocsEditable()\n  static const int SVG_MEETORSLICE_UNKNOWN = 0;\n\n  @DomName('SVGPreserveAspectRatio.SVG_PRESERVEASPECTRATIO_NONE')\n  @DocsEditable()\n  static const int SVG_PRESERVEASPECTRATIO_NONE = 1;\n\n  @DomName('SVGPreserveAspectRatio.SVG_PRESERVEASPECTRATIO_UNKNOWN')\n  @DocsEditable()\n  static const int SVG_PRESERVEASPECTRATIO_UNKNOWN = 0;\n\n  @DomName('SVGPreserveAspectRatio.SVG_PRESERVEASPECTRATIO_XMAXYMAX')\n  @DocsEditable()\n  static const int SVG_PRESERVEASPECTRATIO_XMAXYMAX = 10;\n\n  @DomName('SVGPreserveAspectRatio.SVG_PRESERVEASPECTRATIO_XMAXYMID')\n  @DocsEditable()\n  static const int SVG_PRESERVEASPECTRATIO_XMAXYMID = 7;\n\n  @DomName('SVGPreserveAspectRatio.SVG_PRESERVEASPECTRATIO_XMAXYMIN')\n  @DocsEditable()\n  static const int SVG_PRESERVEASPECTRATIO_XMAXYMIN = 4;\n\n  @DomName('SVGPreserveAspectRatio.SVG_PRESERVEASPECTRATIO_XMIDYMAX')\n  @DocsEditable()\n  static const int SVG_PRESERVEASPECTRATIO_XMIDYMAX = 9;\n\n  @DomName('SVGPreserveAspectRatio.SVG_PRESERVEASPECTRATIO_XMIDYMID')\n  @DocsEditable()\n  static const int SVG_PRESERVEASPECTRATIO_XMIDYMID = 6;\n\n  @DomName('SVGPreserveAspectRatio.SVG_PRESERVEASPECTRATIO_XMIDYMIN')\n  @DocsEditable()\n  static const int SVG_PRESERVEASPECTRATIO_XMIDYMIN = 3;\n\n  @DomName('SVGPreserveAspectRatio.SVG_PRESERVEASPECTRATIO_XMINYMAX')\n  @DocsEditable()\n  static const int SVG_PRESERVEASPECTRATIO_XMINYMAX = 8;\n\n  @DomName('SVGPreserveAspectRatio.SVG_PRESERVEASPECTRATIO_XMINYMID')\n  @DocsEditable()\n  static const int SVG_PRESERVEASPECTRATIO_XMINYMID = 5;\n\n  @DomName('SVGPreserveAspectRatio.SVG_PRESERVEASPECTRATIO_XMINYMIN')\n  @DocsEditable()\n  static const int SVG_PRESERVEASPECTRATIO_XMINYMIN = 2;\n\n  @DomName('SVGPreserveAspectRatio.align')\n  @DocsEditable()\n  int align;\n\n  @DomName('SVGPreserveAspectRatio.meetOrSlice')\n  @DocsEditable()\n  int meetOrSlice;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('SVGRadialGradientElement')\n@Unstable()\n@Native(\"SVGRadialGradientElement\")\nclass RadialGradientElement extends _GradientElement {\n  // To suppress missing implicit constructor warnings.\n  factory RadialGradientElement._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('SVGRadialGradientElement.SVGRadialGradientElement')\n  @DocsEditable()\n  factory RadialGradientElement() => _SvgElementFactoryProvider.createSvgElement_tag(\"radialGradient\");\n  /**\n   * Constructor instantiated by the DOM when a custom element has been created.\n   *\n   * This can only be called by subclasses from their created constructor.\n   */\n  RadialGradientElement.created() : super.created();\n\n  @DomName('SVGRadialGradientElement.cx')\n  @DocsEditable()\n  final AnimatedLength cx;\n\n  @DomName('SVGRadialGradientElement.cy')\n  @DocsEditable()\n  final AnimatedLength cy;\n\n  @DomName('SVGRadialGradientElement.fr')\n  @DocsEditable()\n  final AnimatedLength fr;\n\n  @DomName('SVGRadialGradientElement.fx')\n  @DocsEditable()\n  final AnimatedLength fx;\n\n  @DomName('SVGRadialGradientElement.fy')\n  @DocsEditable()\n  final AnimatedLength fy;\n\n  @DomName('SVGRadialGradientElement.r')\n  @DocsEditable()\n  final AnimatedLength r;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('SVGRect')\n@Unstable()\n@Native(\"SVGRect\")\nclass Rect extends Interceptor {\n  // To suppress missing implicit constructor warnings.\n  factory Rect._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('SVGRect.height')\n  @DocsEditable()\n  num height;\n\n  @DomName('SVGRect.width')\n  @DocsEditable()\n  num width;\n\n  @DomName('SVGRect.x')\n  @DocsEditable()\n  num x;\n\n  @DomName('SVGRect.y')\n  @DocsEditable()\n  num y;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('SVGRectElement')\n@Unstable()\n@Native(\"SVGRectElement\")\nclass RectElement extends GeometryElement {\n  // To suppress missing implicit constructor warnings.\n  factory RectElement._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('SVGRectElement.SVGRectElement')\n  @DocsEditable()\n  factory RectElement() => _SvgElementFactoryProvider.createSvgElement_tag(\"rect\");\n  /**\n   * Constructor instantiated by the DOM when a custom element has been created.\n   *\n   * This can only be called by subclasses from their created constructor.\n   */\n  RectElement.created() : super.created();\n\n  @DomName('SVGRectElement.height')\n  @DocsEditable()\n  final AnimatedLength height;\n\n  @DomName('SVGRectElement.rx')\n  @DocsEditable()\n  final AnimatedLength rx;\n\n  @DomName('SVGRectElement.ry')\n  @DocsEditable()\n  final AnimatedLength ry;\n\n  @DomName('SVGRectElement.width')\n  @DocsEditable()\n  final AnimatedLength width;\n\n  @DomName('SVGRectElement.x')\n  @DocsEditable()\n  final AnimatedLength x;\n\n  @DomName('SVGRectElement.y')\n  @DocsEditable()\n  final AnimatedLength y;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('SVGRenderingIntent')\n@Unstable()\n@Native(\"SVGRenderingIntent\")\nclass RenderingIntent extends Interceptor {\n  // To suppress missing implicit constructor warnings.\n  factory RenderingIntent._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('SVGRenderingIntent.RENDERING_INTENT_ABSOLUTE_COLORIMETRIC')\n  @DocsEditable()\n  static const int RENDERING_INTENT_ABSOLUTE_COLORIMETRIC = 5;\n\n  @DomName('SVGRenderingIntent.RENDERING_INTENT_AUTO')\n  @DocsEditable()\n  static const int RENDERING_INTENT_AUTO = 1;\n\n  @DomName('SVGRenderingIntent.RENDERING_INTENT_PERCEPTUAL')\n  @DocsEditable()\n  static const int RENDERING_INTENT_PERCEPTUAL = 2;\n\n  @DomName('SVGRenderingIntent.RENDERING_INTENT_RELATIVE_COLORIMETRIC')\n  @DocsEditable()\n  static const int RENDERING_INTENT_RELATIVE_COLORIMETRIC = 3;\n\n  @DomName('SVGRenderingIntent.RENDERING_INTENT_SATURATION')\n  @DocsEditable()\n  static const int RENDERING_INTENT_SATURATION = 4;\n\n  @DomName('SVGRenderingIntent.RENDERING_INTENT_UNKNOWN')\n  @DocsEditable()\n  static const int RENDERING_INTENT_UNKNOWN = 0;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('SVGScriptElement')\n@Unstable()\n@Native(\"SVGScriptElement\")\nclass ScriptElement extends SvgElement implements UriReference {\n  // To suppress missing implicit constructor warnings.\n  factory ScriptElement._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('SVGScriptElement.SVGScriptElement')\n  @DocsEditable()\n  factory ScriptElement() => _SvgElementFactoryProvider.createSvgElement_tag(\"script\");\n  /**\n   * Constructor instantiated by the DOM when a custom element has been created.\n   *\n   * This can only be called by subclasses from their created constructor.\n   */\n  ScriptElement.created() : super.created();\n\n  @DomName('SVGScriptElement.type')\n  @DocsEditable()\n  String type;\n\n  // From SVGURIReference\n\n  @DomName('SVGScriptElement.href')\n  @DocsEditable()\n  final AnimatedString href;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('SVGSetElement')\n@SupportedBrowser(SupportedBrowser.CHROME)\n@SupportedBrowser(SupportedBrowser.FIREFOX)\n@SupportedBrowser(SupportedBrowser.SAFARI)\n@Unstable()\n@Native(\"SVGSetElement\")\nclass SetElement extends AnimationElement {\n  // To suppress missing implicit constructor warnings.\n  factory SetElement._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('SVGSetElement.SVGSetElement')\n  @DocsEditable()\n  factory SetElement() => _SvgElementFactoryProvider.createSvgElement_tag(\"set\");\n  /**\n   * Constructor instantiated by the DOM when a custom element has been created.\n   *\n   * This can only be called by subclasses from their created constructor.\n   */\n  SetElement.created() : super.created();\n\n  /// Checks if this type is supported on the current platform.\n  static bool get supported => SvgElement.isTagSupported('set') && (new SvgElement.tag('set') is SetElement);\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('SVGStopElement')\n@Unstable()\n@Native(\"SVGStopElement\")\nclass StopElement extends SvgElement {\n  // To suppress missing implicit constructor warnings.\n  factory StopElement._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('SVGStopElement.SVGStopElement')\n  @DocsEditable()\n  factory StopElement() => _SvgElementFactoryProvider.createSvgElement_tag(\"stop\");\n  /**\n   * Constructor instantiated by the DOM when a custom element has been created.\n   *\n   * This can only be called by subclasses from their created constructor.\n   */\n  StopElement.created() : super.created();\n\n  @JSName('offset')\n  @DomName('SVGStopElement.offset')\n  @DocsEditable()\n  final AnimatedNumber gradientOffset;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('SVGStringList')\n@Unstable()\n@Native(\"SVGStringList\")\nclass StringList extends Interceptor with ListMixin<String>, ImmutableListMixin<String> implements List<String> {\n  // To suppress missing implicit constructor warnings.\n  factory StringList._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('SVGStringList.numberOfItems')\n  @DocsEditable()\n  final int numberOfItems;\n\n  String operator[](int index) {\n    if (JS(\"bool\", \"# >>> 0 !== # || # >= #\", index,\n        index, index, length))\n      throw new RangeError.range(index, 0, length);\n    return this.getItem(index);\n  }\n  void operator[]=(int index, String value) {\n    throw new UnsupportedError(\"Cannot assign element of immutable List.\");\n  }\n  // -- start List<String> mixins.\n  // String is the element type.\n\n  // SVG Collections expose numberOfItems rather than length.\n  int get length => numberOfItems;\n\n  void set length(int value) {\n    throw new UnsupportedError(\"Cannot resize immutable List.\");\n  }\n\n  String get first {\n    if (this.length > 0) {\n      return JS('String', '#[0]', this);\n    }\n    throw new StateError(\"No elements\");\n  }\n\n  String get last {\n    int len = this.length;\n    if (len > 0) {\n      return JS('String', '#[#]', this, len - 1);\n    }\n    throw new StateError(\"No elements\");\n  }\n\n  String get single {\n    int len = this.length;\n    if (len == 1) {\n      return JS('String', '#[0]', this);\n    }\n    if (len == 0) throw new StateError(\"No elements\");\n    throw new StateError(\"More than one element\");\n  }\n\n  String elementAt(int index) => this[index];\n  // -- end List<String> mixins.\n\n  @DomName('SVGStringList.appendItem')\n  @DocsEditable()\n  String appendItem(String item) native;\n\n  @DomName('SVGStringList.clear')\n  @DocsEditable()\n  void clear() native;\n\n  @DomName('SVGStringList.getItem')\n  @DocsEditable()\n  String getItem(int index) native;\n\n  @DomName('SVGStringList.initialize')\n  @DocsEditable()\n  String initialize(String item) native;\n\n  @DomName('SVGStringList.insertItemBefore')\n  @DocsEditable()\n  String insertItemBefore(String item, int index) native;\n\n  @DomName('SVGStringList.removeItem')\n  @DocsEditable()\n  String removeItem(int index) native;\n\n  @DomName('SVGStringList.replaceItem')\n  @DocsEditable()\n  String replaceItem(String item, int index) native;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('SVGStyleElement')\n// http://www.w3.org/TR/SVG/types.html#InterfaceSVGStylable\n@Experimental() // nonstandard\n@Native(\"SVGStyleElement\")\nclass StyleElement extends SvgElement {\n  // To suppress missing implicit constructor warnings.\n  factory StyleElement._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('SVGStyleElement.SVGStyleElement')\n  @DocsEditable()\n  factory StyleElement() => _SvgElementFactoryProvider.createSvgElement_tag(\"style\");\n  /**\n   * Constructor instantiated by the DOM when a custom element has been created.\n   *\n   * This can only be called by subclasses from their created constructor.\n   */\n  StyleElement.created() : super.created();\n\n  @DomName('SVGStyleElement.disabled')\n  @DocsEditable()\n  bool disabled;\n\n  @DomName('SVGStyleElement.media')\n  @DocsEditable()\n  String media;\n\n  // Shadowing definition.\n  String get title => JS(\"String\", \"#.title\", this);\n\n  void set title(String value) {\n    JS(\"void\", \"#.title = #\", this, value);\n  }\n\n  @DomName('SVGStyleElement.type')\n  @DocsEditable()\n  String type;\n}\n// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\nclass _AttributeClassSet extends CssClassSetImpl {\n  final Element _element;\n\n  _AttributeClassSet(this._element);\n\n  Set<String> readClasses() {\n    var classname = _element.attributes['class'];\n\n    Set<String> s = new LinkedHashSet<String>();\n    if (classname == null) {\n      return s;\n    }\n    for (String name in classname.split(' ')) {\n      String trimmed = name.trim();\n      if (!trimmed.isEmpty) {\n        s.add(trimmed);\n      }\n    }\n    return s;\n  }\n\n  void writeClasses(Set s) {\n    _element.attributes['class'] = s.join(' ');\n  }\n}\n\n@DomName('SVGElement')\n@Unstable()\n@Native(\"SVGElement\")\nclass SvgElement extends Element implements GlobalEventHandlers {\n  static final _START_TAG_REGEXP = new RegExp('<(\\\\w+)');\n\n  factory SvgElement.tag(String tag) =>\n      document.createElementNS(\"http://www.w3.org/2000/svg\", tag);\n  factory SvgElement.svg(String svg,\n      {NodeValidator validator, NodeTreeSanitizer treeSanitizer}) {\n\n    if (validator == null && treeSanitizer == null) {\n      validator = new NodeValidatorBuilder.common()..allowSvg();\n    }\n\n    final match = _START_TAG_REGEXP.firstMatch(svg);\n    var parentElement;\n    if (match != null && match.group(1).toLowerCase() == 'svg') {\n      parentElement = document.body;\n    } else {\n      parentElement = new SvgSvgElement();\n    }\n    var fragment = parentElement.createFragment(svg, validator: validator,\n        treeSanitizer: treeSanitizer);\n    return fragment.nodes.where((e) => e is SvgElement).single;\n  }\n\n  _AttributeClassSet _cssClassSet;\n  CssClassSet get classes {\n    if (_cssClassSet == null) {\n      _cssClassSet = new _AttributeClassSet(this);\n    }\n    return _cssClassSet;\n  }\n\n  List<Element> get children => new FilteredElementList<Element>(this);\n\n  void set children(List<Element> value) {\n    final children = this.children;\n    children.clear();\n    children.addAll(value);\n  }\n\n  String get outerHtml {\n    final container = new Element.tag(\"div\");\n    final SvgElement cloned = this.clone(true);\n    container.children.add(cloned);\n    return container.innerHtml;\n  }\n\n  String get innerHtml {\n    final container = new Element.tag(\"div\");\n    final SvgElement cloned = this.clone(true);\n    container.children.addAll(cloned.children);\n    return container.innerHtml;\n  }\n\n  void set innerHtml(String value) {\n    this.setInnerHtml(value);\n  }\n\n  DocumentFragment createFragment(String svg,\n      {NodeValidator validator, NodeTreeSanitizer treeSanitizer}) {\n\n    if (treeSanitizer == null) {\n      if (validator == null) {\n        validator = new NodeValidatorBuilder.common()\n          ..allowSvg();\n      }\n      treeSanitizer = new NodeTreeSanitizer(validator);\n    }\n\n    // We create a fragment which will parse in the HTML parser\n    var html = '<svg version=\"1.1\">$svg</svg>';\n    var fragment = document.body.createFragment(html,\n        treeSanitizer: treeSanitizer);\n\n    var svgFragment = new DocumentFragment();\n    // The root is the <svg/> element, need to pull out the contents.\n    var root = fragment.nodes.single;\n    while (root.firstChild != null) {\n      svgFragment.append(root.firstChild);\n    }\n    return svgFragment;\n  }\n\n  // Unsupported methods inherited from Element.\n\n  @DomName('Element.insertAdjacentText')\n  void insertAdjacentText(String where, String text) {\n    throw new UnsupportedError(\"Cannot invoke insertAdjacentText on SVG.\");\n  }\n\n  @DomName('Element.insertAdjacentHTML')\n  void insertAdjacentHtml(String where, String text) {\n    throw new UnsupportedError(\"Cannot invoke insertAdjacentHtml on SVG.\");\n  }\n\n  @DomName('Element.insertAdjacentHTML')\n  Element insertAdjacentElement(String where, Element element) {\n    throw new UnsupportedError(\"Cannot invoke insertAdjacentElement on SVG.\");\n  }\n\n  HtmlCollection get _children {\n    throw new UnsupportedError(\"Cannot get _children on SVG.\");\n  }\n\n  bool get isContentEditable => false;\n  void click() {\n    throw new UnsupportedError(\"Cannot invoke click SVG.\");\n  }\n\n  /**\n   * Checks to see if the SVG element type is supported by the current platform.\n   *\n   * The tag should be a valid SVG element tag name.\n   */\n  static bool isTagSupported(String tag) {\n    var e = new SvgElement.tag(tag);\n    return e is SvgElement && !(e is UnknownElement);\n  }\n  // To suppress missing implicit constructor warnings.\n  factory SvgElement._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('SVGElement.abortEvent')\n  @DocsEditable()\n  @Experimental() // untriaged\n  static const EventStreamProvider<Event> abortEvent = const EventStreamProvider<Event>('abort');\n\n  @DomName('SVGElement.blurEvent')\n  @DocsEditable()\n  @Experimental() // untriaged\n  static const EventStreamProvider<Event> blurEvent = const EventStreamProvider<Event>('blur');\n\n  @DomName('SVGElement.canplayEvent')\n  @DocsEditable()\n  @Experimental() // untriaged\n  static const EventStreamProvider<Event> canPlayEvent = const EventStreamProvider<Event>('canplay');\n\n  @DomName('SVGElement.canplaythroughEvent')\n  @DocsEditable()\n  @Experimental() // untriaged\n  static const EventStreamProvider<Event> canPlayThroughEvent = const EventStreamProvider<Event>('canplaythrough');\n\n  @DomName('SVGElement.changeEvent')\n  @DocsEditable()\n  @Experimental() // untriaged\n  static const EventStreamProvider<Event> changeEvent = const EventStreamProvider<Event>('change');\n\n  @DomName('SVGElement.clickEvent')\n  @DocsEditable()\n  @Experimental() // untriaged\n  static const EventStreamProvider<MouseEvent> clickEvent = const EventStreamProvider<MouseEvent>('click');\n\n  @DomName('SVGElement.contextmenuEvent')\n  @DocsEditable()\n  @Experimental() // untriaged\n  static const EventStreamProvider<MouseEvent> contextMenuEvent = const EventStreamProvider<MouseEvent>('contextmenu');\n\n  @DomName('SVGElement.dblclickEvent')\n  @DocsEditable()\n  @Experimental() // untriaged\n  static const EventStreamProvider<Event> doubleClickEvent = const EventStreamProvider<Event>('dblclick');\n\n  @DomName('SVGElement.dragEvent')\n  @DocsEditable()\n  @Experimental() // untriaged\n  static const EventStreamProvider<MouseEvent> dragEvent = const EventStreamProvider<MouseEvent>('drag');\n\n  @DomName('SVGElement.dragendEvent')\n  @DocsEditable()\n  @Experimental() // untriaged\n  static const EventStreamProvider<MouseEvent> dragEndEvent = const EventStreamProvider<MouseEvent>('dragend');\n\n  @DomName('SVGElement.dragenterEvent')\n  @DocsEditable()\n  @Experimental() // untriaged\n  static const EventStreamProvider<MouseEvent> dragEnterEvent = const EventStreamProvider<MouseEvent>('dragenter');\n\n  @DomName('SVGElement.dragleaveEvent')\n  @DocsEditable()\n  @Experimental() // untriaged\n  static const EventStreamProvider<MouseEvent> dragLeaveEvent = const EventStreamProvider<MouseEvent>('dragleave');\n\n  @DomName('SVGElement.dragoverEvent')\n  @DocsEditable()\n  @Experimental() // untriaged\n  static const EventStreamProvider<MouseEvent> dragOverEvent = const EventStreamProvider<MouseEvent>('dragover');\n\n  @DomName('SVGElement.dragstartEvent')\n  @DocsEditable()\n  @Experimental() // untriaged\n  static const EventStreamProvider<MouseEvent> dragStartEvent = const EventStreamProvider<MouseEvent>('dragstart');\n\n  @DomName('SVGElement.dropEvent')\n  @DocsEditable()\n  @Experimental() // untriaged\n  static const EventStreamProvider<MouseEvent> dropEvent = const EventStreamProvider<MouseEvent>('drop');\n\n  @DomName('SVGElement.durationchangeEvent')\n  @DocsEditable()\n  @Experimental() // untriaged\n  static const EventStreamProvider<Event> durationChangeEvent = const EventStreamProvider<Event>('durationchange');\n\n  @DomName('SVGElement.emptiedEvent')\n  @DocsEditable()\n  @Experimental() // untriaged\n  static const EventStreamProvider<Event> emptiedEvent = const EventStreamProvider<Event>('emptied');\n\n  @DomName('SVGElement.endedEvent')\n  @DocsEditable()\n  @Experimental() // untriaged\n  static const EventStreamProvider<Event> endedEvent = const EventStreamProvider<Event>('ended');\n\n  @DomName('SVGElement.errorEvent')\n  @DocsEditable()\n  @Experimental() // untriaged\n  static const EventStreamProvider<Event> errorEvent = const EventStreamProvider<Event>('error');\n\n  @DomName('SVGElement.focusEvent')\n  @DocsEditable()\n  @Experimental() // untriaged\n  static const EventStreamProvider<Event> focusEvent = const EventStreamProvider<Event>('focus');\n\n  @DomName('SVGElement.inputEvent')\n  @DocsEditable()\n  @Experimental() // untriaged\n  static const EventStreamProvider<Event> inputEvent = const EventStreamProvider<Event>('input');\n\n  @DomName('SVGElement.invalidEvent')\n  @DocsEditable()\n  @Experimental() // untriaged\n  static const EventStreamProvider<Event> invalidEvent = const EventStreamProvider<Event>('invalid');\n\n  @DomName('SVGElement.keydownEvent')\n  @DocsEditable()\n  @Experimental() // untriaged\n  static const EventStreamProvider<KeyboardEvent> keyDownEvent = const EventStreamProvider<KeyboardEvent>('keydown');\n\n  @DomName('SVGElement.keypressEvent')\n  @DocsEditable()\n  @Experimental() // untriaged\n  static const EventStreamProvider<KeyboardEvent> keyPressEvent = const EventStreamProvider<KeyboardEvent>('keypress');\n\n  @DomName('SVGElement.keyupEvent')\n  @DocsEditable()\n  @Experimental() // untriaged\n  static const EventStreamProvider<KeyboardEvent> keyUpEvent = const EventStreamProvider<KeyboardEvent>('keyup');\n\n  @DomName('SVGElement.loadEvent')\n  @DocsEditable()\n  @Experimental() // untriaged\n  static const EventStreamProvider<Event> loadEvent = const EventStreamProvider<Event>('load');\n\n  @DomName('SVGElement.loadeddataEvent')\n  @DocsEditable()\n  @Experimental() // untriaged\n  static const EventStreamProvider<Event> loadedDataEvent = const EventStreamProvider<Event>('loadeddata');\n\n  @DomName('SVGElement.loadedmetadataEvent')\n  @DocsEditable()\n  @Experimental() // untriaged\n  static const EventStreamProvider<Event> loadedMetadataEvent = const EventStreamProvider<Event>('loadedmetadata');\n\n  @DomName('SVGElement.mousedownEvent')\n  @DocsEditable()\n  @Experimental() // untriaged\n  static const EventStreamProvider<MouseEvent> mouseDownEvent = const EventStreamProvider<MouseEvent>('mousedown');\n\n  @DomName('SVGElement.mouseenterEvent')\n  @DocsEditable()\n  @Experimental() // untriaged\n  static const EventStreamProvider<MouseEvent> mouseEnterEvent = const EventStreamProvider<MouseEvent>('mouseenter');\n\n  @DomName('SVGElement.mouseleaveEvent')\n  @DocsEditable()\n  @Experimental() // untriaged\n  static const EventStreamProvider<MouseEvent> mouseLeaveEvent = const EventStreamProvider<MouseEvent>('mouseleave');\n\n  @DomName('SVGElement.mousemoveEvent')\n  @DocsEditable()\n  @Experimental() // untriaged\n  static const EventStreamProvider<MouseEvent> mouseMoveEvent = const EventStreamProvider<MouseEvent>('mousemove');\n\n  @DomName('SVGElement.mouseoutEvent')\n  @DocsEditable()\n  @Experimental() // untriaged\n  static const EventStreamProvider<MouseEvent> mouseOutEvent = const EventStreamProvider<MouseEvent>('mouseout');\n\n  @DomName('SVGElement.mouseoverEvent')\n  @DocsEditable()\n  @Experimental() // untriaged\n  static const EventStreamProvider<MouseEvent> mouseOverEvent = const EventStreamProvider<MouseEvent>('mouseover');\n\n  @DomName('SVGElement.mouseupEvent')\n  @DocsEditable()\n  @Experimental() // untriaged\n  static const EventStreamProvider<MouseEvent> mouseUpEvent = const EventStreamProvider<MouseEvent>('mouseup');\n\n  @DomName('SVGElement.mousewheelEvent')\n  @DocsEditable()\n  @Experimental() // untriaged\n  static const EventStreamProvider<WheelEvent> mouseWheelEvent = const EventStreamProvider<WheelEvent>('mousewheel');\n\n  @DomName('SVGElement.pauseEvent')\n  @DocsEditable()\n  @Experimental() // untriaged\n  static const EventStreamProvider<Event> pauseEvent = const EventStreamProvider<Event>('pause');\n\n  @DomName('SVGElement.playEvent')\n  @DocsEditable()\n  @Experimental() // untriaged\n  static const EventStreamProvider<Event> playEvent = const EventStreamProvider<Event>('play');\n\n  @DomName('SVGElement.playingEvent')\n  @DocsEditable()\n  @Experimental() // untriaged\n  static const EventStreamProvider<Event> playingEvent = const EventStreamProvider<Event>('playing');\n\n  @DomName('SVGElement.ratechangeEvent')\n  @DocsEditable()\n  @Experimental() // untriaged\n  static const EventStreamProvider<Event> rateChangeEvent = const EventStreamProvider<Event>('ratechange');\n\n  @DomName('SVGElement.resetEvent')\n  @DocsEditable()\n  @Experimental() // untriaged\n  static const EventStreamProvider<Event> resetEvent = const EventStreamProvider<Event>('reset');\n\n  @DomName('SVGElement.resizeEvent')\n  @DocsEditable()\n  @Experimental() // untriaged\n  static const EventStreamProvider<Event> resizeEvent = const EventStreamProvider<Event>('resize');\n\n  @DomName('SVGElement.scrollEvent')\n  @DocsEditable()\n  @Experimental() // untriaged\n  static const EventStreamProvider<Event> scrollEvent = const EventStreamProvider<Event>('scroll');\n\n  @DomName('SVGElement.seekedEvent')\n  @DocsEditable()\n  @Experimental() // untriaged\n  static const EventStreamProvider<Event> seekedEvent = const EventStreamProvider<Event>('seeked');\n\n  @DomName('SVGElement.seekingEvent')\n  @DocsEditable()\n  @Experimental() // untriaged\n  static const EventStreamProvider<Event> seekingEvent = const EventStreamProvider<Event>('seeking');\n\n  @DomName('SVGElement.selectEvent')\n  @DocsEditable()\n  @Experimental() // untriaged\n  static const EventStreamProvider<Event> selectEvent = const EventStreamProvider<Event>('select');\n\n  @DomName('SVGElement.stalledEvent')\n  @DocsEditable()\n  @Experimental() // untriaged\n  static const EventStreamProvider<Event> stalledEvent = const EventStreamProvider<Event>('stalled');\n\n  @DomName('SVGElement.submitEvent')\n  @DocsEditable()\n  @Experimental() // untriaged\n  static const EventStreamProvider<Event> submitEvent = const EventStreamProvider<Event>('submit');\n\n  @DomName('SVGElement.suspendEvent')\n  @DocsEditable()\n  @Experimental() // untriaged\n  static const EventStreamProvider<Event> suspendEvent = const EventStreamProvider<Event>('suspend');\n\n  @DomName('SVGElement.timeupdateEvent')\n  @DocsEditable()\n  @Experimental() // untriaged\n  static const EventStreamProvider<Event> timeUpdateEvent = const EventStreamProvider<Event>('timeupdate');\n\n  @DomName('SVGElement.volumechangeEvent')\n  @DocsEditable()\n  @Experimental() // untriaged\n  static const EventStreamProvider<Event> volumeChangeEvent = const EventStreamProvider<Event>('volumechange');\n\n  @DomName('SVGElement.waitingEvent')\n  @DocsEditable()\n  @Experimental() // untriaged\n  static const EventStreamProvider<Event> waitingEvent = const EventStreamProvider<Event>('waiting');\n  /**\n   * Constructor instantiated by the DOM when a custom element has been created.\n   *\n   * This can only be called by subclasses from their created constructor.\n   */\n  SvgElement.created() : super.created();\n\n  // Shadowing definition.\n  AnimatedString get _svgClassName => JS(\"AnimatedString\", \"#.className\", this);\n\n  @JSName('ownerSVGElement')\n  @DomName('SVGElement.ownerSVGElement')\n  @DocsEditable()\n  final SvgSvgElement ownerSvgElement;\n\n  // Use implementation from Element.\n  // final CssStyleDeclaration style;\n\n  @DomName('SVGElement.viewportElement')\n  @DocsEditable()\n  final SvgElement viewportElement;\n\n  @DomName('SVGElement.xmlbase')\n  @DocsEditable()\n  String xmlbase;\n\n  @DomName('SVGElement.xmllang')\n  @DocsEditable()\n  @Experimental() // untriaged\n  String xmllang;\n\n  @DomName('SVGElement.xmlspace')\n  @DocsEditable()\n  @Experimental() // untriaged\n  String xmlspace;\n\n  @DomName('SVGElement.onabort')\n  @DocsEditable()\n  @Experimental() // untriaged\n  ElementStream<Event> get onAbort => abortEvent.forElement(this);\n\n  @DomName('SVGElement.onblur')\n  @DocsEditable()\n  @Experimental() // untriaged\n  ElementStream<Event> get onBlur => blurEvent.forElement(this);\n\n  @DomName('SVGElement.oncanplay')\n  @DocsEditable()\n  @Experimental() // untriaged\n  ElementStream<Event> get onCanPlay => canPlayEvent.forElement(this);\n\n  @DomName('SVGElement.oncanplaythrough')\n  @DocsEditable()\n  @Experimental() // untriaged\n  ElementStream<Event> get onCanPlayThrough => canPlayThroughEvent.forElement(this);\n\n  @DomName('SVGElement.onchange')\n  @DocsEditable()\n  @Experimental() // untriaged\n  ElementStream<Event> get onChange => changeEvent.forElement(this);\n\n  @DomName('SVGElement.onclick')\n  @DocsEditable()\n  @Experimental() // untriaged\n  ElementStream<MouseEvent> get onClick => clickEvent.forElement(this);\n\n  @DomName('SVGElement.oncontextmenu')\n  @DocsEditable()\n  @Experimental() // untriaged\n  ElementStream<MouseEvent> get onContextMenu => contextMenuEvent.forElement(this);\n\n  @DomName('SVGElement.ondblclick')\n  @DocsEditable()\n  @Experimental() // untriaged\n  ElementStream<Event> get onDoubleClick => doubleClickEvent.forElement(this);\n\n  @DomName('SVGElement.ondrag')\n  @DocsEditable()\n  @Experimental() // untriaged\n  ElementStream<MouseEvent> get onDrag => dragEvent.forElement(this);\n\n  @DomName('SVGElement.ondragend')\n  @DocsEditable()\n  @Experimental() // untriaged\n  ElementStream<MouseEvent> get onDragEnd => dragEndEvent.forElement(this);\n\n  @DomName('SVGElement.ondragenter')\n  @DocsEditable()\n  @Experimental() // untriaged\n  ElementStream<MouseEvent> get onDragEnter => dragEnterEvent.forElement(this);\n\n  @DomName('SVGElement.ondragleave')\n  @DocsEditable()\n  @Experimental() // untriaged\n  ElementStream<MouseEvent> get onDragLeave => dragLeaveEvent.forElement(this);\n\n  @DomName('SVGElement.ondragover')\n  @DocsEditable()\n  @Experimental() // untriaged\n  ElementStream<MouseEvent> get onDragOver => dragOverEvent.forElement(this);\n\n  @DomName('SVGElement.ondragstart')\n  @DocsEditable()\n  @Experimental() // untriaged\n  ElementStream<MouseEvent> get onDragStart => dragStartEvent.forElement(this);\n\n  @DomName('SVGElement.ondrop')\n  @DocsEditable()\n  @Experimental() // untriaged\n  ElementStream<MouseEvent> get onDrop => dropEvent.forElement(this);\n\n  @DomName('SVGElement.ondurationchange')\n  @DocsEditable()\n  @Experimental() // untriaged\n  ElementStream<Event> get onDurationChange => durationChangeEvent.forElement(this);\n\n  @DomName('SVGElement.onemptied')\n  @DocsEditable()\n  @Experimental() // untriaged\n  ElementStream<Event> get onEmptied => emptiedEvent.forElement(this);\n\n  @DomName('SVGElement.onended')\n  @DocsEditable()\n  @Experimental() // untriaged\n  ElementStream<Event> get onEnded => endedEvent.forElement(this);\n\n  @DomName('SVGElement.onerror')\n  @DocsEditable()\n  @Experimental() // untriaged\n  ElementStream<Event> get onError => errorEvent.forElement(this);\n\n  @DomName('SVGElement.onfocus')\n  @DocsEditable()\n  @Experimental() // untriaged\n  ElementStream<Event> get onFocus => focusEvent.forElement(this);\n\n  @DomName('SVGElement.oninput')\n  @DocsEditable()\n  @Experimental() // untriaged\n  ElementStream<Event> get onInput => inputEvent.forElement(this);\n\n  @DomName('SVGElement.oninvalid')\n  @DocsEditable()\n  @Experimental() // untriaged\n  ElementStream<Event> get onInvalid => invalidEvent.forElement(this);\n\n  @DomName('SVGElement.onkeydown')\n  @DocsEditable()\n  @Experimental() // untriaged\n  ElementStream<KeyboardEvent> get onKeyDown => keyDownEvent.forElement(this);\n\n  @DomName('SVGElement.onkeypress')\n  @DocsEditable()\n  @Experimental() // untriaged\n  ElementStream<KeyboardEvent> get onKeyPress => keyPressEvent.forElement(this);\n\n  @DomName('SVGElement.onkeyup')\n  @DocsEditable()\n  @Experimental() // untriaged\n  ElementStream<KeyboardEvent> get onKeyUp => keyUpEvent.forElement(this);\n\n  @DomName('SVGElement.onload')\n  @DocsEditable()\n  @Experimental() // untriaged\n  ElementStream<Event> get onLoad => loadEvent.forElement(this);\n\n  @DomName('SVGElement.onloadeddata')\n  @DocsEditable()\n  @Experimental() // untriaged\n  ElementStream<Event> get onLoadedData => loadedDataEvent.forElement(this);\n\n  @DomName('SVGElement.onloadedmetadata')\n  @DocsEditable()\n  @Experimental() // untriaged\n  ElementStream<Event> get onLoadedMetadata => loadedMetadataEvent.forElement(this);\n\n  @DomName('SVGElement.onmousedown')\n  @DocsEditable()\n  @Experimental() // untriaged\n  ElementStream<MouseEvent> get onMouseDown => mouseDownEvent.forElement(this);\n\n  @DomName('SVGElement.onmouseenter')\n  @DocsEditable()\n  @Experimental() // untriaged\n  ElementStream<MouseEvent> get onMouseEnter => mouseEnterEvent.forElement(this);\n\n  @DomName('SVGElement.onmouseleave')\n  @DocsEditable()\n  @Experimental() // untriaged\n  ElementStream<MouseEvent> get onMouseLeave => mouseLeaveEvent.forElement(this);\n\n  @DomName('SVGElement.onmousemove')\n  @DocsEditable()\n  @Experimental() // untriaged\n  ElementStream<MouseEvent> get onMouseMove => mouseMoveEvent.forElement(this);\n\n  @DomName('SVGElement.onmouseout')\n  @DocsEditable()\n  @Experimental() // untriaged\n  ElementStream<MouseEvent> get onMouseOut => mouseOutEvent.forElement(this);\n\n  @DomName('SVGElement.onmouseover')\n  @DocsEditable()\n  @Experimental() // untriaged\n  ElementStream<MouseEvent> get onMouseOver => mouseOverEvent.forElement(this);\n\n  @DomName('SVGElement.onmouseup')\n  @DocsEditable()\n  @Experimental() // untriaged\n  ElementStream<MouseEvent> get onMouseUp => mouseUpEvent.forElement(this);\n\n  @DomName('SVGElement.onmousewheel')\n  @DocsEditable()\n  @Experimental() // untriaged\n  ElementStream<WheelEvent> get onMouseWheel => mouseWheelEvent.forElement(this);\n\n  @DomName('SVGElement.onpause')\n  @DocsEditable()\n  @Experimental() // untriaged\n  ElementStream<Event> get onPause => pauseEvent.forElement(this);\n\n  @DomName('SVGElement.onplay')\n  @DocsEditable()\n  @Experimental() // untriaged\n  ElementStream<Event> get onPlay => playEvent.forElement(this);\n\n  @DomName('SVGElement.onplaying')\n  @DocsEditable()\n  @Experimental() // untriaged\n  ElementStream<Event> get onPlaying => playingEvent.forElement(this);\n\n  @DomName('SVGElement.onratechange')\n  @DocsEditable()\n  @Experimental() // untriaged\n  ElementStream<Event> get onRateChange => rateChangeEvent.forElement(this);\n\n  @DomName('SVGElement.onreset')\n  @DocsEditable()\n  @Experimental() // untriaged\n  ElementStream<Event> get onReset => resetEvent.forElement(this);\n\n  @DomName('SVGElement.onresize')\n  @DocsEditable()\n  @Experimental() // untriaged\n  ElementStream<Event> get onResize => resizeEvent.forElement(this);\n\n  @DomName('SVGElement.onscroll')\n  @DocsEditable()\n  @Experimental() // untriaged\n  ElementStream<Event> get onScroll => scrollEvent.forElement(this);\n\n  @DomName('SVGElement.onseeked')\n  @DocsEditable()\n  @Experimental() // untriaged\n  ElementStream<Event> get onSeeked => seekedEvent.forElement(this);\n\n  @DomName('SVGElement.onseeking')\n  @DocsEditable()\n  @Experimental() // untriaged\n  ElementStream<Event> get onSeeking => seekingEvent.forElement(this);\n\n  @DomName('SVGElement.onselect')\n  @DocsEditable()\n  @Experimental() // untriaged\n  ElementStream<Event> get onSelect => selectEvent.forElement(this);\n\n  @DomName('SVGElement.onstalled')\n  @DocsEditable()\n  @Experimental() // untriaged\n  ElementStream<Event> get onStalled => stalledEvent.forElement(this);\n\n  @DomName('SVGElement.onsubmit')\n  @DocsEditable()\n  @Experimental() // untriaged\n  ElementStream<Event> get onSubmit => submitEvent.forElement(this);\n\n  @DomName('SVGElement.onsuspend')\n  @DocsEditable()\n  @Experimental() // untriaged\n  ElementStream<Event> get onSuspend => suspendEvent.forElement(this);\n\n  @DomName('SVGElement.ontimeupdate')\n  @DocsEditable()\n  @Experimental() // untriaged\n  ElementStream<Event> get onTimeUpdate => timeUpdateEvent.forElement(this);\n\n  @DomName('SVGElement.onvolumechange')\n  @DocsEditable()\n  @Experimental() // untriaged\n  ElementStream<Event> get onVolumeChange => volumeChangeEvent.forElement(this);\n\n  @DomName('SVGElement.onwaiting')\n  @DocsEditable()\n  @Experimental() // untriaged\n  ElementStream<Event> get onWaiting => waitingEvent.forElement(this);\n\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DomName('SVGSVGElement')\n@Unstable()\n@Native(\"SVGSVGElement\")\nclass SvgSvgElement extends GraphicsElement implements FitToViewBox, ZoomAndPan {\n  factory SvgSvgElement() {\n    final el = new SvgElement.tag(\"svg\");\n    // The SVG spec requires the version attribute to match the spec version\n    el.attributes['version'] = \"1.1\";\n    return el;\n  }\n\n  // To suppress missing implicit constructor warnings.\n  factory SvgSvgElement._() { throw new UnsupportedError(\"Not supported\"); }\n  /**\n   * Constructor instantiated by the DOM when a custom element has been created.\n   *\n   * This can only be called by subclasses from their created constructor.\n   */\n  SvgSvgElement.created() : super.created();\n\n  @DomName('SVGSVGElement.currentScale')\n  @DocsEditable()\n  num currentScale;\n\n  @DomName('SVGSVGElement.currentTranslate')\n  @DocsEditable()\n  final Point currentTranslate;\n\n  @DomName('SVGSVGElement.currentView')\n  @DocsEditable()\n  final ViewSpec currentView;\n\n  @DomName('SVGSVGElement.height')\n  @DocsEditable()\n  final AnimatedLength height;\n\n  @DomName('SVGSVGElement.pixelUnitToMillimeterX')\n  @DocsEditable()\n  final double pixelUnitToMillimeterX;\n\n  @DomName('SVGSVGElement.pixelUnitToMillimeterY')\n  @DocsEditable()\n  final double pixelUnitToMillimeterY;\n\n  @DomName('SVGSVGElement.screenPixelToMillimeterX')\n  @DocsEditable()\n  final double screenPixelToMillimeterX;\n\n  @DomName('SVGSVGElement.screenPixelToMillimeterY')\n  @DocsEditable()\n  final double screenPixelToMillimeterY;\n\n  @DomName('SVGSVGElement.useCurrentView')\n  @DocsEditable()\n  final bool useCurrentView;\n\n  @DomName('SVGSVGElement.viewport')\n  @DocsEditable()\n  final Rect viewport;\n\n  @DomName('SVGSVGElement.width')\n  @DocsEditable()\n  final AnimatedLength width;\n\n  @DomName('SVGSVGElement.x')\n  @DocsEditable()\n  final AnimatedLength x;\n\n  @DomName('SVGSVGElement.y')\n  @DocsEditable()\n  final AnimatedLength y;\n\n  @DomName('SVGSVGElement.animationsPaused')\n  @DocsEditable()\n  bool animationsPaused() native;\n\n  @DomName('SVGSVGElement.checkEnclosure')\n  @DocsEditable()\n  bool checkEnclosure(SvgElement element, Rect rect) native;\n\n  @DomName('SVGSVGElement.checkIntersection')\n  @DocsEditable()\n  bool checkIntersection(SvgElement element, Rect rect) native;\n\n  @JSName('createSVGAngle')\n  @DomName('SVGSVGElement.createSVGAngle')\n  @DocsEditable()\n  Angle createSvgAngle() native;\n\n  @JSName('createSVGLength')\n  @DomName('SVGSVGElement.createSVGLength')\n  @DocsEditable()\n  Length createSvgLength() native;\n\n  @JSName('createSVGMatrix')\n  @DomName('SVGSVGElement.createSVGMatrix')\n  @DocsEditable()\n  Matrix createSvgMatrix() native;\n\n  @JSName('createSVGNumber')\n  @DomName('SVGSVGElement.createSVGNumber')\n  @DocsEditable()\n  Number createSvgNumber() native;\n\n  @JSName('createSVGPoint')\n  @DomName('SVGSVGElement.createSVGPoint')\n  @DocsEditable()\n  Point createSvgPoint() native;\n\n  @JSName('createSVGRect')\n  @DomName('SVGSVGElement.createSVGRect')\n  @DocsEditable()\n  Rect createSvgRect() native;\n\n  @JSName('createSVGTransform')\n  @DomName('SVGSVGElement.createSVGTransform')\n  @DocsEditable()\n  Transform createSvgTransform() native;\n\n  @JSName('createSVGTransformFromMatrix')\n  @DomName('SVGSVGElement.createSVGTransformFromMatrix')\n  @DocsEditable()\n  Transform createSvgTransformFromMatrix(Matrix matrix) native;\n\n  @DomName('SVGSVGElement.deselectAll')\n  @DocsEditable()\n  void deselectAll() native;\n\n  @DomName('SVGSVGElement.forceRedraw')\n  @DocsEditable()\n  void forceRedraw() native;\n\n  @DomName('SVGSVGElement.getCurrentTime')\n  @DocsEditable()\n  double getCurrentTime() native;\n\n  @DomName('SVGSVGElement.getElementById')\n  @DocsEditable()\n  Element getElementById(String elementId) native;\n\n  @DomName('SVGSVGElement.getEnclosureList')\n  @DocsEditable()\n  @Returns('NodeList')\n  @Creates('NodeList')\n  List<Node> getEnclosureList(Rect rect, SvgElement referenceElement) native;\n\n  @DomName('SVGSVGElement.getIntersectionList')\n  @DocsEditable()\n  @Returns('NodeList')\n  @Creates('NodeList')\n  List<Node> getIntersectionList(Rect rect, SvgElement referenceElement) native;\n\n  @DomName('SVGSVGElement.pauseAnimations')\n  @DocsEditable()\n  void pauseAnimations() native;\n\n  @DomName('SVGSVGElement.setCurrentTime')\n  @DocsEditable()\n  void setCurrentTime(num seconds) native;\n\n  @DomName('SVGSVGElement.suspendRedraw')\n  @DocsEditable()\n  int suspendRedraw(int maxWaitMilliseconds) native;\n\n  @DomName('SVGSVGElement.unpauseAnimations')\n  @DocsEditable()\n  void unpauseAnimations() native;\n\n  @DomName('SVGSVGElement.unsuspendRedraw')\n  @DocsEditable()\n  void unsuspendRedraw(int suspendHandleId) native;\n\n  @DomName('SVGSVGElement.unsuspendRedrawAll')\n  @DocsEditable()\n  void unsuspendRedrawAll() native;\n\n  // From SVGFitToViewBox\n\n  @DomName('SVGSVGElement.preserveAspectRatio')\n  @DocsEditable()\n  final AnimatedPreserveAspectRatio preserveAspectRatio;\n\n  @DomName('SVGSVGElement.viewBox')\n  @DocsEditable()\n  final AnimatedRect viewBox;\n\n  // From SVGZoomAndPan\n\n  @DomName('SVGSVGElement.zoomAndPan')\n  @DocsEditable()\n  int zoomAndPan;\n\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('SVGSwitchElement')\n@Unstable()\n@Native(\"SVGSwitchElement\")\nclass SwitchElement extends GraphicsElement {\n  // To suppress missing implicit constructor warnings.\n  factory SwitchElement._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('SVGSwitchElement.SVGSwitchElement')\n  @DocsEditable()\n  factory SwitchElement() => _SvgElementFactoryProvider.createSvgElement_tag(\"switch\");\n  /**\n   * Constructor instantiated by the DOM when a custom element has been created.\n   *\n   * This can only be called by subclasses from their created constructor.\n   */\n  SwitchElement.created() : super.created();\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('SVGSymbolElement')\n@Unstable()\n@Native(\"SVGSymbolElement\")\nclass SymbolElement extends SvgElement implements FitToViewBox {\n  // To suppress missing implicit constructor warnings.\n  factory SymbolElement._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('SVGSymbolElement.SVGSymbolElement')\n  @DocsEditable()\n  factory SymbolElement() => _SvgElementFactoryProvider.createSvgElement_tag(\"symbol\");\n  /**\n   * Constructor instantiated by the DOM when a custom element has been created.\n   *\n   * This can only be called by subclasses from their created constructor.\n   */\n  SymbolElement.created() : super.created();\n\n  // From SVGFitToViewBox\n\n  @DomName('SVGSymbolElement.preserveAspectRatio')\n  @DocsEditable()\n  final AnimatedPreserveAspectRatio preserveAspectRatio;\n\n  @DomName('SVGSymbolElement.viewBox')\n  @DocsEditable()\n  final AnimatedRect viewBox;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('SVGTSpanElement')\n@Unstable()\n@Native(\"SVGTSpanElement\")\nclass TSpanElement extends TextPositioningElement {\n  // To suppress missing implicit constructor warnings.\n  factory TSpanElement._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('SVGTSpanElement.SVGTSpanElement')\n  @DocsEditable()\n  factory TSpanElement() => _SvgElementFactoryProvider.createSvgElement_tag(\"tspan\");\n  /**\n   * Constructor instantiated by the DOM when a custom element has been created.\n   *\n   * This can only be called by subclasses from their created constructor.\n   */\n  TSpanElement.created() : super.created();\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('SVGTests')\n@Unstable()\nabstract class Tests extends Interceptor {\n  // To suppress missing implicit constructor warnings.\n  factory Tests._() { throw new UnsupportedError(\"Not supported\"); }\n\n  final StringList requiredExtensions;\n\n  final StringList requiredFeatures;\n\n  final StringList systemLanguage;\n\n  bool hasExtension(String extension);\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('SVGTextContentElement')\n@Unstable()\n@Native(\"SVGTextContentElement\")\nclass TextContentElement extends GraphicsElement {\n  // To suppress missing implicit constructor warnings.\n  factory TextContentElement._() { throw new UnsupportedError(\"Not supported\"); }\n  /**\n   * Constructor instantiated by the DOM when a custom element has been created.\n   *\n   * This can only be called by subclasses from their created constructor.\n   */\n  TextContentElement.created() : super.created();\n\n  @DomName('SVGTextContentElement.LENGTHADJUST_SPACING')\n  @DocsEditable()\n  static const int LENGTHADJUST_SPACING = 1;\n\n  @DomName('SVGTextContentElement.LENGTHADJUST_SPACINGANDGLYPHS')\n  @DocsEditable()\n  static const int LENGTHADJUST_SPACINGANDGLYPHS = 2;\n\n  @DomName('SVGTextContentElement.LENGTHADJUST_UNKNOWN')\n  @DocsEditable()\n  static const int LENGTHADJUST_UNKNOWN = 0;\n\n  @DomName('SVGTextContentElement.lengthAdjust')\n  @DocsEditable()\n  final AnimatedEnumeration lengthAdjust;\n\n  @DomName('SVGTextContentElement.textLength')\n  @DocsEditable()\n  final AnimatedLength textLength;\n\n  @DomName('SVGTextContentElement.getCharNumAtPosition')\n  @DocsEditable()\n  int getCharNumAtPosition(Point point) native;\n\n  @DomName('SVGTextContentElement.getComputedTextLength')\n  @DocsEditable()\n  double getComputedTextLength() native;\n\n  @DomName('SVGTextContentElement.getEndPositionOfChar')\n  @DocsEditable()\n  Point getEndPositionOfChar(int offset) native;\n\n  @DomName('SVGTextContentElement.getExtentOfChar')\n  @DocsEditable()\n  Rect getExtentOfChar(int offset) native;\n\n  @DomName('SVGTextContentElement.getNumberOfChars')\n  @DocsEditable()\n  int getNumberOfChars() native;\n\n  @DomName('SVGTextContentElement.getRotationOfChar')\n  @DocsEditable()\n  double getRotationOfChar(int offset) native;\n\n  @DomName('SVGTextContentElement.getStartPositionOfChar')\n  @DocsEditable()\n  Point getStartPositionOfChar(int offset) native;\n\n  @DomName('SVGTextContentElement.getSubStringLength')\n  @DocsEditable()\n  double getSubStringLength(int offset, int length) native;\n\n  @DomName('SVGTextContentElement.selectSubString')\n  @DocsEditable()\n  void selectSubString(int offset, int length) native;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('SVGTextElement')\n@Unstable()\n@Native(\"SVGTextElement\")\nclass TextElement extends TextPositioningElement {\n  // To suppress missing implicit constructor warnings.\n  factory TextElement._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('SVGTextElement.SVGTextElement')\n  @DocsEditable()\n  factory TextElement() => _SvgElementFactoryProvider.createSvgElement_tag(\"text\");\n  /**\n   * Constructor instantiated by the DOM when a custom element has been created.\n   *\n   * This can only be called by subclasses from their created constructor.\n   */\n  TextElement.created() : super.created();\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('SVGTextPathElement')\n@Unstable()\n@Native(\"SVGTextPathElement\")\nclass TextPathElement extends TextContentElement implements UriReference {\n  // To suppress missing implicit constructor warnings.\n  factory TextPathElement._() { throw new UnsupportedError(\"Not supported\"); }\n  /**\n   * Constructor instantiated by the DOM when a custom element has been created.\n   *\n   * This can only be called by subclasses from their created constructor.\n   */\n  TextPathElement.created() : super.created();\n\n  @DomName('SVGTextPathElement.TEXTPATH_METHODTYPE_ALIGN')\n  @DocsEditable()\n  static const int TEXTPATH_METHODTYPE_ALIGN = 1;\n\n  @DomName('SVGTextPathElement.TEXTPATH_METHODTYPE_STRETCH')\n  @DocsEditable()\n  static const int TEXTPATH_METHODTYPE_STRETCH = 2;\n\n  @DomName('SVGTextPathElement.TEXTPATH_METHODTYPE_UNKNOWN')\n  @DocsEditable()\n  static const int TEXTPATH_METHODTYPE_UNKNOWN = 0;\n\n  @DomName('SVGTextPathElement.TEXTPATH_SPACINGTYPE_AUTO')\n  @DocsEditable()\n  static const int TEXTPATH_SPACINGTYPE_AUTO = 1;\n\n  @DomName('SVGTextPathElement.TEXTPATH_SPACINGTYPE_EXACT')\n  @DocsEditable()\n  static const int TEXTPATH_SPACINGTYPE_EXACT = 2;\n\n  @DomName('SVGTextPathElement.TEXTPATH_SPACINGTYPE_UNKNOWN')\n  @DocsEditable()\n  static const int TEXTPATH_SPACINGTYPE_UNKNOWN = 0;\n\n  @DomName('SVGTextPathElement.method')\n  @DocsEditable()\n  final AnimatedEnumeration method;\n\n  @DomName('SVGTextPathElement.spacing')\n  @DocsEditable()\n  final AnimatedEnumeration spacing;\n\n  @DomName('SVGTextPathElement.startOffset')\n  @DocsEditable()\n  final AnimatedLength startOffset;\n\n  // From SVGURIReference\n\n  @DomName('SVGTextPathElement.href')\n  @DocsEditable()\n  final AnimatedString href;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('SVGTextPositioningElement')\n@Unstable()\n@Native(\"SVGTextPositioningElement\")\nclass TextPositioningElement extends TextContentElement {\n  // To suppress missing implicit constructor warnings.\n  factory TextPositioningElement._() { throw new UnsupportedError(\"Not supported\"); }\n  /**\n   * Constructor instantiated by the DOM when a custom element has been created.\n   *\n   * This can only be called by subclasses from their created constructor.\n   */\n  TextPositioningElement.created() : super.created();\n\n  @DomName('SVGTextPositioningElement.dx')\n  @DocsEditable()\n  final AnimatedLengthList dx;\n\n  @DomName('SVGTextPositioningElement.dy')\n  @DocsEditable()\n  final AnimatedLengthList dy;\n\n  @DomName('SVGTextPositioningElement.rotate')\n  @DocsEditable()\n  final AnimatedNumberList rotate;\n\n  @DomName('SVGTextPositioningElement.x')\n  @DocsEditable()\n  final AnimatedLengthList x;\n\n  @DomName('SVGTextPositioningElement.y')\n  @DocsEditable()\n  final AnimatedLengthList y;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('SVGTitleElement')\n@Unstable()\n@Native(\"SVGTitleElement\")\nclass TitleElement extends SvgElement {\n  // To suppress missing implicit constructor warnings.\n  factory TitleElement._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('SVGTitleElement.SVGTitleElement')\n  @DocsEditable()\n  factory TitleElement() => _SvgElementFactoryProvider.createSvgElement_tag(\"title\");\n  /**\n   * Constructor instantiated by the DOM when a custom element has been created.\n   *\n   * This can only be called by subclasses from their created constructor.\n   */\n  TitleElement.created() : super.created();\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('SVGTransform')\n@Unstable()\n@Native(\"SVGTransform\")\nclass Transform extends Interceptor {\n  // To suppress missing implicit constructor warnings.\n  factory Transform._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('SVGTransform.SVG_TRANSFORM_MATRIX')\n  @DocsEditable()\n  static const int SVG_TRANSFORM_MATRIX = 1;\n\n  @DomName('SVGTransform.SVG_TRANSFORM_ROTATE')\n  @DocsEditable()\n  static const int SVG_TRANSFORM_ROTATE = 4;\n\n  @DomName('SVGTransform.SVG_TRANSFORM_SCALE')\n  @DocsEditable()\n  static const int SVG_TRANSFORM_SCALE = 3;\n\n  @DomName('SVGTransform.SVG_TRANSFORM_SKEWX')\n  @DocsEditable()\n  static const int SVG_TRANSFORM_SKEWX = 5;\n\n  @DomName('SVGTransform.SVG_TRANSFORM_SKEWY')\n  @DocsEditable()\n  static const int SVG_TRANSFORM_SKEWY = 6;\n\n  @DomName('SVGTransform.SVG_TRANSFORM_TRANSLATE')\n  @DocsEditable()\n  static const int SVG_TRANSFORM_TRANSLATE = 2;\n\n  @DomName('SVGTransform.SVG_TRANSFORM_UNKNOWN')\n  @DocsEditable()\n  static const int SVG_TRANSFORM_UNKNOWN = 0;\n\n  @DomName('SVGTransform.angle')\n  @DocsEditable()\n  final double angle;\n\n  @DomName('SVGTransform.matrix')\n  @DocsEditable()\n  final Matrix matrix;\n\n  @DomName('SVGTransform.type')\n  @DocsEditable()\n  final int type;\n\n  @DomName('SVGTransform.setMatrix')\n  @DocsEditable()\n  void setMatrix(Matrix matrix) native;\n\n  @DomName('SVGTransform.setRotate')\n  @DocsEditable()\n  void setRotate(num angle, num cx, num cy) native;\n\n  @DomName('SVGTransform.setScale')\n  @DocsEditable()\n  void setScale(num sx, num sy) native;\n\n  @DomName('SVGTransform.setSkewX')\n  @DocsEditable()\n  void setSkewX(num angle) native;\n\n  @DomName('SVGTransform.setSkewY')\n  @DocsEditable()\n  void setSkewY(num angle) native;\n\n  @DomName('SVGTransform.setTranslate')\n  @DocsEditable()\n  void setTranslate(num tx, num ty) native;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('SVGTransformList')\n@Unstable()\n@Native(\"SVGTransformList\")\nclass TransformList extends Interceptor with ListMixin<Transform>, ImmutableListMixin<Transform> implements List<Transform> {\n  // To suppress missing implicit constructor warnings.\n  factory TransformList._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('SVGTransformList.numberOfItems')\n  @DocsEditable()\n  final int numberOfItems;\n\n  Transform operator[](int index) {\n    if (JS(\"bool\", \"# >>> 0 !== # || # >= #\", index,\n        index, index, length))\n      throw new RangeError.range(index, 0, length);\n    return this.getItem(index);\n  }\n  void operator[]=(int index, Transform value) {\n    throw new UnsupportedError(\"Cannot assign element of immutable List.\");\n  }\n  // -- start List<Transform> mixins.\n  // Transform is the element type.\n\n  // SVG Collections expose numberOfItems rather than length.\n  int get length => numberOfItems;\n\n  void set length(int value) {\n    throw new UnsupportedError(\"Cannot resize immutable List.\");\n  }\n\n  Transform get first {\n    if (this.length > 0) {\n      return JS('Transform', '#[0]', this);\n    }\n    throw new StateError(\"No elements\");\n  }\n\n  Transform get last {\n    int len = this.length;\n    if (len > 0) {\n      return JS('Transform', '#[#]', this, len - 1);\n    }\n    throw new StateError(\"No elements\");\n  }\n\n  Transform get single {\n    int len = this.length;\n    if (len == 1) {\n      return JS('Transform', '#[0]', this);\n    }\n    if (len == 0) throw new StateError(\"No elements\");\n    throw new StateError(\"More than one element\");\n  }\n\n  Transform elementAt(int index) => this[index];\n  // -- end List<Transform> mixins.\n\n  @DomName('SVGTransformList.appendItem')\n  @DocsEditable()\n  Transform appendItem(Transform item) native;\n\n  @DomName('SVGTransformList.clear')\n  @DocsEditable()\n  void clear() native;\n\n  @DomName('SVGTransformList.consolidate')\n  @DocsEditable()\n  Transform consolidate() native;\n\n  @JSName('createSVGTransformFromMatrix')\n  @DomName('SVGTransformList.createSVGTransformFromMatrix')\n  @DocsEditable()\n  Transform createSvgTransformFromMatrix(Matrix matrix) native;\n\n  @DomName('SVGTransformList.getItem')\n  @DocsEditable()\n  Transform getItem(int index) native;\n\n  @DomName('SVGTransformList.initialize')\n  @DocsEditable()\n  Transform initialize(Transform item) native;\n\n  @DomName('SVGTransformList.insertItemBefore')\n  @DocsEditable()\n  Transform insertItemBefore(Transform item, int index) native;\n\n  @DomName('SVGTransformList.removeItem')\n  @DocsEditable()\n  Transform removeItem(int index) native;\n\n  @DomName('SVGTransformList.replaceItem')\n  @DocsEditable()\n  Transform replaceItem(Transform item, int index) native;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('SVGUnitTypes')\n@Unstable()\n@Native(\"SVGUnitTypes\")\nclass UnitTypes extends Interceptor {\n  // To suppress missing implicit constructor warnings.\n  factory UnitTypes._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('SVGUnitTypes.SVG_UNIT_TYPE_OBJECTBOUNDINGBOX')\n  @DocsEditable()\n  static const int SVG_UNIT_TYPE_OBJECTBOUNDINGBOX = 2;\n\n  @DomName('SVGUnitTypes.SVG_UNIT_TYPE_UNKNOWN')\n  @DocsEditable()\n  static const int SVG_UNIT_TYPE_UNKNOWN = 0;\n\n  @DomName('SVGUnitTypes.SVG_UNIT_TYPE_USERSPACEONUSE')\n  @DocsEditable()\n  static const int SVG_UNIT_TYPE_USERSPACEONUSE = 1;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('SVGURIReference')\n@Unstable()\nabstract class UriReference extends Interceptor {\n  // To suppress missing implicit constructor warnings.\n  factory UriReference._() { throw new UnsupportedError(\"Not supported\"); }\n\n  final AnimatedString href;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('SVGUseElement')\n@Unstable()\n@Native(\"SVGUseElement\")\nclass UseElement extends GraphicsElement implements UriReference, Tests {\n  // To suppress missing implicit constructor warnings.\n  factory UseElement._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('SVGUseElement.SVGUseElement')\n  @DocsEditable()\n  factory UseElement() => _SvgElementFactoryProvider.createSvgElement_tag(\"use\");\n  /**\n   * Constructor instantiated by the DOM when a custom element has been created.\n   *\n   * This can only be called by subclasses from their created constructor.\n   */\n  UseElement.created() : super.created();\n\n  @DomName('SVGUseElement.animatedInstanceRoot')\n  @DocsEditable()\n  final ElementInstance animatedInstanceRoot;\n\n  @DomName('SVGUseElement.height')\n  @DocsEditable()\n  final AnimatedLength height;\n\n  @DomName('SVGUseElement.instanceRoot')\n  @DocsEditable()\n  final ElementInstance instanceRoot;\n\n  @DomName('SVGUseElement.width')\n  @DocsEditable()\n  final AnimatedLength width;\n\n  @DomName('SVGUseElement.x')\n  @DocsEditable()\n  final AnimatedLength x;\n\n  @DomName('SVGUseElement.y')\n  @DocsEditable()\n  final AnimatedLength y;\n\n  // From SVGTests\n\n  @DomName('SVGUseElement.requiredExtensions')\n  @DocsEditable()\n  final StringList requiredExtensions;\n\n  @DomName('SVGUseElement.requiredFeatures')\n  @DocsEditable()\n  final StringList requiredFeatures;\n\n  @DomName('SVGUseElement.systemLanguage')\n  @DocsEditable()\n  final StringList systemLanguage;\n\n  @DomName('SVGUseElement.hasExtension')\n  @DocsEditable()\n  bool hasExtension(String extension) native;\n\n  // From SVGURIReference\n\n  @DomName('SVGUseElement.href')\n  @DocsEditable()\n  final AnimatedString href;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('SVGViewElement')\n@Unstable()\n@Native(\"SVGViewElement\")\nclass ViewElement extends SvgElement implements FitToViewBox, ZoomAndPan {\n  // To suppress missing implicit constructor warnings.\n  factory ViewElement._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('SVGViewElement.SVGViewElement')\n  @DocsEditable()\n  factory ViewElement() => _SvgElementFactoryProvider.createSvgElement_tag(\"view\");\n  /**\n   * Constructor instantiated by the DOM when a custom element has been created.\n   *\n   * This can only be called by subclasses from their created constructor.\n   */\n  ViewElement.created() : super.created();\n\n  @DomName('SVGViewElement.viewTarget')\n  @DocsEditable()\n  final StringList viewTarget;\n\n  // From SVGFitToViewBox\n\n  @DomName('SVGViewElement.preserveAspectRatio')\n  @DocsEditable()\n  final AnimatedPreserveAspectRatio preserveAspectRatio;\n\n  @DomName('SVGViewElement.viewBox')\n  @DocsEditable()\n  final AnimatedRect viewBox;\n\n  // From SVGZoomAndPan\n\n  @DomName('SVGViewElement.zoomAndPan')\n  @DocsEditable()\n  int zoomAndPan;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('SVGViewSpec')\n@Unstable()\n@Native(\"SVGViewSpec\")\nclass ViewSpec extends Interceptor implements FitToViewBox, ZoomAndPan {\n  // To suppress missing implicit constructor warnings.\n  factory ViewSpec._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('SVGViewSpec.preserveAspectRatioString')\n  @DocsEditable()\n  final String preserveAspectRatioString;\n\n  @DomName('SVGViewSpec.transform')\n  @DocsEditable()\n  final TransformList transform;\n\n  @DomName('SVGViewSpec.transformString')\n  @DocsEditable()\n  final String transformString;\n\n  @DomName('SVGViewSpec.viewBoxString')\n  @DocsEditable()\n  final String viewBoxString;\n\n  @DomName('SVGViewSpec.viewTarget')\n  @DocsEditable()\n  final SvgElement viewTarget;\n\n  @DomName('SVGViewSpec.viewTargetString')\n  @DocsEditable()\n  final String viewTargetString;\n\n  // From SVGFitToViewBox\n\n  @DomName('SVGViewSpec.preserveAspectRatio')\n  @DocsEditable()\n  @Experimental() // nonstandard\n  final AnimatedPreserveAspectRatio preserveAspectRatio;\n\n  @DomName('SVGViewSpec.viewBox')\n  @DocsEditable()\n  @Experimental() // nonstandard\n  final AnimatedRect viewBox;\n\n  // From SVGZoomAndPan\n\n  @DomName('SVGViewSpec.zoomAndPan')\n  @DocsEditable()\n  @Experimental() // nonstandard\n  int zoomAndPan;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('SVGZoomAndPan')\n@Unstable()\nabstract class ZoomAndPan extends Interceptor {\n  // To suppress missing implicit constructor warnings.\n  factory ZoomAndPan._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('SVGZoomAndPan.SVG_ZOOMANDPAN_DISABLE')\n  @DocsEditable()\n  static const int SVG_ZOOMANDPAN_DISABLE = 1;\n\n  @DomName('SVGZoomAndPan.SVG_ZOOMANDPAN_MAGNIFY')\n  @DocsEditable()\n  static const int SVG_ZOOMANDPAN_MAGNIFY = 2;\n\n  @DomName('SVGZoomAndPan.SVG_ZOOMANDPAN_UNKNOWN')\n  @DocsEditable()\n  static const int SVG_ZOOMANDPAN_UNKNOWN = 0;\n\n  int zoomAndPan;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('SVGZoomEvent')\n@Unstable()\n@Native(\"SVGZoomEvent\")\nclass ZoomEvent extends UIEvent {\n  // To suppress missing implicit constructor warnings.\n  factory ZoomEvent._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('SVGZoomEvent.newScale')\n  @DocsEditable()\n  final double newScale;\n\n  @DomName('SVGZoomEvent.newTranslate')\n  @DocsEditable()\n  final Point newTranslate;\n\n  @DomName('SVGZoomEvent.previousScale')\n  @DocsEditable()\n  final double previousScale;\n\n  @DomName('SVGZoomEvent.previousTranslate')\n  @DocsEditable()\n  final Point previousTranslate;\n\n  @DomName('SVGZoomEvent.zoomRectScreen')\n  @DocsEditable()\n  final Rect zoomRectScreen;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('SVGElementInstanceList')\n@Unstable()\n@Native(\"SVGElementInstanceList\")\nclass _ElementInstanceList extends Interceptor with ListMixin<ElementInstance>, ImmutableListMixin<ElementInstance> implements List<ElementInstance> {\n  // To suppress missing implicit constructor warnings.\n  factory _ElementInstanceList._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('SVGElementInstanceList.length')\n  @DocsEditable()\n  int get length => JS(\"int\", \"#.length\", this);\n\n  ElementInstance operator[](int index) {\n    if (JS(\"bool\", \"# >>> 0 !== # || # >= #\", index,\n        index, index, length))\n      throw new RangeError.range(index, 0, length);\n    return this.item(index);\n  }\n  void operator[]=(int index, ElementInstance value) {\n    throw new UnsupportedError(\"Cannot assign element of immutable List.\");\n  }\n  // -- start List<ElementInstance> mixins.\n  // ElementInstance is the element type.\n\n\n  void set length(int value) {\n    throw new UnsupportedError(\"Cannot resize immutable List.\");\n  }\n\n  ElementInstance get first {\n    if (this.length > 0) {\n      return JS('ElementInstance', '#[0]', this);\n    }\n    throw new StateError(\"No elements\");\n  }\n\n  ElementInstance get last {\n    int len = this.length;\n    if (len > 0) {\n      return JS('ElementInstance', '#[#]', this, len - 1);\n    }\n    throw new StateError(\"No elements\");\n  }\n\n  ElementInstance get single {\n    int len = this.length;\n    if (len == 1) {\n      return JS('ElementInstance', '#[0]', this);\n    }\n    if (len == 0) throw new StateError(\"No elements\");\n    throw new StateError(\"More than one element\");\n  }\n\n  ElementInstance elementAt(int index) => this[index];\n  // -- end List<ElementInstance> mixins.\n\n  @DomName('SVGElementInstanceList.item')\n  @DocsEditable()\n  ElementInstance item(int index) native;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('SVGGradientElement')\n@Unstable()\n@Native(\"SVGGradientElement\")\nclass _GradientElement extends SvgElement implements UriReference {\n  // To suppress missing implicit constructor warnings.\n  factory _GradientElement._() { throw new UnsupportedError(\"Not supported\"); }\n  /**\n   * Constructor instantiated by the DOM when a custom element has been created.\n   *\n   * This can only be called by subclasses from their created constructor.\n   */\n  _GradientElement.created() : super.created();\n\n  @DomName('SVGGradientElement.SVG_SPREADMETHOD_PAD')\n  @DocsEditable()\n  static const int SVG_SPREADMETHOD_PAD = 1;\n\n  @DomName('SVGGradientElement.SVG_SPREADMETHOD_REFLECT')\n  @DocsEditable()\n  static const int SVG_SPREADMETHOD_REFLECT = 2;\n\n  @DomName('SVGGradientElement.SVG_SPREADMETHOD_REPEAT')\n  @DocsEditable()\n  static const int SVG_SPREADMETHOD_REPEAT = 3;\n\n  @DomName('SVGGradientElement.SVG_SPREADMETHOD_UNKNOWN')\n  @DocsEditable()\n  static const int SVG_SPREADMETHOD_UNKNOWN = 0;\n\n  @DomName('SVGGradientElement.gradientTransform')\n  @DocsEditable()\n  final AnimatedTransformList gradientTransform;\n\n  @DomName('SVGGradientElement.gradientUnits')\n  @DocsEditable()\n  final AnimatedEnumeration gradientUnits;\n\n  @DomName('SVGGradientElement.spreadMethod')\n  @DocsEditable()\n  final AnimatedEnumeration spreadMethod;\n\n  // From SVGURIReference\n\n  @DomName('SVGGradientElement.href')\n  @DocsEditable()\n  final AnimatedString href;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('SVGAltGlyphDefElement')\n@Unstable()\n@Native(\"SVGAltGlyphDefElement\")\nabstract class _SVGAltGlyphDefElement extends SvgElement {\n  // To suppress missing implicit constructor warnings.\n  factory _SVGAltGlyphDefElement._() { throw new UnsupportedError(\"Not supported\"); }\n  /**\n   * Constructor instantiated by the DOM when a custom element has been created.\n   *\n   * This can only be called by subclasses from their created constructor.\n   */\n  _SVGAltGlyphDefElement.created() : super.created();\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('SVGAltGlyphItemElement')\n@Unstable()\n@Native(\"SVGAltGlyphItemElement\")\nabstract class _SVGAltGlyphItemElement extends SvgElement {\n  // To suppress missing implicit constructor warnings.\n  factory _SVGAltGlyphItemElement._() { throw new UnsupportedError(\"Not supported\"); }\n  /**\n   * Constructor instantiated by the DOM when a custom element has been created.\n   *\n   * This can only be called by subclasses from their created constructor.\n   */\n  _SVGAltGlyphItemElement.created() : super.created();\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('SVGComponentTransferFunctionElement')\n@Unstable()\n@Native(\"SVGComponentTransferFunctionElement\")\nabstract class _SVGComponentTransferFunctionElement extends SvgElement {\n  // To suppress missing implicit constructor warnings.\n  factory _SVGComponentTransferFunctionElement._() { throw new UnsupportedError(\"Not supported\"); }\n  /**\n   * Constructor instantiated by the DOM when a custom element has been created.\n   *\n   * This can only be called by subclasses from their created constructor.\n   */\n  _SVGComponentTransferFunctionElement.created() : super.created();\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('SVGCursorElement')\n@Unstable()\n@Native(\"SVGCursorElement\")\nabstract class _SVGCursorElement extends SvgElement implements UriReference, Tests {\n  // To suppress missing implicit constructor warnings.\n  factory _SVGCursorElement._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('SVGCursorElement.SVGCursorElement')\n  @DocsEditable()\n  factory _SVGCursorElement() => _SvgElementFactoryProvider.createSvgElement_tag(\"cursor\");\n  /**\n   * Constructor instantiated by the DOM when a custom element has been created.\n   *\n   * This can only be called by subclasses from their created constructor.\n   */\n  _SVGCursorElement.created() : super.created();\n\n  /// Checks if this type is supported on the current platform.\n  static bool get supported => SvgElement.isTagSupported('cursor') && (new SvgElement.tag('cursor') is _SVGCursorElement);\n\n  // From SVGTests\n\n  // From SVGURIReference\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('SVGFEDropShadowElement')\n@Experimental() // nonstandard\n@Native(\"SVGFEDropShadowElement\")\nabstract class _SVGFEDropShadowElement extends SvgElement implements FilterPrimitiveStandardAttributes {\n  // To suppress missing implicit constructor warnings.\n  factory _SVGFEDropShadowElement._() { throw new UnsupportedError(\"Not supported\"); }\n  /**\n   * Constructor instantiated by the DOM when a custom element has been created.\n   *\n   * This can only be called by subclasses from their created constructor.\n   */\n  _SVGFEDropShadowElement.created() : super.created();\n\n  // From SVGFilterPrimitiveStandardAttributes\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('SVGFontElement')\n@Unstable()\n@Native(\"SVGFontElement\")\nabstract class _SVGFontElement extends SvgElement {\n  // To suppress missing implicit constructor warnings.\n  factory _SVGFontElement._() { throw new UnsupportedError(\"Not supported\"); }\n  /**\n   * Constructor instantiated by the DOM when a custom element has been created.\n   *\n   * This can only be called by subclasses from their created constructor.\n   */\n  _SVGFontElement.created() : super.created();\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('SVGFontFaceElement')\n@Unstable()\n@Native(\"SVGFontFaceElement\")\nabstract class _SVGFontFaceElement extends SvgElement {\n  // To suppress missing implicit constructor warnings.\n  factory _SVGFontFaceElement._() { throw new UnsupportedError(\"Not supported\"); }\n  /**\n   * Constructor instantiated by the DOM when a custom element has been created.\n   *\n   * This can only be called by subclasses from their created constructor.\n   */\n  _SVGFontFaceElement.created() : super.created();\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('SVGFontFaceFormatElement')\n@Unstable()\n@Native(\"SVGFontFaceFormatElement\")\nabstract class _SVGFontFaceFormatElement extends SvgElement {\n  // To suppress missing implicit constructor warnings.\n  factory _SVGFontFaceFormatElement._() { throw new UnsupportedError(\"Not supported\"); }\n  /**\n   * Constructor instantiated by the DOM when a custom element has been created.\n   *\n   * This can only be called by subclasses from their created constructor.\n   */\n  _SVGFontFaceFormatElement.created() : super.created();\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('SVGFontFaceNameElement')\n@Unstable()\n@Native(\"SVGFontFaceNameElement\")\nabstract class _SVGFontFaceNameElement extends SvgElement {\n  // To suppress missing implicit constructor warnings.\n  factory _SVGFontFaceNameElement._() { throw new UnsupportedError(\"Not supported\"); }\n  /**\n   * Constructor instantiated by the DOM when a custom element has been created.\n   *\n   * This can only be called by subclasses from their created constructor.\n   */\n  _SVGFontFaceNameElement.created() : super.created();\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('SVGFontFaceSrcElement')\n@Unstable()\n@Native(\"SVGFontFaceSrcElement\")\nabstract class _SVGFontFaceSrcElement extends SvgElement {\n  // To suppress missing implicit constructor warnings.\n  factory _SVGFontFaceSrcElement._() { throw new UnsupportedError(\"Not supported\"); }\n  /**\n   * Constructor instantiated by the DOM when a custom element has been created.\n   *\n   * This can only be called by subclasses from their created constructor.\n   */\n  _SVGFontFaceSrcElement.created() : super.created();\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('SVGFontFaceUriElement')\n@Unstable()\n@Native(\"SVGFontFaceUriElement\")\nabstract class _SVGFontFaceUriElement extends SvgElement {\n  // To suppress missing implicit constructor warnings.\n  factory _SVGFontFaceUriElement._() { throw new UnsupportedError(\"Not supported\"); }\n  /**\n   * Constructor instantiated by the DOM when a custom element has been created.\n   *\n   * This can only be called by subclasses from their created constructor.\n   */\n  _SVGFontFaceUriElement.created() : super.created();\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('SVGGlyphElement')\n@Unstable()\n@Native(\"SVGGlyphElement\")\nabstract class _SVGGlyphElement extends SvgElement {\n  // To suppress missing implicit constructor warnings.\n  factory _SVGGlyphElement._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('SVGGlyphElement.SVGGlyphElement')\n  @DocsEditable()\n  factory _SVGGlyphElement() => _SvgElementFactoryProvider.createSvgElement_tag(\"glyph\");\n  /**\n   * Constructor instantiated by the DOM when a custom element has been created.\n   *\n   * This can only be called by subclasses from their created constructor.\n   */\n  _SVGGlyphElement.created() : super.created();\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('SVGGlyphRefElement')\n@Unstable()\n@Native(\"SVGGlyphRefElement\")\nabstract class _SVGGlyphRefElement extends SvgElement implements UriReference {\n  // To suppress missing implicit constructor warnings.\n  factory _SVGGlyphRefElement._() { throw new UnsupportedError(\"Not supported\"); }\n  /**\n   * Constructor instantiated by the DOM when a custom element has been created.\n   *\n   * This can only be called by subclasses from their created constructor.\n   */\n  _SVGGlyphRefElement.created() : super.created();\n\n  // From SVGURIReference\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('SVGHKernElement')\n@Unstable()\n@Native(\"SVGHKernElement\")\nabstract class _SVGHKernElement extends SvgElement {\n  // To suppress missing implicit constructor warnings.\n  factory _SVGHKernElement._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('SVGHKernElement.SVGHKernElement')\n  @DocsEditable()\n  factory _SVGHKernElement() => _SvgElementFactoryProvider.createSvgElement_tag(\"hkern\");\n  /**\n   * Constructor instantiated by the DOM when a custom element has been created.\n   *\n   * This can only be called by subclasses from their created constructor.\n   */\n  _SVGHKernElement.created() : super.created();\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('SVGMPathElement')\n@Native(\"SVGMPathElement\")\nabstract class _SVGMPathElement extends SvgElement implements UriReference {\n  // To suppress missing implicit constructor warnings.\n  factory _SVGMPathElement._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('SVGMPathElement.SVGMPathElement')\n  @DocsEditable()\n  factory _SVGMPathElement() => _SvgElementFactoryProvider.createSvgElement_tag(\"mpath\");\n  /**\n   * Constructor instantiated by the DOM when a custom element has been created.\n   *\n   * This can only be called by subclasses from their created constructor.\n   */\n  _SVGMPathElement.created() : super.created();\n\n  // From SVGURIReference\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('SVGMissingGlyphElement')\n@Unstable()\n@Native(\"SVGMissingGlyphElement\")\nabstract class _SVGMissingGlyphElement extends SvgElement {\n  // To suppress missing implicit constructor warnings.\n  factory _SVGMissingGlyphElement._() { throw new UnsupportedError(\"Not supported\"); }\n  /**\n   * Constructor instantiated by the DOM when a custom element has been created.\n   *\n   * This can only be called by subclasses from their created constructor.\n   */\n  _SVGMissingGlyphElement.created() : super.created();\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('SVGVKernElement')\n@Unstable()\n@Native(\"SVGVKernElement\")\nabstract class _SVGVKernElement extends SvgElement {\n  // To suppress missing implicit constructor warnings.\n  factory _SVGVKernElement._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('SVGVKernElement.SVGVKernElement')\n  @DocsEditable()\n  factory _SVGVKernElement() => _SvgElementFactoryProvider.createSvgElement_tag(\"vkern\");\n  /**\n   * Constructor instantiated by the DOM when a custom element has been created.\n   *\n   * This can only be called by subclasses from their created constructor.\n   */\n  _SVGVKernElement.created() : super.created();\n}\n\u0000","sdk:/sdk/lib/web_audio/dart2js/web_audio_dart2js.dart":"/**\n * High-fidelity audio programming in the browser.\n */\nlibrary dart.dom.web_audio;\n\nimport 'dart:async';\nimport 'dart:collection';\nimport 'dart:_internal' hide deprecated;\nimport 'dart:html';\nimport 'dart:html_common';\nimport 'dart:_native_typed_data';\nimport 'dart:typed_data';\nimport 'dart:_js_helper' show Creates, JSName, Native, Returns, convertDartClosureToJS;\nimport 'dart:_foreign_helper' show JS;\nimport 'dart:_interceptors' show Interceptor;\n// DO NOT EDIT - unless you are editing documentation as per:\n// https://code.google.com/p/dart/wiki/ContributingHTMLDocumentation\n// Auto-generated dart:audio library.\n\n\n\n\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('AnalyserNode')\n// https://dvcs.w3.org/hg/audio/raw-file/tip/webaudio/specification.html#AnalyserNode\n@Experimental()\n@Native(\"AnalyserNode,RealtimeAnalyserNode\")\nclass AnalyserNode extends AudioNode {\n  // To suppress missing implicit constructor warnings.\n  factory AnalyserNode._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('AnalyserNode.fftSize')\n  @DocsEditable()\n  int fftSize;\n\n  @DomName('AnalyserNode.frequencyBinCount')\n  @DocsEditable()\n  final int frequencyBinCount;\n\n  @DomName('AnalyserNode.maxDecibels')\n  @DocsEditable()\n  num maxDecibels;\n\n  @DomName('AnalyserNode.minDecibels')\n  @DocsEditable()\n  num minDecibels;\n\n  @DomName('AnalyserNode.smoothingTimeConstant')\n  @DocsEditable()\n  num smoothingTimeConstant;\n\n  @DomName('AnalyserNode.getByteFrequencyData')\n  @DocsEditable()\n  void getByteFrequencyData(Uint8List array) native;\n\n  @DomName('AnalyserNode.getByteTimeDomainData')\n  @DocsEditable()\n  void getByteTimeDomainData(Uint8List array) native;\n\n  @DomName('AnalyserNode.getFloatFrequencyData')\n  @DocsEditable()\n  void getFloatFrequencyData(Float32List array) native;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('AudioBuffer')\n// https://dvcs.w3.org/hg/audio/raw-file/tip/webaudio/specification.html#AudioBuffer-section\n@Experimental()\n@Native(\"AudioBuffer\")\nclass AudioBuffer extends Interceptor {\n  // To suppress missing implicit constructor warnings.\n  factory AudioBuffer._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('AudioBuffer.duration')\n  @DocsEditable()\n  final double duration;\n\n  @DomName('AudioBuffer.length')\n  @DocsEditable()\n  final int length;\n\n  @DomName('AudioBuffer.numberOfChannels')\n  @DocsEditable()\n  final int numberOfChannels;\n\n  @DomName('AudioBuffer.sampleRate')\n  @DocsEditable()\n  final double sampleRate;\n\n  @DomName('AudioBuffer.getChannelData')\n  @DocsEditable()\n  Float32List getChannelData(int channelIndex) native;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n// WARNING: Do not edit - generated code.\n\n\n@DomName('AudioBufferCallback')\n// https://dvcs.w3.org/hg/audio/raw-file/tip/webaudio/specification.html#AudioBuffer-section\n@Experimental()\ntypedef void AudioBufferCallback(AudioBuffer audioBuffer);\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DomName('AudioBufferSourceNode')\n@SupportedBrowser(SupportedBrowser.CHROME)\n@SupportedBrowser(SupportedBrowser.FIREFOX)\n@Experimental()\n// https://dvcs.w3.org/hg/audio/raw-file/tip/webaudio/specification.html#AudioBufferSourceNode-section\n@Native(\"AudioBufferSourceNode\")\nclass AudioBufferSourceNode extends AudioSourceNode {\n\n  // TODO(efortuna): Remove these methods when Chrome stable also uses start\n  // instead of noteOn.\n  void start(num when, [num grainOffset, num grainDuration]) {\n    if (JS('bool', '!!#.start', this)) {\n      if (grainDuration != null) {\n        JS('void', '#.start(#, #, #)', this, when, grainOffset, grainDuration);\n      } else if (grainOffset != null) {\n        JS('void', '#.start(#, #)', this, when, grainOffset);\n      } else {\n        JS('void', '#.start(#)', this, when);\n      }\n    } else {\n      if (grainDuration != null) {\n        JS('void', '#.noteOn(#, #, #)', this, when, grainOffset, grainDuration);\n      } else if (grainOffset != null) {\n        JS('void', '#.noteOn(#, #)', this, when, grainOffset);\n      } else {\n        JS('void', '#.noteOn(#)', this, when);\n      }\n    }\n  }\n\n  void stop(num when) {\n    if (JS('bool', '!!#.stop', this)) {\n      JS('void', '#.stop(#)', this, when);\n    } else {\n      JS('void', '#.noteOff(#)', this, when);\n    }\n  }\n  // To suppress missing implicit constructor warnings.\n  factory AudioBufferSourceNode._() { throw new UnsupportedError(\"Not supported\"); }\n\n  /**\n   * Static factory designed to expose `ended` events to event\n   * handlers that are not necessarily instances of [AudioBufferSourceNode].\n   *\n   * See [EventStreamProvider] for usage information.\n   */\n  @DomName('AudioBufferSourceNode.endedEvent')\n  @DocsEditable()\n  @Experimental() // untriaged\n  static const EventStreamProvider<Event> endedEvent = const EventStreamProvider<Event>('ended');\n\n  @DomName('AudioBufferSourceNode.FINISHED_STATE')\n  @DocsEditable()\n  static const int FINISHED_STATE = 3;\n\n  @DomName('AudioBufferSourceNode.PLAYING_STATE')\n  @DocsEditable()\n  static const int PLAYING_STATE = 2;\n\n  @DomName('AudioBufferSourceNode.SCHEDULED_STATE')\n  @DocsEditable()\n  static const int SCHEDULED_STATE = 1;\n\n  @DomName('AudioBufferSourceNode.UNSCHEDULED_STATE')\n  @DocsEditable()\n  static const int UNSCHEDULED_STATE = 0;\n\n  @DomName('AudioBufferSourceNode.buffer')\n  @DocsEditable()\n  AudioBuffer buffer;\n\n  @DomName('AudioBufferSourceNode.loop')\n  @DocsEditable()\n  bool loop;\n\n  @DomName('AudioBufferSourceNode.loopEnd')\n  @DocsEditable()\n  num loopEnd;\n\n  @DomName('AudioBufferSourceNode.loopStart')\n  @DocsEditable()\n  num loopStart;\n\n  @DomName('AudioBufferSourceNode.playbackRate')\n  @DocsEditable()\n  final AudioParam playbackRate;\n\n  @DomName('AudioBufferSourceNode.noteGrainOn')\n  @DocsEditable()\n  void noteGrainOn(num when, num grainOffset, num grainDuration) native;\n\n  @DomName('AudioBufferSourceNode.noteOff')\n  @DocsEditable()\n  void noteOff(num when) native;\n\n  @DomName('AudioBufferSourceNode.noteOn')\n  @DocsEditable()\n  void noteOn(num when) native;\n\n  /// Stream of `ended` events handled by this [AudioBufferSourceNode].\n  @DomName('AudioBufferSourceNode.onended')\n  @DocsEditable()\n  @Experimental() // untriaged\n  Stream<Event> get onEnded => endedEvent.forTarget(this);\n\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DomName('AudioContext')\n@SupportedBrowser(SupportedBrowser.CHROME)\n@SupportedBrowser(SupportedBrowser.FIREFOX)\n@Experimental()\n// https://dvcs.w3.org/hg/audio/raw-file/tip/webaudio/specification.html#AudioContext-section\n@Native(\"AudioContext,webkitAudioContext\")\nclass AudioContext extends EventTarget {\n  // To suppress missing implicit constructor warnings.\n  factory AudioContext._() { throw new UnsupportedError(\"Not supported\"); }\n\n  /**\n   * Static factory designed to expose `complete` events to event\n   * handlers that are not necessarily instances of [AudioContext].\n   *\n   * See [EventStreamProvider] for usage information.\n   */\n  @DomName('AudioContext.completeEvent')\n  @DocsEditable()\n  static const EventStreamProvider<Event> completeEvent = const EventStreamProvider<Event>('complete');\n\n  /// Checks if this type is supported on the current platform.\n  static bool get supported => JS('bool', '!!(window.AudioContext || window.webkitAudioContext)');\n\n  @DomName('AudioContext.currentTime')\n  @DocsEditable()\n  final double currentTime;\n\n  @DomName('AudioContext.destination')\n  @DocsEditable()\n  final AudioDestinationNode destination;\n\n  @DomName('AudioContext.listener')\n  @DocsEditable()\n  final AudioListener listener;\n\n  @DomName('AudioContext.sampleRate')\n  @DocsEditable()\n  final double sampleRate;\n\n  @DomName('AudioContext.createAnalyser')\n  @DocsEditable()\n  AnalyserNode createAnalyser() native;\n\n  @DomName('AudioContext.createBiquadFilter')\n  @DocsEditable()\n  BiquadFilterNode createBiquadFilter() native;\n\n  @DomName('AudioContext.createBuffer')\n  @DocsEditable()\n  AudioBuffer createBuffer(int numberOfChannels, int numberOfFrames, num sampleRate) native;\n\n  @DomName('AudioContext.createBufferSource')\n  @DocsEditable()\n  AudioBufferSourceNode createBufferSource() native;\n\n  @DomName('AudioContext.createChannelMerger')\n  @DocsEditable()\n  ChannelMergerNode createChannelMerger([int numberOfInputs]) native;\n\n  @DomName('AudioContext.createChannelSplitter')\n  @DocsEditable()\n  ChannelSplitterNode createChannelSplitter([int numberOfOutputs]) native;\n\n  @DomName('AudioContext.createConvolver')\n  @DocsEditable()\n  ConvolverNode createConvolver() native;\n\n  @DomName('AudioContext.createDelay')\n  @DocsEditable()\n  DelayNode createDelay([num maxDelayTime]) native;\n\n  @DomName('AudioContext.createDynamicsCompressor')\n  @DocsEditable()\n  DynamicsCompressorNode createDynamicsCompressor() native;\n\n  @DomName('AudioContext.createMediaElementSource')\n  @DocsEditable()\n  MediaElementAudioSourceNode createMediaElementSource(MediaElement mediaElement) native;\n\n  @DomName('AudioContext.createMediaStreamDestination')\n  @DocsEditable()\n  MediaStreamAudioDestinationNode createMediaStreamDestination() native;\n\n  @DomName('AudioContext.createMediaStreamSource')\n  @DocsEditable()\n  MediaStreamAudioSourceNode createMediaStreamSource(MediaStream mediaStream) native;\n\n  @DomName('AudioContext.createOscillator')\n  @DocsEditable()\n  OscillatorNode createOscillator() native;\n\n  @DomName('AudioContext.createPanner')\n  @DocsEditable()\n  PannerNode createPanner() native;\n\n  @DomName('AudioContext.createPeriodicWave')\n  @DocsEditable()\n  @Experimental() // untriaged\n  PeriodicWave createPeriodicWave(Float32List real, Float32List imag) native;\n\n  @DomName('AudioContext.createWaveShaper')\n  @DocsEditable()\n  WaveShaperNode createWaveShaper() native;\n\n  @JSName('decodeAudioData')\n  @DomName('AudioContext.decodeAudioData')\n  @DocsEditable()\n  void _decodeAudioData(ByteBuffer audioData, AudioBufferCallback successCallback, [AudioBufferCallback errorCallback]) native;\n\n  @DomName('AudioContext.startRendering')\n  @DocsEditable()\n  void startRendering() native;\n\n  /// Stream of `complete` events handled by this [AudioContext].\n  @DomName('AudioContext.oncomplete')\n  @DocsEditable()\n  Stream<Event> get onComplete => completeEvent.forTarget(this);\n\n  factory AudioContext() => JS('AudioContext',\n      'new (window.AudioContext || window.webkitAudioContext)()');\n\n  GainNode createGain() {\n    if (JS('bool', '#.createGain !== undefined', this)) {\n      return JS('GainNode', '#.createGain()', this);\n    } else {\n      return JS('GainNode', '#.createGainNode()', this);\n    }\n  }\n\n  ScriptProcessorNode createScriptProcessor(int bufferSize,\n      [int numberOfInputChannels, int numberOfOutputChannels]) {\n    var function = JS('=Object', '#.createScriptProcessor || '\n        '#.createJavaScriptNode', this, this);\n    if (numberOfOutputChannels != null) {\n      return JS('ScriptProcessorNode', '#.call(#, #, #, #)', function, this,\n          bufferSize, numberOfInputChannels, numberOfOutputChannels);\n    } else if (numberOfInputChannels != null) {\n      return JS('ScriptProcessorNode', '#.call(#, #, #)', function, this,\n          bufferSize, numberOfInputChannels);\n    } else {\n      return JS('ScriptProcessorNode', '#.call(#, #)', function, this,\n          bufferSize);\n    }\n  }\n  @DomName('AudioContext.decodeAudioData')\n  Future<AudioBuffer> decodeAudioData(ByteBuffer audioData) {\n    var completer = new Completer<AudioBuffer>();\n    _decodeAudioData(audioData,\n        (value) { completer.complete(value); },\n        (error) {\n          if (error == null) {\n            completer.completeError('');\n          } else {\n            completer.completeError(error);\n          }\n        });\n    return completer.future;\n  }\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('AudioDestinationNode')\n// https://dvcs.w3.org/hg/audio/raw-file/tip/webaudio/specification.html#AudioDestinationNode-section\n@Experimental()\n@Native(\"AudioDestinationNode\")\nclass AudioDestinationNode extends AudioNode {\n  // To suppress missing implicit constructor warnings.\n  factory AudioDestinationNode._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('AudioDestinationNode.maxChannelCount')\n  @DocsEditable()\n  final int maxChannelCount;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('AudioListener')\n// https://dvcs.w3.org/hg/audio/raw-file/tip/webaudio/specification.html#AudioListener-section\n@Experimental()\n@Native(\"AudioListener\")\nclass AudioListener extends Interceptor {\n  // To suppress missing implicit constructor warnings.\n  factory AudioListener._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('AudioListener.dopplerFactor')\n  @DocsEditable()\n  num dopplerFactor;\n\n  @DomName('AudioListener.speedOfSound')\n  @DocsEditable()\n  num speedOfSound;\n\n  @DomName('AudioListener.setOrientation')\n  @DocsEditable()\n  void setOrientation(num x, num y, num z, num xUp, num yUp, num zUp) native;\n\n  @DomName('AudioListener.setPosition')\n  @DocsEditable()\n  void setPosition(num x, num y, num z) native;\n\n  @DomName('AudioListener.setVelocity')\n  @DocsEditable()\n  void setVelocity(num x, num y, num z) native;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DomName('AudioNode')\n// https://dvcs.w3.org/hg/audio/raw-file/tip/webaudio/specification.html#AudioNode-section\n@Experimental()\n@Native(\"AudioNode\")\nclass AudioNode extends EventTarget {\n  // To suppress missing implicit constructor warnings.\n  factory AudioNode._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('AudioNode.channelCount')\n  @DocsEditable()\n  int channelCount;\n\n  @DomName('AudioNode.channelCountMode')\n  @DocsEditable()\n  String channelCountMode;\n\n  @DomName('AudioNode.channelInterpretation')\n  @DocsEditable()\n  String channelInterpretation;\n\n  @DomName('AudioNode.context')\n  @DocsEditable()\n  final AudioContext context;\n\n  @DomName('AudioNode.numberOfInputs')\n  @DocsEditable()\n  final int numberOfInputs;\n\n  @DomName('AudioNode.numberOfOutputs')\n  @DocsEditable()\n  final int numberOfOutputs;\n\n  @JSName('connect')\n  @DomName('AudioNode.connect')\n  @DocsEditable()\n  void _connect(destination, int output, [int input]) native;\n\n  @DomName('AudioNode.disconnect')\n  @DocsEditable()\n  void disconnect(int output) native;\n\n  @DomName('AudioNode.connect')\n  void connectNode(AudioNode destination, [int output = 0, int input = 0]) =>\n      _connect(destination, output, input);\n\n  @DomName('AudioNode.connect')\n  void connectParam(AudioParam destination, [int output = 0]) =>\n      _connect(destination, output);\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('AudioParam')\n// https://dvcs.w3.org/hg/audio/raw-file/tip/webaudio/specification.html#AudioParam\n@Experimental()\n@Native(\"AudioParam\")\nclass AudioParam extends Interceptor {\n  // To suppress missing implicit constructor warnings.\n  factory AudioParam._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('AudioParam.defaultValue')\n  @DocsEditable()\n  final double defaultValue;\n\n  @DomName('AudioParam.maxValue')\n  @DocsEditable()\n  final double maxValue;\n\n  @DomName('AudioParam.minValue')\n  @DocsEditable()\n  final double minValue;\n\n  @DomName('AudioParam.name')\n  @DocsEditable()\n  final String name;\n\n  @DomName('AudioParam.units')\n  @DocsEditable()\n  final int units;\n\n  @DomName('AudioParam.value')\n  @DocsEditable()\n  num value;\n\n  @DomName('AudioParam.cancelScheduledValues')\n  @DocsEditable()\n  void cancelScheduledValues(num startTime) native;\n\n  @DomName('AudioParam.exponentialRampToValueAtTime')\n  @DocsEditable()\n  void exponentialRampToValueAtTime(num value, num time) native;\n\n  @DomName('AudioParam.linearRampToValueAtTime')\n  @DocsEditable()\n  void linearRampToValueAtTime(num value, num time) native;\n\n  @DomName('AudioParam.setTargetAtTime')\n  @DocsEditable()\n  void setTargetAtTime(num target, num time, num timeConstant) native;\n\n  @DomName('AudioParam.setValueAtTime')\n  @DocsEditable()\n  void setValueAtTime(num value, num time) native;\n\n  @DomName('AudioParam.setValueCurveAtTime')\n  @DocsEditable()\n  void setValueCurveAtTime(Float32List values, num time, num duration) native;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('AudioProcessingEvent')\n// https://dvcs.w3.org/hg/audio/raw-file/tip/webaudio/specification.html#AudioProcessingEvent-section\n@Experimental()\n@Native(\"AudioProcessingEvent\")\nclass AudioProcessingEvent extends Event {\n  // To suppress missing implicit constructor warnings.\n  factory AudioProcessingEvent._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('AudioProcessingEvent.inputBuffer')\n  @DocsEditable()\n  final AudioBuffer inputBuffer;\n\n  @DomName('AudioProcessingEvent.outputBuffer')\n  @DocsEditable()\n  final AudioBuffer outputBuffer;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('AudioSourceNode')\n// https://dvcs.w3.org/hg/audio/raw-file/tip/webaudio/specification.html\n@Experimental()\n@Native(\"AudioSourceNode\")\nclass AudioSourceNode extends AudioNode {\n  // To suppress missing implicit constructor warnings.\n  factory AudioSourceNode._() { throw new UnsupportedError(\"Not supported\"); }\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('BiquadFilterNode')\n// https://dvcs.w3.org/hg/audio/raw-file/tip/webaudio/specification.html#BiquadFilterNode-section\n@Experimental()\n@Native(\"BiquadFilterNode\")\nclass BiquadFilterNode extends AudioNode {\n  // To suppress missing implicit constructor warnings.\n  factory BiquadFilterNode._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('BiquadFilterNode.ALLPASS')\n  @DocsEditable()\n  static const int ALLPASS = 7;\n\n  @DomName('BiquadFilterNode.BANDPASS')\n  @DocsEditable()\n  static const int BANDPASS = 2;\n\n  @DomName('BiquadFilterNode.HIGHPASS')\n  @DocsEditable()\n  static const int HIGHPASS = 1;\n\n  @DomName('BiquadFilterNode.HIGHSHELF')\n  @DocsEditable()\n  static const int HIGHSHELF = 4;\n\n  @DomName('BiquadFilterNode.LOWPASS')\n  @DocsEditable()\n  static const int LOWPASS = 0;\n\n  @DomName('BiquadFilterNode.LOWSHELF')\n  @DocsEditable()\n  static const int LOWSHELF = 3;\n\n  @DomName('BiquadFilterNode.NOTCH')\n  @DocsEditable()\n  static const int NOTCH = 6;\n\n  @DomName('BiquadFilterNode.PEAKING')\n  @DocsEditable()\n  static const int PEAKING = 5;\n\n  @DomName('BiquadFilterNode.Q')\n  @DocsEditable()\n  final AudioParam Q;\n\n  @DomName('BiquadFilterNode.detune')\n  @DocsEditable()\n  final AudioParam detune;\n\n  @DomName('BiquadFilterNode.frequency')\n  @DocsEditable()\n  final AudioParam frequency;\n\n  @DomName('BiquadFilterNode.gain')\n  @DocsEditable()\n  final AudioParam gain;\n\n  @DomName('BiquadFilterNode.type')\n  @DocsEditable()\n  String type;\n\n  @DomName('BiquadFilterNode.getFrequencyResponse')\n  @DocsEditable()\n  void getFrequencyResponse(Float32List frequencyHz, Float32List magResponse, Float32List phaseResponse) native;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('ChannelMergerNode')\n// https://dvcs.w3.org/hg/audio/raw-file/tip/webaudio/specification.html#ChannelMergerNode-section\n@Experimental()\n@Native(\"ChannelMergerNode,AudioChannelMerger\")\nclass ChannelMergerNode extends AudioNode {\n  // To suppress missing implicit constructor warnings.\n  factory ChannelMergerNode._() { throw new UnsupportedError(\"Not supported\"); }\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('ChannelSplitterNode')\n// https://dvcs.w3.org/hg/audio/raw-file/tip/webaudio/specification.html#ChannelSplitterNode-section\n@Experimental()\n@Native(\"ChannelSplitterNode,AudioChannelSplitter\")\nclass ChannelSplitterNode extends AudioNode {\n  // To suppress missing implicit constructor warnings.\n  factory ChannelSplitterNode._() { throw new UnsupportedError(\"Not supported\"); }\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('ConvolverNode')\n// https://dvcs.w3.org/hg/audio/raw-file/tip/webaudio/specification.html#ConvolverNode\n@Experimental()\n@Native(\"ConvolverNode\")\nclass ConvolverNode extends AudioNode {\n  // To suppress missing implicit constructor warnings.\n  factory ConvolverNode._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('ConvolverNode.buffer')\n  @DocsEditable()\n  AudioBuffer buffer;\n\n  @DomName('ConvolverNode.normalize')\n  @DocsEditable()\n  bool normalize;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('DelayNode')\n// https://dvcs.w3.org/hg/audio/raw-file/tip/webaudio/specification.html#DelayNode\n@Experimental()\n@Native(\"DelayNode\")\nclass DelayNode extends AudioNode {\n  // To suppress missing implicit constructor warnings.\n  factory DelayNode._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('DelayNode.delayTime')\n  @DocsEditable()\n  final AudioParam delayTime;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('DynamicsCompressorNode')\n// https://dvcs.w3.org/hg/audio/raw-file/tip/webaudio/specification.html#DynamicsCompressorNode\n@Experimental()\n@Native(\"DynamicsCompressorNode\")\nclass DynamicsCompressorNode extends AudioNode {\n  // To suppress missing implicit constructor warnings.\n  factory DynamicsCompressorNode._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('DynamicsCompressorNode.attack')\n  @DocsEditable()\n  final AudioParam attack;\n\n  @DomName('DynamicsCompressorNode.knee')\n  @DocsEditable()\n  final AudioParam knee;\n\n  @DomName('DynamicsCompressorNode.ratio')\n  @DocsEditable()\n  final AudioParam ratio;\n\n  @DomName('DynamicsCompressorNode.reduction')\n  @DocsEditable()\n  final AudioParam reduction;\n\n  @DomName('DynamicsCompressorNode.release')\n  @DocsEditable()\n  final AudioParam release;\n\n  @DomName('DynamicsCompressorNode.threshold')\n  @DocsEditable()\n  final AudioParam threshold;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('GainNode')\n// https://dvcs.w3.org/hg/audio/raw-file/tip/webaudio/specification.html#GainNode\n@Experimental()\n@Native(\"GainNode,AudioGainNode\")\nclass GainNode extends AudioNode {\n  // To suppress missing implicit constructor warnings.\n  factory GainNode._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('GainNode.gain')\n  @DocsEditable()\n  final AudioParam gain;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('MediaElementAudioSourceNode')\n// https://dvcs.w3.org/hg/audio/raw-file/tip/webaudio/specification.html#MediaElementAudioSourceNode\n@Experimental()\n@Native(\"MediaElementAudioSourceNode\")\nclass MediaElementAudioSourceNode extends AudioSourceNode {\n  // To suppress missing implicit constructor warnings.\n  factory MediaElementAudioSourceNode._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('MediaElementAudioSourceNode.mediaElement')\n  @DocsEditable()\n  @Experimental() // non-standard\n  final MediaElement mediaElement;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('MediaStreamAudioDestinationNode')\n// https://dvcs.w3.org/hg/audio/raw-file/tip/webaudio/specification.html#MediaStreamAudioDestinationNode\n@Experimental()\n@Native(\"MediaStreamAudioDestinationNode\")\nclass MediaStreamAudioDestinationNode extends AudioNode {\n  // To suppress missing implicit constructor warnings.\n  factory MediaStreamAudioDestinationNode._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('MediaStreamAudioDestinationNode.stream')\n  @DocsEditable()\n  final MediaStream stream;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('MediaStreamAudioSourceNode')\n// https://dvcs.w3.org/hg/audio/raw-file/tip/webaudio/specification.html#MediaStreamAudioSourceNode\n@Experimental()\n@Native(\"MediaStreamAudioSourceNode\")\nclass MediaStreamAudioSourceNode extends AudioSourceNode {\n  // To suppress missing implicit constructor warnings.\n  factory MediaStreamAudioSourceNode._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('MediaStreamAudioSourceNode.mediaStream')\n  @DocsEditable()\n  final MediaStream mediaStream;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('OfflineAudioCompletionEvent')\n// https://dvcs.w3.org/hg/audio/raw-file/tip/webaudio/specification.html#OfflineAudioCompletionEvent-section\n@Experimental()\n@Native(\"OfflineAudioCompletionEvent\")\nclass OfflineAudioCompletionEvent extends Event {\n  // To suppress missing implicit constructor warnings.\n  factory OfflineAudioCompletionEvent._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('OfflineAudioCompletionEvent.renderedBuffer')\n  @DocsEditable()\n  final AudioBuffer renderedBuffer;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('OfflineAudioContext')\n// https://dvcs.w3.org/hg/audio/raw-file/tip/webaudio/specification.html#OfflineAudioContext-section\n@Experimental()\n@Native(\"OfflineAudioContext\")\nclass OfflineAudioContext extends AudioContext {\n  // To suppress missing implicit constructor warnings.\n  factory OfflineAudioContext._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('OfflineAudioContext.OfflineAudioContext')\n  @DocsEditable()\n  factory OfflineAudioContext(int numberOfChannels, int numberOfFrames, num sampleRate) {\n    return OfflineAudioContext._create_1(numberOfChannels, numberOfFrames, sampleRate);\n  }\n  static OfflineAudioContext _create_1(numberOfChannels, numberOfFrames, sampleRate) => JS('OfflineAudioContext', 'new OfflineAudioContext(#,#,#)', numberOfChannels, numberOfFrames, sampleRate);\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('OscillatorNode')\n// https://dvcs.w3.org/hg/audio/raw-file/tip/webaudio/specification.html#dfn-OscillatorNode\n@Experimental()\n@Native(\"OscillatorNode,Oscillator\")\nclass OscillatorNode extends AudioSourceNode {\n  // To suppress missing implicit constructor warnings.\n  factory OscillatorNode._() { throw new UnsupportedError(\"Not supported\"); }\n\n  /**\n   * Static factory designed to expose `ended` events to event\n   * handlers that are not necessarily instances of [OscillatorNode].\n   *\n   * See [EventStreamProvider] for usage information.\n   */\n  @DomName('OscillatorNode.endedEvent')\n  @DocsEditable()\n  @Experimental() // untriaged\n  static const EventStreamProvider<Event> endedEvent = const EventStreamProvider<Event>('ended');\n\n  @DomName('OscillatorNode.FINISHED_STATE')\n  @DocsEditable()\n  static const int FINISHED_STATE = 3;\n\n  @DomName('OscillatorNode.PLAYING_STATE')\n  @DocsEditable()\n  static const int PLAYING_STATE = 2;\n\n  @DomName('OscillatorNode.SCHEDULED_STATE')\n  @DocsEditable()\n  static const int SCHEDULED_STATE = 1;\n\n  @DomName('OscillatorNode.UNSCHEDULED_STATE')\n  @DocsEditable()\n  static const int UNSCHEDULED_STATE = 0;\n\n  @DomName('OscillatorNode.detune')\n  @DocsEditable()\n  final AudioParam detune;\n\n  @DomName('OscillatorNode.frequency')\n  @DocsEditable()\n  final AudioParam frequency;\n\n  @DomName('OscillatorNode.type')\n  @DocsEditable()\n  String type;\n\n  @DomName('OscillatorNode.noteOff')\n  @DocsEditable()\n  void noteOff(num when) native;\n\n  @DomName('OscillatorNode.noteOn')\n  @DocsEditable()\n  void noteOn(num when) native;\n\n  @DomName('OscillatorNode.setPeriodicWave')\n  @DocsEditable()\n  @Experimental() // untriaged\n  void setPeriodicWave(PeriodicWave periodicWave) native;\n\n  @DomName('OscillatorNode.start')\n  @DocsEditable()\n  void start([num when]) native;\n\n  @DomName('OscillatorNode.stop')\n  @DocsEditable()\n  void stop([num when]) native;\n\n  /// Stream of `ended` events handled by this [OscillatorNode].\n  @DomName('OscillatorNode.onended')\n  @DocsEditable()\n  @Experimental() // untriaged\n  Stream<Event> get onEnded => endedEvent.forTarget(this);\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('PannerNode')\n// https://dvcs.w3.org/hg/audio/raw-file/tip/webaudio/specification.html#PannerNode\n@Experimental()\n@Native(\"PannerNode,AudioPannerNode\")\nclass PannerNode extends AudioNode {\n  // To suppress missing implicit constructor warnings.\n  factory PannerNode._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('PannerNode.coneInnerAngle')\n  @DocsEditable()\n  num coneInnerAngle;\n\n  @DomName('PannerNode.coneOuterAngle')\n  @DocsEditable()\n  num coneOuterAngle;\n\n  @DomName('PannerNode.coneOuterGain')\n  @DocsEditable()\n  num coneOuterGain;\n\n  @DomName('PannerNode.distanceModel')\n  @DocsEditable()\n  String distanceModel;\n\n  @DomName('PannerNode.maxDistance')\n  @DocsEditable()\n  num maxDistance;\n\n  @DomName('PannerNode.panningModel')\n  @DocsEditable()\n  String panningModel;\n\n  @DomName('PannerNode.refDistance')\n  @DocsEditable()\n  num refDistance;\n\n  @DomName('PannerNode.rolloffFactor')\n  @DocsEditable()\n  num rolloffFactor;\n\n  @DomName('PannerNode.setOrientation')\n  @DocsEditable()\n  void setOrientation(num x, num y, num z) native;\n\n  @DomName('PannerNode.setPosition')\n  @DocsEditable()\n  void setPosition(num x, num y, num z) native;\n\n  @DomName('PannerNode.setVelocity')\n  @DocsEditable()\n  void setVelocity(num x, num y, num z) native;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('PeriodicWave')\n@Experimental() // untriaged\n@Native(\"PeriodicWave\")\nclass PeriodicWave extends Interceptor {\n  // To suppress missing implicit constructor warnings.\n  factory PeriodicWave._() { throw new UnsupportedError(\"Not supported\"); }\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('ScriptProcessorNode')\n// https://dvcs.w3.org/hg/audio/raw-file/tip/webaudio/specification.html#ScriptProcessorNode\n@Experimental()\n@Native(\"ScriptProcessorNode,JavaScriptAudioNode\")\nclass ScriptProcessorNode extends AudioNode {\n  // To suppress missing implicit constructor warnings.\n  factory ScriptProcessorNode._() { throw new UnsupportedError(\"Not supported\"); }\n\n  /**\n   * Static factory designed to expose `audioprocess` events to event\n   * handlers that are not necessarily instances of [ScriptProcessorNode].\n   *\n   * See [EventStreamProvider] for usage information.\n   */\n  @DomName('ScriptProcessorNode.audioprocessEvent')\n  @DocsEditable()\n  @Experimental() // untriaged\n  static const EventStreamProvider<AudioProcessingEvent> audioProcessEvent = const EventStreamProvider<AudioProcessingEvent>('audioprocess');\n\n  @DomName('ScriptProcessorNode.bufferSize')\n  @DocsEditable()\n  final int bufferSize;\n\n  /// Stream of `audioprocess` events handled by this [ScriptProcessorNode].\n/**\n   * Get a Stream that fires events when AudioProcessingEvents occur.\n   * This particular stream is special in that it only allows one listener to a\n   * given stream. Converting the returned Stream [asBroadcast] will likely ruin\n   * the soft-real-time properties which which these events are fired and can\n   * be processed.\n   */\n  @DomName('ScriptProcessorNode.onaudioprocess')\n  @DocsEditable()\n  @Experimental() // untriaged\n  Stream<AudioProcessingEvent> get onAudioProcess => audioProcessEvent.forTarget(this);\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('WaveShaperNode')\n// https://dvcs.w3.org/hg/audio/raw-file/tip/webaudio/specification.html#dfn-WaveShaperNode\n@Experimental()\n@Native(\"WaveShaperNode\")\nclass WaveShaperNode extends AudioNode {\n  // To suppress missing implicit constructor warnings.\n  factory WaveShaperNode._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('WaveShaperNode.curve')\n  @DocsEditable()\n  Float32List curve;\n\n  @DomName('WaveShaperNode.oversample')\n  @DocsEditable()\n  String oversample;\n}\n\u0000","sdk:/sdk/lib/web_sql/dart2js/web_sql_dart2js.dart":"/**\n * An API for storing data in the browser that can be queried with SQL.\n *\n * **Caution:** this specification is no longer actively maintained by the Web\n * Applications Working Group and may be removed at any time.\n * See [the W3C Web SQL Database specification](http://www.w3.org/TR/webdatabase/)\n * for more information.\n *\n * The [dart:indexed_db] APIs is a recommended alternatives.\n */\nlibrary dart.dom.web_sql;\n\nimport 'dart:async';\nimport 'dart:collection';\nimport 'dart:_internal' hide deprecated;\nimport 'dart:html';\nimport 'dart:html_common';\nimport 'dart:_js_helper' show convertDartClosureToJS, Creates, JSName, Native;\nimport 'dart:_foreign_helper' show JS;\nimport 'dart:_interceptors' show Interceptor;\n// DO NOT EDIT - unless you are editing documentation as per:\n// https://code.google.com/p/dart/wiki/ContributingHTMLDocumentation\n// Auto-generated dart:audio library.\n\n\n\n\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n// WARNING: Do not edit - generated code.\n\n\n@DomName('SQLStatementCallback')\n// http://www.w3.org/TR/webdatabase/#sqlstatementcallback\n@Experimental() // deprecated\ntypedef void SqlStatementCallback(SqlTransaction transaction, SqlResultSet resultSet);\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n// WARNING: Do not edit - generated code.\n\n\n@DomName('SQLStatementErrorCallback')\n// http://www.w3.org/TR/webdatabase/#sqlstatementerrorcallback\n@Experimental() // deprecated\ntypedef void SqlStatementErrorCallback(SqlTransaction transaction, SqlError error);\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n// WARNING: Do not edit - generated code.\n\n\n@DomName('SQLTransactionCallback')\n// http://www.w3.org/TR/webdatabase/#sqltransactioncallback\n@Experimental() // deprecated\ntypedef void SqlTransactionCallback(SqlTransaction transaction);\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n// WARNING: Do not edit - generated code.\n\n\n@DomName('SQLTransactionErrorCallback')\n// http://www.w3.org/TR/webdatabase/#sqltransactionerrorcallback\n@Experimental() // deprecated\ntypedef void SqlTransactionErrorCallback(SqlError error);\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('Database')\n@SupportedBrowser(SupportedBrowser.CHROME)\n@SupportedBrowser(SupportedBrowser.SAFARI)\n@Experimental()\n// http://www.w3.org/TR/webdatabase/#asynchronous-database-api\n@Experimental() // deprecated\n@Native(\"Database\")\nclass SqlDatabase extends Interceptor {\n  // To suppress missing implicit constructor warnings.\n  factory SqlDatabase._() { throw new UnsupportedError(\"Not supported\"); }\n\n  /// Checks if this type is supported on the current platform.\n  static bool get supported => JS('bool', '!!(window.openDatabase)');\n\n  @DomName('Database.version')\n  @DocsEditable()\n  final String version;\n\n  /**\n   * Atomically update the database version to [newVersion], asynchronously\n   * running [callback] on the [SqlTransaction] representing this\n   * [changeVersion] transaction.\n   *\n   * If [callback] runs successfully, then [successCallback] is called.\n   * Otherwise, [errorCallback] is called.\n   *\n   * [oldVersion] should match the database's current [version] exactly.\n   *\n   * * [Database.changeVersion](http://www.w3.org/TR/webdatabase/#dom-database-changeversion) from W3C.\n   */\n  @DomName('Database.changeVersion')\n  @DocsEditable()\n  void changeVersion(String oldVersion, String newVersion, [SqlTransactionCallback callback, SqlTransactionErrorCallback errorCallback, VoidCallback successCallback]) native;\n\n  @DomName('Database.readTransaction')\n  @DocsEditable()\n  void readTransaction(SqlTransactionCallback callback, [SqlTransactionErrorCallback errorCallback, VoidCallback successCallback]) native;\n\n  @DomName('Database.transaction')\n  @DocsEditable()\n  void transaction(SqlTransactionCallback callback, [SqlTransactionErrorCallback errorCallback, VoidCallback successCallback]) native;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('SQLError')\n// http://www.w3.org/TR/webdatabase/#sqlerror\n@Experimental() // deprecated\n@Native(\"SQLError\")\nclass SqlError extends Interceptor {\n  // To suppress missing implicit constructor warnings.\n  factory SqlError._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('SQLError.CONSTRAINT_ERR')\n  @DocsEditable()\n  static const int CONSTRAINT_ERR = 6;\n\n  @DomName('SQLError.DATABASE_ERR')\n  @DocsEditable()\n  static const int DATABASE_ERR = 1;\n\n  @DomName('SQLError.QUOTA_ERR')\n  @DocsEditable()\n  static const int QUOTA_ERR = 4;\n\n  @DomName('SQLError.SYNTAX_ERR')\n  @DocsEditable()\n  static const int SYNTAX_ERR = 5;\n\n  @DomName('SQLError.TIMEOUT_ERR')\n  @DocsEditable()\n  static const int TIMEOUT_ERR = 7;\n\n  @DomName('SQLError.TOO_LARGE_ERR')\n  @DocsEditable()\n  static const int TOO_LARGE_ERR = 3;\n\n  @DomName('SQLError.UNKNOWN_ERR')\n  @DocsEditable()\n  static const int UNKNOWN_ERR = 0;\n\n  @DomName('SQLError.VERSION_ERR')\n  @DocsEditable()\n  static const int VERSION_ERR = 2;\n\n  @DomName('SQLError.code')\n  @DocsEditable()\n  final int code;\n\n  @DomName('SQLError.message')\n  @DocsEditable()\n  final String message;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('SQLResultSet')\n// http://www.w3.org/TR/webdatabase/#sqlresultset\n@Experimental() // deprecated\n@Native(\"SQLResultSet\")\nclass SqlResultSet extends Interceptor {\n  // To suppress missing implicit constructor warnings.\n  factory SqlResultSet._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('SQLResultSet.insertId')\n  @DocsEditable()\n  final int insertId;\n\n  @DomName('SQLResultSet.rows')\n  @DocsEditable()\n  final SqlResultSetRowList rows;\n\n  @DomName('SQLResultSet.rowsAffected')\n  @DocsEditable()\n  final int rowsAffected;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('SQLResultSetRowList')\n// http://www.w3.org/TR/webdatabase/#sqlresultsetrowlist\n@Experimental() // deprecated\n@Native(\"SQLResultSetRowList\")\nclass SqlResultSetRowList extends Interceptor with ListMixin<Map>, ImmutableListMixin<Map> implements List<Map> {\n  // To suppress missing implicit constructor warnings.\n  factory SqlResultSetRowList._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('SQLResultSetRowList.length')\n  @DocsEditable()\n  int get length => JS(\"int\", \"#.length\", this);\n\n  Map operator[](int index) {\n    if (JS(\"bool\", \"# >>> 0 !== # || # >= #\", index,\n        index, index, length))\n      throw new RangeError.range(index, 0, length);\n    return this.item(index);\n  }\n  void operator[]=(int index, Map value) {\n    throw new UnsupportedError(\"Cannot assign element of immutable List.\");\n  }\n  // -- start List<Map> mixins.\n  // Map is the element type.\n\n\n  void set length(int value) {\n    throw new UnsupportedError(\"Cannot resize immutable List.\");\n  }\n\n  Map get first {\n    if (this.length > 0) {\n      return JS('Map', '#[0]', this);\n    }\n    throw new StateError(\"No elements\");\n  }\n\n  Map get last {\n    int len = this.length;\n    if (len > 0) {\n      return JS('Map', '#[#]', this, len - 1);\n    }\n    throw new StateError(\"No elements\");\n  }\n\n  Map get single {\n    int len = this.length;\n    if (len == 1) {\n      return JS('Map', '#[0]', this);\n    }\n    if (len == 0) throw new StateError(\"No elements\");\n    throw new StateError(\"More than one element\");\n  }\n\n  Map elementAt(int index) => this[index];\n  // -- end List<Map> mixins.\n\n  @DomName('SQLResultSetRowList.item')\n  @DocsEditable()\n  @Creates('=Object')\n  Map item(int index) {\n    return convertNativeToDart_Dictionary(_item_1(index));\n  }\n  @JSName('item')\n  @DomName('SQLResultSetRowList.item')\n  @DocsEditable()\n  @Creates('=Object')\n  _item_1(index) native;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('SQLTransaction')\n@SupportedBrowser(SupportedBrowser.CHROME)\n@SupportedBrowser(SupportedBrowser.SAFARI)\n@Experimental()\n// http://www.w3.org/TR/webdatabase/#sqltransaction\n@deprecated // deprecated\n@Native(\"SQLTransaction\")\nclass SqlTransaction extends Interceptor {\n  // To suppress missing implicit constructor warnings.\n  factory SqlTransaction._() { throw new UnsupportedError(\"Not supported\"); }\n\n  @DomName('SQLTransaction.executeSql')\n  @DocsEditable()\n  void executeSql(String sqlStatement, List<Object> arguments, [SqlStatementCallback callback, SqlStatementErrorCallback errorCallback]) native;\n}\n// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\n@DocsEditable()\n@DomName('SQLTransactionSync')\n@SupportedBrowser(SupportedBrowser.CHROME)\n@SupportedBrowser(SupportedBrowser.SAFARI)\n@Experimental()\n// http://www.w3.org/TR/webdatabase/#sqltransactionsync\n@Experimental() // deprecated\n@Native(\"SQLTransactionSync\")\nabstract class _SQLTransactionSync extends Interceptor {\n  // To suppress missing implicit constructor warnings.\n  factory _SQLTransactionSync._() { throw new UnsupportedError(\"Not supported\"); }\n}\n\u0000","sdk:/sdk/lib/io/websocket_impl.dart":"// Copyright (c) 2013, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\npart of dart.io;\n\nconst String _webSocketGUID = \"258EAFA5-E914-47DA-95CA-C5AB0DC85B11\";\n\n// Matches _WebSocketOpcode.\nclass _WebSocketMessageType {\n  static const int NONE = 0;\n  static const int TEXT = 1;\n  static const int BINARY = 2;\n}\n\n\nclass _WebSocketOpcode {\n  static const int CONTINUATION = 0;\n  static const int TEXT = 1;\n  static const int BINARY = 2;\n  static const int RESERVED_3 = 3;\n  static const int RESERVED_4 = 4;\n  static const int RESERVED_5 = 5;\n  static const int RESERVED_6 = 6;\n  static const int RESERVED_7 = 7;\n  static const int CLOSE = 8;\n  static const int PING = 9;\n  static const int PONG = 10;\n  static const int RESERVED_B = 11;\n  static const int RESERVED_C = 12;\n  static const int RESERVED_D = 13;\n  static const int RESERVED_E = 14;\n  static const int RESERVED_F = 15;\n}\n\n/**\n * The web socket protocol transformer handles the protocol byte stream\n * which is supplied through the [:handleData:]. As the protocol is processed,\n * it'll output frame data as either a List<int> or String.\n *\n * Important infomation about usage: Be sure you use cancelOnError, so the\n * socket will be closed when the processer encounter an error. Not using it\n * will lead to undefined behaviour.\n */\n// TODO(ajohnsen): make this transformer reusable?\nclass _WebSocketProtocolTransformer implements StreamTransformer, EventSink {\n  static const int START = 0;\n  static const int LEN_FIRST = 1;\n  static const int LEN_REST = 2;\n  static const int MASK = 3;\n  static const int PAYLOAD = 4;\n  static const int CLOSED = 5;\n  static const int FAILURE = 6;\n\n  int _state = START;\n  bool _fin = false;\n  int _opcode = -1;\n  int _len = -1;\n  bool _masked = false;\n  int _remainingLenBytes = -1;\n  int _remainingMaskingKeyBytes = 4;\n  int _remainingPayloadBytes = -1;\n  int _unmaskingIndex = 0;\n  int _currentMessageType = _WebSocketMessageType.NONE;\n  int closeCode = WebSocketStatus.NO_STATUS_RECEIVED;\n  String closeReason = \"\";\n\n  EventSink _eventSink;\n\n  final bool _serverSide;\n  final List _maskingBytes = new List(4);\n  final BytesBuilder _payload = new BytesBuilder(copy: false);\n\n  _WebSocketProtocolTransformer([this._serverSide = false]);\n\n  Stream bind(Stream stream) {\n    return new Stream.eventTransformed(\n        stream,\n        (EventSink eventSink) {\n          if (_eventSink != null) {\n            throw new StateError(\"WebSocket transformer already used.\");\n          }\n          _eventSink = eventSink;\n          return this;\n        });\n  }\n\n  void addError(Object error, [StackTrace stackTrace]) =>\n      _eventSink.addError(error, stackTrace);\n\n  void close() => _eventSink.close();\n\n  /**\n   * Process data received from the underlying communication channel.\n   */\n  void add(Uint8List buffer) {\n    int count = buffer.length;\n    int index = 0;\n    int lastIndex = count;\n    if (_state == CLOSED) {\n      throw new WebSocketException(\"Data on closed connection\");\n    }\n    if (_state == FAILURE) {\n      throw new WebSocketException(\"Data on failed connection\");\n    }\n    while ((index < lastIndex) && _state != CLOSED && _state != FAILURE) {\n      int byte = buffer[index];\n      if (_state <= LEN_REST) {\n        if (_state == START) {\n          _fin = (byte & 0x80) != 0;\n          if ((byte & 0x70) != 0) {\n            // The RSV1, RSV2 bits RSV3 must be all zero.\n            throw new WebSocketException(\"Protocol error\");\n          }\n          _opcode = (byte & 0xF);\n          if (_opcode <= _WebSocketOpcode.BINARY) {\n            if (_opcode == _WebSocketOpcode.CONTINUATION) {\n              if (_currentMessageType == _WebSocketMessageType.NONE) {\n                throw new WebSocketException(\"Protocol error\");\n              }\n            } else {\n              assert(_opcode == _WebSocketOpcode.TEXT ||\n                     _opcode == _WebSocketOpcode.BINARY);\n              if (_currentMessageType != _WebSocketMessageType.NONE) {\n                throw new WebSocketException(\"Protocol error\");\n              }\n              _currentMessageType = _opcode;\n            }\n          } else if (_opcode >= _WebSocketOpcode.CLOSE &&\n                     _opcode <= _WebSocketOpcode.PONG) {\n            // Control frames cannot be fragmented.\n            if (!_fin) throw new WebSocketException(\"Protocol error\");\n          } else {\n            throw new WebSocketException(\"Protocol error\");\n          }\n          _state = LEN_FIRST;\n        } else if (_state == LEN_FIRST) {\n          _masked = (byte & 0x80) != 0;\n          _len = byte & 0x7F;\n          if (_isControlFrame() && _len > 125) {\n            throw new WebSocketException(\"Protocol error\");\n          }\n          if (_len == 126) {\n            _len = 0;\n            _remainingLenBytes = 2;\n            _state = LEN_REST;\n          } else if (_len == 127) {\n            _len = 0;\n            _remainingLenBytes = 8;\n            _state = LEN_REST;\n          } else {\n            assert(_len < 126);\n            _lengthDone();\n          }\n        } else {\n          assert(_state == LEN_REST);\n          _len = _len << 8 | byte;\n          _remainingLenBytes--;\n          if (_remainingLenBytes == 0) {\n            _lengthDone();\n          }\n        }\n      } else {\n        if (_state == MASK) {\n          _maskingBytes[4 - _remainingMaskingKeyBytes--] = byte;\n          if (_remainingMaskingKeyBytes == 0) {\n            _maskDone();\n          }\n        } else {\n          assert(_state == PAYLOAD);\n          // The payload is not handled one byte at a time but in blocks.\n          int payloadLength = min(lastIndex - index, _remainingPayloadBytes);\n          _remainingPayloadBytes -= payloadLength;\n          // Unmask payload if masked.\n          if (_masked) {\n            _unmask(index, payloadLength, buffer);\n          }\n          // Control frame and data frame share _payloads.\n          _payload.add(\n              new Uint8List.view(buffer.buffer, index, payloadLength));\n          index += payloadLength;\n          if (_isControlFrame()) {\n            if (_remainingPayloadBytes == 0) _controlFrameEnd();\n          } else {\n            if (_currentMessageType != _WebSocketMessageType.TEXT &&\n                _currentMessageType != _WebSocketMessageType.BINARY) {\n                throw new WebSocketException(\"Protocol error\");\n            }\n            if (_remainingPayloadBytes == 0) _messageFrameEnd();\n          }\n\n          // Hack - as we always do index++ below.\n          index--;\n        }\n      }\n\n      // Move to the next byte.\n      index++;\n    }\n  }\n\n  void _unmask(int index, int length, Uint8List buffer) {\n    const int BLOCK_SIZE = 16;\n    // Skip Int32x4-version if message is small.\n    if (length >= BLOCK_SIZE) {\n      // Start by aligning to 16 bytes.\n      final int startOffset = BLOCK_SIZE - (index & 15);\n      final int end = index + startOffset;\n      for (int i = index; i < end; i++) {\n        buffer[i] ^= _maskingBytes[_unmaskingIndex++ & 3];\n      }\n      index += startOffset;\n      length -= startOffset;\n      final int blockCount = length ~/ BLOCK_SIZE;\n      if (blockCount > 0) {\n        // Create mask block.\n        int mask = 0;\n        for (int i = 3; i >= 0; i--) {\n          mask = (mask << 8) | _maskingBytes[(_unmaskingIndex + i) & 3];\n        }\n        Int32x4 blockMask = new Int32x4(mask, mask, mask, mask);\n        Int32x4List blockBuffer = new Int32x4List.view(\n            buffer.buffer, index, blockCount);\n        for (int i = 0; i < blockBuffer.length; i++) {\n          blockBuffer[i] ^= blockMask;\n        }\n        final int bytes = blockCount * BLOCK_SIZE;\n        index += bytes;\n        length -= bytes;\n      }\n    }\n    // Handle end.\n    final int end = index + length;\n    for (int i = index; i < end; i++) {\n      buffer[i] ^= _maskingBytes[_unmaskingIndex++ & 3];\n    }\n  }\n\n  void _lengthDone() {\n    if (_masked) {\n      if (!_serverSide) {\n        throw new WebSocketException(\"Received masked frame from server\");\n      }\n      _state = MASK;\n    } else {\n      if (_serverSide) {\n        throw new WebSocketException(\"Received unmasked frame from client\");\n      }\n      _remainingPayloadBytes = _len;\n      _startPayload();\n    }\n  }\n\n  void _maskDone() {\n    _remainingPayloadBytes = _len;\n    _startPayload();\n  }\n\n  void _startPayload() {\n    // If there is no actual payload perform perform callbacks without\n    // going through the PAYLOAD state.\n    if (_remainingPayloadBytes == 0) {\n      if (_isControlFrame()) {\n        switch (_opcode) {\n          case _WebSocketOpcode.CLOSE:\n            _state = CLOSED;\n            _eventSink.close();\n            break;\n          case _WebSocketOpcode.PING:\n            _eventSink.add(new _WebSocketPing());\n            break;\n          case _WebSocketOpcode.PONG:\n            _eventSink.add(new _WebSocketPong());\n            break;\n        }\n        _prepareForNextFrame();\n      } else {\n        _messageFrameEnd();\n      }\n    } else {\n      _state = PAYLOAD;\n    }\n  }\n\n  void _messageFrameEnd() {\n    if (_fin) {\n      switch (_currentMessageType) {\n        case _WebSocketMessageType.TEXT:\n          _eventSink.add(UTF8.decode(_payload.takeBytes()));\n          break;\n        case _WebSocketMessageType.BINARY:\n          _eventSink.add(_payload.takeBytes());\n          break;\n      }\n      _currentMessageType = _WebSocketMessageType.NONE;\n    }\n    _prepareForNextFrame();\n  }\n\n  void _controlFrameEnd() {\n    switch (_opcode) {\n      case _WebSocketOpcode.CLOSE:\n        closeCode = WebSocketStatus.NO_STATUS_RECEIVED;\n        var payload = _payload.takeBytes();\n        if (payload.length > 0) {\n          if (payload.length == 1) {\n            throw new WebSocketException(\"Protocol error\");\n          }\n          closeCode = payload[0] << 8 | payload[1];\n          if (closeCode == WebSocketStatus.NO_STATUS_RECEIVED) {\n            throw new WebSocketException(\"Protocol error\");\n          }\n          if (payload.length > 2) {\n            closeReason = UTF8.decode(payload.sublist(2));\n          }\n        }\n        _state = CLOSED;\n        _eventSink.close();\n        break;\n\n      case _WebSocketOpcode.PING:\n        _eventSink.add(new _WebSocketPing(_payload.takeBytes()));\n        break;\n\n      case _WebSocketOpcode.PONG:\n        _eventSink.add(new _WebSocketPong(_payload.takeBytes()));\n        break;\n    }\n    _prepareForNextFrame();\n  }\n\n  bool _isControlFrame() {\n    return _opcode == _WebSocketOpcode.CLOSE ||\n           _opcode == _WebSocketOpcode.PING ||\n           _opcode == _WebSocketOpcode.PONG;\n  }\n\n  void _prepareForNextFrame() {\n    if (_state != CLOSED && _state != FAILURE) _state = START;\n    _fin = false;\n    _opcode = -1;\n    _len = -1;\n    _remainingLenBytes = -1;\n    _remainingMaskingKeyBytes = 4;\n    _remainingPayloadBytes = -1;\n    _unmaskingIndex = 0;\n  }\n}\n\n\nclass _WebSocketPing {\n  final List<int> payload;\n  _WebSocketPing([this.payload = null]);\n}\n\n\nclass _WebSocketPong {\n  final List<int> payload;\n  _WebSocketPong([this.payload = null]);\n}\n\n\nclass _WebSocketTransformerImpl implements WebSocketTransformer {\n  final StreamController<WebSocket> _controller =\n      new StreamController<WebSocket>(sync: true);\n  final Function _protocolSelector;\n\n  _WebSocketTransformerImpl(this._protocolSelector);\n\n  Stream<WebSocket> bind(Stream<HttpRequest> stream) {\n    stream.listen((request) {\n        _upgrade(request, _protocolSelector)\n            .then((WebSocket webSocket) => _controller.add(webSocket))\n            .catchError(_controller.addError);\n    });\n\n    return _controller.stream;\n  }\n\n  static Future<WebSocket> _upgrade(HttpRequest request, _protocolSelector) {\n    var response = request.response;\n    if (!_isUpgradeRequest(request)) {\n      // Send error response.\n      response\n          ..statusCode = HttpStatus.BAD_REQUEST\n          ..close();\n      return new Future.error(\n          new WebSocketException(\"Invalid WebSocket upgrade request\"));\n    }\n\n    Future upgrade(String protocol) {\n      // Send the upgrade response.\n      response\n          ..statusCode = HttpStatus.SWITCHING_PROTOCOLS\n          ..headers.add(HttpHeaders.CONNECTION, \"Upgrade\")\n          ..headers.add(HttpHeaders.UPGRADE, \"websocket\");\n      String key = request.headers.value(\"Sec-WebSocket-Key\");\n      _SHA1 sha1 = new _SHA1();\n      sha1.add(\"$key$_webSocketGUID\".codeUnits);\n      String accept = _CryptoUtils.bytesToBase64(sha1.close());\n      response.headers.add(\"Sec-WebSocket-Accept\", accept);\n      if (protocol != null && protocol.isNotEmpty) {\n        response.headers.add(\"Sec-WebSocket-Protocol\", protocol);\n      }\n      response.headers.contentLength = 0;\n      return response.detachSocket()\n          .then((socket) => new _WebSocketImpl._fromSocket(\n                socket, protocol, true));\n    }\n\n    var protocols = request.headers['Sec-WebSocket-Protocol'];\n    if (protocols != null && _protocolSelector != null) {\n      // The suggested protocols can be spread over multiple lines, each\n      // consisting of multiple protocols. To unify all of them, first join\n      // the lists with ', ' and then tokenize.\n      protocols = _HttpParser._tokenizeFieldValue(protocols.join(', '));\n      return new Future(() => _protocolSelector(protocols))\n        .then((protocol) {\n          if (protocols.indexOf(protocol) < 0) {\n            throw new WebSocketException(\n                \"Selected protocol is not in the list of available protocols\");\n          }\n          return protocol;\n        })\n        .catchError((error) {\n          response\n              ..statusCode = HttpStatus.INTERNAL_SERVER_ERROR\n              ..close();\n          throw error;\n        })\n        .then(upgrade);\n    } else {\n      return upgrade(null);\n    }\n  }\n\n  static bool _isUpgradeRequest(HttpRequest request) {\n    if (request.method != \"GET\") {\n      return false;\n    }\n    if (request.headers[HttpHeaders.CONNECTION] == null) {\n      return false;\n    }\n    bool isUpgrade = false;\n    request.headers[HttpHeaders.CONNECTION].forEach((String value) {\n      if (value.toLowerCase() == \"upgrade\") isUpgrade = true;\n    });\n    if (!isUpgrade) return false;\n    String upgrade = request.headers.value(HttpHeaders.UPGRADE);\n    if (upgrade == null || upgrade.toLowerCase() != \"websocket\") {\n      return false;\n    }\n    String version = request.headers.value(\"Sec-WebSocket-Version\");\n    if (version == null || version != \"13\") {\n      return false;\n    }\n    String key = request.headers.value(\"Sec-WebSocket-Key\");\n    if (key == null) {\n      return false;\n    }\n    return true;\n  }\n}\n\n\n// TODO(ajohnsen): Make this transformer reusable.\nclass _WebSocketOutgoingTransformer implements StreamTransformer, EventSink {\n  final _WebSocketImpl webSocket;\n  EventSink _eventSink;\n\n  _WebSocketOutgoingTransformer(this.webSocket);\n\n  Stream bind(Stream stream) {\n    return new Stream.eventTransformed(\n        stream,\n        (EventSink eventSink) {\n          if (_eventSink != null) {\n            throw new StateError(\"WebSocket transformer already used\");\n          }\n          _eventSink = eventSink;\n          return this;\n        });\n  }\n\n  void add(message) {\n    if (message is _WebSocketPong) {\n      addFrame(_WebSocketOpcode.PONG, message.payload);\n      return;\n    }\n    if (message is _WebSocketPing) {\n      addFrame(_WebSocketOpcode.PING, message.payload);\n      return;\n    }\n    List<int> data;\n    int opcode;\n    if (message != null) {\n      if (message is String) {\n        opcode = _WebSocketOpcode.TEXT;\n        data = UTF8.encode(message);\n      } else {\n        if (message is !List<int>) {\n          throw new ArgumentError(message);\n        }\n        opcode = _WebSocketOpcode.BINARY;\n        data = message;\n      }\n    } else {\n      opcode = _WebSocketOpcode.TEXT;\n    }\n    addFrame(opcode, data);\n  }\n\n  void addError(Object error, [StackTrace stackTrace]) =>\n      _eventSink.addError(error, stackTrace);\n\n  void close() {\n    int code = webSocket._outCloseCode;\n    String reason = webSocket._outCloseReason;\n    List<int> data;\n    if (code != null) {\n      data = new List<int>();\n      data.add((code >> 8) & 0xFF);\n      data.add(code & 0xFF);\n      if (reason != null) {\n        data.addAll(UTF8.encode(reason));\n      }\n    }\n    addFrame(_WebSocketOpcode.CLOSE, data);\n    _eventSink.close();\n  }\n\n  void addFrame(int opcode, List<int> data) =>\n      createFrame(opcode, data, webSocket._serverSide).forEach(_eventSink.add);\n\n  static Iterable createFrame(int opcode, List<int> data, bool serverSide) {\n    bool mask = !serverSide;  // Masking not implemented for server.\n    int dataLength = data == null ? 0 : data.length;\n    // Determine the header size.\n    int headerSize = (mask) ? 6 : 2;\n    if (dataLength > 65535) {\n      headerSize += 8;\n    } else if (dataLength > 125) {\n      headerSize += 2;\n    }\n    Uint8List header = new Uint8List(headerSize);\n    int index = 0;\n    // Set FIN and opcode.\n    header[index++] = 0x80 | opcode;\n    // Determine size and position of length field.\n    int lengthBytes = 1;\n    int firstLengthByte = 1;\n    if (dataLength > 65535) {\n      header[index++] = 127;\n      lengthBytes = 8;\n    } else if (dataLength > 125) {\n      header[index++] = 126;\n      lengthBytes = 2;\n    }\n    // Write the length in network byte order into the header.\n    for (int i = 0; i < lengthBytes; i++) {\n      header[index++] = dataLength >> (((lengthBytes - 1) - i) * 8) & 0xFF;\n    }\n    if (mask) {\n      header[1] |= 1 << 7;\n      var maskBytes = _IOCrypto.getRandomBytes(4);\n      header.setRange(index, index + 4, maskBytes);\n      index += 4;\n      if (data != null) {\n        Uint8List list;\n        // If this is a text message just do the masking inside the\n        // encoded data.\n        if (opcode == _WebSocketOpcode.TEXT && data is Uint8List) {\n          list = data;\n        } else {\n          if (data is Uint8List) {\n            list = new Uint8List.fromList(data);\n          } else {\n            list = new Uint8List(data.length);\n            for (int i = 0; i < data.length; i++) {\n              if (data[i] < 0 || 255 < data[i]) {\n                throw new ArgumentError(\n                    \"List element is not a byte value \"\n                    \"(value ${data[i]} at index $i)\");\n              }\n              list[i] = data[i];\n            }\n          }\n        }\n        const int BLOCK_SIZE = 16;\n        int blockCount = list.length ~/ BLOCK_SIZE;\n        if (blockCount > 0) {\n          // Create mask block.\n          int mask = 0;\n          for (int i = 3; i >= 0; i--) {\n            mask = (mask << 8) | maskBytes[i];\n          }\n          Int32x4 blockMask = new Int32x4(mask, mask, mask, mask);\n          Int32x4List blockBuffer = new Int32x4List.view(\n              list.buffer, 0, blockCount);\n          for (int i = 0; i < blockBuffer.length; i++) {\n            blockBuffer[i] ^= blockMask;\n          }\n        }\n        // Handle end.\n        for (int i = blockCount * BLOCK_SIZE; i < list.length; i++) {\n          list[i] ^= maskBytes[i & 3];\n        }\n        data = list;\n      }\n    }\n    assert(index == headerSize);\n    if (data == null) {\n      return [header];\n    } else {\n      return [header, data];\n    }\n  }\n}\n\n\nclass _WebSocketConsumer implements StreamConsumer {\n  final _WebSocketImpl webSocket;\n  final Socket socket;\n  StreamController _controller;\n  StreamSubscription _subscription;\n  bool _issuedPause = false;\n  bool _closed = false;\n  Completer _closeCompleter = new Completer();\n  Completer _completer;\n\n  _WebSocketConsumer(this.webSocket, this.socket);\n\n  void _onListen() {\n    if (_subscription != null) {\n      _subscription.cancel();\n    }\n  }\n\n  void _onPause() {\n    if (_subscription != null) {\n      _subscription.pause();\n    } else {\n      _issuedPause = true;\n    }\n  }\n\n  void _onResume() {\n    if (_subscription != null) {\n      _subscription.resume();\n    } else {\n      _issuedPause = false;\n    }\n  }\n\n  void _cancel() {\n    if (_subscription != null) {\n      var subscription = _subscription;\n      _subscription = null;\n      subscription.cancel();\n    }\n  }\n\n  _ensureController() {\n    if (_controller != null) return;\n    _controller = new StreamController(sync: true,\n                                       onPause: _onPause,\n                                       onResume: _onResume,\n                                       onCancel: _onListen);\n    var stream = _controller.stream.transform(\n        new _WebSocketOutgoingTransformer(webSocket));\n    socket.addStream(stream)\n        .then((_) {\n          _done();\n          _closeCompleter.complete(webSocket);\n        }, onError: (error, StackTrace stackTrace) {\n          _closed = true;\n          _cancel();\n          if (error is ArgumentError) {\n            if (!_done(error, stackTrace)) {\n              _closeCompleter.completeError(error, stackTrace);\n            }\n          } else {\n            _done();\n            _closeCompleter.complete(webSocket);\n          }\n        });\n  }\n\n  bool _done([error, StackTrace stackTrace]) {\n    if (_completer == null) return false;\n    if (error != null) {\n      _completer.completeError(error, stackTrace);\n    } else {\n      _completer.complete(webSocket);\n    }\n    _completer = null;\n    return true;\n  }\n\n  Future addStream(var stream) {\n    if (_closed) {\n      stream.listen(null).cancel();\n      return new Future.value(webSocket);\n    }\n    _ensureController();\n    _completer = new Completer();\n    _subscription = stream.listen(\n        (data) {\n          _controller.add(data);\n        },\n        onDone: _done,\n        onError: _done,\n        cancelOnError: true);\n    if (_issuedPause) {\n      _subscription.pause();\n      _issuedPause = false;\n    }\n    return _completer.future;\n  }\n\n  Future close() {\n    _ensureController();\n    Future closeSocket() {\n      return socket.close().catchError((_) {}).then((_) => webSocket);\n    }\n    _controller.close();\n    return _closeCompleter.future.then((_) => closeSocket());\n  }\n\n  void add(data) {\n    if (_closed) return;\n    _ensureController();\n    _controller.add(data);\n  }\n\n  void closeSocket() {\n    _closed = true;\n    _cancel();\n    close();\n  }\n}\n\n\nclass _WebSocketImpl extends Stream with _ServiceObject implements WebSocket {\n  // Use default Map so we keep order.\n  static Map<int, _WebSocketImpl> _webSockets = new Map<int, _WebSocketImpl>();\n\n  final String protocol;\n\n  StreamController _controller;\n  StreamSubscription _subscription;\n  StreamSink _sink;\n\n  final _socket;\n  final bool _serverSide;\n  int _readyState = WebSocket.CONNECTING;\n  bool _writeClosed = false;\n  int _closeCode;\n  String _closeReason;\n  Duration _pingInterval;\n  Timer _pingTimer;\n  _WebSocketConsumer _consumer;\n\n  int _outCloseCode;\n  String _outCloseReason;\n  Timer _closeTimer;\n\n  static final HttpClient _httpClient = new HttpClient();\n\n  static Future<WebSocket> connect(String url, List<String> protocols) {\n    Uri uri = Uri.parse(url);\n    if (uri.scheme != \"ws\" && uri.scheme != \"wss\") {\n      throw new WebSocketException(\"Unsupported URL scheme '${uri.scheme}'\");\n    }\n    if (uri.userInfo != \"\") {\n      throw new WebSocketException(\"Unsupported user info '${uri.userInfo}'\");\n    }\n\n    Random random = new Random();\n    // Generate 16 random bytes.\n    Uint8List nonceData = new Uint8List(16);\n    for (int i = 0; i < 16; i++) {\n      nonceData[i] = random.nextInt(256);\n    }\n    String nonce = _CryptoUtils.bytesToBase64(nonceData);\n\n    uri = new Uri(scheme: uri.scheme == \"wss\" ? \"https\" : \"http\",\n                  userInfo: uri.userInfo,\n                  host: uri.host,\n                  port: uri.port,\n                  path: uri.path,\n                  query: uri.query,\n                  fragment: uri.fragment);\n    return _httpClient.openUrl(\"GET\", uri)\n      .then((request) {\n        // Setup the initial handshake.\n        request.headers\n            ..add(HttpHeaders.CONNECTION, \"Upgrade\")\n            ..set(HttpHeaders.UPGRADE, \"websocket\")\n            ..set(\"Sec-WebSocket-Key\", nonce)\n            ..set(\"Cache-Control\", \"no-cache\")\n            ..set(\"Sec-WebSocket-Version\", \"13\");\n        if (protocols.isNotEmpty) {\n          request.headers.add(\"Sec-WebSocket-Protocol\", protocols);\n        }\n        return request.close();\n      })\n      .then((response) {\n        void error(String message) {\n          // Flush data.\n          response.detachSocket().then((socket) {\n            socket.destroy();\n          });\n          throw new WebSocketException(message);\n        }\n        if (response.statusCode != HttpStatus.SWITCHING_PROTOCOLS ||\n            response.headers[HttpHeaders.CONNECTION] == null ||\n            !response.headers[HttpHeaders.CONNECTION].any(\n                (value) => value.toLowerCase() == \"upgrade\") ||\n            response.headers.value(HttpHeaders.UPGRADE).toLowerCase() !=\n                \"websocket\") {\n          error(\"Connection to '$uri' was not upgraded to websocket\");\n        }\n        String accept = response.headers.value(\"Sec-WebSocket-Accept\");\n        if (accept == null) {\n          error(\"Response did not contain a 'Sec-WebSocket-Accept' header\");\n        }\n        _SHA1 sha1 = new _SHA1();\n        sha1.add(\"$nonce$_webSocketGUID\".codeUnits);\n        List<int> expectedAccept = sha1.close();\n        List<int> receivedAccept = _CryptoUtils.base64StringToBytes(accept);\n        if (expectedAccept.length != receivedAccept.length) {\n          error(\"Reasponse header 'Sec-WebSocket-Accept' is the wrong length\");\n        }\n        for (int i = 0; i < expectedAccept.length; i++) {\n          if (expectedAccept[i] != receivedAccept[i]) {\n            error(\"Bad response 'Sec-WebSocket-Accept' header\");\n          }\n        }\n        var protocol = response.headers.value('Sec-WebSocket-Protocol');\n        return response.detachSocket()\n            .then((socket) => new _WebSocketImpl._fromSocket(socket, protocol));\n      });\n  }\n\n  _WebSocketImpl._fromSocket(this._socket, this.protocol,\n                             [this._serverSide = false]) {\n    _consumer = new _WebSocketConsumer(this, _socket);\n    _sink = new _StreamSinkImpl(_consumer);\n    _readyState = WebSocket.OPEN;\n\n    var transformer = new _WebSocketProtocolTransformer(_serverSide);\n    _subscription = _socket.transform(transformer).listen(\n        (data) {\n          if (data is _WebSocketPing) {\n            if (!_writeClosed) _consumer.add(new _WebSocketPong(data.payload));\n          } else if (data is _WebSocketPong) {\n            // Simply set pingInterval, as it'll cancel any timers.\n            pingInterval = _pingInterval;\n          } else {\n            _controller.add(data);\n          }\n        },\n        onError: (error) {\n          if (_closeTimer != null) _closeTimer.cancel();\n          if (error is FormatException) {\n            _close(WebSocketStatus.INVALID_FRAME_PAYLOAD_DATA);\n          } else {\n            _close(WebSocketStatus.PROTOCOL_ERROR);\n          }\n          // An error happened, set the close code set above.\n          _closeCode = _outCloseCode;\n          _closeReason = _outCloseReason;\n          _controller.close();\n        },\n        onDone: () {\n          if (_closeTimer != null) _closeTimer.cancel();\n          if (_readyState == WebSocket.OPEN) {\n            _readyState = WebSocket.CLOSING;\n            if (!_isReservedStatusCode(transformer.closeCode)) {\n              _close(transformer.closeCode);\n            } else {\n              _close();\n            }\n            _readyState = WebSocket.CLOSED;\n          }\n          // Protocol close, use close code from transformer.\n          _closeCode = transformer.closeCode;\n          _closeReason = transformer.closeReason;\n          _controller.close();\n        },\n        cancelOnError: true);\n    _subscription.pause();\n    _controller = new StreamController(sync: true,\n                                       onListen: _subscription.resume,\n                                       onPause: _subscription.pause,\n                                       onResume: _subscription.resume);\n\n    _webSockets[_serviceId] = this;\n    try { _socket._owner = this; } catch (_) {}\n  }\n\n  StreamSubscription listen(void onData(message),\n                            {Function onError,\n                             void onDone(),\n                             bool cancelOnError}) {\n    return _controller.stream.listen(onData,\n                                     onError: onError,\n                                     onDone: onDone,\n                                     cancelOnError: cancelOnError);\n  }\n\n  Duration get pingInterval => _pingInterval;\n\n  void set pingInterval(Duration interval) {\n    if (_writeClosed) return;\n    if (_pingTimer != null) _pingTimer.cancel();\n    _pingInterval = interval;\n\n    if (_pingInterval == null) return;\n\n    _pingTimer = new Timer(_pingInterval, () {\n      if (_writeClosed) return;\n      _consumer.add(new _WebSocketPing());\n      _pingTimer = new Timer(_pingInterval, () {\n        // No pong received.\n        _close(WebSocketStatus.GOING_AWAY);\n      });\n    });\n  }\n\n  int get readyState => _readyState;\n\n  String get extensions => null;\n  int get closeCode => _closeCode;\n  String get closeReason => _closeReason;\n\n  void add(data) => _sink.add(data);\n  void addError(error, [StackTrace stackTrace]) =>\n      _sink.addError(error, stackTrace);\n  Future addStream(Stream stream) => _sink.addStream(stream);\n  Future get done => _sink.done;\n\n  Future close([int code, String reason]) {\n    if (_isReservedStatusCode(code)) {\n      throw new WebSocketException(\"Reserved status code $code\");\n    }\n    if (_outCloseCode == null) {\n      _outCloseCode = code;\n      _outCloseReason = reason;\n    }\n    if (_closeTimer == null && !_controller.isClosed) {\n      // When closing the web-socket, we no longer accept data.\n      _closeTimer = new Timer(const Duration(seconds: 5), () {\n        // Reuse code and reason from the local close.\n        _closeCode = _outCloseCode;\n        _closeReason = _outCloseReason;\n        _subscription.cancel();\n        _controller.close();\n        _webSockets.remove(_serviceId);\n      });\n    }\n    return _sink.close();\n  }\n\n  void _close([int code, String reason]) {\n    if (_writeClosed) return;\n    if (_outCloseCode == null) {\n      _outCloseCode = code;\n      _outCloseReason = reason;\n    }\n    _writeClosed = true;\n    _consumer.closeSocket();\n    _webSockets.remove(_serviceId);\n  }\n\n  String get _serviceTypePath => 'io/websockets';\n  String get _serviceTypeName => 'WebSocket';\n\n  Map _toJSON(bool ref) {\n    var name = '${_socket.address.host}:${_socket.port}';\n    var r = {\n      'id': _servicePath,\n      'type': _serviceType(ref),\n      'name': name,\n      'user_name': name,\n    };\n    if (ref) {\n      return r;\n    }\n    try {\n      r['socket'] = _socket._toJSON(true);\n    } catch (_) {\n      r['socket'] = {\n        'id': _servicePath,\n        'type': '@Socket',\n        'name': 'UserSocket',\n        'user_name': 'UserSocket',\n      };\n    }\n    return r;\n  }\n\n  static bool _isReservedStatusCode(int code) {\n    return code != null &&\n           (code < WebSocketStatus.NORMAL_CLOSURE ||\n            code == WebSocketStatus.RESERVED_1004 ||\n            code == WebSocketStatus.NO_STATUS_RECEIVED ||\n            code == WebSocketStatus.ABNORMAL_CLOSURE ||\n            (code > WebSocketStatus.INTERNAL_SERVER_ERROR &&\n             code < WebSocketStatus.RESERVED_1015) ||\n            (code >= WebSocketStatus.RESERVED_1015 &&\n             code < 3000));\n  }\n}\n\u0000","sdk:/sdk/lib/io/websocket.dart":"// Copyright (c) 2013, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\npart of dart.io;\n\n/**\n * Web socket status codes used when closing a web socket connection.\n */\nabstract class WebSocketStatus {\n  static const int NORMAL_CLOSURE = 1000;\n  static const int GOING_AWAY = 1001;\n  static const int PROTOCOL_ERROR = 1002;\n  static const int UNSUPPORTED_DATA = 1003;\n  static const int RESERVED_1004  = 1004;\n  static const int NO_STATUS_RECEIVED = 1005;\n  static const int ABNORMAL_CLOSURE = 1006;\n  static const int INVALID_FRAME_PAYLOAD_DATA = 1007;\n  static const int POLICY_VIOLATION = 1008;\n  static const int MESSAGE_TOO_BIG = 1009;\n  static const int MISSING_MANDATORY_EXTENSION = 1010;\n  static const int INTERNAL_SERVER_ERROR = 1011;\n  static const int RESERVED_1015 = 1015;\n}\n\n/**\n * The [WebSocketTransformer] provides the ability to upgrade a\n * [HttpRequest] to a [WebSocket] connection. It supports both\n * upgrading a single [HttpRequest] and upgrading a stream of\n * [HttpRequest]s.\n *\n * To upgrade a single [HttpRequest] use the static [upgrade] method.\n *\n *     HttpServer server;\n *     server.listen((request) {\n *       if (...) {\n *         WebSocketTransformer.upgrade(request).then((websocket) {\n *           ...\n *         });\n *       } else {\n *         // Do normal HTTP request processing.\n *       }\n *     });\n *\n * To transform a stream of [HttpRequest] events as it implements a\n * stream transformer that transforms a stream of HttpRequest into a\n * stream of WebSockets by upgrading each HttpRequest from the HTTP or\n * HTTPS server, to the WebSocket protocol.\n *\n *     server.transform(new WebSocketTransformer()).listen((webSocket) => ...);\n *\n * This transformer strives to implement web sockets as specified by RFC6455.\n */\nabstract class WebSocketTransformer\n    implements StreamTransformer<HttpRequest, WebSocket> {\n\n  /**\n   * Create a new [WebSocketTransformer].\n   *\n   * If [protocolSelector] is provided, [protocolSelector] will be called to\n   * select what protocol to use, if any were provided by the client.\n   * [protocolSelector] is should return either a [String] or a [Future]\n   * completing with a [String]. The [String] must exist in the list of\n   * protocols.\n   */\n  factory WebSocketTransformer({protocolSelector(List<String> protocols)})\n      => new _WebSocketTransformerImpl(protocolSelector);\n\n  /**\n   * Upgrades a [HttpRequest] to a [WebSocket] connection. If the\n   * request is not a valid web socket upgrade request a HTTP response\n   * with status code 500 will be returned. Otherwise the returned\n   * future will complete with the [WebSocket] when the upgrade pocess\n   * is complete.\n   *\n   * If [protocolSelector] is provided, [protocolSelector] will be called to\n   * select what protocol to use, if any were provided by the client.\n   * [protocolSelector] is should return either a [String] or a [Future]\n   * completing with a [String]. The [String] must exist in the list of\n   * protocols.\n   */\n  static Future<WebSocket> upgrade(HttpRequest request,\n                                   {protocolSelector(List<String> protocols)}) {\n    return _WebSocketTransformerImpl._upgrade(request, protocolSelector);\n  }\n\n  /**\n   * Checks whether the request is a valid WebSocket upgrade request.\n   */\n  static bool isUpgradeRequest(HttpRequest request) {\n    return _WebSocketTransformerImpl._isUpgradeRequest(request);\n  }\n}\n\n\n/**\n * A two-way HTTP communication object for client or server applications.\n *\n * The stream exposes the messages received. A text message will be of type\n * [:String:] and a binary message will be of type [:List<int>:].\n */\nabstract class WebSocket implements Stream, StreamSink {\n  /**\n   * Possible states of the connection.\n   */\n  static const int CONNECTING = 0;\n  static const int OPEN = 1;\n  static const int CLOSING = 2;\n  static const int CLOSED = 3;\n\n  /**\n   * Set and get the interval for sending ping signals. If a ping message is not\n   * answered by a pong message from the peer, the `WebSocket` is assumed\n   * disconnected and the connection is closed with a\n   * [WebSocketStatus.GOING_AWAY] close code. When a ping signal is sent, the\n   * pong message must be received within [pingInterval].\n   *\n   * There are never two outstanding pings at any given time, and the next ping\n   * timer starts when the pong is received.\n   *\n   * Set the [pingInterval] to `null` to disable sending ping messages.\n   *\n   * The default value is `null`.\n   */\n  Duration pingInterval;\n\n  /**\n   * Create a new web socket connection. The URL supplied in [url]\n   * must use the scheme [:ws:] or [:wss:]. The [protocols] argument is\n   * specifying the subprotocols the client is willing to speak.\n   */\n  static Future<WebSocket> connect(String url,\n                                   {List<String> protocols: const []}) =>\n      _WebSocketImpl.connect(url, protocols);\n\n  @Deprecated('This constructor will be removed in Dart 2.0. Use `implements`'\n      ' instead of `extends` if implementing this abstract class.')\n  WebSocket();\n\n  /**\n   * Creates a WebSocket from an already-upgraded socket.\n   *\n   * The initial WebSocket handshake must have occurred prior to this call. A\n   * WebSocket client can automatically perform the handshake using\n   * [WebSocket.connect], while a server can do so using\n   * [WebSocketTransformer.upgrade]. To manually upgrade an [HttpRequest],\n   * [HttpRequest.detachSocket] may be called.\n   *\n   * [protocol] should be the protocol negotiated by this handshake, if any.\n   *\n   * [serverSide] must be passed explicitly. If it's `false`, the WebSocket will\n   * act as the client and mask the messages it sends. If it's `true`, it will\n   * act as the server and will not mask its messages.\n   */\n  factory WebSocket.fromUpgradedSocket(Socket socket, {String protocol,\n        bool serverSide}) {\n    if (serverSide == null) {\n      throw new ArgumentError(\"The serverSide argument must be passed \"\n          \"explicitly to WebSocket.fromUpgradedSocket.\");\n    }\n    return new _WebSocketImpl._fromSocket(socket, protocol, serverSide);\n  }\n\n  /**\n   * Returns the current state of the connection.\n   */\n  int get readyState;\n\n  /**\n   * The extensions property is initially the empty string. After the\n   * web socket connection is established this string reflects the\n   * extensions used by the server.\n   */\n  String get extensions;\n\n  /**\n   * The protocol property is initially the empty string. After the\n   * web socket connection is established the value is the subprotocol\n   * selected by the server. If no subprotocol is negotiated the\n   * value will remain [:null:].\n   */\n  String get protocol;\n\n  /**\n   * The close code set when the web socket connection is closed. If\n   * there is no close code available this property will be [:null:]\n   */\n  int get closeCode;\n\n  /**\n   * The close reason set when the web socket connection is closed. If\n   * there is no close reason available this property will be [:null:]\n   */\n  String get closeReason;\n\n  /**\n   * Closes the web socket connection. Set the optional [code] and [reason]\n   * arguments to send close information to the remote peer. If they are\n   * omitted, the peer will see [WebSocketStatus.NO_STATUS_RECEIVED] code\n   * with no reason.\n   */\n  Future close([int code, String reason]);\n\n  /**\n   * Sends data on the web socket connection. The data in [data] must\n   * be either a [:String:], or a [:List<int>:] holding bytes.\n   */\n  void add(data);\n\n  /**\n   * Sends data from a stream on web socket connection. Each data event from\n   * [stream] will be send as a single WebSocket frame. The data from [stream]\n   * must be either [:String:]s, or [:List<int>:]s holding bytes.\n   */\n  Future addStream(Stream stream);\n}\n\n\nclass WebSocketException implements IOException {\n  final String message;\n  const WebSocketException([this.message = \"\"]);\n  String toString() => \"WebSocketException: $message\";\n}\n\u0000","sdk:/sdk/lib/io/secure_server_socket.dart":"// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\npart of dart.io;\n\n/**\n * The [SecureServerSocket] is a server socket, providing a stream of high-level\n * [Socket]s.\n *\n * See [SecureSocket] for more info.\n */\nclass SecureServerSocket extends Stream<SecureSocket> {\n  final RawSecureServerSocket _socket;\n\n  SecureServerSocket._(this._socket);\n\n  /**\n   * Returns a future for a [SecureServerSocket]. When the future\n   * completes the server socket is bound to the given [address] and\n   * [port] and has started listening on it.\n   *\n   * The [address] can either be a [String] or an\n   * [InternetAddress]. If [address] is a [String], [bind] will\n   * perform a [InternetAddress.lookup] and use the first value in the\n   * list. To listen on the loopback adapter, which will allow only\n   * incoming connections from the local host, use the value\n   * [InternetAddress.LOOPBACK_IP_V4] or\n   * [InternetAddress.LOOPBACK_IP_V6]. To allow for incoming\n   * connection from the network use either one of the values\n   * [InternetAddress.ANY_IP_V4] or [InternetAddress.ANY_IP_V6] to\n   * bind to all interfaces or the IP address of a specific interface.\n   *\n   * If [port] has the value [:0:] an ephemeral port will be chosen by\n   * the system. The actual port used can be retrieved using the\n   * [port] getter.\n   *\n   * The optional argument [backlog] can be used to specify the listen\n   * backlog for the underlying OS listen setup. If [backlog] has the\n   * value of [:0:] (the default) a reasonable value will be chosen by\n   * the system.\n   *\n   * Incoming client connections are promoted to secure connections, using\n   * the server certificate given by [certificateName].\n   *\n   * [address] must be given as a numeric address, not a host name.\n   *\n   * [certificateName] is the nickname or the distinguished name (DN) of\n   * the certificate in the certificate database. It is looked up in the\n   * NSS certificate database set by SecureSocket.setCertificateDatabase.\n   * If [certificateName] contains \"CN=\", it is assumed to be a distinguished\n   * name.  Otherwise, it is looked up as a nickname.\n   *\n   * To request or require that clients authenticate by providing an SSL (TLS)\n   * client certificate, set the optional parameter [requestClientCertificate]\n   * or [requireClientCertificate] to true.  Requiring a certificate implies\n   * requesting a certificate, so one doesn't need to set both to true.\n   * To check whether a client certificate was received, check\n   * SecureSocket.peerCertificate after connecting.  If no certificate\n   * was received, the result will be null.\n   */\n  static Future<SecureServerSocket> bind(\n      address,\n      int port,\n      String certificateName,\n      {int backlog: 0,\n       bool v6Only: false,\n       bool requestClientCertificate: false,\n       bool requireClientCertificate: false}) {\n    return RawSecureServerSocket.bind(\n        address,\n        port,\n        certificateName,\n        backlog: backlog,\n        v6Only: v6Only,\n        requestClientCertificate: requestClientCertificate,\n        requireClientCertificate: requireClientCertificate).then(\n            (serverSocket) => new SecureServerSocket._(serverSocket));\n  }\n\n  StreamSubscription<SecureSocket> listen(void onData(SecureSocket socket),\n                                          {Function onError,\n                                           void onDone(),\n                                           bool cancelOnError}) {\n    return _socket.map((rawSocket) => new SecureSocket._(rawSocket))\n                  .listen(onData,\n                          onError: onError,\n                          onDone: onDone,\n                          cancelOnError: cancelOnError);\n  }\n\n  /**\n   * Returns the port used by this socket.\n   */\n  int get port => _socket.port;\n\n  /**\n   * Returns the address used by this socket.\n   */\n  InternetAddress get address => _socket.address;\n\n  /**\n   * Closes the socket. The returned future completes when the socket\n   * is fully closed and is no longer bound.\n   */\n  Future<SecureServerSocket> close() => _socket.close().then((_) => this);\n\n  void set _owner(owner) { _socket._owner = owner; }\n}\n\n\n/**\n * The RawSecureServerSocket is a server socket, providing a stream of low-level\n * [RawSecureSocket]s.\n *\n * See [RawSecureSocket] for more info.\n */\nclass RawSecureServerSocket extends Stream<RawSecureSocket> {\n  RawServerSocket _socket;\n  StreamController<RawSecureSocket> _controller;\n  StreamSubscription<RawSocket> _subscription;\n  final String certificateName;\n  final bool requestClientCertificate;\n  final bool requireClientCertificate;\n  bool _closed = false;\n\n  RawSecureServerSocket._(RawServerSocket serverSocket,\n                          this.certificateName,\n                          this.requestClientCertificate,\n                          this.requireClientCertificate) {\n    _socket = serverSocket;\n    _controller = new StreamController<RawSecureSocket>(\n        sync: true,\n        onListen: _onSubscriptionStateChange,\n        onPause: _onPauseStateChange,\n        onResume: _onPauseStateChange,\n        onCancel: _onSubscriptionStateChange);\n  }\n\n  /**\n   * Returns a future for a [RawSecureServerSocket]. When the future\n   * completes the server socket is bound to the given [address] and\n   * [port] and has started listening on it.\n   *\n   * The [address] can either be a [String] or an\n   * [InternetAddress]. If [address] is a [String], [bind] will\n   * perform a [InternetAddress.lookup] and use the first value in the\n   * list. To listen on the loopback adapter, which will allow only\n   * incoming connections from the local host, use the value\n   * [InternetAddress.LOOPBACK_IP_V4] or\n   * [InternetAddress.LOOPBACK_IP_V6]. To allow for incoming\n   * connection from the network use either one of the values\n   * [InternetAddress.ANY_IP_V4] or [InternetAddress.ANY_IP_V6] to\n   * bind to all interfaces or the IP address of a specific interface.\n   *\n   * If [port] has the value [:0:] an ephemeral port will be chosen by\n   * the system. The actual port used can be retrieved using the\n   * [port] getter.\n   *\n   * The optional argument [backlog] can be used to specify the listen\n   * backlog for the underlying OS listen setup. If [backlog] has the\n   * value of [:0:] (the default) a reasonable value will be chosen by\n   * the system.\n   *\n   * Incoming client connections are promoted to secure connections,\n   * using the server certificate given by [certificateName].\n   *\n   * [address] must be given as a numeric address, not a host name.\n   *\n   * [certificateName] is the nickname or the distinguished name (DN) of\n   * the certificate in the certificate database. It is looked up in the\n   * NSS certificate database set by SecureSocket.setCertificateDatabase.\n   * If [certificateName] contains \"CN=\", it is assumed to be a distinguished\n   * name.  Otherwise, it is looked up as a nickname.\n   *\n   * To request or require that clients authenticate by providing an SSL (TLS)\n   * client certificate, set the optional parameters requestClientCertificate or\n   * requireClientCertificate to true.  Require implies request, so one doesn't\n   * need to specify both.  To check whether a client certificate was received,\n   * check SecureSocket.peerCertificate after connecting.  If no certificate\n   * was received, the result will be null.\n   */\n  static Future<RawSecureServerSocket> bind(\n      address,\n      int port,\n      String certificateName,\n      {int backlog: 0,\n       bool v6Only: false,\n       bool requestClientCertificate: false,\n       bool requireClientCertificate: false}) {\n    return RawServerSocket.bind(address, port, backlog: backlog, v6Only: v6Only)\n        .then((serverSocket) => new RawSecureServerSocket._(\n            serverSocket,\n            certificateName,\n            requestClientCertificate,\n            requireClientCertificate));\n  }\n\n  StreamSubscription<RawSecureSocket> listen(void onData(RawSecureSocket s),\n                                             {Function onError,\n                                              void onDone(),\n                                              bool cancelOnError}) {\n    return _controller.stream.listen(onData,\n                                     onError: onError,\n                                     onDone: onDone,\n                                     cancelOnError: cancelOnError);\n  }\n\n  /**\n   * Returns the port used by this socket.\n   */\n  int get port => _socket.port;\n\n  /**\n   * Returns the address used by this socket.\n   */\n  InternetAddress get address => _socket.address;\n\n  /**\n   * Closes the socket. The returned future completes when the socket\n   * is fully closed and is no longer bound.\n   */\n  Future<RawSecureServerSocket> close() {\n    _closed = true;\n    return _socket.close().then((_) => this);\n  }\n\n  void _onData(RawSocket connection) {\n    var remotePort;\n    try {\n      remotePort = connection.remotePort;\n    } catch (e) {\n      // If connection is already closed, remotePort throws an exception.\n      // Do nothing - connection is closed.\n      return;\n    }\n    _RawSecureSocket.connect(\n        connection.address,\n        remotePort,\n        certificateName,\n        is_server: true,\n        socket: connection,\n        requestClientCertificate: requestClientCertificate,\n        requireClientCertificate: requireClientCertificate)\n    .then((RawSecureSocket secureConnection) {\n      if (_closed) {\n        secureConnection.close();\n      } else {\n        _controller.add(secureConnection);\n      }\n    }).catchError((e) {\n      if (!_closed) {\n        _controller.addError(e);\n      }\n    });\n  }\n\n  void _onError(e, [StackTrace stackTrace]) {\n    _controller.addError(e, stackTrace);\n  }\n\n  void _onDone() {\n    _controller.close();\n  }\n\n  void _onPauseStateChange() {\n    if (_controller.isPaused) {\n      _subscription.pause();\n    } else {\n      _subscription.resume();\n    }\n  }\n\n  void _onSubscriptionStateChange() {\n    if (_controller.hasListener) {\n      _subscription = _socket.listen(_onData,\n                                     onDone: _onDone,\n                                     onError: _onError);\n    } else {\n      close();\n    }\n  }\n\n  void set _owner(owner) { (_socket as dynamic)._owner = owner; }\n}\n\n\n\u0000","sdk:/sdk/lib/io/secure_socket.dart":"// Copyright (c) 2013, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\npart of dart.io;\n\n/**\n * A high-level class for communicating securely over a TCP socket, using\n * TLS and SSL. The [SecureSocket] exposes both a [Stream] and an\n * [IOSink] interface, making it ideal for using together with\n * other [Stream]s.\n */\nabstract class SecureSocket implements Socket {\n  external factory SecureSocket._(RawSecureSocket rawSocket);\n\n  /**\n   * Constructs a new secure client socket and connect it to the given\n   * [host] on port [port]. The returned Future will complete with a\n   * [SecureSocket] that is connected and ready for subscription.\n   *\n   * If [sendClientCertificate] is set to true, the socket will send a client\n   * certificate if one is requested by the server.\n   *\n   * If [certificateName] is the nickname of a certificate in the certificate\n   * database, that certificate will be sent.\n   *\n   * If [certificateName] is null, which is the usual use case, an\n   * appropriate certificate will be searched for in the database and\n   * sent automatically, based on what the server says it will accept.\n   *\n   * [onBadCertificate] is an optional handler for unverifiable certificates.\n   * The handler receives the [X509Certificate], and can inspect it and\n   * decide (or let the user decide) whether to accept\n   * the connection or not.  The handler should return true\n   * to continue the [SecureSocket] connection.\n   */\n  static Future<SecureSocket> connect(\n      host,\n      int port,\n      {bool sendClientCertificate: false,\n       String certificateName,\n       bool onBadCertificate(X509Certificate certificate)}) {\n    return RawSecureSocket.connect(host,\n                                   port,\n                                   sendClientCertificate: sendClientCertificate,\n                                   certificateName: certificateName,\n                                   onBadCertificate: onBadCertificate)\n        .then((rawSocket) => new SecureSocket._(rawSocket));\n  }\n\n  /**\n   * Takes an already connected [socket] and starts client side TLS\n   * handshake to make the communication secure. When the returned\n   * future completes the [SecureSocket] has completed the TLS\n   * handshake. Using this function requires that the other end of the\n   * connection is prepared for TLS handshake.\n   *\n   * If the [socket] already has a subscription, this subscription\n   * will no longer receive and events. In most cases calling\n   * `pause` on this subscription before starting TLS handshake is\n   * the right thing to do.\n   *\n   * If the [host] argument is passed it will be used as the host name\n   * for the TLS handshake. If [host] is not passed the host name from\n   * the [socket] will be used. The [host] can be either a [String] or\n   * an [InternetAddress].\n   *\n   * Calling this function will _not_ cause a DNS host lookup. If the\n   * [host] passed is a [String] the [InternetAddress] for the\n   * resulting [SecureSocket] will have the passed in [host] as its\n   * host value and the internet address of the already connected\n   * socket as its address value.\n   *\n   * See [connect] for more information on the arguments.\n   *\n   */\n  static Future<SecureSocket> secure(\n      Socket socket,\n      {host,\n       bool sendClientCertificate: false,\n       String certificateName,\n       bool onBadCertificate(X509Certificate certificate)}) {\n    var completer = new Completer();\n    (socket as dynamic)._detachRaw()\n        .then((detachedRaw) {\n          return RawSecureSocket.secure(\n            detachedRaw[0],\n            subscription: detachedRaw[1],\n            host: host,\n            sendClientCertificate: sendClientCertificate,\n            onBadCertificate: onBadCertificate);\n          })\n        .then((raw) {\n          completer.complete(new SecureSocket._(raw));\n        });\n    return completer.future;\n  }\n\n  /**\n   * Takes an already connected [socket] and starts server side TLS\n   * handshake to make the communication secure. When the returned\n   * future completes the [SecureSocket] has completed the TLS\n   * handshake. Using this function requires that the other end of the\n   * connection is going to start the TLS handshake.\n   *\n   * If the [socket] already has a subscription, this subscription\n   * will no longer receive and events. In most cases calling\n   * [:pause:] on this subscription before starting TLS handshake is\n   * the right thing to do.\n   *\n   * If some of the data of the TLS handshake has already been read\n   * from the socket this data can be passed in the [bufferedData]\n   * parameter. This data will be processed before any other data\n   * available on the socket.\n   *\n   * See [SecureServerSocket.bind] for more information on the\n   * arguments.\n   *\n   */\n  static Future<SecureSocket> secureServer(\n      Socket socket,\n      String certificateName,\n      {List<int> bufferedData,\n       bool requestClientCertificate: false,\n       bool requireClientCertificate: false}) {\n    var completer = new Completer();\n    (socket as dynamic)._detachRaw()\n        .then((detachedRaw) {\n          return RawSecureSocket.secureServer(\n            detachedRaw[0],\n            certificateName,\n            subscription: detachedRaw[1],\n            bufferedData: bufferedData,\n            requestClientCertificate: requestClientCertificate,\n            requireClientCertificate: requireClientCertificate);\n          })\n        .then((raw) {\n          completer.complete(new SecureSocket._(raw));\n        });\n    return completer.future;\n  }\n\n  /**\n   * Get the peer certificate for a connected SecureSocket.  If this\n   * SecureSocket is the server end of a secure socket connection,\n   * [peerCertificate] will return the client certificate, or null, if no\n   * client certificate was received.  If it is the client end,\n   * [peerCertificate] will return the server's certificate.\n   */\n  X509Certificate get peerCertificate;\n\n  /**\n   * Renegotiate an existing secure connection, renewing the session keys\n   * and possibly changing the connection properties.\n   *\n   * This repeats the SSL or TLS handshake, with options that allow clearing\n   * the session cache and requesting a client certificate.\n   */\n  void renegotiate({bool useSessionCache: true,\n                    bool requestClientCertificate: false,\n                    bool requireClientCertificate: false});\n\n  /**\n   * Initializes the NSS library. If [initialize] is not called, the library\n   * is automatically initialized as if [initialize] were called with no\n   * arguments. If [initialize] is called more than once, or called after\n   * automatic initialization has happened (when a secure connection is made),\n   * then a TlsException is thrown.\n   *\n   * The optional argument [database] is the path to a certificate database\n   * directory containing root certificates for verifying certificate paths on\n   * client connections, and server certificates to provide on server\n   * connections. The argument [password] should be used when creating\n   * secure server sockets, to allow the private key of the server\n   * certificate to be fetched. If [useBuiltinRoots] is true (the default),\n   * then a built-in set of root certificates for trusted certificate\n   * authorities is merged with the certificates in the database.\n   * The list of built-in root certificates, and documentation about this\n   * default database, is available at\n   * http://www.mozilla.org/projects/security/certs/included/ .\n   *\n   * If the [database] argument is omitted, then only the\n   * builtin root certificates are used. If [useBuiltinRoots] is also false,\n   * then no certificates are available.\n   *\n   * Examples:\n   *   1) Use only the builtin root certificates:\n   *     SecureSocket.initialize(); or\n   *\n   *   2) Use a specified database directory and the builtin roots:\n   *     SecureSocket.initialize(database: 'path/to/my/database',\n   *                             password: 'my_password');\n   *\n   *   3) Use a specified database directory, without builtin roots:\n   *     SecureSocket.initialize(database: 'path/to/my/database',\n   *                             password: 'my_password'.\n   *                             useBuiltinRoots: false);\n   *\n   * The database should be an NSS certificate database directory\n   * containing a cert9.db file, not a cert8.db file.  This version of\n   * the database can be created using the NSS certutil tool with \"sql:\" in\n   * front of the absolute path of the database directory, or setting the\n   * environment variable [[NSS_DEFAULT_DB_TYPE]] to \"sql\".\n   */\n  external static void initialize({String database,\n                                   String password,\n                                   bool useBuiltinRoots: true});\n}\n\n\n/**\n * RawSecureSocket provides a secure (SSL or TLS) network connection.\n * Client connections to a server are provided by calling\n * RawSecureSocket.connect.  A secure server, created with\n * RawSecureServerSocket, also returns RawSecureSocket objects representing\n * the server end of a secure connection.\n * The certificate provided by the server is checked\n * using the certificate database provided in SecureSocket.initialize, and/or\n * the default built-in root certificates.\n */\nabstract class RawSecureSocket implements RawSocket {\n  /**\n   * Constructs a new secure client socket and connect it to the given\n   * host on the given port. The returned Future is completed with the\n   * RawSecureSocket when it is connected and ready for subscription.\n   *\n   * The certificate provided by the server is checked using the certificate\n   * database provided in [SecureSocket.initialize], and/or the default built-in\n   * root certificates. If [sendClientCertificate] is\n   * set to true, the socket will send a client certificate if one is\n   * requested by the server. If [certificateName] is the nickname of\n   * a certificate in the certificate database, that certificate will be sent.\n   * If [certificateName] is null, which is the usual use case, an\n   * appropriate certificate will be searched for in the database and\n   * sent automatically, based on what the server says it will accept.\n   *\n   * [onBadCertificate] is an optional handler for unverifiable certificates.\n   * The handler receives the [X509Certificate], and can inspect it and\n   * decide (or let the user decide) whether to accept\n   * the connection or not.  The handler should return true\n   * to continue the [RawSecureSocket] connection.\n   */\n  static Future<RawSecureSocket> connect(\n      host,\n      int port,\n      {bool sendClientCertificate: false,\n       String certificateName,\n       bool onBadCertificate(X509Certificate certificate)}) {\n    _RawSecureSocket._verifyFields(\n        host,\n        port,\n        certificateName,\n        false,\n        false,\n        false,\n        sendClientCertificate,\n        onBadCertificate);\n    return RawSocket.connect(host, port)\n        .then((socket) {\n          return secure(socket,\n                        sendClientCertificate: sendClientCertificate,\n                        certificateName: certificateName,\n                        onBadCertificate: onBadCertificate);\n        });\n  }\n\n  /**\n   * Takes an already connected [socket] and starts client side TLS\n   * handshake to make the communication secure. When the returned\n   * future completes the [RawSecureSocket] has completed the TLS\n   * handshake. Using this function requires that the other end of the\n   * connection is prepared for TLS handshake.\n   *\n   * If the [socket] already has a subscription, pass the existing\n   * subscription in the [subscription] parameter. The [secure]\n   * operation will take over the subscription by replacing the\n   * handlers with it own secure processing. The caller must not touch\n   * this subscription anymore. Passing a paused subscription is an\n   * error.\n   *\n   * If the [host] argument is passed it will be used as the host name\n   * for the TLS handshake. If [host] is not passed the host name from\n   * the [socket] will be used. The [host] can be either a [String] or\n   * an [InternetAddress].\n   *\n   * Calling this function will _not_ cause a DNS host lookup. If the\n   * [host] passed is a [String] the [InternetAddress] for the\n   * resulting [SecureSocket] will have this passed in [host] as its\n   * host value and the internet address of the already connected\n   * socket as its address value.\n   *\n   * See [connect] for more information on the arguments.\n   *\n   */\n  static Future<RawSecureSocket> secure(\n      RawSocket socket,\n      {StreamSubscription subscription,\n       host,\n       bool sendClientCertificate: false,\n       String certificateName,\n       bool onBadCertificate(X509Certificate certificate)}) {\n    socket.readEventsEnabled = false;\n    socket.writeEventsEnabled = false;\n    return  _RawSecureSocket.connect(\n        host != null ? host : socket.address.host,\n        socket.port,\n        certificateName,\n        is_server: false,\n        socket: socket,\n        subscription: subscription,\n        sendClientCertificate: sendClientCertificate,\n        onBadCertificate: onBadCertificate);\n  }\n\n  /**\n   * Takes an already connected [socket] and starts server side TLS\n   * handshake to make the communication secure. When the returned\n   * future completes the [RawSecureSocket] has completed the TLS\n   * handshake. Using this function requires that the other end of the\n   * connection is going to start the TLS handshake.\n   *\n   * If the [socket] already has a subscription, pass the existing\n   * subscription in the [subscription] parameter. The [secureServer]\n   * operation will take over the subscription by replacing the\n   * handlers with it own secure processing. The caller must not touch\n   * this subscription anymore. Passing a paused subscription is an\n   * error.\n   *\n   * If some of the data of the TLS handshake has already been read\n   * from the socket this data can be passed in the [bufferedData]\n   * parameter. This data will be processed before any other data\n   * available on the socket.\n   *\n   * See [RawSecureServerSocket.bind] for more information on the\n   * arguments.\n   *\n   */\n  static Future<RawSecureSocket> secureServer(\n      RawSocket socket,\n      String certificateName,\n      {StreamSubscription subscription,\n       List<int> bufferedData,\n       bool requestClientCertificate: false,\n       bool requireClientCertificate: false}) {\n    socket.readEventsEnabled = false;\n    socket.writeEventsEnabled = false;\n    return _RawSecureSocket.connect(\n        socket.address,\n        socket.remotePort,\n        certificateName,\n        is_server: true,\n        socket: socket,\n        subscription: subscription,\n        bufferedData: bufferedData,\n        requestClientCertificate: requestClientCertificate,\n        requireClientCertificate: requireClientCertificate);\n  }\n\n  /**\n   * Renegotiate an existing secure connection, renewing the session keys\n   * and possibly changing the connection properties.\n   *\n   * This repeats the SSL or TLS handshake, with options that allow clearing\n   * the session cache and requesting a client certificate.\n   */\n  void renegotiate({bool useSessionCache: true,\n                    bool requestClientCertificate: false,\n                    bool requireClientCertificate: false});\n\n  /**\n   * Get the peer certificate for a connected RawSecureSocket.  If this\n   * RawSecureSocket is the server end of a secure socket connection,\n   * [peerCertificate] will return the client certificate, or null, if no\n   * client certificate was received.  If it is the client end,\n   * [peerCertificate] will return the server's certificate.\n   */\n  X509Certificate get peerCertificate;\n}\n\n\n/**\n * X509Certificate represents an SSL certificate, with accessors to\n * get the fields of the certificate.\n */\nclass X509Certificate {\n  X509Certificate(this.subject,\n                  this.issuer,\n                  this.startValidity,\n                  this.endValidity);\n  final String subject;\n  final String issuer;\n  final DateTime startValidity;\n  final DateTime endValidity;\n}\n\n\nclass _FilterStatus {\n  bool progress = false;  // The filter read or wrote data to the buffers.\n  bool readEmpty = true;  // The read buffers and decryption filter are empty.\n  bool writeEmpty = true;  // The write buffers and encryption filter are empty.\n  // These are set if a buffer changes state from empty or full.\n  bool readPlaintextNoLongerEmpty = false;\n  bool writePlaintextNoLongerFull = false;\n  bool readEncryptedNoLongerFull = false;\n  bool writeEncryptedNoLongerEmpty = false;\n\n  _FilterStatus();\n}\n\n\nclass _RawSecureSocket extends Stream<RawSocketEvent>\n                       implements RawSecureSocket {\n  // Status states\n  static final int HANDSHAKE = 201;\n  static final int CONNECTED = 202;\n  static final int CLOSED = 203;\n\n  // Buffer identifiers.\n  // These must agree with those in the native C++ implementation.\n  static final int READ_PLAINTEXT = 0;\n  static final int WRITE_PLAINTEXT = 1;\n  static final int READ_ENCRYPTED = 2;\n  static final int WRITE_ENCRYPTED = 3;\n  static final int NUM_BUFFERS = 4;\n\n  // Is a buffer identifier for an encrypted buffer?\n  static bool _isBufferEncrypted(int identifier) => identifier >= READ_ENCRYPTED;\n\n  RawSocket _socket;\n  final Completer<_RawSecureSocket> _handshakeComplete =\n      new Completer<_RawSecureSocket>();\n  StreamController<RawSocketEvent> _controller;\n  Stream<RawSocketEvent> _stream;\n  StreamSubscription<RawSocketEvent> _socketSubscription;\n  List<int> _bufferedData;\n  int _bufferedDataIndex = 0;\n  final InternetAddress address;\n  final bool is_server;\n  final String certificateName;\n  final bool requestClientCertificate;\n  final bool requireClientCertificate;\n  final bool sendClientCertificate;\n  final Function onBadCertificate;\n\n  var _status = HANDSHAKE;\n  bool _writeEventsEnabled = true;\n  bool _readEventsEnabled = true;\n  int _pauseCount = 0;\n  bool _pendingReadEvent = false;\n  bool _socketClosedRead = false;  // The network socket is closed for reading.\n  bool _socketClosedWrite = false;  // The network socket is closed for writing.\n  bool _closedRead = false;  // The secure socket has fired an onClosed event.\n  bool _closedWrite = false;  // The secure socket has been closed for writing.\n  Completer _closeCompleter = new Completer();  // The network socket is gone.\n  _FilterStatus _filterStatus = new _FilterStatus();\n  bool _connectPending = true;\n  bool _filterPending = false;\n  bool _filterActive = false;\n\n  _SecureFilter _secureFilter = new _SecureFilter();\n  int _filterPointer;\n\n  static Future<_RawSecureSocket> connect(\n      host,\n      int requestedPort,\n      String certificateName,\n      {bool is_server,\n       RawSocket socket,\n       StreamSubscription subscription,\n       List<int> bufferedData,\n       bool requestClientCertificate: false,\n       bool requireClientCertificate: false,\n       bool sendClientCertificate: false,\n       bool onBadCertificate(X509Certificate certificate)}) {\n    _verifyFields(host, requestedPort, certificateName, is_server,\n                 requestClientCertificate, requireClientCertificate,\n                 sendClientCertificate, onBadCertificate);\n    if (host is InternetAddress) host = host.host;\n    var address = socket.address;\n    if (host != null) address =  address._cloneWithNewHost(host);\n    return new _RawSecureSocket(address,\n                                requestedPort,\n                                certificateName,\n                                is_server,\n                                socket,\n                                subscription,\n                                bufferedData,\n                                requestClientCertificate,\n                                requireClientCertificate,\n                                sendClientCertificate,\n                                onBadCertificate)\n        ._handshakeComplete.future;\n  }\n\n  _RawSecureSocket(\n      this.address,\n      int requestedPort,\n      this.certificateName,\n      this.is_server,\n      RawSocket this._socket,\n      this._socketSubscription,\n      this._bufferedData,\n      this.requestClientCertificate,\n      this.requireClientCertificate,\n      this.sendClientCertificate,\n      this.onBadCertificate(X509Certificate certificate)) {\n    _controller = new StreamController<RawSocketEvent>(\n        sync: true,\n        onListen: _onSubscriptionStateChange,\n        onPause: _onPauseStateChange,\n        onResume: _onPauseStateChange,\n        onCancel: _onSubscriptionStateChange);\n    _stream = _controller.stream;\n    // Throw an ArgumentError if any field is invalid.  After this, all\n    // errors will be reported through the future or the stream.\n    _secureFilter.init();\n    _filterPointer = _secureFilter._pointer();\n    _secureFilter.registerHandshakeCompleteCallback(\n        _secureHandshakeCompleteHandler);\n    if (onBadCertificate != null) {\n      _secureFilter.registerBadCertificateCallback(_onBadCertificateWrapper);\n    }\n    _socket.readEventsEnabled = true;\n    _socket.writeEventsEnabled = false;\n    if (_socketSubscription == null) {\n      // If a current subscription is provided use this otherwise\n      // create a new one.\n      _socketSubscription = _socket.listen(_eventDispatcher,\n                                           onError: _reportError,\n                                           onDone: _doneHandler);\n    } else {\n      if (_socketSubscription.isPaused) {\n        _socket.close();\n        throw new ArgumentError(\n            \"Subscription passed to TLS upgrade is paused\");\n      }\n      _socketSubscription\n          ..onData(_eventDispatcher)\n          ..onError(_reportError)\n          ..onDone(_doneHandler);\n    }\n    try {\n      _secureFilter.connect(address.host,\n                            (address as dynamic)._in_addr,\n                            port,\n                            is_server,\n                            certificateName,\n                            requestClientCertificate ||\n                                requireClientCertificate,\n                            requireClientCertificate,\n                            sendClientCertificate);\n      _secureHandshake();\n    } catch (e, s) {\n      _reportError(e, s);\n    }\n  }\n\n  StreamSubscription listen(void onData(RawSocketEvent data),\n                            {Function onError,\n                             void onDone(),\n                             bool cancelOnError}) {\n    _sendWriteEvent();\n    return _stream.listen(onData,\n                          onError: onError,\n                          onDone: onDone,\n                          cancelOnError: cancelOnError);\n  }\n\n  static void _verifyFields(host,\n                            int requestedPort,\n                            String certificateName,\n                            bool is_server,\n                            bool requestClientCertificate,\n                            bool requireClientCertificate,\n                            bool sendClientCertificate,\n                            Function onBadCertificate) {\n    if (host is! String && host is! InternetAddress) {\n      throw new ArgumentError(\"host is not a String or an InternetAddress\");\n    }\n    if (requestedPort is! int) {\n      throw new ArgumentError(\"requestedPort is not an int\");\n    }\n    if (requestedPort < 0 || requestedPort > 65535) {\n      throw new ArgumentError(\"requestedPort is not in the range 0..65535\");\n    }\n    if (certificateName != null && certificateName is! String) {\n      throw new ArgumentError(\"certificateName is not null or a String\");\n    }\n    if (certificateName == null && is_server) {\n      throw new ArgumentError(\"certificateName is null on a server\");\n    }\n    if (requestClientCertificate is! bool) {\n      throw new ArgumentError(\"requestClientCertificate is not a bool\");\n    }\n    if (requireClientCertificate is! bool) {\n      throw new ArgumentError(\"requireClientCertificate is not a bool\");\n    }\n    if (sendClientCertificate is! bool) {\n      throw new ArgumentError(\"sendClientCertificate is not a bool\");\n    }\n    if (onBadCertificate != null && onBadCertificate is! Function) {\n      throw new ArgumentError(\"onBadCertificate is not null or a Function\");\n    }\n   }\n\n  int get port => _socket.port;\n\n  InternetAddress get remoteAddress => _socket.remoteAddress;\n\n  int get remotePort => _socket.remotePort;\n\n  void set _owner(owner) {\n    (_socket as dynamic)._owner = owner;\n  }\n\n  int available() {\n    return _status != CONNECTED ? 0\n                                : _secureFilter.buffers[READ_PLAINTEXT].length;\n  }\n\n  Future<RawSecureSocket> close() {\n    shutdown(SocketDirection.BOTH);\n    return _closeCompleter.future;\n  }\n\n  void _completeCloseCompleter([dummy]) {\n    if (!_closeCompleter.isCompleted) _closeCompleter.complete(this);\n  }\n\n  void _close() {\n    _closedWrite = true;\n    _closedRead = true;\n    if (_socket != null) {\n      _socket.close().then(_completeCloseCompleter);\n    } else {\n      _completeCloseCompleter();\n    }\n    _socketClosedWrite = true;\n    _socketClosedRead = true;\n    if (!_filterActive && _secureFilter != null) {\n      _secureFilter.destroy();\n      _secureFilter = null;\n    }\n    if (_socketSubscription != null) {\n      _socketSubscription.cancel();\n    }\n    _controller.close();\n    _status = CLOSED;\n  }\n\n  void shutdown(SocketDirection direction) {\n    if (direction == SocketDirection.SEND ||\n        direction == SocketDirection.BOTH) {\n      _closedWrite = true;\n      if (_filterStatus.writeEmpty) {\n        _socket.shutdown(SocketDirection.SEND);\n        _socketClosedWrite = true;\n        if (_closedRead) {\n          _close();\n        }\n      }\n    }\n    if (direction == SocketDirection.RECEIVE ||\n        direction == SocketDirection.BOTH) {\n      _closedRead = true;\n      _socketClosedRead = true;\n      _socket.shutdown(SocketDirection.RECEIVE);\n      if (_socketClosedWrite) {\n        _close();\n      }\n    }\n  }\n\n  bool get writeEventsEnabled => _writeEventsEnabled;\n\n  void set writeEventsEnabled(bool value) {\n    _writeEventsEnabled = value;\n    if (value) {\n      Timer.run(() => _sendWriteEvent());\n    }\n  }\n\n  bool get readEventsEnabled => _readEventsEnabled;\n\n  void set readEventsEnabled(bool value) {\n      _readEventsEnabled = value;\n      _scheduleReadEvent();\n  }\n\n  List<int> read([int length]) {\n    if (length != null && (length is! int || length < 0)) {\n        throw new ArgumentError(\n            \"Invalid length parameter in SecureSocket.read (length: $length)\");\n    }\n    if (_closedRead) {\n      throw new SocketException(\"Reading from a closed socket\");\n    }\n    if (_status != CONNECTED) {\n      return null;\n    }\n    var result = _secureFilter.buffers[READ_PLAINTEXT].read(length);\n    _scheduleFilter();\n    return result;\n  }\n\n  // Write the data to the socket, and schedule the filter to encrypt it.\n  int write(List<int> data, [int offset, int bytes]) {\n    if (bytes != null && (bytes is! int || bytes < 0)) {\n        throw new ArgumentError(\n            \"Invalid bytes parameter in SecureSocket.read (bytes: $bytes)\");\n    }\n    if (offset != null && (offset is! int || offset < 0)) {\n        throw new ArgumentError(\n            \"Invalid offset parameter in SecureSocket.read (offset: $offset)\");\n    }\n    if (_closedWrite) {\n      _controller.addError(new SocketException(\"Writing to a closed socket\"));\n      return 0;\n    }\n    if (_status != CONNECTED) return 0;\n    if (offset == null) offset = 0;\n    if (bytes == null) bytes = data.length - offset;\n\n    int written =\n        _secureFilter.buffers[WRITE_PLAINTEXT].write(data, offset, bytes);\n    if (written > 0) {\n      _filterStatus.writeEmpty = false;\n    }\n    _scheduleFilter();\n    return written;\n  }\n\n  X509Certificate get peerCertificate => _secureFilter.peerCertificate;\n\n  bool _onBadCertificateWrapper(X509Certificate certificate) {\n    if (onBadCertificate == null) return false;\n    var result = onBadCertificate(certificate);\n    if (result is bool) return result;\n    throw new ArgumentError(\n        \"onBadCertificate callback returned non-boolean $result\");\n  }\n\n  bool setOption(SocketOption option, bool enabled) {\n    if (_socket == null) return false;\n    return _socket.setOption(option, enabled);\n  }\n\n  void _eventDispatcher(RawSocketEvent event) {\n    try {\n      if (event == RawSocketEvent.READ) {\n        _readHandler();\n      } else if (event == RawSocketEvent.WRITE) {\n        _writeHandler();\n      } else if (event == RawSocketEvent.READ_CLOSED) {\n        _closeHandler();\n      }\n    } catch (e, stackTrace) {\n      _reportError(e, stackTrace);\n    }\n  }\n\n  void _readHandler() {\n    _readSocket();\n    _scheduleFilter();\n  }\n\n  void _writeHandler() {\n    _writeSocket();\n    _scheduleFilter();\n  }\n\n  void _doneHandler() {\n    if (_filterStatus.readEmpty) {\n      _close();\n    }\n  }\n\n  void _reportError(e, [StackTrace stackTrace]) {\n    if (_status == CLOSED) {\n      return;\n    } else if (_connectPending) {\n      // _connectPending is true until the handshake has completed, and the\n      // _handshakeComplete future returned from SecureSocket.connect has\n      // completed.  Before this point, we must complete it with an error.\n      _handshakeComplete.completeError(e, stackTrace);\n    } else {\n      _controller.addError(e, stackTrace);\n    }\n    _close();\n  }\n\n  void _closeHandler() {\n    if  (_status == CONNECTED) {\n      if (_closedRead) return;\n      _socketClosedRead = true;\n      if (_filterStatus.readEmpty) {\n        _closedRead = true;\n        _controller.add(RawSocketEvent.READ_CLOSED);\n        if (_socketClosedWrite) {\n          _close();\n        }\n      } else {\n        _scheduleFilter();\n      }\n    } else if (_status == HANDSHAKE) {\n      _socketClosedRead = true;\n      if (_filterStatus.readEmpty) {\n      _reportError(\n          new HandshakeException('Connection terminated during handshake'),\n          null);\n      } else {\n        _secureHandshake();\n      }\n    }\n  }\n\n  void _secureHandshake() {\n    try {\n      _secureFilter.handshake();\n      _filterStatus.writeEmpty = false;\n      _readSocket();\n      _writeSocket();\n      _scheduleFilter();\n    } catch (e, stackTrace) {\n      _reportError(e, stackTrace);\n    }\n  }\n\n  void renegotiate({bool useSessionCache: true,\n                    bool requestClientCertificate: false,\n                    bool requireClientCertificate: false}) {\n    if (_status != CONNECTED) {\n      throw new HandshakeException(\n          \"Called renegotiate on a non-connected socket\");\n    }\n    _secureFilter.renegotiate(useSessionCache,\n                              requestClientCertificate,\n                              requireClientCertificate);\n    _status = HANDSHAKE;\n    _filterStatus.writeEmpty = false;\n    _scheduleFilter();\n  }\n\n  void _secureHandshakeCompleteHandler() {\n    _status = CONNECTED;\n    if (_connectPending) {\n      _connectPending = false;\n      // We don't want user code to run synchronously in this callback.\n      Timer.run(() => _handshakeComplete.complete(this));\n    }\n  }\n\n  void _onPauseStateChange() {\n    if (_controller.isPaused) {\n      _pauseCount++;\n    } else {\n      _pauseCount--;\n      if (_pauseCount == 0) {\n        _scheduleReadEvent();\n        _sendWriteEvent();  // Can send event synchronously.\n      }\n    }\n\n    if (!_socketClosedRead || !_socketClosedWrite) {\n      if (_controller.isPaused) {\n        _socketSubscription.pause();\n      } else {\n        _socketSubscription.resume();\n      }\n    }\n  }\n\n  void _onSubscriptionStateChange() {\n    if (_controller.hasListener) {\n      // TODO(ajohnsen): Do something here?\n    }\n  }\n\n  void _scheduleFilter() {\n    _filterPending = true;\n    _tryFilter();\n  }\n\n  void _tryFilter() {\n    if (_status == CLOSED) return;\n    if (_filterPending && !_filterActive) {\n      _filterActive = true;\n      _filterPending = false;\n      _pushAllFilterStages().then((status) {\n        _filterStatus = status;\n        _filterActive = false;\n        if (_status == CLOSED) {\n          _secureFilter.destroy();\n          _secureFilter = null;\n          return;\n        }\n        _socket.readEventsEnabled = true;\n        if (_filterStatus.writeEmpty && _closedWrite && !_socketClosedWrite) {\n          // Checks for and handles all cases of partially closed sockets.\n          shutdown(SocketDirection.SEND);\n          if (_status == CLOSED) return;\n        }\n        if (_filterStatus.readEmpty && _socketClosedRead && !_closedRead) {\n          if (_status == HANDSHAKE) {\n            _secureFilter.handshake();\n            if (_status == HANDSHAKE) {\n              throw new HandshakeException(\n                  'Connection terminated during handshake');\n            }\n          }\n          _closeHandler();\n        }\n        if (_status == CLOSED) return;\n        if (_filterStatus.progress) {\n          _filterPending = true;\n          if (_filterStatus.writePlaintextNoLongerFull) _sendWriteEvent();\n          if (_filterStatus.readEncryptedNoLongerFull) _readSocket();\n          if (_filterStatus.writeEncryptedNoLongerEmpty) _writeSocket();\n          if (_filterStatus.readPlaintextNoLongerEmpty) _scheduleReadEvent();\n          if (_status == HANDSHAKE) _secureHandshake();\n        }\n        _tryFilter();\n      }).catchError(_reportError);\n    }\n  }\n\n  List<int> _readSocketOrBufferedData(int bytes) {\n    if (_bufferedData != null) {\n      if (bytes > _bufferedData.length - _bufferedDataIndex) {\n        bytes = _bufferedData.length - _bufferedDataIndex;\n      }\n      var result = _bufferedData.sublist(_bufferedDataIndex,\n                                          _bufferedDataIndex + bytes);\n      _bufferedDataIndex += bytes;\n      if (_bufferedData.length == _bufferedDataIndex) {\n        _bufferedData = null;\n      }\n      return result;\n    } else if (!_socketClosedRead) {\n      return _socket.read(bytes);\n    } else {\n      return null;\n    }\n  }\n\n  void _readSocket() {\n    if (_status == CLOSED) return;\n    var buffer = _secureFilter.buffers[READ_ENCRYPTED];\n    if (buffer.writeFromSource(_readSocketOrBufferedData) > 0) {\n      _filterStatus.readEmpty = false;\n    } else {\n      _socket.readEventsEnabled = false;\n    }\n  }\n\n  void _writeSocket() {\n    if (_socketClosedWrite) return;\n    var buffer = _secureFilter.buffers[WRITE_ENCRYPTED];\n    if (buffer.readToSocket(_socket)) {  // Returns true if blocked\n      _socket.writeEventsEnabled = true;\n    }\n  }\n\n  // If a read event should be sent, add it to the controller.\n  _scheduleReadEvent() {\n    if (!_pendingReadEvent &&\n        _readEventsEnabled &&\n        _pauseCount == 0 &&\n        _secureFilter != null &&\n        !_secureFilter.buffers[READ_PLAINTEXT].isEmpty) {\n      _pendingReadEvent = true;\n      Timer.run(_sendReadEvent);\n    }\n  }\n\n  _sendReadEvent() {\n    _pendingReadEvent = false;\n    if (_status != CLOSED &&\n        _readEventsEnabled &&\n        _pauseCount == 0 &&\n        _secureFilter != null &&\n        !_secureFilter.buffers[READ_PLAINTEXT].isEmpty) {\n      _controller.add(RawSocketEvent.READ);\n      _scheduleReadEvent();\n    }\n  }\n\n  // If a write event should be sent, add it to the controller.\n  _sendWriteEvent() {\n    if (!_closedWrite &&\n        _writeEventsEnabled &&\n        _pauseCount == 0 &&\n        _secureFilter != null &&\n        _secureFilter.buffers[WRITE_PLAINTEXT].free > 0) {\n      _writeEventsEnabled = false;\n      _controller.add(RawSocketEvent.WRITE);\n    }\n  }\n\n  Future<_FilterStatus> _pushAllFilterStages() {\n    bool wasInHandshake = _status != CONNECTED;\n    List args = new List(2 + NUM_BUFFERS * 2);\n    args[0] = _filterPointer;\n    args[1] = wasInHandshake;\n    var bufs = _secureFilter.buffers;\n    for (var i = 0; i < NUM_BUFFERS; ++i) {\n      args[2 * i + 2] = bufs[i].start;\n      args[2 * i + 3] = bufs[i].end;\n    }\n\n    return _IOService.dispatch(_SSL_PROCESS_FILTER, args).then((response) {\n      if (response.length == 2) {\n        _reportError(new TlsException('${response[1]} error ${response[0]}'),\n                     null);\n      }\n      int start(int index) => response[2 * index];\n      int end(int index) => response[2 * index + 1];\n\n      _FilterStatus status = new _FilterStatus();\n      // Compute writeEmpty as \"write plaintext buffer and write encrypted\n      // buffer were empty when we started and are empty now\".\n      status.writeEmpty = bufs[WRITE_PLAINTEXT].isEmpty &&\n          start(WRITE_ENCRYPTED) == end(WRITE_ENCRYPTED);\n      // If we were in handshake when this started, _writeEmpty may be false\n      // because the handshake wrote data after we checked.\n      if (wasInHandshake) status.writeEmpty = false;\n\n      // Compute readEmpty as \"both read buffers were empty when we started\n      // and are empty now\".\n      status.readEmpty = bufs[READ_ENCRYPTED].isEmpty &&\n          start(READ_PLAINTEXT) == end(READ_PLAINTEXT);\n\n      _ExternalBuffer buffer = bufs[WRITE_PLAINTEXT];\n      int new_start = start(WRITE_PLAINTEXT);\n      if (new_start != buffer.start) {\n        status.progress = true;\n        if (buffer.free == 0) {\n          status.writePlaintextNoLongerFull = true;\n        }\n        buffer.start = new_start;\n      }\n      buffer = bufs[READ_ENCRYPTED];\n      new_start = start(READ_ENCRYPTED);\n      if (new_start != buffer.start) {\n        status.progress = true;\n        if (buffer.free == 0) {\n          status.readEncryptedNoLongerFull = true;\n        }\n        buffer.start = new_start;\n      }\n      buffer = bufs[WRITE_ENCRYPTED];\n      int new_end = end(WRITE_ENCRYPTED);\n      if (new_end != buffer.end) {\n        status.progress = true;\n        if (buffer.length == 0) {\n          status.writeEncryptedNoLongerEmpty = true;\n        }\n        buffer.end = new_end;\n      }\n      buffer = bufs[READ_PLAINTEXT];\n      new_end = end(READ_PLAINTEXT);\n      if (new_end != buffer.end) {\n        status.progress = true;\n        if (buffer.length == 0) {\n          status.readPlaintextNoLongerEmpty = true;\n        }\n        buffer.end = new_end;\n      }\n      return status;\n    });\n  }\n}\n\n\n/**\n * A circular buffer backed by an external byte array.  Accessed from\n * both C++ and Dart code in an unsynchronized way, with one reading\n * and one writing.  All updates to start and end are done by Dart code.\n */\nclass _ExternalBuffer {\n  List data;  // This will be a ExternalByteArray, backed by C allocated data.\n  int start;\n  int end;\n  final size;\n\n  _ExternalBuffer(this.size) {\n    start = end = size ~/ 2;\n  }\n\n  void advanceStart(int bytes) {\n    assert(start > end || start + bytes <= end);\n    start += bytes;\n    if (start >= size) {\n      start -= size;\n      assert(start <= end);\n      assert(start < size);\n    }\n  }\n\n  void advanceEnd(int bytes) {\n    assert(start <= end || start > end + bytes);\n    end += bytes;\n    if (end >= size) {\n      end -= size;\n      assert(end < start);\n      assert(end < size);\n    }\n  }\n\n  bool get isEmpty => end == start;\n\n  int get length =>\n      start > end ? size + end - start : end - start;\n\n  int get linearLength =>\n      start > end ? size - start : end - start;\n\n  int get free =>\n      start > end ? start - end - 1 : size + start - end - 1;\n\n  int get linearFree {\n    if (start > end) return start - end - 1;\n    if (start == 0) return size - end - 1;\n    return size - end;\n  }\n\n  List<int> read(int bytes) {\n    if (bytes == null) {\n      bytes = length;\n    } else {\n      bytes = min(bytes, length);\n    }\n    if (bytes == 0) return null;\n    List<int> result = new Uint8List(bytes);\n    int bytesRead = 0;\n    // Loop over zero, one, or two linear data ranges.\n    while (bytesRead < bytes) {\n      int toRead = min(bytes, linearLength);\n      result.setRange(bytesRead,\n                      bytesRead + toRead,\n                      data,\n                      start);\n      advanceStart(toRead);\n      bytesRead += toRead;\n    }\n    return result;\n  }\n\n  int write(List<int> inputData, int offset, int bytes) {\n    if (bytes > free) {\n      bytes = free;\n    }\n    int written = 0;\n    int toWrite = min(bytes, linearFree);\n    // Loop over zero, one, or two linear data ranges.\n    while (toWrite > 0) {\n      data.setRange(end, end + toWrite, inputData, offset);\n      advanceEnd(toWrite);\n      offset += toWrite;\n      written += toWrite;\n      toWrite = min(bytes - written, linearFree);\n    }\n    return written;\n  }\n\n  int writeFromSource(List<int> getData(int requested)) {\n    int written = 0;\n    int toWrite = linearFree;\n    // Loop over zero, one, or two linear data ranges.\n    while (toWrite > 0) {\n      // Source returns at most toWrite bytes, and it returns null when empty.\n      var inputData = getData(toWrite);\n      if (inputData == null || inputData.length == 0) break;\n      var len = inputData.length;\n      data.setRange(end, end + len, inputData);\n      advanceEnd(len);\n      written += len;\n      toWrite = linearFree;\n    }\n    return written;\n  }\n\n  bool readToSocket(RawSocket socket) {\n    // Loop over zero, one, or two linear data ranges.\n    while (true) {\n      var toWrite = linearLength;\n      if (toWrite == 0) return false;\n      int bytes = socket.write(data, start, toWrite);\n      advanceStart(bytes);\n      if (bytes < toWrite) {\n        // The socket has blocked while we have data to write.\n        return true;\n      }\n    }\n  }\n}\n\n\nabstract class _SecureFilter {\n  external factory _SecureFilter();\n\n  void connect(String hostName,\n               Uint8List addr,\n               int port,\n               bool is_server,\n               String certificateName,\n               bool requestClientCertificate,\n               bool requireClientCertificate,\n               bool sendClientCertificate);\n  void destroy();\n  void handshake();\n  void rehandshake();\n  void renegotiate(bool useSessionCache,\n                   bool requestClientCertificate,\n                   bool requireClientCertificate);\n  void init();\n  X509Certificate get peerCertificate;\n  int processBuffer(int bufferIndex);\n  void registerBadCertificateCallback(Function callback);\n  void registerHandshakeCompleteCallback(Function handshakeCompleteHandler);\n  int _pointer();\n\n  List<_ExternalBuffer> get buffers;\n}\n\n/** A secure networking exception caused by a failure in the\n *  TLS/SSL protocol.\n */\nclass TlsException implements IOException {\n  final String type;\n  final String message;\n  final OSError osError;\n\n  const TlsException([String message = \"\",\n                      OSError osError = null])\n     : this._(\"TlsException\", message, osError);\n\n  const TlsException._(this.type, this.message, this.osError);\n\n  String toString() {\n    StringBuffer sb = new StringBuffer();\n    sb.write(type);\n    if (!message.isEmpty) {\n      sb.write(\": $message\");\n      if (osError != null) {\n        sb.write(\" ($osError)\");\n      }\n    } else if (osError != null) {\n      sb.write(\": $osError\");\n    }\n    return sb.toString();\n  }\n}\n\n\n/**\n * An exception that happens in the handshake phase of establishing\n * a secure network connection.\n */\nclass HandshakeException extends TlsException {\n  const HandshakeException([String message = \"\",\n                            OSError osError = null])\n     : super._(\"HandshakeException\", message, osError);\n}\n\n\n/**\n * An exception that happens in the handshake phase of establishing\n * a secure network connection, when looking up or verifying a\n * certificate.\n */\nclass CertificateException extends TlsException {\n  const CertificateException([String message = \"\",\n                            OSError osError = null])\n     : super._(\"CertificateException\", message, osError);\n}\n\u0000","sdk:/sdk/lib/io/timer_impl.dart":"// Copyright (c) 2013, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\npart of dart.io;\n\n// Timer heap implemented as a array-based binary heap[0].\n// This allows for O(1) `first`, O(log(n)) `remove`/`removeFirst` and O(log(n))\n// `add`.\n//\n// To ensure the timers are ordered by insertion time, the _Timer class has a\n// `_id` field set when added to the heap.\n//\n// [0] http://en.wikipedia.org/wiki/Binary_heap\nclass _TimerHeap {\n  List<_Timer> _list;\n  int _used = 0;\n\n  _TimerHeap([int initSize = 7])\n      : _list = new List<_Timer>(initSize);\n\n  bool get isEmpty => _used == 0;\n  bool get isNotEmpty => _used > 0;\n\n  _Timer get first => _list[0];\n\n  bool isFirst(_Timer timer) => timer._indexOrNext == 0;\n\n  void add(_Timer timer) {\n    if (_used == _list.length) {\n      _resize();\n    }\n    timer._indexOrNext = _used++;\n    _list[timer._indexOrNext] = timer;\n    _bubbleUp(timer);\n  }\n\n  _Timer removeFirst() {\n    var f = first;\n    remove(f);\n    return f;\n  }\n\n  void remove(_Timer timer) {\n    _used--;\n    timer._id = -1;\n    if (isEmpty) {\n      _list[0] = null;\n      timer._indexOrNext = null;\n      return;\n    }\n    var last = _list[_used];\n    if (!identical(last, timer)) {\n      last._indexOrNext = timer._indexOrNext;\n      _list[last._indexOrNext] = last;\n      if (last._compareTo(timer) < 0) {\n        _bubbleUp(last);\n      } else {\n        _bubbleDown(last);\n      }\n    }\n    _list[_used] = null;\n    timer._indexOrNext = null;\n  }\n\n  void _resize() {\n    var newList = new List(_list.length * 2 + 1);\n    newList.setRange(0, _used, _list);\n    _list = newList;\n  }\n\n  void _bubbleUp(_Timer timer) {\n    while (!isFirst(timer)) {\n      Timer parent = _parent(timer);\n      if (timer._compareTo(parent) < 0) {\n        _swap(timer, parent);\n      } else {\n        break;\n      }\n    }\n  }\n\n  void _bubbleDown(_Timer timer) {\n    while (true) {\n      int leftIndex = _leftChildIndex(timer._indexOrNext);\n      int rightIndex = _rightChildIndex(timer._indexOrNext);\n      _Timer newest = timer;\n      if (leftIndex < _used && _list[leftIndex]._compareTo(newest) < 0) {\n        newest = _list[leftIndex];\n      }\n      if (rightIndex < _used && _list[rightIndex]._compareTo(newest) < 0) {\n        newest = _list[rightIndex];\n      }\n      if (identical(newest, timer)) {\n        // We are where we should be, break.\n        break;\n      }\n      _swap(newest, timer);\n    }\n  }\n\n  void _swap(_Timer first, _Timer second) {\n    int tmp = first._indexOrNext;\n    first._indexOrNext = second._indexOrNext;\n    second._indexOrNext = tmp;\n    _list[first._indexOrNext] = first;\n    _list[second._indexOrNext] = second;\n  }\n\n  Timer _parent(_Timer timer) => _list[_parentIndex(timer._indexOrNext)];\n  Timer _leftChild(_Timer timer) => _list[_leftChildIndex(timer._indexOrNext)];\n  Timer _rightChild(_Timer timer) =>\n      _list[_rightChildIndex(timer._indexOrNext)];\n\n  static int _parentIndex(int index) => (index - 1) ~/ 2;\n  static int _leftChildIndex(int index) => 2 * index + 1;\n  static int _rightChildIndex(int index) => 2 * index + 2;\n}\n\nclass _Timer implements Timer {\n  // Disables the timer.\n  static const int _NO_TIMER = -1;\n\n  // Timers are ordered by wakeup time.\n  static _TimerHeap _heap = new _TimerHeap();\n  static _Timer _firstZeroTimer;\n  static _Timer _lastZeroTimer;\n  static int _idCount = 0;\n\n  static RawReceivePort _receivePort;\n  static SendPort _sendPort;\n  static bool _handlingCallbacks = false;\n\n  Function _callback;\n  int _milliSeconds;\n  int _wakeupTime = 0;\n  var _indexOrNext;\n  int _id = -1;\n\n  static Timer _createTimer(void callback(Timer timer),\n                            int milliSeconds,\n                            bool repeating) {\n    _Timer timer = new _Timer._internal();\n    timer._callback = callback;\n    if (milliSeconds > 0) {\n      // Add one because DateTime.now() is assumed to round down\n      // to nearest millisecond, not up, so that time + duration is before\n      // duration milliseconds from now. Using micosecond timers like\n      // Stopwatch allows detecting that the timer fires early.\n      timer._wakeupTime =\n          new DateTime.now().millisecondsSinceEpoch + 1 + milliSeconds;\n    }\n    timer._milliSeconds = repeating ? milliSeconds : -1;\n    if (timer._addTimerToHeap()) {\n      // The new timer is the first in queue. Update event handler.\n      _notifyEventHandler();\n    }\n    return timer;\n  }\n\n  factory _Timer(int milliSeconds, void callback(Timer timer)) {\n    return _createTimer(callback, milliSeconds, false);\n  }\n\n  factory _Timer.periodic(int milliSeconds, void callback(Timer timer)) {\n    return _createTimer(callback, milliSeconds, true);\n  }\n\n  _Timer._internal() {}\n\n  bool get _isInHeap => _id >= 0;\n\n  void _clear() {\n    _callback = null;\n  }\n\n  int _compareTo(_Timer other) {\n    int c = _wakeupTime - other._wakeupTime;\n    if (c != 0) return c;\n    return _id - other._id;\n  }\n\n  bool get _repeating => _milliSeconds >= 0;\n\n  bool get isActive => _callback != null;\n\n  // Cancels a set timer. The timer is removed from the timer list and if\n  // the given timer is the earliest timer the native timer is reset.\n  void cancel() {\n    _clear();\n    if (!_isInHeap) return;\n    assert(_wakeupTime != 0);\n    bool update = (_firstZeroTimer == null) && _heap.isFirst(this);\n    _heap.remove(this);\n    if (update) {\n      _notifyEventHandler();\n    }\n  }\n\n  void _advanceWakeupTime() {\n    assert(_milliSeconds >= 0);\n    _wakeupTime += _milliSeconds;\n  }\n\n  // Adds a timer to the timer list. Timers with the same wakeup time are\n  // enqueued in order and notified in FIFO order.\n  bool _addTimerToHeap() {\n    if (_wakeupTime == 0) {\n      if (_firstZeroTimer == null) {\n        _lastZeroTimer = this;\n        _firstZeroTimer = this;\n        return true;\n      } else {\n        _lastZeroTimer._indexOrNext = this;\n        _lastZeroTimer = this;\n        return false;\n      }\n    } else {\n      _id = _idCount++;\n      _heap.add(this);\n      return _firstZeroTimer == null && _heap.isFirst(this);\n    }\n  }\n\n\n  static void _notifyEventHandler() {\n    if (_handlingCallbacks) {\n      // While we are already handling callbacks we will not notify the event\n      // handler. _handleTimeout will call _notifyEventHandler once all pending\n      // timers are processed.\n      return;\n    }\n\n    if (_firstZeroTimer == null && _heap.isEmpty) {\n      // No pending timers: Close the receive port and let the event handler\n      // know.\n      if (_receivePort != null) {\n        _EventHandler._sendData(null, _sendPort, _NO_TIMER);\n        _shutdownTimerHandler();\n      }\n    } else {\n      if (_receivePort == null) {\n        // Create a receive port and register a message handler for the timer\n        // events.\n        _createTimerHandler();\n      }\n      if (_firstZeroTimer != null) {\n        _sendPort.send(null);\n      } else {\n        _EventHandler._sendData(null,\n                                _sendPort,\n                                _heap.first._wakeupTime);\n      }\n    }\n  }\n\n  static void _handleTimeout(_) {\n    int currentTime = new DateTime.now().millisecondsSinceEpoch;\n    // Collect all pending timers.\n    var timer = _firstZeroTimer;\n    var nextTimer = _lastZeroTimer;\n    _firstZeroTimer = null;\n    _lastZeroTimer = null;\n    while (_heap.isNotEmpty && _heap.first._wakeupTime <= currentTime) {\n      var next = _heap.removeFirst();\n      if (timer == null) {\n        nextTimer = next;\n        timer = next;\n      } else {\n        nextTimer._indexOrNext = next;\n        nextTimer = next;\n      }\n    }\n\n    // Trigger all of the pending timers. New timers added as part of the\n    // callbacks will be enqueued now and notified in the next spin at the\n    // earliest.\n    _handlingCallbacks = true;\n    try {\n      while (timer != null) {\n        var next = timer._indexOrNext;\n        timer._indexOrNext = null;\n        // One of the timers in the pending_timers list can cancel\n        // one of the later timers which will set the callback to\n        // null.\n        if (timer._callback != null) {\n          var callback = timer._callback;\n          if (!timer._repeating) {\n            // Mark timer as inactive.\n            timer._callback = null;\n          }\n          callback(timer);\n          // Re-insert repeating timer if not canceled.\n          if (timer._repeating && timer._callback != null) {\n            timer._advanceWakeupTime();\n            timer._addTimerToHeap();\n          }\n        }\n        timer = next;\n      }\n    } finally {\n      _handlingCallbacks = false;\n      _notifyEventHandler();\n    }\n  }\n\n  // Creates a receive port and registers the timer handler on that\n  // receive port.\n  static void _createTimerHandler() {\n    if(_receivePort == null) {\n      _receivePort = new RawReceivePort(_handleTimeout);\n      _sendPort = _receivePort.sendPort;\n    }\n  }\n\n  static void _shutdownTimerHandler() {\n    _receivePort.close();\n    _receivePort = null;\n    _sendPort = null;\n  }\n}\n\n// Provide a closure which will allocate a Timer object to be able to hook\n// up the Timer interface in dart:isolate with the implementation here.\n_getTimerFactoryClosure() {\n  return (int milliSeconds, void callback(Timer timer), bool repeating) {\n    if (repeating) {\n      return new _Timer.periodic(milliSeconds, callback);\n    }\n    return new _Timer(milliSeconds, callback);\n  };\n}\n\n\n\u0000","sdk:/sdk/lib/io/string_transformer.dart":"// Copyright (c) 2013, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\npart of dart.io;\n\n/// The current system encoding.\nconst SystemEncoding SYSTEM_ENCODING = const SystemEncoding();\n\n/**\n * The system encoding is the current code page on Windows and UTF-8 on\n * Linux and Mac.\n */\nclass SystemEncoding extends Encoding {\n  const SystemEncoding();\n\n  String get name => 'system';\n\n  List<int> encode(String input) => encoder.convert(input);\n  String decode(List<int> encoded) => decoder.convert(encoded);\n\n  Converter<String, List<int>> get encoder {\n    if (Platform.operatingSystem == \"windows\") {\n      return const _WindowsCodePageEncoder();\n    } else {\n      return const Utf8Encoder();\n    }\n  }\n\n  Converter<List<int>, String> get decoder {\n    if (Platform.operatingSystem == \"windows\") {\n      return const _WindowsCodePageDecoder();\n    } else {\n      return const Utf8Decoder();\n    }\n  }\n}\n\nclass _WindowsCodePageEncoder extends Converter<String, List<int>> {\n\n  const _WindowsCodePageEncoder();\n\n  List<int> convert(String input) {\n    List<int> encoded = _encodeString(input);\n    if (encoded == null) {\n      throw new FormatException(\"Invalid character for encoding\");\n    }\n    return encoded;\n  }\n\n  /**\n   * Starts a chunked conversion.\n   */\n  StringConversionSink startChunkedConversion(Sink<List<int>> sink) {\n    return new _WindowsCodePageEncoderSink(sink);\n  }\n\n  // Override the base-class' bind, to provide a better type.\n  Stream<List<int>> bind(Stream<String> stream) => super.bind(stream);\n\n  external static List<int> _encodeString(String string);\n}\n\nclass _WindowsCodePageEncoderSink extends StringConversionSinkBase {\n  // TODO(floitsch): provide more efficient conversions when the input is\n  // not a String.\n\n  final Sink<List<int>> _sink;\n\n  _WindowsCodePageEncoderSink(this._sink);\n\n  void close() {\n    _sink.close();\n  }\n\n  void add(String string) {\n    List<int> encoded = _WindowsCodePageEncoder._encodeString(string);\n    if (encoded == null) {\n      throw new FormatException(\"Invalid character for encoding\");\n    }\n    _sink.add(encoded);\n  }\n\n  void addSlice(String source, int start, int end, bool isLast) {\n    if (start != 0 || end != source.length) {\n      source = source.substring(start, end);\n    }\n    add(source);\n    if (isLast) close();\n  }\n}\n\n\nclass _WindowsCodePageDecoder extends Converter<List<int>, String> {\n\n  const _WindowsCodePageDecoder();\n\n  String convert(List<int> input) {\n    return _decodeBytes(input);\n  }\n\n  /**\n   * Starts a chunked conversion.\n   */\n  ByteConversionSink startChunkedConversion(Sink<String> sink) {\n    return new _WindowsCodePageDecoderSink(sink);\n  }\n\n  // Override the base-class' bind, to provide a better type.\n  Stream<String> bind(Stream<List<int>> stream) => super.bind(stream);\n\n  external static String _decodeBytes(List<int> bytes);\n}\n\nclass _WindowsCodePageDecoderSink extends ByteConversionSinkBase {\n  // TODO(floitsch): provide more efficient conversions when the input is\n  // a slice.\n\n  final Sink<String> _sink;\n\n  _WindowsCodePageDecoderSink(this._sink);\n\n  void close() {\n    _sink.close();\n  }\n\n  void add(List<int> bytes) {\n    _sink.add(_WindowsCodePageDecoder._decodeBytes(bytes));\n  }\n}\n\u0000","sdk:/sdk/lib/io/stdio.dart":"// Copyright (c) 2013, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\npart of dart.io;\n\nconst int _STDIO_HANDLE_TYPE_TERMINAL = 0;\nconst int _STDIO_HANDLE_TYPE_PIPE = 1;\nconst int _STDIO_HANDLE_TYPE_FILE = 2;\nconst int _STDIO_HANDLE_TYPE_SOCKET = 3;\nconst int _STDIO_HANDLE_TYPE_OTHER = 4;\n\n\nclass _StdStream extends Stream<List<int>> {\n  final Stream<List<int>> _stream;\n\n  _StdStream(this._stream);\n\n  StreamSubscription<List<int>> listen(void onData(List<int> event),\n                                       {Function onError,\n                                        void onDone(),\n                                        bool cancelOnError}) {\n    return _stream.listen(\n        onData,\n        onError: onError,\n        onDone: onDone,\n        cancelOnError: cancelOnError);\n  }\n}\n\n\n/**\n * [Stdin] allows both synchronous and asynchronous reads from the standard\n * input stream.\n *\n * Mixing synchronous and asynchronous reads is undefined.\n */\nclass Stdin extends _StdStream implements Stream<List<int>> {\n  Stdin._(Stream<List<int>> stream) : super(stream);\n\n  /**\n   * Synchronously read a line from stdin. This call will block until a full\n   * line is available.\n   *\n   * The argument [encoding] can be used to changed how the input should be\n   * decoded. Default is [SYSTEM_ENCODING].\n   *\n   * If [retainNewlines] is `false`, the returned String will not contain the\n   * final newline. If `true`, the returned String will contain the line\n   * terminator. Default is `false`.\n   *\n   * If end-of-file is reached after any bytes have been read from stdin,\n   * that data is returned.\n   * Returns `null` if no bytes preceeded the end of input.\n   */\n  String readLineSync({Encoding encoding: SYSTEM_ENCODING,\n                       bool retainNewlines: false}) {\n    const CR = 13;\n    const LF = 10;\n    final List line = [];\n    // On Windows, if lineMode is disabled, only CR is received.\n    bool crIsNewline = Platform.isWindows &&\n        (stdioType(stdin) == StdioType.TERMINAL) &&\n        !lineMode;\n    if (retainNewlines) {\n      int byte;\n      do {\n        byte = readByteSync();\n        if (byte < 0) {\n          break;\n        }\n        line.add(byte);\n      } while (byte != LF && !(byte == CR && crIsNewline));\n      if (line.isEmpty) {\n        return null;\n      }\n    } else if (crIsNewline) {\n      // CR and LF are both line terminators, neither is retained.\n      while (true) {\n        int byte = readByteSync();\n        if (byte < 0) {\n          if (line.isEmpty) return null;\n          break;\n        }\n        if (byte == LF || byte == CR) break;\n        line.add(byte);\n      }\n    } else {\n      // Case having to hande CR LF as a single unretained line terminator.\n      outer: while (true) {\n        int byte = readByteSync();\n        if (byte == LF) break;\n        if (byte == CR) {\n          do {\n            byte = readByteSync();\n            if (byte == LF) break outer;\n\n            line.add(CR);\n          } while (byte == CR);\n          // Fall through and handle non-CR character.\n        }\n        if (byte < 0) {\n          if (line.isEmpty) return null;\n          break;\n        }\n        line.add(byte);\n      }\n    }\n    return encoding.decode(line);\n  }\n\n  /**\n   * Check if echo mode is enabled on [stdin].\n   */\n  external bool get echoMode;\n\n  /**\n   * Enable or disable echo mode on [stdin].\n   *\n   * If disabled, input from to console will not be echoed.\n   *\n   * Default depends on the parent process, but usually enabled.\n   */\n  external void set echoMode(bool enabled);\n\n  /**\n   * Check if line mode is enabled on [stdin].\n   */\n  external bool get lineMode;\n\n  /**\n   * Enable or disable line mode on [stdin].\n   *\n   * If enabled, characters are delayed until a new-line character is entered.\n   * If disabled, characters will be available as typed.\n   *\n   * Default depends on the parent process, but usually enabled.\n   */\n  external void set lineMode(bool enabled);\n\n  /**\n   * Synchronously read a byte from stdin. This call will block until a byte is\n   * available.\n   *\n   * If at end of file, -1 is returned.\n   */\n  external int readByteSync();\n}\n\n\n/**\n * [Stdout] exposes methods to query the terminal for properties.\n *\n * Use [hasTerminal] to test if there is a terminal associated to stdout.\n */\nclass Stdout extends _StdSink implements IOSink {\n  Stdout._(IOSink sink) : super(sink);\n\n  /**\n   * Returns true if there is a terminal attached to stdout.\n   */\n  external bool get hasTerminal;\n\n  /**\n   * Get the number of columns of the terminal.\n   *\n   * If no terminal is attached to stdout, a [StdoutException] is thrown. See\n   * [hasTerminal] for more info.\n   */\n  external int get terminalColumns;\n\n  /**\n   * Get the number of lines of the terminal.\n   *\n   * If no terminal is attached to stdout, a [StdoutException] is thrown. See\n   * [hasTerminal] for more info.\n   */\n  external int get terminalLines;\n}\n\n\nclass StdoutException implements IOException {\n  final String message;\n  final OSError osError;\n\n  const StdoutException(this.message, [this.osError]);\n\n  String toString() {\n    return \"StdoutException: $message${osError == null ? \"\" : \", $osError\"}\";\n  }\n}\n\n\nclass _StdConsumer implements StreamConsumer<List<int>> {\n  final _file;\n\n  _StdConsumer(int fd) : _file = _File._openStdioSync(fd);\n\n  Future addStream(Stream<List<int>> stream) {\n    var completer = new Completer();\n    var sub;\n    sub = stream.listen(\n        (data) {\n          try {\n            _file.writeFromSync(data);\n          } catch (e, s) {\n            sub.cancel();\n            completer.completeError(e, s);\n          }\n        },\n        onError: completer.completeError,\n        onDone: completer.complete,\n        cancelOnError: true);\n    return completer.future;\n  }\n\n  Future close() {\n    _file.closeSync();\n    return new Future.value();\n  }\n}\n\n\nclass _StdSink implements IOSink {\n  final IOSink _sink;\n\n  _StdSink(this._sink);\n\n  Encoding get encoding => _sink.encoding;\n  void set encoding(Encoding encoding) {\n    _sink.encoding = encoding;\n  }\n  void write(object) => _sink.write(object);\n  void writeln([object = \"\" ]) => _sink.writeln(object);\n  void writeAll(objects, [sep = \"\"]) => _sink.writeAll(objects, sep);\n  void add(List<int> data) => _sink.add(data);\n  void addError(error, [StackTrace stackTrace]) =>\n      _sink.addError(error, stackTrace);\n  void writeCharCode(int charCode) => _sink.writeCharCode(charCode);\n  Future addStream(Stream<List<int>> stream) => _sink.addStream(stream);\n  Future flush() => _sink.flush();\n  Future close() => _sink.close();\n  Future get done => _sink.done;\n}\n\n/// The type of object a standard IO stream is attached to.\nclass StdioType {\n  static const StdioType TERMINAL = const StdioType._(\"terminal\");\n  static const StdioType PIPE = const StdioType._(\"pipe\");\n  static const StdioType FILE = const StdioType._(\"file\");\n  static const StdioType OTHER = const StdioType._(\"other\");\n  final String name;\n  const StdioType._(this.name);\n  String toString() => \"StdioType: $name\";\n}\n\n\nStdin _stdin;\nStdout _stdout;\nIOSink _stderr;\n\n\n/// The standard input stream of data read by this program.\nStdin get stdin {\n  if (_stdin == null) {\n    _stdin = _StdIOUtils._getStdioInputStream();\n  }\n  return _stdin;\n}\n\n\n/// The standard output stream of data written by this program.\nStdout get stdout {\n  if (_stdout == null) {\n    _stdout = _StdIOUtils._getStdioOutputStream(1);\n  }\n  return _stdout;\n}\n\n\n/// The standard output stream of errors written by this program.\nIOSink get stderr {\n  if (_stderr == null) {\n    _stderr = _StdIOUtils._getStdioOutputStream(2);\n  }\n  return _stderr;\n}\n\n\n/// For a stream, returns whether it is attached to a file, pipe, terminal, or\n/// something else.\nStdioType stdioType(object) {\n  if (object is _StdStream) {\n    object = object._stream;\n  } else if (object == stdout || object == stderr) {\n    switch (_StdIOUtils._getStdioHandleType(object == stdout ? 1 : 2)) {\n      case _STDIO_HANDLE_TYPE_TERMINAL: return StdioType.TERMINAL;\n      case _STDIO_HANDLE_TYPE_PIPE: return StdioType.PIPE;\n      case _STDIO_HANDLE_TYPE_FILE:  return StdioType.FILE;\n    }\n  }\n  if (object is _FileStream) {\n    return StdioType.FILE;\n  }\n  if (object is Socket) {\n    switch (_StdIOUtils._socketType(object._nativeSocket)) {\n      case _STDIO_HANDLE_TYPE_TERMINAL: return StdioType.TERMINAL;\n      case _STDIO_HANDLE_TYPE_PIPE: return StdioType.PIPE;\n      case _STDIO_HANDLE_TYPE_FILE:  return StdioType.FILE;\n    }\n  }\n  if (object is IOSink) {\n    try {\n      if (object._target is _FileStreamConsumer) {\n        return StdioType.FILE;\n      }\n    } catch (e) {\n      // Only the interface implemented, _sink not available.\n    }\n  }\n  return StdioType.OTHER;\n}\n\n\nclass _StdIOUtils {\n  external static _getStdioOutputStream(int fd);\n  external static Stdin _getStdioInputStream();\n  external static int _socketType(nativeSocket);\n  external static _getStdioHandleType(int fd);\n}\n\u0000","sdk:/sdk/lib/io/socket.dart":"// Copyright (c) 2013, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\npart of dart.io;\n\n\n/**\n * [InternetAddressType] is the type an [InternetAddress]. Currently,\n * IP version 4 (IPv4) and IP version 6 (IPv6) are supported.\n */\nclass InternetAddressType {\n  static const InternetAddressType IP_V4 = const InternetAddressType._(0);\n  static const InternetAddressType IP_V6 = const InternetAddressType._(1);\n  static const InternetAddressType ANY = const InternetAddressType._(-1);\n\n  final int _value;\n\n  const InternetAddressType._(this._value);\n\n  factory InternetAddressType._from(int value) {\n    if (value == 0) return IP_V4;\n    if (value == 1) return IP_V6;\n    throw new ArgumentError(\"Invalid type: $value\");\n  }\n\n  /**\n   * Get the name of the type, e.g. \"IP_V4\" or \"IP_V6\".\n   */\n  String get name {\n    switch (_value) {\n      case -1: return \"ANY\";\n      case 0: return \"IP_V4\";\n      case 1: return \"IP_V6\";\n      default: throw new ArgumentError(\"Invalid InternetAddress\");\n    }\n  }\n\n  String toString() => \"InternetAddressType: $name\";\n}\n\n\n/**\n * An internet address.\n *\n * This object holds an internet address. If this internet address\n * is the result of a DNS lookup, the address also holds the hostname\n * used to make the lookup.\n * An Internet address combined with a port number represents an\n * endpoint to which a socket can connect or a listening socket can\n * bind.\n */\nabstract class InternetAddress {\n  /**\n   * IP version 4 loopback address. Use this address when listening on\n   * or connecting to the loopback adapter using IP version 4 (IPv4).\n   */\n  external static InternetAddress get LOOPBACK_IP_V4;\n\n  /**\n   * IP version 6 loopback address. Use this address when listening on\n   * or connecting to the loopback adapter using IP version 6 (IPv6).\n   */\n  external static InternetAddress get LOOPBACK_IP_V6;\n\n  /**\n   * IP version 4 any address. Use this address when listening on\n   * all adapters IP addresses using IP version 4 (IPv4).\n   */\n  external static InternetAddress get ANY_IP_V4;\n\n  /**\n   * IP version 6 any address. Use this address when listening on\n   * all adapters IP addresses using IP version 6 (IPv6).\n   */\n  external static InternetAddress get ANY_IP_V6;\n\n  /**\n   * The [type] of the [InternetAddress] specified what IP protocol.\n   */\n  InternetAddressType type;\n\n  /**\n   * The numeric address of the host. For IPv4 addresses this is using\n   * the dotted-decimal notation. For IPv6 it is using the\n   * hexadecimal representation.\n   */\n  String get address;\n\n  /**\n   * The host used to lookup the address. If there is no host\n   * associated with the address this returns the numeric address.\n   */\n  String get host;\n\n  /**\n   * Get the raw address of this [InternetAddress]. The result is either a\n   * 4 or 16 byte long list. The returned list is a copy, making it possible\n   * to change the list without modifying the [InternetAddress].\n   */\n  List<int> get rawAddress;\n\n  /**\n   * Returns true if the [InternetAddress] is a loopback address.\n   */\n  bool get isLoopback;\n\n  /**\n   * Returns true if the [InternetAddress]s scope is a link-local.\n   */\n  bool get isLinkLocal;\n\n  /**\n   * Returns true if the [InternetAddress]s scope is multicast.\n   */\n  bool get isMulticast;\n\n  /**\n   * Creates a new [InternetAddress] from a numeric address.\n   *\n   * If the address in [address] is not a numeric IPv4\n   * (dotted-decimal notation) or IPv6 (hexadecimal representation).\n   * address [ArgumentError] is thrown.\n   */\n  external factory InternetAddress(String address);\n\n  /**\n   * Perform a reverse dns lookup on the [address], creating a new\n   * [InternetAddress] where the host field set to the result.\n   */\n  Future<InternetAddress> reverse();\n\n  /**\n   * Lookup a host, returning a Future of a list of\n   * [InternetAddress]s. If [type] is [InternetAddressType.ANY], it\n   * will lookup both IP version 4 (IPv4) and IP version 6 (IPv6)\n   * addresses. If [type] is either [InternetAddressType.IP_V4] or\n   * [InternetAddressType.IP_V6] it will only lookup addresses of the\n   * specified type. The order of the list can, and most likely will,\n   * change over time.\n   */\n  external static Future<List<InternetAddress>> lookup(\n      String host, {InternetAddressType type: InternetAddressType.ANY});\n}\n\n\n/**\n * A [NetworkInterface] represent an active network interface on the current\n * system. It contains a list of [InternetAddress]s, that's bound to the\n * interface.\n */\nabstract class NetworkInterface {\n  /**\n   * Get the name of the [NetworkInterface].\n   */\n  String get name;\n\n  /**\n   * Get the index of the [NetworkInterface].\n   */\n  String get index;\n\n  /**\n   * Get a list of [InternetAddress]s currently bound to this\n   * [NetworkInterface].\n   */\n  List<InternetAddress> get addresses;\n\n  /**\n   * Query the system for [NetworkInterface]s.\n   *\n   * If [includeLoopback] is `true`, the returned list will include the\n   * loopback device. Default is `false`.\n   *\n   * If [includeLinkLocal] is `true`, the list of addresses of the returned\n   * [NetworkInterface]s, may include link local addresses. Default is `false`.\n   *\n   * If [type] is either [InternetAddressType.IP_V4] or\n   * [InternetAddressType.IP_V6] it will only lookup addresses of the\n   * specified type. Default is [InternetAddressType.ANY].\n   */\n  external static Future<List<NetworkInterface>> list({\n      bool includeLoopback: false,\n      bool includeLinkLocal: false,\n      InternetAddressType type: InternetAddressType.ANY});\n}\n\n\n/**\n * A [RawServerSocket] represents a listening socket, and provides a\n * stream of low-level [RawSocket] objects, one for each connection\n * made to the listening socket.\n *\n * See [RawSocket] for more info.\n */\nabstract class RawServerSocket implements Stream<RawSocket> {\n  /**\n   * Returns a future for a [:RawServerSocket:]. When the future\n   * completes the server socket is bound to the given [address] and\n   * [port] and has started listening on it.\n   *\n   * The [address] can either be a [String] or an\n   * [InternetAddress]. If [address] is a [String], [bind] will\n   * perform a [InternetAddress.lookup] and use the first value in the\n   * list. To listen on the loopback adapter, which will allow only\n   * incoming connections from the local host, use the value\n   * [InternetAddress.LOOPBACK_IP_V4] or\n   * [InternetAddress.LOOPBACK_IP_V6]. To allow for incoming\n   * connection from the network use either one of the values\n   * [InternetAddress.ANY_IP_V4] or [InternetAddress.ANY_IP_V6] to\n   * bind to all interfaces or the IP address of a specific interface.\n   *\n   * If an IP version 6 (IPv6) address is used, both IP version 6\n   * (IPv6) and version 4 (IPv4) connections will be accepted. To\n   * restrict this to version 6 (IPv6) only, use [v6Only] to set\n   * version 6 only.\n   *\n   * If [port] has the value [:0:] an ephemeral port will\n   * be chosen by the system. The actual port used can be retrieved\n   * using the [:port:] getter.\n   *\n   * The optional argument [backlog] can be used to specify the listen\n   * backlog for the underlying OS listen setup. If [backlog] has the\n   * value of [:0:] (the default) a reasonable value will be chosen by\n   * the system.\n   */\n  external static Future<RawServerSocket> bind(address,\n                                               int port,\n                                               {int backlog: 0,\n                                                bool v6Only: false});\n\n  /**\n   * Returns the port used by this socket.\n   */\n  int get port;\n\n  /**\n   * Returns the address used by this socket.\n   */\n  InternetAddress get address;\n\n  /**\n   * Closes the socket. The returned future completes when the socket\n   * is fully closed and is no longer bound.\n   */\n  Future<RawServerSocket> close();\n\n  /**\n   * Get the [RawServerSocketReference].\n   *\n   * WARNING: This feature is *highly experimental* and currently only works on\n   * Linux. The API is most likely going to change in the near future.\n   *\n   * The returned [RawServerSocketReference] can be used to create other\n   * [RawServerSocket]s listening on the same port,\n   * using [RawServerSocketReference.create].\n   * Incoming connections on the port will be distributed fairly between the\n   * active server sockets.\n   * The [RawServerSocketReference] can be distributed to other isolates through\n   * a [RawSendPort].\n   */\n  RawServerSocketReference get reference;\n}\n\n\n/**\n * A [RawServerSocketReference].\n *\n * WARNING: This class is used with [RawServerSocket.reference] which is highly\n * experimental.\n */\nabstract class RawServerSocketReference {\n  /**\n   * Create a new [RawServerSocket], from this reference.\n   */\n  Future<RawServerSocket> create();\n}\n\n\n/**\n * A [ServerSocket] represents a listening socket, and provides a\n * stream of [Socket] objects, one for each connection made to the\n * listening socket.\n *\n * See [Socket] for more info.\n */\nabstract class ServerSocket implements Stream<Socket> {\n  /**\n   * Returns a future for a [:ServerSocket:]. When the future\n   * completes the server socket is bound to the given [address] and\n   * [port] and has started listening on it.\n   *\n   * The [address] can either be a [String] or an\n   * [InternetAddress]. If [address] is a [String], [bind] will\n   * perform a [InternetAddress.lookup] and use the first value in the\n   * list. To listen on the loopback adapter, which will allow only\n   * incoming connections from the local host, use the value\n   * [InternetAddress.LOOPBACK_IP_V4] or\n   * [InternetAddress.LOOPBACK_IP_V6]. To allow for incoming\n   * connection from the network use either one of the values\n   * [InternetAddress.ANY_IP_V4] or [InternetAddress.ANY_IP_V6] to\n   * bind to all interfaces or the IP address of a specific interface.\n   *\n   * If an IP version 6 (IPv6) address is used, both IP version 6\n   * (IPv6) and version 4 (IPv4) connections will be accepted. To\n   * restrict this to version 6 (IPv6) only, use [v6Only] to set\n   * version 6 only.\n   *\n   * If [port] has the value [:0:] an ephemeral port will be chosen by\n   * the system. The actual port used can be retrieved using the\n   * [port] getter.\n   *\n   * The optional argument [backlog] can be used to specify the listen\n   * backlog for the underlying OS listen setup. If [backlog] has the\n   * value of [:0:] (the default) a reasonable value will be chosen by\n   * the system.\n   */\n  external static Future<ServerSocket> bind(address,\n                                            int port,\n                                            {int backlog: 0,\n                                             bool v6Only: false});\n\n  /**\n   * Returns the port used by this socket.\n   */\n  int get port;\n\n  /**\n   * Returns the address used by this socket.\n   */\n  InternetAddress get address;\n\n  /**\n   * Closes the socket. The returned future completes when the socket\n   * is fully closed and is no longer bound.\n   */\n  Future<ServerSocket> close();\n\n  /**\n   * Get the [ServerSocketReference].\n   *\n   * WARNING: This feature is *highly experimental* and currently only works on\n   * Linux. The API is most likely going to change in the near future.\n   *\n   * The returned [ServerSocketReference] can be used to create other\n   * [ServerSocket]s listening on the same port,\n   * using [ServerSocketReference.create].\n   * Incoming connections on the port will be distributed fairly between the\n   * active server sockets.\n   * The [ServerSocketReference] can be distributed to other isolates through a\n   * [SendPort].\n   */\n  ServerSocketReference get reference;\n}\n\n\n/**\n * A [ServerSocketReference].\n *\n * WARNING: This class is used with [ServerSocket.reference] which is highly\n * experimental.\n */\nabstract class ServerSocketReference {\n  /**\n   * Create a new [ServerSocket], from this reference.\n   */\n  Future<ServerSocket> create();\n}\n\n\n/**\n * The [SocketDirection] is used as a parameter to [Socket.close] and\n * [RawSocket.close] to close a socket in the specified direction(s).\n */\nclass SocketDirection {\n  static const SocketDirection RECEIVE = const SocketDirection._(0);\n  static const SocketDirection SEND = const SocketDirection._(1);\n  static const SocketDirection BOTH = const SocketDirection._(2);\n  final _value;\n\n  const SocketDirection._(this._value);\n}\n\n/**\n * The [SocketOption] is used as a parameter to [Socket.setOption] and\n * [RawSocket.setOption] to set customize the behaviour of the underlying\n * socket.\n */\nclass SocketOption {\n  /**\n   * Enable or disable no-delay on the socket. If TCP_NODELAY is enabled, the\n   * socket will not buffer data internally, but instead write each data chunk\n   * as an invidual TCP packet.\n   *\n   * TCP_NODELAY is disabled by default.\n   */\n  static const SocketOption TCP_NODELAY = const SocketOption._(0);\n\n  static const SocketOption _IP_MULTICAST_LOOP = const SocketOption._(1);\n  static const SocketOption _IP_MULTICAST_HOPS = const SocketOption._(2);\n  static const SocketOption _IP_MULTICAST_IF = const SocketOption._(3);\n  static const SocketOption _IP_BROADCAST = const SocketOption._(4);\n  final _value;\n\n  const SocketOption._(this._value);\n}\n\n/**\n * Events for the [RawSocket].\n */\nclass RawSocketEvent {\n  static const RawSocketEvent READ = const RawSocketEvent._(0);\n  static const RawSocketEvent WRITE = const RawSocketEvent._(1);\n  static const RawSocketEvent READ_CLOSED = const RawSocketEvent._(2);\n  static const RawSocketEvent CLOSED = const RawSocketEvent._(3);\n  final int _value;\n\n  const RawSocketEvent._(this._value);\n  String toString() {\n    return ['RawSocketEvent:READ',\n            'RawSocketEvent:WRITE',\n            'RawSocketEvent:READ_CLOSED',\n            'RawSocketEvent:CLOSED'][_value];\n  }\n}\n\n/**\n * The [RawSocket] is a low-level interface to a socket, exposing the raw\n * events signaled by the system. It's a [Stream] of [RawSocketEvent]s.\n */\nabstract class RawSocket implements Stream<RawSocketEvent> {\n  /**\n   * Set or get, if the [RawSocket] should listen for [RawSocketEvent.READ]\n   * events. Default is [:true:].\n   */\n  bool readEventsEnabled;\n\n  /**\n   * Set or get, if the [RawSocket] should listen for [RawSocketEvent.WRITE]\n   * events. Default is [:true:].\n   * This is a one-shot listener, and writeEventsEnabled must be set\n   * to true again to receive another write event.\n   */\n  bool writeEventsEnabled;\n\n  /**\n   * Creates a new socket connection to the host and port and returns a [Future]\n   * that will complete with either a [RawSocket] once connected or an error\n   * if the host-lookup or connection failed.\n   *\n   * [host] can either be a [String] or an [InternetAddress]. If [host] is a\n   * [String], [connect] will perform a [InternetAddress.lookup] and try\n   * all returned [InternetAddress]es, until connected. Unless a\n   * connection was established, the error from the first failing connection is\n   * returned.\n   */\n  external static Future<RawSocket> connect(host, int port);\n\n  /**\n   * Returns the number of received and non-read bytes in the socket that\n   * can be read.\n   */\n  int available();\n\n  /**\n   * Read up to [len] bytes from the socket. This function is\n   * non-blocking and will only return data if data is available. The\n   * number of bytes read can be less then [len] if fewer bytes are\n   * available for immediate reading. If no data is available [:null:]\n   * is returned.\n   */\n  List<int> read([int len]);\n\n  /**\n   * Writes up to [count] bytes of the buffer from [offset] buffer offset to\n   * the socket. The number of successfully written bytes is returned. This\n   * function is non-blocking and will only write data if buffer space is\n   * available in the socket.\n   *\n   * The default value for [offset] is 0, and the default value for [count] is\n   * [:buffer.length - offset:].\n   */\n  int write(List<int> buffer, [int offset, int count]);\n\n  /**\n   * Returns the port used by this socket.\n   */\n  int get port;\n\n  /**\n   * Returns the remote port connected to by this socket.\n   */\n  int get remotePort;\n\n  /**\n   * Returns the [InternetAddress] used to connect this socket.\n   */\n  InternetAddress get address;\n\n  /**\n   * Returns the remote [InternetAddress] connected to by this socket.\n   */\n  InternetAddress get remoteAddress;\n\n  /**\n   * Closes the socket. Returns a Future that completes with [this] when the\n   * underlying connection is completely destroyed.\n   *\n   * Calling [close] will never throw an exception\n   * and calling it several times is supported. Calling [close] can result in\n   * a [RawSocketEvent.READ_CLOSED] event.\n   */\n  Future<RawSocket> close();\n\n  /**\n   * Shutdown the socket in the [direction]. Calling [shutdown] will never\n   * throw an exception and calling it several times is supported. Calling\n   * shutdown with either [SocketDirection.BOTH] or [SocketDirection.RECEIVE]\n   * can result in a [RawSocketEvent.READ_CLOSED] event.\n   */\n  void shutdown(SocketDirection direction);\n\n  /**\n   * Use [setOption] to customize the [RawSocket]. See [SocketOption] for\n   * available options.\n   *\n   * Returns [:true:] if the option was set successfully, false otherwise.\n   */\n  bool setOption(SocketOption option, bool enabled);\n}\n\n/**\n * A high-level class for communicating over a TCP socket.\n *\n * The [Socket] exposes both a [Stream] and a [IOSink] interface, making it\n * ideal for using together with other [Stream]s.\n */\nabstract class Socket implements Stream<List<int>>, IOSink {\n  /**\n   * Creates a new socket connection to the host and port and returns a [Future]\n   * that will complete with either a [Socket] once connected or an error\n   * if the host-lookup or connection failed.\n   *\n   * [host] can either be a [String] or an [InternetAddress]. If [host] is a\n   * [String], [connect] will perform a [InternetAddress.lookup] and try\n   * all returned [InternetAddress]es, until connected. Unless a\n   * connection was established, the error from the first failing connection is\n   * returned.\n   */\n  external static Future<Socket> connect(host, int port);\n\n  /**\n   * Destroy the socket in both directions. Calling [destroy] will make the\n   * send a close event on the stream and will no longer react on data being\n   * piped to it.\n   *\n   * Call [close](inherited from [IOSink]) to only close the [Socket]\n   * for sending data.\n   */\n  void destroy();\n\n  /**\n   * Use [setOption] to customize the [RawSocket]. See [SocketOption] for\n   * available options.\n   *\n   * Returns [:true:] if the option was set successfully, false otherwise.\n   */\n  bool setOption(SocketOption option, bool enabled);\n\n  /**\n   * Returns the port used by this socket.\n   */\n  int get port;\n\n  /**\n   * Returns the remote port connected to by this socket.\n   */\n  int get remotePort;\n\n  /**\n   * Returns the [InternetAddress] used to connect this socket.\n   */\n  InternetAddress get address;\n\n  /**\n   * Returns the remote [InternetAddress] connected to by this socket.\n   */\n  InternetAddress get remoteAddress;\n}\n\n\n/**\n * Datagram package. Data send to and received from datagram sockets\n * contains the internet address and port of the destination or source\n * togeter with the data.\n */\nclass Datagram {\n  List<int> data;\n  InternetAddress address;\n  int port;\n\n  Datagram(this.data, this.address, this.port);\n}\n\n\n/**\n * The [RawDatagramSocket] is a low-level interface to an UDP socket,\n * exposing the raw events signaled by the system. It's a [Stream] of\n * [RawSocketEvent]s.\n *\n * Note that the event [RawSocketEvent.READ_CLOSED] will never be\n * received as an UDP socket cannot be closed by a remote peer.\n */\nabstract class RawDatagramSocket extends Stream<RawSocketEvent> {\n  /**\n   * Set or get, if the [RawDatagramSocket] should listen for\n   * [RawSocketEvent.READ] events. Default is [:true:].\n   */\n  bool readEventsEnabled;\n\n  /**\n   * Set or get, if the [RawDatagramSocket] should listen for\n   * [RawSocketEvent.WRITE] events. Default is [:true:].  This is a\n   * one-shot listener, and writeEventsEnabled must be set to true\n   * again to receive another write event.\n   */\n  bool writeEventsEnabled;\n\n  /**\n   * Set or get, whether multicast traffic is looped back to the host.\n   *\n   * By default multicast loopback is enabled.\n   */\n  bool multicastLoopback;\n\n  /**\n   * Set or get, the maximum network hops for multicast packages\n   * originating from this socket.\n   *\n   * For IPv4 this is referred to as TTL (time to live).\n   *\n   * By default this value is 1 causing multicast traffic to stay on\n   * the local network.\n   */\n  int multicastHops;\n\n  /**\n   * Set or get, the network interface used for outgoing multicast packages.\n   *\n   * A value of `null`indicate that the system chooses the network\n   * interface to use.\n   *\n   * By default this value is `null`\n   */\n  NetworkInterface multicastInterface;\n\n  /**\n   * Set or get, whether IPv4 broadcast is enabled.\n   *\n   * IPv4 broadcast needs to be enabled by the sender for sending IPv4\n   * broadcast packages. By default IPv4 broadcast is disabled.\n   *\n   * For IPv6 there is no general broadcast mechanism. Use multicast\n   * instead.\n   */\n  bool broadcastEnabled;\n\n  /**\n   * Creates a new raw datagram socket binding it to an address and\n   * port.\n   */\n  external static Future<RawDatagramSocket> bind(\n      host, int port, {bool reuseAddress: true});\n\n  /**\n   * Returns the port used by this socket.\n   */\n  int get port;\n\n  /**\n   * Returns the address used by this socket.\n   */\n  InternetAddress get address;\n\n  /**\n   * Close the datagram socket.\n   */\n  void close();\n\n  /**\n   * Send a datagram.\n   *\n   * Returns the number of bytes written. This will always be either\n   * the size of [buffer] or `0`.\n   */\n  int send(List<int> buffer, InternetAddress address, int port);\n\n  /**\n   * Receive a datagram. If there are no datagrams available `null` is\n   * returned.\n   */\n  Datagram receive();\n\n  /**\n   * Join a multicast group.\n   *\n   * If an error occur when trying to join the multicast group an\n   * exception is thrown.\n   */\n  void joinMulticast(InternetAddress group, {NetworkInterface interface});\n\n  /**\n   * Leave a multicast group.\n   *\n   * If an error occur when trying to join the multicase group an\n   * exception is thrown.\n   */\n  void leaveMulticast(InternetAddress group, {NetworkInterface interface});\n}\n\n\nclass SocketException implements IOException {\n  final String message;\n  final OSError osError;\n  final InternetAddress address;\n  final int port;\n\n  const SocketException(this.message, {this.osError, this.address, this.port});\n\n  String toString() {\n    StringBuffer sb = new StringBuffer();\n    sb.write(\"SocketException\");\n    if (!message.isEmpty) {\n      sb.write(\": $message\");\n      if (osError != null) {\n        sb.write(\" ($osError)\");\n      }\n    } else if (osError != null) {\n      sb.write(\": $osError\");\n    }\n    if (address != null) {\n      sb.write(\", address = ${address.host}\");\n    }\n    if (port != null) {\n      sb.write(\", port = $port\");\n    }\n    return sb.toString();\n  }\n}\n\u0000","sdk:/sdk/lib/io/service_object.dart":"// Copyright (c) 2014, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\npart of dart.io;\n\nint _nextServiceId = 1;\n\n// TODO(ajohnsen): Use other way of getting a uniq id.\nabstract class _ServiceObject {\n  int __serviceId = 0;\n  int get _serviceId {\n    if (__serviceId == 0) __serviceId = _nextServiceId++;\n    return __serviceId;\n  }\n\n  Map _toJSON(bool ref);\n\n  String get _servicePath => \"$_serviceTypePath/$_serviceId\";\n\n  String get _serviceTypePath;\n\n  String get _serviceTypeName;\n\n  String _serviceType(bool ref) {\n    if (ref) return \"@$_serviceTypeName\";\n    return _serviceTypeName;\n  }\n}\n\u0000","sdk:/sdk/lib/io/process.dart":"// Copyright (c) 2014, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\npart of dart.io;\n\n// TODO(ager): The only reason for this class is that we\n// cannot patch a top-level at this point.\nclass _ProcessUtils {\n  external static void _exit(int status);\n  external static void _setExitCode(int status);\n  external static int _getExitCode();\n  external static void _sleep(int millis);\n  external static int _pid(Process process);\n  external static Stream<ProcessSignal> _watchSignal(ProcessSignal signal);\n}\n\n/**\n * Exit the Dart VM process immediately with the given exit code.\n *\n * This does not wait for any asynchronous operations to terminate. Using\n * [exit] is therefore very likely to lose data.\n *\n * The handling of exit codes is platform specific.\n *\n * On Linux and Mac OS an exit code for normal termination will always\n * be in the range [0..255]. If an exit code outside this range is\n * set the actual exit code will be the lower 8 bits masked off and\n * treated as an unsigned value. E.g. using an exit code of -1 will\n * result in an actual exit code of 255 being reported.\n *\n * On Windows the exit code can be set to any 32-bit value. However\n * some of these values are reserved for reporting system errors like\n * crashes.\n *\n * Besides this the Dart executable itself uses an exit code of `254`\n * for reporting compile time errors and an exit code of `255` for\n * reporting runtime error (unhandled exception).\n *\n * Due to these facts it is recommended to only use exit codes in the\n * range [0..127] for communicating the result of running a Dart\n * program to the surrounding environment. This will avoid any\n * cross-platform issues.\n */\nvoid exit(int code) {\n  if (code is !int) {\n    throw new ArgumentError(\"Integer value for exit code expected\");\n  }\n  _ProcessUtils._exit(code);\n}\n\n/**\n * Set the global exit code for the Dart VM.\n *\n * The exit code is global for the Dart VM and the last assignment to\n * exitCode from any isolate determines the exit code of the Dart VM\n * on normal termination.\n *\n * Default value is `0`.\n *\n * See [exit] for more information on how to chose a value for the\n * exit code.\n */\nvoid set exitCode(int code) {\n  if (code is !int) {\n    throw new ArgumentError(\"Integer value for exit code expected\");\n  }\n  _ProcessUtils._setExitCode(code);\n}\n\n/*\n * Get the global exit code for the Dart VM.\n *\n * The exit code is global for the Dart VM and the last assignment to\n * exitCode from any isolate determines the exit code of the Dart VM\n * on normal termination.\n *\n * See [exit] for more information on how to chose a value for the\n * exit code.\n */\nint get exitCode => _ProcessUtils._getExitCode();\n\n/**\n * Sleep for the duration specified in [duration].\n *\n * Use this with care, as no asynchronous operations can be processed\n * in a isolate while it is blocked in a [sleep] call.\n */\nvoid sleep(Duration duration) {\n  int milliseconds = duration.inMilliseconds;\n  if (milliseconds < 0) {\n    throw new ArgumentError(\"sleep: duration cannot be negative\");\n  }\n  _ProcessUtils._sleep(milliseconds);\n}\n\n/**\n * Returns the PID of the current process.\n */\nint get pid => _ProcessUtils._pid(null);\n\n/**\n * The means to execute a program.\n *\n * Use the static [start] and [run] methods to start a new process.\n * The run method executes the process non-interactively to completion.\n * In contrast, the start method allows your code to interact with the\n * running process.\n *\n * ## Start a process with the run method\n *\n * The following code sample uses the run method to create a process\n * that runs the UNIX command `ls`, which lists the contents of a directory.\n * The run method completes with a [ProcessResult] object when the process\n * terminates. This provides access to the output and exit code from the\n * process. The run method does not return a Process object; this prevents your\n * code from interacting with the running process.\n *\n *     import 'dart:io';\n *\n *     main() {\n *       // List all files in the current directory in UNIX-like systems.\n *       Process.run('ls', ['-l']).then((ProcessResult results) {\n *         print(results.stdout);\n *       });\n *     }\n *\n * ## Start a process with the start method\n *\n * The following example uses start to create the process.\n * The start method returns a [Future] for a Process object.\n * When the future completes the process is started and\n * your code can interact with the\n * Process: writing to stdin, listening to stdout, and so on.\n *\n * The following sample starts the UNIX `cat` utility, which when given no\n * command-line arguments, echos its input.\n * The program writes to the process's standard input stream\n * and prints data from its standard output stream.\n *\n *     import 'dart:io';\n *     import 'dart:convert';\n *\n *     main() {\n *       Process.start('cat', []).then((Process process) {\n *         process.stdout\n *             .transform(UTF8.decoder)\n *             .listen((data) { print(data); });\n *         process.stdin.writeln('Hello, world!');\n *         process.stdin.writeln('Hello, galaxy!');\n *         process.stdin.writeln('Hello, universe!');\n *       });\n *     }\n *\n * ## Standard I/O streams\n *\n * As seen in the previous code sample, you can interact with the Process's\n * standard output stream through the getter [stdout],\n * and you can interact with the Process's standard input stream through\n * the getter [stdin].\n * In addition, Process provides a getter [stderr] for using the Process's\n * standard error stream.\n *\n * A Process's streams are distinct from the top-level streams\n * for the current program.\n *\n * ## Exit codes\n *\n * Call the [exitCode] method to get the exit code of the process.\n * The exit code indicates whether the program terminated successfully\n * (usually indicated with an exit code of 0) or with an error.\n *\n * If the start method is used, the exitCode is available through a future\n * on the Process object (as shown in the example below).\n * If the run method is used, the exitCode is available\n * through a getter on the ProcessResult instance.\n *\n *     import 'dart:io';\n *\n *     main() {\n *       Process.start('ls', ['-l']).then((process) {\n *         // Get the exit code from the new process.\n *         process.exitCode.then((exitCode) {\n *           print('exit code: $exitCode');\n *         });\n *       });\n *     }\n *\n * ## Other resources\n *\n * [Dart by Example](https://www.dartlang.org/dart-by-example/#dart-io-and-command-line-apps)\n * provides additional task-oriented code samples that show how to use\n * various API from the [dart:io] library.\n */\nabstract class Process {\n  /**\n   * Returns a [:Future:] which completes with the exit code of the process\n   * when the process completes.\n   *\n   * The handling of exit codes is platform specific.\n   *\n   * On Linux and Mac a normal exit code will be a positive value in\n   * the range [0..255]. If the process was terminated due to a signal\n   * the exit code will be a negative value in the range [-255..-1],\n   * where the absolute value of the exit code is the signal\n   * number. For example, if a process crashes due to a segmentation\n   * violation the exit code will be -11, as the signal SIGSEGV has the\n   * number 11.\n   *\n   * On Windows a process can report any 32-bit value as an exit\n   * code. When returning the exit code this exit code is turned into\n   * a signed value. Some special values are used to report\n   * termination due to some system event. E.g. if a process crashes\n   * due to an access violation the 32-bit exit code is `0xc0000005`,\n   * which will be returned as the negative number `-1073741819`. To\n   * get the original 32-bit value use `(0x100000000 + exitCode) &\n   * 0xffffffff`.\n   */\n  Future<int> exitCode;\n\n  /**\n   * Starts a process running the [executable] with the specified\n   * [arguments]. Returns a [:Future<Process>:] that completes with a\n   * Process instance when the process has been successfully\n   * started. That [Process] object can be used to interact with the\n   * process. If the process cannot be started the returned [Future]\n   * completes with an exception.\n   *\n   * Use [workingDirectory] to set the working directory for the process. Note\n   * that the change of directory occurs before executing the process on some\n   * platforms, which may have impact when using relative paths for the\n   * executable and the arguments.\n   *\n   * Use [environment] to set the environment variables for the process. If not\n   * set the environment of the parent process is inherited. Currently, only\n   * US-ASCII environment variables are supported and errors are likely to occur\n   * if an environment variable with code-points outside the US-ASCII range is\n   * passed in.\n   *\n   * If [includeParentEnvironment] is `true`, the process's environment will\n   * include the parent process's environment, with [environment] taking\n   * precedence. Default is `true`.\n   *\n   * If [runInShell] is true, the process will be spawned through a system\n   * shell. On Linux and Mac OS, [:/bin/sh:] is used, while\n   * [:%WINDIR%\\system32\\cmd.exe:] is used on Windows.\n   *\n   * Users must read all data coming on the [stdout] and [stderr]\n   * streams of processes started with [:Process.start:]. If the user\n   * does not read all data on the streams the underlying system\n   * resources will not be freed since there is still pending data.\n   *\n   * The following code uses `Process.start` to grep for `main` in the\n   * file `test.dart` on Linux.\n   *\n   *     Process.start('grep', ['-i', 'main', 'test.dart']).then((process) {\n   *       stdout.addStream(process.stdout);\n   *       stderr.addStream(process.stderr);\n   *     });\n   */\n  external static Future<Process> start(\n      String executable,\n      List<String> arguments,\n      {String workingDirectory,\n       Map<String, String> environment,\n       bool includeParentEnvironment: true,\n       bool runInShell: false});\n\n  /**\n   * Starts a process and runs it non-interactively to completion. The\n   * process run is [executable] with the specified [arguments].\n   *\n   * Use [workingDirectory] to set the working directory for the process. Note\n   * that the change of directory occurs before executing the process on some\n   * platforms, which may have impact when using relative paths for the\n   * executable and the arguments.\n   *\n   * Use [environment] to set the environment variables for the process. If not\n   * set the environment of the parent process is inherited. Currently, only\n   * US-ASCII environment variables are supported and errors are likely to occur\n   * if an environment variable with code-points outside the US-ASCII range is\n   * passed in.\n   *\n   * If [includeParentEnvironment] is `true`, the process's environment will\n   * include the parent process's environment, with [environment] taking\n   * precedence. Default is `true`.\n   *\n   * If [runInShell] is true, the process will be spawned through a system\n   * shell. On Linux and Mac OS, `/bin/sh` is used, while\n   * `%WINDIR%\\system32\\cmd.exe` is used on Windows.\n   *\n   * The encoding used for decoding `stdout` and `stderr` into text is\n   * controlled through [stdoutEncoding] and [stderrEncoding]. The\n   * default encoding is [SYSTEM_ENCODING]. If `null` is used no\n   * decoding will happen and the [ProcessResult] will hold binary\n   * data.\n   *\n   * Returns a `Future<ProcessResult>` that completes with the\n   * result of running the process, i.e., exit code, standard out and\n   * standard in.\n   *\n   * The following code uses `Process.run` to grep for `main` in the\n   * file `test.dart` on Linux.\n   *\n   *     Process.run('grep', ['-i', 'main', 'test.dart']).then((result) {\n   *       stdout.write(result.stdout);\n   *       stderr.write(result.stderr);\n   *     });\n   */\n  external static Future<ProcessResult> run(\n      String executable,\n      List<String> arguments,\n      {String workingDirectory,\n       Map<String, String> environment,\n       bool includeParentEnvironment: true,\n       bool runInShell: false,\n       Encoding stdoutEncoding: SYSTEM_ENCODING,\n       Encoding stderrEncoding: SYSTEM_ENCODING});\n\n\n  /**\n   * Starts a process and runs it to completion. This is a synchronous\n   * call and will block until the child process terminates.\n   *\n   * The arguments are the same as for `Process.run`.\n   *\n   * Returns a `ProcessResult` with the result of running the process,\n   * i.e., exit code, standard out and standard in.\n   */\n  external static ProcessResult runSync(\n      String executable,\n      List<String> arguments,\n      {String workingDirectory,\n       Map<String, String> environment,\n       bool includeParentEnvironment: true,\n       bool runInShell: false,\n       Encoding stdoutEncoding: SYSTEM_ENCODING,\n       Encoding stderrEncoding: SYSTEM_ENCODING});\n\n  /**\n   * Returns the standard output stream of the process as a [:Stream:].\n   */\n  Stream<List<int>> get stdout;\n\n  /**\n   * Returns the standard error stream of the process as a [:Stream:].\n   */\n  Stream<List<int>> get stderr;\n\n  /**\n   * Returns the standard input stream of the process as an [IOSink].\n   */\n  IOSink get stdin;\n\n  /**\n   * Returns the process id of the process.\n   */\n  int get pid;\n\n  /**\n   * On Linux and Mac OS, [kill] sends [signal] to the process. When the process\n   * terminates as a result of calling [kill], the value for [exitCode] may be a\n   * negative number corresponding to the provided [signal].\n   *\n   * On Windows, [kill] kills the process, ignoring the [signal] flag.\n   *\n   * Returns [:true:] if the signal is successfully sent and process is killed.\n   * Otherwise the signal could not be sent, usually meaning that the process is\n   * already dead.\n   */\n  bool kill([ProcessSignal signal = ProcessSignal.SIGTERM]);\n}\n\n\n/**\n * [ProcessResult] represents the result of running a non-interactive\n * process started with [:Process.run:].\n */\nabstract class ProcessResult {\n  /**\n   * Exit code for the process.\n   *\n   * See [Process.exitCode] for more information in the exit code\n   * value.\n   */\n  int get exitCode;\n\n  /**\n   * Standard output from the process. The value used for the\n   * `stdoutEncoding` argument to `Process.run` determines the type. If\n   * `null` was used this value is of type `List<int> otherwise it is\n   * of type `String`.\n   */\n  get stdout;\n\n  /**\n   * Standard error from the process. The value used for the\n   * `stderrEncoding` argument to `Process.run` determines the type. If\n   * `null` was used this value is of type `List<int>\n   * otherwise it is of type `String`.\n   */\n  get stderr;\n\n  /**\n   * Process id from the process.\n   */\n  int get pid;\n}\n\n\n/**\n * On Posix systems, [ProcessSignal] is used to send a specific signal\n * to a child process, see [:Process.kill:].\n *\n * Some [ProcessSignal]s can also be watched, as a way to intercept the default\n * signal handler and implement another. See [ProcessSignal.watch] for more\n * information.\n */\nclass ProcessSignal {\n  static const ProcessSignal SIGHUP = const ProcessSignal._(1, \"SIGHUP\");\n  static const ProcessSignal SIGINT = const ProcessSignal._(2, \"SIGINT\");\n  static const ProcessSignal SIGQUIT = const ProcessSignal._(3, \"SIGQUIT\");\n  static const ProcessSignal SIGILL = const ProcessSignal._(4, \"SIGILL\");\n  static const ProcessSignal SIGTRAP = const ProcessSignal._(5, \"SIGTRAP\");\n  static const ProcessSignal SIGABRT = const ProcessSignal._(6, \"SIGABRT\");\n  static const ProcessSignal SIGBUS = const ProcessSignal._(7, \"SIGBUS\");\n  static const ProcessSignal SIGFPE = const ProcessSignal._(8, \"SIGFPE\");\n  static const ProcessSignal SIGKILL = const ProcessSignal._(9, \"SIGKILL\");\n  static const ProcessSignal SIGUSR1 = const ProcessSignal._(10, \"SIGUSR1\");\n  static const ProcessSignal SIGSEGV = const ProcessSignal._(11, \"SIGSEGV\");\n  static const ProcessSignal SIGUSR2 = const ProcessSignal._(12, \"SIGUSR2\");\n  static const ProcessSignal SIGPIPE = const ProcessSignal._(13, \"SIGPIPE\");\n  static const ProcessSignal SIGALRM = const ProcessSignal._(14, \"SIGALRM\");\n  static const ProcessSignal SIGTERM = const ProcessSignal._(15, \"SIGTERM\");\n  static const ProcessSignal SIGCHLD = const ProcessSignal._(17, \"SIGCHLD\");\n  static const ProcessSignal SIGCONT = const ProcessSignal._(18, \"SIGCONT\");\n  static const ProcessSignal SIGSTOP = const ProcessSignal._(19, \"SIGSTOP\");\n  static const ProcessSignal SIGTSTP = const ProcessSignal._(20, \"SIGTSTP\");\n  static const ProcessSignal SIGTTIN = const ProcessSignal._(21, \"SIGTTIN\");\n  static const ProcessSignal SIGTTOU = const ProcessSignal._(22, \"SIGTTOU\");\n  static const ProcessSignal SIGURG = const ProcessSignal._(23, \"SIGURG\");\n  static const ProcessSignal SIGXCPU = const ProcessSignal._(24, \"SIGXCPU\");\n  static const ProcessSignal SIGXFSZ = const ProcessSignal._(25, \"SIGXFSZ\");\n  static const ProcessSignal SIGVTALRM = const ProcessSignal._(26, \"SIGVTALRM\");\n  static const ProcessSignal SIGPROF = const ProcessSignal._(27, \"SIGPROF\");\n  static const ProcessSignal SIGWINCH = const ProcessSignal._(28, \"SIGWINCH\");\n  static const ProcessSignal SIGPOLL = const ProcessSignal._(29, \"SIGPOLL\");\n  static const ProcessSignal SIGSYS = const ProcessSignal._(31, \"SIGSYS\");\n\n  final int _signalNumber;\n  final String _name;\n\n  const ProcessSignal._(this._signalNumber, this._name);\n\n  String toString() => _name;\n\n  /**\n   * Watch for process signals.\n   *\n   * The following [ProcessSignal]s can be listened to:\n   *\n   *   * [ProcessSignal.SIGHUP].\n   *   * [ProcessSignal.SIGINT]. Signal sent by e.g. CTRL-C.\n   *   * [ProcessSignal.SIGTERM]. Not available on Windows.\n   *   * [ProcessSignal.SIGUSR1]. Not available on Windows.\n   *   * [ProcessSignal.SIGUSR2]. Not available on Windows.\n   *   * [ProcessSignal.SIGWINCH]. Not available on Windows.\n   *\n   * Other signals are disallowed, as they may be used by the VM.\n   *\n   * A signal can be watched multiple times, from multiple isolates, where all\n   * callbacks are invoked when signaled, in no specific order.\n   */\n  Stream<ProcessSignal> watch() => _ProcessUtils._watchSignal(this);\n}\n\n\nclass SignalException implements IOException {\n  final String message;\n  final osError;\n\n  const SignalException(this.message, [this.osError = null]);\n\n  String toString() {\n    var msg = \"\";\n    if (osError != null) {\n      msg = \", osError: $osError\";\n    }\n    return \"SignalException: $message$msg\";\n  }\n}\n\n\nclass ProcessException implements IOException {\n  /**\n   * Contains the executable provided for the process.\n   */\n  final String executable;\n\n  /**\n   * Contains the arguments provided for the process.\n   */\n  final List<String> arguments;\n\n  /**\n   * Contains the system message for the process exception if any.\n   */\n  final String message;\n\n  /**\n   * Contains the OS error code for the process exception if any.\n   */\n  final int errorCode;\n\n  const ProcessException(this.executable, this.arguments, [this.message = \"\",\n                         this.errorCode = 0]);\n  String toString() {\n    var msg = (message == null) ? 'OS error code: $errorCode' : message;\n    var args = arguments.join(' ');\n    return \"ProcessException: $msg\\n  Command: $executable $args\";\n  }\n}\n\u0000","sdk:/sdk/lib/io/platform_impl.dart":"// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\npart of dart.io;\n\nclass _Platform {\n  external static int _numberOfProcessors();\n  external static String _pathSeparator();\n  external static String _operatingSystem();\n  external static _localHostname();\n  external static _executable();\n  external static _environment();\n  external static List<String> _executableArguments();\n  external static String _packageRoot();\n  external static String _version();\n\n  static String executable = _executable();\n  static String packageRoot = _packageRoot();\n\n  // Cache the OS environemnt. This can be an OSError instance if\n  // retrieving the environment failed.\n  static var _environmentCache;\n\n  static int get numberOfProcessors => _numberOfProcessors();\n  static String get pathSeparator => _pathSeparator();\n  static String get operatingSystem => _operatingSystem();\n  static Uri script;\n\n  // This script singleton is written to by the embedder if applicable.\n  static void set _nativeScript(String path) {\n    if (path.startsWith('http:') ||\n        path.startsWith('https:') ||\n        path.startsWith('package:') ||\n        path.startsWith('dart:') ||\n        path.startsWith('file:')) {\n      script = Uri.parse(path);\n    } else {\n      script = Uri.base.resolveUri(new Uri.file(path));\n    }\n  }\n\n  static String get localHostname {\n    var result = _localHostname();\n    if (result is OSError) {\n      throw result;\n    } else {\n      return result;\n    }\n  }\n\n  static List<String> get executableArguments => _executableArguments();\n\n  static Map<String, String> get environment {\n    if (_environmentCache == null) {\n      var env = _environment();\n      if (env is !OSError) {\n        var isWindows = operatingSystem == 'windows';\n        var result = isWindows ? new _CaseInsensitiveStringMap() : new Map();\n        for (var str in env) {\n          // When running on Windows through cmd.exe there are strange\n          // environment variables that are used to record the current\n          // working directory for each drive and the exit code for the\n          // last command. As an example: '=A:=A:\\subdir' records the\n          // current working directory on the 'A' drive.  In order to\n          // handle these correctly we search for a second occurrence of\n          // of '=' in the string if the first occurrence is at index 0.\n          var equalsIndex = str.indexOf('=');\n          if (equalsIndex == 0) {\n            equalsIndex = str.indexOf('=', 1);\n          }\n          assert(equalsIndex != -1);\n          result[str.substring(0, equalsIndex)] =\n              str.substring(equalsIndex + 1);\n        }\n        _environmentCache = new UnmodifiableMapView<String, String>(result);\n      } else {\n        _environmentCache = env;\n      }\n    }\n\n    if (_environmentCache is OSError) {\n      throw _environmentCache;\n    } else {\n      return _environmentCache;\n    }\n  }\n\n  static String get version => _version();\n}\n\n// Environment variables are case-insensitive on Windows. In order\n// to reflect that we use a case-insensitive string map on Windows.\nclass _CaseInsensitiveStringMap<V> implements Map<String, V> {\n  final Map<String, V> _map = new Map<String, V>();\n\n  bool containsKey(String key) => _map.containsKey(key.toUpperCase());\n  bool containsValue(Object value) => _map.containsValue(value);\n  V operator [](String key) => _map[key.toUpperCase()];\n  void operator []=(String key, V value) {\n    _map[key.toUpperCase()] = value;\n  }\n  V putIfAbsent(String key, V ifAbsent()) {\n    _map.putIfAbsent(key.toUpperCase(), ifAbsent);\n  }\n  addAll(Map other) {\n    other.forEach((key, value) => this[key.toUpperCase()] = value);\n  }\n  V remove(String key) => _map.remove(key.toUpperCase());\n  void clear() => _map.clear();\n  void forEach(void f(String key, V value)) => _map.forEach(f);\n  Iterable<String> get keys => _map.keys;\n  Iterable<V> get values => _map.values;\n  int get length => _map.length;\n  bool get isEmpty => _map.isEmpty;\n  bool get isNotEmpty => _map.isNotEmpty;\n  String toString() => _map.toString();\n}\n\u0000","sdk:/sdk/lib/io/platform.dart":"// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\npart of dart.io;\n\n/**\n * Information about the environment in which the current program is running.\n *\n * Platform provides information such as the operating system,\n * the hostname of the computer, the value of environment variables,\n * the path to the running program,\n * and so on.\n *\n * ## Get the URI to the current Dart script\n *\n * Use the [script] getter to get the URI to the currently running\n * Dart script.\n *\n *     import 'dart:io' show Platform;\n *\n *     void main() {\n *       // Get the URI of the script being run.\n *       var uri = Platform.script;\n *       // Convert the URI to a path.\n *       var path = uri.toFilePath();\n *     }\n *\n * ## Get the value of an environment variable\n *\n * The [environment] getter returns a the names and values of environment\n * variables in a [Map] that contains key-value pairs of strings. The Map is\n * unmodifiable. This sample shows how to get the value of the `PATH`\n * environment variable.\n *\n *     import 'dart:io' show Platform;\n *\n *     void main() {\n *       Map<String, String> envVars = Platform.environment;\n *       print(envVars['PATH']);\n *     }\n * \n * ## Determine the OS\n *\n * You can get the name of the operating system as a string with the\n * [operatingSystem] getter. You can also use one of the static boolean\n * getters: [isMacOS], [isLinux], and [isWindows].\n *\n *     import 'dart:io' show Platform, stdout;\n *\n *     void main() {\n *       // Get the operating system as a string.\n *       String os = Platform.operatingSystem;\n *       // Or, use a predicate getter.\n *       if (Platform.isMacOS) {\n *         Print('is a Mac'); \n *       } else {\n *        print('is not a Mac');\n *       }\n *     }\n *\n * ## Other resources\n *\n * [Dart by Example](https://www.dartlang.org/dart-by-example/#dart-io-and-command-line-apps)\n * provides additional task-oriented code samples that show how to use \n * various API from the [dart:io] library.\n */\nclass Platform {\n  static final _numberOfProcessors = _Platform.numberOfProcessors;\n  static final _pathSeparator = _Platform.pathSeparator;\n  static final _operatingSystem = _Platform.operatingSystem;\n  static final _localHostname = _Platform.localHostname;\n  static final _version = _Platform.version;\n\n  /**\n   * Get the number of processors of the machine.\n   */\n  static int get numberOfProcessors => _numberOfProcessors;\n\n  /**\n   * Get the path separator used by the operating system to separate\n   * components in file paths.\n   */\n  static String get pathSeparator => _pathSeparator;\n\n  /**\n   * Get a string (`linux`, `macos`, `windows` or `android`)\n   * representing the operating system.\n   */\n  static String get operatingSystem => _operatingSystem;\n\n  /**\n   * Get the local hostname for the system.\n   */\n  static String get localHostname => _localHostname;\n\n  /**\n   * Returns true if the operating system is Linux.\n   */\n  static final bool isLinux = (_operatingSystem == \"linux\");\n\n  /**\n   * Returns true if the operating system is Mac OS.\n   */\n  static final bool isMacOS = (_operatingSystem == \"macos\");\n\n  /**\n   * Returns true if the operating system is Windows.\n   */\n  static final bool isWindows = (_operatingSystem == \"windows\");\n\n  /**\n   * Returns true if the operating system is Android.\n   */\n  static final bool isAndroid = (_operatingSystem == \"android\");\n\n  /**\n   * Get the environment for this process.\n   *\n   * The returned environment is an unmodifiable map which content is\n   * retrieved from the operating system on its first use.\n   *\n   * Environment variables on Windows are case-insensitive. The map\n   * returned on Windows is therefore case-insensitive and will convert\n   * all keys to upper case. On other platforms the returned map is\n   * a standard case-sensitive map.\n   */\n  static Map<String, String> get environment => _Platform.environment;\n\n  /**\n   * Returns the path of the executable used to run the script in this\n   * isolate.\n   *\n   * If the execution environment does not support [executable] an empty\n   * string is returned.\n   */\n  static String get executable => _Platform.executable;\n\n  /**\n   * Returns the absolute URI of the script being run in this\n   * isolate.\n   *\n   * If the script argument on the command line is relative,\n   * it is resolved to an absolute URI before fetching the script, and\n   * this absolute URI is returned.\n   *\n   * URI resolution only does string manipulation on the script path, and this\n   * may be different from the file system's path resolution behavior. For\n   * example, a symbolic link immediately followed by '..' will not be\n   * looked up.\n   *\n   * If the executable environment does not support [script] an empty\n   * [Uri] is returned.\n   */\n  static Uri get script => _Platform.script;\n\n  /**\n   * Returns the flags passed to the executable used to run the script in this\n   * isolate. These are the command-line flags between the executable name\n   * and the script name. Each fetch of executableArguments returns a new\n   * List, containing the flags passed to the executable.\n   */\n  static List<String> get executableArguments => _Platform.executableArguments;\n\n  /**\n   * Returns the value of the --package-root flag passed to the executable\n   * used to run the script in this isolate.  This is the directory in which\n   * Dart packages are looked up.\n   *\n   * If there is no --package-root flag, then the empty string is returned.\n   */\n  static String get packageRoot => _Platform.packageRoot;\n\n  /**\n   * Returns the version of the current Dart runtime.\n   */\n  static String get version => _version;\n}\n\u0000","sdk:/sdk/lib/io/link.dart":"// Copyright (c) 2013, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\npart of dart.io;\n\n/**\n * [Link] objects are references to filesystem links.\n *\n */\nabstract class Link extends FileSystemEntity {\n  /**\n   * Creates a Link object.\n   */\n  factory Link(String path) => new _Link(path);\n\n  /**\n   * Creates a [Link] object.\n   *\n   * If [path] is a relative path, it will be interpreted relative to the\n   * current working directory (see [Directory.current]), when used.\n   *\n   * If [path] is an absolute path, it will be immune to changes to the\n   * current working directory.\n   */\n  factory Link.fromUri(Uri uri) => new Link(uri.toFilePath());\n\n  /**\n   * Creates a symbolic link. Returns a [:Future<Link>:] that completes with\n   * the link when it has been created. If the link exists,\n   * the future will complete with an error.\n   *\n   * If [recursive] is false, the default, the link is created\n   * only if all directories in its path exist.\n   * If [recursive] is true, all non-existing path\n   * components are created. The directories in the path of [target] are\n   * not affected, unless they are also in [path].\n   *\n   * On the Windows platform, this will only work with directories, and the\n   * target directory must exist. The link will be created as a Junction.\n   * Only absolute links will be created, and relative paths to the target\n   * will be converted to absolute paths by joining them with the path of the\n   * directory the link is contained in.\n   *\n   * On other platforms, the posix symlink() call is used to make a symbolic\n   * link containing the string [target].  If [target] is a relative path,\n   * it will be interpreted relative to the directory containing the link.\n   */\n  Future<Link> create(String target, {bool recursive: false});\n\n  /**\n   * Synchronously create the link. Calling [createSync] on an existing link\n   * will throw an exception.\n   *\n   * If [recursive] is false, the default, the link is created only if all\n   * directories in its path exist. If [recursive] is true, all\n   * non-existing path components are created. The directories in\n   * the path of [target] are not affected, unless they are also in [path].\n   *\n   * On the Windows platform, this will only work with directories, and the\n   * target directory must exist. The link will be created as a Junction.\n   * Only absolute links will be created, and relative paths to the target\n   * will be converted to absolute paths.\n   *\n   * On other platforms, the posix symlink() call is used to make a symbolic\n   * link containing the string [target].  If [target] is a relative path,\n   * it will be interpreted relative to the directory containing the link.\n   */\n  void createSync(String target, {bool recursive: false});\n\n  /**\n   * Synchronously updates the link. Calling [updateSync] on a non-existing link\n   * will throw an exception.\n   *\n   * On the Windows platform, this will only work with directories, and the\n   * target directory must exist.\n   */\n  void updateSync(String target);\n\n  /**\n   * Updates the link. Returns a [:Future<Link>:] that completes with the\n   * link when it has been updated.  Calling [update] on a non-existing link\n   * will complete its returned future with an exception.\n   *\n   * On the Windows platform, this will only work with directories, and the\n   * target directory must exist.\n   */\n  Future<Link> update(String target);\n\n  Future<String> resolveSymbolicLinks();\n\n  String resolveSymbolicLinksSync();\n\n  /**\n   * Renames this link. Returns a `Future<Link>` that completes\n   * with a [Link] instance for the renamed link.\n   *\n   * If [newPath] identifies an existing link, that link is\n   * replaced. If [newPath] identifies an existing file or directory,\n   * the operation fails and the future completes with an exception.\n   */\n  Future<Link> rename(String newPath);\n\n   /**\n   * Synchronously renames this link. Returns a [Link]\n   * instance for the renamed link.\n   *\n   * If [newPath] identifies an existing link, that link is\n   * replaced. If [newPath] identifies an existing file or directory\n   * the operation fails and an exception is thrown.\n   */\n  Link renameSync(String newPath);\n\n  /**\n   * Returns a [Link] instance whose path is the absolute path to [this].\n   *\n   * The absolute path is computed by prefixing\n   * a relative path with the current working directory, and returning\n   * an absolute path unchanged.\n   */\n  Link get absolute;\n\n  /**\n   * Gets the target of the link. Returns a future that completes with\n   * the path to the target.\n   *\n   * If the returned target is a relative path, it is relative to the\n   * directory containing the link.\n   *\n   * If the link does not exist, or is not a link, the future completes with\n   * a FileSystemException.\n   */\n  Future<String> target();\n\n  /**\n   * Synchronously gets the target of the link. Returns the path to the target.\n   *\n   * If the returned target is a relative path, it is relative to the\n   * directory containing the link.\n   *\n   * If the link does not exist, or is not a link, throws a FileSystemException.\n   */\n  String targetSync();\n}\n\n\nclass _Link extends FileSystemEntity implements Link {\n  final String path;\n\n  _Link(this.path) {\n    if (path is! String) {\n      throw new ArgumentError('${Error.safeToString(path)} '\n                              'is not a String');\n    }\n  }\n\n  String toString() => \"Link: '$path'\";\n\n  Future<bool> exists() => FileSystemEntity.isLink(path);\n\n  bool existsSync() => FileSystemEntity.isLinkSync(path);\n\n  Link get absolute => new Link(_absolutePath);\n\n  Future<FileStat> stat() => FileStat.stat(path);\n\n  FileStat statSync() => FileStat.statSync(path);\n\n  Future<Link> create(String target, {bool recursive: false}) {\n    if (Platform.isWindows) {\n      target = _makeWindowsLinkTarget(target);\n    }\n    var result = recursive ? parent.create(recursive: true)\n                           : new Future.value(null);\n    return result\n      .then((_) => _IOService.dispatch(_FILE_CREATE_LINK, [path, target]))\n      .then((response) {\n        if (_isErrorResponse(response)) {\n          throw _exceptionFromResponse(\n              response, \"Cannot create link to target '$target'\", path);\n        }\n        return this;\n      });\n  }\n\n  void createSync(String target, {bool recursive: false}) {\n    if (recursive) {\n      parent.createSync(recursive: true);\n    }\n    if (Platform.isWindows) {\n      target = _makeWindowsLinkTarget(target);\n    }\n    var result = _File._createLink(path, target);\n    throwIfError(result, \"Cannot create link\", path);\n  }\n\n  // Put target into the form \"\\??\\C:\\my\\target\\dir\".\n  String _makeWindowsLinkTarget(String target) {\n    Uri base = new Uri.file('${Directory.current.path}\\\\');\n    Uri link = new Uri.file(path);\n    Uri destination = new Uri.file(target);\n    String result = base.resolveUri(link).resolveUri(destination).toFilePath();\n    if (result.length > 3 && result[1] == ':' && result[2] == '\\\\') {\n      return '\\\\??\\\\$result';\n    } else {\n      throw new FileSystemException(\n          'Target $result of Link.create on Windows cannot be converted' +\n          ' to start with a drive letter.  Unexpected error.');\n    }\n  }\n\n  void updateSync(String target) {\n    // TODO(12414): Replace with atomic update, where supported by platform.\n    // Atomically changing a link can be done by creating the new link, with\n    // a different name, and using the rename() posix call to move it to\n    // the old name atomically.\n    deleteSync();\n    createSync(target);\n  }\n\n  Future<Link> update(String target) {\n    // TODO(12414): Replace with atomic update, where supported by platform.\n    // Atomically changing a link can be done by creating the new link, with\n    // a different name, and using the rename() posix call to move it to\n    // the old name atomically.\n    return delete().then((_) => create(target));\n  }\n\n  Future<Link> _delete({bool recursive: false}) {\n    if (recursive) {\n      return new Directory(path).delete(recursive: true).then((_) => this);\n    }\n    return _IOService.dispatch(_FILE_DELETE_LINK, [path]).then((response) {\n      if (_isErrorResponse(response)) {\n        throw _exceptionFromResponse(response, \"Cannot delete link\", path);\n      }\n      return this;\n    });\n  }\n\n  void _deleteSync({bool recursive: false}) {\n    if (recursive) {\n      return new Directory(path).deleteSync(recursive: true);\n    }\n    var result = _File._deleteLinkNative(path);\n    throwIfError(result, \"Cannot delete link\", path);\n  }\n\n  Future<Link> rename(String newPath) {\n    return _IOService.dispatch(_FILE_RENAME_LINK, [path, newPath])\n        .then((response) {\n          if (_isErrorResponse(response)) {\n            throw _exceptionFromResponse(\n                response, \"Cannot rename link to '$newPath'\", path);\n          }\n          return new Link(newPath);\n        });\n  }\n\n  Link renameSync(String newPath) {\n    var result = _File._renameLink(path, newPath);\n    throwIfError(result, \"Cannot rename link '$path' to '$newPath'\");\n    return new Link(newPath);\n  }\n\n  Future<String> target() {\n    return _IOService.dispatch(_FILE_LINK_TARGET, [path]).then((response) {\n      if (_isErrorResponse(response)) {\n        throw _exceptionFromResponse(\n            response, \"Cannot get target of link\", path);\n      }\n      return response;\n    });\n  }\n\n  String targetSync() {\n    var result = _File._linkTarget(path);\n    throwIfError(result, \"Cannot read link\", path);\n    return result;\n  }\n\n  static throwIfError(Object result, String msg, [String path = \"\"]) {\n    if (result is OSError) {\n      throw new FileSystemException(msg, path, result);\n    }\n  }\n\n  bool _isErrorResponse(response) {\n    return response is List && response[0] != _SUCCESS_RESPONSE;\n  }\n\n  _exceptionFromResponse(response, String message, String path) {\n    assert(_isErrorResponse(response));\n    switch (response[_ERROR_RESPONSE_ERROR_TYPE]) {\n      case _ILLEGAL_ARGUMENT_RESPONSE:\n        return new ArgumentError();\n      case _OSERROR_RESPONSE:\n        var err = new OSError(response[_OSERROR_RESPONSE_MESSAGE],\n                              response[_OSERROR_RESPONSE_ERROR_CODE]);\n        return new FileSystemException(message, path, err);\n      default:\n        return new Exception(\"Unknown error\");\n    }\n  }\n}\n\u0000","sdk:/sdk/lib/io/io_service.dart":"// Copyright (c) 2013, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\npart of dart.io;\n\n// This list must be kept in sync with the list in runtime/bin/io_service.h\nconst int _FILE_EXISTS = 0;\nconst int _FILE_CREATE = 1;\nconst int _FILE_DELETE = 2;\nconst int _FILE_RENAME = 3;\nconst int _FILE_COPY = 4;\nconst int _FILE_OPEN = 5;\nconst int _FILE_RESOLVE_SYMBOLIC_LINKS = 6;\nconst int _FILE_CLOSE = 7;\nconst int _FILE_POSITION = 8;\nconst int _FILE_SET_POSITION = 9;\nconst int _FILE_TRUNCATE = 10;\nconst int _FILE_LENGTH = 11;\nconst int _FILE_LENGTH_FROM_PATH = 12;\nconst int _FILE_LAST_MODIFIED = 13;\nconst int _FILE_FLUSH = 14;\nconst int _FILE_READ_BYTE = 15;\nconst int _FILE_WRITE_BYTE = 16;\nconst int _FILE_READ = 17;\nconst int _FILE_READ_INTO = 18;\nconst int _FILE_WRITE_FROM = 19;\nconst int _FILE_CREATE_LINK = 20;\nconst int _FILE_DELETE_LINK = 21;\nconst int _FILE_RENAME_LINK = 22;\nconst int _FILE_LINK_TARGET = 23;\nconst int _FILE_TYPE = 24;\nconst int _FILE_IDENTICAL = 25;\nconst int _FILE_STAT = 26;\nconst int _SOCKET_LOOKUP = 27;\nconst int _SOCKET_LIST_INTERFACES = 28;\nconst int _SOCKET_REVERSE_LOOKUP = 29;\nconst int _DIRECTORY_CREATE = 30;\nconst int _DIRECTORY_DELETE = 31;\nconst int _DIRECTORY_EXISTS = 32;\nconst int _DIRECTORY_CREATE_TEMP = 33;\nconst int _DIRECTORY_LIST_START = 34;\nconst int _DIRECTORY_LIST_NEXT = 35;\nconst int _DIRECTORY_LIST_STOP = 36;\nconst int _DIRECTORY_RENAME = 37;\nconst int _SSL_PROCESS_FILTER = 38;\n\nclass _IOService {\n  external static Future dispatch(int request, List data);\n}\n\u0000","sdk:/sdk/lib/io/io_sink.dart":"// Copyright (c) 2013, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\npart of dart.io;\n\n/**\n * Helper class to wrap a [StreamConsumer<List<int>>] and provide\n * utility functions for writing to the StreamConsumer directly. The\n * [IOSink] buffers the input given by all [StringSink] methods and will delay\n * an [addStream] until the buffer is flushed.\n *\n * When the [IOSink] is bound to a stream (through [addStream]) any call\n * to the [IOSink] will throw a [StateError]. When the [addStream] completes,\n * the [IOSink] will again be open for all calls.\n *\n * If data is added to the [IOSink] after the sink is closed, the data will be\n * ignored. Use the [done] future to be notified when the [IOSink] is closed.\n */\nabstract class IOSink implements StreamSink<List<int>>, StringSink {\n  // TODO(ajohnsen): Make _encodingMutable an argument.\n  factory IOSink(StreamConsumer<List<int>> target,\n                 {Encoding encoding: UTF8})\n      => new _IOSinkImpl(target, encoding);\n\n  /**\n   * The [Encoding] used when writing strings. Depending on the\n   * underlying consumer this property might be mutable.\n   */\n  Encoding encoding;\n\n  /**\n   * Adds [data] to the target consumer, ignoring [encoding].\n   *\n   * The [encoding] does not apply to this method, and the `data` list is passed\n   * directly to the target consumer as a stream event.\n   *\n   * This function must not be called when a stream is currently being added\n   * using [addStream].\n   *\n   * This operation is non-blocking. See [flush] or [done] for how to get any\n   * errors generated by this call.\n   *\n   * The data list should not be modified after it has been passed to `add`.\n   */\n  void add(List<int> data);\n\n  /**\n   * Converts [obj] to a String by invoking [Object.toString] and\n   * [add]s the encoding of the result to the target consumer.\n   *\n   * This operation is non-blocking. See [flush] or [done] for how to get any\n   * errors generated by this call.\n   */\n  void write(Object obj);\n\n  /**\n   * Iterates over the given [objects] and [write]s them in sequence.\n   *\n   * If [separator] is provided, a `write` with the `separator` is performed\n   * between any two elements of `objects`.\n   *\n   * This operation is non-blocking. See [flush] or [done] for how to get any\n   * errors generated by this call.\n   */\n  void writeAll(Iterable objects, [String separator = \"\"]);\n\n  /**\n   * Converts [obj] to a String by invoking [Object.toString] and\n   * writes the result to `this`, followed by a newline.\n   *\n   * This operation is non-blocking. See [flush] or [done] for how to get any\n   * errors generated by this call.\n   */\n  void writeln([Object obj = \"\"]);\n\n  /**\n   * Writes the [charCode] to `this`.\n   *\n   * This method is equivalent to `write(new String.fromCharCode(charCode))`.\n   *\n   * This operation is non-blocking. See [flush] or [done] for how to get any\n   * errors generated by this call.\n   */\n  void writeCharCode(int charCode);\n\n  /**\n   * Passes the error to the target consumer as an error event.\n   *\n   * This function must not be called when a stream is currently being added\n   * using [addStream].\n   *\n   * This operation is non-blocking. See [flush] or [done] for how to get any\n   * errors generated by this call.\n   */\n  void addError(error, [StackTrace stackTrace]);\n\n  /**\n   * Adds all elements of the given [stream] to `this`.\n   */\n  Future addStream(Stream<List<int>> stream);\n\n  /**\n   * Returns a [Future] that completes once all buffered data is accepted by the\n   * to underlying [StreamConsumer].\n   *\n   * It's an error to call this method, while an [addStream] is incomplete.\n   *\n   * NOTE: This is not necessarily the same as the data being flushed by the\n   * operating system.\n   */\n  Future flush();\n\n  /**\n   * Close the target consumer.\n   */\n  Future close();\n\n  /**\n   * Get a future that will complete when the consumer closes, or when an\n   * error occurs. This future is identical to the future returned by\n   * [close].\n   */\n  Future get done;\n}\n\nclass _StreamSinkImpl<T> implements StreamSink<T> {\n  final StreamConsumer<T> _target;\n  Completer _doneCompleter = new Completer();\n  Future _doneFuture;\n  StreamController<T> _controllerInstance;\n  Completer _controllerCompleter;\n  bool _isClosed = false;\n  bool _isBound = false;\n  bool _hasError = false;\n\n  _StreamSinkImpl(this._target) {\n    _doneFuture = _doneCompleter.future;\n  }\n\n  void add(T data) {\n    if (_isClosed) return;\n    _controller.add(data);\n  }\n\n  void addError(error, [StackTrace stackTrace]) =>\n      _controller.addError(error, stackTrace);\n\n  Future addStream(Stream<T> stream) {\n    if (_isBound) {\n      throw new StateError(\"StreamSink is already bound to a stream\");\n    }\n    _isBound = true;\n    if (_hasError) return done;\n    // Wait for any sync operations to complete.\n    Future targetAddStream() {\n      return _target.addStream(stream)\n          .whenComplete(() {\n            _isBound = false;\n          });\n    }\n    if (_controllerInstance == null) return targetAddStream();\n    var future = _controllerCompleter.future;\n    _controllerInstance.close();\n    return future.then((_) => targetAddStream());\n  }\n\n  Future flush() {\n    if (_isBound) {\n      throw new StateError(\"StreamSink is bound to a stream\");\n    }\n    if (_controllerInstance == null) return new Future.value(this);\n    // Adding an empty stream-controller will return a future that will complete\n    // when all data is done.\n    _isBound = true;\n    var future = _controllerCompleter.future;\n    _controllerInstance.close();\n    return future.whenComplete(() {\n          _isBound = false;\n        });\n  }\n\n  Future close() {\n    if (_isBound) {\n      throw new StateError(\"StreamSink is bound to a stream\");\n    }\n    if (!_isClosed) {\n      _isClosed = true;\n      if (_controllerInstance != null) {\n        _controllerInstance.close();\n      } else {\n        _closeTarget();\n      }\n    }\n    return done;\n  }\n\n  void _closeTarget() {\n    _target.close()\n        .then((value) => _completeDone(value: value),\n              onError: (error) => _completeDone(error: error));\n  }\n\n  Future get done => _doneFuture;\n\n  void _completeDone({value, error}) {\n    if (_doneCompleter == null) return;\n    if (error == null) {\n      _doneCompleter.complete(value);\n    } else {\n      _hasError = true;\n      _doneCompleter.completeError(error);\n    }\n    _doneCompleter = null;\n  }\n\n  StreamController<T> get _controller {\n    if (_isBound) {\n      throw new StateError(\"StreamSink is bound to a stream\");\n    }\n    if (_isClosed) {\n      throw new StateError(\"StreamSink is closed\");\n    }\n    if (_controllerInstance == null) {\n      _controllerInstance = new StreamController<T>(sync: true);\n      _controllerCompleter = new Completer();\n      _target.addStream(_controller.stream)\n          .then(\n              (_) {\n                if (_isBound) {\n                  // A new stream takes over - forward values to that stream.\n                  _controllerCompleter.complete(this);\n                  _controllerCompleter = null;\n                  _controllerInstance = null;\n                } else {\n                  // No new stream, .close was called. Close _target.\n                  _closeTarget();\n                }\n              },\n              onError: (error) {\n                if (_isBound) {\n                  // A new stream takes over - forward errors to that stream.\n                  _controllerCompleter.completeError(error);\n                  _controllerCompleter = null;\n                  _controllerInstance = null;\n                } else {\n                  // No new stream. No need to close target, as it have already\n                  // failed.\n                  _completeDone(error: error);\n                }\n              });\n    }\n    return _controllerInstance;\n  }\n}\n\n\nclass _IOSinkImpl extends _StreamSinkImpl<List<int>> implements IOSink {\n  Encoding _encoding;\n  bool _encodingMutable = true;\n\n  _IOSinkImpl(StreamConsumer<List<int>> target, this._encoding)\n      : super(target);\n\n  Encoding get encoding => _encoding;\n\n  void set encoding(Encoding value) {\n    if (!_encodingMutable) {\n      throw new StateError(\"IOSink encoding is not mutable\");\n    }\n    _encoding = value;\n  }\n\n  void write(Object obj) {\n    // This comment is copied from runtime/lib/string_buffer_patch.dart.\n    // TODO(srdjan): The following four lines could be replaced by\n    // '$obj', but apparently this is too slow on the Dart VM.\n    String string;\n    if (obj is String) {\n      string = obj;\n    } else {\n      string = obj.toString();\n      if (string is! String) {\n        throw new ArgumentError('toString() did not return a string');\n      }\n    }\n    if (string.isEmpty) return;\n    add(_encoding.encode(string));\n  }\n\n  void writeAll(Iterable objects, [String separator = \"\"]) {\n    Iterator iterator = objects.iterator;\n    if (!iterator.moveNext()) return;\n    if (separator.isEmpty) {\n      do {\n        write(iterator.current);\n      } while (iterator.moveNext());\n    } else {\n      write(iterator.current);\n      while (iterator.moveNext()) {\n        write(separator);\n        write(iterator.current);\n      }\n    }\n  }\n\n  void writeln([Object obj = \"\"]) {\n    write(obj);\n    write(\"\\n\");\n  }\n\n  void writeCharCode(int charCode) {\n    write(new String.fromCharCode(charCode));\n  }\n}\n\u0000","sdk:/sdk/lib/io/http_session.dart":"// Copyright (c) 2013, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\npart of dart.io;\n\nconst String _DART_SESSION_ID = \"DARTSESSID\";\n\n// A _HttpSession is a node in a double-linked list, with _next and _prev being\n// the previous and next pointers.\nclass _HttpSession implements HttpSession {\n  // Destroyed marked. Used by the http connection to see if a session is valid.\n  bool _destroyed = false;\n  bool _isNew = true;\n  DateTime _lastSeen;\n  Function _timeoutCallback;\n  _HttpSessionManager _sessionManager;\n  // Pointers in timeout queue.\n  _HttpSession _prev;\n  _HttpSession _next;\n  final String id;\n\n  final Map _data = new HashMap();\n\n  _HttpSession(this._sessionManager, this.id) : _lastSeen = new DateTime.now();\n\n  void destroy() {\n    _destroyed = true;\n    _sessionManager._removeFromTimeoutQueue(this);\n    _sessionManager._sessions.remove(id);\n  }\n\n  // Mark the session as seen. This will reset the timeout and move the node to\n  // the end of the timeout queue.\n  void _markSeen() {\n    _lastSeen = new DateTime.now();\n    _sessionManager._bumpToEnd(this);\n  }\n\n  DateTime get lastSeen => _lastSeen;\n\n  bool get isNew => _isNew;\n\n  void set onTimeout(void callback()) {\n    _timeoutCallback = callback;\n  }\n\n  // Map implementation:\n  bool containsValue(value) => _data.containsValue(value);\n  bool containsKey(key) => _data.containsKey(key);\n  operator [](key) => _data[key];\n  void operator []=(key, value) { _data[key] = value; }\n  putIfAbsent(key, ifAbsent) => _data.putIfAbsent(key, ifAbsent);\n  addAll(Map other) => _data.addAll(other);\n  remove(key) => _data.remove(key);\n  void clear() => _data.clear();\n  void forEach(void f(key, value)) => _data.forEach(f);\n  Iterable get keys => _data.keys;\n  Iterable get values => _data.values;\n  int get length => _data.length;\n  bool get isEmpty => _data.isEmpty;\n  bool get isNotEmpty => _data.isNotEmpty;\n\n  String toString() => 'HttpSession id:$id $_data';\n}\n\n// Private class used to manage all the active sessions. The sessions are stored\n// in two ways:\n//\n//  * In a map, mapping from ID to HttpSession.\n//  * In a linked list, used as a timeout queue.\nclass _HttpSessionManager {\n  Map<String, _HttpSession> _sessions;\n  int _sessionTimeout = 20 * 60;  // 20 mins.\n  _HttpSession _head;\n  _HttpSession _tail;\n  Timer _timer;\n\n  _HttpSessionManager() : _sessions = {};\n\n  String createSessionId() {\n    const int _KEY_LENGTH = 16;  // 128 bits.\n    var data = _IOCrypto.getRandomBytes(_KEY_LENGTH);\n    return _CryptoUtils.bytesToHex(data);\n  }\n\n  _HttpSession getSession(String id) => _sessions[id];\n\n  _HttpSession createSession() {\n    var id = createSessionId();\n    // TODO(ajohnsen): Consider adding a limit and throwing an exception.\n    // Should be very unlikely however.\n    while (_sessions.containsKey(id)) {\n      id = createSessionId();\n    }\n    var session = _sessions[id] = new _HttpSession(this, id);\n    _addToTimeoutQueue(session);\n    return session;\n  }\n\n  void set sessionTimeout(int timeout) {\n    _sessionTimeout = timeout;\n    _stopTimer();\n    _startTimer();\n  }\n\n  void close() => _stopTimer();\n\n  void _bumpToEnd(_HttpSession session) {\n    _removeFromTimeoutQueue(session);\n    _addToTimeoutQueue(session);\n  }\n\n  void _addToTimeoutQueue(_HttpSession session) {\n    if (_head == null) {\n      assert(_tail == null);\n      _tail = _head = session;\n      _startTimer();\n    } else {\n      assert(_timer != null);\n      assert(_tail != null);\n      // Add to end.\n      _tail._next = session;\n      session._prev = _tail;\n      _tail = session;\n    }\n  }\n\n  void _removeFromTimeoutQueue(_HttpSession session) {\n    if (session._next != null) {\n      session._next._prev = session._prev;\n    }\n    if (session._prev != null) {\n      session._prev._next = session._next;\n    }\n    if (_head == session) {\n      // We removed the head element, start new timer.\n      _head = session._next;\n      _stopTimer();\n      _startTimer();\n    }\n    if (_tail == session) {\n      _tail = session._prev;\n    }\n    session._next = session._prev = null;\n  }\n\n  void _timerTimeout() {\n    _stopTimer();  // Clear timer.\n    assert(_head != null);\n    var session = _head;\n    session.destroy();  // Will remove the session from timeout queue and map.\n    if (session._timeoutCallback != null) {\n      session._timeoutCallback();\n    }\n  }\n\n  void _startTimer() {\n    assert(_timer == null);\n    if (_head != null) {\n      int seconds = new DateTime.now().difference(_head.lastSeen).inSeconds;\n      _timer = new Timer(new Duration(seconds: _sessionTimeout - seconds),\n                         _timerTimeout);\n    }\n  }\n\n  void _stopTimer() {\n    if (_timer != null) {\n      _timer.cancel();\n      _timer = null;\n    }\n  }\n}\n\n\u0000","sdk:/sdk/lib/io/http_parser.dart":"// Copyright (c) 2013, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\npart of dart.io;\n\n// Global constants.\nclass _Const {\n  // Bytes for \"HTTP\".\n  static const HTTP = const [72, 84, 84, 80];\n  // Bytes for \"HTTP/1.\".\n  static const HTTP1DOT = const [72, 84, 84, 80, 47, 49, 46];\n  // Bytes for \"HTTP/1.0\".\n  static const HTTP10 = const [72, 84, 84, 80, 47, 49, 46, 48];\n  // Bytes for \"HTTP/1.1\".\n  static const HTTP11 = const [72, 84, 84, 80, 47, 49, 46, 49];\n\n  static const bool T = true;\n  static const bool F = false;\n  // Loopup-map for the following characters: '()<>@,;:\\\\\"/[]?={} \\t'.\n  static const SEPARATOR_MAP = const [\n      F,F,F,F,F,F,F,F,F,T,F,F,F,F,F,F,F,F,F,F,F,F,F,F,F,F,F,F,F,F,F,F,T,F,T,F,F,\n      F,F,F,T,T,F,F,T,F,F,T,F,F,F,F,F,F,F,F,F,F,T,T,T,T,T,T,T,F,F,F,F,F,F,F,F,F,\n      F,F,F,F,F,F,F,F,F,F,F,F,F,F,F,F,F,T,T,T,F,F,F,F,F,F,F,F,F,F,F,F,F,F,F,F,F,\n      F,F,F,F,F,F,F,F,F,F,F,F,T,F,T,F,F,F,F,F,F,F,F,F,F,F,F,F,F,F,F,F,F,F,F,F,F,\n      F,F,F,F,F,F,F,F,F,F,F,F,F,F,F,F,F,F,F,F,F,F,F,F,F,F,F,F,F,F,F,F,F,F,F,F,F,\n      F,F,F,F,F,F,F,F,F,F,F,F,F,F,F,F,F,F,F,F,F,F,F,F,F,F,F,F,F,F,F,F,F,F,F,F,F,\n      F,F,F,F,F,F,F,F,F,F,F,F,F,F,F,F,F,F,F,F,F,F,F,F,F,F,F,F,F,F,F,F,F,F];\n}\n\n\n// Frequently used character codes.\nclass _CharCode {\n  static const int HT = 9;\n  static const int LF = 10;\n  static const int CR = 13;\n  static const int SP = 32;\n  static const int AMPERSAND = 38;\n  static const int COMMA = 44;\n  static const int DASH = 45;\n  static const int SLASH = 47;\n  static const int ZERO = 48;\n  static const int ONE = 49;\n  static const int COLON = 58;\n  static const int SEMI_COLON = 59;\n  static const int EQUAL = 61;\n}\n\n\n// States of the HTTP parser state machine.\nclass _State {\n  static const int START = 0;\n  static const int METHOD_OR_RESPONSE_HTTP_VERSION = 1;\n  static const int RESPONSE_HTTP_VERSION = 2;\n  static const int REQUEST_LINE_METHOD = 3;\n  static const int REQUEST_LINE_URI = 4;\n  static const int REQUEST_LINE_HTTP_VERSION = 5;\n  static const int REQUEST_LINE_ENDING = 6;\n  static const int RESPONSE_LINE_STATUS_CODE = 7;\n  static const int RESPONSE_LINE_REASON_PHRASE = 8;\n  static const int RESPONSE_LINE_ENDING = 9;\n  static const int HEADER_START = 10;\n  static const int HEADER_FIELD = 11;\n  static const int HEADER_VALUE_START = 12;\n  static const int HEADER_VALUE = 13;\n  static const int HEADER_VALUE_FOLDING_OR_ENDING = 14;\n  static const int HEADER_VALUE_FOLD_OR_END = 15;\n  static const int HEADER_ENDING = 16;\n\n  static const int CHUNK_SIZE_STARTING_CR = 17;\n  static const int CHUNK_SIZE_STARTING_LF = 18;\n  static const int CHUNK_SIZE = 19;\n  static const int CHUNK_SIZE_EXTENSION = 20;\n  static const int CHUNK_SIZE_ENDING = 21;\n  static const int CHUNKED_BODY_DONE_CR = 22;\n  static const int CHUNKED_BODY_DONE_LF = 23;\n  static const int BODY = 24;\n  static const int CLOSED = 25;\n  static const int UPGRADED = 26;\n  static const int FAILURE = 27;\n\n  static const int FIRST_BODY_STATE = CHUNK_SIZE_STARTING_CR;\n}\n\n// HTTP version of the request or response being parsed.\nclass _HttpVersion {\n  static const int UNDETERMINED = 0;\n  static const int HTTP10 = 1;\n  static const int HTTP11 = 2;\n}\n\n// States of the HTTP parser state machine.\nclass _MessageType {\n  static const int UNDETERMINED = 0;\n  static const int REQUEST = 1;\n  static const int RESPONSE = 0;\n}\n\n\n/**\n * The _HttpDetachedStreamSubscription takes a subscription and some extra data,\n * and makes it possible to \"inject\" the data in from of other data events\n * from the subscription.\n *\n * It does so by overriding pause/resume, so that once the\n * _HttpDetachedStreamSubscription is resumed, it'll deliver the data before\n * resuming the underlaying subscription.\n */\nclass _HttpDetachedStreamSubscription implements StreamSubscription<List<int>> {\n  StreamSubscription<List<int>> _subscription;\n  List<int> _injectData;\n  bool _isCanceled = false;\n  int _pauseCount = 1;\n  Function _userOnData;\n  bool _scheduled = false;\n\n  _HttpDetachedStreamSubscription(this._subscription,\n                                  this._injectData,\n                                  this._userOnData);\n\n  bool get isPaused => _subscription.isPaused;\n\n  Future asFuture([futureValue]) => _subscription.asFuture(futureValue);\n\n  Future cancel() {\n    _isCanceled = true;\n    _injectData = null;\n    return _subscription.cancel();\n  }\n\n  void onData(void handleData(List<int> data)) {\n    _userOnData = handleData;\n    _subscription.onData(handleData);\n  }\n\n  void onDone(void handleDone()) {\n    _subscription.onDone(handleDone);\n  }\n\n  void onError(Function handleError) {\n    _subscription.onError(handleError);\n  }\n\n  void pause([Future resumeSignal]) {\n    if (_injectData == null) {\n      _subscription.pause(resumeSignal);\n    } else {\n      _pauseCount++;\n      if (resumeSignal != null) {\n        resumeSignal.whenComplete(resume);\n      }\n    }\n  }\n\n  void resume() {\n    if (_injectData == null) {\n      _subscription.resume();\n    } else {\n      _pauseCount--;\n      _maybeScheduleData();\n    }\n  }\n\n  void _maybeScheduleData() {\n    if (_scheduled) return;\n    if (_pauseCount != 0) return;\n    _scheduled = true;\n    scheduleMicrotask(() {\n      _scheduled = false;\n      if (_pauseCount > 0 || _isCanceled) return;\n      var data = _injectData;\n      _injectData = null;\n      // To ensure that 'subscription.isPaused' is false, we resume the\n      // subscription here. This is fine as potential events are delayed.\n      _subscription.resume();\n      if (_userOnData != null) {\n        _userOnData(data);\n      }\n    });\n  }\n}\n\n\nclass _HttpDetachedIncoming extends Stream<List<int>> {\n  final StreamSubscription subscription;\n  final List<int> bufferedData;\n\n  _HttpDetachedIncoming(this.subscription, this.bufferedData);\n\n  StreamSubscription<List<int>> listen(void onData(List<int> event),\n                                       {Function onError,\n                                        void onDone(),\n                                        bool cancelOnError}) {\n    if (subscription != null) {\n      subscription\n        ..onData(onData)\n        ..onError(onError)\n        ..onDone(onDone);\n      if (bufferedData == null) {\n        return subscription..resume();\n      }\n      return new _HttpDetachedStreamSubscription(subscription,\n                                                 bufferedData,\n                                                 onData)\n        ..resume();\n    } else {\n      return new Stream.fromIterable(bufferedData)\n          .listen(onData,\n                  onError: onError,\n                  onDone: onDone,\n                  cancelOnError: cancelOnError);\n    }\n  }\n}\n\n\n/**\n * HTTP parser which parses the data stream given to [consume].\n *\n * If an HTTP parser error occours, the parser will signal an error to either\n * the current _HttpIncoming or the _parser itself.\n *\n * The connection upgrades (e.g. switching from HTTP/1.1 to the\n * WebSocket protocol) is handled in a special way. If connection\n * upgrade is specified in the headers, then on the callback to\n * [:responseStart:] the [:upgrade:] property on the [:HttpParser:]\n * object will be [:true:] indicating that from now on the protocol is\n * not HTTP anymore and no more callbacks will happen, that is\n * [:dataReceived:] and [:dataEnd:] are not called in this case as\n * there is no more HTTP data. After the upgrade the method\n * [:readUnparsedData:] can be used to read any remaining bytes in the\n * HTTP parser which are part of the protocol the connection is\n * upgrading to. These bytes cannot be processed by the HTTP parser\n * and should be handled according to whatever protocol is being\n * upgraded to.\n */\nclass _HttpParser extends Stream<_HttpIncoming> {\n  // State.\n  bool _parserCalled = false;\n\n  // The data that is currently being parsed.\n  Uint8List _buffer;\n  int _index;\n\n  final bool _requestParser;\n  int _state;\n  int _httpVersionIndex;\n  int _messageType;\n  int _statusCode = 0;\n  int _statusCodeLength = 0;\n  final List<int> _method = [];\n  final List<int> _uri_or_reason_phrase = [];\n  final List<int> _headerField = [];\n  final List<int> _headerValue = [];\n\n  int _httpVersion;\n  int _transferLength = -1;\n  bool _persistentConnection;\n  bool _connectionUpgrade;\n  bool _chunked;\n\n  bool _noMessageBody = false;\n  int _remainingContent = -1;\n\n  _HttpHeaders _headers;\n\n  // The current incoming connection.\n  _HttpIncoming _incoming;\n  StreamSubscription _socketSubscription;\n  bool _paused = true;\n  bool _bodyPaused = false;\n  StreamController<_HttpIncoming> _controller;\n  StreamController<List<int>> _bodyController;\n\n  factory _HttpParser.requestParser() {\n    return new _HttpParser._(true);\n  }\n\n  factory _HttpParser.responseParser() {\n    return new _HttpParser._(false);\n  }\n\n  _HttpParser._(this._requestParser) {\n    _controller = new StreamController<_HttpIncoming>(\n        sync: true,\n        onListen: () {\n          _paused = false;\n        },\n        onPause: () {\n          _paused = true;\n          _pauseStateChanged();\n        },\n        onResume: () {\n          _paused = false;\n          _pauseStateChanged();\n        },\n        onCancel: () {\n          if (_socketSubscription != null) {\n            _socketSubscription.cancel();\n          }\n        });\n    _reset();\n  }\n\n\n  StreamSubscription<_HttpIncoming> listen(void onData(_HttpIncoming event),\n                                           {Function onError,\n                                            void onDone(),\n                                            bool cancelOnError}) {\n    return _controller.stream.listen(onData,\n                                     onError: onError,\n                                     onDone: onDone,\n                                     cancelOnError: cancelOnError);\n  }\n\n  void listenToStream(Stream<List<int>> stream) {\n    // Listen to the stream and handle data accordingly. When a\n    // _HttpIncoming is created, _dataPause, _dataResume, _dataDone is\n    // given to provide a way of controlling the parser.\n    // TODO(ajohnsen): Remove _dataPause, _dataResume and _dataDone and clean up\n    // how the _HttpIncoming signals the parser.\n    _socketSubscription = stream.listen(\n        _onData,\n        onError: _onError,\n        onDone: _onDone);\n  }\n\n  void _parse() {\n    try {\n      _doParse();\n    } catch (e, s) {\n      _state = _State.FAILURE;\n      _reportError(e, s);\n    }\n  }\n\n  // From RFC 2616.\n  // generic-message = start-line\n  //                   *(message-header CRLF)\n  //                   CRLF\n  //                   [ message-body ]\n  // start-line      = Request-Line | Status-Line\n  // Request-Line    = Method SP Request-URI SP HTTP-Version CRLF\n  // Status-Line     = HTTP-Version SP Status-Code SP Reason-Phrase CRLF\n  // message-header  = field-name \":\" [ field-value ]\n  void _doParse() {\n    assert(!_parserCalled);\n    _parserCalled = true;\n    if (_state == _State.CLOSED) {\n      throw new HttpException(\"Data on closed connection\");\n    }\n    if (_state == _State.FAILURE) {\n      throw new HttpException(\"Data on failed connection\");\n    }\n    while (_buffer != null &&\n           _index < _buffer.length &&\n           _state != _State.FAILURE &&\n           _state != _State.UPGRADED) {\n      // Depending on _incoming, we either break on _bodyPaused or _paused.\n      if ((_incoming != null && _bodyPaused) ||\n          (_incoming == null && _paused)) {\n        _parserCalled = false;\n        return;\n      }\n      int byte = _buffer[_index++];\n      switch (_state) {\n        case _State.START:\n          if (byte == _Const.HTTP[0]) {\n            // Start parsing method or HTTP version.\n            _httpVersionIndex = 1;\n            _state = _State.METHOD_OR_RESPONSE_HTTP_VERSION;\n          } else {\n            // Start parsing method.\n            if (!_isTokenChar(byte)) {\n              throw new HttpException(\"Invalid request method\");\n            }\n            _method.add(byte);\n            if (!_requestParser) {\n              throw new HttpException(\"Invalid response line\");\n            }\n            _state = _State.REQUEST_LINE_METHOD;\n          }\n          break;\n\n        case _State.METHOD_OR_RESPONSE_HTTP_VERSION:\n          if (_httpVersionIndex < _Const.HTTP.length &&\n              byte == _Const.HTTP[_httpVersionIndex]) {\n            // Continue parsing HTTP version.\n            _httpVersionIndex++;\n          } else if (_httpVersionIndex == _Const.HTTP.length &&\n                     byte == _CharCode.SLASH) {\n            // HTTP/ parsed. As method is a token this cannot be a\n            // method anymore.\n            _httpVersionIndex++;\n            if (_requestParser) {\n              throw new HttpException(\"Invalid request line\");\n            }\n            _state = _State.RESPONSE_HTTP_VERSION;\n          } else {\n            // Did not parse HTTP version. Expect method instead.\n            for (int i = 0; i < _httpVersionIndex; i++) {\n              _method.add(_Const.HTTP[i]);\n            }\n            if (byte == _CharCode.SP) {\n              _state = _State.REQUEST_LINE_URI;\n            } else {\n              _method.add(byte);\n              _httpVersion = _HttpVersion.UNDETERMINED;\n              if (!_requestParser) {\n                throw new HttpException(\"Invalid response line\");\n              }\n              _state = _State.REQUEST_LINE_METHOD;\n            }\n          }\n          break;\n\n        case _State.RESPONSE_HTTP_VERSION:\n          if (_httpVersionIndex < _Const.HTTP1DOT.length) {\n            // Continue parsing HTTP version.\n            _expect(byte, _Const.HTTP1DOT[_httpVersionIndex]);\n            _httpVersionIndex++;\n          } else if (_httpVersionIndex == _Const.HTTP1DOT.length &&\n                     byte == _CharCode.ONE) {\n            // HTTP/1.1 parsed.\n            _httpVersion = _HttpVersion.HTTP11;\n            _persistentConnection = true;\n            _httpVersionIndex++;\n          } else if (_httpVersionIndex == _Const.HTTP1DOT.length &&\n                     byte == _CharCode.ZERO) {\n            // HTTP/1.0 parsed.\n            _httpVersion = _HttpVersion.HTTP10;\n            _persistentConnection = false;\n            _httpVersionIndex++;\n          } else if (_httpVersionIndex == _Const.HTTP1DOT.length + 1) {\n            _expect(byte, _CharCode.SP);\n            // HTTP version parsed.\n            _state = _State.RESPONSE_LINE_STATUS_CODE;\n          } else {\n            throw new HttpException(\"Invalid response line\");\n          }\n          break;\n\n        case _State.REQUEST_LINE_METHOD:\n          if (byte == _CharCode.SP) {\n            _state = _State.REQUEST_LINE_URI;\n          } else {\n            if (_Const.SEPARATOR_MAP[byte] ||\n                byte == _CharCode.CR ||\n                byte == _CharCode.LF) {\n              throw new HttpException(\"Invalid request method\");\n            }\n            _method.add(byte);\n          }\n          break;\n\n        case _State.REQUEST_LINE_URI:\n          if (byte == _CharCode.SP) {\n            if (_uri_or_reason_phrase.length == 0) {\n              throw new HttpException(\"Invalid request URI\");\n            }\n            _state = _State.REQUEST_LINE_HTTP_VERSION;\n            _httpVersionIndex = 0;\n          } else {\n            if (byte == _CharCode.CR || byte == _CharCode.LF) {\n              throw new HttpException(\"Invalid request URI\");\n            }\n            _uri_or_reason_phrase.add(byte);\n          }\n          break;\n\n        case _State.REQUEST_LINE_HTTP_VERSION:\n          if (_httpVersionIndex < _Const.HTTP1DOT.length) {\n            _expect(byte, _Const.HTTP11[_httpVersionIndex]);\n            _httpVersionIndex++;\n          } else if (_httpVersionIndex == _Const.HTTP1DOT.length) {\n            if (byte == _CharCode.ONE) {\n              // HTTP/1.1 parsed.\n              _httpVersion = _HttpVersion.HTTP11;\n              _persistentConnection = true;\n              _httpVersionIndex++;\n            } else if (byte == _CharCode.ZERO) {\n              // HTTP/1.0 parsed.\n              _httpVersion = _HttpVersion.HTTP10;\n              _persistentConnection = false;\n              _httpVersionIndex++;\n            } else {\n              throw new HttpException(\"Invalid response line\");\n            }\n          } else {\n            _expect(byte, _CharCode.CR);\n            _state = _State.REQUEST_LINE_ENDING;\n          }\n          break;\n\n        case _State.REQUEST_LINE_ENDING:\n          _expect(byte, _CharCode.LF);\n          _messageType = _MessageType.REQUEST;\n          _state = _State.HEADER_START;\n          break;\n\n        case _State.RESPONSE_LINE_STATUS_CODE:\n          if (byte == _CharCode.SP) {\n            _state = _State.RESPONSE_LINE_REASON_PHRASE;\n          } else if (byte == _CharCode.CR) {\n            // Some HTTP servers does not follow the spec. and send\n            // \\r\\n right after the status code.\n            _state = _State.RESPONSE_LINE_ENDING;\n          } else {\n            _statusCodeLength++;\n            if ((byte < 0x30 && 0x39 < byte) || _statusCodeLength > 3) {\n              throw new HttpException(\"Invalid response status code\");\n            } else {\n              _statusCode = _statusCode * 10 + byte - 0x30;\n            }\n          }\n          break;\n\n        case _State.RESPONSE_LINE_REASON_PHRASE:\n          if (byte == _CharCode.CR) {\n            _state = _State.RESPONSE_LINE_ENDING;\n          } else {\n            if (byte == _CharCode.CR || byte == _CharCode.LF) {\n              throw new HttpException(\"Invalid response reason phrase\");\n            }\n            _uri_or_reason_phrase.add(byte);\n          }\n          break;\n\n        case _State.RESPONSE_LINE_ENDING:\n          _expect(byte, _CharCode.LF);\n          _messageType == _MessageType.RESPONSE;\n          if (_statusCode < 100 || _statusCode > 599) {\n            throw new HttpException(\"Invalid response status code\");\n          } else {\n            // Check whether this response will never have a body.\n            if (_statusCode <= 199 || _statusCode == 204 ||\n                _statusCode == 304) {\n              _noMessageBody = true;\n            }\n          }\n          _state = _State.HEADER_START;\n          break;\n\n        case _State.HEADER_START:\n          _headers = new _HttpHeaders(version);\n          if (byte == _CharCode.CR) {\n            _state = _State.HEADER_ENDING;\n          } else {\n            // Start of new header field.\n            _headerField.add(_toLowerCaseByte(byte));\n            _state = _State.HEADER_FIELD;\n          }\n          break;\n\n        case _State.HEADER_FIELD:\n          if (byte == _CharCode.COLON) {\n            _state = _State.HEADER_VALUE_START;\n          } else {\n            if (!_isTokenChar(byte)) {\n              throw new HttpException(\"Invalid header field name\");\n            }\n            _headerField.add(_toLowerCaseByte(byte));\n          }\n          break;\n\n        case _State.HEADER_VALUE_START:\n          if (byte == _CharCode.CR) {\n            _state = _State.HEADER_VALUE_FOLDING_OR_ENDING;\n          } else if (byte != _CharCode.SP && byte != _CharCode.HT) {\n            // Start of new header value.\n            _headerValue.add(byte);\n            _state = _State.HEADER_VALUE;\n          }\n          break;\n\n        case _State.HEADER_VALUE:\n          if (byte == _CharCode.CR) {\n            _state = _State.HEADER_VALUE_FOLDING_OR_ENDING;\n          } else {\n            _headerValue.add(byte);\n          }\n          break;\n\n        case _State.HEADER_VALUE_FOLDING_OR_ENDING:\n          _expect(byte, _CharCode.LF);\n          _state = _State.HEADER_VALUE_FOLD_OR_END;\n          break;\n\n        case _State.HEADER_VALUE_FOLD_OR_END:\n          if (byte == _CharCode.SP || byte == _CharCode.HT) {\n            _state = _State.HEADER_VALUE_START;\n          } else {\n            String headerField = new String.fromCharCodes(_headerField);\n            String headerValue = new String.fromCharCodes(_headerValue);\n            if (headerField == \"transfer-encoding\" &&\n                _caseInsensitiveCompare(\"chunked\".codeUnits, _headerValue)) {\n              _chunked = true;\n            }\n            if (headerField == \"connection\") {\n              List<String> tokens = _tokenizeFieldValue(headerValue);\n              for (int i = 0; i < tokens.length; i++) {\n                if (_caseInsensitiveCompare(\"upgrade\".codeUnits,\n                                            tokens[i].codeUnits)) {\n                  _connectionUpgrade = true;\n                }\n                _headers._add(headerField, tokens[i]);\n              }\n            } else {\n              _headers._add(headerField, headerValue);\n            }\n            _headerField.clear();\n            _headerValue.clear();\n\n            if (byte == _CharCode.CR) {\n              _state = _State.HEADER_ENDING;\n            } else {\n              // Start of new header field.\n              _headerField.add(_toLowerCaseByte(byte));\n              _state = _State.HEADER_FIELD;\n            }\n          }\n          break;\n\n        case _State.HEADER_ENDING:\n          _expect(byte, _CharCode.LF);\n          _headers._mutable = false;\n\n          _transferLength = _headers.contentLength;\n          // Ignore the Content-Length header if Transfer-Encoding\n          // is chunked (RFC 2616 section 4.4)\n          if (_chunked) _transferLength = -1;\n\n          // If a request message has neither Content-Length nor\n          // Transfer-Encoding the message must not have a body (RFC\n          // 2616 section 4.3).\n          if (_messageType == _MessageType.REQUEST &&\n              _transferLength < 0 &&\n              _chunked == false) {\n            _transferLength = 0;\n          }\n          if (_connectionUpgrade) {\n            _state = _State.UPGRADED;\n            _transferLength = 0;\n          }\n          _createIncoming(_transferLength);\n          if (_requestParser) {\n            _incoming.method =\n                new String.fromCharCodes(_method);\n            _incoming.uri =\n                Uri.parse(\n                    new String.fromCharCodes(_uri_or_reason_phrase));\n          } else {\n            _incoming.statusCode = _statusCode;\n            _incoming.reasonPhrase =\n                new String.fromCharCodes(_uri_or_reason_phrase);\n          }\n          _method.clear();\n          _uri_or_reason_phrase.clear();\n          if (_connectionUpgrade) {\n            _incoming.upgraded = true;\n            _parserCalled = false;\n            var tmp = _incoming;\n            _closeIncoming();\n            _controller.add(tmp);\n            return;\n          }\n          if (_transferLength == 0 ||\n              (_messageType == _MessageType.RESPONSE && _noMessageBody)) {\n            _reset();\n            var tmp = _incoming;\n            _closeIncoming();\n            _controller.add(tmp);\n            break;\n          } else if (_chunked) {\n            _state = _State.CHUNK_SIZE;\n            _remainingContent = 0;\n          } else if (_transferLength > 0) {\n            _remainingContent = _transferLength;\n            _state = _State.BODY;\n          } else {\n            // Neither chunked nor content length. End of body\n            // indicated by close.\n            _state = _State.BODY;\n          }\n          _parserCalled = false;\n          _controller.add(_incoming);\n          return;\n\n        case _State.CHUNK_SIZE_STARTING_CR:\n          _expect(byte, _CharCode.CR);\n          _state = _State.CHUNK_SIZE_STARTING_LF;\n          break;\n\n        case _State.CHUNK_SIZE_STARTING_LF:\n          _expect(byte, _CharCode.LF);\n          _state = _State.CHUNK_SIZE;\n          break;\n\n        case _State.CHUNK_SIZE:\n          if (byte == _CharCode.CR) {\n            _state = _State.CHUNK_SIZE_ENDING;\n          } else if (byte == _CharCode.SEMI_COLON) {\n            _state = _State.CHUNK_SIZE_EXTENSION;\n          } else {\n            int value = _expectHexDigit(byte);\n            _remainingContent = _remainingContent * 16 + value;\n          }\n          break;\n\n        case _State.CHUNK_SIZE_EXTENSION:\n          if (byte == _CharCode.CR) {\n            _state = _State.CHUNK_SIZE_ENDING;\n          }\n          break;\n\n        case _State.CHUNK_SIZE_ENDING:\n          _expect(byte, _CharCode.LF);\n          if (_remainingContent > 0) {\n            _state = _State.BODY;\n          } else {\n            _state = _State.CHUNKED_BODY_DONE_CR;\n          }\n          break;\n\n        case _State.CHUNKED_BODY_DONE_CR:\n          _expect(byte, _CharCode.CR);\n          _state = _State.CHUNKED_BODY_DONE_LF;\n          break;\n\n        case _State.CHUNKED_BODY_DONE_LF:\n          _expect(byte, _CharCode.LF);\n          _reset();\n          _closeIncoming();\n          break;\n\n        case _State.BODY:\n          // The body is not handled one byte at a time but in blocks.\n          _index--;\n          int dataAvailable = _buffer.length - _index;\n          if (_remainingContent >= 0 && dataAvailable > _remainingContent) {\n            dataAvailable = _remainingContent;\n          }\n          // Always present the data as a view. This way we can handle all\n          // cases like this, and the user will not experince different data\n          // typed (which could lead to polymorphic user code).\n          List<int> data = new Uint8List.view(_buffer.buffer,\n                                              _buffer.offsetInBytes + _index,\n                                              dataAvailable);\n          _bodyController.add(data);\n          if (_remainingContent != -1) {\n            _remainingContent -= data.length;\n          }\n          _index += data.length;\n          if (_remainingContent == 0) {\n            if (!_chunked) {\n              _reset();\n              _closeIncoming();\n            } else {\n              _state = _State.CHUNK_SIZE_STARTING_CR;\n            }\n          }\n          break;\n\n        case _State.FAILURE:\n          // Should be unreachable.\n          assert(false);\n          break;\n\n        default:\n          // Should be unreachable.\n          assert(false);\n          break;\n      }\n    }\n\n    _parserCalled = false;\n    if (_buffer != null && _index == _buffer.length) {\n      // If all data is parsed release the buffer and resume receiving\n      // data.\n      _releaseBuffer();\n      if (_state != _State.UPGRADED && _state != _State.FAILURE) {\n        _socketSubscription.resume();\n      }\n    }\n  }\n\n  void _onData(List<int> buffer) {\n    _socketSubscription.pause();\n    assert(_buffer == null);\n    _buffer = buffer;\n    _index = 0;\n    _parse();\n  }\n\n  void _onDone() {\n    // onDone cancles the subscription.\n    _socketSubscription = null;\n    if (_state == _State.CLOSED || _state == _State.FAILURE) return;\n\n    if (_incoming != null) {\n      if (_state != _State.UPGRADED &&\n          !(_state == _State.START && !_requestParser) &&\n          !(_state == _State.BODY && !_chunked && _transferLength == -1)) {\n        _bodyController.addError(\n              new HttpException(\"Connection closed while receiving data\"));\n      }\n      _closeIncoming(true);\n      _controller.close();\n      return;\n    }\n    // If the connection is idle the HTTP stream is closed.\n    if (_state == _State.START) {\n      if (!_requestParser) {\n        _reportError(new HttpException(\n                    \"Connection closed before full header was received\"));\n      }\n      _controller.close();\n      return;\n    }\n\n    if (_state == _State.UPGRADED) {\n      _controller.close();\n      return;\n    }\n\n    if (_state < _State.FIRST_BODY_STATE) {\n      _state = _State.FAILURE;\n      // Report the error through the error callback if any. Otherwise\n      // throw the error.\n      _reportError(new HttpException(\n                  \"Connection closed before full header was received\"));\n      _controller.close();\n      return;\n    }\n\n    if (!_chunked && _transferLength == -1) {\n      _state = _State.CLOSED;\n    } else {\n      _state = _State.FAILURE;\n      // Report the error through the error callback if any. Otherwise\n      // throw the error.\n      _reportError(new HttpException(\n                  \"Connection closed before full body was received\"));\n    }\n    _controller.close();\n  }\n\n  void _onError(e, [StackTrace stackTrace]) {\n    _controller.addError(e, stackTrace);\n  }\n\n  String get version {\n    switch (_httpVersion) {\n      case _HttpVersion.HTTP10:\n        return \"1.0\";\n      case _HttpVersion.HTTP11:\n        return \"1.1\";\n    }\n    return null;\n  }\n\n  int get messageType => _messageType;\n  int get transferLength => _transferLength;\n  bool get upgrade => _connectionUpgrade && _state == _State.UPGRADED;\n  bool get persistentConnection => _persistentConnection;\n\n  void set isHead(bool value) {\n    if (value) _noMessageBody = true;\n  }\n\n  _HttpDetachedIncoming detachIncoming() {\n    // Simulate detached by marking as upgraded.\n    _state = _State.UPGRADED;\n    return new _HttpDetachedIncoming(_socketSubscription,\n                                     readUnparsedData());\n  }\n\n  List<int> readUnparsedData() {\n    if (_buffer == null) return null;\n    if (_index == _buffer.length) return null;\n    var result = _buffer.sublist(_index);\n    _releaseBuffer();\n    return result;\n  }\n\n  void _reset() {\n    if (_state == _State.UPGRADED) return;\n    _state = _State.START;\n    _messageType = _MessageType.UNDETERMINED;\n    _headerField.clear();\n    _headerValue.clear();\n    _method.clear();\n    _uri_or_reason_phrase.clear();\n\n    _statusCode = 0;\n    _statusCodeLength = 0;\n\n    _httpVersion = _HttpVersion.UNDETERMINED;\n    _transferLength = -1;\n    _persistentConnection = false;\n    _connectionUpgrade = false;\n    _chunked = false;\n\n    _noMessageBody = false;\n    _remainingContent = -1;\n\n    _headers = null;\n  }\n\n  void _releaseBuffer() {\n    _buffer = null;\n    _index = null;\n  }\n\n  static bool _isTokenChar(int byte) {\n    return byte > 31 && byte < 128 && !_Const.SEPARATOR_MAP[byte];\n  }\n\n  static bool _isValueChar(int byte) {\n    return (byte > 31 && byte < 128) || (byte == _CharCode.SP) ||\n        (byte == _CharCode.HT);\n  }\n\n  static List<String> _tokenizeFieldValue(String headerValue) {\n    List<String> tokens = new List<String>();\n    int start = 0;\n    int index = 0;\n    while (index < headerValue.length) {\n      if (headerValue[index] == \",\") {\n        tokens.add(headerValue.substring(start, index));\n        start = index + 1;\n      } else if (headerValue[index] == \" \" || headerValue[index] == \"\\t\") {\n        start++;\n      }\n      index++;\n    }\n    tokens.add(headerValue.substring(start, index));\n    return tokens;\n  }\n\n  static int _toLowerCaseByte(int x) {\n    // Optimized version:\n    //  -  0x41 is 'A'\n    //  -  0x7f is ASCII mask\n    //  -  26 is the number of alpha characters.\n    //  -  0x20 is the delta between lower and upper chars.\n    return (((x - 0x41) & 0x7f) < 26) ? (x | 0x20) : x;\n  }\n\n  // expected should already be lowercase.\n  bool _caseInsensitiveCompare(List<int> expected, List<int> value) {\n    if (expected.length != value.length) return false;\n    for (int i = 0; i < expected.length; i++) {\n      if (expected[i] != _toLowerCaseByte(value[i])) return false;\n    }\n    return true;\n  }\n\n  int _expect(int val1, int val2) {\n    if (val1 != val2) {\n      throw new HttpException(\"Failed to parse HTTP\");\n    }\n  }\n\n  int _expectHexDigit(int byte) {\n    if (0x30 <= byte && byte <= 0x39) {\n      return byte - 0x30;  // 0 - 9\n    } else if (0x41 <= byte && byte <= 0x46) {\n      return byte - 0x41 + 10;  // A - F\n    } else if (0x61 <= byte && byte <= 0x66) {\n      return byte - 0x61 + 10;  // a - f\n    } else {\n      throw new HttpException(\"Failed to parse HTTP\");\n    }\n  }\n\n  void _createIncoming(int transferLength) {\n    assert(_incoming == null);\n    assert(_bodyController == null);\n    assert(!_bodyPaused);\n    var incoming;\n    _bodyController = new StreamController<List<int>>(\n        sync: true,\n        onListen: () {\n          if (incoming != _incoming) return;\n          assert(_bodyPaused);\n          _bodyPaused = false;\n          _pauseStateChanged();\n        },\n        onPause: () {\n          if (incoming != _incoming) return;\n          assert(!_bodyPaused);\n          _bodyPaused = true;\n          _pauseStateChanged();\n        },\n        onResume: () {\n          if (incoming != _incoming) return;\n          assert(_bodyPaused);\n          _bodyPaused = false;\n          _pauseStateChanged();\n        },\n        onCancel: () {\n          if (incoming != _incoming) return;\n          if (_socketSubscription != null) {\n            _socketSubscription.cancel();\n          }\n          _closeIncoming(true);\n          _controller.close();\n        });\n    incoming = _incoming = new _HttpIncoming(\n        _headers, transferLength, _bodyController.stream);\n    _bodyPaused = true;\n    _pauseStateChanged();\n  }\n\n  void _closeIncoming([bool closing = false]) {\n    // Ignore multiple close (can happend in re-entrance).\n    if (_incoming == null) return;\n    var tmp = _incoming;\n    tmp.close(closing);\n    _incoming = null;\n    if (_bodyController != null) {\n      _bodyController.close();\n      _bodyController = null;\n    }\n    _bodyPaused = false;\n    _pauseStateChanged();\n  }\n\n  void _pauseStateChanged() {\n    if (_incoming != null) {\n      if (!_bodyPaused && !_parserCalled) {\n        _parse();\n      }\n    } else {\n      if (!_paused && !_parserCalled) {\n        _parse();\n      }\n    }\n  }\n\n  void _reportError(error, [stackTrace]) {\n    if (_socketSubscription != null) _socketSubscription.cancel();\n    _state = _State.FAILURE;\n    _controller.addError(error, stackTrace);\n    _controller.close();\n  }\n}\n\u0000","sdk:/sdk/lib/io/http_impl.dart":"// Copyright (c) 2013, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\npart of dart.io;\n\nconst int _OUTGOING_BUFFER_SIZE = 8 * 1024;\n\nclass _HttpIncoming extends Stream<List<int>> {\n  final int _transferLength;\n  final Completer _dataCompleter = new Completer();\n  Stream<List<int>> _stream;\n\n  bool fullBodyRead = false;\n\n  // Common properties.\n  final _HttpHeaders headers;\n  bool upgraded = false;\n\n  // ClientResponse properties.\n  int statusCode;\n  String reasonPhrase;\n\n  // Request properties.\n  String method;\n  Uri uri;\n\n  bool hasSubscriber = false;\n\n  // The transfer length if the length of the message body as it\n  // appears in the message (RFC 2616 section 4.4). This can be -1 if\n  // the length of the massage body is not known due to transfer\n  // codings.\n  int get transferLength => _transferLength;\n\n  _HttpIncoming(this.headers, this._transferLength, this._stream);\n\n  StreamSubscription<List<int>> listen(void onData(List<int> event),\n                                       {Function onError,\n                                        void onDone(),\n                                        bool cancelOnError}) {\n    hasSubscriber = true;\n    return _stream\n        .handleError((error) {\n          throw new HttpException(error.message, uri: uri);\n        })\n        .listen(onData,\n                onError: onError,\n                onDone: onDone,\n                cancelOnError: cancelOnError);\n  }\n\n  // Is completed once all data have been received.\n  Future get dataDone => _dataCompleter.future;\n\n  void close(bool closing) {\n    fullBodyRead = true;\n    hasSubscriber = true;\n    _dataCompleter.complete(closing);\n  }\n}\n\nabstract class _HttpInboundMessage extends Stream<List<int>> {\n  final _HttpIncoming _incoming;\n  List<Cookie> _cookies;\n\n  _HttpInboundMessage(this._incoming);\n\n  List<Cookie> get cookies {\n    if (_cookies != null) return _cookies;\n    return _cookies = headers._parseCookies();\n  }\n\n  _HttpHeaders get headers => _incoming.headers;\n  String get protocolVersion => headers.protocolVersion;\n  int get contentLength => headers.contentLength;\n  bool get persistentConnection => headers.persistentConnection;\n}\n\n\nclass _HttpRequest extends _HttpInboundMessage implements HttpRequest {\n  final HttpResponse response;\n\n  final _HttpServer _httpServer;\n\n  final _HttpConnection _httpConnection;\n\n  _HttpSession _session;\n\n  Uri _requestedUri;\n\n  _HttpRequest(this.response, _HttpIncoming _incoming, this._httpServer,\n               this._httpConnection) : super(_incoming) {\n    if (headers.protocolVersion == \"1.1\") {\n      response.headers\n          ..chunkedTransferEncoding = true\n          ..persistentConnection = headers.persistentConnection;\n    }\n\n    if (_httpServer._sessionManagerInstance != null) {\n      // Map to session if exists.\n      var sessionIds = cookies\n          .where((cookie) => cookie.name.toUpperCase() == _DART_SESSION_ID)\n          .map((cookie) => cookie.value);\n      for (var sessionId in sessionIds) {\n        _session = _httpServer._sessionManager.getSession(sessionId);\n        if (_session != null) {\n          _session._markSeen();\n          break;\n        }\n      }\n    }\n  }\n\n  StreamSubscription<List<int>> listen(void onData(List<int> event),\n                                       {Function onError,\n                                        void onDone(),\n                                        bool cancelOnError}) {\n    return _incoming.listen(onData,\n                            onError: onError,\n                            onDone: onDone,\n                            cancelOnError: cancelOnError);\n  }\n\n  Uri get uri => _incoming.uri;\n\n  Uri get requestedUri {\n    if (_requestedUri == null) {\n      var proto = headers['x-forwarded-proto'];\n      var scheme = proto != null ? proto.first :\n          _httpConnection._socket is SecureSocket ? \"https\" : \"http\";\n      var host = headers['x-forwarded-host'];\n      if (host != null) {\n        host = host.first;\n      } else {\n        host = headers['host'];\n        if (host != null) {\n          host = host.first;\n        } else {\n          host = \"${_httpServer.address.host}:${_httpServer.port}\";\n        }\n      }\n      _requestedUri = Uri.parse(\"$scheme://$host$uri\");\n    }\n    return _requestedUri;\n  }\n\n  String get method => _incoming.method;\n\n  HttpSession get session {\n    if (_session != null) {\n      if (_session._destroyed) {\n        // It's destroyed, clear it.\n        _session = null;\n        // Create new session object by calling recursive.\n        return session;\n      }\n      // It's already mapped, use it.\n      return _session;\n    }\n    // Create session, store it in connection, and return.\n    return _session = _httpServer._sessionManager.createSession();\n  }\n\n  HttpConnectionInfo get connectionInfo => _httpConnection.connectionInfo;\n\n  X509Certificate get certificate {\n    var socket = _httpConnection._socket;\n    if (socket is SecureSocket) return socket.peerCertificate;\n    return null;\n  }\n}\n\n\nclass _HttpClientResponse\n    extends _HttpInboundMessage implements HttpClientResponse {\n  List<RedirectInfo> get redirects => _httpRequest._responseRedirects;\n\n  // The HttpClient this response belongs to.\n  final _HttpClient _httpClient;\n\n  // The HttpClientRequest of this response.\n  final _HttpClientRequest _httpRequest;\n\n  List<Cookie> _cookies;\n\n  _HttpClientResponse(_HttpIncoming _incoming, this._httpRequest,\n                      this._httpClient) : super(_incoming) {\n    // Set uri for potential exceptions.\n    _incoming.uri = _httpRequest.uri;\n  }\n\n  int get statusCode => _incoming.statusCode;\n  String get reasonPhrase => _incoming.reasonPhrase;\n\n  X509Certificate get certificate {\n    // The peerCertificate isn't on a plain socket, so cast to dynamic.\n    var socket = _httpRequest._httpClientConnection._socket;\n    return socket.peerCertificate;\n  }\n\n  List<Cookie> get cookies {\n    if (_cookies != null) return _cookies;\n    _cookies = new List<Cookie>();\n    List<String> values = headers[HttpHeaders.SET_COOKIE];\n    if (values != null) {\n      values.forEach((value) {\n        _cookies.add(new Cookie.fromSetCookieValue(value));\n      });\n    }\n    return _cookies;\n  }\n\n  bool get isRedirect {\n    if (_httpRequest.method == \"GET\" || _httpRequest.method == \"HEAD\") {\n      return statusCode == HttpStatus.MOVED_PERMANENTLY ||\n             statusCode == HttpStatus.FOUND ||\n             statusCode == HttpStatus.SEE_OTHER ||\n             statusCode == HttpStatus.TEMPORARY_REDIRECT;\n    } else if (_httpRequest.method == \"POST\") {\n      return statusCode == HttpStatus.SEE_OTHER;\n    }\n    return false;\n  }\n\n  Future<HttpClientResponse> redirect([String method,\n                                       Uri url,\n                                       bool followLoops]) {\n    if (method == null) {\n      // Set method as defined by RFC 2616 section 10.3.4.\n      if (statusCode == HttpStatus.SEE_OTHER && _httpRequest.method == \"POST\") {\n        method = \"GET\";\n      } else {\n        method = _httpRequest.method;\n      }\n    }\n    if (url == null) {\n      String location = headers.value(HttpHeaders.LOCATION);\n      if (location == null) {\n        throw new StateError(\"Response has no Location header for redirect\");\n      }\n      url = Uri.parse(location);\n    }\n    if (followLoops != true) {\n      for (var redirect in redirects) {\n        if (redirect.location == url) {\n          return new Future.error(\n              new RedirectException(\"Redirect loop detected\", redirects));\n        }\n      }\n    }\n    return _httpClient._openUrlFromRequest(method, url, _httpRequest)\n        .then((request) {\n          request._responseRedirects\n              ..addAll(this.redirects)\n              ..add(new _RedirectInfo(statusCode, method, url));\n          return request.close();\n        });\n  }\n\n  StreamSubscription<List<int>> listen(void onData(List<int> event),\n                                       {Function onError,\n                                        void onDone(),\n                                        bool cancelOnError}) {\n    if (_incoming.upgraded) {\n      // If upgraded, the connection is already 'removed' form the client.\n      // Since listening to upgraded data is 'bogus', simply close and\n      // return empty stream subscription.\n      _httpRequest._httpClientConnection.destroy();\n      return new Stream.fromIterable([]).listen(null, onDone: onDone);\n    }\n    var stream = _incoming;\n    if (_httpClient.autoUncompress &&\n        headers.value(HttpHeaders.CONTENT_ENCODING) == \"gzip\") {\n      stream = stream.transform(GZIP.decoder);\n    }\n    return stream.listen(onData,\n                         onError: onError,\n                         onDone: onDone,\n                         cancelOnError: cancelOnError);\n  }\n\n  Future<Socket> detachSocket() {\n    _httpClient._connectionClosed(_httpRequest._httpClientConnection);\n    return _httpRequest._httpClientConnection.detachSocket();\n  }\n\n  HttpConnectionInfo get connectionInfo => _httpRequest.connectionInfo;\n\n  bool get _shouldAuthenticateProxy {\n    // Only try to authenticate if there is a challenge in the response.\n    List<String> challenge = headers[HttpHeaders.PROXY_AUTHENTICATE];\n    return statusCode == HttpStatus.PROXY_AUTHENTICATION_REQUIRED &&\n        challenge != null && challenge.length == 1;\n  }\n\n  bool get _shouldAuthenticate {\n    // Only try to authenticate if there is a challenge in the response.\n    List<String> challenge = headers[HttpHeaders.WWW_AUTHENTICATE];\n    return statusCode == HttpStatus.UNAUTHORIZED &&\n        challenge != null && challenge.length == 1;\n  }\n\n  Future<HttpClientResponse> _authenticate(bool proxyAuth) {\n    Future<HttpClientResponse> retry() {\n      // Drain body and retry.\n      return drain().then((_) {\n          return _httpClient._openUrlFromRequest(_httpRequest.method,\n                                                 _httpRequest.uri,\n                                                 _httpRequest)\n              .then((request) => request.close());\n          });\n    }\n\n    List<String> authChallenge() {\n      return proxyAuth ? headers[HttpHeaders.PROXY_AUTHENTICATE]\n                       : headers[HttpHeaders.WWW_AUTHENTICATE];\n    }\n\n    _Credentials findCredentials(_AuthenticationScheme scheme) {\n      return proxyAuth ? _httpClient._findProxyCredentials(_httpRequest._proxy,\n                                                           scheme)\n                       : _httpClient._findCredentials(_httpRequest.uri, scheme);\n    }\n\n    void removeCredentials(_Credentials cr) {\n      if (proxyAuth) {\n        _httpClient._removeProxyCredentials(cr);\n      } else {\n        _httpClient._removeCredentials(cr);\n      }\n    }\n\n    Future requestAuthentication(_AuthenticationScheme scheme, String realm) {\n      if (proxyAuth) {\n        if (_httpClient._authenticateProxy == null) {\n          return new Future.value(false);\n        }\n        var proxy = _httpRequest._proxy;\n        return _httpClient._authenticateProxy(proxy.host,\n                                              proxy.port,\n                                              scheme.toString(),\n                                              realm);\n      } else {\n        if (_httpClient._authenticate == null) {\n          return new Future.value(false);\n        }\n        return _httpClient._authenticate(_httpRequest.uri,\n                                         scheme.toString(),\n                                         realm);\n      }\n    }\n\n    List<String> challenge = authChallenge();\n    assert(challenge != null || challenge.length == 1);\n    _HeaderValue header =\n        _HeaderValue.parse(challenge[0], parameterSeparator: \",\");\n    _AuthenticationScheme scheme =\n        new _AuthenticationScheme.fromString(header.value);\n    String realm = header.parameters[\"realm\"];\n\n    // See if any matching credentials are available.\n    _Credentials cr = findCredentials(scheme);\n    if (cr != null) {\n      // For basic authentication don't retry already used credentials\n      // as they must have already been added to the request causing\n      // this authenticate response.\n      if (cr.scheme == _AuthenticationScheme.BASIC && !cr.used) {\n        // Credentials where found, prepare for retrying the request.\n        return retry();\n      }\n\n      // Digest authentication only supports the MD5 algorithm.\n      if (cr.scheme == _AuthenticationScheme.DIGEST &&\n          (header.parameters[\"algorithm\"] == null ||\n           header.parameters[\"algorithm\"].toLowerCase() == \"md5\")) {\n        if (cr.nonce == null || cr.nonce == header.parameters[\"nonce\"]) {\n          // If the nonce is not set then this is the first authenticate\n          // response for these credentials. Set up authentication state.\n          if (cr.nonce == null) {\n            cr..nonce = header.parameters[\"nonce\"]\n              ..algorithm = \"MD5\"\n              ..qop = header.parameters[\"qop\"]\n              ..nonceCount = 0;\n          }\n          // Credentials where found, prepare for retrying the request.\n          return retry();\n        } else if (header.parameters[\"stale\"] != null &&\n                   header.parameters[\"stale\"].toLowerCase() == \"true\") {\n          // If stale is true retry with new nonce.\n          cr.nonce = header.parameters[\"nonce\"];\n          // Credentials where found, prepare for retrying the request.\n          return retry();\n        }\n      }\n    }\n\n    // Ask for more credentials if none found or the one found has\n    // already been used. If it has already been used it must now be\n    // invalid and is removed.\n    if (cr != null) {\n      removeCredentials(cr);\n      cr = null;\n    }\n    return requestAuthentication(scheme, realm).then((credsAvailable) {\n      if (credsAvailable) {\n        cr = _httpClient._findCredentials(_httpRequest.uri, scheme);\n        return retry();\n      } else {\n        // No credentials available, complete with original response.\n        return this;\n      }\n    });\n  }\n}\n\n\nabstract class _HttpOutboundMessage<T> extends _IOSinkImpl {\n  // Used to mark when the body should be written. This is used for HEAD\n  // requests and in error handling.\n  bool _encodingSet = false;\n\n  bool _bufferOutput = true;\n\n  final Uri _uri;\n  final _HttpOutgoing _outgoing;\n\n  final _HttpHeaders headers;\n\n  _HttpOutboundMessage(Uri uri,\n                       String protocolVersion,\n                       _HttpOutgoing outgoing,\n                       {_HttpHeaders initialHeaders})\n      : super(outgoing, null),\n        _uri = uri,\n        headers = new _HttpHeaders(\n            protocolVersion,\n            defaultPortForScheme: uri.scheme == 'https' ?\n                HttpClient.DEFAULT_HTTPS_PORT :\n                HttpClient.DEFAULT_HTTP_PORT,\n            initialHeaders: initialHeaders),\n        _outgoing = outgoing {\n    _outgoing.outbound = this;\n    _encodingMutable = false;\n  }\n\n  int get contentLength => headers.contentLength;\n  void set contentLength(int contentLength) {\n    headers.contentLength = contentLength;\n  }\n\n  bool get persistentConnection => headers.persistentConnection;\n  void set persistentConnection(bool p) {\n    headers.persistentConnection = p;\n  }\n\n  bool get bufferOutput => _bufferOutput;\n  void set bufferOutput(bool bufferOutput) {\n    if (_outgoing.headersWritten) throw new StateError(\"Header already sent\");\n    _bufferOutput = bufferOutput;\n  }\n\n\n  Encoding get encoding {\n    if (_encodingSet && _outgoing.headersWritten) {\n      return _encoding;\n    }\n    var charset;\n    if (headers.contentType != null && headers.contentType.charset != null) {\n      charset = headers.contentType.charset;\n    } else {\n      charset = \"iso-8859-1\";\n    }\n    return Encoding.getByName(charset);\n  }\n\n  void add(List<int> data) {\n    if (data.length == 0) return;\n    super.add(data);\n  }\n\n  void write(Object obj) {\n    if (!_encodingSet) {\n      _encoding = encoding;\n      _encodingSet = true;\n    }\n    super.write(obj);\n  }\n\n  void _writeHeader();\n\n  bool get _isConnectionClosed => false;\n}\n\n\nclass _HttpResponse extends _HttpOutboundMessage<HttpResponse>\n    implements HttpResponse {\n  int _statusCode = 200;\n  String _reasonPhrase;\n  List<Cookie> _cookies;\n  _HttpRequest _httpRequest;\n  Duration _deadline;\n  Timer _deadlineTimer;\n\n  _HttpResponse(Uri uri,\n                String protocolVersion,\n                _HttpOutgoing outgoing,\n                HttpHeaders defaultHeaders,\n                String serverHeader)\n      : super(uri, protocolVersion, outgoing, initialHeaders: defaultHeaders) {\n    if (serverHeader != null) headers.set('server', serverHeader);\n  }\n\n  bool get _isConnectionClosed => _httpRequest._httpConnection._isClosing;\n\n  List<Cookie> get cookies {\n    if (_cookies == null) _cookies = new List<Cookie>();\n    return _cookies;\n  }\n\n  int get statusCode => _statusCode;\n  void set statusCode(int statusCode) {\n    if (_outgoing.headersWritten) throw new StateError(\"Header already sent\");\n    _statusCode = statusCode;\n  }\n\n  String get reasonPhrase => _findReasonPhrase(statusCode);\n  void set reasonPhrase(String reasonPhrase) {\n    if (_outgoing.headersWritten) throw new StateError(\"Header already sent\");\n    _reasonPhrase = reasonPhrase;\n  }\n\n  Future redirect(Uri location, {int status: HttpStatus.MOVED_TEMPORARILY}) {\n    if (_outgoing.headersWritten) throw new StateError(\"Header already sent\");\n    statusCode = status;\n    headers.set(\"location\", location.toString());\n    return close();\n  }\n\n  Future<Socket> detachSocket({bool writeHeaders: true}) {\n    if (_outgoing.headersWritten) throw new StateError(\"Headers already sent\");\n    deadline = null;  // Be sure to stop any deadline.\n    var future = _httpRequest._httpConnection.detachSocket();\n    if (writeHeaders) {\n      var headersFuture = _outgoing.writeHeaders(drainRequest: false,\n                                                 setOutgoing: false);\n      assert(headersFuture == null);\n    } else {\n      // Imitate having written the headers.\n      _outgoing.headersWritten = true;\n    }\n    // Close connection so the socket is 'free'.\n    close();\n    done.catchError((_) {\n      // Catch any error on done, as they automatically will be\n      // propagated to the websocket.\n    });\n    return future;\n  }\n\n  HttpConnectionInfo get connectionInfo => _httpRequest.connectionInfo;\n\n  Duration get deadline => _deadline;\n\n  void set deadline(Duration d) {\n    if (_deadlineTimer != null) _deadlineTimer.cancel();\n    _deadline = d;\n\n    if (_deadline == null) return;\n    _deadlineTimer = new Timer(_deadline, () {\n      _httpRequest._httpConnection.destroy();\n    });\n  }\n\n  void _writeHeader() {\n    Uint8List buffer = new Uint8List(_OUTGOING_BUFFER_SIZE);\n    int offset = 0;\n\n    void write(List<int> bytes) {\n      int len = bytes.length;\n      for (int i = 0; i < len; i++) {\n        buffer[offset + i] = bytes[i];\n      }\n      offset += len;\n    }\n\n    // Write status line.\n    if (headers.protocolVersion == \"1.1\") {\n      write(_Const.HTTP11);\n    } else {\n      write(_Const.HTTP10);\n    }\n    buffer[offset++] = _CharCode.SP;\n    write(statusCode.toString().codeUnits);\n    buffer[offset++] = _CharCode.SP;\n    write(reasonPhrase.codeUnits);\n    buffer[offset++] = _CharCode.CR;\n    buffer[offset++] = _CharCode.LF;\n\n    var session = _httpRequest._session;\n    if (session != null && !session._destroyed) {\n      // Mark as not new.\n      session._isNew = false;\n      // Make sure we only send the current session id.\n      bool found = false;\n      for (int i = 0; i < cookies.length; i++) {\n        if (cookies[i].name.toUpperCase() == _DART_SESSION_ID) {\n          cookies[i]\n              ..value = session.id\n              ..httpOnly = true\n              ..path = \"/\";\n          found = true;\n        }\n      }\n      if (!found) {\n        var cookie = new Cookie(_DART_SESSION_ID, session.id);\n        cookies.add(cookie\n            ..httpOnly = true\n            ..path = \"/\");\n      }\n    }\n    // Add all the cookies set to the headers.\n    if (_cookies != null) {\n      _cookies.forEach((cookie) {\n        headers.add(HttpHeaders.SET_COOKIE, cookie);\n      });\n    }\n\n    headers._finalize();\n\n    // Write headers.\n    offset = headers._write(buffer, offset);\n    buffer[offset++] = _CharCode.CR;\n    buffer[offset++] = _CharCode.LF;\n    _outgoing.setHeader(buffer, offset);\n  }\n\n  String _findReasonPhrase(int statusCode) {\n    if (_reasonPhrase != null) {\n      return _reasonPhrase;\n    }\n\n    switch (statusCode) {\n      case HttpStatus.CONTINUE: return \"Continue\";\n      case HttpStatus.SWITCHING_PROTOCOLS: return \"Switching Protocols\";\n      case HttpStatus.OK: return \"OK\";\n      case HttpStatus.CREATED: return \"Created\";\n      case HttpStatus.ACCEPTED: return \"Accepted\";\n      case HttpStatus.NON_AUTHORITATIVE_INFORMATION:\n        return \"Non-Authoritative Information\";\n      case HttpStatus.NO_CONTENT: return \"No Content\";\n      case HttpStatus.RESET_CONTENT: return \"Reset Content\";\n      case HttpStatus.PARTIAL_CONTENT: return \"Partial Content\";\n      case HttpStatus.MULTIPLE_CHOICES: return \"Multiple Choices\";\n      case HttpStatus.MOVED_PERMANENTLY: return \"Moved Permanently\";\n      case HttpStatus.FOUND: return \"Found\";\n      case HttpStatus.SEE_OTHER: return \"See Other\";\n      case HttpStatus.NOT_MODIFIED: return \"Not Modified\";\n      case HttpStatus.USE_PROXY: return \"Use Proxy\";\n      case HttpStatus.TEMPORARY_REDIRECT: return \"Temporary Redirect\";\n      case HttpStatus.BAD_REQUEST: return \"Bad Request\";\n      case HttpStatus.UNAUTHORIZED: return \"Unauthorized\";\n      case HttpStatus.PAYMENT_REQUIRED: return \"Payment Required\";\n      case HttpStatus.FORBIDDEN: return \"Forbidden\";\n      case HttpStatus.NOT_FOUND: return \"Not Found\";\n      case HttpStatus.METHOD_NOT_ALLOWED: return \"Method Not Allowed\";\n      case HttpStatus.NOT_ACCEPTABLE: return \"Not Acceptable\";\n      case HttpStatus.PROXY_AUTHENTICATION_REQUIRED:\n        return \"Proxy Authentication Required\";\n      case HttpStatus.REQUEST_TIMEOUT: return \"Request Time-out\";\n      case HttpStatus.CONFLICT: return \"Conflict\";\n      case HttpStatus.GONE: return \"Gone\";\n      case HttpStatus.LENGTH_REQUIRED: return \"Length Required\";\n      case HttpStatus.PRECONDITION_FAILED: return \"Precondition Failed\";\n      case HttpStatus.REQUEST_ENTITY_TOO_LARGE:\n        return \"Request Entity Too Large\";\n      case HttpStatus.REQUEST_URI_TOO_LONG: return \"Request-URI Too Large\";\n      case HttpStatus.UNSUPPORTED_MEDIA_TYPE: return \"Unsupported Media Type\";\n      case HttpStatus.REQUESTED_RANGE_NOT_SATISFIABLE:\n        return \"Requested range not satisfiable\";\n      case HttpStatus.EXPECTATION_FAILED: return \"Expectation Failed\";\n      case HttpStatus.INTERNAL_SERVER_ERROR: return \"Internal Server Error\";\n      case HttpStatus.NOT_IMPLEMENTED: return \"Not Implemented\";\n      case HttpStatus.BAD_GATEWAY: return \"Bad Gateway\";\n      case HttpStatus.SERVICE_UNAVAILABLE: return \"Service Unavailable\";\n      case HttpStatus.GATEWAY_TIMEOUT: return \"Gateway Time-out\";\n      case HttpStatus.HTTP_VERSION_NOT_SUPPORTED:\n        return \"Http Version not supported\";\n      default: return \"Status $statusCode\";\n    }\n  }\n}\n\n\nclass _HttpClientRequest extends _HttpOutboundMessage<HttpClientResponse>\n    implements HttpClientRequest {\n  final String method;\n  final Uri uri;\n  final List<Cookie> cookies = new List<Cookie>();\n\n  // The HttpClient this request belongs to.\n  final _HttpClient _httpClient;\n  final _HttpClientConnection _httpClientConnection;\n\n  final Completer<HttpClientResponse> _responseCompleter\n      = new Completer<HttpClientResponse>();\n\n  final _Proxy _proxy;\n\n  Future<HttpClientResponse> _response;\n\n  // TODO(ajohnsen): Get default value from client?\n  bool _followRedirects = true;\n\n  int _maxRedirects = 5;\n\n  List<RedirectInfo> _responseRedirects = [];\n\n  _HttpClientRequest(_HttpOutgoing outgoing, Uri uri, this.method, this._proxy,\n                     this._httpClient, this._httpClientConnection)\n      : super(uri, \"1.1\", outgoing),\n        uri = uri {\n    // GET and HEAD have 'content-length: 0' by default.\n    if (method == \"GET\" || method == \"HEAD\") {\n      contentLength = 0;\n    } else {\n      headers.chunkedTransferEncoding = true;\n    }\n  }\n\n  Future<HttpClientResponse> get done {\n    if (_response == null) {\n      _response = Future.wait([_responseCompleter.future, super.done],\n                              eagerError: true)\n        .then((list) => list[0]);\n    }\n    return _response;\n  }\n\n  Future<HttpClientResponse> close() {\n    super.close();\n    return done;\n  }\n\n  int get maxRedirects => _maxRedirects;\n  void set maxRedirects(int maxRedirects) {\n    if (_outgoing.headersWritten) throw new StateError(\"Request already sent\");\n    _maxRedirects = maxRedirects;\n  }\n\n  bool get followRedirects => _followRedirects;\n  void set followRedirects(bool followRedirects) {\n    if (_outgoing.headersWritten) throw new StateError(\"Request already sent\");\n    _followRedirects = followRedirects;\n  }\n\n  HttpConnectionInfo get connectionInfo => _httpClientConnection.connectionInfo;\n\n  void _onIncoming(_HttpIncoming incoming) {\n    var response = new _HttpClientResponse(incoming, this, _httpClient);\n    Future<HttpClientResponse> future;\n    if (followRedirects && response.isRedirect) {\n      if (response.redirects.length < maxRedirects) {\n        // Redirect and drain response.\n        future = response.drain().then((_) => response.redirect());\n      } else {\n        // End with exception, too many redirects.\n        future = response.drain()\n            .then((_) => new Future.error(\n                new RedirectException(\"Redirect limit exceeded\",\n                                      response.redirects)));\n      }\n    } else if (response._shouldAuthenticateProxy) {\n      future = response._authenticate(true);\n    } else if (response._shouldAuthenticate) {\n      future = response._authenticate(false);\n    } else {\n      future = new Future<HttpClientResponse>.value(response);\n    }\n    future.then(\n        (v) => _responseCompleter.complete(v),\n        onError: _responseCompleter.completeError);\n  }\n\n  void _onError(error, StackTrace stackTrace) {\n    _responseCompleter.completeError(error, stackTrace);\n  }\n\n  // Generate the request URI based on the method and proxy.\n  String _requestUri() {\n    // Generate the request URI starting from the path component.\n    String uriStartingFromPath() {\n      String result = uri.path;\n      if (result.length == 0) result = \"/\";\n      if (uri.query != \"\") {\n        if (uri.fragment != \"\") {\n          result = \"${result}?${uri.query}#${uri.fragment}\";\n        } else {\n          result = \"${result}?${uri.query}\";\n        }\n      }\n      return result;\n    }\n\n    if (_proxy.isDirect) {\n      return uriStartingFromPath();\n    } else {\n      if (method == \"CONNECT\") {\n        // For the connect method the request URI is the host:port of\n        // the requested destination of the tunnel (see RFC 2817\n        // section 5.2)\n        return \"${uri.host}:${uri.port}\";\n      } else {\n        if (_httpClientConnection._proxyTunnel) {\n          return uriStartingFromPath();\n        } else {\n          return uri.toString();\n        }\n      }\n    }\n  }\n\n  void _writeHeader() {\n    Uint8List buffer = new Uint8List(_OUTGOING_BUFFER_SIZE);\n    int offset = 0;\n\n    void write(List<int> bytes) {\n      int len = bytes.length;\n      for (int i = 0; i < len; i++) {\n        buffer[offset + i] = bytes[i];\n      }\n      offset += len;\n    }\n\n    // Write the request method.\n    write(method.codeUnits);\n    buffer[offset++] = _CharCode.SP;\n    // Write the request URI.\n    write(_requestUri().codeUnits);\n    buffer[offset++] = _CharCode.SP;\n    // Write HTTP/1.1.\n    write(_Const.HTTP11);\n    buffer[offset++] = _CharCode.CR;\n    buffer[offset++] = _CharCode.LF;\n\n    // Add the cookies to the headers.\n    if (!cookies.isEmpty) {\n      StringBuffer sb = new StringBuffer();\n      for (int i = 0; i < cookies.length; i++) {\n        if (i > 0) sb.write(\"; \");\n        sb..write(cookies[i].name)..write(\"=\")..write(cookies[i].value);\n      }\n      headers.add(HttpHeaders.COOKIE, sb.toString());\n    }\n\n    headers._finalize();\n\n    // Write headers.\n    offset = headers._write(buffer, offset);\n    buffer[offset++] = _CharCode.CR;\n    buffer[offset++] = _CharCode.LF;\n    _outgoing.setHeader(buffer, offset);\n  }\n}\n\n// Used by _HttpOutgoing as a target of a chunked converter for gzip\n// compression.\nclass _HttpGZipSink extends ByteConversionSink {\n  final Function _consume;\n  _HttpGZipSink(this._consume);\n\n  void add(List<int> chunk) {\n    _consume(chunk);\n  }\n\n  void addSlice(Uint8List chunk, int start, int end, bool isLast) {\n    _consume(new Uint8List.view(chunk.buffer, start, end - start));\n  }\n\n  void close() {}\n}\n\n\n// The _HttpOutgoing handles all of the following:\n//  - Buffering\n//  - GZip compressionm\n//  - Content-Length validation.\n//  - Errors.\n//\n// Most notable is the GZip compression, that uses a double-buffering system,\n// one before gzip (_gzipBuffer) and one after (_buffer).\nclass _HttpOutgoing implements StreamConsumer<List<int>> {\n  static const List<int> _footerAndChunk0Length =\n      const [_CharCode.CR, _CharCode.LF, 0x30, _CharCode.CR, _CharCode.LF,\n             _CharCode.CR, _CharCode.LF];\n\n  static const List<int> _chunk0Length =\n      const [0x30, _CharCode.CR, _CharCode.LF, _CharCode.CR, _CharCode.LF];\n\n  final Completer _doneCompleter = new Completer();\n  final Socket socket;\n\n  bool ignoreBody = false;\n  bool headersWritten = false;\n\n  Uint8List _buffer;\n  int _length = 0;\n\n  Future _closeFuture;\n\n  bool chunked = false;\n  int _pendingChunkedFooter = 0;\n\n  int contentLength;\n  int _bytesWritten = 0;\n\n  bool _gzip = false;\n  ByteConversionSink _gzipSink;\n  // _gzipAdd is set iff the sink is being added to. It's used to specify where\n  // gzipped data should be taken (sometimes a controller, sometimes a socket).\n  Function _gzipAdd;\n  Uint8List _gzipBuffer;\n  int _gzipBufferLength = 0;\n\n  bool _socketError = false;\n\n  _HttpOutboundMessage outbound;\n\n  _HttpOutgoing(this.socket);\n\n  // Returns either a future or 'null', if it was able to write headers\n  // immediately.\n  Future writeHeaders({bool drainRequest: true, bool setOutgoing: true}) {\n    Future write() {\n      try {\n        outbound._writeHeader();\n      } catch (_) {\n        // Headers too large.\n        return new Future.error(new HttpException(\n            \"Headers size exceeded the of '$_OUTGOING_BUFFER_SIZE'\"\n            \" bytes\"));\n      }\n    }\n    if (headersWritten) return null;\n    headersWritten = true;\n    Future drainFuture;\n    bool isServerSide = outbound is _HttpResponse;\n    bool gzip = false;\n    if (isServerSide) {\n      var response = outbound;\n      if (outbound.bufferOutput && outbound.headers.chunkedTransferEncoding) {\n        List acceptEncodings =\n            response._httpRequest.headers[HttpHeaders.ACCEPT_ENCODING];\n        List contentEncoding = outbound.headers[HttpHeaders.CONTENT_ENCODING];\n        if (acceptEncodings != null &&\n            acceptEncodings\n                .expand((list) => list.split(\",\"))\n                .any((encoding) => encoding.trim().toLowerCase() == \"gzip\") &&\n            contentEncoding == null) {\n          outbound.headers.set(HttpHeaders.CONTENT_ENCODING, \"gzip\");\n          gzip = true;\n        }\n      }\n      if (drainRequest && !response._httpRequest._incoming.hasSubscriber) {\n        drainFuture = response._httpRequest.drain().catchError((_) {});\n      }\n    } else {\n      drainRequest = false;\n    }\n    if (ignoreBody) {\n      return write();\n    }\n    if (setOutgoing) {\n      int contentLength = outbound.headers.contentLength;\n      if (outbound.headers.chunkedTransferEncoding) {\n        chunked = true;\n        if (gzip) this.gzip = true;\n      } else if (contentLength >= 0) {\n        this.contentLength = contentLength;\n      }\n    }\n    if (drainFuture != null) {\n      return drainFuture.then((_) => write());\n    }\n    return write();\n  }\n\n\n  Future addStream(Stream<List<int>> stream) {\n    if (_socketError) {\n      stream.listen(null).cancel();\n      return new Future.value(outbound);\n    }\n    if (ignoreBody) {\n      stream.drain().catchError((_) {});\n      var future = writeHeaders();\n      if (future != null) {\n        return future.then((_) => close());\n      }\n      return close();\n    }\n    var sub;\n    // Use new stream so we are able to pause (see below listen). The\n    // alternative is to use stream.extand, but that won't give us a way of\n    // pausing.\n    var controller = new StreamController(\n        onPause: () => sub.pause(),\n        onResume: () => sub.resume(),\n        sync: true);\n\n    void onData(data) {\n      if (_socketError) return;\n      if (data.length == 0) return;\n      if (chunked) {\n        if (_gzip) {\n          _gzipAdd = controller.add;\n          _addGZipChunk(data, _gzipSink.add);\n          _gzipAdd = null;\n          return;\n        }\n        _addChunk(_chunkHeader(data.length), controller.add);\n        _pendingChunkedFooter = 2;\n      } else {\n        if (contentLength != null) {\n          _bytesWritten += data.length;\n          if (_bytesWritten > contentLength) {\n            controller.addError(new HttpException(\n                \"Content size exceeds specified contentLength. \"\n                \"$_bytesWritten bytes written while expected \"\n                \"$contentLength. \"\n                \"[${new String.fromCharCodes(data)}]\"));\n            return;\n          }\n        }\n      }\n      _addChunk(data, controller.add);\n    }\n\n    sub = stream.listen(\n        onData,\n        onError: controller.addError,\n        onDone: controller.close,\n        cancelOnError: true);\n    // Write headers now that we are listening to the stream.\n    if (!headersWritten) {\n      var future = writeHeaders();\n      if (future != null) {\n        // While incoming is being drained, the pauseFuture is non-null. Pause\n        // output until it's drained.\n        sub.pause(future);\n      }\n    }\n    return socket.addStream(controller.stream)\n        .then((_) {\n          return outbound;\n        }, onError: (error) {\n          // Be sure to close it in case of an error.\n          if (_gzip) _gzipSink.close();\n          _socketError = true;\n          _doneCompleter.completeError(error);\n          if (_ignoreError(error)) {\n            return outbound;\n          } else {\n            throw error;\n          }\n        });\n  }\n\n  Future close() {\n    // If we are already closed, return that future.\n    if (_closeFuture != null) return _closeFuture;\n    // If we earlier saw an error, return immediate. The notification to\n    // _Http*Connection is already done.\n    if (_socketError) return new Future.value(outbound);\n    if (outbound._isConnectionClosed) return new Future.value(outbound);\n    if (!headersWritten && !ignoreBody) {\n      if (outbound.headers.contentLength == -1) {\n        // If no body was written, ignoreBody is false (it's not a HEAD\n        // request) and the content-length is unspecified, set contentLength to\n        // 0.\n        outbound.headers.chunkedTransferEncoding = false;\n        outbound.headers.contentLength = 0;\n      } else if (outbound.headers.contentLength > 0) {\n        var error = new HttpException(\n              \"No content even though contentLength was specified to be \"\n              \"greater than 0: ${outbound.headers.contentLength}.\",\n              uri: outbound._uri);\n        _doneCompleter.completeError(error);\n        return _closeFuture = new Future.error(error);\n      }\n    }\n    // If contentLength was specified, validate it.\n    if (contentLength != null) {\n      if (_bytesWritten < contentLength) {\n        var error = new HttpException(\n            \"Content size below specified contentLength. \"\n            \" $_bytesWritten bytes written but expected \"\n            \"$contentLength.\",\n            uri: outbound._uri);\n        _doneCompleter.completeError(error);\n        return _closeFuture = new Future.error(error);\n      }\n    }\n\n    Future finalize() {\n      // In case of chunked encoding (and gzip), handle remaining gzip data and\n      // append the 'footer' for chunked encoding.\n      if (chunked) {\n        if (_gzip) {\n          _gzipAdd = socket.add;\n          if (_gzipBufferLength > 0) {\n            _gzipSink.add(new Uint8List.view(\n                _gzipBuffer.buffer, 0, _gzipBufferLength));\n          }\n          _gzipBuffer = null;\n          _gzipSink.close();\n          _gzipAdd = null;\n        }\n        _addChunk(_chunkHeader(0), socket.add);\n      }\n      // Add any remaining data in the buffer.\n      if (_length > 0) {\n        socket.add(new Uint8List.view(_buffer.buffer, 0, _length));\n      }\n      // Clear references, for better GC.\n      _buffer = null;\n      // And finally flush it. As we support keep-alive, never close it from\n      // here. Once the socket is flushed, we'll be able to reuse it (signaled\n      // by the 'done' future).\n      return socket.flush()\n        .then((_) {\n          _doneCompleter.complete(socket);\n          return outbound;\n        }, onError: (error) {\n          _doneCompleter.completeError(error);\n          if (_ignoreError(error)) {\n            return outbound;\n          } else {\n            throw error;\n          }\n        });\n    }\n\n    var future = writeHeaders();\n    if (future != null) {\n      return _closeFuture = future.whenComplete(finalize);\n    }\n    return _closeFuture = finalize();\n  }\n\n  Future get done => _doneCompleter.future;\n\n  void setHeader(List<int> data, int length) {\n    assert(_length == 0);\n    assert(data.length == _OUTGOING_BUFFER_SIZE);\n    _buffer = data;\n    _length = length;\n  }\n\n  void set gzip(bool value) {\n    _gzip = value;\n    if (_gzip) {\n      _gzipBuffer = new Uint8List(_OUTGOING_BUFFER_SIZE);\n      assert(_gzipSink == null);\n      _gzipSink = new ZLibEncoder(gzip: true)\n          .startChunkedConversion(\n              new _HttpGZipSink((data) {\n                // We are closing down prematurely, due to an error. Discard.\n                if (_gzipAdd == null) return;\n                _addChunk(_chunkHeader(data.length), _gzipAdd);\n                _pendingChunkedFooter = 2;\n                _addChunk(data, _gzipAdd);\n              }));\n    }\n  }\n\n  bool _ignoreError(error)\n    => (error is SocketException || error is TlsException) &&\n       outbound is HttpResponse;\n\n  void _addGZipChunk(chunk, void add(List<int> data)) {\n    if (!outbound.bufferOutput) {\n      add(chunk);\n      return;\n    }\n    if (chunk.length > _gzipBuffer.length - _gzipBufferLength) {\n      add(new Uint8List.view(\n          _gzipBuffer.buffer, 0, _gzipBufferLength));\n      _gzipBuffer = new Uint8List(_OUTGOING_BUFFER_SIZE);\n      _gzipBufferLength = 0;\n    }\n    if (chunk.length > _OUTGOING_BUFFER_SIZE) {\n      add(chunk);\n    } else {\n      _gzipBuffer.setRange(_gzipBufferLength,\n                           _gzipBufferLength + chunk.length,\n                           chunk);\n      _gzipBufferLength += chunk.length;\n    }\n  }\n\n  void _addChunk(chunk, void add(List<int> data)) {\n    if (!outbound.bufferOutput) {\n      if (_buffer != null) {\n        // If _buffer is not null, we have not written the header yet. Write\n        // it now.\n        add(new Uint8List.view(_buffer.buffer, 0, _length));\n        _buffer = null;\n        _length = 0;\n      }\n      add(chunk);\n      return;\n    }\n    if (chunk.length > _buffer.length - _length) {\n      add(new Uint8List.view(_buffer.buffer, 0, _length));\n      _buffer = new Uint8List(_OUTGOING_BUFFER_SIZE);\n      _length = 0;\n    }\n    if (chunk.length > _OUTGOING_BUFFER_SIZE) {\n      add(chunk);\n    } else {\n      _buffer.setRange(_length, _length + chunk.length, chunk);\n      _length += chunk.length;\n    }\n  }\n\n  List<int> _chunkHeader(int length) {\n    const hexDigits = const [0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37,\n                             0x38, 0x39, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46];\n    if (length == 0) {\n      if (_pendingChunkedFooter == 2) return _footerAndChunk0Length;\n      return _chunk0Length;\n    }\n    int size = _pendingChunkedFooter;\n    int len = length;\n    // Compute a fast integer version of (log(length + 1) / log(16)).ceil().\n    while (len > 0) {\n      size++;\n      len >>= 4;\n    }\n    var footerAndHeader = new Uint8List(size + 2);\n    if (_pendingChunkedFooter == 2) {\n      footerAndHeader[0] = _CharCode.CR;\n      footerAndHeader[1] = _CharCode.LF;\n    }\n    int index = size;\n    while (index > _pendingChunkedFooter) {\n      footerAndHeader[--index] = hexDigits[length & 15];\n      length = length >> 4;\n    }\n    footerAndHeader[size + 0] = _CharCode.CR;\n    footerAndHeader[size + 1] = _CharCode.LF;\n    return footerAndHeader;\n  }\n}\n\nclass _HttpClientConnection {\n  final String key;\n  final Socket _socket;\n  final bool _proxyTunnel;\n  final _HttpParser _httpParser;\n  StreamSubscription _subscription;\n  final _HttpClient _httpClient;\n  bool _dispose = false;\n  Timer _idleTimer;\n  bool closed = false;\n  Uri _currentUri;\n\n  Completer<_HttpIncoming> _nextResponseCompleter;\n  Future _streamFuture;\n\n  _HttpClientConnection(this.key, this._socket, this._httpClient,\n                        [this._proxyTunnel = false])\n      : _httpParser = new _HttpParser.responseParser() {\n    _httpParser.listenToStream(_socket);\n\n    // Set up handlers on the parser here, so we are sure to get 'onDone' from\n    // the parser.\n    _subscription = _httpParser.listen(\n        (incoming) {\n          // Only handle one incoming response at the time. Keep the\n          // stream paused until the response have been processed.\n          _subscription.pause();\n          // We assume the response is not here, until we have send the request.\n          if (_nextResponseCompleter == null) {\n            throw new HttpException(\n                \"Unexpected response (unsolicited response without request).\",\n                uri: _currentUri);\n          }\n          _nextResponseCompleter.complete(incoming);\n          _nextResponseCompleter = null;\n        },\n        onError: (error, [StackTrace stackTrace]) {\n          if (_nextResponseCompleter != null) {\n            _nextResponseCompleter.completeError(\n                new HttpException(error.message, uri: _currentUri),\n                stackTrace);\n            _nextResponseCompleter = null;\n          }\n        },\n        onDone: () {\n          if (_nextResponseCompleter != null) {\n            _nextResponseCompleter.completeError(new HttpException(\n                \"Connection closed before response was received\",\n                uri: _currentUri));\n            _nextResponseCompleter = null;\n          }\n          close();\n        });\n  }\n\n  _HttpClientRequest send(Uri uri, int port, String method, _Proxy proxy) {\n    if (closed) {\n      throw new HttpException(\n          \"Socket closed before request was sent\", uri: uri);\n    }\n    _currentUri = uri;\n    // Start with pausing the parser.\n    _subscription.pause();\n    _ProxyCredentials proxyCreds;  // Credentials used to authorize proxy.\n    _SiteCredentials creds;  // Credentials used to authorize this request.\n    var outgoing = new _HttpOutgoing(_socket);\n    // Create new request object, wrapping the outgoing connection.\n    var request = new _HttpClientRequest(outgoing,\n                                         uri,\n                                         method,\n                                         proxy,\n                                         _httpClient,\n                                         this);\n    request.headers\n        ..host = uri.host\n        ..port = port\n        .._add(HttpHeaders.ACCEPT_ENCODING, \"gzip\");\n    if (_httpClient.userAgent != null) {\n      request.headers._add('user-agent', _httpClient.userAgent);\n    }\n    if (proxy.isAuthenticated) {\n      // If the proxy configuration contains user information use that\n      // for proxy basic authorization.\n      String auth = _CryptoUtils.bytesToBase64(\n          UTF8.encode(\"${proxy.username}:${proxy.password}\"));\n      request.headers.set(HttpHeaders.PROXY_AUTHORIZATION, \"Basic $auth\");\n    } else if (!proxy.isDirect && _httpClient._proxyCredentials.length > 0) {\n      proxyCreds = _httpClient._findProxyCredentials(proxy);\n      if (proxyCreds != null) {\n        proxyCreds.authorize(request);\n      }\n    }\n    if (uri.userInfo != null && !uri.userInfo.isEmpty) {\n      // If the URL contains user information use that for basic\n      // authorization.\n      String auth =\n          _CryptoUtils.bytesToBase64(UTF8.encode(uri.userInfo));\n      request.headers.set(HttpHeaders.AUTHORIZATION, \"Basic $auth\");\n    } else {\n      // Look for credentials.\n      creds = _httpClient._findCredentials(uri);\n      if (creds != null) {\n        creds.authorize(request);\n      }\n    }\n    // Start sending the request (lazy, delayed until the user provides\n    // data).\n    _httpParser.isHead = method == \"HEAD\";\n    _streamFuture = outgoing.done\n        .then((s) {\n          // Request sent, set up response completer.\n          _nextResponseCompleter = new Completer();\n\n          // Listen for response.\n          _nextResponseCompleter.future\n              .then((incoming) {\n                _currentUri = null;\n                incoming.dataDone.then((closing) {\n                  if (incoming.upgraded) {\n                    _httpClient._connectionClosed(this);\n                    startTimer();\n                    return;\n                  }\n                  if (closed) return;\n                  if (!closing &&\n                      !_dispose &&\n                      incoming.headers.persistentConnection &&\n                      request.persistentConnection) {\n                    // Return connection, now we are done.\n                    _httpClient._returnConnection(this);\n                    _subscription.resume();\n                  } else {\n                    destroy();\n                  }\n                });\n                // For digest authentication if proxy check if the proxy\n                // requests the client to start using a new nonce for proxy\n                // authentication.\n                if (proxyCreds != null &&\n                    proxyCreds.scheme == _AuthenticationScheme.DIGEST) {\n                  var authInfo = incoming.headers[\"proxy-authentication-info\"];\n                  if (authInfo != null && authInfo.length == 1) {\n                    var header =\n                        _HeaderValue.parse(\n                            authInfo[0], parameterSeparator: ',');\n                    var nextnonce = header.parameters[\"nextnonce\"];\n                    if (nextnonce != null) proxyCreds.nonce = nextnonce;\n                  }\n                }\n                // For digest authentication check if the server requests the\n                // client to start using a new nonce.\n                if (creds != null &&\n                    creds.scheme == _AuthenticationScheme.DIGEST) {\n                  var authInfo = incoming.headers[\"authentication-info\"];\n                  if (authInfo != null && authInfo.length == 1) {\n                    var header =\n                        _HeaderValue.parse(\n                            authInfo[0], parameterSeparator: ',');\n                    var nextnonce = header.parameters[\"nextnonce\"];\n                    if (nextnonce != null) creds.nonce = nextnonce;\n                  }\n                }\n                request._onIncoming(incoming);\n              })\n              // If we see a state error, we failed to get the 'first'\n              // element.\n              .catchError((error) {\n                throw new HttpException(\n                    \"Connection closed before data was received\", uri: uri);\n              }, test: (error) => error is StateError)\n              .catchError((error, stackTrace) {\n                // We are done with the socket.\n                destroy();\n                request._onError(error, stackTrace);\n              });\n\n          // Resume the parser now we have a handler.\n          _subscription.resume();\n          return s;\n        }, onError: (e) {\n          destroy();\n        });\n    return request;\n  }\n\n  Future<Socket> detachSocket() {\n    return _streamFuture.then(\n        (_) => new _DetachedSocket(_socket, _httpParser.detachIncoming()));\n  }\n\n  void destroy() {\n    closed = true;\n    _httpClient._connectionClosed(this);\n    _socket.destroy();\n  }\n\n  void close() {\n    closed = true;\n    _httpClient._connectionClosed(this);\n    _streamFuture\n          // TODO(ajohnsen): Add timeout.\n        .then((_) => _socket.destroy());\n  }\n\n  Future<_HttpClientConnection> createProxyTunnel(host, port, proxy, callback) {\n    _HttpClientRequest request =\n        send(new Uri(host: host, port: port),\n             port,\n             \"CONNECT\",\n             proxy);\n    if (proxy.isAuthenticated) {\n      // If the proxy configuration contains user information use that\n      // for proxy basic authorization.\n      String auth = _CryptoUtils.bytesToBase64(\n          UTF8.encode(\"${proxy.username}:${proxy.password}\"));\n      request.headers.set(HttpHeaders.PROXY_AUTHORIZATION, \"Basic $auth\");\n    }\n    return request.close()\n        .then((response) {\n          if (response.statusCode != HttpStatus.OK) {\n            throw \"Proxy failed to establish tunnel \"\n                  \"(${response.statusCode} ${response.reasonPhrase})\";\n          }\n          var socket = response._httpRequest._httpClientConnection._socket;\n          return SecureSocket.secure(\n              socket, host: host, onBadCertificate: callback);\n        })\n        .then((secureSocket) {\n          String key = _HttpClientConnection.makeKey(true, host, port);\n          return new _HttpClientConnection(\n              key, secureSocket, request._httpClient, true);\n        });\n  }\n\n  HttpConnectionInfo get connectionInfo => _HttpConnectionInfo.create(_socket);\n\n  static makeKey(bool isSecure, String host, int port) {\n    return isSecure ? \"ssh:$host:$port\" : \"$host:$port\";\n  }\n\n  void stopTimer() {\n    if (_idleTimer != null) {\n      _idleTimer.cancel();\n      _idleTimer = null;\n    }\n  }\n\n  void startTimer() {\n    assert(_idleTimer == null);\n    _idleTimer = new Timer(\n        _httpClient.idleTimeout,\n        () {\n          _idleTimer = null;\n          close();\n        });\n  }\n}\n\nclass _ConnectionInfo {\n  final _HttpClientConnection connection;\n  final _Proxy proxy;\n\n  _ConnectionInfo(this.connection, this.proxy);\n}\n\n\nclass _ConnectionTarget {\n  // Unique key for this connection target.\n  final String key;\n  final String host;\n  final int port;\n  final bool isSecure;\n  final Set<_HttpClientConnection> _idle = new HashSet();\n  final Set<_HttpClientConnection> _active = new HashSet();\n  final Queue _pending = new ListQueue();\n  int _connecting = 0;\n\n  _ConnectionTarget(this.key, this.host, this.port, this.isSecure);\n\n  bool get isEmpty => _idle.isEmpty && _active.isEmpty && _connecting == 0;\n\n  bool get hasIdle => _idle.isNotEmpty;\n\n  bool get hasActive => _active.isNotEmpty || _connecting > 0;\n\n  _HttpClientConnection takeIdle() {\n    assert(hasIdle);\n    _HttpClientConnection connection = _idle.first;\n    _idle.remove(connection);\n    connection.stopTimer();\n    _active.add(connection);\n    return connection;\n  }\n\n  _checkPending() {\n    if (_pending.isNotEmpty) {\n      _pending.removeFirst()();\n    }\n  }\n\n  void addNewActive(_HttpClientConnection connection) {\n    _active.add(connection);\n  }\n\n  void returnConnection(_HttpClientConnection connection) {\n    assert(_active.contains(connection));\n    _active.remove(connection);\n    _idle.add(connection);\n    connection.startTimer();\n    _checkPending();\n  }\n\n  void connectionClosed(_HttpClientConnection connection) {\n    assert(!_active.contains(connection) || !_idle.contains(connection));\n    _active.remove(connection);\n    _idle.remove(connection);\n    _checkPending();\n  }\n\n  void close(bool force) {\n    for (var c in _idle.toList()) {\n      c.close();\n    }\n    if (force) {\n      for (var c in _active.toList()) {\n        c.destroy();\n      }\n    }\n  }\n\n  Future<_ConnectionInfo> connect(String uriHost,\n                                   int uriPort,\n                                   _Proxy proxy,\n                                   _HttpClient client) {\n    if (hasIdle) {\n      var connection = takeIdle();\n      client._updateTimers();\n      return new Future.value(new _ConnectionInfo(connection, proxy));\n    }\n    if (client.maxConnectionsPerHost != null &&\n        _active.length + _connecting >= client.maxConnectionsPerHost) {\n      var completer = new Completer();\n      _pending.add(() {\n        connect(uriHost, uriPort, proxy, client)\n            .then(completer.complete, onError: completer.completeError);\n      });\n      return completer.future;\n    }\n    var currentBadCertificateCallback = client._badCertificateCallback;\n    bool callback(X509Certificate certificate) =>\n        currentBadCertificateCallback == null ? false :\n        currentBadCertificateCallback(certificate, uriHost, uriPort);\n    Future socketFuture = (isSecure && proxy.isDirect\n        ? SecureSocket.connect(host,\n                               port,\n                               sendClientCertificate: true,\n                               onBadCertificate: callback)\n        : Socket.connect(host, port));\n    _connecting++;\n    return socketFuture.then((socket) {\n        _connecting--;\n        socket.setOption(SocketOption.TCP_NODELAY, true);\n        var connection = new _HttpClientConnection(key, socket, client);\n        if (isSecure && !proxy.isDirect) {\n          connection._dispose = true;\n          return connection.createProxyTunnel(uriHost, uriPort, proxy, callback)\n              .then((tunnel) {\n                client._getConnectionTarget(uriHost, uriPort, true)\n                    .addNewActive(tunnel);\n                return new _ConnectionInfo(tunnel, proxy);\n              });\n        } else {\n          addNewActive(connection);\n          return new _ConnectionInfo(connection, proxy);\n        }\n      }, onError: (error) {\n        _connecting--;\n        _checkPending();\n        throw error;\n      });\n  }\n}\n\n\nclass _HttpClient implements HttpClient {\n  bool _closing = false;\n  final Map<String, _ConnectionTarget> _connectionTargets\n      = new HashMap<String, _ConnectionTarget>();\n  final List<_Credentials> _credentials = [];\n  final List<_ProxyCredentials> _proxyCredentials = [];\n  Function _authenticate;\n  Function _authenticateProxy;\n  Function _findProxy = HttpClient.findProxyFromEnvironment;\n  Duration _idleTimeout = const Duration(seconds: 15);\n  Function _badCertificateCallback;\n\n  Timer _noActiveTimer;\n\n  Duration get idleTimeout => _idleTimeout;\n\n  int maxConnectionsPerHost;\n\n  bool autoUncompress = true;\n\n  String userAgent = _getHttpVersion();\n\n  void set idleTimeout(Duration timeout) {\n    _idleTimeout = timeout;\n    for (var c in _connectionTargets.values) {\n      for (var idle in c.idle) {\n        // Reset timer. This is fine, as it's not happening often.\n        idle.stopTimer();\n        idle.startTimer();\n      }\n    }\n  }\n\n  set badCertificateCallback(bool callback(X509Certificate cert,\n                                           String host,\n                                           int port)) {\n    _badCertificateCallback = callback;\n  }\n\n\n  Future<HttpClientRequest> open(String method,\n                                 String host,\n                                 int port,\n                                 String path) {\n    Uri uri = new Uri(scheme: \"http\", host: host, port: port).resolve(path);\n    // TODO(sgjesse): The path set here can contain both query and\n    // fragment. They should be cracked and set correctly.\n    return _openUrl(method, uri);\n  }\n\n  Future<HttpClientRequest> openUrl(String method, Uri url) {\n    return _openUrl(method, url);\n  }\n\n  Future<HttpClientRequest> get(String host, int port, String path)\n      => open(\"get\", host, port, path);\n\n  Future<HttpClientRequest> getUrl(Uri url) => _openUrl(\"get\", url);\n\n  Future<HttpClientRequest> post(String host, int port, String path)\n      => open(\"post\", host, port, path);\n\n  Future<HttpClientRequest> postUrl(Uri url) => _openUrl(\"post\", url);\n\n  Future<HttpClientRequest> put(String host, int port, String path)\n      => open(\"put\", host, port, path);\n\n  Future<HttpClientRequest> putUrl(Uri url) => _openUrl(\"put\", url);\n\n  Future<HttpClientRequest> delete(String host, int port, String path)\n      => open(\"delete\", host, port, path);\n\n  Future<HttpClientRequest> deleteUrl(Uri url) => _openUrl(\"delete\", url);\n\n  Future<HttpClientRequest> head(String host, int port, String path)\n      => open(\"head\", host, port, path);\n\n  Future<HttpClientRequest> headUrl(Uri url) => _openUrl(\"head\", url);\n\n  Future<HttpClientRequest> patch(String host, int port, String path)\n      => open(\"patch\", host, port, path);\n\n  Future<HttpClientRequest> patchUrl(Uri url) => _openUrl(\"patch\", url);\n\n  void close({bool force: false}) {\n    _closing = true;\n    _connectionTargets.values.toList().forEach((c) => c.close(force));\n    assert(!_connectionTargets.values.any((s) => s.hasIdle));\n    assert(!force ||\n        !_connectionTargets.values.any((s) => s._active.isNotEmpty));\n  }\n\n  set authenticate(Future<bool> f(Uri url, String scheme, String realm)) {\n    _authenticate = f;\n  }\n\n  void addCredentials(Uri url, String realm, HttpClientCredentials cr) =>\n      _credentials.add(new _SiteCredentials(url, realm, cr));\n\n  set authenticateProxy(\n      Future<bool> f(String host, int port, String scheme, String realm)) {\n    _authenticateProxy = f;\n  }\n\n  void addProxyCredentials(String host,\n                           int port,\n                           String realm,\n                           HttpClientCredentials cr) =>\n      _proxyCredentials.add(new _ProxyCredentials(host, port, realm, cr));\n\n  set findProxy(String f(Uri uri)) => _findProxy = f;\n\n  Future<HttpClientRequest> _openUrl(String method, Uri uri) {\n    if (method == null) {\n      throw new ArgumentError(method);\n    }\n    if (method != \"CONNECT\") {\n      if (uri.host.isEmpty) {\n        throw new ArgumentError(\"No host specified in URI $uri\");\n      } else if (uri.scheme != \"http\" && uri.scheme != \"https\") {\n        throw new ArgumentError(\n            \"Unsupported scheme '${uri.scheme}' in URI $uri\");\n      }\n    }\n\n    bool isSecure = (uri.scheme == \"https\");\n    int port = uri.port;\n    if (port == 0) {\n      port = isSecure ?\n          HttpClient.DEFAULT_HTTPS_PORT :\n          HttpClient.DEFAULT_HTTP_PORT;\n    }\n    // Check to see if a proxy server should be used for this connection.\n    var proxyConf = const _ProxyConfiguration.direct();\n    if (_findProxy != null) {\n      // TODO(sgjesse): Keep a map of these as normally only a few\n      // configuration strings will be used.\n      try {\n        proxyConf = new _ProxyConfiguration(_findProxy(uri));\n      } catch (error, stackTrace) {\n        return new Future.error(error, stackTrace);\n      }\n    }\n    return _getConnection(uri.host, port, proxyConf, isSecure)\n        .then((info) {\n          send(info) {\n            return info.connection.send(uri,\n                                        port,\n                                        method.toUpperCase(),\n                                        info.proxy);\n          }\n          // If the connection was closed before the request was sent, create\n          // and use another connection.\n          if (info.connection.closed) {\n            return _getConnection(uri.host, port, proxyConf, isSecure)\n                .then(send);\n          }\n          return send(info);\n        });\n  }\n\n  Future<HttpClientRequest> _openUrlFromRequest(String method,\n                                                Uri uri,\n                                                _HttpClientRequest previous) {\n    // If the new URI is relative (to either '/' or some sub-path),\n    // construct a full URI from the previous one.\n    Uri resolved = previous.uri.resolveUri(uri);\n    return openUrl(method, resolved).then((_HttpClientRequest request) {\n\n          request\n              // Only follow redirects if initial request did.\n              ..followRedirects = previous.followRedirects\n              // Allow same number of redirects.\n              ..maxRedirects = previous.maxRedirects;\n          // Copy headers.\n          for (var header in previous.headers._headers.keys) {\n            if (request.headers[header] == null) {\n              request.headers.set(header, previous.headers[header]);\n            }\n          }\n          return request\n              ..headers.chunkedTransferEncoding = false\n              ..contentLength = 0;\n        });\n  }\n\n  // Return a live connection to the idle pool.\n  void _returnConnection(_HttpClientConnection connection) {\n    _connectionTargets[connection.key].returnConnection(connection);\n    _updateTimers();\n  }\n\n  // Remove a closed connnection from the active set.\n  void _connectionClosed(_HttpClientConnection connection) {\n    connection.stopTimer();\n    var connectionTarget = _connectionTargets[connection.key];\n    if (connectionTarget != null) {\n      connectionTarget.connectionClosed(connection);\n      if (connectionTarget.isEmpty) {\n        _connectionTargets.remove(connection.key);\n      }\n      _updateTimers();\n    }\n  }\n\n  void _updateTimers() {\n    bool hasActive = _connectionTargets.values.any((t) => t.hasActive);\n    if (!hasActive) {\n      bool hasIdle = _connectionTargets.values.any((t) => t.hasIdle);\n      if (hasIdle && _noActiveTimer == null) {\n        _noActiveTimer = new Timer(const Duration(milliseconds: 100), () {\n          _noActiveTimer = null;\n          bool hasActive =\n              _connectionTargets.values.any((t) => t.hasActive);\n          if (!hasActive) {\n            close();\n            _closing = false;\n          }\n        });\n      }\n    } else if (_noActiveTimer != null) {\n      _noActiveTimer.cancel();\n      _noActiveTimer = null;\n    }\n  }\n\n  _ConnectionTarget _getConnectionTarget(String host, int port, bool isSecure) {\n    String key = _HttpClientConnection.makeKey(isSecure, host, port);\n    return _connectionTargets.putIfAbsent(\n        key, () => new _ConnectionTarget(key, host, port, isSecure));\n  }\n\n  // Get a new _HttpClientConnection, from the matching _ConnectionTarget.\n  Future<_ConnectionInfo> _getConnection(String uriHost,\n                                          int uriPort,\n                                          _ProxyConfiguration proxyConf,\n                                          bool isSecure) {\n    Iterator<_Proxy> proxies = proxyConf.proxies.iterator;\n\n    Future<_ConnectionInfo> connect(error) {\n      if (!proxies.moveNext()) return new Future.error(error);\n      _Proxy proxy = proxies.current;\n      String host = proxy.isDirect ? uriHost: proxy.host;\n      int port = proxy.isDirect ? uriPort: proxy.port;\n      return _getConnectionTarget(host, port, isSecure)\n          .connect(uriHost, uriPort, proxy, this)\n          // On error, continue with next proxy.\n          .catchError(connect);\n    }\n    return connect(new HttpException(\"No proxies given\"));\n  }\n\n  _SiteCredentials _findCredentials(Uri url, [_AuthenticationScheme scheme]) {\n    // Look for credentials.\n    _SiteCredentials cr =\n        _credentials.fold(null, (prev, value) {\n          if (value.applies(url, scheme)) {\n            if (prev == null) return value;\n            return value.uri.path.length > prev.uri.path.length ? value : prev;\n          } else {\n            return prev;\n          }\n        });\n    return cr;\n  }\n\n  _ProxyCredentials _findProxyCredentials(_Proxy proxy,\n                                          [_AuthenticationScheme scheme]) {\n    // Look for credentials.\n    var it = _proxyCredentials.iterator;\n    while (it.moveNext()) {\n      if (it.current.applies(proxy, scheme)) {\n        return it.current;\n      }\n    }\n  }\n\n  void _removeCredentials(_Credentials cr) {\n    int index = _credentials.indexOf(cr);\n    if (index != -1) {\n      _credentials.removeAt(index);\n    }\n  }\n\n  void _removeProxyCredentials(_Credentials cr) {\n    int index = _proxyCredentials.indexOf(cr);\n    if (index != -1) {\n      _proxyCredentials.removeAt(index);\n    }\n  }\n\n  static String _findProxyFromEnvironment(Uri url,\n                                          Map<String, String> environment) {\n    checkNoProxy(String option) {\n      if (option == null) return null;\n      Iterator<String> names = option.split(\",\").map((s) => s.trim()).iterator;\n      while (names.moveNext()) {\n        var name = names.current;\n        if ((name.startsWith(\"[\") &&\n             name.endsWith(\"]\") &&\n             \"[${url.host}]\" == name) ||\n            (name.isNotEmpty &&\n             url.host.endsWith(name))) {\n          return \"DIRECT\";\n        }\n      }\n      return null;\n    }\n\n    checkProxy(String option) {\n      if (option == null) return null;\n      option = option.trim();\n      if (option.isEmpty) return null;\n      int pos = option.indexOf(\"://\");\n      if (pos >= 0) {\n        option = option.substring(pos + 3);\n      }\n      pos = option.indexOf(\"/\");\n      if (pos >= 0) {\n        option = option.substring(0, pos);\n      }\n      // Add default port if no port configured.\n      if (option.indexOf(\"[\") == 0) {\n        var pos = option.lastIndexOf(\":\");\n        if (option.indexOf(\"]\") > pos) option = \"$option:1080\";\n      } else {\n        if (option.indexOf(\":\") == -1) option = \"$option:1080\";\n      }\n      return \"PROXY $option\";\n    }\n\n    // Default to using the process current environment.\n    if (environment == null) environment = _platformEnvironmentCache;\n\n    String proxyCfg;\n\n    String noProxy = environment[\"no_proxy\"];\n    if (noProxy == null) noProxy = environment[\"NO_PROXY\"];\n    if ((proxyCfg = checkNoProxy(noProxy)) != null) {\n      return proxyCfg;\n    }\n\n    if (url.scheme == \"http\") {\n      String proxy = environment[\"http_proxy\"];\n      if (proxy == null) proxy = environment[\"HTTP_PROXY\"];\n      if ((proxyCfg = checkProxy(proxy)) != null) {\n        return proxyCfg;\n      }\n    } else if (url.scheme == \"https\") {\n      String proxy = environment[\"https_proxy\"];\n      if (proxy == null) proxy = environment[\"HTTPS_PROXY\"];\n      if ((proxyCfg = checkProxy(proxy)) != null) {\n        return proxyCfg;\n      }\n    }\n    return \"DIRECT\";\n  }\n\n  static Map<String, String> _platformEnvironmentCache = Platform.environment;\n}\n\n\nclass _HttpConnection\n    extends LinkedListEntry<_HttpConnection> with _ServiceObject {\n  static const _ACTIVE = 0;\n  static const _IDLE = 1;\n  static const _CLOSING = 2;\n  static const _DETACHED = 3;\n\n  // Use HashMap, as we don't need to keep order.\n  static Map<int, _HttpConnection> _connections =\n      new HashMap<int, _HttpConnection>();\n\n  final _socket;\n  final _HttpServer _httpServer;\n  final _HttpParser _httpParser;\n  int _state = _IDLE;\n  StreamSubscription _subscription;\n  Timer _idleTimer;\n  bool _idleMark = false;\n  Future _streamFuture;\n\n  _HttpConnection(this._socket, this._httpServer)\n      : _httpParser = new _HttpParser.requestParser() {\n    try { _socket._owner = this; } catch (_) { print(_); }\n    _connections[_serviceId] = this;\n    _httpParser.listenToStream(_socket);\n    _subscription = _httpParser.listen(\n        (incoming) {\n          _httpServer._markActive(this);\n          // If the incoming was closed, close the connection.\n          incoming.dataDone.then((closing) {\n            if (closing) destroy();\n          });\n          // Only handle one incoming request at the time. Keep the\n          // stream paused until the request has been send.\n          _subscription.pause();\n          _state = _ACTIVE;\n          var outgoing = new _HttpOutgoing(_socket);\n          var response = new _HttpResponse(incoming.uri,\n                                           incoming.headers.protocolVersion,\n                                           outgoing,\n                                           _httpServer.defaultResponseHeaders,\n                                           _httpServer.serverHeader);\n          var request = new _HttpRequest(response, incoming, _httpServer, this);\n          _streamFuture = outgoing.done\n              .then((_) {\n                response.deadline = null;\n                if (_state == _DETACHED) return;\n                if (response.persistentConnection &&\n                    request.persistentConnection &&\n                    incoming.fullBodyRead &&\n                    !_httpParser.upgrade &&\n                    !_httpServer.closed) {\n                  _state = _IDLE;\n                  _idleMark = false;\n                  _httpServer._markIdle(this);\n                  // Resume the subscription for incoming requests as the\n                  // request is now processed.\n                  _subscription.resume();\n                } else {\n                  // Close socket, keep-alive not used or body sent before\n                  // received data was handled.\n                  destroy();\n                }\n              }, onError: (_) {\n                destroy();\n              });\n          outgoing.ignoreBody = request.method == \"HEAD\";\n          response._httpRequest = request;\n          _httpServer._handleRequest(request);\n        },\n        onDone: () {\n          destroy();\n        },\n        onError: (error) {\n          // Ignore failed requests that was closed before headers was received.\n          destroy();\n        });\n  }\n\n  void markIdle() {\n    _idleMark = true;\n  }\n\n  bool get isMarkedIdle => _idleMark;\n\n  void destroy() {\n    if (_state == _CLOSING || _state == _DETACHED) return;\n    _state = _CLOSING;\n    _socket.destroy();\n    _httpServer._connectionClosed(this);\n    _connections.remove(_serviceId);\n  }\n\n  Future<Socket> detachSocket() {\n    _state = _DETACHED;\n    // Remove connection from server.\n    _httpServer._connectionClosed(this);\n\n    _HttpDetachedIncoming detachedIncoming = _httpParser.detachIncoming();\n\n    return _streamFuture.then((_) {\n      _connections.remove(_serviceId);\n      return new _DetachedSocket(_socket, detachedIncoming);\n    });\n  }\n\n  HttpConnectionInfo get connectionInfo => _HttpConnectionInfo.create(_socket);\n\n  bool get _isActive => _state == _ACTIVE;\n  bool get _isIdle => _state == _IDLE;\n  bool get _isClosing => _state == _CLOSING;\n  bool get _isDetached => _state == _DETACHED;\n\n  String get _serviceTypePath => 'io/http/serverconnections';\n  String get _serviceTypeName => 'HttpServerConnection';\n\n  Map _toJSON(bool ref) {\n    var name = \"${_socket.address.host}:${_socket.port} <-> \"\n        \"${_socket.remoteAddress.host}:${_socket.remotePort}\";\n    var r = {\n      'id': _servicePath,\n      'type': _serviceType(ref),\n      'name': name,\n      'user_name': name,\n    };\n    if (ref) {\n      return r;\n    }\n    r['server'] = _httpServer._toJSON(true);\n    try {\n      r['socket'] = _socket._toJSON(true);\n    } catch (_) {\n      r['socket'] = {\n        'id': _servicePath,\n        'type': '@Socket',\n        'name': 'UserSocket',\n        'user_name': 'UserSocket',\n      };\n    }\n    switch (_state) {\n      case _ACTIVE: r['state'] = \"Active\"; break;\n      case _IDLE: r['state'] = \"Idle\"; break;\n      case _CLOSING: r['state'] = \"Closing\"; break;\n      case _DETACHED: r['state'] = \"Detached\"; break;\n      default: r['state'] = 'Unknown'; break;\n    }\n    return r;\n  }\n}\n\n\n// HTTP server waiting for socket connections.\nclass _HttpServer\n    extends Stream<HttpRequest> with _ServiceObject\n    implements HttpServer {\n  // Use default Map so we keep order.\n  static Map<int, _HttpServer> _servers = new Map<int, _HttpServer>();\n\n  String serverHeader;\n  final HttpHeaders defaultResponseHeaders = _initDefaultResponseHeaders();\n\n  Duration _idleTimeout;\n  Timer _idleTimer;\n\n  static Future<HttpServer> bind(address, int port, int backlog) {\n    return ServerSocket.bind(address, port, backlog: backlog).then((socket) {\n      return new _HttpServer._(socket, true);\n    });\n  }\n\n  static Future<HttpServer> bindSecure(address,\n                                       int port,\n                                       int backlog,\n                                       String certificate_name,\n                                       bool requestClientCertificate) {\n    return SecureServerSocket.bind(\n        address,\n        port,\n        certificate_name,\n        backlog: backlog,\n        requestClientCertificate: requestClientCertificate)\n        .then((socket) {\n          return new _HttpServer._(socket, true);\n        });\n  }\n\n  _HttpServer._(this._serverSocket, this._closeServer) {\n    _controller = new StreamController<HttpRequest>(sync: true,\n                                                    onCancel: close);\n    idleTimeout = const Duration(seconds: 120);\n    _servers[_serviceId] = this;\n    _serverSocket._owner = this;\n  }\n\n  _HttpServer.listenOn(this._serverSocket) : _closeServer = false {\n    _controller = new StreamController<HttpRequest>(sync: true,\n                                                    onCancel: close);\n    idleTimeout = const Duration(seconds: 120);\n    _servers[_serviceId] = this;\n    try { _serverSocket._owner = this; } catch (_) {}\n  }\n\n  static HttpHeaders _initDefaultResponseHeaders() {\n    var defaultResponseHeaders = new _HttpHeaders('1.1');\n    defaultResponseHeaders.contentType = ContentType.TEXT;\n    defaultResponseHeaders.set('X-Frame-Options', 'SAMEORIGIN');\n    defaultResponseHeaders.set('X-Content-Type-Options', 'nosniff');\n    defaultResponseHeaders.set('X-XSS-Protection', '1; mode=block');\n    return defaultResponseHeaders;\n  }\n\n  Duration get idleTimeout => _idleTimeout;\n\n  void set idleTimeout(Duration duration) {\n    if (_idleTimer != null) {\n      _idleTimer.cancel();\n      _idleTimer = null;\n    }\n    _idleTimeout = duration;\n    if (_idleTimeout != null) {\n      _idleTimer = new Timer.periodic(_idleTimeout, (_) {\n        for (var idle in _idleConnections.toList()) {\n          if (idle.isMarkedIdle) {\n            idle.destroy();\n          } else {\n            idle.markIdle();\n          }\n        }\n      });\n    }\n  }\n\n  StreamSubscription<HttpRequest> listen(void onData(HttpRequest event),\n                                         {Function onError,\n                                         void onDone(),\n                                         bool cancelOnError}) {\n    _serverSocket.listen(\n        (Socket socket) {\n          socket.setOption(SocketOption.TCP_NODELAY, true);\n          // Accept the client connection.\n          _HttpConnection connection = new _HttpConnection(socket, this);\n          _idleConnections.add(connection);\n        },\n        onError: (error) {\n          // Ignore HandshakeExceptions as they are bound to a single request,\n          // and are not fatal for the server.\n          if (error is! HandshakeException) {\n            _controller.addError(error);\n          }\n        },\n        onDone: _controller.close);\n    return _controller.stream.listen(onData,\n                                     onError: onError,\n                                     onDone: onDone,\n                                     cancelOnError: cancelOnError);\n  }\n\n  Future close({bool force: false}) {\n    closed = true;\n    Future result;\n    if (_serverSocket != null && _closeServer) {\n      result = _serverSocket.close();\n    } else {\n      result = new Future.value();\n    }\n    idleTimeout = null;\n    if (force) {\n      for (var c in _activeConnections.toList()) {\n        c.destroy();\n      }\n      assert(_activeConnections.isEmpty);\n    }\n    for (var c in _idleConnections.toList()) {\n      c.destroy();\n    }\n    _maybePerformCleanup();\n    return result;\n  }\n\n  void _maybePerformCleanup() {\n    if (closed &&\n        _idleConnections.isEmpty &&\n        _activeConnections.isEmpty &&\n        _sessionManagerInstance != null) {\n      _sessionManagerInstance.close();\n      _sessionManagerInstance = null;\n      _servers.remove(_serviceId);\n    }\n  }\n\n  int get port {\n    if (closed) throw new HttpException(\"HttpServer is not bound to a socket\");\n    return _serverSocket.port;\n  }\n\n  InternetAddress get address {\n    if (closed) throw new HttpException(\"HttpServer is not bound to a socket\");\n    return _serverSocket.address;\n  }\n\n  set sessionTimeout(int timeout) {\n    _sessionManager.sessionTimeout = timeout;\n  }\n\n  void _handleRequest(_HttpRequest request) {\n    // Delay the request until the isolate's message-queue is handled.\n    // This greatly improves scheduling when a lot of requests are active.\n    Timer.run(() {\n      if (!closed) {\n        _controller.add(request);\n      } else {\n        request._httpConnection.destroy();\n      }\n    });\n  }\n\n  void _handleError(error) {\n    if (!closed) _controller.addError(error);\n  }\n\n  void _connectionClosed(_HttpConnection connection) {\n    // Remove itself from either idle or active connections.\n    connection.unlink();\n    _maybePerformCleanup();\n  }\n\n  void _markIdle(_HttpConnection connection) {\n    _activeConnections.remove(connection);\n    _idleConnections.add(connection);\n  }\n\n  void _markActive(_HttpConnection connection) {\n    _idleConnections.remove(connection);\n    _activeConnections.add(connection);\n  }\n\n  _HttpSessionManager get _sessionManager {\n    // Lazy init.\n    if (_sessionManagerInstance == null) {\n      _sessionManagerInstance = new _HttpSessionManager();\n    }\n    return _sessionManagerInstance;\n  }\n\n  HttpConnectionsInfo connectionsInfo() {\n    HttpConnectionsInfo result = new HttpConnectionsInfo();\n    result.total = _activeConnections.length + _idleConnections.length;\n    _activeConnections.forEach((_HttpConnection conn) {\n      if (conn._isActive) {\n        result.active++;\n      } else {\n        assert(conn._isClosing);\n        result.closing++;\n      }\n    });\n    _idleConnections.forEach((_HttpConnection conn) {\n      result.idle++;\n      assert(conn._isIdle);\n    });\n    return result;\n  }\n\n  String get _serviceTypePath => 'io/http/servers';\n  String get _serviceTypeName => 'HttpServer';\n\n  Map _toJSON(bool ref) {\n    var r = {\n      'id': _servicePath,\n      'type': _serviceType(ref),\n      'name': '${address.host}:$port',\n      'user_name': '${address.host}:$port',\n    };\n    if (ref) {\n      return r;\n    }\n    try {\n      r['socket'] = _serverSocket._toJSON(true);\n    } catch (_) {\n      r['socket'] = {\n        'id': _servicePath,\n        'type': '@Socket',\n        'name': 'UserSocket',\n        'user_name': 'UserSocket',\n      };\n    }\n    r['port'] = port;\n    r['address'] = address.host;\n    r['active'] = _activeConnections.map((c) => c._toJSON(true)).toList();\n    r['idle'] = _idleConnections.map((c) => c._toJSON(true)).toList();\n    r['closed'] = closed;\n    return r;\n  }\n\n  _HttpSessionManager _sessionManagerInstance;\n\n  // Indicated if the http server has been closed.\n  bool closed = false;\n\n  // The server listen socket. Untyped as it can be both ServerSocket and\n  // SecureServerSocket.\n  final _serverSocket;\n  final bool _closeServer;\n\n  // Set of currently connected clients.\n  final LinkedList<_HttpConnection> _activeConnections\n      = new LinkedList<_HttpConnection>();\n  final LinkedList<_HttpConnection> _idleConnections\n      = new LinkedList<_HttpConnection>();\n  StreamController<HttpRequest> _controller;\n}\n\n\nclass _ProxyConfiguration {\n  static const String PROXY_PREFIX = \"PROXY \";\n  static const String DIRECT_PREFIX = \"DIRECT\";\n\n  _ProxyConfiguration(String configuration) : proxies = new List<_Proxy>() {\n    if (configuration == null) {\n      throw new HttpException(\"Invalid proxy configuration $configuration\");\n    }\n    List<String> list = configuration.split(\";\");\n    list.forEach((String proxy) {\n      proxy = proxy.trim();\n      if (!proxy.isEmpty) {\n        if (proxy.startsWith(PROXY_PREFIX)) {\n          String username;\n          String password;\n          // Skip the \"PROXY \" prefix.\n          proxy = proxy.substring(PROXY_PREFIX.length).trim();\n          // Look for proxy authentication.\n          int at = proxy.indexOf(\"@\");\n          if (at != -1) {\n            String userinfo = proxy.substring(0, at).trim();\n            proxy = proxy.substring(at + 1).trim();\n            int colon = userinfo.indexOf(\":\");\n            if (colon == -1 || colon == 0 || colon == proxy.length - 1) {\n              throw new HttpException(\n                  \"Invalid proxy configuration $configuration\");\n            }\n            username = userinfo.substring(0, colon).trim();\n            password = userinfo.substring(colon + 1).trim();\n          }\n          // Look for proxy host and port.\n          int colon = proxy.lastIndexOf(\":\");\n          if (colon == -1 || colon == 0 || colon == proxy.length - 1) {\n            throw new HttpException(\n                \"Invalid proxy configuration $configuration\");\n          }\n          String host = proxy.substring(0, colon).trim();\n          if (host.startsWith(\"[\") && host.endsWith(\"]\")) {\n            host = host.substring(1, host.length - 1);\n          }\n          String portString = proxy.substring(colon + 1).trim();\n          int port;\n          try {\n            port = int.parse(portString);\n          } on FormatException catch (e) {\n            throw new HttpException(\n                \"Invalid proxy configuration $configuration, \"\n                \"invalid port '$portString'\");\n          }\n          proxies.add(new _Proxy(host, port, username, password));\n        } else if (proxy.trim() == DIRECT_PREFIX) {\n          proxies.add(new _Proxy.direct());\n        } else {\n          throw new HttpException(\"Invalid proxy configuration $configuration\");\n        }\n      }\n    });\n  }\n\n  const _ProxyConfiguration.direct()\n      : proxies = const [const _Proxy.direct()];\n\n  final List<_Proxy> proxies;\n}\n\n\nclass _Proxy {\n  final String host;\n  final int port;\n  final String username;\n  final String password;\n  final bool isDirect;\n\n  const _Proxy(this.host, this.port, this.username, this.password)\n      : isDirect = false;\n  const _Proxy.direct() : host = null, port = null,\n                          username = null, password = null, isDirect = true;\n\n  bool get isAuthenticated => username != null;\n}\n\n\nclass _HttpConnectionInfo implements HttpConnectionInfo {\n  InternetAddress remoteAddress;\n  int remotePort;\n  int localPort;\n\n  static _HttpConnectionInfo create(Socket socket) {\n    if (socket == null) return null;\n    try {\n      _HttpConnectionInfo info = new _HttpConnectionInfo();\n      return info\n          ..remoteAddress = socket.remoteAddress\n          ..remotePort = socket.remotePort\n          ..localPort = socket.port;\n    } catch (e) { }\n    return null;\n  }\n}\n\n\nclass _DetachedSocket extends Stream<List<int>> implements Socket {\n  final Stream<List<int>> _incoming;\n  final _socket;\n\n  _DetachedSocket(this._socket, this._incoming);\n\n  StreamSubscription<List<int>> listen(void onData(List<int> event),\n                                       {Function onError,\n                                        void onDone(),\n                                        bool cancelOnError}) {\n    return _incoming.listen(onData,\n                            onError: onError,\n                            onDone: onDone,\n                            cancelOnError: cancelOnError);\n  }\n\n  Encoding get encoding => _socket.encoding;\n\n  void set encoding(Encoding value) {\n    _socket.encoding = value;\n  }\n\n  void write(Object obj) => _socket.write(obj);\n\n  void writeln([Object obj = \"\"]) => _socket.writeln(obj);\n\n  void writeCharCode(int charCode) => _socket.writeCharCode(charCode);\n\n  void writeAll(Iterable objects, [String separator = \"\"]) {\n    _socket.writeAll(objects, separator);\n  }\n\n  void add(List<int> bytes) => _socket.add(bytes);\n\n  void addError(error, [StackTrace stackTrace]) =>\n      _socket.addError(error, stackTrace);\n\n  Future<Socket> addStream(Stream<List<int>> stream) {\n    return _socket.addStream(stream);\n  }\n\n  void destroy() => _socket.destroy();\n\n  Future flush() => _socket.flush();\n\n  Future close() => _socket.close();\n\n  Future<Socket> get done => _socket.done;\n\n  int get port => _socket.port;\n\n  InternetAddress get address => _socket.address;\n\n  InternetAddress get remoteAddress => _socket.remoteAddress;\n\n  int get remotePort => _socket.remotePort;\n\n  bool setOption(SocketOption option, bool enabled) {\n    return _socket.setOption(option, enabled);\n  }\n\n  Map _toJSON(bool ref) => _socket._toJSON(ref);\n  void set _owner(owner) { _socket._owner = owner; }\n}\n\n\nclass _AuthenticationScheme {\n  final int _scheme;\n\n  static const UNKNOWN = const _AuthenticationScheme(-1);\n  static const BASIC = const _AuthenticationScheme(0);\n  static const DIGEST = const _AuthenticationScheme(1);\n\n  const _AuthenticationScheme(this._scheme);\n\n  factory _AuthenticationScheme.fromString(String scheme) {\n    if (scheme.toLowerCase() == \"basic\") return BASIC;\n    if (scheme.toLowerCase() == \"digest\") return DIGEST;\n    return UNKNOWN;\n  }\n\n  String toString() {\n    if (this == BASIC) return \"Basic\";\n    if (this == DIGEST) return \"Digest\";\n    return \"Unknown\";\n  }\n}\n\n\nabstract class _Credentials {\n  _HttpClientCredentials credentials;\n  String realm;\n  bool used = false;\n\n  // Digest specific fields.\n  String ha1;\n  String nonce;\n  String algorithm;\n  String qop;\n  int nonceCount;\n\n  _Credentials(this.credentials, this.realm) {\n    if (credentials.scheme == _AuthenticationScheme.DIGEST) {\n      // Calculate the H(A1) value once. There is no mentioning of\n      // username/password encoding in RFC 2617. However there is an\n      // open draft for adding an additional accept-charset parameter to\n      // the WWW-Authenticate and Proxy-Authenticate headers, see\n      // http://tools.ietf.org/html/draft-reschke-basicauth-enc-06. For\n      // now always use UTF-8 encoding.\n      _HttpClientDigestCredentials creds = credentials;\n      var hasher = new _MD5()\n          ..add(UTF8.encode(creds.username))\n          ..add([_CharCode.COLON])\n          ..add(realm.codeUnits)\n          ..add([_CharCode.COLON])\n          ..add(UTF8.encode(creds.password));\n      ha1 = _CryptoUtils.bytesToHex(hasher.close());\n    }\n  }\n\n  _AuthenticationScheme get scheme => credentials.scheme;\n\n  void authorize(HttpClientRequest request);\n}\n\nclass _SiteCredentials extends _Credentials {\n  Uri uri;\n\n  _SiteCredentials(this.uri, realm, _HttpClientCredentials creds)\n      : super(creds, realm);\n\n  bool applies(Uri uri, _AuthenticationScheme scheme) {\n    if (scheme != null && credentials.scheme != scheme) return false;\n    if (uri.host != this.uri.host) return false;\n    int thisPort =\n        this.uri.port == 0 ? HttpClient.DEFAULT_HTTP_PORT : this.uri.port;\n    int otherPort = uri.port == 0 ? HttpClient.DEFAULT_HTTP_PORT : uri.port;\n    if (otherPort != thisPort) return false;\n    return uri.path.startsWith(this.uri.path);\n  }\n\n  void authorize(HttpClientRequest request) {\n    // Digest credentials cannot be used without a nonce from the\n    // server.\n    if (credentials.scheme == _AuthenticationScheme.DIGEST &&\n        nonce == null) {\n      return;\n    }\n    credentials.authorize(this, request);\n    used = true;\n  }\n}\n\n\nclass _ProxyCredentials extends _Credentials {\n  String host;\n  int port;\n\n  _ProxyCredentials(this.host,\n                    this.port,\n                    realm,\n                    _HttpClientCredentials creds)\n      : super(creds, realm);\n\n  bool applies(_Proxy proxy, _AuthenticationScheme scheme) {\n    if (scheme != null && credentials.scheme != scheme) return false;\n    return proxy.host == host && proxy.port == port;\n  }\n\n  void authorize(HttpClientRequest request) {\n    // Digest credentials cannot be used without a nonce from the\n    // server.\n    if (credentials.scheme == _AuthenticationScheme.DIGEST &&\n        nonce == null) {\n      return;\n    }\n    credentials.authorizeProxy(this, request);\n  }\n}\n\n\nabstract class _HttpClientCredentials implements HttpClientCredentials {\n  _AuthenticationScheme get scheme;\n  void authorize(_Credentials credentials, HttpClientRequest request);\n  void authorizeProxy(_ProxyCredentials credentials, HttpClientRequest request);\n}\n\n\nclass _HttpClientBasicCredentials\n    extends _HttpClientCredentials\n    implements HttpClientBasicCredentials {\n  String username;\n  String password;\n\n  _HttpClientBasicCredentials(this.username, this.password);\n\n  _AuthenticationScheme get scheme => _AuthenticationScheme.BASIC;\n\n  String authorization() {\n    // There is no mentioning of username/password encoding in RFC\n    // 2617. However there is an open draft for adding an additional\n    // accept-charset parameter to the WWW-Authenticate and\n    // Proxy-Authenticate headers, see\n    // http://tools.ietf.org/html/draft-reschke-basicauth-enc-06. For\n    // now always use UTF-8 encoding.\n    String auth =\n        _CryptoUtils.bytesToBase64(UTF8.encode(\"$username:$password\"));\n    return \"Basic $auth\";\n  }\n\n  void authorize(_Credentials _, HttpClientRequest request) =>\n      request.headers.set(HttpHeaders.AUTHORIZATION, authorization());\n\n  void authorizeProxy(_ProxyCredentials _, HttpClientRequest request) =>\n      request.headers.set(HttpHeaders.PROXY_AUTHORIZATION, authorization());\n}\n\n\nclass _HttpClientDigestCredentials\n    extends _HttpClientCredentials\n    implements HttpClientDigestCredentials {\n  String username;\n  String password;\n\n  _HttpClientDigestCredentials(this.username, this.password);\n\n  _AuthenticationScheme get scheme => _AuthenticationScheme.DIGEST;\n\n  String authorization(_Credentials credentials, _HttpClientRequest request) {\n    String requestUri = request._requestUri();\n    _MD5 hasher = new _MD5()\n        ..add(request.method.codeUnits)\n        ..add([_CharCode.COLON])\n        ..add(requestUri.codeUnits);\n    var ha2 = _CryptoUtils.bytesToHex(hasher.close());\n\n    String qop;\n    String cnonce;\n    String nc;\n    var x;\n    hasher = new _MD5()\n        ..add(credentials.ha1.codeUnits)\n        ..add([_CharCode.COLON]);\n    if (credentials.qop == \"auth\") {\n      qop = credentials.qop;\n      cnonce = _CryptoUtils.bytesToHex(_IOCrypto.getRandomBytes(4));\n      ++credentials.nonceCount;\n      nc = credentials.nonceCount.toRadixString(16);\n      nc = \"00000000\".substring(0, 8 - nc.length + 1) + nc;\n      hasher\n          ..add(credentials.nonce.codeUnits)\n          ..add([_CharCode.COLON])\n          ..add(nc.codeUnits)\n          ..add([_CharCode.COLON])\n          ..add(cnonce.codeUnits)\n          ..add([_CharCode.COLON])\n          ..add(credentials.qop.codeUnits)\n          ..add([_CharCode.COLON])\n          ..add(ha2.codeUnits);\n    } else {\n      hasher\n          ..add(credentials.nonce.codeUnits)\n          ..add([_CharCode.COLON])\n          ..add(ha2.codeUnits);\n    }\n    var response = _CryptoUtils.bytesToHex(hasher.close());\n\n    StringBuffer buffer = new StringBuffer()\n        ..write('Digest ')\n        ..write('username=\"$username\"')\n        ..write(', realm=\"${credentials.realm}\"')\n        ..write(', nonce=\"${credentials.nonce}\"')\n        ..write(', uri=\"$requestUri\"')\n        ..write(', algorithm=\"${credentials.algorithm}\"');\n    if (qop == \"auth\") {\n      buffer\n          ..write(', qop=\"$qop\"')\n          ..write(', cnonce=\"$cnonce\"')\n          ..write(', nc=\"$nc\"');\n    }\n    buffer.write(', response=\"$response\"');\n    return buffer.toString();\n  }\n\n  void authorize(_Credentials credentials, HttpClientRequest request) {\n    request.headers.set(HttpHeaders.AUTHORIZATION,\n                        authorization(credentials, request));\n  }\n\n  void authorizeProxy(_ProxyCredentials credentials,\n                      HttpClientRequest request) {\n    request.headers.set(HttpHeaders.PROXY_AUTHORIZATION,\n                        authorization(credentials, request));\n  }\n}\n\n\nclass _RedirectInfo implements RedirectInfo {\n  final int statusCode;\n  final String method;\n  final Uri location;\n  const _RedirectInfo(this.statusCode, this.method, this.location);\n}\n\nString _getHttpVersion() {\n  var version = Platform.version;\n  // Only include major and minor version numbers.\n  int index = version.indexOf('.', version.indexOf('.') + 1);\n  version = version.substring(0, index);\n  return 'Dart/$version (dart:io)';\n}\n\u0000","sdk:/sdk/lib/io/http_headers.dart":"// Copyright (c) 2013, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\npart of dart.io;\n\nclass _HttpHeaders implements HttpHeaders {\n  final Map<String, List<String>> _headers;\n  final String protocolVersion;\n\n  bool _mutable = true;  // Are the headers currently mutable?\n  List<String> _noFoldingHeaders;\n\n  int _contentLength = -1;\n  bool _persistentConnection = true;\n  bool _chunkedTransferEncoding = false;\n  String _host;\n  int _port;\n\n  final int _defaultPortForScheme;\n\n  _HttpHeaders(this.protocolVersion,\n               {int defaultPortForScheme: HttpClient.DEFAULT_HTTP_PORT,\n                _HttpHeaders initialHeaders})\n      : _headers = new HashMap<String, List<String>>(),\n        _defaultPortForScheme = defaultPortForScheme {\n    if (initialHeaders != null) {\n      initialHeaders._headers.forEach((name, value) => _headers[name] = value);\n      _contentLength = initialHeaders._contentLength;\n      _persistentConnection = initialHeaders._persistentConnection;\n      _chunkedTransferEncoding = initialHeaders._chunkedTransferEncoding;\n      _host = initialHeaders._host;\n      _port = initialHeaders._port;\n    }\n    if (protocolVersion == \"1.0\") {\n      _persistentConnection = false;\n      _chunkedTransferEncoding = false;\n    }\n  }\n\n  List<String> operator[](String name) => _headers[name.toLowerCase()];\n\n  String value(String name) {\n    name = name.toLowerCase();\n    List<String> values = _headers[name];\n    if (values == null) return null;\n    if (values.length > 1) {\n      throw new HttpException(\"More than one value for header $name\");\n    }\n    return values[0];\n  }\n\n  void add(String name, value) {\n    _checkMutable();\n    _addAll(_validateField(name), value);\n  }\n\n  void _addAll(String name, value) {\n    assert(name == _validateField(name));\n    if (value is Iterable) {\n      for (var v in value) {\n        _add(name, _validateValue(v));\n      }\n    } else {\n      _add(name, _validateValue(value));\n    }\n  }\n\n  void set(String name, Object value) {\n    _checkMutable();\n    name = _validateField(name);\n    _headers.remove(name);\n    if (name == HttpHeaders.TRANSFER_ENCODING) {\n      _chunkedTransferEncoding = false;\n    }\n    _addAll(name, value);\n  }\n\n  void remove(String name, Object value) {\n    _checkMutable();\n    name = _validateField(name);\n    value = _validateValue(value);\n    List<String> values = _headers[name];\n    if (values != null) {\n      int index = values.indexOf(value);\n      if (index != -1) {\n        values.removeRange(index, index + 1);\n      }\n      if (values.length == 0) _headers.remove(name);\n    }\n    if (name == HttpHeaders.TRANSFER_ENCODING && value == \"chunked\") {\n      _chunkedTransferEncoding = false;\n    }\n  }\n\n  void removeAll(String name) {\n    _checkMutable();\n    name = _validateField(name);\n    _headers.remove(name);\n  }\n\n  void forEach(void f(String name, List<String> values)) {\n    _headers.forEach(f);\n  }\n\n  void noFolding(String name) {\n    if (_noFoldingHeaders == null) _noFoldingHeaders = new List<String>();\n    _noFoldingHeaders.add(name);\n  }\n\n  bool get persistentConnection => _persistentConnection;\n\n  void set persistentConnection(bool persistentConnection) {\n    _checkMutable();\n    if (persistentConnection == _persistentConnection) return;\n    if (persistentConnection) {\n      if (protocolVersion == \"1.1\") {\n        remove(HttpHeaders.CONNECTION, \"close\");\n      } else {\n        if (_contentLength == -1) {\n          throw new HttpException(\n              \"Trying to set 'Connection: Keep-Alive' on HTTP 1.0 headers with \"\n              \"no ContentLength\");\n        }\n        add(HttpHeaders.CONNECTION, \"keep-alive\");\n      }\n    } else {\n      if (protocolVersion == \"1.1\") {\n        add(HttpHeaders.CONNECTION, \"close\");\n      } else {\n        remove(HttpHeaders.CONNECTION, \"keep-alive\");\n      }\n    }\n    _persistentConnection = persistentConnection;\n  }\n\n  int get contentLength => _contentLength;\n\n  void set contentLength(int contentLength) {\n    _checkMutable();\n    if (protocolVersion == \"1.0\" &&\n        persistentConnection &&\n        contentLength == -1) {\n      throw new HttpException(\n          \"Trying to clear ContentLength on HTTP 1.0 headers with \"\n          \"'Connection: Keep-Alive' set\");\n    }\n    if (_contentLength == contentLength) return;\n    _contentLength = contentLength;\n    if (_contentLength >= 0) {\n      if (chunkedTransferEncoding) chunkedTransferEncoding = false;\n      _set(HttpHeaders.CONTENT_LENGTH, contentLength.toString());\n    } else {\n      removeAll(HttpHeaders.CONTENT_LENGTH);\n      if (protocolVersion == \"1.1\") {\n        chunkedTransferEncoding = true;\n      }\n    }\n  }\n\n  bool get chunkedTransferEncoding => _chunkedTransferEncoding;\n\n  void set chunkedTransferEncoding(bool chunkedTransferEncoding) {\n    _checkMutable();\n    if (chunkedTransferEncoding && protocolVersion == \"1.0\") {\n      throw new HttpException(\n          \"Trying to set 'Transfer-Encoding: Chunked' on HTTP 1.0 headers\");\n    }\n    if (chunkedTransferEncoding == _chunkedTransferEncoding) return;\n    if (chunkedTransferEncoding) {\n      List<String> values = _headers[HttpHeaders.TRANSFER_ENCODING];\n      if ((values == null || values.last != \"chunked\")) {\n        // Headers does not specify chunked encoding - add it if set.\n        _addValue(HttpHeaders.TRANSFER_ENCODING, \"chunked\");\n      }\n      contentLength = -1;\n    } else {\n      // Headers does specify chunked encoding - remove it if not set.\n      remove(HttpHeaders.TRANSFER_ENCODING, \"chunked\");\n    }\n    _chunkedTransferEncoding = chunkedTransferEncoding;\n  }\n\n  String get host => _host;\n\n  void set host(String host) {\n    _checkMutable();\n    _host = host;\n    _updateHostHeader();\n  }\n\n  int get port => _port;\n\n  void set port(int port) {\n    _checkMutable();\n    _port = port;\n    _updateHostHeader();\n  }\n\n  DateTime get ifModifiedSince {\n    List<String> values = _headers[HttpHeaders.IF_MODIFIED_SINCE];\n    if (values != null) {\n      try {\n        return HttpDate.parse(values[0]);\n      } on Exception catch (e) {\n        return null;\n      }\n    }\n    return null;\n  }\n\n  void set ifModifiedSince(DateTime ifModifiedSince) {\n    _checkMutable();\n    // Format \"ifModifiedSince\" header with date in Greenwich Mean Time (GMT).\n    String formatted = HttpDate.format(ifModifiedSince.toUtc());\n    _set(HttpHeaders.IF_MODIFIED_SINCE, formatted);\n  }\n\n  DateTime get date {\n    List<String> values = _headers[HttpHeaders.DATE];\n    if (values != null) {\n      try {\n        return HttpDate.parse(values[0]);\n      } on Exception catch (e) {\n        return null;\n      }\n    }\n    return null;\n  }\n\n  void set date(DateTime date) {\n    _checkMutable();\n    // Format \"DateTime\" header with date in Greenwich Mean Time (GMT).\n    String formatted = HttpDate.format(date.toUtc());\n    _set(\"date\", formatted);\n  }\n\n  DateTime get expires {\n    List<String> values = _headers[HttpHeaders.EXPIRES];\n    if (values != null) {\n      try {\n        return HttpDate.parse(values[0]);\n      } on Exception catch (e) {\n        return null;\n      }\n    }\n    return null;\n  }\n\n  void set expires(DateTime expires) {\n    _checkMutable();\n    // Format \"Expires\" header with date in Greenwich Mean Time (GMT).\n    String formatted = HttpDate.format(expires.toUtc());\n    _set(HttpHeaders.EXPIRES, formatted);\n  }\n\n  ContentType get contentType {\n    var values = _headers[\"content-type\"];\n    if (values != null) {\n      return ContentType.parse(values[0]);\n    } else {\n      return null;\n    }\n  }\n\n  void set contentType(ContentType contentType) {\n    _checkMutable();\n    _set(HttpHeaders.CONTENT_TYPE, contentType.toString());\n  }\n\n  void clear() {\n    _checkMutable();\n    _headers.clear();\n    _contentLength = -1;\n    _persistentConnection = true;\n    _chunkedTransferEncoding = false;\n    _host = null;\n    _port = null;\n  }\n\n  // [name] must be a lower-case version of the name.\n  void _add(String name, value) {\n    assert(name == _validateField(name));\n    // Use the length as index on what method to call. This is notable\n    // faster than computing hash and looking up in a hash-map.\n    switch (name.length) {\n      case 4:\n        if (HttpHeaders.DATE == name) {\n          _addDate(name, value);\n          return;\n        }\n        if (HttpHeaders.HOST == name) {\n          _addHost(name, value);\n          return;\n        }\n        break;\n      case 7:\n        if (HttpHeaders.EXPIRES == name) {\n          _addExpires(name, value);\n          return;\n        }\n        break;\n      case 10:\n        if (HttpHeaders.CONNECTION == name) {\n          _addConnection(name, value);\n          return;\n        }\n        break;\n      case 12:\n        if (HttpHeaders.CONTENT_TYPE == name) {\n          _addContentType(name, value);\n          return;\n        }\n        break;\n      case 14:\n        if (HttpHeaders.CONTENT_LENGTH == name) {\n          _addContentLength(name, value);\n          return;\n        }\n        break;\n      case 17:\n        if (HttpHeaders.TRANSFER_ENCODING == name) {\n          _addTransferEncoding(name, value);\n          return;\n        }\n        if (HttpHeaders.IF_MODIFIED_SINCE == name) {\n          _addIfModifiedSince(name, value);\n          return;\n        }\n    }\n    _addValue(name, value);\n  }\n\n  void _addContentLength(String name, value) {\n    if (value is int) {\n      contentLength = value;\n    } else if (value is String) {\n      contentLength = int.parse(value);\n    } else {\n      throw new HttpException(\"Unexpected type for header named $name\");\n    }\n  }\n\n  void _addTransferEncoding(String name, value) {\n    if (value == \"chunked\") {\n      chunkedTransferEncoding = true;\n    } else {\n      _addValue(HttpHeaders.TRANSFER_ENCODING, value);\n    }\n  }\n\n  void _addDate(String name, value) {\n    if (value is DateTime) {\n      date = value;\n    } else if (value is String) {\n      _set(HttpHeaders.DATE, value);\n    } else {\n      throw new HttpException(\"Unexpected type for header named $name\");\n    }\n  }\n\n  void _addExpires(String name, value) {\n    if (value is DateTime) {\n      expires = value;\n    } else if (value is String) {\n      _set(HttpHeaders.EXPIRES, value);\n    } else {\n      throw new HttpException(\"Unexpected type for header named $name\");\n    }\n  }\n\n  void _addIfModifiedSince(String name, value) {\n    if (value is DateTime) {\n      ifModifiedSince = value;\n    } else if (value is String) {\n      _set(HttpHeaders.IF_MODIFIED_SINCE, value);\n    } else {\n      throw new HttpException(\"Unexpected type for header named $name\");\n    }\n  }\n\n  void _addHost(String name, value) {\n    if (value is String) {\n      int pos = value.indexOf(\":\");\n      if (pos == -1) {\n        _host = value;\n        _port = HttpClient.DEFAULT_HTTP_PORT;\n      } else {\n        if (pos > 0) {\n          _host = value.substring(0, pos);\n        } else {\n          _host = null;\n        }\n        if (pos + 1 == value.length) {\n          _port = HttpClient.DEFAULT_HTTP_PORT;\n        } else {\n          try {\n            _port = int.parse(value.substring(pos + 1));\n          } on FormatException catch (e) {\n            _port = null;\n          }\n        }\n      }\n      _set(HttpHeaders.HOST, value);\n    } else {\n      throw new HttpException(\"Unexpected type for header named $name\");\n    }\n  }\n\n  void _addConnection(String name, value) {\n    var lowerCaseValue = value.toLowerCase();\n    if (lowerCaseValue == 'close') {\n      _persistentConnection = false;\n    } else if (lowerCaseValue == 'keep-alive') {\n      _persistentConnection = true;\n    }\n    _addValue(name, value);\n  }\n\n  void _addContentType(String name, value) {\n    _set(HttpHeaders.CONTENT_TYPE, value);\n  }\n\n  void _addValue(String name, Object value) {\n    List<String> values = _headers[name];\n    if (values == null) {\n      values = new List<String>();\n      _headers[name] = values;\n    }\n    if (value is DateTime) {\n      values.add(HttpDate.format(value));\n    } else if (value is String) {\n      values.add(value);\n    } else {\n      values.add(_validateValue(value.toString()));\n    }\n  }\n\n  void _set(String name, String value) {\n    assert(name == _validateField(name));\n    List<String> values = new List<String>();\n    _headers[name] = values;\n    values.add(value);\n  }\n\n  _checkMutable() {\n    if (!_mutable) throw new HttpException(\"HTTP headers are not mutable\");\n  }\n\n  _updateHostHeader() {\n    bool defaultPort = _port == null || _port == _defaultPortForScheme;\n    String portPart = defaultPort ? \"\" : \":$_port\";\n    _set(\"host\", \"$host$portPart\");\n  }\n\n  _foldHeader(String name) {\n    if (name == HttpHeaders.SET_COOKIE ||\n        (_noFoldingHeaders != null &&\n         _noFoldingHeaders.indexOf(name) != -1)) {\n      return false;\n    }\n    return true;\n  }\n\n  void _finalize() {\n    _mutable = false;\n  }\n\n  int _write(Uint8List buffer, int offset) {\n    void write(List<int> bytes) {\n      int len = bytes.length;\n      for (int i = 0; i < len; i++) {\n        buffer[offset + i] = bytes[i];\n      }\n      offset += len;\n    }\n\n    // Format headers.\n    for (String name in _headers.keys) {\n      List<String> values = _headers[name];\n      bool fold = _foldHeader(name);\n      var nameData = name.codeUnits;\n      write(nameData);\n      buffer[offset++] = _CharCode.COLON;\n      buffer[offset++] = _CharCode.SP;\n      for (int i = 0; i < values.length; i++) {\n        if (i > 0) {\n          if (fold) {\n            buffer[offset++] = _CharCode.COMMA;\n            buffer[offset++] = _CharCode.SP;\n          } else {\n            buffer[offset++] = _CharCode.CR;\n            buffer[offset++] = _CharCode.LF;\n            write(nameData);\n            buffer[offset++] = _CharCode.COLON;\n            buffer[offset++] = _CharCode.SP;\n          }\n        }\n        write(values[i].codeUnits);\n      }\n      buffer[offset++] = _CharCode.CR;\n      buffer[offset++] = _CharCode.LF;\n    }\n    return offset;\n  }\n\n  String toString() {\n    StringBuffer sb = new StringBuffer();\n    _headers.forEach((String name, List<String> values) {\n      sb..write(name)..write(\": \");\n      bool fold = _foldHeader(name);\n      for (int i = 0; i < values.length; i++) {\n        if (i > 0) {\n          if (fold) {\n            sb.write(\", \");\n          } else {\n            sb..write(\"\\n\")..write(name)..write(\": \");\n          }\n        }\n        sb.write(values[i]);\n      }\n      sb.write(\"\\n\");\n    });\n    return sb.toString();\n  }\n\n  List<Cookie> _parseCookies() {\n    // Parse a Cookie header value according to the rules in RFC 6265.\n    var cookies = new List<Cookie>();\n    void parseCookieString(String s) {\n      int index = 0;\n\n      bool done() => index == -1 || index == s.length;\n\n      void skipWS() {\n        while (!done()) {\n         if (s[index] != \" \" && s[index] != \"\\t\") return;\n         index++;\n        }\n      }\n\n      String parseName() {\n        int start = index;\n        while (!done()) {\n          if (s[index] == \" \" || s[index] == \"\\t\" || s[index] == \"=\") break;\n          index++;\n        }\n        return s.substring(start, index);\n      }\n\n      String parseValue() {\n        int start = index;\n        while (!done()) {\n          if (s[index] == \" \" || s[index] == \"\\t\" || s[index] == \";\") break;\n          index++;\n        }\n        return s.substring(start, index);\n      }\n\n      bool expect(String expected) {\n        if (done()) return false;\n        if (s[index] != expected) return false;\n        index++;\n        return true;\n      }\n\n      while (!done()) {\n        skipWS();\n        if (done()) return;\n        String name = parseName();\n        skipWS();\n        if (!expect(\"=\")) {\n          index = s.indexOf(';', index);\n          continue;\n        }\n        skipWS();\n        String value = parseValue();\n        try {\n          cookies.add(new _Cookie(name, value));\n        } catch (_) {\n          // Skip it, invalid cookie data.\n        }\n        skipWS();\n        if (done()) return;\n        if (!expect(\";\")) {\n          index = s.indexOf(';', index);\n          continue;\n        }\n      }\n    }\n    List<String> values = _headers[HttpHeaders.COOKIE];\n    if (values != null) {\n      values.forEach((headerValue) => parseCookieString(headerValue));\n    }\n    return cookies;\n  }\n\n  static String _validateField(String field) {\n    for (var i = 0; i < field.length; i++) {\n      if (!_HttpParser._isTokenChar(field.codeUnitAt(i))) {\n        throw new FormatException(\n            \"Invalid HTTP header field name: ${JSON.encode(field)}\");\n      }\n    }\n    return field.toLowerCase();\n  }\n\n  static _validateValue(value) {\n    if (value is! String) return value;\n    for (var i = 0; i < value.length; i++) {\n      if (!_HttpParser._isValueChar(value.codeUnitAt(i))) {\n        throw new FormatException(\n            \"Invalid HTTP header field value: ${JSON.encode(value)}\");\n      }\n    }\n    return value;\n  }\n}\n\n\nclass _HeaderValue implements HeaderValue {\n  String _value;\n  Map<String, String> _parameters;\n  Map<String, String> _unmodifiableParameters;\n\n  _HeaderValue([String this._value = \"\", Map<String, String> parameters]) {\n    if (parameters != null) {\n      _parameters = new HashMap<String, String>.from(parameters);\n    }\n  }\n\n  static _HeaderValue parse(String value,\n                            {parameterSeparator: \";\",\n                             preserveBackslash: false}) {\n    // Parse the string.\n    var result = new _HeaderValue();\n    result._parse(value, parameterSeparator, preserveBackslash);\n    return result;\n  }\n\n  String get value => _value;\n\n  void _ensureParameters() {\n    if (_parameters == null) {\n      _parameters = new HashMap<String, String>();\n    }\n  }\n\n  Map<String, String> get parameters {\n    _ensureParameters();\n    if (_unmodifiableParameters == null) {\n      _unmodifiableParameters = new UnmodifiableMapView(_parameters);\n    }\n    return _unmodifiableParameters;\n  }\n\n  String toString() {\n    StringBuffer sb = new StringBuffer();\n    sb.write(_value);\n    if (parameters != null && parameters.length > 0) {\n      _parameters.forEach((String name, String value) {\n        sb..write(\"; \")..write(name)..write(\"=\")..write(value);\n      });\n    }\n    return sb.toString();\n  }\n\n  void _parse(String s, String parameterSeparator, bool preserveBackslash) {\n    int index = 0;\n\n    bool done() => index == s.length;\n\n    void skipWS() {\n      while (!done()) {\n        if (s[index] != \" \" && s[index] != \"\\t\") return;\n        index++;\n      }\n    }\n\n    String parseValue() {\n      int start = index;\n      while (!done()) {\n        if (s[index] == \" \" ||\n            s[index] == \"\\t\" ||\n            s[index] == parameterSeparator) break;\n        index++;\n      }\n      return s.substring(start, index);\n    }\n\n    void expect(String expected) {\n      if (done() || s[index] != expected) {\n        throw new HttpException(\"Failed to parse header value\");\n      }\n      index++;\n    }\n\n    void maybeExpect(String expected) {\n      if (s[index] == expected) index++;\n    }\n\n    void parseParameters() {\n      var parameters = new HashMap<String, String>();\n      _parameters = new UnmodifiableMapView(parameters);\n\n      String parseParameterName() {\n        int start = index;\n        while (!done()) {\n          if (s[index] == \" \" || s[index] == \"\\t\" || s[index] == \"=\") break;\n          index++;\n        }\n        return s.substring(start, index).toLowerCase();\n      }\n\n      String parseParameterValue() {\n        if (s[index] == \"\\\"\") {\n          // Parse quoted value.\n          StringBuffer sb = new StringBuffer();\n          index++;\n          while (!done()) {\n            if (s[index] == \"\\\\\") {\n              if (index + 1 == s.length) {\n                throw new HttpException(\"Failed to parse header value\");\n              }\n              if (preserveBackslash && s[index + 1] != \"\\\"\") {\n                sb.write(s[index]);\n              }\n              index++;\n            } else if (s[index] == \"\\\"\") {\n              index++;\n              break;\n            }\n            sb.write(s[index]);\n            index++;\n          }\n          return sb.toString();\n        } else {\n          // Parse non-quoted value.\n          return parseValue();\n        }\n      }\n\n      while (!done()) {\n        skipWS();\n        if (done()) return;\n        String name = parseParameterName();\n        skipWS();\n        expect(\"=\");\n        skipWS();\n        String value = parseParameterValue();\n        parameters[name] = value;\n        skipWS();\n        if (done()) return;\n        expect(parameterSeparator);\n      }\n    }\n\n    skipWS();\n    _value = parseValue();\n    skipWS();\n    if (done()) return;\n    maybeExpect(parameterSeparator);\n    parseParameters();\n  }\n}\n\n\nclass _ContentType extends _HeaderValue implements ContentType {\n  String _primaryType = \"\";\n  String _subType = \"\";\n\n  _ContentType(String primaryType,\n               String subType,\n               String charset,\n               Map<String, String> parameters)\n      : _primaryType = primaryType, _subType = subType, super(\"\") {\n    if (_primaryType == null) _primaryType = \"\";\n    if (_subType == null) _subType = \"\";\n    _value = \"$_primaryType/$_subType\";\n    if (parameters != null) {\n      _ensureParameters();\n      parameters.forEach((String key, String value) {\n        this._parameters[key.toLowerCase()] = value.toLowerCase();\n      });\n    }\n    if (charset != null) {\n      _ensureParameters();\n      this._parameters[\"charset\"] = charset.toLowerCase();\n    }\n  }\n\n  _ContentType._();\n\n  static _ContentType parse(String value) {\n    var result = new _ContentType._();\n    result._parse(value, \";\", false);\n    int index = result._value.indexOf(\"/\");\n    if (index == -1 || index == (result._value.length - 1)) {\n      result._primaryType = result._value.trim().toLowerCase();\n      result._subType = \"\";\n    } else {\n      result._primaryType =\n          result._value.substring(0, index).trim().toLowerCase();\n      result._subType = result._value.substring(index + 1).trim().toLowerCase();\n    }\n    return result;\n  }\n\n  String get mimeType => '$primaryType/$subType';\n\n  String get primaryType => _primaryType;\n\n  String get subType => _subType;\n\n  String get charset => parameters[\"charset\"];\n}\n\n\nclass _Cookie implements Cookie {\n  String name;\n  String value;\n  DateTime expires;\n  int maxAge;\n  String domain;\n  String path;\n  bool httpOnly = false;\n  bool secure = false;\n\n  _Cookie([this.name, this.value]) {\n    // Default value of httponly is true.\n    httpOnly = true;\n    _validate();\n  }\n\n  _Cookie.fromSetCookieValue(String value) {\n    // Parse the 'set-cookie' header value.\n    _parseSetCookieValue(value);\n  }\n\n  // Parse a 'set-cookie' header value according to the rules in RFC 6265.\n  void _parseSetCookieValue(String s) {\n    int index = 0;\n\n    bool done() => index == s.length;\n\n    String parseName() {\n      int start = index;\n      while (!done()) {\n        if (s[index] == \"=\") break;\n        index++;\n      }\n      return s.substring(start, index).trim();\n    }\n\n    String parseValue() {\n      int start = index;\n      while (!done()) {\n        if (s[index] == \";\") break;\n        index++;\n      }\n      return s.substring(start, index).trim();\n    }\n\n    void expect(String expected) {\n      if (done()) throw new HttpException(\"Failed to parse header value [$s]\");\n      if (s[index] != expected) {\n        throw new HttpException(\"Failed to parse header value [$s]\");\n      }\n      index++;\n    }\n\n    void parseAttributes() {\n      String parseAttributeName() {\n        int start = index;\n        while (!done()) {\n          if (s[index] == \"=\" || s[index] == \";\") break;\n          index++;\n        }\n        return s.substring(start, index).trim().toLowerCase();\n      }\n\n      String parseAttributeValue() {\n        int start = index;\n        while (!done()) {\n          if (s[index] == \";\") break;\n          index++;\n        }\n        return s.substring(start, index).trim().toLowerCase();\n      }\n\n      while (!done()) {\n        String name = parseAttributeName();\n        String value = \"\";\n        if (!done() && s[index] == \"=\") {\n          index++;  // Skip the = character.\n          value = parseAttributeValue();\n        }\n        if (name == \"expires\") {\n          expires = HttpDate._parseCookieDate(value);\n        } else if (name == \"max-age\") {\n          maxAge = int.parse(value);\n        } else if (name == \"domain\") {\n          domain = value;\n        } else if (name == \"path\") {\n          path = value;\n        } else if (name == \"httponly\") {\n          httpOnly = true;\n        } else if (name == \"secure\") {\n          secure = true;\n        }\n        if (!done()) index++;  // Skip the ; character\n      }\n    }\n\n    name = parseName();\n    if (done() || name.length == 0) {\n      throw new HttpException(\"Failed to parse header value [$s]\");\n    }\n    index++;  // Skip the = character.\n    value = parseValue();\n    _validate();\n    if (done()) return;\n    index++;  // Skip the ; character.\n    parseAttributes();\n  }\n\n  String toString() {\n    StringBuffer sb = new StringBuffer();\n    sb..write(name)..write(\"=\")..write(value);\n    if (expires != null) {\n      sb..write(\"; Expires=\")..write(HttpDate.format(expires));\n    }\n    if (maxAge != null) {\n      sb..write(\"; Max-Age=\")..write(maxAge);\n    }\n    if (domain != null) {\n      sb..write(\"; Domain=\")..write(domain);\n    }\n    if (path != null) {\n      sb..write(\"; Path=\")..write(path);\n    }\n    if (secure) sb.write(\"; Secure\");\n    if (httpOnly) sb.write(\"; HttpOnly\");\n    return sb.toString();\n  }\n\n  void _validate() {\n    const SEPERATORS = const [\n        \"(\", \")\", \"<\", \">\", \"@\", \",\", \";\", \":\", \"\\\\\",\n        '\"', \"/\", \"[\", \"]\", \"?\", \"=\", \"{\", \"}\"];\n    for (int i = 0; i < name.length; i++) {\n      int codeUnit = name.codeUnits[i];\n      if (codeUnit <= 32 ||\n          codeUnit >= 127 ||\n          SEPERATORS.indexOf(name[i]) >= 0) {\n        throw new FormatException(\n            \"Invalid character in cookie name, code unit: '$codeUnit'\");\n      }\n    }\n    for (int i = 0; i < value.length; i++) {\n      int codeUnit = value.codeUnits[i];\n      if (!(codeUnit == 0x21 ||\n            (codeUnit >= 0x23 && codeUnit <= 0x2B) ||\n            (codeUnit >= 0x2D && codeUnit <= 0x3A) ||\n            (codeUnit >= 0x3C && codeUnit <= 0x5B) ||\n            (codeUnit >= 0x5D && codeUnit <= 0x7E))) {\n        throw new FormatException(\n            \"Invalid character in cookie value, code unit: '$codeUnit'\");\n      }\n    }\n  }\n}\n\u0000","sdk:/sdk/lib/io/http_date.dart":"// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\npart of dart.io;\n\n/**\n * Utility functions for working with dates with HTTP specific date\n * formats.\n */\nclass HttpDate {\n  // From RFC-2616 section \"3.3.1 Full Date\",\n  // http://tools.ietf.org/html/rfc2616#section-3.3.1\n  //\n  // HTTP-date    = rfc1123-date | rfc850-date | asctime-date\n  // rfc1123-date = wkday \",\" SP date1 SP time SP \"GMT\"\n  // rfc850-date  = weekday \",\" SP date2 SP time SP \"GMT\"\n  // asctime-date = wkday SP date3 SP time SP 4DIGIT\n  // date1        = 2DIGIT SP month SP 4DIGIT\n  //                ; day month year (e.g., 02 Jun 1982)\n  // date2        = 2DIGIT \"-\" month \"-\" 2DIGIT\n  //                ; day-month-year (e.g., 02-Jun-82)\n  // date3        = month SP ( 2DIGIT | ( SP 1DIGIT ))\n  //                ; month day (e.g., Jun  2)\n  // time         = 2DIGIT \":\" 2DIGIT \":\" 2DIGIT\n  //                ; 00:00:00 - 23:59:59\n  // wkday        = \"Mon\" | \"Tue\" | \"Wed\"\n  //              | \"Thu\" | \"Fri\" | \"Sat\" | \"Sun\"\n  // weekday      = \"Monday\" | \"Tuesday\" | \"Wednesday\"\n  //              | \"Thursday\" | \"Friday\" | \"Saturday\" | \"Sunday\"\n  // month        = \"Jan\" | \"Feb\" | \"Mar\" | \"Apr\"\n  //              | \"May\" | \"Jun\" | \"Jul\" | \"Aug\"\n  //              | \"Sep\" | \"Oct\" | \"Nov\" | \"Dec\"\n\n  /**\n   * Format a date according to\n   * [RFC-1123](http://tools.ietf.org/html/rfc1123 \"RFC-1123\"),\n   * e.g. `Thu, 1 Jan 1970 00:00:00 GMT`.\n   */\n  static String format(DateTime date) {\n    const List wkday = const [\"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\", \"Sun\"];\n    const List month = const [\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\",\n                              \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"];\n\n    DateTime d = date.toUtc();\n    StringBuffer sb = new StringBuffer()\n        ..write(wkday[d.weekday - 1])\n        ..write(\", \")\n        ..write(d.day <= 9 ? \"0\" : \"\")\n        ..write(d.day.toString())\n        ..write(\" \")\n        ..write(month[d.month - 1])\n        ..write(\" \")\n        ..write(d.year.toString())\n        ..write(d.hour <= 9 ? \" 0\" : \" \")\n        ..write(d.hour.toString())\n        ..write(d.minute <= 9 ? \":0\" : \":\")\n        ..write(d.minute.toString())\n        ..write(d.second <= 9 ? \":0\" : \":\")\n        ..write(d.second.toString())\n        ..write(\" GMT\");\n    return sb.toString();\n  }\n\n  /**\n   * Parse a date string in either of the formats\n   * [RFC-1123](http://tools.ietf.org/html/rfc1123 \"RFC-1123\"),\n   * [RFC-850](http://tools.ietf.org/html/rfc850 \"RFC-850\") or\n   * ANSI C's asctime() format. These formats are listed here.\n   *\n   *     Thu, 1 Jan 1970 00:00:00 GMT\n   *     Thursday, 1-Jan-1970 00:00:00 GMT\n   *     Thu Jan  1 00:00:00 1970\n   *\n   * For more information see [RFC-2616 section 3.1.1]\n   * (http://tools.ietf.org/html/rfc2616#section-3.3.1\n   * \"RFC-2616 section 3.1.1\").\n   */\n  static DateTime parse(String date) {\n    final int SP = 32;\n    const List wkdays = const [\"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\", \"Sun\"];\n    const List weekdays = const [\"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\",\n                           \"Friday\", \"Saturday\", \"Sunday\"];\n    const List months = const [\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\",\n                         \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"];\n    const List wkdaysLowerCase =\n        const [\"mon\", \"tue\", \"wed\", \"thu\", \"fri\", \"sat\", \"sun\"];\n    const List weekdaysLowerCase = const [\"monday\", \"tuesday\", \"wednesday\",\n                                          \"thursday\", \"friday\", \"saturday\",\n                                          \"sunday\"];\n    const List monthsLowerCase = const [\"jan\", \"feb\", \"mar\", \"apr\", \"may\",\n                                        \"jun\", \"jul\", \"aug\", \"sep\", \"oct\",\n                                        \"nov\", \"dec\"];\n\n    final int formatRfc1123 = 0;\n    final int formatRfc850 = 1;\n    final int formatAsctime = 2;\n\n    int index = 0;\n    String tmp;\n    int format;\n\n    void expect(String s) {\n      if (date.length - index < s.length) {\n        throw new HttpException(\"Invalid HTTP date $date\");\n      }\n      String tmp = date.substring(index, index + s.length);\n      if (tmp != s) {\n        throw new HttpException(\"Invalid HTTP date $date\");\n      }\n      index += s.length;\n    }\n\n    int expectWeekday() {\n      int weekday;\n      // The formatting of the weekday signals the format of the date string.\n      int pos = date.indexOf(\",\", index);\n      if (pos == -1) {\n        int pos = date.indexOf(\" \", index);\n        if (pos == -1) throw new HttpException(\"Invalid HTTP date $date\");\n        tmp = date.substring(index, pos);\n        index = pos + 1;\n        weekday = wkdays.indexOf(tmp);\n        if (weekday != -1) {\n          format = formatAsctime;\n          return weekday;\n        }\n      } else {\n        tmp = date.substring(index, pos);\n        index = pos + 1;\n        weekday = wkdays.indexOf(tmp);\n        if (weekday != -1) {\n          format = formatRfc1123;\n          return weekday;\n        }\n        weekday = weekdays.indexOf(tmp);\n        if (weekday != -1) {\n          format = formatRfc850;\n          return weekday;\n        }\n      }\n      throw new HttpException(\"Invalid HTTP date $date\");\n    }\n\n    int expectMonth(String separator) {\n      int pos = date.indexOf(separator, index);\n      if (pos - index != 3) throw new HttpException(\"Invalid HTTP date $date\");\n      tmp = date.substring(index, pos);\n      index = pos + 1;\n      int month = months.indexOf(tmp);\n      if (month != -1) return month;\n      throw new HttpException(\"Invalid HTTP date $date\");\n    }\n\n    int expectNum(String separator) {\n      int pos;\n      if (separator.length > 0) {\n        pos = date.indexOf(separator, index);\n      } else {\n        pos = date.length;\n      }\n      String tmp = date.substring(index, pos);\n      index = pos + separator.length;\n      try {\n        int value = int.parse(tmp);\n        return value;\n      } on FormatException catch (e) {\n        throw new HttpException(\"Invalid HTTP date $date\");\n      }\n    }\n\n    void expectEnd() {\n      if (index != date.length) {\n        throw new HttpException(\"Invalid HTTP date $date\");\n      }\n    }\n\n    int weekday = expectWeekday();\n    int day;\n    int month;\n    int year;\n    int hours;\n    int minutes;\n    int seconds;\n    if (format == formatAsctime) {\n      month = expectMonth(\" \");\n      if (date.codeUnitAt(index) == SP) index++;\n      day = expectNum(\" \");\n      hours = expectNum(\":\");\n      minutes = expectNum(\":\");\n      seconds = expectNum(\" \");\n      year = expectNum(\"\");\n    } else {\n      expect(\" \");\n      day = expectNum(format == formatRfc1123 ? \" \" : \"-\");\n      month = expectMonth(format == formatRfc1123 ? \" \" : \"-\");\n      year = expectNum(\" \");\n      hours = expectNum(\":\");\n      minutes = expectNum(\":\");\n      seconds = expectNum(\" \");\n      expect(\"GMT\");\n    }\n    expectEnd();\n    return new DateTime.utc(year, month + 1, day, hours, minutes, seconds, 0);\n  }\n\n  // Parse a cookie date string.\n  static DateTime _parseCookieDate(String date) {\n    const List monthsLowerCase = const [\"jan\", \"feb\", \"mar\", \"apr\", \"may\",\n                                        \"jun\", \"jul\", \"aug\", \"sep\", \"oct\",\n                                        \"nov\", \"dec\"];\n\n    int position = 0;\n\n    void error() {\n      throw new HttpException(\"Invalid cookie date $date\");\n    }\n\n    bool isEnd() => position == date.length;\n\n    bool isDelimiter(String s) {\n      int char = s.codeUnitAt(0);\n      if (char == 0x09) return true;\n      if (char >= 0x20 && char <= 0x2F) return true;\n      if (char >= 0x3B && char <= 0x40) return true;\n      if (char >= 0x5B && char <= 0x60) return true;\n      if (char >= 0x7B && char <= 0x7E) return true;\n      return false;\n    }\n\n    bool isNonDelimiter(String s) {\n      int char = s.codeUnitAt(0);\n      if (char >= 0x00 && char <= 0x08) return true;\n      if (char >= 0x0A && char <= 0x1F) return true;\n      if (char >= 0x30 && char <= 0x39) return true;  // Digit\n      if (char == 0x3A) return true;  // ':'\n      if (char >= 0x41 && char <= 0x5A) return true;  // Alpha\n      if (char >= 0x61 && char <= 0x7A) return true;  // Alpha\n      if (char >= 0x7F && char <= 0xFF) return true;  // Alpha\n      return false;\n    }\n\n    bool isDigit(String s) {\n      int char = s.codeUnitAt(0);\n      if (char > 0x2F && char < 0x3A) return true;\n      return false;\n    }\n\n    int getMonth(String month) {\n      if (month.length < 3) return -1;\n      return monthsLowerCase.indexOf(month.substring(0, 3));\n    }\n\n    int toInt(String s) {\n      int index = 0;\n      for (; index < s.length && isDigit(s[index]); index++);\n      return int.parse(s.substring(0, index));\n    }\n\n    var tokens = [];\n    while (!isEnd()) {\n      while (!isEnd() && isDelimiter(date[position])) position++;\n      int start = position;\n      while (!isEnd() && isNonDelimiter(date[position])) position++;\n      tokens.add(date.substring(start, position).toLowerCase());\n      while (!isEnd() && isDelimiter(date[position])) position++;\n    }\n\n    String timeStr;\n    String dayOfMonthStr;\n    String monthStr;\n    String yearStr;\n\n    for (var token in tokens) {\n      if (token.length < 1) continue;\n      if (timeStr == null && token.length >= 5 && isDigit(token[0]) &&\n          (token[1] == \":\" || (isDigit(token[1]) && token[2] == \":\"))) {\n        timeStr = token;\n      } else if (dayOfMonthStr == null && isDigit(token[0])) {\n        dayOfMonthStr = token;\n      } else if (monthStr == null && getMonth(token) >= 0) {\n        monthStr = token;\n      } else if (yearStr == null && token.length >= 2 &&\n                 isDigit(token[0]) && isDigit(token[1])) {\n        yearStr = token;\n      }\n    }\n\n    if (timeStr == null || dayOfMonthStr == null ||\n        monthStr == null || yearStr == null) {\n      error();\n    }\n\n    int year = toInt(yearStr);\n    if (year >= 70 && year <= 99) year += 1900;\n    else if (year >= 0 && year <= 69) year += 2000;\n    if (year < 1601) error();\n\n    int dayOfMonth = toInt(dayOfMonthStr);\n    if (dayOfMonth < 1 || dayOfMonth > 31) error();\n\n    int month = getMonth(monthStr) + 1;\n\n    var timeList = timeStr.split(\":\");\n    if (timeList.length != 3) error();\n    int hour = toInt(timeList[0]);\n    int minute = toInt(timeList[1]);\n    int second = toInt(timeList[2]);\n    if (hour > 23) error();\n    if (minute > 59) error();\n    if (second > 59) error();\n\n    return new DateTime.utc(year, month, dayOfMonth, hour, minute, second, 0);\n  }\n}\n\u0000","sdk:/sdk/lib/io/http.dart":"// Copyright (c) 2013, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\npart of dart.io;\n\n/**\n * HTTP status codes.\n */\nabstract class HttpStatus {\n  static const int CONTINUE = 100;\n  static const int SWITCHING_PROTOCOLS = 101;\n  static const int OK = 200;\n  static const int CREATED = 201;\n  static const int ACCEPTED = 202;\n  static const int NON_AUTHORITATIVE_INFORMATION = 203;\n  static const int NO_CONTENT = 204;\n  static const int RESET_CONTENT = 205;\n  static const int PARTIAL_CONTENT = 206;\n  static const int MULTIPLE_CHOICES = 300;\n  static const int MOVED_PERMANENTLY = 301;\n  static const int FOUND = 302;\n  static const int MOVED_TEMPORARILY = 302; // Common alias for FOUND.\n  static const int SEE_OTHER = 303;\n  static const int NOT_MODIFIED = 304;\n  static const int USE_PROXY = 305;\n  static const int TEMPORARY_REDIRECT = 307;\n  static const int BAD_REQUEST = 400;\n  static const int UNAUTHORIZED = 401;\n  static const int PAYMENT_REQUIRED = 402;\n  static const int FORBIDDEN = 403;\n  static const int NOT_FOUND = 404;\n  static const int METHOD_NOT_ALLOWED = 405;\n  static const int NOT_ACCEPTABLE = 406;\n  static const int PROXY_AUTHENTICATION_REQUIRED = 407;\n  static const int REQUEST_TIMEOUT = 408;\n  static const int CONFLICT = 409;\n  static const int GONE = 410;\n  static const int LENGTH_REQUIRED = 411;\n  static const int PRECONDITION_FAILED = 412;\n  static const int REQUEST_ENTITY_TOO_LARGE = 413;\n  static const int REQUEST_URI_TOO_LONG = 414;\n  static const int UNSUPPORTED_MEDIA_TYPE = 415;\n  static const int REQUESTED_RANGE_NOT_SATISFIABLE = 416;\n  static const int EXPECTATION_FAILED = 417;\n  static const int INTERNAL_SERVER_ERROR = 500;\n  static const int NOT_IMPLEMENTED = 501;\n  static const int BAD_GATEWAY = 502;\n  static const int SERVICE_UNAVAILABLE = 503;\n  static const int GATEWAY_TIMEOUT = 504;\n  static const int HTTP_VERSION_NOT_SUPPORTED = 505;\n  // Client generated status code.\n  static const int NETWORK_CONNECT_TIMEOUT_ERROR = 599;\n}\n\n\n/**\n * A server that delivers content, such as web pages, using the HTTP protocol.\n *\n * The HttpServer is a [Stream] that provides [HttpRequest] objects. Each\n * HttpRequest has an associated [HttpResponse] object.\n * The server responds to a request by writing to that HttpResponse object.\n * The following example shows how to bind an HttpServer to an IPv6\n * [InternetAddress] on port 80 (the standard port for HTTP servers)\n * and how to listen for requests.\n * Port 80 is the default HTTP port. However, on most systems accessing\n * this requires super-user privileges. For local testing consider\n * using a non-reserved port (1024 and above).\n *\n *     import 'dart:io';\n *\n *     main() {\n *       HttpServer\n *           .bind(InternetAddress.ANY_IP_V6, 80)\n *           .then((server) {\n *             server.listen((HttpRequest request) {\n *               request.response.write('Hello, world!');\n *               request.response.close();\n *             });\n *           });\n *     }\n *\n * Incomplete requests, in which all or part of the header is missing, are\n * ignored, and no exceptions or HttpRequest objects are generated for them.\n * Likewise, when writing to an HttpResponse, any [Socket] exceptions are\n * ignored and any future writes are ignored.\n *\n * The HttpRequest exposes the request headers and provides the request body,\n * if it exists, as a Stream of data. If the body is unread, it is drained\n * when the server writes to the HttpResponse or closes it.\n *\n * ## Bind with a secure HTTPS connection\n *\n * Use [bindSecure] to create an HTTPS server.\n *\n * The server presents a certificate to the client. In the following\n * example, the certificate is named `localhost_cert` and comes from\n * the database found in the `pkcert` directory.\n *\n *     import 'dart:io';\n *     import \"dart:isolate\";\n *\n *     main() {\n *       var testPkcertDatabase = Platform.script.resolve('pkcert')\n *                                        .toFilePath();\n *       SecureSocket.initialize(database: testPkcertDatabase,\n *                               password: 'dartdart');\n *\n *       HttpServer\n *           .bindSecure(InternetAddress.ANY_IP_V6,\n *                       443,\n *                       certificateName: 'localhost_cert')\n *           .then((server) {\n *             server.listen((HttpRequest request) {\n *               request.response.write('Hello, world!');\n *               request.response.close();\n *             });\n *           });\n *     }\n *\n * The certificate database is managed using the Mozilla certutil tool (see\n * [NSS Tools certutil](https://developer.mozilla.org/en-US/docs/NSS/tools/NSS_Tools_certutil)).\n * Dart uses the NSS library to handle SSL, and the Mozilla certutil\n * must be used to manipulate the certificate database.\n *\n * ## Connect to a server socket\n *\n * You can use the [listenOn] constructor to attach an HTTP server to\n * a [ServerSocket].\n *\n *     import 'dart:io';\n *\n *     main() {\n *       ServerSocket.bind(InternetAddress.ANY_IP_V6, 80)\n *         .then((serverSocket) {\n *           HttpServer httpserver = new HttpServer.listenOn(serverSocket);\n *           serverSocket.listen((Socket socket) {\n *             socket.write('Hello, client.');\n *           });\n *         });\n *     }\n *\n * ## Other resources\n *\n * * HttpServer is a Stream. Refer to the [Stream] class for information\n * about the streaming qualities of an HttpServer.\n * Pausing the subscription of the stream, pauses at the OS level.\n *\n * * The [http_server](https://pub.dartlang.org/packages/http_server)\n * package on pub.dartlang.org contains a set of high-level classes that,\n * together with this class, makes it easy to provide content through HTTP\n * servers.\n */\nabstract class HttpServer implements Stream<HttpRequest> {\n  /**\n   * Get and set the default value of the `Server` header for all responses\n   * generated by this [HttpServer].\n   *\n   * If [serverHeader] is `null`, no `Server` header will be added to each\n   * response.\n   *\n   * The default value is `null`.\n   */\n  String serverHeader;\n\n  /**\n   * Default set of headers added to all response objects.\n   *\n   * By default the following headers are in this set:\n   *\n   *    Content-Type: text/plain; charset=utf-8\n   *    X-Frame-Options: SAMEORIGIN\n   *    X-Content-Type-Options: nosniff\n   *    X-XSS-Protection: 1; mode=block\n   *\n   * If the `Server` header is added here and the `serverHeader` is set as\n   * well then the value of `serverHeader` takes precedence.\n   */\n  HttpHeaders get defaultResponseHeaders;\n\n  /**\n   * Get or set the timeout used for idle keep-alive connections. If no further\n   * request is seen within [idleTimeout] after the previous request was\n   * completed, the connection is dropped.\n   *\n   * Default is 120 seconds.\n   *\n   * Note that it may take up to `2 * idleTimeout` before a idle connection is\n   * aborted.\n   *\n   * To disable, set [idleTimeout] to `null`.\n   */\n  Duration idleTimeout;\n\n\n  /**\n   * Starts listening for HTTP requests on the specified [address] and\n   * [port].\n   *\n   * The [address] can either be a [String] or an\n   * [InternetAddress]. If [address] is a [String], [bind] will\n   * perform a [InternetAddress.lookup] and use the first value in the\n   * list. To listen on the loopback adapter, which will allow only\n   * incoming connections from the local host, use the value\n   * [InternetAddress.LOOPBACK_IP_V4] or\n   * [InternetAddress.LOOPBACK_IP_V6]. To allow for incoming\n   * connection from the network use either one of the values\n   * [InternetAddress.ANY_IP_V4] or [InternetAddress.ANY_IP_V6] to\n   * bind to all interfaces or the IP address of a specific interface.\n   *\n   * If an IP version 6 (IPv6) address is used, both IP version 6\n   * (IPv6) and version 4 (IPv4) connections will be accepted. To\n   * restrict this to version 6 (IPv6) only, use [HttpServer.listenOn]\n   * with a [ServerSocket] configured for IP version 6 connections\n   * only.\n   *\n   * If [port] has the value [:0:] an ephemeral port will be chosen by\n   * the system. The actual port used can be retrieved using the\n   * [port] getter.\n   *\n   * The optional argument [backlog] can be used to specify the listen\n   * backlog for the underlying OS listen setup. If [backlog] has the\n   * value of [:0:] (the default) a reasonable value will be chosen by\n   * the system.\n   */\n  static Future<HttpServer> bind(address,\n                                 int port,\n                                 {int backlog: 0})\n      => _HttpServer.bind(address, port, backlog);\n\n  /**\n   * The [address] can either be a [String] or an\n   * [InternetAddress]. If [address] is a [String], [bind] will\n   * perform a [InternetAddress.lookup] and use the first value in the\n   * list. To listen on the loopback adapter, which will allow only\n   * incoming connections from the local host, use the value\n   * [InternetAddress.LOOPBACK_IP_V4] or\n   * [InternetAddress.LOOPBACK_IP_V6]. To allow for incoming\n   * connection from the network use either one of the values\n   * [InternetAddress.ANY_IP_V4] or [InternetAddress.ANY_IP_V6] to\n   * bind to all interfaces or the IP address of a specific interface.\n   *\n   * If an IP version 6 (IPv6) address is used, both IP version 6\n   * (IPv6) and version 4 (IPv4) connections will be accepted. To\n   * restrict this to version 6 (IPv6) only, use [HttpServer.listenOn]\n   * with a [ServerSocket] configured for IP version 6 connections\n   * only.\n   *\n   * If [port] has the value [:0:] an ephemeral port will be chosen by\n   * the system. The actual port used can be retrieved using the\n   * [port] getter.\n   *\n   * The optional argument [backlog] can be used to specify the listen\n   * backlog for the underlying OS listen setup. If [backlog] has the\n   * value of [:0:] (the default) a reasonable value will be chosen by\n   * the system.\n   *\n   * The certificate with nickname or distinguished name (DN) [certificateName]\n   * is looked up in the certificate database, and is used as the server\n   * certificate. If [requestClientCertificate] is true, the server will\n   * request clients to authenticate with a client certificate.\n   */\n\n  static Future<HttpServer> bindSecure(address,\n                                       int port,\n                                       {int backlog: 0,\n                                        String certificateName,\n                                        bool requestClientCertificate: false})\n      => _HttpServer.bindSecure(address,\n                                port,\n                                backlog,\n                                certificateName,\n                                requestClientCertificate);\n\n  /**\n   * Attaches the HTTP server to an existing [ServerSocket]. When the\n   * [HttpServer] is closed, the [HttpServer] will just detach itself,\n   * closing current connections but not closing [serverSocket].\n   */\n  factory HttpServer.listenOn(ServerSocket serverSocket)\n      => new _HttpServer.listenOn(serverSocket);\n\n  /**\n   * Permanently stops this [HttpServer] from listening for new\n   * connections.  This closes the [Stream] of [HttpRequest]s with a\n   * done event. The returned future completes when the server is\n   * stopped. For a server started using [bind] or [bindSecure] this\n   * means that the port listened on no longer in use.\n   *\n   * If [force] is `true`, active connections will be closed immediately.\n   */\n  Future close({bool force: false});\n\n  /**\n   * Returns the port that the server is listening on. This can be\n   * used to get the actual port used when a value of 0 for [:port:] is\n   * specified in the [bind] or [bindSecure] call.\n   */\n  int get port;\n\n  /**\n   * Returns the address that the server is listening on. This can be\n   * used to get the actual address used, when the address is fetched by\n   * a lookup from a hostname.\n   */\n  InternetAddress get address;\n\n  /**\n   * Sets the timeout, in seconds, for sessions of this [HttpServer].\n   * The default timeout is 20 minutes.\n   */\n  set sessionTimeout(int timeout);\n\n  /**\n   * Returns an [HttpConnectionsInfo] object summarizing the number of\n   * current connections handled by the server.\n   */\n  HttpConnectionsInfo connectionsInfo();\n}\n\n\n/**\n * Summary statistics about an [HttpServer]s current socket connections.\n */\nclass HttpConnectionsInfo {\n  /**\n   * Total number of socket connections.\n   */\n  int total = 0;\n\n  /**\n   * Number of active connections where actual request/response\n   * processing is active.\n   */\n  int active = 0;\n\n  /**\n   * Number of idle connections held by clients as persistent connections.\n   */\n  int idle = 0;\n\n  /**\n   * Number of connections which are preparing to close. Note: These\n   * connections are also part of the [:active:] count as they might\n   * still be sending data to the client before finally closing.\n   */\n  int closing = 0;\n}\n\n\n/**\n * Headers for HTTP requests and responses.\n *\n * In some situations, headers are immutable:\n *\n * * HttpRequest and HttpClientResponse always have immutable headers.\n *\n * * HttpResponse and HttpClientRequest have immutable headers\n *   from the moment the body is written to.\n *\n * In these situations, the mutating methods throw exceptions.\n *\n * For all operations on HTTP headers the header name is\n * case-insensitive.\n *\n * To set the value of a header use the `set()` method:\n *\n *     request.headers.set(HttpHeaders.CACHE_CONTROL,\n                           'max-age=3600, must-revalidate');\n *\n * To retrieve the value of a header use the `value()` method:\n *\n *     print(request.headers.value(HttpHeaders.USER_AGENT));\n *\n * An HttpHeaders object holds a list of values for each name\n * as the standard allows. In most cases a name holds only a single value,\n * The most common mode of operation is to use `set()` for setting a value,\n * and `value()` for retrieving a value.\n */\nabstract class HttpHeaders {\n  static const ACCEPT = \"accept\";\n  static const ACCEPT_CHARSET = \"accept-charset\";\n  static const ACCEPT_ENCODING = \"accept-encoding\";\n  static const ACCEPT_LANGUAGE = \"accept-language\";\n  static const ACCEPT_RANGES = \"accept-ranges\";\n  static const AGE = \"age\";\n  static const ALLOW = \"allow\";\n  static const AUTHORIZATION = \"authorization\";\n  static const CACHE_CONTROL = \"cache-control\";\n  static const CONNECTION = \"connection\";\n  static const CONTENT_ENCODING = \"content-encoding\";\n  static const CONTENT_LANGUAGE = \"content-language\";\n  static const CONTENT_LENGTH = \"content-length\";\n  static const CONTENT_LOCATION = \"content-location\";\n  static const CONTENT_MD5 = \"content-md5\";\n  static const CONTENT_RANGE = \"content-range\";\n  static const CONTENT_TYPE = \"content-type\";\n  static const DATE = \"date\";\n  static const ETAG = \"etag\";\n  static const EXPECT = \"expect\";\n  static const EXPIRES = \"expires\";\n  static const FROM = \"from\";\n  static const HOST = \"host\";\n  static const IF_MATCH = \"if-match\";\n  static const IF_MODIFIED_SINCE = \"if-modified-since\";\n  static const IF_NONE_MATCH = \"if-none-match\";\n  static const IF_RANGE = \"if-range\";\n  static const IF_UNMODIFIED_SINCE = \"if-unmodified-since\";\n  static const LAST_MODIFIED = \"last-modified\";\n  static const LOCATION = \"location\";\n  static const MAX_FORWARDS = \"max-forwards\";\n  static const PRAGMA = \"pragma\";\n  static const PROXY_AUTHENTICATE = \"proxy-authenticate\";\n  static const PROXY_AUTHORIZATION = \"proxy-authorization\";\n  static const RANGE = \"range\";\n  static const REFERER = \"referer\";\n  static const RETRY_AFTER = \"retry-after\";\n  static const SERVER = \"server\";\n  static const TE = \"te\";\n  static const TRAILER = \"trailer\";\n  static const TRANSFER_ENCODING = \"transfer-encoding\";\n  static const UPGRADE = \"upgrade\";\n  static const USER_AGENT = \"user-agent\";\n  static const VARY = \"vary\";\n  static const VIA = \"via\";\n  static const WARNING = \"warning\";\n  static const WWW_AUTHENTICATE = \"www-authenticate\";\n\n  // Cookie headers from RFC 6265.\n  static const COOKIE = \"cookie\";\n  static const SET_COOKIE = \"set-cookie\";\n\n  static const GENERAL_HEADERS = const [CACHE_CONTROL,\n                                        CONNECTION,\n                                        DATE,\n                                        PRAGMA,\n                                        TRAILER,\n                                        TRANSFER_ENCODING,\n                                        UPGRADE,\n                                        VIA,\n                                        WARNING];\n\n  static const ENTITY_HEADERS = const [ALLOW,\n                                       CONTENT_ENCODING,\n                                       CONTENT_LANGUAGE,\n                                       CONTENT_LENGTH,\n                                       CONTENT_LOCATION,\n                                       CONTENT_MD5,\n                                       CONTENT_RANGE,\n                                       CONTENT_TYPE,\n                                       EXPIRES,\n                                       LAST_MODIFIED];\n\n\n  static const RESPONSE_HEADERS = const [ACCEPT_RANGES,\n                                         AGE,\n                                         ETAG,\n                                         LOCATION,\n                                         PROXY_AUTHENTICATE,\n                                         RETRY_AFTER,\n                                         SERVER,\n                                         VARY,\n                                         WWW_AUTHENTICATE];\n\n  static const REQUEST_HEADERS = const [ACCEPT,\n                                        ACCEPT_CHARSET,\n                                        ACCEPT_ENCODING,\n                                        ACCEPT_LANGUAGE,\n                                        AUTHORIZATION,\n                                        EXPECT,\n                                        FROM,\n                                        HOST,\n                                        IF_MATCH,\n                                        IF_MODIFIED_SINCE,\n                                        IF_NONE_MATCH,\n                                        IF_RANGE,\n                                        IF_UNMODIFIED_SINCE,\n                                        MAX_FORWARDS,\n                                        PROXY_AUTHORIZATION,\n                                        RANGE,\n                                        REFERER,\n                                        TE,\n                                        USER_AGENT];\n\n  /**\n   * Gets and sets the date. The value of this property will\n   * reflect the 'date' header.\n   */\n  DateTime date;\n\n  /**\n   * Gets and sets the expiry date. The value of this property will\n   * reflect the 'expires' header.\n   */\n  DateTime expires;\n\n  /**\n   * Gets and sets the \"if-modified-since\" date. The value of this property will\n   * reflect the \"if-modified-since\" header.\n   */\n  DateTime ifModifiedSince;\n\n  /**\n   * Gets and sets the host part of the 'host' header for the\n   * connection.\n   */\n  String host;\n\n  /**\n   * Gets and sets the port part of the 'host' header for the\n   * connection.\n   */\n  int port;\n\n  /**\n   * Gets and sets the content type. Note that the content type in the\n   * header will only be updated if this field is set\n   * directly. Mutating the returned current value will have no\n   * effect.\n   */\n  ContentType contentType;\n\n  /**\n   * Gets and sets the content length header value.\n   */\n  int contentLength;\n\n  /**\n   * Gets and sets the persistent connection header value.\n   */\n  bool persistentConnection;\n\n  /**\n   * Gets and sets the chunked transfer encoding header value.\n   */\n  bool chunkedTransferEncoding;\n\n  /**\n   * Returns the list of values for the header named [name]. If there\n   * is no header with the provided name, [:null:] will be returned.\n   */\n  List<String> operator[](String name);\n\n  /**\n   * Convenience method for the value for a single valued header. If\n   * there is no header with the provided name, [:null:] will be\n   * returned. If the header has more than one value an exception is\n   * thrown.\n   */\n  String value(String name);\n\n  /**\n   * Adds a header value. The header named [name] will have the value\n   * [value] added to its list of values. Some headers are single\n   * valued, and for these adding a value will replace the previous\n   * value. If the value is of type DateTime a HTTP date format will be\n   * applied. If the value is a [:List:] each element of the list will\n   * be added separately. For all other types the default [:toString:]\n   * method will be used.\n   */\n  void add(String name, Object value);\n\n  /**\n   * Sets a header. The header named [name] will have all its values\n   * cleared before the value [value] is added as its value.\n   */\n  void set(String name, Object value);\n\n  /**\n   * Removes a specific value for a header name. Some headers have\n   * system supplied values and for these the system supplied values\n   * will still be added to the collection of values for the header.\n   */\n  void remove(String name, Object value);\n\n  /**\n   * Removes all values for the specified header name. Some headers\n   * have system supplied values and for these the system supplied\n   * values will still be added to the collection of values for the\n   * header.\n   */\n  void removeAll(String name);\n\n  /**\n   * Enumerates the headers, applying the function [f] to each\n   * header. The header name passed in [:name:] will be all lower\n   * case.\n   */\n  void forEach(void f(String name, List<String> values));\n\n  /**\n   * Disables folding for the header named [name] when sending the HTTP\n   * header. By default, multiple header values are folded into a\n   * single header line by separating the values with commas. The\n   * 'set-cookie' header has folding disabled by default.\n   */\n  void noFolding(String name);\n\n  /**\n   * Remove all headers. Some headers have system supplied values and\n   * for these the system supplied values will still be added to the\n   * collection of values for the header.\n   */\n  void clear();\n}\n\n\n/**\n * Representation of a header value in the form:\n *\n *   [:value; parameter1=value1; parameter2=value2:]\n *\n * [HeaderValue] can be used to conveniently build and parse header\n * values on this form.\n *\n * To build an [:accepts:] header with the value\n *\n *     text/plain; q=0.3, text/html\n *\n * use code like this:\n *\n *     HttpClientRequest request = ...;\n *     var v = new HeaderValue(\"text/plain\", {\"q\": \"0.3\"});\n *     request.headers.add(HttpHeaders.ACCEPT, v);\n *     request.headers.add(HttpHeaders.ACCEPT, \"text/html\");\n *\n * To parse the header values use the [:parse:] static method.\n *\n *     HttpRequest request = ...;\n *     List<String> values = request.headers[HttpHeaders.ACCEPT];\n *     values.forEach((value) {\n *       HeaderValue v = HeaderValue.parse(value);\n *       // Use v.value and v.parameters\n *     });\n *\n * An instance of [HeaderValue] is immutable.\n */\nabstract class HeaderValue {\n  /**\n   * Creates a new header value object setting the value and parameters.\n   */\n  factory HeaderValue([String value = \"\", Map<String, String> parameters]) {\n    return new _HeaderValue(value, parameters);\n  }\n\n  /**\n   * Creates a new header value object from parsing a header value\n   * string with both value and optional parameters.\n   */\n  static HeaderValue parse(String value,\n                           {String parameterSeparator: \";\",\n                            bool preserveBackslash: false}) {\n    return _HeaderValue.parse(value,\n                              parameterSeparator: parameterSeparator,\n                              preserveBackslash: preserveBackslash);\n  }\n\n  /**\n   * Gets the header value.\n   */\n  String get value;\n\n  /**\n   * Gets the map of parameters.\n   *\n   * This map cannot be modified. invoking any operation which would\n   * modify the map will throw [UnsupportedError].\n   */\n  Map<String, String> get parameters;\n\n  /**\n   * Returns the formatted string representation in the form:\n   *\n   *     value; parameter1=value1; parameter2=value2\n   */\n  String toString();\n}\n\nabstract class HttpSession implements Map {\n  /**\n   * Gets the id for the current session.\n   */\n  String get id;\n\n  /**\n   * Destroys the session. This will terminate the session and any further\n   * connections with this id will be given a new id and session.\n   */\n  void destroy();\n\n  /**\n   * Sets a callback that will be called when the session is timed out.\n   */\n  void set onTimeout(void callback());\n\n  /**\n   * Is true if the session has not been sent to the client yet.\n   */\n  bool get isNew;\n}\n\n\n/**\n * Representation of a content type. An instance of [ContentType] is\n * immutable.\n */\nabstract class ContentType implements HeaderValue {\n  /**\n   * Content type for plain text using UTF-8 encoding.\n   *\n   *     text/plain; charset=utf-8\n   */\n  static final TEXT = new ContentType(\"text\", \"plain\", charset: \"utf-8\");\n\n  /**\n   *  Content type for HTML using UTF-8 encoding.\n   *\n   *     text/html; charset=utf-8\n   */\n  static final HTML = new ContentType(\"text\", \"html\", charset: \"utf-8\");\n\n  /**\n   *  Content type for JSON using UTF-8 encoding.\n   *\n   *     application/json; charset=utf-8\n   */\n  static final JSON = new ContentType(\"application\", \"json\", charset: \"utf-8\");\n\n  /**\n   *  Content type for binary data.\n   *\n   *     application/octet-stream\n   */\n  static final BINARY = new ContentType(\"application\", \"octet-stream\");\n\n  /**\n   * Creates a new content type object setting the primary type and\n   * sub type. The charset and additional parameters can also be set\n   * using [charset] and [parameters]. If charset is passed and\n   * [parameters] contains charset as well the passed [charset] will\n   * override the value in parameters. Keys and values passed in\n   * parameters will be converted to lower case.\n   */\n  factory ContentType(String primaryType,\n                      String subType,\n                      {String charset, Map<String, String> parameters}) {\n    return new _ContentType(primaryType, subType, charset, parameters);\n  }\n\n  /**\n   * Creates a new content type object from parsing a Content-Type\n   * header value. As primary type, sub type and parameter names and\n   * values are not case sensitive all these values will be converted\n   * to lower case. Parsing this string\n   *\n   *     text/html; charset=utf-8\n   *\n   * will create a content type object with primary type [:text:], sub\n   * type [:html:] and parameter [:charset:] with value [:utf-8:].\n   */\n  static ContentType parse(String value) {\n    return _ContentType.parse(value);\n  }\n\n  /**\n   * Gets the mime-type, without any parameters.\n   */\n  String get mimeType;\n\n  /**\n   * Gets the primary type.\n   */\n  String get primaryType;\n\n  /**\n   * Gets the sub type.\n   */\n  String get subType;\n\n  /**\n   * Gets the character set.\n   */\n  String get charset;\n}\n\n\n/**\n * Representation of a cookie. For cookies received by the server as\n * Cookie header values only [:name:] and [:value:] fields will be\n * set. When building a cookie for the 'set-cookie' header in the server\n * and when receiving cookies in the client as 'set-cookie' headers all\n * fields can be used.\n */\nabstract class Cookie {\n  /**\n   * Gets and sets the name.\n   */\n  String name;\n\n  /**\n   * Gets and sets the value.\n   */\n  String value;\n\n  /**\n   * Gets and sets the expiry date.\n   */\n  DateTime expires;\n\n  /**\n   * Gets and sets the max age. A value of [:0:] means delete cookie\n   * now.\n   */\n  int maxAge;\n\n  /**\n   * Gets and sets the domain.\n   */\n  String domain;\n\n  /**\n   * Gets and sets the path.\n   */\n  String path;\n\n  /**\n   * Gets and sets whether this cookie is secure.\n   */\n  bool secure;\n\n  /**\n   * Gets and sets whether this cookie is HTTP only.\n   */\n  bool httpOnly;\n\n  /**\n   * Creates a new cookie optionally setting the name and value.\n   *\n   * By default the value of `httpOnly` will be set to `true`.\n   */\n  factory Cookie([String name, String value]) => new _Cookie(name, value);\n\n  /**\n   * Creates a new cookie by parsing a header value from a 'set-cookie'\n   * header.\n   */\n  factory Cookie.fromSetCookieValue(String value) {\n    return new _Cookie.fromSetCookieValue(value);\n  }\n\n  /**\n   * Returns the formatted string representation of the cookie. The\n   * string representation can be used for for setting the Cookie or\n   * 'set-cookie' headers\n   */\n  String toString();\n}\n\n\n/**\n * A server-side object\n * that contains the content of and information about an HTTP request.\n *\n * __Note__: Check out the\n * [http_server](http://pub.dartlang.org/packages/http_server)\n * package, which makes working with the low-level\n * dart:io HTTP server subsystem easier.\n *\n * `HttpRequest` objects are generated by an [HttpServer],\n * which listens for HTTP requests on a specific host and port.\n * For each request received, the HttpServer, which is a [Stream],\n * generates an `HttpRequest` object and adds it to the stream.\n *\n * An `HttpRequest` object delivers the body content of the request\n * as a stream of byte lists.\n * The object also contains information about the request,\n * such as the method, URI, and headers.\n *\n * In the following code, an HttpServer listens\n * for HTTP requests. When the server receives a request,\n * it uses the HttpRequest object's `method` property to dispatch requests.\n *\n *     final HOST = InternetAddress.LOOPBACK_IP_V4;\n *     final PORT = 80;\n *\n *     HttpServer.bind(HOST, PORT).then((_server) {\n *       _server.listen((HttpRequest request) {\n *         switch (request.method) {\n *           case 'GET':\n *             handleGetRequest(request);\n *             break;\n *           case 'POST':\n *             ...\n *         }\n *       },\n *       onError: handleError);    // listen() failed.\n *     }).catchError(handleError);\n *\n * An HttpRequest object provides access to the associated [HttpResponse]\n * object through the response property.\n * The server writes its response to the body of the HttpResponse object.\n * For example, here's a function that responds to a request:\n *\n *     void handleGetRequest(HttpRequest req) {\n *       HttpResponse res = req.response;\n *       res.write('Received request ${req.method}: ${req.uri.path}');\n *       res.close();\n *     }\n */\nabstract class HttpRequest implements Stream<List<int>> {\n  /**\n   * The content length of the request body.\n   *\n   * If the size of the request body is not known in advance,\n   * this value is -1.\n   */\n  int get contentLength;\n\n  /**\n   * The method, such as 'GET' or 'POST', for the request.\n   */\n  String get method;\n\n  /**\n   * The URI for the request.\n   *\n   * This provides access to the\n   * path, query string, and fragment identifier for the request.\n   */\n  Uri get uri;\n\n  /**\n   * The requested URI for the request.\n   *\n   * The returend URI is reconstructed by using http-header fields, to access\n   * otherwise lost information, e.g. host and scheme.\n   *\n   * To reconstruct the scheme, first 'X-Forwarded-Proto' is checked, and then\n   * falling back to server type.\n   *\n   * To reconstruct the host, fisrt 'X-Forwarded-Host' is checked, then 'Host'\n   * and finally calling back to server.\n   */\n  Uri get requestedUri;\n\n  /**\n   * The request headers.\n   *\n   * The returned [HttpHeaders] are immutable.\n   */\n  HttpHeaders get headers;\n\n  /**\n   * The cookies in the request, from the Cookie headers.\n   */\n  List<Cookie> get cookies;\n\n  /**\n   * The persistent connection state signaled by the client.\n   */\n  bool get persistentConnection;\n\n  /**\n   * The client certificate of the client making the request.\n   *\n   * This value is null if the connection is not a secure TLS or SSL connection,\n   * or if the server does not request a client certificate, or if the client\n   * does not provide one.\n   */\n  X509Certificate get certificate;\n\n  /**\n   * The session for the given request.\n   *\n   * If the session is\n   * being initialized by this call, [:isNew:] is true for the returned\n   * session.\n   * See [HttpServer.sessionTimeout] on how to change default timeout.\n   */\n  HttpSession get session;\n\n  /**\n   * The HTTP protocol version used in the request,\n   * either \"1.0\" or \"1.1\".\n   */\n  String get protocolVersion;\n\n  /**\n   * Information about the client connection.\n   *\n   * Returns [:null:] if the socket is not available.\n   */\n  HttpConnectionInfo get connectionInfo;\n\n  /**\n   * The [HttpResponse] object, used for sending back the response to the\n   * client.\n   *\n   * If the [contentLength] of the body isn't 0, and the body isn't being read,\n   * any write calls on the [HttpResponse] automatically drain the request\n   * body.\n   */\n  HttpResponse get response;\n}\n\n\n/**\n * An HTTP response, which returns the headers and data\n * from the server to the client in response to an HTTP request.\n *\n * Every HttpRequest object provides access to the associated [HttpResponse]\n * object through the `response` property.\n * The server sends its response to the client by writing to the\n * HttpResponse object.\n *\n * ## Writing the response\n *\n * This class implements [IOSink].\n * After the header has been set up, the methods\n * from IOSink, such as `writeln()`, can be used to write\n * the body of the HTTP response.\n * Use the `close()` method to close the response and send it to the client.\n *\n *     server.listen((HttpRequest request) {\n *       request.response.write('Hello, world!');\n *       request.response.close();\n *     });\n *\n * When one of the IOSink methods is used for the\n * first time, the request header is sent. Calling any methods that\n * change the header after it is sent throws an exception.\n *\n * ## Setting the headers\n *\n * The HttpResponse object has a number of properties for setting up\n * the HTTP headers of the response.\n * When writing string data through the IOSink, the encoding used\n * is determined from the \"charset\" parameter of the\n * \"Content-Type\" header.\n *\n *     HttpResponse response = ...\n *     response.headers.contentType\n *         = new ContentType(\"application\", \"json\", charset: \"utf-8\");\n *     response.write(...);  // Strings written will be UTF-8 encoded.\n *\n * If no charset is provided the default of ISO-8859-1 (Latin 1) will\n * be used.\n *\n *     HttpResponse response = ...\n *     response.headers.add(HttpHeaders.CONTENT_TYPE, \"text/plain\");\n *     response.write(...);  // Strings written will be ISO-8859-1 encoded.\n *\n * An exception is thrown if you use the `write()` method\n * while an unsupported content-type is set.\n */\nabstract class HttpResponse implements IOSink {\n  // TODO(ajohnsen): Add documentation of how to pipe a file to the response.\n  /**\n   * Gets and sets the content length of the response. If the size of\n   * the response is not known in advance set the content length to\n   * -1 - which is also the default if not set.\n   */\n  int contentLength;\n\n  /**\n   * Gets and sets the status code. Any integer value is accepted. For\n   * the official HTTP status codes use the fields from\n   * [HttpStatus]. If no status code is explicitly set the default\n   * value [HttpStatus.OK] is used.\n   *\n   * The status code must be set before the body is written\n   * to. Setting the status code after writing to the response body or\n   * closing the response will throw a `StateError`.\n   */\n  int statusCode;\n\n  /**\n   * Gets and sets the reason phrase. If no reason phrase is explicitly\n   * set a default reason phrase is provided.\n   *\n   * The reason phrase must be set before the body is written\n   * to. Setting the reason phrase after writing to the response body\n   * or closing the response will throw a `StateError`.\n   */\n  String reasonPhrase;\n\n  /**\n   * Gets and sets the persistent connection state. The initial value\n   * of this property is the persistent connection state from the\n   * request.\n   */\n  bool persistentConnection;\n\n  /**\n   * Set and get the [deadline] for the response. The deadline is timed from the\n   * time it's set. Setting a new deadline will override any previous deadline.\n   * When a deadline is exceeded, the response will be closed and any further\n   * data ignored.\n   *\n   * To disable a deadline, set the [deadline] to `null`.\n   *\n   * The [deadline] is `null` by default.\n   */\n  Duration deadline;\n\n  /**\n   * Get or set if the [HttpResponse] should buffer output.\n   *\n   * Default value is `true`.\n   *\n   * __Note__: Disabling buffering of the output can result in very poor\n   * performance, when writing many small chunks.\n   */\n  bool bufferOutput;\n\n  /**\n   * Returns the response headers.\n   *\n   * The response headers can be modified until the response body is\n   * written to or closed. After that they become immutable.\n   */\n  HttpHeaders get headers;\n\n  /**\n   * Cookies to set in the client (in the 'set-cookie' header).\n   */\n  List<Cookie> get cookies;\n\n  /**\n   * Respond with a redirect to [location].\n   *\n   * The URI in [location] should be absolute, but there are no checks\n   * to enforce that.\n   *\n   * By default the HTTP status code `HttpStatus.MOVED_TEMPORARILY`\n   * (`302`) is used for the redirect, but an alternative one can be\n   * specified using the [status] argument.\n   *\n   * This method will also call `close`, and the returned future is\n   * the furure returned by `close`.\n   */\n  Future redirect(Uri location, {int status: HttpStatus.MOVED_TEMPORARILY});\n\n  /**\n   * Detaches the underlying socket from the HTTP server. When the\n   * socket is detached the HTTP server will no longer perform any\n   * operations on it.\n   *\n   * This is normally used when a HTTP upgrade request is received\n   * and the communication should continue with a different protocol.\n   *\n   * If [writeHeaders] is `true`, the status line and [headers] will be written\n   * to the socket before it's detached. If `false`, the socket is detached\n   * immediately, without any data written to the socket. Default is `true`.\n   */\n  Future<Socket> detachSocket({bool writeHeaders: true});\n\n  /**\n   * Gets information about the client connection. Returns [:null:] if the\n   * socket is not available.\n   */\n  HttpConnectionInfo get connectionInfo;\n}\n\n\n/**\n * A client that receives content, such as web pages, from\n * a server using the HTTP protocol.\n *\n * HttpClient contains a number of methods to send an [HttpClientRequest]\n * to an Http server and receive an [HttpClientResponse] back.\n * For example, you can use the [get], [getUrl], [post], and [postUrl] methods\n * for GET and POST requests, respectively.\n *\n * ## Making a simple GET request: an example\n *\n * A `getUrl` request is a two-step process, triggered by two [Future]s.\n * When the first future completes with a [HttpClientRequest], the underlying\n * network connection has been established, but no data has been sent.\n * In the callback function for the first future, the HTTP headers and body\n * can be set on the request. Either the first write to the request object\n * or a call to [close] sends the request to the server.\n *\n * When the HTTP response is received from the server,\n * the second future, which is returned by close,\n * completes with an [HttpClientResponse] object.\n * This object provides access to the headers and body of the response.\n * The body is available as a stream implemented by HttpClientResponse.\n * If a body is present, it must be read. Otherwise, it leads to resource\n * leaks. Consider using [HttpClientResponse.drain] if the body is unused.\n *\n *     HttpClient client = new HttpClient();\n *     client.getUrl(Uri.parse(\"http://www.example.com/\"))\n *         .then((HttpClientRequest request) {\n *           // Optionally set up headers...\n *           // Optionally write to the request object...\n *           // Then call close.\n *           ...\n *           return request.close();\n *         })\n *         .then((HttpClientResponse response) {\n *           // Process the response.\n *           ...\n *         });\n *\n * The future for [HttpClientRequest] is created by methods such as\n * [getUrl] and [open].\n *\n * ## Headers\n *\n * All HttpClient requests set the following header by default:\n *\n *     Accept-Encoding: gzip\n *\n * This allows the HTTP server to use gzip compression for the body if\n * possible. If this behavior is not desired set the\n * `Accept-Encoding` header to something else.\n * To turn off gzip compression of the response, clear this header:\n *\n *      request.headers.removeAll(HttpHeaders.ACCEPT_ENCODING)\n *\n * ## Closing the HttpClient\n *\n * The HttpClient supports persistent connections and caches network\n * connections to reuse them for multiple requests whenever\n * possible. This means that network connections can be kept open for\n * some time after a request has completed. Use HttpClient.close\n * to force the HttpClient object to shut down and to close the idle\n * network connections.\n *\n * ## Turning proxies on and off\n *\n * By default the HttpClient uses the proxy configuration available\n * from the environment, see [findProxyFromEnvironment]. To turn off\n * the use of proxies set the [findProxy] property to\n * [:null:].\n *\n *     HttpClient client = new HttpClient();\n *     client.findProxy = null;\n */\nabstract class HttpClient {\n  static const int DEFAULT_HTTP_PORT = 80;\n  static const int DEFAULT_HTTPS_PORT = 443;\n\n  /**\n   * Get and set the idle timeout of non-active persistent (keep-alive)\n   * connections. The default value is 15 seconds.\n   */\n  Duration idleTimeout;\n\n  /**\n   * Get and set the maximum number of live connections, to a single host.\n   *\n   * Increasing this number may lower performance and take up unwanted\n   * system resources.\n   *\n   * To disable, set to `null`.\n   *\n   * Default is `null`.\n   */\n  int maxConnectionsPerHost;\n\n  /**\n   * Get and set whether the body of a response will be automatically\n   * uncompressed.\n   *\n   * The body of an HTTP response can be compressed. In most\n   * situations providing the un-compressed body is most\n   * convenient. Therefore the default behavior is to un-compress the\n   * body. However in some situations (e.g. implementing a transparent\n   * proxy) keeping the uncompressed stream is required.\n   *\n   * NOTE: Headers in from the response is never modified. This means\n   * that when automatic un-compression is turned on the value of the\n   * header `Content-Length` will reflect the length of the original\n   * compressed body. Likewise the header `Content-Encoding` will also\n   * have the original value indicating compression.\n   *\n   * NOTE: Automatic un-compression is only performed if the\n   * `Content-Encoding` header value is `gzip`.\n   *\n   * This value affects all responses produced by this client after the\n   * value is changed.\n   *\n   * To disable, set to `false`.\n   *\n   * Default is `true`.\n   */\n  bool autoUncompress;\n\n  /**\n   * Set and get the default value of the `User-Agent` header for all requests\n   * generated by this [HttpClient]. The default value is\n   * `Dart/<version> (dart:io)`.\n   *\n   * If the userAgent is set to `null`, no default `User-Agent` header will be\n   * added to each request.\n   */\n  String userAgent;\n\n  factory HttpClient() => new _HttpClient();\n\n  /**\n   * Opens a HTTP connection.\n   *\n   * The HTTP method to use is specified in [method], the server is\n   * specified using [host] and [port], and the path (including\n   * possible fragment and query) is specified using [path].\n   *\n   * The `Host` header for the request will be set to the value\n   * [host]:[port]. This can be overridden through the\n   * [HttpClientRequest] interface before the request is sent.  NOTE\n   * if [host] is an IP address this will still be set in the `Host`\n   * header.\n   *\n   * For additional information on the sequence of events during an\n   * HTTP transaction, and the objects returned by the futures, see\n   * the overall documentation for the class [HttpClient].\n   */\n  Future<HttpClientRequest> open(String method,\n                                 String host,\n                                 int port,\n                                 String path);\n\n  /**\n   * Opens a HTTP connection.\n   *\n   * The HTTP method is specified in [method] and the URL to use in\n   * [url].\n   *\n   * The `Host` header for the request will be set to the value\n   * [host]:[port]. This can be overridden through the\n   * [HttpClientRequest] interface before the request is sent.  NOTE\n   * if [host] is an IP address this will still be set in the `Host`\n   * header.\n   *\n   * For additional information on the sequence of events during an\n   * HTTP transaction, and the objects returned by the futures, see\n   * the overall documentation for the class [HttpClient].\n   */\n  Future<HttpClientRequest> openUrl(String method, Uri url);\n\n  /**\n   * Opens a HTTP connection using the GET method.\n   *\n   * The server is specified using [host] and [port], and the path\n   * (including possible fragment and query) is specified using\n   * [path].\n   *\n   * See [open] for details.\n   */\n  Future<HttpClientRequest> get(String host, int port, String path);\n\n  /**\n   * Opens a HTTP connection using the GET method.\n   *\n   * The URL to use is specified in [url].\n   *\n   * See [openUrl] for details.\n   */\n  Future<HttpClientRequest> getUrl(Uri url);\n\n  /**\n   * Opens a HTTP connection using the POST method.\n   *\n   * The server is specified using [host] and [port], and the path\n   * (including possible fragment and query) is specified using\n   * [path].\n   *\n   * See [open] for details.\n   */\n  Future<HttpClientRequest> post(String host, int port, String path);\n\n  /**\n   * Opens a HTTP connection using the POST method.\n   *\n   * The URL to use is specified in [url].\n   *\n   * See [openUrl] for details.\n   */\n  Future<HttpClientRequest> postUrl(Uri url);\n\n  /**\n   * Opens a HTTP connection using the PUT method.\n   *\n   * The server is specified using [host] and [port], and the path\n   * (including possible fragment and query) is specified using\n   * [path].\n   *\n   * See [open] for details.\n   */\n  Future<HttpClientRequest> put(String host, int port, String path);\n\n  /**\n   * Opens a HTTP connection using the PUT method.\n   *\n   * The URL to use is specified in [url].\n   *\n   * See [openUrl] for details.\n   */\n  Future<HttpClientRequest> putUrl(Uri url);\n\n  /**\n   * Opens a HTTP connection using the DELETE method.\n   *\n   * The server is specified using [host] and [port], and the path\n   * (including possible fragment and query) is specified using\n   * [path].\n   *\n   * See [open] for details.\n   */\n  Future<HttpClientRequest> delete(String host, int port, String path);\n\n  /**\n   * Opens a HTTP connection using the DELETE method.\n   *\n   * The URL to use is specified in [url].\n   *\n   * See [openUrl] for details.\n   */\n  Future<HttpClientRequest> deleteUrl(Uri url);\n\n  /**\n   * Opens a HTTP connection using the PATCH method.\n   *\n   * The server is specified using [host] and [port], and the path\n   * (including possible fragment and query) is specified using\n   * [path].\n   *\n   * See [open] for details.\n   */\n  Future<HttpClientRequest> patch(String host, int port, String path);\n\n  /**\n   * Opens a HTTP connection using the PATCH method.\n   *\n   * The URL to use is specified in [url].\n   *\n   * See [openUrl] for details.\n   */\n  Future<HttpClientRequest> patchUrl(Uri url);\n\n  /**\n   * Opens a HTTP connection using the HEAD method.\n   *\n   * The server is specified using [host] and [port], and the path\n   * (including possible fragment and query) is specified using\n   * [path].\n   *\n   * See [open] for details.\n   */\n  Future<HttpClientRequest> head(String host, int port, String path);\n\n  /**\n   * Opens a HTTP connection using the HEAD method.\n   *\n   * The URL to use is specified in [url].\n   *\n   * See [openUrl] for details.\n   */\n  Future<HttpClientRequest> headUrl(Uri url);\n\n  /**\n   * Sets the function to be called when a site is requesting\n   * authentication. The URL requested and the security realm from the\n   * server are passed in the arguments [url] and [realm].\n   *\n   * The function returns a [Future] which should complete when the\n   * authentication has been resolved. If credentials cannot be\n   * provided the [Future] should complete with [:false:]. If\n   * credentials are available the function should add these using\n   * [addCredentials] before completing the [Future] with the value\n   * [:true:].\n   *\n   * If the [Future] completes with true the request will be retried\n   * using the updated credentials. Otherwise response processing will\n   * continue normally.\n   */\n  set authenticate(Future<bool> f(Uri url, String scheme, String realm));\n\n  /**\n   * Add credentials to be used for authorizing HTTP requests.\n   */\n  void addCredentials(Uri url, String realm, HttpClientCredentials credentials);\n\n  /**\n   * Sets the function used to resolve the proxy server to be used for\n   * opening a HTTP connection to the specified [url]. If this\n   * function is not set, direct connections will always be used.\n   *\n   * The string returned by [f] must be in the format used by browser\n   * PAC (proxy auto-config) scripts. That is either\n   *\n   *     \"DIRECT\"\n   *\n   * for using a direct connection or\n   *\n   *     \"PROXY host:port\"\n   *\n   * for using the proxy server [:host:] on port [:port:].\n   *\n   * A configuration can contain several configuration elements\n   * separated by semicolons, e.g.\n   *\n   *     \"PROXY host:port; PROXY host2:port2; DIRECT\"\n   *\n   * The static function [findProxyFromEnvironment] on this class can\n   * be used to implement proxy server resolving based on environment\n   * variables.\n   */\n  set findProxy(String f(Uri url));\n\n  /**\n   * Function for resolving the proxy server to be used for a HTTP\n   * connection from the proxy configuration specified through\n   * environment variables.\n   *\n   * The following environment variables are taken into account:\n   *\n   *     http_proxy\n   *     https_proxy\n   *     no_proxy\n   *     HTTP_PROXY\n   *     HTTPS_PROXY\n   *     NO_PROXY\n   *\n   * [:http_proxy:] and [:HTTP_PROXY:] specify the proxy server to use for\n   * http:// urls. Use the format [:hostname:port:]. If no port is used a\n   * default of 1080 will be used. If both are set the lower case one takes\n   * precedence.\n   *\n   * [:https_proxy:] and [:HTTPS_PROXY:] specify the proxy server to use for\n   * https:// urls. Use the format [:hostname:port:]. If no port is used a\n   * default of 1080 will be used. If both are set the lower case one takes\n   * precedence.\n   *\n   * [:no_proxy:] and [:NO_PROXY:] specify a comma separated list of\n   * postfixes of hostnames for which not to use the proxy\n   * server. E.g. the value \"localhost,127.0.0.1\" will make requests\n   * to both \"localhost\" and \"127.0.0.1\" not use a proxy. If both are set\n   * the lower case one takes precedence.\n   *\n   * To activate this way of resolving proxies assign this function to\n   * the [findProxy] property on the [HttpClient].\n   *\n   *     HttpClient client = new HttpClient();\n   *     client.findProxy = HttpClient.findProxyFromEnvironment;\n   *\n   * If you don't want to use the system environment you can use a\n   * different one by wrapping the function.\n   *\n   *     HttpClient client = new HttpClient();\n   *     client.findProxy = (url) {\n   *       return HttpClient.findProxyFromEnvironment(\n   *           url, {\"http_proxy\": ..., \"no_proxy\": ...});\n   *     }\n   *\n   * If a proxy requires authentication it is possible to configure\n   * the username and password as well. Use the format\n   * [:username:password@hostname:port:] to include the username and\n   * password. Alternatively the API [addProxyCredentials] can be used\n   * to set credentials for proxies which require authentication.\n   */\n  static String findProxyFromEnvironment(Uri url,\n                                         {Map<String, String> environment}) {\n    return _HttpClient._findProxyFromEnvironment(url, environment);\n  }\n\n  /**\n   * Sets the function to be called when a proxy is requesting\n   * authentication. Information on the proxy in use and the security\n   * realm for the authentication are passed in the arguments [host],\n   * [port] and [realm].\n   *\n   * The function returns a [Future] which should complete when the\n   * authentication has been resolved. If credentials cannot be\n   * provided the [Future] should complete with [:false:]. If\n   * credentials are available the function should add these using\n   * [addProxyCredentials] before completing the [Future] with the value\n   * [:true:].\n   *\n   * If the [Future] completes with [:true:] the request will be retried\n   * using the updated credentials. Otherwise response processing will\n   * continue normally.\n   */\n  set authenticateProxy(\n      Future<bool> f(String host, int port, String scheme, String realm));\n\n  /**\n   * Add credentials to be used for authorizing HTTP proxies.\n   */\n  void addProxyCredentials(String host,\n                           int port,\n                           String realm,\n                           HttpClientCredentials credentials);\n\n  /**\n   * Sets a callback that will decide whether to accept a secure connection\n   * with a server certificate that cannot be authenticated by any of our\n   * trusted root certificates.\n   *\n   * When an secure HTTP request if made, using this HttpClient, and the\n   * server returns a server certificate that cannot be authenticated, the\n   * callback is called asynchronously with the [X509Certificate] object and\n   * the server's hostname and port.  If the value of [badCertificateCallback]\n   * is [:null:], the bad certificate is rejected, as if the callback\n   * returned [:false:]\n   *\n   * If the callback returns true, the secure connection is accepted and the\n   * [:Future<HttpClientRequest>:] that was returned from the call making the\n   * request completes with a valid HttpRequest object. If the callback returns\n   * false, the [:Future<HttpClientRequest>:] completes with an exception.\n   *\n   * If a bad certificate is received on a connection attempt, the library calls\n   * the function that was the value of badCertificateCallback at the time\n   * the the request is made, even if the value of badCertificateCallback\n   * has changed since then.\n   */\n  set badCertificateCallback(bool callback(X509Certificate cert,\n                                           String host,\n                                           int port));\n\n  /**\n   * Shutdown the HTTP client. If [force] is [:false:] (the default)\n   * the [:HttpClient:] will be kept alive until all active\n   * connections are done. If [force] is [:true:] any active\n   * connections will be closed to immediately release all\n   * resources. These closed connections will receive an [:onError:]\n   * callback to indicate that the client was shutdown. In both cases\n   * trying to establish a new connection after calling [shutdown]\n   * will throw an exception.\n   */\n  void close({bool force: false});\n}\n\n\n/**\n * HTTP request for a client connection.\n *\n * To set up a request, set the headers using the headers property\n * provided in this class and write the data to the body of the request.\n * HttpClientRequest is an [IOSink]. Use the methods from IOSink,\n * such as writeCharCode(), to write the body of the HTTP\n * request. When one of the IOSink methods is used for the first\n * time, the request header is sent. Calling any methods that\n * change the header after it is sent throws an exception.\n *\n * When writing string data through the [IOSink] the\n * encoding used is determined from the \"charset\" parameter of\n * the \"Content-Type\" header.\n *\n *     HttpClientRequest request = ...\n *     request.headers.contentType\n *         = new ContentType(\"application\", \"json\", charset: \"utf-8\");\n *     request.write(...);  // Strings written will be UTF-8 encoded.\n *\n * If no charset is provided the default of ISO-8859-1 (Latin 1) is\n * be used.\n *\n *     HttpClientRequest request = ...\n *     request.headers.add(HttpHeaders.CONTENT_TYPE, \"text/plain\");\n *     request.write(...);  // Strings written will be ISO-8859-1 encoded.\n *\n * An exception is thrown if you use an unsupported encoding and the\n * `write()` method being used takes a string parameter.\n */\nabstract class HttpClientRequest implements IOSink {\n  /**\n   * Gets and sets the requested persistent connection state.\n   *\n   * The default value is [:true:].\n   */\n  bool persistentConnection;\n\n  /**\n   * Set this property to [:true:] if this request should\n   * automatically follow redirects. The default is [:true:].\n   *\n   * Automatic redirect will only happen for \"GET\" and \"HEAD\" requests\n   * and only for the status codes [:HttpHeaders.MOVED_PERMANENTLY:]\n   * (301), [:HttpStatus.FOUND:] (302),\n   * [:HttpStatus.MOVED_TEMPORARILY:] (302, alias for\n   * [:HttpStatus.FOUND:]), [:HttpStatus.SEE_OTHER:] (303) and\n   * [:HttpStatus.TEMPORARY_REDIRECT:] (307). For\n   * [:HttpStatus.SEE_OTHER:] (303) autmatic redirect will also happen\n   * for \"POST\" requests with the method changed to \"GET\" when\n   * following the redirect.\n   *\n   * All headers added to the request will be added to the redirection\n   * request(s). However, any body send with the request will not be\n   * part of the redirection request(s).\n   */\n  bool followRedirects;\n\n  /**\n   * Set this property to the maximum number of redirects to follow\n   * when [followRedirects] is [:true:]. If this number is exceeded the\n   * [onError] callback will be called with a [RedirectException].\n   *\n   * The default value is 5.\n   */\n  int maxRedirects;\n\n  /**\n   * The method of the request.\n   */\n  String get method;\n\n  /**\n   * The uri of the request.\n   */\n  Uri get uri;\n\n  /**\n   * Gets and sets the content length of the request. If the size of\n   * the request is not known in advance set content length to -1,\n   * which is also the default.\n   */\n  int contentLength;\n\n  /**\n   * Get or set if the [HttpClientRequest] should buffer output.\n   *\n   * Default value is `true`.\n   *\n   * __Note__: Disabling buffering of the output can result in very poor\n   * performance, when writing many small chunks.\n   */\n  bool bufferOutput;\n\n  /**\n   * Returns the client request headers.\n   *\n   * The client request headers can be modified until the client\n   * request body is written to or closed. After that they become\n   * immutable.\n   */\n  HttpHeaders get headers;\n\n  /**\n   * Cookies to present to the server (in the 'cookie' header).\n   */\n  List<Cookie> get cookies;\n\n  /**\n   * A [HttpClientResponse] future that will complete once the response is\n   * available. If an error occurs before the response is available, this\n   * future will complete with an error.\n   */\n  Future<HttpClientResponse> get done;\n\n  /**\n   * Close the request for input. Returns the value of [done].\n   */\n  Future<HttpClientResponse> close();\n\n  /**\n   * Get information about the client connection. Returns [:null:] if the socket\n   * is not available.\n   */\n  HttpConnectionInfo get connectionInfo;\n}\n\n\n/**\n * HTTP response for a client connection.\n\n * The body of a [HttpClientResponse] object is a\n * [Stream] of data from the server. Listen to the body to handle\n * the data and be notified when the entire body is received.\n *\n *     new HttpClient().get('localhost', 80, '/file.txt')\n *          .then((HttpClientRequest request) => request.close())\n *          .then((HttpClientResponse response) {\n *            response.transform(UTF8.decoder).listen((contents) {\n *              // handle data\n *            });\n *          });\n */\nabstract class HttpClientResponse implements Stream<List<int>> {\n  /**\n   * Returns the status code.\n   *\n   * The status code must be set before the body is written\n   * to. Setting the status code after writing to the body will throw\n   * a `StateError`.\n   */\n  int get statusCode;\n\n  /**\n   * Returns the reason phrase associated with the status code.\n   *\n   * The reason phrase must be set before the body is written\n   * to. Setting the reason phrase after writing to the body will throw\n   * a `StateError`.\n   */\n  String get reasonPhrase;\n\n  /**\n   * Returns the content length of the response body. Returns -1 if the size of\n   * the response body is not known in advance.\n   *\n   * If the content length needs to be set, it must be set before the\n   * body is written to. Setting the reason phrase after writing to\n   * the body will throw a `StateError`.\n   */\n  int get contentLength;\n\n  /**\n   * Gets the persistent connection state returned by the server.\n   *\n   * if the persistent connection state needs to be set, it must be\n   * set before the body is written to. Setting the reason phrase\n   * after writing to the body will throw a `StateError`.\n   */\n  bool get persistentConnection;\n\n  /**\n   * Returns whether the status code is one of the normal redirect\n   * codes [HttpStatus.MOVED_PERMANENTLY], [HttpStatus.FOUND],\n   * [HttpStatus.MOVED_TEMPORARILY], [HttpStatus.SEE_OTHER] and\n   * [HttpStatus.TEMPORARY_REDIRECT].\n   */\n  bool get isRedirect;\n\n  /**\n   * Returns the series of redirects this connection has been through. The\n   * list will be empty if no redirects were followed. [redirects] will be\n   * updated both in the case of an automatic and a manual redirect.\n   */\n  List<RedirectInfo> get redirects;\n\n  /**\n   * Redirects this connection to a new URL. The default value for\n   * [method] is the method for the current request. The default value\n   * for [url] is the value of the [HttpHeaders.LOCATION] header of\n   * the current response. All body data must have been read from the\n   * current response before calling [redirect].\n   *\n   * All headers added to the request will be added to the redirection\n   * request. However, any body sent with the request will not be\n   * part of the redirection request.\n   *\n   * If [followLoops] is set to [:true:], redirect will follow the redirect,\n   * even if the URL was already visited. The default value is [:false:].\n   *\n   * [redirect] will ignore [maxRedirects] and will always perform the redirect.\n   */\n  Future<HttpClientResponse> redirect([String method,\n                                       Uri url,\n                                       bool followLoops]);\n\n\n  /**\n   * Returns the client response headers.\n   *\n   * The client response headers are immutable.\n   */\n  HttpHeaders get headers;\n\n  /**\n   * Detach the underlying socket from the HTTP client. When the\n   * socket is detached the HTTP client will no longer perform any\n   * operations on it.\n   *\n   * This is normally used when a HTTP upgrade is negotiated and the\n   * communication should continue with a different protocol.\n   */\n  Future<Socket> detachSocket();\n\n  /**\n   * Cookies set by the server (from the 'set-cookie' header).\n   */\n  List<Cookie> get cookies;\n\n  /**\n   * Returns the certificate of the HTTPS server providing the response.\n   * Returns null if the connection is not a secure TLS or SSL connection.\n   */\n  X509Certificate get certificate;\n\n  /**\n   * Gets information about the client connection. Returns [:null:] if the socket\n   * is not available.\n   */\n  HttpConnectionInfo get connectionInfo;\n}\n\n\nabstract class HttpClientCredentials { }\n\n\n/**\n * Represents credentials for basic authentication.\n */\nabstract class HttpClientBasicCredentials extends HttpClientCredentials {\n  factory HttpClientBasicCredentials(String username, String password) =>\n      new _HttpClientBasicCredentials(username, password);\n}\n\n\n/**\n * Represents credentials for digest authentication. Digest\n * authentication is only supported for servers using the MD5\n * algorithm and quality of protection (qop) of either \"none\" or\n * \"auth\".\n */\nabstract class HttpClientDigestCredentials extends HttpClientCredentials {\n  factory HttpClientDigestCredentials(String username, String password) =>\n      new _HttpClientDigestCredentials(username, password);\n}\n\n\n/**\n * Information about an [HttpRequest], [HttpResponse], [HttpClientRequest], or\n * [HttpClientResponse] connection.\n */\nabstract class HttpConnectionInfo {\n  InternetAddress get remoteAddress;\n  int get remotePort;\n  int get localPort;\n}\n\n\n/**\n * Redirect information.\n */\nabstract class RedirectInfo {\n  /**\n   * Returns the status code used for the redirect.\n   */\n  int get statusCode;\n\n  /**\n   * Returns the method used for the redirect.\n   */\n  String get method;\n\n  /**\n   * Returns the location for the redirect.\n   */\n  Uri get location;\n}\n\n\n/**\n * When detaching a socket from either the [:HttpServer:] or the\n * [:HttpClient:] due to a HTTP connection upgrade there might be\n * unparsed data already read from the socket. This unparsed data\n * together with the detached socket is returned in an instance of\n * this class.\n */\nabstract class DetachedSocket {\n  Socket get socket;\n  List<int> get unparsedData;\n}\n\n\nclass HttpException implements IOException {\n  final String message;\n  final Uri uri;\n\n  const HttpException(String this.message, {Uri this.uri});\n\n  String toString() {\n    var b = new StringBuffer()\n        ..write('HttpException: ')\n        ..write(message);\n    if (uri != null) {\n      b.write(', uri = $uri');\n    }\n    return b.toString();\n  }\n}\n\n\nclass RedirectException implements HttpException {\n  final String message;\n  final List<RedirectInfo> redirects;\n\n  const RedirectException(this.message, this.redirects);\n\n  String toString() => \"RedirectException: $message\";\n\n  Uri get uri => redirects.last.location;\n}\n\u0000","sdk:/sdk/lib/io/file_system_entity.dart":"// Copyright (c) 2013, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\npart of dart.io;\n\n/**\n * The type of an entity on the file system, such as a file, directory, or link.\n *\n * These constants are used by the [FileSystemEntity] class\n * to indicate the object's type.\n *\n */\n\nclass FileSystemEntityType {\n  static const FILE = const FileSystemEntityType._internal(0);\n  static const DIRECTORY = const FileSystemEntityType._internal(1);\n  static const LINK = const FileSystemEntityType._internal(2);\n  static const NOT_FOUND = const FileSystemEntityType._internal(3);\n  static const _typeList = const [FileSystemEntityType.FILE,\n                                  FileSystemEntityType.DIRECTORY,\n                                  FileSystemEntityType.LINK,\n                                  FileSystemEntityType.NOT_FOUND];\n  final int _type;\n\n  const FileSystemEntityType._internal(this._type);\n\n  static FileSystemEntityType _lookup(int type) => _typeList[type];\n  String toString() => const ['FILE', 'DIRECTORY', 'LINK', 'NOT_FOUND'][_type];\n}\n\n/**\n * A FileStat object represents the result of calling the POSIX stat() function\n * on a file system object.  It is an immutable object, representing the\n * snapshotted values returned by the stat() call.\n */\nclass FileStat {\n  // These must agree with enum FileStat in file.h.\n  static const _TYPE = 0;\n  static const _CHANGED_TIME = 1;\n  static const _MODIFIED_TIME = 2;\n  static const _ACCESSED_TIME = 3;\n  static const _MODE = 4;\n  static const _SIZE = 5;\n\n  static const _notFound = const FileStat._internalNotFound();\n\n  /**\n   * The time of the last change to the data or metadata of the file system\n   * object.  On Windows platforms, this is instead the file creation time.\n   */\n  final DateTime changed;\n  /**\n   * The time of the last change to the data of the file system\n   * object.\n   */\n  final DateTime modified;\n  /**\n   * The time of the last access to the data of the file system\n   * object.  On Windows platforms, this may have 1 day granularity, and be\n   * out of date by an hour.\n   */\n  final DateTime accessed;\n  /**\n   * The type of the object (file, directory, or link).  If the call to\n   * stat() fails, the type of the returned object is NOT_FOUND.\n   */\n  final FileSystemEntityType type;\n  /**\n   * The mode of the file system object.  Permissions are encoded in the lower\n   * 16 bits of this number, and can be decoded using the [modeString] getter.\n   */\n  final int mode;\n  /**\n   * The size of the file system object.\n   */\n  final int size;\n\n  FileStat._internal(this.changed,\n                     this.modified,\n                     this.accessed,\n                     this.type,\n                     this.mode,\n                     this.size);\n\n  const FileStat._internalNotFound() :\n      changed = null,  modified = null, accessed = null,\n      type = FileSystemEntityType.NOT_FOUND, mode = 0, size = -1;\n\n  external static _statSync(String path);\n\n\n  /**\n   * Calls the operating system's stat() function on [path].\n   * Returns a [FileStat] object containing the data returned by stat().\n   * If the call fails, returns a [FileStat] object with .type set to\n   * FileSystemEntityType.NOT_FOUND and the other fields invalid.\n   */\n  static FileStat statSync(String path) {\n    // Trailing path is not supported on Windows.\n    if (Platform.isWindows) {\n      path = FileSystemEntity._trimTrailingPathSeparators(path);\n    }\n    var data = _statSync(path);\n    if (data is OSError) return FileStat._notFound;\n    return new FileStat._internal(\n        new DateTime.fromMillisecondsSinceEpoch(data[_CHANGED_TIME]),\n        new DateTime.fromMillisecondsSinceEpoch(data[_MODIFIED_TIME]),\n        new DateTime.fromMillisecondsSinceEpoch(data[_ACCESSED_TIME]),\n        FileSystemEntityType._lookup(data[_TYPE]),\n        data[_MODE],\n        data[_SIZE]);\n  }\n\n  /**\n   * Asynchronously calls the operating system's stat() function on [path].\n   * Returns a Future which completes with a [FileStat] object containing\n   * the data returned by stat().\n   * If the call fails, completes the future with a [FileStat] object with\n   * .type set to FileSystemEntityType.NOT_FOUND and the other fields invalid.\n   */\n  static Future<FileStat> stat(String path) {\n    // Trailing path is not supported on Windows.\n    if (Platform.isWindows) {\n      path = FileSystemEntity._trimTrailingPathSeparators(path);\n    }\n    return _IOService.dispatch(_FILE_STAT, [path]).then((response) {\n      if (_isErrorResponse(response)) {\n        return FileStat._notFound;\n      }\n      // Unwrap the real list from the \"I'm not an error\" wrapper.\n      List data = response[1];\n      return new FileStat._internal(\n          new DateTime.fromMillisecondsSinceEpoch(data[_CHANGED_TIME]),\n          new DateTime.fromMillisecondsSinceEpoch(data[_MODIFIED_TIME]),\n          new DateTime.fromMillisecondsSinceEpoch(data[_ACCESSED_TIME]),\n          FileSystemEntityType._lookup(data[_TYPE]),\n          data[_MODE],\n          data[_SIZE]);\n    });\n  }\n\n  String toString() => \"\"\"\nFileStat: type $type\n          changed $changed\n          modified $modified\n          accessed $accessed\n          mode ${modeString()}\n          size $size\"\"\";\n\n  /**\n   * Returns the mode value as a human-readable string, in the format\n   * \"rwxrwxrwx\", reflecting the user, group, and world permissions to\n   * read, write, and execute the file system object, with \"-\" replacing the\n   * letter for missing permissions.  Extra permission bits may be represented\n   * by prepending \"(suid)\", \"(guid)\", and/or \"(sticky)\" to the mode string.\n   */\n  String modeString() {\n    var permissions = mode & 0xFFF;\n    var codes = const ['---', '--x', '-w-', '-wx', 'r--', 'r-x', 'rw-', 'rwx'];\n    var result = [];\n    if ((permissions & 0x800) != 0) result.add(\"(suid) \");\n    if ((permissions & 0x400) != 0) result.add(\"(guid) \");\n    if ((permissions & 0x200) != 0) result.add(\"(sticky) \");\n    result\n        ..add(codes[(permissions >> 6) & 0x7])\n        ..add(codes[(permissions >> 3) & 0x7])\n        ..add(codes[permissions & 0x7]);\n    return result.join();\n  }\n}\n\n\n/**\n * The common super class for [File], [Directory], and [Link] objects.\n *\n * [FileSystemEntity] objects are returned from directory listing\n * operations. To determine if a FileSystemEntity is a [File], a\n * [Directory], or a [Link] perform a type check:\n *\n *     if (entity is File) (entity as File).readAsStringSync();\n *\n * You can also use the [type] or [typeSync] methods to determine\n * the type of a file system object.\n *\n * Most methods in this class occur in synchronous and asynchronous pairs,\n * for example, [exists] and [existsSync].\n * Unless you have a specific reason for using the synchronous version\n * of a method, prefer the asynchronous version to avoid blocking your program.\n *\n * Here's the exists method in action:\n *\n *     entity.exists().then((isThere) {\n *       isThere ? print('exists') : print('non-existent');\n *     });\n *\n *\n * ## Other resources\n *\n * [Dart by Example](https://www.dartlang.org/dart-by-example/#files-directories-and-symlinks)\n * provides additional task-oriented code samples that show how to use \n * various API from the [Directory] class and the [File] class,\n * both subclasses of FileSystemEntity.\n *\n * * [I/O for Command-Line Apps](https://www.dartlang.org/docs/dart-up-and-running/contents/ch03.html#ch03-dartio---file-and-socket-io-for-command-line-apps)\n * a section from _A Tour of the Dart Libraries_\n * covers files and directories.\n *\n * * [Write Command-Line Apps](https://www.dartlang.org/docs/tutorials/cmdline/),\n * a tutorial about writing command-line apps, includes information\n * about files and directories.\n\n */\nabstract class FileSystemEntity {\n  String get path;\n\n  /**\n   * Checks whether the file system entity with this path exists. Returns\n   * a [:Future<bool>:] that completes with the result.\n   *\n   * Since FileSystemEntity is abstract, every FileSystemEntity object\n   * is actually an instance of one of the subclasses [File],\n   * [Directory], and [Link].  Calling [exists] on an instance of one\n   * of these subclasses checks whether the object exists in the file\n   * system object exists and is of the correct type (file, directory,\n   * or link).  To check whether a path points to an object on the\n   * file system, regardless of the object's type, use the [type]\n   * static method.\n   *\n   */\n  Future<bool> exists();\n\n  /**\n   * Synchronously checks whether the file system entity with this path\n   * exists.\n   *\n   * Since FileSystemEntity is abstract, every FileSystemEntity object\n   * is actually an instance of one of the subclasses [File],\n   * [Directory], and [Link].  Calling [existsSync] on an instance of\n   * one of these subclasses checks whether the object exists in the\n   * file system object exists and is of the correct type (file,\n   * directory, or link).  To check whether a path points to an object\n   * on the file system, regardless of the object's type, use the\n   * [typeSync] static method.\n   */\n  bool existsSync();\n\n  /**\n   * Renames this file system entity. Returns a `Future<FileSystemEntity>`\n   * that completes with a [FileSystemEntity] instance for the renamed\n   * file system entity.\n   *\n   * If [newPath] identifies an existing entity of the same type, that entity\n   * is replaced. If [newPath] identifies an existing entity of a different\n   * type, the operation fails and the future completes with an exception.\n   */\n  Future<FileSystemEntity> rename(String newPath);\n\n   /**\n   * Synchronously renames this file system entity. Returns a [FileSystemEntity]\n   * instance for the renamed entity.\n   *\n   * If [newPath] identifies an existing entity of the same type, that entity\n   * is replaced. If [newPath] identifies an existing entity of a different\n   * type, the operation fails and an exception is thrown.\n   */\n  FileSystemEntity renameSync(String newPath);\n\n  /**\n   * Resolves the path of a file system object relative to the\n   * current working directory, resolving all symbolic links on\n   * the path and resolving all '..' and '.' path segments.\n   * [resolveSymbolicLinks] returns a [:Future<String>:]\n   *\n   * [resolveSymbolicLinks] uses the operating system's native filesystem api\n   * to resolve the path, using the realpath function on linux and\n   * Mac OS, and the GetFinalPathNameByHandle function on Windows.\n   * If the path does not point to an existing file system object,\n   * [resolveSymbolicLinks] completes the returned Future with an FileSystemException.\n   *\n   * On Windows, symbolic links are resolved to their target before applying\n   * a '..' that follows, and on other platforms, the '..' is applied to the\n   * symbolic link without resolving it.  The second behavior can be emulated\n   * on Windows by processing any '..' segments before calling\n   * [resolveSymbolicLinks].  One way of doing this is with the URI class:\n   * [:new Uri.parse('.').resolveUri(new Uri.file(input)).toFilePath();],\n   * since [resolve] removes '..' segments.\n   */\n  Future<String> resolveSymbolicLinks() {\n    return _IOService.dispatch(_FILE_RESOLVE_SYMBOLIC_LINKS, [path])\n        .then((response) {\n          if (_isErrorResponse(response)) {\n            throw _exceptionFromResponse(response,\n                                         \"Cannot resolve symbolic links\",\n                                         path);\n          }\n          return response;\n        });\n  }\n\n  /**\n   * Resolves the path of a file system object relative to the\n   * current working directory, resolving all symbolic links on\n   * the path and resolving all '..' and '.' path segments.\n   *\n   * [resolveSymbolicLinksSync] uses the operating system's native\n   * filesystem api to resolve the path, using the realpath function\n   * on linux and Mac OS, and the GetFinalPathNameByHandle function on Windows.\n   * If the path does not point to an existing file system object,\n   * [resolveSymbolicLinksSync] throws a FileSystemException.\n   *\n   * On Windows, symbolic links are resolved to their target before applying\n   * a '..' that follows, and on other platforms, the '..' is applied to the\n   * symbolic link without resolving it.  The second behavior can be emulated\n   * on Windows by processing any '..' segments before calling\n   * [resolveSymbolicLinks].  One way of doing this is with the URI class:\n   * [:new Uri.parse('.').resolveUri(new Uri.file(input)).toFilePath();],\n   * since [resolve] removes '..' segments.\n   */\n  String resolveSymbolicLinksSync() {\n    var result = _resolveSymbolicLinks(path);\n    _throwIfError(result, \"Cannot resolve symbolic links\", path);\n    return result;\n  }\n\n\n  /**\n   * Calls the operating system's stat() function on the [path] of this\n   * [FileSystemEntity].  Identical to [:FileStat.stat(this.path):].\n   *\n   * Returns a [:Future<FileStat>:] object containing the data returned by\n   * stat().\n   *\n   * If the call fails, completes the future with a [FileStat] object\n   * with .type set to\n   * FileSystemEntityType.NOT_FOUND and the other fields invalid.\n   */\n  Future<FileStat> stat();\n\n  /**\n   * Synchronously calls the operating system's stat() function on the\n   * [path] of this [FileSystemEntity].\n   * Identical to [:FileStat.statSync(this.path):].\n   *\n   * Returns a [FileStat] object containing the data returned by stat().\n   *\n   * If the call fails, returns a [FileStat] object with .type set to\n   * FileSystemEntityType.NOT_FOUND and the other fields invalid.\n   */\n  FileStat statSync();\n\n  /**\n   * Deletes this [FileSystemEntity].\n   *\n   * If the [FileSystemEntity] is a directory, and if [recursive] is false,\n   * the directory must be empty. Otherwise, if [recursive] is true, the\n   * directory and all sub-directories and files in the directories are\n   * deleted. Links are not followed when deleting recursively. Only the link\n   * is deleted, not its target.\n   *\n   * If [recursive] is true, the [FileSystemEntity] is deleted even if the type\n   * of the [FileSystemEntity] doesn't match the content of the file system.\n   * This behavior allows [delete] to be used to unconditionally delete any file\n   * system object.\n   *\n   * Returns a [:Future<FileSystemEntity>:] that completes with this\n   * [FileSystemEntity] when the deletion is done. If the [FileSystemEntity]\n   * cannot be deleted, the future completes with an exception.\n   */\n  Future<FileSystemEntity> delete({bool recursive: false})\n      => _delete(recursive: recursive);\n\n  /**\n   * Synchronously deletes this [FileSystemEntity].\n   *\n   * If the [FileSystemEntity] is a directory, and if [recursive] is false,\n   * the directory must be empty. Otherwise, if [recursive] is true, the\n   * directory and all sub-directories and files in the directories are\n   * deleted. Links are not followed when deleting recursively. Only the link\n   * is deleted, not its target.\n   *\n   * If [recursive] is true, the [FileSystemEntity] is deleted even if the type\n   * of the [FileSystemEntity] doesn't match the content of the file system.\n   * This behavior allows [deleteSync] to be used to unconditionally delete any\n   * file system object.\n   *\n   * Throws an exception if the [FileSystemEntity] cannot be deleted.\n   */\n  void deleteSync({bool recursive: false})\n      => _deleteSync(recursive: recursive);\n\n\n  /**\n   * Start watching the [FileSystemEntity] for changes.\n   *\n   * The implementation uses platform-dependent event-based APIs for receiving\n   * file-system notifications, thus behavior depends on the platform.\n   *\n   *   * `Windows`: Uses `ReadDirectoryChangesW`. The implementation only\n   *     supports watching directories. Recursive watching is supported.\n   *   * `Linux`: Uses `inotify`. The implementation supports watching both\n   *     files and directories. Recursive watching is not supported.\n   *     Note: When watching files directly, delete events might not happen\n   *     as expected.\n   *   * `Mac OS`: Uses `FSEvents`. The implementation supports watching both\n   *     files and directories. Recursive watching is supported.\n   *\n   * The system will start listening for events once the returned [Stream] is\n   * being listened to, not when the call to [watch] is issued.\n   *\n   * The returned value is an endless broadcast [Stream], that only stops when\n   * one of the following happends:\n   *\n   *   * The [Stream] is canceled, e.g. by calling `cancel` on the\n   *      [StreamSubscription].\n   *   * The [FileSystemEntity] being watches, is deleted.\n   *\n   * Use `events` to specify what events to listen for. The constants in\n   * [FileSystemEvent] can be or'ed together to mix events. Default is\n   * [FileSystemEvent.ALL].\n   */\n  Stream<FileSystemEvent> watch({int events: FileSystemEvent.ALL,\n                                 bool recursive: false})\n     => _FileSystemWatcher.watch(_trimTrailingPathSeparators(path),\n                                 events,\n                                 recursive);\n\n  Future<FileSystemEntity> _delete({bool recursive: false});\n  void _deleteSync({bool recursive: false});\n\n  /**\n   * Checks whether two paths refer to the same object in the\n   * file system. Returns a [:Future<bool>:] that completes with the result.\n   *\n   * Comparing a link to its target returns false, as does comparing two links\n   * that point to the same target.  To check the target of a link, use\n   * Link.target explicitly to fetch it.  Directory links appearing\n   * inside a path are followed, though, to find the file system object.\n   *\n   * Completes the returned Future with an error if one of the paths points\n   * to an object that does not exist.\n   */\n  static Future<bool> identical(String path1, String path2) {\n    return _IOService.dispatch(_FILE_IDENTICAL, [path1, path2]).then((response) {\n      if (_isErrorResponse(response)) {\n        throw _exceptionFromResponse(response,\n            \"Error in FileSystemEntity.identical($path1, $path2)\", \"\");\n      }\n      return response;\n    });\n  }\n\n  static final RegExp _absoluteWindowsPathPattern =\n      new RegExp(r'^(\\\\\\\\|[a-zA-Z]:[/\\\\])');\n\n  /**\n   * Returns a [bool] indicating whether this object's path is absolute.\n   *\n   * On Windows, a path is absolute if it starts with \\\\ or a drive letter\n   * between a and z (upper or lower case) followed by :\\ or :/.\n   * On non-Windows, a path is absolute if it starts with /.\n   */\n  bool get isAbsolute {\n    if (Platform.isWindows) {\n      return path.startsWith(_absoluteWindowsPathPattern);\n    } else {\n      return path.startsWith('/');\n    }\n  }\n\n  /**\n   * Returns a [FileSystemEntity] whose path is the absolute path to [this].\n   * The type of the returned instance is the type of [this].\n   *\n   * The absolute path is computed by prefixing\n   * a relative path with the current working directory, and returning\n   * an absolute path unchanged.\n   */\n  FileSystemEntity get absolute;\n\n  String get _absolutePath {\n    if (isAbsolute) return path;\n    String current = Directory.current.path;\n    if (current.endsWith('/') ||\n        (Platform.isWindows && current.endsWith('\\\\'))) {\n      return '$current$path';\n    } else {\n      return '$current${Platform.pathSeparator}$path';\n    }\n  }\n\n\n  /**\n   * Synchronously checks whether two paths refer to the same object in the\n   * file system.\n   *\n   * Comparing a link to its target returns false, as does comparing two links\n   * that point to the same target.  To check the target of a link, use\n   * Link.target explicitly to fetch it.  Directory links appearing\n   * inside a path are followed, though, to find the file system object.\n   *\n   * Throws an error if one of the paths points to an object that does not\n   * exist.\n   */\n  static bool identicalSync(String path1, String path2) {\n    var result = _identical(path1, path2);\n    _throwIfError(result, 'Error in FileSystemEntity.identicalSync');\n    return result;\n  }\n\n  /**\n   * Test if [watch] is supported on the current system.\n   *\n   * Mac OS 10.6 and below is not supported.\n   */\n  static bool get isWatchSupported => _FileSystemWatcher.isSupported;\n\n  /**\n   * Finds the type of file system object that a path points to. Returns\n   * a [:Future<FileSystemEntityType>:] that completes with the result.\n   *\n   * [FileSystemEntityType] has the constant instances FILE, DIRECTORY,\n   * LINK, and NOT_FOUND.  [type] will return LINK only if the optional\n   * named argument [followLinks] is false, and [path] points to a link.\n   * If the path does not point to a file system object, or any other error\n   * occurs in looking up the path, NOT_FOUND is returned.  The only\n   * error or exception that may be put on the returned future is ArgumentError,\n   * caused by passing the wrong type of arguments to the function.\n   */\n  static Future<FileSystemEntityType> type(String path,\n                                           {bool followLinks: true})\n      => _getTypeAsync(path, followLinks).then(FileSystemEntityType._lookup);\n\n  /**\n   * Synchronously finds the type of file system object that a path points to.\n   * Returns a [FileSystemEntityType].\n   *\n   * [FileSystemEntityType] has the constant instances FILE, DIRECTORY,\n   * LINK, and NOT_FOUND.  [type] will return LINK only if the optional\n   * named argument [followLinks] is false, and [path] points to a link.\n   * If the path does not point to a file system object, or any other error\n   * occurs in looking up the path, NOT_FOUND is returned.  The only\n   * error or exception that may be thrown is ArgumentError,\n   * caused by passing the wrong type of arguments to the function.\n   */\n  static FileSystemEntityType typeSync(String path, {bool followLinks: true})\n      => FileSystemEntityType._lookup(_getTypeSync(path, followLinks));\n\n  /**\n   * Checks if type(path, followLinks: false) returns\n   * FileSystemEntityType.LINK.\n   */\n  static Future<bool> isLink(String path) => _getTypeAsync(path, false)\n      .then((type) => (type == FileSystemEntityType.LINK._type));\n\n  /**\n   * Checks if type(path) returns FileSystemEntityType.FILE.\n   */\n  static Future<bool> isFile(String path) => _getTypeAsync(path, true)\n      .then((type) => (type == FileSystemEntityType.FILE._type));\n\n  /**\n   * Checks if type(path) returns FileSystemEntityType.DIRECTORY.\n   */\n  static Future<bool> isDirectory(String path) => _getTypeAsync(path, true)\n      .then((type) => (type == FileSystemEntityType.DIRECTORY._type));\n\n  /**\n   * Synchronously checks if typeSync(path, followLinks: false) returns\n   * FileSystemEntityType.LINK.\n   */\n  static bool isLinkSync(String path) =>\n      (_getTypeSync(path, false) == FileSystemEntityType.LINK._type);\n\n  /**\n   * Synchronously checks if typeSync(path) returns\n   * FileSystemEntityType.FILE.\n   */\n  static bool isFileSync(String path) =>\n      (_getTypeSync(path, true) == FileSystemEntityType.FILE._type);\n\n  /**\n   * Synchronously checks if typeSync(path) returns\n   * FileSystemEntityType.DIRECTORY.\n   */\n  static bool isDirectorySync(String path) =>\n      (_getTypeSync(path, true) == FileSystemEntityType.DIRECTORY._type);\n\n  external static _getType(String path, bool followLinks);\n  external static _identical(String path1, String path2);\n  external static _resolveSymbolicLinks(String path);\n\n  // Finds the next-to-last component when dividing at path separators.\n  static final RegExp _parentRegExp = Platform.isWindows ?\n     new RegExp(r'[^/\\\\][/\\\\]+[^/\\\\]') :\n     new RegExp(r'[^/]/+[^/]');\n\n  /**\n   * Removes the final path component of a path, using the platform's\n   * path separator to split the path.  Will not remove the root component\n   * of a Windows path, like \"C:\\\" or \"\\\\server_name\\\".\n   * Ignores trailing path separators, and leaves no trailing path separators.\n   */\n  static String parentOf(String path) {\n    int rootEnd = -1;\n    if (Platform.isWindows) {\n      if (path.startsWith(_absoluteWindowsPathPattern)) {\n        // Root ends at first / or \\ after the first two characters.\n        rootEnd = path.indexOf(new RegExp(r'[/\\\\]'), 2);\n        if (rootEnd == -1) return path;\n      } else if (path.startsWith('\\\\') || path.startsWith('/')) {\n        rootEnd = 0;\n      }\n    } else if (path.startsWith('/')) {\n      rootEnd = 0;\n    }\n    // Ignore trailing slashes.\n    // All non-trivial cases have separators between two non-separators.\n    int pos = path.lastIndexOf(_parentRegExp);\n    if (pos > rootEnd) {\n      return path.substring(0, pos + 1);\n    } else if (rootEnd > -1) {\n      return path.substring(0, rootEnd + 1);\n    } else {\n      return '.';\n    }\n  }\n\n  /**\n   * The directory containing [this].  If [this] is a root\n   * directory, returns [this].\n   */\n  Directory get parent => new Directory(parentOf(path));\n\n  static int _getTypeSync(String path, bool followLinks) {\n    var result = _getType(path, followLinks);\n    _throwIfError(result, 'Error getting type of FileSystemEntity');\n    return result;\n  }\n\n  static Future<int> _getTypeAsync(String path, bool followLinks) {\n    return _IOService.dispatch(_FILE_TYPE, [path, followLinks])\n      .then((response) {\n        if (_isErrorResponse(response)) {\n          throw _exceptionFromResponse(response, \"Error getting type\", path);\n        }\n        return response;\n      });\n  }\n\n  static _throwIfError(Object result, String msg, [String path]) {\n    if (result is OSError) {\n      throw new FileSystemException(msg, path, result);\n    } else if (result is ArgumentError) {\n      throw result;\n    }\n  }\n\n  static String _trimTrailingPathSeparators(String path) {\n    // Don't handle argument errors here.\n    if (path is! String) return path;\n    if (Platform.isWindows) {\n      while (path.length > 1 &&\n             (path.endsWith(Platform.pathSeparator) ||\n              path.endsWith('/'))) {\n        path = path.substring(0, path.length - 1);\n      }\n    } else {\n      while (path.length > 1 && path.endsWith(Platform.pathSeparator)) {\n        path = path.substring(0, path.length - 1);\n      }\n    }\n    return path;\n  }\n\n  static String _ensureTrailingPathSeparators(String path) {\n    // Don't handle argument errors here.\n    if (path is! String) return path;\n    if (path.isEmpty) path = '.';\n    if (Platform.isWindows) {\n      while (!path.endsWith(Platform.pathSeparator) && !path.endsWith('/')) {\n        path = \"$path${Platform.pathSeparator}\";\n      }\n    } else {\n      while (!path.endsWith(Platform.pathSeparator)) {\n        path = \"$path${Platform.pathSeparator}\";\n      }\n    }\n    return path;\n  }\n}\n\n\n/**\n * Base event class emitted by [FileSystemEntity.watch].\n */\nclass FileSystemEvent {\n  /**\n   * Bitfield for [FileSystemEntity.watch], to enable [FileSystemCreateEvent]s.\n   */\n  static const int CREATE = 1 << 0;\n\n  /**\n   * Bitfield for [FileSystemEntity.watch], to enable [FileSystemModifyEvent]s.\n   */\n  static const int MODIFY = 1 << 1;\n\n  /**\n   * Bitfield for [FileSystemEntity.watch], to enable [FileSystemDeleteEvent]s.\n   */\n  static const int DELETE = 1 << 2;\n\n  /**\n   * Bitfield for [FileSystemEntity.watch], to enable [FileSystemMoveEvent]s.\n   */\n  static const int MOVE = 1 << 3;\n\n  /**\n   * Bitfield for [FileSystemEntity.watch], for enabling all of [CREATE],\n   * [MODIFY], [DELETE] and [MOVE].\n   */\n  static const int ALL = CREATE | MODIFY | DELETE | MOVE;\n\n  static const int _MODIFY_ATTRIBUTES = 1 << 4;\n  static const int _DELETE_SELF = 1 << 5;\n  static const int _IS_DIR = 1 << 6;\n\n  /**\n   * The type of event. See [FileSystemEvent] for a list of events.\n   */\n  final int type;\n\n  /**\n   * The path that triggered the event. Depending on the platform and the\n   * FileSystemEntity, the path may be relative.\n   */\n  final String path;\n\n  /**\n   * Is `true` if the event target was a directory.\n   */\n  final bool isDirectory;\n\n  FileSystemEvent._(this.type, this.path, this.isDirectory);\n}\n\n\n/**\n * File system event for newly created file system objects.\n */\nclass FileSystemCreateEvent extends FileSystemEvent {\n  FileSystemCreateEvent._(path, isDirectory)\n      : super._(FileSystemEvent.CREATE, path, isDirectory);\n\n  String toString() => \"FileSystemCreateEvent('$path')\";\n}\n\n\n/**\n * File system event for modifications of file system objects.\n */\nclass FileSystemModifyEvent extends FileSystemEvent {\n  /**\n   * If the content was changed and not only the attributes, [contentChanged]\n   * is `true`.\n   */\n  final bool contentChanged;\n\n  FileSystemModifyEvent._(path, isDirectory, this.contentChanged)\n      : super._(FileSystemEvent.MODIFY, path, isDirectory);\n\n  String toString() =>\n      \"FileSystemModifyEvent('$path', contentChanged=$contentChanged)\";\n}\n\n\n/**\n * File system event for deletion of file system objects.\n */\nclass FileSystemDeleteEvent extends FileSystemEvent {\n  FileSystemDeleteEvent._(path, isDirectory)\n      : super._(FileSystemEvent.DELETE, path, isDirectory);\n\n  String toString() => \"FileSystemDeleteEvent('$path')\";\n}\n\n\n/**\n * File system event for moving of file system objects.\n */\nclass FileSystemMoveEvent extends FileSystemEvent {\n  /**\n   * If the underlaying implementation is able to identify the destination of\n   * the moved file, [destination] will be set. Otherwise, it will be `null`.\n   */\n  final String destination;\n\n  FileSystemMoveEvent._(path, isDirectory, this.destination)\n      : super._(FileSystemEvent.MOVE, path, isDirectory);\n\n  String toString() {\n    var buffer = new StringBuffer();\n    buffer.write(\"FileSystemMoveEvent('$path'\");\n    if (destination != null) buffer.write(\", '$destination'\");\n    buffer.write(')');\n    return buffer.toString();\n  }\n}\n\n\nclass _FileSystemWatcher {\n  external static Stream<FileSystemEvent> watch(\n      String path, int events, bool recursive);\n  external static bool get isSupported;\n}\n\u0000","sdk:/sdk/lib/io/file_impl.dart":"// Copyright (c) 2013, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\npart of dart.io;\n\n// Read the file in blocks of size 64k.\nconst int _BLOCK_SIZE = 64 * 1024;\n\n\nclass _FileStream extends Stream<List<int>> {\n  // Stream controller.\n  StreamController<List<int>> _controller;\n\n  // Information about the underlying file.\n  String _path;\n  RandomAccessFile _openedFile;\n  int _position;\n  int _end;\n  final Completer _closeCompleter = new Completer();\n\n  // Has the stream been paused or unsubscribed?\n  bool _unsubscribed = false;\n\n  // Is there a read currently in progress?\n  bool _readInProgress = true;\n  bool _closed = false;\n\n  bool _atEnd = false;\n\n  _FileStream(this._path, this._position, this._end) {\n    if (_position == null) _position = 0;\n  }\n\n  _FileStream.forStdin() : _position = 0;\n\n  StreamSubscription<List<int>> listen(void onData(List<int> event),\n                                       {Function onError,\n                                        void onDone(),\n                                        bool cancelOnError}) {\n    _setupController();\n    return _controller.stream.listen(onData,\n                                     onError: onError,\n                                     onDone: onDone,\n                                     cancelOnError: cancelOnError);\n  }\n\n  void _setupController() {\n    _controller = new StreamController<List<int>>(sync: true,\n        onListen: _start,\n        onResume: _readBlock,\n        onCancel: () {\n          _unsubscribed = true;\n          return _closeFile();\n        });\n  }\n\n  Future _closeFile() {\n    if (_readInProgress || _closed) {\n      return _closeCompleter.future;\n    }\n    _closed = true;\n\n    void done() {\n      _closeCompleter.complete();\n      _controller.close();\n    }\n\n    _openedFile.close()\n        .catchError(_controller.addError)\n        .whenComplete(done);\n    return _closeCompleter.future;\n  }\n\n  void _readBlock() {\n    // Don't start a new read if one is already in progress.\n    if (_readInProgress) return;\n    if (_atEnd) {\n      _closeFile();\n      return;\n    }\n    _readInProgress = true;\n    int readBytes = _BLOCK_SIZE;\n    if (_end != null) {\n      readBytes = min(readBytes, _end - _position);\n      if (readBytes < 0) {\n        _readInProgress = false;\n        if (!_unsubscribed) {\n          _controller.addError(new RangeError(\"Bad end position: $_end\"));\n          _closeFile();\n          _unsubscribed = true;\n        }\n        return;\n      }\n    }\n    _openedFile.read(readBytes)\n      .then((block) {\n        _readInProgress = false;\n        if (_unsubscribed) {\n          _closeFile();\n          return;\n        }\n        _position += block.length;\n        if (block.length < readBytes ||\n            (_end != null && _position == _end)) {\n          _atEnd = true;\n        }\n        if (!_atEnd && !_controller.isPaused) {\n          _readBlock();\n        }\n        _controller.add(block);\n        if (_atEnd) {\n          _closeFile();\n        }\n      })\n      .catchError((e, s) {\n        if (!_unsubscribed) {\n          _controller.addError(e, s);\n          _closeFile();\n          _unsubscribed = true;\n        }\n      });\n  }\n\n  void _start() {\n    if (_position < 0) {\n      _controller.addError(new RangeError(\"Bad start position: $_position\"));\n      _controller.close();\n      _closeCompleter.complete();\n      return;\n    }\n\n    void onReady(RandomAccessFile file) {\n      _openedFile = file;\n      _readInProgress = false;\n      _readBlock();\n    }\n\n    void onOpenFile(RandomAccessFile file) {\n      if (_position > 0) {\n        file.setPosition(_position)\n            .then(onReady, onError: (e, s) {\n              _controller.addError(e, s);\n              _readInProgress = false;\n              _closeFile();\n            });\n      } else {\n        onReady(file);\n      }\n    }\n\n    void openFailed(error, stackTrace) {\n      _controller.addError(error, stackTrace);\n      _controller.close();\n      _closeCompleter.complete();\n    }\n\n    if (_path != null) {\n      new File(_path).open(mode: FileMode.READ)\n          .then(onOpenFile, onError: openFailed);\n    } else {\n      try {\n        onOpenFile(_File._openStdioSync(0));\n      } catch (e, s) {\n        openFailed(e, s);\n      }\n    }\n  }\n}\n\nclass _FileStreamConsumer extends StreamConsumer<List<int>> {\n  File _file;\n  Future<RandomAccessFile> _openFuture;\n\n  _FileStreamConsumer(File this._file, FileMode mode) {\n    _openFuture = _file.open(mode: mode);\n  }\n\n  Future<File> addStream(Stream<List<int>> stream) {\n    Completer<File> completer = new Completer<File>.sync();\n    _openFuture\n      .then((openedFile) {\n        var _subscription;\n        void error(e, [StackTrace stackTrace]) {\n          _subscription.cancel();\n          openedFile.close();\n          completer.completeError(e, stackTrace);\n        }\n        _subscription = stream.listen(\n          (d) {\n            _subscription.pause();\n            try {\n              openedFile.writeFrom(d, 0, d.length)\n                .then((_) => _subscription.resume(),\n                      onError: error);\n            } catch (e, stackTrace) {\n              error(e, stackTrace);\n            }\n          },\n          onDone: () {\n            completer.complete(_file);\n          },\n          onError: error,\n          cancelOnError: true);\n      })\n      .catchError((e) {\n        completer.completeError(e);\n      });\n    return completer.future;\n  }\n\n  Future<File> close() =>\n      _openFuture.then((openedFile) => openedFile.close());\n}\n\n\n// Class for encapsulating the native implementation of files.\nclass _File extends FileSystemEntity implements File {\n  final String path;\n\n  // Constructor for file.\n  _File(this.path) {\n    if (path is! String) {\n      throw new ArgumentError('${Error.safeToString(path)} '\n                              'is not a String');\n    }\n  }\n\n  Future<bool> exists() {\n    return _IOService.dispatch(_FILE_EXISTS, [path]).then((response) {\n      if (_isErrorResponse(response)) {\n        throw _exceptionFromResponse(response, \"Cannot check existence\", path);\n      }\n      return response;\n    });\n  }\n\n  external static _exists(String path);\n\n  bool existsSync() {\n    var result = _exists(path);\n    throwIfError(result, \"Cannot check existence of file\", path);\n    return result;\n  }\n\n  File get absolute => new File(_absolutePath);\n\n  Future<FileStat> stat() => FileStat.stat(path);\n\n  FileStat statSync() => FileStat.statSync(path);\n\n  Future<File> create({bool recursive: false}) {\n    var result = recursive ? parent.create(recursive: true)\n                           : new Future.value(null);\n    return result\n      .then((_) => _IOService.dispatch(_FILE_CREATE, [path]))\n      .then((response) {\n        if (_isErrorResponse(response)) {\n          throw _exceptionFromResponse(response, \"Cannot create file\", path);\n        }\n        return this;\n      });\n  }\n\n  external static _create(String path);\n\n  external static _createLink(String path, String target);\n\n  external static _linkTarget(String path);\n\n  void createSync({bool recursive: false}) {\n    if (recursive) {\n      parent.createSync(recursive: true);\n    }\n    var result = _create(path);\n    throwIfError(result, \"Cannot create file\", path);\n  }\n\n  Future<File> _delete({bool recursive: false}) {\n    if (recursive) {\n      return new Directory(path).delete(recursive: true).then((_) => this);\n    }\n    return _IOService.dispatch(_FILE_DELETE, [path]).then((response) {\n      if (_isErrorResponse(response)) {\n        throw _exceptionFromResponse(response, \"Cannot delete file\", path);\n      }\n      return this;\n    });\n  }\n\n  external static _deleteNative(String path);\n\n  external static _deleteLinkNative(String path);\n\n  void _deleteSync({bool recursive: false}) {\n    if (recursive) {\n      return new Directory(path).deleteSync(recursive: true);\n    }\n    var result = _deleteNative(path);\n    throwIfError(result, \"Cannot delete file\", path);\n  }\n\n  Future<File> rename(String newPath) {\n    return _IOService.dispatch(_FILE_RENAME, [path, newPath]).then((response) {\n      if (_isErrorResponse(response)) {\n        throw _exceptionFromResponse(\n            response, \"Cannot rename file to '$newPath'\", path);\n      }\n      return new File(newPath);\n    });\n  }\n\n  external static _rename(String oldPath, String newPath);\n\n  external static _renameLink(String oldPath, String newPath);\n\n  File renameSync(String newPath) {\n    var result = _rename(path, newPath);\n    throwIfError(result, \"Cannot rename file to '$newPath'\", path);\n    return new File(newPath);\n  }\n\n  Future<File> copy(String newPath) {\n    return _IOService.dispatch(_FILE_COPY, [path, newPath]).then((response) {\n      if (_isErrorResponse(response)) {\n        throw _exceptionFromResponse(\n            response, \"Cannot copy file to '$newPath'\", path);\n      }\n      return new File(newPath);\n    });\n  }\n\n  external static _copy(String oldPath, String newPath);\n\n  File copySync(String newPath) {\n    var result = _copy(path, newPath);\n    throwIfError(result, \"Cannot copy file to '$newPath'\", path);\n    return new File(newPath);\n  }\n\n  Future<RandomAccessFile> open({FileMode mode: FileMode.READ}) {\n    if (mode != FileMode.READ &&\n        mode != FileMode.WRITE &&\n        mode != FileMode.APPEND) {\n      return new Future.error(new ArgumentError());\n    }\n    return _IOService.dispatch(_FILE_OPEN, [path, mode._mode]).then((response) {\n      if (_isErrorResponse(response)) {\n        throw _exceptionFromResponse(response, \"Cannot open file\", path);\n      }\n      return new _RandomAccessFile(response, path);\n    });\n  }\n\n  Future<int> length() {\n    return _IOService.dispatch(_FILE_LENGTH_FROM_PATH, [path]).then((response) {\n      if (_isErrorResponse(response)) {\n        throw _exceptionFromResponse(response,\n                                     \"Cannot retrieve length of file\",\n                                     path);\n      }\n      return response;\n    });\n  }\n\n\n  external static _lengthFromPath(String path);\n\n  int lengthSync() {\n    var result = _lengthFromPath(path);\n    throwIfError(result, \"Cannot retrieve length of file\", path);\n    return result;\n  }\n\n  Future<DateTime> lastModified() {\n    return _IOService.dispatch(_FILE_LAST_MODIFIED, [path]).then((response) {\n      if (_isErrorResponse(response)) {\n        throw _exceptionFromResponse(response,\n                                     \"Cannot retrieve modification time\",\n                                     path);\n      }\n      return new DateTime.fromMillisecondsSinceEpoch(response);\n    });\n  }\n\n  external static _lastModified(String path);\n\n  DateTime lastModifiedSync() {\n    var ms = _lastModified(path);\n    throwIfError(ms, \"Cannot retrieve modification time\", path);\n    return new DateTime.fromMillisecondsSinceEpoch(ms);\n  }\n\n  external static _open(String path, int mode);\n\n  RandomAccessFile openSync({FileMode mode: FileMode.READ}) {\n    if (mode != FileMode.READ &&\n        mode != FileMode.WRITE &&\n        mode != FileMode.APPEND) {\n      throw new FileSystemException(\"Unknown file mode. Use FileMode.READ, \"\n                              \"FileMode.WRITE or FileMode.APPEND.\",\n                              path);\n    }\n    var id = _open(path, mode._mode);\n    throwIfError(id, \"Cannot open file\", path);\n    return new _RandomAccessFile(id, path);\n  }\n\n  external static int _openStdio(int fd);\n\n  static RandomAccessFile _openStdioSync(int fd) {\n    var id = _openStdio(fd);\n    if (id == 0) {\n      throw new FileSystemException(\"Cannot open stdio file for: $fd\");\n    }\n    return new _RandomAccessFile(id, \"\");\n  }\n\n  Stream<List<int>> openRead([int start, int end]) {\n    return new _FileStream(path, start, end);\n  }\n\n  IOSink openWrite({FileMode mode: FileMode.WRITE,\n                    Encoding encoding: UTF8}) {\n    if (mode != FileMode.WRITE &&\n        mode != FileMode.APPEND) {\n      throw new ArgumentError(\n          \"Wrong FileMode. Use FileMode.WRITE or FileMode.APPEND\");\n    }\n    var consumer = new _FileStreamConsumer(this, mode);\n    return new IOSink(consumer, encoding: encoding);\n  }\n\n  Future<List<int>> readAsBytes() {\n    Future<List<int>> readDataChunked(file) {\n      var builder = new BytesBuilder(copy: false);\n      var completer = new Completer();\n      void read() {\n        file.read(_BLOCK_SIZE).then((data) {\n          if (data.length > 0) builder.add(data);\n          if (data.length == _BLOCK_SIZE) {\n            read();\n          } else {\n            completer.complete(builder.takeBytes());\n          }\n        }, onError: completer.completeError);\n      }\n      read();\n      return completer.future;\n    }\n\n    return open().then((file) {\n      return file.length().then((length) {\n        if (length == 0) {\n          // May be character device, try to read it in chunks.\n          return readDataChunked(file);\n        }\n        return file.read(length);\n      }).whenComplete(file.close);\n    });\n  }\n\n  List<int> readAsBytesSync() {\n    var opened = openSync();\n    try {\n      var data;\n      var length = opened.lengthSync();\n      if (length == 0) {\n        // May be character device, try to read it in chunks.\n        var builder = new BytesBuilder(copy: false);\n        do {\n          data = opened.readSync(_BLOCK_SIZE);\n          if (data.length > 0) builder.add(data);\n        } while (data.length == _BLOCK_SIZE);\n        data = builder.takeBytes();\n      } else {\n        data = opened.readSync(length);\n      }\n      return data;\n    } finally {\n      opened.closeSync();\n    }\n  }\n\n  String _tryDecode(List<int> bytes, Encoding encoding) {\n    try {\n      return encoding.decode(bytes);\n    } catch (_) {\n      throw new FileSystemException(\n          \"Failed to decode data using encoding '${encoding.name}'\", path);\n    }\n  }\n\n  Future<String> readAsString({Encoding encoding: UTF8}) =>\n    readAsBytes().then((bytes) => _tryDecode(bytes, encoding));\n\n  String readAsStringSync({Encoding encoding: UTF8}) =>\n    _tryDecode(readAsBytesSync(), encoding);\n\n  Future<List<String>> readAsLines({Encoding encoding: UTF8}) =>\n    readAsString(encoding: encoding).then(const LineSplitter().convert);\n\n  List<String> readAsLinesSync({Encoding encoding: UTF8}) =>\n    const LineSplitter().convert(readAsStringSync(encoding: encoding));\n\n  Future<File> writeAsBytes(List<int> bytes,\n                            {FileMode mode: FileMode.WRITE,\n                             bool flush: false}) {\n    return open(mode: mode).then((file) {\n      return file.writeFrom(bytes, 0, bytes.length)\n          .then((_) {\n            if (flush) return file.flush().then((_) => this);\n            return this;\n          })\n          .whenComplete(file.close);\n    });\n  }\n\n  void writeAsBytesSync(List<int> bytes,\n                        {FileMode mode: FileMode.WRITE,\n                         bool flush: false}) {\n    RandomAccessFile opened = openSync(mode: mode);\n    try {\n      opened.writeFromSync(bytes, 0, bytes.length);\n      if (flush) opened.flushSync();\n    } finally {\n      opened.closeSync();\n    }\n  }\n\n  Future<File> writeAsString(String contents,\n                             {FileMode mode: FileMode.WRITE,\n                              Encoding encoding: UTF8,\n                              bool flush: false}) {\n    try {\n      return writeAsBytes(encoding.encode(contents), mode: mode, flush: flush);\n    } catch (e) {\n      return new Future.error(e);\n    }\n  }\n\n  void writeAsStringSync(String contents,\n                         {FileMode mode: FileMode.WRITE,\n                          Encoding encoding: UTF8,\n                          bool flush: false}) {\n    writeAsBytesSync(encoding.encode(contents), mode: mode, flush: flush);\n  }\n\n  String toString() => \"File: '$path'\";\n\n  static throwIfError(Object result, String msg, String path) {\n    if (result is OSError) {\n      throw new FileSystemException(msg, path, result);\n    }\n  }\n}\n\n\nclass _RandomAccessFile\n    extends Object with _ServiceObject\n    implements RandomAccessFile {\n  // Use default Map so we keep order.\n  static Map<int, _RandomAccessFile> _files = new Map<int, _RandomAccessFile>();\n\n  final String path;\n  int _id;\n  bool _asyncDispatched = false;\n  SendPort _fileService;\n\n  int _totalRead = 0;\n  int _totalWritten = 0;\n  int _readCount = 0;\n  int _writeCount = 0;\n\n\n  _RandomAccessFile(this._id, this.path) {\n    _files[_serviceId] = this;\n  }\n\n  String get _serviceTypePath => 'io/file/randomaccessfiles';\n  String get _serviceTypeName => 'RandomAccessFile';\n\n  Map _toJSON(bool ref) {\n    var r = {\n      'id': _servicePath,\n      'type': _serviceType(ref),\n      'name': '$path',\n      'user_name': '$path',\n    };\n    if (ref) {\n      return r;\n    }\n    r['asyncDispatched'] = _asyncDispatched;\n    r['fd'] = _getFD(_id);\n    r['totalRead'] = _totalRead;\n    r['totalWritten'] = _totalWritten;\n    r['readCount'] = _totalWritten;\n    r['writeCount'] = _writeCount;\n    return r;\n  }\n\n  void _maybePerformCleanup() {\n    if (closed) {\n      _files.remove(_serviceId);\n    }\n  }\n\n  external static int _getFD(int id);\n\n  Future<RandomAccessFile> close() {\n    return _dispatch(_FILE_CLOSE, [_id], markClosed: true).then((result) {\n      if (result != -1) {\n        _id = result;\n        _maybePerformCleanup();\n        return this;\n      } else {\n        throw new FileSystemException(\"Cannot close file\", path);\n      }\n    });\n  }\n\n  external static int _close(int id);\n\n  void closeSync() {\n    _checkAvailable();\n    var id = _close(_id);\n    if (id == -1) {\n      throw new FileSystemException(\"Cannot close file\", path);\n    }\n    _id = id;\n    _maybePerformCleanup();\n  }\n\n  Future<int> readByte() {\n    return _dispatch(_FILE_READ_BYTE, [_id]).then((response) {\n      if (_isErrorResponse(response)) {\n        throw _exceptionFromResponse(response, \"readByte failed\", path);\n      }\n      _readCount++;\n      _totalRead++;\n      return response;\n    });\n  }\n\n  external static _readByte(int id);\n\n  int readByteSync() {\n    _checkAvailable();\n    var result = _readByte(_id);\n    if (result is OSError) {\n      throw new FileSystemException(\"readByte failed\", path, result);\n    }\n    _readCount++;\n    _totalRead++;\n    return result;\n  }\n\n  Future<List<int>> read(int bytes) {\n    if (bytes is !int) {\n      throw new ArgumentError(bytes);\n    }\n    return _dispatch(_FILE_READ, [_id, bytes]).then((response) {\n      if (_isErrorResponse(response)) {\n        throw _exceptionFromResponse(response, \"read failed\", path);\n      }\n      _readCount++;\n      _totalRead += response[1].length;\n      return response[1];\n    });\n  }\n\n  external static _read(int id, int bytes);\n\n  List<int> readSync(int bytes) {\n    _checkAvailable();\n    if (bytes is !int) {\n      throw new ArgumentError(bytes);\n    }\n    var result = _read(_id, bytes);\n    if (result is OSError) {\n      throw new FileSystemException(\"readSync failed\", path, result);\n    }\n    _readCount++;\n    _totalRead += result.length;\n    return result;\n  }\n\n  Future<int> readInto(List<int> buffer, [int start, int end]) {\n    if (buffer is !List ||\n        (start != null && start is !int) ||\n        (end != null && end is !int)) {\n      throw new ArgumentError();\n    }\n    if (start == null) start = 0;\n    if (end == null) end = buffer.length;\n    int length = end - start;\n    return _dispatch(_FILE_READ_INTO, [_id, length]).then((response) {\n      if (_isErrorResponse(response)) {\n        throw _exceptionFromResponse(response, \"readInto failed\", path);\n      }\n      var read = response[1];\n      var data = response[2];\n      buffer.setRange(start, start + read, data);\n      _readCount++;\n      _totalRead += read;\n      return read;\n    });\n  }\n\n  static void _checkReadWriteListArguments(int length, int start, int end) {\n    if (start < 0) throw new RangeError.value(start);\n    if (end < start) throw new RangeError.value(end);\n    if (end > length) {\n      throw new RangeError.value(end);\n    }\n  }\n\n  external static _readInto(int id, List<int> buffer, int start, int end);\n\n  int readIntoSync(List<int> buffer, [int start, int end]) {\n    _checkAvailable();\n    if (buffer is !List ||\n        (start != null && start is !int) ||\n        (end != null && end is !int)) {\n      throw new ArgumentError();\n    }\n    if (start == null) start = 0;\n    if (end == null) end = buffer.length;\n    if (end == start) return 0;\n    _checkReadWriteListArguments(buffer.length, start, end);\n    var result = _readInto(_id, buffer, start, end);\n    if (result is OSError) {\n      throw new FileSystemException(\"readInto failed\", path, result);\n    }\n    _readCount++;\n    _totalRead += result;\n    return result;\n  }\n\n  Future<RandomAccessFile> writeByte(int value) {\n    if (value is !int) {\n      throw new ArgumentError(value);\n    }\n    return _dispatch(_FILE_WRITE_BYTE, [_id, value]).then((response) {\n      if (_isErrorResponse(response)) {\n        throw _exceptionFromResponse(response, \"writeByte failed\", path);\n      }\n      _writeCount++;\n      _totalWritten++;\n      return this;\n    });\n  }\n\n  external static _writeByte(int id, int value);\n\n  int writeByteSync(int value) {\n    _checkAvailable();\n    if (value is !int) {\n      throw new ArgumentError(value);\n    }\n    var result = _writeByte(_id, value);\n    if (result is OSError) {\n      throw new FileSystemException(\"writeByte failed\", path, result);\n    }\n    _writeCount++;\n    _totalWritten++;\n    return result;\n  }\n\n  Future<RandomAccessFile> writeFrom(List<int> buffer, [int start, int end]) {\n    if ((buffer is !List && buffer is !ByteData) ||\n        (start != null && start is !int) ||\n        (end != null && end is !int)) {\n      throw new ArgumentError(\"Invalid arguments to writeFrom\");\n    }\n\n    _BufferAndStart result;\n    try {\n      result = _ensureFastAndSerializableByteData(buffer, start, end);\n    } catch (e) {\n      return new Future.error(e);\n    }\n\n    List request = new List(4);\n    request[0] = _id;\n    request[1] = result.buffer;\n    request[2] = result.start;\n    request[3] = end - (start - result.start);\n    return _dispatch(_FILE_WRITE_FROM, request).then((response) {\n      if (_isErrorResponse(response)) {\n        throw _exceptionFromResponse(response, \"writeFrom failed\", path);\n      }\n      _writeCount++;\n      _totalWritten += end - (start - result.start);\n      return this;\n    });\n  }\n\n  external static _writeFrom(int id, List<int> buffer, int start, int end);\n\n  void writeFromSync(List<int> buffer, [int start, int end]) {\n    _checkAvailable();\n    if (buffer is !List ||\n        (start != null && start is !int) ||\n        (end != null && end is !int)) {\n      throw new ArgumentError(\"Invalid arguments to writeFromSync\");\n    }\n    if (start == null) start = 0;\n    if (end == null) end = buffer.length;\n    if (end == start) return;\n    _checkReadWriteListArguments(buffer.length, start, end);\n    _BufferAndStart bufferAndStart =\n        _ensureFastAndSerializableByteData(buffer, start, end);\n    var result = _writeFrom(_id,\n                            bufferAndStart.buffer,\n                            bufferAndStart.start,\n                            end - (start - bufferAndStart.start));\n    if (result is OSError) {\n      throw new FileSystemException(\"writeFrom failed\", path, result);\n    }\n    _writeCount++;\n    _totalWritten += end - (start - bufferAndStart.start);\n  }\n\n  Future<RandomAccessFile> writeString(String string,\n                                       {Encoding encoding: UTF8}) {\n    if (encoding is! Encoding) {\n      throw new ArgumentError(encoding);\n    }\n    var data = encoding.encode(string);\n    return writeFrom(data, 0, data.length);\n  }\n\n  void writeStringSync(String string, {Encoding encoding: UTF8}) {\n    if (encoding is! Encoding) {\n      throw new ArgumentError(encoding);\n    }\n    var data = encoding.encode(string);\n    writeFromSync(data, 0, data.length);\n  }\n\n  Future<int> position() {\n    return _dispatch(_FILE_POSITION, [_id]).then((response) {\n      if (_isErrorResponse(response)) {\n        throw _exceptionFromResponse(response, \"position failed\", path);\n      }\n      return response;\n    });\n  }\n\n  external static _position(int id);\n\n  int positionSync() {\n    _checkAvailable();\n    var result = _position(_id);\n    if (result is OSError) {\n      throw new FileSystemException(\"position failed\", path, result);\n    }\n    return result;\n  }\n\n  Future<RandomAccessFile> setPosition(int position) {\n    return _dispatch(_FILE_SET_POSITION, [_id, position])\n        .then((response) {\n          if (_isErrorResponse(response)) {\n            throw _exceptionFromResponse(response, \"setPosition failed\", path);\n          }\n          return this;\n        });\n  }\n\n  external static _setPosition(int id, int position);\n\n  void setPositionSync(int position) {\n    _checkAvailable();\n    var result = _setPosition(_id, position);\n    if (result is OSError) {\n      throw new FileSystemException(\"setPosition failed\", path, result);\n    }\n  }\n\n  Future<RandomAccessFile> truncate(int length) {\n    return _dispatch(_FILE_TRUNCATE, [_id, length]).then((response) {\n      if (_isErrorResponse(response)) {\n        throw _exceptionFromResponse(response, \"truncate failed\", path);\n      }\n      return this;\n    });\n  }\n\n  external static _truncate(int id, int length);\n\n  void truncateSync(int length) {\n    _checkAvailable();\n    var result = _truncate(_id, length);\n    if (result is OSError) {\n      throw new FileSystemException(\"truncate failed\", path, result);\n    }\n  }\n\n  Future<int> length() {\n    return _dispatch(_FILE_LENGTH, [_id]).then((response) {\n      if (_isErrorResponse(response)) {\n        throw _exceptionFromResponse(response, \"length failed\", path);\n      }\n      return response;\n    });\n  }\n\n  external static _length(int id);\n\n  int lengthSync() {\n    _checkAvailable();\n    var result = _length(_id);\n    if (result is OSError) {\n      throw new FileSystemException(\"length failed\", path, result);\n    }\n    return result;\n  }\n\n  Future<RandomAccessFile> flush() {\n    return _dispatch(_FILE_FLUSH, [_id]).then((response) {\n      if (_isErrorResponse(response)) {\n        throw _exceptionFromResponse(response,\n                                     \"flush failed\",\n                                     path);\n      }\n      return this;\n    });\n  }\n\n  external static _flush(int id);\n\n  void flushSync() {\n    _checkAvailable();\n    var result = _flush(_id);\n    if (result is OSError) {\n      throw new FileSystemException(\"flush failed\", path, result);\n    }\n  }\n\n  bool get closed => _id == 0;\n\n  Future _dispatch(int request, List data, { bool markClosed: false }) {\n    if (closed) {\n      return new Future.error(new FileSystemException(\"File closed\", path));\n    }\n    if (_asyncDispatched) {\n      var msg = \"An async operation is currently pending\";\n      return new Future.error(new FileSystemException(msg, path));\n    }\n    if (markClosed) {\n      // Set the id_ to 0 (NULL) to ensure the no more async requests\n      // can be issued for this file.\n      _id = 0;\n    }\n    _asyncDispatched = true;\n    return _IOService.dispatch(request, data)\n        .whenComplete(() {\n          _asyncDispatched = false;\n        });\n  }\n\n  void _checkAvailable() {\n    if (_asyncDispatched) {\n      throw new FileSystemException(\"An async operation is currently pending\",\n                                    path);\n    }\n    if (closed) {\n      throw new FileSystemException(\"File closed\", path);\n    }\n  }\n}\n\u0000","sdk:/sdk/lib/io/file.dart":"// Copyright (c) 2013, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\npart of dart.io;\n\n/**\n * The modes in which a File can be opened.\n */\nclass FileMode {\n  /// The mode for opening a file only for reading.\n  static const READ = const FileMode._internal(0);\n  /// The mode for opening a file for reading and writing. The file is\n  /// overwritten if it already exists. The file is created if it does not\n  /// already exist.\n  static const WRITE = const FileMode._internal(1);\n  /// The mode for opening a file for reading and writing to the\n  /// end of it. The file is created if it does not already exist.\n  static const APPEND = const FileMode._internal(2);\n  final int _mode;\n\n  const FileMode._internal(this._mode);\n}\n\n/// The mode for opening a file only for reading.\nconst READ = FileMode.READ;\n/// The mode for opening a file for reading and writing. The file is\n/// overwritten if it already exists. The file is created if it does not\n/// already exist.\nconst WRITE = FileMode.WRITE;\n/// The mode for opening a file for reading and writing to the\n/// end of it. The file is created if it does not already exist.\nconst APPEND = FileMode.APPEND;\n\n/**\n * A reference to a file on the file system.\n *\n * A File instance is an object that holds a [path] on which operations can\n * be performed.\n * You can get the parent directory of the file using the getter [parent],\n * a property inherited from [FileSystemEntity].\n *\n * Create a new File object with a pathname to access the specified file on the\n * file system from your program.\n *\n *     var myFile = new File('file.txt');\n *\n * The File class contains methods for manipulating files and their contents.\n * Using methods in this class, you can open and close files, read to and write\n * from them, create and delete them, and check for their existence.\n *\n * When reading or writing a file, you can use streams (with [openRead]),\n * random access operations (with [open]),\n * or convenience methods such as [readAsString],\n *\n * Most methods in this class occur in synchronous and asynchronous pairs,\n * for example, [readAsString] and [readAsStringSync].\n * Unless you have a specific reason for using the synchronous version\n * of a method, prefer the asynchronous version to avoid blocking your program.\n *\n * ## If path is a link\n *\n * If [path] is a symbolic link, rather than a file,\n * then the methods of File operate on the ultimate target of the\n * link, except for [delete] and [deleteSync], which operate on\n * the link.\n *\n * ## Read from a file\n *\n * The following code sample reads the entire contents from a file as a string\n * using the asynchronous [readAsString] method:\n *\n *     import 'dart:async';\n *     import 'dart:io';\n *\n *     void main() {\n *       new File('file.txt').readAsString().then((String contents) {\n *         print(contents);\n *       });\n *     }\n *\n * A more flexible and useful way to read a file is with a [Stream].\n * Open the file with [openRead], which returns a stream that\n * provides the data in the file as chunks of bytes.\n * Listen to the stream for data and process as needed.\n * You can use various transformers in succession to manipulate the\n * data into the required format or to prepare it for output.\n *\n * You might want to use a stream to read large files,\n * to manipulate the data with tranformers,\n * or for compatibility with another API, such as [WebSocket]s.\n * \n *     import 'dart:io';\n *     import 'dart:convert';\n *     import 'dart:async';\n *\n *     main() {\n *       final file = new File('file.txt');\n *       Stream<List<int>> inputStream = file.openRead();\n *\n *       inputStream\n *         .transform(UTF8.decoder)       // Decode bytes to UTF8.\n *         .transform(new LineSplitter()) // Convert stream to individual lines.\n *         .listen((String line) {        // Process results.\n *             print('$line: ${line.length} bytes');\n *           },\n *           onDone: () { print('File is now closed.'); },\n *           onError: (e) { print(e.toString()); });\n *     }\n *\n * ## Write to a file\n *\n * To write a string to a file, use the [writeAsString] method:\n *\n *     import 'dart:io';\n *\n *     void main() {\n *       final filename = 'file.txt';\n *       new File(filename).writeAsString('some content')\n *         .then((File file) {\n *           // Do something with the file.\n *         });\n *     }\n *\n * You can also write to a file using a [Stream]. Open the file with\n * [openWrite], which returns a stream to which you can write data.\n * Be sure to close the file with the [close] method.\n *\n *     import 'dart:io';\n *    \n *     void main() {\n *       var file = new File('file.txt');\n *       var sink = file.openWrite();\n *       sink.write('FILE ACCESSED ${new DateTime.now()}\\n');\n *\n *       // Close the IOSink to free system resources.\n *       sink.close();\n *     }\n *\n * ## The use of Futures\n *\n * To avoid unintentional blocking of the program,\n * several methods use a [Future] to return a value. For example,\n * the [length] method, which gets the length of a file, returns a Future.\n * Use `then` to register a callback function, which is called when\n * the value is ready.\n *\n *     import 'dart:io';\n *\n *     main() {\n *       final file = new File('file.txt');\n *     \n *       file.length().then((len) {\n *         print(len);\n *       });\n *     }\n *\n * In addition to length, the [exists], [lastModified], [stat], and\n * other methods, return Futures.\n *\n * ## Other resources\n *\n * * [Dart by Example](https://www.dartlang.org/dart-by-example/#files-directories-and-symlinks)\n * provides additional task-oriented code samples that show how to use \n * various API from the Directory class and the related [File] class.\n *\n * * [I/O for Command-Line Apps](https://www.dartlang.org/docs/dart-up-and-running/contents/ch03.html#ch03-dartio---file-and-socket-io-for-command-line-apps)\n * a section from _A Tour of the Dart Libraries_\n * covers files and directories.\n *\n * * [Write Command-Line Apps](https://www.dartlang.org/docs/tutorials/cmdline/),\n * a tutorial about writing command-line apps, includes information\n * about files and directories.\n\n */\nabstract class File extends FileSystemEntity {\n  /**\n   * Creates a [File] object.\n   *\n   * If [path] is a relative path, it will be interpreted relative to the\n   * current working directory (see [Directory.current]), when used.\n   *\n   * If [path] is an absolute path, it will be immune to changes to the\n   * current working directory.\n   */\n  factory File(String path) => new _File(path);\n\n  /**\n   * Create a File object from a URI.\n   *\n   * If [uri] cannot reference a file this throws [UnsupportedError].\n   */\n  factory File.fromUri(Uri uri) => new File(uri.toFilePath());\n\n  /**\n   * Create the file. Returns a [:Future<File>:] that completes with\n   * the file when it has been created.\n   *\n   * If [recursive] is false, the default, the file is created only if\n   * all directories in the path exist. If [recursive] is true, all\n   * non-existing path components are created.\n   *\n   * Existing files are left untouched by [create]. Calling [create] on an\n   * existing file might fail if there are restrictive permissions on\n   * the file.\n   *\n   * Completes the future with a [FileSystemException] if the operation fails.\n   */\n  Future<File> create({bool recursive: false});\n\n  /**\n   * Synchronously create the file. Existing files are left untouched\n   * by [createSync]. Calling [createSync] on an existing file might fail\n   * if there are restrictive permissions on the file.\n   *\n   * If [recursive] is false, the default, the file is created\n   * only if all directories in the path exist.\n   * If [recursive] is true, all non-existing path components are created.\n   *\n   * Throws a [FileSystemException] if the operation fails.\n   */\n  void createSync({bool recursive: false});\n\n  /**\n   * Renames this file. Returns a `Future<File>` that completes\n   * with a [File] instance for the renamed file.\n   *\n   * If [newPath] identifies an existing file, that file is\n   * replaced. If [newPath] identifies an existing directory, the\n   * operation fails and the future completes with an exception.\n   */\n  Future<File> rename(String newPath);\n\n   /**\n   * Synchronously renames this file. Returns a [File]\n   * instance for the renamed file.\n   *\n   * If [newPath] identifies an existing file, that file is\n   * replaced. If [newPath] identifies an existing directory the\n   * operation fails and an exception is thrown.\n   */\n  File renameSync(String newPath);\n\n  /**\n   * Copy this file. Returns a `Future<File>` that completes\n   * with a [File] instance for the copied file.\n   *\n   * If [newPath] identifies an existing file, that file is\n   * replaced. If [newPath] identifies an existing directory, the\n   * operation fails and the future completes with an exception.\n   */\n  Future<File> copy(String newPath);\n\n   /**\n   * Synchronously copy this file. Returns a [File]\n   * instance for the copied file.\n   *\n   * If [newPath] identifies an existing file, that file is\n   * replaced. If [newPath] identifies an existing directory the\n   * operation fails and an exception is thrown.\n   */\n  File copySync(String newPath);\n\n  /**\n   * Get the length of the file. Returns a [:Future<int>:] that\n   * completes with the length in bytes.\n   */\n  Future<int> length();\n\n  /**\n   * Synchronously get the length of the file.\n   *\n   * Throws a [FileSystemException] if the operation fails.\n   */\n  int lengthSync();\n\n  /**\n   * Returns a [File] instance whose path is the absolute path to [this].\n   *\n   * The absolute path is computed by prefixing\n   * a relative path with the current working directory, and returning\n   * an absolute path unchanged.\n   */\n  File get absolute;\n\n  /**\n   * Get the last-modified time of the file. Returns a\n   * [:Future<DateTime>:] that completes with a [DateTime] object for the\n   * modification date.\n   */\n  Future<DateTime> lastModified();\n\n  /**\n   * Get the last-modified time of the file. Throws an exception\n   * if the file does not exist.\n   *\n   * Throws a [FileSystemException] if the operation fails.\n   */\n  DateTime lastModifiedSync();\n\n  /**\n   * Open the file for random access operations. Returns a\n   * [:Future<RandomAccessFile>:] that completes with the opened\n   * random access file. [RandomAccessFile]s must be closed using the\n   * [RandomAccessFile.close] method.\n   *\n   * Files can be opened in three modes:\n   *\n   * [FileMode.READ]: open the file for reading.\n   *\n   * [FileMode.WRITE]: open the file for both reading and writing and\n   * truncate the file to length zero. If the file does not exist the\n   * file is created.\n   *\n   * [FileMode.APPEND]: same as [FileMode.WRITE] except that the file is\n   * not truncated.\n   */\n  Future<RandomAccessFile> open({FileMode mode: FileMode.READ});\n\n  /**\n   * Synchronously open the file for random access operations. The\n   * result is a [RandomAccessFile] on which random access operations\n   * can be performed. Opened [RandomAccessFile]s must be closed using\n   * the [RandomAccessFile.close] method.\n   *\n   * See [open] for information on the [mode] argument.\n   *\n   * Throws a [FileSystemException] if the operation fails.\n   */\n  RandomAccessFile openSync({FileMode mode: FileMode.READ});\n\n  /**\n   * Create a new independent [Stream] for the contents of this file.\n   *\n   * If [start] is present, the file will be read from byte-offset [start].\n   * Otherwise from the beginning (index 0).\n   *\n   * If [end] is present, only up to byte-index [end] will be read. Otherwise,\n   * until end of file.\n   *\n   * In order to make sure that system resources are freed, the stream\n   * must be read to completion or the subscription on the stream must\n   * be cancelled.\n   */\n  Stream<List<int>> openRead([int start, int end]);\n\n  /**\n   * Creates a new independent [IOSink] for the file. The\n   * [IOSink] must be closed when no longer used, to free\n   * system resources.\n   *\n   * An [IOSink] for a file can be opened in two modes:\n   *\n   * * [FileMode.WRITE]: truncates the file to length zero.\n   * * [FileMode.APPEND]: sets the initial write position to the end\n   *   of the file.\n   *\n   *  When writing strings through the returned [IOSink] the encoding\n   *  specified using [encoding] will be used. The returned [IOSink]\n   *  has an [:encoding:] property which can be changed after the\n   *  [IOSink] has been created.\n   */\n  IOSink openWrite({FileMode mode: FileMode.WRITE,\n                    Encoding encoding: UTF8});\n\n  /**\n   * Read the entire file contents as a list of bytes. Returns a\n   * [:Future<List<int>>:] that completes with the list of bytes that\n   * is the contents of the file.\n   */\n  Future<List<int>> readAsBytes();\n\n  /**\n   * Synchronously read the entire file contents as a list of bytes.\n   *\n   * Throws a [FileSystemException] if the operation fails.\n   */\n  List<int> readAsBytesSync();\n\n  /**\n   * Read the entire file contents as a string using the given\n   * [Encoding].\n   *\n   * Returns a [:Future<String>:] that completes with the string once\n   * the file contents has been read.\n   */\n  Future<String> readAsString({Encoding encoding: UTF8});\n\n  /**\n   * Synchronously read the entire file contents as a string using the\n   * given [Encoding].\n   *\n   * Throws a [FileSystemException] if the operation fails.\n   */\n  String readAsStringSync({Encoding encoding: UTF8});\n\n  /**\n   * Read the entire file contents as lines of text using the given\n   * [Encoding].\n   *\n   * Returns a [:Future<List<String>>:] that completes with the lines\n   * once the file contents has been read.\n   */\n  Future<List<String>> readAsLines({Encoding encoding: UTF8});\n\n  /**\n   * Synchronously read the entire file contents as lines of text\n   * using the given [Encoding].\n   *\n   * Throws a [FileSystemException] if the operation fails.\n   */\n  List<String> readAsLinesSync({Encoding encoding: UTF8});\n\n  /**\n   * Write a list of bytes to a file.\n   *\n   * Opens the file, writes the list of bytes to it, and closes the file.\n   * Returns a [:Future<File>:] that completes with this [File] object once\n   * the entire operation has completed.\n   *\n   * By default [writeAsBytes] creates the file for writing and truncates the\n   * file if it already exists. In order to append the bytes to an existing\n   * file, pass [FileMode.APPEND] as the optional mode parameter.\n   *\n   * If the argument [flush] is set to `true`, the data written will be\n   * flushed to the file system before the returned future completes.\n   */\n  Future<File> writeAsBytes(List<int> bytes,\n                            {FileMode mode: FileMode.WRITE,\n                             bool flush: false});\n\n  /**\n   * Synchronously write a list of bytes to a file.\n   *\n   * Opens the file, writes the list of bytes to it and closes the file.\n   *\n   * By default [writeAsBytesSync] creates the file for writing and truncates\n   * the file if it already exists. In order to append the bytes to an existing\n   * file, pass [FileMode.APPEND] as the optional mode parameter.\n   *\n   * If the [flush] argument is set to `true` data written will be\n   * flushed to the file system before returning.\n   *\n   * Throws a [FileSystemException] if the operation fails.\n   */\n  void writeAsBytesSync(List<int> bytes,\n                        {FileMode mode: FileMode.WRITE,\n                         bool flush: false});\n\n  /**\n   * Write a string to a file.\n   *\n   * Opens the file, writes the string in the given encoding, and closes the\n   * file. Returns a [:Future<File>:] that completes with this [File] object\n   * once the entire operation has completed.\n   *\n   * By default [writeAsString] creates the file for writing and truncates the\n   * file if it already exists. In order to append the bytes to an existing\n   * file, pass [FileMode.APPEND] as the optional mode parameter.\n   *\n   * If the argument [flush] is set to `true`, the data written will be\n   * flushed to the file system before the returned future completes.\n   *\n   */\n  Future<File> writeAsString(String contents,\n                             {FileMode mode: FileMode.WRITE,\n                              Encoding encoding: UTF8,\n                              bool flush: false});\n\n  /**\n   * Synchronously write a string to a file.\n   *\n   * Opens the file, writes the string in the given encoding, and closes the\n   * file.\n   *\n   * By default [writeAsStringSync] creates the file for writing and\n   * truncates the file if it already exists. In order to append the bytes\n   * to an existing file, pass [FileMode.APPEND] as the optional mode\n   * parameter.\n   *\n   * If the [flush] argument is set to `true` data written will be\n   * flushed to the file system before returning.\n   *\n   * Throws a [FileSystemException] if the operation fails.\n   */\n  void writeAsStringSync(String contents,\n                         {FileMode mode: FileMode.WRITE,\n                          Encoding encoding: UTF8,\n                          bool flush: false});\n\n  /**\n   * Get the path of the file.\n   */\n  String get path;\n}\n\n\n/**\n * [RandomAccessFile] provides random access to the data in a\n * file. [RandomAccessFile] objects are obtained by calling the\n * [:open:] method on a [File] object.\n */\nabstract class RandomAccessFile {\n  /**\n   * Closes the file. Returns a [:Future<RandomAccessFile>:] that\n   * completes with this RandomAccessFile when it has been closed.\n   */\n  Future<RandomAccessFile> close();\n\n  /**\n   * Synchronously closes the file.\n   *\n   * Throws a [FileSystemException] if the operation fails.\n   */\n  void closeSync();\n\n  /**\n   * Reads a byte from the file. Returns a [:Future<int>:] that\n   * completes with the byte, or with -1 if end-of-file has been reached.\n   */\n  Future<int> readByte();\n\n  /**\n   * Synchronously reads a single byte from the file. If end-of-file\n   * has been reached -1 is returned.\n   *\n   * Throws a [FileSystemException] if the operation fails.\n   */\n  int readByteSync();\n\n  /**\n   * Reads [bytes] bytes from a file and returns the result as a list of bytes.\n   */\n  Future<List<int>> read(int bytes);\n\n  /**\n   * Synchronously reads a maximum of [bytes] bytes from a file and\n   * returns the result in a list of bytes.\n   *\n   * Throws a [FileSystemException] if the operation fails.\n   */\n  List<int> readSync(int bytes);\n\n  /**\n   * Reads into an existing List<int> from the file. If [start] is present, the\n   * bytes will be filled into [buffer] from at index [start], otherwise index\n   * 0. If [end] is present, the [end] - [start] bytes will be read into\n   * [buffer], otherwise up to [buffer.length]. If [end] == [start] nothing\n   * happends.\n   *\n   * Returns a [:Future<int>:] that completes with the number of bytes read.\n   */\n  Future<int> readInto(List<int> buffer, [int start, int end]);\n\n  /**\n   * Synchronously reads into an existing List<int> from the file. If [start] is\n   * present, the bytes will be filled into [buffer] from at index [start],\n   * otherwise index 0.  If [end] is present, the [end] - [start] bytes will be\n   * read into [buffer], otherwise up to [buffer.length]. If [end] == [start]\n   * nothing happends.\n   *\n   * Throws a [FileSystemException] if the operation fails.\n   */\n  int readIntoSync(List<int> buffer, [int start, int end]);\n\n  /**\n   * Writes a single byte to the file. Returns a\n   * [:Future<RandomAccessFile>:] that completes with this\n   * RandomAccessFile when the write completes.\n   */\n  Future<RandomAccessFile> writeByte(int value);\n\n  /**\n   * Synchronously writes a single byte to the file. Returns the\n   * number of bytes successfully written.\n   *\n   * Throws a [FileSystemException] if the operation fails.\n   */\n  int writeByteSync(int value);\n\n  /**\n   * Writes from a [List<int>] to the file. It will read the buffer from index\n   * [start] to index [end]. If [start] is omitted, it'll start from index 0.\n   * If [end] is omitted, it will write to end of [buffer].\n   *\n   * Returns a [:Future<RandomAccessFile>:] that completes with this\n   * [RandomAccessFile] when the write completes.\n   */\n  Future<RandomAccessFile> writeFrom(List<int> buffer, [int start, int end]);\n\n  /**\n   * Synchronously writes from a [List<int>] to the file. It will read the\n   * buffer from index [start] to index [end]. If [start] is omitted, it'll\n   * start from index 0. If [end] is omitted, it will write to the end of\n   * [buffer].\n   *\n   * Throws a [FileSystemException] if the operation fails.\n   */\n  void writeFromSync(List<int> buffer, [int start, int end]);\n\n  /**\n   * Writes a string to the file using the given [Encoding]. Returns a\n   * [:Future<RandomAccessFile>:] that completes with this\n   * RandomAccessFile when the write completes.\n   */\n  Future<RandomAccessFile> writeString(String string,\n                                       {Encoding encoding: UTF8});\n\n  /**\n   * Synchronously writes a single string to the file using the given\n   * [Encoding].\n   *\n   * Throws a [FileSystemException] if the operation fails.\n   */\n  void writeStringSync(String string,\n                       {Encoding encoding: UTF8});\n\n  /**\n   * Gets the current byte position in the file. Returns a\n   * [:Future<int>:] that completes with the position.\n   */\n  Future<int> position();\n\n  /**\n   * Synchronously gets the current byte position in the file.\n   *\n   * Throws a [FileSystemException] if the operation fails.\n   */\n  int positionSync();\n\n  /**\n   * Sets the byte position in the file. Returns a\n   * [:Future<RandomAccessFile>:] that completes with this\n   * RandomAccessFile when the position has been set.\n   */\n  Future<RandomAccessFile> setPosition(int position);\n\n  /**\n   * Synchronously sets the byte position in the file.\n   *\n   * Throws a [FileSystemException] if the operation fails.\n   */\n  void setPositionSync(int position);\n\n  /**\n   * Truncates (or extends) the file to [length] bytes. Returns a\n   * [:Future<RandomAccessFile>:] that completes with this\n   * RandomAccessFile when the truncation has been performed.\n   */\n  Future<RandomAccessFile> truncate(int length);\n\n  /**\n   * Synchronously truncates (or extends) the file to [length] bytes.\n   *\n   * Throws a [FileSystemException] if the operation fails.\n   */\n  void truncateSync(int length);\n\n  /**\n   * Gets the length of the file. Returns a [:Future<int>:] that\n   * completes with the length in bytes.\n   */\n  Future<int> length();\n\n  /**\n   * Synchronously gets the length of the file.\n   *\n   * Throws a [FileSystemException] if the operation fails.\n   */\n  int lengthSync();\n\n  /**\n   * Flushes the contents of the file to disk. Returns a\n   * [:Future<RandomAccessFile>:] that completes with this\n   * RandomAccessFile when the flush operation completes.\n   */\n  Future<RandomAccessFile> flush();\n\n  /**\n   * Synchronously flushes the contents of the file to disk.\n   *\n   * Throws a [FileSystemException] if the operation fails.\n   */\n  void flushSync();\n\n  /**\n   * Returns a human-readable string for this RandomAccessFile instance.\n   */\n  String toString();\n\n  /**\n   * Gets the path of the file underlying this RandomAccessFile.\n   */\n  String get path;\n}\n\n\n/**\n * Exception thrown when a file operation fails.\n */\nclass FileSystemException implements IOException {\n  /**\n   * Message describing the error. This does not include any detailed\n   * information form the underlying OS error. Check [osError] for\n   * that information.\n   */\n  final String message;\n\n  /**\n   * The file system path on which the error occurred. Can be `null`\n   * if the exception does not relate directly to a file system path.\n   */\n  final String path;\n\n  /**\n   * The underlying OS error. Can be `null` if the exception is not\n   * raised due to an OS error.\n   */\n  final OSError osError;\n\n  /**\n   * Creates a new FileSystemException with an optional error message\n   * [message], optional file system path [path] and optional OS error\n   * [osError].\n   */\n  const FileSystemException([this.message = \"\", this.path = \"\", this.osError]);\n\n  String toString() {\n    StringBuffer sb = new StringBuffer();\n    sb.write(\"FileSystemException\");\n    if (!message.isEmpty) {\n      sb.write(\": $message\");\n      if (path != null) {\n        sb.write(\", path = '$path'\");\n      }\n      if (osError != null) {\n        sb.write(\" ($osError)\");\n      }\n    } else if (osError != null) {\n      sb.write(\": $osError\");\n      if (path != null) {\n        sb.write(\", path = '$path'\");\n      }\n    } else if (path != null) {\n      sb.write(\": $path\");\n    }\n    return sb.toString();\n  }\n}\n\u0000","sdk:/sdk/lib/io/eventhandler.dart":"// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\npart of dart.io;\n\nclass _EventHandler {\n  external static void _sendData(Object sender,\n                                 SendPort sendPort,\n                                 int data);\n}\n\u0000","sdk:/sdk/lib/io/directory_impl.dart":"// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\npart of dart.io;\n\nclass _Directory extends FileSystemEntity implements Directory {\n  final String path;\n\n  _Directory(this.path) {\n    if (path is! String) {\n      throw new ArgumentError('${Error.safeToString(path)} '\n                              'is not a String');\n    }\n  }\n\n  external static _current();\n  external static _setCurrent(path);\n  external static _createTemp(String path);\n  external static String _systemTemp();\n  external static _exists(String path);\n  external static _create(String path);\n  external static _deleteNative(String path, bool recursive);\n  external static _rename(String path, String newPath);\n  external static List _list(String path, bool recursive, bool followLinks);\n\n  static Directory get current {\n    var result = _current();\n    if (result is OSError) {\n      throw new FileSystemException(\n          \"Getting current working directory failed\", \"\", result);\n    }\n    return new _Directory(result);\n  }\n\n  static void set current(path) {\n    if (path is Directory) path = path.path;\n    var result = _setCurrent(path);\n    if (result is ArgumentError) throw result;\n    if (result is OSError) {\n      throw new FileSystemException(\n          \"Setting current working directory failed\", path, result);\n    }\n  }\n\n  Future<bool> exists() {\n    return _IOService.dispatch(_DIRECTORY_EXISTS, [path]).then((response) {\n      if (_isErrorResponse(response)) {\n        throw _exceptionOrErrorFromResponse(response, \"Exists failed\");\n      }\n      return response == 1;\n    });\n  }\n\n  bool existsSync() {\n    var result = _exists(path);\n    if (result is OSError) {\n      throw new FileSystemException(\"Exists failed\", path, result);\n    }\n    return (result == 1);\n  }\n\n  Directory get absolute => new Directory(_absolutePath);\n\n  Future<FileStat> stat() => FileStat.stat(path);\n\n  FileStat statSync() => FileStat.statSync(path);\n\n  // Compute the index of the first directory in the list that exists. If\n  // none of the directories exist dirsToCreate.length is returned.\n  Future<int> _computeExistingIndex(List dirsToCreate) {\n    var future;\n    var notFound = dirsToCreate.length;\n    for (var i = 0; i < dirsToCreate.length; i++) {\n      if (future == null) {\n        future = dirsToCreate[i].exists().then((e) => e ? i : notFound);\n      } else {\n        future = future.then((index) {\n          if (index != notFound) {\n            return new Future.value(index);\n          }\n          return dirsToCreate[i].exists().then((e) => e ? i : notFound);\n        });\n      }\n    }\n    if (future == null) {\n      return new Future.value(notFound);\n    } else {\n      return future;\n    }\n  }\n\n  Future<Directory> create({bool recursive: false}) {\n    if (recursive) {\n      return exists().then((exists) {\n        if (exists) return this;\n        if (path != parent.path) {\n          return parent.create(recursive: true).then((_) {\n            return create();\n          });\n        } else {\n          return create();\n        }\n      });\n    } else {\n      return _IOService.dispatch(_DIRECTORY_CREATE, [path]).then((response) {\n        if (_isErrorResponse(response)) {\n          throw _exceptionOrErrorFromResponse(response, \"Creation failed\");\n        }\n        return this;\n      });\n    }\n  }\n\n  void createSync({bool recursive: false}) {\n    if (recursive) {\n      if (existsSync()) return;\n      if (path != parent.path) {\n        parent.createSync(recursive: true);\n      }\n    }\n    var result = _create(path);\n    if (result is OSError) {\n      throw new FileSystemException(\"Creation failed\", path, result);\n    }\n  }\n\n  static Directory get systemTemp => new Directory(_systemTemp());\n\n  Future<Directory> createTemp([String prefix]) {\n    if (prefix == null) prefix = '';\n    if (path == '') {\n      throw new ArgumentError(\n          \"Directory.createTemp called with an empty path. \"\n          \"To use the system temp directory, use Directory.systemTemp\");\n    }\n    String fullPrefix;\n    if (path.endsWith('/') || (Platform.isWindows && path.endsWith('\\\\'))) {\n      fullPrefix = \"$path$prefix\";\n    } else {\n      fullPrefix = \"$path${Platform.pathSeparator}$prefix\";\n    }\n    return _IOService.dispatch(_DIRECTORY_CREATE_TEMP, [fullPrefix])\n        .then((response) {\n      if (_isErrorResponse(response)) {\n        throw _exceptionOrErrorFromResponse(\n            response, \"Creation of temporary directory failed\");\n      }\n      return new Directory(response);\n    });\n  }\n\n  Directory createTempSync([String prefix]) {\n    if (prefix == null) prefix = '';\n    if (path == '') {\n      throw new ArgumentError(\n          \"Directory.createTemp called with an empty path. \"\n          \"To use the system temp directory, use Directory.systemTemp\");\n    }\n    String fullPrefix;\n    if (path.endsWith('/') || (Platform.isWindows && path.endsWith('\\\\'))) {\n      fullPrefix = \"$path$prefix\";\n    } else {\n      fullPrefix = \"$path${Platform.pathSeparator}$prefix\";\n    }\n    var result = _createTemp(fullPrefix);\n    if (result is OSError) {\n      throw new FileSystemException(\"Creation of temporary directory failed\",\n                                   fullPrefix,\n                                   result);\n    }\n    return new Directory(result);\n  }\n\n  Future<Directory> _delete({bool recursive: false}) {\n    return _IOService.dispatch(_DIRECTORY_DELETE, [path, recursive])\n        .then((response) {\n          if (_isErrorResponse(response)) {\n            throw _exceptionOrErrorFromResponse(response, \"Deletion failed\");\n          }\n          return this;\n        });\n  }\n\n  void _deleteSync({bool recursive: false}) {\n    var result = _deleteNative(path, recursive);\n    if (result is OSError) {\n      throw new FileSystemException(\"Deletion failed\", path, result);\n    }\n  }\n\n  Future<Directory> rename(String newPath) {\n    return _IOService.dispatch(_DIRECTORY_RENAME, [path, newPath])\n        .then((response) {\n          if (_isErrorResponse(response)) {\n            throw _exceptionOrErrorFromResponse(response, \"Rename failed\");\n          }\n          return new Directory(newPath);\n        });\n  }\n\n  Directory renameSync(String newPath) {\n    if (newPath is !String) {\n      throw new ArgumentError();\n    }\n    var result = _rename(path, newPath);\n    if (result is OSError) {\n      throw new FileSystemException(\"Rename failed\", path, result);\n    }\n    return new Directory(newPath);\n  }\n\n  Stream<FileSystemEntity> list({bool recursive: false,\n                                 bool followLinks: true}) {\n    return new _AsyncDirectoryLister(\n        FileSystemEntity._ensureTrailingPathSeparators(path),\n        recursive,\n        followLinks).stream;\n  }\n\n  List listSync({bool recursive: false, bool followLinks: true}) {\n    if (recursive is! bool || followLinks is! bool) {\n      throw new ArgumentError();\n    }\n    return _list(\n        FileSystemEntity._ensureTrailingPathSeparators(path),\n        recursive,\n        followLinks);\n  }\n\n  String toString() => \"Directory: '$path'\";\n\n  bool _isErrorResponse(response) =>\n      response is List && response[0] != _SUCCESS_RESPONSE;\n\n  _exceptionOrErrorFromResponse(response, String message) {\n    assert(_isErrorResponse(response));\n    switch (response[_ERROR_RESPONSE_ERROR_TYPE]) {\n      case _ILLEGAL_ARGUMENT_RESPONSE:\n        return new ArgumentError();\n      case _OSERROR_RESPONSE:\n        var err = new OSError(response[_OSERROR_RESPONSE_MESSAGE],\n                              response[_OSERROR_RESPONSE_ERROR_CODE]);\n        return new FileSystemException(message, path, err);\n      default:\n        return new Exception(\"Unknown error\");\n    }\n  }\n}\n\nclass _AsyncDirectoryLister {\n  static const int LIST_FILE = 0;\n  static const int LIST_DIRECTORY = 1;\n  static const int LIST_LINK = 2;\n  static const int LIST_ERROR = 3;\n  static const int LIST_DONE = 4;\n\n  static const int RESPONSE_TYPE = 0;\n  static const int RESPONSE_PATH = 1;\n  static const int RESPONSE_COMPLETE = 1;\n  static const int RESPONSE_ERROR = 2;\n\n  final String path;\n  final bool recursive;\n  final bool followLinks;\n\n  StreamController controller;\n  int id;\n  bool canceled = false;\n  bool nextRunning = false;\n  bool closed = false;\n  Completer closeCompleter = new Completer();\n\n  _AsyncDirectoryLister(this.path, this.recursive, this.followLinks) {\n    controller = new StreamController(onListen: onListen,\n                                      onResume: onResume,\n                                      onCancel: onCancel,\n                                      sync: true);\n  }\n\n  Stream get stream => controller.stream;\n\n  void onListen() {\n    _IOService.dispatch(_DIRECTORY_LIST_START, [path, recursive, followLinks])\n        .then((response) {\n          if (response is int) {\n            id = response;\n            next();\n          } else {\n            error(response);\n            close();\n          }\n        });\n  }\n\n  void onResume() {\n    if (!nextRunning) next();\n  }\n\n  Future onCancel() {\n    canceled = true;\n    // If we are active, but not requesting, close.\n    if (!nextRunning) {\n      close();\n    }\n\n    return closeCompleter.future;\n  }\n\n  void next() {\n    if (canceled) {\n      close();\n      return;\n    }\n    if (id == null) return;\n    if (controller.isPaused) return;\n    if (nextRunning) return;\n    nextRunning = true;\n    _IOService.dispatch(_DIRECTORY_LIST_NEXT, [id]).then((result) {\n      nextRunning = false;\n      if (result is List) {\n        next();\n        assert(result.length % 2 == 0);\n        for (int i = 0; i < result.length; i++) {\n          assert(i % 2 == 0);\n          switch (result[i++]) {\n            case LIST_FILE:\n              controller.add(new File(result[i]));\n              break;\n            case LIST_DIRECTORY:\n              controller.add(new Directory(result[i]));\n              break;\n            case LIST_LINK:\n              controller.add(new Link(result[i]));\n              break;\n            case LIST_ERROR:\n              error(result[i]);\n              break;\n            case LIST_DONE:\n              canceled = true;\n              return;\n          }\n        }\n      } else {\n        controller.addError(new FileSystemException(\"Internal error\"));\n      }\n    });\n  }\n\n  void close() {\n    if (closed) return;\n    if (nextRunning) return;\n    void cleanup() {\n      controller.close();\n      closeCompleter.complete();\n    }\n    closed = true;\n    if (id != null) {\n      _IOService.dispatch(_DIRECTORY_LIST_STOP, [id]).whenComplete(cleanup);\n    } else {\n      cleanup();\n    }\n  }\n\n  void error(message) {\n    var errorType =\n        message[RESPONSE_ERROR][_ERROR_RESPONSE_ERROR_TYPE];\n    if (errorType == _ILLEGAL_ARGUMENT_RESPONSE) {\n      controller.addError(new ArgumentError());\n    } else if (errorType == _OSERROR_RESPONSE) {\n      var responseError = message[RESPONSE_ERROR];\n      var err = new OSError(\n          responseError[_OSERROR_RESPONSE_MESSAGE],\n          responseError[_OSERROR_RESPONSE_ERROR_CODE]);\n      var errorPath = message[RESPONSE_PATH];\n      if (errorPath == null) errorPath = path;\n      controller.addError(\n          new FileSystemException(\"Directory listing failed\",\n                                 errorPath,\n                                 err));\n    } else {\n      controller.addError(\n          new FileSystemException(\"Internal error\"));\n    }\n  }\n}\n\u0000","sdk:/sdk/lib/io/directory.dart":"// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\npart of dart.io;\n\n/**\n * A reference to a directory (or _folder_) on the file system.\n *\n * A Directory instance is an object holding a [path] on which operations can\n * be performed. The path to the directory can be [absolute] or [relative].\n * You can get the parent directory using the getter [parent],\n * a property inherited from [FileSystemEntity].\n *\n * In addition to being used as an instance to access the file system,\n * Directory has a number of static properties, such as [systemTemp],\n * which gets the system's temporary directory, and the getter and setter\n * [current], which you can use to access or change the current directory.\n *\n * Create a new Directory object with a pathname to access the specified\n * directory on the file system from your program.\n *\n *     var myDir = new Directory('myDir');\n *\n * Most methods in this class occur in synchronous and asynchronous pairs,\n * for example, [create] and [createSync].\n * Unless you have a specific reason for using the synchronous version\n * of a method, prefer the asynchronous version to avoid blocking your program.\n *\n * ## Create a directory\n *\n * The following code sample creates a directory using the [create] method.\n * By setting the `recursive` parameter to true, you can create the\n * named directory and all its necessary parent directories,\n * if they do not already exist.\n *\n *     import 'dart:io';\n *\n *     void main() {\n *       // Creates dir/ and dir/subdir/.\n *       new Directory('dir/subdir').create(recursive: true)\n *         // The created directory is returned as a Future.\n *         .then((Directory directory) {\n *           print(directory.path);\n *       });\n *     }\n * \n * ## List a directory\n *\n * Use the [list] or [listSync] methods to get the files and directories\n * contained by a directory.\n * Set `recursive` to true to recursively list all subdirectories.\n * Set `followLinks` to true to follow symbolic links.\n * The list method returns a [Stream] that provides FileSystemEntity\n * objects. Use the listen callback function to process each object\n * as it become available.\n *\n *     import 'dart:io';\n *\n *     void main() {\n *       // Get the system temp directory.\n *       var systemTempDir = Directory.systemTemp;\n *\n *       // List directory contents, recursing into sub-directories,\n *       // but not following symbolic links.\n *       systemTempDir.list(recursive: true, followLinks: false)\n *         .listen((FileSystemEntity entity) {\n *           print(entity.path);\n *         });\n *     }\n *\n * ## The use of Futures\n *\n * I/O operations can block a program for some period of time while it waits for\n * the operation to complete. To avoid this, all\n * methods involving I/O have an asynchronous variant which returns a [Future].\n * This future completes when the I/O operation finishes. While the I/O\n * operation is in progress, the Dart program is not blocked,\n * and can perform other operations.\n *\n * For example,\n * the [exists] method, which determines whether the directory exists,\n * returns a boolean value using a Future.\n * Use `then` to register a callback function, which is called when\n * the value is ready.\n *\n *     import 'dart:io';\n *\n *     main() {\n *       final myDir = new Directory('dir');\n *       myDir.exists().then((isThere) {\n *         isThere ? print('exists') : print('non-existent');\n *       });\n *     }\n *\n *\n * In addition to exists, the [stat], [rename], and\n * other methods, return Futures.\n *\n * ## Other resources\n *\n * * [Dart by Example](https://www.dartlang.org/dart-by-example/#files-directories-and-symlinks)\n * provides additional task-oriented code samples that show how to use \n * various API from the Directory class and the related [File] class.\n *\n * * [I/O for Command-Line Apps](https://www.dartlang.org/docs/dart-up-and-running/contents/ch03.html#ch03-dartio---file-and-socket-io-for-command-line-apps)\n * a section from _A Tour of the Dart Libraries_\n * covers files and directories.\n *\n * * [Write Command-Line Apps](https://www.dartlang.org/docs/tutorials/cmdline/),\n * a tutorial about writing command-line apps, includes information\n * about files and directories.\n */\nabstract class Directory extends FileSystemEntity {\n  /**\n   * Gets the path of this directory.\n   */\n  final String path;\n\n  /**\n   * Creates a [Directory] object.\n   *\n   * If [path] is a relative path, it will be interpreted relative to the\n   * current working directory (see [Directory.current]), when used.\n   *\n   * If [path] is an absolute path, it will be immune to changes to the\n   * current working directory.\n   */\n  factory Directory(String path) => new _Directory(path);\n\n  /**\n   * Create a Directory object from a URI.\n   *\n   * If [uri] cannot reference a directory this throws [UnsupportedError].\n   */\n  factory Directory.fromUri(Uri uri) => new Directory(uri.toFilePath());\n\n  /**\n   * Creates a directory object pointing to the current working\n   * directory.\n   */\n  static Directory get current => _Directory.current;\n\n  /**\n   * Sets the current working directory of the Dart process including\n   * all running isolates. The new value set can be either a [Directory]\n   * or a [String].\n   *\n   * The new value is passed to the OS's system call unchanged, so a\n   * relative path passed as the new working directory will be\n   * resolved by the OS.\n   *\n   * Note that setting the current working directory is a synchronous\n   * operation and that it changes the the working directory of *all*\n   * isolates.\n   *\n   * Use this with care - especially when working with asynchronous\n   * operations and multiple isolates. Changing the working directory,\n   * while asynchronous operations are pending or when other isolates\n   * are working with the file system, can lead to unexpected results.\n   */\n  static void set current(path) {\n    _Directory.current = path;\n  }\n\n  /**\n   * Creates the directory with this name.\n   *\n   * If [recursive] is false, only the last directory in the path is\n   * created. If [recursive] is true, all non-existing path components\n   * are created. If the directory already exists nothing is done.\n   *\n   * Returns a [:Future<Directory>:] that completes with this\n   * directory once it has been created. If the directory cannot be\n   * created the future completes with an exception.\n   */\n  Future<Directory> create({bool recursive: false});\n\n  /**\n   * Synchronously creates the directory with this name.\n   *\n   * If [recursive] is false, only the last directory in the path is\n   * created. If [recursive] is true, all non-existing path components\n   * are created. If the directory already exists nothing is done.\n   *\n   * If the directory cannot be created an exception is thrown.\n   */\n  void createSync({bool recursive: false});\n\n  /**\n   * Gets the system temp directory.\n   *\n   * Gets the directory provided by the operating system for creating\n   * temporary files and directories in.\n   * The location of the system temp directory is platform-dependent,\n   * and may be set by an environment variable.\n   */\n  static Directory get systemTemp => _Directory.systemTemp;\n\n  /**\n   * Creates a temporary directory in this directory. Additional random\n   * characters are appended to [prefix] to produce a unique directory\n   * name. If [prefix] is missing or null, the empty string is used\n   * for [prefix].\n   *\n   * Returns a [:Future<Directory>:] that completes with the newly\n   * created temporary directory.\n   */\n  Future<Directory> createTemp([String prefix]);\n\n  /**\n   * Synchronously creates a temporary directory in this directory.\n   * Additional random characters are appended to [prefix] to produce\n   * a unique directory name. If [prefix] is missing or null, the empty\n   * string is used for [prefix].\n   *\n   * Returns the newly created temporary directory.\n   */\n  Directory createTempSync([String prefix]);\n\n  Future<String> resolveSymbolicLinks();\n\n  String resolveSymbolicLinksSync();\n\n  /**\n   * Renames this directory. Returns a [:Future<Directory>:] that completes\n   * with a [Directory] instance for the renamed directory.\n   *\n   * If newPath identifies an existing directory, that directory is\n   * replaced. If newPath identifies an existing file, the operation\n   * fails and the future completes with an exception.\n   */\n  Future<Directory> rename(String newPath);\n\n  /**\n   * Synchronously renames this directory. Returns a [Directory]\n   * instance for the renamed directory.\n   *\n   * If newPath identifies an existing directory, that directory is\n   * replaced. If newPath identifies an existing file the operation\n   * fails and an exception is thrown.\n   */\n  Directory renameSync(String newPath);\n\n  /**\n   * Returns a [Directory] instance whose path is the absolute path to [this].\n   *\n   * The absolute path is computed by prefixing\n   * a relative path with the current working directory, and returning\n   * an absolute path unchanged.\n   */\n  Directory get absolute;\n\n  /**\n   * Lists the sub-directories and files of this [Directory].\n   * Optionally recurses into sub-directories.\n   *\n   * If [followLinks] is false, then any symbolic links found\n   * are reported as [Link] objects, rather than as directories or files,\n   * and are not recursed into.\n   *\n   * If [followLinks] is true, then working links are reported as\n   * directories or files, depending on\n   * their type, and links to directories are recursed into.\n   * Broken links are reported as [Link] objects.\n   * If a symbolic link makes a loop in the file system, then a recursive\n   * listing will not follow a link twice in the\n   * same recursive descent, but will report it as a [Link]\n   * the second time it is seen.\n   *\n   * The result is a stream of [FileSystemEntity] objects\n   * for the directories, files, and links.\n   */\n  Stream<FileSystemEntity> list({bool recursive: false,\n                                 bool followLinks: true});\n\n  /**\n   * Lists the sub-directories and files of this [Directory].\n   * Optionally recurses into sub-directories.\n   *\n   * If [followLinks] is false, then any symbolic links found\n   * are reported as [Link] objects, rather than as directories or files,\n   * and are not recursed into.\n   *\n   * If [followLinks] is true, then working links are reported as\n   * directories or files, depending on\n   * their type, and links to directories are recursed into.\n   * Broken links are reported as [Link] objects.\n   * If a link makes a loop in the file system, then a recursive\n   * listing will not follow a link twice in the\n   * same recursive descent, but will report it as a [Link]\n   * the second time it is seen.\n   *\n   * Returns a [List] containing [FileSystemEntity] objects for the\n   * directories, files, and links.\n   */\n  List<FileSystemEntity> listSync({bool recursive: false,\n                                   bool followLinks: true});\n\n  /**\n   * Returns a human readable string for this Directory instance.\n   */\n  String toString();\n}\n\u0000","sdk:/sdk/lib/io/data_transformer.dart":"// Copyright (c) 2013, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\npart of dart.io;\n\n/**\n * Exposes ZLib options for input parameters.\n *\n * See http://www.zlib.net/manual.html for more documentation.\n */\nabstract class ZLibOption {\n  /// Minimal value for [ZLibCodec.windowBits], [ZLibEncoder.windowBits]\n  /// and [ZLibDecoder.windowBits].\n  static const int MIN_WINDOW_BITS = 8;\n  /// Maximal value for [ZLibCodec.windowBits], [ZLibEncoder.windowBits]\n  /// and [ZLibDecoder.windowBits].\n  static const int MAX_WINDOW_BITS = 15;\n  /// Default value for [ZLibCodec.windowBits], [ZLibEncoder.windowBits]\n  /// and [ZLibDecoder.windowBits].\n  static const int DEFAULT_WINDOW_BITS = 15;\n\n  /// Minimal value for [ZLibCodec.level], [ZLibEncoder.level]\n  /// and [ZLibDecoder.level].\n  static const int MIN_LEVEL = -1;\n  /// Maximal value for [ZLibCodec.level], [ZLibEncoder.level]\n  /// and [ZLibDecoder.level].\n  static const int MAX_LEVEL = 9;\n  /// Default value for [ZLibCodec.level], [ZLibEncoder.level]\n  /// and [ZLibDecoder.level].\n  static const int DEFAULT_LEVEL = 6;\n\n  /// Minimal value for [ZLibCodec.memLevel], [ZLibEncoder.memLevel]\n  /// and [ZLibDecoder.memLevel].\n  static const int MIN_MEM_LEVEL = 1;\n  /// Maximal value for [ZLibCodec.memLevel], [ZLibEncoder.memLevel]\n  /// and [ZLibDecoder.memLevel].\n  static const int MAX_MEM_LEVEL = 9;\n  /// Default value for [ZLibCodec.memLevel], [ZLibEncoder.memLevel]\n  /// and [ZLibDecoder.memLevel].\n  static const int DEFAULT_MEM_LEVEL = 8;\n\n\n  /// Recommended strategy for data produced by a filter (or predictor)\n  static const int STRATEGY_FILTERED = 1;\n  /// Use this strategy to force Huffman encoding only (no string match)\n  static const int STRATEGY_HUFFMAN_ONLY = 2;\n  /// Use this strategy to limit match distances to one (run-length encoding)\n  static const int STRATEGY_RLE = 3;\n  /// This strategy prevents the use of dynamic Huffman codes, allowing for a\n  /// simpler decoder\n  static const int STRATEGY_FIXED = 4;\n  /// Recommended strategy for normal data\n  static const int STRATEGY_DEFAULT = 0;\n}\n\n/**\n * An instance of the default implementation of the [ZLibCodec].\n */\nconst ZLibCodec ZLIB = const ZLibCodec._default();\n\n/**\n * The [ZLibCodec] encodes raw bytes to ZLib compressed bytes and decodes ZLib\n * compressed bytes to raw bytes.\n */\nclass ZLibCodec extends Codec<List<int>, List<int>> {\n  /**\n   * When true, `GZip` frames will be added to the compressed data.\n   */\n  final bool gzip;\n\n  /**\n   * The compression-[level] can be set in the range of `-1..9`, with `6` being\n   * the default compression level. Levels above `6` will have higher\n   * compression rates at the cost of more CPU and memory usage. Levels below\n   * `6` will use less CPU and memory at the cost of lower compression rates.\n   */\n  final int level;\n\n  /**\n   * Specifies how much memory should be allocated for the internal compression\n   * state. `1` uses minimum memory but is slow and reduces compression ratio;\n   * `9` uses maximum memory for optimal speed. The default value is `8`.\n   *\n   * The memory requirements for deflate are (in bytes):\n   *\n   *     (1 << (windowBits + 2)) +  (1 << (memLevel + 9))\n   * that is: 128K for windowBits = 15 + 128K for memLevel = 8 (default values)\n   */\n  final int memLevel;\n\n  /**\n   * Tunes the compression algorithm. Use the value STRATEGY_DEFAULT for normal\n   * data, STRATEGY_FILTERED for data produced by a filter (or predictor),\n   * STRATEGY_HUFFMAN_ONLY to force Huffman encoding only (no string match), or\n   * STRATEGY_RLE to limit match distances to one (run-length encoding).\n   */\n  final int strategy;\n\n  /**\n   * Base two logarithm of the window size (the size of the history buffer). It\n   * should be in the range 8..15. Larger values result in better compression at\n   * the expense of memory usage. The default value is 15\n   */\n  final int windowBits;\n\n  /**\n   * When true, deflate generates raw data with no zlib header or trailer, and\n   * will not compute an adler32 check value\n   */\n  final bool raw;\n\n  /**\n   * Initial compression dictionary.\n   *\n   * It should consist of strings (byte sequences) that are likely to be\n   * encountered later in the data to be compressed, with the most commonly used\n   * strings preferably put towards the end of the dictionary. Using a\n   * dictionary is most useful when the data to be compressed is short and can\n   * be predicted with good accuracy; the data can then be compressed better\n   * than with the default empty dictionary.\n   */\n  final List<int> dictionary;\n\n  ZLibCodec({this.level: ZLibOption.DEFAULT_LEVEL,\n            this.windowBits: ZLibOption.DEFAULT_WINDOW_BITS,\n            this.memLevel: ZLibOption.DEFAULT_MEM_LEVEL,\n            this.strategy: ZLibOption.STRATEGY_DEFAULT,\n            this.dictionary: null,\n            this.raw: false,\n            this.gzip: false}) {\n    _validateZLibeLevel(level);\n    _validateZLibMemLevel(memLevel);\n    _validateZLibStrategy(strategy);\n    _validateZLibWindowBits(windowBits);\n  }\n\n  const ZLibCodec._default()\n      : level = ZLibOption.DEFAULT_LEVEL,\n        windowBits = ZLibOption.DEFAULT_WINDOW_BITS,\n        memLevel = ZLibOption.DEFAULT_MEM_LEVEL,\n        strategy = ZLibOption.STRATEGY_DEFAULT,\n        raw = false,\n        gzip = false,\n        dictionary = null;\n\n  /**\n   * Get a [ZLibEncoder] for encoding to `ZLib` compressed data.\n   */\n  Converter<List<int>, List<int>> get encoder =>\n      new ZLibEncoder(gzip: false, level: level, windowBits: windowBits,\n                      memLevel: memLevel, strategy: strategy,\n                      dictionary: dictionary, raw: raw);\n\n  /**\n   * Get a [ZLibDecoder] for decoding `ZLib` compressed data.\n   */\n  Converter<List<int>, List<int>> get decoder =>\n      new ZLibDecoder(windowBits: windowBits, dictionary: dictionary, raw: raw);\n}\n\n\n/**\n * An instance of the default implementation of the [GZipCodec].\n */\nconst GZipCodec GZIP = const GZipCodec._default();\n\n\n/**\n * The [GZipCodec] encodes raw bytes to GZip compressed bytes and decodes GZip\n * compressed bytes to raw bytes.\n *\n * The difference between [ZLibCodec] and [GZipCodec] is that the [GZipCodec]\n * wraps the `ZLib` compressed bytes in `GZip` frames.\n */\nclass GZipCodec extends Codec<List<int>, List<int>> {\n  /**\n   * When true, `GZip` frames will be added to the compressed data.\n   */\n  final bool gzip;\n\n  /**\n   * The compression-[level] can be set in the range of `-1..9`, with `6` being\n   * the default compression level. Levels above `6` will have higher\n   * compression rates at the cost of more CPU and memory usage. Levels below\n   * `6` will use less CPU and memory at the cost of lower compression rates.\n   */\n  final int level;\n\n  /**\n   * Specifies how much memory should be allocated for the internal compression\n   * state. `1` uses minimum memory but is slow and reduces compression ratio;\n   * `9` uses maximum memory for optimal speed. The default value is `8`.\n   *\n   * The memory requirements for deflate are (in bytes):\n   *\n   *     (1 << (windowBits + 2)) +  (1 << (memLevel + 9))\n   * that is: 128K for windowBits = 15 + 128K for memLevel = 8 (default values)\n   */\n  final int memLevel;\n\n  /**\n   * Tunes the compression algorithm. Use the value\n   * [ZLibOption.STRATEGY_DEFAULT] for normal data,\n   * [ZLibOption.STRATEGY_FILTERED] for data produced by a filter\n   * (or predictor), [ZLibOption.STRATEGY_HUFFMAN_ONLY] to force Huffman\n   * encoding only (no string match), or [ZLibOption.STRATEGY_RLE] to limit\n   * match distances to one (run-length encoding).\n   */\n  final int strategy;\n\n  /**\n   * Base two logarithm of the window size (the size of the history buffer). It\n   * should be in the range `8..15`. Larger values result in better compression\n   * at the expense of memory usage. The default value is `15`\n   */\n  final int windowBits;\n\n  /**\n   * Initial compression dictionary.\n   *\n   * It should consist of strings (byte sequences) that are likely to be\n   * encountered later in the data to be compressed, with the most commonly used\n   * strings preferably put towards the end of the dictionary. Using a\n   * dictionary is most useful when the data to be compressed is short and can\n   * be predicted with good accuracy; the data can then be compressed better\n   * than with the default empty dictionary.\n   */\n  final List<int> dictionary;\n\n  /**\n   * When true, deflate generates raw data with no zlib header or trailer, and\n   * will not compute an adler32 check value\n   */\n  final bool raw;\n\n  GZipCodec({this.level: ZLibOption.DEFAULT_LEVEL,\n            this.windowBits: ZLibOption.DEFAULT_WINDOW_BITS,\n            this.memLevel: ZLibOption.DEFAULT_MEM_LEVEL,\n            this.strategy: ZLibOption.STRATEGY_DEFAULT,\n            this.dictionary: null,\n            this.raw: false,\n            this.gzip: true}) {\n    _validateZLibeLevel(level);\n    _validateZLibMemLevel(memLevel);\n    _validateZLibStrategy(strategy);\n    _validateZLibWindowBits(windowBits);\n  }\n\n  const GZipCodec._default()\n      : level = ZLibOption.DEFAULT_LEVEL,\n        windowBits = ZLibOption.DEFAULT_WINDOW_BITS,\n        memLevel = ZLibOption.DEFAULT_MEM_LEVEL,\n        strategy = ZLibOption.STRATEGY_DEFAULT,\n        raw = false,\n        gzip = true,\n        dictionary = null;\n\n  /**\n   * Get a [ZLibEncoder] for encoding to `GZip` compressed data.\n   */\n  Converter<List<int>, List<int>> get encoder =>\n      new ZLibEncoder(gzip: true, level: level, windowBits: windowBits,\n                      memLevel: memLevel, strategy: strategy,\n                      dictionary: dictionary, raw: raw);\n\n  /**\n   * Get a [ZLibDecoder] for decoding `GZip` compressed data.\n   */\n  Converter<List<int>, List<int>> get decoder =>\n      new ZLibDecoder(windowBits: windowBits, dictionary: dictionary, raw: raw);\n}\n\n/**\n * The [ZLibEncoder] encoder is used by [ZLibCodec] and [GZipCodec] to compress\n * data.\n */\nclass ZLibEncoder extends Converter<List<int>, List<int>> {\n  /**\n   * When true, `GZip` frames will be added to the compressed data.\n   */\n  final bool gzip;\n\n  /**\n   * The compression-[level] can be set in the range of `-1..9`, with `6` being\n   * the default compression level. Levels above `6` will have higher\n   * compression rates at the cost of more CPU and memory usage. Levels below\n   * `6` will use less CPU and memory at the cost of lower compression rates.\n   */\n  final int level;\n\n  /**\n   * Specifies how much memory should be allocated for the internal compression\n   * state. `1` uses minimum memory but is slow and reduces compression ratio;\n   * `9` uses maximum memory for optimal speed. The default value is `8`.\n   *\n   * The memory requirements for deflate are (in bytes):\n   *\n   *     (1 << (windowBits + 2)) +  (1 << (memLevel + 9))\n   * that is: 128K for windowBits = 15 + 128K for memLevel = 8 (default values)\n   */\n  final int memLevel;\n\n  /**\n   * Tunes the compression algorithm. Use the value\n   * [ZLibOption.STRATEGY_DEFAULT] for normal data,\n   * [ZLibOption.STRATEGY_FILTERED] for data produced by a filter\n   * (or predictor), [ZLibOption.STRATEGY_HUFFMAN_ONLY] to force Huffman\n   * encoding only (no string match), or [ZLibOption.STRATEGY_RLE] to limit\n   * match distances to one (run-length encoding).\n   */\n  final int strategy;\n\n  /**\n   * Base two logarithm of the window size (the size of the history buffer). It\n   * should be in the range `8..15`. Larger values result in better compression\n   * at the expense of memory usage. The default value is `15`\n   */\n  final int windowBits;\n\n  /**\n   * Initial compression dictionary.\n   *\n   * It should consist of strings (byte sequences) that are likely to be\n   * encountered later in the data to be compressed, with the most commonly used\n   * strings preferably put towards the end of the dictionary. Using a\n   * dictionary is most useful when the data to be compressed is short and can\n   * be predicted with good accuracy; the data can then be compressed better\n   * than with the default empty dictionary.\n   */\n  final List<int> dictionary;\n\n\n  /**\n   * When true, deflate generates raw data with no zlib header or trailer, and\n   * will not compute an adler32 check value\n   */\n  final bool raw;\n\n  ZLibEncoder({this.gzip: false,\n              this.level: ZLibOption.DEFAULT_LEVEL,\n              this.windowBits: ZLibOption.DEFAULT_WINDOW_BITS,\n              this.memLevel: ZLibOption.DEFAULT_MEM_LEVEL,\n              this.strategy: ZLibOption.STRATEGY_DEFAULT,\n              this.dictionary: null,\n              this.raw: false}) {\n    _validateZLibeLevel(level);\n    _validateZLibMemLevel(memLevel);\n    _validateZLibStrategy(strategy);\n    _validateZLibWindowBits(windowBits);\n  }\n\n  /**\n   * Convert a list of bytes using the options given to the ZLibEncoder\n   * constructor.\n   */\n  List<int> convert(List<int> bytes) {\n    _BufferSink sink = new _BufferSink();\n    startChunkedConversion(sink)..add(bytes)..close();\n    return sink.builder.takeBytes();\n  }\n\n  /**\n   * Start a chunked conversion using the options given to the [ZLibEncoder]\n   * constructor. While it accepts any [Sink] taking [List<int>]'s,\n   * the optimal sink to be passed as [sink] is a [ByteConversionSink].\n   */\n  ByteConversionSink startChunkedConversion(Sink<List<int>> sink) {\n    if (sink is! ByteConversionSink) {\n      sink = new ByteConversionSink.from(sink);\n    }\n    return new _ZLibEncoderSink(sink, gzip, level, windowBits, memLevel,\n                                strategy, dictionary, raw);\n  }\n}\n\n\n/**\n * The [ZLibDecoder] is used by [ZLibCodec] and [GZipCodec] to decompress data.\n */\nclass ZLibDecoder extends Converter<List<int>, List<int>> {\n  /**\n   * Base two logarithm of the window size (the size of the history buffer). It\n   * should be in the range `8..15`. Larger values result in better compression\n   * at the expense of memory usage. The default value is `15`.\n   */\n  final int windowBits;\n\n  /**\n   * Initial compression dictionary.\n   *\n   * It should consist of strings (byte sequences) that are likely to be\n   * encountered later in the data to be compressed, with the most commonly used\n   * strings preferably put towards the end of the dictionary. Using a\n   * dictionary is most useful when the data to be compressed is short and can\n   * be predicted with good accuracy; the data can then be compressed better\n   * than with the default empty dictionary.\n   */\n  final List<int> dictionary;\n\n  /**\n   * When true, deflate generates raw data with no zlib header or trailer, and\n   * will not compute an adler32 check value\n   */\n  final bool raw;\n\n  ZLibDecoder({this.windowBits: ZLibOption.DEFAULT_WINDOW_BITS,\n              this.dictionary: null, this.raw: false}) {\n    _validateZLibWindowBits(windowBits);\n  }\n\n  /**\n   * Convert a list of bytes using the options given to the [ZLibDecoder]\n   * constructor.\n   */\n  List<int> convert(List<int> bytes) {\n    _BufferSink sink = new _BufferSink();\n    startChunkedConversion(sink)..add(bytes)..close();\n    return sink.builder.takeBytes();\n  }\n\n  /**\n   * Start a chunked conversion. While it accepts any [Sink]\n   * taking [List<int>]'s, the optimal sink to be passed as [sink] is a\n   * [ByteConversionSink].\n   */\n  ByteConversionSink startChunkedConversion(Sink<List<int>> sink) {\n    if (sink is! ByteConversionSink) {\n      sink = new ByteConversionSink.from(sink);\n    }\n    return new _ZLibDecoderSink(sink, windowBits, dictionary, raw);\n  }\n}\n\n\nclass _BufferSink extends ByteConversionSink {\n  final BytesBuilder builder = new BytesBuilder(copy: false);\n\n  void add(List<int> chunk) {\n    builder.add(chunk);\n  }\n\n  void addSlice(List<int> chunk, int start, int end, bool isLast) {\n    if (chunk is Uint8List) {\n      Uint8List list = chunk;\n      builder.add(new Uint8List.view(list.buffer, start, end - start));\n    } else {\n      builder.add(chunk.sublist(start, end));\n    }\n  }\n\n  void close() {}\n}\n\n\nclass _ZLibEncoderSink extends _FilterSink {\n  _ZLibEncoderSink(ByteConversionSink sink, bool gzip, int level,\n                   int windowBits, int memLevel, int strategy,\n                   List<int> dictionary, bool raw)\n      : super(sink, _Filter.newZLibDeflateFilter(gzip, level, windowBits,\n                                                 memLevel, strategy,\n                                                 dictionary, raw));\n}\n\nclass _ZLibDecoderSink extends _FilterSink {\n  _ZLibDecoderSink(ByteConversionSink sink, int windowBits,\n                   List<int> dictionary, bool raw)\n      : super(sink, _Filter.newZLibInflateFilter(windowBits, dictionary, raw));\n}\n\n\nclass _FilterSink extends ByteConversionSink {\n  final _Filter _filter;\n  final ByteConversionSink _sink;\n  bool _closed = false;\n  bool _empty = true;\n\n  _FilterSink(this._sink, this._filter);\n\n  void add(List<int> data) {\n    addSlice(data, 0, data.length, false);\n  }\n\n  void addSlice(List<int> data, int start, int end, bool isLast) {\n    if (_closed) return;\n    if (start < 0 || start > data.length) {\n      throw new ArgumentError(\"Invalid start position\");\n    }\n    if (end < 0 || end > data.length || end < start) {\n      throw new ArgumentError(\"Invalid end position\");\n    }\n    try {\n      _empty = false;\n      _filter.process(data, start, end);\n      var out;\n      while ((out = _filter.processed(flush: false)) != null) {\n        _sink.add(out);\n      }\n    } catch (e) {\n      _closed = true;\n      throw e;\n    }\n\n    if (isLast) close();\n  }\n\n  void close() {\n    if (_closed) return;\n    // Be sure to send process an empty chunk of data. Without this, the empty\n    // message would not have a GZip frame (if compressed with GZip).\n    if (_empty) _filter.process(const [], 0, 0);\n    try {\n      var out;\n      while ((out = _filter.processed(end: true)) != null) {\n        _sink.add(out);\n      }\n    } catch (e) {\n      _closed = true;\n      throw e;\n    }\n    if (!_closed) _filter.end();\n    _closed = true;\n    _sink.close();\n  }\n}\n\n\n/**\n * Private helper-class to handle native filters.\n */\nabstract class _Filter {\n  /**\n   * Call to process a chunk of data. A call to [process] should only be made\n   * when [processed] returns [:null:].\n   */\n  void process(List<int> data, int start, int end);\n\n  /**\n   * Get a chunk of processed data. When there are no more data available,\n   * [processed] will return [:null:]. Set [flush] to [:false:] for non-final\n   * calls to improve performance of some filters.\n   *\n   * The last call to [processed] should have [end] set to [:true:]. This will\n   * make sure an 'end' packet is written on the stream.\n   */\n  List<int> processed({bool flush: true, bool end: false});\n\n  /**\n   * Mark the filter as closed. Always call this method for any filter created\n   * to avoid leaking resources. [end] can be called at any time, but any\n   * successive calls to [process] or [processed] will fail.\n   */\n  void end();\n\n  external static _Filter newZLibDeflateFilter(bool gzip, int level,\n                                               int windowBits, int memLevel,\n                                               int strategy,\n                                               List<int> dictionary, bool raw);\n\n  external static _Filter newZLibInflateFilter(int windowBits,\n                                               List<int> dictionary, bool raw);\n}\n\nvoid _validateZLibWindowBits(int windowBits) {\n  if (ZLibOption.MIN_WINDOW_BITS > windowBits ||\n      ZLibOption.MAX_WINDOW_BITS < windowBits) {\n    throw new RangeError.range(windowBits, ZLibOption.MIN_WINDOW_BITS,\n        ZLibOption.MAX_WINDOW_BITS);\n  }\n}\n\nvoid _validateZLibeLevel(int level) {\n  if (ZLibOption.MIN_LEVEL > level ||\n      ZLibOption.MAX_LEVEL < level) {\n    throw new RangeError.range(level, ZLibOption.MIN_LEVEL,\n        ZLibOption.MAX_LEVEL);\n  }\n}\n\nvoid _validateZLibMemLevel(int memLevel) {\n  if (ZLibOption.MIN_MEM_LEVEL > memLevel ||\n      ZLibOption.MAX_MEM_LEVEL < memLevel) {\n    throw new RangeError.range(memLevel, ZLibOption.MIN_MEM_LEVEL,\n        ZLibOption.MAX_MEM_LEVEL);\n  }\n}\n\nvoid _validateZLibStrategy(int strategy) {\n  const strategies = const <int>[ZLibOption.STRATEGY_FILTERED,\n      ZLibOption.STRATEGY_HUFFMAN_ONLY, ZLibOption.STRATEGY_RLE,\n      ZLibOption.STRATEGY_FIXED, ZLibOption.STRATEGY_DEFAULT];\n  if (strategies.indexOf(strategy) == -1) {\n    throw new ArgumentError(\"Unsupported 'strategy'\");\n  }\n}\n\u0000","sdk:/sdk/lib/io/crypto.dart":"// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\npart of dart.io;\n\nclass _CryptoUtils {\n  static const int PAD = 61; // '='\n  static const int CR = 13;  // '\\r'\n  static const int LF = 10;  // '\\n'\n  static const int LINE_LENGTH = 76;\n\n  static const String _encodeTable =\n      \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n\n  static const String _encodeTableUrlSafe =\n      \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_\";\n\n  // Lookup table used for finding Base 64 alphabet index of a given byte.\n  // -2 : Outside Base 64 alphabet.\n  // -1 : '\\r' or '\\n'\n  //  0 : = (Padding character).\n  // >0 : Base 64 alphabet index of given byte.\n  static const List<int> _decodeTable =\n      const [ -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -1, -2, -2, -1, -2, -2,\n              -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2,\n              -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, 62, -2, 62, -2, 63,\n              52, 53, 54, 55, 56, 57, 58, 59, 60, 61, -2, -2, -2,  0, -2, -2,\n              -2,  0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14,\n              15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, -2, -2, -2, -2, 63,\n              -2, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40,\n              41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, -2, -2, -2, -2, -2,\n              -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2,\n              -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2,\n              -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2,\n              -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2,\n              -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2,\n              -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2,\n              -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2,\n              -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2 ];\n\n  static String bytesToHex(List<int> bytes) {\n    var result = new StringBuffer();\n    for (var part in bytes) {\n      result.write('${part < 16 ? '0' : ''}${part.toRadixString(16)}');\n    }\n    return result.toString();\n  }\n\n  static String bytesToBase64(List<int> bytes,\n                              [bool urlSafe = false,\n                               bool addLineSeparator = false]) {\n    int len = bytes.length;\n    if (len == 0) {\n      return \"\";\n    }\n    final String lookup = urlSafe ? _encodeTableUrlSafe : _encodeTable;\n    // Size of 24 bit chunks.\n    final int remainderLength = len.remainder(3);\n    final int chunkLength = len - remainderLength;\n    // Size of base output.\n    int outputLen = ((len ~/ 3) * 4) + ((remainderLength > 0) ? 4 : 0);\n    // Add extra for line separators.\n    if (addLineSeparator) {\n      outputLen += ((outputLen - 1) ~/ LINE_LENGTH) << 1;\n    }\n    List<int> out = new List<int>(outputLen);\n\n    // Encode 24 bit chunks.\n    int j = 0, i = 0, c = 0;\n    while (i < chunkLength) {\n      int x = ((bytes[i++] << 16) & 0xFFFFFF) |\n              ((bytes[i++] << 8) & 0xFFFFFF) |\n                bytes[i++];\n      out[j++] = lookup.codeUnitAt(x >> 18);\n      out[j++] = lookup.codeUnitAt((x >> 12) & 0x3F);\n      out[j++] = lookup.codeUnitAt((x >> 6)  & 0x3F);\n      out[j++] = lookup.codeUnitAt(x & 0x3f);\n      // Add optional line separator for each 76 char output.\n      if (addLineSeparator && ++c == 19 && j < outputLen - 2) {\n          out[j++] = CR;\n          out[j++] = LF;\n          c = 0;\n      }\n    }\n\n    // If input length if not a multiple of 3, encode remaining bytes and\n    // add padding.\n    if (remainderLength == 1) {\n      int x = bytes[i];\n      out[j++] = lookup.codeUnitAt(x >> 2);\n      out[j++] = lookup.codeUnitAt((x << 4) & 0x3F);\n      out[j++] = PAD;\n      out[j++] = PAD;\n    } else if (remainderLength == 2) {\n      int x = bytes[i];\n      int y = bytes[i + 1];\n      out[j++] = lookup.codeUnitAt(x >> 2);\n      out[j++] = lookup.codeUnitAt(((x << 4) | (y >> 4)) & 0x3F);\n      out[j++] = lookup.codeUnitAt((y << 2) & 0x3F);\n      out[j++] = PAD;\n    }\n\n    return new String.fromCharCodes(out);\n  }\n\n  static List<int> base64StringToBytes(String input,\n                                       [bool ignoreInvalidCharacters = true]) {\n    int len = input.length;\n    if (len == 0) {\n      return new List<int>(0);\n    }\n\n    // Count '\\r', '\\n' and illegal characters, For illegal characters,\n    // if [ignoreInvalidCharacters] is false, throw an exception.\n    int extrasLen = 0;\n    for (int i = 0; i < len; i++) {\n      int c = _decodeTable[input.codeUnitAt(i)];\n      if (c < 0) {\n        extrasLen++;\n        if(c == -2 && !ignoreInvalidCharacters) {\n          throw new FormatException('Invalid character: ${input[i]}');\n        }\n      }\n    }\n\n    if ((len - extrasLen) % 4 != 0) {\n      throw new FormatException('''Size of Base 64 characters in Input\n          must be a multiple of 4. Input: $input''');\n    }\n\n    // Count pad characters, ignore illegal characters at the end.\n    int padLength = 0;\n    for (int i = len - 1; i >= 0; i--) {\n      int currentCodeUnit = input.codeUnitAt(i);\n      if (_decodeTable[currentCodeUnit] > 0) break;\n      if (currentCodeUnit == PAD) padLength++;\n    }\n    int outputLen = (((len - extrasLen) * 6) >> 3) - padLength;\n    List<int> out = new List<int>(outputLen);\n\n    for (int i = 0, o = 0; o < outputLen;) {\n      // Accumulate 4 valid 6 bit Base 64 characters into an int.\n      int x = 0;\n      for (int j = 4; j > 0;) {\n        int c = _decodeTable[input.codeUnitAt(i++)];\n        if (c >= 0) {\n          x = ((x << 6) & 0xFFFFFF) | c;\n          j--;\n        }\n      }\n      out[o++] = x >> 16;\n      if (o < outputLen) {\n        out[o++] = (x >> 8) & 0xFF;\n        if (o < outputLen) out[o++] = x & 0xFF;\n      }\n    }\n    return out;\n  }\n\n}\n\n// Constants.\nconst _MASK_8 = 0xff;\nconst _MASK_32 = 0xffffffff;\nconst _BITS_PER_BYTE = 8;\nconst _BYTES_PER_WORD = 4;\n\n// Base class encapsulating common behavior for cryptographic hash\n// functions.\nabstract class _HashBase {\n  // Hasher state.\n  final int _chunkSizeInWords;\n  final int _digestSizeInWords;\n  final bool _bigEndianWords;\n  int _lengthInBytes = 0;\n  List<int> _pendingData;\n  List<int> _currentChunk;\n  List<int> _h;\n  bool _digestCalled = false;\n\n  _HashBase(this._chunkSizeInWords,\n            this._digestSizeInWords,\n            this._bigEndianWords)\n      : _pendingData = [] {\n    _currentChunk = new List(_chunkSizeInWords);\n    _h = new List(_digestSizeInWords);\n  }\n\n  // Update the hasher with more data.\n  add(List<int> data) {\n    if (_digestCalled) {\n      throw new StateError(\n          'Hash update method called after digest was retrieved');\n    }\n    _lengthInBytes += data.length;\n    _pendingData.addAll(data);\n    _iterate();\n  }\n\n  // Finish the hash computation and return the digest string.\n  List<int> close() {\n    if (_digestCalled) {\n      return _resultAsBytes();\n    }\n    _digestCalled = true;\n    _finalizeData();\n    _iterate();\n    assert(_pendingData.length == 0);\n    return _resultAsBytes();\n  }\n\n  // Returns the block size of the hash in bytes.\n  int get blockSize {\n    return _chunkSizeInWords * _BYTES_PER_WORD;\n  }\n\n  // Create a fresh instance of this Hash.\n  newInstance();\n\n  // One round of the hash computation.\n  _updateHash(List<int> m);\n\n  // Helper methods.\n  _add32(x, y) => (x + y) & _MASK_32;\n  _roundUp(val, n) => (val + n - 1) & -n;\n\n  // Rotate left limiting to unsigned 32-bit values.\n  int _rotl32(int val, int shift) {\n    var mod_shift = shift & 31;\n    return ((val << mod_shift) & _MASK_32) |\n        ((val & _MASK_32) >> (32 - mod_shift));\n  }\n\n\n  // Compute the final result as a list of bytes from the hash words.\n  _resultAsBytes() {\n    var result = [];\n    for (var i = 0; i < _h.length; i++) {\n      result.addAll(_wordToBytes(_h[i]));\n    }\n    return result;\n  }\n\n  // Converts a list of bytes to a chunk of 32-bit words.\n  _bytesToChunk(List<int> data, int dataIndex) {\n    assert((data.length - dataIndex) >= (_chunkSizeInWords * _BYTES_PER_WORD));\n\n    for (var wordIndex = 0; wordIndex < _chunkSizeInWords; wordIndex++) {\n      var w3 = _bigEndianWords ? data[dataIndex] : data[dataIndex + 3];\n      var w2 = _bigEndianWords ? data[dataIndex + 1] : data[dataIndex + 2];\n      var w1 = _bigEndianWords ? data[dataIndex + 2] : data[dataIndex + 1];\n      var w0 = _bigEndianWords ? data[dataIndex + 3] : data[dataIndex];\n      dataIndex += 4;\n      var word = (w3 & 0xff) << 24;\n      word |= (w2 & _MASK_8) << 16;\n      word |= (w1 & _MASK_8) << 8;\n      word |= (w0 & _MASK_8);\n      _currentChunk[wordIndex] = word;\n    }\n  }\n\n  // Convert a 32-bit word to four bytes.\n  _wordToBytes(int word) {\n    List<int> bytes = new List(_BYTES_PER_WORD);\n    bytes[0] = (word >> (_bigEndianWords ? 24 : 0)) & _MASK_8;\n    bytes[1] = (word >> (_bigEndianWords ? 16 : 8)) & _MASK_8;\n    bytes[2] = (word >> (_bigEndianWords ? 8 : 16)) & _MASK_8;\n    bytes[3] = (word >> (_bigEndianWords ? 0 : 24)) & _MASK_8;\n    return bytes;\n  }\n\n  // Iterate through data updating the hash computation for each\n  // chunk.\n  _iterate() {\n    var len = _pendingData.length;\n    var chunkSizeInBytes = _chunkSizeInWords * _BYTES_PER_WORD;\n    if (len >= chunkSizeInBytes) {\n      var index = 0;\n      for (; (len - index) >= chunkSizeInBytes; index += chunkSizeInBytes) {\n        _bytesToChunk(_pendingData, index);\n        _updateHash(_currentChunk);\n      }\n      _pendingData = _pendingData.sublist(index, len);\n    }\n  }\n\n  // Finalize the data. Add a 1 bit to the end of the message. Expand with\n  // 0 bits and add the length of the message.\n  _finalizeData() {\n    _pendingData.add(0x80);\n    var contentsLength = _lengthInBytes + 9;\n    var chunkSizeInBytes = _chunkSizeInWords * _BYTES_PER_WORD;\n    var finalizedLength = _roundUp(contentsLength, chunkSizeInBytes);\n    var zeroPadding = finalizedLength - contentsLength;\n    for (var i = 0; i < zeroPadding; i++) {\n      _pendingData.add(0);\n    }\n    var lengthInBits = _lengthInBytes * _BITS_PER_BYTE;\n    assert(lengthInBits < pow(2, 32));\n    if (_bigEndianWords) {\n      _pendingData.addAll(_wordToBytes(0));\n      _pendingData.addAll(_wordToBytes(lengthInBits & _MASK_32));\n    } else {\n      _pendingData.addAll(_wordToBytes(lengthInBits & _MASK_32));\n      _pendingData.addAll(_wordToBytes(0));\n    }\n  }\n}\n\n// The MD5 hasher is used to compute an MD5 message digest.\nclass _MD5 extends _HashBase {\n  _MD5() : super(16, 4, false) {\n    _h[0] = 0x67452301;\n    _h[1] = 0xefcdab89;\n    _h[2] = 0x98badcfe;\n    _h[3] = 0x10325476;\n  }\n\n  // Returns a new instance of this Hash.\n  _MD5 newInstance() {\n    return new _MD5();\n  }\n\n  static const _k = const [\n    0xd76aa478, 0xe8c7b756, 0x242070db, 0xc1bdceee, 0xf57c0faf, 0x4787c62a,\n    0xa8304613, 0xfd469501, 0x698098d8, 0x8b44f7af, 0xffff5bb1, 0x895cd7be,\n    0x6b901122, 0xfd987193, 0xa679438e, 0x49b40821, 0xf61e2562, 0xc040b340,\n    0x265e5a51, 0xe9b6c7aa, 0xd62f105d, 0x02441453, 0xd8a1e681, 0xe7d3fbc8,\n    0x21e1cde6, 0xc33707d6, 0xf4d50d87, 0x455a14ed, 0xa9e3e905, 0xfcefa3f8,\n    0x676f02d9, 0x8d2a4c8a, 0xfffa3942, 0x8771f681, 0x6d9d6122, 0xfde5380c,\n    0xa4beea44, 0x4bdecfa9, 0xf6bb4b60, 0xbebfbc70, 0x289b7ec6, 0xeaa127fa,\n    0xd4ef3085, 0x04881d05, 0xd9d4d039, 0xe6db99e5, 0x1fa27cf8, 0xc4ac5665,\n    0xf4292244, 0x432aff97, 0xab9423a7, 0xfc93a039, 0x655b59c3, 0x8f0ccc92,\n    0xffeff47d, 0x85845dd1, 0x6fa87e4f, 0xfe2ce6e0, 0xa3014314, 0x4e0811a1,\n    0xf7537e82, 0xbd3af235, 0x2ad7d2bb, 0xeb86d391 ];\n\n  static const _r = const [\n    7, 12, 17, 22, 7, 12, 17, 22, 7, 12, 17, 22, 7, 12, 17, 22, 5,  9, 14,\n    20, 5,  9, 14, 20, 5,  9, 14, 20, 5,  9, 14, 20, 4, 11, 16, 23, 4, 11,\n    16, 23, 4, 11, 16, 23, 4, 11, 16, 23, 6, 10, 15, 21, 6, 10, 15, 21, 6,\n    10, 15, 21, 6, 10, 15, 21 ];\n\n  // Compute one iteration of the MD5 algorithm with a chunk of\n  // 16 32-bit pieces.\n  void _updateHash(List<int> m) {\n    assert(m.length == 16);\n\n    var a = _h[0];\n    var b = _h[1];\n    var c = _h[2];\n    var d = _h[3];\n\n    var t0;\n    var t1;\n\n    for (var i = 0; i < 64; i++) {\n      if (i < 16) {\n        t0 = (b & c) | ((~b & _MASK_32) & d);\n        t1 = i;\n      } else if (i < 32) {\n        t0 = (d & b) | ((~d & _MASK_32) & c);\n        t1 = ((5 * i) + 1) % 16;\n      } else if (i < 48) {\n        t0 = b ^ c ^ d;\n        t1 = ((3 * i) + 5) % 16;\n      } else {\n        t0 = c ^ (b | (~d & _MASK_32));\n        t1 = (7 * i) % 16;\n      }\n\n      var temp = d;\n      d = c;\n      c = b;\n      b = _add32(b, _rotl32(_add32(_add32(a, t0),\n                                   _add32(_k[i], m[t1])),\n                            _r[i]));\n      a = temp;\n    }\n\n    _h[0] = _add32(a, _h[0]);\n    _h[1] = _add32(b, _h[1]);\n    _h[2] = _add32(c, _h[2]);\n    _h[3] = _add32(d, _h[3]);\n  }\n}\n\n// The SHA1 hasher is used to compute an SHA1 message digest.\nclass _SHA1 extends _HashBase {\n  // Construct a SHA1 hasher object.\n  _SHA1() : _w = new List(80), super(16, 5, true) {\n    _h[0] = 0x67452301;\n    _h[1] = 0xEFCDAB89;\n    _h[2] = 0x98BADCFE;\n    _h[3] = 0x10325476;\n    _h[4] = 0xC3D2E1F0;\n  }\n\n  // Returns a new instance of this Hash.\n  _SHA1 newInstance() {\n    return new _SHA1();\n  }\n\n  // Compute one iteration of the SHA1 algorithm with a chunk of\n  // 16 32-bit pieces.\n  void _updateHash(List<int> m) {\n    assert(m.length == 16);\n\n    var a = _h[0];\n    var b = _h[1];\n    var c = _h[2];\n    var d = _h[3];\n    var e = _h[4];\n\n    for (var i = 0; i < 80; i++) {\n      if (i < 16) {\n        _w[i] = m[i];\n      } else {\n        var n = _w[i - 3] ^ _w[i - 8] ^ _w[i - 14] ^ _w[i - 16];\n        _w[i] = _rotl32(n, 1);\n      }\n      var t = _add32(_add32(_rotl32(a, 5), e), _w[i]);\n      if (i < 20) {\n        t = _add32(_add32(t, (b & c) | (~b & d)), 0x5A827999);\n      } else if (i < 40) {\n        t = _add32(_add32(t, (b ^ c ^ d)), 0x6ED9EBA1);\n      } else if (i < 60) {\n        t = _add32(_add32(t, (b & c) | (b & d) | (c & d)), 0x8F1BBCDC);\n      } else {\n        t = _add32(_add32(t, b ^ c ^ d), 0xCA62C1D6);\n      }\n\n      e = d;\n      d = c;\n      c = _rotl32(b, 30);\n      b = a;\n      a = t & _MASK_32;\n    }\n\n    _h[0] = _add32(a, _h[0]);\n    _h[1] = _add32(b, _h[1]);\n    _h[2] = _add32(c, _h[2]);\n    _h[3] = _add32(d, _h[3]);\n    _h[4] = _add32(e, _h[4]);\n  }\n\n  List<int> _w;\n}\n\u0000","sdk:/sdk/lib/io/common.dart":"// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\npart of dart.io;\n\n// Constants used when working with native ports.\n// These must match the constants in runtime/bin/dartutils.h class CObject.\nconst int _SUCCESS_RESPONSE = 0;\nconst int _ILLEGAL_ARGUMENT_RESPONSE = 1;\nconst int _OSERROR_RESPONSE = 2;\nconst int _FILE_CLOSED_RESPONSE = 3;\n\nconst int _ERROR_RESPONSE_ERROR_TYPE = 0;\nconst int _OSERROR_RESPONSE_ERROR_CODE = 1;\nconst int _OSERROR_RESPONSE_MESSAGE = 2;\n\n// Functions used to receive exceptions from native ports.\nbool _isErrorResponse(response) =>\n    response is List && response[0] != _SUCCESS_RESPONSE;\n\n/**\n * Returns an Exception or an Error\n */\n_exceptionFromResponse(response, String message, String path) {\n  assert(_isErrorResponse(response));\n  switch (response[_ERROR_RESPONSE_ERROR_TYPE]) {\n    case _ILLEGAL_ARGUMENT_RESPONSE:\n      return new ArgumentError();\n    case _OSERROR_RESPONSE:\n      var err = new OSError(response[_OSERROR_RESPONSE_MESSAGE],\n                            response[_OSERROR_RESPONSE_ERROR_CODE]);\n      return new FileSystemException(message, path, err);\n    case _FILE_CLOSED_RESPONSE:\n      return new FileSystemException(\"File closed\", path);\n    default:\n      return new Exception(\"Unknown error\");\n  }\n}\n\n/**\n * Base class for all IO related exceptions.\n */\nabstract class IOException implements Exception {\n  String toString() => \"IOException\";\n}\n\n/**\n  * An [OSError] object holds information about an error from the\n  * operating system.\n  */\nclass OSError {\n  /** Constant used to indicate that no OS error code is available. */\n  static const int noErrorCode = -1;\n\n  /**\n    * Error message supplied by the operating system. null if no message is\n    * associated with the error.\n    */\n  final String message;\n\n  /**\n    * Error code supplied by the operating system. Will have the value\n    * [noErrorCode] if there is no error code associated with the error.\n    */\n  final int errorCode;\n\n  /** Creates an OSError object from a message and an errorCode. */\n  const OSError([this.message = \"\", this.errorCode = noErrorCode]);\n\n  /** Converts an OSError object to a string representation. */\n  String toString() {\n    StringBuffer sb = new StringBuffer();\n    sb.write(\"OS Error\");\n    if (!message.isEmpty) {\n      sb..write(\": \")\n        ..write(message);\n      if (errorCode != noErrorCode) {\n        sb..write(\", errno = \")\n          ..write(errorCode.toString());\n      }\n    } else if (errorCode != noErrorCode) {\n      sb..write(\": errno = \")\n        ..write(errorCode.toString());\n    }\n    return sb.toString();\n  }\n}\n\n\n// Object for holding a buffer and an offset.\nclass _BufferAndStart {\n  List buffer;\n  int start;\n  _BufferAndStart(this.buffer, this.start);\n}\n\n// Ensure that the input List can be serialized through a native port.\n// Only Int8List and Uint8List Lists are serialized directly.\n// All other lists are first copied into a Uint8List. This has the added\n// benefit that it is faster to access from the C code as well.\n_BufferAndStart _ensureFastAndSerializableByteData(\n    List buffer, int start, int end) {\n  if (buffer is Uint8List || buffer is Int8List) {\n    return new _BufferAndStart(buffer, start);\n  }\n  int length = end - start;\n  var newBuffer = new Uint8List(length);\n  int j = start;\n  for (int i = 0; i < length; i++) {\n    int value = buffer[j];\n    if (value is! int) {\n      throw new ArgumentError(\"List element is not an integer at index $j\");\n    }\n    newBuffer[i] = value;\n    j++;\n  }\n  return new _BufferAndStart(newBuffer, 0);\n}\n\n\nclass _IOCrypto {\n  external static Uint8List getRandomBytes(int count);\n}\n\u0000","sdk:/sdk/lib/io/bytes_builder.dart":"// Copyright (c) 2013, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\npart of dart.io;\n\n/**\n * Builds a list of bytes, allowing bytes and lists of bytes to be added at the\n * end.\n *\n * Used to efficiently collect bytes and lists of bytes.\n */\nabstract class BytesBuilder {\n  /**\n   * Construct a new empty [BytesBuilder].\n   *\n   * If [copy] is true, the data is always copied when added to the list. If\n   * it [copy] is false, the data is only copied if needed. That means that if\n   * the lists are changed after added to the [BytesBuilder], it may effect the\n   * output. Default is `true`.\n   */\n  factory BytesBuilder({bool copy: true}) {\n    if (copy) {\n      return new _CopyingBytesBuilder();\n    } else {\n      return new _BytesBuilder();\n    }\n  }\n\n  /**\n   * Appends [bytes] to the current contents of the builder.\n   *\n   * Each value of [bytes] will be bit-representation truncated to the range\n   * 0 .. 255.\n   */\n  void add(List<int> bytes);\n\n  /**\n   * Append [byte] to the current contents of the builder.\n   *\n   * The [byte] will be bit-representation truncated to the range 0 .. 255.\n   */\n  void addByte(int byte);\n\n  /**\n   * Returns the contents of `this` and clears `this`.\n   *\n   * The list returned is a view of the the internal buffer, limited to the\n   * [length].\n   */\n  List<int> takeBytes();\n\n  /**\n   * Returns a copy of the current contents of the builder.\n   *\n   * Leaves the contents of the builder intact.\n   */\n  List<int> toBytes();\n\n  /**\n   * The number of bytes in the builder.\n   */\n  int get length;\n\n  /**\n   * Returns `true` if the buffer is empty.\n   */\n  bool get isEmpty;\n\n  /**\n   * Returns `true` if the buffer is not empty.\n   */\n  bool get isNotEmpty;\n\n  /**\n   * Clear the contents of the builder.\n   */\n  void clear();\n}\n\n\nclass _CopyingBytesBuilder implements BytesBuilder {\n  // Start with 1024 bytes.\n  static const int _INIT_SIZE = 1024;\n\n  int _length = 0;\n  Uint8List _buffer;\n\n  void add(List<int> bytes) {\n    int bytesLength = bytes.length;\n    if (bytesLength == 0) return;\n    int required = _length + bytesLength;\n    if (_buffer == null) {\n      int size = _pow2roundup(required);\n      size = max(size, _INIT_SIZE);\n      _buffer = new Uint8List(size);\n    } else if (_buffer.length < required) {\n      // We will create a list in the range of 2-4 times larger than\n      // required.\n      int size = _pow2roundup(required) * 2;\n      var newBuffer = new Uint8List(size);\n      newBuffer.setRange(0, _buffer.length, _buffer);\n      _buffer = newBuffer;\n    }\n    assert(_buffer.length >= required);\n    if (bytes is Uint8List) {\n      _buffer.setRange(_length, required, bytes);\n    } else {\n      for (int i = 0; i < bytesLength; i++) {\n        _buffer[_length + i] = bytes[i];\n      }\n    }\n    _length = required;\n  }\n\n  void addByte(int byte) => add([byte]);\n\n  List<int> takeBytes() {\n    if (_buffer == null) return new Uint8List(0);\n    var buffer = new Uint8List.view(_buffer.buffer, 0, _length);\n    clear();\n    return buffer;\n  }\n\n  List<int> toBytes() {\n    if (_buffer == null) return new Uint8List(0);\n    return new Uint8List.fromList(\n        new Uint8List.view(_buffer.buffer, 0, _length));\n  }\n\n  int get length => _length;\n\n  bool get isEmpty => _length == 0;\n\n  bool get isNotEmpty => _length != 0;\n\n  void clear() {\n    _length = 0;\n    _buffer = null;\n  }\n\n  int _pow2roundup(int x) {\n    --x;\n    x |= x >> 1;\n    x |= x >> 2;\n    x |= x >> 4;\n    x |= x >> 8;\n    x |= x >> 16;\n    return x + 1;\n  }\n}\n\n\nclass _BytesBuilder implements BytesBuilder {\n  int _length = 0;\n  final List _chunks = [];\n\n  void add(List<int> bytes) {\n    if (bytes is! Uint8List) {\n      bytes = new Uint8List.fromList(bytes);\n    }\n    _chunks.add(bytes);\n    _length += bytes.length;\n  }\n\n  void addByte(int byte) => add([byte]);\n\n  List<int> takeBytes() {\n    if (_chunks.length == 0) return new Uint8List(0);\n    if (_chunks.length == 1) {\n      var buffer = _chunks.single;\n      clear();\n      return buffer;\n    }\n    var buffer = new Uint8List(_length);\n    int offset = 0;\n    for (var chunk in _chunks) {\n      buffer.setRange(offset, offset + chunk.length, chunk);\n      offset += chunk.length;\n    }\n    clear();\n    return buffer;\n  }\n\n  List<int> toBytes() {\n    if (_chunks.length == 0) return new Uint8List(0);\n    var buffer = new Uint8List(_length);\n    int offset = 0;\n    for (var chunk in _chunks) {\n      buffer.setRange(offset, offset + chunk.length, chunk);\n      offset += chunk.length;\n    }\n    return buffer;\n  }\n\n  int get length => _length;\n\n  bool get isEmpty => _length == 0;\n\n  bool get isNotEmpty => _length != 0;\n\n  void clear() {\n    _length = 0;\n    _chunks.clear();\n  }\n}\n\u0000","sdk:/sdk/lib/io/io.dart":"// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n/**\n * File, socket, HTTP, and other I/O support for server applications.\n *\n * The I/O library is used for Dart server applications,\n * which run on a stand-alone Dart VM from the command line.\n * *This library does not work in browser-based applications.*\n *\n * This library allows you to work with files, directories,\n * sockets, processes, HTTP servers and clients, and more.\n *\n * To use this library in your code:\n *\n *     import 'dart:io';\n *\n * *Note:* Many operations related to input and output are asynchronous\n * and are handled using [Future]s or [Stream]s, both of which\n * are defined in the `dart:async` library.\n *\n * ## File, Directory, and Link\n *\n * An instance of [File], [Directory], or [Link] represents a file,\n * directory, or link, respectively, in the native file system.\n *\n * You can manipulate the file system through objects of these types.\n * For example, you can rename a file or directory:\n *\n *     File myFile = new File('myFile.txt');\n *     myFile.rename('yourFile.txt').then((_) => print('file renamed'));\n *\n * Many methods provided by the File, Directory, and Link classes\n * run asynchronously and return a Future.\n *\n * ## FileSystemEntity\n *\n * File, Directory, and Link all extend [FileSystemEntity].\n * In addition to being the superclass for these classes,\n * FileSystemEntity has a number of static methods for working with paths.\n *\n * To get information about a path,\n * you can use the FileSystemEntity static methods\n * such as 'isDirectory', 'isFile', and 'exists'.\n * Because file system access involves I/O, these methods\n * are asynchronous and return a Future.\n *\n *     FileSystemEntity.isDirectory(myPath).then((isDir) {\n *       if (isDir) {\n *         print('$myPath is a directory');\n *       } else {\n *         print('$myPath is not a directory');\n *       }\n *     });\n *\n * ## HttpServer and HttpClient\n *\n * The classes [HttpServer] and [HttpClient]\n * provide HTTP server and HTTP client functionality.\n *\n * The [HttpServer] class provides the basic functionality for\n * implementing an HTTP server.\n * For some higher-level building-blocks, we recommend that you try\n * the [http_server](https://pub.dartlang.org/packages/http_server)\n * pub package, which contains\n * a set of high-level classes that, together with the [HttpServer] class\n * in this library, make it easier to implement HTTP servers.\n *\n * ## Process\n *\n * The [Process] class provides a way to run a process on\n * the native machine.\n * For example, the following code spawns a process that recursively lists\n * the files under `web`.\n *\n *     Process.start('ls', ['-R', 'web']).then((process) {\n *       stdout.addStream(process.stdout);\n *       stderr.addStream(process.stderr);\n *       process.exitCode.then(print);\n *     });\n *\n * Using `start()` returns a Future, which completes with a [Process] object\n * when the process has started. This [Process] object allows you to interact\n * with the process while it is running. Using `run()` returns a Future, which\n * completes with a [ProcessResult] object when the spawned process has\n * terminated. This [ProcessResult] object collects the output and exit code\n * from the process.\n *\n * When using `start()`,\n * you need to read all data coming on the stdout and stderr streams otherwise\n * the system resources will not be freed.\n *\n * ## WebSocket\n *\n * The [WebSocket] class provides support for the web socket protocol. This\n * allows full-duplex communications between client and server applications.\n * Use the WebSocket class in the `dart:html` library for web clients.\n *\n * A web socket server uses a normal HTTP server for accepting web socket\n * connections. The initial handshake is a HTTP request which is then upgraded to a\n * web socket connection.\n * The server upgrades the request using [WebSocketTransformer]\n * and listens for the data on the returned web socket.\n * For example, here's a mini server that listens for 'ws' data\n * on a WebSocket:\n *\n *     runZoned(() {\n *       HttpServer.bind('127.0.0.1', 4040).then((server) {\n *         server.listen((HttpRequest req) {\n *           if (req.uri.path == '/ws') {\n *             WebSocketTransformer.upgrade(req).then((socket) {\n *               socket.listen(handleMsg);\n *             });\n *           }\n *         });\n *       });\n *     },\n *     onError: (e) => print(\"An error occurred.\"));\n *\n * The client connects to the WebSocket using the `connect()` method\n * and a URI that uses the Web Socket protocol.\n * The the client can write to the WebSocket with the `add()` method.\n * For example,\n *\n *     WebSocket.connect('ws://127.0.0.1:4040/ws').then((socket) {\n *       socket.add('Hello, World!');\n *     });\n *\n * Check out the\n * [dartiverse_search](https://code.google.com/p/dart/source/browse/branches/bleeding_edge/dart/samples/dartiverse_search)\n * sample for a client/server pair that uses\n * WebSockets to communicate.\n *\n * ## Socket and ServerSocket\n *\n * Clients and servers use [Socket]s to communicate using the TCP protocol.\n * Use [ServerSocket] on the server side and [Socket] on the client.\n * The server creates a listening socket using the `bind()` method and\n * then listens for incoming connections on the socket. For example:\n *\n *     ServerSocket.bind('127.0.0.1', 4041)\n *       .then((serverSocket) {\n *         serverSocket.listen((socket) {\n *           socket.transform(UTF8.decoder).listen(print);\n *         });\n *       });\n *\n * A client connects a Socket using the `connect()` method,\n * which returns a Future.\n * Using `write()`, `writeln()`, or `writeAll()` are the easiest ways to\n * send data over the socket.\n * For example:\n *\n *     Socket.connect('127.0.0.1', 4041).then((socket) {\n *       socket.write('Hello, World!');\n *     });\n *\n * Besides [Socket] and [ServerSocket], the [RawSocket] and\n * [RawServerSocket] classes are available for lower-level access\n * to async socket IO.\n *\n * ## Standard output, error, and input streams\n *\n * This library provides the standard output, error, and input\n * streams, named 'stdout', 'stderr', and 'stdin', respectively.\n *\n * The stdout and stderr streams are both [IOSink]s and have the same set\n * of methods and properties.\n *\n * To write a string to 'stdout':\n *\n *     stdout.writeln('Hello, World!');\n *\n * To write a list of objects to 'stderr':\n *\n *     stderr.writeAll([ 'That ', 'is ', 'an ', 'error.', '\\n']);\n *\n * The standard input stream is a true [Stream], so it inherits\n * properties and methods from the Stream class.\n *\n * To read text synchronously from the command line\n * (the program blocks waiting for user to type information):\n *\n *      String inputText = stdin.readLineSync();\n *\n * ## Other resources\n *\n * For an introduction to I/O in Dart, see the\n * [dart:io section of the library tour]\n * (https://www.dartlang.org/docs/dart-up-and-running/contents/ch03.html#ch03-dartio---file-and-socket-io-for-command-line-apps).\n *\n * To learn more about I/O in Dart, refer to the\n * [tutorial about writing command-line apps]\n * (https://www.dartlang.org/docs/tutorials/io/).\n */\nlibrary dart.io;\n\nimport 'dart:async';\nimport 'dart:_internal';\nimport 'dart:collection' show HashMap,\n                              HashSet,\n                              Queue,\n                              ListQueue,\n                              LinkedList,\n                              LinkedListEntry,\n                              UnmodifiableMapView;\nimport 'dart:convert';\nimport 'dart:isolate';\nimport 'dart:math';\nimport 'dart:typed_data';\n\npart 'bytes_builder.dart';\npart 'common.dart';\npart 'crypto.dart';\npart 'data_transformer.dart';\npart 'directory.dart';\npart 'directory_impl.dart';\npart 'eventhandler.dart';\npart 'file.dart';\npart 'file_impl.dart';\npart 'file_system_entity.dart';\npart 'http.dart';\npart 'http_date.dart';\npart 'http_headers.dart';\npart 'http_impl.dart';\npart 'http_parser.dart';\npart 'http_session.dart';\npart 'io_sink.dart';\npart 'io_service.dart';\npart 'link.dart';\npart 'platform.dart';\npart 'platform_impl.dart';\npart 'process.dart';\npart 'service_object.dart';\npart 'socket.dart';\npart 'stdio.dart';\npart 'string_transformer.dart';\npart 'timer_impl.dart';\npart 'secure_socket.dart';\npart 'secure_server_socket.dart';\npart 'websocket.dart';\npart 'websocket_impl.dart';\n\u0000","sdk:/sdk/lib/js/dart2js/js_dart2js.dart":"// Copyright (c) 2013, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n/**\n * Support for interoperating with JavaScript.\n *\n * This library provides access to JavaScript objects from Dart, allowing\n * Dart code to get and set properties, and call methods of JavaScript objects\n * and invoke JavaScript functions. The library takes care of converting\n * between Dart and JavaScript objects where possible, or providing proxies if\n * conversion isn't possible.\n *\n * This library does not yet make Dart objects usable from JavaScript, their\n * methods and proeprties are not accessible, though it does allow Dart\n * functions to be passed into and called from JavaScript.\n *\n * [JsObject] is the core type and represents a proxy of a JavaScript object.\n * JsObject gives access to the underlying JavaScript objects properties and\n * methods. `JsObject`s can be acquired by calls to JavaScript, or they can be\n * created from proxies to JavaScript constructors.\n *\n * The top-level getter [context] provides a [JsObject] that represents the\n * global object in JavaScript, usually `window`.\n *\n * The following example shows an alert dialog via a JavaScript call to the\n * global function `alert()`:\n *\n *     import 'dart:js';\n *\n *     main() => context.callMethod('alert', ['Hello from Dart!']);\n *\n * This example shows how to create a [JsObject] from a JavaScript constructor\n * and access its properties:\n *\n *     import 'dart:js';\n *\n *     main() {\n *       var object = new JsObject(context['Object']);\n *       object['greeting'] = 'Hello';\n *       object['greet'] = (name) => \"${object['greeting']} $name\";\n *       var message = object.callMethod('greet', ['JavaScript']);\n *       context['console'].callMethod('log', [message]);\n *     }\n *\n * ## Proxying and automatic conversion\n *\n * When setting properties on a JsObject or passing arguments to a Javascript\n * method or function, Dart objects are automatically converted or proxied to\n * JavaScript objects. When accessing JavaScript properties, or when a Dart\n * closure is invoked from JavaScript, the JavaScript objects are also\n * converted to Dart.\n *\n * Functions and closures are proxied in such a way that they are callable. A\n * Dart closure assigned to a JavaScript property is proxied by a function in\n * JavaScript. A JavaScript function accessed from Dart is proxied by a\n * [JsFunction], which has a [apply] method to invoke it.\n *\n * The following types are transferred directly and not proxied:\n *\n * * \"Basic\" types: `null`, `bool`, `num`, `String`, `DateTime`\n * * `Blob`\n * * `Event`\n * * `HtmlCollection`\n * * `ImageData`\n * * `KeyRange`\n * * `Node`\n * * `NodeList`\n * * `TypedData`, including its subclasses like `Int32List`, but _not_\n *   `ByteBuffer`\n * * `Window`\n *\n * ## Converting collections with JsObject.jsify()\n *\n * To create a JavaScript collection from a Dart collection use the\n * [JsObject.jsify] constructor, which converts Dart [Map]s and [Iterable]s\n * into JavaScript Objects and Arrays.\n *\n * The following expression creats a new JavaScript object with the properties\n * `a` and `b` defined:\n *\n *     var jsMap = new JsObject.jsify({'a': 1, 'b': 2});\n *\n * This expression creates a JavaScript array:\n *\n *     var jsArray = new JsObject.jsify([1, 2, 3]);\n */\nlibrary dart.js;\n\nimport 'dart:html' show Blob, Event, ImageData, Node, Window;\nimport 'dart:collection' show HashMap, ListMixin;\nimport 'dart:indexed_db' show KeyRange;\nimport 'dart:typed_data' show TypedData;\n\nimport 'dart:_foreign_helper' show JS, DART_CLOSURE_TO_JS;\nimport 'dart:_interceptors' show JavaScriptObject, UnknownJavaScriptObject;\nimport 'dart:_js_helper' show Primitives, convertDartClosureToJS,\n    getIsolateAffinityTag;\n\nfinal JsObject context = _wrapToDart(JS('', 'self'));\n\n_convertDartFunction(Function f, {bool captureThis: false}) {\n  return JS('',\n    'function(_call, f, captureThis) {'\n      'return function() {'\n        'return _call(f, captureThis, this, '\n            'Array.prototype.slice.apply(arguments));'\n      '}'\n    '}(#, #, #)', DART_CLOSURE_TO_JS(_callDartFunction), f, captureThis);\n}\n\n_callDartFunction(callback, bool captureThis, self, List arguments) {\n  if (captureThis) {\n    arguments = [self]..addAll(arguments);\n  }\n  var dartArgs = new List.from(arguments.map(_convertToDart));\n  return _convertToJS(Function.apply(callback, dartArgs));\n}\n\n/**\n * Proxies a JavaScript object to Dart.\n *\n * The properties of the JavaScript object are accessible via the `[]` and\n * `[]=` operators. Methods are callable via [callMethod].\n */\nclass JsObject {\n  // The wrapped JS object.\n  final dynamic _jsObject;\n\n  // This shoud only be called from _wrapToDart\n  JsObject._fromJs(this._jsObject) {\n    assert(_jsObject != null);\n  }\n\n  /**\n   * Constructs a new JavaScript object from [constructor] and returns a proxy\n   * to it.\n   */\n  factory JsObject(JsFunction constructor, [List arguments]) {\n    var constr = _convertToJS(constructor);\n    if (arguments == null) {\n      return _wrapToDart(JS('', 'new #()', constr));\n    }\n    // The following code solves the problem of invoking a JavaScript\n    // constructor with an unknown number arguments.\n    // First bind the constructor to the argument list using bind.apply().\n    // The first argument to bind() is the binding of 'this', so add 'null' to\n    // the arguments list passed to apply().\n    // After that, use the JavaScript 'new' operator which overrides any binding\n    // of 'this' with the new instance.\n    var args = [null]..addAll(arguments.map(_convertToJS));\n    var factoryFunction = JS('', '#.bind.apply(#, #)', constr, constr, args);\n    // Without this line, calling factoryFunction as a constructor throws\n    JS('String', 'String(#)', factoryFunction);\n    // This could return an UnknownJavaScriptObject, or a native\n    // object for which there is an interceptor\n    var jsObj = JS('JavaScriptObject', 'new #()', factoryFunction);\n\n    return _wrapToDart(jsObj);\n  }\n\n  /**\n   * Constructs a [JsObject] that proxies a native Dart object; _for expert use\n   * only_.\n   *\n   * Use this constructor only if you wish to get access to JavaScript\n   * properties attached to a browser host object, such as a Node or Blob, that\n   * is normally automatically converted into a native Dart object.\n   *\n   * An exception will be thrown if [object] either is `null` or has the type\n   * `bool`, `num`, or `String`.\n   */\n  factory JsObject.fromBrowserObject(object) {\n    if (object is num || object is String || object is bool || object == null) {\n      throw new ArgumentError(\n        \"object cannot be a num, string, bool, or null\");\n    }\n    return _wrapToDart(_convertToJS(object));\n  }\n\n  /**\n   * Recursively converts a JSON-like collection of Dart objects to a\n   * collection of JavaScript objects and returns a [JsObject] proxy to it.\n   *\n   * [object] must be a [Map] or [Iterable], the contents of which are also\n   * converted. Maps and Iterables are copied to a new JavaScript object.\n   * Primitives and other transferrable values are directly converted to their\n   * JavaScript type, and all other objects are proxied.\n   */\n  factory JsObject.jsify(object) {\n    if ((object is! Map) && (object is! Iterable)) {\n      throw new ArgumentError(\"object must be a Map or Iterable\");\n    }\n    return _wrapToDart(_convertDataTree(object));\n  }\n\n  static _convertDataTree(data) {\n    var _convertedObjects = new HashMap.identity();\n\n    _convert(o) {\n      if (_convertedObjects.containsKey(o)) {\n        return _convertedObjects[o];\n      }\n      if (o is Map) {\n        final convertedMap = JS('=Object', '{}');\n        _convertedObjects[o] = convertedMap;\n        for (var key in o.keys) {\n          JS('=Object', '#[#]=#', convertedMap, key, _convert(o[key]));\n        }\n        return convertedMap;\n      } else if (o is Iterable) {\n        var convertedList = [];\n        _convertedObjects[o] = convertedList;\n        convertedList.addAll(o.map(_convert));\n        return convertedList;\n      } else {\n        return _convertToJS(o);\n      }\n    }\n\n    return _convert(data);\n  }\n\n  /**\n   * Returns the value associated with [property] from the proxied JavaScript\n   * object.\n   *\n   * The type of [property] must be either [String] or [num].\n   */\n  dynamic operator[](property) {\n    if (property is! String && property is! num) {\n      throw new ArgumentError(\"property is not a String or num\");\n    }\n    return _convertToDart(JS('', '#[#]', _jsObject, property));\n  }\n\n  /**\n   * Sets the value associated with [property] on the proxied JavaScript\n   * object.\n   *\n   * The type of [property] must be either [String] or [num].\n   */\n  operator[]=(property, value) {\n    if (property is! String && property is! num) {\n      throw new ArgumentError(\"property is not a String or num\");\n    }\n    JS('', '#[#]=#', _jsObject, property, _convertToJS(value));\n  }\n\n  int get hashCode => 0;\n\n  bool operator==(other) => other is JsObject &&\n      JS('bool', '# === #', _jsObject, other._jsObject);\n\n  /**\n   * Returns `true` if the JavaScript object contains the specified property\n   * either directly or though its prototype chain.\n   *\n   * This is the equivalent of the `in` operator in JavaScript.\n   */\n  bool hasProperty(property) {\n    if (property is! String && property is! num) {\n      throw new ArgumentError(\"property is not a String or num\");\n    }\n    return JS('bool', '# in #', property, _jsObject);\n  }\n\n  /**\n   * Removes [property] from the JavaScript object.\n   *\n   * This is the equivalent of the `delete` operator in JavaScript.\n   */\n  void deleteProperty(property) {\n    if (property is! String && property is! num) {\n      throw new ArgumentError(\"property is not a String or num\");\n    }\n    JS('bool', 'delete #[#]', _jsObject, property);\n  }\n\n  /**\n   * Returns `true` if the JavaScript object has [type] in its prototype chain.\n   *\n   * This is the equivalent of the `instanceof` operator in JavaScript.\n   */\n  bool instanceof(JsFunction type) {\n    return JS('bool', '# instanceof #', _jsObject, _convertToJS(type));\n  }\n\n  /**\n   * Returns the result of the JavaScript objects `toString` method.\n   */\n  String toString() {\n    try {\n      return JS('String', 'String(#)', _jsObject);\n    } catch(e) {\n      return super.toString();\n    }\n  }\n\n  /**\n   * Calls [method] on the JavaScript object with the arguments [args] and\n   * returns the result.\n   *\n   * The type of [method] must be either [String] or [num].\n   */\n  dynamic callMethod(method, [List args]) {\n    if (method is! String && method is! num) {\n      throw new ArgumentError(\"method is not a String or num\");\n    }\n    return _convertToDart(JS('', '#[#].apply(#, #)', _jsObject, method,\n        _jsObject,\n        args == null ? null : new List.from(args.map(_convertToJS))));\n  }\n}\n\n/**\n * Proxies a JavaScript Function object.\n */\nclass JsFunction extends JsObject {\n\n  /**\n   * Returns a [JsFunction] that captures its 'this' binding and calls [f]\n   * with the value of this passed as the first argument.\n   */\n  factory JsFunction.withThis(Function f) {\n    var jsFunc = _convertDartFunction(f, captureThis: true);\n    return new JsFunction._fromJs(jsFunc);\n  }\n\n  JsFunction._fromJs(jsObject) : super._fromJs(jsObject);\n\n  /**\n   * Invokes the JavaScript function with arguments [args]. If [thisArg] is\n   * supplied it is the value of `this` for the invocation.\n   */\n  dynamic apply(List args, { thisArg }) =>\n      _convertToDart(JS('', '#.apply(#, #)', _jsObject,\n          _convertToJS(thisArg),\n          args == null ? null : new List.from(args.map(_convertToJS))));\n}\n\n/**\n * A [List] that proxies a JavaScript array.\n */\nclass JsArray<E> extends JsObject with ListMixin<E> {\n\n  /**\n   * Creates a new JavaScript array.\n   */\n  JsArray() : super._fromJs([]);\n\n  /**\n   * Creates a new JavaScript array and initializes it to the contents of\n   * [other].\n   */\n  JsArray.from(Iterable<E> other)\n      : super._fromJs([]..addAll(other.map(_convertToJS)));\n\n  JsArray._fromJs(jsObject) : super._fromJs(jsObject);\n\n  _checkIndex(int index) {\n    if (index is int && (index < 0 || index >= length)) {\n      throw new RangeError.range(index, 0, length);\n    }\n  }\n\n  _checkInsertIndex(int index) {\n    if (index is int && (index < 0 || index >= length + 1)) {\n      throw new RangeError.range(index, 0, length);\n    }\n  }\n\n  static _checkRange(int start, int end, int length) {\n    if (start < 0 || start > length) {\n      throw new RangeError.range(start, 0, length);\n    }\n    if (end < start || end > length) {\n      throw new RangeError.range(end, start, length);\n    }\n  }\n\n  // Methods required by ListMixin\n\n  E operator [](index) {\n    // TODO(justinfagnani): fix the semantics for non-ints\n    // dartbug.com/14605\n    if (index is num && index == index.toInt()) {\n      _checkIndex(index);\n    }\n    return super[index];\n  }\n\n  void operator []=(index, E value) {\n    // TODO(justinfagnani): fix the semantics for non-ints\n    // dartbug.com/14605\n    if (index is num && index == index.toInt()) {\n      _checkIndex(index);\n    }\n    super[index] = value;\n  }\n\n  int get length {\n    // Check the length honours the List contract.\n    var len = JS('', '#.length', _jsObject);\n    // JavaScript arrays have lengths which are unsigned 32-bit integers.\n    if (JS('bool', 'typeof # === \"number\" && (# >>> 0) === #', len, len, len)) {\n      return JS('int', '#', len);\n    }\n    throw new StateError('Bad JsArray length');\n  }\n\n  void set length(int length) { super['length'] = length; }\n\n\n  // Methods overriden for better performance\n\n  void add(E value) {\n    callMethod('push', [value]);\n  }\n\n  void addAll(Iterable<E> iterable) {\n    var list = (JS('bool', '# instanceof Array', iterable))\n        ? iterable\n        : new List.from(iterable);\n    callMethod('push', list);\n  }\n\n  void insert(int index, E element) {\n    _checkInsertIndex(index);\n    callMethod('splice', [index, 0, element]);\n  }\n\n  E removeAt(int index) {\n    _checkIndex(index);\n    return callMethod('splice', [index, 1])[0];\n  }\n\n  E removeLast() {\n    if (length == 0) throw new RangeError(-1);\n    return callMethod('pop');\n  }\n\n  void removeRange(int start, int end) {\n    _checkRange(start, end, length);\n    callMethod('splice', [start, end - start]);\n  }\n\n  void setRange(int start, int end, Iterable<E> iterable, [int skipCount = 0]) {\n    _checkRange(start, end, length);\n    int length = end - start;\n    if (length == 0) return;\n    if (skipCount < 0) throw new ArgumentError(skipCount);\n    var args = [start, length]..addAll(iterable.skip(skipCount).take(length));\n    callMethod('splice', args);\n  }\n\n  void sort([int compare(E a, E b)]) {\n    // Note: arr.sort(null) is a type error in FF\n    callMethod('sort', compare == null ? [] : [compare]);\n  }\n}\n\n// property added to a Dart object referencing its JS-side DartObject proxy\nfinal String _DART_OBJECT_PROPERTY_NAME =\n    getIsolateAffinityTag(r'_$dart_dartObject');\nfinal String _DART_CLOSURE_PROPERTY_NAME =\n    getIsolateAffinityTag(r'_$dart_dartClosure');\n\n// property added to a JS object referencing its Dart-side JsObject proxy\nconst _JS_OBJECT_PROPERTY_NAME = r'_$dart_jsObject';\nconst _JS_FUNCTION_PROPERTY_NAME = r'$dart_jsFunction';\n\nbool _defineProperty(o, String name, value) {\n  if (JS('bool', 'Object.isExtensible(#)', o)) {\n    try {\n      JS('void', 'Object.defineProperty(#, #, { value: #})', o, name, value);\n      return true;\n    } catch(e) {\n      // object is native and lies about being extensible\n      // see https://bugzilla.mozilla.org/show_bug.cgi?id=775185\n    }\n  }\n  return false;\n}\n\nObject _getOwnProperty(o, String name) {\n  if (JS('bool', 'Object.prototype.hasOwnProperty.call(#, #)', o, name)) {\n    return JS('', '#[#]', o, name);\n  }\n  return null;\n}\n\nbool _isLocalObject(o) => JS('bool', '# instanceof Object', o);\n\n// The shared constructor function for proxies to Dart objects in JavaScript.\nfinal _dartProxyCtor = JS('', 'function DartObject(o) { this.o = o; }');\n\ndynamic _convertToJS(dynamic o) {\n  // Note: we don't write `if (o == null) return null;` to make sure dart2js\n  // doesn't convert `return null;` into `return;` (which would make `null` be\n  // `undefined` in Javascprit). See dartbug.com/20305 for details.\n  if (o == null || o is String || o is num || o is bool) {\n    return o;\n  } else if (o is Blob || o is Event || o is KeyRange || o is ImageData\n      || o is Node || o is TypedData || o is Window) {\n    return o;\n  } else if (o is DateTime) {\n    return Primitives.lazyAsJsDate(o);\n  } else if (o is JsObject) {\n    return o._jsObject;\n  } else if (o is Function) {\n    return _getJsProxy(o, _JS_FUNCTION_PROPERTY_NAME, (o) {\n      var jsFunction = _convertDartFunction(o);\n      // set a property on the JS closure referencing the Dart closure\n      _defineProperty(jsFunction, _DART_CLOSURE_PROPERTY_NAME, o);\n      return jsFunction;\n    });\n  } else {\n    var ctor = _dartProxyCtor;\n    return _getJsProxy(o, _JS_OBJECT_PROPERTY_NAME,\n        (o) => JS('', 'new #(#)', ctor, o));\n  }\n}\n\nObject _getJsProxy(o, String propertyName, createProxy(o)) {\n  var jsProxy = _getOwnProperty(o, propertyName);\n  if (jsProxy == null) {\n    jsProxy = createProxy(o);\n    _defineProperty(o, propertyName, jsProxy);\n  }\n  return jsProxy;\n}\n\n// converts a Dart object to a reference to a native JS object\n// which might be a DartObject JS->Dart proxy\nObject _convertToDart(o) {\n  if (JS('bool', '# == null', o) ||\n      JS('bool', 'typeof # == \"string\"', o) ||\n      JS('bool', 'typeof # == \"number\"', o) ||\n      JS('bool', 'typeof # == \"boolean\"', o)) {\n    return o;\n  } else if (_isLocalObject(o)\n      && (o is Blob || o is Event || o is KeyRange || o is ImageData\n      || o is Node || o is TypedData || o is Window)) {\n    // long line: dart2js doesn't allow string concatenation in the JS() form\n    return JS('Blob|Event|KeyRange|ImageData|Node|TypedData|Window', '#', o);\n  } else if (JS('bool', '# instanceof Date', o)) {\n    var ms = JS('num', '#.getTime()', o);\n    return new DateTime.fromMillisecondsSinceEpoch(ms);\n  } else if (JS('bool', '#.constructor === #', o, _dartProxyCtor)) {\n    return JS('', '#.o', o);\n  } else {\n    return _wrapToDart(o);\n  }\n}\n\nJsObject _wrapToDart(o) {\n  if (JS('bool', 'typeof # == \"function\"', o)) {\n    return _getDartProxy(o, _DART_CLOSURE_PROPERTY_NAME,\n        (o) => new JsFunction._fromJs(o));\n  } else if (JS('bool', '# instanceof Array', o)) {\n    return _getDartProxy(o, _DART_OBJECT_PROPERTY_NAME,\n        (o) => new JsArray._fromJs(o));\n  } else {\n    return _getDartProxy(o, _DART_OBJECT_PROPERTY_NAME,\n        (o) => new JsObject._fromJs(o));\n  }\n}\n\nObject _getDartProxy(o, String propertyName, createProxy(o)) {\n  var dartProxy = _getOwnProperty(o, propertyName);\n  // Temporary fix for dartbug.com/15193\n  // In some cases it's possible to see a JavaScript object that\n  // came from a different context and was previously proxied to\n  // Dart in that context. The JS object will have a cached proxy\n  // but it won't be a valid Dart object in this context.\n  // For now we throw away the cached proxy, but we should be able\n  // to cache proxies from multiple JS contexts and Dart isolates.\n  if (dartProxy == null || !_isLocalObject(o)) {\n    dartProxy = createProxy(o);\n    _defineProperty(o, propertyName, dartProxy);\n  }\n  return dartProxy;\n}\n\u0000","sdk:/sdk/lib/mirrors/mirrors.dart":"// Copyright (c) 2013, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n// For the purposes of the mirrors library, we adopt a naming\n// convention with respect to getters and setters.  Specifically, for\n// some variable or field...\n//\n//   var myField;\n//\n// ...the getter is named 'myField' and the setter is named\n// 'myField='.  This allows us to assign unique names to getters and\n// setters for the purposes of member lookup.\n\n/**\n * Basic reflection in Dart,\n * with support for introspection and dynamic evaluation.\n *\n * *Introspection* is that subset of reflection by which a running\n * program can examine its own structure. For example, a function\n * that prints out the names of all the members of an arbitrary object.\n *\n * *Dynamic evaluation* refers the ability to evaluate code that\n * has not been literally specified at compile time, such as calling a method\n * whose name is provided as an argument (because it is looked up\n * in a database, or provided interactively by the user).\n *\n * ## How to interpret this library's documentation\n *\n * As a rule, the names of Dart declarations are represented using\n * instances of class [Symbol]. Whenever the doc speaks of an object *s*\n * of class [Symbol] denoting a name, it means the string that\n * was used to construct *s*.\n *\n * The documentation frequently abuses notation with\n * Dart pseudo-code such as [:o.x(a):], where\n * o and a are defined to be objects; what is actually meant in these\n * cases is [:o'.x(a'):] where *o'* and *a'* are Dart variables\n * bound to *o* and *a* respectively. Furthermore, *o'* and *a'*\n * are assumed to be fresh variables (meaning that they are\n * distinct from any other variables in the program).\n *\n * Sometimes the documentation refers to *serializable* objects.\n * An object is serializable across isolates if and only if it is an instance of\n * num, bool, String, a list of objects that are serializable\n * across isolates, or a map with keys and values that are all serializable across\n * isolates.\n *\n * ## Status: Unstable\n *\n * The dart:mirrors library is unstable and its API might change slightly as a\n * result of user feedback. This library is platform dependent and therefore it\n * has implementations for both dart2js and the Dart VM. Both are under\n * development and may not support all operations yet.\n */\nlibrary dart.mirrors;\n\n/**\n * A [MirrorSystem] is the main interface used to reflect on a set of\n * associated libraries.\n *\n * At runtime each running isolate has a distinct [MirrorSystem].\n *\n * It is also possible to have a [MirrorSystem] which represents a set\n * of libraries which are not running -- perhaps at compile-time.  In\n * this case, all available reflective functionality would be\n * supported, but runtime functionality (such as invoking a function\n * or inspecting the contents of a variable) would fail dynamically.\n */\nabstract class MirrorSystem {\n  /**\n   * Returns an immutable map from URIs to mirrors for all\n   * libraries known to this mirror system.\n   */\n  Map<Uri, LibraryMirror> get libraries;\n\n  /**\n   * Returns the unique library named [libraryName] if it exists.\n   *\n   * If no unique library exists, an error is thrown.\n   */\n  LibraryMirror findLibrary(Symbol libraryName) {\n    return libraries.values.singleWhere(\n        (library) => library.simpleName == libraryName);\n  }\n\n  /**\n   * A mirror on the isolate associated with this [MirrorSystem].\n   * This may be null if this mirror system is not running.\n   */\n  IsolateMirror get isolate;\n\n  /**\n   * A mirror on the [:dynamic:] type.\n   */\n  TypeMirror get dynamicType;\n\n  /**\n   * A mirror on the [:void:] type.\n   */\n  TypeMirror get voidType;\n\n  /**\n   * Returns the name of [symbol].\n   *\n   * The following text is non-normative:\n   *\n   * Using this method may result in larger output.  If possible, use\n   * [MirrorsUsed] to specify which symbols must be retained in clear text.\n   */\n  external static String getName(Symbol symbol);\n\n  /**\n   * Returns a symbol for [name]. If [library] is not a [LibraryMirror] or if\n   * [name] is a private identifier and [library] is [:null:], throws an\n   * [ArgumentError]. If [name] is a private identifier, the symbol returned is\n   * with respect to [library].\n   *\n   * The following text is non-normative:\n   *\n   * Using this method may result in larger output.  If possible, use\n   * the const constructor of Symbol or symbol literals.\n   */\n  external static Symbol getSymbol(String name, [LibraryMirror library]);\n}\n\n/**\n * Returns a [MirrorSystem] for the current isolate.\n */\nexternal MirrorSystem currentMirrorSystem();\n\n/**\n * Reflects an instance.\n * Returns an [InstanceMirror] reflecting [reflectee].\n * If [reflectee] is a function or an instance of a class\n * that has a [:call:] method, the returned instance mirror\n * will be a [ClosureMirror].\n *\n * Note that since one cannot obtain an object from\n * another isolate, this function can only be used to\n * obtain  mirrors on objects of the current isolate.\n */\nexternal InstanceMirror reflect(Object reflectee);\n\n/**\n * Reflects a class declaration.\n * Let *C* be the original class declaration of the class\n * represented by [key].\n * This function returns a [ClassMirror] reflecting *C*.\n *\n * If [key] is not an instance of [Type] then this function\n * throws an [ArgumentError]. If [key] is the Type for dynamic\n * or a function typedef, throws an [ArgumentError].\n *\n * Note that since one cannot obtain a [Type] object from\n * another isolate, this function can only be used to\n * obtain class mirrors on classes of the current isolate.\n */\nexternal ClassMirror reflectClass(Type key);\n\n/**\n * This function returns a [TypeMirror] reflecting the type\n * represented by [key].\n *\n * If [key] is not an instance of [Type] then this function\n * throws an [ArgumentError].\n *\n * Note that since one cannot obtain a [Type] object from\n * another isolate, this function can only be used to\n * obtain type mirrors on types of the current isolate.\n */\nexternal TypeMirror reflectType(Type key);\n\n/**\n * A [Mirror] reflects some Dart language entity.\n *\n * Every [Mirror] originates from some [MirrorSystem].\n */\nabstract class Mirror {}\n\n/**\n * An [IsolateMirror] reflects an isolate.\n */\nabstract class IsolateMirror implements Mirror {\n  /**\n   * Returns a unique name used to refer to an isolate\n   * in debugging messages.\n   */\n  String get debugName;\n\n  /**\n   * Returns [:true:] if and only if this mirror reflects\n   * the currently running isolate. Otherwise returns\n   * [:false:].\n   */\n  bool get isCurrent;\n\n  /**\n   * Returns a [LibraryMirror] on the root library for this\n   * isolate.\n   */\n  LibraryMirror get rootLibrary;\n\n  /**\n   * Returns [:true:] if this mirror is equal to [other].\n   * Otherwise returns [:false:].\n   * The equality holds if and only if\n   * (1) [other] is a mirror of the same kind\n   * and\n   * (2) the isolate being reflected by this mirror is the same\n   * isolate being reflected by [other].\n   */\n  bool operator == (other);\n}\n\n/**\n * A [DeclarationMirror] reflects some entity declared in a Dart program.\n */\nabstract class DeclarationMirror implements Mirror {\n  /**\n   * The simple name for this Dart language entity.\n   *\n   * The simple name is in most cases the the identifier name of the\n   * entity, such as 'method' for a method [:void method() {...}:] or\n   * 'mylibrary' for a [:library 'mylibrary';:] declaration.\n   */\n  Symbol get simpleName;\n\n  /**\n   * The fully-qualified name for this Dart language entity.\n   *\n   * This name is qualified by the name of the owner. For instance,\n   * the qualified name of a method 'method' in class 'Class' in\n   * library 'library' is 'library.Class.method'.\n   *\n   * Returns a [Symbol] constructed from a string representing the\n   * fully qualified name of the reflectee.\n   * Let *o* be the [owner] of this mirror, let *r* be the reflectee of\n   * this mirror, let *p* be the fully qualified\n   * name of the reflectee of *o*, and let *s* be the simple name of *r*\n   * computed by [simpleName].\n   * The fully qualified name of *r* is the\n   * concatenation of *p*, '.', and *s*.\n   *\n   * Because an isolate can contain more than one library with the same name (at\n   * different URIs), a fully-qualified name does not uniquely identify any\n   * language entity.\n   */\n  Symbol get qualifiedName;\n\n  /**\n   * A mirror on the owner of this Dart language entity. This is the declaration\n   * immediately surrounding the reflectee.\n   *\n   * For a library, the owner is [:null:].\n   * For a class declaration, typedef or top level function\n   * or variable, the owner is the enclosing library.\n   * For a mixin application *S with M*, the owner is the owner\n   * of *M*.\n   * For a constructor, the owner is the immediately enclosing class.\n   * For a method, instance variable or\n   * a static variable, the owner is the immediately enclosing class,\n   * unless the class is a mixin application *S with M*, in which case\n   * the owner is *M*. Note that *M* may be an invocation of a generic.\n   * For a parameter, local variable or local function the owner is the\n   * immediately enclosing function.\n   */\n  DeclarationMirror get owner;\n\n  /**\n   * Returns [:true:] if this declaration is considered private\n   * according to the Dart language specification.\n   * Always returns [: false :] if this declaration\n   * is a library.\n   * Otherwise return [:false:].\n   *\n   */\n  bool get isPrivate;\n\n  /**\n   * Is this declaration top-level?\n   *\n   * This is defined to be equivalent to:\n   *    [:mirror.owner != null && mirror.owner is LibraryMirror:]\n   */\n  bool get isTopLevel;\n\n  /**\n   * The source location of this Dart language entity.\n   *\n   * This operation is optional and may return [:null:].\n   */\n  SourceLocation get location;\n\n  /**\n   * A list of the metadata associated with this declaration.\n   *\n   * Let *D* be the declaration this mirror reflects.\n   * If *D* is decorated with annotations *A1, ..., An*\n   * where *n > 0*, then for each annotation *Ai* associated\n   * with *D, 1 <= i <= n*, let *ci* be the constant object\n   * specified by *Ai*. Then this method returns a list whose\n   * members are instance mirrors on *c1, ..., cn*.\n   * If no annotations are associated with *D*, then\n   * an empty list is returned.\n   *\n   * If evaluating any of *c1, ..., cn* would cause a\n   * compilation error\n   * the effect is the same as if a non-reflective compilation error\n   * had been encountered.\n   */\n  List<InstanceMirror> get metadata;\n}\n\n/**\n * An [ObjectMirror] is a common superinterface of [InstanceMirror],\n * [ClassMirror], and [LibraryMirror] that represents their shared\n * functionality.\n *\n * For the purposes of the mirrors library, these types are all\n * object-like, in that they support method invocation and field\n * access.  Real Dart objects are represented by the [InstanceMirror]\n * type.\n *\n * See [InstanceMirror], [ClassMirror], and [LibraryMirror].\n */\nabstract class ObjectMirror implements Mirror {\n\n  /**\n   * Invokes the named function and returns a mirror on the result.\n   *\n   * Let *o* be the object reflected by this mirror, let\n   * *f* be the simple name of the member denoted by [memberName],\n   * let *a1, ..., an* be the elements of [positionalArguments]\n   * let *k1, ..., km* be the identifiers denoted by the elements of\n   * [namedArguments.keys]\n   * and let *v1, ..., vm* be the elements of [namedArguments.values].\n   * Then this method will perform the method invocation\n   *  *o.f(a1, ..., an, k1: v1, ..., km: vm)*\n   * in a scope that has access to the private members\n   * of *o* (if *o* is a class or library) or the private members of the\n   * class of *o* (otherwise).\n   * If the invocation returns a result *r*, this method returns\n   * the result of calling [reflect](*r*).\n   * If the invocation causes a compilation error\n   * the effect is the same as if a non-reflective compilation error\n   * had been encountered.\n   * If the invocation throws an exception *e* (that it does not catch)\n   * this method throws *e*.\n   */\n  /*\n   * TODO(turnidge): Handle ambiguous names.\n   * TODO(turnidge): Handle optional & named arguments.\n   */\n  InstanceMirror invoke(Symbol memberName,\n                        List positionalArguments,\n                        [Map<Symbol,dynamic> namedArguments]);\n\n  /**\n   * Invokes a getter and returns a mirror on the result. The getter\n   * can be the implicit getter for a field or a user-defined getter\n   * method.\n   *\n   * Let *o* be the object reflected by this mirror, let\n   * *f* be the simple name of the getter denoted by [fieldName],\n   * Then this method will perform the getter invocation\n   *  *o.f*\n   * in a scope that has access to the private members\n   * of *o* (if *o* is a class or library) or the private members of the\n   * class of *o* (otherwise).\n   *\n   * If this mirror is an [InstanceMirror], and [fieldName] denotes an instance\n   * method on its reflectee, the result of the invocation is an instance\n   * mirror on a closure corresponding to that method.\n   *\n   * If this mirror is a [LibraryMirror], and [fieldName] denotes a top-level\n   * method in the corresponding library, the result of the invocation is an\n   * instance mirror on a closure corresponding to that method.\n   *\n   * If this mirror is a [ClassMirror], and [fieldName] denotes a static method\n   * in the corresponding class, the result of the invocation is an instance\n   * mirror on a closure corresponding to that method.\n   *\n   * If the invocation returns a result *r*, this method returns\n   * the result of calling [reflect](*r*).\n   * If the invocation causes a compilation error\n   * the effect is the same as if a non-reflective compilation error\n   * had been encountered.\n   * If the invocation throws an exception *e* (that it does not catch)\n   * this method throws *e*.\n   */\n  // TODO(ahe): Remove stuff about scope and private members. [fieldName] is a\n  // capability giving access to private members.\n  InstanceMirror getField(Symbol fieldName);\n\n  /**\n   * Invokes a setter and returns a mirror on the result. The setter\n   * may be either the implicit setter for a non-final field or a\n   * user-defined setter method.\n   *\n   * Let *o* be the object reflected by this mirror, let\n   * *f* be the simple name of the getter denoted by [fieldName],\n   * and let *a* be the object bound to [value].\n   * Then this method will perform the setter invocation\n   * *o.f = a*\n   * in a scope that has access to the private members\n   * of *o* (if *o* is a class or library) or the private members of the\n   * class of *o* (otherwise).\n   * If the invocation returns a result *r*, this method returns\n   * the result of calling [reflect]([value]).\n   * If the invocation causes a compilation error\n   * the effect is the same as if a non-reflective compilation error\n   * had been encountered.\n   * If the invocation throws an exception *e* (that it does not catch)\n   * this method throws *e*.\n   */\n  /* TODO(turnidge): Handle ambiguous names.*/\n  InstanceMirror setField(Symbol fieldName, Object value);\n}\n\n/**\n * An [InstanceMirror] reflects an instance of a Dart language object.\n */\nabstract class InstanceMirror implements ObjectMirror {\n  /**\n   * A mirror on the type of the reflectee.\n   *\n   * Returns a mirror on the actual class of the reflectee.\n   * The class of the reflectee may differ from\n   * the object returned by invoking [runtimeType] on\n   * the reflectee.\n   */\n  ClassMirror get type;\n\n  /**\n   * Does [reflectee] contain the instance reflected by this mirror?\n   * This will always be true in the local case (reflecting instances\n   * in the same isolate), but only true in the remote case if this\n   * mirror reflects a simple value.\n   *\n   * A value is simple if one of the following holds:\n   *  - the value is [:null:]\n   *  - the value is of type [num]\n   *  - the value is of type [bool]\n   *  - the value is of type [String]\n   */\n  bool get hasReflectee;\n\n  /**\n   * If the [InstanceMirror] reflects an instance it is meaningful to\n   * have a local reference to, we provide access to the actual\n   * instance here.\n   *\n   * If you access [reflectee] when [hasReflectee] is false, an\n   * exception is thrown.\n   */\n  get reflectee;\n\n  /**\n   * Returns true if this mirror is equal to [other].\n   * The equality holds if and only if\n   * (1) [other] is a mirror of the same kind\n   * and\n   * (2) either\n   * (a) [hasReflectee] is true and so is\n   * [:identical(reflectee, other.reflectee):]\n   * or\n   * (b) the remote objects reflected by this mirror and\n   * by [other] are identical.\n   */\n  bool operator == (other);\n\n  /**\n   * Perform [invocation] on [reflectee].\n   * Equivalent to\n   *\n   * this.invoke(invocation.memberName,\n   *             invocation.positionalArguments,\n   *             invocation.namedArguments);\n   */\n  delegate(Invocation invocation);\n}\n\n/**\n * A [ClosureMirror] reflects a closure.\n *\n * A [ClosureMirror] provides access to its captured variables and\n * provides the ability to execute its reflectee.\n */\nabstract class ClosureMirror implements InstanceMirror {\n  /**\n   * A mirror on the function associated with this closure.\n   *\n   * The function associated with an implicit closure of a function is that\n   * function.\n   *\n   * The function associated with an instance of a class that has a [:call:]\n   * method is that [:call:] method.\n   */\n  MethodMirror get function;\n\n  /**\n   * Executes the closure and returns a mirror on the result.\n   * Let *f* be the closure reflected by this mirror,\n   * let *a1, ..., an* be the elements of [positionalArguments]\n   * let *k1, ..., km* be the identifiers denoted by the elements of\n   * [namedArguments.keys]\n   * and let *v1, ..., vm* be the elements of [namedArguments.values].\n   * Then this method will perform the method invocation\n   *  *f(a1, ..., an, k1: v1, ..., km: vm)*\n   * If the invocation returns a result *r*, this method returns\n   * the result of calling [reflect](*r*).\n   * If the invocation causes a compilation error\n   * the effect is the same as if a non-reflective compilation error\n   * had been encountered.\n   * If the invocation throws an exception *e* (that it does not catch)\n   * this method throws *e*.\n   */\n  InstanceMirror apply(List positionalArguments,\n                       [Map<Symbol, dynamic> namedArguments]);\n}\n\n/**\n * A [LibraryMirror] reflects a Dart language library, providing\n * access to the variables, functions, and classes of the\n * library.\n */\nabstract class LibraryMirror implements DeclarationMirror, ObjectMirror {\n  /**\n   * The absolute uri of the library.\n   */\n  Uri get uri;\n\n  /**\n   * Returns an immutable map of the declarations actually given in the library.\n   *\n   * This map includes all regular methods, getters, setters, fields, classes\n   * and typedefs actually declared in the library. The map is keyed by the\n   * simple names of the declarations.\n   */\n  Map<Symbol, DeclarationMirror> get declarations;\n\n  /**\n   * Returns [:true:] if this mirror is equal to [other].\n   * Otherwise returns [:false:].\n   *\n   * The equality holds if and only if\n   * (1) [other] is a mirror of the same kind\n   * and\n   * (2)  The library being reflected by this mirror\n   * and the library being reflected by [other]\n   * are\n   * the same library in the same isolate.\n   */\n   bool operator ==(other);\n\n  /**\n   * Returns a list of the imports and exports in this library;\n   */\n  List<LibraryDependencyMirror> get libraryDependencies;\n}\n\n/// A mirror on an import or export declaration.\nabstract class LibraryDependencyMirror implements Mirror {\n  /// Is `true` if this dependency is an import.\n  bool get isImport;\n\n  /// Is `true` if this dependency is an export.\n  bool get isExport;\n\n  /// Returns the library mirror of the library that imports or exports the\n  /// [targetLibrary].\n  LibraryMirror get sourceLibrary;\n\n  /// Returns the library mirror of the library that is imported or exported.\n  LibraryMirror get targetLibrary;\n\n  /// Returns the prefix if this is a prefixed import and `null` otherwise.\n  Symbol get prefix;\n\n  /// Returns the list of show/hide combinators on the import/export\n  /// declaration.\n  List<CombinatorMirror> get combinators;\n\n  /// Returns the source location for this import/export declaration.\n  SourceLocation get location;\n\n  List<InstanceMirror> get metadata;\n}\n\n/// A mirror on a show/hide combinator declared on a library dependency.\nabstract class CombinatorMirror implements Mirror {\n  /// The list of identifiers on the combinator.\n  List<Symbol> get identifiers;\n\n  /// Is `true` if this is a 'show' combinator.\n  bool get isShow;\n\n  /// Is `true` if this is a 'hide' combinator.\n  bool get isHide;\n}\n\n/**\n * A [TypeMirror] reflects a Dart language class, typedef,\n * function type or type variable.\n */\nabstract class TypeMirror implements DeclarationMirror {\n  /**\n   * Returns true if this mirror reflects dynamic, a non-generic class or\n   * typedef, or an instantiated generic class or typedef in the current\n   * isolate. Otherwise, returns false.\n   */\n  bool get hasReflectedType;\n\n  /**\n   * If [:hasReflectedType:] returns true, returns the corresponding [Type].\n   * Otherwise, an [UnsupportedError] is thrown.\n   */\n  Type get reflectedType;\n\n  /**\n   * An immutable list with mirrors for all type variables for this type.\n   *\n   * If this type is a generic declaration or an invocation of a generic\n   * declaration, the returned list contains mirrors on the type variables\n   * declared in the original declaration.\n   * Otherwise, the returned list is empty.\n   *\n   * This list preserves the order of declaration of the type variables.\n   */\n  List<TypeVariableMirror> get typeVariables;\n\n  /**\n   * An immutable list with mirrors for all type arguments for\n   * this type.\n   *\n   * If the reflectee is an invocation of a generic class,\n   * the type arguments are the bindings of its type parameters.\n   * If the reflectee is the original declaration of a generic,\n   * it has no type arguments and this method returns an empty list.\n   * If the reflectee is not generic, then\n   * it has no type arguments and this method returns an empty list.\n   *\n   * This list preserves the order of declaration of the type variables.\n   */\n  List<TypeMirror> get typeArguments;\n\n  /**\n   * Is this the original declaration of this type?\n   *\n   * For most classes, they are their own original declaration.  For\n   * generic classes, however, there is a distinction between the\n   * original class declaration, which has unbound type variables, and\n   * the instantiations of generic classes, which have bound type\n   * variables.\n   */\n  bool get isOriginalDeclaration;\n\n  /**\n   * A mirror on the original declaration of this type.\n   *\n   * For most classes, they are their own original declaration.  For\n   * generic classes, however, there is a distinction between the\n   * original class declaration, which has unbound type variables, and\n   * the instantiations of generic classes, which have bound type\n   * variables.\n   */\n  TypeMirror get originalDeclaration;\n\n\n  /**\n   * Checks the subtype relationship, denoted by [:<::] in the language\n   * specification. This is the type relationship used in [:is:] test checks.\n   */\n  bool isSubtypeOf(TypeMirror other);\n\n  /**\n   * Checks the assignability relationship, denoted by [:<=>:] in the language\n   * specification. This is the type relationship tested on assignment in\n   * checked mode.\n   */\n  bool isAssignableTo(TypeMirror other);\n}\n\n/**\n * A [ClassMirror] reflects a Dart language class.\n */\nabstract class ClassMirror implements TypeMirror, ObjectMirror {\n  /**\n   * A mirror on the superclass on the reflectee.\n   *\n   * If this type is [:Object:], the superclass will be null.\n   */\n  ClassMirror get superclass;\n\n  /**\n   * A list of mirrors on the superinterfaces of the reflectee.\n   */\n  List<ClassMirror> get superinterfaces;\n\n  /**\n   * Is the reflectee abstract?\n   */\n  bool get isAbstract;\n\n  /**\n   * Returns an immutable map of the declarations actually given in the class\n   * declaration.\n   *\n   * This map includes all regular methods, getters, setters, fields,\n   * constructors and type variables actually declared in the class. Both\n   * static and instance members are included, but no inherited members are\n   * included. The map is keyed by the simple names of the declarations.\n   *\n   * This does not include inherited members.\n   */\n  Map<Symbol, DeclarationMirror> get declarations;\n\n  /**\n   * Returns a map of the methods, getters and setters of an instance of the\n   * class.\n   *\n   * The intent is to capture those members that constitute the API of an\n   * instance. Hence fields are not included, but the getters and setters\n   * implicitly introduced by fields are included. The map includes methods,\n   * getters and setters that are inherited as well as those introduced by the\n   * class itself.\n   *\n   * The map is keyed by the simple names of the members.\n   */\n  Map<Symbol, MethodMirror> get instanceMembers;\n\n  /**\n   * Returns a map of the static methods, getters and setters of the class.\n   *\n   * The intent is to capture those members that constitute the API of a class.\n   * Hence fields are not included, but the getters and setters implicitly\n   * introduced by fields are included.\n   *\n   * The map is keyed by the simple names of the members.\n   */\n  Map<Symbol, MethodMirror> get staticMembers;\n\n\n  /**\n   * The mixin of this class.\n   * If this class is the result of a mixin application of the\n   * form S with M, returns a class mirror on M.\n   * Otherwise returns a class mirror on [reflectee].\n   */\n  ClassMirror get mixin;\n\n  // TODO(ahe): What about:\n  // /// Finds the instance member named [name] declared or inherited in the\n  // /// reflected class.\n  // DeclarationMirror instanceLookup(Symbol name);\n\n   /**\n   * Invokes the named constructor and returns a mirror on the result.\n   *\n   * Let *c* be the class reflected by this mirror\n   * let *a1, ..., an* be the elements of [positionalArguments]\n   * let *k1, ..., km* be the identifiers denoted by the elements of\n   * [namedArguments.keys]\n   * and let *v1, ..., vm* be the elements of [namedArguments.values].\n   * If [constructorName] was created from the empty string\n   * Then this method will execute the instance creation expression\n   * *new c(a1, ..., an, k1: v1, ..., km: vm)*\n   * in a scope that has access to the private members\n   * of *c*. Otherwise, let\n   * *f* be the simple name of the constructor denoted by [constructorName]\n   * Then this method will execute the instance creation expression\n   *  *new c.f(a1, ..., an, k1: v1, ..., km: vm)*\n   * in a scope that has access to the private members\n   * of *c*.\n   * In either case:\n   * If the expression evaluates to a result *r*, this method returns\n   * the result of calling [reflect](*r*).\n   * If evaluating the expression causes a compilation error\n   * the effect is the same as if a non-reflective compilation error\n   * had been encountered.\n   * If evaluating the expression throws an exception *e*\n   * (that it does not catch)\n   * this method throws *e*.\n   */\n  InstanceMirror newInstance(Symbol constructorName,\n                             List positionalArguments,\n                             [Map<Symbol,dynamic> namedArguments]);\n\n  /**\n   * Returns [:true:] if this mirror is equal to [other].\n   * Otherwise returns [:false:].\n   *\n   * The equality holds if and only if\n   * (1) [other] is a mirror of the same kind\n   * and\n   * (2) This mirror and [other] reflect the same class.\n   *\n   * Note that if the reflected class is an invocation of\n   * a generic class,(2) implies that the reflected class\n   * and [other] have equal type arguments.\n   */\n   bool operator == (other);\n\n  /**\n   * Returns whether the class denoted by the receiver is a subclass of the\n   * class denoted by the argument.\n   *\n   * Note that the subclass relationship is reflexive.\n   */\n  bool isSubclassOf(ClassMirror other);\n}\n\n/**\n * A [FunctionTypeMirror] represents the type of a function in the\n * Dart language.\n */\nabstract class FunctionTypeMirror implements ClassMirror {\n  /**\n   * Returns the return type of the reflectee.\n   */\n  TypeMirror get returnType;\n\n  /**\n   * Returns a list of the parameter types of the reflectee.\n   */\n  List<ParameterMirror> get parameters;\n\n  /**\n   * A mirror on the [:call:] method for the reflectee.\n   */\n  MethodMirror get callMethod;\n}\n\n/**\n * A [TypeVariableMirror] represents a type parameter of a generic\n * type.\n */\nabstract class TypeVariableMirror extends TypeMirror {\n  /**\n   * A mirror on the type that is the upper bound of this type variable.\n   */\n  TypeMirror get upperBound;\n\n  /**\n   * Is the reflectee static?\n   *\n   * For the purposes of the mirrors library, type variables are considered\n   * non-static.\n   */\n  bool get isStatic;\n\n  /**\n   * Returns [:true:] if this mirror is equal to [other].\n   * Otherwise returns [:false:].\n   *\n   * The equality holds if and only if\n   * (1) [other] is a mirror of the same kind\n   * and\n   * (2)  [:simpleName == other.simpleName:] and\n   * [:owner == other.owner:].\n   */\n   bool operator == (other);\n}\n\n/**\n * A [TypedefMirror] represents a typedef in a Dart language program.\n */\nabstract class TypedefMirror implements TypeMirror {\n  /**\n   * The defining type for this typedef.\n   * If the the type referred to by the reflectee is a function type \n   * *F*, the result will be [:FunctionTypeMirror:] reflecting *F*\n   * which is abstract and has an abstract method [:call:] whose \n   * signature corresponds to *F*.\n   *\n   * For instance [:void f(int):] is the referent for [:typedef void f(int):].\n   */\n  FunctionTypeMirror get referent;\n}\n\n/**\n * A [MethodMirror] reflects a Dart language function, method,\n * constructor, getter, or setter.\n */\nabstract class MethodMirror implements DeclarationMirror {\n  /**\n   * A mirror on the return type for the reflectee.\n   */\n  TypeMirror get returnType;\n\n  /**\n   * The source code for the reflectee, if available. Otherwise null.\n   */\n  String get source;\n\n  /**\n   * A list of mirrors on the parameters for the reflectee.\n   */\n  List<ParameterMirror> get parameters;\n\n  /**\n   * A function is considered non-static iff it is permited to refer to 'this'.\n   *\n   * Note that generative constructors are considered non-static, whereas\n   * factory constructors are considered static.\n   */\n  bool get isStatic;\n\n  /**\n   * Is the reflectee abstract?\n   */\n  bool get isAbstract;\n\n  /**\n   * Returns true if the reflectee is synthetic, and returns false otherwise.\n   *\n   * A reflectee is synthetic if it is a getter or setter implicitly introduced\n   * for a field or Type, or if it is a constructor that was implicitly\n   * introduced as a default constructor or as part of a mixin application.\n   */\n  bool get isSynthetic;\n\n  /**\n   * Is the reflectee a regular function or method?\n   *\n   * A function or method is regular if it is not a getter, setter, or\n   * constructor.  Note that operators, by this definition, are\n   * regular methods.\n   */\n  bool get isRegularMethod;\n\n  /**\n   * Is the reflectee an operator?\n   */\n  bool get isOperator;\n\n  /**\n   * Is the reflectee a getter?\n   */\n  bool get isGetter;\n\n  /**\n   * Is the reflectee a setter?\n   */\n  bool get isSetter;\n\n  /**\n   * Is the reflectee a constructor?\n   */\n  bool get isConstructor;\n\n  /**\n   * The constructor name for named constructors and factory methods.\n   *\n   * For unnamed constructors, this is the empty string.  For\n   * non-constructors, this is the empty string.\n   *\n   * For example, [:'bar':] is the constructor name for constructor\n   * [:Foo.bar:] of type [:Foo:].\n   */\n  Symbol get constructorName;\n\n  /**\n   * Is the reflectee a const constructor?\n   */\n  bool get isConstConstructor;\n\n  /**\n   * Is the reflectee a generative constructor?\n   */\n  bool get isGenerativeConstructor;\n\n  /**\n   * Is the reflectee a redirecting constructor?\n   */\n  bool get isRedirectingConstructor;\n\n  /**\n   * Is the reflectee a factory constructor?\n   */\n  bool get isFactoryConstructor;\n\n  /**\n   * Returns true if this mirror is equal to [other].\n   *\n   * The equality holds if and only if\n   * (1) [other] is a mirror of the same kind\n   * and\n   * (2) [:simpleName == other.simpleName:] and\n   * [:owner == other.owner:].\n   */\n   bool operator == (other);\n}\n\n/**\n * A [VariableMirror] reflects a Dart language variable declaration.\n */\nabstract class VariableMirror implements DeclarationMirror {\n  /**\n   * Returns a mirror on the type of the reflectee.\n   */\n  TypeMirror get type;\n\n  /**\n   * Returns [:true:] if the reflectee is a static variable.\n   * Otherwise returns [:false:].\n   *\n   * For the purposes of the mirror library, top-level variables are\n   * implicitly declared static.\n   */\n  bool get isStatic;\n\n  /**\n   * Returns [:true:] if the reflectee is a final variable.\n   * Otherwise returns [:false:].\n   */\n  bool get isFinal;\n\n  /**\n   * Returns [:true:] if the reflectee is declared [:const:].\n   * Otherwise returns [:false:].\n   */\n  bool get isConst;\n\n  /**\n   * Returns true if this mirror is equal to [other].\n   *\n   * The equality holds if and only if\n   * (1) [other] is a mirror of the same kind\n   * and\n   * (2)  [:simpleName == other.simpleName:] and\n   * [:owner == other.owner:].\n   */\n   bool operator == (other);\n}\n\n/**\n * A [ParameterMirror] reflects a Dart formal parameter declaration.\n */\nabstract class ParameterMirror implements VariableMirror {\n  /**\n   * A mirror on the type of this parameter.\n   */\n  TypeMirror get type;\n\n  /**\n   * Returns [:true:] if the reflectee is an optional parameter.\n   * Otherwise returns [:false:].\n   */\n  bool get isOptional;\n\n  /**\n   * Returns [:true:] if the reflectee is a named parameter.\n   * Otherwise returns [:false:].\n   */\n  bool get isNamed;\n\n  /**\n   * Returns [:true:] if the reflectee has explicitly declared a default value.\n   * Otherwise returns [:false:].\n   */\n  bool get hasDefaultValue;\n\n  /**\n   * If this is a required parameter, returns [:null:]. Otherwise returns a\n   * mirror on the default value for this parameter. If no default is declared\n   * for an optional parameter, the default is [:null:] and a mirror on [:null:]\n   * is returned.\n   */\n  InstanceMirror get defaultValue;\n}\n\n/**\n * A [SourceLocation] describes the span of an entity in Dart source code.\n */\nabstract class SourceLocation {\n  /**\n   * The 1-based line number for this source location.\n   *\n   * A value of 0 means that the line number is unknown.\n   */\n  int get line;\n\n  /**\n   * The 1-based column number for this source location.\n   *\n   * A value of 0 means that the column number is unknown.\n   */\n  int get column;\n\n  /**\n   * Returns the URI where the source originated.\n   */\n  Uri get sourceUri;\n}\n\n/**\n * Class used for encoding comments as metadata annotations.\n */\nclass Comment {\n  /**\n   * The comment text as written in the source text.\n   */\n  final String text;\n\n  /**\n   * The comment text without the start, end, and padding text.\n   *\n   * For example, if [text] is [: /** Comment text. */ :] then the [trimmedText]\n   * is [: Comment text. :].\n   */\n  final String trimmedText;\n\n  /**\n   * Is [:true:] if this comment is a documentation comment.\n   *\n   * That is, that the comment is either enclosed in [: /** ... */ :] or starts\n   * with [: /// :].\n   */\n  final bool isDocComment;\n\n  const Comment(this.text, this.trimmedText, this.isDocComment);\n}\n\n/**\n * Annotation describing how \"dart:mirrors\" is used (EXPERIMENTAL).\n *\n * When used as metadata on an import of \"dart:mirrors\" in library *L*, this\n * class describes how \"dart:mirrors\" is used by library *L* unless overridden.\n * See [override].\n *\n * The following text is non-normative:\n *\n * In some scenarios, for example, when minifying Dart code, or when generating\n * JavaScript code from a Dart program, the size and performance of the output\n * can suffer from use of reflection.  In those cases, telling the compiler\n * what is used, can have a significant impact.\n *\n * Example usage:\n *\n *     @MirrorsUsed(symbols: 'foo', override: '*')\n *     import 'dart:mirrors';\n *\n *     class Foo {\n *       noSuchMethod(Invocation invocation) {\n *         print(MirrorSystem.getName(invocation.memberName));\n *       }\n *     }\n *\n *     main() {\n *       new Foo().foo(); // Prints \"foo\".\n *       new Foo().bar(); // Might print an arbitrary (mangled) name, \"bar\".\n *     }\n */\n// TODO(ahe): Remove \", override: '*'\" when it isn't necessary anymore.\nclass MirrorsUsed {\n  // Note: the fields of this class are untyped.  This is because the most\n  // convenient way to specify to specify symbols today is using a single\n  // string. In some cases, a const list of classes might be convenient. Some\n  // might prefer to use a const list of symbols.\n\n  /**\n   * The list of strings passed to new [Symbol], and symbols that might be\n   * passed to [MirrorSystem.getName].\n   *\n   * Combined with the names of [targets], [metaTargets] and their members,\n   * this forms the complete list of strings passed to new [Symbol], and\n   * symbols that might be passed to [MirrorSystem.getName] by the library to\n   * which this metadata applies.\n   *\n   * The following text is non-normative:\n   *\n   * Specifying this option turns off the following warnings emitted by\n   * dart2js:\n   *\n   * * Using \"MirrorSystem.getName\" may result in larger output.\n   * * Using \"new #{name}\" may result in larger output.\n   *\n   * Use symbols = \"*\" to turn off the warnings mentioned above.\n   *\n   * For example, if using [noSuchMethod] to interact with a database, extract\n   * all the possible column names and include them in this list.  Similarly,\n   * if using [noSuchMethod] to interact with another language (JavaScript, for\n   * example) extract all the identifiers from API used and include them in\n   * this list.\n   */\n  final symbols;\n\n  /**\n   * A list of reflective targets.\n   *\n   * Combined with [metaTargets], this provides the complete list of reflective\n   * targets used by the library to which this metadata applies.\n   *\n   * The following text is non-normative:\n   *\n   * For now, there is no formal description of what a reflective target is.\n   * Informally, it is a list of things that are expected to have fully\n   * functional mirrors.\n   */\n  final targets;\n\n  /**\n   * A list of classes that when used as metadata indicates a reflective\n   * target.\n   *\n   * See [targets].\n   */\n  final metaTargets;\n\n  /**\n   * A list of library names or \"*\".\n   *\n   * When used as metadata on an import of \"dart:mirrors\", this metadata does\n   * not apply to the library in which the annotation is used, but instead\n   * applies to the other libraries (all libraries if \"*\" is used).\n   */\n  final override;\n\n  const MirrorsUsed(\n      {this.symbols, this.targets, this.metaTargets, this.override});\n}\n\u0000","sdk:/sdk/lib/_internal/lib/js_mirrors.dart":"// Copyright (c) 2013, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\nlibrary dart._js_mirrors;\n\nimport '../compiler/implementation/runtime_data.dart' as encoding;\n\nimport 'dart:collection' show\n    UnmodifiableListView,\n    UnmodifiableMapView;\n\nimport 'dart:mirrors';\n\nimport 'dart:_foreign_helper' show\n    JS,\n    JS_CURRENT_ISOLATE,\n    JS_CURRENT_ISOLATE_CONTEXT,\n    JS_GET_NAME;\n\nimport 'dart:_internal' as _symbol_dev;\n\nimport 'dart:_js_helper' show\n    BoundClosure,\n    CachedInvocation,\n    Closure,\n    JSInvocationMirror,\n    JsCache,\n    Null,\n    Primitives,\n    ReflectionInfo,\n    RuntimeError,\n    TearOffClosure,\n    TypeVariable,\n    UnimplementedNoSuchMethodError,\n    createRuntimeType,\n    createUnmangledInvocationMirror,\n    getMangledTypeName,\n    getMetadata,\n    getRuntimeType,\n    runtimeTypeToString,\n    setRuntimeTypeInfo,\n    throwInvalidReflectionError;\n\nimport 'dart:_interceptors' show\n    Interceptor,\n    JSArray,\n    JSExtendableArray,\n    getInterceptor;\n\nimport 'dart:_js_names';\n\nconst String METHODS_WITH_OPTIONAL_ARGUMENTS = r'$methodsWithOptionalArguments';\n\nbool hasReflectableProperty(var jsFunction) {\n  return JS('bool', '# in #', JS_GET_NAME(\"REFLECTABLE\"), jsFunction);\n}\n\n/// No-op method that is called to inform the compiler that tree-shaking needs\n/// to be disabled.\ndisableTreeShaking() => preserveNames();\n\n/// No-op method that is called to inform the compiler that metadata must be\n/// preserved at runtime.\npreserveMetadata() {}\n\n/// No-op method that is called to inform the compiler that the compiler must\n/// preserve the URIs.\npreserveUris() {}\n\n/// No-op method that is called to inform the compiler that the compiler must\n/// preserve the library names.\npreserveLibraryNames() {}\n\nString getName(Symbol symbol) {\n  preserveNames();\n  return n(symbol);\n}\n\nclass JsMirrorSystem implements MirrorSystem {\n  UnmodifiableMapView<Uri, LibraryMirror> _cachedLibraries;\n\n  final IsolateMirror isolate = new JsIsolateMirror();\n\n  JsTypeMirror get dynamicType => _dynamicType;\n  JsTypeMirror get voidType => _voidType;\n\n  static final JsTypeMirror _dynamicType =\n      new JsTypeMirror(const Symbol('dynamic'));\n  static final JsTypeMirror _voidType = new JsTypeMirror(const Symbol('void'));\n\n  static final Map<String, List<LibraryMirror>> librariesByName =\n      computeLibrariesByName();\n\n  Map<Uri, LibraryMirror> get libraries {\n    if (_cachedLibraries != null) return _cachedLibraries;\n    Map<Uri, LibraryMirror> result = new Map();\n    for (List<LibraryMirror> list in librariesByName.values) {\n      for (LibraryMirror library in list) {\n        result[library.uri] = library;\n      }\n    }\n    return _cachedLibraries =\n        new UnmodifiableMapView<Uri, LibraryMirror>(result);\n  }\n\n  LibraryMirror findLibrary(Symbol libraryName) {\n    return librariesByName[n(libraryName)].single;\n  }\n\n  static Map<String, List<LibraryMirror>> computeLibrariesByName() {\n    disableTreeShaking();\n    var result = new Map<String, List<LibraryMirror>>();\n    var jsLibraries = JS('JSExtendableArray|Null', 'init.libraries');\n    if (jsLibraries == null) return result;\n    for (List data in jsLibraries) {\n      String name = data[0];\n      Uri uri = Uri.parse(data[1]);\n      List<String> classes = data[2];\n      List<String> functions = data[3];\n      var metadataFunction = data[4];\n      var fields = data[5];\n      bool isRoot = data[6];\n      var globalObject = data[7];\n      List metadata = (metadataFunction == null)\n          ? const [] : JS('List', '#()', metadataFunction);\n      var libraries = result.putIfAbsent(name, () => <LibraryMirror>[]);\n      libraries.add(\n          new JsLibraryMirror(\n              s(name), uri, classes, functions, metadata, fields, isRoot,\n              globalObject));\n    }\n    return result;\n  }\n}\n\nabstract class JsMirror implements Mirror {\n  const JsMirror();\n\n  String get _prettyName;\n\n  String toString() => _prettyName;\n\n  // TODO(ahe): Remove this method from the API.\n  MirrorSystem get mirrors => currentJsMirrorSystem;\n\n  _getField(JsMirror receiver) {\n    throw new UnimplementedError();\n  }\n\n  void _setField(JsMirror receiver, Object arg) {\n    throw new UnimplementedError();\n  }\n\n  _loadField(String name) {\n    throw new UnimplementedError();\n  }\n\n  void _storeField(String name, Object arg) {\n    throw new UnimplementedError();\n  }\n}\n\n// This class is somewhat silly in the current implementation.\nclass JsIsolateMirror extends JsMirror implements IsolateMirror {\n  final _isolateContext = JS_CURRENT_ISOLATE_CONTEXT();\n\n  String get _prettyName => 'Isolate';\n\n  String get debugName {\n    String id = _isolateContext == null ? 'X' : _isolateContext.id.toString();\n    // Using name similar to what the VM uses.\n    return '${n(rootLibrary.simpleName)}-$id';\n  }\n\n  bool get isCurrent => JS_CURRENT_ISOLATE_CONTEXT() == _isolateContext;\n\n  LibraryMirror get rootLibrary {\n    return currentJsMirrorSystem.libraries.values.firstWhere(\n        (JsLibraryMirror library) => library._isRoot);\n  }\n}\n\nabstract class JsDeclarationMirror extends JsMirror\n    implements DeclarationMirror {\n  final Symbol simpleName;\n\n  const JsDeclarationMirror(this.simpleName);\n\n  Symbol get qualifiedName => computeQualifiedName(owner, simpleName);\n\n  bool get isPrivate => n(simpleName).startsWith('_');\n\n  bool get isTopLevel => owner != null && owner is LibraryMirror;\n\n  // TODO(ahe): This should use qualifiedName.\n  String toString() => \"$_prettyName on '${n(simpleName)}'\";\n\n  List<JsMethodMirror> get _methods {\n    throw new RuntimeError('Should not call _methods');\n  }\n\n  _invoke(List positionalArguments, Map<Symbol, dynamic> namedArguments) {\n    throw new RuntimeError('Should not call _invoke');\n  }\n\n  // TODO(ahe): Implement this.\n  SourceLocation get location => throw new UnimplementedError();\n}\n\nclass JsTypeVariableMirror extends JsTypeMirror implements TypeVariableMirror {\n  final DeclarationMirror owner;\n  final TypeVariable _typeVariable;\n  final int _metadataIndex;\n  TypeMirror _cachedUpperBound;\n\n  JsTypeVariableMirror(TypeVariable typeVariable, this.owner,\n                       this._metadataIndex)\n      : this._typeVariable = typeVariable,\n        super(s(typeVariable.name));\n\n  bool operator ==(other) {\n    return (other is JsTypeVariableMirror &&\n        simpleName == other.simpleName &&\n        owner == other.owner);\n  }\n\n  int get hashCode {\n    int code = 0x3FFFFFFF & (JsTypeVariableMirror).hashCode;\n    code ^= 17 * simpleName.hashCode;\n    code ^= 19 * owner.hashCode;\n    return code;\n  }\n\n  String get _prettyName => 'TypeVariableMirror';\n\n  bool get isTopLevel => false;\n  bool get isStatic => false;\n\n  TypeMirror get upperBound {\n    if (_cachedUpperBound != null) return _cachedUpperBound;\n    return _cachedUpperBound = typeMirrorFromRuntimeTypeRepresentation(\n        owner, getMetadata(_typeVariable.bound));\n  }\n\n  bool isSubtypeOf(TypeMirror other) => throw new UnimplementedError();\n  bool isAssignableTo(TypeMirror other) => throw new UnimplementedError();\n\n  _asRuntimeType() => _metadataIndex;\n}\n\nclass JsTypeMirror extends JsDeclarationMirror implements TypeMirror {\n  JsTypeMirror(Symbol simpleName)\n      : super(simpleName);\n\n  String get _prettyName => 'TypeMirror';\n\n  DeclarationMirror get owner => null;\n\n  // TODO(ahe): Doesn't match the specification, see http://dartbug.com/11569.\n  bool get isTopLevel => true;\n\n  // TODO(ahe): Implement these.\n  List<InstanceMirror> get metadata => throw new UnimplementedError();\n\n  bool get hasReflectedType => false;\n  Type get reflectedType {\n    throw new UnsupportedError(\"This type does not support reflectedType\");\n  }\n\n  List<TypeVariableMirror> get typeVariables => const <TypeVariableMirror>[];\n  List<TypeMirror> get typeArguments => const <TypeMirror>[];\n\n  bool get isOriginalDeclaration => true;\n  TypeMirror get originalDeclaration => this;\n\n  bool isSubtypeOf(TypeMirror other) => throw new UnimplementedError();\n  bool isAssignableTo(TypeMirror other) => throw new UnimplementedError();\n\n  _asRuntimeType() {\n    if (this == JsMirrorSystem._dynamicType) return null;\n    if (this == JsMirrorSystem._voidType) return null;\n    throw new RuntimeError('Should not call _asRuntimeType');\n  }\n}\n\nclass JsLibraryMirror extends JsDeclarationMirror with JsObjectMirror\n    implements LibraryMirror {\n  final Uri _uri;\n  final List<String> _classes;\n  final List<String> _functions;\n  final List _metadata;\n  final String _compactFieldSpecification;\n  final bool _isRoot;\n  final _globalObject;\n  List<JsMethodMirror> _cachedFunctionMirrors;\n  List<VariableMirror> _cachedFields;\n  UnmodifiableMapView<Symbol, ClassMirror> _cachedClasses;\n  UnmodifiableMapView<Symbol, MethodMirror> _cachedFunctions;\n  UnmodifiableMapView<Symbol, MethodMirror> _cachedGetters;\n  UnmodifiableMapView<Symbol, MethodMirror> _cachedSetters;\n  UnmodifiableMapView<Symbol, VariableMirror> _cachedVariables;\n  UnmodifiableMapView<Symbol, Mirror> _cachedMembers;\n  UnmodifiableMapView<Symbol, DeclarationMirror> _cachedDeclarations;\n  UnmodifiableListView<InstanceMirror> _cachedMetadata;\n\n  JsLibraryMirror(Symbol simpleName,\n                  this._uri,\n                  this._classes,\n                  this._functions,\n                  this._metadata,\n                  this._compactFieldSpecification,\n                  this._isRoot,\n                  this._globalObject)\n      : super(simpleName) {\n    preserveLibraryNames();\n  }\n\n  String get _prettyName => 'LibraryMirror';\n\n  Uri get uri {\n    preserveUris();\n    return _uri;\n  }\n\n  Symbol get qualifiedName => simpleName;\n\n  List<JsMethodMirror> get _methods => _functionMirrors;\n\n  Map<Symbol, ClassMirror> get __classes {\n    if (_cachedClasses != null) return _cachedClasses;\n    var result = new Map();\n    for (String className in _classes) {\n      var cls = reflectClassByMangledName(className);\n      if (cls is ClassMirror) {\n        cls = cls.originalDeclaration;\n      }\n      if (cls is JsClassMirror) {\n        result[cls.simpleName] = cls;\n        cls._owner = this;\n      } else  if (cls is JsTypedefMirror) {\n        result[cls.simpleName] = cls;\n      }\n    }\n    return _cachedClasses =\n        new UnmodifiableMapView<Symbol, ClassMirror>(result);\n  }\n\n  InstanceMirror setField(Symbol fieldName, Object arg) {\n    String name = n(fieldName);\n    if (name.endsWith('=')) throw new ArgumentError('');\n    var mirror = __functions[s('$name=')];\n    if (mirror == null) mirror = __variables[fieldName];\n    if (mirror == null) {\n      throw new NoSuchStaticMethodError.method(\n          null, setterSymbol(fieldName), [arg], null);\n    }\n    mirror._setField(this, arg);\n    return reflect(arg);\n  }\n\n  InstanceMirror getField(Symbol fieldName) {\n    JsMirror mirror = __members[fieldName];\n    if (mirror == null) {\n      throw new NoSuchStaticMethodError.method(null, fieldName, [], null);\n    }\n    if (mirror is! MethodMirror) return reflect(mirror._getField(this));\n    JsMethodMirror methodMirror = mirror;\n    if (methodMirror.isGetter) return reflect(mirror._getField(this));\n    assert(methodMirror.isRegularMethod);\n    var getter = JS(\"\", \"#['\\$getter']\", methodMirror._jsFunction);\n    if (getter == null) throw new UnimplementedError();\n    return reflect(JS(\"\", \"#()\", getter));\n  }\n\n  InstanceMirror invoke(Symbol memberName,\n                        List positionalArguments,\n                        [Map<Symbol, dynamic> namedArguments]) {\n    if (namedArguments != null && !namedArguments.isEmpty) {\n      throw new UnsupportedError('Named arguments are not implemented.');\n    }\n    JsDeclarationMirror mirror = __members[memberName];\n\n    if (mirror is JsMethodMirror && !mirror.canInvokeReflectively()) {\n      throwInvalidReflectionError(n(memberName));\n    }\n    if (mirror == null || mirror is JsMethodMirror && mirror.isSetter) {\n      throw new NoSuchStaticMethodError.method(\n          null, memberName, positionalArguments, namedArguments);\n    }\n    if (mirror is JsMethodMirror && !mirror.isGetter) {\n      return reflect(mirror._invoke(positionalArguments, namedArguments));\n    }\n    return getField(memberName)\n        .invoke(#call, positionalArguments, namedArguments);\n  }\n\n  _loadField(String name) {\n    // TODO(ahe): What about lazily initialized fields? See\n    // [JsClassMirror.getField].\n\n    // '$' (JS_CURRENT_ISOLATE()) stores state which is read directly, so we\n    // shouldn't use [_globalObject] here.\n    assert(JS('bool', '# in #', name, JS_CURRENT_ISOLATE()));\n    return JS('', '#[#]', JS_CURRENT_ISOLATE(), name);\n  }\n\n  void _storeField(String name, Object arg) {\n    // '$' (JS_CURRENT_ISOLATE()) stores state which is stored directly, so we\n    // shouldn't use [_globalObject] here.\n    assert(JS('bool', '# in #', name, JS_CURRENT_ISOLATE()));\n    JS('void', '#[#] = #', JS_CURRENT_ISOLATE(), name, arg);\n  }\n\n  List<JsMethodMirror> get _functionMirrors {\n    if (_cachedFunctionMirrors != null) return _cachedFunctionMirrors;\n    var result = new List<JsMethodMirror>();\n    for (int i = 0; i < _functions.length; i++) {\n      String name = _functions[i];\n      var jsFunction = JS('', '#[#]', _globalObject, name);\n      String unmangledName = mangledGlobalNames[name];\n      if (unmangledName == null ||\n          JS('bool', \"!!#['\\$getterStub']\", jsFunction)) {\n        // If there is no unmangledName, [jsFunction] is either a synthetic\n        // implementation detail, or something that is excluded\n        // by @MirrorsUsed.\n        // If it has a getterStub property it is a synthetic stub.\n        // TODO(floitsch): Remove the getterStub hack.\n        continue;\n      }\n      bool isConstructor = unmangledName.startsWith('new ');\n      bool isStatic = !isConstructor; // Top-level functions are static, but\n                                      // constructors are not.\n      if (isConstructor) {\n        unmangledName = unmangledName.substring(4).replaceAll(r'$', '.');\n      }\n      JsMethodMirror mirror =\n          new JsMethodMirror.fromUnmangledName(\n              unmangledName, jsFunction, isStatic, isConstructor);\n      result.add(mirror);\n      mirror._owner = this;\n    }\n    return _cachedFunctionMirrors = result;\n  }\n\n  List<VariableMirror> get _fields {\n    if (_cachedFields != null) return _cachedFields;\n    var result = <VariableMirror>[];\n    parseCompactFieldSpecification(\n        this, _compactFieldSpecification, true, result);\n    return _cachedFields = result;\n  }\n\n  Map<Symbol, MethodMirror> get __functions {\n    if (_cachedFunctions != null) return _cachedFunctions;\n    var result = new Map();\n    for (JsMethodMirror mirror in _functionMirrors) {\n      if (!mirror.isConstructor) result[mirror.simpleName] = mirror;\n    }\n    return _cachedFunctions =\n        new UnmodifiableMapView<Symbol, MethodMirror>(result);\n  }\n\n  Map<Symbol, MethodMirror> get __getters {\n    if (_cachedGetters != null) return _cachedGetters;\n    var result = new Map();\n    // TODO(ahe): Implement this.\n    return _cachedGetters =\n        new UnmodifiableMapView<Symbol, MethodMirror>(result);\n  }\n\n  Map<Symbol, MethodMirror> get __setters {\n    if (_cachedSetters != null) return _cachedSetters;\n    var result = new Map();\n    // TODO(ahe): Implement this.\n    return _cachedSetters =\n        new UnmodifiableMapView<Symbol, MethodMirror>(result);\n  }\n\n  Map<Symbol, VariableMirror> get __variables {\n    if (_cachedVariables != null) return _cachedVariables;\n    var result = new Map();\n    for (JsVariableMirror mirror in _fields) {\n      result[mirror.simpleName] = mirror;\n    }\n    return _cachedVariables =\n        new UnmodifiableMapView<Symbol, VariableMirror>(result);\n  }\n\n  Map<Symbol, Mirror> get __members {\n    if (_cachedMembers !=  null) return _cachedMembers;\n    Map<Symbol, Mirror> result = new Map.from(__classes);\n    addToResult(Symbol key, Mirror value) {\n      result[key] = value;\n    }\n    __functions.forEach(addToResult);\n    __getters.forEach(addToResult);\n    __setters.forEach(addToResult);\n    __variables.forEach(addToResult);\n    return _cachedMembers = new UnmodifiableMapView<Symbol, Mirror>(result);\n  }\n\n  Map<Symbol, DeclarationMirror> get declarations {\n    if (_cachedDeclarations != null) return _cachedDeclarations;\n    var result = new Map<Symbol, DeclarationMirror>();\n    addToResult(Symbol key, Mirror value) {\n      result[key] = value;\n    }\n    __members.forEach(addToResult);\n    return _cachedDeclarations =\n        new UnmodifiableMapView<Symbol, DeclarationMirror>(result);\n  }\n\n  List<InstanceMirror> get metadata {\n    if (_cachedMetadata != null) return _cachedMetadata;\n    preserveMetadata();\n    return _cachedMetadata =\n        new UnmodifiableListView<InstanceMirror>(_metadata.map(reflect));\n  }\n\n  // TODO(ahe): Test this getter.\n  DeclarationMirror get owner => null;\n\n  List<LibraryDependencyMirror> get libraryDependencies\n      => throw new UnimplementedError();\n}\n\nString n(Symbol symbol) => _symbol_dev.Symbol.getName(symbol);\n\nSymbol s(String name) {\n  if (name == null) return null;\n  return new _symbol_dev.Symbol.unvalidated(name);\n}\n\nSymbol setterSymbol(Symbol symbol) => s(\"${n(symbol)}=\");\n\nfinal JsMirrorSystem currentJsMirrorSystem = new JsMirrorSystem();\n\nInstanceMirror reflect(Object reflectee) {\n  if (reflectee is Closure) {\n    return new JsClosureMirror(reflectee);\n  } else {\n    return new JsInstanceMirror(reflectee);\n  }\n}\n\nTypeMirror reflectType(Type key) {\n  return reflectClassByMangledName(getMangledTypeName(key));\n}\n\nTypeMirror reflectClassByMangledName(String mangledName) {\n  String unmangledName = mangledGlobalNames[mangledName];\n  if (mangledName == 'dynamic') return JsMirrorSystem._dynamicType;\n  if (mangledName == 'void') return JsMirrorSystem._voidType;\n  if (unmangledName == null) unmangledName = mangledName;\n  return reflectClassByName(s(unmangledName), mangledName);\n}\n\nvar classMirrors;\n\nTypeMirror reflectClassByName(Symbol symbol, String mangledName) {\n  if (classMirrors == null) classMirrors = JsCache.allocate();\n  var mirror = JsCache.fetch(classMirrors, mangledName);\n  if (mirror != null) return mirror;\n  disableTreeShaking();\n  int typeArgIndex = mangledName.indexOf(\"<\");\n  if (typeArgIndex != -1) {\n    mirror = new JsTypeBoundClassMirror(reflectClassByMangledName(\n        mangledName.substring(0, typeArgIndex)).originalDeclaration,\n        // Remove the angle brackets enclosing the type arguments.\n        mangledName.substring(typeArgIndex + 1, mangledName.length - 1));\n    JsCache.update(classMirrors, mangledName, mirror);\n    return mirror;\n  }\n  var constructor = JS('var', 'init.allClasses[#]', mangledName);\n  if (constructor == null) {\n    // Probably an intercepted class.\n    // TODO(ahe): How to handle intercepted classes?\n    throw new UnsupportedError('Cannot find class for: ${n(symbol)}');\n  }\n  var descriptor = JS('', '#[\"@\"]', constructor);\n  var fields;\n  var fieldsMetadata;\n  if (descriptor == null) {\n    // This is a native class, or an intercepted class.\n    // TODO(ahe): Preserve descriptor for such classes.\n  } else {\n    fields = JS('', '#[#]', descriptor,\n        JS_GET_NAME('CLASS_DESCRIPTOR_PROPERTY'));\n    if (fields is List) {\n      fieldsMetadata = fields.getRange(1, fields.length).toList();\n      fields = fields[0];\n    }\n    if (fields is! String) {\n      // TODO(ahe): This is CSP mode.  Find a way to determine the\n      // fields of this class.\n      fields = '';\n    }\n  }\n\n  if (encoding.isTypedefDescriptor(fields)) {\n    int index = encoding.getTypeFromTypedef(fields);\n    mirror = new JsTypedefMirror(symbol, mangledName, getMetadata(index));\n  } else {\n    var superclassName = fields.split(';')[0];\n    var mixins = superclassName.split('+');\n    if (mixins.length > 1 && mangledGlobalNames[mangledName] == null) {\n      mirror = reflectMixinApplication(mixins, mangledName);\n    } else {\n      ClassMirror classMirror = new JsClassMirror(\n          symbol, mangledName, constructor, fields, fieldsMetadata);\n      List typeVariables =\n          JS('JSExtendableArray|Null', '#.prototype[\"<>\"]', constructor);\n      if (typeVariables == null || typeVariables.length == 0) {\n        mirror = classMirror;\n      } else {\n        String typeArguments = 'dynamic';\n        for (int i = 1; i < typeVariables.length; i++) {\n          typeArguments += ',dynamic';\n        }\n        mirror = new JsTypeBoundClassMirror(classMirror, typeArguments);\n      }\n    }\n  }\n\n  JsCache.update(classMirrors, mangledName, mirror);\n  return mirror;\n}\n\nMap<Symbol, MethodMirror> filterMethods(List<MethodMirror> methods) {\n  var result = new Map();\n  for (JsMethodMirror method in methods) {\n    if (!method.isConstructor && !method.isGetter && !method.isSetter) {\n      result[method.simpleName] = method;\n    }\n  }\n  return result;\n}\n\nMap<Symbol, MethodMirror> filterConstructors(methods) {\n  var result = new Map();\n  for (JsMethodMirror method in methods) {\n    if (method.isConstructor) {\n      result[method.simpleName] = method;\n    }\n  }\n  return result;\n}\n\nMap<Symbol, MethodMirror> filterGetters(List<MethodMirror> methods,\n                                        Map<Symbol, VariableMirror> fields) {\n  var result = new Map();\n  for (JsMethodMirror method in methods) {\n    if (method.isGetter) {\n\n      // TODO(ahe): This is a hack to remove getters corresponding to a field.\n      if (fields[method.simpleName] != null) continue;\n\n      result[method.simpleName] = method;\n    }\n  }\n  return result;\n}\n\nMap<Symbol, MethodMirror> filterSetters(List<MethodMirror> methods,\n                                        Map<Symbol, VariableMirror> fields) {\n  var result = new Map();\n  for (JsMethodMirror method in methods) {\n    if (method.isSetter) {\n\n      // TODO(ahe): This is a hack to remove setters corresponding to a field.\n      String name = n(method.simpleName);\n      name = name.substring(0, name.length - 1); // Remove '='.\n      if (fields[s(name)] != null) continue;\n\n      result[method.simpleName] = method;\n    }\n  }\n  return result;\n}\n\nMap<Symbol, Mirror> filterMembers(List<MethodMirror> methods,\n                                  Map<Symbol, VariableMirror> variables) {\n  Map<Symbol, Mirror> result = new Map.from(variables);\n  for (JsMethodMirror method in methods) {\n    if (method.isSetter) {\n      String name = n(method.simpleName);\n      name = name.substring(0, name.length - 1);\n      // Filter-out setters corresponding to variables.\n      if (result[s(name)] is VariableMirror) continue;\n    }\n    // Constructors aren't 'members'.\n    if (method.isConstructor) continue;\n    // Use putIfAbsent to filter-out getters corresponding to variables.\n    result.putIfAbsent(method.simpleName, () => method);\n  }\n  return result;\n}\n\nint counter = 0;\n\nClassMirror reflectMixinApplication(mixinNames, String mangledName) {\n  disableTreeShaking();\n  var mixins = [];\n  for (String mangledName in mixinNames) {\n    mixins.add(reflectClassByMangledName(mangledName));\n  }\n  var it = mixins.iterator;\n  it.moveNext();\n  var superclass = it.current;\n  while (it.moveNext()) {\n    superclass = new JsMixinApplication(superclass, it.current, mangledName);\n  }\n  return superclass;\n}\n\nclass JsMixinApplication extends JsTypeMirror with JsObjectMirror\n    implements ClassMirror {\n  final ClassMirror superclass;\n  final ClassMirror mixin;\n  Symbol _cachedSimpleName;\n  Map<Symbol, MethodMirror> _cachedInstanceMembers;\n\n  JsMixinApplication(ClassMirror superclass, ClassMirror mixin,\n                     String mangledName)\n      : this.superclass = superclass,\n        this.mixin = mixin,\n        super(s(mangledName));\n\n  String get _prettyName => 'ClassMirror';\n\n  Symbol get simpleName {\n    if (_cachedSimpleName != null) return _cachedSimpleName;\n    String superName = n(superclass.qualifiedName);\n    return _cachedSimpleName = (superName.contains(' with '))\n        ? s('$superName, ${n(mixin.qualifiedName)}')\n        : s('$superName with ${n(mixin.qualifiedName)}');\n  }\n\n  Symbol get qualifiedName => simpleName;\n\n  // TODO(ahe): Remove this method, only here to silence warning.\n  get _mixin => mixin;\n\n  Map<Symbol, Mirror> get __members => _mixin.__members;\n\n  Map<Symbol, MethodMirror> get __methods => _mixin.__methods;\n\n  Map<Symbol, MethodMirror> get __getters => _mixin.__getters;\n\n  Map<Symbol, MethodMirror> get __setters => _mixin.__setters;\n\n  Map<Symbol, VariableMirror> get __variables => _mixin.__variables;\n\n  Map<Symbol, DeclarationMirror> get declarations => mixin.declarations;\n\n  Map<Symbol, MethodMirror> get instanceMembers {\n    if (_cachedInstanceMembers == null) {\n      var result = new Map<Symbol, MethodMirror>();\n      if (superclass != null) {\n        result.addAll(superclass.instanceMembers);\n      }\n      result.addAll(mixin.instanceMembers);\n      _cachedInstanceMembers = result;\n    }\n    return _cachedInstanceMembers;\n  }\n\n  Map<Symbol, MethodMirror> get staticMembers => mixin.staticMembers;\n\n  _asRuntimeType() => null;\n\n  InstanceMirror invoke(\n      Symbol memberName,\n      List positionalArguments,\n      [Map<Symbol,dynamic> namedArguments]) {\n    throw new NoSuchStaticMethodError.method(\n        null, memberName, positionalArguments, namedArguments);\n  }\n\n  InstanceMirror getField(Symbol fieldName) {\n    throw new NoSuchStaticMethodError.method(null, fieldName, null, null);\n  }\n\n  InstanceMirror setField(Symbol fieldName, Object arg) {\n    throw new NoSuchStaticMethodError.method(\n        null, setterSymbol(fieldName), [arg], null);\n  }\n\n  List<ClassMirror> get superinterfaces => [mixin];\n\n  Map<Symbol, MethodMirror> get __constructors => _mixin.__constructors;\n\n  InstanceMirror newInstance(\n      Symbol constructorName,\n      List positionalArguments,\n      [Map<Symbol,dynamic> namedArguments]) {\n    throw new UnsupportedError(\n        \"Can't instantiate mixin application '${n(qualifiedName)}'\");\n  }\n\n  bool get isOriginalDeclaration => true;\n\n  ClassMirror get originalDeclaration => this;\n\n  // TODO(ahe): Implement this.\n  List<TypeVariableMirror> get typeVariables {\n    throw new UnimplementedError();\n  }\n\n  List<TypeMirror> get typeArguments => const <TypeMirror>[];\n\n  bool get isAbstract => throw new UnimplementedError();\n\n  bool isSubclassOf(ClassMirror other) {\n    superclass.isSubclassOf(other) || mixin.isSubclassOf(other);\n  }\n\n  bool isSubtypeOf(TypeMirror other) => throw new UnimplementedError();\n\n  bool isAssignableTo(TypeMirror other) => throw new UnimplementedError();\n}\n\nabstract class JsObjectMirror implements ObjectMirror {\n}\n\nclass JsInstanceMirror extends JsObjectMirror implements InstanceMirror {\n  final reflectee;\n\n  JsInstanceMirror(this.reflectee);\n\n  bool get hasReflectee => true;\n\n  ClassMirror get type {\n    // The spec guarantees that `null` is the singleton instance of the `Null`\n    // class.\n    if (reflectee == null) return reflectClass(Null);\n    return reflectType(getRuntimeType(reflectee));\n  }\n\n  InstanceMirror invoke(Symbol memberName,\n                        List positionalArguments,\n                        [Map<Symbol,dynamic> namedArguments]) {\n    if (namedArguments == null) namedArguments = const {};\n    // We can safely pass positionalArguments to _invoke as it will wrap it in\n    // a JSArray if needed.\n    return _invoke(memberName, JSInvocationMirror.METHOD,\n                   positionalArguments, namedArguments);\n  }\n\n  InstanceMirror _invokeMethodWithNamedArguments(\n      String reflectiveName,\n      List positionalArguments, Map<Symbol,dynamic> namedArguments) {\n    assert(namedArguments.isNotEmpty);\n    var interceptor = getInterceptor(reflectee);\n\n    var jsFunction = JS('', '#[#]', interceptor, reflectiveName);\n    if (jsFunction == null) {\n      // TODO(ahe): Invoke noSuchMethod.\n      throw new UnimplementedNoSuchMethodError(\n          'Invoking noSuchMethod with named arguments not implemented');\n    }\n    ReflectionInfo info = new ReflectionInfo(jsFunction);\n    if (jsFunction == null) {\n      // TODO(ahe): Invoke noSuchMethod.\n      throw new UnimplementedNoSuchMethodError(\n          'Invoking noSuchMethod with named arguments not implemented');\n    }\n\n    positionalArguments = new List.from(positionalArguments);\n    // Check the number of positional arguments is valid.\n    if (info.requiredParameterCount != positionalArguments.length) {\n      // TODO(ahe): Invoke noSuchMethod.\n      throw new UnimplementedNoSuchMethodError(\n          'Invoking noSuchMethod with named arguments not implemented');\n    }\n    var defaultArguments = new Map();\n    for (int i = 0; i < info.optionalParameterCount; i++) {\n      var parameterName = info.parameterName(i + info.requiredParameterCount);\n      var defaultValue =\n          getMetadata(info.defaultValue(i + info.requiredParameterCount));\n      defaultArguments[parameterName] = defaultValue;\n    }\n    namedArguments.forEach((Symbol symbol, value) {\n      String parameter = n(symbol);\n      if (defaultArguments.containsKey(parameter)) {\n        defaultArguments[parameter] = value;\n      } else {\n        // Extraneous named argument.\n        // TODO(ahe): Invoke noSuchMethod.\n        throw new UnimplementedNoSuchMethodError(\n            'Invoking noSuchMethod with named arguments not implemented');\n      }\n    });\n    positionalArguments.addAll(defaultArguments.values);\n    // TODO(ahe): Handle intercepted methods.\n    return reflect(\n        JS('', '#.apply(#, #)', jsFunction, reflectee, positionalArguments));\n  }\n\n  /// Grabs hold of the class-specific invocation cache for the reflectee.\n  /// All reflectees with the same class share the same cache. The cache\n  /// maps reflective names to cached invocation objects with enough decoded\n  /// reflective information to know how to to invoke a specific member.\n  get _classInvocationCache {\n    String cacheName = Primitives.mirrorInvokeCacheName;\n    var cacheHolder = (reflectee == null) ? getInterceptor(null) : reflectee;\n    var cache = JS('', r'#.constructor[#]', cacheHolder, cacheName);\n    if (cache == null) {\n      cache = JsCache.allocate();\n      JS('void', r'#.constructor[#] = #', cacheHolder, cacheName, cache);\n    }\n    return cache;\n  }\n\n  String _computeReflectiveName(Symbol symbolName, int type,\n                                List positionalArguments,\n                                Map<Symbol, dynamic> namedArguments) {\n    String name = n(symbolName);\n    switch (type) {\n      case JSInvocationMirror.GETTER: return name;\n      case JSInvocationMirror.SETTER: return '$name=';\n      case JSInvocationMirror.METHOD:\n        if (namedArguments.isNotEmpty) return '$name*';\n        int nbArgs = positionalArguments.length as int;\n        return \"$name:$nbArgs:0\";\n    }\n    throw new RuntimeError(\"Could not compute reflective name for $name\");\n  }\n\n  /**\n   * Returns a `CachedInvocation` or `CachedNoSuchMethodInvocation` for the\n   * given member.\n   *\n   * Caches the result.\n   */\n  _getCachedInvocation(Symbol name, int type, String reflectiveName,\n      List positionalArguments, Map<Symbol,dynamic> namedArguments) {\n\n    var cache = _classInvocationCache;\n    var cacheEntry = JsCache.fetch(cache, reflectiveName);\n    var result;\n    if (cacheEntry == null) {\n      disableTreeShaking();\n      String mangledName = reflectiveNames[reflectiveName];\n      List<String> argumentNames = const [];\n\n      // TODO(ahe): We don't need to create an invocation mirror here. The\n      // logic from JSInvocationMirror.getCachedInvocation could easily be\n      // inlined here.\n      Invocation invocation = createUnmangledInvocationMirror(\n          name, mangledName, type, positionalArguments, argumentNames);\n\n      cacheEntry =\n          JSInvocationMirror.getCachedInvocation(invocation, reflectee);\n      JsCache.update(cache, reflectiveName, cacheEntry);\n    }\n    return cacheEntry;\n  }\n\n  bool _isReflectable(CachedInvocation cachedInvocation) {\n    // TODO(floitsch): tear-off closure does not guarantee that the\n    // function is reflectable.\n    var method = cachedInvocation.jsFunction;\n    return hasReflectableProperty(method) || reflectee is TearOffClosure;\n  }\n\n  /// Invoke the member specified through name and type on the reflectee.\n  /// As a side-effect, this populates the class-specific invocation cache\n  /// for the reflectee.\n  InstanceMirror _invoke(Symbol name,\n                         int type,\n                         List positionalArguments,\n                         Map<Symbol,dynamic> namedArguments) {\n    String reflectiveName =\n        _computeReflectiveName(name, type, positionalArguments, namedArguments);\n\n    if (namedArguments.isNotEmpty) {\n      // TODO(floitsch): first, make sure it's not a getter.\n      return _invokeMethodWithNamedArguments(\n          reflectiveName, positionalArguments, namedArguments);\n    }\n    var cacheEntry = _getCachedInvocation(\n        name, type, reflectiveName, positionalArguments, namedArguments);\n\n    if (cacheEntry.isNoSuchMethod || !_isReflectable(cacheEntry)) {\n      // Could be that we want to invoke a getter, or get a method.\n      if (type == JSInvocationMirror.METHOD && _instanceFieldExists(name)) {\n        return getField(name).invoke(\n            #call, positionalArguments, namedArguments);\n      }\n\n      if (type == JSInvocationMirror.SETTER) {\n        // For setters we report the setter name \"field=\".\n        name = s(\"${n(name)}=\");\n      }\n\n      if (!cacheEntry.isNoSuchMethod) {\n        // Not reflectable.\n        throwInvalidReflectionError(reflectiveName);\n      }\n\n      String mangledName = reflectiveNames[reflectiveName];\n      // TODO(ahe): Get the argument names.\n      List<String> argumentNames = [];\n      Invocation invocation = createUnmangledInvocationMirror(\n          name, mangledName, type, positionalArguments, argumentNames);\n      return reflect(cacheEntry.invokeOn(reflectee, invocation));\n    } else {\n      return reflect(cacheEntry.invokeOn(reflectee, positionalArguments));\n    }\n  }\n\n  InstanceMirror setField(Symbol fieldName, Object arg) {\n    _invoke(fieldName, JSInvocationMirror.SETTER, [arg], const {});\n    return reflect(arg);\n  }\n\n  // JS helpers for getField optimizations.\n  static bool isUndefined(x)\n      => JS('bool', 'typeof # == \"undefined\"', x);\n  static bool isMissingCache(x)\n      => JS('bool', 'typeof # == \"number\"', x);\n  static bool isMissingProbe(Symbol symbol)\n      => JS('bool', 'typeof #.\\$p == \"undefined\"', symbol);\n  static bool isEvalAllowed()\n      => JS('bool', 'typeof dart_precompiled != \"function\"');\n\n\n  /// The getter cache is lazily allocated after a couple\n  /// of invocations of [InstanceMirror.getField]. The delay is\n  /// used to avoid too aggressive caching and dynamic function\n  /// generation for rarely used mirrors. The cache is specific to\n  /// this [InstanceMirror] and maps reflective names to functions\n  /// that will invoke the corresponding getter on the reflectee.\n  /// The reflectee is passed to the function as the first argument\n  /// to avoid the overhead of fetching it from this mirror repeatedly.\n  /// The cache is lazily initialized to a JS object so we can\n  /// benefit from \"map transitions\" in the underlying JavaScript\n  /// engine to speed up cache probing.\n  var _getterCache = 4;\n\n  bool _instanceFieldExists(Symbol name) {\n    int getterType = JSInvocationMirror.GETTER;\n    String getterName =\n        _computeReflectiveName(name, getterType, const [], const {});\n    var getterCacheEntry = _getCachedInvocation(\n        name, getterType, getterName, const [], const {});\n    return !getterCacheEntry.isNoSuchMethod && !getterCacheEntry.isGetterStub;\n  }\n\n  InstanceMirror getField(Symbol fieldName) {\n    FASTPATH: {\n      var cache = _getterCache;\n      if (isMissingCache(cache) || isMissingProbe(fieldName)) break FASTPATH;\n      // If the [fieldName] has an associated probe function, we can use\n      // it to read from the getter cache specific to this [InstanceMirror].\n      var getter = JS('', '#.\\$p(#)', fieldName, cache);\n      if (isUndefined(getter)) break FASTPATH;\n      // Call the getter passing the reflectee as the first argument.\n      var value = JS('', '#(#)', getter, reflectee);\n      // The getter has an associate cache of the last [InstanceMirror]\n      // returned to avoid repeated invocations of [reflect]. To validate\n      // the cache, we check that the value returned by the getter is the\n      // same value as last time.\n      if (JS('bool', '# === #.v', value, getter)) {\n        return JS('InstanceMirror', '#.m', getter);\n      } else {\n        var result = reflect(value);\n        JS('void', '#.v = #', getter, value);\n        JS('void', '#.m = #', getter, result);\n        return result;\n      }\n    }\n    return _getFieldSlow(fieldName);\n  }\n\n  InstanceMirror _getFieldSlow(Symbol fieldName) {\n    // First do the slow-case getter invocation. As a side-effect of this,\n    // the invocation cache is filled in so we can query it afterwards.\n    var result =\n        _invoke(fieldName, JSInvocationMirror.GETTER, const [], const {});\n    String name = n(fieldName);\n    var cacheEntry = JsCache.fetch(_classInvocationCache, name);\n    if (cacheEntry.isNoSuchMethod) {\n      return result;\n    }\n\n    // Make sure we have a getter cache in this [InstanceMirror].\n    var cache = _getterCache;\n    if (isMissingCache(cache)) {\n      if ((_getterCache = --cache) != 0) return result;\n      cache = _getterCache = JS('=Object', 'Object.create(null)');\n    }\n\n    // Make sure that symbol [fieldName] has a cache probing function ($p).\n    bool useEval = isEvalAllowed();\n    if (isMissingProbe(fieldName)) {\n      var probe = _newProbeFn(name, useEval);\n      JS('void', '#.\\$p = #', fieldName, probe);\n    }\n\n    // Create a new getter function and install it in the cache.\n    var mangledName = cacheEntry.mangledName;\n    var getter = (cacheEntry.isIntercepted)\n        ? _newInterceptedGetterFn(mangledName, useEval)\n        : _newGetterFn(mangledName, useEval);\n    JS('void', '#[#] = #', cache, name, getter);\n\n    // Initialize the last value (v) and last mirror (m) on the\n    // newly generated getter to be a sentinel value that is hard\n    // to get hold of through user code.\n    JS('void', '#.v = #.m = #', getter, getter, cache);\n\n    // Return the result of the slow-path getter invocation.\n    return result;\n  }\n\n  _newProbeFn(String id, bool useEval) {\n    if (useEval) {\n      // We give the probe function a name to make it appear nicely in\n      // profiles and when debugging. The name also makes the source code\n      // for the function more \"unique\" so the underlying JavaScript\n      // engine is less likely to re-use an existing piece of generated\n      // code as the result of calling eval. In return, this leads to\n      // less polymorphic access in the probe function.\n      var body = \"(function probe\\$$id(c){return c.$id})\";\n      return JS('', '(function(b){return eval(b)})(#)', body);\n    } else {\n      return JS('', '(function(n){return(function(c){return c[n]})})(#)', id);\n    }\n  }\n\n  _newGetterFn(String name, bool useEval) {\n    if (!useEval) return _newGetterNoEvalFn(name);\n    // We give the getter function a name that associates it with the\n    // class of the reflectee. This makes it easier to spot in profiles\n    // and when debugging, but it also means that the underlying JavaScript\n    // engine will only share the generated code for accessors on the\n    // same class (through caching of eval'ed code). This makes the\n    // generated call to the getter - e.g. o.get$foo() - much more likely\n    // to be monomorphic and inlineable.\n    String className = JS('String', '#.constructor.name', reflectee);\n    var body = \"(function $className\\$$name(o){return o.$name()})\";\n    return JS('', '(function(b){return eval(b)})(#)', body);\n  }\n\n  _newGetterNoEvalFn(n) => JS('',\n      '(function(n){return(function(o){return o[n]()})})(#)', n);\n\n  _newInterceptedGetterFn(String name, bool useEval) {\n    var object = reflectee;\n    // It is possible that the interceptor for a given object is the object\n    // itself, so it is important not to share the code that captures the\n    // interceptor between multiple different instances of [InstanceMirror].\n    var interceptor = getInterceptor(object);\n    if (!useEval) return _newInterceptGetterNoEvalFn(name, interceptor);\n    String className = JS('String', '#.constructor.name', interceptor);\n    String functionName = '$className\\$$name';\n    var body =\n        '(function(i) {'\n        '  function $functionName(o){return i.$name(o)}'\n        '  return $functionName;'\n        '})';\n    return JS('', '(function(b){return eval(b)})(#)(#)', body, interceptor);\n  }\n\n  _newInterceptGetterNoEvalFn(n, i) => JS('',\n      '(function(n,i){return(function(o){return i[n](o)})})(#,#)', n, i);\n\n  delegate(Invocation invocation) {\n    return JSInvocationMirror.invokeFromMirror(invocation, reflectee);\n  }\n\n  operator ==(other) {\n    return other is JsInstanceMirror &&\n           identical(reflectee, other.reflectee);\n  }\n\n  int get hashCode {\n    // Avoid hash collisions with the reflectee. This constant is in Smi range\n    // and happens to be the inner padding from RFC 2104.\n    return identityHashCode(reflectee) ^ 0x36363636;\n  }\n\n  String toString() => 'InstanceMirror on ${Error.safeToString(reflectee)}';\n\n  // TODO(ahe): Remove this method from the API.\n  MirrorSystem get mirrors => currentJsMirrorSystem;\n}\n\n/**\n * ClassMirror for generic classes where the type parameters are bound.\n *\n * [typeArguments] will return a list of the type arguments, in constrast\n * to JsCLassMirror that returns an empty list since it represents original\n * declarations and classes that are not generic.\n */\nclass JsTypeBoundClassMirror extends JsDeclarationMirror\n    implements ClassMirror {\n  final JsClassMirror _class;\n\n  /**\n   * When instantiated this field will hold a string representing the list of\n   * type arguments for the class, i.e. what is inside the outermost angle\n   * brackets. Then, when get typeArguments is called the first time, the string\n   * is parsed into the actual list of TypeMirrors, and stored in\n   * [_cachedTypeArguments]. Due to type substitution of, for instance,\n   * superclasses the mangled name of the class and hence this string is needed\n   * after [_cachedTypeArguments] has been computed.\n   *\n   * If an integer is encountered as a type argument, it represents the type\n   * variable at the corresponding entry in [emitter.globalMetadata].\n   */\n  String _typeArguments;\n\n  UnmodifiableListView<TypeMirror> _cachedTypeArguments;\n  UnmodifiableMapView<Symbol, DeclarationMirror> _cachedDeclarations;\n  UnmodifiableMapView<Symbol, DeclarationMirror> _cachedMembers;\n  UnmodifiableMapView<Symbol, MethodMirror> _cachedConstructors;\n  Map<Symbol, VariableMirror> _cachedVariables;\n  Map<Symbol, MethodMirror> _cachedGetters;\n  Map<Symbol, MethodMirror> _cachedSetters;\n  Map<Symbol, MethodMirror> _cachedMethodsMap;\n  List<JsMethodMirror> _cachedMethods;\n  ClassMirror _superclass;\n  List<ClassMirror> _cachedSuperinterfaces;\n  Map<Symbol, MethodMirror> _cachedInstanceMembers;\n  Map<Symbol, MethodMirror> _cachedStaticMembers;\n\n  JsTypeBoundClassMirror(JsClassMirror originalDeclaration, this._typeArguments)\n      : _class = originalDeclaration,\n        super(originalDeclaration.simpleName);\n\n  String get _prettyName => 'ClassMirror';\n\n  String toString() {\n    String result = '$_prettyName on ${n(simpleName)}';\n    if (typeArguments != null) {\n      result = \"$result<${typeArguments.join(', ')}>\";\n    }\n    return result;\n  }\n\n  String get _mangledName {\n    for (TypeMirror typeArgument in typeArguments) {\n      if (typeArgument != JsMirrorSystem._dynamicType) {\n        return '${_class._mangledName}<$_typeArguments>';\n      }\n    }\n    // When all type arguments are dynamic, the canonical representation is to\n    // drop them.\n    return _class._mangledName;\n  }\n\n  List<TypeVariableMirror> get typeVariables => _class.typeVariables;\n\n  List<TypeMirror> get typeArguments {\n    if (_cachedTypeArguments != null) return _cachedTypeArguments;\n    List result = new List();\n\n    addTypeArgument(String typeArgument) {\n      int parsedIndex = int.parse(typeArgument, onError: (_) => -1);\n      if (parsedIndex == -1) {\n        result.add(reflectClassByMangledName(typeArgument.trim()));\n      } else {\n        TypeVariable typeVariable = getMetadata(parsedIndex);\n        TypeMirror owner = reflectClass(typeVariable.owner);\n        TypeVariableMirror typeMirror =\n            new JsTypeVariableMirror(typeVariable, owner, parsedIndex);\n        result.add(typeMirror);\n      }\n    }\n\n    if (_typeArguments.indexOf('<') == -1) {\n      _typeArguments.split(',').forEach((t) => addTypeArgument(t));\n    } else {\n      int level = 0;\n      String currentTypeArgument = '';\n\n      for (int i = 0; i < _typeArguments.length; i++) {\n        var character = _typeArguments[i];\n        if (character == ' ') {\n          continue;\n        } else if (character == '<') {\n          currentTypeArgument += character;\n          level++;\n        } else if (character == '>') {\n          currentTypeArgument += character;\n          level--;\n        } else if (character == ',') {\n          if (level > 0) {\n            currentTypeArgument += character;\n          } else {\n            addTypeArgument(currentTypeArgument);\n            currentTypeArgument = '';\n          }\n        } else {\n          currentTypeArgument += character;\n        }\n      }\n      addTypeArgument(currentTypeArgument);\n    }\n    return _cachedTypeArguments = new UnmodifiableListView(result);\n  }\n\n  List<JsMethodMirror> get _methods {\n    if (_cachedMethods != null) return _cachedMethods;\n    return _cachedMethods =_class._getMethodsWithOwner(this);\n  }\n\n  Map<Symbol, MethodMirror> get __methods {\n    if (_cachedMethodsMap != null) return _cachedMethodsMap;\n    return _cachedMethodsMap = new UnmodifiableMapView<Symbol, MethodMirror>(\n        filterMethods(_methods));\n  }\n\n  Map<Symbol, MethodMirror> get __constructors {\n    if (_cachedConstructors != null) return _cachedConstructors;\n    return _cachedConstructors =\n        new UnmodifiableMapView<Symbol, MethodMirror>(\n            filterConstructors(_methods));\n  }\n\n  Map<Symbol, MethodMirror> get __getters {\n    if (_cachedGetters != null) return _cachedGetters;\n    return _cachedGetters = new UnmodifiableMapView<Symbol, MethodMirror>(\n        filterGetters(_methods, __variables));\n  }\n\n  Map<Symbol, MethodMirror> get __setters {\n    if (_cachedSetters != null) return _cachedSetters;\n    return _cachedSetters = new UnmodifiableMapView<Symbol, MethodMirror>(\n        filterSetters(_methods, __variables));\n  }\n\n  Map<Symbol, VariableMirror> get __variables {\n    if (_cachedVariables != null) return _cachedVariables;\n    var result = new Map();\n    for (JsVariableMirror mirror in  _class._getFieldsWithOwner(this)) {\n      result[mirror.simpleName] = mirror;\n    }\n    return _cachedVariables =\n        new UnmodifiableMapView<Symbol, VariableMirror>(result);\n  }\n\n  Map<Symbol, DeclarationMirror> get __members {\n    if (_cachedMembers != null) return _cachedMembers;\n    return _cachedMembers = new UnmodifiableMapView<Symbol, DeclarationMirror>(\n        filterMembers(_methods, __variables));\n  }\n\n  Map<Symbol, DeclarationMirror> get declarations {\n    if (_cachedDeclarations != null) return _cachedDeclarations;\n    Map<Symbol, DeclarationMirror> result =\n        new Map<Symbol, DeclarationMirror>();\n    result.addAll(__members);\n    result.addAll(__constructors);\n    typeVariables.forEach((tv) => result[tv.simpleName] = tv);\n    return _cachedDeclarations =\n        new UnmodifiableMapView<Symbol, DeclarationMirror>(result);\n  }\n\n  Map<Symbol, MethodMirror> get staticMembers {\n    if (_cachedStaticMembers == null) {\n      var result = new Map<Symbol, MethodMirror>();\n      declarations.values.forEach((decl) {\n        if (decl is MethodMirror && decl.isStatic && !decl.isConstructor) {\n          result[decl.simpleName] = decl;\n        }\n        if (decl is VariableMirror && decl.isStatic) {\n          var getterName = decl.simpleName;\n          result[getterName] = new JsSyntheticAccessor(\n              this, getterName, true, true, false, decl);\n          if (!decl.isFinal) {\n            var setterName = setterSymbol(decl.simpleName);\n            result[setterName] = new JsSyntheticAccessor(\n                this, setterName, false, true, false, decl);\n          }\n        }\n      });\n      _cachedStaticMembers = result;\n    }\n    return _cachedStaticMembers;\n  }\n\n  Map<Symbol, MethodMirror> get instanceMembers {\n    if (_cachedInstanceMembers == null) {\n      var result = new Map<Symbol, MethodMirror>();\n      if (superclass != null) {\n        result.addAll(superclass.instanceMembers);\n      }\n      declarations.values.forEach((decl) {\n        if (decl is MethodMirror && !decl.isStatic &&\n            !decl.isConstructor && !decl.isAbstract) {\n          result[decl.simpleName] = decl;\n        }\n        if (decl is VariableMirror && !decl.isStatic) {\n          var getterName = decl.simpleName;\n          result[getterName] = new JsSyntheticAccessor(\n              this, getterName, true, false, false, decl);\n          if (!decl.isFinal) {\n            var setterName = setterSymbol(decl.simpleName);\n            result[setterName] = new JsSyntheticAccessor(\n                this, setterName, false, false, false, decl);\n          }\n        }\n      });\n      _cachedInstanceMembers = result;\n    }\n    return _cachedInstanceMembers;\n  }\n\n  InstanceMirror setField(Symbol fieldName, Object arg) {\n    return _class.setField(fieldName, arg);\n  }\n\n  InstanceMirror getField(Symbol fieldName) => _class.getField(fieldName);\n\n  InstanceMirror newInstance(Symbol constructorName,\n                             List positionalArguments,\n                             [Map<Symbol, dynamic> namedArguments]) {\n    var instance = _class._getInvokedInstance(constructorName,\n                                              positionalArguments,\n                                              namedArguments);\n    return reflect(setRuntimeTypeInfo(\n        instance, typeArguments.map((t) => t._asRuntimeType()).toList()));\n  }\n\n  _asRuntimeType() {\n    return [_class._jsConstructor].addAll(\n        typeArguments.map((t) => t._asRuntimeType()));\n  }\n\n  JsLibraryMirror get owner => _class.owner;\n\n  List<InstanceMirror> get metadata => _class.metadata;\n\n  ClassMirror get superclass {\n    if (_superclass != null) return _superclass;\n\n    List<int> typeInformation =\n        JS('List|Null', 'init.typeInformation[#]', _class._mangledName);\n    assert(typeInformation != null);\n    var type = getMetadata(typeInformation[0]);\n    return _superclass = typeMirrorFromRuntimeTypeRepresentation(this, type);\n  }\n\n  InstanceMirror invoke(Symbol memberName,\n                        List positionalArguments,\n                        [Map<Symbol,dynamic> namedArguments]) {\n    return _class.invoke(memberName, positionalArguments, namedArguments);\n  }\n\n  bool get isOriginalDeclaration => false;\n\n  ClassMirror get originalDeclaration => _class;\n\n  List<ClassMirror> get superinterfaces {\n    if (_cachedSuperinterfaces != null) return _cachedSuperinterfaces;\n    return _cachedSuperinterfaces = _class._getSuperinterfacesWithOwner(this);\n  }\n\n  bool get isPrivate => _class.isPrivate;\n\n  bool get isTopLevel => _class.isTopLevel;\n\n  bool get isAbstract => _class.isAbstract;\n\n  bool isSubclassOf(ClassMirror other) => _class.isSubclassOf(other);\n\n  SourceLocation get location => _class.location;\n\n  MirrorSystem get mirrors => _class.mirrors;\n\n  Symbol get qualifiedName => _class.qualifiedName;\n\n  bool get hasReflectedType => true;\n\n  Type get reflectedType => createRuntimeType(_mangledName);\n\n  Symbol get simpleName => _class.simpleName;\n\n  // TODO(ahe): Implement this.\n  ClassMirror get mixin => throw new UnimplementedError();\n\n  bool isSubtypeOf(TypeMirror other) => throw new UnimplementedError();\n\n  bool isAssignableTo(TypeMirror other) => throw new UnimplementedError();\n}\n\nclass JsSyntheticAccessor implements MethodMirror {\n  final DeclarationMirror owner;\n  final Symbol simpleName;\n  final bool isGetter;\n  final bool isStatic;\n  final bool isTopLevel;\n  final _target;  /// The field or type that introduces the synthetic accessor.\n\n  JsSyntheticAccessor(this.owner,\n                      this.simpleName,\n                      this.isGetter,\n                      this.isStatic,\n                      this.isTopLevel,\n                      this._target);\n\n  bool get isSynthetic => true;\n  bool get isRegularMethod => false;\n  bool get isOperator => false;\n  bool get isConstructor => false;\n  bool get isConstConstructor => false;\n  bool get isGenerativeConstructor => false;\n  bool get isFactoryConstructor => false;\n  bool get isRedirectingConstructor => false;\n  bool get isAbstract => false;\n\n  bool get isSetter => !isGetter;\n  bool get isPrivate => n(simpleName).startsWith('_');\n\n  Symbol get qualifiedName => computeQualifiedName(owner, simpleName);\n  Symbol get constructorName => const Symbol('');\n\n  TypeMirror get returnType => _target.type;\n  List<ParameterMirror> get parameters {\n    if (isGetter) return const [];\n    return new UnmodifiableListView(\n        [new JsSyntheticSetterParameter(this, this._target)]);\n  }\n\n  List<InstanceMirror> get metadata => const [];\n  String get source => null;\n  SourceLocation get location => throw new UnimplementedError();\n}\n\nclass JsSyntheticSetterParameter implements ParameterMirror {\n  final DeclarationMirror owner;\n  final VariableMirror _target;\n\n  JsSyntheticSetterParameter(this.owner, this._target);\n\n  Symbol get simpleName => _target.simpleName;\n  Symbol get qualifiedName => computeQualifiedName(owner, simpleName);\n  TypeMirror get type => _target.type;\n\n  bool get isOptional => false;\n  bool get isNamed => false;\n  bool get isStatic => false;\n  bool get isTopLevel => false;\n  bool get isConst => false;\n  bool get isFinal => true;\n  bool get isPrivate => false;\n  bool get hasDefaultValue => false;\n  InstanceMirror get defaultValue => null;\n  List<InstanceMirror> get metadata => const [];\n  SourceLocation get location => throw new UnimplementedError();\n}\n\nclass JsClassMirror extends JsTypeMirror with JsObjectMirror\n    implements ClassMirror {\n  final String _mangledName;\n  final _jsConstructor;\n  final String _fieldsDescriptor;\n  final List _fieldsMetadata;\n  final _jsConstructorCache = JsCache.allocate();\n  List _metadata;\n  ClassMirror _superclass;\n  List<JsMethodMirror> _cachedMethods;\n  List<VariableMirror> _cachedFields;\n  UnmodifiableMapView<Symbol, MethodMirror> _cachedConstructors;\n  UnmodifiableMapView<Symbol, MethodMirror> _cachedMethodsMap;\n  UnmodifiableMapView<Symbol, MethodMirror> _cachedGetters;\n  UnmodifiableMapView<Symbol, MethodMirror> _cachedSetters;\n  UnmodifiableMapView<Symbol, VariableMirror> _cachedVariables;\n  UnmodifiableMapView<Symbol, Mirror> _cachedMembers;\n  UnmodifiableMapView<Symbol, DeclarationMirror> _cachedDeclarations;\n  UnmodifiableListView<InstanceMirror> _cachedMetadata;\n  UnmodifiableListView<ClassMirror> _cachedSuperinterfaces;\n  UnmodifiableListView<TypeVariableMirror> _cachedTypeVariables;\n  Map<Symbol, MethodMirror> _cachedInstanceMembers;\n  Map<Symbol, MethodMirror> _cachedStaticMembers;\n\n  // Set as side-effect of accessing JsLibraryMirror.classes.\n  JsLibraryMirror _owner;\n\n  JsClassMirror(Symbol simpleName,\n                this._mangledName,\n                this._jsConstructor,\n                this._fieldsDescriptor,\n                this._fieldsMetadata)\n      : super(simpleName);\n\n  String get _prettyName => 'ClassMirror';\n\n  Map<Symbol, MethodMirror> get __constructors {\n    if (_cachedConstructors != null) return _cachedConstructors;\n    return _cachedConstructors =\n        new UnmodifiableMapView<Symbol, MethodMirror>(\n            filterConstructors(_methods));\n  }\n\n  _asRuntimeType() {\n    if (typeVariables.isEmpty)  return _jsConstructor;\n    var type = [_jsConstructor];\n    for (int i = 0; i < typeVariables.length; i ++) {\n      type.add(JsMirrorSystem._dynamicType._asRuntimeType);\n    }\n    return type;\n  }\n\n  List<JsMethodMirror> _getMethodsWithOwner(DeclarationMirror methodOwner) {\n    var prototype = JS('', '#.prototype', _jsConstructor);\n    List<String> keys = extractKeys(prototype);\n    var result = <JsMethodMirror>[];\n    for (String key in keys) {\n      if (isReflectiveDataInPrototype(key)) continue;\n      String simpleName = mangledNames[key];\n      // [simpleName] can be null if [key] represents an implementation\n      // detail, for example, a bailout method, or runtime type support.\n      // It might also be null if the user has limited what is reified for\n      // reflection with metadata.\n      if (simpleName == null) continue;\n      var function = JS('', '#[#]', prototype, key);\n      if (isNoSuchMethodStub(function)) continue;\n      var mirror =\n          new JsMethodMirror.fromUnmangledName(\n              simpleName, function, false, false);\n      result.add(mirror);\n      mirror._owner = methodOwner;\n    }\n\n    keys = extractKeys(JS('', 'init.statics[#]', _mangledName));\n    for (String mangledName in keys) {\n      if (isReflectiveDataInPrototype(mangledName)) continue;\n      String unmangledName = mangledName;\n      var jsFunction = JS('', '#[#]', owner._globalObject, mangledName);\n\n      bool isConstructor = false;\n      if (hasReflectableProperty(jsFunction)) {\n        String reflectionName =\n            JS('String|Null', r'#.$reflectionName', jsFunction);\n        if (reflectionName == null) continue;\n        isConstructor = reflectionName.startsWith('new ');\n        if (isConstructor) {\n          reflectionName = reflectionName.substring(4).replaceAll(r'$', '.');\n        }\n        unmangledName = reflectionName;\n      } else {\n        continue;\n      }\n      bool isStatic = !isConstructor; // Constructors are not static.\n      JsMethodMirror mirror =\n          new JsMethodMirror.fromUnmangledName(\n              unmangledName, jsFunction, isStatic, isConstructor);\n      result.add(mirror);\n      mirror._owner = methodOwner;\n    }\n\n    return result;\n  }\n\n  List<JsMethodMirror> get _methods {\n    if (_cachedMethods != null) return _cachedMethods;\n    return _cachedMethods = _getMethodsWithOwner(this);\n  }\n\n  List<VariableMirror> _getFieldsWithOwner(DeclarationMirror fieldOwner) {\n    var result = <VariableMirror>[];\n\n    var instanceFieldSpecfication = _fieldsDescriptor.split(';')[1];\n    if (_fieldsMetadata != null) {\n      instanceFieldSpecfication =\n          [instanceFieldSpecfication]..addAll(_fieldsMetadata);\n    }\n    parseCompactFieldSpecification(\n        fieldOwner, instanceFieldSpecfication, false, result);\n\n    var staticDescriptor = JS('', 'init.statics[#]', _mangledName);\n    if (staticDescriptor != null) {\n      parseCompactFieldSpecification(\n          fieldOwner,\n          JS('', '#[#]',\n              staticDescriptor, JS_GET_NAME('CLASS_DESCRIPTOR_PROPERTY')),\n          true, result);\n    }\n    return result;\n  }\n\n  List<VariableMirror> get _fields {\n    if (_cachedFields != null) return _cachedFields;\n    return _cachedFields = _getFieldsWithOwner(this);\n  }\n\n  Map<Symbol, MethodMirror> get __methods {\n    if (_cachedMethodsMap != null) return _cachedMethodsMap;\n    return _cachedMethodsMap =\n        new UnmodifiableMapView<Symbol, MethodMirror>(filterMethods(_methods));\n  }\n\n  Map<Symbol, MethodMirror> get __getters {\n    if (_cachedGetters != null) return _cachedGetters;\n    return _cachedGetters = new UnmodifiableMapView<Symbol, MethodMirror>(\n        filterGetters(_methods, __variables));\n  }\n\n  Map<Symbol, MethodMirror> get __setters {\n    if (_cachedSetters != null) return _cachedSetters;\n    return _cachedSetters = new UnmodifiableMapView<Symbol, MethodMirror>(\n        filterSetters(_methods, __variables));\n  }\n\n  Map<Symbol, VariableMirror> get __variables {\n    if (_cachedVariables != null) return _cachedVariables;\n    var result = new Map();\n    for (JsVariableMirror mirror in _fields) {\n      result[mirror.simpleName] = mirror;\n    }\n    return _cachedVariables =\n        new UnmodifiableMapView<Symbol, VariableMirror>(result);\n  }\n\n  Map<Symbol, Mirror> get __members {\n    if (_cachedMembers != null) return _cachedMembers;\n    return _cachedMembers = new UnmodifiableMapView<Symbol, Mirror>(\n        filterMembers(_methods, __variables));\n  }\n\n  Map<Symbol, DeclarationMirror> get declarations {\n    if (_cachedDeclarations != null) return _cachedDeclarations;\n    var result = new Map<Symbol, DeclarationMirror>();\n    addToResult(Symbol key, Mirror value) {\n      result[key] = value;\n    }\n    __members.forEach(addToResult);\n    __constructors.forEach(addToResult);\n    typeVariables.forEach((tv) => result[tv.simpleName] = tv);\n    return _cachedDeclarations =\n        new UnmodifiableMapView<Symbol, DeclarationMirror>(result);\n  }\n\n  Map<Symbol, MethodMirror> get staticMembers {\n    if (_cachedStaticMembers == null) {\n      var result = new Map<Symbol, MethodMirror>();\n      declarations.values.forEach((decl) {\n        if (decl is MethodMirror && decl.isStatic && !decl.isConstructor) {\n          result[decl.simpleName] = decl;\n        }\n        if (decl is VariableMirror && decl.isStatic) {\n          var getterName = decl.simpleName;\n          result[getterName] = new JsSyntheticAccessor(\n              this, getterName, true, true, false, decl);\n          if (!decl.isFinal) {\n            var setterName = setterSymbol(decl.simpleName);\n            result[setterName] = new JsSyntheticAccessor(\n                this, setterName, false, true, false, decl);\n          }\n        }\n      });\n      _cachedStaticMembers = result;\n    }\n    return _cachedStaticMembers;\n  }\n\n  Map<Symbol, MethodMirror> get instanceMembers {\n    if (_cachedInstanceMembers == null) {\n      var result = new Map<Symbol, MethodMirror>();\n      if (superclass != null) {\n        result.addAll(superclass.instanceMembers);\n      }\n      declarations.values.forEach((decl) {\n        if (decl is MethodMirror && !decl.isStatic &&\n            !decl.isConstructor && !decl.isAbstract) {\n          result[decl.simpleName] = decl;\n        }\n        if (decl is VariableMirror && !decl.isStatic) {\n          var getterName = decl.simpleName;\n          result[getterName] = new JsSyntheticAccessor(\n              this, getterName, true, false, false, decl);\n          if (!decl.isFinal) {\n            var setterName = setterSymbol(decl.simpleName);\n            result[setterName] = new JsSyntheticAccessor(\n                this, setterName, false, false, false, decl);\n          }\n        }\n      });\n      _cachedInstanceMembers = result;\n    }\n    return _cachedInstanceMembers;\n  }\n\n  InstanceMirror setField(Symbol fieldName, Object arg) {\n    JsVariableMirror mirror = __variables[fieldName];\n    if (mirror != null && mirror.isStatic && !mirror.isFinal) {\n      // '$' (JS_CURRENT_ISOLATE()) stores state which is stored directly, so\n      // we shouldn't use [JsLibraryMirror._globalObject] here.\n      String jsName = mirror._jsName;\n      if (!JS('bool', '# in #', jsName, JS_CURRENT_ISOLATE())) {\n        throw new RuntimeError('Cannot find \"$jsName\" in current isolate.');\n      }\n      JS('void', '#[#] = #', JS_CURRENT_ISOLATE(), jsName, arg);\n      return reflect(arg);\n    }\n    Symbol setterName = setterSymbol(fieldName);\n    if (mirror == null) {\n      JsMethodMirror setter = __setters[setterName];\n      if (setter != null) {\n        setter._invoke([arg], const {});\n        return reflect(arg);\n      }\n    }\n    throw new NoSuchStaticMethodError.method(null, setterName, [arg], null);\n  }\n\n  bool _staticFieldExists(Symbol fieldName) {\n    JsVariableMirror mirror = __variables[fieldName];\n    if (mirror != null) return mirror.isStatic;\n    JsMethodMirror getter = __getters[fieldName];\n    return getter != null && getter.isStatic;\n  }\n\n  InstanceMirror getField(Symbol fieldName) {\n    JsVariableMirror mirror = __variables[fieldName];\n    if (mirror != null && mirror.isStatic) {\n      String jsName = mirror._jsName;\n      // '$' (JS_CURRENT_ISOLATE()) stores state which is read directly, so\n      // we shouldn't use [JsLibraryMirror._globalObject] here.\n      if (!JS('bool', '# in #', jsName, JS_CURRENT_ISOLATE())) {\n        throw new RuntimeError('Cannot find \"$jsName\" in current isolate.');\n      }\n      if (JS('bool', '# in init.lazies', jsName)) {\n        String getterName = JS('String', 'init.lazies[#]', jsName);\n        return reflect(JS('', '#[#]()', JS_CURRENT_ISOLATE(), getterName));\n      } else {\n        return reflect(JS('', '#[#]', JS_CURRENT_ISOLATE(), jsName));\n      }\n    }\n    JsMethodMirror getter = __getters[fieldName];\n    if (getter != null && getter.isStatic) {\n      return reflect(getter._invoke(const [], const {}));\n    }\n    // If the fieldName designates a static function we have to return\n    // its closure.\n    JsMethodMirror method = __methods[fieldName];\n    if (method != null && method.isStatic) {\n      // We invoke the same getter that Dart code would execute. During\n      // initialization we have stored that getter on the function (so that\n      // we can find it more easily here).\n      var getter = JS(\"\", \"#['\\$getter']\", method._jsFunction);\n      if (getter == null) throw new UnimplementedError();\n      return reflect(JS(\"\", \"#()\", getter));\n    }\n    throw new NoSuchStaticMethodError.method(null, fieldName, null, null);\n  }\n\n  _getInvokedInstance(Symbol constructorName,\n                      List positionalArguments,\n                      [Map<Symbol, dynamic> namedArguments]) {\n     if (namedArguments != null && !namedArguments.isEmpty) {\n       throw new UnsupportedError('Named arguments are not implemented.');\n     }\n     JsMethodMirror mirror =\n         JsCache.fetch(_jsConstructorCache, n(constructorName));\n     if (mirror == null) {\n       mirror = __constructors.values.firstWhere(\n           (m) => m.constructorName == constructorName,\n           orElse: () {\n             throw new NoSuchStaticMethodError.method(\n                 null, constructorName, positionalArguments, namedArguments);\n           });\n       JsCache.update(_jsConstructorCache, n(constructorName), mirror);\n     }\n     return mirror._invoke(positionalArguments, namedArguments);\n   }\n\n  InstanceMirror newInstance(Symbol constructorName,\n                             List positionalArguments,\n                             [Map<Symbol, dynamic> namedArguments]) {\n    return reflect(_getInvokedInstance(constructorName,\n                                       positionalArguments,\n                                       namedArguments));\n  }\n\n  JsLibraryMirror get owner {\n    if (_owner == null) {\n      for (var list in JsMirrorSystem.librariesByName.values) {\n        for (JsLibraryMirror library in list) {\n          // This will set _owner field on all classes as a side\n          // effect.  This gives us a fast path to reflect on a\n          // class without parsing reflection data.\n          library.__classes;\n        }\n      }\n      if (_owner == null) {\n        throw new StateError('Class \"${n(simpleName)}\" has no owner');\n      }\n    }\n    return _owner;\n  }\n\n  List<InstanceMirror> get metadata {\n    if (_cachedMetadata != null) return _cachedMetadata;\n    if (_metadata == null) {\n      _metadata = extractMetadata(JS('', '#.prototype', _jsConstructor));\n    }\n    return _cachedMetadata =\n        new UnmodifiableListView<InstanceMirror>(_metadata.map(reflect));\n  }\n\n  ClassMirror get superclass {\n    if (_superclass == null) {\n      List<int> typeInformation =\n          JS('List|Null', 'init.typeInformation[#]', _mangledName);\n      if (typeInformation != null) {\n        var type = getMetadata(typeInformation[0]);\n        _superclass = typeMirrorFromRuntimeTypeRepresentation(this, type);\n      } else {\n        var superclassName = _fieldsDescriptor.split(';')[0];\n        // TODO(zarah): Remove special handing of mixins.\n        var mixins = superclassName.split('+');\n        if (mixins.length > 1) {\n          if (mixins.length != 2) {\n            throw new RuntimeError('Strange mixin: $_fieldsDescriptor');\n          }\n          _superclass = reflectClassByMangledName(mixins[0]);\n        } else {\n          // Use _superclass == this to represent class with no superclass\n          // (Object).\n          _superclass = (superclassName == '')\n              ? this : reflectClassByMangledName(superclassName);\n          }\n        }\n      }\n    return _superclass == this ? null : _superclass;\n  }\n\n  InstanceMirror invoke(Symbol memberName,\n                        List positionalArguments,\n                        [Map<Symbol,dynamic> namedArguments]) {\n    // Mirror API gotcha: Calling [invoke] on a ClassMirror means invoke a\n    // static method.\n\n    if (namedArguments != null && !namedArguments.isEmpty) {\n      throw new UnsupportedError('Named arguments are not implemented.');\n    }\n    JsMethodMirror mirror = __methods[memberName];\n\n    if (mirror == null && _staticFieldExists(memberName)) {\n      return getField(memberName)\n          .invoke(#call, positionalArguments, namedArguments);\n    }\n    if (mirror == null || !mirror.isStatic) {\n      throw new NoSuchStaticMethodError.method(\n          null, memberName, positionalArguments, namedArguments);\n    }\n    if (!mirror.canInvokeReflectively()) {\n      throwInvalidReflectionError(n(memberName));\n    }\n    return reflect(mirror._invoke(positionalArguments, namedArguments));\n  }\n\n  bool get isOriginalDeclaration => true;\n\n  ClassMirror get originalDeclaration => this;\n\n  List<ClassMirror> _getSuperinterfacesWithOwner(DeclarationMirror owner) {\n    List<int> typeInformation =\n        JS('List|Null', 'init.typeInformation[#]', _mangledName);\n    List<ClassMirror> result = const <ClassMirror>[];\n    if (typeInformation != null) {\n      ClassMirror lookupType(int i) {\n        var type = getMetadata(i);\n        return typeMirrorFromRuntimeTypeRepresentation(owner, type);\n      }\n\n      //We skip the first since it is the supertype.\n      result = typeInformation.skip(1).map(lookupType).toList();\n    }\n\n    return new UnmodifiableListView<ClassMirror>(result);\n  }\n\n  List<ClassMirror> get superinterfaces {\n    if (_cachedSuperinterfaces != null) return _cachedSuperinterfaces;\n    return _cachedSuperinterfaces = _getSuperinterfacesWithOwner(this);\n  }\n\n  List<TypeVariableMirror> get typeVariables {\n   if (_cachedTypeVariables != null) return _cachedTypeVariables;\n   List result = new List();\n   List typeVariables =\n        JS('JSExtendableArray|Null', '#.prototype[\"<>\"]', _jsConstructor);\n    if (typeVariables == null) return result;\n    for (int i = 0; i < typeVariables.length; i++) {\n      TypeVariable typeVariable = getMetadata(typeVariables[i]);\n      result.add(new JsTypeVariableMirror(typeVariable, this,\n                                          typeVariables[i]));\n    }\n    return _cachedTypeVariables = new UnmodifiableListView(result);\n  }\n\n  List<TypeMirror> get typeArguments => const <TypeMirror>[];\n\n  bool get hasReflectedType => typeVariables.length == 0;\n\n  Type get reflectedType {\n    if (!hasReflectedType) {\n      throw new UnsupportedError(\n          \"Declarations of generics have no reflected type\");\n    }\n    return createRuntimeType(_mangledName);\n  }\n\n  // TODO(ahe): Implement this.\n  ClassMirror get mixin => throw new UnimplementedError();\n\n  bool get isAbstract => throw new UnimplementedError();\n\n  bool isSubclassOf(ClassMirror other) {\n    if (other is! ClassMirror) {\n      throw new ArgumentError(other);\n    }\n    if (other is JsFunctionTypeMirror) {\n      return false;\n    } if (other is JsClassMirror &&\n          JS('bool', '# == #', other._jsConstructor, _jsConstructor)) {\n      return true;\n    } else if (superclass == null) {\n      return false;\n    } else {\n      return superclass.isSubclassOf(other);\n    }\n  }\n}\n\nclass JsVariableMirror extends JsDeclarationMirror implements VariableMirror {\n\n  // TODO(ahe): The values in these fields are virtually untested.\n  final String _jsName;\n  final bool isFinal;\n  final bool isStatic;\n  final _metadataFunction;\n  final DeclarationMirror _owner;\n  final int _type;\n  List _metadata;\n\n  JsVariableMirror(Symbol simpleName,\n                   this._jsName,\n                   this._type,\n                   this.isFinal,\n                   this.isStatic,\n                   this._metadataFunction,\n                   this._owner)\n      : super(simpleName);\n\n  factory JsVariableMirror.from(String descriptor,\n                                metadataFunction,\n                                JsDeclarationMirror owner,\n                                bool isStatic) {\n    List<String> fieldInformation = descriptor.split('-');\n    if (fieldInformation.length == 1) {\n      // The field is not available for reflection.\n      // TODO(ahe): Should return an unreflectable field.\n      return null;\n    }\n\n    String field = fieldInformation[0];\n    int length = field.length;\n    var code = fieldCode(field.codeUnitAt(length - 1));\n    bool isFinal = false;\n    if (code == 0) return null; // Inherited field.\n    bool hasGetter = (code & 3) != 0;\n    bool hasSetter = (code >> 2) != 0;\n    isFinal = !hasSetter;\n    length--;\n    String jsName;\n    String accessorName = jsName = field.substring(0, length);\n    int divider = field.indexOf(':');\n    if (divider > 0) {\n      accessorName = accessorName.substring(0, divider);\n      jsName = field.substring(divider + 1);\n    }\n    var unmangledName;\n    if (isStatic) {\n      unmangledName = mangledGlobalNames[accessorName];\n    } else {\n      String getterPrefix = JS_GET_NAME('GETTER_PREFIX');\n      unmangledName = mangledNames['$getterPrefix$accessorName'];\n    }\n    if (unmangledName == null) unmangledName = accessorName;\n    if (!hasSetter) {\n      // TODO(ahe): This is a hack to handle checked setters in checked mode.\n      var setterName = s('$unmangledName=');\n      for (JsMethodMirror method in owner._methods) {\n        if (method.simpleName == setterName) {\n          isFinal = false;\n          break;\n        }\n      }\n    }\n    int type = int.parse(fieldInformation[1]);\n    return new JsVariableMirror(s(unmangledName),\n                                jsName,\n                                type,\n                                isFinal,\n                                isStatic,\n                                metadataFunction,\n                                owner);\n  }\n\n  String get _prettyName => 'VariableMirror';\n\n  TypeMirror get type {\n    return typeMirrorFromRuntimeTypeRepresentation(owner, getMetadata(_type));\n  }\n\n  DeclarationMirror get owner => _owner;\n\n  List<InstanceMirror> get metadata {\n    preserveMetadata();\n    if (_metadata == null) {\n      _metadata = (_metadataFunction == null)\n          ? const [] : JS('', '#()', _metadataFunction);\n    }\n    return _metadata.map(reflect).toList();\n  }\n\n  static int fieldCode(int code) {\n    if (code >= 60 && code <= 64) return code - 59;\n    if (code >= 123 && code <= 126) return code - 117;\n    if (code >= 37 && code <= 43) return code - 27;\n    return 0;\n  }\n\n  _getField(JsMirror receiver) => receiver._loadField(_jsName);\n\n  void _setField(JsMirror receiver, Object arg) {\n    if (isFinal) {\n      // TODO(floitsch): when the field is non-static we don't want to have\n      // a mirror as receiver.\n      if (isStatic) {\n        throw new NoSuchStaticMethodError.method(\n            null, setterSymbol(simpleName), [arg], null);\n      }\n      throw new NoSuchMethodError(this, setterSymbol(simpleName), [arg], null);\n    }\n    receiver._storeField(_jsName, arg);\n  }\n\n  // TODO(ahe): Implement this method.\n  bool get isConst => throw new UnimplementedError();\n}\n\nclass JsClosureMirror extends JsInstanceMirror implements ClosureMirror {\n  JsClosureMirror(reflectee)\n      : super(reflectee);\n\n  MethodMirror get function {\n    String cacheName = Primitives.mirrorFunctionCacheName;\n    JsMethodMirror cachedFunction;\n    // TODO(ahe): Restore caching.\n    //= JS('JsMethodMirror|Null', r'#.constructor[#]', reflectee, cacheName);\n    if (cachedFunction != null) return cachedFunction;\n    disableTreeShaking();\n    // TODO(ahe): What about optional parameters (named or not).\n    String callPrefix = \"${JS_GET_NAME(\"CALL_PREFIX\")}\\$\";\n    var extractCallName = JS('', r'''\nfunction(reflectee) {\n  for (var property in reflectee) {\n    if (# == property.substring(0, #) &&\n        property[#] >= '0' &&\n        property[#] <= '9') return property;\n  }\n  return null;\n}\n''', callPrefix, callPrefix.length, callPrefix.length, callPrefix.length);\n    String callName = JS('String|Null', '#(#)', extractCallName, reflectee);\n    if (callName == null) {\n      throw new RuntimeError('Cannot find callName on \"$reflectee\"');\n    }\n    // TODO(floitsch): What about optional parameters?\n    int parameterCount = int.parse(callName.split(r'$')[1]);\n    if (reflectee is BoundClosure) {\n      var target = BoundClosure.targetOf(reflectee);\n      var self = BoundClosure.selfOf(reflectee);\n      var name = mangledNames[BoundClosure.nameOf(reflectee)];\n      if (name == null) {\n        throwInvalidReflectionError(name);\n      }\n      cachedFunction = new JsMethodMirror.fromUnmangledName(\n          name, target, false, false);\n    } else {\n      bool isStatic = true; // TODO(ahe): Compute isStatic correctly.\n      var jsFunction = JS('', '#[#]', reflectee, callName);\n      var dummyOptionalParameterCount = 0;\n      cachedFunction = new JsMethodMirror(\n          s(callName), jsFunction, parameterCount, dummyOptionalParameterCount,\n          false, false, isStatic, false, false);\n    }\n    JS('void', r'#.constructor[#] = #', reflectee, cacheName, cachedFunction);\n    return cachedFunction;\n  }\n\n  InstanceMirror apply(List positionalArguments,\n                       [Map<Symbol, dynamic> namedArguments]) {\n    return reflect(\n        Function.apply(reflectee, positionalArguments, namedArguments));\n  }\n\n  String toString() => \"ClosureMirror on '${Error.safeToString(reflectee)}'\";\n\n  // TODO(ahe): Implement this method.\n  String get source => throw new UnimplementedError();\n}\n\nclass JsMethodMirror extends JsDeclarationMirror implements MethodMirror {\n  final _jsFunction;\n  final int _requiredParameterCount;\n  final int _optionalParameterCount;\n  final bool isGetter;\n  final bool isSetter;\n  final bool isStatic;\n  final bool isConstructor;\n  final bool isOperator;\n  DeclarationMirror _owner;\n  List _metadata;\n  TypeMirror _returnType;\n  UnmodifiableListView<ParameterMirror> _parameters;\n\n  JsMethodMirror(Symbol simpleName,\n                 this._jsFunction,\n                 this._requiredParameterCount,\n                 this._optionalParameterCount,\n                 this.isGetter,\n                 this.isSetter,\n                 this.isStatic,\n                 this.isConstructor,\n                 this.isOperator)\n      : super(simpleName);\n\n  factory JsMethodMirror.fromUnmangledName(String name,\n                                           jsFunction,\n                                           bool isStatic,\n                                           bool isConstructor) {\n    List<String> info = name.split(':');\n    name = info[0];\n    bool isOperator = isOperatorName(name);\n    bool isSetter = !isOperator && name.endsWith('=');\n    int requiredParameterCount = 0;\n    int optionalParameterCount = 0;\n    bool isGetter = false;\n    if (info.length == 1) {\n      if (isSetter) {\n        requiredParameterCount = 1;\n      } else {\n        isGetter = true;\n        requiredParameterCount = 0;\n      }\n    } else {\n      requiredParameterCount = int.parse(info[1]);\n      optionalParameterCount = int.parse(info[2]);\n    }\n    return new JsMethodMirror(\n        s(name), jsFunction, requiredParameterCount, optionalParameterCount,\n        isGetter, isSetter, isStatic, isConstructor, isOperator);\n  }\n\n  String get _prettyName => 'MethodMirror';\n\n  int get _parameterCount => _requiredParameterCount + _optionalParameterCount;\n\n  List<ParameterMirror> get parameters {\n    if (_parameters != null) return _parameters;\n    metadata; // Compute _parameters as a side-effect of extracting metadata.\n    return _parameters;\n  }\n\n  bool canInvokeReflectively() {\n    return hasReflectableProperty(_jsFunction);\n  }\n\n  DeclarationMirror get owner => _owner;\n\n  TypeMirror get returnType {\n    metadata; // Compute _returnType as a side-effect of extracting metadata.\n    return _returnType;\n  }\n\n  List<InstanceMirror> get metadata {\n    if (_metadata == null) {\n      var raw = extractMetadata(_jsFunction);\n      var formals = new List(_parameterCount);\n      ReflectionInfo info = new ReflectionInfo(_jsFunction);\n      if (info != null) {\n        assert(_parameterCount\n               == info.requiredParameterCount + info.optionalParameterCount);\n        var functionType = info.functionType;\n        var type;\n        if (functionType is int) {\n          type = new JsFunctionTypeMirror(info.computeFunctionRti(null), this);\n          assert(_parameterCount == type.parameters.length);\n        } else if (isTopLevel) {\n          type = new JsFunctionTypeMirror(info.computeFunctionRti(null), owner);\n        } else {\n          TypeMirror ownerType = owner;\n          JsClassMirror ownerClass = ownerType.originalDeclaration;\n          type = new JsFunctionTypeMirror(\n              info.computeFunctionRti(ownerClass._jsConstructor),\n              owner);\n        }\n        // Constructors aren't reified with their return type.\n        if (isConstructor) {\n          _returnType = owner;\n        } else {\n          _returnType = type.returnType;\n        }\n        int i = 0;\n        bool isNamed = info.areOptionalParametersNamed;\n        for (JsParameterMirror parameter in type.parameters) {\n          var name = info.parameterName(i);\n          List<int> annotations = info.parameterMetadataAnnotations(i);\n          var p;\n          if (i < info.requiredParameterCount) {\n            p = new JsParameterMirror(name, this, parameter._type,\n                metadataList: annotations);\n          } else {\n            var defaultValue = info.defaultValue(i);\n            p = new JsParameterMirror(\n                name, this, parameter._type, metadataList: annotations,\n                isOptional: true, isNamed: isNamed, defaultValue: defaultValue);\n          }\n          formals[i++] = p;\n        }\n      }\n      _parameters = new UnmodifiableListView<ParameterMirror>(formals);\n      _metadata = new UnmodifiableListView(raw.map(reflect));\n    }\n    return _metadata;\n  }\n\n  Symbol get constructorName {\n    // TODO(ahe): I believe it is more appropriate to throw an exception or\n    // return null.\n    if (!isConstructor) return const Symbol('');\n    String name = n(simpleName);\n    int index = name.indexOf('.');\n    if (index == -1) return const Symbol('');\n    return s(name.substring(index + 1));\n  }\n\n  _invoke(List positionalArguments, Map<Symbol, dynamic> namedArguments) {\n    if (namedArguments != null && !namedArguments.isEmpty) {\n      throw new UnsupportedError('Named arguments are not implemented.');\n    }\n    if (!isStatic && !isConstructor) {\n      throw new RuntimeError('Cannot invoke instance method without receiver.');\n    }\n    int positionalLength = positionalArguments.length;\n    if (positionalLength < _requiredParameterCount ||\n        positionalLength >  _parameterCount ||\n        _jsFunction == null) {\n      // TODO(ahe): What receiver to use?\n      throw new NoSuchMethodError(\n          owner, simpleName, positionalArguments, namedArguments);\n    }\n    if (positionalLength < _parameterCount) {\n      // Fill up with default values.\n      // Make a copy so we don't modify the input.\n      positionalArguments = positionalArguments.toList();\n      for (int i = positionalLength; i < parameters.length; i++) {\n        JsParameterMirror parameter = parameters[i];\n        positionalArguments.add(parameter.defaultValue.reflectee);\n      }\n    }\n    // Using JS_CURRENT_ISOLATE() ('$') here is actually correct, although\n    // _jsFunction may not be a property of '$', most static functions do not\n    // care who their receiver is. But to lazy getters, it is important that\n    // 'this' is '$'.\n    return JS('', r'#.apply(#, #)', _jsFunction, JS_CURRENT_ISOLATE(),\n              new List.from(positionalArguments));\n  }\n\n  _getField(JsMirror receiver) {\n    if (isGetter) {\n      return _invoke([], null);\n    } else {\n      // TODO(ahe): Closurize method.\n      throw new UnimplementedError('getField on $receiver');\n    }\n  }\n\n  _setField(JsMirror receiver, Object arg) {\n    if (isSetter) {\n      return _invoke([arg], null);\n    } else {\n      throw new NoSuchMethodError(this, setterSymbol(simpleName), [], null);\n    }\n  }\n\n  // Abstract methods are tree-shaken away.\n  bool get isAbstract => false;\n\n  // TODO(ahe, 14633): This might not be true for all cases.\n  bool get isSynthetic => false;\n\n  // TODO(ahe): Test this.\n  bool get isRegularMethod => !isGetter && !isSetter && !isConstructor;\n\n  // TODO(ahe): Implement this method.\n  bool get isConstConstructor => throw new UnimplementedError();\n\n  // TODO(ahe): Implement this method.\n  bool get isGenerativeConstructor => throw new UnimplementedError();\n\n  // TODO(ahe): Implement this method.\n  bool get isRedirectingConstructor => throw new UnimplementedError();\n\n  // TODO(ahe): Implement this method.\n  bool get isFactoryConstructor => throw new UnimplementedError();\n\n  // TODO(ahe): Implement this method.\n  String get source => throw new UnimplementedError();\n}\n\nclass JsParameterMirror extends JsDeclarationMirror implements ParameterMirror {\n  final DeclarationMirror owner;\n  // A JS object representing the type.\n  final _type;\n\n  final bool isOptional;\n\n  final bool isNamed;\n\n  final int _defaultValue;\n\n  final List<int> metadataList;\n\n  JsParameterMirror(String unmangledName,\n                    this.owner,\n                    this._type,\n                     {this.metadataList: const <int>[],\n                     this.isOptional: false,\n                     this.isNamed: false,\n                     defaultValue})\n      : _defaultValue = defaultValue,\n        super(s(unmangledName));\n\n  String get _prettyName => 'ParameterMirror';\n\n  TypeMirror get type {\n    return typeMirrorFromRuntimeTypeRepresentation(owner, _type);\n  }\n\n  // Only true for static fields, never for a parameter.\n  bool get isStatic => false;\n\n  // TODO(ahe): Implement this.\n  bool get isFinal => false;\n\n  // TODO(ahe): Implement this.\n  bool get isConst => false;\n\n  bool get hasDefaultValue => _defaultValue != null;\n\n  get defaultValue {\n    return hasDefaultValue ? reflect(getMetadata(_defaultValue)) : null;\n  }\n\n  List<InstanceMirror> get metadata {\n    preserveMetadata();\n    return metadataList.map((int i) => reflect(getMetadata(i))).toList();\n  }\n}\n\nclass JsTypedefMirror extends JsDeclarationMirror implements TypedefMirror {\n  final String _mangledName;\n  JsFunctionTypeMirror referent;\n\n  JsTypedefMirror(Symbol simpleName,  this._mangledName, _typeData)\n      : super(simpleName) {\n    referent = new JsFunctionTypeMirror(_typeData, this);\n  }\n\n  JsFunctionTypeMirror get value => referent;\n\n  String get _prettyName => 'TypedefMirror';\n\n  bool get hasReflectedType => throw new UnimplementedError();\n\n  Type get reflectedType => throw new UnimplementedError();\n\n  // TODO(ahe): Implement this method.\n  List<TypeVariableMirror> get typeVariables => throw new UnimplementedError();\n\n  // TODO(ahe): Implement this method.\n  List<TypeMirror> get typeArguments => throw new UnimplementedError();\n\n  // TODO(ahe): Implement this method.\n  bool get isOriginalDeclaration => throw new UnimplementedError();\n\n  // TODO(ahe): Implement this method.\n  TypeMirror get originalDeclaration => throw new UnimplementedError();\n\n  // TODO(ahe): Implement this method.\n  DeclarationMirror get owner => throw new UnimplementedError();\n\n  // TODO(ahe): Implement this method.\n  List<InstanceMirror> get metadata => throw new UnimplementedError();\n\n  bool isSubtypeOf(TypeMirror other) => throw new UnimplementedError();\n  bool isAssignableTo(TypeMirror other) => throw new UnimplementedError();\n}\n\n// TODO(ahe): Remove this class when API is updated.\nclass BrokenClassMirror {\n  bool get hasReflectedType => throw new UnimplementedError();\n  Type get reflectedType => throw new UnimplementedError();\n  ClassMirror get superclass => throw new UnimplementedError();\n  List<ClassMirror> get superinterfaces => throw new UnimplementedError();\n  Map<Symbol, DeclarationMirror> get declarations\n      => throw new UnimplementedError();\n  Map<Symbol, MethodMirror> get instanceMembers\n      => throw new UnimplementedError();\n  Map<Symbol, MethodMirror> get staticMembers => throw new UnimplementedError();\n  ClassMirror get mixin => throw new UnimplementedError();\n  InstanceMirror newInstance(\n      Symbol constructorName,\n      List positionalArguments,\n      [Map<Symbol, dynamic> namedArguments]) => throw new UnimplementedError();\n  InstanceMirror invoke(Symbol memberName,\n                        List positionalArguments,\n                        [Map<Symbol, dynamic> namedArguments])\n      => throw new UnimplementedError();\n  InstanceMirror getField(Symbol fieldName) => throw new UnimplementedError();\n  InstanceMirror setField(Symbol fieldName, Object value)\n      => throw new UnimplementedError();\n  List<TypeVariableMirror> get typeVariables => throw new UnimplementedError();\n  List<TypeMirror> get typeArguments => throw new UnimplementedError();\n  TypeMirror get originalDeclaration => throw new UnimplementedError();\n  Symbol get simpleName => throw new UnimplementedError();\n  Symbol get qualifiedName => throw new UnimplementedError();\n  bool get isPrivate => throw new UnimplementedError();\n  bool get isTopLevel => throw new UnimplementedError();\n  SourceLocation get location => throw new UnimplementedError();\n  List<InstanceMirror> get metadata => throw new UnimplementedError();\n}\n\nclass JsFunctionTypeMirror extends BrokenClassMirror\n    implements FunctionTypeMirror {\n  final _typeData;\n  String _cachedToString;\n  TypeMirror _cachedReturnType;\n  UnmodifiableListView<ParameterMirror> _cachedParameters;\n  DeclarationMirror owner;\n\n  JsFunctionTypeMirror(this._typeData, this.owner);\n\n  bool get _hasReturnType => JS('bool', '\"ret\" in #', _typeData);\n  get _returnType => JS('', '#.ret', _typeData);\n\n  bool get _isVoid => JS('bool', '!!#.void', _typeData);\n\n  bool get _hasArguments => JS('bool', '\"args\" in #', _typeData);\n  List get _arguments => JS('JSExtendableArray', '#.args', _typeData);\n\n  bool get _hasOptionalArguments => JS('bool', '\"opt\" in #', _typeData);\n  List get _optionalArguments => JS('JSExtendableArray', '#.opt', _typeData);\n\n  bool get _hasNamedArguments => JS('bool', '\"named\" in #', _typeData);\n  get _namedArguments => JS('=Object', '#.named', _typeData);\n  bool get isOriginalDeclaration => true;\n\n  bool get isAbstract => false;\n\n  TypeMirror get returnType {\n    if (_cachedReturnType != null) return _cachedReturnType;\n    if (_isVoid) return _cachedReturnType = JsMirrorSystem._voidType;\n    if (!_hasReturnType) return _cachedReturnType = JsMirrorSystem._dynamicType;\n    return _cachedReturnType =\n        typeMirrorFromRuntimeTypeRepresentation(owner, _returnType);\n  }\n\n  List<ParameterMirror> get parameters {\n    if (_cachedParameters != null) return _cachedParameters;\n    List result = [];\n    int parameterCount = 0;\n    if (_hasArguments) {\n      for (var type in _arguments) {\n        result.add(\n            new JsParameterMirror('argument${parameterCount++}', this, type));\n      }\n    }\n    if (_hasOptionalArguments) {\n      for (var type in _optionalArguments) {\n        result.add(\n            new JsParameterMirror('argument${parameterCount++}', this, type));\n      }\n    }\n    if (_hasNamedArguments) {\n      for (var name in extractKeys(_namedArguments)) {\n        var type = JS('', '#[#]', _namedArguments, name);\n        result.add(new JsParameterMirror(name, this, type));\n      }\n    }\n    return _cachedParameters = new UnmodifiableListView<ParameterMirror>(\n        result);\n  }\n\n  String _unmangleIfPreserved(String mangled) {\n    String result = unmangleGlobalNameIfPreservedAnyways(mangled);\n    if (result != null) return result;\n    return mangled;\n  }\n\n  String toString() {\n    if (_cachedToString != null) return _cachedToString;\n    var s = \"FunctionTypeMirror on '(\";\n    var sep = '';\n    if (_hasArguments) {\n      for (var argument in _arguments) {\n        s += sep;\n        s += _unmangleIfPreserved(runtimeTypeToString(argument));\n        sep = ', ';\n      }\n    }\n    if (_hasOptionalArguments) {\n      s += '$sep[';\n      sep = '';\n      for (var argument in _optionalArguments) {\n        s += sep;\n        s += _unmangleIfPreserved(runtimeTypeToString(argument));\n        sep = ', ';\n      }\n      s += ']';\n    }\n    if (_hasNamedArguments) {\n      s += '$sep{';\n      sep = '';\n      for (var name in extractKeys(_namedArguments)) {\n        s += sep;\n        s += '$name: ';\n        s += _unmangleIfPreserved(\n            runtimeTypeToString(JS('', '#[#]', _namedArguments, name)));\n        sep = ', ';\n      }\n      s += '}';\n    }\n    s += ') -> ';\n    if (_isVoid) {\n      s += 'void';\n    } else if (_hasReturnType) {\n      s += _unmangleIfPreserved(runtimeTypeToString(_returnType));\n    } else {\n      s += 'dynamic';\n    }\n    return _cachedToString = \"$s'\";\n  }\n\n  bool isSubclassOf(ClassMirror other) => false;\n\n  bool isSubtypeOf(TypeMirror other) => throw new UnimplementedError();\n\n  bool isAssignableTo(TypeMirror other) => throw new UnimplementedError();\n\n  // TODO(ahe): Implement this method.\n  MethodMirror get callMethod => throw new UnimplementedError();\n}\n\nint findTypeVariableIndex(List<TypeVariableMirror> typeVariables, String name) {\n  for (int i = 0; i < typeVariables.length; i++) {\n    if (typeVariables[i].simpleName == s(name)) {\n      return i;\n    }\n  }\n  throw new ArgumentError('Type variable not present in list.');\n}\n\nTypeMirror typeMirrorFromRuntimeTypeRepresentation(\n    DeclarationMirror owner,\n    var /*int|List|JsFunction*/ type) {\n  // TODO(ahe): This method might benefit from using convertRtiToRuntimeType\n  // instead of working on strings.\n  ClassMirror ownerClass;\n  DeclarationMirror context = owner;\n  while (context != null) {\n    if (context is ClassMirror) {\n      ownerClass = context;\n      break;\n    }\n    // TODO(ahe): Get type parameters and arguments from typedefs.\n    if (context is TypedefMirror) break;\n    context = context.owner;\n  }\n\n  String representation;\n  if (type == null) {\n    return JsMirrorSystem._dynamicType;\n  } else if (ownerClass == null) {\n    representation = runtimeTypeToString(type);\n  } else if (ownerClass.isOriginalDeclaration) {\n    if (type is num) {\n      // [type] represents a type variable so in the context of an original\n      // declaration the corresponding type variable should be returned.\n      TypeVariable typeVariable = getMetadata(type);\n      List<TypeVariableMirror> typeVariables = ownerClass.typeVariables;\n      int index = findTypeVariableIndex(typeVariables, typeVariable.name);\n      return typeVariables[index];\n    } else {\n      // Nested type variables will be retrieved lazily (the integer\n      // representation is kept in the string) so they are not processed here.\n      representation = runtimeTypeToString(type);\n    }\n  } else {\n    TypeMirror getTypeArgument(int index) {\n      TypeVariable typeVariable = getMetadata(index);\n      int variableIndex =\n          findTypeVariableIndex(ownerClass.typeVariables, typeVariable.name);\n      return ownerClass.typeArguments[variableIndex];\n    }\n\n    if (type is num) {\n      // [type] represents a type variable used as type argument for example\n      // the type argument of Bar: class Foo<T> extends Bar<T> {}\n      TypeMirror typeArgument = getTypeArgument(type);\n      if (typeArgument is JsTypeVariableMirror)\n        return typeArgument;\n    }\n    String substituteTypeVariable(int index) {\n      var typeArgument = getTypeArgument(index);\n      if (typeArgument is JsTypeVariableMirror) {\n        return '${typeArgument._metadataIndex}';\n      }\n      if (typeArgument is! JsClassMirror &&\n          typeArgument is! JsTypeBoundClassMirror) {\n        if (typeArgument == JsMirrorSystem._dynamicType) {\n          return 'dynamic';\n        } else if (typeArgument == JsMirrorSystem._voidType) {\n          return 'void';\n        } else {\n          // TODO(ahe): This case shouldn't happen.\n          return 'dynamic';\n        }\n      }\n      return typeArgument._mangledName;\n    }\n    representation =\n        runtimeTypeToString(type, onTypeVariable: substituteTypeVariable);\n  }\n  if (representation != null) {\n    return reflectClassByMangledName(\n        getMangledTypeName(createRuntimeType(representation)));\n  }\n  return reflectClass(Function);\n}\n\nSymbol computeQualifiedName(DeclarationMirror owner, Symbol simpleName) {\n  if (owner == null) return simpleName;\n  String ownerName = n(owner.qualifiedName);\n  return s('$ownerName.${n(simpleName)}');\n}\n\nList extractMetadata(victim) {\n  preserveMetadata();\n  var metadataFunction;\n  if (JS('bool', 'Object.prototype.hasOwnProperty.call(#, \"@\")', victim)) {\n    metadataFunction = JS('', '#[\"@\"]', victim);\n  }\n  if (metadataFunction != null) return JS('', '#()', metadataFunction);\n  if (JS('bool', 'typeof # != \"function\"', victim)) return const [];\n  if (JS('bool', '# in #', r'$metadataIndex', victim)) {\n    return JSArray.markFixedList(\n        JS('JSExtendableArray',\n           r'#.$reflectionInfo.splice(#.$metadataIndex)', victim, victim))\n        .map((int i) => getMetadata(i)).toList();\n  }\n  return const [];\n}\n\nvoid parseCompactFieldSpecification(\n    JsDeclarationMirror owner,\n    fieldSpecification,\n    bool isStatic,\n    List<Mirror> result) {\n  List fieldsMetadata = null;\n  List<String> fields;\n  if (fieldSpecification is List) {\n    fields = splitFields(fieldSpecification[0], ',');\n    fieldsMetadata = fieldSpecification.sublist(1);\n  } else if (fieldSpecification is String) {\n    fields = splitFields(fieldSpecification, ',');\n  } else {\n    fields = [];\n  }\n  int fieldNumber = 0;\n  for (String field in fields) {\n    var metadata;\n    if (fieldsMetadata != null) {\n      metadata = fieldsMetadata[fieldNumber++];\n    }\n    var mirror = new JsVariableMirror.from(field, metadata, owner, isStatic);\n    if (mirror != null) {\n      result.add(mirror);\n    }\n  }\n}\n\n/// Similar to [String.split], but returns an empty list if [string] is empty.\nList<String> splitFields(String string, Pattern pattern) {\n  if (string.isEmpty) return <String>[];\n  return string.split(pattern);\n}\n\nbool isOperatorName(String name) {\n  switch (name) {\n  case '==':\n  case '[]':\n  case '*':\n  case '/':\n  case '%':\n  case '~/':\n  case '+':\n  case '<<':\n  case '>>':\n  case '>=':\n  case '>':\n  case '<=':\n  case '<':\n  case '&':\n  case '^':\n  case '|':\n  case '-':\n  case 'unary-':\n  case '[]=':\n  case '~':\n    return true;\n  default:\n    return false;\n  }\n}\n\n/// Returns true if the key represent ancillary reflection data, that is, not a\n/// method.\nbool isReflectiveDataInPrototype(String key) {\n  if (key == JS_GET_NAME('CLASS_DESCRIPTOR_PROPERTY') ||\n      key == METHODS_WITH_OPTIONAL_ARGUMENTS) {\n    return true;\n  }\n  String firstChar = key[0];\n  return firstChar == '*' || firstChar == '+';\n}\n\nbool isNoSuchMethodStub(var jsFunction) {\n  return JS('bool', r'#.$reflectable == 2', jsFunction);\n}\n\nclass NoSuchStaticMethodError extends Error implements NoSuchMethodError {\n  static const int MISSING_CONSTRUCTOR = 0;\n  static const int MISSING_METHOD = 1;\n  final ClassMirror _cls;\n  final Symbol _name;\n  final List _positionalArguments;\n  final Map<Symbol, dynamic> _namedArguments;\n  final int _kind;\n\n  NoSuchStaticMethodError.missingConstructor(\n      this._cls,\n      this._name,\n      this._positionalArguments,\n      this._namedArguments)\n      : _kind = MISSING_CONSTRUCTOR;\n\n  /// If the given class is `null` the static method/getter/setter is top-level.\n  NoSuchStaticMethodError.method(\n      this._cls,\n      this._name,\n      this._positionalArguments,\n      this._namedArguments)\n      : _kind = MISSING_METHOD;\n\n  String toString() {\n    // TODO(floitsch): show arguments.\n    switch(_kind) {\n    case MISSING_CONSTRUCTOR:\n      return\n          \"NoSuchMethodError: No constructor named '${n(_name)}' in class\"\n          \" '${n(_cls.qualifiedName)}'.\";\n    case MISSING_METHOD:\n      if (_cls == null) {\n        return \"NoSuchMethodError: No top-level method named '${n(_name)}'.\";\n      }\n      return \"NoSuchMethodError: No static method named '${n(_name)}' in\"\n             \" class '${n(_cls.qualifiedName)}'\";\n    default:\n      return 'NoSuchMethodError';\n    }\n  }\n}\n\nSymbol getSymbol(String name, LibraryMirror library) {\n  if (_isPublicSymbol(name)) {\n    return new _symbol_dev.Symbol.validated(name);\n  }\n  if (library == null) {\n    throw new ArgumentError(\n        \"Library required for private symbol name: $name\");\n  }\n  if (!_symbol_dev.Symbol.isValidSymbol(name)) {\n    throw new ArgumentError(\"Not a valid symbol name: $name\");\n  }\n  throw new UnimplementedError(\n      \"MirrorSystem.getSymbol not implemented for private names\");\n}\n\nbool _isPublicSymbol(String name) {\n  // A symbol is public if it doesn't start with '_' and it doesn't\n  // have a part (following a '.') that starts with '_'.\n  const int UNDERSCORE = 0x5f;\n  if (name.isEmpty) return true;\n  int index = -1;\n  do {\n    if (name.codeUnitAt(index + 1) == UNDERSCORE) return false;\n    index = name.indexOf('.', index + 1);\n  } while (index >= 0 && index + 1 < name.length);\n  return true;\n}\n\u0000","sdk:/sdk/lib/_internal/compiler/implementation/runtime_data.dart":"// Copyright (c) 2014, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n/// Contains encoding, decoding and detection functionality for the\n/// representation of program data at runtime.\n///\n/// This library is shared between the compiler and the runtime system.\nlibrary dart2js.runtime_data;\n\n\nString encodeTypedefFieldDescriptor(int typeIndex) {\n  return \":$typeIndex;\";\n}\n\nbool isTypedefDescriptor(String descriptor) {\n  return descriptor.startsWith(':');\n}\n\nint getTypeFromTypedef(String descriptor) {\n  return int.parse(descriptor.substring(1, descriptor.length - 1));\n}\u0000","sdk:/sdk/lib/profiler/profiler.dart":"// Copyright (c) 2014, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\nlibrary dart.profiler;\n\nimport 'dart:convert';\n\n/// A UserTag can be used to group samples in the Observatory profiler.\nabstract class UserTag {\n  /// The maximum number of UserTag instances that can be created by a program.\n  static const MAX_USER_TAGS = 64;\n\n  factory UserTag(String label) => new _FakeUserTag(label);\n\n  /// Label of [this].\n  String get label;\n\n  /// Make [this] the current tag for the isolate. Returns the current tag\n  /// before setting.\n  UserTag makeCurrent();\n\n  /// The default [UserTag] with label 'Default'.\n  static UserTag get defaultTag => _FakeUserTag._defaultTag;\n}\n\n// This is a fake implementation of UserTag so that code can compile and run\n// in dart2js.\nclass _FakeUserTag implements UserTag {\n  static Map _instances = {};\n\n  _FakeUserTag.real(this.label);\n\n  factory _FakeUserTag(String label) {\n    // Canonicalize by name.\n    var existingTag = _instances[label];\n    if (existingTag != null) {\n      return existingTag;\n    }\n    // Throw an exception if we've reached the maximum number of user tags.\n    if (_instances.length == UserTag.MAX_USER_TAGS) {\n      throw new UnsupportedError(\n          'UserTag instance limit (${UserTag.MAX_USER_TAGS}) reached.');\n    }\n    // Create a new instance and add it to the instance map.\n    var instance = new _FakeUserTag.real(label);\n    _instances[label] = instance;\n    return instance;\n  }\n\n  final String label;\n\n  UserTag makeCurrent() {\n    var old = _currentTag;\n    _currentTag = this;\n    return old;\n  }\n\n  static final UserTag _defaultTag = new _FakeUserTag('Default');\n}\n\nvar _currentTag = _FakeUserTag._defaultTag;\n\n/// Returns the current [UserTag] for the isolate.\nUserTag getCurrentTag() {\n  return _currentTag;\n}\n\n/// Abstract [Metric] class. Metric names must be unique, are hierarchical,\n/// and use periods as separators. For example, 'a.b.c'. Uniqueness is only\n/// enforced when a Metric is registered. The name of a metric cannot contain\n/// the slash ('/') character.\nabstract class Metric {\n  /// [name] of this metric.\n  final String name;\n  /// [description] of this metric.\n  final String description;\n\n  Metric(this.name, this.description) {\n    if ((name == 'vm') || name.contains('/')) {\n      throw new ArgumentError('Invalid Metric name.');\n    }\n\n  }\n\n  Map _toJSON();\n}\n\n/// A measured value with a min and max. Initial value is min. Value will\n/// be clamped to the interval [min, max].\nclass Gauge extends Metric {\n  final double min;\n  final double max;\n\n  double _value;\n  double get value => _value;\n  set value(double v) {\n    if (v < min) {\n      v = min;\n    } else if (v > max) {\n      v = max;\n    }\n    _value = v;\n  }\n\n  Gauge(String name, String description, this.min, this.max)\n      : super(name, description) {\n    if (min is! double) {\n      throw new ArgumentError('min must be a double');\n    }\n    if (max is! double) {\n      throw new ArgumentError('max must be a double');\n    }\n    if (!(min < max)) {\n      throw new ArgumentError('min must be less than max');\n    }\n    _value = min;\n  }\n\n  Map _toJSON() {\n    var map = {\n      'type': 'Gauge',\n      'id': 'metrics/$name',\n      'name': name,\n      'description': description,\n      'value': value,\n      'min': min,\n      'max': max,\n    };\n    return map;\n  }\n}\n\n\n/// A changing value. Initial value is 0.0.\nclass Counter extends Metric {\n  Counter(String name, String description)\n      : super(name, description);\n\n  double _value = 0.0;\n  double get value => _value;\n  set value(double v) {\n    _value = v;\n  }\n\n  Map _toJSON() {\n    var map = {\n      'type': 'Counter',\n      'id': 'metrics/$name',\n      'name': name,\n      'description': description,\n      'value': value,\n    };\n    return map;\n  }\n}\n\nclass Metrics {\n  static final Map<String, Metric> _metrics = new Map<String, Metric>();\n\n  /// Register [Metric]s to make them visible to Observatory.\n  static void register(Metric metric) {\n    if (metric is! Metric) {\n      throw new ArgumentError('metric must be a Metric');\n    }\n    if (_metrics[metric.name] != null) {\n      throw new ArgumentError('Registered metrics have unique names');\n    }\n    _metrics[metric.name] = metric;\n  }\n\n  /// Deregister [Metric]s to make them not visible to Observatory.\n  static void deregister(Metric metric) {\n    if (metric is! Metric) {\n      throw new ArgumentError('metric must be a Metric');\n    }\n    _metrics.remove(metric.name);\n  }\n\n  static String _printMetric(String id) {\n    var metric = _metrics[id];\n    if (metric == null) {\n      return null;\n    }\n    return JSON.encode(metric._toJSON());\n  }\n\n  static String _printMetrics() {\n    var members = [];\n    for (var metric in _metrics.values) {\n      members.add(metric._toJSON());\n    }\n    var map = {\n      'type': 'MetricList',\n      'id': 'metrics',\n      'members': members,\n    };\n    return JSON.encode(map);\n  }\n}\n\u0000","sdk:/sdk/lib/_internal/lib/async_patch.dart":"// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n// Patch file for the dart:async library.\n\nimport 'dart:_js_helper' show\n    patch,\n    Primitives,\n    convertDartClosureToJS,\n    loadDeferredLibrary,\n    requiresPreamble;\nimport 'dart:_isolate_helper' show\n    IsolateNatives,\n    TimerImpl,\n    leaveJsAsync,\n    enterJsAsync,\n    isWorker;\n\nimport 'dart:_foreign_helper' show JS;\n\n@patch\nclass _AsyncRun {\n  @patch\n  static void _scheduleImmediate(void callback()) {\n    scheduleImmediateClosure(callback);\n  }\n\n  // Lazily initialized.\n  static final Function scheduleImmediateClosure =\n      _initializeScheduleImmediate();\n\n  static Function _initializeScheduleImmediate() {\n    requiresPreamble();\n    if (JS('', 'self.scheduleImmediate') != null) {\n      return _scheduleImmediateJsOverride;\n    }\n    if (JS('', 'self.MutationObserver') != null &&\n        JS('', 'self.document') != null) {\n      // Use mutationObservers.\n      var div = JS('', 'self.document.createElement(\"div\")');\n      var span = JS('', 'self.document.createElement(\"span\")');\n      var storedCallback;\n\n      internalCallback(_) {\n        leaveJsAsync();\n        var f = storedCallback;\n        storedCallback = null;\n        f();\n      };\n\n      var observer = JS('', 'new self.MutationObserver(#)',\n          convertDartClosureToJS(internalCallback, 1));\n      JS('', '#.observe(#, { childList: true })',\n          observer, div);\n\n      return (void callback()) {\n        assert(storedCallback == null);\n        enterJsAsync();\n        storedCallback = callback;\n        // Because of a broken shadow-dom polyfill we have to change the\n        // children instead a cheap property.\n        // See https://github.com/Polymer/ShadowDOM/issues/468\n        JS('', '#.firstChild ? #.removeChild(#): #.appendChild(#)',\n            div, div, span, div, span);\n      };\n\n    }\n    // TODO(9002): don't use the Timer to enqueue the immediate callback.\n    // Also check for other JS options like setImmediate.\n    // TODO(20055): We should use DOM promises when available.\n    return _scheduleImmediateWithTimer;\n  }\n\n  static void _scheduleImmediateJsOverride(void callback()) {\n    internalCallback() {\n      leaveJsAsync();\n      callback();\n    };\n    enterJsAsync();\n    JS('void', 'self.scheduleImmediate(#)',\n       convertDartClosureToJS(internalCallback, 0));\n  }\n\n  static void _scheduleImmediateWithTimer(void callback()) {\n    Timer._createTimer(Duration.ZERO, callback);\n  }\n}\n\n@patch\nclass DeferredLibrary {\n  @patch\n  Future<Null> load() {\n    return loadDeferredLibrary(libraryName, uri);\n  }\n}\n\n@patch\nclass Timer {\n  @patch\n  static Timer _createTimer(Duration duration, void callback()) {\n    int milliseconds = duration.inMilliseconds;\n    if (milliseconds < 0) milliseconds = 0;\n    return new TimerImpl(milliseconds, callback);\n  }\n\n  @patch\n  static Timer _createPeriodicTimer(Duration duration,\n                             void callback(Timer timer)) {\n    int milliseconds = duration.inMilliseconds;\n    if (milliseconds < 0) milliseconds = 0;\n    return new TimerImpl.periodic(milliseconds, callback);\n  }\n}\n\nbool get _hasDocument => JS('String', 'typeof document') == 'object';\n\u0000","sdk:/sdk/lib/_internal/lib/collection_patch.dart":"// Copyright (c) 2013, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n// Patch file for dart:collection classes.\nimport 'dart:_foreign_helper' show JS;\nimport 'dart:_js_helper' show fillLiteralMap, NoInline, patch;\n\n@patch\nclass HashMap<K, V> {\n  @patch\n  factory HashMap({ bool equals(K key1, K key2),\n                    int hashCode(K key),\n                    bool isValidKey(potentialKey) }) {\n    if (isValidKey == null) {\n      if (hashCode == null) {\n        if (equals == null) {\n          return new _HashMap<K, V>();\n        }\n        hashCode = _defaultHashCode;\n      } else {\n        if (identical(identityHashCode, hashCode) &&\n            identical(identical, equals)) {\n          return new _IdentityHashMap<K, V>();\n        }\n        if (equals == null) {\n          equals = _defaultEquals;\n        }\n      }\n    } else {\n      if (hashCode == null) {\n        hashCode = _defaultHashCode;\n      }\n      if (equals == null) {\n        equals = _defaultEquals;\n      }\n    }\n    return new _CustomHashMap<K, V>(equals, hashCode, isValidKey);\n  }\n\n  @patch\n  factory HashMap.identity() = _IdentityHashMap<K, V>;\n}\n\nclass _HashMap<K, V> implements HashMap<K, V> {\n  int _length = 0;\n\n  // The hash map contents are divided into three parts: one part for\n  // string keys, one for numeric keys, and one for the rest. String\n  // and numeric keys map directly to their values, but the rest of\n  // the entries are stored in bucket lists of the form:\n  //\n  //    [key-0, value-0, key-1, value-1, ...]\n  //\n  // where all keys in the same bucket share the same hash code.\n  var _strings;\n  var _nums;\n  var _rest;\n\n  // When iterating over the hash map, it is very convenient to have a\n  // list of all the keys. We cache that on the instance and clear the\n  // the cache whenever the key set changes. This is also used to\n  // guard against concurrent modifications.\n  List _keys;\n\n  _HashMap();\n\n\n  int get length => _length;\n  bool get isEmpty => _length == 0;\n  bool get isNotEmpty => !isEmpty;\n\n  Iterable<K> get keys {\n    return new HashMapKeyIterable<K>(this);\n  }\n\n  Iterable<V> get values {\n    return new MappedIterable<K, V>(keys, (each) => this[each]);\n  }\n\n  bool containsKey(Object key) {\n    if (_isStringKey(key)) {\n      var strings = _strings;\n      return (strings == null) ? false : _hasTableEntry(strings, key);\n    } else if (_isNumericKey(key)) {\n      var nums = _nums;\n      return (nums == null) ? false : _hasTableEntry(nums, key);\n    } else {\n      return _containsKey(key);\n    }\n  }\n\n  bool _containsKey(Object key) {\n    var rest = _rest;\n    if (rest == null) return false;\n    var bucket = _getBucket(rest, key);\n    return _findBucketIndex(bucket, key) >= 0;\n  }\n\n  bool containsValue(Object value) {\n    return _computeKeys().any((each) => this[each] == value);\n  }\n\n  void addAll(Map<K, V> other) {\n    other.forEach((K key, V value) {\n      this[key] = value;\n    });\n  }\n\n  V operator[](Object key) {\n    if (_isStringKey(key)) {\n      var strings = _strings;\n      return (strings == null) ? null : _getTableEntry(strings, key);\n    } else if (_isNumericKey(key)) {\n      var nums = _nums;\n      return (nums == null) ? null : _getTableEntry(nums, key);\n    } else {\n      return _get(key);\n    }\n  }\n\n  V _get(Object key) {\n    var rest = _rest;\n    if (rest == null) return null;\n    var bucket = _getBucket(rest, key);\n    int index = _findBucketIndex(bucket, key);\n    return (index < 0) ? null : JS('var', '#[#]', bucket, index + 1);\n  }\n\n  void operator[]=(K key, V value) {\n    if (_isStringKey(key)) {\n      var strings = _strings;\n      if (strings == null) _strings = strings = _newHashTable();\n      _addHashTableEntry(strings, key, value);\n    } else if (_isNumericKey(key)) {\n      var nums = _nums;\n      if (nums == null) _nums = nums = _newHashTable();\n      _addHashTableEntry(nums, key, value);\n    } else {\n      _set(key, value);\n    }\n  }\n\n  void _set(K key, V value) {\n    var rest = _rest;\n    if (rest == null) _rest = rest = _newHashTable();\n    var hash = _computeHashCode(key);\n    var bucket = JS('var', '#[#]', rest, hash);\n    if (bucket == null) {\n      _setTableEntry(rest, hash, JS('var', '[#, #]', key, value));\n      _length++;\n      _keys = null;\n    } else {\n      int index = _findBucketIndex(bucket, key);\n      if (index >= 0) {\n        JS('void', '#[#] = #', bucket, index + 1, value);\n      } else {\n        JS('void', '#.push(#, #)', bucket, key, value);\n        _length++;\n        _keys = null;\n      }\n    }\n  }\n\n  V putIfAbsent(K key, V ifAbsent()) {\n    if (containsKey(key)) return this[key];\n    V value = ifAbsent();\n    this[key] = value;\n    return value;\n  }\n\n  V remove(Object key) {\n    if (_isStringKey(key)) {\n      return _removeHashTableEntry(_strings, key);\n    } else if (_isNumericKey(key)) {\n      return _removeHashTableEntry(_nums, key);\n    } else {\n      return _remove(key);\n    }\n  }\n\n  V _remove(Object key) {\n    var rest = _rest;\n    if (rest == null) return null;\n    var bucket = _getBucket(rest, key);\n    int index = _findBucketIndex(bucket, key);\n    if (index < 0) return null;\n    // TODO(kasperl): Consider getting rid of the bucket list when\n    // the length reaches zero.\n    _length--;\n    _keys = null;\n    // Use splice to remove the two [key, value] elements at the\n    // index and return the value.\n    return JS('var', '#.splice(#, 2)[1]', bucket, index);\n  }\n\n  void clear() {\n    if (_length > 0) {\n      _strings = _nums = _rest = _keys = null;\n      _length = 0;\n    }\n  }\n\n  void forEach(void action(K key, V value)) {\n    List keys = _computeKeys();\n    for (int i = 0, length = keys.length; i < length; i++) {\n      var key = JS('var', '#[#]', keys, i);\n      action(key, this[key]);\n      if (JS('bool', '# !== #', keys, _keys)) {\n        throw new ConcurrentModificationError(this);\n      }\n    }\n  }\n\n  List _computeKeys() {\n    if (_keys != null) return _keys;\n    List result = new List(_length);\n    int index = 0;\n\n    // Add all string keys to the list.\n    var strings = _strings;\n    if (strings != null) {\n      var names = JS('var', 'Object.getOwnPropertyNames(#)', strings);\n      int entries = JS('int', '#.length', names);\n      for (int i = 0; i < entries; i++) {\n        String key = JS('String', '#[#]', names, i);\n        JS('void', '#[#] = #', result, index, key);\n        index++;\n      }\n    }\n\n    // Add all numeric keys to the list.\n    var nums = _nums;\n    if (nums != null) {\n      var names = JS('var', 'Object.getOwnPropertyNames(#)', nums);\n      int entries = JS('int', '#.length', names);\n      for (int i = 0; i < entries; i++) {\n        // Object.getOwnPropertyNames returns a list of strings, so we\n        // have to convert the keys back to numbers (+).\n        num key = JS('num', '+#[#]', names, i);\n        JS('void', '#[#] = #', result, index, key);\n        index++;\n      }\n    }\n\n    // Add all the remaining keys to the list.\n    var rest = _rest;\n    if (rest != null) {\n      var names = JS('var', 'Object.getOwnPropertyNames(#)', rest);\n      int entries = JS('int', '#.length', names);\n      for (int i = 0; i < entries; i++) {\n        var key = JS('String', '#[#]', names, i);\n        var bucket = JS('var', '#[#]', rest, key);\n        int length = JS('int', '#.length', bucket);\n        for (int i = 0; i < length; i += 2) {\n          var key = JS('var', '#[#]', bucket, i);\n          JS('void', '#[#] = #', result, index, key);\n          index++;\n        }\n      }\n    }\n    assert(index == _length);\n    return _keys = result;\n  }\n\n  void _addHashTableEntry(var table, K key, V value) {\n    if (!_hasTableEntry(table, key)) {\n      _length++;\n      _keys = null;\n    }\n    _setTableEntry(table, key, value);\n  }\n\n  V _removeHashTableEntry(var table, Object key) {\n    if (table != null && _hasTableEntry(table, key)) {\n      V value = _getTableEntry(table, key);\n      _deleteTableEntry(table, key);\n      _length--;\n      _keys = null;\n      return value;\n    } else {\n      return null;\n    }\n  }\n\n  static bool _isStringKey(var key) {\n    return key is String && key != '__proto__';\n  }\n\n  static bool _isNumericKey(var key) {\n    // Only treat unsigned 30-bit integers as numeric keys. This way,\n    // we avoid converting them to strings when we use them as keys in\n    // the JavaScript hash table object.\n    return key is num && JS('bool', '(# & 0x3ffffff) === #', key, key);\n  }\n\n  int _computeHashCode(var key) {\n    // We force the hash codes to be unsigned 30-bit integers to avoid\n    // issues with problematic keys like '__proto__'. Another option\n    // would be to throw an exception if the hash code isn't a number.\n    return JS('int', '# & 0x3ffffff', key.hashCode);\n  }\n\n  static bool _hasTableEntry(var table, var key) {\n    var entry = JS('var', '#[#]', table, key);\n    // We take care to only store non-null entries in the table, so we\n    // can check if the table has an entry for the given key with a\n    // simple null check.\n    return entry != null;\n  }\n\n  static _getTableEntry(var table, var key) {\n    var entry = JS('var', '#[#]', table, key);\n    // We store the table itself as the entry to signal that it really\n    // is a null value, so we have to map back to null here.\n    return JS('bool', '# === #', entry, table) ? null : entry;\n  }\n\n  static void _setTableEntry(var table, var key, var value) {\n    // We only store non-null entries in the table, so we have to\n    // change null values to refer to the table itself. Such values\n    // will be recognized and mapped back to null on access.\n    if (value == null) {\n      // Do not update [value] with [table], otherwise our\n      // optimizations could be confused by this opaque object being\n      // now used for more things than storing and fetching from it.\n      JS('void', '#[#] = #', table, key, table);\n    } else {\n      JS('void', '#[#] = #', table, key, value);\n    }\n  }\n\n  static void _deleteTableEntry(var table, var key) {\n    JS('void', 'delete #[#]', table, key);\n  }\n\n  List _getBucket(var table, var key) {\n    var hash = _computeHashCode(key);\n    return JS('var', '#[#]', table, hash);\n  }\n\n  int _findBucketIndex(var bucket, var key) {\n    if (bucket == null) return -1;\n    int length = JS('int', '#.length', bucket);\n    for (int i = 0; i < length; i += 2) {\n      if (JS('var', '#[#]', bucket, i) == key) return i;\n    }\n    return -1;\n  }\n\n  static _newHashTable() {\n    // Create a new JavaScript object to be used as a hash table. Use\n    // Object.create to avoid the properties on Object.prototype\n    // showing up as entries.\n    var table = JS('var', 'Object.create(null)');\n    // Attempt to force the hash table into 'dictionary' mode by\n    // adding a property to it and deleting it again.\n    var temporaryKey = '<non-identifier-key>';\n    _setTableEntry(table, temporaryKey, table);\n    _deleteTableEntry(table, temporaryKey);\n    return table;\n  }\n}\n\nclass _IdentityHashMap<K, V> extends _HashMap<K, V> {\n  int _computeHashCode(var key) {\n    // We force the hash codes to be unsigned 30-bit integers to avoid\n    // issues with problematic keys like '__proto__'. Another option\n    // would be to throw an exception if the hash code isn't a number.\n    return JS('int', '# & 0x3ffffff', identityHashCode(key));\n  }\n\n  int _findBucketIndex(var bucket, var key) {\n    if (bucket == null) return -1;\n    int length = JS('int', '#.length', bucket);\n    for (int i = 0; i < length; i += 2) {\n      if (identical(JS('var', '#[#]', bucket, i), key)) return i;\n    }\n    return -1;\n  }\n}\n\nclass _CustomHashMap<K, V> extends _HashMap<K, V> {\n  final _Equality<K> _equals;\n  final _Hasher<K> _hashCode;\n  final _Predicate _validKey;\n  _CustomHashMap(this._equals, this._hashCode, bool validKey(potentialKey))\n      : _validKey = (validKey != null) ? validKey : ((v) => v is K);\n\n  V operator[](Object key) {\n    if (!_validKey(key)) return null;\n    return super._get(key);\n  }\n\n  void operator[]=(K key, V value) {\n    super._set(key, value);\n  }\n\n  bool containsKey(Object key) {\n    if (!_validKey(key)) return false;\n    return super._containsKey(key);\n  }\n\n  V remove(Object key) {\n    if (!_validKey(key)) return null;\n    return super._remove(key);\n  }\n\n  int _computeHashCode(var key) {\n    // We force the hash codes to be unsigned 30-bit integers to avoid\n    // issues with problematic keys like '__proto__'. Another option\n    // would be to throw an exception if the hash code isn't a number.\n    return JS('int', '# & 0x3ffffff', _hashCode(key));\n  }\n\n  int _findBucketIndex(var bucket, var key) {\n    if (bucket == null) return -1;\n    int length = JS('int', '#.length', bucket);\n    for (int i = 0; i < length; i += 2) {\n      if (_equals(JS('var', '#[#]', bucket, i), key)) return i;\n    }\n    return -1;\n  }\n\n  String toString() => Maps.mapToString(this);\n}\n\nclass HashMapKeyIterable<E> extends IterableBase<E>\n                            implements EfficientLength {\n  final _map;\n  HashMapKeyIterable(this._map);\n\n  int get length => _map._length;\n  bool get isEmpty => _map._length == 0;\n\n  Iterator<E> get iterator {\n    return new HashMapKeyIterator<E>(_map, _map._computeKeys());\n  }\n\n  bool contains(Object element) {\n    return _map.containsKey(element);\n  }\n\n  void forEach(void f(E element)) {\n    List keys = _map._computeKeys();\n    for (int i = 0, length = JS('int', '#.length', keys); i < length; i++) {\n      f(JS('var', '#[#]', keys, i));\n      if (JS('bool', '# !== #', keys, _map._keys)) {\n        throw new ConcurrentModificationError(_map);\n      }\n    }\n  }\n}\n\nclass HashMapKeyIterator<E> implements Iterator<E> {\n  final _map;\n  final List _keys;\n  int _offset = 0;\n  E _current;\n\n  HashMapKeyIterator(this._map, this._keys);\n\n  E get current => _current;\n\n  bool moveNext() {\n    var keys = _keys;\n    int offset = _offset;\n    if (JS('bool', '# !== #', keys, _map._keys)) {\n      throw new ConcurrentModificationError(_map);\n    } else if (offset >= JS('int', '#.length', keys)) {\n      _current = null;\n      return false;\n    } else {\n      _current = JS('var', '#[#]', keys, offset);\n      // TODO(kasperl): For now, we have to tell the type inferrer to\n      // treat the result of doing offset + 1 as an int. Otherwise, we\n      // get unnecessary bailout code.\n      _offset = JS('int', '#', offset + 1);\n      return true;\n    }\n  }\n}\n\n@patch\nclass LinkedHashMap<K, V> {\n  @patch\n  factory LinkedHashMap({ bool equals(K key1, K key2),\n                          int hashCode(K key),\n                          bool isValidKey(potentialKey) }) {\n    if (isValidKey == null) {\n      if (hashCode == null) {\n        if (equals == null) {\n          return new _LinkedHashMap<K, V>();\n        }\n        hashCode = _defaultHashCode;\n      } else {\n        if (identical(identityHashCode, hashCode) &&\n            identical(identical, equals)) {\n          return new _LinkedIdentityHashMap<K, V>();\n        }\n        if (equals == null) {\n          equals = _defaultEquals;\n        }\n      }\n    } else {\n      if (hashCode == null) {\n        hashCode = _defaultHashCode;\n      }\n      if (equals == null) {\n        equals = _defaultEquals;\n      }\n    }\n    return new _LinkedCustomHashMap<K, V>(equals, hashCode, isValidKey);\n  }\n\n  @patch\n  factory LinkedHashMap.identity() = _LinkedIdentityHashMap<K, V>;\n\n  // Private factory constructor called by generated code for map literals.\n  @NoInline()\n  factory LinkedHashMap._literal(List keyValuePairs) {\n    return fillLiteralMap(keyValuePairs, new _LinkedHashMap<K, V>());\n  }\n\n  // Private factory constructor called by generated code for map literals.\n  @NoInline()\n  factory LinkedHashMap._empty() {\n    return new _LinkedHashMap<K, V>();\n  }\n}\n\nclass _LinkedHashMap<K, V> implements LinkedHashMap<K, V> {\n  int _length = 0;\n\n  // The hash map contents are divided into three parts: one part for\n  // string keys, one for numeric keys, and one for the rest. String\n  // and numeric keys map directly to their linked cells, but the rest\n  // of the entries are stored in bucket lists of the form:\n  //\n  //    [cell-0, cell-1, ...]\n  //\n  // where all keys in the same bucket share the same hash code.\n  var _strings;\n  var _nums;\n  var _rest;\n\n  // The keys and values are stored in cells that are linked together\n  // to form a double linked list.\n  LinkedHashMapCell _first;\n  LinkedHashMapCell _last;\n\n  // We track the number of modifications done to the key set of the\n  // hash map to be able to throw when the map is modified while being\n  // iterated over.\n  int _modifications = 0;\n\n  _LinkedHashMap();\n\n\n  int get length => _length;\n  bool get isEmpty => _length == 0;\n  bool get isNotEmpty => !isEmpty;\n\n  Iterable<K> get keys {\n    return new LinkedHashMapKeyIterable<K>(this);\n  }\n\n  Iterable<V> get values {\n    return new MappedIterable<K, V>(keys, (each) => this[each]);\n  }\n\n  bool containsKey(Object key) {\n    if (_isStringKey(key)) {\n      var strings = _strings;\n      if (strings == null) return false;\n      LinkedHashMapCell cell = _getTableEntry(strings, key);\n      return cell != null;\n    } else if (_isNumericKey(key)) {\n      var nums = _nums;\n      if (nums == null) return false;\n      LinkedHashMapCell cell = _getTableEntry(nums, key);\n      return cell != null;\n    } else {\n      return _containsKey(key);\n    }\n  }\n\n  bool _containsKey(Object key) {\n    var rest = _rest;\n    if (rest == null) return false;\n    var bucket = _getBucket(rest, key);\n    return _findBucketIndex(bucket, key) >= 0;\n  }\n\n  bool containsValue(Object value) {\n    return keys.any((each) => this[each] == value);\n  }\n\n  void addAll(Map<K, V> other) {\n    other.forEach((K key, V value) {\n      this[key] = value;\n    });\n  }\n\n  V operator[](Object key) {\n    if (_isStringKey(key)) {\n      var strings = _strings;\n      if (strings == null) return null;\n      LinkedHashMapCell cell = _getTableEntry(strings, key);\n      return (cell == null) ? null : cell._value;\n    } else if (_isNumericKey(key)) {\n      var nums = _nums;\n      if (nums == null) return null;\n      LinkedHashMapCell cell = _getTableEntry(nums, key);\n      return (cell == null) ? null : cell._value;\n    } else {\n      return _get(key);\n    }\n  }\n\n  V _get(Object key) {\n    var rest = _rest;\n    if (rest == null) return null;\n    var bucket = _getBucket(rest, key);\n    int index = _findBucketIndex(bucket, key);\n    if (index < 0) return null;\n    LinkedHashMapCell cell = JS('var', '#[#]', bucket, index);\n    return cell._value;\n  }\n\n  void operator[]=(K key, V value) {\n    if (_isStringKey(key)) {\n      var strings = _strings;\n      if (strings == null) _strings = strings = _newHashTable();\n      _addHashTableEntry(strings, key, value);\n    } else if (_isNumericKey(key)) {\n      var nums = _nums;\n      if (nums == null) _nums = nums = _newHashTable();\n      _addHashTableEntry(nums, key, value);\n    } else {\n      _set(key, value);\n    }\n  }\n\n  void _set(K key, V value) {\n    var rest = _rest;\n    if (rest == null) _rest = rest = _newHashTable();\n    var hash = _computeHashCode(key);\n    var bucket = JS('var', '#[#]', rest, hash);\n    if (bucket == null) {\n      LinkedHashMapCell cell = _newLinkedCell(key, value);\n      _setTableEntry(rest, hash, JS('var', '[#]', cell));\n    } else {\n      int index = _findBucketIndex(bucket, key);\n      if (index >= 0) {\n        LinkedHashMapCell cell = JS('var', '#[#]', bucket, index);\n        cell._value = value;\n      } else {\n        LinkedHashMapCell cell = _newLinkedCell(key, value);\n        JS('void', '#.push(#)', bucket, cell);\n      }\n    }\n  }\n\n  V putIfAbsent(K key, V ifAbsent()) {\n    if (containsKey(key)) return this[key];\n    V value = ifAbsent();\n    this[key] = value;\n    return value;\n  }\n\n  V remove(Object key) {\n    if (_isStringKey(key)) {\n      return _removeHashTableEntry(_strings, key);\n    } else if (_isNumericKey(key)) {\n      return _removeHashTableEntry(_nums, key);\n    } else {\n      return _remove(key);\n    }\n  }\n\n  V _remove(Object key) {\n    var rest = _rest;\n    if (rest == null) return null;\n    var bucket = _getBucket(rest, key);\n    int index = _findBucketIndex(bucket, key);\n    if (index < 0) return null;\n    // Use splice to remove the [cell] element at the index and\n    // unlink the cell before returning its value.\n    LinkedHashMapCell cell = JS('var', '#.splice(#, 1)[0]', bucket, index);\n    _unlinkCell(cell);\n    // TODO(kasperl): Consider getting rid of the bucket list when\n    // the length reaches zero.\n    return cell._value;\n  }\n\n  void clear() {\n    if (_length > 0) {\n      _strings = _nums = _rest = _first = _last = null;\n      _length = 0;\n      _modified();\n    }\n  }\n\n  void forEach(void action(K key, V value)) {\n    LinkedHashMapCell cell = _first;\n    int modifications = _modifications;\n    while (cell != null) {\n      action(cell._key, cell._value);\n      if (modifications != _modifications) {\n        throw new ConcurrentModificationError(this);\n      }\n      cell = cell._next;\n    }\n  }\n\n  void _addHashTableEntry(var table, K key, V value) {\n    LinkedHashMapCell cell = _getTableEntry(table, key);\n    if (cell == null) {\n      _setTableEntry(table, key, _newLinkedCell(key, value));\n    } else {\n      cell._value = value;\n    }\n  }\n\n  V _removeHashTableEntry(var table, Object key) {\n    if (table == null) return null;\n    LinkedHashMapCell cell = _getTableEntry(table, key);\n    if (cell == null) return null;\n    _unlinkCell(cell);\n    _deleteTableEntry(table, key);\n    return cell._value;\n  }\n\n  void _modified() {\n    // Value cycles after 2^30 modifications. If you keep hold of an\n    // iterator for that long, you might miss a modification\n    // detection, and iteration can go sour. Don't do that.\n    _modifications = (_modifications + 1) & 0x3ffffff;\n  }\n\n  // Create a new cell and link it in as the last one in the list.\n  LinkedHashMapCell _newLinkedCell(K key, V value) {\n    LinkedHashMapCell cell = new LinkedHashMapCell(key, value);\n    if (_first == null) {\n      _first = _last = cell;\n    } else {\n      LinkedHashMapCell last = _last;\n      cell._previous = last;\n      _last = last._next = cell;\n    }\n    _length++;\n    _modified();\n    return cell;\n  }\n\n  // Unlink the given cell from the linked list of cells.\n  void _unlinkCell(LinkedHashMapCell cell) {\n    LinkedHashMapCell previous = cell._previous;\n    LinkedHashMapCell next = cell._next;\n    if (previous == null) {\n      assert(cell == _first);\n      _first = next;\n    } else {\n      previous._next = next;\n    }\n    if (next == null) {\n      assert(cell == _last);\n      _last = previous;\n    } else {\n      next._previous = previous;\n    }\n    _length--;\n    _modified();\n  }\n\n  static bool _isStringKey(var key) {\n    return key is String && key != '__proto__';\n  }\n\n  static bool _isNumericKey(var key) {\n    // Only treat unsigned 30-bit integers as numeric keys. This way,\n    // we avoid converting them to strings when we use them as keys in\n    // the JavaScript hash table object.\n    return key is num && JS('bool', '(# & 0x3ffffff) === #', key, key);\n  }\n\n  int _computeHashCode(var key) {\n    // We force the hash codes to be unsigned 30-bit integers to avoid\n    // issues with problematic keys like '__proto__'. Another option\n    // would be to throw an exception if the hash code isn't a number.\n    return JS('int', '# & 0x3ffffff', key.hashCode);\n  }\n\n  static _getTableEntry(var table, var key) {\n    return JS('var', '#[#]', table, key);\n  }\n\n  static void _setTableEntry(var table, var key, var value) {\n    assert(value != null);\n    JS('void', '#[#] = #', table, key, value);\n  }\n\n  static void _deleteTableEntry(var table, var key) {\n    JS('void', 'delete #[#]', table, key);\n  }\n\n  List _getBucket(var table, var key) {\n    var hash = _computeHashCode(key);\n    return JS('var', '#[#]', table, hash);\n  }\n\n  int _findBucketIndex(var bucket, var key) {\n    if (bucket == null) return -1;\n    int length = JS('int', '#.length', bucket);\n    for (int i = 0; i < length; i++) {\n      LinkedHashMapCell cell = JS('var', '#[#]', bucket, i);\n      if (cell._key == key) return i;\n    }\n    return -1;\n  }\n\n  static _newHashTable() {\n    // Create a new JavaScript object to be used as a hash table. Use\n    // Object.create to avoid the properties on Object.prototype\n    // showing up as entries.\n    var table = JS('var', 'Object.create(null)');\n    // Attempt to force the hash table into 'dictionary' mode by\n    // adding a property to it and deleting it again.\n    var temporaryKey = '<non-identifier-key>';\n    _setTableEntry(table, temporaryKey, table);\n    _deleteTableEntry(table, temporaryKey);\n    return table;\n  }\n\n  String toString() => Maps.mapToString(this);\n}\n\nclass _LinkedIdentityHashMap<K, V> extends _LinkedHashMap<K, V> {\n  int _computeHashCode(var key) {\n    // We force the hash codes to be unsigned 30-bit integers to avoid\n    // issues with problematic keys like '__proto__'. Another option\n    // would be to throw an exception if the hash code isn't a number.\n    return JS('int', '# & 0x3ffffff', identityHashCode(key));\n  }\n\n  int _findBucketIndex(var bucket, var key) {\n    if (bucket == null) return -1;\n    int length = JS('int', '#.length', bucket);\n    for (int i = 0; i < length; i++) {\n      LinkedHashMapCell cell = JS('var', '#[#]', bucket, i);\n      if (identical(cell._key, key)) return i;\n    }\n    return -1;\n  }\n}\n\nclass _LinkedCustomHashMap<K, V> extends _LinkedHashMap<K, V> {\n  final _Equality<K> _equals;\n  final _Hasher<K> _hashCode;\n  final _Predicate _validKey;\n  _LinkedCustomHashMap(this._equals, this._hashCode,\n                       bool validKey(potentialKey))\n      : _validKey = (validKey != null) ? validKey : ((v) => v is K);\n\n  V operator[](Object key) {\n    if (!_validKey(key)) return null;\n    return super._get(key);\n  }\n\n  void operator[]=(K key, V value) {\n    super._set(key, value);\n  }\n\n  bool containsKey(Object key) {\n    if (!_validKey(key)) return false;\n    return super._containsKey(key);\n  }\n\n  V remove(Object key) {\n    if (!_validKey(key)) return null;\n    return super._remove(key);\n  }\n\n  int _computeHashCode(var key) {\n    // We force the hash codes to be unsigned 30-bit integers to avoid\n    // issues with problematic keys like '__proto__'. Another option\n    // would be to throw an exception if the hash code isn't a number.\n    return JS('int', '# & 0x3ffffff', _hashCode(key));\n  }\n\n  int _findBucketIndex(var bucket, var key) {\n    if (bucket == null) return -1;\n    int length = JS('int', '#.length', bucket);\n    for (int i = 0; i < length; i++) {\n      LinkedHashMapCell cell = JS('var', '#[#]', bucket, i);\n      if (_equals(cell._key, key)) return i;\n    }\n    return -1;\n  }\n}\n\nclass LinkedHashMapCell {\n  final _key;\n  var _value;\n\n  LinkedHashMapCell _next;\n  LinkedHashMapCell _previous;\n\n  LinkedHashMapCell(this._key, this._value);\n}\n\nclass LinkedHashMapKeyIterable<E> extends IterableBase<E>\n                                  implements EfficientLength {\n  final _map;\n  LinkedHashMapKeyIterable(this._map);\n\n  int get length => _map._length;\n  bool get isEmpty => _map._length == 0;\n\n  Iterator<E> get iterator {\n    return new LinkedHashMapKeyIterator<E>(_map, _map._modifications);\n  }\n\n  bool contains(Object element) {\n    return _map.containsKey(element);\n  }\n\n  void forEach(void f(E element)) {\n    LinkedHashMapCell cell = _map._first;\n    int modifications = _map._modifications;\n    while (cell != null) {\n      f(cell._key);\n      if (modifications != _map._modifications) {\n        throw new ConcurrentModificationError(_map);\n      }\n      cell = cell._next;\n    }\n  }\n}\n\nclass LinkedHashMapKeyIterator<E> implements Iterator<E> {\n  final _map;\n  final int _modifications;\n  LinkedHashMapCell _cell;\n  E _current;\n\n  LinkedHashMapKeyIterator(this._map, this._modifications) {\n    _cell = _map._first;\n  }\n\n  E get current => _current;\n\n  bool moveNext() {\n    if (_modifications != _map._modifications) {\n      throw new ConcurrentModificationError(_map);\n    } else if (_cell == null) {\n      _current = null;\n      return false;\n    } else {\n      _current = _cell._key;\n      _cell = _cell._next;\n      return true;\n    }\n  }\n}\n\n@patch\nclass HashSet<E> {\n  @patch\n  factory HashSet({ bool equals(E e1, E e2),\n                    int hashCode(E e),\n                    bool isValidKey(potentialKey) }) {\n    if (isValidKey == null) {\n      if (hashCode == null) {\n        if (equals == null) {\n          return new _HashSet<E>();\n        }\n        hashCode = _defaultHashCode;\n      } else {\n        if (identical(identityHashCode, hashCode) &&\n            identical(identical, equals)) {\n          return new _IdentityHashSet<E>();\n        }\n        if (equals == null) {\n          equals = _defaultEquals;\n        }\n      }\n    } else {\n      if (hashCode == null) {\n        hashCode = _defaultHashCode;\n      }\n      if (equals == null) {\n        equals = _defaultEquals;\n      }\n    }\n    return new _CustomHashSet<E>(equals, hashCode, isValidKey);\n  }\n\n  @patch\n  factory HashSet.identity() = _IdentityHashSet<E>;\n}\n\nclass _HashSet<E> extends _HashSetBase<E> implements HashSet<E> {\n  int _length = 0;\n\n  // The hash set contents are divided into three parts: one part for\n  // string elements, one for numeric elements, and one for the\n  // rest. String and numeric elements map directly to a sentinel\n  // value, but the rest of the entries are stored in bucket lists of\n  // the form:\n  //\n  //    [element-0, element-1, element-2, ...]\n  //\n  // where all elements in the same bucket share the same hash code.\n  var _strings;\n  var _nums;\n  var _rest;\n\n  // When iterating over the hash set, it is very convenient to have a\n  // list of all the elements. We cache that on the instance and clear\n  // the the cache whenever the set changes. This is also used to\n  // guard against concurrent modifications.\n  List _elements;\n\n  _HashSet();\n\n  Set<E> _newSet() => new _HashSet<E>();\n\n  // Iterable.\n  Iterator<E> get iterator {\n    return new HashSetIterator<E>(this, _computeElements());\n  }\n\n  int get length => _length;\n  bool get isEmpty => _length == 0;\n  bool get isNotEmpty => !isEmpty;\n\n  bool contains(Object object) {\n    if (_isStringElement(object)) {\n      var strings = _strings;\n      return (strings == null) ? false : _hasTableEntry(strings, object);\n    } else if (_isNumericElement(object)) {\n      var nums = _nums;\n      return (nums == null) ? false : _hasTableEntry(nums, object);\n    } else {\n      return _contains(object);\n    }\n  }\n\n  bool _contains(Object object) {\n    var rest = _rest;\n    if (rest == null) return false;\n    var bucket = _getBucket(rest, object);\n    return _findBucketIndex(bucket, object) >= 0;\n  }\n\n  E lookup(Object object) {\n    if (_isStringElement(object) || _isNumericElement(object)) {\n      return this.contains(object) ? object : null;\n    }\n    return _lookup(object);\n  }\n\n  E _lookup(Object object) {\n    var rest = _rest;\n    if (rest == null) return null;\n    var bucket = _getBucket(rest, object);\n    var index = _findBucketIndex(bucket, object);\n    if (index < 0) return null;\n    return bucket[index];\n  }\n\n  // Collection.\n  bool add(E element) {\n    if (_isStringElement(element)) {\n      var strings = _strings;\n      if (strings == null) _strings = strings = _newHashTable();\n      return _addHashTableEntry(strings, element);\n    } else if (_isNumericElement(element)) {\n      var nums = _nums;\n      if (nums == null) _nums = nums = _newHashTable();\n      return _addHashTableEntry(nums, element);\n    } else {\n      return _add(element);\n    }\n  }\n\n  bool _add(E element) {\n    var rest = _rest;\n    if (rest == null) _rest = rest = _newHashTable();\n    var hash = _computeHashCode(element);\n    var bucket = JS('var', '#[#]', rest, hash);\n    if (bucket == null) {\n      _setTableEntry(rest, hash, JS('var', '[#]', element));\n    } else {\n      int index = _findBucketIndex(bucket, element);\n      if (index >= 0) return false;\n      JS('void', '#.push(#)', bucket, element);\n    }\n    _length++;\n    _elements = null;\n    return true;\n  }\n\n  void addAll(Iterable<E> objects) {\n    for (E each in objects) {\n      add(each);\n    }\n  }\n\n  bool remove(Object object) {\n    if (_isStringElement(object)) {\n      return _removeHashTableEntry(_strings, object);\n    } else if (_isNumericElement(object)) {\n      return _removeHashTableEntry(_nums, object);\n    } else {\n      return _remove(object);\n    }\n  }\n\n  bool _remove(Object object) {\n    var rest = _rest;\n    if (rest == null) return false;\n    var bucket = _getBucket(rest, object);\n    int index = _findBucketIndex(bucket, object);\n    if (index < 0) return false;\n    // TODO(kasperl): Consider getting rid of the bucket list when\n    // the length reaches zero.\n    _length--;\n    _elements = null;\n    // TODO(kasperl): It would probably be faster to move the\n    // element to the end and reduce the length of the bucket list.\n    JS('void', '#.splice(#, 1)', bucket, index);\n    return true;\n  }\n\n  void clear() {\n    if (_length > 0) {\n      _strings = _nums = _rest = _elements = null;\n      _length = 0;\n    }\n  }\n\n  List _computeElements() {\n    if (_elements != null) return _elements;\n    List result = new List(_length);\n    int index = 0;\n\n    // Add all string elements to the list.\n    var strings = _strings;\n    if (strings != null) {\n      var names = JS('var', 'Object.getOwnPropertyNames(#)', strings);\n      int entries = JS('int', '#.length', names);\n      for (int i = 0; i < entries; i++) {\n        String element = JS('String', '#[#]', names, i);\n        JS('void', '#[#] = #', result, index, element);\n        index++;\n      }\n    }\n\n    // Add all numeric elements to the list.\n    var nums = _nums;\n    if (nums != null) {\n      var names = JS('var', 'Object.getOwnPropertyNames(#)', nums);\n      int entries = JS('int', '#.length', names);\n      for (int i = 0; i < entries; i++) {\n        // Object.getOwnPropertyNames returns a list of strings, so we\n        // have to convert the elements back to numbers (+).\n        num element = JS('num', '+#[#]', names, i);\n        JS('void', '#[#] = #', result, index, element);\n        index++;\n      }\n    }\n\n    // Add all the remaining elements to the list.\n    var rest = _rest;\n    if (rest != null) {\n      var names = JS('var', 'Object.getOwnPropertyNames(#)', rest);\n      int entries = JS('int', '#.length', names);\n      for (int i = 0; i < entries; i++) {\n        var entry = JS('String', '#[#]', names, i);\n        var bucket = JS('var', '#[#]', rest, entry);\n        int length = JS('int', '#.length', bucket);\n        for (int i = 0; i < length; i++) {\n          JS('void', '#[#] = #[#]', result, index, bucket, i);\n          index++;\n        }\n      }\n    }\n    assert(index == _length);\n    return _elements = result;\n  }\n\n  bool _addHashTableEntry(var table, E element) {\n    if (_hasTableEntry(table, element)) return false;\n    _setTableEntry(table, element, 0);\n    _length++;\n    _elements = null;\n    return true;\n  }\n\n  bool _removeHashTableEntry(var table, Object element) {\n    if (table != null && _hasTableEntry(table, element)) {\n      _deleteTableEntry(table, element);\n      _length--;\n      _elements = null;\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  static bool _isStringElement(var element) {\n    return element is String && element != '__proto__';\n  }\n\n  static bool _isNumericElement(var element) {\n    // Only treat unsigned 30-bit integers as numeric elements. This\n    // way, we avoid converting them to strings when we use them as\n    // keys in the JavaScript hash table object.\n    return element is num &&\n        JS('bool', '(# & 0x3ffffff) === #', element, element);\n  }\n\n  int _computeHashCode(var element) {\n    // We force the hash codes to be unsigned 30-bit integers to avoid\n    // issues with problematic elements like '__proto__'. Another\n    // option would be to throw an exception if the hash code isn't a\n    // number.\n    return JS('int', '# & 0x3ffffff', element.hashCode);\n  }\n\n  static bool _hasTableEntry(var table, var key) {\n    var entry = JS('var', '#[#]', table, key);\n    // We take care to only store non-null entries in the table, so we\n    // can check if the table has an entry for the given key with a\n    // simple null check.\n    return entry != null;\n  }\n\n  static void _setTableEntry(var table, var key, var value) {\n    assert(value != null);\n    JS('void', '#[#] = #', table, key, value);\n  }\n\n  static void _deleteTableEntry(var table, var key) {\n    JS('void', 'delete #[#]', table, key);\n  }\n\n  List _getBucket(var table, var element) {\n    var hash = _computeHashCode(element);\n    return JS('var', '#[#]', table, hash);\n  }\n\n  int _findBucketIndex(var bucket, var element) {\n    if (bucket == null) return -1;\n    int length = JS('int', '#.length', bucket);\n    for (int i = 0; i < length; i++) {\n      if (JS('var', '#[#]', bucket, i) == element) return i;\n    }\n    return -1;\n  }\n\n  static _newHashTable() {\n    // Create a new JavaScript object to be used as a hash table. Use\n    // Object.create to avoid the properties on Object.prototype\n    // showing up as entries.\n    var table = JS('var', 'Object.create(null)');\n    // Attempt to force the hash table into 'dictionary' mode by\n    // adding a property to it and deleting it again.\n    var temporaryKey = '<non-identifier-key>';\n    _setTableEntry(table, temporaryKey, table);\n    _deleteTableEntry(table, temporaryKey);\n    return table;\n  }\n}\n\nclass _IdentityHashSet<E> extends _HashSet<E> {\n  Set<E> _newSet() => new _IdentityHashSet<E>();\n\n  int _computeHashCode(var key) {\n    // We force the hash codes to be unsigned 30-bit integers to avoid\n    // issues with problematic keys like '__proto__'. Another option\n    // would be to throw an exception if the hash code isn't a number.\n    return JS('int', '# & 0x3ffffff', identityHashCode(key));\n  }\n\n  int _findBucketIndex(var bucket, var element) {\n    if (bucket == null) return -1;\n    int length = JS('int', '#.length', bucket);\n    for (int i = 0; i < length; i++) {\n      if (identical(JS('var', '#[#]', bucket, i), element)) return i;\n    }\n    return -1;\n  }\n}\n\nclass _CustomHashSet<E> extends _HashSet<E> {\n  _Equality<E> _equality;\n  _Hasher<E> _hasher;\n  _Predicate _validKey;\n  _CustomHashSet(this._equality, this._hasher, bool validKey(potentialKey))\n      : _validKey = (validKey != null) ? validKey : ((x) => x is E);\n\n  Set<E> _newSet() => new _CustomHashSet<E>(_equality, _hasher, _validKey);\n\n  int _findBucketIndex(var bucket, var element) {\n    if (bucket == null) return -1;\n    int length = JS('int', '#.length', bucket);\n    for (int i = 0; i < length; i++) {\n      if (_equality(JS('var', '#[#]', bucket, i), element)) return i;\n    }\n    return -1;\n  }\n\n  int _computeHashCode(var element) {\n    // We force the hash codes to be unsigned 30-bit integers to avoid\n    // issues with problematic elements like '__proto__'. Another\n    // option would be to throw an exception if the hash code isn't a\n    // number.\n    return JS('int', '# & 0x3ffffff', _hasher(element));\n  }\n\n  bool add(E object) => super._add(object);\n\n  bool contains(Object object) {\n    if (!_validKey(object)) return false;\n    return super._contains(object);\n  }\n\n  E lookup(Object object) {\n    if (!_validKey(object)) return null;\n    return super._lookup(object);\n  }\n\n  bool remove(Object object) {\n    if (!_validKey(object)) return false;\n    return super._remove(object);\n  }\n}\n\n// TODO(kasperl): Share this code with HashMapKeyIterator<E>?\nclass HashSetIterator<E> implements Iterator<E> {\n  final _set;\n  final List _elements;\n  int _offset = 0;\n  E _current;\n\n  HashSetIterator(this._set, this._elements);\n\n  E get current => _current;\n\n  bool moveNext() {\n    var elements = _elements;\n    int offset = _offset;\n    if (JS('bool', '# !== #', elements, _set._elements)) {\n      throw new ConcurrentModificationError(_set);\n    } else if (offset >= JS('int', '#.length', elements)) {\n      _current = null;\n      return false;\n    } else {\n      _current = JS('var', '#[#]', elements, offset);\n      // TODO(kasperl): For now, we have to tell the type inferrer to\n      // treat the result of doing offset + 1 as an int. Otherwise, we\n      // get unnecessary bailout code.\n      _offset = JS('int', '#', offset + 1);\n      return true;\n    }\n  }\n}\n\n@patch\nclass LinkedHashSet<E> {\n  @patch\n  factory LinkedHashSet({ bool equals(E e1, E e2),\n                          int hashCode(E e),\n                          bool isValidKey(potentialKey) }) {\n    if (isValidKey == null) {\n      if (hashCode == null) {\n        if (equals == null) {\n          return new _LinkedHashSet<E>();\n        }\n        hashCode = _defaultHashCode;\n      } else {\n        if (identical(identityHashCode, hashCode) &&\n            identical(identical, equals)) {\n          return new _LinkedIdentityHashSet<E>();\n        }\n        if (equals == null) {\n          equals = _defaultEquals;\n        }\n      }\n    } else {\n      if (hashCode == null) {\n        hashCode = _defaultHashCode;\n      }\n      if (equals == null) {\n        equals = _defaultEquals;\n      }\n    }\n    return new _LinkedCustomHashSet<E>(equals, hashCode, isValidKey);\n  }\n\n  @patch\n  factory LinkedHashSet.identity() = _LinkedIdentityHashSet<E>;\n}\n\nclass _LinkedHashSet<E> extends _HashSetBase<E> implements LinkedHashSet<E> {\n  int _length = 0;\n\n  // The hash set contents are divided into three parts: one part for\n  // string elements, one for numeric elements, and one for the\n  // rest. String and numeric elements map directly to their linked\n  // cells, but the rest of the entries are stored in bucket lists of\n  // the form:\n  //\n  //    [cell-0, cell-1, ...]\n  //\n  // where all elements in the same bucket share the same hash code.\n  var _strings;\n  var _nums;\n  var _rest;\n\n  // The elements are stored in cells that are linked together\n  // to form a double linked list.\n  LinkedHashSetCell _first;\n  LinkedHashSetCell _last;\n\n  // We track the number of modifications done to the element set to\n  // be able to throw when the set is modified while being iterated\n  // over.\n  int _modifications = 0;\n\n  _LinkedHashSet();\n\n  Set<E> _newSet() => new _LinkedHashSet<E>();\n\n  void _unsupported(String operation) {\n    throw 'LinkedHashSet: unsupported $operation';\n  }\n\n  // Iterable.\n  Iterator<E> get iterator {\n    return new LinkedHashSetIterator(this, _modifications);\n  }\n\n  int get length => _length;\n  bool get isEmpty => _length == 0;\n  bool get isNotEmpty => !isEmpty;\n\n  bool contains(Object object) {\n    if (_isStringElement(object)) {\n      var strings = _strings;\n      if (strings == null) return false;\n      LinkedHashSetCell cell = _getTableEntry(strings, object);\n      return cell != null;\n    } else if (_isNumericElement(object)) {\n      var nums = _nums;\n      if (nums == null) return false;\n      LinkedHashSetCell cell = _getTableEntry(nums, object);\n      return cell != null;\n    } else {\n      return _contains(object);\n    }\n  }\n\n  bool _contains(Object object) {\n    var rest = _rest;\n    if (rest == null) return false;\n    var bucket = _getBucket(rest, object);\n    return _findBucketIndex(bucket, object) >= 0;\n  }\n\n  E lookup(Object object) {\n    if (_isStringElement(object) || _isNumericElement(object)) {\n      return this.contains(object) ? object : null;\n    } else {\n      return _lookup(object);\n    }\n  }\n\n  E _lookup(Object object) {\n    var rest = _rest;\n    if (rest == null) return null;\n    var bucket = _getBucket(rest, object);\n    var index = _findBucketIndex(bucket, object);\n    if (index < 0) return null;\n    return bucket[index]._element;\n  }\n\n  void forEach(void action(E element)) {\n    LinkedHashSetCell cell = _first;\n    int modifications = _modifications;\n    while (cell != null) {\n      action(cell._element);\n      if (modifications != _modifications) {\n        throw new ConcurrentModificationError(this);\n      }\n      cell = cell._next;\n    }\n  }\n\n  E get first {\n    if (_first == null) throw new StateError(\"No elements\");\n    return _first._element;\n  }\n\n  E get last {\n    if (_last == null) throw new StateError(\"No elements\");\n    return _last._element;\n  }\n\n  // Collection.\n  bool add(E element) {\n    if (_isStringElement(element)) {\n      var strings = _strings;\n      if (strings == null) _strings = strings = _newHashTable();\n      return _addHashTableEntry(strings, element);\n    } else if (_isNumericElement(element)) {\n      var nums = _nums;\n      if (nums == null) _nums = nums = _newHashTable();\n      return _addHashTableEntry(nums, element);\n    } else {\n      return _add(element);\n    }\n  }\n\n  bool _add(E element) {\n    var rest = _rest;\n    if (rest == null) _rest = rest = _newHashTable();\n    var hash = _computeHashCode(element);\n    var bucket = JS('var', '#[#]', rest, hash);\n    if (bucket == null) {\n      LinkedHashSetCell cell = _newLinkedCell(element);\n      _setTableEntry(rest, hash, JS('var', '[#]', cell));\n    } else {\n      int index = _findBucketIndex(bucket, element);\n      if (index >= 0) return false;\n      LinkedHashSetCell cell = _newLinkedCell(element);\n      JS('void', '#.push(#)', bucket, cell);\n    }\n    return true;\n  }\n\n  bool remove(Object object) {\n    if (_isStringElement(object)) {\n      return _removeHashTableEntry(_strings, object);\n    } else if (_isNumericElement(object)) {\n      return _removeHashTableEntry(_nums, object);\n    } else {\n      return _remove(object);\n    }\n  }\n\n  bool _remove(Object object) {\n    var rest = _rest;\n    if (rest == null) return false;\n    var bucket = _getBucket(rest, object);\n    int index = _findBucketIndex(bucket, object);\n    if (index < 0) return false;\n    // Use splice to remove the [cell] element at the index and\n    // unlink it.\n    LinkedHashSetCell cell = JS('var', '#.splice(#, 1)[0]', bucket, index);\n    _unlinkCell(cell);\n    return true;\n  }\n\n  void removeWhere(bool test(E element)) {\n    _filterWhere(test, true);\n  }\n\n  void retainWhere(bool test(E element)) {\n    _filterWhere(test, false);\n  }\n\n  void _filterWhere(bool test(E element), bool removeMatching) {\n    LinkedHashSetCell cell = _first;\n    while (cell != null) {\n      E element = cell._element;\n      LinkedHashSetCell next = cell._next;\n      int modifications = _modifications;\n      bool shouldRemove = (removeMatching == test(element));\n      if (modifications != _modifications) {\n        throw new ConcurrentModificationError(this);\n      }\n      if (shouldRemove) remove(element);\n      cell = next;\n    }\n  }\n\n  void clear() {\n    if (_length > 0) {\n      _strings = _nums = _rest = _first = _last = null;\n      _length = 0;\n      _modified();\n    }\n  }\n\n  bool _addHashTableEntry(var table, E element) {\n    LinkedHashSetCell cell = _getTableEntry(table, element);\n    if (cell != null) return false;\n    _setTableEntry(table, element, _newLinkedCell(element));\n    return true;\n  }\n\n  bool _removeHashTableEntry(var table, Object element) {\n    if (table == null) return false;\n    LinkedHashSetCell cell = _getTableEntry(table, element);\n    if (cell == null) return false;\n    _unlinkCell(cell);\n    _deleteTableEntry(table, element);\n    return true;\n  }\n\n  void _modified() {\n    // Value cycles after 2^30 modifications. If you keep hold of an\n    // iterator for that long, you might miss a modification\n    // detection, and iteration can go sour. Don't do that.\n    _modifications = (_modifications + 1) & 0x3ffffff;\n  }\n\n  // Create a new cell and link it in as the last one in the list.\n  LinkedHashSetCell _newLinkedCell(E element) {\n    LinkedHashSetCell cell = new LinkedHashSetCell(element);\n    if (_first == null) {\n      _first = _last = cell;\n    } else {\n      LinkedHashSetCell last = _last;\n      cell._previous = last;\n      _last = last._next = cell;\n    }\n    _length++;\n    _modified();\n    return cell;\n  }\n\n  // Unlink the given cell from the linked list of cells.\n  void _unlinkCell(LinkedHashSetCell cell) {\n    LinkedHashSetCell previous = cell._previous;\n    LinkedHashSetCell next = cell._next;\n    if (previous == null) {\n      assert(cell == _first);\n      _first = next;\n    } else {\n      previous._next = next;\n    }\n    if (next == null) {\n      assert(cell == _last);\n      _last = previous;\n    } else {\n      next._previous = previous;\n    }\n    _length--;\n    _modified();\n  }\n\n  static bool _isStringElement(var element) {\n    return element is String && element != '__proto__';\n  }\n\n  static bool _isNumericElement(var element) {\n    // Only treat unsigned 30-bit integers as numeric elements. This\n    // way, we avoid converting them to strings when we use them as\n    // keys in the JavaScript hash table object.\n    return element is num &&\n        JS('bool', '(# & 0x3ffffff) === #', element, element);\n  }\n\n  int _computeHashCode(var element) {\n    // We force the hash codes to be unsigned 30-bit integers to avoid\n    // issues with problematic elements like '__proto__'. Another\n    // option would be to throw an exception if the hash code isn't a\n    // number.\n    return JS('int', '# & 0x3ffffff', element.hashCode);\n  }\n\n  static _getTableEntry(var table, var key) {\n    return JS('var', '#[#]', table, key);\n  }\n\n  static void _setTableEntry(var table, var key, var value) {\n    assert(value != null);\n    JS('void', '#[#] = #', table, key, value);\n  }\n\n  static void _deleteTableEntry(var table, var key) {\n    JS('void', 'delete #[#]', table, key);\n  }\n\n  List _getBucket(var table, var element) {\n    var hash = _computeHashCode(element);\n    return JS('var', '#[#]', table, hash);\n  }\n\n  int _findBucketIndex(var bucket, var element) {\n    if (bucket == null) return -1;\n    int length = JS('int', '#.length', bucket);\n    for (int i = 0; i < length; i++) {\n      LinkedHashSetCell cell = JS('var', '#[#]', bucket, i);\n      if (cell._element == element) return i;\n    }\n    return -1;\n  }\n\n  static _newHashTable() {\n    // Create a new JavaScript object to be used as a hash table. Use\n    // Object.create to avoid the properties on Object.prototype\n    // showing up as entries.\n    var table = JS('var', 'Object.create(null)');\n    // Attempt to force the hash table into 'dictionary' mode by\n    // adding a property to it and deleting it again.\n    var temporaryKey = '<non-identifier-key>';\n    _setTableEntry(table, temporaryKey, table);\n    _deleteTableEntry(table, temporaryKey);\n    return table;\n  }\n}\n\nclass _LinkedIdentityHashSet<E> extends _LinkedHashSet<E> {\n  Set<E> _newSet() => new _LinkedIdentityHashSet<E>();\n\n  int _computeHashCode(var key) {\n    // We force the hash codes to be unsigned 30-bit integers to avoid\n    // issues with problematic keys like '__proto__'. Another option\n    // would be to throw an exception if the hash code isn't a number.\n    return JS('int', '# & 0x3ffffff', identityHashCode(key));\n  }\n\n  int _findBucketIndex(var bucket, var element) {\n    if (bucket == null) return -1;\n    int length = JS('int', '#.length', bucket);\n    for (int i = 0; i < length; i++) {\n      LinkedHashSetCell cell = JS('var', '#[#]', bucket, i);\n      if (identical(cell._element, element)) return i;\n    }\n    return -1;\n  }\n}\n\nclass _LinkedCustomHashSet<E> extends _LinkedHashSet<E> {\n  _Equality<E> _equality;\n  _Hasher<E> _hasher;\n  _Predicate _validKey;\n  _LinkedCustomHashSet(this._equality, this._hasher,\n                       bool validKey(potentialKey))\n      : _validKey = (validKey != null) ? validKey : ((x) => x is E);\n\n  Set<E> _newSet() =>\n      new _LinkedCustomHashSet<E>(_equality, _hasher, _validKey);\n\n  int _findBucketIndex(var bucket, var element) {\n    if (bucket == null) return -1;\n    int length = JS('int', '#.length', bucket);\n    for (int i = 0; i < length; i++) {\n      LinkedHashSetCell cell = JS('var', '#[#]', bucket, i);\n      if (_equality(cell._element, element)) return i;\n    }\n    return -1;\n  }\n\n  int _computeHashCode(var element) {\n    // We force the hash codes to be unsigned 30-bit integers to avoid\n    // issues with problematic elements like '__proto__'. Another\n    // option would be to throw an exception if the hash code isn't a\n    // number.\n    return JS('int', '# & 0x3ffffff', _hasher(element));\n  }\n\n  bool add(E element) => super._add(element);\n\n  bool contains(Object object) {\n    if (!_validKey(object)) return false;\n    return super._contains(object);\n  }\n\n  E lookup(Object object) {\n    if (!_validKey(object)) return null;\n    return super._lookup(object);\n  }\n\n  bool remove(Object object) {\n    if (!_validKey(object)) return false;\n    return super._remove(object);\n  }\n\n  bool containsAll(Iterable<Object> elements) {\n    for (Object element in elements) {\n      if (!_validKey(element) || !this.contains(element)) return false;\n    }\n    return true;\n  }\n\n  void removeAll(Iterable<Object> elements) {\n    for (Object element in elements) {\n      if (_validKey(element)) {\n        super._remove(element);\n      }\n    }\n  }\n}\n\nclass LinkedHashSetCell {\n  final _element;\n\n  LinkedHashSetCell _next;\n  LinkedHashSetCell _previous;\n\n  LinkedHashSetCell(this._element);\n}\n\n// TODO(kasperl): Share this code with LinkedHashMapKeyIterator<E>?\nclass LinkedHashSetIterator<E> implements Iterator<E> {\n  final _set;\n  final int _modifications;\n  LinkedHashSetCell _cell;\n  E _current;\n\n  LinkedHashSetIterator(this._set, this._modifications) {\n    _cell = _set._first;\n  }\n\n  E get current => _current;\n\n  bool moveNext() {\n    if (_modifications != _set._modifications) {\n      throw new ConcurrentModificationError(_set);\n    } else if (_cell == null) {\n      _current = null;\n      return false;\n    } else {\n      _current = _cell._element;\n      _cell = _cell._next;\n      return true;\n    }\n  }\n}\n\u0000","sdk:/sdk/lib/_internal/lib/convert_patch.dart":"// Copyright (c) 2013, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n// Patch file for dart:convert library.\n\nimport 'dart:_js_helper' show patch;\nimport 'dart:_foreign_helper' show JS;\nimport 'dart:_interceptors' show JSExtendableArray;\nimport 'dart:_internal' show MappedIterable;\nimport 'dart:collection' show Maps, LinkedHashMap;\n\n/**\n * Parses [json] and builds the corresponding parsed JSON value.\n *\n * Parsed JSON values Nare of the types [num], [String], [bool], [Null],\n * [List]s of parsed JSON values or [Map]s from [String] to parsed\n * JSON values.\n *\n * The optional [reviver] function, if provided, is called once for each object\n * or list property parsed. The arguments are the property name ([String]) or\n * list index ([int]), and the value is the parsed value.  The return value of\n * the reviver will be used as the value of that property instead of the parsed\n * value.  The top level value is passed to the reviver with the empty string as\n * a key.\n *\n * Throws [FormatException] if the input is not valid JSON text.\n */\n@patch\n_parseJson(String source, reviver(key, value)) {\n  if (source is! String) throw new ArgumentError(source);\n\n  var parsed;\n  try {\n    parsed = JS('=Object|JSExtendableArray|Null|bool|num|String',\n                'JSON.parse(#)',\n                source);\n  } catch (e) {\n    throw new FormatException(JS('String', 'String(#)', e));\n  }\n\n  if (reviver == null) {\n    return _convertJsonToDartLazy(parsed);\n  } else {\n    return _convertJsonToDart(parsed, reviver);\n  }\n}\n\n/**\n * Walks the raw JavaScript value [json], replacing JavaScript Objects with\n * Maps. [json] is expected to be freshly allocated so elements can be replaced\n * in-place.\n */\n_convertJsonToDart(json, reviver(key, value)) {\n  assert(reviver != null);\n  walk(e) {\n    // JavaScript null, string, number, bool are in the correct representation.\n    if (JS('bool', '# == null', e) || JS('bool', 'typeof # != \"object\"', e)) {\n      return e;\n    }\n\n    // This test is needed to avoid identifing '{\"__proto__\":[]}' as an Array.\n    // TODO(sra): Replace this test with cheaper '#.constructor === Array' when\n    // bug 621 below is fixed.\n    if (JS('bool', 'Object.getPrototypeOf(#) === Array.prototype', e)) {\n      // In-place update of the elements since JS Array is a Dart List.\n      for (int i = 0; i < JS('int', '#.length', e); i++) {\n        // Use JS indexing to avoid range checks.  We know this is the only\n        // reference to the list, but the compiler will likely never be able to\n        // tell that this instance of the list cannot have its length changed by\n        // the reviver even though it later will be passed to the reviver at the\n        // outer level.\n        var item = JS('', '#[#]', e, i);\n        JS('', '#[#]=#', e, i, reviver(i, walk(item)));\n      }\n      return e;\n    }\n\n    // Otherwise it is a plain object, so copy to a JSON map, so we process\n    // and revive all entries recursively.\n    _JsonMap map = new _JsonMap(e);\n    var processed = map._processed;\n    List<String> keys = map._computeKeys();\n    for (int i = 0; i < keys.length; i++) {\n      String key = keys[i];\n      var revived = reviver(key, walk(JS('', '#[#]', e, key)));\n      JS('', '#[#]=#', processed, key, revived);\n    }\n\n    // Update the JSON map structure so future access is cheaper.\n    map._original = processed;  // Don't keep two objects around.\n    return map;\n  }\n\n  return reviver(null, walk(json));\n}\n\n_convertJsonToDartLazy(object) {\n  // JavaScript null and undefined are represented as null.\n  if (object == null) return null;\n\n  // JavaScript string, number, bool already has the correct representation.\n  if (JS('bool', 'typeof # != \"object\"', object)) {\n    return object;\n  }\n\n  // This test is needed to avoid identifing '{\"__proto__\":[]}' as an array.\n  // TODO(sra): Replace this test with cheaper '#.constructor === Array' when\n  // bug https://code.google.com/p/v8/issues/detail?id=621 is fixed.\n  if (JS('bool', 'Object.getPrototypeOf(#) !== Array.prototype', object)) {\n    return new _JsonMap(object);\n  }\n\n  // Update the elements in place since JS arrays are Dart lists.\n  for (int i = 0; i < JS('int', '#.length', object); i++) {\n    // Use JS indexing to avoid range checks.  We know this is the only\n    // reference to the list, but the compiler will likely never be able to\n    // tell that this instance of the list cannot have its length changed by\n    // the reviver even though it later will be passed to the reviver at the\n    // outer level.\n    var item = JS('', '#[#]', object, i);\n    JS('', '#[#]=#', object, i, _convertJsonToDartLazy(item));\n  }\n  return object;\n}\n\nclass _JsonMap implements LinkedHashMap {\n  // The original JavaScript object remains unchanged until\n  // the map is eventually upgraded, in which case we null it\n  // out to reclaim the memory used by it.\n  var _original;\n\n  // We keep track of the map entries that we have already\n  // processed by adding them to a separate JavaScript object.\n  var _processed = _newJavaScriptObject();\n\n  // If the data slot isn't null, it represents either the list\n  // of keys (for non-upgraded JSON maps) or the upgraded map.\n  var _data = null;\n\n  _JsonMap(this._original);\n\n  operator[](key) {\n    if (_isUpgraded) {\n      return _upgradedMap[key];\n    } else if (key is !String) {\n      return null;\n    } else {\n      var result = _getProperty(_processed, key);\n      if (_isUnprocessed(result)) result = _process(key);\n      return result;\n    }\n  }\n\n  int get length => _isUpgraded\n      ? _upgradedMap.length\n      : _computeKeys().length;\n\n  bool get isEmpty => length == 0;\n  bool get isNotEmpty => length > 0;\n\n  Iterable get keys {\n    if (_isUpgraded) return _upgradedMap.keys;\n    return _computeKeys().skip(0);\n  }\n\n  Iterable get values {\n    if (_isUpgraded) return _upgradedMap.values;\n    return new MappedIterable(_computeKeys(), (each) => this[each]);\n  }\n\n  operator[]=(key, value) {\n    if (_isUpgraded) {\n      _upgradedMap[key] = value;\n    } else if (containsKey(key)) {\n      var processed = _processed;\n      _setProperty(processed, key, value);\n      var original = _original;\n      if (!identical(original, processed)) {\n        _setProperty(original, key, null);  // Reclaim memory.\n      }\n    } else {\n      _upgrade()[key] = value;\n    }\n  }\n\n  void addAll(Map other) {\n    other.forEach((key, value) {\n      this[key] = value;\n    });\n  }\n\n  bool containsValue(value) {\n    if (_isUpgraded) return _upgradedMap.containsValue(value);\n    List<String> keys = _computeKeys();\n    for (int i = 0; i < keys.length; i++) {\n      String key = keys[i];\n      if (this[key] == value) return true;\n    }\n    return false;\n  }\n\n  bool containsKey(key) {\n    if (_isUpgraded) return _upgradedMap.containsKey(key);\n    if (key is !String) return false;\n    return _hasProperty(_original, key);\n  }\n\n  putIfAbsent(key, ifAbsent()) {\n    if (containsKey(key)) return this[key];\n    var value = ifAbsent();\n    this[key] = value;\n    return value;\n  }\n\n  remove(Object key) {\n    if (!_isUpgraded && !containsKey(key)) return null;\n    return _upgrade().remove(key);\n  }\n\n  void clear() {\n    if (_isUpgraded) {\n      _upgradedMap.clear();\n    } else {\n      if (_data != null) {\n        // Clear the list of keys to make sure we force\n        // a concurrent modification error if anyone is\n        // currently iterating over it.\n        _data.clear();\n      }\n      _original = _processed = null;\n      _data = {};\n    }\n  }\n\n  void forEach(void f(key, value)) {\n    if (_isUpgraded) return _upgradedMap.forEach(f);\n    List<String> keys = _computeKeys();\n    for (int i = 0; i < keys.length; i++) {\n      String key = keys[i];\n\n      // Compute the value under the assumption that the property\n      // is present but potentially not processed.\n      var value = _getProperty(_processed, key);\n      if (_isUnprocessed(value)) {\n        value = _convertJsonToDartLazy(_getProperty(_original, key));\n        _setProperty(_processed, key, value);\n      }\n\n      // Do the callback.\n      f(key, value);\n\n      // Check if invoking the callback function changed\n      // the key set. If so, throw an exception.\n      if (!identical(keys, _data)) {\n        throw new ConcurrentModificationError(this);\n      }\n    }\n  }\n\n  String toString() => Maps.mapToString(this);\n\n\n  // ------------------------------------------\n  // Private helper methods.\n  // ------------------------------------------\n\n  bool get _isUpgraded => _processed == null;\n\n  Map get _upgradedMap {\n    assert(_isUpgraded);\n    // 'cast' the union type to LinkedHashMap.  It would be even better if we\n    // could 'cast' to the implementation type, since LinkedHashMap includes\n    // _JsonMap.\n    return JS('LinkedHashMap', '#', _data);\n  }\n\n  List<String> _computeKeys() {\n    assert(!_isUpgraded);\n    List keys = _data;\n    if (keys == null) {\n      keys = _data = _getPropertyNames(_original);\n    }\n    return JS('JSExtendableArray', '#', keys);\n  }\n\n  Map _upgrade() {\n    if (_isUpgraded) return _upgradedMap;\n\n    // Copy all the (key, value) pairs to a freshly allocated\n    // linked hash map thus preserving the ordering.\n    Map result = {};\n    List<String> keys = _computeKeys();\n    for (int i = 0; i < keys.length; i++) {\n      String key = keys[i];\n      result[key] = this[key];\n    }\n\n    // We only upgrade when we need to extend the map, so we can\n    // safely force a concurrent modification error in case\n    // someone is iterating over the map here.\n    if (keys.isEmpty) {\n      keys.add(null);\n    } else {\n      keys.clear();\n    }\n\n    // Clear out the associated JavaScript objects and mark the\n    // map as having been upgraded.\n    _original = _processed = null;\n    _data = result;\n    assert(_isUpgraded);\n    return result;\n  }\n\n  _process(String key) {\n    if (!_hasProperty(_original, key)) return null;\n    var result = _convertJsonToDartLazy(_getProperty(_original, key));\n    return _setProperty(_processed, key, result);\n  }\n\n\n  // ------------------------------------------\n  // Private JavaScript helper methods.\n  // ------------------------------------------\n\n  static bool _hasProperty(object, String key)\n      => JS('bool', 'Object.prototype.hasOwnProperty.call(#,#)', object, key);\n  static _getProperty(object, String key)\n      => JS('', '#[#]', object, key);\n  static _setProperty(object, String key, value)\n      => JS('', '#[#]=#', object, key, value);\n  static List _getPropertyNames(object)\n      => JS('JSExtendableArray', 'Object.keys(#)', object);\n  static bool _isUnprocessed(object)\n      => JS('bool', 'typeof(#)==\"undefined\"', object);\n  static _newJavaScriptObject()\n      => JS('=Object', 'Object.create(null)');\n}\n\n@patch\nclass _Utf8Encoder {\n  // Use Uint8List when supported on all platforms.\n  @patch\n  static List<int> _createBuffer(int size) => new List<int>(size);\n}\n\u0000","sdk:/sdk/lib/_internal/lib/core_patch.dart":"// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n// Patch file for dart:core classes.\nimport \"dart:_internal\" as _symbol_dev;\nimport 'dart:_interceptors';\nimport 'dart:_js_helper' show patch,\n                              checkNull,\n                              getRuntimeType,\n                              JSSyntaxRegExp,\n                              Primitives,\n                              stringJoinUnchecked,\n                              objectHashCode;\n\nString _symbolToString(Symbol symbol) => _symbol_dev.Symbol.getName(symbol);\n\n_symbolMapToStringMap(Map<Symbol, dynamic> map) {\n  if (map == null) return null;\n  var result = new Map<String, dynamic>();\n  map.forEach((Symbol key, value) {\n    result[_symbolToString(key)] = value;\n  });\n  return result;\n}\n\n@patch\nint identityHashCode(Object object) => objectHashCode(object);\n\n// Patch for Object implementation.\n@patch\nclass Object {\n  @patch\n  int get hashCode => Primitives.objectHashCode(this);\n\n\n  @patch\n  String toString() => Primitives.objectToString(this);\n\n  @patch\n  dynamic noSuchMethod(Invocation invocation) {\n    throw new NoSuchMethodError(\n        this,\n        invocation.memberName,\n        invocation.positionalArguments,\n        invocation.namedArguments);\n  }\n\n  @patch\n  Type get runtimeType => getRuntimeType(this);\n}\n\n// Patch for Function implementation.\n@patch\nclass Function {\n  @patch\n  static apply(Function function,\n               List positionalArguments,\n               [Map<Symbol, dynamic> namedArguments]) {\n    return Primitives.applyFunction(\n        function, positionalArguments, _toMangledNames(namedArguments));\n  }\n\n  static Map<String, dynamic> _toMangledNames(\n      Map<Symbol, dynamic> namedArguments) {\n    if (namedArguments == null) return null;\n    Map<String, dynamic> result = {};\n    namedArguments.forEach((symbol, value) {\n      result[_symbolToString(symbol)] = value;\n    });\n    return result;\n  }\n}\n\n// Patch for Expando implementation.\n@patch\nclass Expando<T> {\n  @patch\n  Expando([String name]) : this.name = name;\n\n  @patch\n  T operator[](Object object) {\n    var values = Primitives.getProperty(object, _EXPANDO_PROPERTY_NAME);\n    return (values == null) ? null : Primitives.getProperty(values, _getKey());\n  }\n\n  @patch\n  void operator[]=(Object object, T value) {\n    var values = Primitives.getProperty(object, _EXPANDO_PROPERTY_NAME);\n    if (values == null) {\n      values = new Object();\n      Primitives.setProperty(object, _EXPANDO_PROPERTY_NAME, values);\n    }\n    Primitives.setProperty(values, _getKey(), value);\n  }\n\n  String _getKey() {\n    String key = Primitives.getProperty(this, _KEY_PROPERTY_NAME);\n    if (key == null) {\n      key = \"expando\\$key\\$${_keyCount++}\";\n      Primitives.setProperty(this, _KEY_PROPERTY_NAME, key);\n    }\n    return key;\n  }\n\n  static const String _KEY_PROPERTY_NAME = 'expando\\$key';\n  static const String _EXPANDO_PROPERTY_NAME = 'expando\\$values';\n  static int _keyCount = 0;\n}\n\n@patch\nclass int {\n  @patch\n  static int parse(String source,\n                         { int radix,\n                           int onError(String source) }) {\n    return Primitives.parseInt(source, radix, onError);\n  }\n\n  @patch\n  factory int.fromEnvironment(String name, {int defaultValue}) {\n    throw new UnsupportedError(\n        'int.fromEnvironment can only be used as a const constructor');\n  }\n}\n\n@patch\nclass double {\n  @patch\n  static double parse(String source,\n                            [double onError(String source)]) {\n    return Primitives.parseDouble(source, onError);\n  }\n}\n\n@patch\nclass Error {\n  @patch\n  static String _objectToString(Object object) {\n    return Primitives.objectToString(object);\n  }\n\n  @patch\n  StackTrace get stackTrace => Primitives.extractStackTrace(this);\n}\n\n// Patch for DateTime implementation.\n@patch\nclass DateTime {\n  @patch\n  DateTime._internal(int year,\n                     int month,\n                     int day,\n                     int hour,\n                     int minute,\n                     int second,\n                     int millisecond,\n                     bool isUtc)\n      : this.isUtc = checkNull(isUtc),\n        millisecondsSinceEpoch = Primitives.valueFromDecomposedDate(\n            year, month, day, hour, minute, second, millisecond, isUtc) {\n    if (millisecondsSinceEpoch == null) throw new ArgumentError();\n    Primitives.lazyAsJsDate(this);\n  }\n\n  @patch\n  DateTime._now()\n      : isUtc = false,\n        millisecondsSinceEpoch = Primitives.dateNow() {\n    Primitives.lazyAsJsDate(this);\n  }\n\n  @patch\n  static int _brokenDownDateToMillisecondsSinceEpoch(\n      int year, int month, int day, int hour, int minute, int second,\n      int millisecond, bool isUtc) {\n    return Primitives.valueFromDecomposedDate(\n        year, month, day, hour, minute, second, millisecond, isUtc);\n  }\n\n  @patch\n  String get timeZoneName {\n    if (isUtc) return \"UTC\";\n    return Primitives.getTimeZoneName(this);\n  }\n\n  @patch\n  Duration get timeZoneOffset {\n    if (isUtc) return new Duration();\n    return new Duration(minutes: Primitives.getTimeZoneOffsetInMinutes(this));\n  }\n\n  @patch\n  int get year => Primitives.getYear(this);\n\n  @patch\n  int get month => Primitives.getMonth(this);\n\n  @patch\n  int get day => Primitives.getDay(this);\n\n  @patch\n  int get hour => Primitives.getHours(this);\n\n  @patch\n  int get minute => Primitives.getMinutes(this);\n\n  @patch\n  int get second => Primitives.getSeconds(this);\n\n  @patch\n  int get millisecond => Primitives.getMilliseconds(this);\n\n  @patch\n  int get weekday => Primitives.getWeekday(this);\n}\n\n\n// Patch for Stopwatch implementation.\n@patch\nclass Stopwatch {\n  @patch\n  static void _initTicker() {\n    Primitives.initTicker();\n    _frequency = Primitives.timerFrequency;\n  }\n\n  @patch\n  static int _now() => Primitives.timerTicks();\n}\n\nclass _ListConstructorSentinel extends JSInt {\n  const _ListConstructorSentinel();\n}\n\n// Patch for List implementation.\n@patch\nclass List<E> {\n  @patch\n  factory List([int length = const _ListConstructorSentinel()]) {\n    if (length == const _ListConstructorSentinel()) {\n      return new JSArray<E>.emptyGrowable();\n    }\n    return new JSArray<E>.fixed(length);\n  }\n\n  @patch\n  factory List.filled(int length, E fill) {\n    List result = new JSArray<E>.fixed(length);\n    if (length != 0 && fill != null) {\n      for (int i = 0; i < result.length; i++) {\n        result[i] = fill;\n      }\n    }\n    return result;\n  }\n}\n\n\n@patch\nclass String {\n  @patch\n  factory String.fromCharCodes(Iterable<int> charCodes) {\n    if (charCodes is! JSArray) {\n      charCodes = new List.from(charCodes);\n    }\n    return Primitives.stringFromCharCodes(charCodes);\n  }\n\n  @patch\n  factory String.fromCharCode(int charCode) {\n    return Primitives.stringFromCharCode(charCode);\n  }\n\n  @patch\n  factory String.fromEnvironment(String name, {String defaultValue}) {\n    throw new UnsupportedError(\n        'String.fromEnvironment can only be used as a const constructor');\n  }\n}\n\n@patch\nclass bool {\n  @patch\n  factory bool.fromEnvironment(String name, {bool defaultValue: false}) {\n    throw new UnsupportedError(\n        'bool.fromEnvironment can only be used as a const constructor');\n  }\n}\n\n@patch\nclass RegExp {\n  @patch\n  factory RegExp(String source,\n                       {bool multiLine: false,\n                        bool caseSensitive: true})\n    => new JSSyntaxRegExp(source,\n                          multiLine: multiLine,\n                          caseSensitive: caseSensitive);\n}\n\n// Patch for 'identical' function.\n@patch\nbool identical(Object a, Object b) {\n  return Primitives.identicalImplementation(a, b);\n}\n\n@patch\nclass StringBuffer {\n  String _contents = \"\";\n\n  @patch\n  StringBuffer([Object content = \"\"]) {\n    if (content is String) {\n      _contents = content;\n    } else {\n      write(content);\n    }\n  }\n\n  @patch\n  int get length => _contents.length;\n\n  @patch\n  void write(Object obj) {\n    String str = obj is String ? obj : \"$obj\";\n    _contents = Primitives.stringConcatUnchecked(_contents, str);\n  }\n\n  @patch\n  void writeCharCode(int charCode) {\n    write(new String.fromCharCode(charCode));\n  }\n\n  @patch\n  void clear() {\n    _contents = \"\";\n  }\n\n  @patch\n  String toString() => _contents;\n}\n\n@patch\nclass NoSuchMethodError {\n  @patch\n  String toString() {\n    StringBuffer sb = new StringBuffer();\n    int i = 0;\n    if (_arguments != null) {\n      for (; i < _arguments.length; i++) {\n        if (i > 0) {\n          sb.write(\", \");\n        }\n        sb.write(Error.safeToString(_arguments[i]));\n      }\n    }\n    if (_namedArguments != null) {\n      _namedArguments.forEach((Symbol key, var value) {\n        if (i > 0) {\n          sb.write(\", \");\n        }\n        sb.write(_symbolToString(key));\n        sb.write(\": \");\n        sb.write(Error.safeToString(value));\n        i++;\n      });\n    }\n    if (_existingArgumentNames == null) {\n      return \"NoSuchMethodError : method not found: '$_memberName'\\n\"\n          \"Receiver: ${Error.safeToString(_receiver)}\\n\"\n          \"Arguments: [$sb]\";\n    } else {\n      String actualParameters = sb.toString();\n      sb = new StringBuffer();\n      for (int i = 0; i < _existingArgumentNames.length; i++) {\n        if (i > 0) {\n          sb.write(\", \");\n        }\n        sb.write(_existingArgumentNames[i]);\n      }\n      String formalParameters = sb.toString();\n      return \"NoSuchMethodError: incorrect number of arguments passed to \"\n          \"method named '$_memberName'\\n\"\n          \"Receiver: ${Error.safeToString(_receiver)}\\n\"\n          \"Tried calling: $_memberName($actualParameters)\\n\"\n          \"Found: $_memberName($formalParameters)\";\n    }\n  }\n}\n\n@patch\nclass Uri {\n  @patch\n  static bool get _isWindows => false;\n\n  @patch\n  static Uri get base {\n    String uri = Primitives.currentUri();\n    if (uri != null) return Uri.parse(uri);\n    throw new UnsupportedError(\"'Uri.base' is not supported\");\n  }\n}\n\u0000","sdk:/sdk/lib/_internal/lib/io_patch.dart":"// Copyright (c) 2013, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\nimport 'dart:_js_helper' show patch;\n\n@patch\nclass _Directory {\n  @patch\n  static _current() {\n    throw new UnsupportedError(\"Directory._current\");\n  }\n  @patch\n  static _setCurrent(path) {\n    throw new UnsupportedError(\"Directory_SetCurrent\");\n  }\n  @patch\n  static _createTemp(String path) {\n    throw new UnsupportedError(\"Directory._createTemp\");\n  }\n  @patch\n  static String _systemTemp() {\n    throw new UnsupportedError(\"Directory._systemTemp\");\n  }\n  @patch\n  static _exists(String path) {\n    throw new UnsupportedError(\"Directory._exists\");\n  }\n  @patch\n  static _create(String path) {\n    throw new UnsupportedError(\"Directory._create\");\n  }\n  @patch\n  static _deleteNative(String path, bool recursive) {\n    throw new UnsupportedError(\"Directory._deleteNative\");\n  }\n  @patch\n  static _rename(String path, String newPath) {\n    throw new UnsupportedError(\"Directory._rename\");\n  }\n  @patch\n  static List _list(String path, bool recursive, bool followLinks) {\n    throw new UnsupportedError(\"Directory._list\");\n  }\n}\n\n@patch\nclass _EventHandler {\n  @patch\n  static void _sendData(Object sender,\n                        SendPort sendPort,\n                        int data) {\n    throw new UnsupportedError(\"EventHandler._sendData\");\n  }\n}\n\n@patch\nclass FileStat {\n  @patch\n  static _statSync(String path) {\n    throw new UnsupportedError(\"FileStat.stat\");\n  }\n}\n\n@patch\nclass FileSystemEntity {\n  @patch\n  static _getType(String path, bool followLinks) {\n    throw new UnsupportedError(\"FileSystemEntity._getType\");\n  }\n  @patch\n  static _identical(String path1, String path2) {\n    throw new UnsupportedError(\"FileSystemEntity._identical\");\n  }\n  @patch\n  static _resolveSymbolicLinks(String path) {\n    throw new UnsupportedError(\"FileSystemEntity._resolveSymbolicLinks\");\n  }\n}\n\n@patch\nclass _File {\n  @patch\n  static _exists(String path) {\n    throw new UnsupportedError(\"File._exists\");\n  }\n  @patch\n  static _create(String path) {\n    throw new UnsupportedError(\"File._create\");\n  }\n  @patch\n  static _createLink(String path, String target) {\n    throw new UnsupportedError(\"File._createLink\");\n  }\n  @patch\n  static _linkTarget(String path) {\n    throw new UnsupportedError(\"File._linkTarget\");\n  }\n  @patch\n  static _deleteNative(String path) {\n    throw new UnsupportedError(\"File._deleteNative\");\n  }\n  @patch\n  static _deleteLinkNative(String path) {\n    throw new UnsupportedError(\"File._deleteLinkNative\");\n  }\n  @patch\n  static _rename(String oldPath, String newPath) {\n    throw new UnsupportedError(\"File._rename\");\n  }\n  @patch\n  static _renameLink(String oldPath, String newPath) {\n    throw new UnsupportedError(\"File._renameLink\");\n  }\n  @patch\n  static _copy(String oldPath, String newPath) {\n    throw new UnsupportedError(\"File._copy\");\n  }\n  @patch\n  static _lengthFromPath(String path) {\n    throw new UnsupportedError(\"File._lengthFromPath\");\n  }\n  @patch\n  static _lastModified(String path) {\n    throw new UnsupportedError(\"File._lastModified\");\n  }\n  @patch\n  static _open(String path, int mode) {\n    throw new UnsupportedError(\"File._open\");\n  }\n  @patch\n  static int _openStdio(int fd) {\n    throw new UnsupportedError(\"File._openStdio\");\n  }\n}\n\n@patch\nclass _RandomAccessFile {\n  @patch\n  static int _close(int id) {\n    throw new UnsupportedError(\"RandomAccessFile._close\");\n  }\n  @patch\n  static int _getFD(int id) {\n    throw new UnsupportedError(\"RandomAccessFile._getFD\");\n  }\n  @patch\n  static _readByte(int id) {\n    throw new UnsupportedError(\"RandomAccessFile._readByte\");\n  }\n  @patch\n  static _read(int id, int bytes) {\n    throw new UnsupportedError(\"RandomAccessFile._read\");\n  }\n  @patch\n  static _readInto(int id, List<int> buffer, int start, int end) {\n    throw new UnsupportedError(\"RandomAccessFile._readInto\");\n  }\n  @patch\n  static _writeByte(int id, int value) {\n    throw new UnsupportedError(\"RandomAccessFile._writeByte\");\n  }\n  @patch\n  static _writeFrom(int id, List<int> buffer, int start, int end) {\n    throw new UnsupportedError(\"RandomAccessFile._writeFrom\");\n  }\n  @patch\n  static _position(int id) {\n    throw new UnsupportedError(\"RandomAccessFile._position\");\n  }\n  @patch\n  static _setPosition(int id, int position) {\n    throw new UnsupportedError(\"RandomAccessFile._setPosition\");\n  }\n  @patch\n  static _truncate(int id, int length) {\n    throw new UnsupportedError(\"RandomAccessFile._truncate\");\n  }\n  @patch\n  static _length(int id) {\n    throw new UnsupportedError(\"RandomAccessFile._length\");\n  }\n  @patch\n  static _flush(int id) {\n    throw new UnsupportedError(\"RandomAccessFile._flush\");\n  }\n}\n\n@patch\nclass _IOCrypto {\n  @patch\n  static Uint8List getRandomBytes(int count) {\n    throw new UnsupportedError(\"_IOCrypto.getRandomBytes\");\n  }\n}\n\n@patch\nclass _Platform {\n  @patch\n  static int _numberOfProcessors() {\n    throw new UnsupportedError(\"Platform._numberOfProcessors\");\n  }\n  @patch\n  static String _pathSeparator() {\n    throw new UnsupportedError(\"Platform._pathSeparator\");\n  }\n  @patch\n  static String _operatingSystem() {\n    throw new UnsupportedError(\"Platform._operatingSystem\");\n  }\n  @patch\n  static _localHostname() {\n    throw new UnsupportedError(\"Platform._localHostname\");\n  }\n  @patch\n  static _executable() {\n    throw new UnsupportedError(\"Platform._executable\");\n  }\n  @patch\n  static List<String> _executableArguments() {\n    throw new UnsupportedError(\"Platform._executableArguments\");\n  }\n  @patch\n  static String _packageRoot() {\n    throw new UnsupportedError(\"Platform._packageRoot\");\n  }\n  @patch\n  static _environment() {\n    throw new UnsupportedError(\"Platform._environment\");\n  }\n  @patch\n  static String _version() {\n    throw new UnsupportedError(\"Platform._version\");\n  }\n}\n\n@patch\nclass _ProcessUtils {\n  @patch\n  static void _exit(int status) {\n    throw new UnsupportedError(\"ProcessUtils._exit\");\n  }\n  @patch\n  static void _setExitCode(int status) {\n    throw new UnsupportedError(\"ProcessUtils._setExitCode\");\n  }\n  @patch\n  static int _getExitCode() {\n    throw new UnsupportedError(\"ProcessUtils._getExitCode\");\n  }\n  @patch\n  static void _sleep(int millis) {\n    throw new UnsupportedError(\"ProcessUtils._sleep\");\n  }\n  @patch\n  static int _pid(Process process) {\n    throw new UnsupportedError(\"ProcessUtils._pid\");\n  }\n  @patch\n  static Stream<ProcessSignal> _watchSignal(ProcessSignal signal) {\n    throw new UnsupportedError(\"ProcessUtils._watchSignal\");\n  }\n}\n\n@patch\nclass Process {\n  @patch\n  static Future<Process> start(\n      String executable,\n      List<String> arguments,\n      {String workingDirectory,\n       Map<String, String> environment,\n       bool includeParentEnvironment: true,\n       bool runInShell: false}) {\n    throw new UnsupportedError(\"Process.start\");\n  }\n\n  @patch\n  static Future<ProcessResult> run(\n      String executable,\n      List<String> arguments,\n      {String workingDirectory,\n       Map<String, String> environment,\n       bool includeParentEnvironment: true,\n       bool runInShell: false,\n       Encoding stdoutEncoding: SYSTEM_ENCODING,\n       Encoding stderrEncoding: SYSTEM_ENCODING}) {\n    throw new UnsupportedError(\"Process.run\");\n  }\n\n  @patch\n  static ProcessResult runSync(\n      String executable,\n      List<String> arguments,\n      {String workingDirectory,\n       Map<String, String> environment,\n       bool includeParentEnvironment: true,\n       bool runInShell: false,\n       Encoding stdoutEncoding: SYSTEM_ENCODING,\n       Encoding stderrEncoding: SYSTEM_ENCODING}) {\n    throw new UnsupportedError(\"Process.runSync\");\n  }\n}\n\n@patch\nclass InternetAddress {\n  @patch\n  static InternetAddress get LOOPBACK_IP_V4 {\n    throw new UnsupportedError(\"InternetAddress.LOOPBACK_IP_V4\");\n  }\n  @patch\n  static InternetAddress get LOOPBACK_IP_V6 {\n    throw new UnsupportedError(\"InternetAddress.LOOPBACK_IP_V6\");\n  }\n  @patch\n  static InternetAddress get ANY_IP_V4 {\n    throw new UnsupportedError(\"InternetAddress.ANY_IP_V4\");\n  }\n  @patch\n  static InternetAddress get ANY_IP_V6 {\n    throw new UnsupportedError(\"InternetAddress.ANY_IP_V6\");\n  }\n  @patch\n  factory InternetAddress(String address) {\n    throw new UnsupportedError(\"InternetAddress\");\n  }\n  @patch\n  static Future<List<InternetAddress>> lookup(\n      String host, {InternetAddressType type: InternetAddressType.ANY}) {\n    throw new UnsupportedError(\"InternetAddress.lookup\");\n  }\n}\n\n@patch\nclass NetworkInterface {\n  @patch\n  static Future<List<NetworkInterface>> list({\n      bool includeLoopback: false,\n      bool includeLinkLocal: false,\n      InternetAddressType type: InternetAddressType.ANY}) {\n    throw new UnsupportedError(\"NetworkInterface.list\");\n  }\n}\n\n@patch\nclass RawServerSocket {\n  @patch\n  static Future<RawServerSocket> bind(address,\n                                      int port,\n                                      {int backlog: 0,\n                                       bool v6Only: false}) {\n    throw new UnsupportedError(\"RawServerSocket.bind\");\n  }\n}\n\n@patch\nclass ServerSocket {\n  @patch\n  static Future<ServerSocket> bind(address,\n                                   int port,\n                                   {int backlog: 0,\n                                    bool v6Only: false}) {\n    throw new UnsupportedError(\"ServerSocket.bind\");\n  }\n}\n\n@patch\nclass RawSocket {\n  @patch\n  static Future<RawSocket> connect(host, int port) {\n    throw new UnsupportedError(\"RawSocket constructor\");\n  }\n}\n\n@patch\nclass Socket {\n  @patch\n  static Future<Socket> connect(host, int port) {\n    throw new UnsupportedError(\"Socket constructor\");\n  }\n}\n\n@patch\nclass SecureSocket {\n  @patch\n  factory SecureSocket._(RawSecureSocket rawSocket) {\n    throw new UnsupportedError(\"SecureSocket constructor\");\n  }\n\n  @patch\n  static void initialize({String database,\n                          String password,\n                          bool useBuiltinRoots: true}) {\n    throw new UnsupportedError(\"SecureSocket.initialize\");\n  }\n}\n\n@patch\nclass RawDatagramSocket {\n  @patch\n  static Future<RawDatagramSocket> bind(\n      host, int port, {bool reuseAddress: true}) {\n    throw new UnsupportedError(\"RawDatagramSocket.bind\");\n  }\n}\n\n@patch\nclass _SecureFilter {\n  @patch\n  factory _SecureFilter() {\n    throw new UnsupportedError(\"_SecureFilter._SecureFilter\");\n  }\n}\n\n@patch\nclass _StdIOUtils {\n  @patch\n  static Stdin _getStdioInputStream() {\n    throw new UnsupportedError(\"StdIOUtils._getStdioInputStream\");\n  }\n  @patch\n  static _getStdioOutputStream(int fd) {\n    throw new UnsupportedError(\"StdIOUtils._getStdioOutputStream\");\n  }\n  @patch\n  static int _socketType(nativeSocket) {\n    throw new UnsupportedError(\"StdIOUtils._socketType\");\n  }\n  @patch\n  static _getStdioHandleType(int fd) {\n    throw new UnsupportedError(\"StdIOUtils._getStdioHandleType\");\n  }\n}\n\n@patch\nclass _WindowsCodePageDecoder {\n  @patch\n  static String _decodeBytes(List<int> bytes) {\n    throw new UnsupportedError(\"_WindowsCodePageDecoder._decodeBytes\");\n  }\n}\n\n@patch\nclass _WindowsCodePageEncoder {\n  @patch\n  static List<int> _encodeString(String string) {\n    throw new UnsupportedError(\"_WindowsCodePageEncoder._encodeString\");\n  }\n}\n\n@patch\nclass _Filter {\n  @patch\n  static _Filter newZLibDeflateFilter(bool gzip, int level,\n                                      int windowBits, int memLevel,\n                                      int strategy,\n                                      List<int> dictionary, bool raw) {\n    throw new UnsupportedError(\"newZLibDeflateFilter\");\n  }\n  @patch\n  static _Filter newZLibInflateFilter(int windowBits,\n                                      List<int> dictionary, bool raw) {\n    throw new UnsupportedError(\"newZLibInflateFilter\");\n  }\n}\n\n@patch\nclass Stdin {\n  @patch\n  int readByteSync() {\n    throw new UnsupportedError(\"Stdin.readByteSync\");\n  }\n  @patch\n  bool get echoMode {\n    throw new UnsupportedError(\"Stdin.echoMode\");\n  }\n  @patch\n  void set echoMode(bool enabled) {\n    throw new UnsupportedError(\"Stdin.echoMode\");\n  }\n  @patch\n  bool get lineMode {\n    throw new UnsupportedError(\"Stdin.lineMode\");\n  }\n  @patch\n  void set lineMode(bool enabled) {\n    throw new UnsupportedError(\"Stdin.lineMode\");\n  }\n}\n\n@patch\nclass Stdout {\n  @patch\n  bool get hasTerminal {\n    throw new UnsupportedError(\"Stdout.hasTerminal\");\n  }\n  @patch\n  int get terminalColumns {\n    throw new UnsupportedError(\"Stdout.terminalColumns\");\n  }\n  @patch\n  int get terminalLines {\n    throw new UnsupportedError(\"Stdout.terminalLines\");\n  }\n}\n\n@patch\nclass _FileSystemWatcher {\n  @patch\n  static Stream<FileSystemEvent> watch(\n      String path, int events, bool recursive) {\n    throw new UnsupportedError(\"_FileSystemWatcher.watch\");\n  }\n  @patch\n  static bool get isSupported {\n    throw new UnsupportedError(\"_FileSystemWatcher.isSupported\");\n  }\n}\n\n@patch\nclass _IOService {\n  @patch\n  static Future dispatch(int request, List data) {\n    throw new UnsupportedError(\"_IOService.dispatch\");\n  }\n}\n\u0000","sdk:/sdk/lib/_internal/lib/isolate_patch.dart":"// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n// Patch file for the dart:isolate library.\n\nimport 'dart:_js_helper' show patch;\nimport 'dart:_isolate_helper' show CapabilityImpl,\n                                   CloseToken,\n                                   IsolateNatives,\n                                   JsIsolateSink,\n                                   ReceivePortImpl,\n                                   RawReceivePortImpl;\n\n@patch\nclass Isolate {\n  @patch\n  static Future<Isolate> spawn(void entryPoint(message), var message,\n                                     { bool paused: false }) {\n    try {\n      return IsolateNatives.spawnFunction(entryPoint, message, paused)\n          .then((msg) => new Isolate(msg[1],\n                                     pauseCapability: msg[2],\n                                     terminateCapability: msg[3]));\n    } catch (e, st) {\n      return new Future<Isolate>.error(e, st);\n    }\n  }\n\n  @patch\n  static Future<Isolate> spawnUri(\n      Uri uri, List<String> args, var message, { bool paused: false }) {\n    try {\n      if (args is List<String>) {\n        for (int i = 0; i < args.length; i++) {\n          if (args[i] is! String) {\n            throw new ArgumentError(\"Args must be a list of Strings $args\");\n          }\n        }\n      } else if (args != null) {\n        throw new ArgumentError(\"Args must be a list of Strings $args\");\n      }\n      return IsolateNatives.spawnUri(uri, args, message, paused)\n          .then((msg) => new Isolate(msg[1],\n                                     pauseCapability: msg[2],\n                                     terminateCapability: msg[3]));\n    } catch (e, st) {\n      return new Future<Isolate>.error(e, st);\n    }\n  }\n\n  @patch\n  void _pause(Capability resumeCapability) {\n    var message = new List(3)\n        ..[0] = \"pause\"\n        ..[1] = pauseCapability\n        ..[2] = resumeCapability;\n    controlPort.send(message);\n  }\n\n  @patch\n  void resume(Capability resumeCapability) {\n    var message = new List(2)\n        ..[0] = \"resume\"\n        ..[1] = resumeCapability;\n    controlPort.send(message);\n  }\n\n  @patch\n  void addOnExitListener(SendPort responsePort) {\n    // TODO(lrn): Can we have an internal method that checks if the receiving\n    // isolate of a SendPort is still alive?\n    var message = new List(2)\n        ..[0] = \"add-ondone\"\n        ..[1] = responsePort;\n    controlPort.send(message);\n  }\n\n  @patch\n  void removeOnExitListener(SendPort responsePort) {\n    var message = new List(2)\n        ..[0] = \"remove-ondone\"\n        ..[1] = responsePort;\n    controlPort.send(message);\n  }\n\n  @patch\n  void setErrorsFatal(bool errorsAreFatal) {\n    var message = new List(3)\n        ..[0] = \"set-errors-fatal\"\n        ..[1] = terminateCapability\n        ..[2] = errorsAreFatal;\n    controlPort.send(message);\n  }\n\n  @patch\n  void kill([int priority = BEFORE_NEXT_EVENT]) {\n    controlPort.send([\"kill\", terminateCapability, priority]);\n  }\n\n  @patch\n  void ping(SendPort responsePort, [int pingType = IMMEDIATE]) {\n    var message = new List(3)\n        ..[0] = \"ping\"\n        ..[1] = responsePort\n        ..[2] = pingType;\n    controlPort.send(message);\n  }\n\n  @patch\n  void addErrorListener(SendPort port) {\n    var message = new List(2)\n        ..[0] = \"getErrors\"\n        ..[1] = port;\n    controlPort.send(message);\n  }\n\n  @patch\n  void removeErrorListener(SendPort port) {\n    var message = new List(2)\n        ..[0] = \"stopErrors\"\n        ..[1] = port;\n    controlPort.send(message);\n  }\n}\n\n/** Default factory for receive ports. */\n@patch\nclass ReceivePort {\n  @patch\n  factory ReceivePort() = ReceivePortImpl;\n\n  @patch\n  factory ReceivePort.fromRawReceivePort(RawReceivePort rawPort) {\n    return new ReceivePortImpl.fromRawReceivePort(rawPort);\n  }\n}\n\n@patch\nclass RawReceivePort {\n  @patch\n  factory RawReceivePort([void handler(event)]) {\n    return new RawReceivePortImpl(handler);\n  }\n}\n\n@patch\nclass Capability {\n  @patch\n  factory Capability() = CapabilityImpl;\n}\n\u0000","sdk:/sdk/lib/_internal/lib/math_patch.dart":"// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n// Patch file for dart:math library.\nimport 'dart:_foreign_helper' show JS;\nimport 'dart:_js_helper' show patch, checkNum;\n\n@patch\ndouble sqrt(num x)\n  => JS('double', r'Math.sqrt(#)', checkNum(x));\n\n@patch\ndouble sin(num x)\n  => JS('double', r'Math.sin(#)', checkNum(x));\n\n@patch\ndouble cos(num x)\n  => JS('double', r'Math.cos(#)', checkNum(x));\n\n@patch\ndouble tan(num x)\n  => JS('double', r'Math.tan(#)', checkNum(x));\n\n@patch\ndouble acos(num x)\n  => JS('double', r'Math.acos(#)', checkNum(x));\n\n@patch\ndouble asin(num x)\n  => JS('double', r'Math.asin(#)', checkNum(x));\n\n@patch\ndouble atan(num x)\n  => JS('double', r'Math.atan(#)', checkNum(x));\n\n@patch\ndouble atan2(num a, num b)\n  => JS('double', r'Math.atan2(#, #)', checkNum(a), checkNum(b));\n\n@patch\ndouble exp(num x)\n  => JS('double', r'Math.exp(#)', checkNum(x));\n\n@patch\ndouble log(num x)\n  => JS('double', r'Math.log(#)', checkNum(x));\n\n@patch\nnum pow(num x, num exponent) {\n  checkNum(x);\n  checkNum(exponent);\n  return JS('num', r'Math.pow(#, #)', x, exponent);\n}\n\nconst int _POW2_32 = 0x100000000;\n\n@patch\nclass Random {\n  @patch\n  factory Random([int seed]) =>\n      (seed == null) ? const _JSRandom() : new _Random(seed);\n}\n\nclass _JSRandom implements Random {\n  // The Dart2JS implementation of Random doesn't use a seed.\n  const _JSRandom();\n\n  int nextInt(int max) {\n    if (max <= 0 || max > _POW2_32) {\n      throw new RangeError(\"max must be in range 0 < max ≤ 2^32, was $max\");\n    }\n    return JS(\"int\", \"(Math.random() * #) >>> 0\", max);\n  }\n\n  /**\n   * Generates a positive random floating point value uniformly distributed on\n   * the range from 0.0, inclusive, to 1.0, exclusive.\n   */\n  double nextDouble() => JS(\"double\", \"Math.random()\");\n\n  /**\n   * Generates a random boolean value.\n   */\n  bool nextBool() => JS(\"bool\", \"Math.random() < 0.5\");\n}\n\n\nclass _Random implements Random {\n  // Constants used by the algorithm or masking.\n  static const double _POW2_53_D = 1.0 * (0x20000000000000);\n  static const double _POW2_27_D = 1.0 * (1 << 27);\n  static const int _MASK32 = 0xFFFFFFFF;\n\n  // State comprised of two unsigned 32 bit integers.\n  int _lo = 0;\n  int _hi = 0;\n\n  // Implements:\n  //   uint64_t hash = 0;\n  //   do {\n  //      hash = hash * 1037 ^ mix64((uint64_t)seed);\n  //      seed >>= 64;\n  //   } while (seed != 0 && seed != -1);  // Limits for pos/neg seed.\n  //   if (hash == 0) {\n  //     hash = 0x5A17;\n  //   }\n  //   _lo = hash & _MASK_32;\n  //   _hi = hash >> 32;\n  // and then does four _nextState calls to shuffle bits around.\n  _Random(int seed) {\n    int empty_seed = 0;\n    if (seed < 0) {\n      empty_seed = -1;\n    }\n    do {\n      int low = seed & _MASK32;\n      seed = (seed - low) ~/ _POW2_32;\n      int high = seed & _MASK32;\n      seed = (seed - high) ~/ _POW2_32;\n\n      // Thomas Wang's 64-bit mix function.\n      // http://www.concentric.net/~Ttwang/tech/inthash.htm\n      // via. http://web.archive.org/web/20071223173210/http://www.concentric.net/~Ttwang/tech/inthash.htm\n\n      // key = ~key + (key << 21);\n      int tmplow = low << 21;\n      int tmphigh = (high << 21) | (low >> 11);\n      tmplow = (~low & _MASK32) + tmplow;\n      low = tmplow & _MASK32;\n      high = (~high + tmphigh + ((tmplow - low) ~/ 0x100000000)) & _MASK32;\n      // key = key ^ (key >> 24).\n      tmphigh = high >> 24;\n      tmplow = (low >> 24) | (high << 8);\n      low ^= tmplow;\n      high ^= tmphigh;\n      // key = key * 265\n      tmplow = low * 265;\n      low = tmplow & _MASK32;\n      high = (high * 265 + (tmplow - low) ~/ 0x100000000) & _MASK32;\n      // key = key ^ (key >> 14);\n      tmphigh = high >> 14;\n      tmplow = (low >> 14) | (high << 18);\n      low ^= tmplow;\n      high ^= tmphigh;\n      // key = key * 21\n      tmplow = low * 21;\n      low = tmplow & _MASK32;\n      high = (high * 21 + (tmplow - low) ~/ 0x100000000) & _MASK32;\n      // key = key ^ (key >> 28).\n      tmphigh = high >> 28;\n      tmplow = (low >> 28) | (high << 4);\n      low ^= tmplow;\n      high ^= tmphigh;\n      // key = key + (key << 31);\n      tmplow = low << 31;\n      tmphigh = (high << 31) | (low >> 1);\n      tmplow += low;\n      low = tmplow & _MASK32;\n      high = (high + tmphigh + (tmplow - low) ~/ 0x100000000) & _MASK32;\n      // Mix end.\n\n      // seed = seed * 1037 ^ key;\n      tmplow = _lo * 1037;\n      _lo = tmplow & _MASK32;\n      _hi = (_hi * 1037 + (tmplow - _lo) ~/ 0x100000000) & _MASK32;\n      _lo ^= low;\n      _hi ^= high;\n    } while (seed != empty_seed);\n\n    if (_hi == 0 && _lo == 0) {\n      _lo = 0x5A17;\n    }\n    _nextState();\n    _nextState();\n    _nextState();\n    _nextState();\n  }\n\n  // The algorithm used here is Multiply with Carry (MWC) with a Base b = 2^32.\n  // http://en.wikipedia.org/wiki/Multiply-with-carry\n  // The constant A (0xFFFFDA61) is selected from \"Numerical Recipes 3rd\n  // Edition\" p.348 B1.\n\n  // Implements:\n  //   var state = (A * _lo + _hi) & _MASK_64;\n  //   _lo = state & _MASK_32;\n  //   _hi = state >> 32;\n  void _nextState() {\n    // Simulate (0xFFFFDA61 * lo + hi) without overflowing 53 bits.\n    int tmpHi = 0xFFFF0000 * _lo;  // At most 48 bits of significant result.\n    int tmpHiLo = tmpHi & _MASK32;             // Get the lower 32 bits.\n    int tmpHiHi = tmpHi - tmpHiLo;            // And just the upper 32 bits.\n    int tmpLo = 0xDA61 * _lo;\n    int tmpLoLo = tmpLo & _MASK32;\n    int tmpLoHi = tmpLo - tmpLoLo;\n\n    int newLo = tmpLoLo + tmpHiLo + _hi;\n    _lo = newLo & _MASK32;\n    int newLoHi = newLo - _lo;\n    _hi = ((tmpLoHi + tmpHiHi + newLoHi) ~/ _POW2_32) & _MASK32;\n    assert(_lo < _POW2_32);\n    assert(_hi < _POW2_32);\n  }\n\n  int nextInt(int max) {\n    if (max <= 0 || max > _POW2_32) {\n      throw new RangeError(\"max must be in range 0 < max ≤ 2^32, was $max\");\n    }\n    if ((max & (max - 1)) == 0) {\n      // Fast case for powers of two.\n      _nextState();\n      return _lo & (max - 1);\n    }\n\n    int rnd32;\n    int result;\n    do {\n      _nextState();\n      rnd32 = _lo;\n      result = rnd32.remainder(max); // % max;\n    } while ((rnd32 - result + max) >= _POW2_32);\n    return result;\n  }\n\n  double nextDouble() {\n    _nextState();\n    int bits26 = _lo & ((1 << 26) - 1);\n    _nextState();\n    int bits27 = _lo & ((1 << 27) - 1);\n    return (bits26 * _POW2_27_D + bits27) / _POW2_53_D;\n  }\n\n  bool nextBool() {\n    _nextState();\n    return (_lo & 1) == 0;\n  }\n}\n\u0000","sdk:/sdk/lib/_internal/lib/mirrors_patch.dart":"// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n// Patch library for dart:mirrors.\n\nimport 'dart:_js_helper' show patch;\nimport 'dart:_js_mirrors' as js;\n\n@patch\nclass MirrorSystem {\n  @patch\n  static String getName(Symbol symbol) => js.getName(symbol);\n\n  @patch\n  static Symbol getSymbol(String name, [LibraryMirror library]) {\n    return js.getSymbol(name, library);\n  }\n}\n\n@patch\nMirrorSystem currentMirrorSystem() => js.currentJsMirrorSystem;\n\n@patch\nInstanceMirror reflect(Object reflectee) => js.reflect(reflectee);\n\n@patch\nClassMirror reflectClass(Type key) {\n  if (key is! Type || key == dynamic) {\n    throw new ArgumentError('$key does not denote a class');\n  }\n  TypeMirror tm = reflectType(key);\n  if (tm is! ClassMirror) {\n    throw new ArgumentError(\"$key does not denote a class\");\n  }\n  return (tm as ClassMirror).originalDeclaration;\n}\n\n@patch\nTypeMirror reflectType(Type key) {\n  if (key == dynamic) {\n    return currentMirrorSystem().dynamicType;\n  }\n  return js.reflectType(key);\n}\n\u0000","sdk:/sdk/lib/_internal/lib/typed_data_patch.dart":"// Copyright (c) 2013, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\n\nimport 'dart:_internal' show FixedLengthListMixin;\nimport 'dart:_foreign_helper' show JS;\nimport 'dart:math' as Math;\nimport 'dart:_internal';\nimport 'dart:_interceptors' show JSIndexable, JSUInt32, JSUInt31;\nimport 'dart:_js_helper'\n    show Creates, JavaScriptIndexingBehavior, JSName, Null, Returns, patch;\nimport 'dart:_native_typed_data';\n\n@patch class ByteData {\n  @patch factory ByteData(int length) = NativeByteData;\n}\n\n\n@patch class Float32List {\n  @patch factory Float32List(int length) = NativeFloat32List;\n\n  @patch factory Float32List.fromList(List<double> elements) =\n      NativeFloat32List.fromList;\n}\n\n\n@patch class Float64List {\n  @patch factory Float64List(int length) = NativeFloat64List;\n\n  @patch factory Float64List.fromList(List<double> elements) =\n      NativeFloat64List.fromList;\n}\n\n\n@patch class Int16List {\n  @patch factory Int16List(int length) = NativeInt16List;\n\n  @patch factory Int16List.fromList(List<int> elements) =\n      NativeInt16List.fromList;\n}\n\n@patch class Int32List {\n  @patch factory Int32List(int length) = NativeInt32List;\n\n  @patch factory Int32List.fromList(List<int> elements) =\n      NativeInt32List.fromList;\n}\n\n\n@patch class Int8List {\n  @patch factory Int8List(int length) = NativeInt8List;\n\n  @patch factory Int8List.fromList(List<int> elements) =\n      NativeInt8List.fromList;\n}\n\n\n@patch class Uint32List {\n  @patch factory Uint32List(int length) = NativeUint32List;\n\n  @patch factory Uint32List.fromList(List<int> elements) =\n      NativeUint32List.fromList;\n}\n\n\n@patch class Uint16List {\n  @patch factory Uint16List(int length) = NativeUint16List;\n\n  @patch factory Uint16List.fromList(List<int> elements) =\n      NativeUint16List.fromList;\n}\n\n\n@patch class Uint8ClampedList {\n  @patch factory Uint8ClampedList(int length) = NativeUint8ClampedList;\n\n  @patch factory Uint8ClampedList.fromList(List<int> elements) =\n      NativeUint8ClampedList.fromList;\n}\n\n\n@patch class Uint8List {\n  @patch factory Uint8List(int length) = NativeUint8List;\n\n  @patch factory Uint8List.fromList(List<int> elements) =\n      NativeUint8List.fromList;\n}\n\n\n@patch class Int64List {\n  @patch factory Int64List(int length) {\n    throw new UnsupportedError(\"Int64List not supported by dart2js.\");\n  }\n\n  @patch factory Int64List.fromList(List<int> elements) {\n    throw new UnsupportedError(\"Int64List not supported by dart2js.\");\n  }\n}\n\n\n@patch class Uint64List {\n  @patch factory Uint64List(int length) {\n    throw new UnsupportedError(\"Uint64List not supported by dart2js.\");\n  }\n\n  @patch factory Uint64List.fromList(List<int> elements) {\n    throw new UnsupportedError(\"Uint64List not supported by dart2js.\");\n  }\n}\n\n@patch class Int32x4List {\n  @patch factory Int32x4List(int length) = NativeInt32x4List;\n\n  @patch factory Int32x4List.fromList(List<Int32x4> elements) =\n      NativeInt32x4List.fromList;\n}\n\n@patch class Float32x4List {\n  @patch factory Float32x4List(int length) = NativeFloat32x4List;\n\n  @patch factory Float32x4List.fromList(List<Float32x4> elements) =\n      NativeFloat32x4List.fromList;\n}\n\n@patch class Float64x2List {\n  @patch factory Float64x2List(int length) = NativeFloat64x2List;\n\n  @patch factory Float64x2List.fromList(List<Float64x2> elements) =\n      NativeFloat64x2List.fromList;\n}\n\n@patch class Float32x4 {\n  @patch factory Float32x4(double x, double y, double z, double w) =\n      NativeFloat32x4;\n  @patch factory Float32x4.splat(double v) = NativeFloat32x4.splat;\n  @patch factory Float32x4.zero() = NativeFloat32x4.zero;\n  @patch factory Float32x4.fromInt32x4Bits(Int32x4 x) =\n      NativeFloat32x4.fromInt32x4Bits;\n  @patch factory Float32x4.fromFloat64x2(Float64x2 v) =\n      NativeFloat32x4.fromFloat64x2;\n}\n\n@patch class Int32x4 {\n  @patch factory Int32x4(int x, int y, int z, int w) = NativeInt32x4;\n  @patch factory Int32x4.bool(bool x, bool y, bool z, bool w) =\n      NativeInt32x4.bool;\n  @patch factory Int32x4.fromFloat32x4Bits(Float32x4 x) =\n      NativeInt32x4.fromFloat32x4Bits;\n}\n\n@patch class Float64x2 {\n  @patch factory Float64x2(double x, double y) = NativeFloat64x2;\n  @patch factory Float64x2.splat(double v) = NativeFloat64x2.splat;\n  @patch factory Float64x2.zero() = NativeFloat64x2.zero;\n  @patch factory Float64x2.fromFloat32x4(Float32x4 v) =\n      NativeFloat64x2.fromFloat32x4;\n}\n\u0000","sdk:/sdk/lib/_internal/lib/internal_patch.dart":"// Copyright (c) 2013, the Dart project authors.  Please see the AUTHORS file\n// for details. All rights reserved. Use of this source code is governed by a\n// BSD-style license that can be found in the LICENSE file.\n\nimport 'dart:_js_primitives' show printString;\nimport 'dart:_js_helper' show JS, patch;\nimport 'dart:_interceptors' show JSArray;\n\n@patch\nclass Symbol implements core.Symbol {\n  @patch\n  const Symbol(String name)\n      : this._name = name;\n}\n\n@patch\nvoid printToConsole(String line) {\n  printString('$line');\n}\n\n@patch\nList makeListFixedLength(List growableList) {\n  JSArray.markFixedList(growableList);\n  return growableList;\n}\n\u0000"}