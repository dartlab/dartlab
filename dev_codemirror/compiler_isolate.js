// Generated by dart2js, the Dart to JavaScript compiler version: 1.6.0-edge.39328.
// The code supports the following hooks:
// dartPrint(message):
//    if this function is defined it is called instead of the Dart [print]
//    method.
//
// dartMainRunner(main, args):
//    if this function is defined, the Dart [main] method will not be invoked
//    directly. Instead, a closure that will invoke [main], and its arguments
//    [args] is passed to [dartMainRunner].
(function($) {
function dart(){ this.x = 0 }var A = new dart;
delete A.x;
var B = new dart;
delete B.x;
var C = new dart;
delete C.x;
var D = new dart;
delete D.x;
var E = new dart;
delete E.x;
var F = new dart;
delete F.x;
var G = new dart;
delete G.x;
var H = new dart;
delete H.x;
var J = new dart;
delete J.x;
var K = new dart;
delete K.x;
var L = new dart;
delete L.x;
var M = new dart;
delete M.x;
var N = new dart;
delete N.x;
var O = new dart;
delete O.x;
var P = new dart;
delete P.x;
var Q = new dart;
delete Q.x;
var R = new dart;
delete R.x;
var S = new dart;
delete S.x;
var T = new dart;
delete T.x;
var U = new dart;
delete U.x;
var V = new dart;
delete V.x;
var W = new dart;
delete W.x;
var X = new dart;
delete X.x;
var Y = new dart;
delete Y.x;
var Z = new dart;
delete Z.x;
function Isolate() {}
init();

$ = Isolate.$isolateProperties;
var $$ = {};

// Native classes
(function(reflectionData) {
  "use strict";
  function map(x) {
    x = {x: x};
    delete x.x;
    return x;
  }
  function processStatics(descriptor) {
    for (var property in descriptor) {
      if (!hasOwnProperty.call(descriptor, property))
        continue;
      if (property === "^")
        continue;
      var element = descriptor[property];
      var firstChar = property.substring(0, 1);
      var previousProperty;
      if (firstChar === "+") {
        mangledGlobalNames[previousProperty] = property.substring(1);
        var flag = descriptor[property];
        if (flag > 0)
          descriptor[previousProperty].$reflectable = flag;
        if (element && element.length)
          init.typeInformation[previousProperty] = element;
      } else if (firstChar === "@") {
        property = property.substring(1);
        $[property]["@"] = element;
      } else if (firstChar === "*") {
        globalObject[previousProperty].$defaultValues = element;
        var optionalMethods = descriptor.$methodsWithOptionalArguments;
        if (!optionalMethods) {
          descriptor.$methodsWithOptionalArguments = optionalMethods = {};
        }
        optionalMethods[property] = previousProperty;
      } else if (typeof element === "function") {
        globalObject[previousProperty = property] = element;
        functions.push(property);
        init.globalFunctions[property] = element;
      } else if (element.constructor === Array) {
        addStubs(globalObject, element, property, true, descriptor, functions);
      } else {
        previousProperty = property;
        var newDesc = {};
        var previousProp;
        for (var prop in element) {
          if (!hasOwnProperty.call(element, prop))
            continue;
          firstChar = prop.substring(0, 1);
          if (prop === "static") {
            processStatics(init.statics[property] = element[prop]);
          } else if (firstChar === "+") {
            mangledNames[previousProp] = prop.substring(1);
            var flag = element[prop];
            if (flag > 0)
              element[previousProp].$reflectable = flag;
          } else if (firstChar === "@" && prop !== "@") {
            newDesc[prop.substring(1)]["@"] = element[prop];
          } else if (firstChar === "*") {
            newDesc[previousProp].$defaultValues = element[prop];
            var optionalMethods = newDesc.$methodsWithOptionalArguments;
            if (!optionalMethods) {
              newDesc.$methodsWithOptionalArguments = optionalMethods = {};
            }
            optionalMethods[prop] = previousProp;
          } else {
            var elem = element[prop];
            if (prop !== "^" && elem != null && elem.constructor === Array && prop !== "<>") {
              addStubs(newDesc, elem, prop, false, element, []);
            } else {
              newDesc[previousProp = prop] = elem;
            }
          }
        }
        $$[property] = [globalObject, newDesc];
        classes.push(property);
      }
    }
  }
  function addStubs(descriptor, array, name, isStatic, originalDescriptor, functions) {
    var f, funcs = [originalDescriptor[name] = descriptor[name] = f = array[0]];
    f.$stubName = name;
    functions.push(name);
    for (var index = 0; index < array.length; index += 2) {
      f = array[index + 1];
      if (typeof f != "function")
        break;
      f.$stubName = array[index + 2];
      funcs.push(f);
      if (f.$stubName) {
        originalDescriptor[f.$stubName] = descriptor[f.$stubName] = f;
        functions.push(f.$stubName);
      }
    }
    for (var i = 0; i < funcs.length; index++, i++) {
      funcs[i].$callName = array[index + 1];
    }
    var getterStubName = array[++index];
    array = array.slice(++index);
    var requiredParameterInfo = array[0];
    var requiredParameterCount = requiredParameterInfo >> 1;
    var isAccessor = (requiredParameterInfo & 1) === 1;
    var isSetter = requiredParameterInfo === 3;
    var isGetter = requiredParameterInfo === 1;
    var optionalParameterInfo = array[1];
    var optionalParameterCount = optionalParameterInfo >> 1;
    var optionalParametersAreNamed = (optionalParameterInfo & 1) === 1;
    var isIntercepted = requiredParameterCount + optionalParameterCount != funcs[0].length;
    var functionTypeIndex = array[2];
    var unmangledNameIndex = 2 * optionalParameterCount + requiredParameterCount + 3;
    var isReflectable = array.length > unmangledNameIndex;
    if (getterStubName) {
      f = tearOff(funcs, array, isStatic, name, isIntercepted);
      descriptor[name].$getter = f;
      f.$getterStub = true;
      if (isStatic)
        init.globalFunctions[name] = f;
      originalDescriptor[getterStubName] = descriptor[getterStubName] = f;
      funcs.push(f);
      if (getterStubName)
        functions.push(getterStubName);
      f.$stubName = getterStubName;
      f.$callName = null;
      if (isIntercepted)
        init.interceptedNames[getterStubName] = true;
    }
    if (isReflectable) {
      for (var i = 0; i < funcs.length; i++) {
        funcs[i].$reflectable = 1;
        funcs[i].$reflectionInfo = array;
      }
      var mangledNames = isStatic ? init.mangledGlobalNames : init.mangledNames;
      var unmangledName = array[unmangledNameIndex];
      var reflectionName = unmangledName;
      if (getterStubName)
        mangledNames[getterStubName] = reflectionName;
      if (isSetter) {
        reflectionName += "=";
      } else if (!isGetter) {
        reflectionName += ":" + requiredParameterCount + ":" + optionalParameterCount;
      }
      mangledNames[name] = reflectionName;
      funcs[0].$reflectionName = reflectionName;
      funcs[0].$metadataIndex = unmangledNameIndex + 1;
      if (optionalParameterCount)
        descriptor[unmangledName + "*"] = funcs[0];
    }
  }
  function tearOffGetterNoCsp(funcs, reflectionInfo, name, isIntercepted) {
    return isIntercepted ? new Function("funcs", "reflectionInfo", "name", "H", "c", "return function tearOff_" + name + functionCounter++ + "(x) {" + "if (c === null) c = H.closureFromTearOff(" + "this, funcs, reflectionInfo, false, [x], name);" + "return new c(this, funcs[0], x, name);" + "}")(funcs, reflectionInfo, name, H, null) : new Function("funcs", "reflectionInfo", "name", "H", "c", "return function tearOff_" + name + functionCounter++ + "() {" + "if (c === null) c = H.closureFromTearOff(" + "this, funcs, reflectionInfo, false, [], name);" + "return new c(this, funcs[0], null, name);" + "}")(funcs, reflectionInfo, name, H, null);
  }
  function tearOffGetterCsp(funcs, reflectionInfo, name, isIntercepted) {
    var cache = null;
    return isIntercepted ? function(x) {
      if (cache === null)
        cache = H.closureFromTearOff(this, funcs, reflectionInfo, false, [x], name);
      return new cache(this, funcs[0], x, name);
    } : function() {
      if (cache === null)
        cache = H.closureFromTearOff(this, funcs, reflectionInfo, false, [], name);
      return new cache(this, funcs[0], null, name);
    };
  }
  function tearOff(funcs, reflectionInfo, isStatic, name, isIntercepted) {
    var cache;
    return isStatic ? function() {
      if (cache === void 0)
        cache = H.closureFromTearOff(this, funcs, reflectionInfo, true, [], name).prototype;
      return cache;
    } : tearOffGetter(funcs, reflectionInfo, name, isIntercepted);
  }
  var functionCounter = 0;
  var tearOffGetter = typeof dart_precompiled == "function" ? tearOffGetterCsp : tearOffGetterNoCsp;
  if (!init.libraries)
    init.libraries = [];
  if (!init.mangledNames)
    init.mangledNames = map();
  if (!init.mangledGlobalNames)
    init.mangledGlobalNames = map();
  if (!init.statics)
    init.statics = map();
  if (!init.typeInformation)
    init.typeInformation = map();
  if (!init.globalFunctions)
    init.globalFunctions = map();
  if (!init.interceptedNames)
    init.interceptedNames = map();
  var libraries = init.libraries;
  var mangledNames = init.mangledNames;
  var mangledGlobalNames = init.mangledGlobalNames;
  var hasOwnProperty = Object.prototype.hasOwnProperty;
  var length = reflectionData.length;
  for (var i = 0; i < length; i++) {
    var data = reflectionData[i];
    var name = data[0];
    var uri = data[1];
    var metadata = data[2];
    var globalObject = data[3];
    var descriptor = data[4];
    var isRoot = !!data[5];
    var fields = descriptor && descriptor["^"];
    if (fields instanceof Array)
      fields = fields[0];
    var classes = [];
    var functions = [];
    processStatics(descriptor);
    libraries.push([name, uri, classes, functions, metadata, fields, isRoot, globalObject]);
  }
})([
["_foreign_helper", "dart:_foreign_helper", , H, {
  "^": "",
  JS_CONST: {
    "^": "Object;code"
  }
}],
["_interceptors", "dart:_interceptors", , J, {
  "^": "",
  getInterceptor: function(object) {
    return void 0;
  },
  makeDispatchRecord: function(interceptor, proto, extension, indexability) {
    return {i: interceptor, p: proto, e: extension, x: indexability};
  },
  getNativeInterceptor: function(object) {
    var record, proto, objectProto, interceptor;
    record = object[init.dispatchPropertyName];
    if (record == null)
      if ($.initNativeDispatchFlag == null) {
        H.initNativeDispatch();
        record = object[init.dispatchPropertyName];
      }
    if (record != null) {
      proto = record.p;
      if (false === proto)
        return record.i;
      if (true === proto)
        return object;
      objectProto = Object.getPrototypeOf(object);
      if (proto === objectProto)
        return record.i;
      if (record.e === objectProto)
        throw H.wrapException(P.UnimplementedError$("Return interceptor for " + H.S(proto(object, record))));
    }
    interceptor = H.lookupAndCacheInterceptor(object);
    if (interceptor == null) {
      proto = Object.getPrototypeOf(object);
      if (proto == null || proto === Object.prototype)
        return C.PlainJavaScriptObject_methods;
      else
        return C.UnknownJavaScriptObject_methods;
    }
    return interceptor;
  },
  Interceptor: {
    "^": "Object;",
    $eq: function(receiver, other) {
      return receiver === other;
    },
    get$hashCode: function(receiver) {
      return H.Primitives_objectHashCode(receiver);
    },
    toString$0: function(receiver) {
      return H.Primitives_objectToString(receiver);
    },
    "%": "ArrayBuffer|DOMImplementation|MediaError|MediaKeyError|Navigator|PositionError|SQLError|SVGAnimatedEnumeration|SVGAnimatedLength|SVGAnimatedLengthList|SVGAnimatedNumber|SVGAnimatedNumberList|SVGAnimatedString"
  },
  JSBool: {
    "^": "Interceptor;",
    toString$0: function(receiver) {
      return String(receiver);
    },
    get$hashCode: function(receiver) {
      return receiver ? 519018 : 218159;
    },
    $isbool: true
  },
  JSNull: {
    "^": "Interceptor;",
    $eq: function(receiver, other) {
      return null == other;
    },
    toString$0: function(receiver) {
      return "null";
    },
    get$hashCode: function(receiver) {
      return 0;
    }
  },
  JavaScriptObject: {
    "^": "Interceptor;",
    get$hashCode: function(_) {
      return 0;
    }
  },
  PlainJavaScriptObject: {
    "^": "JavaScriptObject;"
  },
  UnknownJavaScriptObject: {
    "^": "JavaScriptObject;",
    toString$0: function(receiver) {
      return String(receiver);
    }
  },
  JSArray: {
    "^": "Interceptor;",
    add$1: [function(receiver, value) {
      if (!!receiver.fixed$length)
        H.throwExpression(P.UnsupportedError$("add"));
      receiver.push(value);
    }, "call$1", "get$add", 2, 0, function() {
      return H.computeSignature(function(E) {
        return {func: "void__E", void: true, args: [E]};
      }, this.$receiver, "JSArray");
    }],
    insert$2: function(receiver, index, value) {
      if (index < 0 || index > receiver.length)
        throw H.wrapException(P.RangeError$value(index));
      if (!!receiver.fixed$length)
        H.throwExpression(P.UnsupportedError$("insert"));
      receiver.splice(index, 0, value);
    },
    removeLast$0: function(receiver) {
      if (!!receiver.fixed$length)
        H.throwExpression(P.UnsupportedError$("removeLast"));
      if (receiver.length === 0)
        throw H.wrapException(P.RangeError$value(-1));
      return receiver.pop();
    },
    remove$1: function(receiver, element) {
      var i;
      if (!!receiver.fixed$length)
        H.throwExpression(P.UnsupportedError$("remove"));
      for (i = 0; i < receiver.length; ++i)
        if (J.$eq(receiver[i], element)) {
          receiver.splice(i, 1);
          return true;
        }
      return false;
    },
    removeWhere$1: function(receiver, test) {
      H.IterableMixinWorkaround_removeWhereList(receiver, test);
    },
    where$1: function(receiver, f) {
      return H.setRuntimeTypeInfo(new H.WhereIterable(receiver, f), [H.getTypeArgumentByIndex(H.setRuntimeTypeInfo(new H.IterableMixinWorkaround(), [H.getTypeArgumentByIndex(receiver, 0)]), 0)]);
    },
    expand$1: function(receiver, f) {
      return H.setRuntimeTypeInfo(new H.ExpandIterable(receiver, f), [null, null]);
    },
    addAll$1: function(receiver, collection) {
      var t1;
      for (t1 = J.get$iterator$ax(collection); t1.moveNext$0();)
        this.add$1(receiver, t1.get$current());
    },
    clear$0: function(receiver) {
      this.set$length(receiver, 0);
    },
    forEach$1: function(receiver, f) {
      return H.IterableMixinWorkaround_forEach(receiver, f);
    },
    map$1: function(receiver, f) {
      return H.setRuntimeTypeInfo(new H.MappedListIterable(receiver, f), [null, null]);
    },
    join$1: function(receiver, separator) {
      var t1, list, i, t2;
      t1 = receiver.length;
      list = Array(t1);
      list.fixed$length = init;
      for (i = 0; i < receiver.length; ++i) {
        t2 = H.S(receiver[i]);
        if (i >= t1)
          return H.ioore(list, i);
        list[i] = t2;
      }
      return list.join(separator);
    },
    join$0: function($receiver) {
      return this.join$1($receiver, "");
    },
    skip$1: function(receiver, n) {
      return H.SubListIterable$(receiver, n, null, H.getTypeArgumentByIndex(H.setRuntimeTypeInfo(new H.IterableMixinWorkaround(), [H.getTypeArgumentByIndex(receiver, 0)]), 0));
    },
    fold$2: function(receiver, initialValue, combine) {
      return H.IterableMixinWorkaround_fold(receiver, initialValue, combine);
    },
    elementAt$1: function(receiver, index) {
      if (index >>> 0 !== index || index >= receiver.length)
        return H.ioore(receiver, index);
      return receiver[index];
    },
    sublist$2: function(receiver, start, end) {
      if (start < 0 || start > receiver.length)
        throw H.wrapException(P.RangeError$range(start, 0, receiver.length));
      if (end == null)
        end = receiver.length;
      else if (end < start || end > receiver.length)
        throw H.wrapException(P.RangeError$range(end, start, receiver.length));
      if (start === end)
        return H.setRuntimeTypeInfo([], [H.getTypeArgumentByIndex(receiver, 0)]);
      return H.setRuntimeTypeInfo(receiver.slice(start, end), [H.getTypeArgumentByIndex(receiver, 0)]);
    },
    sublist$1: function($receiver, start) {
      return this.sublist$2($receiver, start, null);
    },
    getRange$2: function(receiver, start, end) {
      var t1 = H.setRuntimeTypeInfo(new H.IterableMixinWorkaround(), [H.getTypeArgumentByIndex(receiver, 0)]);
      H.IterableMixinWorkaround__rangeCheck(receiver, start, end);
      return H.SubListIterable$(receiver, start, end, H.getTypeArgumentByIndex(t1, 0));
    },
    get$first: function(receiver) {
      if (receiver.length > 0)
        return receiver[0];
      throw H.wrapException(P.StateError$("No elements"));
    },
    get$last: function(receiver) {
      var t1 = receiver.length;
      if (t1 > 0)
        return receiver[t1 - 1];
      throw H.wrapException(P.StateError$("No elements"));
    },
    get$single: function(receiver) {
      var t1 = receiver.length;
      if (t1 === 1) {
        if (0 >= t1)
          return H.ioore(receiver, 0);
        return receiver[0];
      }
      if (t1 === 0)
        throw H.wrapException(P.StateError$("No elements"));
      throw H.wrapException(P.StateError$("More than one element"));
    },
    any$1: function(receiver, f) {
      return H.IterableMixinWorkaround_any(receiver, f);
    },
    every$1: function(receiver, f) {
      return H.IterableMixinWorkaround_every(receiver, f);
    },
    indexOf$2: function(receiver, element, start) {
      return H.Lists_indexOf(receiver, element, start, receiver.length);
    },
    indexOf$1: function($receiver, element) {
      return this.indexOf$2($receiver, element, 0);
    },
    contains$1: function(receiver, other) {
      var i;
      for (i = 0; i < receiver.length; ++i)
        if (J.$eq(receiver[i], other))
          return true;
      return false;
    },
    get$isEmpty: function(receiver) {
      return receiver.length === 0;
    },
    get$isNotEmpty: function(receiver) {
      return receiver.length !== 0;
    },
    toString$0: function(receiver) {
      return P.IterableBase_iterableToFullString(receiver, "[", "]");
    },
    toList$1$growable: function(receiver, growable) {
      var t1;
      if (growable)
        return H.setRuntimeTypeInfo(receiver.slice(), [H.getTypeArgumentByIndex(receiver, 0)]);
      else {
        t1 = H.setRuntimeTypeInfo(receiver.slice(), [H.getTypeArgumentByIndex(receiver, 0)]);
        t1.fixed$length = init;
        return t1;
      }
    },
    toList$0: function($receiver) {
      return this.toList$1$growable($receiver, true);
    },
    toSet$0: function(receiver) {
      var t1 = P.LinkedHashSet_LinkedHashSet(null, null, null, H.getTypeArgumentByIndex(receiver, 0));
      t1.addAll$1(0, receiver);
      return t1;
    },
    get$iterator: function(receiver) {
      return H.setRuntimeTypeInfo(new H.ListIterator(receiver, receiver.length, 0, null), [H.getTypeArgumentByIndex(receiver, 0)]);
    },
    get$hashCode: function(receiver) {
      return H.Primitives_objectHashCode(receiver);
    },
    get$length: function(receiver) {
      return receiver.length;
    },
    set$length: function(receiver, newLength) {
      if (typeof newLength !== "number" || Math.floor(newLength) !== newLength)
        throw H.wrapException(P.ArgumentError$(newLength));
      if (newLength < 0)
        throw H.wrapException(P.RangeError$value(newLength));
      if (!!receiver.fixed$length)
        H.throwExpression(P.UnsupportedError$("set length"));
      receiver.length = newLength;
    },
    $index: function(receiver, index) {
      if (typeof index !== "number" || Math.floor(index) !== index)
        throw H.wrapException(P.ArgumentError$(index));
      if (index >= receiver.length || index < 0)
        throw H.wrapException(P.RangeError$value(index));
      return receiver[index];
    },
    $indexSet: function(receiver, index, value) {
      if (!!receiver.immutable$list)
        H.throwExpression(P.UnsupportedError$("indexed set"));
      if (typeof index !== "number" || Math.floor(index) !== index)
        throw H.wrapException(P.ArgumentError$(index));
      if (index >= receiver.length || index < 0)
        throw H.wrapException(P.RangeError$value(index));
      receiver[index] = value;
    },
    $isJSArray: true,
    $isList: true,
    $asList: null,
    $isEfficientLength: true,
    $isIterable: true,
    $asIterable: null,
    static: {JSArray_JSArray$fixed: function($length, $E) {
        var t1;
        if (typeof $length !== "number" || Math.floor($length) !== $length || $length < 0)
          throw H.wrapException(P.ArgumentError$("Length must be a non-negative integer: " + H.S($length)));
        t1 = H.setRuntimeTypeInfo(new Array($length), [$E]);
        t1.fixed$length = init;
        return t1;
      }}
  },
  JSNumber: {
    "^": "Interceptor;",
    compareTo$1: function(receiver, b) {
      var bIsNegative;
      if (typeof b !== "number")
        throw H.wrapException(P.ArgumentError$(b));
      if (receiver < b)
        return -1;
      else if (receiver > b)
        return 1;
      else if (receiver === b) {
        if (receiver === 0) {
          bIsNegative = this.get$isNegative(b);
          if (this.get$isNegative(receiver) === bIsNegative)
            return 0;
          if (this.get$isNegative(receiver))
            return -1;
          return 1;
        }
        return 0;
      } else if (isNaN(receiver)) {
        if (this.get$isNaN(b))
          return 0;
        return 1;
      } else
        return -1;
    },
    get$isNegative: function(receiver) {
      return receiver === 0 ? 1 / receiver < 0 : receiver < 0;
    },
    get$isNaN: function(receiver) {
      return isNaN(receiver);
    },
    get$isFinite: function(receiver) {
      return isFinite(receiver);
    },
    remainder$1: function(receiver, b) {
      return receiver % b;
    },
    abs$0: function(receiver) {
      return Math.abs(receiver);
    },
    toInt$0: function(receiver) {
      var t1;
      if (receiver >= -2147483648 && receiver <= 2147483647)
        return receiver | 0;
      if (isFinite(receiver)) {
        t1 = receiver < 0 ? Math.ceil(receiver) : Math.floor(receiver);
        return t1 + 0;
      }
      throw H.wrapException(P.UnsupportedError$('' + receiver));
    },
    roundToDouble$0: function(receiver) {
      if (receiver < 0)
        return -Math.round(-receiver);
      else
        return Math.round(receiver);
    },
    toDouble$0: function(receiver) {
      return receiver;
    },
    toRadixString$1: function(receiver, radix) {
      if (radix < 2 || radix > 36)
        throw H.wrapException(P.RangeError$(radix));
      return receiver.toString(radix);
    },
    toString$0: function(receiver) {
      if (receiver === 0 && 1 / receiver < 0)
        return "-0.0";
      else
        return "" + receiver;
    },
    get$hashCode: function(receiver) {
      return receiver & 0x1FFFFFFF;
    },
    $negate: function(receiver) {
      return -receiver;
    },
    $add: function(receiver, other) {
      if (typeof other !== "number")
        throw H.wrapException(P.ArgumentError$(other));
      return receiver + other;
    },
    $sub: function(receiver, other) {
      if (typeof other !== "number")
        throw H.wrapException(P.ArgumentError$(other));
      return receiver - other;
    },
    $mul: function(receiver, other) {
      if (typeof other !== "number")
        throw H.wrapException(P.ArgumentError$(other));
      return receiver * other;
    },
    $mod: function(receiver, other) {
      var result;
      if (typeof other !== "number")
        throw H.wrapException(P.ArgumentError$(other));
      result = receiver % other;
      if (result === 0)
        return 0;
      if (result > 0)
        return result;
      if (other < 0)
        return result - other;
      else
        return result + other;
    },
    $tdiv: function(receiver, other) {
      if ((receiver | 0) === receiver && (other | 0) === other && 0 !== other && -1 !== other)
        return receiver / other | 0;
      else {
        if (typeof other !== "number")
          H.throwExpression(P.ArgumentError$(other));
        return this.toInt$0(receiver / other);
      }
    },
    _tdivFast$1: function(receiver, other) {
      return (receiver | 0) === receiver ? receiver / other | 0 : this.toInt$0(receiver / other);
    },
    $shl: function(receiver, other) {
      if (other < 0)
        throw H.wrapException(P.ArgumentError$(other));
      return other > 31 ? 0 : receiver << other >>> 0;
    },
    _shlPositive$1: function(receiver, other) {
      return other > 31 ? 0 : receiver << other >>> 0;
    },
    $shr: function(receiver, other) {
      var t1;
      if (other < 0)
        throw H.wrapException(P.ArgumentError$(other));
      if (receiver > 0)
        t1 = other > 31 ? 0 : receiver >>> other;
      else {
        t1 = other > 31 ? 31 : other;
        t1 = receiver >> t1 >>> 0;
      }
      return t1;
    },
    _shrOtherPositive$1: function(receiver, other) {
      var t1;
      if (receiver > 0)
        t1 = other > 31 ? 0 : receiver >>> other;
      else {
        t1 = other > 31 ? 31 : other;
        t1 = receiver >> t1 >>> 0;
      }
      return t1;
    },
    _shrReceiverPositive$1: function(receiver, other) {
      if (other < 0)
        throw H.wrapException(P.ArgumentError$(other));
      return other > 31 ? 0 : receiver >>> other;
    },
    $and: function(receiver, other) {
      if (typeof other !== "number")
        throw H.wrapException(P.ArgumentError$(other));
      return (receiver & other) >>> 0;
    },
    $lt: function(receiver, other) {
      if (typeof other !== "number")
        throw H.wrapException(P.ArgumentError$(other));
      return receiver < other;
    },
    $gt: function(receiver, other) {
      if (typeof other !== "number")
        throw H.wrapException(P.ArgumentError$(other));
      return receiver > other;
    },
    $le: function(receiver, other) {
      if (typeof other !== "number")
        throw H.wrapException(P.ArgumentError$(other));
      return receiver <= other;
    },
    $ge: function(receiver, other) {
      if (typeof other !== "number")
        throw H.wrapException(P.ArgumentError$(other));
      return receiver >= other;
    },
    $isnum: true,
    static: {"^": "JSNumber__MIN_INT32,JSNumber__MAX_INT32"}
  },
  JSInt: {
    "^": "JSNumber;",
    $not: function(receiver) {
      return ~receiver >>> 0;
    },
    $is$double: true,
    $isnum: true,
    $is$int: true
  },
  JSDouble: {
    "^": "JSNumber;",
    $is$double: true,
    $isnum: true
  },
  JSString: {
    "^": "Interceptor;",
    codeUnitAt$1: function(receiver, index) {
      if (typeof index !== "number" || Math.floor(index) !== index)
        throw H.wrapException(P.ArgumentError$(index));
      if (index < 0)
        throw H.wrapException(P.RangeError$value(index));
      if (index >= receiver.length)
        throw H.wrapException(P.RangeError$value(index));
      return receiver.charCodeAt(index);
    },
    allMatches$2: function(receiver, string, start) {
      if (start > string.length)
        throw H.wrapException(P.RangeError$range(start, 0, string.length));
      return H.allMatchesInStringUnchecked(receiver, string, start);
    },
    allMatches$1: function($receiver, string) {
      return this.allMatches$2($receiver, string, 0);
    },
    matchAsPrefix$2: function(receiver, string, start) {
      var t1, t2, i, t3;
      if (start < 0 || start > string.length)
        throw H.wrapException(P.RangeError$range(start, 0, string.length));
      t1 = receiver.length;
      t2 = string.length;
      if (start + t1 > t2)
        return;
      for (i = 0; i < t1; ++i) {
        t3 = start + i;
        if (t3 < 0)
          H.throwExpression(P.RangeError$value(t3));
        if (t3 >= t2)
          H.throwExpression(P.RangeError$value(t3));
        t3 = string.charCodeAt(t3);
        if (i >= t1)
          H.throwExpression(P.RangeError$value(i));
        if (t3 !== receiver.charCodeAt(i))
          return;
      }
      return new H.StringMatch(start, string, receiver);
    },
    $add: function(receiver, other) {
      if (typeof other !== "string")
        throw H.wrapException(P.ArgumentError$(other));
      return receiver + other;
    },
    endsWith$1: function(receiver, other) {
      var otherLength, t1;
      otherLength = other.length;
      t1 = receiver.length;
      if (otherLength > t1)
        return false;
      return other === this.substring$1(receiver, t1 - otherLength);
    },
    replaceAll$2: function(receiver, from, to) {
      return H.stringReplaceAllUnchecked(receiver, from, to);
    },
    startsWith$2: function(receiver, pattern, index) {
      var endIndex;
      if (index > receiver.length)
        throw H.wrapException(P.RangeError$range(index, 0, receiver.length));
      if (typeof pattern === "string") {
        endIndex = index + pattern.length;
        if (endIndex > receiver.length)
          return false;
        return pattern === receiver.substring(index, endIndex);
      }
      return J.matchAsPrefix$2$s(pattern, receiver, index) != null;
    },
    startsWith$1: function($receiver, pattern) {
      return this.startsWith$2($receiver, pattern, 0);
    },
    substring$2: function(receiver, startIndex, endIndex) {
      if (endIndex == null)
        endIndex = receiver.length;
      if (typeof endIndex !== "number" || Math.floor(endIndex) !== endIndex)
        H.throwExpression(P.ArgumentError$(endIndex));
      if (startIndex < 0)
        throw H.wrapException(P.RangeError$value(startIndex));
      if (typeof endIndex !== "number")
        return H.iae(endIndex);
      if (startIndex > endIndex)
        throw H.wrapException(P.RangeError$value(startIndex));
      if (endIndex > receiver.length)
        throw H.wrapException(P.RangeError$value(endIndex));
      return receiver.substring(startIndex, endIndex);
    },
    substring$1: function($receiver, startIndex) {
      return this.substring$2($receiver, startIndex, null);
    },
    toLowerCase$0: function(receiver) {
      return receiver.toLowerCase();
    },
    trim$0: function(receiver) {
      var result, endIndex, startIndex, t1, endIndex0;
      result = receiver.trim();
      endIndex = result.length;
      if (endIndex === 0)
        return result;
      if (this.codeUnitAt$1(result, 0) === 133) {
        startIndex = J.JSString__skipLeadingWhitespace(result, 1);
        if (startIndex === endIndex)
          return "";
      } else
        startIndex = 0;
      t1 = endIndex - 1;
      endIndex0 = this.codeUnitAt$1(result, t1) === 133 ? J.JSString__skipTrailingWhitespace(result, t1) : endIndex;
      if (startIndex === 0 && endIndex0 === endIndex)
        return result;
      return result.substring(startIndex, endIndex0);
    },
    $mul: function(receiver, times) {
      var s, result;
      if (typeof times !== "number")
        return H.iae(times);
      if (0 >= times)
        return "";
      if (times === 1 || receiver.length === 0)
        return receiver;
      if (times !== times >>> 0)
        throw H.wrapException(C.C_OutOfMemoryError);
      for (s = receiver, result = ""; true;) {
        if ((times & 1) === 1)
          result = s + result;
        times = times >>> 1;
        if (times === 0)
          break;
        s += s;
      }
      return result;
    },
    get$codeUnits: function(receiver) {
      return new J._CodeUnits(receiver);
    },
    indexOf$2: function(receiver, pattern, start) {
      if (start < 0 || start > receiver.length)
        throw H.wrapException(P.RangeError$range(start, 0, receiver.length));
      return receiver.indexOf(pattern, start);
    },
    indexOf$1: function($receiver, pattern) {
      return this.indexOf$2($receiver, pattern, 0);
    },
    lastIndexOf$2: function(receiver, pattern, start) {
      var t1, t2;
      start = receiver.length;
      t1 = pattern.length;
      t2 = receiver.length;
      if (start + t1 > t2)
        start = t2 - t1;
      return receiver.lastIndexOf(pattern, start);
    },
    lastIndexOf$1: function($receiver, pattern) {
      return this.lastIndexOf$2($receiver, pattern, null);
    },
    contains$2: function(receiver, other, startIndex) {
      if (other == null)
        H.throwExpression(P.ArgumentError$(null));
      if (typeof startIndex !== "number")
        return startIndex.$lt();
      if (startIndex > receiver.length)
        throw H.wrapException(P.RangeError$range(startIndex, 0, receiver.length));
      return H.stringContainsUnchecked(receiver, other, startIndex);
    },
    contains$1: function($receiver, other) {
      return this.contains$2($receiver, other, 0);
    },
    get$isEmpty: function(receiver) {
      return receiver.length === 0;
    },
    compareTo$1: function(receiver, other) {
      var t1;
      if (typeof other !== "string")
        throw H.wrapException(P.ArgumentError$(other));
      if (receiver === other)
        t1 = 0;
      else
        t1 = receiver < other ? -1 : 1;
      return t1;
    },
    toString$0: function(receiver) {
      return receiver;
    },
    get$hashCode: function(receiver) {
      var t1, hash, i;
      for (t1 = receiver.length, hash = 0, i = 0; i < t1; ++i) {
        hash = 536870911 & hash + receiver.charCodeAt(i);
        hash = 536870911 & hash + ((524287 & hash) << 10 >>> 0);
        hash ^= hash >> 6;
      }
      hash = 536870911 & hash + ((67108863 & hash) << 3 >>> 0);
      hash ^= hash >> 11;
      return 536870911 & hash + ((16383 & hash) << 15 >>> 0);
    },
    get$length: function(receiver) {
      return receiver.length;
    },
    $index: function(receiver, index) {
      if (typeof index !== "number" || Math.floor(index) !== index)
        throw H.wrapException(P.ArgumentError$(index));
      if (index >= receiver.length || index < 0)
        throw H.wrapException(P.RangeError$value(index));
      return receiver[index];
    },
    $isString: true,
    $isPattern: true,
    static: {JSString__isWhitespace: function(codeUnit) {
        if (codeUnit < 256)
          switch (codeUnit) {
            case 9:
            case 10:
            case 11:
            case 12:
            case 13:
            case 32:
            case 133:
            case 160:
              return true;
            default:
              return false;
          }
        switch (codeUnit) {
          case 5760:
          case 6158:
          case 8192:
          case 8193:
          case 8194:
          case 8195:
          case 8196:
          case 8197:
          case 8198:
          case 8199:
          case 8200:
          case 8201:
          case 8202:
          case 8232:
          case 8233:
          case 8239:
          case 8287:
          case 12288:
          case 65279:
            return true;
          default:
            return false;
        }
      }, JSString__skipLeadingWhitespace: function(string, index) {
        var t1, codeUnit;
        for (t1 = string.length; index < t1;) {
          if (index >= t1)
            H.throwExpression(P.RangeError$value(index));
          codeUnit = string.charCodeAt(index);
          if (codeUnit !== 32 && codeUnit !== 13 && !J.JSString__isWhitespace(codeUnit))
            break;
          ++index;
        }
        return index;
      }, JSString__skipTrailingWhitespace: function(string, index) {
        var t1, index0, codeUnit;
        for (t1 = string.length; index > 0; index = index0) {
          index0 = index - 1;
          if (index0 >= t1)
            H.throwExpression(P.RangeError$value(index0));
          codeUnit = string.charCodeAt(index0);
          if (codeUnit !== 32 && codeUnit !== 13 && !J.JSString__isWhitespace(codeUnit))
            break;
        }
        return index;
      }}
  },
  _CodeUnits: {
    "^": "UnmodifiableListBase;__interceptors$_string",
    get$length: function(_) {
      return this.__interceptors$_string.length;
    },
    $index: function(_, i) {
      var t1, t2;
      t1 = this.__interceptors$_string;
      if (typeof i !== "number" || Math.floor(i) !== i)
        H.throwExpression(P.ArgumentError$(i));
      t2 = J.getInterceptor$n(i);
      if (t2.$lt(i, 0))
        H.throwExpression(P.RangeError$value(i));
      if (t2.$ge(i, t1.length))
        H.throwExpression(P.RangeError$value(i));
      return t1.charCodeAt(i);
    },
    $asUnmodifiableListBase: function() {
      return [P.$int];
    },
    $asListBase: function() {
      return [P.$int];
    },
    $asObject_ListMixin: function() {
      return [P.$int];
    },
    $asList: function() {
      return [P.$int];
    },
    $asIterable: function() {
      return [P.$int];
    }
  }
}],
["_isolate_helper", "dart:_isolate_helper", , H, {
  "^": "",
  _callInIsolate: function(isolate, $function) {
    var result = isolate.eval$1($function);
    init.globalState.topEventLoop.run$0();
    return result;
  },
  leaveJsAsync: function() {
    --init.globalState.topEventLoop._activeJsAsyncCount;
  },
  startRootIsolate: function(entry, args) {
    var t1, t2, t3, t4, t5, rootContext;
    t1 = {};
    t1.args_0 = args;
    args = args;
    t1.args_0 = args;
    if (args == null) {
      args = [];
      t1.args_0 = args;
      t2 = args;
    } else
      t2 = args;
    if (!J.getInterceptor(t2).$isList)
      throw H.wrapException(P.ArgumentError$("Arguments to main must be a List: " + H.S(t2)));
    t2 = new H._Manager(0, 0, 1, null, null, null, null, null, null, null, null, null, entry);
    t2._Manager$1(entry);
    init.globalState = t2;
    if (init.globalState.isWorker === true)
      return;
    t2 = init.globalState.nextIsolateId++;
    t3 = P.LinkedHashMap_LinkedHashMap(null, null, null, P.$int, H.RawReceivePortImpl);
    t4 = P.LinkedHashSet_LinkedHashSet(null, null, null, P.$int);
    t5 = new H.RawReceivePortImpl(0, null, false);
    rootContext = new H._IsolateContext(t2, t3, t4, new Isolate(), t5, new H.CapabilityImpl(H.random64()), new H.CapabilityImpl(H.random64()), false, false, [], P.LinkedHashSet_LinkedHashSet(null, null, null, null), null, null, false, true, P.LinkedHashSet_LinkedHashSet(null, null, null, null));
    t4.add$1(0, 0);
    rootContext._addRegistration$2(0, t5);
    init.globalState.rootContext = rootContext;
    init.globalState.currentContext = rootContext;
    t2 = H.getDynamicRuntimeType();
    t3 = H.buildFunctionType(t2, [t2])._isTest$1(entry);
    if (t3)
      rootContext.eval$1(new H.startRootIsolate_closure(t1, entry));
    else {
      t2 = H.buildFunctionType(t2, [t2, t2])._isTest$1(entry);
      if (t2)
        rootContext.eval$1(new H.startRootIsolate_closure0(t1, entry));
      else
        rootContext.eval$1(entry);
    }
    init.globalState.topEventLoop.run$0();
  },
  IsolateNatives_computeThisScript: function() {
    var currentScript = init.currentScript;
    if (currentScript != null)
      return String(currentScript.src);
    if (typeof version == "function" && typeof os == "object" && "system" in os)
      return H.IsolateNatives_computeThisScriptFromTrace();
    if (typeof version == "function" && typeof system == "function")
      return thisFilename();
    if (init.globalState.isWorker === true)
      return H.IsolateNatives_computeThisScriptFromTrace();
    return;
  },
  IsolateNatives_computeThisScriptFromTrace: function() {
    var stack, matches;
    stack = new Error().stack;
    if (stack == null) {
      stack = function() {
        try {
          throw new Error();
        } catch (e) {
          return e.stack;
        }

      }();
      if (stack == null)
        throw H.wrapException(P.UnsupportedError$("No stack trace"));
    }
    matches = stack.match(new RegExp("^ *at [^(]*\\((.*):[0-9]*:[0-9]*\\)$", "m"));
    if (matches != null)
      return matches[1];
    matches = stack.match(new RegExp("^[^@]*@(.*):[0-9]*$", "m"));
    if (matches != null)
      return matches[1];
    throw H.wrapException(P.UnsupportedError$("Cannot extract URI from \"" + H.S(stack) + "\""));
  },
  IsolateNatives__processWorkerMessage: function(sender, e) {
    var msg, t1, functionName, entryPoint, args, message, isSpawnUri, startPaused, replyTo, t2, t3, t4, context;
    msg = H._deserializeMessage(e.data);
    t1 = J.getInterceptor$asx(msg);
    switch (t1.$index(msg, "command")) {
      case "start":
        init.globalState.currentManagerId = t1.$index(msg, "id");
        functionName = t1.$index(msg, "functionName");
        entryPoint = functionName == null ? init.globalState.entry : init.globalFunctions[functionName]();
        args = t1.$index(msg, "args");
        message = H._deserializeMessage(t1.$index(msg, "msg"));
        isSpawnUri = t1.$index(msg, "isSpawnUri");
        startPaused = t1.$index(msg, "startPaused");
        replyTo = H._deserializeMessage(t1.$index(msg, "replyTo"));
        t1 = init.globalState.nextIsolateId++;
        t2 = P.LinkedHashMap_LinkedHashMap(null, null, null, P.$int, H.RawReceivePortImpl);
        t3 = P.LinkedHashSet_LinkedHashSet(null, null, null, P.$int);
        t4 = new H.RawReceivePortImpl(0, null, false);
        context = new H._IsolateContext(t1, t2, t3, new Isolate(), t4, new H.CapabilityImpl(H.random64()), new H.CapabilityImpl(H.random64()), false, false, [], P.LinkedHashSet_LinkedHashSet(null, null, null, null), null, null, false, true, P.LinkedHashSet_LinkedHashSet(null, null, null, null));
        t3.add$1(0, 0);
        context._addRegistration$2(0, t4);
        init.globalState.topEventLoop.events._add$1(new H._IsolateEvent(context, new H.IsolateNatives__processWorkerMessage_closure(entryPoint, args, message, isSpawnUri, startPaused, replyTo), "worker-start"));
        init.globalState.currentContext = context;
        init.globalState.topEventLoop.run$0();
        break;
      case "spawn-worker":
        break;
      case "message":
        if (t1.$index(msg, "port") != null)
          J.send$1$x(t1.$index(msg, "port"), t1.$index(msg, "msg"));
        init.globalState.topEventLoop.run$0();
        break;
      case "close":
        init.globalState.managers.remove$1(0, $.get$IsolateNatives_workerIds().$index(0, sender));
        sender.terminate();
        init.globalState.topEventLoop.run$0();
        break;
      case "log":
        H.IsolateNatives__log(t1.$index(msg, "msg"));
        break;
      case "print":
        if (init.globalState.isWorker === true) {
          t1 = init.globalState.mainManager;
          t2 = H._serializeMessage(P.LinkedHashMap_LinkedHashMap$_literal(["command", "print", "msg", msg], null, null));
          t1.toString;
          self.postMessage(t2);
        } else
          P.print(t1.$index(msg, "msg"));
        break;
      case "error":
        throw H.wrapException(t1.$index(msg, "msg"));
    }
  },
  IsolateNatives__log: function(msg) {
    var trace, t1, t2, exception;
    if (init.globalState.isWorker === true) {
      t1 = init.globalState.mainManager;
      t2 = H._serializeMessage(P.LinkedHashMap_LinkedHashMap$_literal(["command", "log", "msg", msg], null, null));
      t1.toString;
      self.postMessage(t2);
    } else
      try {
        self.console.log(msg);
      } catch (exception) {
        H.unwrapException(exception);
        trace = new H._StackTrace(exception, null);
        throw H.wrapException(P.Exception_Exception(trace));
      }

  },
  IsolateNatives__startIsolate: function(topLevel, args, message, isSpawnUri, startPaused, replyTo) {
    var context, t1, t2, t3;
    context = init.globalState.currentContext;
    t1 = context.id;
    $.Primitives_mirrorFunctionCacheName = $.Primitives_mirrorFunctionCacheName + ("_" + t1);
    $.Primitives_mirrorInvokeCacheName = $.Primitives_mirrorInvokeCacheName + ("_" + t1);
    t1 = context.controlPort;
    t2 = init.globalState.currentContext.id;
    t3 = context.pauseCapability;
    J.send$1$x(replyTo, ["spawned", new H._NativeJsSendPort(t1, t2), t3, context.terminateCapability]);
    t2 = new H.IsolateNatives__startIsolate_runStartFunction(topLevel, args, message, isSpawnUri, context);
    if (startPaused === true) {
      context.addPause$2(t3, t3);
      init.globalState.topEventLoop.events._add$1(new H._IsolateEvent(context, t2, "start isolate"));
    } else
      t2.call$0();
  },
  _serializeMessage: function(message) {
    var t1;
    if (init.globalState.supportsWorkers === true) {
      t1 = new H._JsSerializer(0, new H._MessageTraverserVisitedMap());
      t1._visited = new H._JsVisitedMap(null);
      return t1.traverse$1(message);
    } else {
      t1 = new H._JsCopier(new H._MessageTraverserVisitedMap());
      t1._visited = new H._JsVisitedMap(null);
      return t1.traverse$1(message);
    }
  },
  _deserializeMessage: function(message) {
    if (init.globalState.supportsWorkers === true)
      return new H._JsDeserializer(null).deserialize$1(message);
    else
      return message;
  },
  _MessageTraverser_isPrimitive: function(x) {
    return x == null || typeof x === "string" || typeof x === "number" || typeof x === "boolean";
  },
  _Deserializer_isPrimitive: function(x) {
    return x == null || typeof x === "string" || typeof x === "number" || typeof x === "boolean";
  },
  startRootIsolate_closure: {
    "^": "Closure:23;box_0,entry_1",
    call$0: function() {
      this.entry_1.call$1(this.box_0.args_0);
    },
    $isFunction: true
  },
  startRootIsolate_closure0: {
    "^": "Closure:23;box_0,entry_2",
    call$0: function() {
      this.entry_2.call$2(this.box_0.args_0, null);
    },
    $isFunction: true
  },
  _Manager: {
    "^": "Object;nextIsolateId,currentManagerId,nextManagerId,currentContext,rootContext,topEventLoop,fromCommandLine,isWorker,supportsWorkers,isolates,mainManager,managers,entry",
    _Manager$1: function(entry) {
      var t1, t2, t3;
      t1 = self.window == null;
      t2 = self.Worker;
      t3 = t1 && !!self.postMessage;
      this.isWorker = t3;
      if (!t3)
        t2 = t2 != null && $.get$IsolateNatives_thisScript() != null;
      else
        t2 = true;
      this.supportsWorkers = t2;
      this.fromCommandLine = t1 && !t3;
      t2 = H._IsolateEvent;
      t3 = H.setRuntimeTypeInfo(new P.ListQueue(null, 0, 0, 0), [t2]);
      t3.ListQueue$1(null, t2);
      this.topEventLoop = new H._EventLoop(t3, 0);
      this.isolates = P.LinkedHashMap_LinkedHashMap(null, null, null, P.$int, H._IsolateContext);
      this.managers = P.LinkedHashMap_LinkedHashMap(null, null, null, P.$int, null);
      if (this.isWorker === true) {
        t1 = new H._MainManagerStub();
        this.mainManager = t1;
        self.onmessage = function(f, a) {
          return function(e) {
            f(a, e);
          };
        }(H.IsolateNatives__processWorkerMessage, t1);
        self.dartPrint = self.dartPrint || function(serialize) {
          return function(object) {
            if (self.console && self.console.log) {
              self.console.log(object);
            } else {
              self.postMessage(serialize(object));
            }
          };
        }(H._Manager__serializePrintMessage);
      }
    },
    static: {_Manager__serializePrintMessage: function(object) {
        return H._serializeMessage(P.LinkedHashMap_LinkedHashMap$_literal(["command", "print", "msg", object], null, null));
      }}
  },
  _IsolateContext: {
    "^": "Object;id>,ports,weakPorts,isolateStatics<,controlPort<,pauseCapability,terminateCapability,initialized,isPaused,delayedEvents,pauseTokens,doneHandlers,_scheduledControlEvents,_isExecutingEvent,errorsAreFatal,errorPorts",
    addPause$2: function(authentification, resume) {
      if (!this.pauseCapability.$eq(0, authentification))
        return;
      if (this.pauseTokens.add$1(0, resume) && !this.isPaused)
        this.isPaused = true;
      this._updateGlobalState$0();
    },
    removePause$1: function(resume) {
      var t1, t2, $event, t3, t4, t5;
      if (!this.isPaused)
        return;
      t1 = this.pauseTokens;
      t1.remove$1(0, resume);
      if (t1._collection$_length === 0) {
        for (t1 = this.delayedEvents; t2 = t1.length, t2 !== 0;) {
          if (0 >= t2)
            return H.ioore(t1, 0);
          $event = t1.pop();
          t2 = init.globalState.topEventLoop.events;
          t3 = t2._head;
          t4 = t2._table;
          t5 = t4.length;
          t3 = (t3 - 1 & t5 - 1) >>> 0;
          t2._head = t3;
          if (t3 < 0 || t3 >= t5)
            return H.ioore(t4, t3);
          t4[t3] = $event;
          if (t3 === t2._tail)
            t2._grow$0();
          ++t2._modificationCount;
        }
        this.isPaused = false;
      }
      this._updateGlobalState$0();
    },
    addDoneListener$1: function(responsePort) {
      var t1 = this.doneHandlers;
      if (t1 == null) {
        t1 = [];
        this.doneHandlers = t1;
      }
      if (J.contains$1$asx(t1, responsePort))
        return;
      this.doneHandlers.push(responsePort);
    },
    removeDoneListener$1: function(responsePort) {
      var t1 = this.doneHandlers;
      if (t1 == null)
        return;
      J.remove$1$ax(t1, responsePort);
    },
    setErrorsFatal$2: function(authentification, errorsAreFatal) {
      if (!this.terminateCapability.$eq(0, authentification))
        return;
      this.errorsAreFatal = errorsAreFatal;
    },
    handlePing$2: function(responsePort, pingType) {
      var t1, t2;
      t1 = J.getInterceptor(pingType);
      if (!t1.$eq(pingType, 0))
        t2 = t1.$eq(pingType, 1) && !this._isExecutingEvent;
      else
        t2 = true;
      if (t2) {
        J.send$1$x(responsePort, null);
        return;
      }
      t2 = new H._IsolateContext_handlePing_respond(responsePort);
      if (t1.$eq(pingType, 2)) {
        init.globalState.topEventLoop.events._add$1(new H._IsolateEvent(this, t2, "ping"));
        return;
      }
      t1 = this._scheduledControlEvents;
      if (t1 == null) {
        t1 = H.setRuntimeTypeInfo(new P.ListQueue(null, 0, 0, 0), [null]);
        t1.ListQueue$1(null, null);
        this._scheduledControlEvents = t1;
      }
      t1._add$1(t2);
    },
    handleKill$2: function(authentification, priority) {
      var t1, t2;
      if (!this.terminateCapability.$eq(0, authentification))
        return;
      t1 = J.getInterceptor(priority);
      if (!t1.$eq(priority, 0))
        t2 = t1.$eq(priority, 1) && !this._isExecutingEvent;
      else
        t2 = true;
      if (t2) {
        this.kill$0();
        return;
      }
      if (t1.$eq(priority, 2)) {
        t1 = init.globalState.topEventLoop;
        t2 = this.get$kill();
        t1.events._add$1(new H._IsolateEvent(this, t2, "kill"));
        return;
      }
      t1 = this._scheduledControlEvents;
      if (t1 == null) {
        t1 = H.setRuntimeTypeInfo(new P.ListQueue(null, 0, 0, 0), [null]);
        t1.ListQueue$1(null, null);
        this._scheduledControlEvents = t1;
      }
      t1._add$1(this.get$kill());
    },
    handleUncaughtError$2: function(error, stackTrace) {
      var t1, message;
      t1 = this.errorPorts;
      if (t1._collection$_length === 0) {
        if (this.errorsAreFatal === true && this === init.globalState.rootContext)
          return;
        if (self.console && self.console.error)
          self.console.error(error, stackTrace);
        else {
          P.print(error);
          if (stackTrace != null)
            P.print(stackTrace);
        }
        return;
      }
      message = Array(2);
      message.fixed$length = init;
      message[0] = J.toString$0(error);
      message[1] = stackTrace == null ? null : stackTrace.toString$0(0);
      for (t1 = H.setRuntimeTypeInfo(new P.LinkedHashSetIterator(t1, t1._modifications, null, null), [null]), t1._cell = t1._set._first; t1.moveNext$0();)
        J.send$1$x(t1._collection$_current, message);
    },
    eval$1: function(code) {
      var old, result, e, s, exception, t1;
      old = init.globalState.currentContext;
      init.globalState.currentContext = this;
      $ = this.isolateStatics;
      result = null;
      this._isExecutingEvent = true;
      try {
        result = code.call$0();
      } catch (exception) {
        t1 = H.unwrapException(exception);
        e = t1;
        s = new H._StackTrace(exception, null);
        this.handleUncaughtError$2(e, s);
        if (this.errorsAreFatal === true) {
          this.kill$0();
          if (this === init.globalState.rootContext)
            throw exception;
        }
      }
 finally {
        this._isExecutingEvent = false;
        init.globalState.currentContext = old;
        if (old != null)
          $ = old.get$isolateStatics();
        if (this._scheduledControlEvents != null)
          for (; t1 = this._scheduledControlEvents, !t1.get$isEmpty(t1);)
            this._scheduledControlEvents.removeFirst$0().call$0();
      }
      return result;
    },
    lookup$1: function(portId) {
      return this.ports.$index(0, portId);
    },
    _addRegistration$2: function(portId, port) {
      var t1 = this.ports;
      if (t1.containsKey$1(portId))
        throw H.wrapException(P.Exception_Exception("Registry: ports must be registered only once."));
      t1.$indexSet(0, portId, port);
    },
    _updateGlobalState$0: function() {
      if (this.ports._collection$_length - this.weakPorts._collection$_length > 0 || this.isPaused || !this.initialized)
        init.globalState.isolates.$indexSet(0, this.id, this);
      else
        this.kill$0();
    },
    kill$0: [function() {
      var t1, t2;
      t1 = this._scheduledControlEvents;
      if (t1 != null)
        t1.clear$0(0);
      for (t1 = this.ports, t2 = t1.get$values(t1), t2 = H.setRuntimeTypeInfo(new H.MappedIterator(null, J.get$iterator$ax(t2._iterable), t2._f), [H.getTypeArgumentByIndex(t2, 0), H.getTypeArgumentByIndex(t2, 1)]); t2.moveNext$0();)
        t2.__internal$_current.__isolate_helper$_close$0();
      t1.clear$0(0);
      this.weakPorts.clear$0(0);
      init.globalState.isolates.remove$1(0, this.id);
      this.errorPorts.clear$0(0);
      t1 = this.doneHandlers;
      if (t1 != null) {
        for (t1 = H.setRuntimeTypeInfo(new H.ListIterator(t1, t1.length, 0, null), [H.getTypeArgumentByIndex(t1, 0)]); t1.moveNext$0();)
          J.send$1$x(t1.__internal$_current, null);
        this.doneHandlers = null;
      }
    }, "call$0", "get$kill", 0, 0, 7]
  },
  _IsolateContext_handlePing_respond: {
    "^": "Closure:7;responsePort_0",
    call$0: function() {
      this.responsePort_0.send$1(0, null);
    },
    $isFunction: true
  },
  _EventLoop: {
    "^": "Object;events,_activeJsAsyncCount",
    dequeue$0: function() {
      var t1 = this.events;
      if (t1._head === t1._tail)
        return;
      return t1.removeFirst$0();
    },
    runIteration$0: function() {
      var $event, t1, t2;
      $event = this.dequeue$0();
      if ($event == null) {
        if (init.globalState.rootContext != null && init.globalState.isolates.containsKey$1(init.globalState.rootContext.id) && init.globalState.fromCommandLine === true && init.globalState.rootContext.ports._collection$_length === 0)
          H.throwExpression(P.Exception_Exception("Program exited with open ReceivePorts."));
        t1 = init.globalState;
        if (t1.isWorker === true && t1.isolates._collection$_length === 0 && t1.topEventLoop._activeJsAsyncCount === 0) {
          t1 = t1.mainManager;
          t2 = H._serializeMessage(P.LinkedHashMap_LinkedHashMap$_literal(["command", "close"], null, null));
          t1.toString;
          self.postMessage(t2);
        }
        return false;
      }
      $event.process$0();
      return true;
    },
    _runHelper$0: function() {
      if (self.window != null)
        new H._EventLoop__runHelper_next(this).call$0();
      else
        for (; this.runIteration$0();)
          ;
    },
    run$0: function() {
      var e, trace, exception, t1, t2;
      if (init.globalState.isWorker !== true)
        this._runHelper$0();
      else
        try {
          this._runHelper$0();
        } catch (exception) {
          t1 = H.unwrapException(exception);
          e = t1;
          trace = new H._StackTrace(exception, null);
          t1 = init.globalState.mainManager;
          t2 = H._serializeMessage(P.LinkedHashMap_LinkedHashMap$_literal(["command", "error", "msg", H.S(e) + "\n" + H.S(trace)], null, null));
          t1.toString;
          self.postMessage(t2);
        }

    }
  },
  _EventLoop__runHelper_next: {
    "^": "Closure:7;this_0",
    call$0: function() {
      if (!this.this_0.runIteration$0())
        return;
      P.Timer_Timer(C.Duration_0, this);
    },
    $isFunction: true
  },
  _IsolateEvent: {
    "^": "Object;isolate,fn,message",
    process$0: function() {
      var t1 = this.isolate;
      if (t1.isPaused) {
        t1.delayedEvents.push(this);
        return;
      }
      t1.eval$1(this.fn);
    }
  },
  _MainManagerStub: {
    "^": "Object;"
  },
  IsolateNatives__processWorkerMessage_closure: {
    "^": "Closure:23;entryPoint_0,args_1,message_2,isSpawnUri_3,startPaused_4,replyTo_5",
    call$0: function() {
      H.IsolateNatives__startIsolate(this.entryPoint_0, this.args_1, this.message_2, this.isSpawnUri_3, this.startPaused_4, this.replyTo_5);
    },
    $isFunction: true
  },
  IsolateNatives__startIsolate_runStartFunction: {
    "^": "Closure:7;topLevel_0,args_1,message_2,isSpawnUri_3,context_4",
    call$0: function() {
      var t1, t2, t3;
      this.context_4.initialized = true;
      if (this.isSpawnUri_3 !== true)
        this.topLevel_0.call$1(this.message_2);
      else {
        t1 = this.topLevel_0;
        t2 = H.getDynamicRuntimeType();
        t3 = H.buildFunctionType(t2, [t2, t2])._isTest$1(t1);
        if (t3)
          t1.call$2(this.args_1, this.message_2);
        else {
          t2 = H.buildFunctionType(t2, [t2])._isTest$1(t1);
          if (t2)
            t1.call$1(this.args_1);
          else
            t1.call$0();
        }
      }
    },
    $isFunction: true
  },
  _BaseSendPort: {
    "^": "Object;",
    $isSendPort: true,
    $isCapability: true
  },
  _NativeJsSendPort: {
    "^": "_BaseSendPort;_receivePort,_isolateId",
    send$1: function(_, message) {
      var t1, t2, isolate, t3, shouldSerialize;
      t1 = {};
      t2 = this._isolateId;
      isolate = init.globalState.isolates.$index(0, t2);
      if (isolate == null)
        return;
      t3 = this._receivePort;
      if (t3._isClosed)
        return;
      shouldSerialize = init.globalState.currentContext != null && init.globalState.currentContext.id !== t2;
      t1.msg_0 = message;
      if (shouldSerialize)
        t1.msg_0 = H._serializeMessage(message);
      if (isolate.get$controlPort() === t3) {
        t1 = t1.msg_0;
        t2 = J.getInterceptor$asx(t1);
        switch (t2.$index(t1, 0)) {
          case "pause":
            isolate.addPause$2(t2.$index(t1, 1), t2.$index(t1, 2));
            break;
          case "resume":
            isolate.removePause$1(t2.$index(t1, 1));
            break;
          case "add-ondone":
            isolate.addDoneListener$1(t2.$index(t1, 1));
            break;
          case "remove-ondone":
            isolate.removeDoneListener$1(t2.$index(t1, 1));
            break;
          case "set-errors-fatal":
            isolate.setErrorsFatal$2(t2.$index(t1, 1), t2.$index(t1, 2));
            break;
          case "ping":
            isolate.handlePing$2(t2.$index(t1, 1), t2.$index(t1, 2));
            break;
          case "kill":
            isolate.handleKill$2(t2.$index(t1, 1), t2.$index(t1, 2));
            break;
          case "getErrors":
            t1 = t2.$index(t1, 1);
            isolate.errorPorts.add$1(0, t1);
            break;
          case "stopErrors":
            t1 = t2.$index(t1, 1);
            isolate.errorPorts.remove$1(0, t1);
            break;
        }
        return;
      }
      t2 = init.globalState.topEventLoop;
      t3 = "receive " + H.S(message);
      t2.events._add$1(new H._IsolateEvent(isolate, new H._NativeJsSendPort_send_closure(t1, this, shouldSerialize), t3));
    },
    $eq: function(_, other) {
      var t1, t2;
      if (other == null)
        return false;
      if (!!J.getInterceptor(other).$is_NativeJsSendPort) {
        t1 = this._receivePort;
        t2 = other._receivePort;
        t2 = t1 == null ? t2 == null : t1 === t2;
        t1 = t2;
      } else
        t1 = false;
      return t1;
    },
    get$hashCode: function(_) {
      return this._receivePort._id;
    },
    $is_NativeJsSendPort: true,
    $isSendPort: true,
    $isCapability: true
  },
  _NativeJsSendPort_send_closure: {
    "^": "Closure:23;box_0,this_1,shouldSerialize_2",
    call$0: function() {
      var t1, t2;
      t1 = this.this_1._receivePort;
      if (!t1._isClosed) {
        if (this.shouldSerialize_2) {
          t2 = this.box_0;
          t2.msg_0 = H._deserializeMessage(t2.msg_0);
        }
        t1.__isolate_helper$_add$1(this.box_0.msg_0);
      }
    },
    $isFunction: true
  },
  _WorkerSendPort: {
    "^": "_BaseSendPort;_workerId,_receivePortId,_isolateId",
    send$1: function(_, message) {
      var workerMessage, manager;
      workerMessage = H._serializeMessage(P.LinkedHashMap_LinkedHashMap$_literal(["command", "message", "port", this, "msg", message], null, null));
      if (init.globalState.isWorker === true) {
        init.globalState.mainManager.toString;
        self.postMessage(workerMessage);
      } else {
        manager = init.globalState.managers.$index(0, this._workerId);
        if (manager != null)
          manager.postMessage(workerMessage);
      }
    },
    $eq: function(_, other) {
      var t1, t2;
      if (other == null)
        return false;
      if (!!J.getInterceptor(other).$is_WorkerSendPort) {
        t1 = this._workerId;
        t2 = other._workerId;
        if (t1 == null ? t2 == null : t1 === t2) {
          t1 = this._isolateId;
          t2 = other._isolateId;
          if (t1 == null ? t2 == null : t1 === t2) {
            t1 = this._receivePortId;
            t2 = other._receivePortId;
            t2 = t1 == null ? t2 == null : t1 === t2;
            t1 = t2;
          } else
            t1 = false;
        } else
          t1 = false;
      } else
        t1 = false;
      return t1;
    },
    get$hashCode: function(_) {
      var t1, t2, t3;
      t1 = this._workerId;
      if (typeof t1 !== "number")
        return t1.$shl();
      t2 = this._isolateId;
      if (typeof t2 !== "number")
        return t2.$shl();
      t3 = this._receivePortId;
      if (typeof t3 !== "number")
        return H.iae(t3);
      return (t1 << 16 ^ t2 << 8 ^ t3) >>> 0;
    },
    $is_WorkerSendPort: true,
    $isSendPort: true,
    $isCapability: true
  },
  RawReceivePortImpl: {
    "^": "Object;_id,_handler,_isClosed",
    _handler$1: function(arg0) {
      return this._handler.call$1(arg0);
    },
    __isolate_helper$_close$0: function() {
      this._isClosed = true;
      this._handler = null;
    },
    close$0: function(_) {
      var t1, t2;
      if (this._isClosed)
        return;
      this._isClosed = true;
      this._handler = null;
      t1 = init.globalState.currentContext;
      t2 = this._id;
      t1.ports.remove$1(0, t2);
      t1.weakPorts.remove$1(0, t2);
      t1._updateGlobalState$0();
    },
    __isolate_helper$_add$1: function(dataEvent) {
      if (this._isClosed)
        return;
      this._handler$1(dataEvent);
    },
    static: {"^": "RawReceivePortImpl__nextFreeId"}
  },
  ReceivePortImpl: {
    "^": "Stream;_rawPort,_controller",
    listen$4$cancelOnError$onDone$onError: function(onData, cancelOnError, onDone, onError) {
      var t1 = this._controller;
      t1.toString;
      return H.setRuntimeTypeInfo(new P._ControllerStream(t1), [null]).listen$4$cancelOnError$onDone$onError(onData, cancelOnError, onDone, onError);
    },
    listen$3$onDone$onError: function(onData, onDone, onError) {
      return this.listen$4$cancelOnError$onDone$onError(onData, null, onDone, onError);
    },
    close$0: [function(_) {
      this._rawPort.close$0(0);
      this._controller.close$0(0);
    }, "call$0", "get$close", 0, 0, 7],
    ReceivePortImpl$fromRawReceivePort$1: function(_rawPort) {
      var t1 = P.StreamController_StreamController(this.get$close(this), null, null, null, true, null);
      this._controller = t1;
      this._rawPort._handler = t1.get$add(t1);
    },
    $asStream: function() {
      return [null];
    }
  },
  _JsSerializer: {
    "^": "_Serializer;_nextFreeRefId,_visited",
    visitSendPort$1: function(x) {
      if (!!x.$is_NativeJsSendPort)
        return ["sendport", init.globalState.currentManagerId, x._isolateId, x._receivePort._id];
      if (!!x.$is_WorkerSendPort)
        return ["sendport", x._workerId, x._isolateId, x._receivePortId];
      throw H.wrapException("Illegal underlying port " + x.toString$0(0));
    },
    visitCapability$1: function(x) {
      if (!!x.$isCapabilityImpl)
        return ["capability", x._id];
      throw H.wrapException("Capability not serializable: " + x.toString$0(0));
    }
  },
  _JsCopier: {
    "^": "_Copier;_visited",
    visitSendPort$1: function(x) {
      if (!!x.$is_NativeJsSendPort)
        return new H._NativeJsSendPort(x._receivePort, x._isolateId);
      if (!!x.$is_WorkerSendPort)
        return new H._WorkerSendPort(x._workerId, x._receivePortId, x._isolateId);
      throw H.wrapException("Illegal underlying port " + x.toString$0(0));
    },
    visitCapability$1: function(x) {
      if (!!x.$isCapabilityImpl)
        return new H.CapabilityImpl(x._id);
      throw H.wrapException("Capability not serializable: " + x.toString$0(0));
    }
  },
  _JsDeserializer: {
    "^": "_Deserializer;_deserialized",
    deserializeSendPort$1: function(list) {
      var t1, managerId, isolateId, receivePortId, isolate, receivePort;
      t1 = J.getInterceptor$asx(list);
      managerId = t1.$index(list, 1);
      isolateId = t1.$index(list, 2);
      receivePortId = t1.$index(list, 3);
      if (J.$eq(managerId, init.globalState.currentManagerId)) {
        isolate = init.globalState.isolates.$index(0, isolateId);
        if (isolate == null)
          return;
        receivePort = isolate.lookup$1(receivePortId);
        if (receivePort == null)
          return;
        return new H._NativeJsSendPort(receivePort, isolateId);
      } else
        return new H._WorkerSendPort(managerId, receivePortId, isolateId);
    },
    deserializeCapability$1: function(list) {
      return new H.CapabilityImpl(J.$index$asx(list, 1));
    }
  },
  _JsVisitedMap: {
    "^": "Object;tagged",
    $index: function(_, object) {
      return object.__MessageTraverser__attached_info__;
    },
    $indexSet: function(_, object, info) {
      this.tagged.push(object);
      object.__MessageTraverser__attached_info__ = info;
    },
    reset$0: function(_) {
      this.tagged = [];
    },
    cleanup$0: function() {
      var $length, i, t1;
      for ($length = this.tagged.length, i = 0; i < $length; ++i) {
        t1 = this.tagged;
        if (i >= t1.length)
          return H.ioore(t1, i);
        t1[i].__MessageTraverser__attached_info__ = null;
      }
      this.tagged = null;
    }
  },
  _MessageTraverserVisitedMap: {
    "^": "Object;",
    $index: function(_, object) {
      return;
    },
    $indexSet: function(_, object, info) {
    },
    reset$0: function(_) {
    },
    cleanup$0: function() {
    }
  },
  _MessageTraverser: {
    "^": "Object;",
    traverse$1: function(x) {
      var result;
      if (H._MessageTraverser_isPrimitive(x))
        return this.visitPrimitive$1(x);
      this._visited.reset$0(0);
      result = null;
      try {
        result = this._dispatch$1(x);
      } finally {
        this._visited.cleanup$0();
      }
      return result;
    },
    _dispatch$1: function(x) {
      var t1;
      if (x == null || typeof x === "string" || typeof x === "number" || typeof x === "boolean")
        return this.visitPrimitive$1(x);
      t1 = J.getInterceptor(x);
      if (!!t1.$isList)
        return this.visitList$1(x);
      if (!!t1.$isMap)
        return this.visitMap$1(x);
      if (!!t1.$isSendPort)
        return this.visitSendPort$1(x);
      if (!!t1.$isCapability)
        return this.visitCapability$1(x);
      return this.visitObject$1(x);
    },
    visitObject$1: function(x) {
      throw H.wrapException("Message serialization: Illegal value " + H.S(x) + " passed");
    }
  },
  _Copier: {
    "^": "_MessageTraverser;",
    visitPrimitive$1: function(x) {
      return x;
    },
    visitList$1: function(list) {
      var copy, t1, len, i;
      copy = this._visited.$index(0, list);
      if (copy != null)
        return copy;
      t1 = J.getInterceptor$asx(list);
      len = t1.get$length(list);
      copy = Array(len);
      copy.fixed$length = init;
      this._visited.$indexSet(0, list, copy);
      for (i = 0; i < len; ++i)
        copy[i] = this._dispatch$1(t1.$index(list, i));
      return copy;
    },
    visitMap$1: function(map) {
      var t1, copy;
      t1 = {};
      copy = this._visited.$index(0, map);
      t1.copy_0 = copy;
      if (copy != null)
        return copy;
      copy = P.LinkedHashMap_LinkedHashMap(null, null, null, null, null);
      t1.copy_0 = copy;
      this._visited.$indexSet(0, map, copy);
      map.forEach$1(0, new H._Copier_visitMap_closure(t1, this));
      return t1.copy_0;
    },
    visitSendPort$1: function(x) {
      return H.throwExpression(P.UnimplementedError$(null));
    },
    visitCapability$1: function(x) {
      return H.throwExpression(P.UnimplementedError$(null));
    }
  },
  _Copier_visitMap_closure: {
    "^": "Closure:19;box_0,this_1",
    call$2: function(key, val) {
      var t1 = this.this_1;
      this.box_0.copy_0.$indexSet(0, t1._dispatch$1(key), t1._dispatch$1(val));
    },
    $isFunction: true
  },
  _Serializer: {
    "^": "_MessageTraverser;",
    visitPrimitive$1: function(x) {
      return x;
    },
    visitList$1: function(list) {
      var copyId, t1;
      copyId = this._visited.$index(0, list);
      if (copyId != null)
        return ["ref", copyId];
      t1 = this._nextFreeRefId++;
      this._visited.$indexSet(0, list, t1);
      return ["list", t1, this._serializeList$1(list)];
    },
    visitMap$1: function(map) {
      var copyId, t1;
      copyId = this._visited.$index(0, map);
      if (copyId != null)
        return ["ref", copyId];
      t1 = this._nextFreeRefId++;
      this._visited.$indexSet(0, map, t1);
      return ["map", t1, this._serializeList$1(J.toList$0$ax(map.get$keys())), this._serializeList$1(J.toList$0$ax(map.get$values(map)))];
    },
    _serializeList$1: function(list) {
      var t1, len, result, i, t2;
      t1 = J.getInterceptor$asx(list);
      len = t1.get$length(list);
      result = [];
      C.JSArray_methods.set$length(result, len);
      for (i = 0; i < len; ++i) {
        t2 = this._dispatch$1(t1.$index(list, i));
        if (i >= result.length)
          return H.ioore(result, i);
        result[i] = t2;
      }
      return result;
    },
    visitSendPort$1: function(x) {
      return H.throwExpression(P.UnimplementedError$(null));
    },
    visitCapability$1: function(x) {
      return H.throwExpression(P.UnimplementedError$(null));
    }
  },
  _Deserializer: {
    "^": "Object;",
    deserialize$1: function(x) {
      if (H._Deserializer_isPrimitive(x))
        return x;
      this._deserialized = P.HashMap_HashMap(null, null, null, null, null);
      return this._deserializeHelper$1(x);
    },
    _deserializeHelper$1: function(x) {
      var t1, id;
      if (x == null || typeof x === "string" || typeof x === "number" || typeof x === "boolean")
        return x;
      t1 = J.getInterceptor$asx(x);
      switch (t1.$index(x, 0)) {
        case "ref":
          id = t1.$index(x, 1);
          return this._deserialized.$index(0, id);
        case "list":
          return this._deserializeList$1(x);
        case "map":
          return this._deserializeMap$1(x);
        case "sendport":
          return this.deserializeSendPort$1(x);
        case "capability":
          return this.deserializeCapability$1(x);
        default:
          return this.deserializeObject$1(x);
      }
    },
    _deserializeList$1: function(x) {
      var t1, id, dartList, len, i;
      t1 = J.getInterceptor$asx(x);
      id = t1.$index(x, 1);
      dartList = t1.$index(x, 2);
      this._deserialized.$indexSet(0, id, dartList);
      t1 = J.getInterceptor$asx(dartList);
      len = t1.get$length(dartList);
      if (typeof len !== "number")
        return H.iae(len);
      i = 0;
      for (; i < len; ++i)
        t1.$indexSet(dartList, i, this._deserializeHelper$1(t1.$index(dartList, i)));
      return dartList;
    },
    _deserializeMap$1: function(x) {
      var result, t1, id, keys, values, len, t2, i;
      result = P.LinkedHashMap_LinkedHashMap(null, null, null, null, null);
      t1 = J.getInterceptor$asx(x);
      id = t1.$index(x, 1);
      this._deserialized.$indexSet(0, id, result);
      keys = t1.$index(x, 2);
      values = t1.$index(x, 3);
      t1 = J.getInterceptor$asx(keys);
      len = t1.get$length(keys);
      if (typeof len !== "number")
        return H.iae(len);
      t2 = J.getInterceptor$asx(values);
      i = 0;
      for (; i < len; ++i)
        result.$indexSet(0, this._deserializeHelper$1(t1.$index(keys, i)), this._deserializeHelper$1(t2.$index(values, i)));
      return result;
    },
    deserializeObject$1: function(x) {
      throw H.wrapException("Unexpected serialized object");
    }
  },
  TimerImpl: {
    "^": "Object;_once,_inEventLoop,_handle",
    TimerImpl$2: function(milliseconds, callback) {
      var t1, t2;
      if (milliseconds === 0)
        t1 = self.setTimeout == null || init.globalState.isWorker === true;
      else
        t1 = false;
      if (t1) {
        this._handle = 1;
        t1 = init.globalState.topEventLoop;
        t2 = init.globalState.currentContext;
        t1.events._add$1(new H._IsolateEvent(t2, new H.TimerImpl_internalCallback(this, callback), "timer"));
        this._inEventLoop = true;
      } else if (self.setTimeout != null) {
        ++init.globalState.topEventLoop._activeJsAsyncCount;
        this._handle = self.setTimeout(H.convertDartClosureToJS(new H.TimerImpl_internalCallback0(this, callback), 0), milliseconds);
      } else
        throw H.wrapException(P.UnsupportedError$("Timer greater than 0."));
    },
    static: {TimerImpl$: function(milliseconds, callback) {
        var t1 = new H.TimerImpl(true, false, null);
        t1.TimerImpl$2(milliseconds, callback);
        return t1;
      }}
  },
  TimerImpl_internalCallback: {
    "^": "Closure:7;this_0,callback_1",
    call$0: function() {
      this.this_0._handle = null;
      this.callback_1.call$0();
    },
    $isFunction: true
  },
  TimerImpl_internalCallback0: {
    "^": "Closure:7;this_2,callback_3",
    call$0: function() {
      this.this_2._handle = null;
      H.leaveJsAsync();
      this.callback_3.call$0();
    },
    $isFunction: true
  },
  CapabilityImpl: {
    "^": "Object;_id",
    get$hashCode: function(_) {
      var hash = this._id;
      if (typeof hash !== "number")
        return hash.$shr();
      hash = C.JSInt_methods._shrOtherPositive$1(hash, 0) ^ C.JSInt_methods._tdivFast$1(hash, 4294967296);
      hash = (~hash >>> 0) + (hash << 15 >>> 0) & 4294967295;
      hash = ((hash ^ hash >>> 12) >>> 0) * 5 & 4294967295;
      hash = ((hash ^ hash >>> 4) >>> 0) * 2057 & 4294967295;
      return (hash ^ hash >>> 16) >>> 0;
    },
    $eq: function(_, other) {
      var t1, t2;
      if (other == null)
        return false;
      if (other === this)
        return true;
      if (!!J.getInterceptor(other).$isCapabilityImpl) {
        t1 = this._id;
        t2 = other._id;
        return t1 == null ? t2 == null : t1 === t2;
      }
      return false;
    },
    $isCapabilityImpl: true,
    $isCapability: true
  }
}],
["_js_helper", "dart:_js_helper", , H, {
  "^": "",
  isJsIndexable: function(object, record) {
    var result;
    if (record != null) {
      result = record.x;
      if (result != null)
        return result;
    }
    return !!J.getInterceptor(object).$isJavaScriptIndexingBehavior;
  },
  S: function(value) {
    var res;
    if (typeof value === "string")
      return value;
    if (typeof value === "number") {
      if (value !== 0)
        return "" + value;
    } else if (true === value)
      return "true";
    else if (false === value)
      return "false";
    else if (value == null)
      return "null";
    res = J.toString$0(value);
    if (typeof res !== "string")
      throw H.wrapException(P.ArgumentError$(value));
    return res;
  },
  Primitives_objectHashCode: function(object) {
    var hash = object.$identityHash;
    if (hash == null) {
      hash = Math.random() * 0x3fffffff | 0;
      object.$identityHash = hash;
    }
    return hash;
  },
  Primitives__throwFormatException: [function(string) {
    throw H.wrapException(P.FormatException$(string, null, null));
  }, "call$1", "Primitives__throwFormatException$closure", 2, 0, 0],
  Primitives_parseInt: function(source, radix, handleError) {
    var match, t1, maxCharCode, digitsPart, i, t2;
    if (handleError == null)
      handleError = H.Primitives__throwFormatException$closure();
    if (typeof source !== "string")
      H.throwExpression(P.ArgumentError$(source));
    match = /^\s*[+-]?((0x[a-f0-9]+)|(\d+)|([a-z0-9]+))\s*$/i.exec(source);
    if (radix == null) {
      if (match != null) {
        t1 = match.length;
        if (2 >= t1)
          return H.ioore(match, 2);
        if (match[2] != null)
          return parseInt(source, 16);
        if (3 >= t1)
          return H.ioore(match, 3);
        if (match[3] != null)
          return parseInt(source, 10);
        return handleError.call$1(source);
      }
      radix = 10;
    } else {
      if (radix < 2 || radix > 36)
        throw H.wrapException(P.RangeError$("Radix " + H.S(radix) + " not in range 2..36"));
      if (match != null) {
        if (radix === 10) {
          if (3 >= match.length)
            return H.ioore(match, 3);
          t1 = match[3] != null;
        } else
          t1 = false;
        if (t1)
          return parseInt(source, 10);
        if (!(radix < 10)) {
          if (3 >= match.length)
            return H.ioore(match, 3);
          t1 = match[3] == null;
        } else
          t1 = true;
        if (t1) {
          maxCharCode = radix <= 10 ? 48 + radix - 1 : 97 + radix - 10 - 1;
          if (1 >= match.length)
            return H.ioore(match, 1);
          digitsPart = match[1];
          t1 = J.getInterceptor$asx(digitsPart);
          i = 0;
          while (true) {
            t2 = t1.get$length(digitsPart);
            if (typeof t2 !== "number")
              return H.iae(t2);
            if (!(i < t2))
              break;
            t1.codeUnitAt$1(digitsPart, 0);
            if (i >= digitsPart.length)
              H.throwExpression(P.RangeError$value(i));
            if (digitsPart.charCodeAt(i) > maxCharCode)
              return handleError.call$1(source);
            ++i;
          }
        }
      }
    }
    if (match == null)
      return handleError.call$1(source);
    return parseInt(source, radix);
  },
  Primitives_parseDouble: function(source, handleError) {
    var result, trimmed;
    if (typeof source !== "string")
      H.throwExpression(P.ArgumentError$(source));
    if (handleError == null)
      handleError = H.Primitives__throwFormatException$closure();
    if (!/^\s*[+-]?(?:Infinity|NaN|(?:\.\d+|\d+(?:\.\d*)?)(?:[eE][+-]?\d+)?)\s*$/.test(source))
      return handleError.call$1(source);
    result = parseFloat(source);
    if (isNaN(result)) {
      trimmed = J.trim$0$s(source);
      if (trimmed === "NaN" || trimmed === "+NaN" || trimmed === "-NaN")
        return result;
      return handleError.call$1(source);
    }
    return result;
  },
  Primitives_objectTypeName: function(object) {
    var $name, decompiled;
    $name = C.JS_CONST_8ZY(J.getInterceptor(object));
    if ($name === "Object") {
      decompiled = String(object.constructor).match(/^\s*function\s*(\S*)\s*\(/)[1];
      if (typeof decompiled === "string")
        $name = /^\w+$/.test(decompiled) ? decompiled : $name;
    }
    if ($name.length > 1 && C.JSString_methods.codeUnitAt$1($name, 0) === 36)
      $name = C.JSString_methods.substring$1($name, 1);
    return ($name + H.joinArguments(H.getRuntimeTypeInfo(object), 0, null)).replace(/[^<,> ]+/g, function(m) {
      return init.mangledGlobalNames[m] || m;
    });
  },
  Primitives_objectToString: function(object) {
    return "Instance of '" + H.Primitives_objectTypeName(object) + "'";
  },
  Primitives_dateNow: [function() {
    return Date.now();
  }, "call$0", "Primitives_dateNow$closure", 0, 0, 1],
  Primitives_initTicker: function() {
    var $window, performance;
    if ($.Primitives_timerFrequency != null)
      return;
    $.Primitives_timerFrequency = 1000;
    $.Primitives_timerTicks = H.Primitives_dateNow$closure();
    if (typeof window == "undefined")
      return;
    $window = window;
    if ($window == null)
      return;
    performance = $window.performance;
    if (performance == null)
      return;
    if (typeof performance.now != "function")
      return;
    $.Primitives_timerFrequency = 1000000;
    $.Primitives_timerTicks = new H.Primitives_initTicker_closure(performance);
  },
  Primitives_currentUri: function() {
    if (!!self.location)
      return self.location.href;
    return;
  },
  Primitives__fromCharCodeApply: function(array) {
    var end, t1, result, i, subarray, t2;
    end = array.length;
    for (t1 = end <= 500, result = "", i = 0; i < end; i += 500) {
      if (t1)
        subarray = array;
      else {
        t2 = i + 500;
        t2 = t2 < end ? t2 : end;
        subarray = array.slice(i, t2);
      }
      result += String.fromCharCode.apply(null, subarray);
    }
    return result;
  },
  Primitives_stringFromCodePoints: function(codePoints) {
    var a, t1, i;
    a = [];
    a.$builtinTypeInfo = [P.$int];
    t1 = new H.ListIterator(codePoints, codePoints.length, 0, null);
    t1.$builtinTypeInfo = [H.getTypeArgumentByIndex(codePoints, 0)];
    for (; t1.moveNext$0();) {
      i = t1.__internal$_current;
      if (typeof i !== "number" || Math.floor(i) !== i)
        throw H.wrapException(P.ArgumentError$(i));
      if (i <= 65535)
        a.push(i);
      else if (i <= 1114111) {
        a.push(55296 + (C.JSInt_methods._shrOtherPositive$1(i - 65536, 10) & 1023));
        a.push(56320 + (i & 1023));
      } else
        throw H.wrapException(P.ArgumentError$(i));
    }
    return H.Primitives__fromCharCodeApply(a);
  },
  Primitives_stringFromCharCodes: function(charCodes) {
    var t1, i;
    for (t1 = H.setRuntimeTypeInfo(new H.ListIterator(charCodes, charCodes.length, 0, null), [H.getTypeArgumentByIndex(charCodes, 0)]); t1.moveNext$0();) {
      i = t1.__internal$_current;
      if (typeof i !== "number" || Math.floor(i) !== i)
        throw H.wrapException(P.ArgumentError$(i));
      if (i < 0)
        throw H.wrapException(P.ArgumentError$(i));
      if (i > 65535)
        return H.Primitives_stringFromCodePoints(charCodes);
    }
    return H.Primitives__fromCharCodeApply(charCodes);
  },
  Primitives_stringFromCharCode: function(charCode) {
    var bits;
    if (typeof charCode !== "number")
      return H.iae(charCode);
    if (0 <= charCode) {
      if (charCode <= 65535)
        return String.fromCharCode(charCode);
      if (charCode <= 1114111) {
        bits = charCode - 65536;
        return String.fromCharCode((55296 | C.JSInt_methods._shrOtherPositive$1(bits, 10)) >>> 0, 56320 | bits & 1023);
      }
    }
    throw H.wrapException(P.RangeError$range(charCode, 0, 1114111));
  },
  Primitives_lazyAsJsDate: function(receiver) {
    if (receiver.date === void 0)
      receiver.date = new Date(receiver.millisecondsSinceEpoch);
    return receiver.date;
  },
  Primitives_getProperty: function(object, key) {
    if (object == null || typeof object === "boolean" || typeof object === "number" || typeof object === "string")
      throw H.wrapException(P.ArgumentError$(object));
    return object[key];
  },
  Primitives_setProperty: function(object, key, value) {
    if (object == null || typeof object === "boolean" || typeof object === "number" || typeof object === "string")
      throw H.wrapException(P.ArgumentError$(object));
    object[key] = value;
  },
  iae: function(argument) {
    throw H.wrapException(P.ArgumentError$(argument));
  },
  ioore: function(receiver, index) {
    if (receiver == null)
      J.get$length$asx(receiver);
    if (typeof index !== "number" || Math.floor(index) !== index)
      H.iae(index);
    throw H.wrapException(P.RangeError$value(index));
  },
  wrapException: function(ex) {
    var wrapper;
    if (ex == null)
      ex = new P.NullThrownError();
    wrapper = new Error();
    wrapper.dartException = ex;
    if ("defineProperty" in Object) {
      Object.defineProperty(wrapper, "message", {get: H.toStringWrapper});
      wrapper.name = "";
    } else
      wrapper.toString = H.toStringWrapper;
    return wrapper;
  },
  toStringWrapper: function() {
    return J.toString$0(this.dartException);
  },
  throwExpression: function(ex) {
    throw H.wrapException(ex);
  },
  unwrapException: function(ex) {
    var t1, message, number, ieErrorCode, t2, t3, t4, nullLiteralCall, t5, t6, t7, t8, t9, match;
    t1 = new H.unwrapException_saveStackTrace(ex);
    if (ex == null)
      return;
    if (typeof ex !== "object")
      return ex;
    if ("dartException" in ex)
      return t1.call$1(ex.dartException);
    else if (!("message" in ex))
      return ex;
    message = ex.message;
    if ("number" in ex && typeof ex.number == "number") {
      number = ex.number;
      ieErrorCode = number & 65535;
      if ((C.JSInt_methods._shrOtherPositive$1(number, 16) & 8191) === 10)
        switch (ieErrorCode) {
          case 438:
            return t1.call$1(H.JsNoSuchMethodError$(H.S(message) + " (Error " + ieErrorCode + ")", null));
          case 445:
          case 5007:
            t2 = H.S(message) + " (Error " + ieErrorCode + ")";
            return t1.call$1(new H.NullError(t2, null));
        }
    }
    if (ex instanceof TypeError) {
      t2 = $.get$TypeErrorDecoder_noSuchMethodPattern();
      t3 = $.get$TypeErrorDecoder_notClosurePattern();
      t4 = $.get$TypeErrorDecoder_nullCallPattern();
      nullLiteralCall = $.get$TypeErrorDecoder_nullLiteralCallPattern();
      t5 = $.get$TypeErrorDecoder_undefinedCallPattern();
      t6 = $.get$TypeErrorDecoder_undefinedLiteralCallPattern();
      t7 = $.get$TypeErrorDecoder_nullPropertyPattern();
      $.get$TypeErrorDecoder_nullLiteralPropertyPattern();
      t8 = $.get$TypeErrorDecoder_undefinedPropertyPattern();
      t9 = $.get$TypeErrorDecoder_undefinedLiteralPropertyPattern();
      match = t2.matchTypeError$1(message);
      if (match != null)
        return t1.call$1(H.JsNoSuchMethodError$(message, match));
      else {
        match = t3.matchTypeError$1(message);
        if (match != null) {
          match.method = "call";
          return t1.call$1(H.JsNoSuchMethodError$(message, match));
        } else {
          match = t4.matchTypeError$1(message);
          if (match == null) {
            match = nullLiteralCall.matchTypeError$1(message);
            if (match == null) {
              match = t5.matchTypeError$1(message);
              if (match == null) {
                match = t6.matchTypeError$1(message);
                if (match == null) {
                  match = t7.matchTypeError$1(message);
                  if (match == null) {
                    match = nullLiteralCall.matchTypeError$1(message);
                    if (match == null) {
                      match = t8.matchTypeError$1(message);
                      if (match == null) {
                        match = t9.matchTypeError$1(message);
                        t2 = match != null;
                      } else
                        t2 = true;
                    } else
                      t2 = true;
                  } else
                    t2 = true;
                } else
                  t2 = true;
              } else
                t2 = true;
            } else
              t2 = true;
          } else
            t2 = true;
          if (t2) {
            t2 = match == null ? null : match.method;
            return t1.call$1(new H.NullError(message, t2));
          }
        }
      }
      t2 = typeof message === "string" ? message : "";
      return t1.call$1(new H.UnknownJsTypeError(t2));
    }
    if (ex instanceof RangeError) {
      if (typeof message === "string" && message.indexOf("call stack") !== -1)
        return new P.StackOverflowError();
      return t1.call$1(new P.ArgumentError(null));
    }
    if (typeof InternalError == "function" && ex instanceof InternalError)
      if (typeof message === "string" && message === "too much recursion")
        return new P.StackOverflowError();
    return ex;
  },
  objectHashCode: function(object) {
    if (object == null || typeof object != 'object')
      return J.get$hashCode$(object);
    else
      return H.Primitives_objectHashCode(object);
  },
  fillLiteralMap: function(keyValuePairs, result) {
    var $length, index, index0, index1;
    $length = keyValuePairs.length;
    for (index = 0; index < $length; index = index1) {
      index0 = index + 1;
      index1 = index0 + 1;
      result.$indexSet(0, keyValuePairs[index], keyValuePairs[index0]);
    }
    return result;
  },
  invokeClosure: function(closure, isolate, numberOfArguments, arg1, arg2, arg3, arg4) {
    var t1 = J.getInterceptor(numberOfArguments);
    if (t1.$eq(numberOfArguments, 0))
      return H._callInIsolate(isolate, new H.invokeClosure_closure(closure));
    else if (t1.$eq(numberOfArguments, 1))
      return H._callInIsolate(isolate, new H.invokeClosure_closure0(closure, arg1));
    else if (t1.$eq(numberOfArguments, 2))
      return H._callInIsolate(isolate, new H.invokeClosure_closure1(closure, arg1, arg2));
    else if (t1.$eq(numberOfArguments, 3))
      return H._callInIsolate(isolate, new H.invokeClosure_closure2(closure, arg1, arg2, arg3));
    else if (t1.$eq(numberOfArguments, 4))
      return H._callInIsolate(isolate, new H.invokeClosure_closure3(closure, arg1, arg2, arg3, arg4));
    else
      throw H.wrapException(P.Exception_Exception("Unsupported number of arguments for wrapped closure"));
  },
  convertDartClosureToJS: function(closure, arity) {
    var $function;
    if (closure == null)
      return;
    $function = closure.$identity;
    if (!!$function)
      return $function;
    $function = function(closure, arity, context, invoke) {
      return function(a1, a2, a3, a4) {
        return invoke(closure, context, arity, a1, a2, a3, a4);
      };
    }(closure, arity, init.globalState.currentContext, H.invokeClosure);
    closure.$identity = $function;
    return $function;
  },
  Closure_fromTearOff: function(receiver, functions, reflectionInfo, isStatic, jsArguments, propertyName) {
    var $function, callName, functionType, $prototype, $constructor, t1, isIntercepted, trampoline, signatureFunction, getReceiver, i, stub, stubCallName, t2;
    $function = functions[0];
    $function.$stubName;
    callName = $function.$callName;
    $function.$reflectionInfo = reflectionInfo;
    functionType = H.ReflectionInfo_ReflectionInfo($function).functionType;
    $prototype = isStatic ? Object.create(new H.TearOffClosure().constructor.prototype) : Object.create(new H.BoundClosure(null, null, null, null).constructor.prototype);
    $prototype.$initialize = $prototype.constructor;
    if (isStatic)
      $constructor = function() {
        this.$initialize();
      };
    else if (typeof dart_precompiled == "function") {
      t1 = function(a, b, c, d) {
        this.$initialize(a, b, c, d);
      };
      $constructor = t1;
    } else {
      t1 = $.Closure_functionCounter;
      if (typeof t1 !== "number")
        return t1.$add();
      $.Closure_functionCounter = t1 + 1;
      t1 = new Function("a", "b", "c", "d", "this.$initialize(a,b,c,d);" + t1);
      $constructor = t1;
    }
    $prototype.constructor = $constructor;
    $constructor.prototype = $prototype;
    t1 = !isStatic;
    if (t1) {
      isIntercepted = jsArguments.length == 1 && true;
      trampoline = H.Closure_forwardCallTo(receiver, $function, isIntercepted);
      trampoline.$reflectionInfo = reflectionInfo;
    } else {
      $prototype.$name = propertyName;
      trampoline = $function;
      isIntercepted = false;
    }
    if (typeof functionType == "number")
      signatureFunction = function(s) {
        return function() {
          return init.metadata[s];
        };
      }(functionType);
    else if (t1 && typeof functionType == "function") {
      getReceiver = isIntercepted ? H.BoundClosure_receiverOf : H.BoundClosure_selfOf;
      signatureFunction = function(f, r) {
        return function() {
          return f.apply({$receiver: r(this)}, arguments);
        };
      }(functionType, getReceiver);
    } else
      throw H.wrapException("Error in reflectionInfo.");
    $prototype.$signature = signatureFunction;
    $prototype[callName] = trampoline;
    for (t1 = functions.length, i = 1; i < t1; ++i) {
      stub = functions[i];
      stubCallName = stub.$callName;
      if (stubCallName != null) {
        t2 = isStatic ? stub : H.Closure_forwardCallTo(receiver, stub, isIntercepted);
        $prototype[stubCallName] = t2;
      }
    }
    $prototype["call*"] = trampoline;
    return $constructor;
  },
  Closure_cspForwardCall: function(arity, isSuperCall, stubName, $function) {
    var getSelf = H.BoundClosure_selfOf;
    switch (isSuperCall ? -1 : arity) {
      case 0:
        return function(n, S) {
          return function() {
            return S(this)[n]();
          };
        }(stubName, getSelf);
      case 1:
        return function(n, S) {
          return function(a) {
            return S(this)[n](a);
          };
        }(stubName, getSelf);
      case 2:
        return function(n, S) {
          return function(a, b) {
            return S(this)[n](a, b);
          };
        }(stubName, getSelf);
      case 3:
        return function(n, S) {
          return function(a, b, c) {
            return S(this)[n](a, b, c);
          };
        }(stubName, getSelf);
      case 4:
        return function(n, S) {
          return function(a, b, c, d) {
            return S(this)[n](a, b, c, d);
          };
        }(stubName, getSelf);
      case 5:
        return function(n, S) {
          return function(a, b, c, d, e) {
            return S(this)[n](a, b, c, d, e);
          };
        }(stubName, getSelf);
      default:
        return function(f, s) {
          return function() {
            return f.apply(s(this), arguments);
          };
        }($function, getSelf);
    }
  },
  Closure_forwardCallTo: function(receiver, $function, isIntercepted) {
    var stubName, arity, lookedUpFunction, t1, t2, $arguments;
    if (isIntercepted)
      return H.Closure_forwardInterceptedCallTo(receiver, $function);
    stubName = $function.$stubName;
    arity = $function.length;
    lookedUpFunction = receiver[stubName];
    t1 = $function == null ? lookedUpFunction == null : $function === lookedUpFunction;
    if (typeof dart_precompiled == "function" || !t1 || arity >= 27)
      return H.Closure_cspForwardCall(arity, !t1, stubName, $function);
    if (arity === 0) {
      t1 = $.BoundClosure_selfFieldNameCache;
      if (t1 == null) {
        t1 = H.BoundClosure_computeFieldNamed("self");
        $.BoundClosure_selfFieldNameCache = t1;
      }
      t1 = "return function(){return this." + H.S(t1) + "." + H.S(stubName) + "();";
      t2 = $.Closure_functionCounter;
      if (typeof t2 !== "number")
        return t2.$add();
      $.Closure_functionCounter = t2 + 1;
      return new Function(t1 + t2 + "}")();
    }
    $arguments = "abcdefghijklmnopqrstuvwxyz".split("").splice(0, arity).join(",");
    t1 = "return function(" + $arguments + "){return this.";
    t2 = $.BoundClosure_selfFieldNameCache;
    if (t2 == null) {
      t2 = H.BoundClosure_computeFieldNamed("self");
      $.BoundClosure_selfFieldNameCache = t2;
    }
    t2 = t1 + H.S(t2) + "." + H.S(stubName) + "(" + $arguments + ");";
    t1 = $.Closure_functionCounter;
    if (typeof t1 !== "number")
      return t1.$add();
    $.Closure_functionCounter = t1 + 1;
    return new Function(t2 + t1 + "}")();
  },
  Closure_cspForwardInterceptedCall: function(arity, isSuperCall, $name, $function) {
    var getSelf, getReceiver;
    getSelf = H.BoundClosure_selfOf;
    getReceiver = H.BoundClosure_receiverOf;
    switch (isSuperCall ? -1 : arity) {
      case 0:
        throw H.wrapException(H.RuntimeError$("Intercepted function with no arguments."));
      case 1:
        return function(n, s, r) {
          return function() {
            return s(this)[n](r(this));
          };
        }($name, getSelf, getReceiver);
      case 2:
        return function(n, s, r) {
          return function(a) {
            return s(this)[n](r(this), a);
          };
        }($name, getSelf, getReceiver);
      case 3:
        return function(n, s, r) {
          return function(a, b) {
            return s(this)[n](r(this), a, b);
          };
        }($name, getSelf, getReceiver);
      case 4:
        return function(n, s, r) {
          return function(a, b, c) {
            return s(this)[n](r(this), a, b, c);
          };
        }($name, getSelf, getReceiver);
      case 5:
        return function(n, s, r) {
          return function(a, b, c, d) {
            return s(this)[n](r(this), a, b, c, d);
          };
        }($name, getSelf, getReceiver);
      case 6:
        return function(n, s, r) {
          return function(a, b, c, d, e) {
            return s(this)[n](r(this), a, b, c, d, e);
          };
        }($name, getSelf, getReceiver);
      default:
        return function(f, s, r, a) {
          return function() {
            a = [r(this)];
            Array.prototype.push.apply(a, arguments);
            return f.apply(s(this), a);
          };
        }($function, getSelf, getReceiver);
    }
  },
  Closure_forwardInterceptedCallTo: function(receiver, $function) {
    var selfField, t1, stubName, arity, isCsp, lookedUpFunction, t2, $arguments;
    selfField = H.BoundClosure_selfFieldName();
    t1 = $.BoundClosure_receiverFieldNameCache;
    if (t1 == null) {
      t1 = H.BoundClosure_computeFieldNamed("receiver");
      $.BoundClosure_receiverFieldNameCache = t1;
    }
    stubName = $function.$stubName;
    arity = $function.length;
    isCsp = typeof dart_precompiled == "function";
    lookedUpFunction = receiver[stubName];
    t2 = $function == null ? lookedUpFunction == null : $function === lookedUpFunction;
    if (isCsp || !t2 || arity >= 28)
      return H.Closure_cspForwardInterceptedCall(arity, !t2, stubName, $function);
    if (arity === 1) {
      t1 = "return function(){return this." + H.S(selfField) + "." + H.S(stubName) + "(this." + H.S(t1) + ");";
      t2 = $.Closure_functionCounter;
      if (typeof t2 !== "number")
        return t2.$add();
      $.Closure_functionCounter = t2 + 1;
      return new Function(t1 + t2 + "}")();
    }
    $arguments = "abcdefghijklmnopqrstuvwxyz".split("").splice(0, arity - 1).join(",");
    t1 = "return function(" + $arguments + "){return this." + H.S(selfField) + "." + H.S(stubName) + "(this." + H.S(t1) + ", " + $arguments + ");";
    t2 = $.Closure_functionCounter;
    if (typeof t2 !== "number")
      return t2.$add();
    $.Closure_functionCounter = t2 + 1;
    return new Function(t1 + t2 + "}")();
  },
  closureFromTearOff: function(receiver, functions, reflectionInfo, isStatic, jsArguments, $name) {
    functions.fixed$length = init;
    reflectionInfo.fixed$length = init;
    return H.Closure_fromTearOff(receiver, functions, reflectionInfo, !!isStatic, jsArguments, $name);
  },
  propertyTypeCastError: function(value, property) {
    var t1 = J.getInterceptor$asx(property);
    throw H.wrapException(H.CastErrorImplementation$(H.Primitives_objectTypeName(value), t1.substring$2(property, 3, t1.get$length(property))));
  },
  interceptedTypeCast: function(value, property) {
    var t1;
    if (value != null)
      t1 = typeof value === "object" && J.getInterceptor(value)[property];
    else
      t1 = true;
    if (t1)
      return value;
    H.propertyTypeCastError(value, property);
  },
  listTypeCast: function(value) {
    if (!!J.getInterceptor(value).$isList || value == null)
      return value;
    throw H.wrapException(H.CastErrorImplementation$(H.Primitives_objectTypeName(value), "List"));
  },
  throwCyclicInit: function(staticName) {
    throw H.wrapException(P.CyclicInitializationError$("Cyclic initialization for static " + H.S(staticName)));
  },
  buildFunctionType: function(returnType, parameterTypes, optionalParameterTypes) {
    return new H.RuntimeFunctionType(returnType, parameterTypes, optionalParameterTypes, null);
  },
  getDynamicRuntimeType: function() {
    return C.C_DynamicRuntimeType;
  },
  random64: function() {
    return (Math.random() * 0x100000000 >>> 0) + (Math.random() * 0x100000000 >>> 0) * 4294967296;
  },
  createRuntimeType: function($name) {
    return new H.TypeImpl($name, null);
  },
  setRuntimeTypeInfo: function(target, typeInfo) {
    if (target != null)
      target.$builtinTypeInfo = typeInfo;
    return target;
  },
  getRuntimeTypeInfo: function(target) {
    if (target == null)
      return;
    return target.$builtinTypeInfo;
  },
  getRuntimeTypeArguments: function(target, substitutionName) {
    return H.substitute(target["$as" + H.S(substitutionName)], H.getRuntimeTypeInfo(target));
  },
  getRuntimeTypeArgument: function(target, substitutionName, index) {
    var $arguments = H.getRuntimeTypeArguments(target, substitutionName);
    return $arguments == null ? null : $arguments[index];
  },
  getTypeArgumentByIndex: function(target, index) {
    var rti = H.getRuntimeTypeInfo(target);
    return rti == null ? null : rti[index];
  },
  runtimeTypeToString: function(type, onTypeVariable) {
    if (type == null)
      return "dynamic";
    else if (typeof type === "object" && type !== null && type.constructor === Array)
      return type[0].builtin$cls + H.joinArguments(type, 1, onTypeVariable);
    else if (typeof type == "function")
      return type.builtin$cls;
    else if (typeof type === "number" && Math.floor(type) === type)
      return C.JSInt_methods.toString$0(type);
    else
      return;
  },
  joinArguments: function(types, startIndex, onTypeVariable) {
    var buffer, index, firstArgument, allDynamic, argument, str;
    if (types == null)
      return "";
    buffer = P.StringBuffer$("");
    for (index = startIndex, firstArgument = true, allDynamic = true; index < types.length; ++index) {
      if (firstArgument)
        firstArgument = false;
      else
        buffer._contents += ", ";
      argument = types[index];
      if (argument != null)
        allDynamic = false;
      str = H.runtimeTypeToString(argument, onTypeVariable);
      buffer._contents += typeof str === "string" ? str : H.S(str);
    }
    return allDynamic ? "" : "<" + H.S(buffer) + ">";
  },
  substitute: function(substitution, $arguments) {
    if (typeof substitution === "object" && substitution !== null && substitution.constructor === Array)
      $arguments = substitution;
    else if (typeof substitution == "function") {
      substitution = H.invokeOn(substitution, null, $arguments);
      if (typeof substitution === "object" && substitution !== null && substitution.constructor === Array)
        $arguments = substitution;
      else if (typeof substitution == "function")
        $arguments = H.invokeOn(substitution, null, $arguments);
    }
    return $arguments;
  },
  checkSubtype: function(object, isField, checks, asField) {
    var $arguments, interceptor;
    if (object == null)
      return false;
    $arguments = H.getRuntimeTypeInfo(object);
    interceptor = J.getInterceptor(object);
    if (interceptor[isField] == null)
      return false;
    return H.areSubtypes(H.substitute(interceptor[asField], $arguments), checks);
  },
  areSubtypes: function(s, t) {
    var len, i;
    if (s == null || t == null)
      return true;
    len = s.length;
    for (i = 0; i < len; ++i)
      if (!H.isSubtype(s[i], t[i]))
        return false;
    return true;
  },
  computeSignature: function(signature, context, contextName) {
    return H.invokeOn(signature, context, H.getRuntimeTypeArguments(context, contextName));
  },
  isSubtype: function(s, t) {
    var targetSignatureFunction, t1, typeOfS, t2, typeOfT, $name, substitution;
    if (s === t)
      return true;
    if (s == null || t == null)
      return true;
    if ("func" in t) {
      if (!("func" in s)) {
        if ("$is_" + H.S(t.func) in s)
          return true;
        targetSignatureFunction = s.$signature;
        if (targetSignatureFunction == null)
          return false;
        s = targetSignatureFunction.apply(s, null);
      }
      return H.isFunctionSubtype(s, t);
    }
    if (t.builtin$cls === "Function" && "func" in s)
      return true;
    t1 = typeof s === "object" && s !== null && s.constructor === Array;
    typeOfS = t1 ? s[0] : s;
    t2 = typeof t === "object" && t !== null && t.constructor === Array;
    typeOfT = t2 ? t[0] : t;
    $name = H.runtimeTypeToString(typeOfT, null);
    if (typeOfT !== typeOfS) {
      if (!("$is" + H.S($name) in typeOfS))
        return false;
      substitution = typeOfS["$as" + H.S(H.runtimeTypeToString(typeOfT, null))];
    } else
      substitution = null;
    if (!t1 && substitution == null || !t2)
      return true;
    t1 = t1 ? s.slice(1) : null;
    t2 = t2 ? t.slice(1) : null;
    return H.areSubtypes(H.substitute(substitution, t1), t2);
  },
  areAssignable: function(s, t, allowShorter) {
    var sLength, tLength, i, t1, t2;
    if (t == null && s == null)
      return true;
    if (t == null)
      return allowShorter;
    if (s == null)
      return false;
    sLength = s.length;
    tLength = t.length;
    if (allowShorter) {
      if (sLength < tLength)
        return false;
    } else if (sLength !== tLength)
      return false;
    for (i = 0; i < tLength; ++i) {
      t1 = s[i];
      t2 = t[i];
      if (!(H.isSubtype(t1, t2) || H.isSubtype(t2, t1)))
        return false;
    }
    return true;
  },
  areAssignableMaps: function(s, t) {
    var t1, names, i, $name, tType, sType;
    if (t == null)
      return true;
    if (s == null)
      return false;
    t1 = Object.getOwnPropertyNames(t);
    t1.fixed$length = init;
    names = t1;
    for (t1 = names.length, i = 0; i < t1; ++i) {
      $name = names[i];
      if (!Object.hasOwnProperty.call(s, $name))
        return false;
      tType = t[$name];
      sType = s[$name];
      if (!(H.isSubtype(tType, sType) || H.isSubtype(sType, tType)))
        return false;
    }
    return true;
  },
  isFunctionSubtype: function(s, t) {
    var sReturnType, tReturnType, sParameterTypes, tParameterTypes, sOptionalParameterTypes, tOptionalParameterTypes, sParametersLen, tParametersLen, sOptionalParametersLen, tOptionalParametersLen, pos, t1, t2, tPos, sPos;
    if (!("func" in s))
      return false;
    if ("void" in s) {
      if (!("void" in t) && "ret" in t)
        return false;
    } else if (!("void" in t)) {
      sReturnType = s.ret;
      tReturnType = t.ret;
      if (!(H.isSubtype(sReturnType, tReturnType) || H.isSubtype(tReturnType, sReturnType)))
        return false;
    }
    sParameterTypes = s.args;
    tParameterTypes = t.args;
    sOptionalParameterTypes = s.opt;
    tOptionalParameterTypes = t.opt;
    sParametersLen = sParameterTypes != null ? sParameterTypes.length : 0;
    tParametersLen = tParameterTypes != null ? tParameterTypes.length : 0;
    sOptionalParametersLen = sOptionalParameterTypes != null ? sOptionalParameterTypes.length : 0;
    tOptionalParametersLen = tOptionalParameterTypes != null ? tOptionalParameterTypes.length : 0;
    if (sParametersLen > tParametersLen)
      return false;
    if (sParametersLen + sOptionalParametersLen < tParametersLen + tOptionalParametersLen)
      return false;
    if (sParametersLen === tParametersLen) {
      if (!H.areAssignable(sParameterTypes, tParameterTypes, false))
        return false;
      if (!H.areAssignable(sOptionalParameterTypes, tOptionalParameterTypes, true))
        return false;
    } else {
      for (pos = 0; pos < sParametersLen; ++pos) {
        t1 = sParameterTypes[pos];
        t2 = tParameterTypes[pos];
        if (!(H.isSubtype(t1, t2) || H.isSubtype(t2, t1)))
          return false;
      }
      for (tPos = pos, sPos = 0; tPos < tParametersLen; ++sPos, ++tPos) {
        t1 = sOptionalParameterTypes[sPos];
        t2 = tParameterTypes[tPos];
        if (!(H.isSubtype(t1, t2) || H.isSubtype(t2, t1)))
          return false;
      }
      for (tPos = 0; tPos < tOptionalParametersLen; ++sPos, ++tPos) {
        t1 = sOptionalParameterTypes[sPos];
        t2 = tOptionalParameterTypes[tPos];
        if (!(H.isSubtype(t1, t2) || H.isSubtype(t2, t1)))
          return false;
      }
    }
    return H.areAssignableMaps(s.named, t.named);
  },
  invokeOn: function($function, receiver, $arguments) {
    return $function.apply(receiver, $arguments);
  },
  toStringForNativeObject: function(obj) {
    var t1 = $.getTagFunction;
    return "Instance of " + (t1 == null ? "<Unknown>" : t1.call$1(obj));
  },
  hashCodeForNativeObject: function(object) {
    return H.Primitives_objectHashCode(object);
  },
  defineProperty: function(obj, property, value) {
    Object.defineProperty(obj, property, {value: value, enumerable: false, writable: true, configurable: true});
  },
  lookupAndCacheInterceptor: function(obj) {
    var tag, record, interceptor, interceptorClass, mark, t1;
    tag = $.getTagFunction.call$1(obj);
    record = $.dispatchRecordsForInstanceTags[tag];
    if (record != null) {
      Object.defineProperty(obj, init.dispatchPropertyName, {value: record, enumerable: false, writable: true, configurable: true});
      return record.i;
    }
    interceptor = $.interceptorsForUncacheableTags[tag];
    if (interceptor != null)
      return interceptor;
    interceptorClass = init.interceptorsByTag[tag];
    if (interceptorClass == null) {
      tag = $.alternateTagFunction.call$2(obj, tag);
      if (tag != null) {
        record = $.dispatchRecordsForInstanceTags[tag];
        if (record != null) {
          Object.defineProperty(obj, init.dispatchPropertyName, {value: record, enumerable: false, writable: true, configurable: true});
          return record.i;
        }
        interceptor = $.interceptorsForUncacheableTags[tag];
        if (interceptor != null)
          return interceptor;
        interceptorClass = init.interceptorsByTag[tag];
      }
    }
    if (interceptorClass == null)
      return;
    interceptor = interceptorClass.prototype;
    mark = tag[0];
    if (mark === "!") {
      record = H.makeLeafDispatchRecord(interceptor);
      $.dispatchRecordsForInstanceTags[tag] = record;
      Object.defineProperty(obj, init.dispatchPropertyName, {value: record, enumerable: false, writable: true, configurable: true});
      return record.i;
    }
    if (mark === "~") {
      $.interceptorsForUncacheableTags[tag] = interceptor;
      return interceptor;
    }
    if (mark === "-") {
      t1 = H.makeLeafDispatchRecord(interceptor);
      Object.defineProperty(Object.getPrototypeOf(obj), init.dispatchPropertyName, {value: t1, enumerable: false, writable: true, configurable: true});
      return t1.i;
    }
    if (mark === "+")
      return H.patchInteriorProto(obj, interceptor);
    if (mark === "*")
      throw H.wrapException(P.UnimplementedError$(tag));
    if (init.leafTags[tag] === true) {
      t1 = H.makeLeafDispatchRecord(interceptor);
      Object.defineProperty(Object.getPrototypeOf(obj), init.dispatchPropertyName, {value: t1, enumerable: false, writable: true, configurable: true});
      return t1.i;
    } else
      return H.patchInteriorProto(obj, interceptor);
  },
  patchInteriorProto: function(obj, interceptor) {
    var proto, record;
    proto = Object.getPrototypeOf(obj);
    record = J.makeDispatchRecord(interceptor, proto, null, null);
    Object.defineProperty(proto, init.dispatchPropertyName, {value: record, enumerable: false, writable: true, configurable: true});
    return interceptor;
  },
  makeLeafDispatchRecord: function(interceptor) {
    return J.makeDispatchRecord(interceptor, false, null, !!interceptor.$isJavaScriptIndexingBehavior);
  },
  makeDefaultDispatchRecord: function(tag, interceptorClass, proto) {
    var interceptor = interceptorClass.prototype;
    if (init.leafTags[tag] === true)
      return J.makeDispatchRecord(interceptor, false, null, !!interceptor.$isJavaScriptIndexingBehavior);
    else
      return J.makeDispatchRecord(interceptor, proto, null, null);
  },
  initNativeDispatch: function() {
    if (true === $.initNativeDispatchFlag)
      return;
    $.initNativeDispatchFlag = true;
    H.initNativeDispatchContinue();
  },
  initNativeDispatchContinue: function() {
    var map, tags, fun, i, tag, proto, record, interceptorClass;
    $.dispatchRecordsForInstanceTags = Object.create(null);
    $.interceptorsForUncacheableTags = Object.create(null);
    H.initHooks();
    map = init.interceptorsByTag;
    tags = Object.getOwnPropertyNames(map);
    if (typeof window != "undefined") {
      window;
      fun = function() {
      };
      for (i = 0; i < tags.length; ++i) {
        tag = tags[i];
        proto = $.prototypeForTagFunction.call$1(tag);
        if (proto != null) {
          record = H.makeDefaultDispatchRecord(tag, map[tag], proto);
          if (record != null) {
            Object.defineProperty(proto, init.dispatchPropertyName, {value: record, enumerable: false, writable: true, configurable: true});
            fun.prototype = proto;
          }
        }
      }
    }
    for (i = 0; i < tags.length; ++i) {
      tag = tags[i];
      if (/^[A-Za-z_]/.test(tag)) {
        interceptorClass = map[tag];
        map["!" + tag] = interceptorClass;
        map["~" + tag] = interceptorClass;
        map["-" + tag] = interceptorClass;
        map["+" + tag] = interceptorClass;
        map["*" + tag] = interceptorClass;
      }
    }
  },
  initHooks: function() {
    var hooks, transformers, i, transformer, getTag, getUnknownTag, prototypeForTag;
    hooks = C.JS_CONST_oRe();
    hooks = H.applyHooksTransformer(C.JS_CONST_0, H.applyHooksTransformer(C.JS_CONST_rr7, H.applyHooksTransformer(C.JS_CONST_Fs4, H.applyHooksTransformer(C.JS_CONST_Fs4, H.applyHooksTransformer(C.JS_CONST_gkc, H.applyHooksTransformer(C.JS_CONST_4hp, H.applyHooksTransformer(C.JS_CONST_QJm(C.JS_CONST_8ZY), hooks)))))));
    if (typeof dartNativeDispatchHooksTransformer != "undefined") {
      transformers = dartNativeDispatchHooksTransformer;
      if (typeof transformers == "function")
        transformers = [transformers];
      if (transformers.constructor == Array)
        for (i = 0; i < transformers.length; ++i) {
          transformer = transformers[i];
          if (typeof transformer == "function")
            hooks = transformer(hooks) || hooks;
        }
    }
    getTag = hooks.getTag;
    getUnknownTag = hooks.getUnknownTag;
    prototypeForTag = hooks.prototypeForTag;
    $.getTagFunction = new H.initHooks_closure(getTag);
    $.alternateTagFunction = new H.initHooks_closure0(getUnknownTag);
    $.prototypeForTagFunction = new H.initHooks_closure1(prototypeForTag);
  },
  applyHooksTransformer: function(transformer, hooks) {
    return transformer(hooks) || hooks;
  },
  allMatchesInStringUnchecked: function(needle, haystack, startIndex) {
    var result, $length, patternLength, position, endIndex;
    result = H.setRuntimeTypeInfo([], [P.Match]);
    $length = haystack.length;
    patternLength = needle.length;
    for (; true;) {
      position = C.JSString_methods.indexOf$2(haystack, needle, startIndex);
      if (position === -1)
        break;
      result.push(new H.StringMatch(position, haystack, needle));
      endIndex = position + patternLength;
      if (endIndex === $length)
        break;
      else
        startIndex = position === endIndex ? startIndex + 1 : endIndex;
    }
    return result;
  },
  stringContainsUnchecked: function(receiver, other, startIndex) {
    var t1, t2;
    if (typeof other === "string")
      return C.JSString_methods.indexOf$2(receiver, other, startIndex) !== -1;
    else {
      t1 = J.getInterceptor(other);
      if (!!t1.$isJSSyntaxRegExp) {
        t1 = C.JSString_methods.substring$1(receiver, startIndex);
        t2 = other._nativeRegExp;
        return t2.test(t1);
      } else
        return J.get$isNotEmpty$asx(t1.allMatches$1(other, C.JSString_methods.substring$1(receiver, startIndex)));
    }
  },
  stringReplaceAllUnchecked: function(receiver, from, to) {
    var result, $length, i, t1, nativeRegexp;
    if (typeof from === "string")
      if (from === "")
        if (receiver === "")
          return to;
        else {
          result = P.StringBuffer$("");
          $length = receiver.length;
          result.write$1(to);
          for (i = 0; i < $length; ++i) {
            t1 = receiver[i];
            t1 = result._contents += t1;
            result._contents = t1 + to;
          }
          return result._contents;
        }
      else
        return receiver.replace(new RegExp(from.replace(new RegExp("[[\\]{}()*+?.\\\\^$|]", 'g'), "\\$&"), 'g'), to.replace(/\$/g, "$$$$"));
    else if (!!J.getInterceptor(from).$isJSSyntaxRegExp) {
      nativeRegexp = from.get$_nativeGlobalVersion();
      nativeRegexp.lastIndex = 0;
      return receiver.replace(nativeRegexp, to.replace(/\$/g, "$$$$"));
    } else {
      if (from == null)
        H.throwExpression(P.ArgumentError$(null));
      throw H.wrapException("String.replaceAll(Pattern) UNIMPLEMENTED");
    }
  },
  _matchString: [function(match) {
    return match.$index(0, 0);
  }, "call$1", "_matchString$closure", 2, 0, 2],
  _stringIdentity: [function(string) {
    return string;
  }, "call$1", "_stringIdentity$closure", 2, 0, 3],
  stringReplaceAllFuncUnchecked: function(receiver, pattern, onMatch, onNonMatch) {
    var t1, buffer, startIndex, match, t2, str, t3;
    t1 = J.getInterceptor(pattern);
    if (!t1.$isPattern)
      throw H.wrapException(P.ArgumentError$(t1.toString$0(pattern) + " is not a Pattern"));
    onNonMatch = H._stringIdentity$closure();
    buffer = P.StringBuffer$("");
    for (t1 = t1.allMatches$1(pattern, receiver), t1 = new H._AllMatchesIterator(t1._re, t1._string, t1.__js_helper$_start, null), startIndex = 0; t1.moveNext$0();) {
      match = t1.__js_helper$_current;
      t2 = match._match;
      str = onNonMatch.call$1(C.JSString_methods.substring$2(receiver, startIndex, t2.index));
      buffer._contents += typeof str === "string" ? str : H.S(str);
      str = onMatch.call$1(match);
      buffer._contents += typeof str === "string" ? str : H.S(str);
      t3 = t2.index;
      if (0 >= t2.length)
        return H.ioore(t2, 0);
      t2 = J.get$length$asx(t2[0]);
      if (typeof t2 !== "number")
        return H.iae(t2);
      startIndex = t3 + t2;
    }
    buffer.write$1(onNonMatch.call$1(C.JSString_methods.substring$1(receiver, startIndex)));
    return buffer._contents;
  },
  ConstantMap: {
    "^": "Object;",
    get$isEmpty: function(_) {
      return this.get$length(this) === 0;
    },
    toString$0: function(_) {
      return P.Maps_mapToString(this);
    },
    _throwUnmodifiable$0: function() {
      throw H.wrapException(P.UnsupportedError$("Cannot modify unmodifiable Map"));
    },
    $indexSet: function(_, key, val) {
      return this._throwUnmodifiable$0();
    },
    putIfAbsent$2: function(key, ifAbsent) {
      return this._throwUnmodifiable$0();
    },
    remove$1: function(_, key) {
      return this._throwUnmodifiable$0();
    },
    clear$0: function(_) {
      return this._throwUnmodifiable$0();
    },
    addAll$1: function(_, other) {
      return this._throwUnmodifiable$0();
    },
    $isMap: true
  },
  ConstantStringMap: {
    "^": "ConstantMap;length>,_jsObject,__js_helper$_keys",
    containsValue$1: function(needle) {
      return this.get$values(this).any$1(0, new H.ConstantStringMap_containsValue_closure(this, needle));
    },
    containsKey$1: function(key) {
      if (typeof key !== "string")
        return false;
      if ("__proto__" === key)
        return false;
      return this._jsObject.hasOwnProperty(key);
    },
    $index: function(_, key) {
      if (!this.containsKey$1(key))
        return;
      return this._fetch$1(key);
    },
    _fetch$1: function(key) {
      return this._jsObject[key];
    },
    forEach$1: function(_, f) {
      var keys, i, key;
      keys = this.__js_helper$_keys;
      for (i = 0; i < keys.length; ++i) {
        key = keys[i];
        f.call$2(key, this._fetch$1(key));
      }
    },
    get$keys: function() {
      return H.setRuntimeTypeInfo(new H._ConstantMapKeyIterable(this), [H.getTypeArgumentByIndex(this, 0)]);
    },
    get$values: function(_) {
      return H.MappedIterable_MappedIterable(this.__js_helper$_keys, new H.ConstantStringMap_values_closure(this), H.getTypeArgumentByIndex(this, 0), H.getTypeArgumentByIndex(this, 1));
    },
    $isEfficientLength: true
  },
  ConstantStringMap_containsValue_closure: {
    "^": "Closure;this_0,needle_1",
    call$1: function(value) {
      return J.$eq(value, this.needle_1);
    },
    $isFunction: true,
    $signature: function() {
      return H.computeSignature(function(K, V) {
        return {func: "dynamic__V", args: [V]};
      }, this.this_0, "ConstantStringMap");
    }
  },
  ConstantStringMap_values_closure: {
    "^": "Closure:13;this_0",
    call$1: function(key) {
      return this.this_0._fetch$1(key);
    },
    $isFunction: true
  },
  _ConstantMapKeyIterable: {
    "^": "IterableBase;__js_helper$_map",
    get$iterator: function(_) {
      return J.get$iterator$ax(this.__js_helper$_map.__js_helper$_keys);
    }
  },
  ReflectionInfo: {
    "^": "Object;jsFunction,data,isAccessor,requiredParameterCount,optionalParameterCount,areOptionalParametersNamed,functionType<,cachedSortedIndices",
    defaultValue$1: [function(_, parameter) {
      var t1 = this.requiredParameterCount;
      parameter.$lt(0, t1);
      return this.data[3 + parameter - t1];
    }, "call$1", "get$defaultValue", 2, 0, 24],
    static: {"^": "ReflectionInfo_REQUIRED_PARAMETERS_INFO,ReflectionInfo_OPTIONAL_PARAMETERS_INFO,ReflectionInfo_FUNCTION_TYPE_INDEX,ReflectionInfo_FIRST_DEFAULT_ARGUMENT", ReflectionInfo_ReflectionInfo: function(jsFunction) {
        var data, requiredParametersInfo, optionalParametersInfo;
        data = jsFunction.$reflectionInfo;
        if (data == null)
          return;
        data.fixed$length = init;
        data = data;
        requiredParametersInfo = data[0];
        optionalParametersInfo = data[1];
        return new H.ReflectionInfo(jsFunction, data, (requiredParametersInfo & 1) === 1, requiredParametersInfo >> 1, optionalParametersInfo >> 1, (optionalParametersInfo & 1) === 1, data[2], null);
      }}
  },
  Primitives_initTicker_closure: {
    "^": "Closure:23;performance_0",
    call$0: function() {
      return C.JSNumber_methods.toInt$0(Math.floor(1000 * this.performance_0.now()));
    },
    $isFunction: true
  },
  TypeErrorDecoder: {
    "^": "Object;_pattern,_arguments,_argumentsExpr,_expr,_method,_receiver",
    matchTypeError$1: function(message) {
      var match, result, t1;
      match = new RegExp(this._pattern).exec(message);
      if (match == null)
        return;
      result = {};
      t1 = this._arguments;
      if (t1 !== -1)
        result.arguments = match[t1 + 1];
      t1 = this._argumentsExpr;
      if (t1 !== -1)
        result.argumentsExpr = match[t1 + 1];
      t1 = this._expr;
      if (t1 !== -1)
        result.expr = match[t1 + 1];
      t1 = this._method;
      if (t1 !== -1)
        result.method = match[t1 + 1];
      t1 = this._receiver;
      if (t1 !== -1)
        result.receiver = match[t1 + 1];
      return result;
    },
    static: {"^": "TypeErrorDecoder_noSuchMethodPattern,TypeErrorDecoder_notClosurePattern,TypeErrorDecoder_nullCallPattern,TypeErrorDecoder_nullLiteralCallPattern,TypeErrorDecoder_undefinedCallPattern,TypeErrorDecoder_undefinedLiteralCallPattern,TypeErrorDecoder_nullPropertyPattern,TypeErrorDecoder_nullLiteralPropertyPattern,TypeErrorDecoder_undefinedPropertyPattern,TypeErrorDecoder_undefinedLiteralPropertyPattern", TypeErrorDecoder_extractPattern: function(message) {
        var match, $arguments, argumentsExpr, expr, method, receiver;
        message = message.replace(String({}), '$receiver$').replace(new RegExp("[[\\]{}()*+?.\\\\^$|]", 'g'), '\\$&');
        match = message.match(/\\\$[a-zA-Z]+\\\$/g);
        if (match == null)
          match = [];
        $arguments = match.indexOf("\\$arguments\\$");
        argumentsExpr = match.indexOf("\\$argumentsExpr\\$");
        expr = match.indexOf("\\$expr\\$");
        method = match.indexOf("\\$method\\$");
        receiver = match.indexOf("\\$receiver\\$");
        return new H.TypeErrorDecoder(message.replace('\\$arguments\\$', '((?:x|[^x])*)').replace('\\$argumentsExpr\\$', '((?:x|[^x])*)').replace('\\$expr\\$', '((?:x|[^x])*)').replace('\\$method\\$', '((?:x|[^x])*)').replace('\\$receiver\\$', '((?:x|[^x])*)'), $arguments, argumentsExpr, expr, method, receiver);
      }, TypeErrorDecoder_provokeCallErrorOn: function(expression) {
        return function($expr$) {
          var $argumentsExpr$ = '$arguments$';
          try {
            $expr$.$method$($argumentsExpr$);
          } catch (e) {
            return e.message;
          }

        }(expression);
      }, TypeErrorDecoder_provokePropertyErrorOn: function(expression) {
        return function($expr$) {
          try {
            $expr$.$method$;
          } catch (e) {
            return e.message;
          }

        }(expression);
      }}
  },
  NullError: {
    "^": "Error;_message,_method",
    toString$0: function(_) {
      var t1 = this._method;
      if (t1 == null)
        return "NullError: " + H.S(this._message);
      return "NullError: Cannot call \"" + H.S(t1) + "\" on null";
    },
    $isError: true
  },
  JsNoSuchMethodError: {
    "^": "Error;_message,_method,_receiver",
    toString$0: function(_) {
      var t1, t2;
      t1 = this._method;
      if (t1 == null)
        return "NoSuchMethodError: " + H.S(this._message);
      t2 = this._receiver;
      if (t2 == null)
        return "NoSuchMethodError: Cannot call \"" + H.S(t1) + "\" (" + H.S(this._message) + ")";
      return "NoSuchMethodError: Cannot call \"" + H.S(t1) + "\" on \"" + H.S(t2) + "\" (" + H.S(this._message) + ")";
    },
    $isError: true,
    static: {JsNoSuchMethodError$: function(_message, match) {
        var t1, t2;
        t1 = match == null;
        t2 = t1 ? null : match.method;
        t1 = t1 ? null : match.receiver;
        return new H.JsNoSuchMethodError(_message, t2, t1);
      }}
  },
  UnknownJsTypeError: {
    "^": "Error;_message",
    toString$0: function(_) {
      var t1 = this._message;
      return C.JSString_methods.get$isEmpty(t1) ? "Error" : "Error: " + t1;
    }
  },
  unwrapException_saveStackTrace: {
    "^": "Closure:13;ex_0",
    call$1: function(error) {
      if (!!J.getInterceptor(error).$isError)
        if (error.$thrownJsError == null)
          error.$thrownJsError = this.ex_0;
      return error;
    },
    $isFunction: true
  },
  _StackTrace: {
    "^": "Object;_exception,_trace",
    toString$0: function(_) {
      var t1, trace;
      t1 = this._trace;
      if (t1 != null)
        return t1;
      t1 = this._exception;
      trace = typeof t1 === "object" ? t1.stack : null;
      t1 = trace == null ? "" : trace;
      this._trace = t1;
      return t1;
    }
  },
  invokeClosure_closure: {
    "^": "Closure:23;closure_0",
    call$0: function() {
      return this.closure_0.call$0();
    },
    $isFunction: true
  },
  invokeClosure_closure0: {
    "^": "Closure:23;closure_1,arg1_2",
    call$0: function() {
      return this.closure_1.call$1(this.arg1_2);
    },
    $isFunction: true
  },
  invokeClosure_closure1: {
    "^": "Closure:23;closure_3,arg1_4,arg2_5",
    call$0: function() {
      return this.closure_3.call$2(this.arg1_4, this.arg2_5);
    },
    $isFunction: true
  },
  invokeClosure_closure2: {
    "^": "Closure:23;closure_6,arg1_7,arg2_8,arg3_9",
    call$0: function() {
      return this.closure_6.call$3(this.arg1_7, this.arg2_8, this.arg3_9);
    },
    $isFunction: true
  },
  invokeClosure_closure3: {
    "^": "Closure:23;closure_10,arg1_11,arg2_12,arg3_13,arg4_14",
    call$0: function() {
      return this.closure_10.call$4(this.arg1_11, this.arg2_12, this.arg3_13, this.arg4_14);
    },
    $isFunction: true
  },
  Closure: {
    "^": "Object;",
    toString$0: function(_) {
      return "Closure";
    },
    $isFunction: true,
    get$$call: function() {
      return this;
    }
  },
  TearOffClosure: {
    "^": "Closure;"
  },
  BoundClosure: {
    "^": "TearOffClosure;_self,_target,_receiver,__js_helper$_name",
    $eq: function(_, other) {
      if (other == null)
        return false;
      if (this === other)
        return true;
      if (!J.getInterceptor(other).$isBoundClosure)
        return false;
      return this._self === other._self && this._target === other._target && this._receiver === other._receiver;
    },
    get$hashCode: function(_) {
      var t1, receiverHashCode;
      t1 = this._receiver;
      if (t1 == null)
        receiverHashCode = H.Primitives_objectHashCode(this._self);
      else
        receiverHashCode = typeof t1 !== "object" ? J.get$hashCode$(t1) : H.Primitives_objectHashCode(t1);
      t1 = H.Primitives_objectHashCode(this._target);
      if (typeof receiverHashCode !== "number")
        return receiverHashCode.$xor();
      return (receiverHashCode ^ t1) >>> 0;
    },
    $isBoundClosure: true,
    static: {"^": "BoundClosure_selfFieldNameCache,BoundClosure_receiverFieldNameCache", BoundClosure_selfOf: function(closure) {
        return closure._self;
      }, BoundClosure_receiverOf: function(closure) {
        return closure._receiver;
      }, BoundClosure_selfFieldName: function() {
        var t1 = $.BoundClosure_selfFieldNameCache;
        if (t1 == null) {
          t1 = H.BoundClosure_computeFieldNamed("self");
          $.BoundClosure_selfFieldNameCache = t1;
        }
        return t1;
      }, BoundClosure_computeFieldNamed: function(fieldName) {
        var template, t1, names, i, $name;
        template = new H.BoundClosure("self", "target", "receiver", "name");
        t1 = Object.getOwnPropertyNames(template);
        t1.fixed$length = init;
        names = t1;
        for (t1 = names.length, i = 0; i < t1; ++i) {
          $name = names[i];
          if (template[$name] === fieldName)
            return $name;
        }
      }}
  },
  CastErrorImplementation: {
    "^": "Error;message",
    toString$0: function(_) {
      return this.message;
    },
    $isError: true,
    static: {CastErrorImplementation$: function(actualType, expectedType) {
        return new H.CastErrorImplementation("CastError: Casting value of type " + H.S(actualType) + " to incompatible type " + H.S(expectedType));
      }}
  },
  RuntimeError: {
    "^": "Error;message",
    toString$0: function(_) {
      return "RuntimeError: " + H.S(this.message);
    },
    static: {RuntimeError$: function(message) {
        return new H.RuntimeError(message);
      }}
  },
  RuntimeType: {
    "^": "Object;"
  },
  RuntimeFunctionType: {
    "^": "RuntimeType;returnType<,parameterTypes<,optionalParameterTypes<,namedParameters<",
    get$isVoid: function() {
      return !!J.getInterceptor(this.returnType).$isVoidRuntimeType;
    },
    _isTest$1: function(expression) {
      var functionTypeObject = this._extractFunctionTypeObjectFrom$1(expression);
      return functionTypeObject == null ? false : H.isFunctionSubtype(functionTypeObject, this.toRti$0());
    },
    _extractFunctionTypeObjectFrom$1: function(o) {
      var interceptor = J.getInterceptor(o);
      return "$signature" in interceptor ? interceptor.$signature() : null;
    },
    toRti$0: function() {
      var result, t1, t2, namedRti, keys, i, $name;
      result = {func: "dynafunc"};
      t1 = this.returnType;
      t2 = J.getInterceptor(t1);
      if (!!t2.$isVoidRuntimeType)
        result.void = true;
      else if (!t2.$isDynamicRuntimeType)
        result.ret = t1.toRti$0();
      t1 = this.parameterTypes;
      if (t1 != null && t1.length !== 0)
        result.args = H.RuntimeFunctionType_listToRti(t1);
      t1 = this.optionalParameterTypes;
      if (t1 != null && t1.length !== 0)
        result.opt = H.RuntimeFunctionType_listToRti(t1);
      t1 = this.namedParameters;
      if (t1 != null) {
        namedRti = {};
        keys = H.extractKeys(t1);
        for (t2 = keys.length, i = 0; i < t2; ++i) {
          $name = keys[i];
          namedRti[$name] = t1[$name].toRti$0();
        }
        result.named = namedRti;
      }
      return result;
    },
    toString$0: function(_) {
      var t1, t2, result, needsComma, i, type, keys, $name;
      t1 = this.parameterTypes;
      if (t1 != null)
        for (t2 = t1.length, result = "(", needsComma = false, i = 0; i < t2; ++i, needsComma = true) {
          type = t1[i];
          if (needsComma)
            result += ", ";
          result += H.S(type);
        }
      else {
        result = "(";
        needsComma = false;
      }
      t1 = this.optionalParameterTypes;
      if (t1 != null && t1.length !== 0) {
        result = (needsComma ? result + ", " : result) + "[";
        for (t2 = t1.length, needsComma = false, i = 0; i < t2; ++i, needsComma = true) {
          type = t1[i];
          if (needsComma)
            result += ", ";
          result += H.S(type);
        }
        result += "]";
      } else {
        t1 = this.namedParameters;
        if (t1 != null) {
          result = (needsComma ? result + ", " : result) + "{";
          keys = H.extractKeys(t1);
          for (t2 = keys.length, needsComma = false, i = 0; i < t2; ++i, needsComma = true) {
            $name = keys[i];
            if (needsComma)
              result += ", ";
            result += H.S(t1[$name].toRti$0()) + " " + $name;
          }
          result += "}";
        }
      }
      return result + (") -> " + J.toString$0(this.returnType));
    },
    static: {"^": "RuntimeFunctionType_inAssert", RuntimeFunctionType_listToRti: function(list) {
        var result, t1, i;
        list = list;
        result = [];
        for (t1 = list.length, i = 0; i < t1; ++i)
          result.push(list[i].toRti$0());
        return result;
      }}
  },
  DynamicRuntimeType: {
    "^": "RuntimeType;",
    toString$0: function(_) {
      return "dynamic";
    },
    toRti$0: function() {
      return;
    },
    $isDynamicRuntimeType: true
  },
  TypeImpl: {
    "^": "Object;_typeName,_unmangledName",
    toString$0: function(_) {
      var t1, unmangledName;
      t1 = this._unmangledName;
      if (t1 != null)
        return t1;
      unmangledName = this._typeName.replace(/[^<,> ]+/g, function(m) {
        return init.mangledGlobalNames[m] || m;
      });
      this._unmangledName = unmangledName;
      return unmangledName;
    },
    get$hashCode: function(_) {
      return J.get$hashCode$(this._typeName);
    },
    $eq: function(_, other) {
      var t1, t2;
      if (other == null)
        return false;
      if (!!J.getInterceptor(other).$isTypeImpl) {
        t1 = this._typeName;
        t2 = other._typeName;
        t2 = t1 == null ? t2 == null : t1 === t2;
        t1 = t2;
      } else
        t1 = false;
      return t1;
    },
    $isTypeImpl: true
  },
  initHooks_closure: {
    "^": "Closure:13;getTag_0",
    call$1: function(o) {
      return this.getTag_0(o);
    },
    $isFunction: true
  },
  initHooks_closure0: {
    "^": "Closure:25;getUnknownTag_1",
    call$2: function(o, tag) {
      return this.getUnknownTag_1(o, tag);
    },
    $isFunction: true
  },
  initHooks_closure1: {
    "^": "Closure:0;prototypeForTag_2",
    call$1: function(tag) {
      return this.prototypeForTag_2(tag);
    },
    $isFunction: true
  },
  JSSyntaxRegExp: {
    "^": "Object;pattern,_nativeRegExp,_nativeGlobalRegExp,_nativeAnchoredRegExp",
    get$_nativeGlobalVersion: function() {
      var t1 = this._nativeGlobalRegExp;
      if (t1 != null)
        return t1;
      t1 = this._nativeRegExp;
      t1 = H.JSSyntaxRegExp_makeNative(this.pattern, t1.multiline, !t1.ignoreCase, true);
      this._nativeGlobalRegExp = t1;
      return t1;
    },
    allMatches$2: function(_, string, start) {
      if (start > string.length)
        throw H.wrapException(P.RangeError$range(start, 0, string.length));
      return new H._AllMatchesIterable(this, string, start);
    },
    allMatches$1: function($receiver, string) {
      return this.allMatches$2($receiver, string, 0);
    },
    _execGlobal$2: function(string, start) {
      var regexp, match;
      regexp = this.get$_nativeGlobalVersion();
      regexp.lastIndex = start;
      match = regexp.exec(string);
      if (match == null)
        return;
      return H._MatchImplementation$(this, match);
    },
    $isJSSyntaxRegExp: true,
    $isPattern: true,
    static: {JSSyntaxRegExp_makeNative: function(source, multiLine, caseSensitive, global) {
        var m, i, g, regexp, errorMessage;
        if (typeof source !== "string")
          H.throwExpression(P.ArgumentError$(source));
        m = multiLine ? "m" : "";
        i = caseSensitive ? "" : "i";
        g = global ? "g" : "";
        regexp = function() {
          try {
            return new RegExp(source, m + i + g);
          } catch (e) {
            return e;
          }

        }();
        if (regexp instanceof RegExp)
          return regexp;
        errorMessage = String(regexp);
        throw H.wrapException(P.FormatException$("Illegal RegExp pattern: " + H.S(source) + ", " + errorMessage, null, null));
      }}
  },
  _MatchImplementation: {
    "^": "Object;pattern,_match",
    get$start: function(_) {
      return this._match.index;
    },
    get$end: function() {
      var t1, t2;
      t1 = this._match;
      t2 = t1.index;
      if (0 >= t1.length)
        return H.ioore(t1, 0);
      t1 = J.get$length$asx(t1[0]);
      if (typeof t1 !== "number")
        return H.iae(t1);
      return t2 + t1;
    },
    group$1: function(index) {
      var t1 = this._match;
      if (index >>> 0 !== index || index >= t1.length)
        return H.ioore(t1, index);
      return t1[index];
    },
    $index: function(_, index) {
      var t1 = this._match;
      if (index >>> 0 !== index || index >= t1.length)
        return H.ioore(t1, index);
      return t1[index];
    },
    _MatchImplementation$2: function(pattern, _match) {
    },
    static: {_MatchImplementation$: function(pattern, _match) {
        var t1 = new H._MatchImplementation(pattern, _match);
        t1._MatchImplementation$2(pattern, _match);
        return t1;
      }}
  },
  _AllMatchesIterable: {
    "^": "IterableBase;_re,_string,__js_helper$_start",
    get$iterator: function(_) {
      return new H._AllMatchesIterator(this._re, this._string, this.__js_helper$_start, null);
    },
    $asIterableBase: function() {
      return [P.Match];
    },
    $asIterable: function() {
      return [P.Match];
    }
  },
  _AllMatchesIterator: {
    "^": "Object;_regExp,_string,_nextIndex,__js_helper$_current",
    get$current: function() {
      return this.__js_helper$_current;
    },
    moveNext$0: function() {
      var t1, t2, match, t3, nextIndex;
      t1 = this._string;
      if (t1 == null)
        return false;
      t2 = this._nextIndex;
      if (t2 <= t1.length) {
        match = this._regExp._execGlobal$2(t1, t2);
        if (match != null) {
          this.__js_helper$_current = match;
          t1 = match._match;
          t2 = t1.index;
          if (0 >= t1.length)
            return H.ioore(t1, 0);
          t3 = J.get$length$asx(t1[0]);
          if (typeof t3 !== "number")
            return H.iae(t3);
          nextIndex = t2 + t3;
          this._nextIndex = t1.index === nextIndex ? nextIndex + 1 : nextIndex;
          return true;
        }
      }
      this.__js_helper$_current = null;
      this._string = null;
      return false;
    }
  },
  StringMatch: {
    "^": "Object;start>,input,pattern",
    get$end: function() {
      return this.start + this.pattern.length;
    },
    $index: function(_, g) {
      if (!J.$eq(g, 0))
        H.throwExpression(P.RangeError$value(g));
      return this.pattern;
    },
    group$1: function(group_) {
      if (group_ !== 0)
        throw H.wrapException(P.RangeError$value(group_));
      return this.pattern;
    }
  }
}],
["backend_ast_emitter", "package:compiler/implementation/dart_backend/backend_ast_emitter.dart", , Y, {
  "^": "",
  ASTEmitter: {
    "^": "Visitor0;variables,variableNames,constantNames,declaredVariables,usedVariableNames,statementBuffer,functionElement,variableList,fallthrough,usedLabels,firstStatement,parent*",
    emit$1: function(definition) {
      var parameters, t1, t2, t3, param, t4, t5, variable, constants, constDecl, decl, bodyParts, functionType;
      this.functionElement = definition.element;
      parameters = this.emitRootParameters$1(definition);
      for (t1 = definition.parameters, t1 = H.setRuntimeTypeInfo(new H.ListIterator(t1, t1.length, 0, null), [H.getTypeArgumentByIndex(t1, 0)]), t2 = this.usedVariableNames, t3 = this.declaredVariables; t1.moveNext$0();) {
        param = t1.__internal$_current;
        t4 = this.variableNames;
        t5 = param.get$element();
        t4.$indexSet(0, param, t5.get$name(t5));
        t5 = param.get$element();
        t2.add$1(0, t5.get$name(t5));
        t3.add$1(0, param);
      }
      t1 = definition.body;
      this.firstStatement = t1;
      t1.accept$1(0, this);
      this.removeTrailingReturn$0();
      for (t1 = this.variableNames.get$keys(), t1 = t1.get$iterator(t1); t1.moveNext$0();) {
        variable = t1.get$current();
        if (!t3.contains$1(0, variable))
          this.addDeclaration$1(variable);
      }
      constants = H.setRuntimeTypeInfo([], [F.VariableDeclaration0]);
      for (t1 = definition.localConstants, t1 = H.setRuntimeTypeInfo(new H.ListIterator(t1, t1.length, 0, null), [H.getTypeArgumentByIndex(t1, 0)]), t2 = this.constantNames; t1.moveNext$0();) {
        constDecl = t1.__internal$_current;
        if (!t2.containsKey$1(constDecl.get$element()))
          continue;
        decl = new F.VariableDeclaration0(this.getConstantName$1(constDecl.get$element()), J.accept$1$x(constDecl.get$expression(), new Y.ConstantEmitter0(this)), null);
        decl.element = constDecl.get$element();
        constants.push(decl);
      }
      bodyParts = [];
      if (constants.length > 0)
        bodyParts.push(new F.VariableDeclarations(null, false, true, constants));
      t1 = this.variables;
      if (t1.length > 0)
        bodyParts.push(new F.VariableDeclarations(null, false, false, t1));
      C.JSArray_methods.addAll$1(bodyParts, this.statementBuffer);
      t1 = this.functionElement;
      functionType = t1.get$type(t1);
      t1 = this.functionElement.name;
      t1 = new F.FunctionExpression0(this.emitOptionalType$1(functionType.returnType), t1, parameters, new F.Block1(bodyParts), null);
      t1.element = this.functionElement;
      return t1;
    },
    addDeclaration$2: function(variable, initializer) {
      var decl = new F.VariableDeclaration0(this.getVariableName$1(variable), initializer, null);
      decl.element = variable.element;
      this.declaredVariables.add$1(0, variable);
      this.variables.push(decl);
    },
    addDeclaration$1: function(variable) {
      return this.addDeclaration$2(variable, null);
    },
    removeTrailingReturn$0: function() {
      var t1, expr;
      t1 = this.statementBuffer;
      if (t1.length === 0)
        return;
      if (!J.getInterceptor(C.JSArray_methods.get$last(t1)).$isReturn1)
        return;
      expr = C.JSArray_methods.get$last(this.statementBuffer).get$expression();
      if (!!J.getInterceptor(expr).$isLiteral0 && !!J.getInterceptor(expr.value).$isNullConstant) {
        t1 = this.statementBuffer;
        if (0 >= t1.length)
          return H.ioore(t1, 0);
        t1.pop();
      }
    },
    emitParameterFromElement$2: [function(element, $name) {
      var signature, t1;
      $name = J.get$name$x(element);
      if (element.get$functionSignature() != null) {
        signature = element.get$functionSignatureCache();
        t1 = new F.Parameter0($name, this.emitOptionalType$1(signature.type.returnType), null, new F.Parameters(signature.requiredParameters.mapToList$1(this.get$emitParameterFromElement()), signature.optionalParameters.mapToList$1(this.get$emitParameterFromElement()), signature.optionalParametersAreNamed), null);
        t1.element = element;
        return t1;
      } else {
        t1 = new F.Parameter0($name, this.emitOptionalType$1(element.get$typeCache()), null, null, null);
        t1.element = element;
        return t1;
      }
    }, function(element) {
      return this.emitParameterFromElement$2(element, null);
    }, "emitParameterFromElement$1", "call$2", "call$1", "get$emitParameterFromElement", 2, 2, 26, 10],
    emitRootParameters$1: function($function) {
      var signature, defaults, required, optional, t1, t2, i, t3, constant;
      signature = $function.element.get$functionSignature();
      defaults = $function.defaultParameterValues;
      required = signature.get$requiredParameters().mapToList$1(this.get$emitParameterFromElement());
      optional = H.setRuntimeTypeInfo(Array(defaults.length), [F.Parameter0]);
      for (t1 = signature.orderedOptionalParameters, t2 = optional.length, i = 0; i < defaults.length; ++i) {
        if (i >= t1.length)
          return H.ioore(t1, i);
        t3 = this.emitParameterFromElement$1(t1[i]);
        if (i >= t2)
          return H.ioore(optional, i);
        optional[i] = t3;
        if (i >= defaults.length)
          return H.ioore(defaults, i);
        constant = defaults[i].accept$1(0, new Y.ConstantEmitter0(this));
        if (!(!!constant.$isLiteral0 && constant.value.get$isNull()))
          optional[i].defaultValue = constant;
      }
      return new F.Parameters(required, optional, signature.optionalParametersAreNamed);
    },
    isSameVariable$2: function(e1, e2) {
      var t1, t2;
      if (!!J.getInterceptor(e1).$isIdentifier0)
        if (!!J.getInterceptor(e2).$isIdentifier0) {
          t1 = e1.element;
          if (!!J.getInterceptor(t1).$isVariableElement) {
            t2 = e2.element;
            t2 = t1 == null ? t2 == null : t1 === t2;
            t1 = t2;
          } else
            t1 = false;
        } else
          t1 = false;
      else
        t1 = false;
      return t1;
    },
    makeAssignment$2: function(target, value) {
      var t1, leftOperand, rightOperand, valid, t2, t3;
      t1 = J.getInterceptor(value);
      if (!!t1.$isBinaryOperator && F.isCompoundableOperator(value.operator)) {
        leftOperand = t1.get$left(value);
        rightOperand = t1.get$right(value);
        if (this.isSameVariable$2(target, leftOperand))
          valid = true;
        else {
          if (!!target.$isFieldExpression)
            if (!!J.getInterceptor(leftOperand).$isFieldExpression)
              if (this.isSameVariable$2(target.object, leftOperand.object)) {
                t2 = target.fieldName;
                t3 = leftOperand.fieldName;
                t3 = t2 == null ? t3 == null : t2 === t3;
                t2 = t3;
              } else
                t2 = false;
            else
              t2 = false;
          else
            t2 = false;
          if (t2)
            valid = true;
          else
            valid = !!target.$isIndexExpression && !!J.getInterceptor(leftOperand).$isIndexExpression && this.isSameVariable$2(target.object, leftOperand.object) && this.isSameVariable$2(target.index, leftOperand.index) && true;
        }
        if (valid) {
          if (!!J.getInterceptor(rightOperand).$isLiteral0)
            if (rightOperand.value.get$isOne())
              t2 = t1.get$operator(value) === "+" || t1.get$operator(value) === "-";
            else
              t2 = false;
          else
            t2 = false;
          if (t2) {
            t2 = t1.get$operator(value);
            t1 = t1.get$operator(value);
            if (typeof t2 !== "string")
              return t2.$add();
            t1 = C.JSString_methods.$add(t2, t1);
            t2 = new F.Increment(target, t1, true);
            t2.Increment$3(target, t1, true);
            return t2;
          } else {
            t1 = t1.get$operator(value);
            if (typeof t1 !== "string")
              return t1.$add();
            return new F.Assignment0(target, t1 + "=", rightOperand);
          }
        }
      }
      return new F.Assignment0(target, "=", value);
    },
    visitExpressionStatement$1: function(stmt) {
      var e = stmt.expression.accept$1(0, this);
      this.statementBuffer.push(new F.ExpressionStatement1(e));
      stmt.next.accept$1(0, this);
    },
    visitLabeledStatement$1: function(stmt) {
      var savedBuffer, savedFallthrough, t1;
      savedBuffer = this.statementBuffer;
      savedFallthrough = this.fallthrough;
      this.statementBuffer = H.setRuntimeTypeInfo([], [F.Statement1]);
      this.fallthrough = stmt.next;
      stmt.body.accept$1(0, this);
      t1 = stmt.label;
      if (this.usedLabels.remove$1(0, t1))
        savedBuffer.push(new F.LabeledStatement0(t1.get$name(t1), new F.Block1(this.statementBuffer)));
      else
        savedBuffer.push(new F.Block1(this.statementBuffer));
      this.fallthrough = savedFallthrough;
      this.statementBuffer = savedBuffer;
      stmt.next.accept$1(0, this);
    },
    getVariableName$1: function(variable) {
      var $name, t1, prefix, counter, t2;
      if (variable.host.element !== this.functionElement)
        return this.parent.getVariableName$1(variable);
      $name = this.variableNames.$index(0, variable);
      if ($name != null)
        return $name;
      t1 = variable.element;
      prefix = t1 == null ? "v" : t1.get$name(t1);
      t1 = variable.element;
      $name = t1 == null ? H.S(prefix) + "0" : t1.get$name(t1);
      for (t1 = this.usedVariableNames, counter = 0; !t1.add$1(0, $name);) {
        ++counter;
        $name = H.S(prefix) + counter;
      }
      this.variableNames.$indexSet(0, variable, $name);
      t1 = variable.element;
      if (t1 != null) {
        t1 = t1.get$name(t1);
        t1 = $name == null ? t1 != null : $name !== t1;
      } else
        t1 = true;
      if (t1) {
        t1 = this.functionElement;
        t2 = $.ElementX_elementHashCode + 1;
        $.ElementX_elementHashCode = t2;
        variable.element = new U.LocalVariableElementX(null, this.variableList, null, null, $name, C.ElementKind_variable_1, t1, t2, C.C_Link2, null, false);
      }
      return $name;
    },
    getConstantName$1: function(element) {
      var t1, t2, $name, prefix, counter;
      t1 = element.get$enclosingElement();
      t2 = this.functionElement;
      if (t1 == null ? t2 != null : t1 !== t2)
        return this.parent.getConstantName$1(element);
      t1 = this.constantNames;
      $name = t1.$index(0, element);
      if ($name != null)
        return $name;
      prefix = element.name;
      for (t2 = this.usedVariableNames, $name = prefix, counter = 0; !t2.add$1(0, $name);) {
        ++counter;
        $name = H.S(prefix) + counter;
      }
      t1.$indexSet(0, element, $name);
      return $name;
    },
    visitAssign$1: function(stmt) {
      var t1, $function, t2, isDeclaredHere, $name, definition, decl, t3;
      t1 = stmt.variable;
      if (!!J.getInterceptor(t1.element).$isFunctionElement && !!J.getInterceptor(stmt.definition).$isFunctionExpression1 && !this.declaredVariables.contains$1(0, t1)) {
        t1 = stmt.definition.get$definition();
        $function = new Y.ASTEmitter(H.setRuntimeTypeInfo([], [F.VariableDeclaration0]), P.LinkedHashMap_LinkedHashMap$_empty(M.Variable, P.String), P.LinkedHashMap_LinkedHashMap$_empty(O.VariableElement, P.String), P.LinkedHashSet_LinkedHashSet(null, null, null, M.Variable), this.usedVariableNames, H.setRuntimeTypeInfo([], [F.Statement1]), null, new U.VariableList(null, null, $.get$Modifiers_EMPTY(), C.C_Link2), null, P.LinkedHashSet_LinkedHashSet(null, null, null, M.Label0), null, this).emit$1(t1);
        this.statementBuffer.push(new F.FunctionDeclaration1($function));
        this.declaredVariables.add$1(0, stmt.variable);
        stmt.next.accept$1(0, this);
        return;
      }
      t1 = this.variableNames.$index(0, stmt.variable);
      t2 = stmt.variable;
      isDeclaredHere = t2.host.element === this.functionElement;
      $name = this.getVariableName$1(t2);
      definition = stmt.definition.accept$1(0, this);
      if (this.firstStatement === stmt && t1 == null && isDeclaredHere) {
        if (!!J.getInterceptor(definition).$isLiteral0 && definition.value.get$isNull())
          definition = null;
        this.addDeclaration$2(stmt.variable, definition);
        t1 = stmt.next;
        this.firstStatement = t1;
        t1.accept$1(0, this);
        return;
      }
      if (stmt.isDeclaration) {
        if (!!J.getInterceptor(definition).$isLiteral0 && definition.value.get$isNull())
          definition = null;
        decl = new F.VariableDeclaration0($name, definition, null);
        t1 = stmt.variable;
        decl.element = t1.element;
        this.declaredVariables.add$1(0, t1);
        this.statementBuffer.push(new F.VariableDeclarations(null, false, false, [decl]));
        stmt.next.accept$1(0, this);
        return;
      }
      t1 = this.statementBuffer;
      t2 = stmt.variable;
      t3 = new F.Identifier0(this.getVariableName$1(t2), null);
      t3.element = t2.element;
      t1.push(new F.ExpressionStatement1(this.makeAssignment$2(t3, definition)));
      stmt.next.accept$1(0, this);
    },
    visitReturn$1: function(stmt) {
      var inner = stmt.get$value(stmt).accept$1(0, this);
      this.statementBuffer.push(new F.Return1(inner));
    },
    visitBreak$1: function(stmt) {
      var fall, t1, t2;
      fall = this.fallthrough;
      t1 = stmt.get$target(stmt).binding.get$next();
      if (t1 == null ? fall == null : t1 === fall)
        ;
      else {
        if (!!J.getInterceptor(fall).$isBreak1) {
          t1 = fall.target;
          t2 = stmt.get$target(stmt);
          t2 = t1 == null ? t2 == null : t1 === t2;
          t1 = t2;
        } else
          t1 = false;
        if (t1)
          ;
        else {
          this.usedLabels.add$1(0, stmt.get$target(stmt));
          t1 = this.statementBuffer;
          t2 = stmt.get$target(stmt);
          t1.push(new F.Break0(t2.get$name(t2)));
        }
      }
    },
    visitContinue$1: function(stmt) {
      var fall, t1, t2;
      fall = this.fallthrough;
      t1 = stmt.get$target(stmt).binding;
      if (t1 == null ? fall == null : t1 === fall)
        ;
      else {
        if (!!J.getInterceptor(fall).$isContinue1) {
          t1 = fall.target;
          t2 = stmt.get$target(stmt);
          t2 = t1 == null ? t2 == null : t1 === t2;
          t1 = t2;
        } else
          t1 = false;
        if (t1)
          ;
        else {
          this.usedLabels.add$1(0, stmt.get$target(stmt));
          t1 = this.statementBuffer;
          t2 = stmt.get$target(stmt);
          t1.push(new F.Continue0(t2.get$name(t2)));
        }
      }
    },
    visitIf$1: function(stmt) {
      var condition, savedBuffer, thenBuffer, elseBuffer;
      condition = stmt.get$condition().accept$1(0, this);
      savedBuffer = this.statementBuffer;
      thenBuffer = H.setRuntimeTypeInfo([], [F.Statement1]);
      this.statementBuffer = thenBuffer;
      stmt.get$thenStatement().accept$1(0, this);
      elseBuffer = H.setRuntimeTypeInfo([], [F.Statement1]);
      this.statementBuffer = elseBuffer;
      stmt.elseStatement.accept$1(0, this);
      savedBuffer.push(new F.If1(condition, new F.Block1(thenBuffer), new F.Block1(elseBuffer)));
      this.statementBuffer = savedBuffer;
    },
    visitWhileTrue$1: function(stmt) {
      var savedBuffer, savedFallthrough, statement, t1;
      savedBuffer = this.statementBuffer;
      savedFallthrough = this.fallthrough;
      this.statementBuffer = H.setRuntimeTypeInfo([], [F.Statement1]);
      this.fallthrough = stmt;
      stmt.body.accept$1(0, this);
      statement = new F.While0(new F.Literal0(C.TrueConstant_true), new F.Block1(this.statementBuffer));
      t1 = stmt.label;
      savedBuffer.push(this.usedLabels.remove$1(0, t1) ? new F.LabeledStatement0(t1.get$name(t1), statement) : statement);
      this.statementBuffer = savedBuffer;
      this.fallthrough = savedFallthrough;
    },
    visitWhileCondition$1: function(stmt) {
      var condition, savedBuffer, savedFallthrough, statement, t1;
      condition = stmt.condition.accept$1(0, this);
      savedBuffer = this.statementBuffer;
      savedFallthrough = this.fallthrough;
      this.statementBuffer = H.setRuntimeTypeInfo([], [F.Statement1]);
      this.fallthrough = stmt;
      stmt.body.accept$1(0, this);
      statement = new F.While0(condition, new F.Block1(this.statementBuffer));
      t1 = stmt.label;
      savedBuffer.push(this.usedLabels.remove$1(0, t1) ? new F.LabeledStatement0(t1.get$name(t1), statement) : statement);
      this.statementBuffer = savedBuffer;
      this.fallthrough = savedFallthrough;
      stmt.next.accept$1(0, this);
    },
    visitConstant$1: function(exp) {
      return exp.get$expression().accept$1(0, new Y.ConstantEmitter0(this));
    },
    visitThis$1: function(exp) {
      return $.get$This__instance();
    },
    visitReifyTypeVar$1: function(exp) {
      var t1, t2;
      t1 = exp.typeVariable;
      t2 = new F.ReifyTypeVar(t1.name, null);
      t2.element = t1;
      return t2;
    },
    visitLiteralList$1: function(exp) {
      var t1 = H.setRuntimeTypeInfo(new H.MappedListIterable(exp.get$values(exp), this.get$visitExpression()), [null, null]).toList$1$growable(0, false);
      return new F.LiteralList0(false, this.emitOptionalType$1(C.JSArray_methods.get$single(exp.type.typeArguments)), t1);
    },
    visitLiteralMap$1: function(exp) {
      var entries, t1;
      entries = P.List_List$generate(exp.values.length, new Y.ASTEmitter_visitLiteralMap_closure(this, exp), true, F.LiteralMapEntry0);
      t1 = exp.type;
      return F.LiteralMap$(entries, false, t1.get$treatAsRaw() ? null : H.setRuntimeTypeInfo(new H.MappedListIterable(t1.typeArguments, this.get$emitType()), [null, null]).toList$1$growable(0, false));
    },
    visitTypeOperator$1: function(exp) {
      var t1, t2, t3, t4;
      t1 = exp.receiver.accept$1(0, this);
      t2 = exp.operator;
      t3 = this.emitType$1(exp.type);
      t4 = new F.TypeOperator(t1, t2, t3);
      t4.TypeOperator$3(t1, t2, t3);
      return t4;
    },
    emitArguments$1: function(exp) {
      var t1, positionalArgumentCount, result, i, t2, t3;
      exp.get$arguments();
      t1 = exp.get$selector();
      positionalArgumentCount = t1.argumentCount - t1.namedArguments.length;
      result = P.List_List$generate(positionalArgumentCount, new Y.ASTEmitter_emitArguments_closure(this, exp), true, F.Argument);
      for (i = 0; i < exp.get$selector().namedArguments.length; ++i) {
        t1 = exp.get$selector().namedArguments;
        if (i >= t1.length)
          return H.ioore(t1, i);
        t1 = t1[i];
        t2 = exp.get$arguments();
        t3 = positionalArgumentCount + i;
        if (t3 < 0 || t3 >= t2.length)
          return H.ioore(t2, t3);
        C.JSArray_methods.add$1(result, new F.NamedArgument0(t1, J.accept$1$x(t2[t3], this)));
      }
      return result;
    },
    visitInvokeStatic$1: function(exp) {
      var t1, t2;
      switch (exp.get$selector().kind) {
        case C.SelectorKind_getter_0:
          t1 = exp.get$target(exp);
          t1 = new F.Identifier0(t1.get$name(t1), null);
          t1.element = exp.target;
          return t1;
        case C.SelectorKind_setter_1:
          t1 = exp.get$target(exp);
          t1 = new F.Identifier0(t1.get$name(t1), null);
          t1.element = exp.target;
          t2 = exp.arguments;
          if (0 >= t2.length)
            return H.ioore(t2, 0);
          return new F.Assignment0(t1, "=", J.accept$1$x(t2[0], this));
        case C.SelectorKind_call_2:
          t1 = exp.get$target(exp);
          t1 = new F.CallStatic(null, t1.get$name(t1), this.emitArguments$1(exp), null);
          t1.element = exp.target;
          return t1;
        default:
          throw H.wrapException("Unexpected selector kind: " + exp.get$selector().kind.toString$0(0));
      }
    },
    emitMethodCall$2: function(exp, receiver) {
      var args, $name, t1, e;
      args = this.emitArguments$1(exp);
      switch (exp.get$selector().kind) {
        case C.SelectorKind_call_2:
          if (exp.get$selector().name === "call")
            return new F.CallFunction(receiver, args);
          return new F.CallMethod(receiver, exp.get$selector().name, args);
        case C.SelectorKind_operator_3:
          if (args.length === 0) {
            $name = exp.get$selector().name;
            if ($name === "unary-")
              $name = "-";
            return new F.UnaryOperator($name, receiver);
          }
          t1 = exp.get$selector().name;
          if (0 >= args.length)
            return H.ioore(args, 0);
          return new F.BinaryOperator(receiver, t1, args[0]);
        case C.SelectorKind_getter_0:
          return new F.FieldExpression(receiver, exp.get$selector().name);
        case C.SelectorKind_setter_1:
          t1 = exp.get$selector().name;
          if (0 >= args.length)
            return H.ioore(args, 0);
          return this.makeAssignment$2(new F.FieldExpression(receiver, t1), args[0]);
        case C.SelectorKind_index_4:
          t1 = args.length;
          if (0 >= t1)
            return H.ioore(args, 0);
          e = new F.IndexExpression(receiver, args[0]);
          if (t1 === 2) {
            if (1 >= t1)
              return H.ioore(args, 1);
            e = this.makeAssignment$2(e, args[1]);
          }
          return e;
        default:
          throw H.wrapException("Unexpected selector in InvokeMethod: " + exp.get$selector().kind.toString$0(0));
      }
    },
    visitInvokeMethod$1: function(exp) {
      return this.emitMethodCall$2(exp, exp.receiver.accept$1(0, this));
    },
    visitInvokeSuperMethod$1: function(exp) {
      return this.emitMethodCall$2(exp, $.get$SuperReceiver__instance());
    },
    visitInvokeConstructor$1: function(exp) {
      var args, $constructor, $name, t1, t2;
      args = this.emitArguments$1(exp);
      $constructor = exp.target;
      $name = J.get$isEmpty$asx($constructor.get$name($constructor)) ? null : $constructor.name;
      t1 = exp.type;
      t2 = new F.CallNew(false, this.emitType$1(t1), $name, args, null, null);
      t2.$constructor = $constructor;
      t2.dartType = t1;
      return t2;
    },
    visitConcatenateStrings$1: function(exp) {
      return new F.StringConcat(H.setRuntimeTypeInfo(new H.MappedListIterable(exp.arguments, this.get$visitExpression()), [null, null]).toList$1$growable(0, false));
    },
    visitConditional$1: function(exp) {
      return new F.Conditional1(exp.condition.accept$1(0, this), exp.thenExpression.accept$1(0, this), exp.elseExpression.accept$1(0, this));
    },
    visitLogicalOperator$1: function(exp) {
      var t1, t2;
      t1 = exp.left.accept$1(0, this);
      t2 = exp.isAnd ? "&&" : "||";
      return new F.BinaryOperator(t1, t2, exp.right.accept$1(0, this));
    },
    visitNot$1: function(exp) {
      return new F.UnaryOperator("!", exp.get$operand().accept$1(0, this));
    },
    visitVariable$1: function(exp) {
      var t1 = new F.Identifier0(this.getVariableName$1(exp), null);
      t1.element = exp.element;
      return t1;
    },
    visitFunctionExpression$1: function(exp) {
      var t1 = new Y.ASTEmitter(H.setRuntimeTypeInfo([], [F.VariableDeclaration0]), P.LinkedHashMap_LinkedHashMap$_empty(M.Variable, P.String), P.LinkedHashMap_LinkedHashMap$_empty(O.VariableElement, P.String), P.LinkedHashSet_LinkedHashSet(null, null, null, M.Variable), this.usedVariableNames, H.setRuntimeTypeInfo([], [F.Statement1]), null, new U.VariableList(null, null, $.get$Modifiers_EMPTY(), C.C_Link2), null, P.LinkedHashSet_LinkedHashSet(null, null, null, M.Label0), null, this).emit$1(exp.definition);
      t1.name = null;
      return t1;
    },
    visitFunctionDeclaration$1: function(node) {
      var $name, inner;
      $name = this.getVariableName$1(node.variable);
      inner = new Y.ASTEmitter(H.setRuntimeTypeInfo([], [F.VariableDeclaration0]), P.LinkedHashMap_LinkedHashMap$_empty(M.Variable, P.String), P.LinkedHashMap_LinkedHashMap$_empty(O.VariableElement, P.String), P.LinkedHashSet_LinkedHashSet(null, null, null, M.Variable), this.usedVariableNames, H.setRuntimeTypeInfo([], [F.Statement1]), null, new U.VariableList(null, null, $.get$Modifiers_EMPTY(), C.C_Link2), null, P.LinkedHashSet_LinkedHashSet(null, null, null, M.Label0), null, this).emit$1(node.definition);
      inner.name = $name;
      this.declaredVariables.add$1(0, node.variable);
      this.statementBuffer.push(new F.FunctionDeclaration1(inner));
      node.next.accept$1(0, this);
    },
    emitType$1: [function(type) {
      var t1 = J.getInterceptor(type);
      if (!!t1.$isGenericType) {
        t1 = new F.TypeAnnotation0(type.get$element().name, H.setRuntimeTypeInfo(new H.MappedListIterable(type.typeArguments, this.get$emitType()), [null, null]).toList$1$growable(0, false), null);
        t1.dartType = type;
        return t1;
      } else if (!!t1.$isVoidType) {
        t1 = new F.TypeAnnotation0("void", C.List_empty9, null);
        t1.dartType = type;
        return t1;
      } else if (!!t1.$isTypeVariableType) {
        t1 = new F.TypeAnnotation0(type.element.name, C.List_empty9, null);
        t1.dartType = type;
        return t1;
      } else if (!!t1.$isDynamicType) {
        t1 = new F.TypeAnnotation0("dynamic", C.List_empty9, null);
        t1.dartType = type;
        return t1;
      } else if (!!t1.$isMalformedType) {
        t1 = new F.TypeAnnotation0(type.element.name, C.List_empty9, null);
        t1.dartType = type;
        return t1;
      } else
        throw H.wrapException("Unsupported type annotation: " + H.S(type));
    }, "call$1", "get$emitType", 2, 0, 27],
    emitOptionalType$1: function(type) {
      if (type.get$treatAsDynamic())
        return;
      else
        return this.emitType$1(type);
    },
    $asVisitor0: function() {
      return [null, F.Expression1];
    }
  },
  ASTEmitter_visitLiteralMap_closure: {
    "^": "Closure:13;this_0,exp_1",
    call$1: function(i) {
      var t1, t2, t3;
      t1 = this.this_0;
      t2 = this.exp_1;
      t3 = t2.keys;
      if (i >= t3.length)
        return H.ioore(t3, i);
      t3 = J.accept$1$x(t3[i], t1);
      t2 = t2.values;
      if (i >= t2.length)
        return H.ioore(t2, i);
      return new F.LiteralMapEntry0(t3, J.accept$1$x(t2[i], t1));
    },
    $isFunction: true
  },
  ASTEmitter_emitArguments_closure: {
    "^": "Closure:13;this_0,exp_1",
    call$1: function(i) {
      var t1 = this.exp_1.get$arguments();
      if (i >= t1.length)
        return H.ioore(t1, i);
      return J.accept$1$x(t1[i], this.this_0);
    },
    $isFunction: true
  },
  ConstantEmitter0: {
    "^": "ConstExpVisitor;parent*",
    visitPrimitive$1: function(exp) {
      var t1, t2, positiveConstant;
      t1 = exp.constant;
      t2 = J.getInterceptor(t1);
      if (!!t2.$isNumConstant)
        if (J.get$isNegative$n(t2.get$value(t1))) {
          if (t1.get$isInt()) {
            t1 = t2.get$value(t1);
            if (typeof t1 !== "number")
              return t1.$negate();
            positiveConstant = K.IntConstant_IntConstant(-t1);
          } else if (t1.get$isDouble()) {
            t1 = t2.get$value(t1);
            if (typeof t1 !== "number")
              return t1.$negate();
            positiveConstant = K.DoubleConstant_DoubleConstant(-t1);
          } else {
            H.throwExpression("Unexpected type of NumConstant: " + t2.toString$0(t1));
            positiveConstant = null;
          }
          return new F.UnaryOperator("-", new F.Literal0(positiveConstant));
        }
      return new F.Literal0(t1);
    },
    visitList$1: function(exp) {
      var t1 = H.setRuntimeTypeInfo(new H.MappedListIterable(exp.values, this.get$visit()), [null, null]).toList$1$growable(0, false);
      return new F.LiteralList0(true, this.parent.emitOptionalType$1(C.JSArray_methods.get$single(exp.type.typeArguments)), t1);
    },
    visitMap$1: function(exp) {
      var entries, t1;
      entries = P.List_List$generate(exp.values.length, new Y.ConstantEmitter_visitMap_closure(this, exp), true, F.LiteralMapEntry0);
      t1 = exp.type;
      return F.LiteralMap$(entries, true, t1.get$treatAsRaw() ? null : H.setRuntimeTypeInfo(new H.MappedListIterable(t1.typeArguments, this.parent.get$emitType()), [null, null]).toList$0(0));
    },
    visitConstructor$1: function(exp) {
      var t1, t2, positionalArgumentCount, args, i, t3, t4, $constructor, $name;
      t1 = exp.selector;
      t2 = t1.argumentCount;
      t1 = t1.namedArguments;
      positionalArgumentCount = t2 - t1.length;
      args = P.List_List$generate(positionalArgumentCount, new Y.ConstantEmitter_visitConstructor_closure(this, exp), true, F.Argument);
      for (t2 = exp.arguments, i = 0; i < t1.length; ++i) {
        t3 = t1[i];
        t4 = positionalArgumentCount + i;
        if (t4 < 0 || t4 >= t2.length)
          return H.ioore(t2, t4);
        C.JSArray_methods.add$1(args, new F.NamedArgument0(t3, J.accept$1$x(t2[t4], this)));
      }
      $constructor = exp.target;
      $name = J.get$isEmpty$asx($constructor.get$name($constructor)) ? null : $constructor.name;
      t1 = exp.type;
      t2 = new F.CallNew(true, this.parent.emitType$1(t1), $name, args, null, null);
      t2.$constructor = $constructor;
      t2.dartType = t1;
      return t2;
    },
    visitConcatenate$1: function(exp) {
      return new F.StringConcat(H.setRuntimeTypeInfo(new H.MappedListIterable(exp.arguments, this.get$visit()), [null, null]).toList$1$growable(0, false));
    },
    visitSymbol$1: function(exp) {
      return new F.LiteralSymbol0(exp.name);
    },
    visitType$1: function(exp) {
      var type, t1;
      type = exp.type;
      t1 = new F.LiteralType(type.get$name(type), null);
      t1.type = type;
      return t1;
    },
    visitVariable$1: function(exp) {
      var element, t1;
      element = exp.element;
      if (element.get$kind(element) !== C.ElementKind_variable_1) {
        t1 = new F.Identifier0(element.name, null);
        t1.element = element;
        return t1;
      }
      t1 = new F.Identifier0(this.parent.getConstantName$1(element), null);
      t1.element = element;
      return t1;
    },
    visitFunction$1: function(exp) {
      var t1, t2;
      t1 = exp.element;
      t2 = new F.Identifier0(t1.get$name(t1), null);
      t2.element = t1;
      return t2;
    },
    $asConstExpVisitor: function() {
      return [F.Expression1];
    }
  },
  ConstantEmitter_visitMap_closure: {
    "^": "Closure:13;this_0,exp_1",
    call$1: function(i) {
      var t1, t2, t3;
      t1 = this.this_0;
      t2 = this.exp_1;
      t3 = t2.keys;
      if (i >= t3.length)
        return H.ioore(t3, i);
      t3 = t3[i].accept$1(0, t1);
      t2 = t2.values;
      if (i >= t2.length)
        return H.ioore(t2, i);
      return new F.LiteralMapEntry0(t3, t2[i].accept$1(0, t1));
    },
    $isFunction: true
  },
  ConstantEmitter_visitConstructor_closure: {
    "^": "Closure:13;this_0,exp_1",
    call$1: function(i) {
      var t1 = this.exp_1.arguments;
      if (i >= t1.length)
        return H.ioore(t1, i);
      return J.accept$1$x(t1[i], this.this_0);
    },
    $isFunction: true
  },
  UnshadowParameters: {
    "^": "RecursiveVisitor;environment<,shadowedParameters,hasShadowedUse",
    visitFunctionDefinition$1: function(definition) {
      var oldShadow, oldEnvironment, t1, t2, param, t3, t4, oldVariable, i, newParam;
      oldShadow = this.shadowedParameters;
      oldEnvironment = this.environment;
      t1 = P.LinkedHashMap_LinkedHashMap(null, null, null, P.String, M.Variable);
      t1.addAll$1(0, oldEnvironment);
      this.environment = t1;
      t1 = this.shadowedParameters;
      t2 = P.LinkedHashSet_LinkedHashSet(null, null, null, M.Variable);
      t2.addAll$1(0, t1);
      this.shadowedParameters = t2;
      for (t1 = definition.parameters, t2 = H.setRuntimeTypeInfo(new H.ListIterator(t1, t1.length, 0, null), [H.getTypeArgumentByIndex(t1, 0)]); t2.moveNext$0();) {
        param = t2.__internal$_current;
        t3 = this.environment;
        t4 = param.get$element();
        oldVariable = t3.$index(0, t4.get$name(t4));
        if (oldVariable != null)
          this.shadowedParameters.add$1(0, oldVariable);
        t3 = this.environment;
        t4 = param.get$element();
        t3.$indexSet(0, t4.get$name(t4), param);
      }
      definition.body.accept$1(0, this);
      this.environment = oldEnvironment;
      this.shadowedParameters = oldShadow;
      for (t2 = this.hasShadowedUse, i = 0; i < t1.length; ++i) {
        param = t1[i];
        if (t2.remove$1(0, param)) {
          newParam = new M.Variable(definition, param.element, 0, 0, false);
          if (i >= t1.length)
            return H.ioore(t1, i);
          t1[i] = newParam;
          t3 = definition.body;
          ++param.writeCount;
          definition.body = new M.Assign(t3, param, newParam, false);
          newParam.writeCount = 1;
        }
      }
    },
    visitVariable$1: function(variable) {
      if (this.shadowedParameters.contains$1(0, variable))
        this.hasShadowedUse.add$1(0, variable);
    }
  }
}],
["backend_ast_nodes", "package:compiler/implementation/dart_backend/backend_ast_nodes.dart", , F, {
  "^": "",
  isCompoundableOperator: function(op) {
    switch (C.Map_qwccO.$index(0, op)) {
      case 8:
      case 9:
      case 10:
      case 11:
      case 12:
      case 13:
        return true;
      default:
        return false;
    }
  },
  isIdentifierPartNoDollar: function(x) {
    var t1;
    if (typeof x !== "number" || Math.floor(x) !== x)
      return false;
    if (!(48 <= x && x <= 57))
      if (!(65 <= x && x <= 90))
        t1 = 97 <= x && x <= 122 || x === 95;
      else
        t1 = true;
    else
      t1 = true;
    return t1;
  },
  Unparser_definesVariable: [function(s) {
    var t1 = J.getInterceptor(s);
    return !!t1.$isVariableDeclarations || !!t1.$isFunctionDeclaration1;
  }, "call$1", "Unparser_definesVariable$closure", 2, 0, 4],
  Unparser_analyzeStringLiteral: function(node) {
    var parts, t1, best, raws, nonRaws, sqs, dqs, t2, q, t3, index, i, part, t4, j, k, t5, t6, newCost, bestChunk, chunk;
    parts = [];
    new F.Unparser_analyzeStringLiteral_collectParts(parts).call$1(node);
    t1 = new F.Unparser_analyzeStringLiteral_getQuoteCost();
    best = H.setRuntimeTypeInfo([], [F.OpenStringChunk]);
    raws = H.setRuntimeTypeInfo([], [P.$int]);
    nonRaws = H.setRuntimeTypeInfo([], [P.$int]);
    sqs = H.setRuntimeTypeInfo([], [P.$int]);
    dqs = H.setRuntimeTypeInfo([], [P.$int]);
    for (t2 = H.setRuntimeTypeInfo(new H.ListIterator(C.List_ru3, 4, 0, null), [H.getTypeArgumentByIndex(C.List_ru3, 0)]); t2.moveNext$0();) {
      q = t2.__internal$_current;
      t3 = t1.call$1(q);
      index = best.length;
      best.push(new F.OpenStringChunk(null, q, t3));
      if (q.get$raw())
        raws.push(index);
      else
        nonRaws.push(index);
      if (q.quote === 39)
        sqs.push(index);
      else
        dqs.push(index);
    }
    t2 = new F.Unparser_analyzeStringLiteral_penalize(t1, best);
    for (i = 0; i < parts.length; ++i) {
      part = parts[i];
      if (typeof part === "number" && Math.floor(part) === part)
        switch (part) {
          case 36:
          case 92:
            t2.call$4(nonRaws, raws, i, new F.Unparser_analyzeStringLiteral_closure());
            break;
          case 34:
            t2.call$4(dqs, sqs, i, new F.Unparser_analyzeStringLiteral_closure0());
            break;
          case 39:
            t2.call$4(sqs, dqs, i, new F.Unparser_analyzeStringLiteral_closure1());
            break;
          case 10:
          case 13:
          case 12:
          case 8:
          case 11:
          case 9:
          case 0:
            t2.call$4(raws, nonRaws, i, new F.Unparser_analyzeStringLiteral_closure2());
            break;
        }
      else {
        t2.call$4(raws, nonRaws, i, new F.Unparser_analyzeStringLiteral_closure3());
        if (!!J.getInterceptor(part).$isIdentifier0)
          if (!J.contains$1$asx(part.name, "$")) {
            t3 = i + 1;
            t3 = t3 < parts.length && F.isIdentifierPartNoDollar(parts[t3]);
          } else
            t3 = false;
        else
          t3 = false;
        if (t3) {
          t3 = new H.ListIterator(nonRaws, nonRaws.length, 0, null);
          t3.$builtinTypeInfo = [H.getTypeArgumentByIndex(nonRaws, 0)];
          t4 = i + 1;
          for (; t3.moveNext$0();) {
            j = t3.__internal$_current;
            for (k = 0; t5 = best.length, k < t5; ++k) {
              if (j >>> 0 !== j || j >= t5)
                return H.ioore(best, j);
              t5 = best[j].cost;
              t6 = t1.call$1(best[k].quoting);
              if (typeof t6 !== "number")
                return H.iae(t6);
              newCost = t5 + 1 - 2 + t6;
              t5 = best.length;
              if (k >= t5)
                return H.ioore(best, k);
              t6 = best[k];
              if (newCost < t6.cost) {
                if (j >= t5)
                  return H.ioore(best, j);
                t5 = best[j];
                best[k] = new F.OpenStringChunk(new F.StringChunk(t5.previous, t5.quoting, t4), t6.quoting, newCost);
              }
            }
          }
        }
      }
    }
    t1 = best.length;
    if (0 >= t1)
      return H.ioore(best, 0);
    bestChunk = best[0];
    for (t1 = H.setRuntimeTypeInfo(new H.ListIterator(best, t1, 0, null), [H.getTypeArgumentByIndex(best, 0)]); t1.moveNext$0();) {
      chunk = t1.__internal$_current;
      if (chunk.get$cost() < bestChunk.cost)
        bestChunk = chunk;
    }
    return new F.StringLiteralOutput(parts, new F.StringChunk(bestChunk.previous, bestChunk.quoting, parts.length));
  },
  Unparser_getEscapedCharacter: function($char, quoteCode, raw) {
    switch ($char) {
      case 36:
        return raw ? "$" : "\\$";
      case 92:
        return raw ? "\\" : "\\\\";
      case 34:
        return (quoteCode == null ? $char == null : quoteCode === $char) ? "\\\"" : "\"";
      case 39:
        return (quoteCode == null ? $char == null : quoteCode === $char) ? "\\'" : "'";
      case 10:
        return "\\n";
      case 13:
        return "\\r";
      case 12:
        return "\\f";
      case 8:
        return "\\b";
      case 9:
        return "\\t";
      case 11:
        return "\\v";
      case 0:
        return "\\x00";
      default:
        return H.Primitives_stringFromCharCode($char);
    }
  },
  Node3: {
    "^": "Object;"
  },
  Receiver: {
    "^": "Node3;"
  },
  Argument: {
    "^": "Node3;"
  },
  Expression1: {
    "^": "Node3;",
    $isExpression1: true
  },
  Statement1: {
    "^": "Node3;"
  },
  SuperReceiver: {
    "^": "Receiver;",
    $isSuperReceiver: true,
    static: {"^": "SuperReceiver__instance"}
  },
  NamedArgument0: {
    "^": "Argument;name>,expression<",
    $isNamedArgument0: true
  },
  TypeAnnotation0: {
    "^": "Node3;name>,typeArguments<,dartType<"
  },
  Block1: {
    "^": "Statement1;statements<",
    $isBlock1: true
  },
  Break0: {
    "^": "Statement1;label",
    $isBreak0: true
  },
  Continue0: {
    "^": "Statement1;label",
    $isContinue0: true
  },
  ExpressionStatement1: {
    "^": "Statement1;expression<",
    $isExpressionStatement1: true
  },
  While0: {
    "^": "Statement1;condition,body>",
    $isWhile0: true
  },
  If1: {
    "^": "Statement1;condition,thenStatement,elseStatement",
    $isIf1: true
  },
  LabeledStatement0: {
    "^": "Statement1;label,statement<",
    $isLabeledStatement0: true
  },
  Return1: {
    "^": "Statement1;expression<",
    $isReturn1: true
  },
  SwitchCase0: {
    "^": "Node3;"
  },
  CatchBlock0: {
    "^": "Node3;"
  },
  VariableDeclarations: {
    "^": "Statement1;type>,isFinal<,isConst<,declarations",
    $isVariableDeclarations: true
  },
  VariableDeclaration0: {
    "^": "Node3;name>,initializer<,element<"
  },
  FunctionDeclaration1: {
    "^": "Statement1;$function<",
    get$returnType: function() {
      return this.$function.returnType;
    },
    get$parameters: function() {
      return this.$function.parameters;
    },
    get$name: function(_) {
      return this.$function.name;
    },
    get$body: function(_) {
      return this.$function.body;
    },
    $isFunctionDeclaration1: true
  },
  Parameters: {
    "^": "Node3;requiredParameters,optionalParameters,hasNamedParameters"
  },
  Parameter0: {
    "^": "Node3;name>,type>,defaultValue>,parameters<,element<",
    get$isFunction: function() {
      return this.parameters != null;
    }
  },
  FunctionExpression0: {
    "^": "Expression1;returnType<,name>,parameters<,body>,element<",
    $isFunctionExpression0: true
  },
  Conditional1: {
    "^": "Expression1;condition,thenExpression,elseExpression",
    $isConditional1: true
  },
  Identifier0: {
    "^": "Expression1;name>,element<",
    $isIdentifier0: true
  },
  Literal0: {
    "^": "Expression1;value>",
    $isLiteral0: true
  },
  LiteralList0: {
    "^": "Expression1;isConst<,typeArgument,values>",
    $isLiteralList0: true
  },
  LiteralMap0: {
    "^": "Expression1;isConst<,typeArguments<,entries",
    LiteralMap$3$isConst$typeArguments: function(entries, isConst, typeArguments) {
    },
    $isLiteralMap0: true,
    static: {LiteralMap$: function(entries, isConst, typeArguments) {
        var t1 = new F.LiteralMap0(isConst, typeArguments, entries);
        t1.LiteralMap$3$isConst$typeArguments(entries, isConst, typeArguments);
        return t1;
      }}
  },
  LiteralMapEntry0: {
    "^": "Node3;key>,value>"
  },
  LiteralSymbol0: {
    "^": "Expression1;id>",
    $isLiteralSymbol0: true
  },
  LiteralType: {
    "^": "Expression1;name>,type>",
    $isLiteralType: true
  },
  ReifyTypeVar: {
    "^": "Expression1;name>,element<",
    $isReifyTypeVar: true
  },
  StringConcat: {
    "^": "Expression1;expressions",
    $isStringConcat: true
  },
  FieldExpression: {
    "^": "Expression1;object,fieldName",
    $isFieldExpression: true
  },
  IndexExpression: {
    "^": "Expression1;object,index>",
    $isIndexExpression: true
  },
  CallFunction: {
    "^": "Expression1;callee,arguments<",
    $isCallFunction: true
  },
  CallMethod: {
    "^": "Expression1;object,methodName,arguments<",
    $isCallMethod: true
  },
  CallNew: {
    "^": "Expression1;isConst<,type>,constructorName,arguments<,$constructor<,dartType<",
    $isCallNew: true
  },
  CallStatic: {
    "^": "Expression1;className,methodName,arguments<,element<",
    $isCallStatic: true
  },
  UnaryOperator: {
    "^": "Expression1;operatorName,operand",
    $isUnaryOperator: true
  },
  BinaryOperator: {
    "^": "Expression1;left>,operator>,right>",
    $isBinaryOperator: true
  },
  TypeOperator: {
    "^": "Expression1;expression<,operator>,type>",
    TypeOperator$3: function(expression, operator, type) {
    },
    $isTypeOperator: true
  },
  Increment: {
    "^": "Expression1;expression<,operator>,isPrefix",
    Increment$3: function(expression, operator, isPrefix) {
    },
    $isIncrement: true
  },
  Assignment0: {
    "^": "Expression1;left>,operator>,right>",
    $isAssignment0: true,
    static: {"^": "Assignment__operators"}
  },
  This0: {
    "^": "Expression1;",
    $isThis0: true,
    static: {"^": "This__instance"}
  },
  Unparser_analyzeStringLiteral_collectParts: {
    "^": "Closure:28;parts_0",
    call$1: function(e) {
      var t1, t2;
      t1 = J.getInterceptor(e);
      if (!!t1.$isStringConcat)
        H.IterableMixinWorkaround_forEach(e.expressions, this);
      else if (!!t1.$isLiteral0 && !!J.getInterceptor(e.value).$isStringConstant)
        for (t1 = J.get$iterator$ax(J.get$value$x(t1.get$value(e))), t2 = this.parts_0; t1.moveNext$0();)
          t2.push(t1.get$current());
      else
        this.parts_0.push(e);
    },
    $isFunction: true
  },
  Unparser_analyzeStringLiteral_getQuoteCost: {
    "^": "Closure:29;",
    call$1: function(quot) {
      var t1, t2, t3;
      t1 = quot.raw ? 1 : 0;
      t2 = quot.leftQuoteCharCount;
      t3 = t2 > 2 ? 3 : 1;
      return t1 + t2 + t3;
    },
    $isFunction: true
  },
  Unparser_analyzeStringLiteral_penalize: {
    "^": "Closure:30;getQuoteCost_1,best_2",
    call$4: function(penalized, nonPenalized, endIndex, cost) {
      var t1, t2, t3, j, t4, k, t5, t6, newCost;
      for (t1 = H.setRuntimeTypeInfo(new H.ListIterator(penalized, penalized.length, 0, null), [H.getTypeArgumentByIndex(penalized, 0)]), t2 = this.best_2, t3 = this.getQuoteCost_1; t1.moveNext$0();) {
        j = t1.__internal$_current;
        t4 = new H.ListIterator(nonPenalized, nonPenalized.length, 0, null);
        t4.$builtinTypeInfo = [H.getTypeArgumentByIndex(nonPenalized, 0)];
        for (; t4.moveNext$0();) {
          k = t4.__internal$_current;
          t5 = t2.length;
          if (j >>> 0 !== j || j >= t5)
            return H.ioore(t2, j);
          t6 = t2[j].cost;
          if (k >>> 0 !== k || k >= t5)
            return H.ioore(t2, k);
          t5 = t3.call$1(t2[k].quoting);
          if (typeof t5 !== "number")
            return H.iae(t5);
          newCost = t6 + 1 + t5;
          t5 = t2.length;
          if (k >= t5)
            return H.ioore(t2, k);
          t6 = t2[k];
          if (newCost < t6.cost) {
            if (j >= t5)
              return H.ioore(t2, j);
            t5 = t2[j];
            t2[k] = new F.OpenStringChunk(new F.StringChunk(t5.previous, t5.quoting, endIndex), t6.quoting, newCost);
          }
        }
        if (j >>> 0 !== j || j >= t2.length)
          return H.ioore(t2, j);
        t4 = t2[j];
        t5 = t4.cost;
        t6 = cost.call$1(t4.quoting);
        if (typeof t6 !== "number")
          return H.iae(t6);
        t4.cost = t5 + t6;
      }
    },
    $isFunction: true
  },
  Unparser_analyzeStringLiteral_closure: {
    "^": "Closure:13;",
    call$1: function(q) {
      return 1;
    },
    $isFunction: true
  },
  Unparser_analyzeStringLiteral_closure0: {
    "^": "Closure:13;",
    call$1: function(q) {
      return q.raw ? 1 / 0 : 1;
    },
    $isFunction: true
  },
  Unparser_analyzeStringLiteral_closure1: {
    "^": "Closure:13;",
    call$1: function(q) {
      return q.raw ? 1 / 0 : 1;
    },
    $isFunction: true
  },
  Unparser_analyzeStringLiteral_closure2: {
    "^": "Closure:13;",
    call$1: function(q) {
      return 1 / 0;
    },
    $isFunction: true
  },
  Unparser_analyzeStringLiteral_closure3: {
    "^": "Closure:13;",
    call$1: function(q) {
      return 1 / 0;
    },
    $isFunction: true
  },
  StringLiteralOutput: {
    "^": "Object;parts,chunk"
  },
  StringChunk: {
    "^": "Object;previous,quoting,endIndex"
  },
  OpenStringChunk: {
    "^": "Object;previous,quoting,cost<",
    end$1: [function(endIndex) {
      return new F.StringChunk(this.previous, this.quoting, endIndex);
    }, "call$1", "get$end", 2, 0, 31]
  }
}],
["", "package:compiler/implementation/cache_strategy.dart", , S, {
  "^": "",
  CacheStrategy: {
    "^": "Object;hasIncrementalSupport"
  }
}],
["characters", "package:compiler/implementation/util/characters.dart", , Q, {
  "^": "",
  isHexDigit: function(characterCode) {
    if (typeof characterCode !== "number")
      return characterCode.$le();
    if (characterCode <= 57)
      return 48 <= characterCode;
    characterCode = (characterCode | 32) >>> 0;
    return 97 <= characterCode && characterCode <= 102;
  },
  hexDigitValue: function(hexDigit) {
    var t1 = J.getInterceptor$n(hexDigit);
    if (t1.$le(hexDigit, 57))
      return t1.$sub(hexDigit, 48);
    if (typeof hexDigit !== "number")
      return hexDigit.$or();
    return ((hexDigit | 32) >>> 0) - 87;
  }
}],
["closureToClassMapper", "package:compiler/implementation/closure.dart", , Q, {
  "^": "",
  ClosureNamer: {
    "^": "Object;",
    getClosureVariableName$2: function($name, id) {
      return H.S($name) + "_" + id;
    }
  },
  ClosureTask: {
    "^": "CompilerTask;closureMappingCache,namer,compiler,watch,profilerTag",
    get$name: function(_) {
      return "Closure Simplifier";
    },
    computeClosureToClassMapping$3: function(element, node, elements) {
      return this.measure$1(new Q.ClosureTask_computeClosureToClassMapping_closure(this, element, node, elements));
    },
    getMappingForNestedFunction$1: function(node) {
      return this.measure$1(new Q.ClosureTask_getMappingForNestedFunction_closure(this, node));
    }
  },
  ClosureTask_computeClosureToClassMapping_closure: {
    "^": "Closure:23;this_0,element_1,node_2,elements_3",
    call$0: function() {
      var t1, t2, t3, cached, translator;
      t1 = this.this_0;
      t2 = t1.closureMappingCache;
      t3 = this.node_2;
      cached = t2.$index(0, t3);
      if (cached != null)
        return cached;
      translator = new Q.ClosureTranslator(t1.compiler, this.elements_3, 0, 0, false, t2, P.LinkedHashMap_LinkedHashMap(null, null, null, O.Local, Q.BoxFieldElement), H.setRuntimeTypeInfo([], [Y.Expression2]), null, P.LinkedHashSet_LinkedHashSet(null, null, null, O.LocalVariableElement), null, null, null, t1.namer, false);
      t1 = J.getInterceptor(t3);
      if (!!t1.$isFunctionExpression) {
        t1.accept$1(t3, translator);
        translator.updateClosures$0();
      } else {
        t1 = this.element_1;
        if (t1.get$isSynthesized())
          return new Q.ClosureClassMap(null, null, null, new Q.ThisLocal(t1), P.LinkedHashMap_LinkedHashMap(null, null, null, O.Local, Q.CapturedVariable), P.LinkedHashMap_LinkedHashMap(null, null, null, Q.ClosureFieldElement, O.Local), P.LinkedHashMap_LinkedHashMap(null, null, null, Y.Node, Q.ClosureScope), P.LinkedHashSet_LinkedHashSet(null, null, null, O.Local));
        else if (t1.get$initializer() != null)
          translator.translateLazyInitializer$3(t1, t3, t1.get$initializer());
        else
          t2.$indexSet(0, t3, new Q.ClosureClassMap(null, null, null, new Q.ThisLocal(t1), P.LinkedHashMap_LinkedHashMap(null, null, null, O.Local, Q.CapturedVariable), P.LinkedHashMap_LinkedHashMap(null, null, null, Q.ClosureFieldElement, O.Local), P.LinkedHashMap_LinkedHashMap(null, null, null, Y.Node, Q.ClosureScope), P.LinkedHashSet_LinkedHashSet(null, null, null, O.Local)));
      }
      return t2.$index(0, t3);
    },
    $isFunction: true
  },
  ClosureTask_getMappingForNestedFunction_closure: {
    "^": "Closure:23;this_0,node_1",
    call$0: function() {
      var t1, t2, nestedClosureData;
      t1 = this.this_0;
      t2 = this.node_1;
      nestedClosureData = t1.closureMappingCache.$index(0, t2);
      if (nestedClosureData == null)
        t1.compiler.internalError$2(t2, "No closure cache.");
      return nestedClosureData;
    },
    $isFunction: true
  },
  CapturedVariable: {
    "^": "Object;"
  },
  ClosureFieldElement: {
    "^": "ElementX;local,name,kind,enclosingElement,hashCode,metadata,_fixedBackendName,_isNative",
    get$enclosingElement: function() {
      return this.enclosingElement;
    },
    get$memberContext: function() {
      return this.enclosingElement.get$methodElement().get$memberContext();
    },
    get$node: function() {
      throw H.wrapException(O.SpannableAssertionFailure$(this.local, "Should not access node of ClosureFieldElement."));
    },
    get$resolvedAst: function() {
      return new O.ResolvedAst(this, null, this.get$analyzableElement().get$treeElements());
    },
    get$initializer: function() {
      throw H.wrapException(O.SpannableAssertionFailure$(this.local, "Should not access initializer of ClosureFieldElement."));
    },
    get$isInstanceMember: function() {
      return true;
    },
    get$isAssignable: function() {
      return false;
    },
    computeType$1: function(compiler) {
      return this.get$type(this);
    },
    get$type: function(_) {
      var t1, t2;
      t1 = this.local;
      t2 = J.getInterceptor(t1);
      if (!!t2.$isLocalElement)
        return t2.get$type(t1);
      return C.C_DynamicType;
    },
    toString$0: function(_) {
      return "ClosureFieldElement(" + H.S(this.name) + ")";
    },
    accept$1: function(_, visitor) {
      return visitor.visitElement$1(this);
    },
    get$analyzableElement: function() {
      return this.enclosingElement.get$methodElement().get$analyzableElement();
    },
    $isClosureFieldElement: true,
    $isVariableElement: true,
    $isAstElement: true,
    $isElement: true
  },
  ClosureClassElement: {
    "^": "ClassElementX;rawType<,thisType@,callType<,node<,methodElement<,_closureFields,localMembersReversed,localScope,localMembersCache,id,supertype,interfaces,nativeTagInfo,supertypeLoadState,resolutionState,isProxy,hasIncompleteHierarchy,backendMembers,allSupertypesAndSelf,compute_members$ClassMemberMixin$computedMemberNames,compute_members$ClassMemberMixin$interfaceMembersAreClassMembers,compute_members$ClassMemberMixin$classMembers,compute_members$ClassMemberMixin$interfaceMembers,modelx$PatchMixin$patch,modelx$PatchMixin$origin,modelx$TypeDeclarationElementX$thisTypeCache,modelx$TypeDeclarationElementX$rawTypeCache,resolution$AnalyzableElementX$_treeElements,name,kind,enclosingElement,hashCode,metadata,_fixedBackendName,_isNative",
    get$isClosure: function() {
      return true;
    },
    get$position: function(_) {
      return this.node.getBeginToken$0();
    },
    parseNode$1: function(listener) {
      return this.node;
    },
    get$isTopLevel: function() {
      return true;
    },
    get$enclosingElement: function() {
      return this.methodElement;
    },
    accept$1: function(_, visitor) {
      return visitor.visitClassElement$1(this);
    },
    ClosureClassElement$4: function(node, $name, compiler, closure) {
      var backend, t1, superclass, t2;
      backend = compiler.backend;
      t1 = this.methodElement;
      superclass = t1.get$isInstanceMember() ? backend.get$boundClosureClass() : backend.get$closureClass();
      superclass.ensureResolved$1(compiler);
      this.supertype = superclass.get$thisType();
      this.interfaces = C.C_Link0;
      t2 = new V.InterfaceType(this, C.List_empty3);
      t2.GenericType$3$checkTypeArgumentCount(this, C.List_empty3, true);
      this.rawType = t2;
      this.thisType = t2;
      this.allSupertypesAndSelf = superclass.allSupertypesAndSelf.extendClass$1(t2);
      this.callType = t1.get$type(t1);
    },
    $isClosureClassElement: true
  },
  BoxLocal: {
    "^": "Local;name>,executableContext<",
    $isBoxLocal: true
  },
  BoxFieldElement: {
    "^": "ElementX;box<,variableElement,name,kind,enclosingElement,hashCode,metadata,_fixedBackendName,_isNative",
    computeType$1: function(compiler) {
      var t1 = this.variableElement;
      return t1.get$type(t1);
    },
    get$type: function(_) {
      var t1 = this.variableElement;
      return t1.get$type(t1);
    },
    accept$1: function(_, visitor) {
      return visitor.visitElement$1(this);
    },
    $isBoxFieldElement: true,
    $isElement: true
  },
  ThisLocal: {
    "^": "Local;executableContext<",
    get$name: function(_) {
      return "this";
    },
    get$enclosingClass: function() {
      return this.executableContext.get$enclosingClass();
    },
    $isThisLocal: true
  },
  SynthesizedCallMethodElementX: {
    "^": "BaseFunctionElementX;expression<,typeCache,modifiers,nestedClosures,functionSignatureCache,_hasNoBody,abstractField,modelx$PatchMixin$patch,modelx$PatchMixin$origin,name,kind,enclosingElement,hashCode,metadata,_fixedBackendName,_isNative",
    get$enclosingElement: function() {
      return this.enclosingElement;
    },
    get$memberContext: function() {
      return this.enclosingElement.get$methodElement().get$memberContext();
    },
    get$node: function() {
      return this.expression.node;
    },
    parseNode$1: function(listener) {
      return this.expression.node;
    },
    get$resolvedAst: function() {
      return new O.ResolvedAst(this, this.expression.node, this.get$analyzableElement().get$treeElements());
    },
    get$analyzableElement: function() {
      return this.enclosingElement.get$methodElement().get$analyzableElement();
    },
    SynthesizedCallMethodElementX$3: function($name, other, enclosing) {
      this.functionSignatureCache = other.get$functionSignature();
    },
    $isSynthesizedCallMethodElementX: true
  },
  ClosureScope: {
    "^": "Object;boxElement<,_capturedVariableMapping<,boxedLoopVariables@"
  },
  ClosureClassMap: {
    "^": "Object;closureElement,closureClassElement,callElement,thisLocal<,_freeVariableMapping<,_closureFieldMapping,capturingScopes,usedVariablesInTry",
    capturingScopesBox$1: function(variable) {
      var t1 = this.capturingScopes;
      return t1.get$values(t1).any$1(0, new Q.ClosureClassMap_capturingScopesBox_closure(variable));
    },
    isVariableBoxed$1: function(variable) {
      if (!!J.getInterceptor(this._freeVariableMapping.$index(0, variable)).$isBoxFieldElement)
        return true;
      return this.capturingScopesBox$1(variable);
    },
    forEachCapturedVariable$1: function(f) {
      var t1;
      this._freeVariableMapping.forEach$1(0, new Q.ClosureClassMap_forEachCapturedVariable_closure(f));
      t1 = this.capturingScopes;
      t1.get$values(t1).forEach$1(0, new Q.ClosureClassMap_forEachCapturedVariable_closure0(f));
    },
    forEachBoxedVariable$1: function(f) {
      var t1;
      this._freeVariableMapping.forEach$1(0, new Q.ClosureClassMap_forEachBoxedVariable_closure(this, f));
      t1 = this.capturingScopes;
      t1.get$values(t1).forEach$1(0, new Q.ClosureClassMap_forEachBoxedVariable_closure0(f));
    }
  },
  ClosureClassMap_capturingScopesBox_closure: {
    "^": "Closure:13;variable_0",
    call$1: function(scope) {
      return C.JSArray_methods.contains$1(scope.get$boxedLoopVariables(), this.variable_0);
    },
    $isFunction: true
  },
  ClosureClassMap_forEachCapturedVariable_closure: {
    "^": "Closure:19;f_0",
    call$2: function(variable, copy) {
      if (!!J.getInterceptor(variable).$isBoxLocal)
        return;
      this.f_0.call$2(variable, copy);
    },
    $isFunction: true
  },
  ClosureClassMap_forEachCapturedVariable_closure0: {
    "^": "Closure:32;f_1",
    call$1: function(scope) {
      scope.get$_capturedVariableMapping().forEach$1(0, this.f_1);
    },
    $isFunction: true
  },
  ClosureClassMap_forEachBoxedVariable_closure: {
    "^": "Closure:19;this_0,f_1",
    call$2: function(variable, copy) {
      if (!this.this_0.isVariableBoxed$1(variable))
        return;
      this.f_1.call$2(variable, copy);
    },
    $isFunction: true
  },
  ClosureClassMap_forEachBoxedVariable_closure0: {
    "^": "Closure:32;f_2",
    call$1: function(scope) {
      scope.get$_capturedVariableMapping().forEach$1(0, this.f_2);
    },
    $isFunction: true
  },
  ClosureTranslator: {
    "^": "Visitor;compiler<,elements>,closureFieldCounter,boxedFieldCounter,inTryStatement,closureMappingCache,_capturedVariableMapping<,closures,scopeVariables,mutatedVariables,outermostElement,executableContext,closureData,namer,insideClosure",
    translateLazyInitializer$3: function(element, node, initializer) {
      this.visitInvokable$3(element, node, new Q.ClosureTranslator_translateLazyInitializer_closure(this, initializer));
      this.updateClosures$0();
    },
    updateClosures$0: function() {
      var t1, t2, t3, closure, fieldCaptures, boxes, data, t4, t5, closureClass, capturedElement, t6, t7, capturedLocal;
      for (t1 = this.closures, t1 = H.setRuntimeTypeInfo(new H.ListIterator(t1, t1.length, 0, null), [H.getTypeArgumentByIndex(t1, 0)]), t2 = this.namer, t3 = this.closureMappingCache; t1.moveNext$0();) {
        closure = t1.__internal$_current;
        fieldCaptures = P.LinkedHashSet_LinkedHashSet(null, null, null, O.Local);
        boxes = P.LinkedHashSet_LinkedHashSet(null, null, null, Q.BoxLocal);
        data = t3.$index(0, closure);
        t4 = data.get$_freeVariableMapping();
        t5 = new P.LinkedHashMapKeyIterable(t4);
        t5.$builtinTypeInfo = [H.getTypeArgumentByIndex(t4, 0)];
        H.IterableMixinWorkaround_forEach(P.List_List$from(t5, true, H.getRuntimeTypeArgument(t5, "IterableBase", 0)), new Q.ClosureTranslator_updateClosures_closure(this, fieldCaptures, boxes, data));
        closureClass = data.closureClassElement;
        t4 = new Q.ClosureTranslator_updateClosures_addClosureField(this, data, closureClass);
        t5 = new P.LinkedHashSetIterator(boxes, boxes._modifications, null, null);
        t5.$builtinTypeInfo = [null];
        t5._cell = boxes._first;
        for (; t5.moveNext$0();) {
          capturedElement = t5._collection$_current;
          t4.call$2(capturedElement, J.get$name$x(capturedElement));
        }
        t5 = new Q.ClosureTranslator_updateClosures_compareLocals();
        t6 = fieldCaptures.toList$0(0);
        t7 = t6.length - 1;
        if (t7 - 0 <= 32)
          H.Sort__insertionSort(t6, 0, t7, t5);
        else
          H.Sort__dualPivotQuicksort(t6, 0, t7, t5);
        t5 = new H.ListIterator(t6, t6.length, 0, null);
        t5.$builtinTypeInfo = [H.getTypeArgumentByIndex(t6, 0)];
        for (; t5.moveNext$0();) {
          capturedLocal = t5.__internal$_current;
          t6 = this.closureFieldCounter++;
          t4.call$2(capturedLocal, t2.getClosureVariableName$2(J.get$name$x(capturedLocal), t6));
        }
        closureClass.backendMembers = closureClass.backendMembers.reverse$0();
      }
    },
    useLocal$1: function(variable) {
      var t1;
      if (this.insideClosure && new Q.ClosureTranslator_useLocal_inCurrentContext(this).call$1(variable) !== true)
        this.closureData._freeVariableMapping.$indexSet(0, variable, null);
      else if (this.inTryStatement) {
        t1 = J.getInterceptor(variable);
        if (!t1.$eq(variable, this.closureData.thisLocal) && !t1.$eq(variable, this.closureData.closureElement))
          this.closureData.usedVariablesInTry.add$1(0, variable);
      }
    },
    registerNeedsThis$0: function() {
      var t1 = this.closureData.thisLocal;
      if (t1 != null)
        this.useLocal$1(t1);
    },
    visitNode$1: function(node) {
      return node.visitChildren$1(this);
    },
    visitVariableDefinitions$1: function(node) {
      var t1, link, definition, element, $arguments;
      t1 = node.type;
      if (t1 != null)
        t1.accept$1(0, this);
      for (link = node.definitions.nodes, t1 = this.elements; !link.get$isEmpty(link); link = link.get$tail()) {
        definition = link.get$head(link);
        t1.toString;
        element = definition.get$_secret_tree_element$_element();
        if (element.get$kind(element) !== C.ElementKind_initializing_formal_1)
          this.scopeVariables.push(element);
        if (!!definition.$isSend) {
          $arguments = definition.argumentsNode;
          if ($arguments != null)
            $arguments.accept$1(0, this);
        } else
          definition.accept$1(0, this);
      }
    },
    visitTypeAnnotation$1: function(node) {
      var member, t1, type;
      member = this.executableContext.get$memberContext();
      t1 = this.elements._types;
      type = t1 != null ? t1.$index(0, node) : null;
      if (this.compiler.enableTypeAssertions && type != null && type.get$typeVariableOccurrence() != null) {
        if (this.insideClosure && member.get$isFactoryConstructor())
          type.forEachTypeVariable$1(new Q.ClosureTranslator_visitTypeAnnotation_closure(this));
        if (member.get$isInstanceMember() && member.kind !== C.ElementKind_field_1)
          this.registerNeedsThis$0();
      }
    },
    visitIdentifier$1: function(node) {
      var t1, element;
      t1 = node.token;
      if (t1.get$value(t1) === "this")
        this.registerNeedsThis$0();
      else {
        this.elements.toString;
        element = node.get$_secret_tree_element$_element();
        if (element != null && element.get$kind(element) === C.ElementKind_type_variable_128) {
          t1 = this.outermostElement;
          if (t1.get$kind(t1) === C.ElementKind_generative_constructor_16 || t1.get$isFactoryConstructor())
            this.useLocal$1(new Q.TypeVariableLocal(element.get$type(element), this.outermostElement));
          else
            this.registerNeedsThis$0();
        }
      }
    },
    visitSend$1: function(node) {
      var t1, element, t2, t3, t4, annotation;
      t1 = this.elements;
      t1.toString;
      element = node.get$_secret_tree_element$_element();
      if (O.Elements_isLocal(element))
        this.useLocal$1(element);
      else if (element != null && element.get$kind(element) === C.ElementKind_type_variable_128)
        this.analyzeType$1(element.get$type(element));
      else {
        t2 = node.receiver;
        t3 = t2 == null;
        if (t3 && O.Elements_isInstanceSend(node, t1))
          this.registerNeedsThis$0();
        else if (!t3 && t2.isSuper$0())
          this.registerNeedsThis$0();
        else {
          t2 = node.selector;
          t3 = !!J.getInterceptor(t2).$isOperator;
          if (t3) {
            t4 = t2.asOperator$0().token;
            t4 = t4.get$value(t4) === "is";
          } else
            t4 = false;
          if (!t4)
            if (t3) {
              t4 = t2.asOperator$0().token;
              t4 = t4.get$value(t4) === "as";
            } else
              t4 = false;
          else
            t4 = true;
          if (t4) {
            annotation = node.get$typeAnnotationFromIsCheckOrCast();
            t1 = t1._types;
            this.analyzeType$1(t1 != null ? t1.$index(0, annotation) : null);
          } else {
            if (t3) {
              t4 = t2.asOperator$0().token;
              t4 = t4.get$value(t4) === "is";
            } else
              t4 = false;
            if (t4) {
              t2 = node.get$typeAnnotationFromIsCheckOrCast();
              t1 = t1._types;
              this.analyzeType$1(t1 != null ? t1.$index(0, t2) : null);
            } else {
              if (t3) {
                t2 = t2.asOperator$0().token;
                t2 = t2.get$value(t2) === "as";
              } else
                t2 = false;
              if (t2) {
                t2 = node.argumentsNode.nodes;
                t2 = t2.get$head(t2);
                t1 = t1._types;
                this.analyzeType$1(t1 != null ? t1.$index(0, t2) : null);
              } else {
                t1 = t1._asserts;
                if (t1 != null && t1.contains$1(0, node) === true && !this.compiler.enableUserAssertions)
                  return;
              }
            }
          }
        }
      }
      node.visitChildren$1(this);
    },
    visitSendSet$1: function(node) {
      var element;
      this.elements.toString;
      element = node.get$_secret_tree_element$_element();
      if (O.Elements_isLocal(element)) {
        this.mutatedVariables.add$1(0, element);
        if (this.compiler.enableTypeAssertions)
          this.analyzeTypeVariables$1(element.get$type(element));
      }
      Y.Visitor.prototype.visitSendSet$1.call(this, node);
    },
    visitNewExpression$1: function(node) {
      var t1 = this.elements._types;
      this.analyzeType$1(t1 != null ? t1.$index(0, node) : null);
      this.visitSend$1(node.send);
    },
    analyzeTypeVariables$1: function(type) {
      type.forEachTypeVariable$1(new Q.ClosureTranslator_analyzeTypeVariables_closure(this));
    },
    analyzeType$1: function(type) {
      var t1;
      if (type == null)
        return;
      if (this.outermostElement.get$isClassMember() && this.compiler.backend.classNeedsRti$1(this.outermostElement.get$enclosingClass())) {
        t1 = this.outermostElement;
        if (!(t1.get$kind(t1) === C.ElementKind_generative_constructor_16 || t1.get$isFactoryConstructor())) {
          t1 = this.outermostElement;
          t1 = t1.get$kind(t1) === C.ElementKind_field_1;
        } else
          t1 = true;
        if (t1)
          this.analyzeTypeVariables$1(type);
        else if (this.outermostElement.get$isInstanceMember())
          if (type.get$typeVariableOccurrence() != null)
            this.registerNeedsThis$0();
      }
    },
    attachCapturedScopeVariables$1: function(node) {
      var t1, scopeMapping, t2, t3, t4, variable;
      t1 = {};
      t1.box_0 = null;
      scopeMapping = P.LinkedHashMap_LinkedHashMap(null, null, null, O.LocalVariableElement, Q.BoxFieldElement);
      t2 = new Q.ClosureTranslator_attachCapturedScopeVariables_boxCapturedVariable(t1, this, scopeMapping);
      for (t3 = this.scopeVariables, t3 = H.setRuntimeTypeInfo(new H.ListIterator(t3, t3.length, 0, null), [H.getTypeArgumentByIndex(t3, 0)]), t4 = this.mutatedVariables; t3.moveNext$0();) {
        variable = t3.__internal$_current;
        if (!variable.get$isAssignable())
          continue;
        if (!t4.contains$1(0, variable))
          continue;
        t2.call$1(variable);
      }
      if (scopeMapping._collection$_length !== 0) {
        t1 = t1.box_0;
        this.closureData.capturingScopes.$indexSet(0, node, new Q.ClosureScope(t1, scopeMapping, C.List_empty11));
      }
    },
    inNewScope$2: function(node, action) {
      var oldScopeVariables = this.scopeVariables;
      this.scopeVariables = H.setRuntimeTypeInfo([], [O.LocalVariableElement]);
      action.call$0();
      this.attachCapturedScopeVariables$1(node);
      this.mutatedVariables.removeAll$1(this.scopeVariables);
      this.scopeVariables = oldScopeVariables;
    },
    visitLoop$1: function(node) {
      this.inNewScope$2(node, new Q.ClosureTranslator_visitLoop_closure(this, node));
    },
    visitFor$1: function(node) {
      var t1, definitions, scopeData, result, link, t2, definition, element;
      this.visitLoop$1(node);
      t1 = node.initializer;
      if (t1 == null)
        return;
      definitions = t1.asVariableDefinitions$0();
      if (definitions == null)
        return;
      scopeData = this.closureData.capturingScopes.$index(0, node);
      if (scopeData == null)
        return;
      result = H.setRuntimeTypeInfo([], [O.LocalVariableElement]);
      for (link = definitions.definitions.nodes, t1 = this._capturedVariableMapping, t2 = this.elements; !link.get$isEmpty(link); link = link.get$tail()) {
        definition = link.get$head(link);
        t2.toString;
        element = definition.get$_secret_tree_element$_element();
        if (t1.containsKey$1(element))
          result.push(element);
      }
      scopeData.set$boxedLoopVariables(result);
    },
    computeClosureName$1: function(element) {
      var ownName, parts, enclosingElement, t1, parts0, surroundingName, sb;
      ownName = element.get$name(element);
      parts = ownName == null || ownName === "" ? E.LinkEntry$("closure", C.C_Link14, H.getTypeArgumentByIndex(C.C_Link14, 0)) : E.LinkEntry$(ownName, C.C_Link14, H.getTypeArgumentByIndex(C.C_Link14, 0));
      enclosingElement = element.enclosingElement;
      while (true) {
        if (enclosingElement != null)
          if (enclosingElement.get$kind(enclosingElement) !== C.ElementKind_generative_constructor_body_0) {
            t1 = enclosingElement.kind;
            t1 = t1 === C.ElementKind_generative_constructor_16 || t1 === C.ElementKind_class_4 || t1 === C.ElementKind_function_2 || t1 === C.ElementKind_getter_0 || t1 === C.ElementKind_setter_0;
          } else
            t1 = true;
        else
          t1 = false;
        if (!t1)
          break;
        if (enclosingElement.get$kind(enclosingElement) === C.ElementKind_generative_constructor_16 || enclosingElement.kind === C.ElementKind_generative_constructor_body_0 || enclosingElement.get$isFactoryConstructor()) {
          t1 = O.Elements_reconstructConstructorName(enclosingElement);
          parts0 = new E.LinkEntry(t1, parts);
          parts0.$builtinTypeInfo = [H.getTypeArgumentByIndex(parts, 0)];
          parts = parts0;
        } else {
          surroundingName = O.Elements_operatorNameToIdentifier(enclosingElement.name);
          parts0 = new E.LinkEntry(surroundingName, parts);
          parts0.$builtinTypeInfo = [H.getTypeArgumentByIndex(parts, 0)];
          parts = parts0;
        }
        if (enclosingElement.kind === C.ElementKind_generative_constructor_16)
          break;
        enclosingElement = enclosingElement.get$enclosingElement();
      }
      sb = P.StringBuffer$("");
      parts.printOn$2(sb, "_");
      return sb._contents;
    },
    visitInvokable$3: function(element, node, visitChildren) {
      var oldInsideClosure, oldFunctionElement, oldClosureData, t1, closureName, t2, t3, t4, t5, t6, globalizedElement, callElement, thisElement, savedClosureData, freeVariables, freeVariable;
      oldInsideClosure = this.insideClosure;
      oldFunctionElement = this.executableContext;
      oldClosureData = this.closureData;
      t1 = this.outermostElement != null;
      this.insideClosure = t1;
      this.executableContext = element;
      if (t1) {
        this.closures.push(node);
        closureName = this.computeClosureName$1(element);
        t1 = this.compiler;
        t2 = H.setRuntimeTypeInfo([], [Q.ClosureFieldElement]);
        t3 = element.get$compilationUnit();
        t4 = t1.nextFreeClassId++;
        t5 = P.LinkedHashMap_LinkedHashMap(null, null, null, P.String, O.Element);
        t6 = $.ElementX_elementHashCode + 1;
        $.ElementX_elementHashCode = t6;
        globalizedElement = new Q.ClosureClassElement(null, null, null, node, element, t2, C.C_Link, new U.ScopeX(t5), null, t4, null, null, null, 2, 2, false, false, C.C_Link, null, null, true, null, null, null, null, null, null, null, closureName, C.ElementKind_class_4, t3, t6, C.C_Link2, null, false);
        globalizedElement.ClosureClassElement$4(node, closureName, t1, element);
        t6 = element.get$modifiers();
        t3 = H.setRuntimeTypeInfo([], [O.FunctionElement]);
        t4 = $.ElementX_elementHashCode + 1;
        $.ElementX_elementHashCode = t4;
        callElement = new Q.SynthesizedCallMethodElementX(element, null, t6, t3, null, false, null, null, null, "call", element.kind, globalizedElement, t4, C.C_Link2, null, false);
        callElement.SynthesizedCallMethodElementX$3("call", element, globalizedElement);
        element.get$memberContext().get$nestedClosures().push(callElement);
        globalizedElement.addMember$2(callElement, t1);
        globalizedElement.computeAllClassMembers$1(t1);
        t1 = new Q.ClosureClassMap(element, globalizedElement, callElement, this.closureData.thisLocal, P.LinkedHashMap_LinkedHashMap(null, null, null, O.Local, Q.CapturedVariable), P.LinkedHashMap_LinkedHashMap(null, null, null, Q.ClosureFieldElement, O.Local), P.LinkedHashMap_LinkedHashMap(null, null, null, Y.Node, Q.ClosureScope), P.LinkedHashSet_LinkedHashSet(null, null, null, O.Local));
        this.closureData = t1;
      } else {
        this.outermostElement = element;
        thisElement = element.get$isInstanceMember() || element.kind === C.ElementKind_generative_constructor_16 ? new Q.ThisLocal(element) : null;
        t1 = new Q.ClosureClassMap(null, null, null, thisElement, P.LinkedHashMap_LinkedHashMap(null, null, null, O.Local, Q.CapturedVariable), P.LinkedHashMap_LinkedHashMap(null, null, null, Q.ClosureFieldElement, O.Local), P.LinkedHashMap_LinkedHashMap(null, null, null, Y.Node, Q.ClosureScope), P.LinkedHashSet_LinkedHashSet(null, null, null, O.Local));
        this.closureData = t1;
      }
      this.closureMappingCache.$indexSet(0, node, t1);
      this.inNewScope$2(node, new Q.ClosureTranslator_visitInvokable_closure(this, element, visitChildren));
      savedClosureData = this.closureData;
      this.insideClosure = oldInsideClosure;
      this.closureData = oldClosureData;
      this.executableContext = oldFunctionElement;
      t1 = savedClosureData._freeVariableMapping;
      freeVariables = H.setRuntimeTypeInfo(new P.LinkedHashMapKeyIterable(t1), [H.getTypeArgumentByIndex(t1, 0)]);
      for (t1 = freeVariables._map, t1 = H.setRuntimeTypeInfo(new P.LinkedHashMapKeyIterator(t1, t1._modifications, null, null), [H.getTypeArgumentByIndex(freeVariables, 0)]), t1._cell = t1._map._first, t2 = this._capturedVariableMapping, t3 = this.compiler; t1.moveNext$0();) {
        freeVariable = t1._collection$_current;
        if (t2.$index(0, freeVariable) != null)
          t3.internalError$2(node, "In closure analyzer.");
        t2.$indexSet(0, freeVariable, null);
        this.useLocal$1(freeVariable);
      }
    },
    visitFunctionExpression$1: function(node) {
      var element;
      this.elements.toString;
      element = node.get$_secret_tree_element$_element();
      if (element.get$kind(element) === C.ElementKind_parameter_1)
        return node.name.accept$1(0, this);
      this.visitInvokable$3(element, node, new Q.ClosureTranslator_visitFunctionExpression_closure(this, node));
    },
    visitTryStatement$1: function(node) {
      var oldInTryStatement = this.inTryStatement;
      this.inTryStatement = true;
      node.visitChildren$1(this);
      this.inTryStatement = oldInTryStatement;
    },
    $asVisitor: function() {
      return [null];
    }
  },
  ClosureTranslator_translateLazyInitializer_closure: {
    "^": "Closure:23;this_0,initializer_1",
    call$0: function() {
      this.initializer_1.accept$1(0, this.this_0);
    },
    $isFunction: true
  },
  ClosureTranslator_updateClosures_closure: {
    "^": "Closure:33;this_0,fieldCaptures_1,boxes_2,data_3",
    call$1: function(fromElement) {
      var boxFieldElement = this.this_0._capturedVariableMapping.$index(0, fromElement);
      if (boxFieldElement == null)
        this.fieldCaptures_1.add$1(0, fromElement);
      else {
        this.data_3._freeVariableMapping.$indexSet(0, fromElement, boxFieldElement);
        this.boxes_2.add$1(0, boxFieldElement.get$box());
      }
    },
    $isFunction: true
  },
  ClosureTranslator_updateClosures_addClosureField: {
    "^": "Closure:34;this_4,data_5,closureClass_6",
    call$2: function(local, $name) {
      var t1, t2, closureField;
      t1 = this.closureClass_6;
      t2 = $.ElementX_elementHashCode + 1;
      $.ElementX_elementHashCode = t2;
      closureField = new Q.ClosureFieldElement(local, $name, C.ElementKind_field_1, t1, t2, C.C_Link2, null, false);
      t1._closureFields.push(closureField);
      t1.addMember$2(closureField, this.this_4.compiler);
      t1 = this.data_5;
      t1._closureFieldMapping.$indexSet(0, closureField, local);
      t1._freeVariableMapping.$indexSet(0, local, closureField);
    },
    $isFunction: true
  },
  ClosureTranslator_updateClosures_compareLocals: {
    "^": "Closure:35;",
    call$2: function(a, b) {
      var t1, t2;
      t1 = J.getInterceptor(a);
      t2 = !!t1.$isElement;
      if (t2 && !!J.getInterceptor(b).$isElement)
        return O.Elements_compareByPosition(a, b);
      else if (t2)
        return 1;
      else {
        t2 = J.getInterceptor(b);
        if (!!t2.$isElement)
          return -1;
        else
          return J.compareTo$1$ns(t1.get$name(a), t2.get$name(b));
      }
    },
    $isFunction: true
  },
  ClosureTranslator_useLocal_inCurrentContext: {
    "^": "Closure:36;this_0",
    call$1: function(variable) {
      var t1, t2;
      t1 = this.this_0;
      if (!J.$eq(variable, t1.executableContext)) {
        t2 = variable.get$executableContext();
        t1 = t1.executableContext;
        t1 = t2 == null ? t1 == null : t2 === t1;
      } else
        t1 = true;
      return t1;
    },
    $isFunction: true
  },
  ClosureTranslator_visitTypeAnnotation_closure: {
    "^": "Closure:37;this_0",
    call$1: function(variable) {
      var t1 = this.this_0;
      t1.useLocal$1(new Q.TypeVariableLocal(variable, t1.outermostElement));
    },
    $isFunction: true
  },
  ClosureTranslator_analyzeTypeVariables_closure: {
    "^": "Closure:37;this_0",
    call$1: function(typeVariable) {
      var t1, t2;
      t1 = this.this_0;
      t2 = t1.outermostElement;
      if (t2.get$kind(t2) !== C.ElementKind_field_1) {
        t2 = t1.outermostElement;
        t2 = !(t2.get$kind(t2) === C.ElementKind_generative_constructor_16 || t2.get$isFactoryConstructor());
      } else
        t2 = false;
      if (t2)
        t1.registerNeedsThis$0();
      else
        t1.useLocal$1(new Q.TypeVariableLocal(typeVariable, t1.outermostElement));
    },
    $isFunction: true
  },
  ClosureTranslator_attachCapturedScopeVariables_boxCapturedVariable: {
    "^": "Closure:38;box_0,this_1,scopeMapping_2",
    call$1: function(variable) {
      var t1, t2, t3, boxedName, t4, boxed;
      t1 = this.this_1;
      t2 = t1._capturedVariableMapping;
      if (t2.containsKey$1(variable)) {
        t3 = this.box_0;
        if (t3.box_0 == null)
          t3.box_0 = new Q.BoxLocal(t1.namer.getClosureVariableName$2("box", t1.closureFieldCounter++), t1.executableContext);
        boxedName = t1.namer.getClosureVariableName$2(variable.name, t1.boxedFieldCounter++);
        t1 = t3.box_0;
        t3 = t1.executableContext;
        t4 = $.ElementX_elementHashCode + 1;
        $.ElementX_elementHashCode = t4;
        boxed = new Q.BoxFieldElement(t1, variable, boxedName, C.ElementKind_field_1, t3, t4, C.C_Link2, null, false);
        boxed._fixedBackendName = boxedName;
        this.scopeMapping_2.$indexSet(0, variable, boxed);
        t2.$indexSet(0, variable, boxed);
      }
    },
    $isFunction: true
  },
  ClosureTranslator_visitLoop_closure: {
    "^": "Closure:23;this_0,node_1",
    call$0: function() {
      this.node_1.visitChildren$1(this.this_0);
    },
    $isFunction: true
  },
  ClosureTranslator_visitInvokable_closure: {
    "^": "Closure:23;this_0,element_1,visitChildren_2",
    call$0: function() {
      var t1, type, t2;
      t1 = this.element_1;
      type = t1.get$type(t1);
      if (!!t1.$isFunctionElement) {
        t2 = this.this_0.compiler;
        t1 = t2.backend.methodNeedsRti$1(t1) || t2.enableTypeAssertions;
      } else
        t1 = false;
      if (t1)
        this.this_0.analyzeTypeVariables$1(type);
      this.visitChildren_2.call$0();
    },
    $isFunction: true
  },
  ClosureTranslator_visitFunctionExpression_closure: {
    "^": "Closure:23;this_0,node_1",
    call$0: function() {
      var t1, t2;
      t1 = this.node_1;
      t2 = t1.parameters;
      if (t2 != null) {
        t2.toString;
        this.this_0.visitNodeList$1(t2);
      }
      t2 = t1.initializers;
      if (t2 != null) {
        t2.toString;
        this.this_0.visitNodeList$1(t2);
      }
      t1 = t1.body;
      if (t1 != null)
        t1.accept$1(0, this.this_0);
    },
    $isFunction: true
  },
  TypeVariableLocal: {
    "^": "Object;typeVariable,executableContext<",
    get$name: function(_) {
      return this.typeVariable.element.name;
    },
    get$hashCode: function(_) {
      return J.get$hashCode$(this.typeVariable);
    },
    $eq: function(_, other) {
      if (other == null)
        return false;
      if (!J.getInterceptor(other).$isTypeVariableLocal)
        return false;
      return J.$eq(this.typeVariable, other.typeVariable);
    },
    $isTypeVariableLocal: true,
    $isLocal: true
  }
}],
["compiler", "package:compiler/compiler.dart", , D, {
  "^": "",
  Diagnostic: {
    "^": "Object;ordinal,name>",
    toString$0: function(_) {
      return this.name;
    },
    static: {"^": "Diagnostic_ERROR,Diagnostic_WARNING,Diagnostic_HINT,Diagnostic_INFO,Diagnostic_VERBOSE_INFO,Diagnostic_CRASH"}
  }
}],
["compiler_isolate", "../../../site/try/src/compiler_isolate.dart", , O, {
  "^": "",
  compile: function(source, replyTo) {
    var t1, request, t2, messageType, data, compilationTimer, t3;
    t1 = {};
    if ($.sdkLocation == null) {
      if (J.endsWith$1$s(source, "/sdk.json")) {
        request = new XMLHttpRequest();
        C.HttpRequest_methods.open$3$async(request, "GET", source, false);
        request.send(null);
        if (request.status !== 200)
          throw H.wrapException("SDK not found at " + source);
        $.sdkLocation = P.Uri_parse("sdk:/sdk/");
        J.forEach$1$ax(C.JsonCodec_null_null.decode$1(request.responseText), new O.compile_closure());
      } else
        $.sdkLocation = P.Uri_parse(source);
      J.send$1$x(replyTo, null);
      return;
    }
    t2 = J.getInterceptor(source);
    if (!!t2.$isList) {
      messageType = t2.get$length(source) > 0 ? t2.$index(source, 0) : null;
      data = t2.get$length(source) > 1 ? t2.$index(source, 1) : null;
      if (J.$eq(messageType, "options"))
        $.options = H.listTypeCast(data);
      return;
    }
    t1.charactersRead_0 = 0;
    t2 = new O.compile_handler(replyTo);
    compilationTimer = new P.Stopwatch(null, null);
    H.Primitives_initTicker();
    $.Stopwatch__frequency = $.Primitives_timerFrequency;
    compilationTimer.start$0(0);
    t3 = $.get$options();
    t3 = D.reuseCompiler($.cachedCompiler, t2, null, new O.compile_inputProvider(t1, source, replyTo), $.sdkLocation, t3, null, P.Uri_base().resolveUri$1(P.Uri_parse("/packages/")), true);
    $.cachedCompiler = t3;
    t3.run$1(P.Uri_parse("org-trydart:/main.dart")).then$1(new O.compile_closure0(t1, source, replyTo, t2, compilationTimer)).catchError$1(new O.compile_closure1(replyTo)).whenComplete$1(new O.compile_closure2(replyTo));
  },
  main: [function($arguments, port) {
    var t1, t2, t3, replyTo;
    t1 = $.RawReceivePortImpl__nextFreeId;
    $.RawReceivePortImpl__nextFreeId = t1 + 1;
    t2 = new H.RawReceivePortImpl(t1, null, false);
    t3 = init.globalState.currentContext;
    t3._addRegistration$2(t1, t2);
    t3._updateGlobalState$0();
    replyTo = new H.ReceivePortImpl(t2, null);
    replyTo.ReceivePortImpl$fromRawReceivePort$1(t2);
    J.send$1$x(port, new H._NativeJsSendPort(t2, init.globalState.currentContext.id));
    t2 = replyTo._controller;
    t2.toString;
    H.setRuntimeTypeInfo(new P._ControllerStream(t2), [null]).listen$4$cancelOnError$onDone$onError(new O.main_closure(port), null, null, null);
  }, "call$2", "main$closure", 4, 0, 5],
  compile_closure: {
    "^": "Closure:19;",
    call$2: function(file, $content) {
      $.get$cachedSources().$indexSet(0, P.Uri_parse(file), P._Future$immediate($content, P.String));
    },
    $isFunction: true
  },
  compile_inputProvider: {
    "^": "Closure:39;box_0,source_1,replyTo_2",
    call$1: function(uri) {
      var future, t1;
      if (uri.get$scheme() === "sdk") {
        if (C.JSString_methods.endsWith$1(uri._path, "/lib/html/dart2js/html_dart2js.dart"))
          this.replyTo_2.send$1(0, "dart:html");
        future = $.get$cachedSources().$index(0, uri);
      } else {
        t1 = uri.scheme;
        if (t1 === "http" || t1 === "https")
          future = $.get$cachedSources().putIfAbsent$2(uri, new O.compile_inputProvider_closure(uri));
        else if (H.S(uri) === "org-trydart:/main.dart")
          future = P._Future$immediate(this.source_1, P.String);
        else
          future = t1 === "org-trydart" ? W.HttpRequest_getString("project" + uri._path, null, null) : null;
      }
      if (future == null)
        future = P._Future$immediateError(H.S(uri) + ": Not found", null, P.String);
      return future.then$1(new O.compile_inputProvider_closure0(this.box_0)).catchError$2$test(new O.compile_inputProvider_closure1(uri), new O.compile_inputProvider_closure2());
    },
    $isFunction: true
  },
  compile_inputProvider_closure: {
    "^": "Closure:23;uri_3",
    call$0: function() {
      return W.HttpRequest_getString(this.uri_3.toString$0(0), null, null);
    },
    $isFunction: true
  },
  compile_inputProvider_closure0: {
    "^": "Closure:0;box_0",
    call$1: function(value) {
      var t1 = this.box_0;
      t1.charactersRead_0 = t1.charactersRead_0 + J.get$length$asx(value);
      return value;
    },
    $isFunction: true
  },
  compile_inputProvider_closure1: {
    "^": "Closure:40;uri_4",
    call$1: function($event) {
      var target = W._convertNativeToDart_EventTarget(J.get$_get_target$x($event));
      if (!!J.getInterceptor(target).$isHttpRequest)
        throw H.wrapException(this.uri_4.toString$0(0) + ": " + H.S(target.statusText));
      else
        throw H.wrapException($event);
    },
    $isFunction: true
  },
  compile_inputProvider_closure2: {
    "^": "Closure:13;",
    call$1: function(error) {
      return !!J.getInterceptor(error).$isEvent;
    },
    $isFunction: true
  },
  compile_handler: {
    "^": "Closure:41;replyTo_5",
    call$5: function(uri, begin, end, message, kind) {
      this.replyTo_5.send$1(0, ["diagnostic", P.LinkedHashMap_LinkedHashMap$_literal(["uri", J.toString$0(uri), "begin", begin, "end", end, "message", message, "kind", kind.name], null, null)]);
    },
    $isFunction: true
  },
  compile_closure0: {
    "^": "Closure:13;box_0,source_6,replyTo_7,handler_8,compilationTimer_9",
    call$1: function(success) {
      var js, url, t1, t2, exception;
      t1 = this.compilationTimer_9;
      t1.stop$0(0);
      t1 = t1.get$elapsedTicks();
      t2 = $.Stopwatch__frequency;
      if (typeof t2 !== "number")
        return H.iae(t2);
      P.print("Compilation took " + P.Duration$(0, 0, C.JSInt_methods.$tdiv(t1 * 1000000, t2), 0, 0, 0).toString$0(0));
      t1 = $.cachedCompiler.libraryLoader;
      t2 = P.Uri_parse("dart:html");
      if (t1.libraryCanonicalUriMap.$index(0, t2) != null)
        this.replyTo_7.send$1(0, "dart:html");
      js = $.cachedCompiler.assembledCode;
      if (js == null) {
        if (!J.contains$1$asx($.get$options(), "--analyze-only"))
          this.replyTo_7.send$1(0, "failed");
      } else {
        url = null;
        this.handler_8.call$5(null, 0, 0, "Compiled " + H.S(J.get$length$asx(this.source_6)) + "/" + this.box_0.charactersRead_0 + " characters Dart -> " + H.S(J.get$length$asx(js)) + " characters.", C.Diagnostic_kiE);
        try {
          url = (self.URL || self.webkitURL).createObjectURL(W.Blob_Blob([js], "application/javascript", null));
        } catch (exception) {
          H.unwrapException(exception);
        }

        t1 = this.replyTo_7;
        if (url != null)
          t1.send$1(0, ["url", url]);
        else
          t1.send$1(0, ["code", js]);
      }
    },
    $isFunction: true
  },
  compile_closure1: {
    "^": "Closure:19;replyTo_10",
    call$2: function(e, trace) {
      this.replyTo_10.send$1(0, ["crash", H.S(e) + ", " + H.S(trace)]);
    },
    $isFunction: true
  },
  compile_closure2: {
    "^": "Closure:23;replyTo_11",
    call$0: function() {
      this.replyTo_11.send$1(0, "done");
    },
    $isFunction: true
  },
  main_closure: {
    "^": "Closure:13;port_0",
    call$1: function(message) {
      var list, exception, stack, exception0, t1;
      try {
        list = H.listTypeCast(message);
        O.compile(J.$index$asx(list, 0), J.$index$asx(list, 1));
      } catch (exception0) {
        t1 = H.unwrapException(exception0);
        exception = t1;
        stack = new H._StackTrace(exception0, null);
        this.port_0.send$1(0, H.S(exception) + "\n" + H.S(stack));
      }

    },
    $isFunction: true
  }
},
1],
["concrete_types_inferrer", "package:compiler/implementation/inferrer/concrete_types_inferrer.dart", , L, {
  "^": "",
  ConcreteType_ConcreteType$singleton: function(maxConcreteTypeSize, classBaseTypes, baseType) {
    var singletonSet;
    if (baseType.isUnknown$0() || maxConcreteTypeSize < 1)
      return C.C_UnknownConcreteType;
    singletonSet = P.LinkedHashSet_LinkedHashSet(null, null, null, L.BaseType);
    singletonSet.add$1(0, baseType);
    return new L.UnionType(maxConcreteTypeSize, classBaseTypes, singletonSet);
  },
  BaseType: {
    "^": "Object;"
  },
  ClassBaseType: {
    "^": "Object;element<",
    $eq: function(_, other) {
      var t1, t2;
      if (other == null)
        return false;
      if (this === other)
        return true;
      if (!J.getInterceptor(other).$isClassBaseType)
        return false;
      t1 = this.element;
      t2 = other.element;
      return t1 == null ? t2 == null : t1 === t2;
    },
    get$hashCode: function(_) {
      return J.get$hashCode$(this.element);
    },
    toString$0: function(_) {
      var t1 = this.element;
      return t1 == null ? "toplevel" : t1.get$name(t1);
    },
    isClass$0: [function() {
      return true;
    }, "call$0", "get$isClass", 0, 0, 42],
    isUnknown$0: function() {
      return false;
    },
    isNull$0: [function() {
      return false;
    }, "call$0", "get$isNull", 0, 0, 42],
    $isClassBaseType: true
  },
  UnknownBaseType: {
    "^": "Object;",
    $eq: function(_, other) {
      if (other == null)
        return false;
      return !!J.getInterceptor(other).$isUnknownBaseType;
    },
    get$hashCode: function(_) {
      return 0;
    },
    isClass$0: [function() {
      return false;
    }, "call$0", "get$isClass", 0, 0, 42],
    isUnknown$0: function() {
      return true;
    },
    isNull$0: [function() {
      return false;
    }, "call$0", "get$isNull", 0, 0, 42],
    toString$0: function(_) {
      return "unknown";
    },
    $isUnknownBaseType: true
  },
  NullBaseType: {
    "^": "Object;",
    $eq: function(_, other) {
      if (other == null)
        return false;
      return other === this;
    },
    get$hashCode: function(_) {
      return 1;
    },
    isClass$0: [function() {
      return false;
    }, "call$0", "get$isClass", 0, 0, 42],
    isUnknown$0: function() {
      return false;
    },
    isNull$0: [function() {
      return true;
    }, "call$0", "get$isNull", 0, 0, 42],
    toString$0: function(_) {
      return "null";
    }
  },
  ConcreteType: {
    "^": "Object;"
  },
  UnknownConcreteType: {
    "^": "Object;",
    isUnknown$0: function() {
      return true;
    },
    isEmpty$0: [function(_) {
      return false;
    }, "call$0", "get$isEmpty", 0, 0, 42],
    $eq: function(_, other) {
      if (other == null)
        return false;
      return this === other;
    },
    get$baseTypes: function() {
      var t1 = P.LinkedHashSet_LinkedHashSet(null, null, null, L.BaseType);
      t1.addAll$1(0, [C.C_UnknownBaseType]);
      return t1;
    },
    get$hashCode: function(_) {
      return 0;
    },
    union$1: function(other) {
      return this;
    },
    intersection$1: function(_, other) {
      return other;
    },
    refine$2: function(selector, compiler) {
      return this;
    },
    getUniqueType$0: function() {
      return;
    },
    toString$0: function(_) {
      return "unknown";
    }
  },
  UnionType: {
    "^": "Object;maxConcreteTypeSize,classBaseTypes,baseTypes<",
    isUnknown$0: function() {
      return false;
    },
    isEmpty$0: [function(_) {
      var t1 = this.baseTypes;
      return t1.get$isEmpty(t1);
    }, "call$0", "get$isEmpty", 0, 0, 42],
    $eq: function(_, other) {
      var t1, t2, t3;
      if (other == null)
        return false;
      if (!J.getInterceptor(other).$isUnionType)
        return false;
      t1 = this.baseTypes;
      t2 = t1.get$length(t1);
      t3 = other.baseTypes;
      if (t2 !== t3.get$length(t3))
        return false;
      return t1.containsAll$1(t3);
    },
    get$hashCode: function(_) {
      var t1, result, t2;
      for (t1 = this.baseTypes, t1 = t1.get$iterator(t1), result = 1; t1.moveNext$0();) {
        t2 = J.get$hashCode$(t1.get$current());
        if (typeof t2 !== "number")
          return H.iae(t2);
        result = 31 * result + t2;
      }
      return result;
    },
    _simplify$1: function(baseTypes) {
      var t1, t2, t3;
      t1 = this.classBaseTypes;
      t2 = t1.uint31Type;
      if (baseTypes.contains$1(0, t2)) {
        baseTypes.remove$1(0, t2);
        baseTypes.add$1(0, t1.intBaseType);
      }
      t2 = t1.uint32Type;
      if (baseTypes.contains$1(0, t2)) {
        baseTypes.remove$1(0, t2);
        baseTypes.add$1(0, t1.intBaseType);
      }
      t2 = t1.positiveIntType;
      if (baseTypes.contains$1(0, t2)) {
        baseTypes.remove$1(0, t2);
        baseTypes.add$1(0, t1.intBaseType);
      }
      t2 = t1.numBaseType;
      if (!baseTypes.contains$1(0, t2))
        t3 = baseTypes.contains$1(0, t1.intBaseType) && baseTypes.contains$1(0, t1.doubleBaseType);
      else
        t3 = true;
      if (t3) {
        baseTypes.remove$1(0, t1.intBaseType);
        baseTypes.remove$1(0, t1.doubleBaseType);
        baseTypes.add$1(0, t2);
      }
      t2 = this.maxConcreteTypeSize;
      return baseTypes.get$length(baseTypes) > t2 ? C.C_UnknownConcreteType : new L.UnionType(t2, t1, baseTypes);
    },
    union$1: function(other) {
      var newBaseTypes;
      if (other.isUnknown$0())
        return C.C_UnknownConcreteType;
      newBaseTypes = P.LinkedHashSet_LinkedHashSet(null, null, null, L.BaseType);
      newBaseTypes.addAll$1(0, this.baseTypes);
      newBaseTypes.addAll$1(0, other.get$baseTypes());
      return this._simplify$1(newBaseTypes);
    },
    intersection$1: function(_, other) {
      var thisBaseTypes, t1, otherBaseTypes;
      if (other.isUnknown$0())
        return this;
      thisBaseTypes = P.LinkedHashSet_LinkedHashSet(null, null, null, L.BaseType);
      thisBaseTypes.addAll$1(0, this.baseTypes);
      t1 = other.get$baseTypes();
      otherBaseTypes = P.LinkedHashSet_LinkedHashSet(null, null, null, L.BaseType);
      otherBaseTypes.addAll$1(0, t1);
      return this._simplify$1(thisBaseTypes.intersection$1(0, otherBaseTypes));
    },
    refine$2: function(selector, compiler) {
      var newBaseTypes, t1, baseType;
      newBaseTypes = P.LinkedHashSet_LinkedHashSet(null, null, null, L.BaseType);
      for (t1 = this.baseTypes, t1 = t1.get$iterator(t1); t1.moveNext$0();) {
        baseType = t1.get$current();
        if (baseType.isClass$0()) {
          if (baseType.get$element().lookupSelector$2(selector, compiler) != null)
            newBaseTypes.add$1(0, baseType);
        } else
          newBaseTypes.add$1(0, baseType);
      }
      return this._simplify$1(newBaseTypes);
    },
    getUniqueType$0: function() {
      var t1, iterator, uniqueBaseType;
      t1 = this.baseTypes;
      if (t1.get$length(t1) === 1) {
        iterator = t1.get$iterator(t1);
        iterator.moveNext$0();
        uniqueBaseType = iterator.get$current();
        if (uniqueBaseType.isClass$0())
          return uniqueBaseType.get$element();
      }
      return;
    },
    toString$0: function(_) {
      return P.IterableBase_iterableToFullString(this.baseTypes, "{", "}");
    },
    $isUnionType: true
  },
  ConcreteTypeSystem: {
    "^": "TypeSystem;compiler<,inferrer,baseTypes<,nullType<,_intType,_uint31Type,_uint32Type,_positiveIntType,_doubleType,_numType,_boolType,_functionType,_listType,_constListType,_fixedListType,_growableListType,_mapType,_constMapType,_stringType,dynamicType<,typeType<,nonNullEmptyType",
    get$intType: function() {
      this.inferrer.augmentSeenClasses$1(this.compiler.backend.get$intImplementation());
      return this._intType;
    },
    get$uint31Type: function() {
      this.inferrer.augmentSeenClasses$1(this.compiler.backend.get$uint31Implementation());
      return this._uint31Type;
    },
    get$doubleType: function() {
      this.inferrer.augmentSeenClasses$1(this.compiler.backend.get$doubleImplementation());
      return this._doubleType;
    },
    get$numType: function() {
      this.inferrer.augmentSeenClasses$1(this.compiler.backend.get$numImplementation());
      return this._numType;
    },
    get$boolType: function() {
      this.inferrer.augmentSeenClasses$1(this.compiler.backend.get$boolImplementation());
      return this._boolType;
    },
    get$functionType: function() {
      this.inferrer.augmentSeenClasses$1(this.compiler.backend.compiler.functionClass);
      return this._functionType;
    },
    get$constListType: function() {
      this.inferrer.augmentSeenClasses$1(this.compiler.backend.get$constListImplementation());
      return this._constListType;
    },
    get$fixedListType: function() {
      this.inferrer.augmentSeenClasses$1(this.compiler.backend.get$fixedListImplementation());
      return this._fixedListType;
    },
    get$growableListType: function() {
      this.inferrer.augmentSeenClasses$1(this.compiler.backend.get$growableListImplementation());
      return this._growableListType;
    },
    get$mapType: function() {
      this.inferrer.augmentSeenClasses$1(this.compiler.backend.get$mapImplementation());
      return this._mapType;
    },
    get$constMapType: function() {
      this.inferrer.augmentSeenClasses$1(this.compiler.backend.get$constMapImplementation());
      return this._constMapType;
    },
    get$stringType: function() {
      this.inferrer.augmentSeenClasses$1(this.compiler.backend.get$stringImplementation());
      return this._stringType;
    },
    stringLiteralType$1: function(_) {
      this.inferrer.augmentSeenClasses$1(this.compiler.backend.get$stringImplementation());
      return this._stringType;
    },
    baseTypeToTypeMask$1: function(baseType) {
      var element, t1, t2;
      if (baseType.isUnknown$0())
        return C.C_DynamicTypeMask;
      else if (baseType.isNull$0())
        return new B.FlatTypeMask(null, 1);
      else {
        element = baseType.get$element();
        t1 = this.compiler;
        t2 = t1.backend.get$numImplementation();
        if (element == null ? t2 == null : element === t2)
          return new B.FlatTypeMask(t1.backend.get$numImplementation(), 4);
        else {
          t2 = t1.backend.get$intImplementation();
          if (element == null ? t2 == null : element === t2)
            return new B.FlatTypeMask(t1.backend.get$intImplementation(), 4);
          else
            return new B.FlatTypeMask(element.get$declaration(), 2);
        }
      }
    },
    concreteTypeToTypeMask$1: function(concreteType) {
      var typeMask, t1, baseMask;
      if (concreteType == null)
        return;
      typeMask = new B.FlatTypeMask(null, 0);
      for (t1 = concreteType.get$baseTypes(), t1 = t1.get$iterator(t1); t1.moveNext$0();) {
        baseMask = this.baseTypeToTypeMask$1(t1.get$current());
        if (baseMask.$eq(0, C.C_DynamicTypeMask))
          return baseMask;
        typeMask = typeMask.union$2(baseMask, this.compiler);
      }
      return typeMask;
    },
    addPhiInput$3: function(variable, phiType, newType) {
      return this.computeLUB$2(phiType, newType);
    },
    allocateDiamondPhi$2: function(firstInput, secondInput) {
      return this.computeLUB$2(firstInput, secondInput);
    },
    allocatePhi$3: function(node, variable, inputType) {
      return inputType;
    },
    computeLUB$2: function(firstType, secondType) {
      if (firstType == null)
        return secondType;
      else if (secondType == null)
        return firstType;
      else
        return firstType.union$1(secondType);
    },
    narrowType$3$isNullable: function(type, annotation, isNullable) {
      var t1, t2, t3, otherType;
      if (annotation.get$treatAsDynamic())
        return type;
      if (annotation.get$kind(annotation) === C.TypeKind_void)
        return this.nullType;
      t1 = annotation.get$element();
      t2 = this.compiler;
      t3 = t2.objectClass;
      if (t1 == null ? t3 == null : t1 === t3)
        return type;
      if (annotation.get$kind(annotation) === C.TypeKind_typedef || annotation.get$kind(annotation) === C.TypeKind_function) {
        this.inferrer.augmentSeenClasses$1(t2.backend.compiler.functionClass);
        otherType = this._functionType;
      } else if (annotation.get$kind(annotation) === C.TypeKind_kuk)
        return type;
      else
        otherType = this.nonNullSubX$2(annotation.get$element(), t2.world.get$subtypesOf());
      if (isNullable)
        otherType = otherType.union$1(this.nullType);
      if (type == null)
        return otherType;
      return J.intersection$1$x(type, otherType);
    },
    narrowType$2: function(type, annotation) {
      return this.narrowType$3$isNullable(type, annotation, true);
    },
    newTypedSelector$2: function(receiver, selector) {
      return Z.TypedSelector_TypedSelector(this.concreteTypeToTypeMask$1(receiver), selector, this.compiler);
    },
    nonNullEmpty$0: function() {
      return this.nonNullEmptyType;
    },
    nonNullExact$1: function(cls) {
      return this.nonNullSubX$2(cls, this.compiler.world.get$subtypesOf());
    },
    nonNullSubX$2: function(cls, extractor) {
      var t1, t2, subtypes;
      t1 = {};
      t2 = this.compiler.objectClass;
      if (cls == null ? t2 == null : cls === t2)
        return this.dynamicType;
      t1.result_0 = this.nonNullEmptyType;
      t2 = new L.ConcreteTypeSystem_nonNullSubX_registerClass(t1, this);
      t2.call$1(cls);
      subtypes = extractor.call$1(cls);
      if (subtypes != null)
        J.forEach$1$ax(subtypes, t2);
      return t1.result_0;
    },
    nonNullSubclass$1: function(cls) {
      return this.nonNullSubX$2(cls, this.compiler.world.get$subclassesOf());
    },
    nonNullSubtype$1: function(cls) {
      return this.nonNullSubX$2(cls, this.compiler.world.get$subtypesOf());
    },
    simplifyPhi$3: function(node, variable, phiType) {
      return phiType;
    },
    refineReceiver$2: function(selector, receiverType) {
      return receiverType.refine$2(selector, this.compiler);
    },
    isNull$1: [function(type) {
      var t1 = type.get$baseTypes();
      if (t1.get$length(t1) === 1) {
        t1 = type.get$baseTypes();
        t1 = t1.get$first(t1).isNull$0() === true;
      } else
        t1 = false;
      return t1;
    }, "call$1", "get$isNull", 2, 0, 43],
    allocateClosure$2: function(node, element) {
      this.inferrer.augmentSeenClasses$1(this.compiler.backend.compiler.functionClass);
      return this._functionType;
    },
    allocateList$5: function(type, node, enclosing, elementType, $length) {
      if (elementType != null)
        this.inferrer.augmentListElementType$1(elementType);
      return type;
    },
    allocateMap$5: function(type, node, element, keyTypes, valueTypes) {
      return type;
    },
    getConcreteTypeFor$1: function(mask) {
      var result, t1;
      if (mask.get$isUnion())
        return J.fold$2$ax(mask.get$disjointMasks(), this.nonNullEmptyType, new L.ConcreteTypeSystem_getConcreteTypeFor_closure(this));
      else {
        if (mask.get$flags() >>> 1 === 0)
          result = this.nonNullEmptyType;
        else {
          t1 = mask.flags >>> 1;
          if (t1 === 1)
            result = this.nonNullSubX$2(mask.base, this.compiler.world.get$subtypesOf());
          else if (t1 === 2)
            result = this.nonNullSubX$2(mask.base, this.compiler.world.get$subclassesOf());
          else if (t1 === 3)
            result = this.nonNullSubX$2(mask.base, this.compiler.world.get$subtypesOf());
          else
            throw H.wrapException(P.ArgumentError$("unexpected mask"));
        }
        return (mask.flags & 1) !== 0 ? result.union$1(this.nullType) : result;
      }
    },
    $asTypeSystem: function() {
      return [L.ConcreteType];
    },
    static: {ConcreteTypeSystem_ConcreteTypeSystem: function(inferrer) {
        var compiler, baseTypes, t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15, t16, t17;
        compiler = inferrer.compiler;
        baseTypes = L.BaseTypes$(compiler);
        t1 = new L.ConcreteTypeSystem_ConcreteTypeSystem_closure(compiler, baseTypes);
        t2 = baseTypes.constMapBaseType;
        t3 = t1.call$1(t2);
        t2 = t1.call$1(t2);
        t4 = t1.call$1(baseTypes.doubleBaseType);
        t5 = t1.call$1(baseTypes.fixedListBaseType);
        t6 = t1.call$1(baseTypes.functionBaseType);
        t7 = t1.call$1(baseTypes.growableListBaseType);
        t8 = baseTypes.intBaseType;
        t9 = t1.call$1(t8);
        t10 = t1.call$1(baseTypes.listBaseType);
        t11 = t1.call$1(baseTypes.mapBaseType);
        t12 = t1.call$1(baseTypes.numBaseType);
        t13 = t1.call$1(baseTypes.boolBaseType);
        t14 = t1.call$1(baseTypes.stringBaseType);
        t15 = t1.call$1(baseTypes.typeBaseType);
        t16 = t1.call$1(C.C_NullBaseType);
        t17 = P.LinkedHashSet_LinkedHashSet(null, null, null, L.BaseType);
        return new L.ConcreteTypeSystem(compiler, inferrer, baseTypes, t16, t9, t1.call$1(t8), t1.call$1(t8), t1.call$1(t8), t4, t12, t13, t6, t10, t3, t5, t7, t11, t2, t14, C.C_UnknownConcreteType, t15, new L.UnionType(compiler.maxConcreteTypeSize, baseTypes, t17));
      }}
  },
  ConcreteTypeSystem_ConcreteTypeSystem_closure: {
    "^": "Closure:44;compiler_0,baseTypes_1",
    call$1: function(baseType) {
      return L.ConcreteType_ConcreteType$singleton(this.compiler_0.maxConcreteTypeSize, this.baseTypes_1, baseType);
    },
    $isFunction: true
  },
  ConcreteTypeSystem_nonNullSubX_registerClass: {
    "^": "Closure:45;box_0,this_1",
    call$1: function(element) {
      var t1, t2;
      if (!element.get$isAbstract()) {
        t1 = this.box_0;
        t2 = this.this_1;
        t1.result_0 = t1.result_0.union$1(L.ConcreteType_ConcreteType$singleton(t2.compiler.maxConcreteTypeSize, t2.baseTypes, new L.ClassBaseType(element)));
        t2.inferrer.augmentSeenClasses$1(element);
      }
    },
    $isFunction: true
  },
  ConcreteTypeSystem_getConcreteTypeFor_closure: {
    "^": "Closure:19;this_0",
    call$2: function(type1, type2) {
      return type1.union$1(this.this_0.getConcreteTypeFor$1(type2));
    },
    $isFunction: true
  },
  ConcreteTypeCartesianProductIterator: {
    "^": "Object;inferrer,classOfThis,concreteTypes,nextValues,state,size,counter,_concrete_types_inferrer$_current",
    get$current: function() {
      return this._concrete_types_inferrer$_current;
    },
    takeSnapshot$0: function() {
      var result = P.LinkedHashMap_LinkedHashMap(null, null, null, O.Element, L.ConcreteType);
      this.nextValues.forEach$1(0, new L.ConcreteTypeCartesianProductIterator_takeSnapshot_closure(this, result));
      return new L.ConcreteTypesEnvironment(result, this.classOfThis);
    },
    moveNext$0: function() {
      var t1, t2, t3, t4, key, iterator, t5, newIterator;
      if (this.counter >= this.size) {
        this._concrete_types_inferrer$_current = null;
        return false;
      }
      for (t1 = this.concreteTypes, t2 = H.setRuntimeTypeInfo(new P.LinkedHashMapKeyIterable(t1), [H.getTypeArgumentByIndex(t1, 0)]), t3 = t2._map, t2 = H.setRuntimeTypeInfo(new P.LinkedHashMapKeyIterator(t3, t3._modifications, null, null), [H.getTypeArgumentByIndex(t2, 0)]), t2._cell = t2._map._first, t3 = this.state, t4 = this.nextValues; t2.moveNext$0();) {
        key = t2._collection$_current;
        iterator = t3.$index(0, key);
        if (iterator != null && iterator.moveNext$0()) {
          t4.$indexSet(0, key, t3.$index(0, key).get$current());
          break;
        }
        t5 = t1.$index(0, key).get$baseTypes();
        newIterator = t5.get$iterator(t5);
        t3.$indexSet(0, key, newIterator);
        newIterator.moveNext$0();
        t4.$indexSet(0, key, newIterator.get$current());
      }
      ++this.counter;
      this._concrete_types_inferrer$_current = this.takeSnapshot$0();
      return true;
    },
    ConcreteTypeCartesianProductIterator$3: function(inferrer, classOfThis, concreteTypes) {
      var t1, t2, baseTypes;
      if (concreteTypes._collection$_length === 0) {
        this.size = 0;
        return;
      }
      for (t1 = H.setRuntimeTypeInfo(new P.LinkedHashMapKeyIterable(concreteTypes), [H.getTypeArgumentByIndex(concreteTypes, 0)]), t2 = t1._map, t1 = H.setRuntimeTypeInfo(new P.LinkedHashMapKeyIterator(t2, t2._modifications, null, null), [H.getTypeArgumentByIndex(t1, 0)]), t1._cell = t1._map._first; t1.moveNext$0();) {
        baseTypes = concreteTypes.$index(0, t1._collection$_current).get$baseTypes();
        this.size = this.size * baseTypes.get$length(baseTypes);
      }
    },
    static: {ConcreteTypeCartesianProductIterator$: function(inferrer, classOfThis, concreteTypes) {
        var t1 = new L.ConcreteTypeCartesianProductIterator(inferrer, classOfThis, concreteTypes, P.LinkedHashMap_LinkedHashMap(null, null, null, O.Element, L.BaseType), P.LinkedHashMap_LinkedHashMap(null, null, null, O.Element, P.Iterator), 1, 0, null);
        t1.ConcreteTypeCartesianProductIterator$3(inferrer, classOfThis, concreteTypes);
        return t1;
      }}
  },
  ConcreteTypeCartesianProductIterator_takeSnapshot_closure: {
    "^": "Closure:19;this_0,result_1",
    call$2: function(k, v) {
      var t1 = this.this_0.inferrer;
      this.result_1.$indexSet(0, k, L.ConcreteType_ConcreteType$singleton(t1.compiler.maxConcreteTypeSize, t1.baseTypes, v));
    },
    $isFunction: true
  },
  BaseTypes: {
    "^": "Object;intBaseType,doubleBaseType,numBaseType,boolBaseType,stringBaseType,listBaseType,growableListBaseType,fixedListBaseType,constListBaseType,mapBaseType,constMapBaseType,objectBaseType,typeBaseType,functionBaseType,uint31Type,uint32Type,positiveIntType",
    static: {BaseTypes$: function(compiler) {
        var t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14;
        t1 = compiler.backend.get$intImplementation();
        t2 = compiler.backend.get$doubleImplementation();
        t3 = compiler.backend.get$numImplementation();
        t4 = compiler.backend.get$boolImplementation();
        t5 = compiler.backend.get$stringImplementation();
        t6 = compiler.backend.get$listImplementation();
        t7 = compiler.backend.get$growableListImplementation();
        t8 = compiler.backend.get$fixedListImplementation();
        t9 = compiler.backend.get$constListImplementation();
        t10 = compiler.backend.get$mapImplementation();
        t11 = compiler.backend.get$constMapImplementation();
        t12 = compiler.objectClass;
        t13 = compiler.backend.get$typeImplementation();
        t14 = compiler.backend;
        return new L.BaseTypes(new L.ClassBaseType(t1), new L.ClassBaseType(t2), new L.ClassBaseType(t3), new L.ClassBaseType(t4), new L.ClassBaseType(t5), new L.ClassBaseType(t6), new L.ClassBaseType(t7), new L.ClassBaseType(t8), new L.ClassBaseType(t9), new L.ClassBaseType(t10), new L.ClassBaseType(t11), new L.ClassBaseType(t12), new L.ClassBaseType(t13), new L.ClassBaseType(t14.compiler.functionClass), new L.ClassBaseType(t14.get$uint31Implementation()), new L.ClassBaseType(compiler.backend.get$uint32Implementation()), new L.ClassBaseType(compiler.backend.get$positiveIntImplementation()));
      }}
  },
  ConcreteTypesEnvironment: {
    "^": "Object;environment<,classOfThis",
    $eq: function(_, other) {
      var t1, t2, t3, t4, key;
      if (other == null)
        return false;
      if (!J.getInterceptor(other).$isConcreteTypesEnvironment)
        return false;
      t1 = this.classOfThis;
      t2 = other.classOfThis;
      if (t1 == null ? t2 != null : t1 !== t2)
        return false;
      t1 = this.environment;
      t2 = t1._collection$_length;
      t3 = other.environment;
      if (t2 !== t3._collection$_length)
        return false;
      for (t2 = H.setRuntimeTypeInfo(new P.LinkedHashMapKeyIterable(t1), [H.getTypeArgumentByIndex(t1, 0)]), t4 = t2._map, t2 = H.setRuntimeTypeInfo(new P.LinkedHashMapKeyIterator(t4, t4._modifications, null, null), [H.getTypeArgumentByIndex(t2, 0)]), t2._cell = t2._map._first; t2.moveNext$0();) {
        key = t2._collection$_current;
        if (!t3.containsKey$1(key) || !J.$eq(t1.$index(0, key), t3.$index(0, key)))
          return false;
      }
      return true;
    },
    get$hashCode: function(_) {
      var t1, t2;
      t1 = {};
      t2 = this.classOfThis;
      t1.result_0 = t2 != null ? J.get$hashCode$(t2) : 1;
      this.environment.forEach$1(0, new L.ConcreteTypesEnvironment_hashCode_closure(t1));
      return t1.result_0;
    },
    toString$0: function(_) {
      return "{ this: " + J.toString$0(this.classOfThis) + ", env: " + P.Maps_mapToString(this.environment) + " }";
    },
    $isConcreteTypesEnvironment: true
  },
  ConcreteTypesEnvironment_hashCode_closure: {
    "^": "Closure:19;box_0",
    call$2: function(element, concreteType) {
      var t1, t2, t3, t4;
      t1 = this.box_0;
      t2 = t1.result_0;
      if (typeof t2 !== "number")
        return H.iae(t2);
      t3 = J.get$hashCode$(element);
      if (typeof t3 !== "number")
        return H.iae(t3);
      t4 = J.get$hashCode$(concreteType);
      if (typeof t4 !== "number")
        return H.iae(t4);
      t1.result_0 = 31 * (31 * t2 + t3) + t4;
    },
    $isFunction: true
  },
  ClosureEnvironment: {
    "^": "Object;thisType@,locals<",
    toString$0: function(_) {
      return "ClosureEnvironment { thisType = " + J.toString$0(this.thisType) + ", locals = ... }";
    }
  },
  Closures: {
    "^": "Object;compiler<,closures",
    put$3: function(closure, typeOfThis, locals) {
      var t1, oldEnvironent, oldThisType;
      t1 = this.closures;
      oldEnvironent = t1.$index(0, closure);
      if (oldEnvironent == null) {
        t1.$indexSet(0, closure, new L.ClosureEnvironment(typeOfThis, locals));
        return true;
      } else {
        oldThisType = oldEnvironent.get$thisType();
        if (oldEnvironent.get$thisType() == null)
          oldEnvironent.set$thisType(typeOfThis);
        else if (typeOfThis != null)
          oldEnvironent.set$thisType(oldEnvironent.get$thisType().union$1(typeOfThis));
        return oldEnvironent.get$locals() != null && oldEnvironent.get$locals().mergeAll$1([locals]) || !J.$eq(oldEnvironent.get$thisType(), oldThisType);
      }
    },
    contains$1: function(_, $function) {
      return this.closures.containsKey$1($function);
    },
    toString$0: function(_) {
      return P.Maps_mapToString(this.closures);
    }
  },
  InferenceWorkItem: {
    "^": "Object;method,environment<",
    toString$0: function(_) {
      return "{ method = " + J.toString$0(this.method) + ", environment = " + J.toString$0(this.environment) + " }";
    },
    $eq: function(_, other) {
      var t1, t2;
      if (other == null)
        return false;
      if (!!J.getInterceptor(other).$isInferenceWorkItem) {
        t1 = this.method;
        t2 = other.method;
        t1 = (t1 == null ? t2 == null : t1 === t2) && J.$eq(this.environment, other.environment);
      } else
        t1 = false;
      return t1;
    },
    get$hashCode: function(_) {
      var t1, t2;
      t1 = J.get$hashCode$(this.method);
      if (typeof t1 !== "number")
        return H.iae(t1);
      t2 = J.get$hashCode$(this.environment);
      if (typeof t2 !== "number")
        return H.iae(t2);
      return 31 * t1 + t2;
    },
    $isInferenceWorkItem: true
  },
  DynamicTypeMask: {
    "^": "Object;",
    toString$0: function(_) {
      return "sentinel type mask";
    },
    nullable$0: function() {
      throw H.wrapException(P.UnsupportedError$(""));
    },
    nonNullable$0: function() {
      throw H.wrapException(P.UnsupportedError$(""));
    },
    get$isEmpty: function(_) {
      throw H.wrapException(P.UnsupportedError$(""));
    },
    get$isNullable: function() {
      throw H.wrapException(P.UnsupportedError$(""));
    },
    get$isExact: function() {
      throw H.wrapException(P.UnsupportedError$(""));
    },
    get$isUnion: function() {
      throw H.wrapException(P.UnsupportedError$(""));
    },
    get$isContainer: function() {
      throw H.wrapException(P.UnsupportedError$(""));
    },
    get$isMap: function(_) {
      throw H.wrapException(P.UnsupportedError$(""));
    },
    get$isDictionary: function() {
      throw H.wrapException(P.UnsupportedError$(""));
    },
    get$isForwarding: function() {
      throw H.wrapException(P.UnsupportedError$(""));
    },
    get$isValue: function() {
      throw H.wrapException(P.UnsupportedError$(""));
    },
    containsOnlyInt$1: function(compiler) {
      throw H.wrapException(P.UnsupportedError$(""));
    },
    containsOnlyDouble$1: function(compiler) {
      throw H.wrapException(P.UnsupportedError$(""));
    },
    containsOnlyNum$1: function(compiler) {
      throw H.wrapException(P.UnsupportedError$(""));
    },
    containsOnlyBool$1: function(compiler) {
      throw H.wrapException(P.UnsupportedError$(""));
    },
    containsOnlyString$1: function(compiler) {
      throw H.wrapException(P.UnsupportedError$(""));
    },
    containsOnly$1: function(element) {
      throw H.wrapException(P.UnsupportedError$(""));
    },
    satisfies$2: function(cls, compiler) {
      throw H.wrapException(P.UnsupportedError$(""));
    },
    contains$2: function(_, type, compiler) {
      throw H.wrapException(P.UnsupportedError$(""));
    },
    containsAll$1: function(compiler) {
      throw H.wrapException(P.UnsupportedError$(""));
    },
    singleClass$1: function(compiler) {
      throw H.wrapException(P.UnsupportedError$(""));
    },
    union$2: function(other, compiler) {
      throw H.wrapException(P.UnsupportedError$(""));
    },
    intersection$2: function(_, other, compiler) {
      throw H.wrapException(P.UnsupportedError$(""));
    },
    canHit$3: function(element, selector, compiler) {
      throw H.wrapException(P.UnsupportedError$(""));
    },
    locateSingleElement$2: function(selector, compiler) {
      throw H.wrapException(P.UnsupportedError$(""));
    },
    needsNoSuchMethodHandling$2: function(selector, compiler) {
      throw H.wrapException(P.UnsupportedError$(""));
    },
    isInMask$2: function(other, compiler) {
      throw H.wrapException(P.UnsupportedError$(""));
    },
    containsMask$2: function(other, compiler) {
      throw H.wrapException(P.UnsupportedError$(""));
    }
  },
  WorkQueue: {
    "^": "Object;queue",
    add$1: function(_, workItem) {
      var t1 = this.queue;
      if (!t1.contains$1(0, workItem))
        t1._add$1(workItem);
    },
    get$isEmpty: function(_) {
      var t1 = this.queue;
      return t1._head === t1._tail;
    }
  },
  ConcreteTypesInferrer: {
    "^": "InferrerEngine;name>,testMode<,baseTypes<,types:concrete_types_inferrer$ConcreteTypesInferrer$types<,listIndex,listIndexSet,listAdd,listRemoveAt,listInsert,listRemoveLast,listConstructor,unknownConcreteType<,emptyConcreteType,nullConcreteType,methodToTemplates,closures<,inferredTypes<,inferredFieldTypes,callers,fieldReaders,capturedLocalsReaders,seenClasses,dynamicCallers,listElementType,inferredParameterTypes,inferredSelectorTypes,workQueue,currentWorkItem,compiler,types,concreteTypes,generativeConstructorsExposingThis",
    typeMaskUnion$2: function(mask1, mask2) {
      if (J.$eq(mask1, C.C_DynamicTypeMask) || J.$eq(mask2, C.C_DynamicTypeMask))
        return C.C_DynamicTypeMask;
      return mask1.union$2(mask2, this.compiler);
    },
    getMembersBySelector$1: function(selector) {
      var result, t1, t2, elem;
      result = P.LinkedHashSet_LinkedHashSet(null, null, null, O.Element);
      for (t1 = this.seenClasses, t1 = H.setRuntimeTypeInfo(new P.LinkedHashSetIterator(t1, t1._modifications, null, null), [null]), t1._cell = t1._set._first, t2 = this.compiler; t1.moveNext$0();) {
        elem = t1._collection$_current.lookupSelector$2(selector, t2);
        if (elem != null)
          result.add$1(0, elem.get$implementation(elem));
      }
      return result;
    },
    getReflexiveSubtypesOf$1: function(cls) {
      var result, t1, t2, candidate, subtypes;
      result = P.LinkedHashSet_LinkedHashSet(null, null, null, O.ClassElement);
      result.add$1(0, cls);
      t1 = this.seenClasses;
      t2 = new P.LinkedHashSetIterator(t1, t1._modifications, null, null);
      t2.$builtinTypeInfo = [null];
      t2._cell = t1._first;
      t1 = this.compiler;
      for (; t2.moveNext$0();) {
        candidate = t2._collection$_current;
        subtypes = t1.world._subtypes.$index(0, cls.get$declaration());
        if (subtypes != null && J.contains$1$asx(subtypes, candidate.get$declaration()) === true)
          result.add$1(0, candidate);
      }
      return result;
    },
    augmentInferredSelectorType$3: function(selector, typeOfThis, returnType) {
      var currentMap, t1, currentReturnType;
      currentMap = this.inferredSelectorTypes.putIfAbsent$2(selector.get$asUntyped(), new L.ConcreteTypesInferrer_augmentInferredSelectorType_closure());
      t1 = J.getInterceptor$asx(currentMap);
      currentReturnType = t1.$index(currentMap, typeOfThis);
      t1.$indexSet(currentMap, typeOfThis, currentReturnType == null ? returnType : this.typeMaskUnion$2(currentReturnType, returnType));
    },
    getFieldType$2: function(selector, field) {
      var result, enclosing;
      this.ensureFieldInitialized$1(field);
      result = this.inferredFieldTypes.$index(0, field);
      if (result == null)
        result = this.emptyConcreteType;
      if (selector != null) {
        enclosing = field.get$enclosingElement();
        if (enclosing.get$kind(enclosing) === C.ElementKind_class_4)
          this.augmentInferredSelectorType$3(selector, new B.FlatTypeMask(enclosing.get$declaration(), 3), this.concrete_types_inferrer$ConcreteTypesInferrer$types.concreteTypeToTypeMask$1(result));
      }
      return result;
    },
    augmentFieldType$2: function(field, type) {
      var t1, oldType, newType;
      this.ensureFieldInitialized$1(field);
      t1 = this.inferredFieldTypes;
      oldType = t1.$index(0, field);
      newType = oldType != null ? oldType.union$1(type) : type;
      if (!J.$eq(oldType, newType)) {
        t1.$indexSet(0, field, newType);
        this.invalidateReaders$1(field);
      }
    },
    augmentListElementType$1: function(type) {
      var newType = this.listElementType.union$1(type);
      if (!newType.$eq(0, this.listElementType)) {
        this.invalidateCallers$1(this.listIndex);
        this.listElementType = newType;
      }
    },
    augmentParameterType$2: [function(parameter, type) {
      var t1, oldType;
      t1 = this.inferredParameterTypes;
      oldType = t1.$index(0, parameter);
      t1.$indexSet(0, parameter, oldType == null ? type : oldType.union$1(type));
    }, "call$2", "get$augmentParameterType", 4, 0, 46],
    augmentSeenClasses$1: function(cls) {
      var t1 = this.seenClasses;
      if (!t1.contains$1(0, cls)) {
        t1.add$1(0, cls);
        cls.forEachMember$2$includeSuperAndInjectedMembers(new L.ConcreteTypesInferrer_augmentSeenClasses_closure(this), true);
      }
    },
    addCaller$2: function(callee, caller) {
      J.add$1$ax(this.callers.putIfAbsent$2(callee, new L.ConcreteTypesInferrer_addCaller_closure()), caller);
    },
    addDynamicCaller$2: function(callee, caller) {
      J.add$1$ax(this.dynamicCallers.putIfAbsent$2(callee.name, new L.ConcreteTypesInferrer_addDynamicCaller_closure()), caller);
    },
    addFieldReader$2: function(field, reader) {
      J.add$1$ax(this.fieldReaders.putIfAbsent$2(field, new L.ConcreteTypesInferrer_addFieldReader_closure()), reader);
    },
    addCapturedLocalReader$2: function(local, reader) {
      J.add$1$ax(this.capturedLocalsReaders.putIfAbsent$2(local, new L.ConcreteTypesInferrer_addCapturedLocalReader_closure()), reader);
    },
    invalidateCallers$1: function($function) {
      var methodCallers = this.callers.$index(0, $function);
      if (methodCallers != null)
        J.forEach$1$ax(methodCallers, this.get$invalidate());
    },
    invalidateReaders$1: function(field) {
      var readers = this.fieldReaders.$index(0, field);
      if (readers != null)
        J.forEach$1$ax(readers, this.get$invalidate());
    },
    invalidate$1: [function(methodOrField) {
      var templates;
      if (J.get$kind$x(methodOrField) === C.ElementKind_field_1)
        this.workQueue.add$1(0, new L.InferenceWorkItem(methodOrField, new L.ConcreteTypesEnvironment(P.LinkedHashMap_LinkedHashMap(null, null, null, O.Element, L.ConcreteType), null)));
      else {
        templates = this.methodToTemplates.$index(0, methodOrField);
        if (templates != null)
          J.forEach$1$ax(templates, new L.ConcreteTypesInferrer_invalidate_closure(this, methodOrField));
      }
    }, "call$1", "get$invalidate", 2, 0, 47],
    getTemplatesOrEmpty$1: function($function) {
      return this.methodToTemplates.putIfAbsent$2($function, new L.ConcreteTypesInferrer_getTemplatesOrEmpty_closure());
    },
    getReturnTypeOfElement$1: function(element) {
      var t1, templates, result;
      t1 = {};
      templates = this.methodToTemplates.$index(0, element);
      if (templates == null)
        return;
      t1.returnType_0 = this.emptyConcreteType;
      J.forEach$1$ax(templates, new L.ConcreteTypesInferrer_getReturnTypeOfElement_closure(t1));
      result = this.concrete_types_inferrer$ConcreteTypesInferrer$types.concreteTypeToTypeMask$1(t1.returnType_0);
      return J.$eq(result, C.C_DynamicTypeMask) ? null : result;
    },
    getTypeOfSelector$1: function(selector) {
      var t1, candidates, t2;
      t1 = {};
      candidates = this.inferredSelectorTypes.$index(0, selector.get$asUntyped());
      if (candidates == null)
        return;
      t1.result_0 = new B.FlatTypeMask(null, 0);
      t2 = J.getInterceptor$ax(candidates);
      if (selector.get$mask() == null)
        t2.forEach$1(candidates, new L.ConcreteTypesInferrer_getTypeOfSelector_closure(t1, this));
      else
        t2.forEach$1(candidates, new L.ConcreteTypesInferrer_getTypeOfSelector_closure0(t1, this, selector));
      return J.$eq(t1.result_0, C.C_DynamicTypeMask) ? null : t1.result_0;
    },
    clear$0: function(_) {
      throw H.wrapException(P.UnsupportedError$("clearing is not yet implemented"));
    },
    getSendReturnType$4: function(selector, $function, receiverType, argumentsTypes) {
      var result, argumentMap, t1, t2, receiverMask;
      result = this.emptyConcreteType;
      argumentMap = this.associateArguments$2($function, argumentsTypes);
      if (argumentMap == null)
        return this.emptyConcreteType;
      argumentMap.forEach$1(0, this.get$augmentParameterType());
      if (argumentMap._collection$_length === 0) {
        t1 = [new L.ConcreteTypesEnvironment(P.LinkedHashMap_LinkedHashMap(null, null, null, O.Element, L.ConcreteType), receiverType)];
        t2 = new H.ListIterator(t1, 1, 0, null);
        t2.$builtinTypeInfo = [H.getTypeArgumentByIndex(t1, 0)];
        t1 = t2;
      } else
        t1 = L.ConcreteTypeCartesianProductIterator$(this, receiverType, argumentMap);
      for (; t1.moveNext$0();)
        result = result.union$1(this.getMonomorphicSendReturnType$2($function, t1.get$current()));
      if (selector != null && receiverType != null) {
        t1 = this.compiler;
        t2 = t1.backend.get$numImplementation();
        if (receiverType == null ? t2 != null : receiverType !== t2) {
          t1 = t1.backend.get$intImplementation();
          t1 = receiverType == null ? t1 == null : receiverType === t1;
        } else
          t1 = true;
        receiverMask = t1 ? new B.FlatTypeMask(receiverType.get$declaration(), 4) : new B.FlatTypeMask(receiverType.get$declaration(), 2);
        this.augmentInferredSelectorType$3(selector, receiverMask, this.concrete_types_inferrer$ConcreteTypesInferrer$types.concreteTypeToTypeMask$1(result));
      }
      return result;
    },
    associateArguments$2: function($function, argumentsTypes) {
      var result, signature, t1, t2, t3, t4, t5, remainingPositionalArguments, requiredParameters, requiredParameter, remainingOptionalParameters, leftOverNamedParameters, namedParameter, source, concreteType;
      result = P.LinkedHashMap_LinkedHashMap(null, null, null, O.Element, L.ConcreteType);
      signature = $function.get$functionSignature();
      t1 = argumentsTypes.positional;
      t2 = t1.length;
      t3 = argumentsTypes.named;
      t4 = t3.get$length(t3);
      if (typeof t4 !== "number")
        return H.iae(t4);
      if (t2 + t4 > signature.get$parameterCount())
        return;
      t2 = t1.length;
      t4 = signature.requiredParameterCount;
      if (t2 < t4)
        return;
      t5 = signature.optionalParametersAreNamed;
      if (t5 && t2 > t4)
        return;
      t4 = new L.ConcreteTypesInferrer_associateArguments_handleLeftoverOptionalParameter(this, $function, result);
      remainingPositionalArguments = H.setRuntimeTypeInfo(new H.ListIterator(t1, t2, 0, null), [H.getTypeArgumentByIndex(t1, 0)]);
      for (requiredParameters = signature.requiredParameters; !requiredParameters.get$isEmpty(requiredParameters); requiredParameters = requiredParameters.get$tail()) {
        requiredParameter = requiredParameters.get$head(requiredParameters);
        remainingPositionalArguments.moveNext$0();
        result.$indexSet(0, requiredParameter, remainingPositionalArguments.__internal$_current);
      }
      remainingOptionalParameters = signature.optionalParameters;
      if (t5) {
        leftOverNamedParameters = P.LinkedHashMap_LinkedHashMap(null, null, null, P.String, O.Element);
        for (; !remainingOptionalParameters.get$isEmpty(remainingOptionalParameters); remainingOptionalParameters = remainingOptionalParameters.get$tail()) {
          namedParameter = remainingOptionalParameters.get$head(remainingOptionalParameters);
          leftOverNamedParameters.$indexSet(0, J.get$name$x(namedParameter), namedParameter);
        }
        for (t1 = J.get$iterator$ax(t3.get$keys()); t1.moveNext$0();) {
          source = t1.get$current();
          concreteType = t3.$index(0, source);
          namedParameter = leftOverNamedParameters.$index(0, source);
          if (namedParameter == null)
            return;
          result.$indexSet(0, namedParameter, concreteType);
          leftOverNamedParameters.remove$1(0, source);
        }
        leftOverNamedParameters.forEach$1(0, new L.ConcreteTypesInferrer_associateArguments_closure(t4));
      } else {
        for (; remainingPositionalArguments.moveNext$0();) {
          result.$indexSet(0, remainingOptionalParameters.get$head(remainingOptionalParameters), remainingPositionalArguments.__internal$_current);
          remainingOptionalParameters = remainingOptionalParameters.get$tail();
        }
        for (; !remainingOptionalParameters.get$isEmpty(remainingOptionalParameters); remainingOptionalParameters = remainingOptionalParameters.get$tail())
          t4.call$1(remainingOptionalParameters.get$head(remainingOptionalParameters));
      }
      return result;
    },
    getMonomorphicSendReturnType$2: function($function, environment) {
      var type, specialType, t1, t2;
      type = this.getTemplatesOrEmpty$1($function).$index(0, environment);
      specialType = this.getSpecialCaseReturnType$2($function, environment);
      if (type != null)
        return specialType != null ? specialType : type;
      else {
        t1 = new L.InferenceWorkItem($function, environment);
        t2 = this.workQueue.queue;
        if (!t2.contains$1(0, t1))
          t2._add$1(t1);
        return specialType != null ? specialType : this.emptyConcreteType;
      }
    },
    getSpecialCaseReturnType$2: function($function, environment) {
      var cls, $name, t1, parameters, t2;
      cls = environment.classOfThis;
      if (cls != null) {
        $name = $function.get$name($function);
        t1 = this.baseTypes;
        if (cls === t1.intBaseType.element || cls === t1.doubleBaseType.element)
          t1 = $name === "+" || $name === "-" || $name === "*";
        else
          t1 = false;
        if (t1) {
          parameters = $function.get$functionSignature().get$requiredParameters();
          t1 = parameters.get$head(parameters);
          if (environment.environment.$index(0, t1).getUniqueType$0() === cls)
            return L.ConcreteType_ConcreteType$singleton(this.compiler.maxConcreteTypeSize, this.baseTypes, new L.ClassBaseType(cls));
        }
      }
      t1 = this.listIndex;
      if ($function == null ? t1 != null : $function !== t1) {
        t1 = this.listRemoveAt;
        t1 = $function == null ? t1 == null : $function === t1;
      } else
        t1 = true;
      if (t1) {
        parameters = $function.get$functionSignature().get$requiredParameters();
        t1 = parameters.get$head(parameters);
        if (!environment.environment.$index(0, t1).get$baseTypes().contains$1(0, this.baseTypes.intBaseType))
          return this.emptyConcreteType;
        return this.listElementType;
      } else {
        t1 = this.listIndexSet;
        if ($function == null ? t1 != null : $function !== t1) {
          t1 = this.listInsert;
          t1 = $function == null ? t1 == null : $function === t1;
        } else
          t1 = true;
        if (t1) {
          parameters = $function.get$functionSignature().get$requiredParameters();
          t1 = parameters.get$head(parameters);
          t2 = environment.environment;
          if (!t2.$index(0, t1).get$baseTypes().contains$1(0, this.baseTypes.intBaseType))
            return this.emptyConcreteType;
          t1 = parameters.get$tail();
          this.augmentListElementType$1(t2.$index(0, t1.get$head(t1)));
          return this.emptyConcreteType;
        } else {
          t1 = this.listAdd;
          if ($function == null ? t1 == null : $function === t1) {
            parameters = $function.get$functionSignature().get$requiredParameters();
            t1 = parameters.get$head(parameters);
            this.augmentListElementType$1(environment.environment.$index(0, t1));
            return this.emptyConcreteType;
          } else {
            t1 = this.listRemoveLast;
            if ($function == null ? t1 == null : $function === t1)
              return this.listElementType;
          }
        }
      }
      return;
    },
    analyzeMethodOrClosure$2: function(element, environment) {
      var specialResult, closureEnv, t1, t2, t3, t4, t5, t6, t7, t8, visitor, locals;
      specialResult = this.handleSpecialMethod$2(element, environment);
      if (specialResult != null)
        return specialResult;
      closureEnv = this.closures.closures.$index(0, element);
      if (closureEnv == null) {
        t1 = environment.classOfThis;
        t2 = this.compiler;
        t1 = L.ConcreteType_ConcreteType$singleton(t2.maxConcreteTypeSize, this.baseTypes, new L.ClassBaseType(t1));
        environment.environment;
        t3 = new N.Setlet(C.C__SetletMarker, null);
        t3.$builtinTypeInfo = [O.Element];
        t4 = element.get$outermostEnclosingMemberOrTopLevel();
        t4 = t4.get$implementation(t4);
        t5 = this.concrete_types_inferrer$ConcreteTypesInferrer$types;
        t6 = P.LinkedHashMap_LinkedHashMap(null, null, null, O.JumpTarget, [P.List, [X.LocalsHandler, L.ConcreteType]]);
        t7 = P.LinkedHashMap_LinkedHashMap(null, null, null, O.JumpTarget, [P.List, [X.LocalsHandler, L.ConcreteType]]);
        t8 = [];
        t8.$builtinTypeInfo = [L.ConcreteType];
        visitor = new L.TypeInferrerVisitor(t1, null, false, false, false, new Z.SideEffects(0), t4, this, t3, element, t5, this, t6, t7, null, t8, false, false, null, 0, null, null, t2, element.get$resolvedAst().elements);
        visitor.InferrerVisitor$5(element, this, t5, t2, null, L.ConcreteType, [Q.InferrerEngine, L.ConcreteType, [X.TypeSystem, L.ConcreteType]]);
        visitor.run$0();
        t1 = visitor.returnType;
      } else {
        locals = closureEnv.get$locals() != null ? X.LocalsHandler$deepCopyOf(closureEnv.get$locals(), null) : null;
        t1 = closureEnv.get$thisType();
        environment.environment;
        t2 = this.compiler;
        t3 = new N.Setlet(C.C__SetletMarker, null);
        t3.$builtinTypeInfo = [O.Element];
        t4 = element.get$outermostEnclosingMemberOrTopLevel();
        t4 = t4.get$implementation(t4);
        t5 = this.concrete_types_inferrer$ConcreteTypesInferrer$types;
        t6 = P.LinkedHashMap_LinkedHashMap(null, null, null, O.JumpTarget, [P.List, [X.LocalsHandler, L.ConcreteType]]);
        t7 = P.LinkedHashMap_LinkedHashMap(null, null, null, O.JumpTarget, [P.List, [X.LocalsHandler, L.ConcreteType]]);
        t8 = [];
        t8.$builtinTypeInfo = [L.ConcreteType];
        visitor = new L.TypeInferrerVisitor(t1, null, false, false, false, new Z.SideEffects(0), t4, this, t3, element, t5, this, t6, t7, locals, t8, false, false, null, 0, null, null, t2, element.get$resolvedAst().elements);
        visitor.InferrerVisitor$5(element, this, t5, t2, locals, L.ConcreteType, [Q.InferrerEngine, L.ConcreteType, [X.TypeSystem, L.ConcreteType]]);
        visitor.run$0();
        t1 = visitor.returnType;
      }
      return t1;
    },
    ensureFieldInitialized$1: function(field) {
      if (!!J.getInterceptor(field).$isFieldElement && this.inferredFieldTypes.$index(0, field) == null)
        this.analyzeFieldInitialization$1(field);
    },
    analyzeFieldInitialization$1: function(field) {
      var t1, t2, t3, t4, t5, t6, t7, visitor, type, readers;
      P.LinkedHashMap_LinkedHashMap(null, null, null, null, null);
      t1 = this.compiler;
      t2 = new N.Setlet(C.C__SetletMarker, null);
      t2.$builtinTypeInfo = [O.Element];
      t3 = field.get$outermostEnclosingMemberOrTopLevel();
      t3 = t3.get$implementation(t3);
      t4 = this.concrete_types_inferrer$ConcreteTypesInferrer$types;
      t5 = P.LinkedHashMap_LinkedHashMap(null, null, null, O.JumpTarget, [P.List, [X.LocalsHandler, L.ConcreteType]]);
      t6 = P.LinkedHashMap_LinkedHashMap(null, null, null, O.JumpTarget, [P.List, [X.LocalsHandler, L.ConcreteType]]);
      t7 = [];
      t7.$builtinTypeInfo = [L.ConcreteType];
      visitor = new L.TypeInferrerVisitor(null, null, false, false, false, new Z.SideEffects(0), t3, this, t2, field, t4, this, t5, t6, null, t7, false, false, null, 0, null, null, t1, field.get$resolvedAst().elements);
      visitor.InferrerVisitor$5(field, this, t4, t1, null, L.ConcreteType, [Q.InferrerEngine, L.ConcreteType, [X.TypeSystem, L.ConcreteType]]);
      if (field.get$initializer() != null) {
        type = field.get$initializer().accept$1(0, visitor);
        this.inferredFieldTypes.$indexSet(0, field, type);
        readers = this.fieldReaders.$index(0, field);
        if (readers != null)
          J.forEach$1$ax(readers, this.get$invalidate());
      } else
        type = null;
      return type;
    },
    handleSpecialMethod$2: function(element, environment) {
      var t1, parameters;
      if (this.isNativeElement$1(element)) {
        element.get$type(element);
        return this.typeOfNativeBehavior$1(L.NativeBehavior_ofMethod(element, this.compiler));
      }
      t1 = this.listConstructor;
      if (element == null ? t1 == null : element === t1) {
        parameters = t1.get$functionSignature().get$optionalParameters();
        t1 = parameters.get$head(parameters);
        if (environment.environment.$index(0, t1).get$baseTypes().contains$1(0, this.baseTypes.intBaseType))
          this.augmentListElementType$1(this.nullConcreteType);
      }
      return;
    },
    analyzeMain$1: function(element) {
      var t1, jsArrayClass, t2, t3;
      t1 = this.compiler;
      this.baseTypes = L.BaseTypes$(t1);
      this.concrete_types_inferrer$ConcreteTypesInferrer$types = L.ConcreteTypeSystem_ConcreteTypeSystem(this);
      jsArrayClass = this.baseTypes.listBaseType.element;
      this.listIndex = jsArrayClass.lookupMember$1("[]");
      this.listIndexSet = jsArrayClass.lookupMember$1("[]=");
      this.listAdd = jsArrayClass.lookupMember$1("add");
      this.listRemoveAt = jsArrayClass.lookupMember$1("removeAt");
      this.listInsert = jsArrayClass.lookupMember$1("insert");
      this.listRemoveLast = jsArrayClass.lookupMember$1("removeLast");
      t2 = t1.listClass;
      t2 = t2.lookupConstructor$1(Z.Selector_Selector(C.SelectorKind_call_2, "", t2.get$library(), 0, null));
      this.listConstructor = t2.get$implementation(t2);
      t1 = t1.maxConcreteTypeSize;
      this.emptyConcreteType = new L.UnionType(t1, this.baseTypes, P.LinkedHashSet_LinkedHashSet(null, null, null, L.BaseType));
      this.nullConcreteType = L.ConcreteType_ConcreteType$singleton(t1, this.baseTypes, C.C_NullBaseType);
      this.listElementType = this.emptyConcreteType;
      t1 = this.workQueue;
      t1.add$1(0, new L.InferenceWorkItem(element, new L.ConcreteTypesEnvironment(P.LinkedHashMap_LinkedHashMap(null, null, null, O.Element, L.ConcreteType), null)));
      for (t1 = t1.queue; t1._head !== t1._tail;) {
        t2 = t1.removeFirst$0();
        this.currentWorkItem = t2;
        t2 = t2.method;
        t2 = t2.get$kind(t2);
        t3 = this.currentWorkItem;
        if (t2 === C.ElementKind_field_1)
          this.analyzeFieldInitialization$1(t3.method);
        else {
          this.getTemplatesOrEmpty$1(t3.method).putIfAbsent$2(this.currentWorkItem.environment, new L.ConcreteTypesInferrer_analyzeMain_closure(this));
          t2 = this.currentWorkItem;
          t3 = t2.method;
          this.recordReturnType$2(t3, this.analyzeMethodOrClosure$2(t3, t2.environment));
        }
      }
      return true;
    },
    addReturnTypeFor$3: function(analyzedElement, currentType, newType) {
      return currentType == null ? newType : currentType.union$1(newType);
    },
    forEachElementMatching$2: function(selector, f) {
      this.getMembersBySelector$1(selector).forEach$1(0, f);
    },
    recordReturnType$2: function(element, type) {
      var template, methodCallers;
      template = this.getTemplatesOrEmpty$1(element);
      if (!J.$eq(template.$index(0, this.currentWorkItem.environment), type)) {
        template.$indexSet(0, this.currentWorkItem.environment, type);
        methodCallers = this.callers.$index(0, element);
        if (methodCallers != null)
          J.forEach$1$ax(methodCallers, this.get$invalidate());
      }
    },
    recordType$2: function(element, type) {
      this.augmentFieldType$2(element, type);
    },
    recordTypeOfFinalField$4: function(node, nodeHolder, field, type) {
      this.augmentFieldType$2(field, type);
    },
    recordTypeOfNonFinalField$3: function(node, field, type) {
      this.augmentFieldType$2(field, type);
    },
    recordCapturedLocalRead$1: function(local) {
      this.addCapturedLocalReader$2(local, this.currentWorkItem.method);
    },
    recordLocalUpdate$2: function(local, type) {
      var localReaders = this.capturedLocalsReaders.$index(0, local);
      if (localReaders != null)
        J.forEach$1$ax(localReaders, this.get$invalidate());
    },
    getRealCaller$1: function(allegedCaller) {
      var currentMethod = this.currentWorkItem.method;
      if ((currentMethod == null ? allegedCaller != null : currentMethod !== allegedCaller) && currentMethod.get$isFunction() && this.closures.closures.containsKey$1(currentMethod))
        return currentMethod;
      else
        return allegedCaller;
    },
    registerCalledElement$7: function(node, selector, caller, callee, $arguments, sideEffects, inLoop) {
      var t1, result, t2, $function, receiverClass, enclosing, argumentType;
      caller = this.getRealCaller$1(caller);
      t1 = selector != null;
      if (!t1 || selector.kind === C.SelectorKind_call_2) {
        callee = callee.get$implementation(callee);
        if (t1 && selector.name === "JS")
          return;
        if (callee.get$isField()) {
          this.getFieldType$2(selector, callee);
          this.addFieldReader$2(callee, caller);
          result = this.emptyConcreteType;
          for (t1 = this.closures.closures, t1 = H.setRuntimeTypeInfo(new P.LinkedHashMapKeyIterable(t1), [H.getTypeArgumentByIndex(t1, 0)]), t2 = t1._map, t1 = H.setRuntimeTypeInfo(new P.LinkedHashMapKeyIterator(t2, t2._modifications, null, null), [H.getTypeArgumentByIndex(t1, 0)]), t1._cell = t1._map._first; t1.moveNext$0();) {
            $function = t1._collection$_current;
            this.addCaller$2($function, caller);
            result = result.union$1(this.getSendReturnType$4(selector, $function, null, $arguments));
          }
          return result;
        } else {
          this.addCaller$2(callee, caller);
          if (callee.kind === C.ElementKind_generative_constructor_16)
            receiverClass = callee.get$enclosingClass();
          else if (!!J.getInterceptor(node).$isSend) {
            t1 = node.receiver;
            if (t1 != null) {
              t1 = t1.isSuper$0();
              t2 = this.currentWorkItem;
              receiverClass = t1 ? t2.environment.classOfThis.get$superclass() : t2.environment.classOfThis;
            } else
              receiverClass = null;
          } else
            receiverClass = null;
          return this.getSendReturnType$4(selector, callee, receiverClass, $arguments);
        }
      } else {
        t1 = selector.kind;
        if (t1 === C.SelectorKind_getter_0) {
          if (callee.get$kind(callee) === C.ElementKind_field_1) {
            this.addFieldReader$2(callee, caller);
            return this.getFieldType$2(selector, callee);
          } else if (callee.get$isGetter()) {
            t1 = callee.get$enclosingElement();
            enclosing = t1.get$kind(t1) === C.ElementKind_compilation_unit_0 ? null : callee.get$enclosingElement();
            this.addCaller$2(callee, caller);
            return this.getSendReturnType$4(selector, callee, enclosing, X.ArgumentsTypes$([], P.LinkedHashMap_LinkedHashMap(null, null, null, null, null), null));
          } else if (callee.get$isFunction()) {
            if (this.closures.put$3(callee, null, null))
              this.invalidateCallers$1(callee);
            t1 = this.baseTypes;
            return L.ConcreteType_ConcreteType$singleton(this.compiler.maxConcreteTypeSize, t1, t1.functionBaseType);
          }
        } else if (t1 === C.SelectorKind_setter_1) {
          argumentType = C.JSArray_methods.get$first($arguments.positional);
          if (callee.get$kind(callee) === C.ElementKind_field_1)
            this.augmentFieldType$2(callee, argumentType);
          else if (callee.kind === C.ElementKind_setter_0) {
            t1 = callee.get$enclosingElement();
            enclosing = t1.get$kind(t1) === C.ElementKind_compilation_unit_0 ? null : callee.get$enclosingElement();
            return this.getSendReturnType$4(selector, callee, enclosing, X.ArgumentsTypes$([argumentType], P.LinkedHashMap_LinkedHashMap(null, null, null, null, null), null));
          }
        } else
          throw H.wrapException(P.ArgumentError$("unexpected selector kind"));
      }
      return;
    },
    registerCalledSelector$7: function(node, selector, receiverType, caller, $arguments, sideEffects, inLoop) {
      caller = this.getRealCaller$1(caller);
      switch (selector.kind) {
        case C.SelectorKind_getter_0:
          return this.registerDynamicGetterSend$3(selector, receiverType, caller);
        case C.SelectorKind_setter_1:
          return this.registerDynamicSetterSend$4(selector, receiverType, caller, $arguments);
        default:
          return this.registerDynamicSend$4(selector, receiverType, caller, $arguments);
      }
    },
    registerDynamicGetterSend$3: function(selector, receiverType, caller) {
      var t1, t2, members, t3, member, t4, t5, baseReceiverType, cls, getterOrField;
      t1 = {};
      t1.caller_0 = caller;
      t1.caller_0 = this.getRealCaller$1(caller);
      t1.result_1 = this.emptyConcreteType;
      t2 = new L.ConcreteTypesInferrer_registerDynamicGetterSend_augmentResult(t1, this, selector, receiverType);
      if (receiverType.isUnknown$0()) {
        this.addDynamicCaller$2(selector, t1.caller_0);
        members = this.getMembersBySelector$1(selector);
        for (t3 = H.setRuntimeTypeInfo(new P.LinkedHashSetIterator(members, members._modifications, null, null), [null]), t3._cell = t3._set._first; t3.moveNext$0();) {
          member = t3._collection$_current;
          if (!(J.get$kind$x(member) === C.ElementKind_field_1 || member.get$isGetter()))
            continue;
          t4 = this.getReflexiveSubtypesOf$1(member.get$enclosingElement());
          t5 = new P.LinkedHashSetIterator(t4, t4._modifications, null, null);
          t5.$builtinTypeInfo = [null];
          t5._cell = t4._first;
          for (; t5.moveNext$0();)
            t2.call$2(t5._collection$_current, member);
        }
      } else
        for (t3 = receiverType.get$baseTypes(), t3 = t3.get$iterator(t3), t4 = this.compiler; t3.moveNext$0();) {
          baseReceiverType = t3.get$current();
          if (!baseReceiverType.isNull$0()) {
            cls = baseReceiverType.get$element();
            getterOrField = cls.lookupSelector$2(selector, t4);
            if (getterOrField != null)
              t2.call$2(cls, getterOrField.get$implementation(getterOrField));
          }
        }
      return t1.result_1;
    },
    registerDynamicSetterSend$4: function(selector, receiverType, caller, $arguments) {
      var argumentType, t1, t2, member, t3, baseReceiverType, cls, setterOrField;
      this.getRealCaller$1(caller);
      argumentType = C.JSArray_methods.get$first($arguments.positional);
      t1 = new L.ConcreteTypesInferrer_registerDynamicSetterSend_augmentField(this, selector, argumentType);
      if (receiverType.isUnknown$0())
        for (t2 = this.getMembersBySelector$1(selector), t2 = H.setRuntimeTypeInfo(new P.LinkedHashSetIterator(t2, t2._modifications, null, null), [null]), t2._cell = t2._set._first; t2.moveNext$0();) {
          member = t2._collection$_current;
          t3 = J.getInterceptor$x(member);
          if (!(t3.get$kind(member) === C.ElementKind_field_1 || t3.get$kind(member) === C.ElementKind_setter_0))
            continue;
          t1.call$2(member.get$enclosingClass(), member);
        }
      else
        for (t2 = receiverType.get$baseTypes(), t2 = t2.get$iterator(t2), t3 = this.compiler; t2.moveNext$0();) {
          baseReceiverType = t2.get$current();
          if (!baseReceiverType.isNull$0()) {
            cls = baseReceiverType.get$element();
            setterOrField = cls.lookupSelector$2(selector, t3);
            if (setterOrField != null)
              t1.call$2(cls, setterOrField.get$implementation(setterOrField));
          }
        }
      return argumentType;
    },
    registerDynamicSend$4: function(selector, receiverType, caller, $arguments) {
      var result, elements, t1, t2, element, t3, t4, $function, baseReceiverType, cls, method, t5;
      caller = this.getRealCaller$1(caller);
      result = this.emptyConcreteType;
      if (receiverType.isUnknown$0()) {
        this.addDynamicCaller$2(selector, caller);
        elements = this.getMembersBySelector$1(selector);
        for (t1 = H.setRuntimeTypeInfo(new P.LinkedHashSetIterator(elements, elements._modifications, null, null), [null]), t1._cell = t1._set._first, t2 = this.closures.closures; t1.moveNext$0();) {
          element = t1._collection$_current;
          if (element.get$isFunction()) {
            this.addCaller$2(element, caller);
            t3 = this.getReflexiveSubtypesOf$1(element.get$enclosingElement());
            t4 = new P.LinkedHashSetIterator(t3, t3._modifications, null, null);
            t4.$builtinTypeInfo = [null];
            t4._cell = t3._first;
            for (; t4.moveNext$0();)
              result = result.union$1(this.getSendReturnType$4(selector, element, t4._collection$_current, $arguments));
          } else {
            t3 = new P.LinkedHashMapKeyIterable(t2);
            t3.$builtinTypeInfo = [H.getTypeArgumentByIndex(t2, 0)];
            t4 = new P.LinkedHashMapKeyIterator(t2, t2._modifications, null, null);
            t4.$builtinTypeInfo = [H.getTypeArgumentByIndex(t3, 0)];
            t4._cell = t2._first;
            for (; t4.moveNext$0();) {
              $function = t4._collection$_current;
              this.addCaller$2($function, caller);
              result = result.union$1(this.getSendReturnType$4(selector, $function, null, $arguments));
            }
          }
        }
      } else
        for (t1 = receiverType.get$baseTypes(), t1 = t1.get$iterator(t1), t2 = this.compiler, t3 = this.closures.closures; t1.moveNext$0();) {
          baseReceiverType = t1.get$current();
          if (!baseReceiverType.isNull$0()) {
            cls = baseReceiverType.get$element();
            method = cls.lookupSelector$2(selector, t2);
            if (method != null)
              if (method.get$isFunction()) {
                method = method.get$implementation(method);
                this.addCaller$2(method, caller);
                result = result.union$1(this.getSendReturnType$4(selector, method, cls, $arguments));
              } else {
                t4 = new P.LinkedHashMapKeyIterable(t3);
                t4.$builtinTypeInfo = [H.getTypeArgumentByIndex(t3, 0)];
                t5 = new P.LinkedHashMapKeyIterator(t3, t3._modifications, null, null);
                t5.$builtinTypeInfo = [H.getTypeArgumentByIndex(t4, 0)];
                t5._cell = t3._first;
                for (; t5.moveNext$0();) {
                  $function = t5._collection$_current;
                  this.addCaller$2($function, caller);
                  result = result.union$1(this.getSendReturnType$4(selector, $function, null, $arguments));
                }
              }
          }
        }
      return result;
    },
    setDefaultTypeOfParameter$2: function(parameter, type) {
    },
    registerCalledClosure$7: function(node, selector, closure, caller, $arguments, sideEffects, inLoop) {
      var result, t1, t2, $function;
      caller = this.getRealCaller$1(caller);
      result = this.emptyConcreteType;
      for (t1 = this.closures.closures, t1 = H.setRuntimeTypeInfo(new P.LinkedHashMapKeyIterable(t1), [H.getTypeArgumentByIndex(t1, 0)]), t2 = t1._map, t1 = H.setRuntimeTypeInfo(new P.LinkedHashMapKeyIterator(t2, t2._modifications, null, null), [H.getTypeArgumentByIndex(t1, 0)]), t1._cell = t1._map._first; t1.moveNext$0();) {
        $function = t1._collection$_current;
        this.addCaller$2($function, caller);
        result = result.union$1(this.getSendReturnType$4(selector, $function, null, $arguments));
      }
      return result;
    },
    returnTypeOfElement$1: function(element) {
      throw H.wrapException(P.UnsupportedError$(""));
    },
    typeOfElement$1: function(element) {
      var t1, result;
      t1 = this.currentWorkItem;
      if (t1 != null) {
        result = t1.environment.environment.$index(0, element);
        if (result != null)
          return result;
      }
      t1 = J.getInterceptor$x(element);
      if (t1.get$kind(element) === C.ElementKind_parameter_1 || t1.get$kind(element) === C.ElementKind_initializing_formal_1)
        return this.inferredParameterTypes.$index(0, element);
      else if (t1.get$kind(element) === C.ElementKind_field_1)
        return this.inferredFieldTypes.$index(0, element);
      throw H.wrapException(P.ArgumentError$("unexpected element type"));
    },
    analyze$2: function(element, $arguments) {
      this.getSendReturnType$4(null, element, this.currentWorkItem.environment.classOfThis, $arguments);
    },
    $asInferrerEngine: function() {
      return [L.ConcreteType, L.ConcreteTypeSystem];
    }
  },
  ConcreteTypesInferrer_augmentInferredSelectorType_closure: {
    "^": "Closure:23;",
    call$0: function() {
      return P.LinkedHashMap_LinkedHashMap(null, null, null, B.TypeMask, B.TypeMask);
    },
    $isFunction: true
  },
  ConcreteTypesInferrer_augmentSeenClasses_closure: {
    "^": "Closure:48;this_0",
    call$2: function(_, member) {
      var t1, functions;
      t1 = this.this_0;
      functions = t1.dynamicCallers.$index(0, J.get$name$x(member));
      if (functions != null)
        J.forEach$1$ax(functions, t1.get$invalidate());
    },
    $isFunction: true
  },
  ConcreteTypesInferrer_addCaller_closure: {
    "^": "Closure:23;",
    call$0: function() {
      return P.LinkedHashSet_LinkedHashSet(null, null, null, O.Element);
    },
    $isFunction: true
  },
  ConcreteTypesInferrer_addDynamicCaller_closure: {
    "^": "Closure:23;",
    call$0: function() {
      return P.LinkedHashSet_LinkedHashSet(null, null, null, O.FunctionElement);
    },
    $isFunction: true
  },
  ConcreteTypesInferrer_addFieldReader_closure: {
    "^": "Closure:23;",
    call$0: function() {
      return P.LinkedHashSet_LinkedHashSet(null, null, null, O.Element);
    },
    $isFunction: true
  },
  ConcreteTypesInferrer_addCapturedLocalReader_closure: {
    "^": "Closure:23;",
    call$0: function() {
      return P.LinkedHashSet_LinkedHashSet(null, null, null, O.FunctionElement);
    },
    $isFunction: true
  },
  ConcreteTypesInferrer_invalidate_closure: {
    "^": "Closure:19;this_0,methodOrField_1",
    call$2: function(environment, _) {
      this.this_0.workQueue.add$1(0, new L.InferenceWorkItem(this.methodOrField_1, environment));
    },
    $isFunction: true
  },
  ConcreteTypesInferrer_getTemplatesOrEmpty_closure: {
    "^": "Closure:23;",
    call$0: function() {
      return P.LinkedHashMap_LinkedHashMap(null, null, null, L.ConcreteTypesEnvironment, L.ConcreteType);
    },
    $isFunction: true
  },
  ConcreteTypesInferrer_getReturnTypeOfElement_closure: {
    "^": "Closure:19;box_0",
    call$2: function(_, concreteType) {
      var t1 = this.box_0;
      t1.returnType_0 = t1.returnType_0.union$1(concreteType);
    },
    $isFunction: true
  },
  ConcreteTypesInferrer_getTypeOfSelector_closure: {
    "^": "Closure:49;box_0,this_1",
    call$2: function(receiverType, returnType) {
      var t1 = this.box_0;
      t1.result_0 = this.this_1.typeMaskUnion$2(t1.result_0, returnType);
    },
    $isFunction: true
  },
  ConcreteTypesInferrer_getTypeOfSelector_closure0: {
    "^": "Closure:49;box_0,this_2,selector_3",
    call$2: function(receiverType, returnType) {
      var t1, intersection, t2;
      t1 = this.this_2;
      intersection = J.intersection$2$x(receiverType, this.selector_3.get$mask(), t1.compiler);
      if (!intersection.get$isEmpty(intersection) || intersection.get$isNullable()) {
        t2 = this.box_0;
        t2.result_0 = t1.typeMaskUnion$2(t2.result_0, returnType);
      }
    },
    $isFunction: true
  },
  ConcreteTypesInferrer_associateArguments_handleLeftoverOptionalParameter: {
    "^": "Closure:50;this_0,function_1,result_2",
    call$1: function(parameter) {
      var initializer, t1, t2, t3, t4, t5, t6, visitor;
      initializer = parameter.get$initializer();
      t1 = this.this_0;
      if (initializer == null)
        t1 = t1.nullConcreteType;
      else {
        t2 = this.function_1;
        P.LinkedHashMap_LinkedHashMap$_empty(null, null);
        t3 = t1.compiler;
        t4 = H.setRuntimeTypeInfo(new N.Setlet(C.C__SetletMarker, null), [O.Element]);
        t5 = t2.get$outermostEnclosingMemberOrTopLevel();
        t5 = t5.get$implementation(t5);
        t6 = t1.concrete_types_inferrer$ConcreteTypesInferrer$types;
        visitor = new L.TypeInferrerVisitor(null, null, false, false, false, new Z.SideEffects(0), t5, t1, t4, t2, t6, t1, P.LinkedHashMap_LinkedHashMap(null, null, null, O.JumpTarget, [P.List, [X.LocalsHandler, L.ConcreteType]]), P.LinkedHashMap_LinkedHashMap(null, null, null, O.JumpTarget, [P.List, [X.LocalsHandler, L.ConcreteType]]), null, H.setRuntimeTypeInfo([], [L.ConcreteType]), false, false, null, 0, null, null, t3, t2.get$resolvedAst().elements);
        visitor.InferrerVisitor$5(t2, t1, t6, t3, null, L.ConcreteType, [Q.InferrerEngine, L.ConcreteType, [X.TypeSystem, L.ConcreteType]]);
        visitor.SimpleTypeInferrerVisitor$internal$5(t2, t5, t1, t3, null, L.ConcreteType);
        t3 = initializer.accept$1(0, visitor);
        t1 = t3;
      }
      this.result_2.$indexSet(0, parameter, t1);
    },
    $isFunction: true
  },
  ConcreteTypesInferrer_associateArguments_closure: {
    "^": "Closure:48;handleLeftoverOptionalParameter_3",
    call$2: function(_, parameter) {
      this.handleLeftoverOptionalParameter_3.call$1(parameter);
    },
    $isFunction: true
  },
  ConcreteTypesInferrer_analyzeMain_closure: {
    "^": "Closure:23;this_0",
    call$0: function() {
      return this.this_0.emptyConcreteType;
    },
    $isFunction: true
  },
  ConcreteTypesInferrer_registerDynamicGetterSend_augmentResult: {
    "^": "Closure:51;box_0,this_1,selector_2,receiverType_3",
    call$2: function(baseReceiverType, member) {
      var t1, t2, noArguments, t3, t4;
      if (member.get$kind(member) === C.ElementKind_field_1) {
        t1 = this.this_1;
        t2 = this.box_0;
        t1.addFieldReader$2(member, t2.caller_0);
        t2.result_1 = t2.result_1.union$1(t1.getFieldType$2(this.selector_2, member));
      } else if (member.get$isGetter()) {
        t1 = this.this_1;
        t2 = this.box_0;
        t1.addCaller$2(member, t2.caller_0);
        noArguments = X.ArgumentsTypes$([], P.LinkedHashMap_LinkedHashMap(null, null, null, null, null), null);
        t2.result_1 = t2.result_1.union$1(t1.getSendReturnType$4(this.selector_2, member, baseReceiverType, noArguments));
      } else if (member.get$isFunction()) {
        t1 = this.this_1;
        if (t1.closures.put$3(member, this.receiverType_3, null))
          t1.invalidateCallers$1(member);
        t2 = this.box_0;
        t3 = t2.result_1;
        t4 = t1.baseTypes;
        t2.result_1 = t3.union$1(L.ConcreteType_ConcreteType$singleton(t1.compiler.maxConcreteTypeSize, t4, t4.functionBaseType));
      } else
        throw H.wrapException(P.ArgumentError$("unexpected element type"));
    },
    $isFunction: true
  },
  ConcreteTypesInferrer_registerDynamicSetterSend_augmentField: {
    "^": "Closure:51;this_0,selector_1,argumentType_2",
    call$2: function(receiverType, setterOrField) {
      if (setterOrField.get$isField())
        this.this_0.augmentFieldType$2(setterOrField, this.argumentType_2);
      else if (setterOrField.kind === C.ElementKind_setter_0)
        this.this_0.getSendReturnType$4(this.selector_1, setterOrField, receiverType, X.ArgumentsTypes$([this.argumentType_2], P.LinkedHashMap_LinkedHashMap(null, null, null, null, null), null));
      else
        throw H.wrapException(P.ArgumentError$("unexpected element type"));
    },
    $isFunction: true
  },
  TypeInferrerVisitor: {
    "^": "SimpleTypeInferrerVisitor;thisType<,returnType,visitingInitializers,isConstructorRedirect,seenSuperConstructorCall,sideEffects,outermostElement,simple_types_inferrer$SimpleTypeInferrerVisitor$inferrer,capturedVariables,analyzedElement,types,inferrer,breaksFor,continuesFor,locals,cascadeReceiverStack,accumulateIsChecks,conditionIsSimple,isChecks,loopLevel,_thisType,_superType,compiler,elements",
    get$inferrer: function() {
      return this.simple_types_inferrer$SimpleTypeInferrerVisitor$inferrer;
    },
    visitFunctionExpression$1: function(node) {
      var element, t1, t2;
      this.elements.toString;
      element = node.get$_secret_tree_element$_element();
      t1 = this.simple_types_inferrer$SimpleTypeInferrerVisitor$inferrer;
      t2 = X.LocalsHandler$deepCopyOf(this.locals, null);
      if (t1.get$closures().put$3(element, this.thisType, t2))
        t1.invalidateCallers$1(element);
      return this.types.get$functionType();
    },
    visitLiteralString$1: function(node) {
      if (this.simple_types_inferrer$SimpleTypeInferrerVisitor$inferrer.get$testMode() && node.dartString.slowToString$0() === "__dynamic_for_test")
        return this.simple_types_inferrer$SimpleTypeInferrerVisitor$inferrer.get$unknownConcreteType();
      return X.InferrerVisitor.prototype.visitLiteralString$1.call(this, node);
    },
    visitLiteralList$1: function(node) {
      var t1, t2, elementType, $length, element, type, containerType;
      for (t1 = node.get$elements(node).nodes, t1.toString, t1 = H.setRuntimeTypeInfo(new E.LinkIterator(null, t1), [H.getTypeArgumentByIndex(t1, 0)]), t2 = this.types, elementType = null, $length = 0; t1.moveNext$0();) {
        element = t1._util_implementation$_current;
        type = element == null ? null : J.accept$1$x(element, this);
        elementType = elementType == null ? t2.allocatePhi$3(null, null, type) : t2.addPhiInput$3(null, elementType, type);
        ++$length;
      }
      elementType = elementType == null ? t2.nonNullEmpty$0() : t2.simplifyPhi$3(null, null, elementType);
      containerType = node.constKeyword != null ? t2.get$constListType() : t2.get$growableListType();
      return t2.allocateList$5(containerType, node, this.outermostElement, elementType, $length);
    },
    visitGetterSend$1: function(node) {
      var element, type, t1, currentType, t2;
      if (this.simple_types_inferrer$SimpleTypeInferrerVisitor$inferrer.get$testMode()) {
        this.elements.toString;
        element = node.get$_secret_tree_element$_element();
        if (!!J.getInterceptor(element).$isLocal) {
          type = this.locals.use$1(element);
          if (type != null) {
            t1 = this.simple_types_inferrer$SimpleTypeInferrerVisitor$inferrer;
            currentType = t1.get$inferredTypes().$index(0, node);
            t2 = currentType == null ? type : currentType.union$1(type);
            t1.inferredTypes.$indexSet(0, node, t2);
          }
        }
      }
      return Q.SimpleTypeInferrerVisitor.prototype.visitGetterSend$1.call(this, node);
    },
    $asSimpleTypeInferrerVisitor: function() {
      return [L.ConcreteType];
    },
    $asInferrerVisitor: function() {
      return [L.ConcreteType, [Q.InferrerEngine, L.ConcreteType, [X.TypeSystem, L.ConcreteType]]];
    },
    $asResolvedVisitor: function() {
      return [L.ConcreteType];
    },
    $asVisitor: function() {
      return [L.ConcreteType];
    }
  }
}],
["const_expression", "package:compiler/implementation/cps_ir/const_expression.dart", , M, {
  "^": "",
  ConstExp: {
    "^": "Object;"
  },
  PrimitiveConstExp: {
    "^": "ConstExp;constant<",
    accept$1: function(_, visitor) {
      return visitor.visitPrimitive$1(this);
    }
  },
  ListConstExp: {
    "^": "ConstExp;type>,values>",
    accept$1: function(_, visitor) {
      return visitor.visitList$1(this);
    }
  },
  MapConstExp: {
    "^": "ConstExp;type>,keys<,values>",
    accept$1: function(_, visitor) {
      return visitor.visitMap$1(this);
    }
  },
  ConstructorConstExp: {
    "^": "ConstExp;type>,target>,selector<,arguments<",
    accept$1: function(_, visitor) {
      return visitor.visitConstructor$1(this);
    }
  },
  ConcatenateConstExp: {
    "^": "ConstExp;arguments<",
    accept$1: function(_, visitor) {
      return visitor.visitConcatenate$1(this);
    }
  },
  SymbolConstExp: {
    "^": "ConstExp;name>",
    accept$1: function(_, visitor) {
      return visitor.visitSymbol$1(this);
    }
  },
  TypeConstExp: {
    "^": "ConstExp;type>",
    accept$1: function(_, visitor) {
      return visitor.visitType$1(this);
    },
    TypeConstExp$1: function(type) {
    }
  },
  VariableConstExp: {
    "^": "ConstExp;element<",
    accept$1: function(_, visitor) {
      return visitor.visitVariable$1(this);
    }
  },
  FunctionConstExp: {
    "^": "ConstExp;element<",
    accept$1: function(_, visitor) {
      return visitor.visitFunction$1(this);
    }
  },
  ConstExpVisitor: {
    "^": "Object;",
    visit$1: [function(constant) {
      return J.accept$1$x(constant, this);
    }, "call$1", "get$visit", 2, 0, function() {
      return H.computeSignature(function(T) {
        return {func: "T__ConstExp", ret: T, args: [M.ConstExp]};
      }, this.$receiver, "ConstExpVisitor");
    }]
  },
  ConstDeclaration: {
    "^": "Object;element<,expression<"
  }
}],
["copy_propagator", "package:compiler/implementation/dart_backend/copy_propagator.dart", , E, {
  "^": "",
  CopyPropagator: {
    "^": "RecursiveVisitor;move,inverseMove,functionElement",
    visitFunctionDefinition$1: function($function) {
      var t1, i, param, replacement;
      $function.body = $function.body.accept$1(0, this);
      t1 = $function.parameters;
      H.IterableMixinWorkaround_forEach(t1, this.get$visitVariable());
      for (i = 0; i < t1.length; ++i) {
        param = t1[i];
        replacement = this.copyPropagateVariable$1(param);
        replacement.element = param.element;
        if (i >= t1.length)
          return H.ioore(t1, i);
        t1[i] = replacement;
      }
    },
    visitBasicBlock$1: function(node) {
      node = node.accept$1(0, this);
      this.move.clear$0(0);
      this.inverseMove.clear$0(0);
      return node;
    },
    visitVariable$1: [function(variable) {
      var movingAssignment = this.inverseMove.remove$1(0, variable);
      if (movingAssignment != null)
        this.move.remove$1(0, movingAssignment.get$definition());
    }, "call$1", "get$visitVariable", 2, 0, 52],
    copyPropagateVariable$1: function(v) {
      var movingAssign, w;
      movingAssign = this.move.$index(0, v);
      if (movingAssign != null) {
        w = movingAssign.variable;
        movingAssign.definition = w;
        ++w.writeCount;
        ++w.readCount;
        return w;
      }
      return v;
    },
    visitAssign$1: function(node) {
      var t1;
      node.next = node.next.accept$1(0, this);
      node.variable = this.copyPropagateVariable$1(node.variable);
      node.definition.accept$1(0, this);
      this.visitVariable$1(node.variable);
      t1 = node.definition;
      if (!!J.getInterceptor(t1).$isVariable)
        if (t1.get$readCount() === 1 && node.variable.host.element === this.functionElement) {
          this.move.$indexSet(0, node.definition, node);
          this.inverseMove.$indexSet(0, node.variable, node);
        }
      return node;
    },
    visitLabeledStatement$1: function(node) {
      node.next = this.visitBasicBlock$1(node.next);
      node.body = node.body.accept$1(0, this);
      return node;
    },
    visitReturn$1: function(node) {
      node.get$value(node).accept$1(0, this);
      return node;
    },
    visitBreak$1: function(node) {
      return node;
    },
    visitContinue$1: function(node) {
      return node;
    },
    visitIf$1: function(node) {
      node.get$condition().accept$1(0, this);
      node.thenStatement = this.visitBasicBlock$1(node.get$thenStatement());
      node.elseStatement = this.visitBasicBlock$1(node.elseStatement);
      return node;
    },
    visitWhileTrue$1: function(node) {
      node.body = this.visitBasicBlock$1(node.body);
      return node;
    },
    visitWhileCondition$1: function(node) {
      throw H.wrapException("WhileCondition before LoopRewriter");
    },
    visitFunctionDeclaration$1: function(node) {
      var t1, t2;
      t1 = new E.CopyPropagator(P.LinkedHashMap_LinkedHashMap$_empty(M.Variable, M.Assign), P.LinkedHashMap_LinkedHashMap$_empty(M.Variable, M.Assign), null);
      t2 = node.definition;
      t1.functionElement = t2.element;
      t1.visitFunctionDefinition$1(t2);
      node.next = node.next.accept$1(0, this);
      node.variable = this.copyPropagateVariable$1(node.variable);
      return node;
    },
    visitExpressionStatement$1: function(node) {
      node.next = node.next.accept$1(0, this);
      node.expression.accept$1(0, this);
      return node;
    },
    visitFunctionExpression$1: function(node) {
      var t1, t2;
      t1 = new E.CopyPropagator(P.LinkedHashMap_LinkedHashMap$_empty(M.Variable, M.Assign), P.LinkedHashMap_LinkedHashMap$_empty(M.Variable, M.Assign), null);
      t2 = node.definition;
      t1.functionElement = t2.element;
      t1.visitFunctionDefinition$1(t2);
    }
  }
}],
["dart._internal", "dart:_internal", , H, {
  "^": "",
  IterableElementError_noElement: function() {
    return new P.StateError("No element");
  },
  IterableElementError_tooMany: function() {
    return new P.StateError("Too many elements");
  },
  IterableElementError_tooFew: function() {
    return new P.StateError("Too few elements");
  },
  Lists_copy: function(src, srcStart, dst, dstStart, count) {
    var i, j, t1, t2;
    if (srcStart < dstStart)
      for (i = srcStart + count - 1, j = dstStart + count - 1, t1 = J.getInterceptor$asx(src); i >= srcStart; --i, --j)
        C.JSArray_methods.$indexSet(dst, j, t1.$index(src, i));
    else
      for (t1 = srcStart + count, t2 = J.getInterceptor$asx(src), j = dstStart, i = srcStart; i < t1; ++i, ++j)
        C.JSArray_methods.$indexSet(dst, j, t2.$index(src, i));
  },
  Lists_indexOf: function(a, element, startIndex, endIndex) {
    var i;
    if (startIndex >= a.length)
      return -1;
    for (i = startIndex; i < endIndex; ++i) {
      if (i >= a.length)
        return H.ioore(a, i);
      if (J.$eq(a[i], element))
        return i;
    }
    return -1;
  },
  Sort__doSort: function(a, left, right, compare) {
    if (right - left <= 32)
      H.Sort__insertionSort(a, left, right, compare);
    else
      H.Sort__dualPivotQuicksort(a, left, right, compare);
  },
  Sort__insertionSort: function(a, left, right, compare) {
    var i, t1, el, j, j0;
    for (i = left + 1, t1 = J.getInterceptor$asx(a); i <= right; ++i) {
      el = t1.$index(a, i);
      j = i;
      while (true) {
        if (!(j > left && J.$gt$n(compare.call$2(t1.$index(a, j - 1), el), 0)))
          break;
        j0 = j - 1;
        t1.$indexSet(a, j, t1.$index(a, j0));
        j = j0;
      }
      t1.$indexSet(a, j, el);
    }
  },
  Sort__dualPivotQuicksort: function(a, left, right, compare) {
    var sixth, index1, index5, index3, index2, index4, t1, el1, el2, el3, el4, el5, t0, less, great, k, ak, comp, t2, great0, less0, pivots_are_equal;
    sixth = C.JSInt_methods._tdivFast$1(right - left + 1, 6);
    index1 = left + sixth;
    index5 = right - sixth;
    index3 = C.JSInt_methods._tdivFast$1(left + right, 2);
    index2 = index3 - sixth;
    index4 = index3 + sixth;
    t1 = J.getInterceptor$asx(a);
    el1 = t1.$index(a, index1);
    el2 = t1.$index(a, index2);
    el3 = t1.$index(a, index3);
    el4 = t1.$index(a, index4);
    el5 = t1.$index(a, index5);
    if (J.$gt$n(compare.call$2(el1, el2), 0)) {
      t0 = el2;
      el2 = el1;
      el1 = t0;
    }
    if (J.$gt$n(compare.call$2(el4, el5), 0)) {
      t0 = el5;
      el5 = el4;
      el4 = t0;
    }
    if (J.$gt$n(compare.call$2(el1, el3), 0)) {
      t0 = el3;
      el3 = el1;
      el1 = t0;
    }
    if (J.$gt$n(compare.call$2(el2, el3), 0)) {
      t0 = el3;
      el3 = el2;
      el2 = t0;
    }
    if (J.$gt$n(compare.call$2(el1, el4), 0)) {
      t0 = el4;
      el4 = el1;
      el1 = t0;
    }
    if (J.$gt$n(compare.call$2(el3, el4), 0)) {
      t0 = el4;
      el4 = el3;
      el3 = t0;
    }
    if (J.$gt$n(compare.call$2(el2, el5), 0)) {
      t0 = el5;
      el5 = el2;
      el2 = t0;
    }
    if (J.$gt$n(compare.call$2(el2, el3), 0)) {
      t0 = el3;
      el3 = el2;
      el2 = t0;
    }
    if (J.$gt$n(compare.call$2(el4, el5), 0)) {
      t0 = el5;
      el5 = el4;
      el4 = t0;
    }
    t1.$indexSet(a, index1, el1);
    t1.$indexSet(a, index3, el3);
    t1.$indexSet(a, index5, el5);
    t1.$indexSet(a, index2, t1.$index(a, left));
    t1.$indexSet(a, index4, t1.$index(a, right));
    less = left + 1;
    great = right - 1;
    if (J.$eq(compare.call$2(el2, el4), 0)) {
      for (k = less; k <= great; ++k) {
        ak = t1.$index(a, k);
        comp = compare.call$2(ak, el2);
        t2 = J.getInterceptor(comp);
        if (t2.$eq(comp, 0))
          continue;
        if (t2.$lt(comp, 0)) {
          if (k !== less) {
            t1.$indexSet(a, k, t1.$index(a, less));
            t1.$indexSet(a, less, ak);
          }
          ++less;
        } else
          for (; true;) {
            comp = compare.call$2(t1.$index(a, great), el2);
            t2 = J.getInterceptor$n(comp);
            if (t2.$gt(comp, 0)) {
              --great;
              continue;
            } else {
              great0 = great - 1;
              if (t2.$lt(comp, 0)) {
                t1.$indexSet(a, k, t1.$index(a, less));
                less0 = less + 1;
                t1.$indexSet(a, less, t1.$index(a, great));
                t1.$indexSet(a, great, ak);
                great = great0;
                less = less0;
                break;
              } else {
                t1.$indexSet(a, k, t1.$index(a, great));
                t1.$indexSet(a, great, ak);
                great = great0;
                break;
              }
            }
          }
      }
      pivots_are_equal = true;
    } else {
      for (k = less; k <= great; ++k) {
        ak = t1.$index(a, k);
        if (J.$lt$n(compare.call$2(ak, el2), 0)) {
          if (k !== less) {
            t1.$indexSet(a, k, t1.$index(a, less));
            t1.$indexSet(a, less, ak);
          }
          ++less;
        } else if (J.$gt$n(compare.call$2(ak, el4), 0))
          for (; true;)
            if (J.$gt$n(compare.call$2(t1.$index(a, great), el4), 0)) {
              --great;
              if (great < k)
                break;
              continue;
            } else {
              great0 = great - 1;
              if (J.$lt$n(compare.call$2(t1.$index(a, great), el2), 0)) {
                t1.$indexSet(a, k, t1.$index(a, less));
                less0 = less + 1;
                t1.$indexSet(a, less, t1.$index(a, great));
                t1.$indexSet(a, great, ak);
                great = great0;
                less = less0;
              } else {
                t1.$indexSet(a, k, t1.$index(a, great));
                t1.$indexSet(a, great, ak);
                great = great0;
              }
              break;
            }
      }
      pivots_are_equal = false;
    }
    t2 = less - 1;
    t1.$indexSet(a, left, t1.$index(a, t2));
    t1.$indexSet(a, t2, el2);
    t2 = great + 1;
    t1.$indexSet(a, right, t1.$index(a, t2));
    t1.$indexSet(a, t2, el4);
    H.Sort__doSort(a, left, less - 2, compare);
    H.Sort__doSort(a, great + 2, right, compare);
    if (pivots_are_equal)
      return;
    if (less < index1 && great > index5) {
      for (; J.$eq(compare.call$2(t1.$index(a, less), el2), 0);)
        ++less;
      for (; J.$eq(compare.call$2(t1.$index(a, great), el4), 0);)
        --great;
      for (k = less; k <= great; ++k) {
        ak = t1.$index(a, k);
        if (J.$eq(compare.call$2(ak, el2), 0)) {
          if (k !== less) {
            t1.$indexSet(a, k, t1.$index(a, less));
            t1.$indexSet(a, less, ak);
          }
          ++less;
        } else if (J.$eq(compare.call$2(ak, el4), 0))
          for (; true;)
            if (J.$eq(compare.call$2(t1.$index(a, great), el4), 0)) {
              --great;
              if (great < k)
                break;
              continue;
            } else {
              great0 = great - 1;
              if (J.$lt$n(compare.call$2(t1.$index(a, great), el2), 0)) {
                t1.$indexSet(a, k, t1.$index(a, less));
                less0 = less + 1;
                t1.$indexSet(a, less, t1.$index(a, great));
                t1.$indexSet(a, great, ak);
                great = great0;
                less = less0;
              } else {
                t1.$indexSet(a, k, t1.$index(a, great));
                t1.$indexSet(a, great, ak);
                great = great0;
              }
              break;
            }
      }
      H.Sort__doSort(a, less, great, compare);
    } else
      H.Sort__doSort(a, less, great, compare);
  },
  Symbol_getName: function(symbol) {
    return symbol.get$_name();
  },
  ListIterable: {
    "^": "IterableBase;",
    get$iterator: function(_) {
      return H.setRuntimeTypeInfo(new H.ListIterator(this, this.get$length(this), 0, null), [H.getRuntimeTypeArgument(this, "ListIterable", 0)]);
    },
    forEach$1: function(_, action) {
      var $length, i;
      $length = this.get$length(this);
      for (i = 0; i < $length; ++i) {
        action.call$1(this.elementAt$1(0, i));
        if ($length !== this.get$length(this))
          throw H.wrapException(P.ConcurrentModificationError$(this));
      }
    },
    get$isEmpty: function(_) {
      return this.get$length(this) === 0;
    },
    get$first: function(_) {
      if (this.get$length(this) === 0)
        throw H.wrapException(H.IterableElementError_noElement());
      return this.elementAt$1(0, 0);
    },
    get$last: function(_) {
      if (this.get$length(this) === 0)
        throw H.wrapException(H.IterableElementError_noElement());
      return this.elementAt$1(0, this.get$length(this) - 1);
    },
    get$single: function(_) {
      if (this.get$length(this) === 0)
        throw H.wrapException(H.IterableElementError_noElement());
      if (this.get$length(this) > 1)
        throw H.wrapException(H.IterableElementError_tooMany());
      return this.elementAt$1(0, 0);
    },
    contains$1: function(_, element) {
      var $length, i;
      $length = this.get$length(this);
      for (i = 0; i < $length; ++i) {
        if (J.$eq(this.elementAt$1(0, i), element))
          return true;
        if ($length !== this.get$length(this))
          throw H.wrapException(P.ConcurrentModificationError$(this));
      }
      return false;
    },
    every$1: function(_, test) {
      var $length, i;
      $length = this.get$length(this);
      for (i = 0; i < $length; ++i) {
        if (test.call$1(this.elementAt$1(0, i)) !== true)
          return false;
        if ($length !== this.get$length(this))
          throw H.wrapException(P.ConcurrentModificationError$(this));
      }
      return true;
    },
    any$1: function(_, test) {
      var $length, i;
      $length = this.get$length(this);
      for (i = 0; i < $length; ++i) {
        if (test.call$1(this.elementAt$1(0, i)) === true)
          return true;
        if ($length !== this.get$length(this))
          throw H.wrapException(P.ConcurrentModificationError$(this));
      }
      return false;
    },
    join$1: function(_, separator) {
      var $length, first, buffer, i, str;
      $length = this.get$length(this);
      if (separator.length !== 0) {
        if ($length === 0)
          return "";
        first = H.S(this.elementAt$1(0, 0));
        if ($length !== this.get$length(this))
          throw H.wrapException(P.ConcurrentModificationError$(this));
        buffer = P.StringBuffer$(first);
        for (i = 1; i < $length; ++i) {
          buffer._contents += separator;
          str = this.elementAt$1(0, i);
          buffer._contents += typeof str === "string" ? str : H.S(str);
          if ($length !== this.get$length(this))
            throw H.wrapException(P.ConcurrentModificationError$(this));
        }
        return buffer._contents;
      } else {
        buffer = P.StringBuffer$("");
        for (i = 0; i < $length; ++i) {
          str = this.elementAt$1(0, i);
          buffer._contents += typeof str === "string" ? str : H.S(str);
          if ($length !== this.get$length(this))
            throw H.wrapException(P.ConcurrentModificationError$(this));
        }
        return buffer._contents;
      }
    },
    where$1: function(_, test) {
      return P.IterableBase.prototype.where$1.call(this, this, test);
    },
    map$1: function(_, f) {
      return H.setRuntimeTypeInfo(new H.MappedListIterable(this, f), [null, null]);
    },
    reduce$1: function(_, combine) {
      var value, i;
      if (this.get$length(this) === 0)
        throw H.wrapException(H.IterableElementError_noElement());
      value = this.elementAt$1(0, 0);
      for (i = 1; i < this.get$length(this); ++i)
        value = combine.call$2(value, this.elementAt$1(0, i));
      return value;
    },
    fold$2: function(_, initialValue, combine) {
      var $length, value, i;
      $length = this.get$length(this);
      for (value = initialValue, i = 0; i < $length; ++i) {
        value = combine.call$2(value, this.elementAt$1(0, i));
        if ($length !== this.get$length(this))
          throw H.wrapException(P.ConcurrentModificationError$(this));
      }
      return value;
    },
    toList$1$growable: function(_, growable) {
      var result, t1, i;
      if (growable) {
        result = H.setRuntimeTypeInfo([], [H.getRuntimeTypeArgument(this, "ListIterable", 0)]);
        C.JSArray_methods.set$length(result, this.get$length(this));
      } else {
        t1 = Array(this.get$length(this));
        t1.fixed$length = init;
        result = H.setRuntimeTypeInfo(t1, [H.getRuntimeTypeArgument(this, "ListIterable", 0)]);
      }
      for (i = 0; i < this.get$length(this); ++i) {
        t1 = this.elementAt$1(0, i);
        if (i >= result.length)
          return H.ioore(result, i);
        result[i] = t1;
      }
      return result;
    },
    toList$0: function($receiver) {
      return this.toList$1$growable($receiver, true);
    },
    $isEfficientLength: true
  },
  SubListIterable: {
    "^": "ListIterable;_iterable,__internal$_start,_endOrLength",
    get$_endIndex: function() {
      var $length, t1, t2;
      $length = J.get$length$asx(this._iterable);
      t1 = this._endOrLength;
      if (t1 != null) {
        if (typeof t1 !== "number")
          return t1.$gt();
        t2 = t1 > $length;
      } else
        t2 = true;
      if (t2)
        return $length;
      return t1;
    },
    get$_startIndex: function() {
      var $length, t1;
      $length = J.get$length$asx(this._iterable);
      t1 = this.__internal$_start;
      if (t1 > $length)
        return $length;
      return t1;
    },
    get$length: function(_) {
      var $length, t1, t2, t3;
      $length = J.get$length$asx(this._iterable);
      t1 = this.__internal$_start;
      if (t1 >= $length)
        return 0;
      t2 = this._endOrLength;
      if (t2 != null) {
        if (typeof t2 !== "number")
          return t2.$ge();
        t3 = t2 >= $length;
      } else
        t3 = true;
      if (t3)
        return $length - t1;
      if (typeof t2 !== "number")
        return t2.$sub();
      return t2 - t1;
    },
    elementAt$1: function(_, index) {
      var realIndex, t1;
      realIndex = this.get$_startIndex() + index;
      if (index >= 0) {
        t1 = this.get$_endIndex();
        if (typeof t1 !== "number")
          return H.iae(t1);
        t1 = realIndex >= t1;
      } else
        t1 = true;
      if (t1)
        throw H.wrapException(P.RangeError$range(index, 0, this.get$length(this)));
      return J.elementAt$1$ax(this._iterable, realIndex);
    },
    SubListIterable$3: function(_iterable, _start, _endOrLength, $E) {
      var t1, t2;
      t1 = this.__internal$_start;
      if (t1 < 0)
        throw H.wrapException(P.RangeError$value(t1));
      t2 = this._endOrLength;
      if (t2 != null) {
        if (typeof t2 !== "number")
          return t2.$lt();
        if (t2 < 0)
          throw H.wrapException(P.RangeError$value(t2));
        if (t1 > t2)
          throw H.wrapException(P.RangeError$range(t1, 0, t2));
      }
    },
    static: {SubListIterable$: function(_iterable, _start, _endOrLength, $E) {
        var t1 = H.setRuntimeTypeInfo(new H.SubListIterable(_iterable, _start, _endOrLength), [$E]);
        t1.SubListIterable$3(_iterable, _start, _endOrLength, $E);
        return t1;
      }}
  },
  ListIterator: {
    "^": "Object;_iterable,__internal$_length,_index,__internal$_current",
    get$current: function() {
      return this.__internal$_current;
    },
    moveNext$0: function() {
      var t1, t2, $length, t3;
      t1 = this._iterable;
      t2 = J.getInterceptor$asx(t1);
      $length = t2.get$length(t1);
      if (this.__internal$_length !== $length)
        throw H.wrapException(P.ConcurrentModificationError$(t1));
      t3 = this._index;
      if (t3 >= $length) {
        this.__internal$_current = null;
        return false;
      }
      this.__internal$_current = t2.elementAt$1(t1, t3);
      ++this._index;
      return true;
    }
  },
  MappedIterable: {
    "^": "IterableBase;_iterable,_f",
    _f$1: function(arg0) {
      return this._f.call$1(arg0);
    },
    get$iterator: function(_) {
      var t1 = new H.MappedIterator(null, J.get$iterator$ax(this._iterable), this._f);
      t1.$builtinTypeInfo = this.$builtinTypeInfo;
      return t1;
    },
    get$length: function(_) {
      return J.get$length$asx(this._iterable);
    },
    get$isEmpty: function(_) {
      return J.get$isEmpty$asx(this._iterable);
    },
    get$first: function(_) {
      return this._f$1(J.get$first$ax(this._iterable));
    },
    get$last: function(_) {
      return this._f$1(J.get$last$ax(this._iterable));
    },
    get$single: function(_) {
      return this._f$1(J.get$single$ax(this._iterable));
    },
    $asIterableBase: function($S, $T) {
      return [$T];
    },
    $asIterable: function($S, $T) {
      return [$T];
    },
    static: {MappedIterable_MappedIterable: function(iterable, $function, $S, $T) {
        if (!!J.getInterceptor(iterable).$isEfficientLength)
          return H.setRuntimeTypeInfo(new H.EfficientLengthMappedIterable(iterable, $function), [$S, $T]);
        return H.setRuntimeTypeInfo(new H.MappedIterable(iterable, $function), [$S, $T]);
      }}
  },
  EfficientLengthMappedIterable: {
    "^": "MappedIterable;_iterable,_f",
    $isEfficientLength: true
  },
  MappedIterator: {
    "^": "Iterator;__internal$_current,_iterator,_f",
    _f$1: function(arg0) {
      return this._f.call$1(arg0);
    },
    moveNext$0: function() {
      var t1 = this._iterator;
      if (t1.moveNext$0()) {
        this.__internal$_current = this._f$1(t1.get$current());
        return true;
      }
      this.__internal$_current = null;
      return false;
    },
    get$current: function() {
      return this.__internal$_current;
    },
    $asIterator: function($S, $T) {
      return [$T];
    }
  },
  MappedListIterable: {
    "^": "ListIterable;_source,_f",
    _f$1: function(arg0) {
      return this._f.call$1(arg0);
    },
    get$length: function(_) {
      return J.get$length$asx(this._source);
    },
    elementAt$1: function(_, index) {
      return this._f$1(J.elementAt$1$ax(this._source, index));
    },
    $asListIterable: function($S, $T) {
      return [$T];
    },
    $asIterableBase: function($S, $T) {
      return [$T];
    },
    $asIterable: function($S, $T) {
      return [$T];
    },
    $isEfficientLength: true
  },
  WhereIterable: {
    "^": "IterableBase;_iterable,_f",
    get$iterator: function(_) {
      var t1 = new H.WhereIterator(J.get$iterator$ax(this._iterable), this._f);
      t1.$builtinTypeInfo = this.$builtinTypeInfo;
      return t1;
    }
  },
  WhereIterator: {
    "^": "Iterator;_iterator,_f",
    _f$1: function(arg0) {
      return this._f.call$1(arg0);
    },
    moveNext$0: function() {
      for (var t1 = this._iterator; t1.moveNext$0();)
        if (this._f$1(t1.get$current()) === true)
          return true;
      return false;
    },
    get$current: function() {
      return this._iterator.get$current();
    }
  },
  ExpandIterable: {
    "^": "IterableBase;_iterable,_f",
    get$iterator: function(_) {
      var t1 = new H.ExpandIterator(J.get$iterator$ax(this._iterable), this._f, C.C_EmptyIterator, null);
      t1.$builtinTypeInfo = this.$builtinTypeInfo;
      return t1;
    },
    $asIterableBase: function($S, $T) {
      return [$T];
    },
    $asIterable: function($S, $T) {
      return [$T];
    }
  },
  ExpandIterator: {
    "^": "Object;_iterator,_f,_currentExpansion,__internal$_current",
    _f$1: function(arg0) {
      return this._f.call$1(arg0);
    },
    get$current: function() {
      return this.__internal$_current;
    },
    moveNext$0: function() {
      var t1, t2;
      t1 = this._currentExpansion;
      if (t1 == null)
        return false;
      for (t2 = this._iterator; !t1.moveNext$0();) {
        this.__internal$_current = null;
        if (t2.moveNext$0()) {
          this._currentExpansion = null;
          t1 = J.get$iterator$ax(this._f$1(t2.get$current()));
          this._currentExpansion = t1;
        } else
          return false;
      }
      this.__internal$_current = this._currentExpansion.get$current();
      return true;
    }
  },
  EmptyIterator: {
    "^": "Object;",
    moveNext$0: function() {
      return false;
    },
    get$current: function() {
      return;
    }
  },
  IterableMixinWorkaround: {
    "^": "Object;",
    static: {IterableMixinWorkaround_forEach: function(iterable, f) {
        var t1;
        for (t1 = H.setRuntimeTypeInfo(new H.ListIterator(iterable, iterable.length, 0, null), [H.getTypeArgumentByIndex(iterable, 0)]); t1.moveNext$0();)
          f.call$1(t1.__internal$_current);
      }, IterableMixinWorkaround_any: function(iterable, f) {
        var t1;
        for (t1 = H.setRuntimeTypeInfo(new H.ListIterator(iterable, iterable.length, 0, null), [H.getTypeArgumentByIndex(iterable, 0)]); t1.moveNext$0();)
          if (f.call$1(t1.__internal$_current) === true)
            return true;
        return false;
      }, IterableMixinWorkaround_every: function(iterable, f) {
        var t1;
        for (t1 = H.setRuntimeTypeInfo(new H.ListIterator(iterable, iterable.length, 0, null), [H.getTypeArgumentByIndex(iterable, 0)]); t1.moveNext$0();)
          if (f.call$1(t1.__internal$_current) !== true)
            return false;
        return true;
      }, IterableMixinWorkaround_fold: function(iterable, initialValue, combine) {
        var t1;
        for (t1 = H.setRuntimeTypeInfo(new H.ListIterator(iterable, iterable.length, 0, null), [H.getTypeArgumentByIndex(iterable, 0)]); t1.moveNext$0();)
          initialValue = combine.call$2(initialValue, t1.__internal$_current);
        return initialValue;
      }, IterableMixinWorkaround_removeWhereList: function(list, test) {
        var retained, $length, t1, i, element;
        retained = [];
        $length = list.length;
        for (t1 = $length, i = 0; i < $length; ++i) {
          if (i >= t1)
            return H.ioore(list, i);
          element = list[i];
          if (test.call$1(element) !== true)
            retained.push(element);
          t1 = list.length;
          if ($length !== t1)
            throw H.wrapException(P.ConcurrentModificationError$(list));
        }
        t1 = retained.length;
        if (t1 === $length)
          return;
        C.JSArray_methods.set$length(list, t1);
        for (i = 0; i < retained.length; ++i)
          C.JSArray_methods.$indexSet(list, i, retained[i]);
      }, IterableMixinWorkaround_firstWhere: function(iterable, test, orElse) {
        var t1, element;
        for (t1 = H.setRuntimeTypeInfo(new H.ListIterator(iterable, iterable.length, 0, null), [H.getTypeArgumentByIndex(iterable, 0)]); t1.moveNext$0();) {
          element = t1.__internal$_current;
          if (test.call$1(element) === true)
            return element;
        }
        return orElse.call$0();
      }, IterableMixinWorkaround_sortList: function(list, compare) {
        if (compare == null)
          compare = P.Comparable_compare$closure();
        H.Sort__doSort(list, 0, list.length - 1, compare);
      }, IterableMixinWorkaround__rangeCheck: function(list, start, end) {
        if (start < 0 || start > list.length)
          throw H.wrapException(P.RangeError$range(start, 0, list.length));
        if (end < start || end > list.length)
          throw H.wrapException(P.RangeError$range(end, start, list.length));
      }, IterableMixinWorkaround_setRangeList: function(list, start, end, from, skipCount) {
        var $length, t1, otherStart, otherList;
        H.IterableMixinWorkaround__rangeCheck(list, start, end);
        $length = end - start;
        if ($length === 0)
          return;
        if (skipCount < 0)
          throw H.wrapException(P.ArgumentError$(skipCount));
        t1 = J.getInterceptor(from);
        if (!!t1.$isList) {
          otherStart = skipCount;
          otherList = from;
        } else {
          otherList = t1.skip$1(from, skipCount).toList$1$growable(0, false);
          otherStart = 0;
        }
        if (otherStart + $length > J.get$length$asx(otherList))
          throw H.wrapException(H.IterableElementError_tooFew());
        H.Lists_copy(otherList, otherStart, list, start, $length);
      }}
  },
  FixedLengthListMixin: {
    "^": "Object;",
    set$length: function(receiver, newLength) {
      throw H.wrapException(P.UnsupportedError$("Cannot change the length of a fixed-length list"));
    },
    add$1: function(receiver, value) {
      throw H.wrapException(P.UnsupportedError$("Cannot add to a fixed-length list"));
    },
    addAll$1: function(receiver, iterable) {
      throw H.wrapException(P.UnsupportedError$("Cannot add to a fixed-length list"));
    },
    remove$1: function(receiver, element) {
      throw H.wrapException(P.UnsupportedError$("Cannot remove from a fixed-length list"));
    },
    removeWhere$1: function(receiver, test) {
      throw H.wrapException(P.UnsupportedError$("Cannot remove from a fixed-length list"));
    },
    clear$0: function(receiver) {
      throw H.wrapException(P.UnsupportedError$("Cannot clear a fixed-length list"));
    },
    removeLast$0: function(receiver) {
      throw H.wrapException(P.UnsupportedError$("Cannot remove from a fixed-length list"));
    }
  },
  UnmodifiableListMixin: {
    "^": "Object;",
    $indexSet: function(_, index, value) {
      throw H.wrapException(P.UnsupportedError$("Cannot modify an unmodifiable list"));
    },
    set$length: function(_, newLength) {
      throw H.wrapException(P.UnsupportedError$("Cannot change the length of an unmodifiable list"));
    },
    add$1: function(_, value) {
      throw H.wrapException(P.UnsupportedError$("Cannot add to an unmodifiable list"));
    },
    addAll$1: function(_, iterable) {
      throw H.wrapException(P.UnsupportedError$("Cannot add to an unmodifiable list"));
    },
    remove$1: function(_, element) {
      throw H.wrapException(P.UnsupportedError$("Cannot remove from an unmodifiable list"));
    },
    removeWhere$1: function(_, test) {
      throw H.wrapException(P.UnsupportedError$("Cannot remove from an unmodifiable list"));
    },
    clear$0: function(_) {
      throw H.wrapException(P.UnsupportedError$("Cannot clear an unmodifiable list"));
    },
    removeLast$0: function(_) {
      throw H.wrapException(P.UnsupportedError$("Cannot remove from an unmodifiable list"));
    },
    setRange$4: function(_, start, end, iterable, skipCount) {
      throw H.wrapException(P.UnsupportedError$("Cannot modify an unmodifiable list"));
    },
    setRange$3: function($receiver, start, end, iterable) {
      return this.setRange$4($receiver, start, end, iterable, 0);
    },
    $isList: true,
    $asList: null,
    $isEfficientLength: true,
    $isIterable: true,
    $asIterable: null
  },
  UnmodifiableListBase: {
    "^": "ListBase+UnmodifiableListMixin;",
    $isList: true,
    $asList: null,
    $isEfficientLength: true,
    $isIterable: true,
    $asIterable: null
  },
  ReversedListIterable: {
    "^": "ListIterable;_source",
    get$length: function(_) {
      return J.get$length$asx(this._source);
    },
    elementAt$1: function(_, index) {
      var t1, t2;
      t1 = this._source;
      t2 = J.getInterceptor$asx(t1);
      return t2.elementAt$1(t1, t2.get$length(t1) - 1 - index);
    }
  }
}],
["dart._js_names", "dart:_js_names", , H, {
  "^": "",
  extractKeys: function(victim) {
    var t1 = H.setRuntimeTypeInfo(function(victim, hasOwnProperty) {
      var result = [];
      for (var key in victim) {
        if (hasOwnProperty.call(victim, key))
          result.push(key);
      }
      return result;
    }(victim, Object.prototype.hasOwnProperty), [null]);
    t1.fixed$length = init;
    return t1;
  }
}],
["dart.async", "dart:async", , P, {
  "^": "",
  _AsyncRun__initializeScheduleImmediate: function() {
    var t1, div, span;
    t1 = {};
    if (self.scheduleImmediate != null)
      return P._AsyncRun__scheduleImmediateJsOverride$closure();
    if (self.MutationObserver != null && self.document != null) {
      div = self.document.createElement("div");
      span = self.document.createElement("span");
      t1.storedCallback_0 = null;
      new self.MutationObserver(H.convertDartClosureToJS(new P._AsyncRun__initializeScheduleImmediate_internalCallback(t1), 1)).observe(div, {childList: true});
      return new P._AsyncRun__initializeScheduleImmediate_closure(t1, div, span);
    }
    return P._AsyncRun__scheduleImmediateWithTimer$closure();
  },
  _AsyncRun__scheduleImmediateJsOverride: [function(callback) {
    ++init.globalState.topEventLoop._activeJsAsyncCount;
    self.scheduleImmediate(H.convertDartClosureToJS(new P._AsyncRun__scheduleImmediateJsOverride_internalCallback(callback), 0));
  }, "call$1", "_AsyncRun__scheduleImmediateJsOverride$closure", 2, 0, 6],
  _AsyncRun__scheduleImmediateWithTimer: [function(callback) {
    P.Timer__createTimer(C.Duration_0, callback);
  }, "call$1", "_AsyncRun__scheduleImmediateWithTimer$closure", 2, 0, 6],
  _registerErrorHandler: function(errorHandler, zone) {
    var t1 = H.getDynamicRuntimeType();
    t1 = H.buildFunctionType(t1, [t1, t1])._isTest$1(errorHandler);
    if (t1) {
      zone.toString;
      return errorHandler;
    } else {
      zone.toString;
      return errorHandler;
    }
  },
  Future_Future$sync: function(computation, $T) {
    var result, T0, error, stackTrace, t1, exception;
    try {
      result = computation.call$0();
      t1 = P._Future$immediate(result, T0);
      return t1;
    } catch (exception) {
      t1 = H.unwrapException(exception);
      error = t1;
      stackTrace = new H._StackTrace(exception, null);
      return P._Future$immediateError(error, stackTrace, T0);
    }

  },
  Future_forEach: function(input, f) {
    return P.Future_doWhile(new P.Future_forEach_closure(f, H.setRuntimeTypeInfo(new H.ListIterator(input, input.length, 0, null), [H.getTypeArgumentByIndex(input, 0)])));
  },
  Future_doWhile: function(f) {
    var t1, doneSignal, nextIteration;
    t1 = {};
    doneSignal = P._Future$(null);
    t1.nextIteration_0 = null;
    nextIteration = $.Zone__current.bindUnaryCallback$2$runGuarded(new P.Future_doWhile_closure(t1, f, doneSignal), true);
    t1.nextIteration_0 = nextIteration;
    nextIteration.call$1(true);
    return doneSignal;
  },
  _asyncRunCallbackLoop: function() {
    var t1, t2;
    for (; t1 = $._nextCallback, t1 != null;) {
      $._lastPriorityCallback = null;
      t2 = t1.next;
      $._nextCallback = t2;
      if (t2 == null)
        $._lastCallback = null;
      t1.callback$0();
    }
  },
  _asyncRunCallback: [function() {
    $._isInCallbackLoop = true;
    try {
      P._asyncRunCallbackLoop();
    } finally {
      $._lastPriorityCallback = null;
      $._isInCallbackLoop = false;
      if ($._nextCallback != null)
        $.get$_AsyncRun_scheduleImmediateClosure().call$1(P._asyncRunCallback$closure());
    }
  }, "call$0", "_asyncRunCallback$closure", 0, 0, 7],
  scheduleMicrotask: function(callback) {
    var t1 = $.Zone__current;
    if (C.C__RootZone === t1) {
      P._rootScheduleMicrotask(null, null, C.C__RootZone, callback);
      return;
    }
    P._rootScheduleMicrotask(null, null, t1, t1.bindCallback$2$runGuarded(callback, true));
  },
  StreamController_StreamController: function(onCancel, onListen, onPause, onResume, sync, $T) {
    return sync ? H.setRuntimeTypeInfo(new P._SyncStreamController(onListen, onPause, onResume, onCancel, null, 0, null), [$T]) : H.setRuntimeTypeInfo(new P._AsyncStreamController(onListen, onPause, onResume, onCancel, null, 0, null), [$T]);
  },
  _runGuarded: function(notificationHandler) {
    var result, e, s, exception, t1;
    if (notificationHandler == null)
      return;
    try {
      result = notificationHandler.call$0();
      if (!!J.getInterceptor(result).$isFuture)
        return result;
      return;
    } catch (exception) {
      t1 = H.unwrapException(exception);
      e = t1;
      s = new H._StackTrace(exception, null);
      t1 = $.Zone__current;
      t1.toString;
      P._rootHandleUncaughtError(null, null, t1, e, s);
    }

  },
  _nullDataHandler: [function(value) {
  }, "call$1", "_nullDataHandler$closure", 2, 0, 8],
  _nullErrorHandler: [function(error, stackTrace) {
    var t1 = $.Zone__current;
    t1.toString;
    P._rootHandleUncaughtError(null, null, t1, error, stackTrace);
  }, function(error) {
    return P._nullErrorHandler(error, null);
  }, null, "call$2", "call$1", "_nullErrorHandler$closure", 2, 2, 9, 10],
  _nullDoneHandler: [function() {
  }, "call$0", "_nullDoneHandler$closure", 0, 0, 7],
  _runUserCode: function(userCode, onSuccess, onError) {
    var e, s, exception, t1;
    try {
      onSuccess.call$1(userCode.call$0());
    } catch (exception) {
      t1 = H.unwrapException(exception);
      e = t1;
      s = new H._StackTrace(exception, null);
      onError.call$2(e, s);
    }

  },
  _cancelAndError: function(subscription, future, error, stackTrace) {
    var cancelFuture = subscription.cancel$0();
    if (!!J.getInterceptor(cancelFuture).$isFuture)
      cancelFuture.whenComplete$1(new P._cancelAndError_closure(future, error, stackTrace));
    else
      future._completeError$2(error, stackTrace);
  },
  _cancelAndErrorClosure: function(subscription, future) {
    return new P._cancelAndErrorClosure_closure(subscription, future);
  },
  _cancelAndValue: function(subscription, future, value) {
    var cancelFuture = subscription.cancel$0();
    if (!!J.getInterceptor(cancelFuture).$isFuture)
      cancelFuture.whenComplete$1(new P._cancelAndValue_closure(future, value));
    else
      future._complete$1(value);
  },
  Timer_Timer: function(duration, callback) {
    var t1 = $.Zone__current;
    if (t1 === C.C__RootZone) {
      t1.toString;
      return P.Timer__createTimer(duration, callback);
    }
    return P.Timer__createTimer(duration, t1.bindCallback$2$runGuarded(callback, true));
  },
  Timer__createTimer: function(duration, callback) {
    var milliseconds = C.JSInt_methods._tdivFast$1(duration._duration, 1000);
    return H.TimerImpl$(milliseconds < 0 ? 0 : milliseconds, callback);
  },
  Zone__enter: function(zone) {
    var previous = $.Zone__current;
    $.Zone__current = zone;
    return previous;
  },
  _rootHandleUncaughtError: function($self, $parent, zone, error, stackTrace) {
    var entry, t1, t2;
    entry = new P._AsyncCallbackEntry(new P._rootHandleUncaughtError_closure(error, stackTrace), null);
    t1 = $._nextCallback;
    if (t1 == null) {
      $._lastPriorityCallback = entry;
      $._lastCallback = entry;
      $._nextCallback = entry;
      if (!$._isInCallbackLoop)
        $.get$_AsyncRun_scheduleImmediateClosure().call$1(P._asyncRunCallback$closure());
    } else {
      t2 = $._lastPriorityCallback;
      if (t2 == null) {
        entry.next = t1;
        $._lastPriorityCallback = entry;
        $._nextCallback = entry;
      } else {
        entry.next = t2.next;
        t2.next = entry;
        $._lastPriorityCallback = entry;
        if (entry.next == null)
          $._lastCallback = entry;
      }
    }
  },
  _rootRun: function($self, $parent, zone, f) {
    var old, t1;
    if ($.Zone__current === zone)
      return f.call$0();
    old = P.Zone__enter(zone);
    try {
      t1 = f.call$0();
      return t1;
    } finally {
      $.Zone__current = old;
    }
  },
  _rootRunUnary: function($self, $parent, zone, f, arg) {
    var old, t1;
    if ($.Zone__current === zone)
      return f.call$1(arg);
    old = P.Zone__enter(zone);
    try {
      t1 = f.call$1(arg);
      return t1;
    } finally {
      $.Zone__current = old;
    }
  },
  _rootRunBinary: function($self, $parent, zone, f, arg1, arg2) {
    var old, t1;
    if ($.Zone__current === zone)
      return f.call$2(arg1, arg2);
    old = P.Zone__enter(zone);
    try {
      t1 = f.call$2(arg1, arg2);
      return t1;
    } finally {
      $.Zone__current = old;
    }
  },
  _rootScheduleMicrotask: function($self, $parent, zone, f) {
    var t1, newEntry;
    if (C.C__RootZone !== zone)
      f = zone.bindCallback$1(f);
    if ($._nextCallback == null) {
      t1 = new P._AsyncCallbackEntry(f, null);
      $._lastCallback = t1;
      $._nextCallback = t1;
      if (!$._isInCallbackLoop)
        $.get$_AsyncRun_scheduleImmediateClosure().call$1(P._asyncRunCallback$closure());
    } else {
      newEntry = new P._AsyncCallbackEntry(f, null);
      $._lastCallback.next = newEntry;
      $._lastCallback = newEntry;
    }
  },
  _AsyncRun__initializeScheduleImmediate_internalCallback: {
    "^": "Closure:13;box_0",
    call$1: function(_) {
      var t1, f;
      H.leaveJsAsync();
      t1 = this.box_0;
      f = t1.storedCallback_0;
      t1.storedCallback_0 = null;
      f.call$0();
    },
    $isFunction: true
  },
  _AsyncRun__initializeScheduleImmediate_closure: {
    "^": "Closure:53;box_0,div_1,span_2",
    call$1: function(callback) {
      var t1, t2;
      ++init.globalState.topEventLoop._activeJsAsyncCount;
      this.box_0.storedCallback_0 = callback;
      t1 = this.div_1;
      t2 = this.span_2;
      t1.firstChild ? t1.removeChild(t2) : t1.appendChild(t2);
    },
    $isFunction: true
  },
  _AsyncRun__scheduleImmediateJsOverride_internalCallback: {
    "^": "Closure:23;callback_0",
    call$0: function() {
      H.leaveJsAsync();
      this.callback_0.call$0();
    },
    $isFunction: true
  },
  _AsyncError: {
    "^": "Object;error>,stackTrace<",
    $isError: true
  },
  _UncaughtAsyncError: {
    "^": "_AsyncError;error,stackTrace",
    toString$0: function(_) {
      var result, t1;
      result = "Uncaught Error: " + H.S(this.error);
      t1 = this.stackTrace;
      return t1 != null ? result + ("\nStack Trace:\n" + J.toString$0(t1)) : result;
    },
    static: {_UncaughtAsyncError$: function(error, stackTrace) {
        return new P._UncaughtAsyncError(error, P._UncaughtAsyncError__getBestStackTrace(error, stackTrace));
      }, _UncaughtAsyncError__getBestStackTrace: function(error, stackTrace) {
        if (stackTrace != null)
          return stackTrace;
        if (!!J.getInterceptor(error).$isError)
          return error.get$stackTrace();
        return;
      }}
  },
  Future: {
    "^": "Object;",
    $isFuture: true
  },
  Future_forEach_closure: {
    "^": "Closure:23;f_0,iterator_1",
    call$0: function() {
      var t1 = this.iterator_1;
      if (!t1.moveNext$0())
        return false;
      return P.Future_Future$sync(new P.Future_forEach__closure(this.f_0, t1), null).then$1(new P.Future_forEach__closure0());
    },
    $isFunction: true
  },
  Future_forEach__closure: {
    "^": "Closure:23;f_2,iterator_3",
    call$0: function() {
      return this.f_2.call$1(this.iterator_3.__internal$_current);
    },
    $isFunction: true
  },
  Future_forEach__closure0: {
    "^": "Closure:13;",
    call$1: function(_) {
      return true;
    },
    $isFunction: true
  },
  Future_doWhile_closure: {
    "^": "Closure:54;box_0,f_1,doneSignal_2",
    call$1: function(keepGoing) {
      var t1 = this.doneSignal_2;
      if (keepGoing === true)
        P.Future_Future$sync(this.f_1, null).then$2$onError(this.box_0.nextIteration_0, t1.get$_completeError());
      else
        t1._complete$1(null);
    },
    $isFunction: true
  },
  _Completer: {
    "^": "Object;"
  },
  _AsyncCompleter: {
    "^": "_Completer;future",
    completeError$2: [function(error, stackTrace) {
      var t1;
      if (error == null)
        throw H.wrapException(P.ArgumentError$("Error must not be null"));
      t1 = this.future;
      if (t1._state !== 0)
        throw H.wrapException(P.StateError$("Future already completed"));
      t1._asyncCompleteError$2(error, stackTrace);
    }, function(error) {
      return this.completeError$2(error, null);
    }, "completeError$1", "call$2", "call$1", "get$completeError", 2, 2, 55, 10]
  },
  _Future: {
    "^": "Object;_state,_zone,_resultOrListeners,_nextListener<,_onValueCallback,_errorTestCallback,_onErrorCallback,_whenCompleteActionCallback",
    set$_isChained: function(value) {
      if (value)
        this._state = 2;
      else
        this._state = 0;
    },
    then$2$onError: function(f, onError) {
      var t1, result;
      t1 = $.Zone__current;
      t1.toString;
      result = H.setRuntimeTypeInfo(new P._Future(0, t1, null, null, f, null, P._registerErrorHandler(onError, t1), null), [null]);
      this._addListener$1(result);
      return result;
    },
    then$1: function(f) {
      return this.then$2$onError(f, null);
    },
    catchError$2$test: function(onError, test) {
      var t1, t2, result;
      t1 = $.Zone__current;
      t2 = P._registerErrorHandler(onError, t1);
      t1.toString;
      result = H.setRuntimeTypeInfo(new P._Future(0, t1, null, null, null, test, t2, null), [null]);
      this._addListener$1(result);
      return result;
    },
    catchError$1: function(onError) {
      return this.catchError$2$test(onError, null);
    },
    whenComplete$1: function(action) {
      var t1, result;
      t1 = $.Zone__current;
      t1.toString;
      result = new P._Future(0, t1, null, null, null, null, null, action);
      result.$builtinTypeInfo = this.$builtinTypeInfo;
      this._addListener$1(result);
      return result;
    },
    _setValue$1: function(value) {
      this._state = 4;
      this._resultOrListeners = value;
    },
    _setError$2: function(error, stackTrace) {
      this._state = 8;
      this._resultOrListeners = new P._AsyncError(error, stackTrace);
    },
    _addListener$1: function(listener) {
      var t1;
      if (this._state >= 4) {
        t1 = this._zone;
        t1.toString;
        P._rootScheduleMicrotask(null, null, t1, new P._Future__addListener_closure(this, listener));
      } else {
        listener._nextListener = this._resultOrListeners;
        this._resultOrListeners = listener;
      }
    },
    _removeListeners$0: function() {
      var current, prev, next;
      current = this._resultOrListeners;
      this._resultOrListeners = null;
      for (prev = null; current != null; prev = current, current = next) {
        next = current.get$_nextListener();
        current._nextListener = prev;
      }
      return prev;
    },
    _complete$1: function(value) {
      var t1, listeners;
      t1 = J.getInterceptor(value);
      if (!!t1.$isFuture)
        if (!!t1.$is_Future)
          P._Future__chainCoreFuture(value, this);
        else
          P._Future__chainForeignFuture(value, this);
      else {
        listeners = this._removeListeners$0();
        this._setValue$1(value);
        P._Future__propagateToListeners(this, listeners);
      }
    },
    _completeWithValue$1: function(value) {
      var listeners = this._removeListeners$0();
      this._setValue$1(value);
      P._Future__propagateToListeners(this, listeners);
    },
    _completeError$2: [function(error, stackTrace) {
      var listeners = this._removeListeners$0();
      this._setError$2(error, stackTrace);
      P._Future__propagateToListeners(this, listeners);
    }, function(error) {
      return this._completeError$2(error, null);
    }, "_completeError$1", "call$2", "call$1", "get$_completeError", 2, 2, 9, 10],
    _asyncComplete$1: function(value) {
      var t1;
      if (value == null)
        ;
      else {
        t1 = J.getInterceptor(value);
        if (!!t1.$isFuture) {
          if (!!t1.$is_Future) {
            t1 = value._state;
            if (t1 >= 4 && t1 === 8) {
              if (this._state !== 0)
                H.throwExpression(P.StateError$("Future already completed"));
              this._state = 1;
              t1 = this._zone;
              t1.toString;
              P._rootScheduleMicrotask(null, null, t1, new P._Future__asyncComplete_closure(this, value));
            } else
              P._Future__chainCoreFuture(value, this);
          } else
            P._Future__chainForeignFuture(value, this);
          return;
        }
      }
      if (this._state !== 0)
        H.throwExpression(P.StateError$("Future already completed"));
      this._state = 1;
      t1 = this._zone;
      t1.toString;
      P._rootScheduleMicrotask(null, null, t1, new P._Future__asyncComplete_closure0(this, value));
    },
    _asyncCompleteError$2: function(error, stackTrace) {
      var t1;
      if (this._state !== 0)
        H.throwExpression(P.StateError$("Future already completed"));
      this._state = 1;
      t1 = this._zone;
      t1.toString;
      P._rootScheduleMicrotask(null, null, t1, new P._Future__asyncCompleteError_closure(this, error, stackTrace));
    },
    _async$_Future$immediate$1: function(value, $T) {
      this._asyncComplete$1(value);
    },
    _async$_Future$immediateError$2: function(error, stackTrace, $T) {
      this._asyncCompleteError$2(error, stackTrace);
    },
    $is_Future: true,
    $isFuture: true,
    static: {"^": "_Future__INCOMPLETE,_Future__PENDING_COMPLETE,_Future__CHAINED,_Future__VALUE,_Future__ERROR", _Future$: function($T) {
        return H.setRuntimeTypeInfo(new P._Future(0, $.Zone__current, null, null, null, null, null, null), [$T]);
      }, _Future$immediate: function(value, $T) {
        var t1 = H.setRuntimeTypeInfo(new P._Future(0, $.Zone__current, null, null, null, null, null, null), [$T]);
        t1._async$_Future$immediate$1(value, $T);
        return t1;
      }, _Future$immediateError: function(error, stackTrace, $T) {
        var t1 = H.setRuntimeTypeInfo(new P._Future(0, $.Zone__current, null, null, null, null, null, null), [$T]);
        t1._async$_Future$immediateError$2(error, stackTrace, $T);
        return t1;
      }, _Future__chainForeignFuture: function(source, target) {
        target._state = 2;
        source.then$2$onError(new P._Future__chainForeignFuture_closure(target), new P._Future__chainForeignFuture_closure0(target));
      }, _Future__chainCoreFuture: function(source, target) {
        target._state = 2;
        if (source._state >= 4)
          P._Future__propagateToListeners(source, target);
        else
          source._addListener$1(target);
      }, _Future__propagateMultipleListeners: function(source, listeners) {
        var listeners0;
        do {
          listeners0 = listeners._nextListener;
          listeners._nextListener = null;
          P._Future__propagateToListeners(source, listeners);
          if (listeners0 != null) {
            listeners = listeners0;
            continue;
          } else
            break;
        } while (true);
      }, _Future__propagateToListeners: function(source, listeners) {
        var t1, t2, t3, t4, hasError, asyncError, sourceValue, t5, t6, zone, oldZone, chainSource, listeners0;
        t1 = {};
        t1.source_4 = source;
        for (t2 = source; true;) {
          t3 = {};
          t4 = t2._state;
          if (t4 < 4)
            return;
          hasError = t4 === 8;
          if (hasError && listeners == null) {
            asyncError = t2._resultOrListeners;
            t1 = t2._zone;
            t2 = J.get$error$x(asyncError);
            t3 = asyncError.get$stackTrace();
            t1.toString;
            P._rootHandleUncaughtError(null, null, t1, t2, t3);
            return;
          }
          if (listeners == null)
            return;
          if (listeners._nextListener != null) {
            P._Future__propagateMultipleListeners(t2, listeners);
            return;
          }
          t3.listenerHasValue_1 = true;
          sourceValue = t4 === 4 ? t2._resultOrListeners : null;
          t3.listenerValueOrError_2 = sourceValue;
          t3.isPropagationAborted_3 = false;
          t4 = !hasError;
          if (t4) {
            t5 = listeners._state === 2;
            if ((t5 ? null : listeners._onValueCallback) == null) {
              t6 = (t5 ? null : listeners._whenCompleteActionCallback) != null;
              t5 = t6;
            } else
              t5 = true;
          } else
            t5 = true;
          if (t5) {
            zone = listeners._zone;
            if (hasError) {
              t2 = t2._zone.get$errorZone();
              zone.toString;
              t2 = t2 !== zone;
            } else
              t2 = false;
            if (t2) {
              t2 = t1.source_4;
              asyncError = t2._resultOrListeners;
              t2 = t2._zone;
              t3 = J.get$error$x(asyncError);
              t4 = asyncError.get$stackTrace();
              t2.toString;
              P._rootHandleUncaughtError(null, null, t2, t3, t4);
              return;
            }
            oldZone = $.Zone__current;
            if (oldZone == null ? zone != null : oldZone !== zone)
              $.Zone__current = zone;
            else
              oldZone = null;
            if (t4) {
              if ((listeners._state === 2 ? null : listeners._onValueCallback) != null)
                t3.listenerHasValue_1 = new P._Future__propagateToListeners_handleValueCallback(t3, listeners, sourceValue, zone).call$0();
            } else
              new P._Future__propagateToListeners_handleError(t1, t3, listeners, zone).call$0();
            if ((listeners._state === 2 ? null : listeners._whenCompleteActionCallback) != null)
              new P._Future__propagateToListeners_handleWhenCompleteCallback(t1, t3, hasError, listeners, zone).call$0();
            if (oldZone != null)
              $.Zone__current = oldZone;
            listeners._onValueCallback = null;
            listeners._errorTestCallback = null;
            listeners._onErrorCallback = null;
            listeners._whenCompleteActionCallback = null;
            if (t3.isPropagationAborted_3)
              return;
            t2 = t3.listenerHasValue_1;
            if (t2 === true) {
              t4 = t3.listenerValueOrError_2;
              t4 = (sourceValue == null ? t4 != null : sourceValue !== t4) && !!J.getInterceptor(t4).$isFuture;
            } else
              t4 = false;
            if (t4) {
              chainSource = t3.listenerValueOrError_2;
              if (!!J.getInterceptor(chainSource).$is_Future)
                if (chainSource._state >= 4) {
                  listeners._state = 2;
                  t1.source_4 = chainSource;
                  t2 = chainSource;
                  continue;
                } else
                  P._Future__chainCoreFuture(chainSource, listeners);
              else
                P._Future__chainForeignFuture(chainSource, listeners);
              return;
            }
          } else
            t2 = true;
          if (t2 === true) {
            listeners0 = listeners._removeListeners$0();
            t2 = t3.listenerValueOrError_2;
            listeners._state = 4;
            listeners._resultOrListeners = t2;
          } else {
            listeners0 = listeners._removeListeners$0();
            asyncError = t3.listenerValueOrError_2;
            t2 = J.get$error$x(asyncError);
            t3 = asyncError.get$stackTrace();
            listeners._state = 8;
            listeners._resultOrListeners = new P._AsyncError(t2, t3);
          }
          t1.source_4 = listeners;
          t2 = listeners;
          listeners = listeners0;
        }
      }}
  },
  _Future__addListener_closure: {
    "^": "Closure:23;this_0,listener_1",
    call$0: function() {
      P._Future__propagateToListeners(this.this_0, this.listener_1);
    },
    $isFunction: true
  },
  _Future__chainForeignFuture_closure: {
    "^": "Closure:13;target_0",
    call$1: function(value) {
      this.target_0._completeWithValue$1(value);
    },
    $isFunction: true
  },
  _Future__chainForeignFuture_closure0: {
    "^": "Closure:56;target_1",
    call$2: function(error, stackTrace) {
      this.target_1._completeError$2(error, stackTrace);
    },
    call$1: function(error) {
      return this.call$2(error, null);
    },
    $isFunction: true
  },
  _Future__asyncComplete_closure: {
    "^": "Closure:23;this_0,coreFuture_1",
    call$0: function() {
      P._Future__chainCoreFuture(this.coreFuture_1, this.this_0);
    },
    $isFunction: true
  },
  _Future__asyncComplete_closure0: {
    "^": "Closure:23;this_2,value_3",
    call$0: function() {
      this.this_2._completeWithValue$1(this.value_3);
    },
    $isFunction: true
  },
  _Future__asyncCompleteError_closure: {
    "^": "Closure:23;this_0,error_1,stackTrace_2",
    call$0: function() {
      this.this_0._completeError$2(this.error_1, this.stackTrace_2);
    },
    $isFunction: true
  },
  _Future__propagateToListeners_handleValueCallback: {
    "^": "Closure:42;box_1,listener_3,sourceValue_4,zone_5",
    call$0: function() {
      var e, s, t1, exception;
      try {
        t1 = this.listener_3;
        t1 = t1._state === 2 ? null : t1._onValueCallback;
        this.box_1.listenerValueOrError_2 = this.zone_5.runUnary$2(t1, this.sourceValue_4);
        return true;
      } catch (exception) {
        t1 = H.unwrapException(exception);
        e = t1;
        s = new H._StackTrace(exception, null);
        this.box_1.listenerValueOrError_2 = new P._AsyncError(e, s);
        return false;
      }

    },
    $isFunction: true
  },
  _Future__propagateToListeners_handleError: {
    "^": "Closure:7;box_2,box_1,listener_6,zone_7",
    call$0: function() {
      var asyncError, test, matchesTest, e, s, errorCallback, e0, s0, t1, exception, t2, listenerValueOrError, t3, t4;
      asyncError = this.box_2.source_4._resultOrListeners;
      t1 = this.listener_6;
      test = t1._state === 2 ? null : t1._errorTestCallback;
      matchesTest = true;
      if (test != null)
        try {
          matchesTest = this.zone_7.runUnary$2(test, J.get$error$x(asyncError));
        } catch (exception) {
          t1 = H.unwrapException(exception);
          e = t1;
          s = new H._StackTrace(exception, null);
          t1 = J.get$error$x(asyncError);
          t2 = e;
          listenerValueOrError = (t1 == null ? t2 == null : t1 === t2) ? asyncError : new P._AsyncError(e, s);
          t1 = this.box_1;
          t1.listenerValueOrError_2 = listenerValueOrError;
          t1.listenerHasValue_1 = false;
          return;
        }

      errorCallback = t1._state === 2 ? null : t1._onErrorCallback;
      if (matchesTest === true && errorCallback != null) {
        try {
          t1 = errorCallback;
          t2 = H.getDynamicRuntimeType();
          t2 = H.buildFunctionType(t2, [t2, t2])._isTest$1(t1);
          t3 = this.zone_7;
          t4 = this.box_1;
          if (t2)
            t4.listenerValueOrError_2 = t3.runBinary$3(errorCallback, J.get$error$x(asyncError), asyncError.get$stackTrace());
          else
            t4.listenerValueOrError_2 = t3.runUnary$2(errorCallback, J.get$error$x(asyncError));
        } catch (exception) {
          t1 = H.unwrapException(exception);
          e0 = t1;
          s0 = new H._StackTrace(exception, null);
          t1 = J.get$error$x(asyncError);
          t2 = e0;
          listenerValueOrError = (t1 == null ? t2 == null : t1 === t2) ? asyncError : new P._AsyncError(e0, s0);
          t1 = this.box_1;
          t1.listenerValueOrError_2 = listenerValueOrError;
          t1.listenerHasValue_1 = false;
          return;
        }

        this.box_1.listenerHasValue_1 = true;
      } else {
        t1 = this.box_1;
        t1.listenerValueOrError_2 = asyncError;
        t1.listenerHasValue_1 = false;
      }
    },
    $isFunction: true
  },
  _Future__propagateToListeners_handleWhenCompleteCallback: {
    "^": "Closure:7;box_2,box_1,hasError_8,listener_9,zone_10",
    call$0: function() {
      var t1, e, s, t2, exception, t3;
      t1 = {};
      t1.completeResult_0 = null;
      try {
        t2 = this.listener_9;
        t2 = t2._state === 2 ? null : t2._whenCompleteActionCallback;
        t1.completeResult_0 = this.zone_10.run$1(t2);
      } catch (exception) {
        t2 = H.unwrapException(exception);
        e = t2;
        s = new H._StackTrace(exception, null);
        if (this.hasError_8) {
          t2 = J.get$error$x(this.box_2.source_4._resultOrListeners);
          t3 = e;
          t3 = t2 == null ? t3 == null : t2 === t3;
          t2 = t3;
        } else
          t2 = false;
        t3 = this.box_1;
        if (t2)
          t3.listenerValueOrError_2 = this.box_2.source_4._resultOrListeners;
        else
          t3.listenerValueOrError_2 = new P._AsyncError(e, s);
        t3.listenerHasValue_1 = false;
      }

      if (!!J.getInterceptor(t1.completeResult_0).$isFuture) {
        t2 = this.listener_9;
        t2.set$_isChained(true);
        this.box_1.isPropagationAborted_3 = true;
        t1.completeResult_0.then$2$onError(new P._Future__propagateToListeners_handleWhenCompleteCallback_closure(this.box_2, t2), new P._Future__propagateToListeners_handleWhenCompleteCallback_closure0(t1, t2));
      }
    },
    $isFunction: true
  },
  _Future__propagateToListeners_handleWhenCompleteCallback_closure: {
    "^": "Closure:13;box_2,listener_11",
    call$1: function(ignored) {
      P._Future__propagateToListeners(this.box_2.source_4, this.listener_11);
    },
    $isFunction: true
  },
  _Future__propagateToListeners_handleWhenCompleteCallback_closure0: {
    "^": "Closure:56;box_0,listener_12",
    call$2: function(error, stackTrace) {
      var t1, completeResult;
      t1 = this.box_0;
      if (!J.getInterceptor(t1.completeResult_0).$is_Future) {
        completeResult = P._Future$(null);
        t1.completeResult_0 = completeResult;
        completeResult._setError$2(error, stackTrace);
      }
      P._Future__propagateToListeners(t1.completeResult_0, this.listener_12);
    },
    call$1: function(error) {
      return this.call$2(error, null);
    },
    $isFunction: true
  },
  _AsyncCallbackEntry: {
    "^": "Object;callback,next<",
    callback$0: function() {
      return this.callback.call$0();
    }
  },
  Stream: {
    "^": "Object;",
    where$1: function(_, test) {
      return H.setRuntimeTypeInfo(new P._WhereStream(test, this), [H.getRuntimeTypeArgument(this, "Stream", 0)]);
    },
    map$1: function(_, convert) {
      return H.setRuntimeTypeInfo(new P._MapStream(convert, this), [H.getRuntimeTypeArgument(this, "Stream", 0), null]);
    },
    expand$1: function(_, convert) {
      return H.setRuntimeTypeInfo(new P._ExpandStream(convert, this), [H.getRuntimeTypeArgument(this, "Stream", 0), null]);
    },
    fold$2: function(_, initialValue, combine) {
      var t1, result;
      t1 = {};
      result = P._Future$(null);
      t1.value_0 = initialValue;
      t1.subscription_1 = null;
      t1.subscription_1 = this.listen$4$cancelOnError$onDone$onError(new P.Stream_fold_closure(t1, this, combine, result), true, new P.Stream_fold_closure0(t1, result), new P.Stream_fold_closure1(result));
      return result;
    },
    contains$1: function(_, needle) {
      var t1, future;
      t1 = {};
      future = P._Future$(P.bool);
      t1.subscription_0 = null;
      t1.subscription_0 = this.listen$4$cancelOnError$onDone$onError(new P.Stream_contains_closure(t1, this, needle, future), true, new P.Stream_contains_closure0(future), future.get$_completeError());
      return future;
    },
    forEach$1: function(_, action) {
      var t1, future;
      t1 = {};
      future = P._Future$(null);
      t1.subscription_0 = null;
      t1.subscription_0 = this.listen$4$cancelOnError$onDone$onError(new P.Stream_forEach_closure(t1, this, action, future), true, new P.Stream_forEach_closure0(future), future.get$_completeError());
      return future;
    },
    every$1: function(_, test) {
      var t1, future;
      t1 = {};
      future = P._Future$(P.bool);
      t1.subscription_0 = null;
      t1.subscription_0 = this.listen$4$cancelOnError$onDone$onError(new P.Stream_every_closure(t1, this, test, future), true, new P.Stream_every_closure0(future), future.get$_completeError());
      return future;
    },
    any$1: function(_, test) {
      var t1, future;
      t1 = {};
      future = P._Future$(P.bool);
      t1.subscription_0 = null;
      t1.subscription_0 = this.listen$4$cancelOnError$onDone$onError(new P.Stream_any_closure(t1, this, test, future), true, new P.Stream_any_closure0(future), future.get$_completeError());
      return future;
    },
    get$length: function(_) {
      var t1, future;
      t1 = {};
      future = P._Future$(P.$int);
      t1.count_0 = 0;
      this.listen$4$cancelOnError$onDone$onError(new P.Stream_length_closure(t1), true, new P.Stream_length_closure0(t1, future), future.get$_completeError());
      return future;
    },
    get$isEmpty: function(_) {
      var t1, future;
      t1 = {};
      future = P._Future$(P.bool);
      t1.subscription_0 = null;
      t1.subscription_0 = this.listen$4$cancelOnError$onDone$onError(new P.Stream_isEmpty_closure(t1, future), true, new P.Stream_isEmpty_closure0(future), future.get$_completeError());
      return future;
    },
    toList$0: function(_) {
      var result, future;
      result = H.setRuntimeTypeInfo([], [H.getRuntimeTypeArgument(this, "Stream", 0)]);
      future = P._Future$([P.List, H.getRuntimeTypeArgument(this, "Stream", 0)]);
      this.listen$4$cancelOnError$onDone$onError(new P.Stream_toList_closure(this, result), true, new P.Stream_toList_closure0(result, future), future.get$_completeError());
      return future;
    },
    get$first: function(_) {
      var t1, future;
      t1 = {};
      future = P._Future$(H.getRuntimeTypeArgument(this, "Stream", 0));
      t1.subscription_0 = null;
      t1.subscription_0 = this.listen$4$cancelOnError$onDone$onError(new P.Stream_first_closure(t1, this, future), true, new P.Stream_first_closure0(future), future.get$_completeError());
      return future;
    },
    get$last: function(_) {
      var t1, future;
      t1 = {};
      future = P._Future$(H.getRuntimeTypeArgument(this, "Stream", 0));
      t1.result_0 = null;
      t1.foundResult_1 = false;
      this.listen$4$cancelOnError$onDone$onError(new P.Stream_last_closure(t1, this), true, new P.Stream_last_closure0(t1, future), future.get$_completeError());
      return future;
    },
    get$single: function(_) {
      var t1, future;
      t1 = {};
      future = P._Future$(H.getRuntimeTypeArgument(this, "Stream", 0));
      t1.result_0 = null;
      t1.foundResult_1 = false;
      t1.subscription_2 = null;
      t1.subscription_2 = this.listen$4$cancelOnError$onDone$onError(new P.Stream_single_closure(t1, this, future), true, new P.Stream_single_closure0(t1, future), future.get$_completeError());
      return future;
    }
  },
  Stream_fold_closure: {
    "^": "Closure;box_0,this_1,combine_2,result_3",
    call$1: function(element) {
      var t1 = this.box_0;
      P._runUserCode(new P.Stream_fold__closure(t1, this.combine_2, element), new P.Stream_fold__closure0(t1), P._cancelAndErrorClosure(t1.subscription_1, this.result_3));
    },
    $isFunction: true,
    $signature: function() {
      return H.computeSignature(function(T) {
        return {func: "dynamic__T", args: [T]};
      }, this.this_1, "Stream");
    }
  },
  Stream_fold__closure: {
    "^": "Closure:23;box_0,combine_4,element_5",
    call$0: function() {
      return this.combine_4.call$2(this.box_0.value_0, this.element_5);
    },
    $isFunction: true
  },
  Stream_fold__closure0: {
    "^": "Closure:13;box_0",
    call$1: function(newValue) {
      this.box_0.value_0 = newValue;
    },
    $isFunction: true
  },
  Stream_fold_closure1: {
    "^": "Closure:19;result_6",
    call$2: function(e, st) {
      this.result_6._completeError$2(e, st);
    },
    $isFunction: true
  },
  Stream_fold_closure0: {
    "^": "Closure:23;box_0,result_7",
    call$0: function() {
      this.result_7._complete$1(this.box_0.value_0);
    },
    $isFunction: true
  },
  Stream_contains_closure: {
    "^": "Closure;box_0,this_1,needle_2,future_3",
    call$1: function(element) {
      var t1, t2;
      t1 = this.box_0;
      t2 = this.future_3;
      P._runUserCode(new P.Stream_contains__closure(this.needle_2, element), new P.Stream_contains__closure0(t1, t2), P._cancelAndErrorClosure(t1.subscription_0, t2));
    },
    $isFunction: true,
    $signature: function() {
      return H.computeSignature(function(T) {
        return {func: "dynamic__T", args: [T]};
      }, this.this_1, "Stream");
    }
  },
  Stream_contains__closure: {
    "^": "Closure:23;needle_4,element_5",
    call$0: function() {
      return J.$eq(this.element_5, this.needle_4);
    },
    $isFunction: true
  },
  Stream_contains__closure0: {
    "^": "Closure:54;box_0,future_6",
    call$1: function(isMatch) {
      if (isMatch === true)
        P._cancelAndValue(this.box_0.subscription_0, this.future_6, true);
    },
    $isFunction: true
  },
  Stream_contains_closure0: {
    "^": "Closure:23;future_7",
    call$0: function() {
      this.future_7._complete$1(false);
    },
    $isFunction: true
  },
  Stream_forEach_closure: {
    "^": "Closure;box_0,this_1,action_2,future_3",
    call$1: function(element) {
      P._runUserCode(new P.Stream_forEach__closure(this.action_2, element), new P.Stream_forEach__closure0(), P._cancelAndErrorClosure(this.box_0.subscription_0, this.future_3));
    },
    $isFunction: true,
    $signature: function() {
      return H.computeSignature(function(T) {
        return {func: "dynamic__T", args: [T]};
      }, this.this_1, "Stream");
    }
  },
  Stream_forEach__closure: {
    "^": "Closure:23;action_4,element_5",
    call$0: function() {
      return this.action_4.call$1(this.element_5);
    },
    $isFunction: true
  },
  Stream_forEach__closure0: {
    "^": "Closure:13;",
    call$1: function(_) {
    },
    $isFunction: true
  },
  Stream_forEach_closure0: {
    "^": "Closure:23;future_6",
    call$0: function() {
      this.future_6._complete$1(null);
    },
    $isFunction: true
  },
  Stream_every_closure: {
    "^": "Closure;box_0,this_1,test_2,future_3",
    call$1: function(element) {
      var t1, t2;
      t1 = this.box_0;
      t2 = this.future_3;
      P._runUserCode(new P.Stream_every__closure(this.test_2, element), new P.Stream_every__closure0(t1, t2), P._cancelAndErrorClosure(t1.subscription_0, t2));
    },
    $isFunction: true,
    $signature: function() {
      return H.computeSignature(function(T) {
        return {func: "dynamic__T", args: [T]};
      }, this.this_1, "Stream");
    }
  },
  Stream_every__closure: {
    "^": "Closure:23;test_4,element_5",
    call$0: function() {
      return this.test_4.call$1(this.element_5);
    },
    $isFunction: true
  },
  Stream_every__closure0: {
    "^": "Closure:54;box_0,future_6",
    call$1: function(isMatch) {
      if (isMatch !== true)
        P._cancelAndValue(this.box_0.subscription_0, this.future_6, false);
    },
    $isFunction: true
  },
  Stream_every_closure0: {
    "^": "Closure:23;future_7",
    call$0: function() {
      this.future_7._complete$1(true);
    },
    $isFunction: true
  },
  Stream_any_closure: {
    "^": "Closure;box_0,this_1,test_2,future_3",
    call$1: function(element) {
      var t1, t2;
      t1 = this.box_0;
      t2 = this.future_3;
      P._runUserCode(new P.Stream_any__closure(this.test_2, element), new P.Stream_any__closure0(t1, t2), P._cancelAndErrorClosure(t1.subscription_0, t2));
    },
    $isFunction: true,
    $signature: function() {
      return H.computeSignature(function(T) {
        return {func: "dynamic__T", args: [T]};
      }, this.this_1, "Stream");
    }
  },
  Stream_any__closure: {
    "^": "Closure:23;test_4,element_5",
    call$0: function() {
      return this.test_4.call$1(this.element_5);
    },
    $isFunction: true
  },
  Stream_any__closure0: {
    "^": "Closure:54;box_0,future_6",
    call$1: function(isMatch) {
      if (isMatch === true)
        P._cancelAndValue(this.box_0.subscription_0, this.future_6, true);
    },
    $isFunction: true
  },
  Stream_any_closure0: {
    "^": "Closure:23;future_7",
    call$0: function() {
      this.future_7._complete$1(false);
    },
    $isFunction: true
  },
  Stream_length_closure: {
    "^": "Closure:13;box_0",
    call$1: function(_) {
      ++this.box_0.count_0;
    },
    $isFunction: true
  },
  Stream_length_closure0: {
    "^": "Closure:23;box_0,future_1",
    call$0: function() {
      this.future_1._complete$1(this.box_0.count_0);
    },
    $isFunction: true
  },
  Stream_isEmpty_closure: {
    "^": "Closure:13;box_0,future_1",
    call$1: function(_) {
      P._cancelAndValue(this.box_0.subscription_0, this.future_1, false);
    },
    $isFunction: true
  },
  Stream_isEmpty_closure0: {
    "^": "Closure:23;future_2",
    call$0: function() {
      this.future_2._complete$1(true);
    },
    $isFunction: true
  },
  Stream_toList_closure: {
    "^": "Closure;this_0,result_1",
    call$1: function(data) {
      this.result_1.push(data);
    },
    $isFunction: true,
    $signature: function() {
      return H.computeSignature(function(T) {
        return {func: "dynamic__T", args: [T]};
      }, this.this_0, "Stream");
    }
  },
  Stream_toList_closure0: {
    "^": "Closure:23;result_2,future_3",
    call$0: function() {
      this.future_3._complete$1(this.result_2);
    },
    $isFunction: true
  },
  Stream_first_closure: {
    "^": "Closure;box_0,this_1,future_2",
    call$1: function(value) {
      P._cancelAndValue(this.box_0.subscription_0, this.future_2, value);
    },
    $isFunction: true,
    $signature: function() {
      return H.computeSignature(function(T) {
        return {func: "dynamic__T", args: [T]};
      }, this.this_1, "Stream");
    }
  },
  Stream_first_closure0: {
    "^": "Closure:23;future_3",
    call$0: function() {
      var e, s, t1, exception;
      try {
        t1 = H.IterableElementError_noElement();
        throw H.wrapException(t1);
      } catch (exception) {
        t1 = H.unwrapException(exception);
        e = t1;
        s = new H._StackTrace(exception, null);
        this.future_3._completeError$2(e, s);
      }

    },
    $isFunction: true
  },
  Stream_last_closure: {
    "^": "Closure;box_0,this_1",
    call$1: function(value) {
      var t1 = this.box_0;
      t1.foundResult_1 = true;
      t1.result_0 = value;
    },
    $isFunction: true,
    $signature: function() {
      return H.computeSignature(function(T) {
        return {func: "dynamic__T", args: [T]};
      }, this.this_1, "Stream");
    }
  },
  Stream_last_closure0: {
    "^": "Closure:23;box_0,future_2",
    call$0: function() {
      var e, s, t1, exception;
      t1 = this.box_0;
      if (t1.foundResult_1) {
        this.future_2._complete$1(t1.result_0);
        return;
      }
      try {
        t1 = H.IterableElementError_noElement();
        throw H.wrapException(t1);
      } catch (exception) {
        t1 = H.unwrapException(exception);
        e = t1;
        s = new H._StackTrace(exception, null);
        this.future_2._completeError$2(e, s);
      }

    },
    $isFunction: true
  },
  Stream_single_closure: {
    "^": "Closure;box_0,this_1,future_2",
    call$1: function(value) {
      var e, s, t1, t2, exception;
      t1 = this.box_0;
      if (t1.foundResult_1) {
        try {
          t2 = H.IterableElementError_tooMany();
          throw H.wrapException(t2);
        } catch (exception) {
          t2 = H.unwrapException(exception);
          e = t2;
          s = new H._StackTrace(exception, null);
          P._cancelAndError(t1.subscription_2, this.future_2, e, s);
        }

        return;
      }
      t1.foundResult_1 = true;
      t1.result_0 = value;
    },
    $isFunction: true,
    $signature: function() {
      return H.computeSignature(function(T) {
        return {func: "dynamic__T", args: [T]};
      }, this.this_1, "Stream");
    }
  },
  Stream_single_closure0: {
    "^": "Closure:23;box_0,future_3",
    call$0: function() {
      var e, s, t1, exception;
      t1 = this.box_0;
      if (t1.foundResult_1) {
        this.future_3._complete$1(t1.result_0);
        return;
      }
      try {
        t1 = H.IterableElementError_noElement();
        throw H.wrapException(t1);
      } catch (exception) {
        t1 = H.unwrapException(exception);
        e = t1;
        s = new H._StackTrace(exception, null);
        this.future_3._completeError$2(e, s);
      }

    },
    $isFunction: true
  },
  StreamSubscription: {
    "^": "Object;"
  },
  _StreamController: {
    "^": "Object;",
    get$_pendingEvents: function() {
      if ((this._state & 8) === 0)
        return this._varData;
      return this._varData.get$varData();
    },
    _ensurePendingEvents$0: function() {
      var t1, state;
      if ((this._state & 8) === 0) {
        t1 = this._varData;
        if (t1 == null) {
          t1 = new P._StreamImplEvents(null, null, 0);
          this._varData = t1;
        }
        return t1;
      }
      state = this._varData;
      state.get$varData();
      return state.get$varData();
    },
    get$_subscription: function() {
      if ((this._state & 8) !== 0)
        return this._varData.get$varData();
      return this._varData;
    },
    _badEventState$0: function() {
      if ((this._state & 4) !== 0)
        return new P.StateError("Cannot add event after closing");
      return new P.StateError("Cannot add event while adding a stream");
    },
    _ensureDoneFuture$0: function() {
      var t1 = this._doneFuture;
      if (t1 == null) {
        t1 = (this._state & 2) !== 0 ? $.get$Future__nullFuture() : P._Future$(null);
        this._doneFuture = t1;
      }
      return t1;
    },
    add$1: [function(_, value) {
      var t1 = this._state;
      if (t1 >= 4)
        throw H.wrapException(this._badEventState$0());
      if ((t1 & 1) !== 0)
        this._sendData$1(value);
      else if ((t1 & 3) === 0)
        this._ensurePendingEvents$0().add$1(0, H.setRuntimeTypeInfo(new P._DelayedData(value, null), [H.getRuntimeTypeArgument(this, "_StreamController", 0)]));
    }, "call$1", "get$add", 2, 0, function() {
      return H.computeSignature(function(T) {
        return {func: "void__T", void: true, args: [T]};
      }, this.$receiver, "_StreamController");
    }],
    close$0: function(_) {
      var t1 = this._state;
      if ((t1 & 4) !== 0)
        return this._ensureDoneFuture$0();
      if (t1 >= 4)
        throw H.wrapException(this._badEventState$0());
      t1 |= 4;
      this._state = t1;
      if ((t1 & 1) !== 0)
        this._sendDone$0();
      else if ((t1 & 3) === 0)
        this._ensurePendingEvents$0().add$1(0, C.C__DelayedDone);
      return this._ensureDoneFuture$0();
    },
    _async$_add$1: function(value) {
      var t1 = this._state;
      if ((t1 & 1) !== 0)
        this._sendData$1(value);
      else if ((t1 & 3) === 0)
        this._ensurePendingEvents$0().add$1(0, H.setRuntimeTypeInfo(new P._DelayedData(value, null), [H.getRuntimeTypeArgument(this, "_StreamController", 0)]));
    },
    _addError$2: function(error, stackTrace) {
      var t1 = this._state;
      if ((t1 & 1) !== 0)
        this._sendError$2(error, stackTrace);
      else if ((t1 & 3) === 0)
        this._ensurePendingEvents$0().add$1(0, new P._DelayedError(error, stackTrace, null));
    },
    _subscribe$4: function(onData, onError, onDone, cancelOnError) {
      var t1, t2, subscription, pendingEvents, addState;
      if ((this._state & 3) !== 0)
        throw H.wrapException(P.StateError$("Stream has already been listened to."));
      t1 = $.Zone__current;
      t2 = cancelOnError ? 1 : 0;
      subscription = H.setRuntimeTypeInfo(new P._ControllerSubscription(this, null, null, null, t1, t2, null, null), [null]);
      subscription._BufferingStreamSubscription$4(onData, onError, onDone, cancelOnError, null);
      pendingEvents = this.get$_pendingEvents();
      t2 = this._state |= 1;
      if ((t2 & 8) !== 0) {
        addState = this._varData;
        addState.set$varData(subscription);
        addState.resume$0();
      } else
        this._varData = subscription;
      subscription._setPendingEvents$1(pendingEvents);
      subscription._guardCallback$1(new P._StreamController__subscribe_closure(this));
      return subscription;
    },
    _recordCancel$1: function(subscription) {
      var result, e, s, exception, t1, result0;
      result = null;
      if ((this._state & 8) !== 0)
        result = this._varData.cancel$0();
      this._varData = null;
      this._state = this._state & 4294967286 | 2;
      if (this.get$_onCancel() != null)
        if (result == null)
          try {
            result = this._onCancel$0();
          } catch (exception) {
            t1 = H.unwrapException(exception);
            e = t1;
            s = new H._StackTrace(exception, null);
            result0 = P._Future$(null);
            result0._asyncCompleteError$2(e, s);
            result = result0;
          }

        else
          result = result.whenComplete$1(this.get$_onCancel());
      t1 = new P._StreamController__recordCancel_complete(this);
      if (result != null)
        result = result.whenComplete$1(t1);
      else
        t1.call$0();
      return result;
    },
    _recordPause$1: function(subscription) {
      if ((this._state & 8) !== 0)
        this._varData.pause$0(0);
      P._runGuarded(this.get$_onPause());
    },
    _recordResume$1: function(subscription) {
      if ((this._state & 8) !== 0)
        this._varData.resume$0();
      P._runGuarded(this.get$_onResume());
    }
  },
  _StreamController__subscribe_closure: {
    "^": "Closure:23;this_0",
    call$0: function() {
      P._runGuarded(this.this_0.get$_onListen());
    },
    $isFunction: true
  },
  _StreamController__recordCancel_complete: {
    "^": "Closure:7;this_0",
    call$0: function() {
      var t1 = this.this_0._doneFuture;
      if (t1 != null && t1._state === 0)
        t1._asyncComplete$1(null);
    },
    $isFunction: true
  },
  _SyncStreamControllerDispatch: {
    "^": "Object;",
    _sendData$1: function(data) {
      this.get$_subscription()._async$_add$1(data);
    },
    _sendError$2: function(error, stackTrace) {
      this.get$_subscription()._addError$2(error, stackTrace);
    },
    _sendDone$0: function() {
      this.get$_subscription()._close$0();
    }
  },
  _AsyncStreamControllerDispatch: {
    "^": "Object;",
    _sendData$1: function(data) {
      this.get$_subscription()._addPending$1(H.setRuntimeTypeInfo(new P._DelayedData(data, null), [null]));
    },
    _sendError$2: function(error, stackTrace) {
      this.get$_subscription()._addPending$1(new P._DelayedError(error, stackTrace, null));
    },
    _sendDone$0: function() {
      this.get$_subscription()._addPending$1(C.C__DelayedDone);
    }
  },
  _AsyncStreamController: {
    "^": "_StreamController__AsyncStreamControllerDispatch;_onListen<,_onPause<,_onResume<,_onCancel<,_varData,_state,_doneFuture",
    _onCancel$0: function() {
      return this._onCancel.call$0();
    }
  },
  _StreamController__AsyncStreamControllerDispatch: {
    "^": "_StreamController+_AsyncStreamControllerDispatch;"
  },
  _SyncStreamController: {
    "^": "_StreamController__SyncStreamControllerDispatch;_onListen<,_onPause<,_onResume<,_onCancel<,_varData,_state,_doneFuture",
    _onCancel$0: function() {
      return this._onCancel.call$0();
    }
  },
  _StreamController__SyncStreamControllerDispatch: {
    "^": "_StreamController+_SyncStreamControllerDispatch;"
  },
  _ControllerStream: {
    "^": "_StreamImpl;_async$_controller",
    _createSubscription$4: function(onData, onError, onDone, cancelOnError) {
      return this._async$_controller._subscribe$4(onData, onError, onDone, cancelOnError);
    },
    get$hashCode: function(_) {
      return (H.Primitives_objectHashCode(this._async$_controller) ^ 892482866) >>> 0;
    },
    $eq: function(_, other) {
      if (other == null)
        return false;
      if (this === other)
        return true;
      if (!J.getInterceptor(other).$is_ControllerStream)
        return false;
      return other._async$_controller === this._async$_controller;
    },
    $is_ControllerStream: true
  },
  _ControllerSubscription: {
    "^": "_BufferingStreamSubscription;_async$_controller<,_onData,_onError,_onDone,_zone,_state,_cancelFuture,_pending",
    _onCancel$0: function() {
      return this.get$_async$_controller()._recordCancel$1(this);
    },
    _onPause$0: [function() {
      this.get$_async$_controller()._recordPause$1(this);
    }, "call$0", "get$_onPause", 0, 0, 7],
    _onResume$0: [function() {
      this.get$_async$_controller()._recordResume$1(this);
    }, "call$0", "get$_onResume", 0, 0, 7]
  },
  _EventSink: {
    "^": "Object;"
  },
  _BufferingStreamSubscription: {
    "^": "Object;_onData,_onError,_onDone,_zone,_state,_cancelFuture,_pending",
    _setPendingEvents$1: function(pendingEvents) {
      if (pendingEvents == null)
        return;
      this._pending = pendingEvents;
      if (pendingEvents.lastPendingEvent != null) {
        this._state = (this._state | 64) >>> 0;
        pendingEvents.schedule$1(this);
      }
    },
    pause$1: function(_, resumeSignal) {
      var t1, t2, t3;
      t1 = this._state;
      if ((t1 & 8) !== 0)
        return;
      t2 = (t1 + 128 | 4) >>> 0;
      this._state = t2;
      if (t1 < 128 && this._pending != null) {
        t3 = this._pending;
        if (t3._state === 1)
          t3._state = 3;
      }
      if ((t1 & 4) === 0 && (t2 & 32) === 0)
        this._guardCallback$1(this.get$_onPause());
    },
    pause$0: function($receiver) {
      return this.pause$1($receiver, null);
    },
    resume$0: function() {
      var t1 = this._state;
      if ((t1 & 8) !== 0)
        return;
      if (t1 >= 128) {
        t1 -= 128;
        this._state = t1;
        if (t1 < 128)
          if ((t1 & 64) !== 0 && this._pending.lastPendingEvent != null)
            this._pending.schedule$1(this);
          else {
            t1 = (t1 & 4294967291) >>> 0;
            this._state = t1;
            if ((t1 & 32) === 0)
              this._guardCallback$1(this.get$_onResume());
          }
      }
    },
    cancel$0: function() {
      var t1 = (this._state & 4294967279) >>> 0;
      this._state = t1;
      if ((t1 & 8) !== 0)
        return this._cancelFuture;
      this._cancel$0();
      return this._cancelFuture;
    },
    _cancel$0: function() {
      var t1, t2;
      t1 = (this._state | 8) >>> 0;
      this._state = t1;
      if ((t1 & 64) !== 0) {
        t2 = this._pending;
        if (t2._state === 1)
          t2._state = 3;
      }
      if ((t1 & 32) === 0)
        this._pending = null;
      this._cancelFuture = this._onCancel$0();
    },
    _async$_add$1: function(data) {
      var t1 = this._state;
      if ((t1 & 8) !== 0)
        return;
      if (t1 < 32)
        this._sendData$1(data);
      else
        this._addPending$1(H.setRuntimeTypeInfo(new P._DelayedData(data, null), [null]));
    },
    _addError$2: function(error, stackTrace) {
      var t1 = this._state;
      if ((t1 & 8) !== 0)
        return;
      if (t1 < 32)
        this._sendError$2(error, stackTrace);
      else
        this._addPending$1(new P._DelayedError(error, stackTrace, null));
    },
    _close$0: function() {
      var t1 = this._state;
      if ((t1 & 8) !== 0)
        return;
      t1 = (t1 | 2) >>> 0;
      this._state = t1;
      if (t1 < 32)
        this._sendDone$0();
      else
        this._addPending$1(C.C__DelayedDone);
    },
    _onPause$0: [function() {
    }, "call$0", "get$_onPause", 0, 0, 7],
    _onResume$0: [function() {
    }, "call$0", "get$_onResume", 0, 0, 7],
    _onCancel$0: function() {
      return;
    },
    _addPending$1: function($event) {
      var pending, t1;
      pending = this._pending;
      if (pending == null) {
        pending = new P._StreamImplEvents(null, null, 0);
        this._pending = pending;
      }
      pending.add$1(0, $event);
      t1 = this._state;
      if ((t1 & 64) === 0) {
        t1 = (t1 | 64) >>> 0;
        this._state = t1;
        if (t1 < 128)
          this._pending.schedule$1(this);
      }
    },
    _sendData$1: function(data) {
      var t1 = this._state;
      this._state = (t1 | 32) >>> 0;
      this._zone.runUnaryGuarded$2(this._onData, data);
      this._state = (this._state & 4294967263) >>> 0;
      this._checkState$1((t1 & 4) !== 0);
    },
    _sendError$2: function(error, stackTrace) {
      var t1, t2;
      t1 = this._state;
      t2 = new P._BufferingStreamSubscription__sendError_sendError(this, error, stackTrace);
      if ((t1 & 1) !== 0) {
        this._state = (t1 | 16) >>> 0;
        this._cancel$0();
        t1 = this._cancelFuture;
        if (!!J.getInterceptor(t1).$isFuture)
          t1.whenComplete$1(t2);
        else
          t2.call$0();
      } else {
        t2.call$0();
        this._checkState$1((t1 & 4) !== 0);
      }
    },
    _sendDone$0: function() {
      var t1, t2;
      t1 = new P._BufferingStreamSubscription__sendDone_sendDone(this);
      this._cancel$0();
      this._state = (this._state | 16) >>> 0;
      t2 = this._cancelFuture;
      if (!!J.getInterceptor(t2).$isFuture)
        t2.whenComplete$1(t1);
      else
        t1.call$0();
    },
    _guardCallback$1: function(callback) {
      var t1 = this._state;
      this._state = (t1 | 32) >>> 0;
      callback.call$0();
      this._state = (this._state & 4294967263) >>> 0;
      this._checkState$1((t1 & 4) !== 0);
    },
    _checkState$1: function(wasInputPaused) {
      var t1, t2, isInputPaused;
      t1 = this._state;
      if ((t1 & 64) !== 0 && this._pending.lastPendingEvent == null) {
        t1 = (t1 & 4294967231) >>> 0;
        this._state = t1;
        if ((t1 & 4) !== 0)
          if (t1 < 128) {
            t2 = this._pending;
            t2 = t2 == null || t2.lastPendingEvent == null;
          } else
            t2 = false;
        else
          t2 = false;
        if (t2) {
          t1 = (t1 & 4294967291) >>> 0;
          this._state = t1;
        }
      }
      for (; true; wasInputPaused = isInputPaused) {
        if ((t1 & 8) !== 0) {
          this._pending = null;
          return;
        }
        isInputPaused = (t1 & 4) !== 0;
        if (wasInputPaused === isInputPaused)
          break;
        this._state = (t1 ^ 32) >>> 0;
        if (isInputPaused)
          this._onPause$0();
        else
          this._onResume$0();
        t1 = (this._state & 4294967263) >>> 0;
        this._state = t1;
      }
      if ((t1 & 64) !== 0 && t1 < 128)
        this._pending.schedule$1(this);
    },
    _BufferingStreamSubscription$4: function(onData, onError, onDone, cancelOnError, $T) {
      var t1 = this._zone;
      t1.toString;
      this._onData = onData;
      this._onError = P._registerErrorHandler(onError == null ? P._nullErrorHandler$closure() : onError, t1);
      this._onDone = onDone == null ? P._nullDoneHandler$closure() : onDone;
    },
    static: {"^": "_BufferingStreamSubscription__STATE_CANCEL_ON_ERROR,_BufferingStreamSubscription__STATE_CLOSED,_BufferingStreamSubscription__STATE_INPUT_PAUSED,_BufferingStreamSubscription__STATE_CANCELED,_BufferingStreamSubscription__STATE_WAIT_FOR_CANCEL,_BufferingStreamSubscription__STATE_IN_CALLBACK,_BufferingStreamSubscription__STATE_HAS_PENDING,_BufferingStreamSubscription__STATE_PAUSE_COUNT,_BufferingStreamSubscription__STATE_PAUSE_COUNT_SHIFT", _BufferingStreamSubscription$: function(onData, onError, onDone, cancelOnError, $T) {
        var t1, t2;
        t1 = $.Zone__current;
        t2 = cancelOnError ? 1 : 0;
        t2 = H.setRuntimeTypeInfo(new P._BufferingStreamSubscription(null, null, null, t1, t2, null, null), [$T]);
        t2._BufferingStreamSubscription$4(onData, onError, onDone, cancelOnError, $T);
        return t2;
      }}
  },
  _BufferingStreamSubscription__sendError_sendError: {
    "^": "Closure:7;this_0,error_1,stackTrace_2",
    call$0: function() {
      var t1, t2, t3, t4, t5, t6;
      t1 = this.this_0;
      t2 = t1._state;
      if ((t2 & 8) !== 0 && (t2 & 16) === 0)
        return;
      t1._state = (t2 | 32) >>> 0;
      t2 = t1._onError;
      t3 = H.getDynamicRuntimeType();
      t3 = H.buildFunctionType(t3, [t3, t3])._isTest$1(t2);
      t4 = t1._zone;
      t5 = this.error_1;
      t6 = t1._onError;
      if (t3)
        t4.runBinaryGuarded$3(t6, t5, this.stackTrace_2);
      else
        t4.runUnaryGuarded$2(t6, t5);
      t1._state = (t1._state & 4294967263) >>> 0;
    },
    $isFunction: true
  },
  _BufferingStreamSubscription__sendDone_sendDone: {
    "^": "Closure:7;this_0",
    call$0: function() {
      var t1, t2;
      t1 = this.this_0;
      t2 = t1._state;
      if ((t2 & 16) === 0)
        return;
      t1._state = (t2 | 42) >>> 0;
      t1._zone.runGuarded$1(t1._onDone);
      t1._state = (t1._state & 4294967263) >>> 0;
    },
    $isFunction: true
  },
  _StreamImpl: {
    "^": "Stream;",
    listen$4$cancelOnError$onDone$onError: function(onData, cancelOnError, onDone, onError) {
      return this._createSubscription$4(onData, onError, onDone, true === cancelOnError);
    },
    listen$3$onDone$onError: function(onData, onDone, onError) {
      return this.listen$4$cancelOnError$onDone$onError(onData, null, onDone, onError);
    },
    _createSubscription$4: function(onData, onError, onDone, cancelOnError) {
      return P._BufferingStreamSubscription$(onData, onError, onDone, cancelOnError, H.getTypeArgumentByIndex(this, 0));
    }
  },
  _DelayedEvent: {
    "^": "Object;next@"
  },
  _DelayedData: {
    "^": "_DelayedEvent;value>,next",
    perform$1: function(dispatch) {
      dispatch._sendData$1(this.value);
    }
  },
  _DelayedError: {
    "^": "_DelayedEvent;error>,stackTrace<,next",
    perform$1: function(dispatch) {
      dispatch._sendError$2(this.error, this.stackTrace);
    }
  },
  _DelayedDone: {
    "^": "Object;",
    perform$1: function(dispatch) {
      dispatch._sendDone$0();
    },
    get$next: function() {
      return;
    },
    set$next: function(_) {
      throw H.wrapException(P.StateError$("No events after a done."));
    }
  },
  _PendingEvents: {
    "^": "Object;",
    schedule$1: function(dispatch) {
      var t1 = this._state;
      if (t1 === 1)
        return;
      if (t1 >= 1) {
        this._state = 1;
        return;
      }
      P.scheduleMicrotask(new P._PendingEvents_schedule_closure(this, dispatch));
      this._state = 1;
    }
  },
  _PendingEvents_schedule_closure: {
    "^": "Closure:23;this_0,dispatch_1",
    call$0: function() {
      var t1, oldState;
      t1 = this.this_0;
      oldState = t1._state;
      t1._state = 0;
      if (oldState === 3)
        return;
      t1.handleNext$1(this.dispatch_1);
    },
    $isFunction: true
  },
  _StreamImplEvents: {
    "^": "_PendingEvents;firstPendingEvent,lastPendingEvent,_state",
    get$isEmpty: function(_) {
      return this.lastPendingEvent == null;
    },
    add$1: function(_, $event) {
      var t1 = this.lastPendingEvent;
      if (t1 == null) {
        this.lastPendingEvent = $event;
        this.firstPendingEvent = $event;
      } else {
        t1.set$next($event);
        this.lastPendingEvent = $event;
      }
    },
    handleNext$1: function(dispatch) {
      var $event, t1;
      $event = this.firstPendingEvent;
      t1 = $event.get$next();
      this.firstPendingEvent = t1;
      if (t1 == null)
        this.lastPendingEvent = null;
      $event.perform$1(dispatch);
    },
    clear$0: function(_) {
      if (this._state === 1)
        this._state = 3;
      this.lastPendingEvent = null;
      this.firstPendingEvent = null;
    }
  },
  _cancelAndError_closure: {
    "^": "Closure:23;future_0,error_1,stackTrace_2",
    call$0: function() {
      return this.future_0._completeError$2(this.error_1, this.stackTrace_2);
    },
    $isFunction: true
  },
  _cancelAndErrorClosure_closure: {
    "^": "Closure:57;subscription_0,future_1",
    call$2: function(error, stackTrace) {
      return P._cancelAndError(this.subscription_0, this.future_1, error, stackTrace);
    },
    $isFunction: true
  },
  _cancelAndValue_closure: {
    "^": "Closure:23;future_0,value_1",
    call$0: function() {
      return this.future_0._complete$1(this.value_1);
    },
    $isFunction: true
  },
  _ForwardingStream: {
    "^": "Stream;",
    listen$4$cancelOnError$onDone$onError: function(onData, cancelOnError, onDone, onError) {
      var t1, t2, t3, t4;
      cancelOnError = true === cancelOnError;
      t1 = H.getRuntimeTypeArgument(this, "_ForwardingStream", 0);
      t2 = H.getRuntimeTypeArgument(this, "_ForwardingStream", 1);
      t3 = $.Zone__current;
      t4 = cancelOnError ? 1 : 0;
      t4 = H.setRuntimeTypeInfo(new P._ForwardingStreamSubscription(this, null, null, null, null, t3, t4, null, null), [t1, t2]);
      t4._BufferingStreamSubscription$4(onData, onError, onDone, cancelOnError, t2);
      t4._ForwardingStreamSubscription$5(this, onData, onError, onDone, cancelOnError, t1, t2);
      return t4;
    },
    listen$3$onDone$onError: function(onData, onDone, onError) {
      return this.listen$4$cancelOnError$onDone$onError(onData, null, onDone, onError);
    },
    _handleData$2: function(data, sink) {
      sink._async$_add$1(data);
    },
    $asStream: function($S, $T) {
      return [$T];
    }
  },
  _ForwardingStreamSubscription: {
    "^": "_BufferingStreamSubscription;_stream,_subscription,_onData,_onError,_onDone,_zone,_state,_cancelFuture,_pending",
    _async$_add$1: function(data) {
      if ((this._state & 2) !== 0)
        return;
      P._BufferingStreamSubscription.prototype._async$_add$1.call(this, data);
    },
    _addError$2: function(error, stackTrace) {
      if ((this._state & 2) !== 0)
        return;
      P._BufferingStreamSubscription.prototype._addError$2.call(this, error, stackTrace);
    },
    _onPause$0: [function() {
      var t1 = this._subscription;
      if (t1 == null)
        return;
      t1.pause$0(0);
    }, "call$0", "get$_onPause", 0, 0, 7],
    _onResume$0: [function() {
      var t1 = this._subscription;
      if (t1 == null)
        return;
      t1.resume$0();
    }, "call$0", "get$_onResume", 0, 0, 7],
    _onCancel$0: function() {
      var t1 = this._subscription;
      if (t1 != null) {
        this._subscription = null;
        t1.cancel$0();
      }
      return;
    },
    _handleData$1: [function(data) {
      this._stream._handleData$2(data, this);
    }, "call$1", "get$_handleData", 2, 0, function() {
      return H.computeSignature(function(S, T) {
        return {func: "void__S", void: true, args: [S]};
      }, this.$receiver, "_ForwardingStreamSubscription");
    }],
    _handleError$2: [function(error, stackTrace) {
      this._addError$2(error, stackTrace);
    }, "call$2", "get$_handleError", 4, 0, 58],
    _handleDone$0: [function() {
      this._close$0();
    }, "call$0", "get$_handleDone", 0, 0, 7],
    _ForwardingStreamSubscription$5: function(_stream, onData, onError, onDone, cancelOnError, $S, $T) {
      var t1, t2;
      t1 = this.get$_handleData();
      t2 = this.get$_handleError();
      this._subscription = this._stream._async$_source.listen$3$onDone$onError(t1, this.get$_handleDone(), t2);
    },
    $as_BufferingStreamSubscription: function($S, $T) {
      return [$T];
    }
  },
  _WhereStream: {
    "^": "_ForwardingStream;_test,_async$_source",
    _test$1: function(arg0) {
      return this._test.call$1(arg0);
    },
    _handleData$2: function(inputEvent, sink) {
      var satisfies, e, s, exception, t1;
      satisfies = null;
      try {
        satisfies = this._test$1(inputEvent);
      } catch (exception) {
        t1 = H.unwrapException(exception);
        e = t1;
        s = new H._StackTrace(exception, null);
        sink._addError$2(e, s);
        return;
      }

      if (satisfies === true)
        sink._async$_add$1(inputEvent);
    },
    $as_ForwardingStream: function($T) {
      return [$T, $T];
    },
    $asStream: null
  },
  _MapStream: {
    "^": "_ForwardingStream;_transform,_async$_source",
    _transform$1: function(arg0) {
      return this._transform.call$1(arg0);
    },
    _handleData$2: function(inputEvent, sink) {
      var outputEvent, e, s, exception, t1;
      outputEvent = null;
      try {
        outputEvent = this._transform$1(inputEvent);
      } catch (exception) {
        t1 = H.unwrapException(exception);
        e = t1;
        s = new H._StackTrace(exception, null);
        sink._addError$2(e, s);
        return;
      }

      sink._async$_add$1(outputEvent);
    }
  },
  _ExpandStream: {
    "^": "_ForwardingStream;_expand,_async$_source",
    _expand$1: function(arg0) {
      return this._expand.call$1(arg0);
    },
    _handleData$2: function(inputEvent, sink) {
      var value, e, s, t1, exception;
      try {
        for (t1 = J.get$iterator$ax(this._expand$1(inputEvent)); t1.moveNext$0();) {
          value = t1.get$current();
          sink._async$_add$1(value);
        }
      } catch (exception) {
        t1 = H.unwrapException(exception);
        e = t1;
        s = new H._StackTrace(exception, null);
        sink._addError$2(e, s);
      }

    }
  },
  _Zone: {
    "^": "Object;"
  },
  _rootHandleUncaughtError_closure: {
    "^": "Closure:23;error_0,stackTrace_1",
    call$0: function() {
      throw H.wrapException(P._UncaughtAsyncError$(this.error_0, this.stackTrace_1));
    },
    $isFunction: true
  },
  _RootZone: {
    "^": "_Zone;",
    get$parent: function(_) {
      return;
    },
    get$errorZone: function() {
      return this;
    },
    runGuarded$1: function(f) {
      var e, s, t1, exception;
      try {
        if (C.C__RootZone === $.Zone__current) {
          t1 = f.call$0();
          return t1;
        }
        t1 = P._rootRun(null, null, this, f);
        return t1;
      } catch (exception) {
        t1 = H.unwrapException(exception);
        e = t1;
        s = new H._StackTrace(exception, null);
        return P._rootHandleUncaughtError(null, null, this, e, s);
      }

    },
    runUnaryGuarded$2: function(f, arg) {
      var e, s, t1, exception;
      try {
        if (C.C__RootZone === $.Zone__current) {
          t1 = f.call$1(arg);
          return t1;
        }
        t1 = P._rootRunUnary(null, null, this, f, arg);
        return t1;
      } catch (exception) {
        t1 = H.unwrapException(exception);
        e = t1;
        s = new H._StackTrace(exception, null);
        return P._rootHandleUncaughtError(null, null, this, e, s);
      }

    },
    runBinaryGuarded$3: function(f, arg1, arg2) {
      var e, s, t1, exception;
      try {
        if (C.C__RootZone === $.Zone__current) {
          t1 = f.call$2(arg1, arg2);
          return t1;
        }
        t1 = P._rootRunBinary(null, null, this, f, arg1, arg2);
        return t1;
      } catch (exception) {
        t1 = H.unwrapException(exception);
        e = t1;
        s = new H._StackTrace(exception, null);
        return P._rootHandleUncaughtError(null, null, this, e, s);
      }

    },
    bindCallback$2$runGuarded: function(f, runGuarded) {
      if (runGuarded)
        return new P._RootZone_bindCallback_closure(this, f);
      else
        return new P._RootZone_bindCallback_closure0(this, f);
    },
    bindCallback$1: function(f) {
      return this.bindCallback$2$runGuarded(f, true);
    },
    bindUnaryCallback$2$runGuarded: function(f, runGuarded) {
      if (runGuarded)
        return new P._RootZone_bindUnaryCallback_closure(this, f);
      else
        return new P._RootZone_bindUnaryCallback_closure0(this, f);
    },
    $index: function(_, key) {
      return;
    },
    run$1: function(f) {
      if ($.Zone__current === C.C__RootZone)
        return f.call$0();
      return P._rootRun(null, null, this, f);
    },
    runUnary$2: function(f, arg) {
      if ($.Zone__current === C.C__RootZone)
        return f.call$1(arg);
      return P._rootRunUnary(null, null, this, f, arg);
    },
    runBinary$3: function(f, arg1, arg2) {
      if ($.Zone__current === C.C__RootZone)
        return f.call$2(arg1, arg2);
      return P._rootRunBinary(null, null, this, f, arg1, arg2);
    },
    static: {"^": "_RootZone__rootMap,_RootZone__rootDelegate"}
  },
  _RootZone_bindCallback_closure: {
    "^": "Closure:23;this_0,f_1",
    call$0: function() {
      return this.this_0.runGuarded$1(this.f_1);
    },
    $isFunction: true
  },
  _RootZone_bindCallback_closure0: {
    "^": "Closure:23;this_2,f_3",
    call$0: function() {
      return this.this_2.run$1(this.f_3);
    },
    $isFunction: true
  },
  _RootZone_bindUnaryCallback_closure: {
    "^": "Closure:13;this_0,f_1",
    call$1: function(arg) {
      return this.this_0.runUnaryGuarded$2(this.f_1, arg);
    },
    $isFunction: true
  },
  _RootZone_bindUnaryCallback_closure0: {
    "^": "Closure:13;this_2,f_3",
    call$1: function(arg) {
      return this.this_2.runUnary$2(this.f_3, arg);
    },
    $isFunction: true
  }
}],
["dart.collection", "dart:collection", , P, {
  "^": "",
  LinkedHashMap_LinkedHashMap$_literal: function(keyValuePairs, $K, $V) {
    return H.fillLiteralMap(keyValuePairs, H.setRuntimeTypeInfo(new P._LinkedHashMap(0, null, null, null, null, null, 0), [$K, $V]));
  },
  LinkedHashMap_LinkedHashMap$_empty: function($K, $V) {
    return H.setRuntimeTypeInfo(new P._LinkedHashMap(0, null, null, null, null, null, 0), [$K, $V]);
  },
  _defaultEquals: [function(a, b) {
    return J.$eq(a, b);
  }, "call$2", "_defaultEquals$closure", 4, 0, 11],
  _defaultHashCode: [function(a) {
    return J.get$hashCode$(a);
  }, "call$1", "_defaultHashCode$closure", 2, 0, 12],
  HashMap_HashMap: function(equals, hashCode, isValidKey, $K, $V) {
    return H.setRuntimeTypeInfo(new P._HashMap(0, null, null, null, null), [$K, $V]);
  },
  HashSet_HashSet: function(equals, hashCode, isValidKey, $E) {
    return H.setRuntimeTypeInfo(new P._HashSet(0, null, null, null, null), [$E]);
  },
  IterableBase_iterableToShortString: function(iterable, leftDelimiter, rightDelimiter) {
    var parts, t1;
    if (P.IterableBase__isToStringVisiting(iterable)) {
      if (leftDelimiter === "(" && rightDelimiter === ")")
        return "(...)";
      return leftDelimiter + "..." + rightDelimiter;
    }
    parts = [];
    t1 = $.get$IterableBase__toStringVisiting();
    t1.push(iterable);
    try {
      P.IterableBase__iterablePartsToStrings(iterable, parts);
    } finally {
      if (0 >= t1.length)
        return H.ioore(t1, 0);
      t1.pop();
    }
    t1 = P.StringBuffer$(leftDelimiter);
    t1.writeAll$2(parts, ", ");
    t1.write$1(rightDelimiter);
    return t1._contents;
  },
  IterableBase_iterableToFullString: function(iterable, leftDelimiter, rightDelimiter) {
    var buffer, t1;
    if (P.IterableBase__isToStringVisiting(iterable))
      return leftDelimiter + "..." + rightDelimiter;
    buffer = P.StringBuffer$(leftDelimiter);
    t1 = $.get$IterableBase__toStringVisiting();
    t1.push(iterable);
    try {
      buffer.writeAll$2(iterable, ", ");
    } finally {
      if (0 >= t1.length)
        return H.ioore(t1, 0);
      t1.pop();
    }
    buffer.write$1(rightDelimiter);
    return buffer.get$_contents();
  },
  IterableBase__isToStringVisiting: function(o) {
    var i, t1;
    for (i = 0; t1 = $.get$IterableBase__toStringVisiting(), i < t1.length; ++i)
      if (o === t1[i])
        return true;
    return false;
  },
  IterableBase__iterablePartsToStrings: function(iterable, parts) {
    var it, $length, count, next, ultimateString, penultimateString, penultimate, ultimate, ultimate0, elision;
    it = iterable.get$iterator(iterable);
    $length = 0;
    count = 0;
    while (true) {
      if (!($length < 80 || count < 3))
        break;
      if (!it.moveNext$0())
        return;
      next = H.S(it.get$current());
      parts.push(next);
      $length += next.length + 2;
      ++count;
    }
    if (!it.moveNext$0()) {
      if (count <= 5)
        return;
      if (0 >= parts.length)
        return H.ioore(parts, 0);
      ultimateString = parts.pop();
      if (0 >= parts.length)
        return H.ioore(parts, 0);
      penultimateString = parts.pop();
    } else {
      penultimate = it.get$current();
      ++count;
      if (!it.moveNext$0()) {
        if (count <= 4) {
          parts.push(H.S(penultimate));
          return;
        }
        ultimateString = H.S(penultimate);
        if (0 >= parts.length)
          return H.ioore(parts, 0);
        penultimateString = parts.pop();
        $length += ultimateString.length + 2;
      } else {
        ultimate = it.get$current();
        ++count;
        for (; it.moveNext$0(); penultimate = ultimate, ultimate = ultimate0) {
          ultimate0 = it.get$current();
          ++count;
          if (count > 100) {
            while (true) {
              if (!($length > 75 && count > 3))
                break;
              if (0 >= parts.length)
                return H.ioore(parts, 0);
              $length -= parts.pop().length + 2;
              --count;
            }
            parts.push("...");
            return;
          }
        }
        penultimateString = H.S(penultimate);
        ultimateString = H.S(ultimate);
        $length += ultimateString.length + penultimateString.length + 4;
      }
    }
    if (count > parts.length + 2) {
      $length += 5;
      elision = "...";
    } else
      elision = null;
    while (true) {
      if (!($length > 80 && parts.length > 3))
        break;
      if (0 >= parts.length)
        return H.ioore(parts, 0);
      $length -= parts.pop().length + 2;
      if (elision == null) {
        $length += 5;
        elision = "...";
      }
    }
    if (elision != null)
      parts.push(elision);
    parts.push(penultimateString);
    parts.push(ultimateString);
  },
  LinkedHashMap_LinkedHashMap: function(equals, hashCode, isValidKey, $K, $V) {
    return H.setRuntimeTypeInfo(new P._LinkedHashMap(0, null, null, null, null, null, 0), [$K, $V]);
  },
  LinkedHashSet_LinkedHashSet: function(equals, hashCode, isValidKey, $E) {
    return H.setRuntimeTypeInfo(new P._LinkedHashSet(0, null, null, null, null, null, 0), [$E]);
  },
  ListMixin__filter: function(source, test, retainMatching) {
    var retained, t1, $length, i, element;
    retained = [];
    t1 = J.getInterceptor$asx(source);
    $length = t1.get$length(source);
    for (i = 0; i < $length; ++i) {
      element = t1.$index(source, i);
      if (J.$eq(test.call$1(element), retainMatching))
        retained.push(element);
      if ($length !== t1.get$length(source))
        throw H.wrapException(P.ConcurrentModificationError$(source));
    }
    if (retained.length !== t1.get$length(source)) {
      t1.setRange$3(source, 0, retained.length, retained);
      t1.set$length(source, retained.length);
    }
  },
  Maps_mapToString: function(m) {
    var t1, result;
    t1 = {};
    if (P.IterableBase__isToStringVisiting(m))
      return "{...}";
    result = P.StringBuffer$("");
    try {
      $.get$IterableBase__toStringVisiting().push(m);
      result.write$1("{");
      t1.first_0 = true;
      J.forEach$1$ax(m, new P.Maps_mapToString_closure(t1, result));
      result.write$1("}");
    } finally {
      t1 = $.get$IterableBase__toStringVisiting();
      if (0 >= t1.length)
        return H.ioore(t1, 0);
      t1.pop();
    }
    return result.get$_contents();
  },
  Maps__id: [function(x) {
    return x;
  }, "call$1", "Maps__id$closure", 2, 0, 13],
  Maps__fillMapWithMappedIterable: function(map, iterable, key, value) {
    var t1, element;
    value = P.Maps__id$closure();
    for (t1 = H.setRuntimeTypeInfo(new H.ListIterator(iterable, 34, 0, null), [H.getTypeArgumentByIndex(iterable, 0)]); t1.moveNext$0();) {
      element = t1.__internal$_current;
      map.$indexSet(0, key.call$1(element), value.call$1(element));
    }
  },
  _HashMap: {
    "^": "Object;_collection$_length,_strings,_nums,_rest,_keys",
    get$length: function(_) {
      return this._collection$_length;
    },
    get$isEmpty: function(_) {
      return this._collection$_length === 0;
    },
    get$keys: function() {
      return H.setRuntimeTypeInfo(new P.HashMapKeyIterable(this), [H.getTypeArgumentByIndex(this, 0)]);
    },
    get$values: function(_) {
      return H.MappedIterable_MappedIterable(H.setRuntimeTypeInfo(new P.HashMapKeyIterable(this), [H.getTypeArgumentByIndex(this, 0)]), new P._HashMap_values_closure(this), H.getTypeArgumentByIndex(this, 0), H.getTypeArgumentByIndex(this, 1));
    },
    containsKey$1: function(key) {
      var strings, nums;
      if (typeof key === "string" && key !== "__proto__") {
        strings = this._strings;
        return strings == null ? false : strings[key] != null;
      } else if (typeof key === "number" && (key & 0x3ffffff) === key) {
        nums = this._nums;
        return nums == null ? false : nums[key] != null;
      } else
        return this._containsKey$1(key);
    },
    _containsKey$1: function(key) {
      var rest = this._rest;
      if (rest == null)
        return false;
      return this._findBucketIndex$2(rest[this._computeHashCode$1(key)], key) >= 0;
    },
    addAll$1: function(_, other) {
      J.forEach$1$ax(other, new P._HashMap_addAll_closure(this));
    },
    $index: function(_, key) {
      var strings, t1, entry, nums;
      if (typeof key === "string" && key !== "__proto__") {
        strings = this._strings;
        if (strings == null)
          t1 = null;
        else {
          entry = strings[key];
          t1 = entry === strings ? null : entry;
        }
        return t1;
      } else if (typeof key === "number" && (key & 0x3ffffff) === key) {
        nums = this._nums;
        if (nums == null)
          t1 = null;
        else {
          entry = nums[key];
          t1 = entry === nums ? null : entry;
        }
        return t1;
      } else
        return this._get$1(key);
    },
    _get$1: function(key) {
      var rest, bucket, index;
      rest = this._rest;
      if (rest == null)
        return;
      bucket = rest[this._computeHashCode$1(key)];
      index = this._findBucketIndex$2(bucket, key);
      return index < 0 ? null : bucket[index + 1];
    },
    $indexSet: function(_, key, value) {
      var strings, nums;
      if (typeof key === "string" && key !== "__proto__") {
        strings = this._strings;
        if (strings == null) {
          strings = P._HashMap__newHashTable();
          this._strings = strings;
        }
        this._addHashTableEntry$3(strings, key, value);
      } else if (typeof key === "number" && (key & 0x3ffffff) === key) {
        nums = this._nums;
        if (nums == null) {
          nums = P._HashMap__newHashTable();
          this._nums = nums;
        }
        this._addHashTableEntry$3(nums, key, value);
      } else
        this._set$2(key, value);
    },
    _set$2: function(key, value) {
      var rest, hash, bucket, index;
      rest = this._rest;
      if (rest == null) {
        rest = P._HashMap__newHashTable();
        this._rest = rest;
      }
      hash = this._computeHashCode$1(key);
      bucket = rest[hash];
      if (bucket == null) {
        P._HashMap__setTableEntry(rest, hash, [key, value]);
        ++this._collection$_length;
        this._keys = null;
      } else {
        index = this._findBucketIndex$2(bucket, key);
        if (index >= 0)
          bucket[index + 1] = value;
        else {
          bucket.push(key, value);
          ++this._collection$_length;
          this._keys = null;
        }
      }
    },
    putIfAbsent$2: function(key, ifAbsent) {
      var value;
      if (this.containsKey$1(key))
        return this.$index(0, key);
      value = ifAbsent.call$0();
      this.$indexSet(0, key, value);
      return value;
    },
    remove$1: function(_, key) {
      if (typeof key === "string" && key !== "__proto__")
        return this._removeHashTableEntry$2(this._strings, key);
      else if (typeof key === "number" && (key & 0x3ffffff) === key)
        return this._removeHashTableEntry$2(this._nums, key);
      else
        return this._remove$1(key);
    },
    _remove$1: function(key) {
      var rest, bucket, index;
      rest = this._rest;
      if (rest == null)
        return;
      bucket = rest[this._computeHashCode$1(key)];
      index = this._findBucketIndex$2(bucket, key);
      if (index < 0)
        return;
      --this._collection$_length;
      this._keys = null;
      return bucket.splice(index, 2)[1];
    },
    clear$0: function(_) {
      if (this._collection$_length > 0) {
        this._keys = null;
        this._rest = null;
        this._nums = null;
        this._strings = null;
        this._collection$_length = 0;
      }
    },
    forEach$1: function(_, action) {
      var keys, $length, i, key;
      keys = this._computeKeys$0();
      for ($length = keys.length, i = 0; i < $length; ++i) {
        key = keys[i];
        action.call$2(key, this.$index(0, key));
        if (keys !== this._keys)
          throw H.wrapException(P.ConcurrentModificationError$(this));
      }
    },
    _computeKeys$0: function() {
      var t1, result, strings, names, entries, index, i, nums, rest, bucket, $length, i0;
      t1 = this._keys;
      if (t1 != null)
        return t1;
      result = Array(this._collection$_length);
      result.fixed$length = init;
      strings = this._strings;
      if (strings != null) {
        names = Object.getOwnPropertyNames(strings);
        entries = names.length;
        for (index = 0, i = 0; i < entries; ++i) {
          result[index] = names[i];
          ++index;
        }
      } else
        index = 0;
      nums = this._nums;
      if (nums != null) {
        names = Object.getOwnPropertyNames(nums);
        entries = names.length;
        for (i = 0; i < entries; ++i) {
          result[index] = +names[i];
          ++index;
        }
      }
      rest = this._rest;
      if (rest != null) {
        names = Object.getOwnPropertyNames(rest);
        entries = names.length;
        for (i = 0; i < entries; ++i) {
          bucket = rest[names[i]];
          $length = bucket.length;
          for (i0 = 0; i0 < $length; i0 += 2) {
            result[index] = bucket[i0];
            ++index;
          }
        }
      }
      this._keys = result;
      return result;
    },
    _addHashTableEntry$3: function(table, key, value) {
      if (table[key] == null) {
        ++this._collection$_length;
        this._keys = null;
      }
      P._HashMap__setTableEntry(table, key, value);
    },
    _removeHashTableEntry$2: function(table, key) {
      var value;
      if (table != null && table[key] != null) {
        value = P._HashMap__getTableEntry(table, key);
        delete table[key];
        --this._collection$_length;
        this._keys = null;
        return value;
      } else
        return;
    },
    _computeHashCode$1: function(key) {
      return J.get$hashCode$(key) & 0x3ffffff;
    },
    _findBucketIndex$2: function(bucket, key) {
      var $length, i;
      if (bucket == null)
        return -1;
      $length = bucket.length;
      for (i = 0; i < $length; i += 2)
        if (J.$eq(bucket[i], key))
          return i;
      return -1;
    },
    $isMap: true,
    static: {_HashMap__getTableEntry: function(table, key) {
        var entry = table[key];
        return entry === table ? null : entry;
      }, _HashMap__setTableEntry: function(table, key, value) {
        if (value == null)
          table[key] = table;
        else
          table[key] = value;
      }, _HashMap__newHashTable: function() {
        var table = Object.create(null);
        P._HashMap__setTableEntry(table, "<non-identifier-key>", table);
        delete table["<non-identifier-key>"];
        return table;
      }}
  },
  _HashMap_values_closure: {
    "^": "Closure:13;this_0",
    call$1: function(each) {
      return this.this_0.$index(0, each);
    },
    $isFunction: true
  },
  _HashMap_addAll_closure: {
    "^": "Closure;this_0",
    call$2: function(key, value) {
      this.this_0.$indexSet(0, key, value);
    },
    $isFunction: true,
    $signature: function() {
      return H.computeSignature(function(K, V) {
        return {func: "dynamic__K_V", args: [K, V]};
      }, this.this_0, "_HashMap");
    }
  },
  _IdentityHashMap: {
    "^": "_HashMap;_collection$_length,_strings,_nums,_rest,_keys",
    _computeHashCode$1: function(key) {
      return H.objectHashCode(key) & 0x3ffffff;
    },
    _findBucketIndex$2: function(bucket, key) {
      var $length, i, t1;
      if (bucket == null)
        return -1;
      $length = bucket.length;
      for (i = 0; i < $length; i += 2) {
        t1 = bucket[i];
        if (t1 == null ? key == null : t1 === key)
          return i;
      }
      return -1;
    }
  },
  HashMapKeyIterable: {
    "^": "IterableBase;_map",
    get$length: function(_) {
      return this._map._collection$_length;
    },
    get$isEmpty: function(_) {
      return this._map._collection$_length === 0;
    },
    get$iterator: function(_) {
      var t1 = this._map;
      t1 = new P.HashMapKeyIterator(t1, t1._computeKeys$0(), 0, null);
      t1.$builtinTypeInfo = this.$builtinTypeInfo;
      return t1;
    },
    contains$1: function(_, element) {
      return this._map.containsKey$1(element);
    },
    forEach$1: function(_, f) {
      var t1, keys, $length, i;
      t1 = this._map;
      keys = t1._computeKeys$0();
      for ($length = keys.length, i = 0; i < $length; ++i) {
        f.call$1(keys[i]);
        if (keys !== t1._keys)
          throw H.wrapException(P.ConcurrentModificationError$(t1));
      }
    },
    $isEfficientLength: true
  },
  HashMapKeyIterator: {
    "^": "Object;_map,_keys,_offset,_collection$_current",
    get$current: function() {
      return this._collection$_current;
    },
    moveNext$0: function() {
      var keys, offset, t1;
      keys = this._keys;
      offset = this._offset;
      t1 = this._map;
      if (keys !== t1._keys)
        throw H.wrapException(P.ConcurrentModificationError$(t1));
      else if (offset >= keys.length) {
        this._collection$_current = null;
        return false;
      } else {
        this._collection$_current = keys[offset];
        this._offset = offset + 1;
        return true;
      }
    }
  },
  _LinkedHashMap: {
    "^": "Object;_collection$_length,_strings,_nums,_rest,_first,_last,_modifications",
    get$length: function(_) {
      return this._collection$_length;
    },
    get$isEmpty: function(_) {
      return this._collection$_length === 0;
    },
    get$keys: function() {
      return H.setRuntimeTypeInfo(new P.LinkedHashMapKeyIterable(this), [H.getTypeArgumentByIndex(this, 0)]);
    },
    get$values: function(_) {
      return H.MappedIterable_MappedIterable(H.setRuntimeTypeInfo(new P.LinkedHashMapKeyIterable(this), [H.getTypeArgumentByIndex(this, 0)]), new P._LinkedHashMap_values_closure(this), H.getTypeArgumentByIndex(this, 0), H.getTypeArgumentByIndex(this, 1));
    },
    containsKey$1: function(key) {
      var strings, nums;
      if (typeof key === "string" && key !== "__proto__") {
        strings = this._strings;
        if (strings == null)
          return false;
        return strings[key] != null;
      } else if (typeof key === "number" && (key & 0x3ffffff) === key) {
        nums = this._nums;
        if (nums == null)
          return false;
        return nums[key] != null;
      } else
        return this._containsKey$1(key);
    },
    _containsKey$1: function(key) {
      var rest = this._rest;
      if (rest == null)
        return false;
      return this._findBucketIndex$2(rest[this._computeHashCode$1(key)], key) >= 0;
    },
    containsValue$1: function(value) {
      return H.setRuntimeTypeInfo(new P.LinkedHashMapKeyIterable(this), [H.getTypeArgumentByIndex(this, 0)]).any$1(0, new P._LinkedHashMap_containsValue_closure(this, value));
    },
    addAll$1: function(_, other) {
      J.forEach$1$ax(other, new P._LinkedHashMap_addAll_closure(this));
    },
    $index: function(_, key) {
      var strings, cell, nums;
      if (typeof key === "string" && key !== "__proto__") {
        strings = this._strings;
        if (strings == null)
          return;
        cell = strings[key];
        return cell == null ? null : cell.get$_value();
      } else if (typeof key === "number" && (key & 0x3ffffff) === key) {
        nums = this._nums;
        if (nums == null)
          return;
        cell = nums[key];
        return cell == null ? null : cell.get$_value();
      } else
        return this._get$1(key);
    },
    _get$1: function(key) {
      var rest, bucket, index;
      rest = this._rest;
      if (rest == null)
        return;
      bucket = rest[this._computeHashCode$1(key)];
      index = this._findBucketIndex$2(bucket, key);
      if (index < 0)
        return;
      return bucket[index].get$_value();
    },
    $indexSet: function(_, key, value) {
      var strings, nums;
      if (typeof key === "string" && key !== "__proto__") {
        strings = this._strings;
        if (strings == null) {
          strings = P._LinkedHashMap__newHashTable();
          this._strings = strings;
        }
        this._addHashTableEntry$3(strings, key, value);
      } else if (typeof key === "number" && (key & 0x3ffffff) === key) {
        nums = this._nums;
        if (nums == null) {
          nums = P._LinkedHashMap__newHashTable();
          this._nums = nums;
        }
        this._addHashTableEntry$3(nums, key, value);
      } else
        this._set$2(key, value);
    },
    _set$2: function(key, value) {
      var rest, hash, bucket, index;
      rest = this._rest;
      if (rest == null) {
        rest = P._LinkedHashMap__newHashTable();
        this._rest = rest;
      }
      hash = this._computeHashCode$1(key);
      bucket = rest[hash];
      if (bucket == null)
        rest[hash] = [this._newLinkedCell$2(key, value)];
      else {
        index = this._findBucketIndex$2(bucket, key);
        if (index >= 0)
          bucket[index].set$_value(value);
        else
          bucket.push(this._newLinkedCell$2(key, value));
      }
    },
    putIfAbsent$2: function(key, ifAbsent) {
      var value;
      if (this.containsKey$1(key))
        return this.$index(0, key);
      value = ifAbsent.call$0();
      this.$indexSet(0, key, value);
      return value;
    },
    remove$1: function(_, key) {
      if (typeof key === "string" && key !== "__proto__")
        return this._removeHashTableEntry$2(this._strings, key);
      else if (typeof key === "number" && (key & 0x3ffffff) === key)
        return this._removeHashTableEntry$2(this._nums, key);
      else
        return this._remove$1(key);
    },
    _remove$1: function(key) {
      var rest, bucket, index, cell;
      rest = this._rest;
      if (rest == null)
        return;
      bucket = rest[this._computeHashCode$1(key)];
      index = this._findBucketIndex$2(bucket, key);
      if (index < 0)
        return;
      cell = bucket.splice(index, 1)[0];
      this._unlinkCell$1(cell);
      return cell.get$_value();
    },
    clear$0: function(_) {
      if (this._collection$_length > 0) {
        this._last = null;
        this._first = null;
        this._rest = null;
        this._nums = null;
        this._strings = null;
        this._collection$_length = 0;
        this._modifications = this._modifications + 1 & 67108863;
      }
    },
    forEach$1: function(_, action) {
      var cell, modifications;
      cell = this._first;
      modifications = this._modifications;
      for (; cell != null;) {
        action.call$2(cell._key, cell._value);
        if (modifications !== this._modifications)
          throw H.wrapException(P.ConcurrentModificationError$(this));
        cell = cell._next;
      }
    },
    _addHashTableEntry$3: function(table, key, value) {
      var cell = table[key];
      if (cell == null)
        table[key] = this._newLinkedCell$2(key, value);
      else
        cell.set$_value(value);
    },
    _removeHashTableEntry$2: function(table, key) {
      var cell;
      if (table == null)
        return;
      cell = table[key];
      if (cell == null)
        return;
      this._unlinkCell$1(cell);
      delete table[key];
      return cell.get$_value();
    },
    _newLinkedCell$2: function(key, value) {
      var cell, last;
      cell = new P.LinkedHashMapCell(key, value, null, null);
      if (this._first == null) {
        this._last = cell;
        this._first = cell;
      } else {
        last = this._last;
        cell._previous = last;
        last._next = cell;
        this._last = cell;
      }
      ++this._collection$_length;
      this._modifications = this._modifications + 1 & 67108863;
      return cell;
    },
    _unlinkCell$1: function(cell) {
      var previous, next;
      previous = cell._previous;
      next = cell._next;
      if (previous == null)
        this._first = next;
      else
        previous._next = next;
      if (next == null)
        this._last = previous;
      else
        next._previous = previous;
      --this._collection$_length;
      this._modifications = this._modifications + 1 & 67108863;
    },
    _computeHashCode$1: function(key) {
      return J.get$hashCode$(key) & 0x3ffffff;
    },
    _findBucketIndex$2: function(bucket, key) {
      var $length, i;
      if (bucket == null)
        return -1;
      $length = bucket.length;
      for (i = 0; i < $length; ++i)
        if (J.$eq(bucket[i].get$_key(), key))
          return i;
      return -1;
    },
    toString$0: function(_) {
      return P.Maps_mapToString(this);
    },
    $isMap: true,
    static: {_LinkedHashMap__newHashTable: function() {
        var table = Object.create(null);
        table["<non-identifier-key>"] = table;
        delete table["<non-identifier-key>"];
        return table;
      }}
  },
  _LinkedHashMap_values_closure: {
    "^": "Closure:13;this_0",
    call$1: function(each) {
      return this.this_0.$index(0, each);
    },
    $isFunction: true
  },
  _LinkedHashMap_containsValue_closure: {
    "^": "Closure:13;this_0,value_1",
    call$1: function(each) {
      return J.$eq(this.this_0.$index(0, each), this.value_1);
    },
    $isFunction: true
  },
  _LinkedHashMap_addAll_closure: {
    "^": "Closure;this_0",
    call$2: function(key, value) {
      this.this_0.$indexSet(0, key, value);
    },
    $isFunction: true,
    $signature: function() {
      return H.computeSignature(function(K, V) {
        return {func: "dynamic__K_V0", args: [K, V]};
      }, this.this_0, "_LinkedHashMap");
    }
  },
  LinkedHashMapCell: {
    "^": "Object;_key<,_value@,_next,_previous"
  },
  LinkedHashMapKeyIterable: {
    "^": "IterableBase;_map",
    get$length: function(_) {
      return this._map._collection$_length;
    },
    get$isEmpty: function(_) {
      return this._map._collection$_length === 0;
    },
    get$iterator: function(_) {
      var t1, t2;
      t1 = this._map;
      t2 = new P.LinkedHashMapKeyIterator(t1, t1._modifications, null, null);
      t2.$builtinTypeInfo = this.$builtinTypeInfo;
      t2._cell = t1._first;
      return t2;
    },
    contains$1: function(_, element) {
      return this._map.containsKey$1(element);
    },
    forEach$1: function(_, f) {
      var t1, cell, modifications;
      t1 = this._map;
      cell = t1._first;
      modifications = t1._modifications;
      for (; cell != null;) {
        f.call$1(cell._key);
        if (modifications !== t1._modifications)
          throw H.wrapException(P.ConcurrentModificationError$(t1));
        cell = cell._next;
      }
    },
    $isEfficientLength: true
  },
  LinkedHashMapKeyIterator: {
    "^": "Object;_map,_modifications,_cell,_collection$_current",
    get$current: function() {
      return this._collection$_current;
    },
    moveNext$0: function() {
      var t1 = this._map;
      if (this._modifications !== t1._modifications)
        throw H.wrapException(P.ConcurrentModificationError$(t1));
      else {
        t1 = this._cell;
        if (t1 == null) {
          this._collection$_current = null;
          return false;
        } else {
          this._collection$_current = t1._key;
          this._cell = t1._next;
          return true;
        }
      }
    }
  },
  _HashSet: {
    "^": "_HashSetBase;_collection$_length<,_strings,_nums,_rest,_elements",
    _newSet$0: function() {
      var t1 = new P._HashSet(0, null, null, null, null);
      t1.$builtinTypeInfo = this.$builtinTypeInfo;
      return t1;
    },
    get$iterator: function(_) {
      var t1 = new P.HashSetIterator(this, this._computeElements$0(), 0, null);
      t1.$builtinTypeInfo = this.$builtinTypeInfo;
      return t1;
    },
    get$length: function(_) {
      return this._collection$_length;
    },
    get$isEmpty: function(_) {
      return this._collection$_length === 0;
    },
    contains$1: function(_, object) {
      var strings, nums;
      if (typeof object === "string" && object !== "__proto__") {
        strings = this._strings;
        return strings == null ? false : strings[object] != null;
      } else if (typeof object === "number" && (object & 0x3ffffff) === object) {
        nums = this._nums;
        return nums == null ? false : nums[object] != null;
      } else
        return this._contains$1(object);
    },
    _contains$1: function(object) {
      var rest = this._rest;
      if (rest == null)
        return false;
      return this._findBucketIndex$2(rest[this._computeHashCode$1(object)], object) >= 0;
    },
    lookup$1: function(object) {
      var t1;
      if (!(typeof object === "string" && object !== "__proto__"))
        t1 = typeof object === "number" && (object & 0x3ffffff) === object;
      else
        t1 = true;
      if (t1)
        return this.contains$1(0, object) ? object : null;
      return this._lookup$1(object);
    },
    _lookup$1: function(object) {
      var rest, bucket, index;
      rest = this._rest;
      if (rest == null)
        return;
      bucket = rest[this._computeHashCode$1(object)];
      index = this._findBucketIndex$2(bucket, object);
      if (index < 0)
        return;
      return J.$index$asx(bucket, index);
    },
    add$1: [function(_, element) {
      var strings, table, nums;
      if (typeof element === "string" && element !== "__proto__") {
        strings = this._strings;
        if (strings == null) {
          table = Object.create(null);
          table["<non-identifier-key>"] = table;
          delete table["<non-identifier-key>"];
          this._strings = table;
          strings = table;
        }
        return this._addHashTableEntry$2(strings, element);
      } else if (typeof element === "number" && (element & 0x3ffffff) === element) {
        nums = this._nums;
        if (nums == null) {
          table = Object.create(null);
          table["<non-identifier-key>"] = table;
          delete table["<non-identifier-key>"];
          this._nums = table;
          nums = table;
        }
        return this._addHashTableEntry$2(nums, element);
      } else
        return this._add$1(element);
    }, "call$1", "get$add", 2, 0, function() {
      return H.computeSignature(function(E) {
        return {func: "bool__E", ret: P.bool, args: [E]};
      }, this.$receiver, "_HashSet");
    }],
    _add$1: function(element) {
      var rest, hash, bucket;
      rest = this._rest;
      if (rest == null) {
        rest = P._HashSet__newHashTable();
        this._rest = rest;
      }
      hash = this._computeHashCode$1(element);
      bucket = rest[hash];
      if (bucket == null)
        rest[hash] = [element];
      else {
        if (this._findBucketIndex$2(bucket, element) >= 0)
          return false;
        bucket.push(element);
      }
      ++this._collection$_length;
      this._elements = null;
      return true;
    },
    addAll$1: function(_, objects) {
      var t1;
      for (t1 = J.get$iterator$ax(objects); t1.moveNext$0();)
        this.add$1(0, t1.get$current());
    },
    remove$1: function(_, object) {
      if (typeof object === "string" && object !== "__proto__")
        return this._removeHashTableEntry$2(this._strings, object);
      else if (typeof object === "number" && (object & 0x3ffffff) === object)
        return this._removeHashTableEntry$2(this._nums, object);
      else
        return this._remove$1(object);
    },
    _remove$1: function(object) {
      var rest, bucket, index;
      rest = this._rest;
      if (rest == null)
        return false;
      bucket = rest[this._computeHashCode$1(object)];
      index = this._findBucketIndex$2(bucket, object);
      if (index < 0)
        return false;
      --this._collection$_length;
      this._elements = null;
      bucket.splice(index, 1);
      return true;
    },
    clear$0: function(_) {
      if (this._collection$_length > 0) {
        this._elements = null;
        this._rest = null;
        this._nums = null;
        this._strings = null;
        this._collection$_length = 0;
      }
    },
    _computeElements$0: function() {
      var t1, result, strings, names, entries, index, i, nums, rest, bucket, $length, i0;
      t1 = this._elements;
      if (t1 != null)
        return t1;
      result = Array(this._collection$_length);
      result.fixed$length = init;
      strings = this._strings;
      if (strings != null) {
        names = Object.getOwnPropertyNames(strings);
        entries = names.length;
        for (index = 0, i = 0; i < entries; ++i) {
          result[index] = names[i];
          ++index;
        }
      } else
        index = 0;
      nums = this._nums;
      if (nums != null) {
        names = Object.getOwnPropertyNames(nums);
        entries = names.length;
        for (i = 0; i < entries; ++i) {
          result[index] = +names[i];
          ++index;
        }
      }
      rest = this._rest;
      if (rest != null) {
        names = Object.getOwnPropertyNames(rest);
        entries = names.length;
        for (i = 0; i < entries; ++i) {
          bucket = rest[names[i]];
          $length = bucket.length;
          for (i0 = 0; i0 < $length; ++i0) {
            result[index] = bucket[i0];
            ++index;
          }
        }
      }
      this._elements = result;
      return result;
    },
    _addHashTableEntry$2: function(table, element) {
      if (table[element] != null)
        return false;
      table[element] = 0;
      ++this._collection$_length;
      this._elements = null;
      return true;
    },
    _removeHashTableEntry$2: function(table, element) {
      if (table != null && table[element] != null) {
        delete table[element];
        --this._collection$_length;
        this._elements = null;
        return true;
      } else
        return false;
    },
    _computeHashCode$1: function(element) {
      return J.get$hashCode$(element) & 0x3ffffff;
    },
    _findBucketIndex$2: function(bucket, element) {
      var $length, i;
      if (bucket == null)
        return -1;
      $length = bucket.length;
      for (i = 0; i < $length; ++i)
        if (J.$eq(bucket[i], element))
          return i;
      return -1;
    },
    $isEfficientLength: true,
    $isIterable: true,
    $asIterable: null,
    static: {_HashSet__newHashTable: function() {
        var table = Object.create(null);
        table["<non-identifier-key>"] = table;
        delete table["<non-identifier-key>"];
        return table;
      }}
  },
  _IdentityHashSet: {
    "^": "_HashSet;_collection$_length,_strings,_nums,_rest,_elements",
    _newSet$0: function() {
      var t1 = new P._IdentityHashSet(0, null, null, null, null);
      t1.$builtinTypeInfo = this.$builtinTypeInfo;
      return t1;
    },
    _computeHashCode$1: function(key) {
      return H.objectHashCode(key) & 0x3ffffff;
    },
    _findBucketIndex$2: function(bucket, element) {
      var $length, i, t1;
      if (bucket == null)
        return -1;
      $length = bucket.length;
      for (i = 0; i < $length; ++i) {
        t1 = bucket[i];
        if (t1 == null ? element == null : t1 === element)
          return i;
      }
      return -1;
    }
  },
  HashSetIterator: {
    "^": "Object;_set,_elements,_offset,_collection$_current",
    get$current: function() {
      return this._collection$_current;
    },
    moveNext$0: function() {
      var elements, offset, t1;
      elements = this._elements;
      offset = this._offset;
      t1 = this._set;
      if (elements !== t1._elements)
        throw H.wrapException(P.ConcurrentModificationError$(t1));
      else if (offset >= elements.length) {
        this._collection$_current = null;
        return false;
      } else {
        this._collection$_current = elements[offset];
        this._offset = offset + 1;
        return true;
      }
    }
  },
  _LinkedHashSet: {
    "^": "_HashSetBase;_collection$_length<,_strings,_nums,_rest,_first<,_last,_modifications",
    _newSet$0: function() {
      var t1 = new P._LinkedHashSet(0, null, null, null, null, null, 0);
      t1.$builtinTypeInfo = this.$builtinTypeInfo;
      return t1;
    },
    get$iterator: function(_) {
      var t1 = H.setRuntimeTypeInfo(new P.LinkedHashSetIterator(this, this._modifications, null, null), [null]);
      t1._cell = t1._set._first;
      return t1;
    },
    get$length: function(_) {
      return this._collection$_length;
    },
    get$isEmpty: function(_) {
      return this._collection$_length === 0;
    },
    contains$1: [function(_, object) {
      var strings, nums;
      if (typeof object === "string" && object !== "__proto__") {
        strings = this._strings;
        if (strings == null)
          return false;
        return strings[object] != null;
      } else if (typeof object === "number" && (object & 0x3ffffff) === object) {
        nums = this._nums;
        if (nums == null)
          return false;
        return nums[object] != null;
      } else
        return this._contains$1(object);
    }, "call$1", "get$contains", 2, 0, 59],
    _contains$1: function(object) {
      var rest = this._rest;
      if (rest == null)
        return false;
      return this._findBucketIndex$2(rest[this._computeHashCode$1(object)], object) >= 0;
    },
    lookup$1: function(object) {
      var t1 = typeof object === "number" && (object & 0x3ffffff) === object;
      if (t1)
        return this.contains$1(0, object) ? object : null;
      else
        return this._lookup$1(object);
    },
    _lookup$1: function(object) {
      var rest, bucket, index;
      rest = this._rest;
      if (rest == null)
        return;
      bucket = rest[this._computeHashCode$1(object)];
      index = this._findBucketIndex$2(bucket, object);
      if (index < 0)
        return;
      return J.$index$asx(bucket, index).get$_element();
    },
    forEach$1: function(_, action) {
      var cell, modifications;
      cell = this._first;
      modifications = this._modifications;
      for (; cell != null;) {
        action.call$1(cell._element);
        if (modifications !== this._modifications)
          throw H.wrapException(P.ConcurrentModificationError$(this));
        cell = cell._next;
      }
    },
    get$first: function(_) {
      var t1 = this._first;
      if (t1 == null)
        throw H.wrapException(P.StateError$("No elements"));
      return t1._element;
    },
    get$last: function(_) {
      var t1 = this._last;
      if (t1 == null)
        throw H.wrapException(P.StateError$("No elements"));
      return t1._element;
    },
    add$1: function(_, element) {
      var strings, table, nums;
      if (typeof element === "string" && element !== "__proto__") {
        strings = this._strings;
        if (strings == null) {
          table = Object.create(null);
          table["<non-identifier-key>"] = table;
          delete table["<non-identifier-key>"];
          this._strings = table;
          strings = table;
        }
        return this._addHashTableEntry$2(strings, element);
      } else if (typeof element === "number" && (element & 0x3ffffff) === element) {
        nums = this._nums;
        if (nums == null) {
          table = Object.create(null);
          table["<non-identifier-key>"] = table;
          delete table["<non-identifier-key>"];
          this._nums = table;
          nums = table;
        }
        return this._addHashTableEntry$2(nums, element);
      } else
        return this._add$1(element);
    },
    _add$1: function(element) {
      var rest, hash, bucket;
      rest = this._rest;
      if (rest == null) {
        rest = P._LinkedHashSet__newHashTable();
        this._rest = rest;
      }
      hash = this._computeHashCode$1(element);
      bucket = rest[hash];
      if (bucket == null)
        rest[hash] = [this._newLinkedCell$1(element)];
      else {
        if (this._findBucketIndex$2(bucket, element) >= 0)
          return false;
        bucket.push(this._newLinkedCell$1(element));
      }
      return true;
    },
    remove$1: function(_, object) {
      if (typeof object === "string" && object !== "__proto__")
        return this._removeHashTableEntry$2(this._strings, object);
      else if (typeof object === "number" && (object & 0x3ffffff) === object)
        return this._removeHashTableEntry$2(this._nums, object);
      else
        return this._remove$1(object);
    },
    _remove$1: function(object) {
      var rest, bucket, index;
      rest = this._rest;
      if (rest == null)
        return false;
      bucket = rest[this._computeHashCode$1(object)];
      index = this._findBucketIndex$2(bucket, object);
      if (index < 0)
        return false;
      this._unlinkCell$1(bucket.splice(index, 1)[0]);
      return true;
    },
    removeWhere$1: function(_, test) {
      this._filterWhere$2(test, true);
    },
    _filterWhere$2: function(test, removeMatching) {
      var cell, element, next, modifications, t1;
      cell = this._first;
      for (; cell != null; cell = next) {
        element = cell._element;
        next = cell._next;
        modifications = this._modifications;
        t1 = test.call$1(element);
        if (modifications !== this._modifications)
          throw H.wrapException(P.ConcurrentModificationError$(this));
        if (removeMatching === t1)
          this.remove$1(0, element);
      }
    },
    clear$0: function(_) {
      if (this._collection$_length > 0) {
        this._last = null;
        this._first = null;
        this._rest = null;
        this._nums = null;
        this._strings = null;
        this._collection$_length = 0;
        this._modifications = this._modifications + 1 & 67108863;
      }
    },
    _addHashTableEntry$2: function(table, element) {
      if (table[element] != null)
        return false;
      table[element] = this._newLinkedCell$1(element);
      return true;
    },
    _removeHashTableEntry$2: function(table, element) {
      var cell;
      if (table == null)
        return false;
      cell = table[element];
      if (cell == null)
        return false;
      this._unlinkCell$1(cell);
      delete table[element];
      return true;
    },
    _newLinkedCell$1: function(element) {
      var cell, last;
      cell = new P.LinkedHashSetCell(element, null, null);
      if (this._first == null) {
        this._last = cell;
        this._first = cell;
      } else {
        last = this._last;
        cell._previous = last;
        last._next = cell;
        this._last = cell;
      }
      ++this._collection$_length;
      this._modifications = this._modifications + 1 & 67108863;
      return cell;
    },
    _unlinkCell$1: function(cell) {
      var previous, next;
      previous = cell._previous;
      next = cell._next;
      if (previous == null)
        this._first = next;
      else
        previous._next = next;
      if (next == null)
        this._last = previous;
      else
        next._previous = previous;
      --this._collection$_length;
      this._modifications = this._modifications + 1 & 67108863;
    },
    _computeHashCode$1: function(element) {
      return J.get$hashCode$(element) & 0x3ffffff;
    },
    _findBucketIndex$2: function(bucket, element) {
      var $length, i;
      if (bucket == null)
        return -1;
      $length = bucket.length;
      for (i = 0; i < $length; ++i)
        if (J.$eq(bucket[i].get$_element(), element))
          return i;
      return -1;
    },
    $isEfficientLength: true,
    $isIterable: true,
    $asIterable: null,
    static: {_LinkedHashSet__newHashTable: function() {
        var table = Object.create(null);
        table["<non-identifier-key>"] = table;
        delete table["<non-identifier-key>"];
        return table;
      }}
  },
  LinkedHashSetCell: {
    "^": "Object;_element<,_next,_previous"
  },
  LinkedHashSetIterator: {
    "^": "Object;_set,_modifications,_cell,_collection$_current",
    get$current: function() {
      return this._collection$_current;
    },
    moveNext$0: function() {
      var t1 = this._set;
      if (this._modifications !== t1._modifications)
        throw H.wrapException(P.ConcurrentModificationError$(t1));
      else {
        t1 = this._cell;
        if (t1 == null) {
          this._collection$_current = null;
          return false;
        } else {
          this._collection$_current = t1._element;
          this._cell = t1._next;
          return true;
        }
      }
    }
  },
  _HashSetBase: {
    "^": "SetBase;",
    intersection$1: function(_, other) {
      var result, t1, element;
      result = this._newSet$0();
      for (t1 = this.get$iterator(this); t1.moveNext$0();) {
        element = t1.get$current();
        if (other.contains$1(0, element))
          result.add$1(0, element);
      }
      return result;
    },
    toSet$0: function(_) {
      var t1 = this._newSet$0();
      t1.addAll$1(0, this);
      return t1;
    }
  },
  IterableBase: {
    "^": "Object;",
    map$1: function(_, f) {
      return H.MappedIterable_MappedIterable(this, f, H.getRuntimeTypeArgument(this, "IterableBase", 0), null);
    },
    where$1: function(_, f) {
      return H.setRuntimeTypeInfo(new H.WhereIterable(this, f), [H.getRuntimeTypeArgument(this, "IterableBase", 0)]);
    },
    expand$1: function(_, f) {
      return H.setRuntimeTypeInfo(new H.ExpandIterable(this, f), [H.getRuntimeTypeArgument(this, "IterableBase", 0), null]);
    },
    contains$1: function(_, element) {
      var t1;
      for (t1 = this.get$iterator(this); t1.moveNext$0();)
        if (J.$eq(t1.get$current(), element))
          return true;
      return false;
    },
    forEach$1: function(_, f) {
      var t1;
      for (t1 = this.get$iterator(this); t1.moveNext$0();)
        f.call$1(t1.get$current());
    },
    fold$2: function(_, initialValue, combine) {
      var t1, value;
      for (t1 = this.get$iterator(this), value = initialValue; t1.moveNext$0();)
        value = combine.call$2(value, t1.get$current());
      return value;
    },
    every$1: function(_, f) {
      var t1;
      for (t1 = this.get$iterator(this); t1.moveNext$0();)
        if (f.call$1(t1.get$current()) !== true)
          return false;
      return true;
    },
    join$1: function(_, separator) {
      var iterator, buffer, t1;
      iterator = this.get$iterator(this);
      if (!iterator.moveNext$0())
        return "";
      buffer = P.StringBuffer$("");
      if (separator === "") {
        do {
          t1 = H.S(iterator.get$current());
          buffer._contents += t1;
        } while (iterator.moveNext$0());
      } else {
        buffer.write$1(H.S(iterator.get$current()));
        for (; iterator.moveNext$0();) {
          buffer._contents += separator;
          t1 = H.S(iterator.get$current());
          buffer._contents += t1;
        }
      }
      return buffer._contents;
    },
    any$1: function(_, f) {
      var t1;
      for (t1 = this.get$iterator(this); t1.moveNext$0();)
        if (f.call$1(t1.get$current()) === true)
          return true;
      return false;
    },
    toList$1$growable: function(_, growable) {
      return P.List_List$from(this, growable, H.getRuntimeTypeArgument(this, "IterableBase", 0));
    },
    toList$0: function($receiver) {
      return this.toList$1$growable($receiver, true);
    },
    get$length: function(_) {
      var it, count;
      it = this.get$iterator(this);
      for (count = 0; it.moveNext$0();)
        ++count;
      return count;
    },
    get$isEmpty: function(_) {
      return !this.get$iterator(this).moveNext$0();
    },
    get$isNotEmpty: function(_) {
      return !this.get$isEmpty(this);
    },
    get$first: function(_) {
      var it = this.get$iterator(this);
      if (!it.moveNext$0())
        throw H.wrapException(H.IterableElementError_noElement());
      return it.get$current();
    },
    get$last: function(_) {
      var it, result;
      it = this.get$iterator(this);
      if (!it.moveNext$0())
        throw H.wrapException(H.IterableElementError_noElement());
      do
        result = it.get$current();
      while (it.moveNext$0());
      return result;
    },
    get$single: function(_) {
      var it, result;
      it = this.get$iterator(this);
      if (!it.moveNext$0())
        throw H.wrapException(H.IterableElementError_noElement());
      result = it.get$current();
      if (it.moveNext$0())
        throw H.wrapException(H.IterableElementError_tooMany());
      return result;
    },
    elementAt$1: function(_, index) {
      var t1, remaining, element;
      if (index < 0)
        throw H.wrapException(P.RangeError$value(index));
      for (t1 = this.get$iterator(this), remaining = index; t1.moveNext$0();) {
        element = t1.get$current();
        if (remaining === 0)
          return element;
        --remaining;
      }
      throw H.wrapException(P.RangeError$value(index));
    },
    toString$0: function(_) {
      return P.IterableBase_iterableToShortString(this, "(", ")");
    },
    $isIterable: true,
    $asIterable: null
  },
  HasNextIterator: {
    "^": "Object;_collection$_iterator,_collection$_state",
    get$hasNext: function() {
      if (this._collection$_state === 2)
        this._move$0();
      return this._collection$_state === 0;
    },
    next$0: [function() {
      if (!this.get$hasNext())
        throw H.wrapException(P.StateError$("No more elements"));
      var result = this._collection$_iterator.get$current();
      this._move$0();
      return result;
    }, "call$0", "get$next", 0, 0, function() {
      return H.computeSignature(function(E) {
        return {func: "E_", ret: E};
      }, this.$receiver, "HasNextIterator");
    }],
    _move$0: function() {
      if (this._collection$_iterator.moveNext$0())
        this._collection$_state = 0;
      else
        this._collection$_state = 1;
    },
    static: {"^": "HasNextIterator__HAS_NEXT_AND_NEXT_IN_CURRENT,HasNextIterator__NO_NEXT,HasNextIterator__NOT_MOVED_YET"}
  },
  ListBase: {
    "^": "Object_ListMixin;"
  },
  Object_ListMixin: {
    "^": "Object+ListMixin;",
    $isList: true,
    $asList: null,
    $isEfficientLength: true,
    $isIterable: true,
    $asIterable: null
  },
  ListMixin: {
    "^": "Object;",
    get$iterator: function(receiver) {
      return H.setRuntimeTypeInfo(new H.ListIterator(receiver, this.get$length(receiver), 0, null), [H.getRuntimeTypeArgument(receiver, "ListMixin", 0)]);
    },
    elementAt$1: function(receiver, index) {
      return this.$index(receiver, index);
    },
    forEach$1: function(receiver, action) {
      var $length, i;
      $length = this.get$length(receiver);
      for (i = 0; i < $length; ++i) {
        action.call$1(this.$index(receiver, i));
        if ($length !== this.get$length(receiver))
          throw H.wrapException(P.ConcurrentModificationError$(receiver));
      }
    },
    get$isEmpty: function(receiver) {
      return this.get$length(receiver) === 0;
    },
    get$first: function(receiver) {
      if (this.get$length(receiver) === 0)
        throw H.wrapException(P.StateError$("No elements"));
      return this.$index(receiver, 0);
    },
    get$last: function(receiver) {
      if (this.get$length(receiver) === 0)
        throw H.wrapException(P.StateError$("No elements"));
      return this.$index(receiver, this.get$length(receiver) - 1);
    },
    get$single: function(receiver) {
      if (this.get$length(receiver) === 0)
        throw H.wrapException(P.StateError$("No elements"));
      if (this.get$length(receiver) > 1)
        throw H.wrapException(P.StateError$("Too many elements"));
      return this.$index(receiver, 0);
    },
    contains$1: function(receiver, element) {
      var $length, i;
      $length = this.get$length(receiver);
      for (i = 0; i < this.get$length(receiver); ++i) {
        if (J.$eq(this.$index(receiver, i), element))
          return true;
        if ($length !== this.get$length(receiver))
          throw H.wrapException(P.ConcurrentModificationError$(receiver));
      }
      return false;
    },
    every$1: function(receiver, test) {
      var $length, i;
      $length = this.get$length(receiver);
      for (i = 0; i < $length; ++i) {
        if (test.call$1(this.$index(receiver, i)) !== true)
          return false;
        if ($length !== this.get$length(receiver))
          throw H.wrapException(P.ConcurrentModificationError$(receiver));
      }
      return true;
    },
    any$1: function(receiver, test) {
      var $length, i;
      $length = this.get$length(receiver);
      for (i = 0; i < $length; ++i) {
        if (test.call$1(this.$index(receiver, i)) === true)
          return true;
        if ($length !== this.get$length(receiver))
          throw H.wrapException(P.ConcurrentModificationError$(receiver));
      }
      return false;
    },
    where$1: function(receiver, test) {
      return H.setRuntimeTypeInfo(new H.WhereIterable(receiver, test), [H.getRuntimeTypeArgument(receiver, "ListMixin", 0)]);
    },
    map$1: function(receiver, f) {
      return H.setRuntimeTypeInfo(new H.MappedListIterable(receiver, f), [null, null]);
    },
    expand$1: function(receiver, f) {
      return H.setRuntimeTypeInfo(new H.ExpandIterable(receiver, f), [H.getRuntimeTypeArgument(receiver, "ListMixin", 0), null]);
    },
    fold$2: function(receiver, initialValue, combine) {
      var $length, value, i;
      $length = this.get$length(receiver);
      for (value = initialValue, i = 0; i < $length; ++i) {
        value = combine.call$2(value, this.$index(receiver, i));
        if ($length !== this.get$length(receiver))
          throw H.wrapException(P.ConcurrentModificationError$(receiver));
      }
      return value;
    },
    skip$1: function(receiver, count) {
      return H.SubListIterable$(receiver, count, null, null);
    },
    toList$1$growable: function(receiver, growable) {
      var result, t1, i;
      if (growable) {
        result = H.setRuntimeTypeInfo([], [H.getRuntimeTypeArgument(receiver, "ListMixin", 0)]);
        C.JSArray_methods.set$length(result, this.get$length(receiver));
      } else {
        t1 = Array(this.get$length(receiver));
        t1.fixed$length = init;
        result = H.setRuntimeTypeInfo(t1, [H.getRuntimeTypeArgument(receiver, "ListMixin", 0)]);
      }
      for (i = 0; i < this.get$length(receiver); ++i) {
        t1 = this.$index(receiver, i);
        if (i >= result.length)
          return H.ioore(result, i);
        result[i] = t1;
      }
      return result;
    },
    toList$0: function($receiver) {
      return this.toList$1$growable($receiver, true);
    },
    add$1: function(receiver, element) {
      var t1 = this.get$length(receiver);
      this.set$length(receiver, t1 + 1);
      this.$indexSet(receiver, t1, element);
    },
    addAll$1: function(receiver, iterable) {
      var t1, element, t2;
      for (t1 = J.get$iterator$ax(iterable); t1.moveNext$0();) {
        element = t1.get$current();
        t2 = this.get$length(receiver);
        this.set$length(receiver, t2 + 1);
        this.$indexSet(receiver, t2, element);
      }
    },
    remove$1: function(receiver, element) {
      var i;
      for (i = 0; i < this.get$length(receiver); ++i)
        if (J.$eq(this.$index(receiver, i), element)) {
          this.setRange$4(receiver, i, this.get$length(receiver) - 1, receiver, i + 1);
          this.set$length(receiver, this.get$length(receiver) - 1);
          return true;
        }
      return false;
    },
    removeWhere$1: function(receiver, test) {
      P.ListMixin__filter(receiver, test, false);
    },
    clear$0: function(receiver) {
      this.set$length(receiver, 0);
    },
    removeLast$0: function(receiver) {
      var result;
      if (this.get$length(receiver) === 0)
        throw H.wrapException(P.StateError$("No elements"));
      result = this.$index(receiver, this.get$length(receiver) - 1);
      this.set$length(receiver, this.get$length(receiver) - 1);
      return result;
    },
    _rangeCheck$2: function(receiver, start, end) {
      if (start < 0 || start > this.get$length(receiver))
        throw H.wrapException(P.RangeError$range(start, 0, this.get$length(receiver)));
      if (end < start || end > this.get$length(receiver))
        throw H.wrapException(P.RangeError$range(end, start, this.get$length(receiver)));
    },
    sublist$2: function(receiver, start, end) {
      var $length, result, i, t1;
      this._rangeCheck$2(receiver, start, end);
      $length = end - start;
      result = H.setRuntimeTypeInfo([], [H.getRuntimeTypeArgument(receiver, "ListMixin", 0)]);
      C.JSArray_methods.set$length(result, $length);
      for (i = 0; i < $length; ++i) {
        t1 = this.$index(receiver, start + i);
        if (i >= result.length)
          return H.ioore(result, i);
        result[i] = t1;
      }
      return result;
    },
    getRange$2: function(receiver, start, end) {
      this._rangeCheck$2(receiver, start, end);
      return H.SubListIterable$(receiver, start, end, null);
    },
    setRange$4: function(receiver, start, end, iterable, skipCount) {
      var $length, t1, i;
      if (start > this.get$length(receiver))
        H.throwExpression(P.RangeError$range(start, 0, this.get$length(receiver)));
      if (end < start || end > this.get$length(receiver))
        H.throwExpression(P.RangeError$range(end, start, this.get$length(receiver)));
      $length = end - start;
      if ($length === 0)
        return;
      t1 = J.getInterceptor$asx(iterable);
      if (skipCount + $length > t1.get$length(iterable))
        throw H.wrapException(P.StateError$("Not enough elements"));
      if (skipCount < start)
        for (i = $length - 1; i >= 0; --i)
          this.$indexSet(receiver, start + i, t1.$index(iterable, skipCount + i));
      else
        for (i = 0; i < $length; ++i)
          this.$indexSet(receiver, start + i, t1.$index(iterable, skipCount + i));
    },
    setRange$3: function($receiver, start, end, iterable) {
      return this.setRange$4($receiver, start, end, iterable, 0);
    },
    indexOf$2: function(receiver, element, startIndex) {
      var i;
      if (startIndex >= this.get$length(receiver))
        return -1;
      for (i = startIndex; i < this.get$length(receiver); ++i)
        if (J.$eq(this.$index(receiver, i), element))
          return i;
      return -1;
    },
    indexOf$1: function($receiver, element) {
      return this.indexOf$2($receiver, element, 0);
    },
    toString$0: function(receiver) {
      return P.IterableBase_iterableToFullString(receiver, "[", "]");
    },
    $isList: true,
    $asList: null,
    $isEfficientLength: true,
    $isIterable: true,
    $asIterable: null
  },
  MapBase: {
    "^": "Object+MapMixin;",
    $isMap: true
  },
  MapMixin: {
    "^": "Object;",
    forEach$1: function(_, action) {
      var t1, key;
      for (t1 = this.get$keys(), t1 = t1.get$iterator(t1); t1.moveNext$0();) {
        key = t1.get$current();
        action.call$2(key, this.$index(0, key));
      }
    },
    addAll$1: function(_, other) {
      var t1, t2, key;
      for (t1 = J.get$iterator$ax(other.get$keys()), t2 = J.getInterceptor$asx(other); t1.moveNext$0();) {
        key = t1.get$current();
        this.$indexSet(0, key, t2.$index(other, key));
      }
    },
    putIfAbsent$2: function(key, ifAbsent) {
      var t1;
      if (this.get$keys().contains$1(0, key))
        return this.$index(0, key);
      t1 = ifAbsent.call$0();
      this.$indexSet(0, key, t1);
      return t1;
    },
    containsKey$1: function(key) {
      return this.get$keys().contains$1(0, key);
    },
    get$length: function(_) {
      var t1 = this.get$keys();
      return t1.get$length(t1);
    },
    get$isEmpty: function(_) {
      var t1 = this.get$keys();
      return !t1.get$iterator(t1).moveNext$0();
    },
    get$values: function(_) {
      return H.setRuntimeTypeInfo(new P._MapBaseValueIterable(this), [H.getRuntimeTypeArgument(this, "MapMixin", 1)]);
    },
    toString$0: function(_) {
      return P.Maps_mapToString(this);
    },
    $isMap: true
  },
  _MapBaseValueIterable: {
    "^": "IterableBase;_map",
    get$length: function(_) {
      var t1 = this._map;
      return t1.get$length(t1);
    },
    get$isEmpty: function(_) {
      var t1 = this._map;
      return t1.get$isEmpty(t1);
    },
    get$first: function(_) {
      var t1, t2;
      t1 = this._map;
      t2 = t1.get$keys();
      return t1.$index(0, t2.get$first(t2));
    },
    get$single: function(_) {
      var t1, t2;
      t1 = this._map;
      t2 = t1.get$keys();
      return t1.$index(0, t2.get$single(t2));
    },
    get$last: function(_) {
      var t1, t2;
      t1 = this._map;
      t2 = t1.get$keys();
      return t1.$index(0, t2.get$last(t2));
    },
    get$iterator: function(_) {
      var t1, t2;
      t1 = this._map;
      t2 = t1.get$keys();
      t1 = new P._MapBaseValueIterator(t2.get$iterator(t2), t1, null);
      t1.$builtinTypeInfo = this.$builtinTypeInfo;
      return t1;
    },
    $isEfficientLength: true
  },
  _MapBaseValueIterator: {
    "^": "Object;_keys,_map,_collection$_current",
    moveNext$0: function() {
      var t1 = this._keys;
      if (t1.moveNext$0()) {
        this._collection$_current = this._map.$index(0, t1.get$current());
        return true;
      }
      this._collection$_current = null;
      return false;
    },
    get$current: function() {
      return this._collection$_current;
    }
  },
  Maps_mapToString_closure: {
    "^": "Closure:19;box_0,result_1",
    call$2: function(k, v) {
      var t1 = this.box_0;
      if (!t1.first_0)
        this.result_1.write$1(", ");
      t1.first_0 = false;
      t1 = this.result_1;
      t1.write$1(k);
      t1.write$1(": ");
      t1.write$1(v);
    },
    $isFunction: true
  },
  ListQueue: {
    "^": "IterableBase;_table,_head,_tail,_modificationCount",
    get$iterator: function(_) {
      var t1 = new P._ListQueueIterator(this, this._tail, this._modificationCount, this._head, null);
      t1.$builtinTypeInfo = this.$builtinTypeInfo;
      return t1;
    },
    forEach$1: function(_, action) {
      var modificationCount, i, t1;
      modificationCount = this._modificationCount;
      for (i = this._head; i !== this._tail; i = (i + 1 & this._table.length - 1) >>> 0) {
        t1 = this._table;
        if (i < 0 || i >= t1.length)
          return H.ioore(t1, i);
        action.call$1(t1[i]);
        if (modificationCount !== this._modificationCount)
          H.throwExpression(P.ConcurrentModificationError$(this));
      }
    },
    get$isEmpty: function(_) {
      return this._head === this._tail;
    },
    get$length: function(_) {
      return (this._tail - this._head & this._table.length - 1) >>> 0;
    },
    get$first: function(_) {
      var t1, t2;
      t1 = this._head;
      if (t1 === this._tail)
        throw H.wrapException(H.IterableElementError_noElement());
      t2 = this._table;
      if (t1 >= t2.length)
        return H.ioore(t2, t1);
      return t2[t1];
    },
    get$last: function(_) {
      var t1, t2, t3;
      t1 = this._head;
      t2 = this._tail;
      if (t1 === t2)
        throw H.wrapException(H.IterableElementError_noElement());
      t1 = this._table;
      t3 = t1.length;
      t2 = (t2 - 1 & t3 - 1) >>> 0;
      if (t2 < 0 || t2 >= t3)
        return H.ioore(t1, t2);
      return t1[t2];
    },
    get$single: function(_) {
      var t1, t2;
      if (this._head === this._tail)
        throw H.wrapException(H.IterableElementError_noElement());
      if (this.get$length(this) > 1)
        throw H.wrapException(H.IterableElementError_tooMany());
      t1 = this._table;
      t2 = this._head;
      if (t2 >= t1.length)
        return H.ioore(t1, t2);
      return t1[t2];
    },
    toList$1$growable: function(_, growable) {
      var list, t1;
      if (growable) {
        list = H.setRuntimeTypeInfo([], [H.getTypeArgumentByIndex(this, 0)]);
        C.JSArray_methods.set$length(list, this.get$length(this));
      } else {
        t1 = Array(this.get$length(this));
        t1.fixed$length = init;
        list = H.setRuntimeTypeInfo(t1, [H.getTypeArgumentByIndex(this, 0)]);
      }
      this._writeToList$1(list);
      return list;
    },
    toList$0: function($receiver) {
      return this.toList$1$growable($receiver, true);
    },
    add$1: function(_, element) {
      this._add$1(element);
    },
    addAll$1: function(_, elements) {
      var t1, addCount, $length, t2, t3, newCapacity, newTable, endSpace, preSpace;
      t1 = J.getInterceptor(elements);
      if (!!t1.$isList) {
        addCount = t1.get$length(elements);
        $length = this.get$length(this);
        t1 = $length + addCount;
        t2 = this._table;
        t3 = t2.length;
        if (t1 >= t3) {
          newCapacity = P.ListQueue__nextPowerOf2(t1);
          if (typeof newCapacity !== "number")
            return H.iae(newCapacity);
          t2 = Array(newCapacity);
          t2.fixed$length = init;
          newTable = H.setRuntimeTypeInfo(t2, [H.getTypeArgumentByIndex(this, 0)]);
          this._tail = this._writeToList$1(newTable);
          this._table = newTable;
          this._head = 0;
          H.IterableMixinWorkaround_setRangeList(newTable, $length, t1, elements, 0);
          this._tail += addCount;
        } else {
          t1 = this._tail;
          endSpace = t3 - t1;
          if (addCount < endSpace) {
            H.IterableMixinWorkaround_setRangeList(t2, t1, t1 + addCount, elements, 0);
            this._tail += addCount;
          } else {
            preSpace = addCount - endSpace;
            H.IterableMixinWorkaround_setRangeList(t2, t1, t1 + endSpace, elements, 0);
            t1 = this._table;
            H.IterableMixinWorkaround_setRangeList(t1, 0, preSpace, elements, endSpace);
            this._tail = preSpace;
          }
        }
        ++this._modificationCount;
      } else
        for (t1 = t1.get$iterator(elements); t1.moveNext$0();)
          this._add$1(t1.get$current());
    },
    remove$1: function(_, object) {
      var i, t1;
      for (i = this._head; i !== this._tail; i = (i + 1 & this._table.length - 1) >>> 0) {
        t1 = this._table;
        if (i < 0 || i >= t1.length)
          return H.ioore(t1, i);
        if (J.$eq(t1[i], object)) {
          this._remove$1(i);
          ++this._modificationCount;
          return true;
        }
      }
      return false;
    },
    _filterWhere$2: function(test, removeMatching) {
      var modificationCount, i, t1, t2;
      modificationCount = this._modificationCount;
      i = this._head;
      for (; i !== this._tail;) {
        t1 = this._table;
        if (i < 0 || i >= t1.length)
          return H.ioore(t1, i);
        t1 = test.call$1(t1[i]);
        t2 = this._modificationCount;
        if (modificationCount !== t2)
          H.throwExpression(P.ConcurrentModificationError$(this));
        if (removeMatching === t1) {
          i = this._remove$1(i);
          modificationCount = ++this._modificationCount;
        } else
          i = (i + 1 & this._table.length - 1) >>> 0;
      }
    },
    removeWhere$1: function(_, test) {
      this._filterWhere$2(test, true);
    },
    clear$0: function(_) {
      var i, t1, t2, t3, t4;
      i = this._head;
      t1 = this._tail;
      if (i !== t1) {
        for (t2 = this._table, t3 = t2.length, t4 = t3 - 1; i !== t1; i = (i + 1 & t4) >>> 0) {
          if (i < 0 || i >= t3)
            return H.ioore(t2, i);
          t2[i] = null;
        }
        this._tail = 0;
        this._head = 0;
        ++this._modificationCount;
      }
    },
    toString$0: function(_) {
      return P.IterableBase_iterableToFullString(this, "{", "}");
    },
    removeFirst$0: function() {
      var t1, t2, t3, result;
      t1 = this._head;
      if (t1 === this._tail)
        throw H.wrapException(H.IterableElementError_noElement());
      ++this._modificationCount;
      t2 = this._table;
      t3 = t2.length;
      if (t1 >= t3)
        return H.ioore(t2, t1);
      result = t2[t1];
      t2[t1] = null;
      this._head = (t1 + 1 & t3 - 1) >>> 0;
      return result;
    },
    removeLast$0: function(_) {
      var t1, t2, t3, result;
      t1 = this._head;
      t2 = this._tail;
      if (t1 === t2)
        throw H.wrapException(H.IterableElementError_noElement());
      ++this._modificationCount;
      t1 = this._table;
      t3 = t1.length;
      t2 = (t2 - 1 & t3 - 1) >>> 0;
      this._tail = t2;
      if (t2 < 0 || t2 >= t3)
        return H.ioore(t1, t2);
      result = t1[t2];
      t1[t2] = null;
      return result;
    },
    _add$1: function(element) {
      var t1, t2, t3;
      t1 = this._table;
      t2 = this._tail;
      t3 = t1.length;
      if (t2 < 0 || t2 >= t3)
        return H.ioore(t1, t2);
      t1[t2] = element;
      t3 = (t2 + 1 & t3 - 1) >>> 0;
      this._tail = t3;
      if (this._head === t3)
        this._grow$0();
      ++this._modificationCount;
    },
    _remove$1: function(offset) {
      var t1, t2, mask, t3, t4, i, prevOffset, nextOffset;
      t1 = this._table;
      t2 = t1.length;
      mask = t2 - 1;
      t3 = this._head;
      t4 = this._tail;
      if ((offset - t3 & mask) >>> 0 < (t4 - offset & mask) >>> 0) {
        for (i = offset; i !== t3; i = prevOffset) {
          prevOffset = (i - 1 & mask) >>> 0;
          if (prevOffset < 0 || prevOffset >= t2)
            return H.ioore(t1, prevOffset);
          t4 = t1[prevOffset];
          if (i < 0 || i >= t2)
            return H.ioore(t1, i);
          t1[i] = t4;
        }
        if (t3 >= t2)
          return H.ioore(t1, t3);
        t1[t3] = null;
        this._head = (t3 + 1 & mask) >>> 0;
        return (offset + 1 & mask) >>> 0;
      } else {
        t3 = (t4 - 1 & mask) >>> 0;
        this._tail = t3;
        for (i = offset; i !== t3; i = nextOffset) {
          nextOffset = (i + 1 & mask) >>> 0;
          if (nextOffset < 0 || nextOffset >= t2)
            return H.ioore(t1, nextOffset);
          t4 = t1[nextOffset];
          if (i < 0 || i >= t2)
            return H.ioore(t1, i);
          t1[i] = t4;
        }
        if (t3 < 0 || t3 >= t2)
          return H.ioore(t1, t3);
        t1[t3] = null;
        return offset;
      }
    },
    _grow$0: function() {
      var t1, newTable, t2, split;
      t1 = Array(this._table.length * 2);
      t1.fixed$length = init;
      newTable = H.setRuntimeTypeInfo(t1, [H.getTypeArgumentByIndex(this, 0)]);
      t1 = this._table;
      t2 = this._head;
      split = t1.length - t2;
      H.IterableMixinWorkaround_setRangeList(newTable, 0, split, t1, t2);
      t1 = this._head;
      t2 = this._table;
      H.IterableMixinWorkaround_setRangeList(newTable, split, split + t1, t2, 0);
      this._head = 0;
      this._tail = this._table.length;
      this._table = newTable;
    },
    _writeToList$1: function(target) {
      var t1, t2, t3, $length, firstPartSize;
      t1 = this._head;
      t2 = this._tail;
      t3 = this._table;
      if (t1 <= t2) {
        $length = t2 - t1;
        H.IterableMixinWorkaround_setRangeList(target, 0, $length, t3, t1);
        return $length;
      } else {
        firstPartSize = t3.length - t1;
        H.IterableMixinWorkaround_setRangeList(target, 0, firstPartSize, t3, t1);
        t1 = this._tail;
        t2 = this._table;
        H.IterableMixinWorkaround_setRangeList(target, firstPartSize, firstPartSize + t1, t2, 0);
        return this._tail + firstPartSize;
      }
    },
    ListQueue$1: function(initialCapacity, $E) {
      var t1 = Array(8);
      t1.fixed$length = init;
      this._table = H.setRuntimeTypeInfo(t1, [$E]);
    },
    $isEfficientLength: true,
    $isIterable: true,
    $asIterable: null,
    static: {"^": "ListQueue__INITIAL_CAPACITY", ListQueue__nextPowerOf2: function(number) {
        var nextNumber;
        if (typeof number !== "number")
          return number.$shl();
        number = (number << 2 >>> 0) - 1;
        for (; true; number = nextNumber) {
          nextNumber = (number & number - 1) >>> 0;
          if (nextNumber === 0)
            return number;
        }
      }}
  },
  _ListQueueIterator: {
    "^": "Object;_queue,_end,_modificationCount,_collection$_position,_collection$_current",
    get$current: function() {
      return this._collection$_current;
    },
    moveNext$0: function() {
      var t1, t2, t3;
      t1 = this._queue;
      if (this._modificationCount !== t1._modificationCount)
        H.throwExpression(P.ConcurrentModificationError$(t1));
      t2 = this._collection$_position;
      if (t2 === this._end) {
        this._collection$_current = null;
        return false;
      }
      t1 = t1._table;
      t3 = t1.length;
      if (t2 >= t3)
        return H.ioore(t1, t2);
      this._collection$_current = t1[t2];
      this._collection$_position = (t2 + 1 & t3 - 1) >>> 0;
      return true;
    }
  },
  SetMixin: {
    "^": "Object;",
    get$isEmpty: function(_) {
      return this.get$length(this) === 0;
    },
    clear$0: function(_) {
      this.removeAll$1(this.toList$0(0));
    },
    addAll$1: function(_, elements) {
      var t1;
      for (t1 = J.get$iterator$ax(elements); t1.moveNext$0();)
        this.add$1(0, t1.get$current());
    },
    removeAll$1: function(elements) {
      var t1;
      for (t1 = J.get$iterator$ax(elements); t1.moveNext$0();)
        this.remove$1(0, t1.get$current());
    },
    retainAll$1: function(elements) {
      var toRemove, t1;
      toRemove = this.toSet$0(0);
      for (t1 = H.setRuntimeTypeInfo(new P.LinkedHashSetIterator(elements, elements._modifications, null, null), [null]), t1._cell = t1._set._first; t1.moveNext$0();)
        toRemove.remove$1(0, t1._collection$_current);
      this.removeAll$1(toRemove);
    },
    removeWhere$1: function(_, test) {
      var toRemove, t1, element;
      toRemove = [];
      for (t1 = this.get$iterator(this); t1.moveNext$0();) {
        element = t1.get$current();
        if (test.call$1(element) === true)
          toRemove.push(element);
      }
      this.removeAll$1(toRemove);
    },
    containsAll$1: function(other) {
      var t1;
      for (t1 = other.get$iterator(other); t1.moveNext$0();)
        if (!this.contains$1(0, t1.get$current()))
          return false;
      return true;
    },
    union$1: function(other) {
      var t1 = this.toSet$0(0);
      t1.addAll$1(0, other);
      return t1;
    },
    intersection$1: function(_, other) {
      var result, t1, element;
      result = this.toSet$0(0);
      for (t1 = this.get$iterator(this); t1.moveNext$0();) {
        element = t1.get$current();
        other.contains$1(0, element);
        result.remove$1(0, element);
      }
      return result;
    },
    toList$1$growable: function(_, growable) {
      var result, t1, i, element, i0;
      if (growable) {
        result = H.setRuntimeTypeInfo([], [H.getTypeArgumentByIndex(this, 0)]);
        C.JSArray_methods.set$length(result, this.get$length(this));
      } else {
        t1 = Array(this.get$length(this));
        t1.fixed$length = init;
        result = H.setRuntimeTypeInfo(t1, [H.getTypeArgumentByIndex(this, 0)]);
      }
      for (t1 = this.get$iterator(this), i = 0; t1.moveNext$0(); i = i0) {
        element = t1.get$current();
        i0 = i + 1;
        if (i >= result.length)
          return H.ioore(result, i);
        result[i] = element;
      }
      return result;
    },
    toList$0: function($receiver) {
      return this.toList$1$growable($receiver, true);
    },
    map$1: function(_, f) {
      return H.setRuntimeTypeInfo(new H.EfficientLengthMappedIterable(this, f), [H.getTypeArgumentByIndex(this, 0), null]);
    },
    get$single: function(_) {
      var it;
      if (this.get$length(this) > 1)
        throw H.wrapException(H.IterableElementError_tooMany());
      it = this.get$iterator(this);
      if (!it.moveNext$0())
        throw H.wrapException(H.IterableElementError_noElement());
      return it.get$current();
    },
    toString$0: function(_) {
      return P.IterableBase_iterableToFullString(this, "{", "}");
    },
    where$1: function(_, f) {
      var t1 = new H.WhereIterable(this, f);
      t1.$builtinTypeInfo = this.$builtinTypeInfo;
      return t1;
    },
    expand$1: function(_, f) {
      return H.setRuntimeTypeInfo(new H.ExpandIterable(this, f), [H.getTypeArgumentByIndex(this, 0), null]);
    },
    forEach$1: function(_, f) {
      var t1;
      for (t1 = this.get$iterator(this); t1.moveNext$0();)
        f.call$1(t1.get$current());
    },
    fold$2: function(_, initialValue, combine) {
      var t1, value;
      for (t1 = this.get$iterator(this), value = initialValue; t1.moveNext$0();)
        value = combine.call$2(value, t1.get$current());
      return value;
    },
    every$1: function(_, f) {
      var t1;
      for (t1 = this.get$iterator(this); t1.moveNext$0();)
        if (f.call$1(t1.get$current()) !== true)
          return false;
      return true;
    },
    any$1: function(_, test) {
      var t1;
      for (t1 = this.get$iterator(this); t1.moveNext$0();)
        if (test.call$1(t1.get$current()) === true)
          return true;
      return false;
    },
    get$first: function(_) {
      var it = this.get$iterator(this);
      if (!it.moveNext$0())
        throw H.wrapException(H.IterableElementError_noElement());
      return it.get$current();
    },
    get$last: function(_) {
      var it, result;
      it = this.get$iterator(this);
      if (!it.moveNext$0())
        throw H.wrapException(H.IterableElementError_noElement());
      do
        result = it.get$current();
      while (it.moveNext$0());
      return result;
    },
    $isEfficientLength: true,
    $isIterable: true,
    $asIterable: null
  },
  SetBase: {
    "^": "SetMixin;"
  }
}],
["dart.convert", "dart:convert", , P, {
  "^": "",
  _convertJsonToDartLazy: function(object) {
    var i;
    if (object == null)
      return;
    if (typeof object != "object")
      return object;
    if (Object.getPrototypeOf(object) !== Array.prototype)
      return new P._JsonMap(object, Object.create(null), null);
    for (i = 0; i < object.length; ++i)
      object[i] = P._convertJsonToDartLazy(object[i]);
    return object;
  },
  _parseJson: function(source, reviver) {
    var parsed, e, t1, exception;
    t1 = source;
    if (typeof t1 !== "string")
      throw H.wrapException(P.ArgumentError$(source));
    parsed = null;
    try {
      parsed = JSON.parse(source);
    } catch (exception) {
      t1 = H.unwrapException(exception);
      e = t1;
      throw H.wrapException(P.FormatException$(String(e), null, null));
    }

    return P._convertJsonToDartLazy(parsed);
  },
  _JsonMap: {
    "^": "Object;_original,_processed,_data",
    $index: function(_, key) {
      var t1, result;
      t1 = this._processed;
      if (t1 == null)
        return this._data.$index(0, key);
      else if (typeof key !== "string")
        return;
      else {
        result = t1[key];
        return typeof result == "undefined" ? this._process$1(key) : result;
      }
    },
    get$length: function(_) {
      var t1;
      if (this._processed == null) {
        t1 = this._data;
        t1 = t1.get$length(t1);
      } else
        t1 = this._convert$_computeKeys$0().length;
      return t1;
    },
    get$isEmpty: function(_) {
      var t1;
      if (this._processed == null) {
        t1 = this._data;
        t1 = t1.get$length(t1);
      } else
        t1 = this._convert$_computeKeys$0().length;
      return t1 === 0;
    },
    get$keys: function() {
      if (this._processed == null)
        return this._data.get$keys();
      var t1 = this._convert$_computeKeys$0();
      return H.SubListIterable$(t1, 0, null, H.getTypeArgumentByIndex(H.setRuntimeTypeInfo(new H.IterableMixinWorkaround(), [H.getTypeArgumentByIndex(t1, 0)]), 0));
    },
    get$values: function(_) {
      var t1;
      if (this._processed == null) {
        t1 = this._data;
        return t1.get$values(t1);
      }
      return H.MappedIterable_MappedIterable(this._convert$_computeKeys$0(), new P._JsonMap_values_closure(this), null, null);
    },
    $indexSet: function(_, key, value) {
      var processed, original;
      if (this._processed == null)
        this._data.$indexSet(0, key, value);
      else if (this.containsKey$1(key)) {
        processed = this._processed;
        processed[key] = value;
        original = this._original;
        if (original == null ? processed != null : original !== processed)
          original[key] = null;
      } else
        this._upgrade$0().$indexSet(0, key, value);
    },
    addAll$1: function(_, other) {
      J.forEach$1$ax(other, new P._JsonMap_addAll_closure(this));
    },
    containsValue$1: function(value) {
      var keys, i;
      if (this._processed == null)
        return this._data.containsValue$1(value);
      keys = this._convert$_computeKeys$0();
      for (i = 0; i < keys.length; ++i)
        if (J.$eq(this.$index(0, keys[i]), value))
          return true;
      return false;
    },
    containsKey$1: function(key) {
      if (this._processed == null)
        return this._data.containsKey$1(key);
      if (typeof key !== "string")
        return false;
      return Object.prototype.hasOwnProperty.call(this._original, key);
    },
    putIfAbsent$2: function(key, ifAbsent) {
      var value;
      if (this.containsKey$1(key))
        return this.$index(0, key);
      value = ifAbsent.call$0();
      this.$indexSet(0, key, value);
      return value;
    },
    remove$1: function(_, key) {
      if (this._processed != null && !this.containsKey$1(key))
        return;
      return this._upgrade$0().remove$1(0, key);
    },
    clear$0: function(_) {
      var t1;
      if (this._processed == null)
        this._data.clear$0(0);
      else {
        t1 = this._data;
        if (t1 != null)
          J.clear$0$ax(t1);
        this._processed = null;
        this._original = null;
        this._data = P.LinkedHashMap_LinkedHashMap$_empty(null, null);
      }
    },
    forEach$1: function(_, f) {
      var keys, i, key, value;
      if (this._processed == null)
        return this._data.forEach$1(0, f);
      keys = this._convert$_computeKeys$0();
      for (i = 0; i < keys.length; ++i) {
        key = keys[i];
        value = this._processed[key];
        if (typeof value == "undefined") {
          value = P._convertJsonToDartLazy(this._original[key]);
          this._processed[key] = value;
        }
        f.call$2(key, value);
        if (keys !== this._data)
          throw H.wrapException(P.ConcurrentModificationError$(this));
      }
    },
    toString$0: function(_) {
      return P.Maps_mapToString(this);
    },
    _convert$_computeKeys$0: function() {
      var keys = this._data;
      if (keys == null) {
        keys = Object.keys(this._original);
        this._data = keys;
      }
      return keys;
    },
    _upgrade$0: function() {
      var result, keys, i, t1, key;
      if (this._processed == null)
        return this._data;
      result = P.LinkedHashMap_LinkedHashMap$_empty(null, null);
      keys = this._convert$_computeKeys$0();
      for (i = 0; t1 = keys.length, i < t1; ++i) {
        key = keys[i];
        result.$indexSet(0, key, this.$index(0, key));
      }
      if (t1 === 0)
        keys.push(null);
      else
        C.JSArray_methods.set$length(keys, 0);
      this._processed = null;
      this._original = null;
      this._data = result;
      return result;
    },
    _process$1: function(key) {
      var result;
      if (!Object.prototype.hasOwnProperty.call(this._original, key))
        return;
      result = P._convertJsonToDartLazy(this._original[key]);
      return this._processed[key] = result;
    },
    $isMap: true,
    $asMap: function() {
      return [null, null];
    }
  },
  _JsonMap_values_closure: {
    "^": "Closure:13;this_0",
    call$1: function(each) {
      return this.this_0.$index(0, each);
    },
    $isFunction: true
  },
  _JsonMap_addAll_closure: {
    "^": "Closure:19;this_0",
    call$2: function(key, value) {
      this.this_0.$indexSet(0, key, value);
    },
    $isFunction: true
  },
  ChunkedConversionSink: {
    "^": "Object;"
  },
  Codec: {
    "^": "Object;"
  },
  Converter: {
    "^": "Object;"
  },
  Encoding: {
    "^": "Codec;",
    $asCodec: function() {
      return [P.String, [P.List, P.$int]];
    }
  },
  JsonUnsupportedObjectError: {
    "^": "Error;unsupportedObject,cause",
    toString$0: function(_) {
      if (this.cause != null)
        return "Converting object to an encodable object failed.";
      else
        return "Converting object did not return an encodable object.";
    },
    static: {JsonUnsupportedObjectError$: function(unsupportedObject, cause) {
        return new P.JsonUnsupportedObjectError(unsupportedObject, cause);
      }}
  },
  JsonCyclicError: {
    "^": "JsonUnsupportedObjectError;unsupportedObject,cause",
    toString$0: function(_) {
      return "Cyclic error in JSON stringify";
    },
    static: {JsonCyclicError$: function(object) {
        return new P.JsonCyclicError(object, null);
      }}
  },
  JsonCodec: {
    "^": "Codec;_reviver,_toEncodable",
    decode$2$reviver: function(source, reviver) {
      return P._parseJson(source, this.get$decoder()._reviver);
    },
    decode$1: function(source) {
      return this.decode$2$reviver(source, null);
    },
    get$decoder: function() {
      return C.JsonDecoder_null;
    },
    $asCodec: function() {
      return [P.Object, P.String];
    }
  },
  JsonEncoder: {
    "^": "Converter;indent,_toEncodableFunction",
    $asConverter: function() {
      return [P.Object, P.String];
    }
  },
  _JsonEncoderSink: {
    "^": "ChunkedConversionSink;_indent,_toEncodableFunction,_sink,_isDone",
    add$1: function(_, o) {
      var stringSink;
      if (this._isDone)
        throw H.wrapException(P.StateError$("Only one call to add allowed"));
      this._isDone = true;
      stringSink = this._sink.asStringSink$0();
      P._JsonStringifier__JsonStringifier(stringSink, this._toEncodableFunction, this._indent).stringifyValue$1(o);
      stringSink.close$0(0);
    },
    close$0: function(_) {
    },
    $asChunkedConversionSink: function() {
      return [P.Object];
    }
  },
  JsonDecoder: {
    "^": "Converter;_reviver",
    $asConverter: function() {
      return [P.String, P.Object];
    }
  },
  _JsonStringifier: {
    "^": "Object;_toEncodable,_sink,_seen",
    _toEncodable$1: function(arg0) {
      return this._toEncodable.call$1(arg0);
    },
    escape$1: function(s) {
      var $length, t1, t2, offset, i, charCode, t3;
      $length = s.length;
      for (t1 = J.getInterceptor$s(s), t2 = this._sink, offset = 0, i = 0; i < $length; ++i) {
        charCode = t1.codeUnitAt$1(s, i);
        if (charCode > 92)
          continue;
        if (charCode < 32) {
          if (i > offset)
            t2.write$1(C.JSString_methods.substring$2(s, offset, i));
          offset = i + 1;
          t2.writeCharCode$1(92);
          switch (charCode) {
            case 8:
              t2.writeCharCode$1(98);
              break;
            case 9:
              t2.writeCharCode$1(116);
              break;
            case 10:
              t2.writeCharCode$1(110);
              break;
            case 12:
              t2.writeCharCode$1(102);
              break;
            case 13:
              t2.writeCharCode$1(114);
              break;
            default:
              t2.writeCharCode$1(117);
              t2.writeCharCode$1(48);
              t2.writeCharCode$1(48);
              t3 = charCode >>> 4 & 15;
              t2.writeCharCode$1(t3 < 10 ? 48 + t3 : 87 + t3);
              t3 = charCode & 15;
              t2.writeCharCode$1(t3 < 10 ? 48 + t3 : 87 + t3);
              break;
          }
        } else if (charCode === 34 || charCode === 92) {
          if (i > offset)
            t2.write$1(C.JSString_methods.substring$2(s, offset, i));
          offset = i + 1;
          t2.writeCharCode$1(92);
          t2.writeCharCode$1(charCode);
        }
      }
      if (offset === 0)
        t2.write$1(s);
      else if (offset < $length)
        t2.write$1(t1.substring$2(s, offset, $length));
    },
    checkCycle$1: function(object) {
      var t1, t2, i, t3;
      for (t1 = this._seen, t2 = t1.length, i = 0; i < t2; ++i) {
        t3 = t1[i];
        if (object == null ? t3 == null : object === t3)
          throw H.wrapException(P.JsonCyclicError$(object));
      }
      t1.push(object);
    },
    stringifyValue$1: function(object) {
      var customJson, e, t1, exception;
      if (!this.stringifyJsonValue$1(object)) {
        this.checkCycle$1(object);
        try {
          customJson = this._toEncodable$1(object);
          if (!this.stringifyJsonValue$1(customJson)) {
            t1 = P.JsonUnsupportedObjectError$(object, null);
            throw H.wrapException(t1);
          }
          t1 = this._seen;
          if (0 >= t1.length)
            return H.ioore(t1, 0);
          t1.pop();
        } catch (exception) {
          t1 = H.unwrapException(exception);
          e = t1;
          throw H.wrapException(P.JsonUnsupportedObjectError$(object, e));
        }

      }
    },
    stringifyJsonValue$1: function(object) {
      var t1, t2, i, t3;
      t1 = {};
      if (typeof object === "number") {
        if (!C.JSNumber_methods.get$isFinite(object))
          return false;
        this._sink.write$1(C.JSNumber_methods.toString$0(object));
        return true;
      } else if (object === true) {
        this._sink.write$1("true");
        return true;
      } else if (object === false) {
        this._sink.write$1("false");
        return true;
      } else if (object == null) {
        this._sink.write$1("null");
        return true;
      } else if (typeof object === "string") {
        t1 = this._sink;
        t1.write$1("\"");
        this.escape$1(object);
        t1.write$1("\"");
        return true;
      } else {
        t2 = J.getInterceptor(object);
        if (!!t2.$isList) {
          this.checkCycle$1(object);
          t1 = this._sink;
          t1.write$1("[");
          if (t2.get$length(object) > 0) {
            this.stringifyValue$1(t2.$index(object, 0));
            for (i = 1; i < t2.get$length(object); ++i) {
              t1.write$1(",");
              this.stringifyValue$1(t2.$index(object, i));
            }
          }
          t1.write$1("]");
          this._removeSeen$1(object);
          return true;
        } else if (!!t2.$isMap) {
          this.checkCycle$1(object);
          t3 = this._sink;
          t3.write$1("{");
          t1.separator_0 = "\"";
          t2.forEach$1(object, new P._JsonStringifier_stringifyJsonValue_closure(t1, this));
          t3.write$1("}");
          this._removeSeen$1(object);
          return true;
        } else
          return false;
      }
    },
    _removeSeen$1: function(object) {
      var t1 = this._seen;
      if (0 >= t1.length)
        return H.ioore(t1, 0);
      t1.pop();
    },
    static: {"^": "_JsonStringifier_BACKSPACE,_JsonStringifier_TAB,_JsonStringifier_NEWLINE,_JsonStringifier_CARRIAGE_RETURN,_JsonStringifier_FORM_FEED,_JsonStringifier_QUOTE,_JsonStringifier_CHAR_0,_JsonStringifier_BACKSLASH,_JsonStringifier_CHAR_b,_JsonStringifier_CHAR_f,_JsonStringifier_CHAR_n,_JsonStringifier_CHAR_r,_JsonStringifier_CHAR_t,_JsonStringifier_CHAR_u", _JsonStringifier__JsonStringifier: function(sink, toEncodable, indent) {
        return new P._JsonStringifier(toEncodable, sink, []);
      }}
  },
  _JsonStringifier_stringifyJsonValue_closure: {
    "^": "Closure:60;box_0,this_1",
    call$2: function(key, value) {
      var t1, t2, t3;
      t1 = this.this_1;
      t2 = t1._sink;
      t3 = this.box_0;
      t2.write$1(t3.separator_0);
      t3.separator_0 = ",\"";
      t1.escape$1(key);
      t2.write$1("\":");
      t1.stringifyValue$1(value);
    },
    $isFunction: true
  },
  _ClosableStringSink: {
    "^": "Object;_callback,_sink",
    _callback$0: function() {
      return this._callback.call$0();
    },
    close$0: function(_) {
      return this._callback$0();
    },
    writeCharCode$1: function(charCode) {
      this._sink.write$1(H.Primitives_stringFromCharCode(charCode));
      return;
    },
    write$1: function(o) {
      return this._sink.write$1(o);
    },
    writeAll$2: function(objects, separator) {
      return this._sink.writeAll$2(objects, separator);
    }
  },
  _StringConversionSinkAsStringSinkAdapter: {
    "^": "Object;_buffer,_chunkedSink",
    close$0: function(_) {
      if (this._buffer._contents.length !== 0)
        this._flush$0();
      this._chunkedSink.close$0(0);
    },
    writeCharCode$1: function(charCode) {
      var t1 = this._buffer;
      t1.write$1(H.Primitives_stringFromCharCode(charCode));
      if (t1._contents.length > 16)
        this._flush$0();
    },
    write$1: function(o) {
      var t1, t2;
      t1 = this._buffer;
      t2 = t1._contents;
      if (t2.length !== 0) {
        t1._contents = "";
        this._chunkedSink.add$1(0, t2);
      }
      this._chunkedSink.add$1(0, o);
    },
    writeAll$2: function(objects, separator) {
      if (this._buffer._contents.length !== 0)
        this._flush$0();
      objects.get$iterator(objects).moveNext$0();
      return;
    },
    _flush$0: function() {
      var t1, accumulated;
      t1 = this._buffer;
      accumulated = t1._contents;
      t1._contents = "";
      this._chunkedSink.add$1(0, accumulated);
    },
    static: {"^": "_StringConversionSinkAsStringSinkAdapter__MIN_STRING_SIZE"}
  },
  StringConversionSinkBase: {
    "^": "StringConversionSinkMixin;"
  },
  StringConversionSinkMixin: {
    "^": "Object;",
    add$1: function(_, str) {
      return this.addSlice$4(str, 0, J.get$length$asx(str), false);
    },
    asStringSink$0: function() {
      return new P._StringConversionSinkAsStringSinkAdapter(P.StringBuffer$(""), this);
    }
  },
  _StringSinkConversionSink: {
    "^": "StringConversionSinkBase;_stringSink",
    close$0: [function(_) {
    }, "call$0", "get$close", 0, 0, 7],
    addSlice$4: function(str, start, end, isLast) {
      var t1, t2, i, t3;
      if (start !== 0 || end !== str.length)
        for (t1 = this._stringSink, t2 = J.getInterceptor$s(str), i = start; i < end; ++i) {
          t3 = H.Primitives_stringFromCharCode(t2.codeUnitAt$1(str, i));
          t1._contents += t3;
        }
      else
        this._stringSink.write$1(str);
      if (isLast)
        this.close$0(0);
    },
    add$1: function(_, str) {
      return this._stringSink.write$1(str);
    },
    asStringSink$0: function() {
      return new P._ClosableStringSink(this.get$close(this), this._stringSink);
    }
  },
  Utf8Codec: {
    "^": "Encoding;_allowMalformed",
    get$name: function(_) {
      return "utf-8";
    },
    decode$2$allowMalformed: function(codeUnits, allowMalformed) {
      allowMalformed = this._allowMalformed;
      return new P.Utf8Decoder(allowMalformed).convert$1(codeUnits);
    },
    decode$1: function(codeUnits) {
      return this.decode$2$allowMalformed(codeUnits, null);
    },
    get$encoder: function() {
      return new P.Utf8Encoder();
    }
  },
  Utf8Encoder: {
    "^": "Converter;",
    convert$1: function(string) {
      var t1, t2, encoder;
      t1 = string.length;
      t2 = Array(t1 * 3);
      t2.fixed$length = init;
      t2 = H.setRuntimeTypeInfo(t2, [P.$int]);
      encoder = new P._Utf8Encoder(0, 0, t2);
      if (encoder._fillBuffer$3(string, 0, t1) !== t1)
        encoder._writeSurrogate$2(C.JSString_methods.codeUnitAt$1(string, t1 - 1), 0);
      return C.JSArray_methods.sublist$2(t2, 0, encoder._bufferIndex);
    },
    $asConverter: function() {
      return [P.String, [P.List, P.$int]];
    }
  },
  _Utf8Encoder: {
    "^": "Object;_carry,_bufferIndex,_buffer",
    _writeSurrogate$2: function(leadingSurrogate, nextCodeUnit) {
      var t1, t2, rune, t3, t4;
      t1 = this._buffer;
      t2 = this._bufferIndex;
      if ((nextCodeUnit & 64512) === 56320) {
        rune = 65536 + ((leadingSurrogate & 1023) << 10 >>> 0) | nextCodeUnit & 1023;
        t3 = t2 + 1;
        this._bufferIndex = t3;
        t4 = t1.length;
        if (t2 >= t4)
          return H.ioore(t1, t2);
        t1[t2] = (240 | rune >>> 18) >>> 0;
        t2 = t3 + 1;
        this._bufferIndex = t2;
        if (t3 >= t4)
          return H.ioore(t1, t3);
        t1[t3] = 128 | rune >>> 12 & 63;
        t3 = t2 + 1;
        this._bufferIndex = t3;
        if (t2 >= t4)
          return H.ioore(t1, t2);
        t1[t2] = 128 | rune >>> 6 & 63;
        this._bufferIndex = t3 + 1;
        if (t3 >= t4)
          return H.ioore(t1, t3);
        t1[t3] = 128 | rune & 63;
        return true;
      } else {
        t3 = t2 + 1;
        this._bufferIndex = t3;
        t4 = t1.length;
        if (t2 >= t4)
          return H.ioore(t1, t2);
        t1[t2] = 224 | leadingSurrogate >>> 12;
        t2 = t3 + 1;
        this._bufferIndex = t2;
        if (t3 >= t4)
          return H.ioore(t1, t3);
        t1[t3] = 128 | leadingSurrogate >>> 6 & 63;
        this._bufferIndex = t2 + 1;
        if (t2 >= t4)
          return H.ioore(t1, t2);
        t1[t2] = 128 | leadingSurrogate & 63;
        return false;
      }
    },
    _fillBuffer$3: function(str, start, end) {
      var t1, t2, t3, stringIndex, codeUnit, t4, stringIndex0, t5;
      if (start !== end && (J.codeUnitAt$1$s(str, end - 1) & 64512) === 55296)
        --end;
      for (t1 = this._buffer, t2 = t1.length, t3 = J.getInterceptor$s(str), stringIndex = start; stringIndex < end; ++stringIndex) {
        codeUnit = t3.codeUnitAt$1(str, stringIndex);
        if (codeUnit <= 127) {
          t4 = this._bufferIndex;
          if (t4 >= t2)
            break;
          this._bufferIndex = t4 + 1;
          t1[t4] = codeUnit;
        } else if ((codeUnit & 64512) === 55296) {
          if (this._bufferIndex + 3 >= t2)
            break;
          stringIndex0 = stringIndex + 1;
          if (stringIndex0 >= str.length)
            H.throwExpression(P.RangeError$value(stringIndex0));
          if (this._writeSurrogate$2(codeUnit, str.charCodeAt(stringIndex0)))
            stringIndex = stringIndex0;
        } else if (codeUnit <= 2047) {
          t4 = this._bufferIndex;
          t5 = t4 + 1;
          if (t5 >= t2)
            break;
          this._bufferIndex = t5;
          if (t4 >= t2)
            return H.ioore(t1, t4);
          t1[t4] = 192 | codeUnit >>> 6;
          this._bufferIndex = t5 + 1;
          t1[t5] = 128 | codeUnit & 63;
        } else {
          t4 = this._bufferIndex;
          if (t4 + 2 >= t2)
            break;
          t5 = t4 + 1;
          this._bufferIndex = t5;
          if (t4 >= t2)
            return H.ioore(t1, t4);
          t1[t4] = 224 | codeUnit >>> 12;
          t4 = t5 + 1;
          this._bufferIndex = t4;
          if (t5 >= t2)
            return H.ioore(t1, t5);
          t1[t5] = 128 | codeUnit >>> 6 & 63;
          this._bufferIndex = t4 + 1;
          if (t4 >= t2)
            return H.ioore(t1, t4);
          t1[t4] = 128 | codeUnit & 63;
        }
      }
      return stringIndex;
    },
    static: {"^": "_Utf8Encoder__DEFAULT_BYTE_BUFFER_SIZE"}
  },
  Utf8Decoder: {
    "^": "Converter;_allowMalformed",
    convert$1: function(codeUnits) {
      var buffer, decoder;
      buffer = P.StringBuffer$("");
      decoder = new P._Utf8Decoder(this._allowMalformed, buffer, true, 0, 0, 0);
      decoder.convert$3(codeUnits, 0, J.get$length$asx(codeUnits));
      decoder.flush$0();
      return buffer._contents;
    },
    $asConverter: function() {
      return [[P.List, P.$int], P.String];
    }
  },
  _Utf8Decoder: {
    "^": "Object;_allowMalformed,_stringSink,_isFirstCharacter,_convert$_value,_expectedUnits,_extraUnits",
    close$0: function(_) {
      this.flush$0();
    },
    flush$0: function() {
      if (this._expectedUnits > 0) {
        if (!this._allowMalformed)
          throw H.wrapException(P.FormatException$("Unfinished UTF-8 octet sequence", null, null));
        this._stringSink.write$1(H.Primitives_stringFromCharCode(65533));
        this._convert$_value = 0;
        this._expectedUnits = 0;
        this._extraUnits = 0;
      }
    },
    convert$3: function(codeUnits, startIndex, endIndex) {
      var value, expectedUnits, extraUnits, t1, t2, t3, t4, t5, i, unit, t6, oneBytes, i0;
      value = this._convert$_value;
      expectedUnits = this._expectedUnits;
      extraUnits = this._extraUnits;
      this._convert$_value = 0;
      this._expectedUnits = 0;
      this._extraUnits = 0;
      t1 = new P._Utf8Decoder_convert_scanOneByteCharacters(endIndex);
      t2 = new P._Utf8Decoder_convert_addSingleBytes(this, codeUnits, startIndex, endIndex);
      $loop$0:
        for (t3 = this._stringSink, t4 = !this._allowMalformed, t5 = J.getInterceptor$asx(codeUnits), i = startIndex; true; i = i0) {
          $multibyte$2: {
            if (expectedUnits > 0) {
              do {
                if (i === endIndex)
                  break $loop$0;
                unit = t5.$index(codeUnits, i);
                t6 = J.getInterceptor$n(unit);
                if (t6.$and(unit, 192) !== 128) {
                  if (t4)
                    throw H.wrapException(P.FormatException$("Bad UTF-8 encoding 0x" + t6.toRadixString$1(unit, 16), null, null));
                  this._isFirstCharacter = false;
                  t6 = H.Primitives_stringFromCharCode(65533);
                  t3._contents += t6;
                  expectedUnits = 0;
                  break $multibyte$2;
                } else {
                  value = (value << 6 | t6.$and(unit, 63)) >>> 0;
                  --expectedUnits;
                  ++i;
                }
              } while (expectedUnits > 0);
              t6 = extraUnits - 1;
              if (t6 < 0 || t6 >= 4)
                return H.ioore(C.List_127_2047_65535_1114111, t6);
              if (value <= C.List_127_2047_65535_1114111[t6]) {
                if (t4)
                  throw H.wrapException(P.FormatException$("Overlong encoding of 0x" + C.JSInt_methods.toRadixString$1(value, 16), null, null));
                value = 65533;
                expectedUnits = 0;
                extraUnits = 0;
              }
              if (value > 1114111) {
                if (t4)
                  throw H.wrapException(P.FormatException$("Character outside valid Unicode range: 0x" + C.JSInt_methods.toRadixString$1(value, 16), null, null));
                value = 65533;
              }
              if (!this._isFirstCharacter || value !== 65279) {
                t6 = H.Primitives_stringFromCharCode(value);
                t3._contents += t6;
              }
              this._isFirstCharacter = false;
            }
          }
          for (; i < endIndex; i = i0) {
            oneBytes = t1.call$2(codeUnits, i);
            if (J.$gt$n(oneBytes, 0)) {
              this._isFirstCharacter = false;
              if (typeof oneBytes !== "number")
                return H.iae(oneBytes);
              i0 = i + oneBytes;
              t2.call$2(i, i0);
              if (i0 === endIndex)
                break;
              i = i0;
            }
            i0 = i + 1;
            unit = t5.$index(codeUnits, i);
            t6 = J.getInterceptor$n(unit);
            if (t6.$lt(unit, 0)) {
              if (t4)
                throw H.wrapException(P.FormatException$("Negative UTF-8 code unit: -0x" + J.toRadixString$1$n(t6.$negate(unit), 16), null, null));
              t6 = H.Primitives_stringFromCharCode(65533);
              t3._contents += t6;
            } else {
              if (t6.$and(unit, 224) === 192) {
                value = t6.$and(unit, 31);
                expectedUnits = 1;
                extraUnits = 1;
                continue $loop$0;
              }
              if (t6.$and(unit, 240) === 224) {
                value = t6.$and(unit, 15);
                expectedUnits = 2;
                extraUnits = 2;
                continue $loop$0;
              }
              if (t6.$and(unit, 248) === 240 && t6.$lt(unit, 245)) {
                value = t6.$and(unit, 7);
                expectedUnits = 3;
                extraUnits = 3;
                continue $loop$0;
              }
              if (t4)
                throw H.wrapException(P.FormatException$("Bad UTF-8 encoding 0x" + t6.toRadixString$1(unit, 16), null, null));
              this._isFirstCharacter = false;
              t6 = H.Primitives_stringFromCharCode(65533);
              t3._contents += t6;
              value = 65533;
              expectedUnits = 0;
              extraUnits = 0;
            }
          }
          break $loop$0;
        }
      if (expectedUnits > 0) {
        this._convert$_value = value;
        this._expectedUnits = expectedUnits;
        this._extraUnits = extraUnits;
      }
    },
    static: {"^": "_Utf8Decoder__LIMITS"}
  },
  _Utf8Decoder_convert_scanOneByteCharacters: {
    "^": "Closure:61;endIndex_0",
    call$2: function(units, from) {
      var to, t1, i, unit;
      to = this.endIndex_0;
      for (t1 = J.getInterceptor$asx(units), i = from; i < to; ++i) {
        unit = t1.$index(units, i);
        if (J.$and$n(unit, 127) !== unit)
          return i - from;
      }
      return to - from;
    },
    $isFunction: true
  },
  _Utf8Decoder_convert_addSingleBytes: {
    "^": "Closure:62;this_1,codeUnits_2,startIndex_3,endIndex_4",
    call$2: function(from, to) {
      var t1, t2, t3;
      t1 = from === 0 && to === J.get$length$asx(this.codeUnits_2);
      t2 = this.this_1;
      t3 = this.codeUnits_2;
      if (t1)
        t2._stringSink.write$1(P.String_String$fromCharCodes(t3));
      else
        t2._stringSink.write$1(P.String_String$fromCharCodes(J.sublist$2$ax(t3, from, to)));
    },
    $isFunction: true
  }
}],
["dart.core", "dart:core", , P, {
  "^": "",
  _symbolToString: function(symbol) {
    return H.Symbol_getName(symbol);
  },
  Comparable_compare: [function(a, b) {
    return J.compareTo$1$ns(a, b);
  }, "call$2", "Comparable_compare$closure", 4, 0, 14],
  Error_safeToString: function(object) {
    var buffer, t1, i, t2, codeUnit;
    if (typeof object === "number" || typeof object === "boolean" || null == object)
      return J.toString$0(object);
    if (typeof object === "string") {
      buffer = new P.StringBuffer("");
      buffer._contents = "\"";
      for (t1 = object.length, i = 0, t2 = "\""; i < t1; ++i) {
        codeUnit = C.JSString_methods.codeUnitAt$1(object, i);
        if (codeUnit <= 31)
          if (codeUnit === 10)
            t2 = buffer._contents += "\\n";
          else if (codeUnit === 13)
            t2 = buffer._contents += "\\r";
          else if (codeUnit === 9)
            t2 = buffer._contents += "\\t";
          else {
            t2 = buffer._contents += "\\x";
            if (codeUnit < 16)
              buffer._contents = t2 + "0";
            else {
              buffer._contents = t2 + "1";
              codeUnit -= 16;
            }
            t2 = H.Primitives_stringFromCharCode(codeUnit < 10 ? 48 + codeUnit : 87 + codeUnit);
            t2 = buffer._contents += t2;
          }
        else if (codeUnit === 92)
          t2 = buffer._contents += "\\\\";
        else if (codeUnit === 34)
          t2 = buffer._contents += "\\\"";
        else {
          t2 = H.Primitives_stringFromCharCode(codeUnit);
          t2 = buffer._contents += t2;
        }
      }
      t1 = t2 + "\"";
      buffer._contents = t1;
      return t1;
    }
    return "Instance of '" + H.Primitives_objectTypeName(object) + "'";
  },
  Exception_Exception: function(message) {
    return new P._ExceptionImplementation(message);
  },
  identical: [function(a, b) {
    return a == null ? b == null : a === b;
  }, "call$2", "identical$closure", 4, 0, 15],
  identityHashCode: [function(object) {
    return H.objectHashCode(object);
  }, "call$1", "identityHashCode$closure", 2, 0, 16],
  List_List$filled: function($length, fill, $E) {
    var result, t1, i;
    result = J.JSArray_JSArray$fixed($length, $E);
    if ($length !== 0 && true)
      for (t1 = result.length, i = 0; i < t1; ++i)
        result[i] = fill;
    return result;
  },
  List_List$from: function(other, growable, $E) {
    var list, t1;
    list = H.setRuntimeTypeInfo([], [$E]);
    for (t1 = J.get$iterator$ax(other); t1.moveNext$0();)
      list.push(t1.get$current());
    if (growable)
      return list;
    list.fixed$length = init;
    return list;
  },
  List_List$generate: function($length, generator, growable, $E) {
    var result, t1, i;
    if (growable) {
      result = H.setRuntimeTypeInfo([], [$E]);
      C.JSArray_methods.set$length(result, $length);
    } else {
      if (typeof $length !== "number")
        return H.iae($length);
      t1 = Array($length);
      t1.fixed$length = init;
      result = H.setRuntimeTypeInfo(t1, [$E]);
    }
    if (typeof $length !== "number")
      return H.iae($length);
    i = 0;
    for (; i < $length; ++i) {
      t1 = generator.call$1(i);
      if (i >= result.length)
        return H.ioore(result, i);
      result[i] = t1;
    }
    return result;
  },
  print: function(object) {
    var line = H.S(object);
    H.printString(line);
  },
  String_String$fromCharCodes: function(charCodes) {
    return H.Primitives_stringFromCharCodes(typeof charCodes !== "object" || charCodes === null || charCodes.constructor !== Array ? P.List_List$from(charCodes, true, null) : charCodes);
  },
  _combineSurrogatePair: function(start, end) {
    return 65536 + ((start & 1023) << 10 >>> 0) + (end & 1023);
  },
  NoSuchMethodError_toString_closure: {
    "^": "Closure:63;box_0",
    call$2: function(key, value) {
      var t1 = this.box_0;
      if (t1.i_1 > 0)
        t1.sb_0.write$1(", ");
      t1.sb_0.write$1(P._symbolToString(key));
    },
    $isFunction: true
  },
  bool: {
    "^": "Object;",
    $isbool: true
  },
  "+bool": 0,
  Comparable: {
    "^": "Object;"
  },
  DateTime: {
    "^": "Object;millisecondsSinceEpoch<,isUtc",
    $eq: function(_, other) {
      if (other == null)
        return false;
      if (!J.getInterceptor(other).$isDateTime)
        return false;
      return this.millisecondsSinceEpoch === other.millisecondsSinceEpoch && this.isUtc === other.isUtc;
    },
    compareTo$1: function(_, other) {
      return C.JSInt_methods.compareTo$1(this.millisecondsSinceEpoch, other.get$millisecondsSinceEpoch());
    },
    get$hashCode: function(_) {
      return this.millisecondsSinceEpoch;
    },
    toString$0: function(_) {
      var t1, y, m, d, h, min, sec, ms;
      t1 = this.isUtc;
      y = P.DateTime__fourDigits(t1 ? H.Primitives_lazyAsJsDate(this).getUTCFullYear() + 0 : H.Primitives_lazyAsJsDate(this).getFullYear() + 0);
      m = P.DateTime__twoDigits(t1 ? H.Primitives_lazyAsJsDate(this).getUTCMonth() + 1 : H.Primitives_lazyAsJsDate(this).getMonth() + 1);
      d = P.DateTime__twoDigits(t1 ? H.Primitives_lazyAsJsDate(this).getUTCDate() + 0 : H.Primitives_lazyAsJsDate(this).getDate() + 0);
      h = P.DateTime__twoDigits(t1 ? H.Primitives_lazyAsJsDate(this).getUTCHours() + 0 : H.Primitives_lazyAsJsDate(this).getHours() + 0);
      min = P.DateTime__twoDigits(t1 ? H.Primitives_lazyAsJsDate(this).getUTCMinutes() + 0 : H.Primitives_lazyAsJsDate(this).getMinutes() + 0);
      sec = P.DateTime__twoDigits(t1 ? H.Primitives_lazyAsJsDate(this).getUTCSeconds() + 0 : H.Primitives_lazyAsJsDate(this).getSeconds() + 0);
      ms = P.DateTime__threeDigits(t1 ? H.Primitives_lazyAsJsDate(this).getUTCMilliseconds() + 0 : H.Primitives_lazyAsJsDate(this).getMilliseconds() + 0);
      if (t1)
        return y + "-" + m + "-" + d + " " + h + ":" + min + ":" + sec + "." + ms + "Z";
      else
        return y + "-" + m + "-" + d + " " + h + ":" + min + ":" + sec + "." + ms;
    },
    add$1: function(_, duration) {
      return P.DateTime$fromMillisecondsSinceEpoch(this.millisecondsSinceEpoch + C.JSInt_methods._tdivFast$1(duration.get$_duration(), 1000), this.isUtc);
    },
    difference$1: function(other) {
      return P.Duration$(0, 0, 0, this.millisecondsSinceEpoch - other.millisecondsSinceEpoch, 0, 0);
    },
    DateTime$fromMillisecondsSinceEpoch$2$isUtc: function(millisecondsSinceEpoch, isUtc) {
      if (Math.abs(millisecondsSinceEpoch) > 8640000000000000)
        throw H.wrapException(P.ArgumentError$(millisecondsSinceEpoch));
    },
    DateTime$_now$0: function() {
      H.Primitives_lazyAsJsDate(this);
    },
    $isDateTime: true,
    static: {"^": "DateTime_MONDAY,DateTime_TUESDAY,DateTime_WEDNESDAY,DateTime_THURSDAY,DateTime_FRIDAY,DateTime_SATURDAY,DateTime_SUNDAY,DateTime_DAYS_PER_WEEK,DateTime_JANUARY,DateTime_FEBRUARY,DateTime_MARCH,DateTime_APRIL,DateTime_MAY,DateTime_JUNE,DateTime_JULY,DateTime_AUGUST,DateTime_SEPTEMBER,DateTime_OCTOBER,DateTime_NOVEMBER,DateTime_DECEMBER,DateTime_MONTHS_PER_YEAR,DateTime__MAX_MILLISECONDS_SINCE_EPOCH", DateTime$fromMillisecondsSinceEpoch: function(millisecondsSinceEpoch, isUtc) {
        var t1 = new P.DateTime(millisecondsSinceEpoch, isUtc);
        t1.DateTime$fromMillisecondsSinceEpoch$2$isUtc(millisecondsSinceEpoch, isUtc);
        return t1;
      }, DateTime__fourDigits: function(n) {
        var absN, sign;
        absN = Math.abs(n);
        sign = n < 0 ? "-" : "";
        if (absN >= 1000)
          return "" + n;
        if (absN >= 100)
          return sign + "0" + H.S(absN);
        if (absN >= 10)
          return sign + "00" + H.S(absN);
        return sign + "000" + H.S(absN);
      }, DateTime__threeDigits: function(n) {
        if (n >= 100)
          return "" + n;
        if (n >= 10)
          return "0" + n;
        return "00" + n;
      }, DateTime__twoDigits: function(n) {
        if (n >= 10)
          return "" + n;
        return "0" + n;
      }}
  },
  $double: {
    "^": "num;",
    $is$double: true
  },
  "+double": 0,
  Duration: {
    "^": "Object;_duration<",
    $add: function(_, other) {
      return P.Duration$(0, 0, this._duration + other.get$_duration(), 0, 0, 0);
    },
    $sub: function(_, other) {
      return P.Duration$(0, 0, this._duration - other.get$_duration(), 0, 0, 0);
    },
    $mul: function(_, factor) {
      if (typeof factor !== "number")
        return H.iae(factor);
      return P.Duration$(0, 0, C.JSNumber_methods.toInt$0(C.JSNumber_methods.roundToDouble$0(this._duration * factor)), 0, 0, 0);
    },
    $tdiv: function(_, quotient) {
      if (J.$eq(quotient, 0))
        throw H.wrapException(P.IntegerDivisionByZeroException$());
      if (typeof quotient !== "number")
        return H.iae(quotient);
      return P.Duration$(0, 0, C.JSInt_methods.$tdiv(this._duration, quotient), 0, 0, 0);
    },
    $lt: function(_, other) {
      return C.JSInt_methods.$lt(this._duration, other.get$_duration());
    },
    $gt: function(_, other) {
      return C.JSInt_methods.$gt(this._duration, other.get$_duration());
    },
    $le: function(_, other) {
      return C.JSInt_methods.$le(this._duration, other.get$_duration());
    },
    $ge: function(_, other) {
      return C.JSInt_methods.$ge(this._duration, other.get$_duration());
    },
    $eq: function(_, other) {
      if (other == null)
        return false;
      if (!J.getInterceptor(other).$isDuration)
        return false;
      return this._duration === other._duration;
    },
    get$hashCode: function(_) {
      return this._duration & 0x1FFFFFFF;
    },
    compareTo$1: function(_, other) {
      return C.JSInt_methods.compareTo$1(this._duration, other.get$_duration());
    },
    toString$0: function(_) {
      var t1, t2, twoDigitMinutes, twoDigitSeconds, sixDigitUs;
      t1 = new P.Duration_toString_twoDigits();
      t2 = this._duration;
      if (t2 < 0)
        return "-" + P.Duration$(0, 0, -t2, 0, 0, 0).toString$0(0);
      twoDigitMinutes = t1.call$1(C.JSInt_methods.remainder$1(C.JSInt_methods._tdivFast$1(t2, 60000000), 60));
      twoDigitSeconds = t1.call$1(C.JSInt_methods.remainder$1(C.JSInt_methods._tdivFast$1(t2, 1000000), 60));
      sixDigitUs = new P.Duration_toString_sixDigits().call$1(C.JSInt_methods.remainder$1(t2, 1000000));
      return "" + C.JSInt_methods._tdivFast$1(t2, 3600000000) + ":" + H.S(twoDigitMinutes) + ":" + H.S(twoDigitSeconds) + "." + H.S(sixDigitUs);
    },
    $negate: function(_) {
      return P.Duration$(0, 0, -this._duration, 0, 0, 0);
    },
    $isDuration: true,
    static: {"^": "Duration_MICROSECONDS_PER_MILLISECOND,Duration_MILLISECONDS_PER_SECOND,Duration_SECONDS_PER_MINUTE,Duration_MINUTES_PER_HOUR,Duration_HOURS_PER_DAY,Duration_MICROSECONDS_PER_SECOND,Duration_MICROSECONDS_PER_MINUTE,Duration_MICROSECONDS_PER_HOUR,Duration_MICROSECONDS_PER_DAY,Duration_MILLISECONDS_PER_MINUTE,Duration_MILLISECONDS_PER_HOUR,Duration_MILLISECONDS_PER_DAY,Duration_SECONDS_PER_HOUR,Duration_SECONDS_PER_DAY,Duration_MINUTES_PER_DAY,Duration_ZERO", Duration$: function(days, hours, microseconds, milliseconds, minutes, seconds) {
        return new P.Duration(days * 86400000000 + hours * 3600000000 + minutes * 60000000 + seconds * 1000000 + milliseconds * 1000 + microseconds);
      }}
  },
  Duration_toString_sixDigits: {
    "^": "Closure:64;",
    call$1: function(n) {
      if (n >= 100000)
        return "" + n;
      if (n >= 10000)
        return "0" + n;
      if (n >= 1000)
        return "00" + n;
      if (n >= 100)
        return "000" + n;
      if (n >= 10)
        return "0000" + n;
      return "00000" + n;
    },
    $isFunction: true
  },
  Duration_toString_twoDigits: {
    "^": "Closure:64;",
    call$1: function(n) {
      if (n >= 10)
        return "" + n;
      return "0" + n;
    },
    $isFunction: true
  },
  Error: {
    "^": "Object;",
    get$stackTrace: function() {
      return new H._StackTrace(this.$thrownJsError, null);
    },
    $isError: true
  },
  NullThrownError: {
    "^": "Error;",
    toString$0: function(_) {
      return "Throw of null.";
    }
  },
  ArgumentError: {
    "^": "Error;message",
    toString$0: function(_) {
      var t1 = this.message;
      if (t1 != null)
        return "Illegal argument(s): " + H.S(t1);
      return "Illegal argument(s)";
    },
    static: {ArgumentError$: function(message) {
        return new P.ArgumentError(message);
      }}
  },
  RangeError: {
    "^": "ArgumentError;message",
    toString$0: function(_) {
      return "RangeError: " + H.S(this.message);
    },
    static: {RangeError$: function(message) {
        return new P.RangeError(message);
      }, RangeError$value: function(value) {
        return new P.RangeError("value " + H.S(value));
      }, RangeError$range: function(value, start, end) {
        return new P.RangeError("value " + H.S(value) + " not in range " + start + ".." + H.S(end));
      }}
  },
  UnsupportedError: {
    "^": "Error;message",
    toString$0: function(_) {
      return "Unsupported operation: " + this.message;
    },
    static: {UnsupportedError$: function(message) {
        return new P.UnsupportedError(message);
      }}
  },
  UnimplementedError: {
    "^": "Error;message",
    toString$0: function(_) {
      var t1 = this.message;
      return t1 != null ? "UnimplementedError: " + H.S(t1) : "UnimplementedError";
    },
    $isError: true,
    static: {UnimplementedError$: function(message) {
        return new P.UnimplementedError(message);
      }}
  },
  StateError: {
    "^": "Error;message",
    toString$0: function(_) {
      return "Bad state: " + this.message;
    },
    static: {StateError$: function(message) {
        return new P.StateError(message);
      }}
  },
  ConcurrentModificationError: {
    "^": "Error;modifiedObject",
    toString$0: function(_) {
      var t1 = this.modifiedObject;
      if (t1 == null)
        return "Concurrent modification during iteration.";
      return "Concurrent modification during iteration: " + H.S(P.Error_safeToString(t1)) + ".";
    },
    static: {ConcurrentModificationError$: function(modifiedObject) {
        return new P.ConcurrentModificationError(modifiedObject);
      }}
  },
  OutOfMemoryError: {
    "^": "Object;",
    toString$0: function(_) {
      return "Out of Memory";
    },
    get$stackTrace: function() {
      return;
    },
    $isError: true
  },
  StackOverflowError: {
    "^": "Object;",
    toString$0: function(_) {
      return "Stack Overflow";
    },
    get$stackTrace: function() {
      return;
    },
    $isStackOverflowError: true,
    $isError: true
  },
  CyclicInitializationError: {
    "^": "Error;variableName",
    toString$0: function(_) {
      return "Reading static variable '" + this.variableName + "' during its initialization";
    },
    static: {CyclicInitializationError$: function(variableName) {
        return new P.CyclicInitializationError(variableName);
      }}
  },
  _ExceptionImplementation: {
    "^": "Object;message",
    toString$0: function(_) {
      var t1 = this.message;
      if (t1 == null)
        return "Exception";
      return "Exception: " + H.S(t1);
    }
  },
  FormatException: {
    "^": "Object;message,source>,offset",
    toString$0: function(_) {
      var t1, report, offset, source, lineNum, lineStart, lastWasCR, i, $char, lineEnd, end, start, prefix, postfix, slice;
      t1 = this.message;
      report = t1 != null && "" !== t1 ? "FormatException: " + H.S(t1) : "FormatException";
      offset = this.offset;
      source = this.source;
      if (typeof source !== "string")
        return offset != null ? report + (" (at offset " + H.S(offset) + ")") : report;
      if (offset != null)
        t1 = offset < 0 || offset > source.length;
      else
        t1 = false;
      if (t1)
        offset = null;
      if (offset == null) {
        if (source.length > 78)
          source = J.substring$2$s(source, 0, 75) + "...";
        return report + "\n" + H.S(source);
      }
      for (t1 = J.getInterceptor$s(source), lineNum = 1, lineStart = 0, lastWasCR = null, i = 0; i < offset; ++i) {
        $char = t1.codeUnitAt$1(source, i);
        if ($char === 10) {
          if (lineStart !== i || lastWasCR !== true)
            ++lineNum;
          lineStart = i + 1;
          lastWasCR = false;
        } else if ($char === 13) {
          ++lineNum;
          lineStart = i + 1;
          lastWasCR = true;
        }
      }
      report = lineNum > 1 ? report + (" (at line " + lineNum + ", character " + (offset - lineStart + 1) + ")\n") : report + (" (at character " + (offset + 1) + ")\n");
      lineEnd = source.length;
      for (i = offset; i < lineEnd; ++i) {
        $char = t1.codeUnitAt$1(source, i);
        if ($char === 10 || $char === 13) {
          lineEnd = i;
          break;
        }
      }
      if (lineEnd - lineStart > 78)
        if (offset - lineStart < 75) {
          end = lineStart + 75;
          start = lineStart;
          prefix = "";
          postfix = "...";
        } else {
          if (lineEnd - offset < 75) {
            start = lineEnd - 75;
            end = lineEnd;
            postfix = "";
          } else {
            start = offset - 36;
            end = offset + 36;
            postfix = "...";
          }
          prefix = "...";
        }
      else {
        end = lineEnd;
        start = lineStart;
        prefix = "";
        postfix = "";
      }
      slice = t1.substring$2(source, start, end);
      return report + prefix + slice + postfix + "\n" + C.JSString_methods.$mul(" ", offset - start + prefix.length) + "^\n";
    },
    $isFormatException: true,
    static: {FormatException$: function(message, source, offset) {
        return new P.FormatException(message, source, offset);
      }}
  },
  IntegerDivisionByZeroException: {
    "^": "Object;",
    toString$0: function(_) {
      return "IntegerDivisionByZeroException";
    },
    static: {IntegerDivisionByZeroException$: function() {
        return new P.IntegerDivisionByZeroException();
      }}
  },
  Expando: {
    "^": "Object;name>",
    toString$0: function(_) {
      return "Expando:" + H.S(this.name);
    },
    $index: function(_, object) {
      var values = H.Primitives_getProperty(object, "expando$values");
      return values == null ? null : H.Primitives_getProperty(values, this._getKey$0());
    },
    $indexSet: function(_, object, value) {
      var values = H.Primitives_getProperty(object, "expando$values");
      if (values == null) {
        values = new P.Object();
        H.Primitives_setProperty(object, "expando$values", values);
      }
      H.Primitives_setProperty(values, this._getKey$0(), value);
    },
    _getKey$0: function() {
      var key, t1;
      key = H.Primitives_getProperty(this, "expando$key");
      if (key == null) {
        t1 = $.Expando__keyCount;
        $.Expando__keyCount = t1 + 1;
        key = "expando$key$" + t1;
        H.Primitives_setProperty(this, "expando$key", key);
      }
      return key;
    },
    static: {"^": "Expando__KEY_PROPERTY_NAME,Expando__EXPANDO_PROPERTY_NAME,Expando__keyCount"}
  },
  Function: {
    "^": "Object;",
    $isFunction: true
  },
  $int: {
    "^": "num;",
    $is$int: true
  },
  "+int": 0,
  Iterable: {
    "^": "Object;",
    $isIterable: true,
    $asIterable: null
  },
  Iterator: {
    "^": "Object;"
  },
  List: {
    "^": "Object;",
    $isList: true,
    $asList: null,
    $isEfficientLength: true,
    $isIterable: true,
    $asIterable: null
  },
  "+List": 0,
  Map: {
    "^": "Object;",
    $isMap: true
  },
  Null: {
    "^": "Object;",
    toString$0: function(_) {
      return "null";
    }
  },
  "+Null": 0,
  num: {
    "^": "Object;",
    $isnum: true
  },
  "+num": 0,
  Object: {
    "^": ";",
    $eq: function(_, other) {
      return this === other;
    },
    get$hashCode: function(_) {
      return H.Primitives_objectHashCode(this);
    },
    toString$0: function(_) {
      return H.Primitives_objectToString(this);
    }
  },
  Pattern: {
    "^": "Object;",
    $isPattern: true
  },
  Match: {
    "^": "Object;"
  },
  Set: {
    "^": "IterableBase;",
    $isEfficientLength: true
  },
  StackTrace: {
    "^": "Object;"
  },
  Stopwatch: {
    "^": "Object;_start,_stop",
    start$0: [function(_) {
      var t1, t2, t3;
      t1 = this._start == null;
      if (!t1 && this._stop == null)
        return;
      t2 = $.Primitives_timerTicks;
      if (t1)
        this._start = t2.call$0();
      else {
        t1 = t2.call$0();
        t2 = this._stop;
        t3 = this._start;
        if (typeof t2 !== "number")
          return t2.$sub();
        if (typeof t3 !== "number")
          return H.iae(t3);
        this._start = J.$sub$n(t1, t2 - t3);
        this._stop = null;
      }
    }, "call$0", "get$start", 0, 0, 7],
    stop$0: function(_) {
      if (!(this._start != null && this._stop == null))
        return;
      this._stop = $.Primitives_timerTicks.call$0();
    },
    reset$0: function(_) {
      var t1;
      if (this._start == null)
        return;
      t1 = $.Primitives_timerTicks.call$0();
      this._start = t1;
      if (this._stop != null)
        this._stop = t1;
    },
    get$elapsedTicks: function() {
      var t1, t2;
      t1 = this._start;
      if (t1 == null)
        return 0;
      t2 = this._stop;
      if (t2 == null)
        t1 = J.$sub$n($.Primitives_timerTicks.call$0(), this._start);
      else {
        if (typeof t2 !== "number")
          return t2.$sub();
        if (typeof t1 !== "number")
          return H.iae(t1);
        t1 = t2 - t1;
      }
      return t1;
    },
    static: {"^": "Stopwatch__frequency"}
  },
  String: {
    "^": "Object;",
    $isString: true,
    $isPattern: true
  },
  "+String": 0,
  Runes: {
    "^": "IterableBase;string<",
    get$iterator: function(_) {
      return new P.RuneIterator(this.string, 0, 0, null);
    },
    get$last: function(_) {
      var t1, t2, code, previousCode;
      t1 = this.string;
      t2 = t1.length;
      if (t2 === 0)
        throw H.wrapException(P.StateError$("No elements."));
      code = C.JSString_methods.codeUnitAt$1(t1, t2 - 1);
      if ((code & 64512) === 56320 && t2 > 1) {
        previousCode = C.JSString_methods.codeUnitAt$1(t1, t2 - 2);
        if ((previousCode & 64512) === 55296)
          return P._combineSurrogatePair(previousCode, code);
      }
      return code;
    },
    $asIterableBase: function() {
      return [P.$int];
    },
    $asIterable: function() {
      return [P.$int];
    }
  },
  RuneIterator: {
    "^": "Object;string<,_core$_position,_nextPosition,_currentCodePoint",
    get$current: function() {
      return this._currentCodePoint;
    },
    moveNext$0: function() {
      var t1, t2, t3, codeUnit, nextPosition, nextCodeUnit;
      t1 = this._nextPosition;
      this._core$_position = t1;
      t2 = this.string;
      t3 = t2.length;
      if (t1 === t3) {
        this._currentCodePoint = null;
        return false;
      }
      codeUnit = C.JSString_methods.codeUnitAt$1(t2, t1);
      nextPosition = this._core$_position + 1;
      if ((codeUnit & 64512) === 55296 && nextPosition < t3) {
        nextCodeUnit = C.JSString_methods.codeUnitAt$1(t2, nextPosition);
        if ((nextCodeUnit & 64512) === 56320) {
          this._nextPosition = nextPosition + 1;
          this._currentCodePoint = P._combineSurrogatePair(codeUnit, nextCodeUnit);
          return true;
        }
      }
      this._nextPosition = nextPosition;
      this._currentCodePoint = codeUnit;
      return true;
    }
  },
  StringBuffer: {
    "^": "Object;_contents<",
    get$length: function(_) {
      return this._contents.length;
    },
    get$isEmpty: function(_) {
      return this._contents.length === 0;
    },
    write$1: function(obj) {
      this._contents += typeof obj === "string" ? obj : H.S(obj);
    },
    writeCharCode$1: function(charCode) {
      this.write$1(H.Primitives_stringFromCharCode(charCode));
    },
    writeAll$2: function(objects, separator) {
      var iterator, str;
      iterator = J.get$iterator$ax(objects);
      if (!iterator.moveNext$0())
        return;
      if (separator.length === 0) {
        do {
          str = iterator.get$current();
          this._contents += typeof str === "string" ? str : H.S(str);
        } while (iterator.moveNext$0());
      } else {
        this.write$1(iterator.get$current());
        for (; iterator.moveNext$0();) {
          this._contents += separator;
          str = iterator.get$current();
          this._contents += typeof str === "string" ? str : H.S(str);
        }
      }
    },
    clear$0: function(_) {
      this._contents = "";
    },
    toString$0: function(_) {
      return this._contents;
    },
    StringBuffer$1: function($content) {
      this._contents = $content;
    },
    static: {StringBuffer$: function($content) {
        var t1 = new P.StringBuffer("");
        t1.StringBuffer$1($content);
        return t1;
      }}
  },
  Symbol: {
    "^": "Object;"
  },
  Uri: {
    "^": "Object;_host,_port,_path,scheme<,_userInfo,_query,_fragment,_pathSegments,_queryParameters",
    get$host: function(_) {
      var t1 = this._host;
      if (t1 == null)
        return "";
      if (J.getInterceptor$s(t1).startsWith$1(t1, "["))
        return C.JSString_methods.substring$2(t1, 1, t1.length - 1);
      return t1;
    },
    get$port: function(_) {
      var t1 = this._port;
      if (t1 == null)
        return P.Uri__defaultPort(this.scheme);
      return t1;
    },
    get$path: function(_) {
      return this._path;
    },
    get$query: function(_) {
      var t1 = this._query;
      return t1 == null ? "" : t1;
    },
    query$3: function($receiver, arg0, arg1, arg2) {
      return this.get$query(this).call$3(arg0, arg1, arg2);
    },
    _merge$2: function(base, reference) {
      if (base === "")
        return "/" + reference;
      return C.JSString_methods.substring$2(base, 0, C.JSString_methods.lastIndexOf$1(base, "/") + 1) + reference;
    },
    _hasDotSegments$1: function(path) {
      if (path.length > 0 && C.JSString_methods.codeUnitAt$1(path, 0) === 58)
        return true;
      return C.JSString_methods.indexOf$1(path, "/.") !== -1;
    },
    _removeDotSegments$1: function(path) {
      var output, t1, appendSlash, segment, t2, t3;
      if (!this._hasDotSegments$1(path))
        return path;
      output = [];
      for (t1 = path.split("/"), t1 = H.setRuntimeTypeInfo(new H.ListIterator(t1, t1.length, 0, null), [H.getTypeArgumentByIndex(t1, 0)]), appendSlash = false; t1.moveNext$0();) {
        segment = t1.__internal$_current;
        if (J.$eq(segment, "..")) {
          t2 = output.length;
          if (t2 !== 0)
            if (t2 === 1) {
              if (0 >= t2)
                return H.ioore(output, 0);
              t3 = output[0] !== "";
            } else
              t3 = true;
          else
            t3 = false;
          if (t3) {
            if (0 >= t2)
              return H.ioore(output, 0);
            output.pop();
          }
          appendSlash = true;
        } else if ("." === segment)
          appendSlash = true;
        else {
          output.push(segment);
          appendSlash = false;
        }
      }
      if (appendSlash)
        output.push("");
      return C.JSArray_methods.join$1(output, "/");
    },
    resolveUri$1: function(reference) {
      var targetScheme, targetUserInfo, targetHost, targetPort, targetPath, targetQuery, t1, fragment;
      targetScheme = reference.scheme;
      if (targetScheme.length !== 0) {
        if (reference._host != null) {
          targetUserInfo = reference._userInfo;
          targetHost = reference.get$host(reference);
          targetPort = reference._port != null ? reference.get$port(reference) : null;
        } else {
          targetUserInfo = "";
          targetHost = null;
          targetPort = null;
        }
        targetPath = this._removeDotSegments$1(reference._path);
        targetQuery = reference._query;
        if (targetQuery != null)
          ;
        else
          targetQuery = null;
      } else {
        targetScheme = this.scheme;
        if (reference._host != null) {
          targetUserInfo = reference._userInfo;
          targetHost = reference.get$host(reference);
          targetPort = P.Uri__makePort(reference._port != null ? reference.get$port(reference) : null, targetScheme);
          targetPath = this._removeDotSegments$1(reference._path);
          targetQuery = reference._query;
          if (targetQuery != null)
            ;
          else
            targetQuery = null;
        } else {
          t1 = reference._path;
          if (t1 === "") {
            targetPath = this._path;
            targetQuery = reference._query;
            if (targetQuery != null)
              ;
            else
              targetQuery = this._query;
          } else {
            targetPath = C.JSString_methods.startsWith$1(t1, "/") ? this._removeDotSegments$1(t1) : this._removeDotSegments$1(this._merge$2(this._path, t1));
            targetQuery = reference._query;
            if (targetQuery != null)
              ;
            else
              targetQuery = null;
          }
          targetUserInfo = this._userInfo;
          targetHost = this._host;
          targetPort = this._port;
        }
      }
      fragment = reference._fragment;
      if (fragment != null)
        ;
      else
        fragment = null;
      return new P.Uri(targetHost, targetPort, targetPath, targetScheme, targetUserInfo, targetQuery, fragment, null, null);
    },
    toString$0: function(_) {
      var sb, t1, t2, t3;
      sb = P.StringBuffer$("");
      t1 = this.scheme;
      if ("" !== t1) {
        sb.write$1(t1);
        sb.write$1(":");
      }
      t2 = this._host;
      t3 = t2 == null;
      if (!t3 || C.JSString_methods.startsWith$1(this._path, "//") || t1 === "file") {
        sb.write$1("//");
        t1 = this._userInfo;
        if (t1.length !== 0) {
          sb.write$1(t1);
          sb.write$1("@");
        }
        if (!t3)
          sb.write$1(t2);
        t1 = this._port;
        if (t1 != null) {
          sb.write$1(":");
          sb.write$1(t1);
        }
      }
      sb.write$1(this._path);
      t1 = this._query;
      if (t1 != null) {
        sb.write$1("?");
        sb.write$1(t1);
      }
      t1 = this._fragment;
      if (t1 != null) {
        sb.write$1("#");
        sb.write$1(t1);
      }
      return sb._contents;
    },
    $eq: function(_, other) {
      var t1, t2, t3, t4;
      if (other == null)
        return false;
      t1 = J.getInterceptor(other);
      if (!t1.$isUri)
        return false;
      if (this.scheme === other.scheme)
        if (this._host != null === (other._host != null))
          if (this._userInfo === other._userInfo) {
            t2 = this.get$host(this);
            t3 = t1.get$host(other);
            if (t2 == null ? t3 == null : t2 === t3) {
              t2 = this.get$port(this);
              t1 = t1.get$port(other);
              if (t2 == null ? t1 == null : t2 === t1)
                if (this._path === other._path) {
                  t1 = this._query;
                  t2 = t1 == null;
                  t3 = other._query;
                  t4 = t3 == null;
                  if (!t2 === !t4) {
                    if (t2)
                      t1 = "";
                    if (t1 == null ? (t4 ? "" : t3) == null : t1 === (t4 ? "" : t3)) {
                      t1 = this._fragment;
                      t2 = t1 == null;
                      t3 = other._fragment;
                      t4 = t3 == null;
                      if (!t2 === !t4) {
                        if (t2)
                          t1 = "";
                        t1 = t1 == null ? (t4 ? "" : t3) == null : t1 === (t4 ? "" : t3);
                      } else
                        t1 = false;
                    } else
                      t1 = false;
                  } else
                    t1 = false;
                } else
                  t1 = false;
              else
                t1 = false;
            } else
              t1 = false;
          } else
            t1 = false;
        else
          t1 = false;
      else
        t1 = false;
      return t1;
    },
    get$hashCode: function(_) {
      var t1, t2, t3, t4, t5;
      t1 = new P.Uri_hashCode_combine();
      t2 = this.get$host(this);
      t3 = this.get$port(this);
      t4 = this._query;
      if (t4 == null)
        t4 = "";
      t5 = this._fragment;
      return t1.call$2(this.scheme, t1.call$2(this._userInfo, t1.call$2(t2, t1.call$2(t3, t1.call$2(this._path, t1.call$2(t4, t1.call$2(t5 == null ? "" : t5, 1)))))));
    },
    $isUri: true,
    static: {"^": "Uri__SPACE,Uri__DOUBLE_QUOTE,Uri__NUMBER_SIGN,Uri__PERCENT,Uri__ASTERISK,Uri__PLUS,Uri__SLASH,Uri__ZERO,Uri__NINE,Uri__COLON,Uri__LESS,Uri__GREATER,Uri__QUESTION,Uri__AT_SIGN,Uri__UPPER_CASE_A,Uri__UPPER_CASE_F,Uri__UPPER_CASE_Z,Uri__LEFT_BRACKET,Uri__BACKSLASH,Uri__RIGHT_BRACKET,Uri__LOWER_CASE_A,Uri__LOWER_CASE_F,Uri__LOWER_CASE_Z,Uri__BAR,Uri__unreservedTable,Uri__unreserved2396Table,Uri__encodeFullTable,Uri__schemeTable,Uri__schemeLowerTable,Uri__subDelimitersTable,Uri__genDelimitersTable,Uri__userinfoTable,Uri__regNameTable,Uri__pathCharTable,Uri__pathCharOrSlashTable,Uri__queryCharTable", Uri__defaultPort: function(scheme) {
        if (scheme === "http")
          return 80;
        if (scheme === "https")
          return 443;
        return 0;
      }, Uri_parse: function(uri) {
        var t1, pathStart, state, t2, i, t3, $char, index, t4, path, numberSignIndex, query, fragment;
        t1 = {};
        t1.scheme_0 = "";
        t1.userinfo_1 = "";
        t1.host_2 = null;
        t1.port_3 = null;
        t1.index_4 = 0;
        t1.char_5 = -1;
        t2 = J.getInterceptor$asx(uri);
        i = 0;
        while (true) {
          t3 = t2.get$length(uri);
          if (typeof t3 !== "number")
            return H.iae(t3);
          if (!(i < t3)) {
            pathStart = 0;
            state = 0;
            break;
          }
          $char = t2.codeUnitAt$1(uri, i);
          t1.char_5 = $char;
          if ($char === 63 || $char === 35) {
            pathStart = 0;
            state = 0;
            break;
          }
          if ($char === 47) {
            state = i === 0 ? 2 : 1;
            pathStart = 0;
            break;
          }
          if ($char === 58) {
            if (i === 0)
              P.Uri__fail(uri, 0, "Invalid empty scheme");
            t1.scheme_0 = P.Uri__makeScheme(uri, i);
            ++i;
            if (i === uri.length) {
              t1.char_5 = -1;
              state = 0;
            } else {
              $char = C.JSString_methods.codeUnitAt$1(uri, i);
              t1.char_5 = $char;
              if ($char === 63 || $char === 35)
                state = 0;
              else
                state = $char === 47 ? 2 : 1;
            }
            pathStart = i;
            break;
          }
          ++i;
          t1.char_5 = -1;
        }
        t1.index_4 = i;
        if (state === 2) {
          index = i + 1;
          t1.index_4 = index;
          if (index === t2.get$length(uri)) {
            t1.char_5 = -1;
            state = 0;
          } else {
            $char = t2.codeUnitAt$1(uri, t1.index_4);
            t1.char_5 = $char;
            if ($char === 47) {
              ++t1.index_4;
              new P.Uri_parse_parseAuth(t1, uri, -1).call$0();
              pathStart = t1.index_4;
            }
            t3 = t1.char_5;
            state = t3 === 63 || t3 === 35 || t3 === -1 ? 0 : 1;
          }
        }
        if (state === 1)
          for (; ++t1.index_4 < t2.get$length(uri);) {
            $char = t2.codeUnitAt$1(uri, t1.index_4);
            t1.char_5 = $char;
            if ($char === 63 || $char === 35)
              break;
            t1.char_5 = -1;
          }
        t3 = t1.scheme_0;
        t4 = t1.host_2;
        path = P.Uri__makePath(uri, pathStart, t1.index_4, null, t4 != null, t3 === "file");
        t3 = t1.char_5;
        if (t3 === 63) {
          numberSignIndex = t2.indexOf$2(uri, "#", t1.index_4 + 1);
          t3 = t1.index_4;
          if (numberSignIndex < 0) {
            query = P.Uri__makeQuery(uri, t3 + 1, t2.get$length(uri), null);
            fragment = null;
          } else {
            query = P.Uri__makeQuery(uri, t3 + 1, numberSignIndex, null);
            fragment = P.Uri__makeFragment(uri, numberSignIndex + 1, t2.get$length(uri));
          }
        } else {
          fragment = t3 === 35 ? P.Uri__makeFragment(uri, t1.index_4 + 1, t2.get$length(uri)) : null;
          query = null;
        }
        t2 = t1.scheme_0;
        t3 = t1.userinfo_1;
        return new P.Uri(t1.host_2, t1.port_3, path, t2, t3, query, fragment, null, null);
      }, Uri__fail: function(uri, index, message) {
        throw H.wrapException(P.FormatException$(message, uri, index));
      }, Uri_Uri: function(fragment, host, path, pathSegments, port, query, queryParameters, scheme, userInfo) {
        var isFile, t1;
        scheme = P.Uri__makeScheme(scheme, scheme.length);
        userInfo = P.Uri__makeUserInfo(userInfo, 0, userInfo.length);
        host = P.Uri__makeHost(host, 0, 0, false);
        query = P.Uri__makeQuery(query, 0, 0, queryParameters);
        fragment = P.Uri__makeFragment(fragment, 0, 0);
        port = P.Uri__makePort(port, scheme);
        isFile = scheme === "file";
        if (host == null)
          t1 = userInfo.length !== 0 || port != null || isFile;
        else
          t1 = false;
        if (t1)
          host = "";
        t1 = path.length;
        return new P.Uri(host, port, P.Uri__makePath(path, 0, t1, pathSegments, host != null, isFile), scheme, userInfo, query, fragment, null, null);
      }, Uri_base: function() {
        var uri = H.Primitives_currentUri();
        if (uri != null)
          return P.Uri_parse(uri);
        throw H.wrapException(P.UnsupportedError$("'Uri.base' is not supported"));
      }, Uri__makePort: function(port, scheme) {
        if (port != null && port === P.Uri__defaultPort(scheme))
          return;
        return port;
      }, Uri__makeHost: function(host, start, end, strictIPv6) {
        var t1, i;
        if (host == null)
          return;
        if (start === end)
          return "";
        if (C.JSString_methods.codeUnitAt$1(host, start) === 91) {
          t1 = end - 1;
          if (C.JSString_methods.codeUnitAt$1(host, t1) !== 93)
            P.Uri__fail(host, start, "Missing end `]` to match `[` in host");
          P.Uri_parseIPv6Address(host, start + 1, t1);
          return C.JSString_methods.substring$2(host, start, end).toLowerCase();
        }
        if (!strictIPv6)
          for (t1 = host.length, i = start; i < end; ++i) {
            if (i < 0)
              H.throwExpression(P.RangeError$value(i));
            if (i >= t1)
              H.throwExpression(P.RangeError$value(i));
            if (host.charCodeAt(i) === 58) {
              P.Uri_parseIPv6Address(host, start, end);
              return "[" + host + "]";
            }
          }
        return P.Uri__normalizeRegName(host, start, end);
      }, Uri__normalizeRegName: function(host, start, end) {
        var t1, index, sectionStart, buffer, isNormalized, $char, replacement, t2, slice, sourceLength, tail;
        for (t1 = host.length, index = start, sectionStart = index, buffer = null, isNormalized = true; index < end;) {
          if (index < 0)
            H.throwExpression(P.RangeError$value(index));
          if (index >= t1)
            H.throwExpression(P.RangeError$value(index));
          $char = host.charCodeAt(index);
          if ($char === 37) {
            replacement = P.Uri__normalizeEscape(host, index, true);
            t2 = replacement == null;
            if (t2 && isNormalized) {
              index += 3;
              continue;
            }
            if (buffer == null) {
              buffer = new P.StringBuffer("");
              buffer._contents = "";
            }
            slice = C.JSString_methods.substring$2(host, sectionStart, index);
            if (!isNormalized)
              slice = slice.toLowerCase();
            buffer._contents = buffer._contents + slice;
            if (t2) {
              replacement = C.JSString_methods.substring$2(host, index, index + 3);
              sourceLength = 3;
            } else if (replacement === "%") {
              replacement = "%25";
              sourceLength = 1;
            } else
              sourceLength = 3;
            buffer._contents += replacement;
            index += sourceLength;
            sectionStart = index;
            isNormalized = true;
          } else {
            if ($char < 127) {
              t2 = $char >>> 4;
              if (t2 >= 8)
                return H.ioore(C.List_qNA, t2);
              t2 = (C.List_qNA[t2] & C.JSInt_methods._shlPositive$1(1, $char & 15)) !== 0;
            } else
              t2 = false;
            if (t2) {
              if (isNormalized && 65 <= $char && 90 >= $char) {
                if (buffer == null) {
                  buffer = new P.StringBuffer("");
                  buffer._contents = "";
                }
                if (sectionStart < index) {
                  t2 = C.JSString_methods.substring$2(host, sectionStart, index);
                  buffer._contents = buffer._contents + t2;
                  sectionStart = index;
                }
                isNormalized = false;
              }
              ++index;
            } else {
              if ($char <= 93) {
                t2 = $char >>> 4;
                if (t2 >= 8)
                  return H.ioore(C.List_2Vk, t2);
                t2 = (C.List_2Vk[t2] & C.JSInt_methods._shlPositive$1(1, $char & 15)) !== 0;
              } else
                t2 = false;
              if (t2)
                P.Uri__fail(host, index, "Invalid character");
              else {
                if (($char & 64512) === 55296 && index + 1 < end) {
                  t2 = index + 1;
                  if (t2 < 0)
                    H.throwExpression(P.RangeError$value(t2));
                  if (t2 >= t1)
                    H.throwExpression(P.RangeError$value(t2));
                  tail = host.charCodeAt(t2);
                  if ((tail & 64512) === 56320) {
                    $char = (65536 | ($char & 1023) << 10 | tail & 1023) >>> 0;
                    sourceLength = 2;
                  } else
                    sourceLength = 1;
                } else
                  sourceLength = 1;
                if (buffer == null) {
                  buffer = new P.StringBuffer("");
                  buffer._contents = "";
                }
                slice = C.JSString_methods.substring$2(host, sectionStart, index);
                if (!isNormalized)
                  slice = slice.toLowerCase();
                buffer._contents = buffer._contents + slice;
                t2 = P.Uri__escapeChar($char);
                buffer._contents += t2;
                index += sourceLength;
                sectionStart = index;
              }
            }
          }
        }
        if (buffer == null)
          return C.JSString_methods.substring$2(host, start, end);
        if (sectionStart < end) {
          slice = C.JSString_methods.substring$2(host, sectionStart, end);
          buffer.write$1(!isNormalized ? slice.toLowerCase() : slice);
        }
        return buffer._contents;
      }, Uri__makeScheme: function(scheme, end) {
        var $char, allLowercase, t1, t2, t3, i, codeUnit, t4;
        if (end === 0)
          return "";
        $char = J.codeUnitAt$1$s(scheme, 0);
        allLowercase = $char >= 97;
        if (!(allLowercase && $char <= 122))
          t1 = $char >= 65 && $char <= 90;
        else
          t1 = true;
        if (!t1)
          P.Uri__fail(scheme, 0, "Scheme not starting with alphabetic character");
        for (t1 = 97 <= $char, t2 = scheme.length, t3 = 122 >= $char, i = 0; i < end; ++i) {
          if (i >= t2)
            H.throwExpression(P.RangeError$value(i));
          codeUnit = scheme.charCodeAt(i);
          if (codeUnit < 128) {
            t4 = codeUnit >>> 4;
            if (t4 >= 8)
              return H.ioore(C.List_JYB, t4);
            t4 = (C.List_JYB[t4] & C.JSInt_methods._shlPositive$1(1, codeUnit & 15)) !== 0;
          } else
            t4 = false;
          if (!t4)
            P.Uri__fail(scheme, i, "Illegal scheme character");
          if (t1 && t3)
            allLowercase = false;
        }
        scheme = C.JSString_methods.substring$2(scheme, 0, end);
        return !allLowercase ? scheme.toLowerCase() : scheme;
      }, Uri__makeUserInfo: function(userInfo, start, end) {
        return P.Uri__normalize(userInfo, start, end, C.List_gRj);
      }, Uri__makePath: function(path, start, end, pathSegments, ensureLeadingSlash, isFile) {
        var t1, result;
        t1 = path == null;
        if (t1 && true)
          return isFile ? "/" : "";
        t1 = !t1;
        if (t1)
          ;
        result = t1 ? P.Uri__normalize(path, start, end, C.List_qg4) : C.JSNull_methods.map$1(pathSegments, new P.Uri__makePath_closure()).join$1(0, "/");
        if (result.length === 0) {
          if (isFile)
            return "/";
        } else if ((isFile || ensureLeadingSlash) && C.JSString_methods.codeUnitAt$1(result, 0) !== 47)
          return "/" + result;
        return result;
      }, Uri__makeQuery: function(query, start, end, queryParameters) {
        var t1, t2, result;
        t1 = {};
        t2 = query == null;
        if (t2 && true)
          return;
        t2 = !t2;
        if (t2)
          ;
        if (t2)
          return P.Uri__normalize(query, start, end, C.List_CVk);
        result = P.StringBuffer$("");
        t1.first_0 = true;
        C.JSNull_methods.forEach$1(queryParameters, new P.Uri__makeQuery_closure(t1, result));
        return result._contents;
      }, Uri__makeFragment: function(fragment, start, end) {
        if (fragment == null)
          return;
        return P.Uri__normalize(fragment, start, end, C.List_CVk);
      }, Uri__isHexDigit: function($char) {
        if (57 >= $char)
          return 48 <= $char;
        $char |= 32;
        return 97 <= $char && 102 >= $char;
      }, Uri__hexValue: function($char) {
        if (57 >= $char)
          return $char - 48;
        return ($char | 32) - 87;
      }, Uri__normalizeEscape: function(source, index, lowerCase) {
        var t1, t2, t3, firstDigit, secondDigit, value;
        t1 = index + 2;
        t2 = source.length;
        if (t1 >= t2)
          return "%";
        t3 = index + 1;
        if (t3 < 0)
          H.throwExpression(P.RangeError$value(t3));
        if (t3 >= t2)
          H.throwExpression(P.RangeError$value(t3));
        firstDigit = source.charCodeAt(t3);
        if (t1 < 0)
          H.throwExpression(P.RangeError$value(t1));
        secondDigit = source.charCodeAt(t1);
        if (!P.Uri__isHexDigit(firstDigit) || !P.Uri__isHexDigit(secondDigit))
          return "%";
        value = P.Uri__hexValue(firstDigit) * 16 + P.Uri__hexValue(secondDigit);
        if (value < 127) {
          t1 = C.JSInt_methods._shrOtherPositive$1(value, 4);
          if (t1 >= 8)
            return H.ioore(C.List_nxB, t1);
          t1 = (C.List_nxB[t1] & C.JSInt_methods._shlPositive$1(1, value & 15)) !== 0;
        } else
          t1 = false;
        if (t1)
          return H.Primitives_stringFromCharCode(lowerCase && 65 <= value && 90 >= value ? (value | 32) >>> 0 : value);
        if (firstDigit >= 97 || secondDigit >= 97)
          return C.JSString_methods.substring$2(source, index, index + 3).toUpperCase();
        return;
      }, Uri__escapeChar: function($char) {
        var codeUnits, t1, flag, encodedBytes, index, $byte, t2, t3;
        if ($char < 128) {
          codeUnits = Array(3);
          codeUnits.fixed$length = init;
          codeUnits[0] = 37;
          t1 = $char >>> 4;
          if (t1 >= 16)
            H.throwExpression(P.RangeError$value(t1));
          codeUnits[1] = "0123456789ABCDEF".charCodeAt(t1);
          codeUnits[2] = "0123456789ABCDEF".charCodeAt($char & 15);
        } else {
          if ($char > 2047)
            if ($char > 65535) {
              flag = 240;
              encodedBytes = 4;
            } else {
              flag = 224;
              encodedBytes = 3;
            }
          else {
            flag = 192;
            encodedBytes = 2;
          }
          t1 = 3 * encodedBytes;
          codeUnits = Array(t1);
          codeUnits.fixed$length = init;
          for (index = 0; --encodedBytes, encodedBytes >= 0; flag = 128) {
            $byte = C.JSInt_methods._shrReceiverPositive$1($char, 6 * encodedBytes) & 63 | flag;
            if (index >= t1)
              return H.ioore(codeUnits, index);
            codeUnits[index] = 37;
            t2 = index + 1;
            t3 = $byte >>> 4;
            if (t3 >= 16)
              H.throwExpression(P.RangeError$value(t3));
            t3 = "0123456789ABCDEF".charCodeAt(t3);
            if (t2 >= t1)
              return H.ioore(codeUnits, t2);
            codeUnits[t2] = t3;
            t3 = index + 2;
            t2 = "0123456789ABCDEF".charCodeAt($byte & 15);
            if (t3 >= t1)
              return H.ioore(codeUnits, t3);
            codeUnits[t3] = t2;
            index += 3;
          }
        }
        return H.Primitives_stringFromCharCodes(codeUnits);
      }, Uri__normalize: function(component, start, end, charTable) {
        var t1, index, sectionStart, buffer, $char, t2, replacement, sourceLength, tail;
        for (t1 = component.length, index = start, sectionStart = index, buffer = null; index < end;) {
          $char = C.JSString_methods.codeUnitAt$1(component, index);
          if ($char < 127) {
            t2 = $char >>> 4;
            if (t2 >= 8)
              return H.ioore(charTable, t2);
            t2 = (charTable[t2] & C.JSInt_methods._shlPositive$1(1, $char & 15)) !== 0;
          } else
            t2 = false;
          if (t2)
            ++index;
          else {
            if ($char === 37) {
              replacement = P.Uri__normalizeEscape(component, index, false);
              if (replacement == null) {
                index += 3;
                continue;
              }
              if ("%" === replacement) {
                replacement = "%25";
                sourceLength = 1;
              } else
                sourceLength = 3;
            } else {
              if ($char <= 93) {
                t2 = $char >>> 4;
                if (t2 >= 8)
                  return H.ioore(C.List_2Vk, t2);
                t2 = (C.List_2Vk[t2] & C.JSInt_methods._shlPositive$1(1, $char & 15)) !== 0;
              } else
                t2 = false;
              if (t2) {
                P.Uri__fail(component, index, "Invalid character");
                replacement = null;
                sourceLength = null;
              } else {
                if (($char & 64512) === 55296) {
                  t2 = index + 1;
                  if (t2 < end) {
                    if (t2 < 0)
                      H.throwExpression(P.RangeError$value(t2));
                    if (t2 >= t1)
                      H.throwExpression(P.RangeError$value(t2));
                    tail = component.charCodeAt(t2);
                    if ((tail & 64512) === 56320) {
                      $char = (65536 | ($char & 1023) << 10 | tail & 1023) >>> 0;
                      sourceLength = 2;
                    } else
                      sourceLength = 1;
                  } else
                    sourceLength = 1;
                } else
                  sourceLength = 1;
                replacement = P.Uri__escapeChar($char);
              }
            }
            if (buffer == null) {
              buffer = new P.StringBuffer("");
              buffer._contents = "";
            }
            t2 = C.JSString_methods.substring$2(component, sectionStart, index);
            buffer._contents = buffer._contents + t2;
            buffer._contents += typeof replacement === "string" ? replacement : H.S(replacement);
            if (typeof sourceLength !== "number")
              return H.iae(sourceLength);
            index += sourceLength;
            sectionStart = index;
          }
        }
        if (buffer == null)
          return C.JSString_methods.substring$2(component, start, end);
        if (sectionStart < end)
          buffer.write$1(C.JSString_methods.substring$2(component, sectionStart, end));
        return buffer._contents;
      }, Uri_parseIPv4Address: function(host) {
        var t1, bytes;
        t1 = new P.Uri_parseIPv4Address_error();
        bytes = host.split(".");
        if (bytes.length !== 4)
          t1.call$1("IPv4 address should contain exactly 4 parts");
        return H.setRuntimeTypeInfo(new H.MappedListIterable(bytes, new P.Uri_parseIPv4Address_closure(t1)), [null, null]).toList$0(0);
      }, Uri_parseIPv6Address: function(host, start, end) {
        var error, parseHex, parts, partStart, last, i, wildcardSeen, t1, t2, atEnd, exception, bytes, index, value, wildCardLength, j;
        if (end == null)
          end = J.get$length$asx(host);
        error = new P.Uri_parseIPv6Address_error(host);
        parseHex = new P.Uri_parseIPv6Address_parseHex(host, error);
        if (J.get$length$asx(host) < 2)
          error.call$1("address is too short");
        parts = [];
        partStart = start;
        i = start;
        wildcardSeen = false;
        while (true) {
          t1 = end;
          if (typeof t1 !== "number")
            return H.iae(t1);
          if (!(i < t1))
            break;
          t1 = host;
          if (i < 0)
            H.throwExpression(P.RangeError$value(i));
          t2 = J.get$length$asx(t1);
          if (typeof t2 !== "number")
            return H.iae(t2);
          if (i >= t2)
            H.throwExpression(P.RangeError$value(i));
          if (t1.charCodeAt(i) === 58) {
            if (i === start) {
              ++i;
              t1 = host;
              if (i < 0)
                H.throwExpression(P.RangeError$value(i));
              if (i >= J.get$length$asx(t1))
                H.throwExpression(P.RangeError$value(i));
              if (t1.charCodeAt(i) !== 58)
                error.call$2("invalid start colon.", i);
              partStart = i;
            }
            if (i === partStart) {
              if (wildcardSeen)
                error.call$2("only one wildcard `::` is allowed", i);
              J.add$1$ax(parts, -1);
              wildcardSeen = true;
            } else
              J.add$1$ax(parts, parseHex.call$2(partStart, i));
            partStart = i + 1;
          }
          ++i;
        }
        if (J.get$length$asx(parts) === 0)
          error.call$1("too few parts");
        atEnd = J.$eq(partStart, end);
        t1 = J.get$last$ax(parts);
        if (atEnd && t1 !== -1)
          error.call$2("expected a part after last `:`", end);
        if (!atEnd)
          try {
            J.add$1$ax(parts, parseHex.call$2(partStart, end));
          } catch (exception) {
            H.unwrapException(exception);
            try {
              last = P.Uri_parseIPv4Address(J.substring$2$s(host, partStart, end));
              t1 = J.$index$asx(last, 0);
              if (typeof t1 !== "number")
                return t1.$shl();
              t2 = J.$index$asx(last, 1);
              if (typeof t2 !== "number")
                return H.iae(t2);
              J.add$1$ax(parts, (t1 << 8 | t2) >>> 0);
              t2 = J.$index$asx(last, 2);
              if (typeof t2 !== "number")
                return t2.$shl();
              t1 = J.$index$asx(last, 3);
              if (typeof t1 !== "number")
                return H.iae(t1);
              J.add$1$ax(parts, (t2 << 8 | t1) >>> 0);
            } catch (exception) {
              H.unwrapException(exception);
              error.call$2("invalid end of IPv6 address.", partStart);
            }

          }

        if (wildcardSeen) {
          if (J.get$length$asx(parts) > 7)
            error.call$1("an address with a wildcard must have less than 7 parts");
        } else if (J.get$length$asx(parts) !== 8)
          error.call$1("an address without a wildcard must contain exactly 8 parts");
        bytes = Array(16);
        bytes.$builtinTypeInfo = [P.$int];
        i = 0;
        index = 0;
        while (true) {
          t1 = J.get$length$asx(parts);
          if (typeof t1 !== "number")
            return H.iae(t1);
          if (!(i < t1))
            break;
          value = J.$index$asx(parts, i);
          if (value === -1) {
            wildCardLength = 9 - J.get$length$asx(parts);
            for (j = 0; j < wildCardLength; ++j) {
              if (index < 0 || index >= 16)
                return H.ioore(bytes, index);
              bytes[index] = 0;
              t1 = index + 1;
              if (t1 >= 16)
                return H.ioore(bytes, t1);
              bytes[t1] = 0;
              index += 2;
            }
          } else {
            t1 = J._shrOtherPositive$1$n(value, 8);
            if (index < 0 || index >= 16)
              return H.ioore(bytes, index);
            bytes[index] = t1;
            t1 = index + 1;
            if (t1 >= 16)
              return H.ioore(bytes, t1);
            bytes[t1] = value & 255;
            index += 2;
          }
          ++i;
        }
        return bytes;
      }, Uri__uriEncode: function(canonicalTable, text, encoding, spaceToPlus) {
        var t1, result, bytes, i, $byte, t2, t3;
        t1 = new P.Uri__uriEncode_byteToHex();
        result = P.StringBuffer$("");
        bytes = encoding.get$encoder().convert$1(text);
        for (i = 0; i < bytes.length; ++i) {
          $byte = bytes[i];
          t2 = J.getInterceptor$n($byte);
          if (t2.$lt($byte, 128)) {
            if (typeof $byte !== "number")
              return $byte.$shr();
            t3 = C.JSNumber_methods._shrOtherPositive$1($byte, 4);
            if (t3 >= 8)
              return H.ioore(canonicalTable, t3);
            t3 = (canonicalTable[t3] & C.JSInt_methods._shlPositive$1(1, $byte & 15)) !== 0;
          } else
            t3 = false;
          if (t3) {
            t2 = H.Primitives_stringFromCharCode($byte);
            result._contents += t2;
          } else if (spaceToPlus && t2.$eq($byte, 32)) {
            t2 = H.Primitives_stringFromCharCode(43);
            result._contents += t2;
          } else {
            t2 = H.Primitives_stringFromCharCode(37);
            result._contents += t2;
            t1.call$2($byte, result);
          }
        }
        return result._contents;
      }}
  },
  Uri_parse_isRegName: {
    "^": "Closure:65;",
    call$1: function(ch) {
      ch.$lt(0, 128);
      return false;
    },
    $isFunction: true
  },
  Uri_parse_parseAuth: {
    "^": "Closure:7;box_0,uri_1,EOI_2",
    call$0: function() {
      var t1, hostStart, t2, t3, $char, lastColon, lastAt, t4, char0, endBracket, hostEnd, i, portNumber, digit;
      t1 = this.box_0;
      hostStart = t1.index_4;
      t2 = this.uri_1;
      t3 = t2.length;
      if (hostStart === t3) {
        t1.char_5 = this.EOI_2;
        return;
      }
      t1.char_5 = J.codeUnitAt$1$s(t2, hostStart);
      for ($char = this.EOI_2, lastColon = -1, lastAt = -1; t4 = t1.index_4, t4 < t3;) {
        if (t4 < 0)
          H.throwExpression(P.RangeError$value(t4));
        if (t4 >= t3)
          H.throwExpression(P.RangeError$value(t4));
        char0 = t2.charCodeAt(t4);
        t1.char_5 = char0;
        if (char0 === 47 || char0 === 63 || char0 === 35)
          break;
        if (char0 === 64) {
          lastAt = t1.index_4;
          lastColon = -1;
        } else if (char0 === 58)
          lastColon = t1.index_4;
        else if (char0 === 91) {
          endBracket = C.JSString_methods.indexOf$2(t2, "]", t1.index_4 + 1);
          if (endBracket === -1) {
            t1.index_4 = t3;
            t1.char_5 = $char;
            lastColon = -1;
            break;
          } else
            t1.index_4 = endBracket;
          lastColon = -1;
        }
        ++t1.index_4;
        t1.char_5 = $char;
      }
      hostEnd = t1.index_4;
      if (lastAt >= 0) {
        t1.userinfo_1 = P.Uri__makeUserInfo(t2, hostStart, lastAt);
        hostStart = lastAt + 1;
      }
      if (lastColon >= 0) {
        i = lastColon + 1;
        if (i < t1.index_4)
          for (portNumber = 0; i < t1.index_4; ++i) {
            if (i >= t3)
              H.throwExpression(P.RangeError$value(i));
            digit = t2.charCodeAt(i);
            if (48 > digit || 57 < digit)
              P.Uri__fail(t2, i, "Invalid port number");
            portNumber = portNumber * 10 + (digit - 48);
          }
        else
          portNumber = null;
        t1.port_3 = P.Uri__makePort(portNumber, t1.scheme_0);
        hostEnd = lastColon;
      }
      t1.host_2 = P.Uri__makeHost(t2, hostStart, hostEnd, true);
      t4 = t1.index_4;
      if (t4 < t3)
        t1.char_5 = C.JSString_methods.codeUnitAt$1(t2, t4);
    },
    $isFunction: true
  },
  Uri__makePath_closure: {
    "^": "Closure:13;",
    call$1: function(s) {
      return P.Uri__uriEncode(C.List_qg40, s, C.Utf8Codec_false, false);
    },
    $isFunction: true
  },
  Uri__makeQuery_closure: {
    "^": "Closure:19;box_0,result_1",
    call$2: function(key, value) {
      var t1 = this.box_0;
      if (!t1.first_0)
        this.result_1.write$1("&");
      t1.first_0 = false;
      t1 = this.result_1;
      t1.write$1(P.Uri__uriEncode(C.List_nxB, key, C.Utf8Codec_false, true));
      value.get$isEmpty(value);
      t1.write$1("=");
      t1.write$1(P.Uri__uriEncode(C.List_nxB, value, C.Utf8Codec_false, true));
    },
    $isFunction: true
  },
  Uri_hashCode_combine: {
    "^": "Closure:35;",
    call$2: function(part, current) {
      return current * 31 + J.get$hashCode$(part) & 1073741823;
    },
    $isFunction: true
  },
  Uri_parseIPv4Address_error: {
    "^": "Closure:66;",
    call$1: function(msg) {
      throw H.wrapException(P.FormatException$("Illegal IPv4 address, " + msg, null, null));
    },
    $isFunction: true
  },
  Uri_parseIPv4Address_closure: {
    "^": "Closure:13;error_0",
    call$1: function(byteString) {
      var $byte = H.Primitives_parseInt(byteString, null, null);
      if (typeof $byte !== "number")
        return $byte.$lt();
      if ($byte < 0 || $byte > 255)
        this.error_0.call$1("each part must be in the range of `0..255`");
      return $byte;
    },
    $isFunction: true
  },
  Uri_parseIPv6Address_error: {
    "^": "Closure:67;host_0",
    call$2: function(msg, position) {
      throw H.wrapException(P.FormatException$("Illegal IPv6 address, " + msg, this.host_0, position));
    },
    call$1: function(msg) {
      return this.call$2(msg, null);
    },
    $isFunction: true
  },
  Uri_parseIPv6Address_parseHex: {
    "^": "Closure:68;host_1,error_2",
    call$2: function(start, end) {
      var value;
      if (end - start > 4)
        this.error_2.call$2("an IPv6 part can only contain a maximum of 4 hex digits", start);
      value = H.Primitives_parseInt(C.JSString_methods.substring$2(this.host_1, start, end), 16, null);
      if (typeof value !== "number")
        return value.$lt();
      if (value < 0 || value > 65535)
        this.error_2.call$2("each part must be in the range of `0x0..0xFFFF`", start);
      return value;
    },
    $isFunction: true
  },
  Uri__uriEncode_byteToHex: {
    "^": "Closure:19;",
    call$2: function($byte, buffer) {
      buffer.write$1(H.Primitives_stringFromCharCode(C.JSString_methods.codeUnitAt$1("0123456789ABCDEF", C.JSInt_methods._shrOtherPositive$1($byte, 4))));
      buffer.write$1(H.Primitives_stringFromCharCode(C.JSString_methods.codeUnitAt$1("0123456789ABCDEF", $byte & 15)));
    },
    $isFunction: true
  }
}],
["dart.dom.html", "dart:html", , W, {
  "^": "",
  Blob_Blob: function(blobParts, type, endings) {
    var bag = {};
    bag.type = type;
    return new Blob(blobParts, bag);
  },
  HttpRequest_getString: function(url, onProgress, withCredentials) {
    return W.HttpRequest_request(url, null, null, onProgress, null, null, null, withCredentials).then$1(new W.HttpRequest_getString_closure());
  },
  HttpRequest_request: function(url, method, mimeType, onProgress, requestHeaders, responseType, sendData, withCredentials) {
    var t1, completer, xhr;
    t1 = W.HttpRequest;
    completer = H.setRuntimeTypeInfo(new P._AsyncCompleter(P._Future$(t1)), [t1]);
    xhr = new XMLHttpRequest();
    C.HttpRequest_methods.open$3$async(xhr, "GET", url, true);
    t1 = H.setRuntimeTypeInfo(new W._EventStream(xhr, C.EventStreamProvider_load._eventType, false), [null]);
    H.setRuntimeTypeInfo(new W._EventStreamSubscription(0, t1._html$_target, t1._eventType, W._wrapZone(new W.HttpRequest_request_closure(completer, xhr)), t1._useCapture), [H.getTypeArgumentByIndex(t1, 0)])._tryResume$0();
    t1 = H.setRuntimeTypeInfo(new W._EventStream(xhr, C.EventStreamProvider_error._eventType, false), [null]);
    H.setRuntimeTypeInfo(new W._EventStreamSubscription(0, t1._html$_target, t1._eventType, W._wrapZone(completer.get$completeError()), t1._useCapture), [H.getTypeArgumentByIndex(t1, 0)])._tryResume$0();
    xhr.send();
    return completer.future;
  },
  _JenkinsSmiHash_combine: function(hash, value) {
    hash = 536870911 & hash + value;
    hash = 536870911 & hash + ((524287 & hash) << 10 >>> 0);
    return hash ^ hash >>> 6;
  },
  _convertNativeToDart_Window: function(win) {
    if (win == null)
      return;
    return W._DOMWindowCrossFrame__createSafe(win);
  },
  _convertNativeToDart_EventTarget: function(e) {
    var $window;
    if (e == null)
      return;
    if ("postMessage" in e) {
      $window = W._DOMWindowCrossFrame__createSafe(e);
      if (!!J.getInterceptor($window).$isEventTarget)
        return $window;
      return;
    } else
      return e;
  },
  _wrapZone: function(callback) {
    var t1 = $.Zone__current;
    if (t1 === C.C__RootZone)
      return callback;
    return t1.bindUnaryCallback$2$runGuarded(callback, true);
  },
  HtmlElement: {
    "^": "Element0;",
    "%": "HTMLAppletElement|HTMLBRElement|HTMLCanvasElement|HTMLContentElement|HTMLDListElement|HTMLDataListElement|HTMLDetailsElement|HTMLDialogElement|HTMLDirectoryElement|HTMLDivElement|HTMLFontElement|HTMLFrameElement|HTMLHRElement|HTMLHeadElement|HTMLHeadingElement|HTMLHtmlElement|HTMLLabelElement|HTMLLegendElement|HTMLMarqueeElement|HTMLMenuElement|HTMLModElement|HTMLOptGroupElement|HTMLParagraphElement|HTMLPreElement|HTMLQuoteElement|HTMLShadowElement|HTMLSpanElement|HTMLTableCaptionElement|HTMLTableCellElement|HTMLTableColElement|HTMLTableDataCellElement|HTMLTableElement|HTMLTableHeaderCellElement|HTMLTableRowElement|HTMLTableSectionElement|HTMLTemplateElement|HTMLTitleElement|HTMLUListElement|HTMLUnknownElement;HTMLElement"
  },
  _EntryArray: {
    "^": "Interceptor;",
    $isList: true,
    $asList: function() {
      return [W.Entry];
    },
    $isEfficientLength: true,
    $isIterable: true,
    $asIterable: function() {
      return [W.Entry];
    },
    "%": "EntryArray"
  },
  AnchorElement: {
    "^": "HtmlElement;target=,type=",
    toString$0: function(receiver) {
      return receiver.toString();
    },
    "%": "HTMLAnchorElement"
  },
  AreaElement: {
    "^": "HtmlElement;target=",
    toString$0: function(receiver) {
      return receiver.toString();
    },
    "%": "HTMLAreaElement"
  },
  AutocompleteErrorEvent: {
    "^": "Event;reason=",
    "%": "AutocompleteErrorEvent"
  },
  BaseElement: {
    "^": "HtmlElement;target=",
    "%": "HTMLBaseElement"
  },
  Blob: {
    "^": "Interceptor;type=",
    "%": ";Blob"
  },
  BodyElement: {
    "^": "HtmlElement;",
    $isEventTarget: true,
    "%": "HTMLBodyElement"
  },
  ButtonElement: {
    "^": "HtmlElement;name=,type=,value=",
    "%": "HTMLButtonElement"
  },
  CharacterData: {
    "^": "Node1;length=",
    "%": "CDATASection|Comment|Text;CharacterData"
  },
  CloseEvent: {
    "^": "Event;reason=",
    "%": "CloseEvent"
  },
  Document: {
    "^": "Node1;implementation=",
    "%": "XMLDocument;Document"
  },
  DomError: {
    "^": "Interceptor;name=",
    "%": "DOMError|FileError"
  },
  DomException: {
    "^": "Interceptor;",
    get$name: function(receiver) {
      var errorName = receiver.name;
      if (P.Device_isWebKit() === true && errorName === "SECURITY_ERR")
        return "SecurityError";
      if (P.Device_isWebKit() === true && errorName === "SYNTAX_ERR")
        return "SyntaxError";
      return errorName;
    },
    toString$0: function(receiver) {
      return receiver.toString();
    },
    "%": "DOMException"
  },
  Element0: {
    "^": "Node1;id=",
    toString$0: function(receiver) {
      return receiver.localName;
    },
    $isEventTarget: true,
    "%": ";Element"
  },
  EmbedElement: {
    "^": "HtmlElement;name=,type=",
    "%": "HTMLEmbedElement"
  },
  ErrorEvent: {
    "^": "Event;error=",
    "%": "ErrorEvent"
  },
  Event: {
    "^": "Interceptor;_get_target:target=,type=",
    get$target: function(receiver) {
      return W._convertNativeToDart_EventTarget(receiver.target);
    },
    $isEvent: true,
    "%": "AudioProcessingEvent|BeforeLoadEvent|BeforeUnloadEvent|CSSFontFaceLoadEvent|CompositionEvent|CustomEvent|DeviceMotionEvent|DeviceOrientationEvent|DragEvent|FocusEvent|HashChangeEvent|IDBVersionChangeEvent|InstallEvent|InstallPhaseEvent|KeyboardEvent|MIDIConnectionEvent|MIDIMessageEvent|MSPointerEvent|MediaKeyEvent|MediaKeyMessageEvent|MediaKeyNeededEvent|MediaStreamEvent|MediaStreamTrackEvent|MouseEvent|MouseScrollEvent|MouseWheelEvent|MutationEvent|OfflineAudioCompletionEvent|OverflowEvent|PageTransitionEvent|PointerEvent|PopStateEvent|RTCDTMFToneChangeEvent|RTCDataChannelEvent|RTCIceCandidateEvent|SVGZoomEvent|SecurityPolicyViolationEvent|SpeechInputEvent|SpeechRecognitionEvent|TextEvent|TouchEvent|TrackEvent|TransitionEvent|UIEvent|WebGLContextEvent|WebKitAnimationEvent|WebKitTransitionEvent|WheelEvent;ClipboardEvent|Event|InputEvent"
  },
  EventTarget: {
    "^": "Interceptor;",
    addEventListener$3: function(receiver, type, listener, useCapture) {
      return receiver.addEventListener(type, H.convertDartClosureToJS(listener, 1), useCapture);
    },
    removeEventListener$3: function(receiver, type, listener, useCapture) {
      return receiver.removeEventListener(type, H.convertDartClosureToJS(listener, 1), useCapture);
    },
    $isEventTarget: true,
    "%": ";EventTarget"
  },
  FieldSetElement: {
    "^": "HtmlElement;elements=,name=,type=",
    "%": "HTMLFieldSetElement"
  },
  File: {
    "^": "Blob;name=",
    "%": "File"
  },
  FormElement: {
    "^": "HtmlElement;action=,length=,name=,target=",
    "%": "HTMLFormElement"
  },
  HtmlCollection: {
    "^": "Interceptor_ListMixin_ImmutableListMixin;",
    get$length: function(receiver) {
      return receiver.length;
    },
    $index: function(receiver, index) {
      var t1 = receiver.length;
      if (index >>> 0 !== index || index >= t1)
        throw H.wrapException(P.RangeError$range(index, 0, t1));
      return receiver[index];
    },
    $indexSet: function(receiver, index, value) {
      throw H.wrapException(P.UnsupportedError$("Cannot assign element of immutable List."));
    },
    set$length: function(receiver, value) {
      throw H.wrapException(P.UnsupportedError$("Cannot resize immutable List."));
    },
    get$first: function(receiver) {
      if (receiver.length > 0)
        return receiver[0];
      throw H.wrapException(P.StateError$("No elements"));
    },
    get$last: function(receiver) {
      var len = receiver.length;
      if (len > 0)
        return receiver[len - 1];
      throw H.wrapException(P.StateError$("No elements"));
    },
    get$single: function(receiver) {
      var len = receiver.length;
      if (len === 1)
        return receiver[0];
      if (len === 0)
        throw H.wrapException(P.StateError$("No elements"));
      throw H.wrapException(P.StateError$("More than one element"));
    },
    elementAt$1: function(receiver, index) {
      if (index < 0 || index >= receiver.length)
        return H.ioore(receiver, index);
      return receiver[index];
    },
    $isList: true,
    $asList: function() {
      return [W.Node1];
    },
    $isEfficientLength: true,
    $isIterable: true,
    $asIterable: function() {
      return [W.Node1];
    },
    $isJavaScriptIndexingBehavior: true,
    "%": "HTMLCollection|HTMLFormControlsCollection|HTMLOptionsCollection"
  },
  HtmlDocument: {
    "^": "Document;body%",
    get$head: function(receiver) {
      return receiver.head;
    },
    "%": "HTMLDocument"
  },
  HttpRequest: {
    "^": "HttpRequestEventTarget;responseText=",
    open$5$async$password$user: function(receiver, method, url, async, password, user) {
      return receiver.open(method, url, async, user, password);
    },
    open$3$async: function($receiver, method, url, async) {
      return $receiver.open(method, url, async);
    },
    send$1: function(receiver, data) {
      return receiver.send(data);
    },
    $isHttpRequest: true,
    "%": "XMLHttpRequest"
  },
  HttpRequestEventTarget: {
    "^": "EventTarget;",
    "%": ";XMLHttpRequestEventTarget"
  },
  IFrameElement: {
    "^": "HtmlElement;name=",
    "%": "HTMLIFrameElement"
  },
  ImageElement: {
    "^": "HtmlElement;isMap=",
    "%": "HTMLImageElement"
  },
  InputElement: {
    "^": "HtmlElement;defaultValue=,name=,type=,value=",
    accept$1: function($receiver, arg0) {
      return $receiver.accept.call$1(arg0);
    },
    accept$2: function($receiver, arg0, arg1) {
      return $receiver.accept.call$2(arg0, arg1);
    },
    $isEventTarget: true,
    $isNode1: true,
    "%": "HTMLInputElement"
  },
  KeygenElement: {
    "^": "HtmlElement;name=,type=",
    "%": "HTMLKeygenElement"
  },
  LIElement: {
    "^": "HtmlElement;value=",
    "%": "HTMLLIElement"
  },
  LinkElement: {
    "^": "HtmlElement;type=",
    "%": "HTMLLinkElement"
  },
  MapElement: {
    "^": "HtmlElement;name=",
    "%": "HTMLMapElement"
  },
  MediaElement: {
    "^": "HtmlElement;error=",
    "%": "HTMLAudioElement|HTMLMediaElement|HTMLVideoElement"
  },
  MediaStream: {
    "^": "EventTarget;id=",
    "%": "MediaStream"
  },
  MessageEvent: {
    "^": "Event;",
    get$source: function(receiver) {
      return W._convertNativeToDart_EventTarget(receiver.source);
    },
    "%": "MessageEvent"
  },
  MetaElement: {
    "^": "HtmlElement;name=",
    "%": "HTMLMetaElement"
  },
  MeterElement: {
    "^": "HtmlElement;value=",
    "%": "HTMLMeterElement"
  },
  MidiOutput: {
    "^": "MidiPort;",
    send$2: function(receiver, data, timestamp) {
      return receiver.send(data, timestamp);
    },
    send$1: function($receiver, data) {
      return $receiver.send(data);
    },
    "%": "MIDIOutput"
  },
  MidiPort: {
    "^": "EventTarget;id=,name=,type=",
    "%": "MIDIInput;MIDIPort"
  },
  NavigatorUserMediaError: {
    "^": "Interceptor;name=",
    "%": "NavigatorUserMediaError"
  },
  Node1: {
    "^": "EventTarget;parent:parentElement=,text:textContent=",
    get$nodes: function(receiver) {
      return new W._ChildNodeListLazy(receiver);
    },
    _clearChildren$0: function(receiver) {
      var t1;
      for (; t1 = receiver.firstChild, t1 != null;)
        receiver.removeChild(t1);
    },
    toString$0: function(receiver) {
      var t1 = receiver.nodeValue;
      return t1 == null ? J.Interceptor.prototype.toString$0.call(this, receiver) : t1;
    },
    contains$1: function(receiver, other) {
      return receiver.contains(other);
    },
    $isNode1: true,
    "%": "DocumentFragment|DocumentType|Notation|ShadowRoot;Node"
  },
  NodeList0: {
    "^": "Interceptor_ListMixin_ImmutableListMixin0;",
    get$length: function(receiver) {
      return receiver.length;
    },
    $index: function(receiver, index) {
      var t1 = receiver.length;
      if (index >>> 0 !== index || index >= t1)
        throw H.wrapException(P.RangeError$range(index, 0, t1));
      return receiver[index];
    },
    $indexSet: function(receiver, index, value) {
      throw H.wrapException(P.UnsupportedError$("Cannot assign element of immutable List."));
    },
    set$length: function(receiver, value) {
      throw H.wrapException(P.UnsupportedError$("Cannot resize immutable List."));
    },
    get$first: function(receiver) {
      if (receiver.length > 0)
        return receiver[0];
      throw H.wrapException(P.StateError$("No elements"));
    },
    get$last: function(receiver) {
      var len = receiver.length;
      if (len > 0)
        return receiver[len - 1];
      throw H.wrapException(P.StateError$("No elements"));
    },
    get$single: function(receiver) {
      var len = receiver.length;
      if (len === 1)
        return receiver[0];
      if (len === 0)
        throw H.wrapException(P.StateError$("No elements"));
      throw H.wrapException(P.StateError$("More than one element"));
    },
    elementAt$1: function(receiver, index) {
      if (index < 0 || index >= receiver.length)
        return H.ioore(receiver, index);
      return receiver[index];
    },
    $isList: true,
    $asList: function() {
      return [W.Node1];
    },
    $isEfficientLength: true,
    $isIterable: true,
    $asIterable: function() {
      return [W.Node1];
    },
    $isJavaScriptIndexingBehavior: true,
    "%": "NodeList|RadioNodeList"
  },
  OListElement: {
    "^": "HtmlElement;start%,type=",
    "%": "HTMLOListElement"
  },
  ObjectElement: {
    "^": "HtmlElement;name=,type=",
    "%": "HTMLObjectElement"
  },
  OptionElement: {
    "^": "HtmlElement;index=,value=",
    "%": "HTMLOptionElement"
  },
  OutputElement: {
    "^": "HtmlElement;defaultValue=,name=,type=,value=",
    "%": "HTMLOutputElement"
  },
  ParamElement: {
    "^": "HtmlElement;name=,value=",
    "%": "HTMLParamElement"
  },
  ProcessingInstruction: {
    "^": "CharacterData;target=",
    "%": "ProcessingInstruction"
  },
  ProgressElement: {
    "^": "HtmlElement;position=,value=",
    "%": "HTMLProgressElement"
  },
  ProgressEvent: {
    "^": "Event;",
    "%": "ProgressEvent|ResourceProgressEvent|XMLHttpRequestProgressEvent"
  },
  ScriptElement: {
    "^": "HtmlElement;type=",
    "%": "HTMLScriptElement"
  },
  SelectElement: {
    "^": "HtmlElement;length%,name=,type=,value=",
    "%": "HTMLSelectElement"
  },
  SourceElement: {
    "^": "HtmlElement;type=",
    "%": "HTMLSourceElement"
  },
  SpeechRecognitionError: {
    "^": "Event;error=",
    "%": "SpeechRecognitionError"
  },
  SpeechSynthesisEvent: {
    "^": "Event;name=",
    "%": "SpeechSynthesisEvent"
  },
  StorageEvent: {
    "^": "Event;key=",
    "%": "StorageEvent"
  },
  StyleElement: {
    "^": "HtmlElement;type=",
    "%": "HTMLStyleElement"
  },
  TextAreaElement: {
    "^": "HtmlElement;defaultValue=,name=,type=,value=",
    "%": "HTMLTextAreaElement"
  },
  TrackElement: {
    "^": "HtmlElement;defaultValue:default=,kind=",
    "%": "HTMLTrackElement"
  },
  Window: {
    "^": "EventTarget;name=",
    get$parent: function(receiver) {
      return W._convertNativeToDart_Window(receiver.parent);
    },
    close$0: function(receiver) {
      return receiver.close();
    },
    toString$0: function(receiver) {
      return receiver.toString();
    },
    $isEventTarget: true,
    "%": "DOMWindow|Window"
  },
  _Attr: {
    "^": "Node1;name=,value=",
    "%": "Attr"
  },
  _ClientRect: {
    "^": "Interceptor;bottom=,height=,left=,right=,top=,width=",
    toString$0: function(receiver) {
      return "Rectangle (" + H.S(receiver.left) + ", " + H.S(receiver.top) + ") " + H.S(receiver.width) + " x " + H.S(receiver.height);
    },
    $eq: function(receiver, other) {
      var t1, t2, t3;
      if (other == null)
        return false;
      t1 = J.getInterceptor(other);
      if (!t1.$isRectangle)
        return false;
      t2 = receiver.left;
      t3 = t1.get$left(other);
      if (t2 == null ? t3 == null : t2 === t3) {
        t2 = receiver.top;
        t3 = t1.get$top(other);
        if (t2 == null ? t3 == null : t2 === t3) {
          t2 = receiver.width;
          t3 = t1.get$width(other);
          if (t2 == null ? t3 == null : t2 === t3) {
            t2 = receiver.height;
            t1 = t1.get$height(other);
            t1 = t2 == null ? t1 == null : t2 === t1;
          } else
            t1 = false;
        } else
          t1 = false;
      } else
        t1 = false;
      return t1;
    },
    get$hashCode: function(receiver) {
      var t1, t2, t3, t4, hash;
      t1 = J.get$hashCode$(receiver.left);
      t2 = J.get$hashCode$(receiver.top);
      t3 = J.get$hashCode$(receiver.width);
      t4 = J.get$hashCode$(receiver.height);
      t4 = W._JenkinsSmiHash_combine(W._JenkinsSmiHash_combine(W._JenkinsSmiHash_combine(W._JenkinsSmiHash_combine(0, t1), t2), t3), t4);
      hash = 536870911 & t4 + ((67108863 & t4) << 3 >>> 0);
      hash ^= hash >>> 11;
      return 536870911 & hash + ((16383 & hash) << 15 >>> 0);
    },
    intersection$1: function(receiver, other) {
      var x0, t1, t2, x1, y0, y1;
      x0 = P.max(receiver.left, other.get$left(other));
      t1 = receiver.left;
      t2 = receiver.width;
      if (typeof t1 !== "number")
        return t1.$add();
      if (typeof t2 !== "number")
        return H.iae(t2);
      x1 = P.min(t1 + t2, other.get$left(other).$add(0, other.get$width(other)));
      if (x0 <= x1) {
        y0 = P.max(receiver.top, other.get$top(other));
        t1 = receiver.top;
        t2 = receiver.height;
        if (typeof t1 !== "number")
          return t1.$add();
        if (typeof t2 !== "number")
          return H.iae(t2);
        y1 = P.min(t1 + t2, other.get$top(other).$add(0, other.get$height(other)));
        if (y0 <= y1)
          return P.Rectangle$(x0, y0, x1 - x0, y1 - y0, null);
      }
      return;
    },
    $isRectangle: true,
    $asRectangle: function() {
      return [null];
    },
    "%": "ClientRect|DOMRect"
  },
  _HTMLFrameSetElement: {
    "^": "HtmlElement;",
    $isEventTarget: true,
    "%": "HTMLFrameSetElement"
  },
  _NamedNodeMap: {
    "^": "Interceptor_ListMixin_ImmutableListMixin1;",
    get$length: function(receiver) {
      return receiver.length;
    },
    $index: function(receiver, index) {
      var t1 = receiver.length;
      if (index >>> 0 !== index || index >= t1)
        throw H.wrapException(P.RangeError$range(index, 0, t1));
      return receiver[index];
    },
    $indexSet: function(receiver, index, value) {
      throw H.wrapException(P.UnsupportedError$("Cannot assign element of immutable List."));
    },
    set$length: function(receiver, value) {
      throw H.wrapException(P.UnsupportedError$("Cannot resize immutable List."));
    },
    get$first: function(receiver) {
      if (receiver.length > 0)
        return receiver[0];
      throw H.wrapException(P.StateError$("No elements"));
    },
    get$last: function(receiver) {
      var len = receiver.length;
      if (len > 0)
        return receiver[len - 1];
      throw H.wrapException(P.StateError$("No elements"));
    },
    get$single: function(receiver) {
      var len = receiver.length;
      if (len === 1)
        return receiver[0];
      if (len === 0)
        throw H.wrapException(P.StateError$("No elements"));
      throw H.wrapException(P.StateError$("More than one element"));
    },
    elementAt$1: function(receiver, index) {
      if (index < 0 || index >= receiver.length)
        return H.ioore(receiver, index);
      return receiver[index];
    },
    $isList: true,
    $asList: function() {
      return [W.Node1];
    },
    $isEfficientLength: true,
    $isIterable: true,
    $asIterable: function() {
      return [W.Node1];
    },
    $isJavaScriptIndexingBehavior: true,
    "%": "MozNamedAttrMap|NamedNodeMap"
  },
  Entry: {
    "^": "Interceptor;"
  },
  Interceptor_ListMixin: {
    "^": "Interceptor+ListMixin;",
    $isList: true,
    $asList: function() {
      return [W.Node1];
    },
    $isEfficientLength: true,
    $isIterable: true,
    $asIterable: function() {
      return [W.Node1];
    }
  },
  Interceptor_ListMixin_ImmutableListMixin: {
    "^": "Interceptor_ListMixin+ImmutableListMixin;",
    $isList: true,
    $asList: function() {
      return [W.Node1];
    },
    $isEfficientLength: true,
    $isIterable: true,
    $asIterable: function() {
      return [W.Node1];
    }
  },
  HttpRequest_getString_closure: {
    "^": "Closure:13;",
    call$1: function(xhr) {
      return J.get$responseText$x(xhr);
    },
    $isFunction: true
  },
  HttpRequest_request_closure0: {
    "^": "Closure:19;xhr_0",
    call$2: function(header, value) {
      this.xhr_0.setRequestHeader(header, value);
    },
    $isFunction: true
  },
  HttpRequest_request_closure: {
    "^": "Closure:13;completer_1,xhr_2",
    call$1: function(e) {
      var t1, t2, t3;
      t1 = this.xhr_2;
      t2 = t1.status;
      if (typeof t2 !== "number")
        return t2.$ge();
      t2 = t2 >= 200 && t2 < 300 || t2 === 0 || t2 === 304;
      t3 = this.completer_1;
      if (t2) {
        t2 = t3.future;
        if (t2._state !== 0)
          H.throwExpression(P.StateError$("Future already completed"));
        t2._asyncComplete$1(t1);
      } else
        t3.completeError$1(e);
    },
    $isFunction: true
  },
  _ChildNodeListLazy: {
    "^": "ListBase;_this",
    get$first: function(_) {
      var result = this._this.firstChild;
      if (result == null)
        throw H.wrapException(P.StateError$("No elements"));
      return result;
    },
    get$last: function(_) {
      var result = this._this.lastChild;
      if (result == null)
        throw H.wrapException(P.StateError$("No elements"));
      return result;
    },
    get$single: function(_) {
      var t1, l;
      t1 = this._this;
      l = t1.childNodes.length;
      if (l === 0)
        throw H.wrapException(P.StateError$("No elements"));
      if (l > 1)
        throw H.wrapException(P.StateError$("More than one element"));
      return t1.firstChild;
    },
    add$1: function(_, value) {
      this._this.appendChild(value);
    },
    addAll$1: function(_, iterable) {
      var t1, t2, len, i;
      t1 = J.getInterceptor(iterable);
      if (!!t1.$is_ChildNodeListLazy) {
        t1 = iterable._this;
        t2 = this._this;
        if (t1 !== t2)
          for (len = t1.childNodes.length, i = 0; i < len; ++i)
            t2.appendChild(t1.firstChild);
        return;
      }
      for (t1 = t1.get$iterator(iterable), t2 = this._this; t1.moveNext$0();)
        t2.appendChild(t1.get$current());
    },
    removeLast$0: function(_) {
      var result = this.get$last(this);
      this._this.removeChild(result);
      return result;
    },
    remove$1: function(_, object) {
      var t1;
      if (!J.getInterceptor(object).$isNode1)
        return false;
      t1 = this._this;
      if (t1 !== object.parentNode)
        return false;
      t1.removeChild(object);
      return true;
    },
    _filter$2: function(test, removeMatching) {
      var t1, child, nextChild;
      t1 = this._this;
      child = t1.firstChild;
      for (; child != null; child = nextChild) {
        nextChild = child.nextSibling;
        if (J.$eq(test.call$1(child), removeMatching))
          t1.removeChild(child);
      }
    },
    removeWhere$1: function(_, test) {
      this._filter$2(test, true);
    },
    clear$0: function(_) {
      J._clearChildren$0$x(this._this);
    },
    $indexSet: function(_, index, value) {
      var t1, t2;
      t1 = this._this;
      t2 = t1.childNodes;
      if (index >>> 0 !== index || index >= t2.length)
        return H.ioore(t2, index);
      t1.replaceChild(value, t2[index]);
    },
    get$iterator: function(_) {
      return C.NodeList_methods.get$iterator(this._this.childNodes);
    },
    setRange$4: function(_, start, end, iterable, skipCount) {
      throw H.wrapException(P.UnsupportedError$("Cannot setRange on Node list"));
    },
    setRange$3: function($receiver, start, end, iterable) {
      return this.setRange$4($receiver, start, end, iterable, 0);
    },
    get$length: function(_) {
      return this._this.childNodes.length;
    },
    set$length: function(_, value) {
      throw H.wrapException(P.UnsupportedError$("Cannot set length on immutable List."));
    },
    $index: function(_, index) {
      var t1 = this._this.childNodes;
      if (index >>> 0 !== index || index >= t1.length)
        return H.ioore(t1, index);
      return t1[index];
    },
    $is_ChildNodeListLazy: true,
    $asListBase: function() {
      return [W.Node1];
    },
    $asObject_ListMixin: function() {
      return [W.Node1];
    },
    $asList: function() {
      return [W.Node1];
    },
    $asIterable: function() {
      return [W.Node1];
    }
  },
  Interceptor_ListMixin0: {
    "^": "Interceptor+ListMixin;",
    $isList: true,
    $asList: function() {
      return [W.Node1];
    },
    $isEfficientLength: true,
    $isIterable: true,
    $asIterable: function() {
      return [W.Node1];
    }
  },
  Interceptor_ListMixin_ImmutableListMixin0: {
    "^": "Interceptor_ListMixin0+ImmutableListMixin;",
    $isList: true,
    $asList: function() {
      return [W.Node1];
    },
    $isEfficientLength: true,
    $isIterable: true,
    $asIterable: function() {
      return [W.Node1];
    }
  },
  Interceptor_ListMixin1: {
    "^": "Interceptor+ListMixin;",
    $isList: true,
    $asList: function() {
      return [W.Node1];
    },
    $isEfficientLength: true,
    $isIterable: true,
    $asIterable: function() {
      return [W.Node1];
    }
  },
  Interceptor_ListMixin_ImmutableListMixin1: {
    "^": "Interceptor_ListMixin1+ImmutableListMixin;",
    $isList: true,
    $asList: function() {
      return [W.Node1];
    },
    $isEfficientLength: true,
    $isIterable: true,
    $asIterable: function() {
      return [W.Node1];
    }
  },
  EventStreamProvider: {
    "^": "Object;_eventType"
  },
  _EventStream: {
    "^": "Stream;_html$_target,_eventType,_useCapture",
    listen$4$cancelOnError$onDone$onError: function(onData, cancelOnError, onDone, onError) {
      var t1 = new W._EventStreamSubscription(0, this._html$_target, this._eventType, W._wrapZone(onData), this._useCapture);
      t1.$builtinTypeInfo = this.$builtinTypeInfo;
      t1._tryResume$0();
      return t1;
    },
    listen$3$onDone$onError: function(onData, onDone, onError) {
      return this.listen$4$cancelOnError$onDone$onError(onData, null, onDone, onError);
    }
  },
  _EventStreamSubscription: {
    "^": "StreamSubscription;_pauseCount,_html$_target,_eventType,_html$_onData,_useCapture",
    cancel$0: function() {
      if (this._html$_target == null)
        return;
      this._unlisten$0();
      this._html$_target = null;
      this._html$_onData = null;
      return;
    },
    pause$1: function(_, resumeSignal) {
      if (this._html$_target == null)
        return;
      ++this._pauseCount;
      this._unlisten$0();
    },
    pause$0: function($receiver) {
      return this.pause$1($receiver, null);
    },
    resume$0: function() {
      if (this._html$_target == null || this._pauseCount <= 0)
        return;
      --this._pauseCount;
      this._tryResume$0();
    },
    _tryResume$0: function() {
      var t1 = this._html$_onData;
      if (t1 != null && this._pauseCount <= 0)
        J.addEventListener$3$x(this._html$_target, this._eventType, t1, this._useCapture);
    },
    _unlisten$0: function() {
      var t1 = this._html$_onData;
      if (t1 != null)
        J.removeEventListener$3$x(this._html$_target, this._eventType, t1, this._useCapture);
    }
  },
  ImmutableListMixin: {
    "^": "Object;",
    get$iterator: function(receiver) {
      return H.setRuntimeTypeInfo(new W.FixedSizeListIterator(receiver, this.get$length(receiver), -1, null), [H.getRuntimeTypeArgument(receiver, "ImmutableListMixin", 0)]);
    },
    add$1: function(receiver, value) {
      throw H.wrapException(P.UnsupportedError$("Cannot add to immutable List."));
    },
    addAll$1: function(receiver, iterable) {
      throw H.wrapException(P.UnsupportedError$("Cannot add to immutable List."));
    },
    removeLast$0: function(receiver) {
      throw H.wrapException(P.UnsupportedError$("Cannot remove from immutable List."));
    },
    remove$1: function(receiver, object) {
      throw H.wrapException(P.UnsupportedError$("Cannot remove from immutable List."));
    },
    removeWhere$1: function(receiver, test) {
      throw H.wrapException(P.UnsupportedError$("Cannot remove from immutable List."));
    },
    setRange$4: function(receiver, start, end, iterable, skipCount) {
      throw H.wrapException(P.UnsupportedError$("Cannot setRange on immutable List."));
    },
    setRange$3: function($receiver, start, end, iterable) {
      return this.setRange$4($receiver, start, end, iterable, 0);
    },
    $isList: true,
    $asList: null,
    $isEfficientLength: true,
    $isIterable: true,
    $asIterable: null
  },
  FixedSizeListIterator: {
    "^": "Object;_array,_length,_position,_current",
    moveNext$0: function() {
      var nextPosition, t1;
      nextPosition = this._position + 1;
      t1 = this._length;
      if (nextPosition < t1) {
        this._current = J.$index$asx(this._array, nextPosition);
        this._position = nextPosition;
        return true;
      }
      this._current = null;
      this._position = t1;
      return false;
    },
    get$current: function() {
      return this._current;
    }
  },
  _DOMWindowCrossFrame: {
    "^": "Object;_window",
    get$parent: function(_) {
      return W._DOMWindowCrossFrame__createSafe(this._window.parent);
    },
    close$0: function(_) {
      return this._window.close();
    },
    addEventListener$3: function(_, type, listener, useCapture) {
      return H.throwExpression(P.UnsupportedError$("You can only attach EventListeners to your own window."));
    },
    removeEventListener$3: function(_, type, listener, useCapture) {
      return H.throwExpression(P.UnsupportedError$("You can only attach EventListeners to your own window."));
    },
    $isEventTarget: true,
    static: {_DOMWindowCrossFrame__createSafe: function(w) {
        if (w === window)
          return w;
        else
          return new W._DOMWindowCrossFrame(w);
      }}
  }
}],
["dart.dom.svg", "dart:svg", , P, {
  "^": "",
  AElement: {
    "^": "GraphicsElement;target=",
    "%": "SVGAElement"
  },
  FEColorMatrixElement: {
    "^": "SvgElement;type=,values=",
    "%": "SVGFEColorMatrixElement"
  },
  FECompositeElement: {
    "^": "SvgElement;operator=",
    "%": "SVGFECompositeElement"
  },
  FEMorphologyElement: {
    "^": "SvgElement;operator=",
    "%": "SVGFEMorphologyElement"
  },
  FETurbulenceElement: {
    "^": "SvgElement;type=",
    "%": "SVGFETurbulenceElement"
  },
  GraphicsElement: {
    "^": "SvgElement;",
    "%": "SVGAltGlyphElement|SVGCircleElement|SVGClipPathElement|SVGDefsElement|SVGEllipseElement|SVGForeignObjectElement|SVGGElement|SVGGeometryElement|SVGImageElement|SVGLineElement|SVGPathElement|SVGPolygonElement|SVGPolylineElement|SVGRectElement|SVGSVGElement|SVGSwitchElement|SVGTSpanElement|SVGTextContentElement|SVGTextElement|SVGTextPathElement|SVGTextPositioningElement|SVGUseElement;SVGGraphicsElement"
  },
  ScriptElement0: {
    "^": "SvgElement;type=",
    "%": "SVGScriptElement"
  },
  StyleElement0: {
    "^": "SvgElement;type=",
    "%": "SVGStyleElement"
  },
  SvgElement: {
    "^": "Element0;",
    $isEventTarget: true,
    "%": "SVGAltGlyphDefElement|SVGAltGlyphItemElement|SVGAnimateElement|SVGAnimateMotionElement|SVGAnimateTransformElement|SVGAnimationElement|SVGComponentTransferFunctionElement|SVGCursorElement|SVGDescElement|SVGDiscardElement|SVGFEBlendElement|SVGFEComponentTransferElement|SVGFEConvolveMatrixElement|SVGFEDiffuseLightingElement|SVGFEDisplacementMapElement|SVGFEDistantLightElement|SVGFEDropShadowElement|SVGFEFloodElement|SVGFEFuncAElement|SVGFEFuncBElement|SVGFEFuncGElement|SVGFEFuncRElement|SVGFEGaussianBlurElement|SVGFEImageElement|SVGFEMergeElement|SVGFEMergeNodeElement|SVGFEOffsetElement|SVGFEPointLightElement|SVGFESpecularLightingElement|SVGFESpotLightElement|SVGFETileElement|SVGFilterElement|SVGFontElement|SVGFontFaceElement|SVGFontFaceFormatElement|SVGFontFaceNameElement|SVGFontFaceSrcElement|SVGFontFaceUriElement|SVGGlyphElement|SVGGlyphRefElement|SVGGradientElement|SVGHKernElement|SVGLinearGradientElement|SVGMPathElement|SVGMarkerElement|SVGMaskElement|SVGMetadataElement|SVGMissingGlyphElement|SVGPatternElement|SVGRadialGradientElement|SVGSetElement|SVGStopElement|SVGSymbolElement|SVGTitleElement|SVGVKernElement|SVGViewElement;SVGElement"
  }
}],
["dart.isolate", "dart:isolate", , P, {
  "^": "",
  Capability: {
    "^": "Object;",
    $isCapability: true
  },
  SendPort: {
    "^": "Object;",
    $isSendPort: true,
    $isCapability: true
  }
}],
["dart.math", "dart:math", , P, {
  "^": "",
  _JenkinsSmiHash_combine0: function(hash, value) {
    hash = 536870911 & hash + value;
    hash = 536870911 & hash + ((524287 & hash) << 10 >>> 0);
    return hash ^ hash >>> 6;
  },
  _JenkinsSmiHash_finish: function(hash) {
    hash = 536870911 & hash + ((67108863 & hash) << 3 >>> 0);
    hash ^= hash >>> 11;
    return 536870911 & hash + ((16383 & hash) << 15 >>> 0);
  },
  min: function(a, b) {
    if (typeof b !== "number")
      throw H.wrapException(P.ArgumentError$(b));
    if (a > b)
      return b;
    if (a < b)
      return a;
    if (typeof b === "number") {
      if (typeof a === "number")
        if (a === 0)
          return (a + b) * a * b;
      if (a === 0 && C.JSInt_methods.get$isNegative(b) || isNaN(b))
        return b;
      return a;
    }
    return a;
  },
  max: function(a, b) {
    if (typeof a !== "number")
      throw H.wrapException(P.ArgumentError$(a));
    if (a > b)
      return a;
    if (a < b)
      return b;
    if (typeof b === "number") {
      if (typeof a === "number")
        if (a === 0)
          return a + b;
      if (isNaN(b))
        return b;
      return a;
    }
    if (b === 0 && C.JSNumber_methods.get$isNegative(a))
      return b;
    return a;
  },
  _RectangleBase: {
    "^": "Object;",
    get$right: function(_) {
      return this.get$left(this) + this.width;
    },
    get$bottom: function(_) {
      return this.get$top(this) + this.height;
    },
    toString$0: function(_) {
      return "Rectangle (" + H.S(this.get$left(this)) + ", " + H.S(this.top) + ") " + H.S(this.width) + " x " + H.S(this.height);
    },
    $eq: function(_, other) {
      var t1, t2;
      if (other == null)
        return false;
      t1 = J.getInterceptor(other);
      if (!t1.$isRectangle)
        return false;
      if (this.get$left(this) === t1.get$left(other)) {
        t2 = this.top;
        t1 = t2 === t1.get$top(other) && this.left + this.width === t1.get$right(other) && t2 + this.height === t1.get$bottom(other);
      } else
        t1 = false;
      return t1;
    },
    get$hashCode: function(_) {
      var t1 = this.top;
      return P._JenkinsSmiHash_finish(P._JenkinsSmiHash_combine0(P._JenkinsSmiHash_combine0(P._JenkinsSmiHash_combine0(P._JenkinsSmiHash_combine0(0, this.get$left(this) & 0x1FFFFFFF), t1 & 0x1FFFFFFF), this.left + this.width & 0x1FFFFFFF), t1 + this.height & 0x1FFFFFFF));
    },
    intersection$1: function(_, other) {
      var x0, x1, t1, y0, y1;
      x0 = P.max(this.get$left(this), other.get$left(other));
      x1 = P.min(this.left + this.width, other.get$left(other).$add(0, other.get$width(other)));
      if (x0 <= x1) {
        t1 = this.top;
        y0 = P.max(t1, other.get$top(other));
        y1 = P.min(t1 + this.height, other.get$top(other).$add(0, other.get$height(other)));
        if (y0 <= y1)
          return P.Rectangle$(x0, y0, x1 - x0, y1 - y0, H.getTypeArgumentByIndex(this, 0));
      }
      return;
    }
  },
  Rectangle: {
    "^": "_RectangleBase;left>,top>,width>,height>",
    $isRectangle: true,
    $asRectangle: null,
    static: {Rectangle$: function(left, $top, width, height, $T) {
        var t1, t2;
        t1 = width < 0 ? -width * 0 : width;
        t2 = height < 0 ? -height * 0 : height;
        return H.setRuntimeTypeInfo(new P.Rectangle(left, $top, t1, t2), [$T]);
      }}
  }
}],
["dart.profiler", "dart:profiler", , P, {
  "^": "",
  _FakeUserTag: {
    "^": "Object;label",
    static: {"^": "_FakeUserTag__instances,_FakeUserTag__defaultTag", _FakeUserTag__FakeUserTag: function(label) {
        var existingTag, t1, instance;
        existingTag = $.get$_FakeUserTag__instances().$index(0, label);
        if (existingTag != null)
          return existingTag;
        t1 = $.get$_FakeUserTag__instances();
        if (t1.get$length(t1) === 64)
          throw H.wrapException(P.UnsupportedError$("UserTag instance limit (64) reached."));
        instance = new P._FakeUserTag(label);
        $.get$_FakeUserTag__instances().$indexSet(0, label, instance);
        return instance;
      }}
  }
}],
["dart.typed_data", "dart:typed_data", , P, {
  "^": "",
  Uint8List: {
    "^": "Object;",
    $isList: true,
    $asList: function() {
      return [P.$int];
    },
    $isEfficientLength: true,
    $isIterable: true,
    $asIterable: function() {
      return [P.$int];
    }
  }
}],
["dart.typed_data.implementation", "dart:_native_typed_data", , H, {
  "^": "",
  NativeTypedData: {
    "^": "Interceptor;",
    _invalidIndex$2: function(receiver, index, $length) {
      if (typeof index !== "number")
        return index.$lt();
      if (index < 0 || index >= $length)
        throw H.wrapException(P.RangeError$range(index, 0, $length));
      else
        throw H.wrapException(P.ArgumentError$("Invalid list index " + index));
    },
    _checkIndex$2: function(receiver, index, $length) {
      if (index >>> 0 !== index || index >= $length)
        this._invalidIndex$2(receiver, index, $length);
    },
    _checkSublistArguments$3: function(receiver, start, end, $length) {
      var t1 = $length + 1;
      this._checkIndex$2(receiver, start, t1);
      this._checkIndex$2(receiver, end, t1);
      if (start > end)
        throw H.wrapException(P.RangeError$range(start, 0, end));
      return end;
    },
    "%": "DataView;ArrayBufferView;NativeTypedArray|NativeTypedArray_ListMixin|NativeTypedArray_ListMixin_FixedLengthListMixin|NativeTypedArrayOfDouble|NativeTypedArray_ListMixin0|NativeTypedArray_ListMixin_FixedLengthListMixin0|NativeTypedArrayOfInt"
  },
  NativeFloat32List: {
    "^": "NativeTypedArrayOfDouble;",
    sublist$2: function(receiver, start, end) {
      return new Float32Array(receiver.subarray(start, this._checkSublistArguments$3(receiver, start, end, receiver.length)));
    },
    $isList: true,
    $asList: function() {
      return [P.$double];
    },
    $isEfficientLength: true,
    $isIterable: true,
    $asIterable: function() {
      return [P.$double];
    },
    "%": "Float32Array"
  },
  NativeFloat64List: {
    "^": "NativeTypedArrayOfDouble;",
    sublist$2: function(receiver, start, end) {
      return new Float64Array(receiver.subarray(start, this._checkSublistArguments$3(receiver, start, end, receiver.length)));
    },
    $isList: true,
    $asList: function() {
      return [P.$double];
    },
    $isEfficientLength: true,
    $isIterable: true,
    $asIterable: function() {
      return [P.$double];
    },
    "%": "Float64Array"
  },
  NativeInt16List: {
    "^": "NativeTypedArrayOfInt;",
    $index: function(receiver, index) {
      var t1 = receiver.length;
      if (index >>> 0 !== index || index >= t1)
        this._invalidIndex$2(receiver, index, t1);
      return receiver[index];
    },
    sublist$2: function(receiver, start, end) {
      return new Int16Array(receiver.subarray(start, this._checkSublistArguments$3(receiver, start, end, receiver.length)));
    },
    $isList: true,
    $asList: function() {
      return [P.$int];
    },
    $isEfficientLength: true,
    $isIterable: true,
    $asIterable: function() {
      return [P.$int];
    },
    "%": "Int16Array"
  },
  NativeInt32List: {
    "^": "NativeTypedArrayOfInt;",
    $index: function(receiver, index) {
      var t1 = receiver.length;
      if (index >>> 0 !== index || index >= t1)
        this._invalidIndex$2(receiver, index, t1);
      return receiver[index];
    },
    sublist$2: function(receiver, start, end) {
      return new Int32Array(receiver.subarray(start, this._checkSublistArguments$3(receiver, start, end, receiver.length)));
    },
    $isList: true,
    $asList: function() {
      return [P.$int];
    },
    $isEfficientLength: true,
    $isIterable: true,
    $asIterable: function() {
      return [P.$int];
    },
    "%": "Int32Array"
  },
  NativeInt8List: {
    "^": "NativeTypedArrayOfInt;",
    $index: function(receiver, index) {
      var t1 = receiver.length;
      if (index >>> 0 !== index || index >= t1)
        this._invalidIndex$2(receiver, index, t1);
      return receiver[index];
    },
    sublist$2: function(receiver, start, end) {
      return new Int8Array(receiver.subarray(start, this._checkSublistArguments$3(receiver, start, end, receiver.length)));
    },
    $isList: true,
    $asList: function() {
      return [P.$int];
    },
    $isEfficientLength: true,
    $isIterable: true,
    $asIterable: function() {
      return [P.$int];
    },
    "%": "Int8Array"
  },
  NativeUint16List: {
    "^": "NativeTypedArrayOfInt;",
    $index: function(receiver, index) {
      var t1 = receiver.length;
      if (index >>> 0 !== index || index >= t1)
        this._invalidIndex$2(receiver, index, t1);
      return receiver[index];
    },
    sublist$2: function(receiver, start, end) {
      return new Uint16Array(receiver.subarray(start, this._checkSublistArguments$3(receiver, start, end, receiver.length)));
    },
    $isList: true,
    $asList: function() {
      return [P.$int];
    },
    $isEfficientLength: true,
    $isIterable: true,
    $asIterable: function() {
      return [P.$int];
    },
    "%": "Uint16Array"
  },
  NativeUint32List: {
    "^": "NativeTypedArrayOfInt;",
    $index: function(receiver, index) {
      var t1 = receiver.length;
      if (index >>> 0 !== index || index >= t1)
        this._invalidIndex$2(receiver, index, t1);
      return receiver[index];
    },
    sublist$2: function(receiver, start, end) {
      return new Uint32Array(receiver.subarray(start, this._checkSublistArguments$3(receiver, start, end, receiver.length)));
    },
    $isList: true,
    $asList: function() {
      return [P.$int];
    },
    $isEfficientLength: true,
    $isIterable: true,
    $asIterable: function() {
      return [P.$int];
    },
    "%": "Uint32Array"
  },
  NativeUint8ClampedList: {
    "^": "NativeTypedArrayOfInt;",
    get$length: function(receiver) {
      return receiver.length;
    },
    $index: function(receiver, index) {
      var t1 = receiver.length;
      if (index >>> 0 !== index || index >= t1)
        this._invalidIndex$2(receiver, index, t1);
      return receiver[index];
    },
    sublist$2: function(receiver, start, end) {
      return new Uint8ClampedArray(receiver.subarray(start, this._checkSublistArguments$3(receiver, start, end, receiver.length)));
    },
    $isList: true,
    $asList: function() {
      return [P.$int];
    },
    $isEfficientLength: true,
    $isIterable: true,
    $asIterable: function() {
      return [P.$int];
    },
    "%": "CanvasPixelArray|Uint8ClampedArray"
  },
  NativeUint8List: {
    "^": "NativeTypedArrayOfInt;",
    get$length: function(receiver) {
      return receiver.length;
    },
    $index: function(receiver, index) {
      var t1 = receiver.length;
      if (index >>> 0 !== index || index >= t1)
        this._invalidIndex$2(receiver, index, t1);
      return receiver[index];
    },
    sublist$2: function(receiver, start, end) {
      return new Uint8Array(receiver.subarray(start, this._checkSublistArguments$3(receiver, start, end, receiver.length)));
    },
    $isList: true,
    $asList: function() {
      return [P.$int];
    },
    $isEfficientLength: true,
    $isIterable: true,
    $asIterable: function() {
      return [P.$int];
    },
    "%": ";Uint8Array"
  },
  NativeTypedArray: {
    "^": "NativeTypedData;",
    get$length: function(receiver) {
      return receiver.length;
    },
    _setRangeFast$4: function(receiver, start, end, source, skipCount) {
      var t1, count, sourceLength;
      t1 = receiver.length + 1;
      this._checkIndex$2(receiver, start, t1);
      this._checkIndex$2(receiver, end, t1);
      if (start > end)
        throw H.wrapException(P.RangeError$range(start, 0, end));
      count = end - start;
      sourceLength = source.length;
      if (sourceLength - skipCount < count)
        throw H.wrapException(P.StateError$("Not enough elements"));
      if (skipCount !== 0 || sourceLength !== count)
        source = source.subarray(skipCount, skipCount + count);
      receiver.set(source, start);
    },
    $isJavaScriptIndexingBehavior: true
  },
  NativeTypedArrayOfDouble: {
    "^": "NativeTypedArray_ListMixin_FixedLengthListMixin;",
    $index: function(receiver, index) {
      var t1 = receiver.length;
      if (index >>> 0 !== index || index >= t1)
        this._invalidIndex$2(receiver, index, t1);
      return receiver[index];
    },
    $indexSet: function(receiver, index, value) {
      var t1 = receiver.length;
      if (index >>> 0 !== index || index >= t1)
        this._invalidIndex$2(receiver, index, t1);
      receiver[index] = value;
    },
    setRange$4: function(receiver, start, end, iterable, skipCount) {
      if (!!J.getInterceptor(iterable).$isNativeTypedArrayOfDouble) {
        this._setRangeFast$4(receiver, start, end, iterable, skipCount);
        return;
      }
      P.ListMixin.prototype.setRange$4.call(this, receiver, start, end, iterable, skipCount);
    },
    setRange$3: function($receiver, start, end, iterable) {
      return this.setRange$4($receiver, start, end, iterable, 0);
    },
    $isNativeTypedArrayOfDouble: true
  },
  NativeTypedArray_ListMixin: {
    "^": "NativeTypedArray+ListMixin;",
    $isList: true,
    $asList: function() {
      return [P.$double];
    },
    $isEfficientLength: true,
    $isIterable: true,
    $asIterable: function() {
      return [P.$double];
    }
  },
  NativeTypedArray_ListMixin_FixedLengthListMixin: {
    "^": "NativeTypedArray_ListMixin+FixedLengthListMixin;"
  },
  NativeTypedArrayOfInt: {
    "^": "NativeTypedArray_ListMixin_FixedLengthListMixin0;",
    $indexSet: function(receiver, index, value) {
      var t1 = receiver.length;
      if (index >>> 0 !== index || index >= t1)
        this._invalidIndex$2(receiver, index, t1);
      receiver[index] = value;
    },
    setRange$4: function(receiver, start, end, iterable, skipCount) {
      if (!!J.getInterceptor(iterable).$isNativeTypedArrayOfInt) {
        this._setRangeFast$4(receiver, start, end, iterable, skipCount);
        return;
      }
      P.ListMixin.prototype.setRange$4.call(this, receiver, start, end, iterable, skipCount);
    },
    setRange$3: function($receiver, start, end, iterable) {
      return this.setRange$4($receiver, start, end, iterable, 0);
    },
    $isNativeTypedArrayOfInt: true,
    $isList: true,
    $asList: function() {
      return [P.$int];
    },
    $isEfficientLength: true,
    $isIterable: true,
    $asIterable: function() {
      return [P.$int];
    }
  },
  NativeTypedArray_ListMixin0: {
    "^": "NativeTypedArray+ListMixin;",
    $isList: true,
    $asList: function() {
      return [P.$int];
    },
    $isEfficientLength: true,
    $isIterable: true,
    $asIterable: function() {
      return [P.$int];
    }
  },
  NativeTypedArray_ListMixin_FixedLengthListMixin0: {
    "^": "NativeTypedArray_ListMixin0+FixedLengthListMixin;"
  }
}],
["dart2js", "package:compiler/implementation/dart2jslib.dart", , K, {
  "^": "",
  invariant: function(spannable, condition, message) {
    if (spannable == null)
      throw H.wrapException(O.SpannableAssertionFailure$(C._SpannableSentinel_0, "Spannable was null for invariant. Use CURRENT_ELEMENT_SPANNABLE."));
    if ((!!J.getInterceptor(condition).$isFunction ? condition.call$0() : condition) !== true)
      throw H.wrapException(O.SpannableAssertionFailure$(spannable, !!J.getInterceptor(message).$isFunction ? message.call$0() : message));
    return true;
  },
  CodeBuffer: {
    "^": "Object;buffer,markers,lastBufferOffset,mappedRangeCounter",
    get$length: function(_) {
      return this.buffer._contents.length;
    },
    get$isEmpty: function(_) {
      return this.buffer._contents.length === 0;
    },
    add$1: function(_, object) {
      this.write$1(object);
      return this;
    },
    write$1: function(object) {
      var t1;
      if (!!J.getInterceptor(object).$isCodeBuffer)
        return this.addBuffer$1(object);
      if (this.mappedRangeCounter === 0)
        this.setSourceLocation$1(null);
      t1 = this.buffer;
      t1._contents += typeof object === "string" ? object : H.S(object);
      return this;
    },
    writeAll$2: function(objects, separator) {
      var iterator = J.get$iterator$ax(objects);
      if (!iterator.moveNext$0())
        return this;
      if (separator.length === 0) {
        do
          this.write$1(iterator.get$current());
        while (iterator.moveNext$0());
      } else {
        this.write$1(iterator.get$current());
        for (; iterator.moveNext$0();) {
          this.write$1(separator);
          this.write$1(iterator.get$current());
        }
      }
      return this;
    },
    writeAll$1: function(objects) {
      return this.writeAll$2(objects, "");
    },
    addBuffer$1: function(other) {
      var t1, firstMarker, t2, i;
      t1 = other.markers;
      if (t1.length > 0) {
        firstMarker = t1[0];
        t2 = this.markers;
        t2.push(new K.CodeBufferMarker(this.buffer._contents.length + firstMarker.offsetDelta - this.lastBufferOffset, firstMarker.sourcePosition));
        for (i = 1; i < t1.length; ++i)
          t2.push(t1[i]);
        this.lastBufferOffset = this.buffer._contents.length + other.lastBufferOffset;
      }
      this.buffer.write$1(other.buffer._contents);
      return this;
    },
    addAll$1: function(_, iterable) {
      return this.writeAll$1(iterable);
    },
    clear$0: function(_) {
      this.buffer = P.StringBuffer$("");
      C.JSArray_methods.set$length(this.markers, 0);
      this.lastBufferOffset = 0;
      return this;
    },
    toString$0: function(_) {
      throw H.wrapException("Don't use CodeBuffer.toString() since it drops sourcemap data.");
    },
    setSourceLocation$1: function(sourcePosition) {
      var t1;
      if (sourcePosition == null) {
        t1 = this.markers;
        if (t1.length > 0 && C.JSArray_methods.get$last(t1).sourcePosition == null)
          return;
      }
      this.markers.push(new K.CodeBufferMarker(this.buffer._contents.length - this.lastBufferOffset, sourcePosition));
      this.lastBufferOffset = this.buffer._contents.length;
    },
    forEachSourceLocation$1: function(f) {
      var t1 = {};
      t1.targetOffset_0 = 0;
      H.IterableMixinWorkaround_forEach(this.markers, new K.CodeBuffer_forEachSourceLocation_closure(t1, f));
    },
    $isCodeBuffer: true
  },
  CodeBuffer_forEachSourceLocation_closure: {
    "^": "Closure:13;box_0,f_1",
    call$1: function(marker) {
      var t1, targetOffset;
      t1 = this.box_0;
      targetOffset = t1.targetOffset_0 + marker.get$offsetDelta();
      t1.targetOffset_0 = targetOffset;
      this.f_1.call$2(targetOffset, marker.sourcePosition);
    },
    $isFunction: true
  },
  CodeBufferMarker: {
    "^": "Object;offsetDelta<,sourcePosition<"
  },
  ConstantCompilerTask: {
    "^": "CompilerTask;"
  },
  ConstantCompilerBase: {
    "^": "Object;compiler<",
    getConstantForVariable$1: function(element) {
      return this.initialVariableValues.$index(0, element.get$declaration());
    },
    compileConstant$1: [function(element) {
      return this.compileVariable$2$isConst(element, true);
    }, "call$1", "get$compileConstant", 2, 0, 69],
    compileVariable$2$isConst: function(element, isConst) {
      var t1, currentElement;
      t1 = this.initialVariableValues;
      if (t1.containsKey$1(element.get$declaration()))
        return t1.$index(0, element.get$declaration());
      currentElement = element.get$analyzableElement();
      return this.compiler.withCurrentElement$2(currentElement, new K.ConstantCompilerBase_compileVariable_closure(this, element, isConst, currentElement));
    },
    compileVariable$1: function(element) {
      return this.compileVariable$2$isConst(element, false);
    },
    compileVariableWithDefinitions$3$isConst: function(element, definitions, isConst) {
      var node, t1, initializer, value, t2, elementType, element0, constantType;
      node = element.get$node();
      t1 = this.pendingVariables;
      if (t1.contains$1(0, element)) {
        if (isConst)
          this.compiler.reportFatalError$2(node, C.MessageKind_EyN);
        return;
      }
      t1.add$1(0, element);
      initializer = element.get$initializer();
      if (initializer == null)
        value = C.C_NullConstant;
      else {
        value = this.compileNodeWithDefinitions$3$isConst(initializer, definitions, isConst);
        t2 = this.compiler;
        if (t2.enableTypeAssertions && value != null && element.kind === C.ElementKind_field_1) {
          elementType = element.get$type(element);
          if (J.get$kind$x(elementType) === C.TypeKind_malformed && !value.get$isNull())
            if (isConst) {
              element0 = elementType.get$element();
              t2.reportFatalError$3(node, element0.get$messageKind(), element0.get$messageArguments());
            } else
              value = null;
          else {
            constantType = value.computeType$1(t2);
            if (!this.constantSystem.isSubtype$3(t2, constantType, elementType))
              if (isConst)
                t2.reportFatalError$3(node, C.MessageKind_Yeh, P.LinkedHashMap_LinkedHashMap$_literal(["fromType", constantType, "toType", elementType], null, null));
              else
                value = null;
          }
        }
      }
      if (value != null)
        this.initialVariableValues.$indexSet(0, element.get$declaration(), value);
      t1.remove$1(0, element);
      return value;
    },
    compileNodeWithDefinitions$3$isConst: function(node, definitions, isConst) {
      return node.accept$1(0, new K.CompileTimeConstantEvaluator(isConst, this, definitions, this.compiler));
    },
    compileNodeWithDefinitions$2: function(node, definitions) {
      return this.compileNodeWithDefinitions$3$isConst(node, definitions, true);
    },
    compileMetadata$3: function(metadata, node, elements) {
      return this.compileNodeWithDefinitions$2(node, elements);
    }
  },
  ConstantCompilerBase_compileVariable_closure: {
    "^": "Closure:23;this_0,element_1,isConst_2,currentElement_3",
    call$0: function() {
      var t1, t2;
      t1 = this.this_0;
      t2 = this.currentElement_3;
      t1.compiler.analyzeElement$1(t2.get$declaration());
      return t1.compileVariableWithDefinitions$3$isConst(this.element_1, t2.get$resolvedAst().elements, this.isConst_2);
    },
    $isFunction: true
  },
  DartConstantCompiler: {
    "^": "ConstantCompilerBase;compiler,constantSystem,initialVariableValues,pendingVariables",
    compileNodeWithDefinitions$3$isConst: function(node, definitions, isConst) {
      var t1, constant;
      t1 = definitions._constants;
      constant = t1 != null ? t1.$index(0, node) : null;
      if (constant != null)
        return constant;
      constant = K.ConstantCompilerBase.prototype.compileNodeWithDefinitions$3$isConst.call(this, node, definitions, isConst);
      if (constant != null) {
        t1 = definitions._constants;
        if (t1 == null) {
          t1 = H.setRuntimeTypeInfo(new M.Maplet(C.C__MapletMarker, null, null), [Y.Node, K.Constant]);
          definitions._constants = t1;
        }
        t1.$indexSet(0, node, constant);
      }
      return constant;
    },
    compileNodeWithDefinitions$2: function(node, definitions) {
      return this.compileNodeWithDefinitions$3$isConst(node, definitions, true);
    }
  },
  CompileTimeConstantEvaluator: {
    "^": "Visitor;isEvaluatingConstant,handler,elements>,compiler<",
    evaluateConstant$1: [function(node) {
      var oldIsEvaluatingConstant, result;
      oldIsEvaluatingConstant = this.isEvaluatingConstant;
      this.isEvaluatingConstant = true;
      result = J.accept$1$x(node, this);
      this.isEvaluatingConstant = oldIsEvaluatingConstant;
      return result;
    }, "call$1", "get$evaluateConstant", 2, 0, 70],
    visitNode$1: function(node) {
      if (this.isEvaluatingConstant)
        this.compiler.reportFatalError$2(node, C.MessageKind_wdf);
      return;
    },
    visitLiteralBool$1: function(node) {
      return this.handler.constantSystem.createBool$1(node.get$value(node));
    },
    visitLiteralDouble$1: function(node) {
      return this.handler.constantSystem.createDouble$1(node.get$value(node));
    },
    visitLiteralInt$1: function(node) {
      return this.handler.constantSystem.createInt$1(node.get$value(node));
    },
    visitLiteralList$1: function(node) {
      var $arguments, link, type;
      if (node.get$constKeyword() == null) {
        if (this.isEvaluatingConstant)
          this.compiler.reportFatalError$2(node, C.MessageKind_wdf);
        return;
      }
      $arguments = H.setRuntimeTypeInfo([], [K.Constant]);
      for (link = node.elements.nodes; !link.get$isEmpty(link); link = link.get$tail())
        $arguments.push(this.evaluateConstant$1(link.get$head(link)));
      type = this.elements.getType$1(node);
      return new K.ListConstant($arguments, K.ListConstant__computeHash(type, $arguments), type);
    },
    visitLiteralMap$1: function(node) {
      var keys, map, link, t1, entry, t2, key, values;
      if (node.constKeyword == null) {
        if (this.isEvaluatingConstant)
          this.compiler.reportFatalError$2(node, C.MessageKind_wdf);
        return;
      }
      keys = H.setRuntimeTypeInfo([], [K.Constant]);
      map = P.LinkedHashMap_LinkedHashMap(null, null, null, K.Constant, K.Constant);
      for (link = node.entries.nodes, t1 = this.compiler; !link.get$isEmpty(link); link = link.get$tail()) {
        entry = link.get$head(link);
        t2 = J.getInterceptor$x(entry);
        key = this.evaluateConstant$1(t2.get$key(entry));
        if (!map.containsKey$1(key))
          keys.push(key);
        else
          t1.reportDiagnosticInternal$4(t2.get$key(entry), C.MessageKind_6ez, C.Map_empty, C.Diagnostic_2_warning);
        map.$indexSet(0, key, this.evaluateConstant$1(t2.get$value(entry)));
      }
      t2 = map.get$values(map);
      values = P.List_List$from(t2, true, H.getRuntimeTypeArgument(t2, "IterableBase", 0));
      return this.handler.constantSystem.createMap$4(t1, this.elements.getType$1(node), keys, values);
    },
    visitLiteralNull$1: function(node) {
      return this.handler.constantSystem.createNull$0();
    },
    visitLiteralString$1: function(node) {
      return this.handler.constantSystem.createString$1(node.dartString);
    },
    visitStringJuxtaposition$1: function(node) {
      var left, right;
      left = node.first.accept$1(0, this);
      right = node.second.accept$1(0, this);
      if (left == null || right == null)
        return;
      return this.handler.constantSystem.createString$1(Y.DartString_DartString$concat(J.get$value$x(left), J.get$value$x(right)));
    },
    visitStringInterpolation$1: function(node) {
      var initialString, accumulator, t1, part, expression, expressionString, partString;
      initialString = node.string.accept$1(0, this);
      if (initialString == null)
        return;
      accumulator = J.get$value$x(initialString);
      for (t1 = node.parts.nodes, t1.toString, t1 = H.setRuntimeTypeInfo(new E.LinkIterator(null, t1), [H.getTypeArgumentByIndex(t1, 0)]); t1.moveNext$0();) {
        part = t1._util_implementation$_current;
        expression = J.accept$1$x(part.get$expression(), this);
        if (expression == null) {
          t1 = part.get$expression();
          if (this.isEvaluatingConstant)
            this.compiler.reportFatalError$2(t1, C.MessageKind_wdf);
          return;
        } else if (expression.get$isNum() || expression.get$isBool())
          expressionString = new Y.LiteralDartString(J.toString$0(expression.get$value(expression)));
        else if (expression.get$isString())
          expressionString = expression.get$value(expression);
        else {
          t1 = part.get$expression();
          if (this.isEvaluatingConstant)
            this.compiler.reportFatalError$2(t1, C.MessageKind_wdf);
          return;
        }
        accumulator = Y.DartString_DartString$concat(accumulator, expressionString);
        partString = J.accept$1$x(part.get$string(), this);
        if (partString == null)
          return;
        accumulator = Y.DartString_DartString$concat(accumulator, J.get$value$x(partString));
      }
      return this.handler.constantSystem.createString$1(accumulator);
    },
    visitLiteralSymbol$1: function(node) {
      var t1 = this.compiler;
      return K.CompileTimeConstantEvaluator_makeConstructedConstant(t1, this.handler, node, t1.symbolClass.get$rawType(), t1.symbolConstructor, new K.CompileTimeConstantEvaluator_visitLiteralSymbol_createArguments(this, node), true);
    },
    makeTypeConstant$1: function(elementType) {
      var t1 = this.compiler;
      return new K.TypeConstant(elementType, t1.backend.get$typeImplementation().computeType$1(t1));
    },
    isDeferredUse$1: function(send) {
      if (send == null)
        return false;
      return this.compiler.deferredLoadTask.deferredPrefixElement$2(send, this.elements) != null;
    },
    visitIdentifier$1: function(node) {
      var element = this.elements.$index(0, node);
      if (element != null && element.get$kind(element) === C.ElementKind_class_4 || O.Elements_isTypedef(element))
        return this.makeTypeConstant$1(element.get$rawType());
      if (this.isEvaluatingConstant)
        this.compiler.reportFatalError$2(node, C.MessageKind_wdf);
      return;
    },
    visitSend$1: function(send) {
      var t1, element, t2, result, t3, left, right, t4, receiverConstant, operation, folded, areEquals;
      t1 = this.elements;
      element = t1.$index(0, send);
      t2 = send.argumentsNode;
      if (t2 == null) {
        if (this.isDeferredUse$1(send)) {
          if (this.isEvaluatingConstant)
            this.compiler.reportFatalError$2(send, C.MessageKind_Q9z);
          return;
        }
        if (O.Elements_isStaticOrTopLevelFunction(element))
          return new K.FunctionConstant(element);
        else if (O.Elements_isStaticOrTopLevelField(element)) {
          if (element.get$isConst())
            result = this.handler.compileVariable$2$isConst(element, true);
          else
            result = element.get$isFinal() && !this.isEvaluatingConstant ? this.handler.compileVariable$1(element) : null;
          if (result != null)
            return result;
        } else {
          t2 = element != null;
          if (t2 && element.get$kind(element) === C.ElementKind_class_4 || O.Elements_isTypedef(element))
            return this.makeTypeConstant$1(t1.getTypeLiteralType$1(send));
          else if (send.receiver != null)
            ;
          else if (!(!t2 || element.get$isErroneous()) && element.get$kind(element) === C.ElementKind_variable_1 && element.get$isConst()) {
            result = this.handler.compileVariable$2$isConst(element, true);
            if (result != null)
              return result;
          }
        }
        if (this.isEvaluatingConstant)
          this.compiler.reportFatalError$2(send, C.MessageKind_wdf);
        return;
      } else {
        t1 = send.selector;
        t3 = !!J.getInterceptor(t1).$isOperator;
        if (!t3 && true) {
          t1 = this.compiler;
          t3 = t1.identicalFunction;
          if (element == null ? t3 == null : element === t3)
            t3 = t2.slowLength$0() === 2;
          else
            t3 = false;
          if (t3) {
            t2 = t2.nodes;
            left = J.accept$1$x(t2.get$head(t2), this);
            t2 = t2.get$tail();
            right = J.accept$1$x(t2.get$head(t2), this);
            result = this.handler.constantSystem.get$identity().fold$2(0, left, right);
            if (result != null)
              return result;
          }
          if (this.isEvaluatingConstant)
            t1.reportFatalError$2(send, C.MessageKind_wdf);
          return;
        } else {
          t4 = J.getInterceptor(t2);
          if (!!t4.$isPrefix0) {
            receiverConstant = send.receiver.accept$1(0, this);
            if (receiverConstant == null)
              return;
            t2 = t1.get$token();
            operation = this.handler.constantSystem.lookupUnary$1(t2.get$value(t2));
            if (operation == null)
              this.compiler.internalError$2(t1, "Unexpected operator.");
            folded = operation.fold$1(0, receiverConstant);
            if (folded == null) {
              if (this.isEvaluatingConstant)
                this.compiler.reportFatalError$2(send, C.MessageKind_wdf);
              return;
            }
            return folded;
          } else if (t3 && !t4.$isPostfix0) {
            left = send.receiver.accept$1(0, this);
            t2 = t2.nodes;
            right = J.accept$1$x(t2.get$head(t2), this);
            if (left == null || right == null)
              return;
            t1 = t1.asOperator$0().token;
            switch (t1.get$value(t1)) {
              case "==":
                folded = (left.get$isPrimitive() && right.get$isPrimitive()) === true ? this.handler.constantSystem.get$equal().fold$2(0, left, right) : null;
                break;
              case "!=":
                if ((left.get$isPrimitive() && right.get$isPrimitive()) === true) {
                  areEquals = this.handler.constantSystem.get$equal().fold$2(0, left, right);
                  folded = areEquals == null ? null : areEquals.negate$0();
                } else
                  folded = null;
                break;
              default:
                operation = this.handler.constantSystem.lookupBinary$1(t1.get$value(t1));
                folded = operation != null ? operation.fold$2(0, left, right) : null;
            }
            if (folded == null) {
              if (this.isEvaluatingConstant)
                this.compiler.reportFatalError$2(send, C.MessageKind_wdf);
              return;
            }
            return folded;
          }
        }
      }
      if (this.isEvaluatingConstant)
        this.compiler.reportFatalError$2(send, C.MessageKind_wdf);
      return;
    },
    visitConditional$1: function(node) {
      var t1, condition, t2, conditionType, thenExpression, elseExpression;
      t1 = node.condition;
      condition = t1.accept$1(0, this);
      if (condition == null)
        return;
      else if (!condition.get$isBool()) {
        t2 = this.compiler;
        conditionType = condition.computeType$1(t2);
        if (this.isEvaluatingConstant)
          t2.reportFatalError$3(t1, C.MessageKind_Yeh, P.LinkedHashMap_LinkedHashMap$_literal(["fromType", conditionType, "toType", t2.boolClass.get$rawType()], null, null));
        return;
      }
      thenExpression = node.thenExpression.accept$1(0, this);
      elseExpression = node.elseExpression.accept$1(0, this);
      return condition.get$value(condition) ? thenExpression : elseExpression;
    },
    visitSendSet$1: function(node) {
      if (this.isEvaluatingConstant)
        this.compiler.reportFatalError$2(node, C.MessageKind_wdf);
      return;
    },
    evaluateArgumentsToConstructor$4: function(node, selector, $arguments, target) {
      var compiledArguments, t1, t2, classNameString, constructorNameString;
      compiledArguments = [];
      compiledArguments.$builtinTypeInfo = [K.Constant];
      t1 = this.compiler;
      if (!selector.addArgumentsToList$6($arguments, compiledArguments, target, this.get$evaluateConstant(), this.handler.get$compileConstant(), t1)) {
        t2 = target.get$enclosingClass();
        classNameString = t2.get$name(t2);
        constructorNameString = target.name;
        t1.reportFatalError$3(node, C.MessageKind_yHq, P.LinkedHashMap_LinkedHashMap$_literal(["constructorName", constructorNameString === "" ? classNameString : H.S(classNameString) + "." + H.S(constructorNameString)], null, null));
      }
      return compiledArguments;
    },
    visitNewExpression$1: function(node) {
      var send, t1, $constructor, t2, type, $arguments, firstArgument, defaultValue, t3;
      if (!node.get$isConst()) {
        if (this.isEvaluatingConstant)
          this.compiler.reportFatalError$2(node, C.MessageKind_wdf);
        return;
      }
      send = node.send;
      t1 = this.elements;
      $constructor = t1.$index(0, send);
      if ($constructor == null || $constructor.get$isErroneous()) {
        if (this.isEvaluatingConstant)
          this.compiler.reportFatalError$2(node, C.MessageKind_wdf);
        return;
      }
      if (this.isDeferredUse$1(send.selector.asSend$0())) {
        if (this.isEvaluatingConstant)
          this.compiler.reportFatalError$2(node, C.MessageKind_aI0);
        return;
      }
      t2 = this.compiler;
      t2.analyzeElement$1($constructor.get$declaration());
      type = t1.getType$1(node);
      t1 = new K.CompileTimeConstantEvaluator_visitNewExpression_evaluateArguments(this, node, send);
      if ($constructor === t2.intEnvironment || $constructor === t2.boolEnvironment || $constructor === t2.stringEnvironment) {
        $arguments = t1.call$1($constructor.get$implementation($constructor));
        t1 = J.getInterceptor$asx($arguments);
        firstArgument = t1.$index($arguments, 0);
        defaultValue = t1.$index($arguments, 1);
        t1 = J.getInterceptor(firstArgument);
        if (!!t1.$isNullConstant) {
          t3 = send.argumentsNode.nodes;
          t2.reportFatalError$2(t3.get$head(t3), C.MessageKind_7Re);
        }
        if (!t1.$isStringConstant) {
          type = defaultValue.computeType$1(t2);
          t3 = send.argumentsNode.nodes;
          t2.reportFatalError$3(t3.get$head(t3), C.MessageKind_Yeh, P.LinkedHashMap_LinkedHashMap$_literal(["fromType", type, "toType", t2.stringClass.get$rawType()], null, null));
        }
        if ($constructor === t2.intEnvironment) {
          t3 = J.getInterceptor(defaultValue);
          t3 = !(!!t3.$isNullConstant || !!t3.$isIntConstant);
        } else
          t3 = false;
        if (t3) {
          type = defaultValue.computeType$1(t2);
          t3 = send.argumentsNode.nodes.get$tail();
          t2.reportFatalError$3(t3.get$head(t3), C.MessageKind_Yeh, P.LinkedHashMap_LinkedHashMap$_literal(["fromType", type, "toType", t2.intClass.get$rawType()], null, null));
        }
        if ($constructor === t2.boolEnvironment) {
          t3 = J.getInterceptor(defaultValue);
          t3 = !(!!t3.$isNullConstant || !!t3.$isBoolConstant);
        } else
          t3 = false;
        if (t3) {
          type = defaultValue.computeType$1(t2);
          t3 = send.argumentsNode.nodes.get$tail();
          t2.reportFatalError$3(t3.get$head(t3), C.MessageKind_Yeh, P.LinkedHashMap_LinkedHashMap$_literal(["fromType", type, "toType", t2.boolClass.get$rawType()], null, null));
        }
        if ($constructor === t2.stringEnvironment) {
          t3 = J.getInterceptor(defaultValue);
          t3 = !(!!t3.$isNullConstant || !!t3.$isStringConstant);
        } else
          t3 = false;
        if (t3) {
          type = defaultValue.computeType$1(t2);
          t3 = send.argumentsNode.nodes.get$tail();
          t2.reportFatalError$3(t3.get$head(t3), C.MessageKind_Yeh, P.LinkedHashMap_LinkedHashMap$_literal(["fromType", type, "toType", t2.stringClass.get$rawType()], null, null));
        }
        t2.fromEnvironment$1(t1.get$value(firstArgument).slowToString$0());
        return defaultValue;
      } else
        return K.CompileTimeConstantEvaluator_makeConstructedConstant(t2, this.handler, node, type, $constructor, t1, false);
    },
    visitParenthesizedExpression$1: function(node) {
      return node.expression.accept$1(0, this);
    },
    error$2: [function(_, node, message) {
      this.compiler.reportFatalError$2(node, message);
    }, "call$2", "get$error", 4, 0, 71],
    $asVisitor: function() {
      return [null];
    },
    static: {CompileTimeConstantEvaluator_makeConstructedConstant: function(compiler, handler, node, type, $constructor, getArguments, isLiteralSymbol) {
        var constructedType, classElement, $arguments, evaluator, jsNewArguments;
        compiler.resolver.resolveRedirectionChain$2($constructor, node);
        constructedType = $constructor.computeEffectiveTargetType$1(type);
        $constructor = $constructor.get$effectiveTarget();
        classElement = $constructor.get$enclosingClass();
        $constructor = $constructor.get$implementation($constructor);
        $arguments = getArguments.call$1($constructor);
        evaluator = K.ConstructorEvaluator$(constructedType, $constructor, handler, compiler);
        evaluator.evaluateConstructorFieldValues$1($arguments);
        jsNewArguments = evaluator.buildJsNewArguments$1(classElement);
        return new K.ConstructedConstant(jsNewArguments, K.ConstructedConstant_computeHash(constructedType, jsNewArguments), isLiteralSymbol, constructedType);
      }}
  },
  CompileTimeConstantEvaluator_visitLiteralSymbol_createArguments: {
    "^": "Closure:72;this_0,node_1",
    call$1: function(_) {
      return [this.this_0.handler.constantSystem.createString$1(new Y.LiteralDartString(this.node_1.get$slowNameString()))];
    },
    $isFunction: true
  },
  CompileTimeConstantEvaluator_visitNewExpression_evaluateArguments: {
    "^": "Closure:73;this_0,node_1,send_2",
    call$1: function($constructor) {
      var t1, t2;
      t1 = this.this_0;
      t2 = this.send_2;
      return t1.evaluateArgumentsToConstructor$4(this.node_1, t1.elements.getSelector$1(t2), t2.argumentsNode.nodes, $constructor);
    },
    $isFunction: true
  },
  CompileTimeConstantEvaluator_visitNewExpression_closure: {
    "^": "Closure:13;",
    call$1: function(_) {
      return;
    },
    $isFunction: true
  },
  ConstructorEvaluator: {
    "^": "CompileTimeConstantEvaluator;constructedType,$constructor<,definitions<,fieldValues,isEvaluatingConstant,handler,elements,compiler",
    visitSend$1: function(send) {
      var element, constant;
      element = this.elements.$index(0, send);
      if (O.Elements_isLocal(element)) {
        constant = this.definitions.$index(0, element);
        if (constant == null)
          this.compiler.internalError$2(send, "Local variable without value.");
        return constant;
      }
      return K.CompileTimeConstantEvaluator.prototype.visitSend$1.call(this, send);
    },
    potentiallyCheckType$3: function(node, element, constant) {
      var t1, elementType, constantType;
      t1 = this.compiler;
      if (t1.enableTypeAssertions) {
        elementType = element.get$type(element).substByContext$1(this.constructedType);
        constantType = constant.computeType$1(t1);
        if (!this.handler.constantSystem.isSubtype$3(t1, constantType, elementType))
          t1.reportFatalError$3(node, C.MessageKind_Yeh, P.LinkedHashMap_LinkedHashMap$_literal(["fromType", constantType, "toType", elementType], null, null));
      }
    },
    assignArgumentsToParameters$1: function($arguments) {
      var t1, signature;
      t1 = {};
      signature = this.$constructor.get$functionSignature();
      t1.index_0 = 0;
      signature.orderedForEachParameter$1(new K.ConstructorEvaluator_assignArgumentsToParameters_closure(t1, this, $arguments));
    },
    evaluateSuperOrRedirectSend$2: function(compiledArguments, targetConstructor) {
      var evaluator = K.ConstructorEvaluator$(this.constructedType.asInstanceOf$1(targetConstructor.get$enclosingClass()), targetConstructor, this.handler, this.compiler);
      evaluator.evaluateConstructorFieldValues$1(compiledArguments);
      evaluator.fieldValues.forEach$1(0, new K.ConstructorEvaluator_evaluateSuperOrRedirectSend_closure(this));
    },
    evaluateConstructorInitializers$0: function() {
      var t1, compiledArguments, compileConstant, t2, target, functionNode, initializerList, link, foundSuperOrRedirect, $call, $init, initArguments, fieldValue, t3, enclosingClass, superClass, selector, targetConstructor;
      t1 = this.$constructor;
      if (t1.get$isSynthesized()) {
        compiledArguments = H.setRuntimeTypeInfo([], [K.Constant]);
        compileConstant = this.handler.get$compileConstant();
        t2 = t1.get$definingConstructor();
        target = t2.get$implementation(t2);
        Z.Selector_addForwardingElementArgumentsToList(t1, compiledArguments, target, new K.ConstructorEvaluator_evaluateConstructorInitializers_closure(this), compileConstant, this.compiler);
        this.evaluateSuperOrRedirectSend$2(compiledArguments, target);
        return;
      }
      functionNode = t1.get$node();
      initializerList = functionNode.get$initializers();
      if (initializerList != null)
        for (link = initializerList.nodes, t2 = this.elements, foundSuperOrRedirect = false; !link.get$isEmpty(link); link = link.get$tail())
          if (!J.getInterceptor(link.get$head(link)).$isSendSet) {
            $call = link.get$head(link);
            target = t2.$index(0, $call);
            this.evaluateSuperOrRedirectSend$2(this.evaluateArgumentsToConstructor$4($call, t2.getSelector$1($call), $call.get$argumentsNode().nodes, target), target);
            foundSuperOrRedirect = true;
          } else {
            $init = link.get$head(link);
            initArguments = $init.get$argumentsNode().nodes;
            fieldValue = J.accept$1$x(initArguments.get$head(initArguments), this);
            t3 = t2.$index(0, $init);
            this.potentiallyCheckType$3($init, t3, fieldValue);
            this.fieldValues.$indexSet(0, t3, fieldValue);
          }
      else
        foundSuperOrRedirect = false;
      if (!foundSuperOrRedirect) {
        enclosingClass = t1.get$enclosingClass();
        superClass = enclosingClass.get$superclass();
        t1 = this.compiler;
        if (enclosingClass !== t1.objectClass) {
          selector = Z.Selector_Selector(C.SelectorKind_call_2, "", enclosingClass.get$enclosingElement().get$library(), 0, null);
          targetConstructor = superClass.lookupConstructor$1(selector);
          if (targetConstructor == null)
            t1.internalError$2(functionNode, "No default constructor available.");
          this.evaluateSuperOrRedirectSend$2(this.evaluateArgumentsToConstructor$4(functionNode, selector, C.C_Link3, targetConstructor), targetConstructor);
        }
      }
    },
    evaluateConstructorFieldValues$1: function($arguments) {
      this.compiler.withCurrentElement$2(this.$constructor, new K.ConstructorEvaluator_evaluateConstructorFieldValues_closure(this, $arguments));
    },
    buildJsNewArguments$1: function(classElement) {
      var jsNewArguments = H.setRuntimeTypeInfo([], [K.Constant]);
      classElement.get$implementation(classElement).forEachInstanceField$2$includeSuperAndInjectedMembers(new K.ConstructorEvaluator_buildJsNewArguments_closure(this, jsNewArguments), true);
      return jsNewArguments;
    },
    ConstructorEvaluator$4: function(constructedType, $constructor, handler, compiler) {
    },
    static: {ConstructorEvaluator$: function(constructedType, $constructor, handler, compiler) {
        var t1 = new K.ConstructorEvaluator(constructedType, $constructor, P.LinkedHashMap_LinkedHashMap(null, null, null, O.Element, K.Constant), P.LinkedHashMap_LinkedHashMap(null, null, null, O.Element, K.Constant), true, handler, compiler.resolver.resolveMethodElement$1($constructor.get$declaration()), compiler);
        t1.ConstructorEvaluator$4(constructedType, $constructor, handler, compiler);
        return t1;
      }}
  },
  ConstructorEvaluator_assignArgumentsToParameters_closure: {
    "^": "Closure:50;box_0,this_1,arguments_2",
    call$1: function(parameter) {
      var argument, node, t1, t2;
      argument = J.$index$asx(this.arguments_2, this.box_0.index_0++);
      node = parameter.get$node();
      t1 = this.this_1;
      t1.potentiallyCheckType$3(node, parameter, argument);
      t1.definitions.$indexSet(0, parameter, argument);
      if (J.get$kind$x(parameter) === C.ElementKind_initializing_formal_1) {
        t2 = parameter.get$fieldElement();
        t1.potentiallyCheckType$3(node, t2, argument);
        t1.fieldValues.$indexSet(0, t2, argument);
      }
    },
    $isFunction: true
  },
  ConstructorEvaluator_evaluateSuperOrRedirectSend_closure: {
    "^": "Closure:19;this_0",
    call$2: function(key, value) {
      this.this_0.fieldValues.$indexSet(0, key, value);
      return value;
    },
    $isFunction: true
  },
  ConstructorEvaluator_evaluateConstructorInitializers_closure: {
    "^": "Closure:13;this_0",
    call$1: function(element) {
      return this.this_0.definitions.$index(0, element);
    },
    $isFunction: true
  },
  ConstructorEvaluator_evaluateConstructorFieldValues_closure: {
    "^": "Closure:23;this_0,arguments_1",
    call$0: function() {
      var t1 = this.this_0;
      t1.assignArgumentsToParameters$1(this.arguments_1);
      t1.evaluateConstructorInitializers$0();
    },
    $isFunction: true
  },
  ConstructorEvaluator_buildJsNewArguments_closure: {
    "^": "Closure:74;this_0,jsNewArguments_1",
    call$2: function(enclosing, field) {
      var t1, fieldValue;
      t1 = this.this_0;
      fieldValue = t1.fieldValues.$index(0, field);
      if (fieldValue == null)
        fieldValue = t1.handler.compileVariable$2$isConst(field, true);
      this.jsNewArguments_1.push(fieldValue);
    },
    $isFunction: true
  },
  ItemCompilationContext: {
    "^": "Object;"
  },
  WorkItem: {
    "^": "Object;element<"
  },
  ResolutionWorkItem: {
    "^": "WorkItem;resolutionTree,compilationContext,element",
    run$2: function(compiler, world) {
      compiler.analyze$2(this, world);
      this.resolutionTree = this.element.get$resolvedAst().elements;
    }
  },
  CodegenRegistry: {
    "^": "Registry;compiler<,treeElements<",
    get$backend: function() {
      return this.compiler.backend;
    },
    registerDependency$1: [function(element) {
      this.treeElements.registerDependency$1(element);
    }, "call$1", "get$registerDependency", 2, 0, 47],
    registerGetOfStaticFunction$1: function(element) {
      this.compiler.enqueuer.codegen.registerGetOfStaticFunction$1(element);
    },
    registerStaticInvocation$1: function(element) {
      this.compiler.enqueuer.codegen.registerStaticUse$1(element);
    },
    registerInstantiation$1: function(type) {
      this.compiler.enqueuer.codegen.registerInstantiatedType$2(type, this);
    }
  },
  CodegenWorkItem: {
    "^": "WorkItem;registry,resolutionTree,compilationContext,element",
    run$2: function(compiler, world) {
      var t1, t2, t3;
      t1 = this.element;
      if (t1.get$isAbstract() || world.get$generatedCode().containsKey$1(t1))
        return;
      this.registry = new K.CodegenRegistry(compiler, this.resolutionTree);
      t1 = compiler.progress;
      t2 = t1.get$elapsedTicks();
      t3 = $.Stopwatch__frequency;
      if (typeof t3 !== "number")
        return H.iae(t3);
      if (C.JSInt_methods.$tdiv(t2 * 1000, t3) > 500) {
        compiler.log$1("Compiled " + compiler.enqueuer.codegen.generatedCode._collection$_length + " methods.");
        t1.reset$0(0);
      }
      compiler.backend.codegen$1(this);
    },
    CodegenWorkItem$2: function(element, compilationContext) {
    }
  },
  DeferredTask: {
    "^": "Object;element<,action>"
  },
  Registry: {
    "^": "Object;"
  },
  Backend: {
    "^": "Object;compiler<,classesRequiredForReflection<",
    nativeResolutionEnqueuer$1: function(world) {
      return new L.NativeEnqueuer();
    },
    nativeCodegenEnqueuer$1: function(world) {
      return new L.NativeEnqueuer();
    },
    onResolutionComplete$0: function() {
    },
    createItemCompilationContext$0: [function() {
      return new K.ItemCompilationContext();
    }, "call$0", "get$createItemCompilationContext", 0, 0, 75],
    registerCompileTimeConstant$2: function(constant, registry) {
    },
    registerMetadataConstant$3: function(constant, annotatedElement, registry) {
    },
    registerInstantiatedClass$3: function(cls, enqueuer, registry) {
    },
    registerIsCheckForCodegen$3: function(type, enqueuer, registry) {
    },
    isAssertMethod$1: function(element) {
      return false;
    },
    registerGenericCallMethod$3: function(callMethod, enqueuer, registry) {
    },
    registerGenericClosure$3: function(closure, enqueuer, registry) {
    },
    registerBoundClosure$1: function(enqueuer) {
    },
    registerGetOfStaticFunction$1: function(enqueuer) {
    },
    registerRuntimeType$2: function(enqueuer, registry) {
    },
    enableNoSuchMethod$2: function(context, enqueuer) {
      enqueuer.registerInvocation$1(this.compiler.noSuchMethodSelector);
    },
    enableIsolateSupport$1: function(enqueuer) {
    },
    registerRequiredType$2: function(type, enclosingElement) {
    },
    registerClassUsingVariableExpression$1: function(cls) {
    },
    registerConstSymbol$2: function($name, registry) {
    },
    registerNewSymbol$1: function(registry) {
    },
    isNullImplementation$1: function(cls) {
      return J.$eq(cls, this.compiler.nullClass);
    },
    get$intImplementation: function() {
      return this.compiler.intClass;
    },
    get$doubleImplementation: function() {
      return this.compiler.doubleClass;
    },
    get$numImplementation: function() {
      return this.compiler.numClass;
    },
    get$stringImplementation: function() {
      return this.compiler.stringClass;
    },
    get$listImplementation: function() {
      return this.compiler.listClass;
    },
    get$growableListImplementation: function() {
      return this.compiler.listClass;
    },
    get$fixedListImplementation: function() {
      return this.compiler.listClass;
    },
    get$constListImplementation: function() {
      return this.compiler.listClass;
    },
    get$mapImplementation: function() {
      return this.compiler.mapClass;
    },
    get$constMapImplementation: function() {
      return this.compiler.mapClass;
    },
    get$typeImplementation: function() {
      return this.compiler.typeClass;
    },
    get$boolImplementation: function() {
      return this.compiler.boolClass;
    },
    get$nullImplementation: function() {
      return this.compiler.nullClass;
    },
    get$uint32Implementation: function() {
      return this.compiler.intClass;
    },
    get$uint31Implementation: function() {
      return this.compiler.intClass;
    },
    get$positiveIntImplementation: function() {
      return this.compiler.intClass;
    },
    defaultSuperclass$1: function(element) {
      return this.compiler.objectClass;
    },
    isDefaultNoSuchMethodImplementation$1: function(element) {
      var classElement, t1;
      classElement = element.get$enclosingClass();
      t1 = this.compiler.objectClass;
      return classElement == null ? t1 == null : classElement === t1;
    },
    isInterceptorClass$1: function(element) {
      return false;
    },
    isForeign$1: function(element) {
      return false;
    },
    isBackendLibrary$1: function(library) {
      var canonicalUri = library.canonicalUri;
      if (canonicalUri.$eq(0, $.get$JavaScriptBackend_DART_JS_HELPER()) || canonicalUri.$eq(0, $.get$JavaScriptBackend_DART_INTERCEPTORS()))
        return true;
      return false;
    },
    onLibraryCreated$1: function(library) {
    },
    onLibraryScanned$2: function(library, loader) {
      var t1, t2, patchUri;
      t1 = library.canonicalUri;
      if (t1.scheme === "dart" && !library.get$isPatched()) {
        t2 = this.compiler;
        patchUri = t2.resolvePatchUri$1(t1._path);
        if (patchUri != null)
          return t2.patchParser.patchLibrary$3(loader, patchUri, library);
      }
      if (library.canUseNative)
        library.forEachLocalMember$1(new K.Backend_onLibraryScanned_closure(this));
      return P._Future$immediate(null, null);
    },
    registerMirrorUsage$3: function(symbols, targets, metaTargets) {
    },
    isAccessibleByReflection$1: [function(element) {
      return true;
    }, "call$1", "get$isAccessibleByReflection", 2, 0, 76],
    referencedFromMirrorSystem$2: function(element, recursive) {
      return false;
    },
    referencedFromMirrorSystem$1: function(element) {
      return this.referencedFromMirrorSystem$2(element, null);
    },
    requiredByMirrorSystem$1: function(element) {
      return false;
    },
    canBeUsedForGlobalOptimizations$1: function(element) {
      return true;
    },
    onQueueEmpty$2: function(enqueuer, recentClasses) {
      return true;
    },
    onElementResolved$2: function(element, elements) {
    },
    shouldOutput$1: function(element) {
      return true;
    },
    helperForBadMain$0: function() {
      return;
    },
    helperForMissingMain$0: function() {
      return;
    },
    helperForMainArity$0: function() {
      return;
    }
  },
  Backend_onLibraryScanned_closure: {
    "^": "Closure:77;this_0",
    call$1: function(element) {
      if (J.get$kind$x(element) === C.ElementKind_class_4)
        S.EagerAnnotationHandler_checkAnnotation(this.this_0.compiler, element, C.C_NativeAnnotationHandler);
    },
    $isFunction: true
  },
  ResolutionCallbacks: {
    "^": "Object;",
    onAssert$2: function(node, registry) {
    },
    onStringInterpolation$1: function(registry) {
    },
    onCatchStatement$1: function(registry) {
    },
    onThrowExpression$1: function(registry) {
    },
    onLazyField$1: function(registry) {
    },
    onTypeVariableExpression$1: function(registry) {
    },
    onStackTraceInCatch$1: function(registry) {
    },
    onIsCheck$2: function(type, registry) {
    },
    onAsCheck$2: function(type, registry) {
    },
    onTypeVariableBoundCheck$1: function(registry) {
    },
    onThrowNoSuchMethod$1: function(registry) {
    },
    onThrowRuntimeError$1: function(registry) {
    },
    onAbstractClassInstantiation$1: function(registry) {
    },
    onFallThroughError$1: function(registry) {
    },
    onSuperNoSuchMethod$1: function(registry) {
    },
    onConstantMap$1: function(registry) {
    },
    onSymbolConstructor$1: function(registry) {
    }
  },
  TokenKey: {
    "^": "Object;token<",
    get$hashCode: function(_) {
      return this.token.charOffset;
    },
    $eq: function(_, other) {
      if (other == null)
        return false;
      return !!J.getInterceptor(other).$isTokenKey && this.token === other.token;
    },
    $isTokenKey: true
  },
  TokenMap: {
    "^": "Object;comments",
    $index: function(_, key) {
      if (key == null)
        return;
      return this.comments.$index(0, new K.TokenKey(key));
    },
    $indexSet: function(_, key, value) {
      if (key == null)
        return;
      this.comments.$indexSet(0, new K.TokenKey(key), value);
    }
  },
  Compiler0: {
    "^": "Object;types<,intClass<,backend<",
    outputProvider$2: function(arg0, arg1) {
      return this.outputProvider.call$2(arg0, arg1);
    },
    fromEnvironment$1: function($name) {
      return;
    },
    tryToString$1: function(object) {
      var t1, exception;
      try {
        t1 = J.toString$0(object);
        return t1;
      } catch (exception) {
        H.unwrapException(exception);
        return "<exception in toString()>";
      }

    },
    withCurrentElement$2: function(element, f) {
      var old, ex, t1, exception, t2, exception0;
      old = this._currentElement;
      this._currentElement = element;
      try {
        t1 = f.call$0();
        return t1;
      } catch (exception) {
        t1 = H.unwrapException(exception);
        t2 = J.getInterceptor(t1);
        if (!!t2.$isSpannableAssertionFailure) {
          ex = t1;
          if (!this.hasCrashed) {
            this.reportAssertionFailure$1(ex);
            P.print(K.Message$(C.MessageKind_u5H, P.LinkedHashMap_LinkedHashMap$_literal(["buildId", this.buildId], null, null), false));
          }
          this.hasCrashed = true;
          throw exception;
        } else if (!!t2.$isCompilerCancelledException)
          throw exception;
        else if (!!t2.$isStackOverflowError)
          throw exception;
        else {
          if (this.hasCrashed)
            throw exception;
          try {
            this.unhandledExceptionOnElement$1(element);
          } catch (exception0) {
            H.unwrapException(exception0);
          }

          throw exception;
        }
      }
 finally {
        this._currentElement = old;
      }
    },
    getNextFreeClassId$0: [function() {
      return this.nextFreeClassId++;
    }, "call$0", "get$getNextFreeClassId", 0, 0, 78],
    internalError$2: function(node, reason) {
      var message;
      this.assembledCode = null;
      message = this.tryToString$1(reason);
      this.reportDiagnosticInternal$4(node, C.MessageKind_wwi, P.LinkedHashMap_LinkedHashMap$_literal(["text", message], null, null), C.Diagnostic_32_crash);
      throw H.wrapException("Internal Error: " + H.S(message));
    },
    unhandledExceptionOnElement$1: function(element) {
      if (this.hasCrashed)
        return;
      this.hasCrashed = true;
      this.reportDiagnostic$3(element, K.Message$(C.MessageKind_WR8, C.Map_empty, false), C.Diagnostic_32_crash);
      P.print(K.Message$(C.MessageKind_u5H, P.LinkedHashMap_LinkedHashMap$_literal(["buildId", this.buildId], null, null), false));
    },
    spanFromSpannable$1: function(node) {
      var t1;
      if (node == null)
        return;
      if (node.$eq(0, C._SpannableSentinel_0))
        node = this._currentElement;
      else if (node.$eq(0, C._SpannableSentinel_fBD)) {
        node = this._currentElement;
        if (node == null)
          return;
      }
      t1 = J.getInterceptor(node);
      if (!!t1.$isSourceSpan)
        return node;
      else if (!!t1.$isNode)
        return this.spanFromTokens$2(node.getBeginToken$0(), node.getEndToken$0());
      else if (!!t1.$isToken)
        return this.spanFromTokens$2(node, node);
      else if (!!t1.$isHInstruction)
        return this.spanFromHInstruction$1(node);
      else if (!!t1.$isElement)
        return this.spanFromElement$1(node);
      else if (!!t1.$isMetadataAnnotation) {
        t1 = node.get$annotatedElement().get$compilationUnit().get$script();
        return this.spanFromTokens$3(node.get$beginToken(), node.get$endToken(), t1.readableUri);
      } else if (!!t1.$isLocal)
        return this.spanFromElement$1(node.get$executableContext());
      else
        throw H.wrapException("No error location.");
    },
    log$1: [function(message) {
      this.reportDiagnostic$3(null, K.Message$(C.MessageKind_wwi, P.LinkedHashMap_LinkedHashMap$_literal(["text", message], null, null), false), C.Diagnostic_kiE);
    }, "call$1", "get$log", 2, 0, 8],
    run$1: function(uri) {
      this.totalCompileTime.start$0(0);
      return P.Future_Future$sync(new K.Compiler_run_closure0(this, uri), null).catchError$1(new K.Compiler_run_closure1(this, uri)).whenComplete$1(new K.Compiler_run_closure2(this)).then$1(new K.Compiler_run_closure3(this));
    },
    onLibrariesLoaded$1: function(loadedLibraries) {
      return P.Future_Future$sync(new K.Compiler_onLibrariesLoaded_closure(this, loadedLibraries), null).then$1(new K.Compiler_onLibrariesLoaded_closure0(this, loadedLibraries));
    },
    findRequiredElement$2: function(library, $name) {
      var element = library.find$1(0, $name);
      if (element == null)
        this.internalError$2(library, "The library '" + library.canonicalUri.toString$0(0) + "' does not contain required element: '" + $name + "'.");
      return element;
    },
    initializeCoreClasses$0: function() {
      var missingCoreClasses, t1;
      missingCoreClasses = [];
      t1 = new K.Compiler_initializeCoreClasses_lookupCoreClass(this, missingCoreClasses);
      this.objectClass = t1.call$1("Object");
      this.boolClass = t1.call$1("bool");
      this.numClass = t1.call$1("num");
      this.intClass = t1.call$1("int");
      this.doubleClass = t1.call$1("double");
      this.stringClass = t1.call$1("String");
      this.functionClass = t1.call$1("Function");
      this.listClass = t1.call$1("List");
      this.typeClass = t1.call$1("Type");
      this.mapClass = t1.call$1("Map");
      this.nullClass = t1.call$1("Null");
      this.stackTraceClass = t1.call$1("StackTrace");
      if (missingCoreClasses.length !== 0)
        this.internalError$2(this.coreLibrary, "dart:core library does not contain required classes: " + H.S(missingCoreClasses));
      this.symbolClass = t1.call$1("Symbol");
    },
    get$unnamedListConstructor: function() {
      var t1, callConstructor;
      t1 = this._unnamedListConstructor;
      if (t1 != null)
        return t1;
      callConstructor = Z.Selector_Selector(C.SelectorKind_call_2, "", this.listClass.get$library(), 0, null);
      t1 = this.listClass.lookupConstructor$1(callConstructor);
      this._unnamedListConstructor = t1;
      return t1;
    },
    get$filledListConstructor: function() {
      var t1, callConstructor;
      t1 = this._filledListConstructor;
      if (t1 != null)
        return t1;
      callConstructor = Z.Selector_Selector(C.SelectorKind_call_2, "filled", this.listClass.get$library(), 0, null);
      t1 = this.listClass.lookupConstructor$1(callConstructor);
      this._filledListConstructor = t1;
      return t1;
    },
    runCompiler$1: function(uri) {
      $.get$StringToken_canonicalizedSubstrings().clear$0(0);
      $.get$Selector_canonicalizedValues().clear$0(0);
      $.get$TypedSelector_canonicalizedValues().clear$0(0);
      return P.Future_Future$sync(new K.Compiler_runCompiler_closure(this), null).then$1(new K.Compiler_runCompiler_closure0(this, uri)).then$1(new K.Compiler_runCompiler_closure1(this));
    },
    computeMain$0: function() {
      var t1, t2, main, t3, t4, parameters;
      t1 = {};
      t2 = this.mainApp;
      if (t2 == null)
        return;
      main = t2.findExported$1("main");
      t1.errorElement_0 = null;
      if (main == null) {
        if (this.analyzeOnly) {
          if (!(this.analyzeAllFlag || false)) {
            t2 = P.LinkedHashMap_LinkedHashMap$_literal(["main", "main"], null, null);
            t3 = this.mainApp;
            t4 = $.ElementX_elementHashCode + 1;
            $.ElementX_elementHashCode = t4;
            t1.errorElement_0 = new U.ErroneousElementX(C.MessageKind_rti, t2, null, "main", C.ElementKind_error_0, t3, t4, C.C_Link2, null, false);
          }
        } else {
          t2 = P.LinkedHashMap_LinkedHashMap$_literal(["main", "main"], null, null);
          t3 = this.mainApp;
          t4 = $.ElementX_elementHashCode + 1;
          $.ElementX_elementHashCode = t4;
          t1.errorElement_0 = new U.ErroneousElementX(C.MessageKind_JJ0, t2, null, "main", C.ElementKind_error_0, t3, t4, C.C_Link2, null, false);
        }
        this.mainFunction = this.backend.helperForMissingMain$0();
      } else if (main.get$isErroneous() && main.get$isSynthesized()) {
        if (!!main.$isErroneousElement)
          t1.errorElement_0 = main;
        else
          this.internalError$2(main, "Problem with main.");
        this.mainFunction = this.backend.helperForBadMain$0();
      } else if (!main.get$isFunction()) {
        t2 = P.LinkedHashMap_LinkedHashMap$_literal(["main", "main"], null, null);
        t3 = $.ElementX_elementHashCode + 1;
        $.ElementX_elementHashCode = t3;
        t1.errorElement_0 = new U.ErroneousElementX(C.MessageKind_Q8B, t2, null, "main", C.ElementKind_error_0, main, t3, C.C_Link2, null, false);
        this.mainFunction = this.backend.helperForBadMain$0();
      } else {
        this.mainFunction = main;
        parameters = main.computeSignature$1(this);
        if (parameters.get$requiredParameterCount() > 2) {
          t1.index_1 = 0;
          t2 = new K.Compiler_computeMain_closure(t1, this, main);
          parameters.forEachRequiredParameter$1(t2);
          H.IterableMixinWorkaround_forEach(parameters.orderedOptionalParameters, t2);
        }
      }
      if (this.mainFunction == null) {
        t2 = t1.errorElement_0;
        if (t2 == null)
          if (!this.analyzeOnly)
            t3 = !(this.analyzeAllFlag || false);
          else
            t3 = false;
        else
          t3 = false;
        if (t3)
          this.internalError$2(this.mainApp, "Problem with 'main'.");
        else
          this.mainFunction = t2;
      }
      t2 = t1.errorElement_0;
      if (t2 != null && t2.get$isSynthesized()) {
        t2 = t1.errorElement_0;
        this.reportDiagnosticInternal$4(t2, t2.get$messageKind(), t1.errorElement_0.get$messageArguments(), C.Diagnostic_2_warning);
      }
    },
    compileLoadedLibraries$0: function() {
      var t1, t2, t3;
      this.computeMain$0();
      this.mirrorUsageAnalyzerTask.analyzeUsage$1(this.mainApp);
      this.deferredLoadTask.ensureMetadataResolved$1(this);
      this.phase = 1;
      t1 = !this.analyzeAllFlag;
      if (!t1 || false) {
        t2 = this.libraryLoader.libraryCanonicalUriMap;
        t2.get$values(t2).forEach$1(0, new K.Compiler_compileLoadedLibraries_closure(this));
      } else if (this.analyzeMain && this.mainApp != null)
        this.fullyEnqueueLibrary$2(this.mainApp, this.enqueuer.resolution);
      this.backend.enqueueHelpers$2(this.enqueuer.resolution, this.globalDependencies);
      this.resolveLibraryMetadata$0();
      this.log$1("Resolving...");
      this.processQueue$2(this.enqueuer.resolution, this.mainFunction);
      t2 = this.enqueuer.resolution;
      t3 = this.get$log();
      t2._logSpecificSummary$1(t3);
      t2.nativeEnqueuer.logSummary$1(t3);
      if (this.compilationFailed)
        return;
      if (!this.showPackageWarnings && !this.suppressWarnings)
        this.suppressedWarnings.forEach$1(0, new K.Compiler_compileLoadedLibraries_closure0(this));
      if (this.analyzeOnly) {
        if (!(!t1 || false))
          this.reportUnusedCode$0();
        return;
      }
      this.phase = 2;
      this.world.populate$0();
      this.backend.onResolutionComplete$0();
      this.deferredLoadTask.onResolutionComplete$1(this.mainFunction);
      this.log$1("Building IR...");
      this.irBuilder.buildNodes$0();
      this.log$1("Inferring types...");
      this.typesTask.onResolutionComplete$1(this.mainFunction);
      if (this.stopAfterTypeInference)
        return;
      this.log$1("Compiling...");
      this.phase = 3;
      if (this.hasIsolateSupport) {
        this.backend.enableIsolateSupport$1(this.enqueuer.codegen);
        this.enqueuer.codegen.registerGetOfStaticFunction$1(this.mainFunction);
      }
      if (this.enabledNoSuchMethod)
        this.backend.enableNoSuchMethod$2(null, this.enqueuer.codegen);
      this.processQueue$2(this.enqueuer.codegen, this.mainFunction);
      t1 = this.enqueuer.codegen;
      t2 = this.get$log();
      t1._logSpecificSummary$1(t2);
      t1.nativeEnqueuer.logSummary$1(t2);
      if (this.compilationFailed)
        return;
      this.backend.assembleProgram$0();
      if (this.dumpInfo)
        this.dumpInfoTask.dumpInfo$0();
      this.checkQueues$0();
      if (this.compilationFailed)
        this.assembledCode = null;
    },
    fullyEnqueueLibrary$2: function(library, world) {
      library.get$implementation(library).forEachLocalMember$1(new K.Compiler_fullyEnqueueLibrary_enqueueAll(this, world));
    },
    resolveLibraryMetadata$0: function() {
      var t1, library, t2, t3;
      for (t1 = this.libraryLoader.libraryCanonicalUriMap, t1 = t1.get$values(t1), t1 = H.setRuntimeTypeInfo(new H.MappedIterator(null, J.get$iterator$ax(t1._iterable), t1._f), [H.getTypeArgumentByIndex(t1, 0), H.getTypeArgumentByIndex(t1, 1)]); t1.moveNext$0();) {
        library = t1.__internal$_current;
        if (library.get$metadata() != null) {
          t2 = library.get$metadata();
          t2.toString;
          t3 = new E.LinkIterator(null, t2);
          t3.$builtinTypeInfo = [H.getTypeArgumentByIndex(t2, 0)];
          for (; t3.moveNext$0();)
            t3._util_implementation$_current.ensureResolved$1(this);
        }
      }
    },
    processQueue$2: function(world, main) {
      var t1, t2, t3;
      t1 = world.nativeEnqueuer;
      t2 = this.libraryLoader.libraryCanonicalUriMap;
      t1.processNativeClasses$1(t2.get$values(t2));
      if (main != null && !main.get$isErroneous()) {
        if (main.computeSignature$1(this).get$parameterCount() !== 0) {
          world.enableIsolateSupport$0();
          t1 = this.listClass;
          t2 = this.globalDependencies;
          t3 = world.compiler;
          t1.ensureResolved$1(t3);
          world.registerInstantiatedType$3$mirrorUsage(t1.get$rawType(), t2, false);
          t2 = this.stringClass;
          t1 = this.globalDependencies;
          t2.ensureResolved$1(t3);
          world.registerInstantiatedType$3$mirrorUsage(t2.get$rawType(), t1, false);
        }
        world.internalAddToWorkList$1(main);
      }
      this.progress.reset$0(0);
      world.forEach$1(0, new K.Compiler_processQueue_closure(this, world));
      world.queueIsClosed = true;
      if (this.compilationFailed)
        return;
    },
    checkQueues$0: function() {
      for (var t1 = this.enqueuer, t1 = [t1.resolution, t1.codegen], t1 = H.setRuntimeTypeInfo(new H.ListIterator(t1, 2, 0, null), [H.getTypeArgumentByIndex(t1, 0)]); t1.moveNext$0();)
        J.forEach$1$ax(t1.__internal$_current, new K.Compiler_checkQueues_closure(this));
      return;
    },
    analyzeElement$1: function(element) {
      var t1, t2, elements;
      t1 = this.enqueuer.resolution.resolvedElements;
      if (t1.contains$1(0, element.get$analyzableElement().get$declaration()))
        return;
      t2 = this.parser.parse$1(element) != null;
      if (t2)
        this.validator.toString;
      elements = this.resolver.resolve$1(element);
      if (elements != null) {
        if (t2 && !this.analyzeSignaturesOnly && !this.suppressWarnings)
          this.checker.check$1(elements);
        t1.add$1(0, element);
      }
    },
    analyze$2: function(work, world) {
      var t1, t2, t3, element;
      t1 = this.progress;
      t2 = t1.get$elapsedTicks();
      t3 = $.Stopwatch__frequency;
      if (typeof t3 !== "number")
        return H.iae(t3);
      if (C.JSInt_methods.$tdiv(t2 * 1000, t3) > 500)
        if (this.phase === 1) {
          this.log$1("Resolved " + this.enqueuer.resolution.resolvedElements._collection$_length + " elements.");
          t1.reset$0(0);
        }
      element = work.element;
      if (world.resolvedElements.contains$1(0, element.get$analyzableElement().get$declaration()))
        return;
      this.analyzeElement$1(element);
      this.backend.onElementResolved$2(element, element.get$resolvedAst().elements);
    },
    resolveSignature$1: function(element) {
      return this.withCurrentElement$2(element, new K.Compiler_resolveSignature_closure(this, element));
    },
    reportFatalError$3: function(node, messageKind, $arguments) {
      this.reportDiagnosticInternal$4(node, messageKind, $arguments, C.Diagnostic_1_error);
      throw H.wrapException(K.CompilerCancelledException$("Error: Cannot continue due to previous error."));
    },
    reportFatalError$2: function(node, messageKind) {
      return this.reportFatalError$3(node, messageKind, C.Map_empty);
    },
    reportDiagnosticInternal$4: function(node, messageKind, $arguments, kind) {
      var t1, element, info;
      if (!this.showPackageWarnings && !J.$eq(node, C._SpannableSentinel_fBD))
        switch (kind) {
          case C.Diagnostic_2_warning:
          case C.Diagnostic_4_hint:
            t1 = J.getInterceptor(node);
            if (!!t1.$isElement)
              element = node;
            else if (!!t1.$isHInstruction)
              element = !!J.getInterceptor(node.get$sourceElement()).$isElement ? node.get$sourceElement() : null;
            else
              element = !!t1.$isMetadataAnnotation ? node.get$annotatedElement() : null;
            element = element != null ? element : this._currentElement;
            if (!this.inUserCode$2$assumeInUserCode(element, true)) {
              info = this.suppressedWarnings.putIfAbsent$2(this.getCanonicalUri$1(element), new K.Compiler_reportDiagnosticInternal_closure());
              if (kind === C.Diagnostic_2_warning)
                info.warnings = info.get$warnings() + 1;
              else
                info.hints = info.get$hints() + 1;
              this.lastDiagnosticWasFiltered = true;
              return;
            }
            break;
          case C.Diagnostic_8_info:
            if (this.lastDiagnosticWasFiltered)
              return;
            break;
        }
      this.lastDiagnosticWasFiltered = false;
      messageKind.toString;
      this.reportDiagnostic$3(node, K.Message$(messageKind, $arguments, this.terseDiagnostics), kind);
    },
    reportAssertionFailure$1: function(ex) {
      var t1, message;
      t1 = ex.message;
      message = t1 != null ? this.tryToString$1(t1) : this.tryToString$1(ex);
      t1 = ex.node;
      this.spanFromSpannable$1(t1);
      this.reportDiagnosticInternal$4(t1, C.MessageKind_wwi, P.LinkedHashMap_LinkedHashMap$_literal(["text", message], null, null), C.Diagnostic_32_crash);
    },
    spanFromTokens$3: function(begin, end, uri) {
      var t1 = {};
      t1.uri_0 = uri;
      if (begin == null || end == null)
        throw H.wrapException("Cannot find tokens to produce error message.");
      if (uri == null && this._currentElement != null)
        t1.uri_0 = this._currentElement.get$compilationUnit().get$script().readableUri;
      return new K.Compiler_spanFromTokens_closure(t1).call$2(begin.charOffset, end.charOffset + end.get$charCount());
    },
    spanFromTokens$2: function(begin, end) {
      return this.spanFromTokens$3(begin, end, null);
    },
    spanFromElement$1: function(element) {
      var t1, position, uri;
      while (true) {
        t1 = element != null;
        if (!(t1 && element.get$isSynthesized()))
          break;
        element = element.get$enclosingElement();
      }
      if (t1 && element.get$position(element) == null && element.get$kind(element) !== C.ElementKind_library_0 && element.kind !== C.ElementKind_compilation_unit_0)
        element = element.get$enclosingElement();
      if (element == null)
        element = this._currentElement;
      position = element.get$position(element);
      uri = element.get$compilationUnit().get$script().readableUri;
      return position == null ? new K.SourceSpan(uri, 0, 0) : this.spanFromTokens$3(position, position, uri);
    },
    spanFromHInstruction$1: function(instruction) {
      var element, position, token;
      element = !!J.getInterceptor(instruction.get$sourceElement()).$isElement ? instruction.get$sourceElement() : null;
      if (element == null)
        element = this._currentElement;
      position = instruction.sourcePosition;
      if (position == null)
        return this.spanFromElement$1(element);
      token = position.token;
      if (token == null)
        return this.spanFromElement$1(element);
      return this.spanFromTokens$3(token, token, element.get$compilationUnit().get$script().readableUri);
    },
    translateResolvedUri$3: function(importingLibrary, resolvedUri, node) {
      this.internalError$2(importingLibrary, "Compiler.translateResolvedUri not implemented.");
    },
    readScript$2: function(node, readableUri) {
      this.internalError$2(node, "Compiler.readScript not implemented.");
    },
    lookupElementIn$2: function(container, $name) {
      var element = container.localLookup$1($name);
      if (element == null)
        throw H.wrapException("Could not find " + $name + " in " + container.toString$0(0));
      return element;
    },
    get$isMockCompilation: function() {
      return false;
    },
    processAndStripComments$1: function(currentToken) {
      var t1, firstToken, prevToken, currentToken0;
      for (t1 = this.commentMap, firstToken = currentToken, prevToken = null; currentToken.get$info().kind !== 0; prevToken = currentToken, currentToken = currentToken0) {
        if (currentToken.get$info().kind === 158) {
          for (currentToken0 = currentToken; currentToken0.get$info().kind === 158;)
            currentToken0 = currentToken0.next;
          t1.$indexSet(0, currentToken0, currentToken);
          if (prevToken == null)
            firstToken = currentToken0;
          else
            prevToken.next = currentToken0;
          currentToken = currentToken0;
        }
        currentToken0 = currentToken.next;
      }
      return firstToken;
    },
    reportUnusedCode$0: function() {
      var t1 = this.libraryLoader.libraryCanonicalUriMap;
      t1.get$values(t1).forEach$1(0, new K.Compiler_reportUnusedCode_closure(new K.Compiler_reportUnusedCode_checkLive(this)));
    },
    inUserCode$2$assumeInUserCode: function(element, assumeInUserCode) {
      var entrypoints, t1, libraryUri, t2, uri, slashPos, packageName;
      entrypoints = H.setRuntimeTypeInfo([], [P.Uri]);
      t1 = this.mainApp;
      if (t1 != null)
        entrypoints.push(t1.get$canonicalUri());
      if (entrypoints.length === 0 && assumeInUserCode)
        return true;
      if (element == null)
        return false;
      libraryUri = element.get$library().canonicalUri;
      t1 = libraryUri.scheme;
      if (t1 === "package")
        for (t1 = H.setRuntimeTypeInfo(new H.ListIterator(entrypoints, entrypoints.length, 0, null), [H.getTypeArgumentByIndex(entrypoints, 0)]), t2 = libraryUri._path; t1.moveNext$0();) {
          uri = t1.__internal$_current;
          if (uri.get$scheme() !== "package")
            continue;
          slashPos = C.JSString_methods.indexOf$1(t2, "/");
          if (slashPos !== -1) {
            packageName = C.JSString_methods.substring$2(t2, 0, slashPos + 1);
            if (C.JSString_methods.startsWith$1(uri._path, packageName))
              return true;
          } else if (t2 === uri._path)
            return true;
        }
      else
        for (t2 = H.setRuntimeTypeInfo(new H.ListIterator(entrypoints, entrypoints.length, 0, null), [H.getTypeArgumentByIndex(entrypoints, 0)]); t2.moveNext$0();)
          if (t1 === t2.__internal$_current.get$scheme())
            return true;
      return false;
    },
    getCanonicalUri$1: function(element) {
      var libraryUri, t1, slashPos;
      if (element == null)
        return;
      libraryUri = element.get$library().canonicalUri;
      if (libraryUri.scheme === "package") {
        t1 = libraryUri._path;
        slashPos = C.JSString_methods.indexOf$1(t1, "/");
        if (slashPos !== -1)
          return P.Uri_Uri(null, null, C.JSString_methods.substring$2(t1, 0, slashPos), null, null, null, null, "package", "");
      }
      return libraryUri;
    },
    Compiler$27$analyzeAllFlag$analyzeMain$analyzeOnly$analyzeSignaturesOnly$buildId$disableTypeInferenceFlag$dumpInfo$emitJavaScript$enableConcreteTypeInference$enableMinification$enableNativeLiveTypeAnalysis$enableTypeAssertions$enableUserAssertions$generateSourceMap$hasIncrementalSupport$maxConcreteTypeSize$outputProvider$outputUri$preserveComments$showPackageWarnings$sourceMapUri$strips$suppressWarnings$terseDiagnostics$trustTypeAnnotations$useContentSecurityPolicy$verbose: function(analyzeAllFlag, analyzeMain, analyzeOnly, analyzeSignaturesOnly, buildId, disableTypeInferenceFlag, dumpInfo, emitJavaScript, enableConcreteTypeInference, enableMinification, enableNativeLiveTypeAnalysis, enableTypeAssertions, enableUserAssertions, generateSourceMap, hasIncrementalSupport, maxConcreteTypeSize, outputProvider, outputUri, preserveComments, showPackageWarnings, sourceMapUri, strips, suppressWarnings, terseDiagnostics, trustTypeAnnotations, useContentSecurityPolicy, verbose) {
      var t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, map, t15, t16, t17, t18, t19, t20, closureNamer, t21, jsBackend, t22, t23, t24, t25, t26, t27, t28, t29, t30, t31, t32, t33, t34, t35, t36, t37, t38, t39, t40, t41, t42, t43, t44, t45, t46, t47, t48, t49, t50, t51, t52, t53, t54, t55, t56, t57, t58, t59;
      t1 = P.LinkedHashSet_LinkedHashSet(null, null, null, O.Element);
      t2 = P.LinkedHashMap_LinkedHashMap(null, null, null, O.Element, Z.SideEffects);
      t3 = P.LinkedHashSet_LinkedHashSet(null, null, null, O.TypedefElement);
      t4 = P.LinkedHashMap_LinkedHashMap(null, null, null, O.ClassElement, [P.Set, O.MixinApplicationElement]);
      t5 = P.LinkedHashMap_LinkedHashMap(null, null, null, O.ClassElement, [P.Set, O.ClassElement]);
      t6 = P.LinkedHashMap_LinkedHashMap(null, null, null, O.ClassElement, [P.Set, O.ClassElement]);
      t7 = P.LinkedHashMap_LinkedHashMap(null, null, null, O.ClassElement, [P.Set, O.ClassElement]);
      t8 = P.LinkedHashMap_LinkedHashMap(null, null, null, O.ClassElement, [P.Set, O.ClassElement]);
      t9 = P.LinkedHashSet_LinkedHashSet(null, null, null, O.Element);
      t10 = P.LinkedHashSet_LinkedHashSet(null, null, null, O.Element);
      t11 = P.LinkedHashSet_LinkedHashSet(null, null, null, O.FunctionElement);
      t12 = P.LinkedHashMap_LinkedHashMap(null, null, null, P.String, Z.FunctionSetNode);
      t13 = this.cacheStrategy.hasIncrementalSupport;
      t14 = t13 ? H.setRuntimeTypeInfo(new P._IdentityHashSet(0, null, null, null, null), [null]) : null;
      this.world = new K.World(this, new Z.FunctionSet(this, t12), t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t14);
      this.types = new V.Types(this, new V.MoreSpecificVisitor(this), new V.SubtypeVisitor(this), new V.PotentialSubtypeVisitor(this));
      this.tracer = new Z.Tracer(null, null, false, null, false, new O.Indentation(0, H.setRuntimeTypeInfo([""], [P.String]), "  "));
      t1 = $.TreeElementMapping__hashCodeCounter + 1;
      $.TreeElementMapping__hashCodeCounter = t1;
      this.globalDependencies = new K.CodegenRegistry(this, new A.TreeElementMapping(null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, t1));
      if (emitJavaScript) {
        t1 = P.LinkedHashMap_LinkedHashMap(null, null, null, O.FunctionElement, P.bool);
        t2 = P.LinkedHashMap_LinkedHashMap(null, null, null, O.FunctionElement, P.bool);
        t3 = P.LinkedHashMap_LinkedHashMap(null, null, null, P.String, [P.Set, O.Element]);
        t4 = P.LinkedHashSet_LinkedHashSet(null, null, null, O.ClassElement);
        t5 = P.LinkedHashSet_LinkedHashSet(null, null, null, O.ClassElement);
        t6 = P.LinkedHashSet_LinkedHashSet(null, null, null, O.ClassElement);
        t7 = H.setRuntimeTypeInfo([], [Z.Dependency]);
        t8 = P.LinkedHashSet_LinkedHashSet(null, null, null, O.Element);
        t9 = P.LinkedHashSet_LinkedHashSet(null, null, null, O.Element);
        t10 = P.LinkedHashSet_LinkedHashSet(null, null, null, P.String);
        t11 = P.LinkedHashSet_LinkedHashSet(null, null, null, O.Element);
        map = P.LinkedHashMap_LinkedHashMap(null, null, null, P.String, Z.CheckedModeHelper);
        P.Maps__fillMapWithMappedIterable(map, C.List_4vz, new Z.closure(), null);
        t12 = P.LinkedHashMap_LinkedHashMap(null, null, null, P.String, [P.Set, O.ClassElement]);
        if (this.enableMinification) {
          t14 = P.LinkedHashMap_LinkedHashMap(null, null, null, V.FunctionType, P.String);
          t15 = P.LinkedHashMap_LinkedHashMap(null, null, null, O.Element, P.String);
          t16 = P.LinkedHashMap_LinkedHashMap(null, null, null, P.String, O.LibraryElement);
          t17 = P.LinkedHashSet_LinkedHashSet(null, null, null, P.String);
          t18 = P.LinkedHashSet_LinkedHashSet(null, null, null, P.String);
          t19 = P.LinkedHashMap_LinkedHashMap(null, null, null, P.String, P.String);
          t20 = P.LinkedHashMap_LinkedHashMap(null, null, null, P.String, P.String);
          t14 = new Z.MinifyNamer("g", "s", "", null, null, "$", "get$", "set$", "@", "call", "call$catchAll", "$reflectable", "$defaultValues", "$methodsWithOptionalArguments", "^", "%", this, t15, t16, t17, t18, P.LinkedHashMap_LinkedHashMap(null, null, null, P.String, P.String), P.LinkedHashMap_LinkedHashMap(null, null, null, P.String, P.String), t19, P.LinkedHashMap_LinkedHashMap(null, null, null, P.String, P.String), t20, P.LinkedHashMap_LinkedHashMap(null, null, null, P.String, P.$int), P.LinkedHashMap_LinkedHashMap(null, null, null, K.Constant, P.String), P.LinkedHashMap_LinkedHashMap(null, null, null, K.Constant, P.String), new Z.ConstantCanonicalHasher(this, P.LinkedHashMap_LinkedHashMap(null, null, null, K.Constant, P.$int)), t14, new Z.FunctionTypeNamer(this, null));
          t14.reserveBackendNames$0();
          closureNamer = t14;
        } else {
          t14 = Z.Namer$(this);
          closureNamer = t14;
        }
        t14 = P.LinkedHashMap_LinkedHashMap(null, null, null, P.String, Z.Selector);
        t15 = P.LinkedHashMap_LinkedHashMap(null, null, null, P.String, [P.Set, O.Element]);
        t16 = P.LinkedHashSet_LinkedHashSet(null, null, null, O.ClassElement);
        t17 = P.LinkedHashSet_LinkedHashSet(null, null, null, O.Element);
        t18 = P.LinkedHashMap_LinkedHashMap(null, null, null, O.ClassElement, [P.Set, O.ClassElement]);
        t19 = P.LinkedHashSet_LinkedHashSet(null, null, null, O.ClassElement);
        t20 = P.LinkedHashSet_LinkedHashSet(null, null, null, V.DartType);
        t21 = P.LinkedHashSet_LinkedHashSet(null, null, null, V.DartType);
        jsBackend = new Z.JavaScriptBackend(null, null, null, null, new Z.FunctionInlineCache(t1, t2), null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, false, false, null, closureNamer, null, t14, t15, t3, P.LinkedHashMap_LinkedHashMap(null, null, null, P.String, [P.Set, O.ClassElement]), t4, t5, t6, new Z.RuntimeTypes(this, new Z.TypeRepresentationGenerator(this, null), t18, t16, t17, t19, t20, t21, null, null, null, false, null), null, null, null, null, null, null, false, false, false, false, false, false, false, false, false, t7, t8, t9, null, t10, t11, map, null, 0, null, null, null, t12, this, C.List_empty);
        jsBackend.JavaScriptBackend$2(this, generateSourceMap);
        this.backend = jsBackend;
      } else {
        closureNamer = new Q.ClosureNamer();
        t1 = P.LinkedHashSet_LinkedHashSet(null, null, null, O.ClassElement);
        t2 = H.setRuntimeTypeInfo([], [K.CompilerTask]);
        t3 = P.LinkedHashMap_LinkedHashMap(null, null, null, Y.ClassNode, [P.List, Y.Node]);
        t4 = H.Lists_indexOf(strips, "types", 0, strips.length);
        t5 = H.Lists_indexOf(strips, "asserts", 0, strips.length);
        t6 = P.LinkedHashMap_LinkedHashMap(null, null, null, O.VariableElement, K.Constant);
        t7 = P.LinkedHashSet_LinkedHashSet(null, null, null, O.VariableElement);
        if (this.verbose) {
          t8 = new P.Stopwatch(null, null);
          H.Primitives_initTicker();
          $.Stopwatch__frequency = $.Primitives_timerFrequency;
        } else
          t8 = null;
        t1 = new G.DartBackend(t2, t4 !== -1, t5 !== -1, false, t3, null, false, null, null, null, null, new G.DartConstantTask(new K.DartConstantCompiler(this, C.DartConstantSystem_CJj, t6, t7), this, t8, null), null, t1, this, C.List_empty);
        t1.DartBackend$2(this, strips);
        this.backend = t1;
      }
      t1 = this.verbose;
      if (t1) {
        t2 = new P.Stopwatch(null, null);
        H.Primitives_initTicker();
        $.Stopwatch__frequency = $.Primitives_timerFrequency;
      } else
        t2 = null;
      this.validator = new K.TreeValidatorTask(this, t2, null);
      t2 = P.LinkedHashMap_LinkedHashMap(null, null, null, P.Uri, O.LibraryElement);
      t3 = P.LinkedHashMap_LinkedHashMap(null, null, null, P.Uri, O.LibraryElement);
      t4 = P.LinkedHashMap_LinkedHashMap(null, null, null, P.String, O.LibraryElement);
      if (t1) {
        t5 = new P.Stopwatch(null, null);
        H.Primitives_initTicker();
        $.Stopwatch__frequency = $.Primitives_timerFrequency;
      } else
        t5 = null;
      t5 = new Z._LibraryLoaderTask(t2, t3, t4, null, this, t5, null);
      this.libraryLoader = t5;
      if (t1) {
        t2 = new P.Stopwatch(null, null);
        H.Primitives_initTicker();
        $.Stopwatch__frequency = $.Primitives_timerFrequency;
      } else
        t2 = null;
      t2 = new Y.ScannerTask(this, t2, null);
      this.scanner = t2;
      if (t1) {
        t3 = new P.Stopwatch(null, null);
        H.Primitives_initTicker();
        $.Stopwatch__frequency = $.Primitives_timerFrequency;
      } else
        t3 = null;
      t3 = new Y.DietParserTask("Diet Parser", this, t3, null);
      this.dietParser = t3;
      if (t1) {
        t4 = new P.Stopwatch(null, null);
        H.Primitives_initTicker();
        $.Stopwatch__frequency = $.Primitives_timerFrequency;
      } else
        t4 = null;
      t4 = new Y.ParserTask(this, t4, null);
      this.parser = t4;
      if (t1) {
        t6 = new P.Stopwatch(null, null);
        H.Primitives_initTicker();
        $.Stopwatch__frequency = $.Primitives_timerFrequency;
      } else
        t6 = null;
      t6 = new S.PatchParserTask("Patching Parser", this, t6, null);
      this.patchParser = t6;
      t7 = this.backend.get$constantCompilerTask();
      t8 = O.ClassElement;
      t9 = H.setRuntimeTypeInfo(new P.ListQueue(null, 0, 0, 0), [t8]);
      t9.ListQueue$1(null, t8);
      t8 = O.ClassElement;
      t10 = H.setRuntimeTypeInfo(new P.ListQueue(null, 0, 0, 0), [t8]);
      t10.ListQueue$1(null, t8);
      if (t1) {
        t8 = new P.Stopwatch(null, null);
        H.Primitives_initTicker();
        $.Stopwatch__frequency = $.Primitives_timerFrequency;
      } else
        t8 = null;
      t8 = new A.ResolverTask(t7, null, t9, t10, this, t8, null);
      this.resolver = t8;
      t10 = P.LinkedHashMap_LinkedHashMap(null, null, null, Y.Node, Q.ClosureClassMap);
      if (t1) {
        t7 = new P.Stopwatch(null, null);
        H.Primitives_initTicker();
        $.Stopwatch__frequency = $.Primitives_timerFrequency;
      } else
        t7 = null;
      t7 = new Q.ClosureTask(t10, closureNamer, this, t7, null);
      this.closureToClassMapper = t7;
      if (t1) {
        t9 = new P.Stopwatch(null, null);
        H.Primitives_initTicker();
        $.Stopwatch__frequency = $.Primitives_timerFrequency;
      } else
        t9 = null;
      t9 = new K.TypeCheckerTask(this, t9, null);
      this.checker = t9;
      t10 = P.LinkedHashMap_LinkedHashMap$_empty(O.Element, D.FunctionDefinition);
      if (t1) {
        t11 = new P.Stopwatch(null, null);
        H.Primitives_initTicker();
        $.Stopwatch__frequency = $.Primitives_timerFrequency;
      } else
        t11 = null;
      t11 = new K.IrBuilderTask(t10, this, t11, null);
      this.irBuilder = t11;
      if (t1) {
        t10 = new P.Stopwatch(null, null);
        H.Primitives_initTicker();
        $.Stopwatch__frequency = $.Primitives_timerFrequency;
      } else
        t10 = null;
      t10 = new B.TypesTask("Type inference", null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, this, t10, null);
      t10.TypesTask$1(this);
      this.typesTask = t10;
      t12 = this.backend.get$constantCompilerTask();
      this.constants = t12;
      t14 = $.Node__HASH_COUNTER + 1;
      $.Node__HASH_COUNTER = t14;
      t15 = t14 + 1;
      $.Node__HASH_COUNTER = t15;
      t16 = H.setRuntimeTypeInfo(new N.Setlet(C.C__SetletMarker, null), [Y.Import]);
      t17 = P.LinkedHashSet_LinkedHashSet(null, null, null, B.OutputUnit);
      t18 = P.LinkedHashMap_LinkedHashMap(null, null, null, P.String, [P.List, [P.List, B.OutputUnit]]);
      t19 = P.LinkedHashMap_LinkedHashMap(null, null, null, Y.Import, P.String);
      t20 = P.LinkedHashMap_LinkedHashMap(null, null, null, O.Element, B.OutputUnit);
      t21 = P.LinkedHashMap_LinkedHashMap(null, null, null, K.Constant, B.OutputUnit);
      t22 = P.LinkedHashMap_LinkedHashMap(null, null, null, Y.Import, O.LibraryElement);
      t23 = P.LinkedHashSet_LinkedHashSet(null, null, null, O.Element);
      if (t1) {
        t24 = new P.Stopwatch(null, null);
        H.Primitives_initTicker();
        $.Stopwatch__frequency = $.Primitives_timerFrequency;
      } else
        t24 = null;
      t24 = new B.DeferredLoadTask(new Y.Import(null, null, null, new Y.LiteralString(null, new Y.LiteralDartString("main"), t14), null, null, t15), new B.OutputUnit(t16, null), t17, false, t18, t19, t20, t21, t22, null, null, t23, this, t24, null);
      this.deferredLoadTask = t24;
      if (t1) {
        t14 = new P.Stopwatch(null, null);
        H.Primitives_initTicker();
        $.Stopwatch__frequency = $.Primitives_timerFrequency;
      } else
        t14 = null;
      t14 = new F.MirrorUsageAnalyzerTask(null, null, this, t14, null);
      t14.analyzer = F.MirrorUsageAnalyzer$(this, t14);
      this.mirrorUsageAnalyzerTask = t14;
      t15 = this.backend.get$createItemCompilationContext();
      t16 = P.LinkedHashMap_LinkedHashMap(null, null, null, P.String, [O.Link, O.Element]);
      t17 = P.LinkedHashMap_LinkedHashMap(null, null, null, P.String, [O.Link, O.Element]);
      t18 = P.LinkedHashSet_LinkedHashSet(null, null, null, O.ClassElement);
      t19 = H.setRuntimeTypeInfo(new N.Setlet(C.C__SetletMarker, null), [O.ClassElement]);
      t20 = P.LinkedHashSet_LinkedHashSet(null, null, null, O.ClassElement);
      t21 = P.LinkedHashSet_LinkedHashSet(null, null, null, V.DartType);
      t22 = P.LinkedHashSet_LinkedHashSet(null, null, null, O.FunctionElement);
      t23 = P.LinkedHashSet_LinkedHashSet(null, null, null, O.FunctionElement);
      t25 = P.LinkedHashMap_LinkedHashMap(null, null, null, P.String, [P.Set, Z.Selector]);
      t26 = P.LinkedHashMap_LinkedHashMap(null, null, null, P.String, [P.Set, Z.Selector]);
      t27 = P.LinkedHashMap_LinkedHashMap(null, null, null, P.String, [P.Set, Z.Selector]);
      t28 = P.LinkedHashSet_LinkedHashSet(null, null, null, O.Element);
      t29 = P.LinkedHashSet_LinkedHashSet(null, null, null, O.Element);
      t30 = P.LinkedHashSet_LinkedHashSet(null, null, null, V.DartType);
      t31 = P.LinkedHashSet_LinkedHashSet(null, null, null, O.Element);
      t32 = P.LinkedHashSet_LinkedHashSet(null, null, null, O.Element);
      t33 = P.LinkedHashSet_LinkedHashSet(null, null, null, O.LocalFunctionElement);
      t34 = P.LinkedHashSet_LinkedHashSet(null, null, null, O.Element);
      t35 = P.LinkedHashSet_LinkedHashSet(null, null, null, O.AstElement);
      t36 = K.ResolutionWorkItem;
      t37 = H.setRuntimeTypeInfo(new P.ListQueue(null, 0, 0, 0), [t36]);
      t37.ListQueue$1(null, t36);
      t36 = K.DeferredTask;
      t38 = H.setRuntimeTypeInfo(new P.ListQueue(null, 0, 0, 0), [t36]);
      t38.ListQueue$1(null, t36);
      t36 = this.backend.get$createItemCompilationContext();
      t39 = P.LinkedHashMap_LinkedHashMap(null, null, null, O.Element, Q.Expression);
      t40 = K.CodegenWorkItem;
      t41 = H.setRuntimeTypeInfo(new P.ListQueue(null, 0, 0, 0), [t40]);
      t41.ListQueue$1(null, t40);
      t13 = t13 ? H.setRuntimeTypeInfo(new P._IdentityHashSet(0, null, null, null, null), [null]) : null;
      t40 = P.LinkedHashMap_LinkedHashMap(null, null, null, P.String, [O.Link, O.Element]);
      t42 = P.LinkedHashMap_LinkedHashMap(null, null, null, P.String, [O.Link, O.Element]);
      t43 = P.LinkedHashSet_LinkedHashSet(null, null, null, O.ClassElement);
      t44 = H.setRuntimeTypeInfo(new N.Setlet(C.C__SetletMarker, null), [O.ClassElement]);
      t45 = P.LinkedHashSet_LinkedHashSet(null, null, null, O.ClassElement);
      t46 = P.LinkedHashSet_LinkedHashSet(null, null, null, V.DartType);
      t47 = P.LinkedHashSet_LinkedHashSet(null, null, null, O.FunctionElement);
      t48 = P.LinkedHashSet_LinkedHashSet(null, null, null, O.FunctionElement);
      t49 = P.LinkedHashMap_LinkedHashMap(null, null, null, P.String, [P.Set, Z.Selector]);
      t50 = P.LinkedHashMap_LinkedHashMap(null, null, null, P.String, [P.Set, Z.Selector]);
      t51 = P.LinkedHashMap_LinkedHashMap(null, null, null, P.String, [P.Set, Z.Selector]);
      t52 = P.LinkedHashSet_LinkedHashSet(null, null, null, O.Element);
      t53 = P.LinkedHashSet_LinkedHashSet(null, null, null, O.Element);
      t54 = P.LinkedHashSet_LinkedHashSet(null, null, null, V.DartType);
      t55 = P.LinkedHashSet_LinkedHashSet(null, null, null, O.Element);
      t56 = P.LinkedHashSet_LinkedHashSet(null, null, null, O.Element);
      t57 = P.LinkedHashSet_LinkedHashSet(null, null, null, O.LocalFunctionElement);
      t58 = P.LinkedHashSet_LinkedHashSet(null, null, null, O.Element);
      if (t1) {
        t59 = new P.Stopwatch(null, null);
        H.Primitives_initTicker();
        $.Stopwatch__frequency = $.Primitives_timerFrequency;
      } else
        t59 = null;
      t59 = new K.EnqueueTask(new K.ResolutionEnqueuer(t35, t37, t38, "resolution enqueuer", this, t15, t16, t17, t18, t19, new Z.Universe(t20, t21, t22, t23, t25, t26, t27, t28, t29, t30, t31, t32, t33, t34, false), false, null, null, false, false), new K.CodegenEnqueuer(t41, t39, t13, "codegen enqueuer", this, t36, t40, t42, t43, t44, new Z.Universe(t45, t46, t47, t48, t49, t50, t51, t52, t53, t54, t55, t56, t57, t58, false), false, null, null, false, false), this, t59, null);
      t59.EnqueueTask$1(this);
      this.enqueuer = t59;
      t58 = P.LinkedHashSet_LinkedHashSet(null, null, null, Q.Node0);
      t57 = P.LinkedHashMap_LinkedHashMap$_empty(O.Element, [P.List, Q.Node0]);
      t56 = P.LinkedHashMap_LinkedHashMap$_empty(Q.Node0, P.$int);
      t55 = P.LinkedHashMap_LinkedHashMap$_empty(Q.Node0, P.$int);
      t54 = P.LinkedHashMap_LinkedHashMap$_empty(O.Element, P.$int);
      t53 = P.LinkedHashMap_LinkedHashMap$_empty(null, null);
      if (t1) {
        t1 = new P.Stopwatch(null, null);
        H.Primitives_initTicker();
        $.Stopwatch__frequency = $.Primitives_timerFrequency;
      } else
        t1 = null;
      t1 = new E.DumpInfoTask("Dump Info", null, t58, t57, t56, t55, t54, t53, this, t1, null);
      this.dumpInfoTask = t1;
      t1 = [t5, t2, t3, t4, t6, t8, t7, t9, t11, t10, t12, t24, t14, t59, t1];
      this.tasks = t1;
      C.JSArray_methods.addAll$1(t1, this.backend.get$tasks());
    }
  },
  Compiler_run_closure0: {
    "^": "Closure:23;this_0,uri_1",
    call$0: function() {
      return this.this_0.runCompiler$1(this.uri_1);
    },
    $isFunction: true
  },
  Compiler_run_closure1: {
    "^": "Closure:13;this_2,uri_3",
    call$1: function(error) {
      var t1, exception;
      if (!!J.getInterceptor(error).$isCompilerCancelledException) {
        t1 = this.this_2;
        t1.compilerWasCancelled = true;
        t1.log$1("Error: " + H.S(error));
        return false;
      }
      try {
        t1 = this.this_2;
        if (!t1.hasCrashed) {
          t1.hasCrashed = true;
          if (!!J.getInterceptor(error).$isSpannableAssertionFailure)
            t1.reportAssertionFailure$1(error);
          else
            t1.reportDiagnostic$3(new K.SourceSpan(this.uri_3, 0, 0), K.Message$(C.MessageKind_WR8, C.Map_empty, false), C.Diagnostic_32_crash);
          P.print(K.Message$(C.MessageKind_u5H, P.LinkedHashMap_LinkedHashMap$_literal(["buildId", t1.buildId], null, null), false));
        }
      } catch (exception) {
        H.unwrapException(exception);
      }

      throw H.wrapException(error);
    },
    $isFunction: true
  },
  Compiler_run_closure2: {
    "^": "Closure:23;this_4",
    call$0: function() {
      var t1, t2;
      t1 = this.this_4;
      t2 = t1.tracer.output;
      if (t2 != null)
        t2.close$0(0);
      t1.totalCompileTime.stop$0(0);
    },
    $isFunction: true
  },
  Compiler_run_closure3: {
    "^": "Closure:13;this_5",
    call$1: function(_) {
      return !this.this_5.compilationFailed;
    },
    $isFunction: true
  },
  Compiler_onLibrariesLoaded_closure: {
    "^": "Closure:23;this_0,loadedLibraries_1",
    call$0: function() {
      var t1, t2, jsHelperLibrary;
      t1 = this.loadedLibraries_1;
      if (!t1.containsKey$1($.get$Compiler_DART_CORE()))
        return P._Future$immediate(null, null);
      t2 = this.this_0;
      t2.functionClass.ensureResolved$1(t2);
      t2.functionApplyMethod = t2.functionClass.lookupLocalMember$1("apply");
      t2.proxyConstant = t2.resolver.constantCompiler.compileConstant$1(t2.coreLibrary.find$1(0, "proxy"));
      jsHelperLibrary = t1.$index(0, $.get$JavaScriptBackend_DART_JS_HELPER());
      if (jsHelperLibrary != null)
        t2.patchConstant = t2.resolver.constantCompiler.compileConstant$1(jsHelperLibrary.find$1(0, "patch"));
      if (t2.preserveComments)
        return t2.libraryLoader.loadLibrary$1($.get$Compiler_DART_MIRRORS()).then$1(new K.Compiler_onLibrariesLoaded__closure(t2));
    },
    $isFunction: true
  },
  Compiler_onLibrariesLoaded__closure: {
    "^": "Closure:79;this_2",
    call$1: function(libraryElement) {
      this.this_2.documentClass = J.find$1$x(libraryElement, "Comment");
    },
    $isFunction: true
  },
  Compiler_onLibrariesLoaded_closure0: {
    "^": "Closure:13;this_3,loadedLibraries_4",
    call$1: function(_) {
      return this.this_3.backend.onLibrariesLoaded$1(this.loadedLibraries_4);
    },
    $isFunction: true
  },
  Compiler_initializeCoreClasses_lookupCoreClass: {
    "^": "Closure:80;this_0,missingCoreClasses_1",
    call$1: function($name) {
      var result = this.this_0.coreLibrary.find$1(0, $name);
      if (result == null)
        this.missingCoreClasses_1.push($name);
      return result;
    },
    $isFunction: true
  },
  Compiler_runCompiler_closure: {
    "^": "Closure:23;this_0",
    call$0: function() {
    },
    $isFunction: true
  },
  Compiler_runCompiler__closure0: {
    "^": "Closure:13;this_1",
    call$1: function(libraryUri) {
      var t1 = this.this_1;
      t1.log$1("Analyzing " + H.S(libraryUri) + " (" + H.S(t1.buildId) + ")");
      return t1.libraryLoader.loadLibrary$1(libraryUri);
    },
    $isFunction: true
  },
  Compiler_runCompiler_closure0: {
    "^": "Closure:13;this_2,uri_3",
    call$1: function(_) {
      var t1, t2, t3, t4;
      t1 = this.uri_3;
      if (t1 != null) {
        t2 = this.this_2;
        t3 = J.getInterceptor(t1);
        t4 = t2.buildId;
        if (t2.analyzeOnly)
          t2.log$1("Analyzing " + t3.toString$0(t1) + " (" + H.S(t4) + ")");
        else
          t2.log$1("Compiling " + t3.toString$0(t1) + " (" + H.S(t4) + ")");
        return t2.libraryLoader.loadLibrary$1(t1).then$1(new K.Compiler_runCompiler__closure(t2));
      }
    },
    $isFunction: true
  },
  Compiler_runCompiler__closure: {
    "^": "Closure:79;this_4",
    call$1: function(library) {
      this.this_4.mainApp = library;
    },
    $isFunction: true
  },
  Compiler_runCompiler_closure1: {
    "^": "Closure:13;this_5",
    call$1: function(_) {
      var t1 = this.this_5;
      if (!t1.compilationFailed)
        t1.compileLoadedLibraries$0();
    },
    $isFunction: true
  },
  Compiler_computeMain_closure: {
    "^": "Closure:77;box_0,this_1,main_2",
    call$1: function(parameter) {
      var t1, t2, t3;
      t1 = this.box_0;
      if (t1.index_1++ < 2)
        return;
      t2 = P.LinkedHashMap_LinkedHashMap$_literal(["main", "main"], null, null);
      t3 = $.ElementX_elementHashCode + 1;
      $.ElementX_elementHashCode = t3;
      t1.errorElement_0 = new U.ErroneousElementX(C.MessageKind_ird, t2, null, "main", C.ElementKind_error_0, parameter, t3, C.C_Link2, null, false);
      t3 = this.this_1;
      t3.mainFunction = t3.backend.helperForMainArity$0();
      t3.enqueuer.resolution.registerStaticUse$1(this.main_2);
    },
    $isFunction: true
  },
  Compiler_compileLoadedLibraries_closure: {
    "^": "Closure:79;this_0",
    call$1: function(library) {
      var t1 = this.this_0;
      t1.log$1("Enqueuing " + library.get$canonicalUri().toString$0(0));
      t1.fullyEnqueueLibrary$2(library, t1.enqueuer.resolution);
    },
    $isFunction: true
  },
  Compiler_compileLoadedLibraries_closure0: {
    "^": "Closure:81;this_1",
    call$2: function(uri, info) {
      var kind, t1;
      if (info.get$warnings() === 0)
        kind = C.MessageKind_2Vk0;
      else
        kind = info.hints === 0 ? C.MessageKind_PPt : C.MessageKind_YZe;
      t1 = this.this_1;
      t1.reportDiagnostic$3(null, K.Message$(kind, P.LinkedHashMap_LinkedHashMap$_literal(["warnings", info.warnings, "hints", info.hints, "uri", uri], null, null), t1.terseDiagnostics), C.Diagnostic_4_hint);
    },
    $isFunction: true
  },
  Compiler_compileLoadedLibraries_closure1: {
    "^": "Closure:79;this_2",
    call$1: function(library) {
      var t1 = this.this_2;
      t1.fullyEnqueueLibrary$2(library, t1.enqueuer.codegen);
    },
    $isFunction: true
  },
  Compiler_fullyEnqueueLibrary_enqueueAll: {
    "^": "Closure:47;this_0,world_1",
    call$1: function(element) {
      var t1, t2;
      t1 = this.this_0;
      t2 = this.world_1;
      if (J.get$kind$x(element) === C.ElementKind_class_4) {
        element.ensureResolved$1(t1);
        element.forEachLocalMember$1(t1.enqueuer.resolution.get$addToWorkList());
        t1 = t1.globalDependencies;
        element.ensureResolved$1(t2.compiler);
        t2.registerInstantiatedType$3$mirrorUsage(element.get$rawType(), t1, false);
      } else
        t2.internalAddToWorkList$1(element);
    },
    $isFunction: true
  },
  Compiler_processQueue_closure: {
    "^": "Closure:82;this_0,world_1",
    call$1: function(work) {
      var t1 = this.this_0;
      t1.withCurrentElement$2(work.element, new K.Compiler_processQueue__closure(t1, this.world_1, work));
    },
    $isFunction: true
  },
  Compiler_processQueue__closure: {
    "^": "Closure:23;this_2,world_3,work_4",
    call$0: function() {
      return this.work_4.run$2(this.this_2, this.world_3);
    },
    $isFunction: true
  },
  Compiler_checkQueues_closure: {
    "^": "Closure:82;this_0",
    call$1: function(work) {
      this.this_0.internalError$2(work.element, "Work list is not empty.");
    },
    $isFunction: true
  },
  Compiler_resolveSignature_closure: {
    "^": "Closure:23;this_0,element_1",
    call$0: function() {
      return this.this_0.resolver.resolveSignature$1(this.element_1);
    },
    $isFunction: true
  },
  Compiler_reportDiagnosticInternal_closure: {
    "^": "Closure:23;",
    call$0: function() {
      return new K.SuppressionInfo(0, 0);
    },
    $isFunction: true
  },
  Compiler_spanFromTokens_closure: {
    "^": "Closure:19;box_0",
    call$2: function(beginOffset, endOffset) {
      return new K.SourceSpan(this.box_0.uri_0, beginOffset, endOffset);
    },
    $isFunction: true
  },
  Compiler_reportUnusedCode_checkLive: {
    "^": "Closure:8;this_0",
    call$1: function(member) {
      var t1;
      if (member.get$isFunction()) {
        t1 = this.this_0;
        if (!t1.enqueuer.resolution.isLive$1(member))
          t1.reportDiagnosticInternal$4(member, C.MessageKind_lmC, P.LinkedHashMap_LinkedHashMap$_literal(["name", member.get$name(member)], null, null), C.Diagnostic_4_hint);
      } else if (member.get$isClass())
        if (!member.get$isResolved())
          this.this_0.reportDiagnosticInternal$4(member, C.MessageKind_Gpa, P.LinkedHashMap_LinkedHashMap$_literal(["name", member.name], null, null), C.Diagnostic_4_hint);
        else
          member.forEachLocalMember$1(this);
      else if (member.get$kind(member) === C.ElementKind_typedef_32)
        if (!member.get$isResolved())
          this.this_0.reportDiagnosticInternal$4(member, C.MessageKind_fVf, P.LinkedHashMap_LinkedHashMap$_literal(["name", member.name], null, null), C.Diagnostic_4_hint);
    },
    $isFunction: true
  },
  Compiler_reportUnusedCode_closure: {
    "^": "Closure:79;checkLive_1",
    call$1: function(library) {
      if (library.get$isPlatformLibrary() || library.canonicalUri.scheme === "package")
        return;
      library.compilationUnits.forEach$1(0, new K.Compiler_reportUnusedCode__closure(this.checkLive_1));
    },
    $isFunction: true
  },
  Compiler_reportUnusedCode__closure: {
    "^": "Closure:13;checkLive_2",
    call$1: function(unit) {
      unit.forEachLocalMember$1(this.checkLive_2);
    },
    $isFunction: true
  },
  CompilerTask: {
    "^": "Object;compiler<,watch<",
    get$name: function(_) {
      return "Unknown task";
    },
    get$timing: function() {
      var t1, t2;
      t1 = this.watch;
      if (t1 != null) {
        t1 = t1.get$elapsedTicks();
        t2 = $.Stopwatch__frequency;
        if (typeof t2 !== "number")
          return H.iae(t2);
        t2 = C.JSInt_methods.$tdiv(t1 * 1000, t2);
        t1 = t2;
      } else
        t1 = 0;
      return t1;
    },
    measure$1: function(action) {
      var previous, oldTag, t1, t2, old;
      t1 = this.watch;
      if (t1 == null)
        return action.call$0();
      previous = this.get$compiler().measuredTask;
      if (this === previous)
        return action.call$0();
      this.get$compiler().measuredTask = this;
      if (previous != null)
        previous.get$watch().stop$0(0);
      t1.start$0(0);
      t2 = this.profilerTag;
      if (t2 == null) {
        t2 = P._FakeUserTag__FakeUserTag(this.get$name(this));
        this.profilerTag = t2;
      }
      t2.toString;
      old = $.get$_currentTag();
      $._currentTag = t2;
      oldTag = old;
      try {
        t2 = action.call$0();
        return t2;
      } finally {
        t1.stop$0(0);
        t1 = oldTag;
        t1.toString;
        $.get$_currentTag();
        $._currentTag = t1;
        if (previous != null)
          previous.get$watch().start$0(0);
        this.get$compiler().measuredTask = previous;
      }
    },
    measureElement$2: function(element, action) {
      this.get$compiler().withCurrentElement$2(element, new K.CompilerTask_measureElement_closure(this, action));
    }
  },
  CompilerTask_measureElement_closure: {
    "^": "Closure:23;this_0,action_1",
    call$0: function() {
      return this.this_0.measure$1(this.action_1);
    },
    $isFunction: true
  },
  CompilerCancelledException: {
    "^": "Object;reason>",
    toString$0: function(_) {
      return "compiler cancelled: " + this.reason;
    },
    $isCompilerCancelledException: true,
    static: {CompilerCancelledException$: function(reason) {
        return new K.CompilerCancelledException(reason);
      }}
  },
  SourceSpan: {
    "^": "Object;uri<,begin,end<",
    toString$0: function(_) {
      return "SourceSpan(" + J.toString$0(this.uri) + ", " + this.begin + ", " + this.end + ")";
    },
    $isSourceSpan: true
  },
  NullSink: {
    "^": "Object;name>",
    add$1: function(_, value) {
    },
    close$0: function(_) {
    },
    toString$0: function(_) {
      return this.name;
    },
    static: {NullSink_outputProvider: [function($name, extension) {
        return new K.NullSink($name + "." + extension);
      }, "call$2", "NullSink_outputProvider$closure", 4, 0, 17]}
  },
  SuppressionInfo: {
    "^": "Object;warnings<,hints<"
  },
  ConstantSystem: {
    "^": "Object;",
    add$1: function($receiver, arg0) {
      return this.get$add(this).call$1(arg0);
    },
    lookupUnary$1: function(operator) {
      switch (operator) {
        case "~":
          return this.get$bitNot();
        case "-":
          return this.get$negate();
        case "!":
          return this.get$not();
        default:
          return;
      }
    },
    lookupBinary$1: function(operator) {
      switch (operator) {
        case "+":
          return this.get$add(this);
        case "-":
          return this.get$subtract();
        case "*":
          return this.get$multiply();
        case "/":
          return this.get$divide();
        case "%":
          return this.get$modulo();
        case "~/":
          return this.get$truncatingDivide();
        case "|":
          return this.get$bitOr();
        case "&":
          return this.get$bitAnd();
        case "^":
          return this.get$bitXor();
        case "||":
          return this.get$booleanOr();
        case "&&":
          return this.get$booleanAnd();
        case "<<":
          return this.get$shiftLeft();
        case ">>":
          return this.get$shiftRight();
        case "<":
          return this.get$less();
        case "<=":
          return this.get$lessEqual();
        case ">":
          return this.get$greater();
        case ">=":
          return this.get$greaterEqual();
        case "==":
          return this.get$equal();
        default:
          return;
      }
    }
  },
  BitNotOperation: {
    "^": "Object;name>",
    fold$1: function(_, constant) {
      if (constant.get$isInt())
        return K.IntConstant_IntConstant(J.$not$i(constant.get$value(constant)));
      return;
    }
  },
  NegateOperation: {
    "^": "Object;name>",
    fold$1: function(_, constant) {
      var t1;
      if (constant.get$isInt()) {
        t1 = constant.get$value(constant);
        if (typeof t1 !== "number")
          return t1.$negate();
        return K.IntConstant_IntConstant(-t1);
      }
      if (constant.get$isDouble())
        return K.DoubleConstant_DoubleConstant(-constant.get$value(constant));
      return;
    }
  },
  NotOperation: {
    "^": "Object;name>",
    fold$1: function(_, constant) {
      if (constant.get$isBool())
        return !constant.get$value(constant) ? C.TrueConstant_true : C.FalseConstant_false;
      return;
    }
  },
  BinaryBitOperation: {
    "^": "Object;",
    fold$2: function(_, left, right) {
      var resultValue;
      if (left.get$isInt() && right.get$isInt()) {
        resultValue = this.foldInts$2(left.get$value(left), right.get$value(right));
        if (resultValue == null)
          return;
        return K.IntConstant_IntConstant(resultValue);
      }
      return;
    }
  },
  BitOrOperation: {
    "^": "BinaryBitOperation;name>",
    foldInts$2: function(left, right) {
      if (typeof left !== "number")
        return left.$or();
      if (typeof right !== "number")
        return H.iae(right);
      return (left | right) >>> 0;
    },
    apply$2: function(left, right) {
      return left.$or(0, right);
    }
  },
  BitAndOperation: {
    "^": "BinaryBitOperation;name>",
    foldInts$2: function(left, right) {
      if (typeof left !== "number")
        return left.$and();
      if (typeof right !== "number")
        return H.iae(right);
      return (left & right) >>> 0;
    },
    apply$2: function(left, right) {
      return left.$and(0, right);
    }
  },
  BitXorOperation: {
    "^": "BinaryBitOperation;name>",
    foldInts$2: function(left, right) {
      if (typeof left !== "number")
        return left.$xor();
      if (typeof right !== "number")
        return H.iae(right);
      return (left ^ right) >>> 0;
    },
    apply$2: function(left, right) {
      return left.$xor(0, right);
    }
  },
  ShiftLeftOperation: {
    "^": "BinaryBitOperation;name>",
    foldInts$2: function(left, right) {
      if (typeof right !== "number")
        return right.$gt();
      if (right > 100 || right < 0)
        return;
      if (typeof left !== "number")
        return left.$shl();
      return C.JSInt_methods.$shl(left, right);
    },
    apply$2: function(left, right) {
      return left.$shl(0, right);
    }
  },
  ShiftRightOperation: {
    "^": "BinaryBitOperation;name>",
    foldInts$2: function(left, right) {
      if (typeof right !== "number")
        return right.$lt();
      if (right < 0)
        return;
      if (typeof left !== "number")
        return left.$shr();
      return C.JSInt_methods.$shr(left, right);
    },
    apply$2: function(left, right) {
      return left.$shr(0, right);
    }
  },
  BinaryBoolOperation: {
    "^": "Object;",
    fold$2: function(_, left, right) {
      if (left.get$isBool() && right.get$isBool())
        return this.foldBools$2(left.get$value(left), right.get$value(right)) ? C.TrueConstant_true : C.FalseConstant_false;
      return;
    }
  },
  BooleanAndOperation: {
    "^": "BinaryBoolOperation;name>",
    foldBools$2: function(left, right) {
      return left && right;
    },
    apply$2: function(left, right) {
      return false;
    }
  },
  BooleanOrOperation: {
    "^": "BinaryBoolOperation;name>",
    foldBools$2: function(left, right) {
      return left || right;
    },
    apply$2: function(left, right) {
      return false;
    }
  },
  ArithmeticNumOperation: {
    "^": "Object;",
    fold$2: function(_, left, right) {
      var foldedValue;
      if (left.get$isNum() && right.get$isNum()) {
        foldedValue = left.get$isInt() && right.get$isInt() ? this.foldInts$2(left.get$value(left), right.get$value(right)) : this.foldNums$2(left.get$value(left), right.get$value(right));
        if (foldedValue == null)
          return;
        if (left.get$isInt() && right.get$isInt() && !this.isDivide$0() || this.isTruncatingDivide$0())
          return K.IntConstant_IntConstant(foldedValue);
        else
          return K.DoubleConstant_DoubleConstant(foldedValue);
      }
      return;
    },
    isDivide$0: function() {
      return false;
    },
    isTruncatingDivide$0: function() {
      return false;
    },
    foldInts$2: function(left, right) {
      return this.foldNums$2(left, right);
    }
  },
  SubtractOperation: {
    "^": "ArithmeticNumOperation;name>",
    foldNums$2: function(left, right) {
      if (typeof left !== "number")
        return left.$sub();
      if (typeof right !== "number")
        return H.iae(right);
      return left - right;
    },
    apply$2: function(left, right) {
      return J.$sub$n(left, right);
    }
  },
  MultiplyOperation: {
    "^": "ArithmeticNumOperation;name>",
    foldNums$2: function(left, right) {
      if (typeof left !== "number")
        return left.$mul();
      if (typeof right !== "number")
        return H.iae(right);
      return left * right;
    },
    apply$2: function(left, right) {
      return J.$mul$ns(left, right);
    }
  },
  ModuloOperation: {
    "^": "ArithmeticNumOperation;name>",
    foldInts$2: function(left, right) {
      if (right === 0)
        return;
      if (typeof left !== "number")
        return left.$mod();
      if (typeof right !== "number")
        return H.iae(right);
      return C.JSNumber_methods.$mod(left, right);
    },
    foldNums$2: function(left, right) {
      if (typeof left !== "number")
        return left.$mod();
      if (typeof right !== "number")
        return H.iae(right);
      return C.JSNumber_methods.$mod(left, right);
    },
    apply$2: function(left, right) {
      if (typeof left !== "number")
        return left.$mod();
      if (typeof right !== "number")
        return H.iae(right);
      return C.JSNumber_methods.$mod(left, right);
    }
  },
  TruncatingDivideOperation: {
    "^": "ArithmeticNumOperation;name>",
    foldInts$2: function(left, right) {
      if (right === 0)
        return;
      if (typeof left !== "number")
        return left.$tdiv();
      if (typeof right !== "number")
        return H.iae(right);
      return C.JSNumber_methods.$tdiv(left, right);
    },
    foldNums$2: function(left, right) {
      var ratio;
      if (typeof left !== "number")
        return left.$div();
      if (typeof right !== "number")
        return H.iae(right);
      ratio = left / right;
      if (isNaN(ratio) || ratio == Infinity || ratio == -Infinity)
        return;
      return C.JSInt_methods.toInt$0(C.JSNumber_methods.toInt$0(ratio));
    },
    apply$2: function(left, right) {
      return J.$tdiv$n(left, right);
    },
    isTruncatingDivide$0: function() {
      return true;
    }
  },
  DivideOperation: {
    "^": "ArithmeticNumOperation;name>",
    foldNums$2: function(left, right) {
      if (typeof left !== "number")
        return left.$div();
      if (typeof right !== "number")
        return H.iae(right);
      return left / right;
    },
    isDivide$0: function() {
      return true;
    },
    apply$2: function(left, right) {
      if (typeof left !== "number")
        return left.$div();
      if (typeof right !== "number")
        return H.iae(right);
      return left / right;
    }
  },
  AddOperation: {
    "^": "Object;name>",
    fold$2: function(_, left, right) {
      var t1, t2;
      if (left.get$isInt() && right.get$isInt()) {
        t1 = left.get$value(left);
        t2 = right.get$value(right);
        if (typeof t1 !== "number")
          return t1.$add();
        if (typeof t2 !== "number")
          return H.iae(t2);
        return K.IntConstant_IntConstant(t1 + t2);
      } else if (left.get$isNum() && right.get$isNum()) {
        t1 = left.get$value(left);
        t2 = right.get$value(right);
        if (typeof t1 !== "number")
          return t1.$add();
        if (typeof t2 !== "number")
          return H.iae(t2);
        return K.DoubleConstant_DoubleConstant(t1 + t2);
      } else
        return;
    },
    apply$2: function(left, right) {
      return J.$add$ns(left, right);
    }
  },
  RelationalNumOperation: {
    "^": "Object;",
    fold$2: function(_, left, right) {
      if (!left.get$isNum() || !right.get$isNum())
        return;
      return this.foldNums$2(left.get$value(left), right.get$value(right)) ? C.TrueConstant_true : C.FalseConstant_false;
    }
  },
  LessOperation: {
    "^": "RelationalNumOperation;name>",
    foldNums$2: function(left, right) {
      if (typeof left !== "number")
        return left.$lt();
      if (typeof right !== "number")
        return H.iae(right);
      return left < right;
    },
    apply$2: function(left, right) {
      return left.$lt(0, right);
    }
  },
  LessEqualOperation: {
    "^": "RelationalNumOperation;name>",
    foldNums$2: function(left, right) {
      if (typeof left !== "number")
        return left.$le();
      if (typeof right !== "number")
        return H.iae(right);
      return left <= right;
    },
    apply$2: function(left, right) {
      var t1 = left.upper;
      return J.$eq(t1.min$1(0, right.lower), t1);
    }
  },
  GreaterOperation: {
    "^": "RelationalNumOperation;name>",
    foldNums$2: function(left, right) {
      if (typeof left !== "number")
        return left.$gt();
      if (typeof right !== "number")
        return H.iae(right);
      return left > right;
    },
    apply$2: function(left, right) {
      return left.$gt(0, right);
    }
  },
  GreaterEqualOperation: {
    "^": "RelationalNumOperation;name>",
    foldNums$2: function(left, right) {
      if (typeof left !== "number")
        return left.$ge();
      if (typeof right !== "number")
        return H.iae(right);
      return left >= right;
    },
    apply$2: function(left, right) {
      var t1 = left.lower;
      return J.$eq(t1.max$1(0, right.upper), t1);
    }
  },
  EqualsOperation: {
    "^": "Object;name>",
    fold$2: function(_, left, right) {
      var t1, t2;
      if (left.get$isNum() && right.get$isNum()) {
        t1 = left.get$value(left);
        t2 = right.get$value(right);
        return (t1 == null ? t2 == null : t1 === t2) ? C.TrueConstant_true : C.FalseConstant_false;
      }
      if (left.get$isConstructedObject())
        return;
      return left.$eq(0, right) ? C.TrueConstant_true : C.FalseConstant_false;
    },
    apply$2: function(left, right) {
      return J.$eq(left, right);
    }
  },
  IdentityOperation: {
    "^": "Object;name>",
    fold$2: function(_, left, right) {
      var t1 = J.getInterceptor$n(left);
      if (t1.get$isNaN(left) && right.get$isNaN(right))
        return;
      return t1.$eq(left, right) ? C.TrueConstant_true : C.FalseConstant_false;
    },
    apply$2: function(left, right) {
      return left == null ? right == null : left === right;
    }
  },
  DartConstantSystem: {
    "^": "ConstantSystem;add>,bitAnd<,bitNot<,bitOr<,bitXor<,booleanAnd<,booleanOr<,divide<,equal<,greaterEqual<,greater<,identity<,lessEqual<,less<,modulo<,multiply<,negate<,not<,shiftLeft<,shiftRight<,subtract<,truncatingDivide<",
    add$1: function($receiver, arg0) {
      return this.add.call$1(arg0);
    },
    createInt$1: function(i) {
      return K.IntConstant_IntConstant(i);
    },
    createDouble$1: function(d) {
      return K.DoubleConstant_DoubleConstant(d);
    },
    createString$1: function(string) {
      return new K.StringConstant(string, J.get$hashCode$(string.slowToString$0()));
    },
    createBool$1: function(value) {
      return value ? C.TrueConstant_true : C.FalseConstant_false;
    },
    createNull$0: function() {
      return C.C_NullConstant;
    },
    createMap$4: function(compiler, type, keys, values) {
      return K.MapConstant$(type, keys, values);
    },
    isInt$1: function(constant) {
      return constant.get$isInt();
    },
    isString$1: [function(constant) {
      return constant.get$isString();
    }, "call$1", "get$isString", 2, 0, 83],
    isBool$1: [function(constant) {
      return constant.get$isBool();
    }, "call$1", "get$isBool", 2, 0, 83],
    isNull$1: [function(constant) {
      return constant.get$isNull();
    }, "call$1", "get$isNull", 2, 0, 83],
    isSubtype$3: [function(compiler, s, t) {
      var t1 = compiler.get$types().subtypeVisitor;
      return s.get$treatAsDynamic() || t1.isMoreSpecific$2(s, t) === true;
    }, "call$3", "get$isSubtype", 6, 0, 84]
  },
  Constant: {
    "^": "Object;",
    get$isNull: function() {
      return false;
    },
    isNull$0: function() {
      return this.get$isNull().call$0();
    },
    get$isBool: function() {
      return false;
    },
    get$isTrue: function() {
      return false;
    },
    get$isFalse: function() {
      return false;
    },
    get$isInt: function() {
      return false;
    },
    get$isDouble: function() {
      return false;
    },
    get$isNum: function() {
      return false;
    },
    get$isString: function() {
      return false;
    },
    get$isList: function() {
      return false;
    },
    get$isMap: function(_) {
      return false;
    },
    get$isConstructedObject: function() {
      return false;
    },
    get$isFunction: function() {
      return false;
    },
    get$isPrimitive: function() {
      return false;
    },
    get$isObject: function() {
      return false;
    },
    get$isType: function() {
      return false;
    },
    get$isInterceptor: function() {
      return false;
    },
    isInterceptor$1: function(arg0) {
      return this.get$isInterceptor().call$1(arg0);
    },
    get$isDummy: function() {
      return false;
    },
    get$isNaN: function(_) {
      return false;
    },
    get$isMinusZero: function() {
      return false;
    },
    get$isZero: function() {
      return false;
    },
    get$isOne: function() {
      return false;
    }
  },
  FunctionConstant: {
    "^": "Constant;element<",
    get$isFunction: function() {
      return true;
    },
    $eq: function(_, other) {
      var t1, t2;
      if (other == null)
        return false;
      if (!J.getInterceptor(other).$isFunctionConstant)
        return false;
      t1 = other.element;
      t2 = this.element;
      return t1 == null ? t2 == null : t1 === t2;
    },
    toString$0: function(_) {
      return J.toString$0(this.element);
    },
    getDependencies$0: function() {
      return C.List_empty2;
    },
    toDartString$0: function() {
      var t1 = this.element;
      return new Y.LiteralDartString(t1.get$name(t1));
    },
    computeType$1: function(compiler) {
      return this.element.computeType$1(compiler);
    },
    computeMask$1: function(compiler) {
      return compiler.typesTask.get$functionType();
    },
    get$hashCode: function(_) {
      var t1 = J.get$hashCode$(this.element);
      if (typeof t1 !== "number")
        return H.iae(t1);
      return 17 * t1 & 2147483647;
    },
    accept$1: function(_, visitor) {
      return visitor.visitFunction$1(this);
    },
    $isFunctionConstant: true
  },
  PrimitiveConstant: {
    "^": "Constant;",
    get$isPrimitive: function() {
      return true;
    },
    $eq: function(_, other) {
      var t1;
      if (other == null)
        return false;
      t1 = J.getInterceptor(other);
      if (!t1.$isPrimitiveConstant)
        return false;
      return J.$eq(this.get$value(this), t1.get$value(other));
    },
    get$hashCode: function(_) {
      return H.throwExpression(P.UnsupportedError$("PrimitiveConstant.hashCode"));
    },
    toString$0: function(_) {
      return J.toString$0(this.get$value(this));
    },
    getDependencies$0: function() {
      return C.List_empty2;
    },
    $isPrimitiveConstant: true
  },
  NullConstant: {
    "^": "PrimitiveConstant;",
    get$isNull: function() {
      return true;
    },
    isNull$0: function() {
      return this.get$isNull().call$0();
    },
    get$value: function(_) {
      return;
    },
    computeType$1: function(compiler) {
      return compiler.nullClass.computeType$1(compiler);
    },
    computeMask$1: function(compiler) {
      return compiler.typesTask.get$nullType();
    },
    get$hashCode: function(_) {
      return 785965825;
    },
    toDartString$0: function() {
      return C.LiteralDartString_null;
    },
    accept$1: function(_, visitor) {
      return visitor.visitNull$1(this);
    },
    $isNullConstant: true,
    static: {"^": "NullConstant_JsNull"}
  },
  NumConstant: {
    "^": "PrimitiveConstant;",
    get$isNum: function() {
      return true;
    },
    $isNumConstant: true
  },
  IntConstant: {
    "^": "NumConstant;value>",
    get$isInt: function() {
      return true;
    },
    isUInt32$0: function() {
      var t1 = this.value;
      if (typeof t1 !== "number")
        return t1.$ge();
      return t1 >= 0 && false;
    },
    isPositive$0: [function() {
      var t1 = this.value;
      if (typeof t1 !== "number")
        return t1.$ge();
      return t1 >= 0;
    }, "call$0", "get$isPositive", 0, 0, 42],
    get$isZero: function() {
      return this.value === 0;
    },
    get$isOne: function() {
      return this.value === 1;
    },
    computeType$1: function(compiler) {
      return compiler.intClass.get$rawType();
    },
    computeMask$1: function(compiler) {
      var t1, t2;
      t1 = this.value;
      if (typeof t1 !== "number")
        return t1.$ge();
      t2 = t1 >= 0;
      if (t2 && t1 < 2147483648)
        return compiler.typesTask.get$uint31Type();
      if (this.isUInt32$0())
        return compiler.typesTask.get$uint32Type();
      if (t2)
        return compiler.typesTask.get$positiveIntType();
      return compiler.typesTask.get$intType();
    },
    $eq: function(_, other) {
      var t1, t2;
      if (other == null)
        return false;
      if (!J.getInterceptor(other).$isIntConstant)
        return false;
      t1 = this.value;
      t2 = other.value;
      return t1 == null ? t2 == null : t1 === t2;
    },
    get$hashCode: function(_) {
      return J.get$hashCode$(this.value);
    },
    toDartString$0: function() {
      return new Y.LiteralDartString(J.toString$0(this.value));
    },
    accept$1: function(_, visitor) {
      return visitor.visitInt$1(this);
    },
    $isIntConstant: true,
    static: {IntConstant_IntConstant: function(value) {
        switch (value) {
          case 0:
            return C.IntConstant_0;
          case 1:
            return C.IntConstant_1;
          case 2:
            return C.IntConstant_2;
          case 3:
            return C.IntConstant_3;
          case 4:
            return C.IntConstant_4;
          case 5:
            return C.IntConstant_5;
          case 6:
            return C.IntConstant_6;
          case 7:
            return C.IntConstant_7;
          case 8:
            return C.IntConstant_8;
          case 9:
            return C.IntConstant_9;
          case 10:
            return C.IntConstant_10;
          case -1:
            return C.IntConstant_m1;
          case -2:
            return C.IntConstant_m2;
          default:
            return new K.IntConstant(value);
        }
      }}
  },
  DoubleConstant: {
    "^": "NumConstant;value>",
    get$isDouble: function() {
      return true;
    },
    get$isNaN: function(_) {
      return isNaN(this.value);
    },
    get$isMinusZero: function() {
      var t1 = this.value;
      return t1 === 0 && C.JSNumber_methods.get$isNegative(t1);
    },
    get$isZero: function() {
      return this.value === 0;
    },
    get$isOne: function() {
      return this.value === 1;
    },
    computeType$1: function(compiler) {
      return compiler.doubleClass.get$rawType();
    },
    computeMask$1: function(compiler) {
      var t1 = this.value;
      if (t1 === 0 && C.JSNumber_methods.get$isNegative(t1) && compiler.backend.get$constantSystem().isInt$1(this))
        return compiler.typesTask.get$uint31Type();
      return compiler.typesTask.get$doubleType();
    },
    $eq: function(_, other) {
      var otherValue, t1;
      if (other == null)
        return false;
      if (!J.getInterceptor(other).$isDoubleConstant)
        return false;
      otherValue = other.value;
      t1 = this.value;
      if (t1 === 0 && otherValue === 0)
        return C.JSNumber_methods.get$isNegative(t1) === C.JSNumber_methods.get$isNegative(otherValue);
      else if (isNaN(t1))
        return isNaN(otherValue);
      else
        return t1 === otherValue;
    },
    get$hashCode: function(_) {
      return this.value & 0x1FFFFFFF;
    },
    toDartString$0: function() {
      return new Y.LiteralDartString(C.JSNumber_methods.toString$0(this.value));
    },
    accept$1: function(_, visitor) {
      return visitor.visitDouble$1(this);
    },
    $isDoubleConstant: true,
    static: {DoubleConstant_DoubleConstant: function(value) {
        if (J.getInterceptor$n(value).get$isNaN(value))
          return C.DoubleConstant_PZL;
        else if (value === 1 / 0)
          return C.DoubleConstant_C8D;
        else if (value === -1 / 0)
          return C.DoubleConstant_AmO;
        else if (value === 0 && !C.JSNumber_methods.get$isNegative(value))
          return C.DoubleConstant_0;
        else if (value === 1)
          return C.DoubleConstant_1;
        else
          return new K.DoubleConstant(value);
      }}
  },
  BoolConstant: {
    "^": "PrimitiveConstant;",
    get$isBool: function() {
      return true;
    },
    computeType$1: function(compiler) {
      return compiler.boolClass.get$rawType();
    },
    computeMask$1: function(compiler) {
      return compiler.typesTask.get$boolType();
    },
    $isBoolConstant: true
  },
  TrueConstant: {
    "^": "BoolConstant;value>",
    get$isTrue: function() {
      return true;
    },
    negate$0: function() {
      return C.FalseConstant_false;
    },
    $eq: function(_, other) {
      if (other == null)
        return false;
      return this === other;
    },
    get$hashCode: function(_) {
      return 499;
    },
    toDartString$0: function() {
      return C.LiteralDartString_true;
    },
    accept$1: function(_, visitor) {
      return visitor.visitTrue$1(this);
    },
    $isTrueConstant: true
  },
  FalseConstant: {
    "^": "BoolConstant;value>",
    get$isFalse: function() {
      return true;
    },
    negate$0: function() {
      return C.TrueConstant_true;
    },
    $eq: function(_, other) {
      if (other == null)
        return false;
      return this === other;
    },
    get$hashCode: function(_) {
      return 536555975;
    },
    toDartString$0: function() {
      return C.LiteralDartString_false;
    },
    accept$1: function(_, visitor) {
      return visitor.visitFalse$1(this);
    },
    $isFalseConstant: true
  },
  StringConstant: {
    "^": "PrimitiveConstant;value>,hashCode>",
    get$isString: function() {
      return true;
    },
    computeType$1: function(compiler) {
      return compiler.stringClass.get$rawType();
    },
    computeMask$1: function(compiler) {
      return compiler.typesTask.get$stringType();
    },
    $eq: function(_, other) {
      if (other == null)
        return false;
      if (!J.getInterceptor(other).$isStringConstant)
        return false;
      return this.hashCode === other.hashCode && J.$eq(this.value, other.value);
    },
    toDartString$0: function() {
      return this.value;
    },
    get$length: function(_) {
      var t1 = this.value;
      return t1.get$length(t1);
    },
    accept$1: function(_, visitor) {
      return visitor.visitString$1(this);
    },
    toString$0: function(_) {
      return "StringConstant(\"" + H.S(this.value.slowToString$0()) + "\")";
    },
    $isStringConstant: true
  },
  ObjectConstant: {
    "^": "Constant;type>",
    get$isObject: function() {
      return true;
    },
    computeType$1: function(compiler) {
      return this.type;
    }
  },
  TypeConstant: {
    "^": "ObjectConstant;representedType<,type",
    get$isType: function() {
      return true;
    },
    $eq: function(_, other) {
      if (other == null)
        return false;
      return !!J.getInterceptor(other).$isTypeConstant && J.$eq(this.representedType, other.representedType);
    },
    computeMask$1: function(compiler) {
      return compiler.typesTask.get$typeType();
    },
    get$hashCode: function(_) {
      var t1 = J.get$hashCode$(this.representedType);
      if (typeof t1 !== "number")
        return t1.$mul();
      return t1 * 13;
    },
    getDependencies$0: function() {
      return C.List_empty2;
    },
    accept$1: function(_, visitor) {
      return visitor.visitType$1(this);
    },
    toString$0: function(_) {
      return "TypeConstant(" + J.toString$0(this.representedType) + ")";
    },
    $isTypeConstant: true
  },
  ListConstant: {
    "^": "ObjectConstant;entries>,hashCode>,type",
    get$isList: function() {
      return true;
    },
    $eq: function(_, other) {
      var t1, t2, t3, i;
      if (other == null)
        return false;
      if (!J.getInterceptor(other).$isListConstant)
        return false;
      if (this.hashCode !== other.hashCode)
        return false;
      if (!J.$eq(this.type, other.type))
        return false;
      t1 = this.entries;
      t2 = t1.length;
      t3 = other.entries;
      if (t2 !== t3.length)
        return false;
      for (i = 0; i < t1.length; ++i) {
        t2 = t1[i];
        if (i >= t3.length)
          return H.ioore(t3, i);
        if (!J.$eq(t2, t3[i]))
          return false;
      }
      return true;
    },
    getDependencies$0: function() {
      return this.entries;
    },
    get$length: function(_) {
      return this.entries.length;
    },
    computeMask$1: function(compiler) {
      return compiler.typesTask.get$constListType();
    },
    accept$1: function(_, visitor) {
      return visitor.visitList$1(this);
    },
    toString$0: function(_) {
      var sb, t1, i, str;
      sb = P.StringBuffer$("");
      sb.write$1("ListConstant([");
      for (t1 = this.entries, i = 0; i < t1.length; ++i) {
        if (i > 0)
          sb._contents += ",";
        str = t1[i];
        sb._contents += typeof str === "string" ? str : H.S(str);
      }
      sb.write$1("])");
      return sb._contents;
    },
    $isListConstant: true,
    static: {ListConstant__computeHash: function(type, entries) {
        var t1, hash, t2;
        for (t1 = H.setRuntimeTypeInfo(new H.ListIterator(entries, entries.length, 0, null), [H.getTypeArgumentByIndex(entries, 0)]), hash = 7; t1.moveNext$0();) {
          t2 = J.get$hashCode$(t1.__internal$_current);
          if (typeof t2 !== "number")
            return H.iae(t2);
          hash ^= t2;
        }
        t1 = J.get$hashCode$(type);
        if (typeof t1 !== "number")
          return H.iae(t1);
        return (hash ^ t1) >>> 0;
      }}
  },
  MapConstant: {
    "^": "ObjectConstant;keys<,values>,hashCode>,type",
    get$isMap: function(_) {
      return true;
    },
    computeMask$1: function(compiler) {
      return compiler.typesTask.get$constMapType();
    },
    $eq: function(_, other) {
      var t1, t2, t3, t4, i, t5;
      if (other == null)
        return false;
      t1 = J.getInterceptor(other);
      if (!t1.$isMapConstant)
        return false;
      if (this.hashCode !== t1.get$hashCode(other))
        return false;
      if (!J.$eq(this.type, other.type))
        return false;
      t1 = this.keys;
      t2 = t1.length;
      t3 = other.keys;
      if (t2 !== t3.length)
        return false;
      for (t2 = this.values, t4 = other.values, i = 0; i < t1.length; ++i) {
        t5 = t1[i];
        if (i >= t3.length)
          return H.ioore(t3, i);
        if (!J.$eq(t5, t3[i]))
          return false;
        if (i >= t2.length)
          return H.ioore(t2, i);
        t5 = t2[i];
        if (i >= t4.length)
          return H.ioore(t4, i);
        if (!J.$eq(t5, t4[i]))
          return false;
      }
      return true;
    },
    getDependencies$0: function() {
      var result = H.setRuntimeTypeInfo([], [K.Constant]);
      C.JSArray_methods.addAll$1(result, this.keys);
      C.JSArray_methods.addAll$1(result, this.values);
      return result;
    },
    get$length: function(_) {
      return this.keys.length;
    },
    accept$1: function(_, visitor) {
      return visitor.visitMap$1(this);
    },
    toString$0: function(_) {
      var sb, t1, t2, i, str, t3;
      sb = P.StringBuffer$("");
      sb.write$1("MapConstant({");
      for (t1 = this.keys, t2 = this.values, i = 0; i < t1.length; ++i) {
        if (i > 0)
          sb._contents += ",";
        str = t1[i];
        t3 = sb._contents += typeof str === "string" ? str : H.S(str);
        sb._contents = t3 + ":";
        if (i >= t2.length)
          return H.ioore(t2, i);
        str = t2[i];
        sb._contents += typeof str === "string" ? str : H.S(str);
      }
      sb.write$1("})");
      return sb._contents;
    },
    MapConstant$3: function(type, keys, values) {
    },
    $isMapConstant: true,
    static: {MapConstant$: function(type, keys, values) {
        var t1 = new K.MapConstant(keys, values, K.MapConstant_computeHash(type, keys, values), type);
        t1.MapConstant$3(type, keys, values);
        return t1;
      }, MapConstant_computeHash: function(type, keys, values) {
        var t1, hash, t2;
        for (t1 = H.setRuntimeTypeInfo(new H.ListIterator(keys, keys.length, 0, null), [H.getTypeArgumentByIndex(keys, 0)]), hash = 0; t1.moveNext$0();) {
          t2 = J.get$hashCode$(t1.__internal$_current);
          if (typeof t2 !== "number")
            return H.iae(t2);
          hash ^= t2;
        }
        for (t1 = H.setRuntimeTypeInfo(new H.ListIterator(values, values.length, 0, null), [H.getTypeArgumentByIndex(values, 0)]); t1.moveNext$0();) {
          t2 = J.get$hashCode$(t1.__internal$_current);
          if (typeof t2 !== "number")
            return H.iae(t2);
          hash ^= t2;
        }
        t1 = J.get$hashCode$(type);
        if (typeof t1 !== "number")
          return H.iae(t1);
        return (hash ^ t1) >>> 0;
      }}
  },
  InterceptorConstant: {
    "^": "Constant;dispatchedType<",
    get$isInterceptor: function() {
      return true;
    },
    isInterceptor$1: function(arg0) {
      return this.get$isInterceptor().call$1(arg0);
    },
    $eq: function(_, other) {
      if (other == null)
        return false;
      return !!J.getInterceptor(other).$isInterceptorConstant && J.$eq(this.dispatchedType, other.dispatchedType);
    },
    get$hashCode: function(_) {
      var t1 = J.get$hashCode$(this.dispatchedType);
      if (typeof t1 !== "number")
        return t1.$mul();
      return t1 * 43;
    },
    getDependencies$0: function() {
      return C.List_empty2;
    },
    accept$1: function(_, visitor) {
      return visitor.visitInterceptor$1(this);
    },
    computeType$1: function(compiler) {
      return C.C_DynamicType;
    },
    computeMask$1: function(compiler) {
      return compiler.typesTask.get$nonNullType();
    },
    toString$0: function(_) {
      var t1 = this.dispatchedType;
      t1.toString;
      return "InterceptorConstant(" + new V.TypeDeclarationFormatter(null, null).format$2(0, t1, "o") + ")";
    },
    $isInterceptorConstant: true
  },
  DummyConstant: {
    "^": "Constant;typeMask",
    get$isDummy: function() {
      return true;
    },
    $eq: function(_, other) {
      if (other == null)
        return false;
      return !!J.getInterceptor(other).$isDummyConstant && J.$eq(this.typeMask, other.typeMask);
    },
    get$hashCode: function(_) {
      return J.get$hashCode$(this.typeMask);
    },
    getDependencies$0: function() {
      return C.List_empty2;
    },
    accept$1: function(_, visitor) {
      return visitor.visitDummy$1(this);
    },
    computeType$1: function(compiler) {
      return C.C_DynamicType;
    },
    computeMask$1: function(compiler) {
      return this.typeMask;
    },
    toString$0: function(_) {
      return "DummyConstant(" + J.toString$0(this.typeMask) + ")";
    },
    $isDummyConstant: true
  },
  ConstructedConstant: {
    "^": "ObjectConstant;fields<,hashCode>,isLiteralSymbol,type",
    get$isConstructedObject: function() {
      return true;
    },
    $eq: function(_, otherVar) {
      var t1, t2, t3, i;
      if (otherVar == null)
        return false;
      if (!J.getInterceptor(otherVar).$isConstructedConstant)
        return false;
      if (this.hashCode !== otherVar.hashCode)
        return false;
      if (!J.$eq(this.type, otherVar.type))
        return false;
      t1 = this.fields;
      t2 = t1.length;
      t3 = otherVar.fields;
      if (t2 !== t3.length)
        return false;
      for (i = 0; i < t1.length; ++i) {
        t2 = t1[i];
        if (i >= t3.length)
          return H.ioore(t3, i);
        if (!J.$eq(t2, t3[i]))
          return false;
      }
      return true;
    },
    getDependencies$0: function() {
      return this.fields;
    },
    computeMask$1: function(compiler) {
      var t1 = this.type;
      if (compiler.backend.isInterceptorClass$1(t1.get$element()))
        return compiler.typesTask.get$nonNullType();
      return new B.FlatTypeMask(t1.get$element(), 2);
    },
    accept$1: function(_, visitor) {
      return visitor.visitConstructed$1(this);
    },
    get$fieldElements: function() {
      var t1, classElement, result;
      t1 = {};
      classElement = this.type.get$element();
      t1.count_0 = 0;
      result = P.LinkedHashMap_LinkedHashMap(null, null, null, O.Element, K.Constant);
      classElement.get$implementation(classElement).forEachInstanceField$2$includeSuperAndInjectedMembers(new K.ConstructedConstant_fieldElements_closure(t1, this, result), true);
      return result;
    },
    toString$0: function(_) {
      var t1, sb;
      t1 = {};
      sb = P.StringBuffer$("");
      sb.write$1("ConstructedConstant(");
      sb.write$1(this.type);
      sb.write$1("(");
      t1.i_0 = 0;
      this.get$fieldElements().forEach$1(0, new K.ConstructedConstant_toString_closure(t1, sb));
      sb.write$1("))");
      return sb._contents;
    },
    $isConstructedConstant: true,
    static: {ConstructedConstant_computeHash: function(type, fields) {
        var t1, hash, t2;
        for (t1 = H.setRuntimeTypeInfo(new H.ListIterator(fields, fields.length, 0, null), [H.getTypeArgumentByIndex(fields, 0)]), hash = 0; t1.moveNext$0();) {
          t2 = J.get$hashCode$(t1.__internal$_current);
          if (typeof t2 !== "number")
            return H.iae(t2);
          hash ^= t2;
        }
        t1 = J.get$hashCode$(type);
        if (typeof t1 !== "number")
          return H.iae(t1);
        return (hash ^ t1) >>> 0;
      }}
  },
  ConstructedConstant_fieldElements_closure: {
    "^": "Closure:19;box_0,this_1,result_2",
    call$2: function(holder, field) {
      var t1, t2;
      t1 = this.this_1.fields;
      t2 = this.box_0.count_0++;
      if (t2 >= t1.length)
        return H.ioore(t1, t2);
      this.result_2.$indexSet(0, field, t1[t2]);
    },
    $isFunction: true
  },
  ConstructedConstant_toString_closure: {
    "^": "Closure:85;box_0,sb_1",
    call$2: function(field, value) {
      var t1, t2;
      t1 = this.box_0;
      if (t1.i_0 > 0)
        this.sb_1.write$1(",");
      t2 = this.sb_1;
      t2.write$1(J.get$name$x(field));
      t2.write$1("=");
      t2.write$1(value);
      ++t1.i_0;
    },
    $isFunction: true
  },
  DeferredConstant: {
    "^": "Constant;referenced,prefix<",
    $eq: function(_, other) {
      if (other == null)
        return false;
      return !!J.getInterceptor(other).$isDeferredConstant && this.referenced.$eq(0, other.referenced) && this.prefix === other.prefix;
    },
    get$hashCode: function(_) {
      var t1 = this.referenced;
      return t1.get$hashCode(t1) * 17 + this.prefix.hashCode & 1073741823;
    },
    getDependencies$0: function() {
      return H.setRuntimeTypeInfo([this.referenced], [K.Constant]);
    },
    accept$1: function(_, visitor) {
      return visitor.visitDeferred$1(this);
    },
    computeType$1: function(compiler) {
      return this.referenced.computeType$1(compiler);
    },
    computeMask$1: function(compiler) {
      return this.referenced.computeMask$1(compiler);
    },
    toString$0: function(_) {
      return "DeferredConstant(" + this.referenced.toString$0(0) + ")";
    },
    $isDeferredConstant: true
  },
  DiagnosticListener: {
    "^": "Object;"
  },
  EnqueueTask: {
    "^": "CompilerTask;resolution,codegen,compiler,watch,profilerTag",
    get$name: function(_) {
      return "Enqueue";
    },
    EnqueueTask$1: function(compiler) {
      var t1, t2;
      t1 = this.codegen;
      t1.task = this;
      t2 = this.resolution;
      t2.task = this;
      t1.nativeEnqueuer = compiler.backend.nativeCodegenEnqueuer$1(t1);
      t2.nativeEnqueuer = compiler.backend.nativeResolutionEnqueuer$1(t2);
    }
  },
  Enqueuer: {
    "^": "Object;name>,compiler<",
    itemCompilationContextCreator$0: function() {
      return this.itemCompilationContextCreator.call$0();
    },
    get$isResolutionQueue: function() {
      return false;
    },
    addToWorkList$1: [function(element) {
      this.internalAddToWorkList$1(element);
    }, "call$1", "get$addToWorkList", 2, 0, 47],
    registerInstantiatedType$3$mirrorUsage: function(type, registry, mirrorUsage) {
      this.task.measure$1(new K.Enqueuer_registerInstantiatedType_closure(this, type, registry, mirrorUsage));
    },
    registerInstantiatedType$2: function(type, registry) {
      return this.registerInstantiatedType$3$mirrorUsage(type, registry, false);
    },
    processInstantiatedClassMember$2: [function(cls, member) {
      var memberName, t1, t2, t3;
      if (this.isProcessed$1(member))
        return;
      if (!member.get$isInstanceMember())
        return;
      memberName = member.name;
      t1 = member.kind;
      if (t1 === C.ElementKind_field_1)
        if (cls.get$isNative()) {
          t1 = this.compiler;
          t1.world.registerUsedElement$1(member);
          this.nativeEnqueuer.handleFieldAnnotations$1(member);
          t2 = this.universe;
          if (t2.hasMatchingSelector$3(t2.invokedGetters.$index(0, memberName), member, t1) || t2.hasMatchingSelector$3(t2.invokedNames.$index(0, memberName), member, t1)) {
            this.nativeEnqueuer.registerFieldLoad$1(member);
            this.nativeEnqueuer.registerFieldStore$1(member);
            this.internalAddToWorkList$1(member);
            return;
          }
          if (t2.hasMatchingSelector$3(t2.invokedSetters.$index(0, memberName), member, t1)) {
            this.nativeEnqueuer.registerFieldStore$1(member);
            this.nativeEnqueuer.registerFieldLoad$1(member);
            this.internalAddToWorkList$1(member);
            return;
          }
        } else {
          this.internalAddToWorkList$1(member);
          return;
        }
      else if (t1 === C.ElementKind_function_2) {
        if (memberName === "noSuchMethod")
          this.enableNoSuchMethod$1(member);
        if (memberName === "call" && cls.get$typeVariables().length !== 0) {
          t1 = this.compiler;
          t2 = t1.globalDependencies;
          t1.backend.registerGenericCallMethod$3(member, this, t2);
          this.universe.genericCallMethods.add$1(0, member);
        }
        t1 = this.universe;
        t2 = this.compiler;
        if (t1.hasMatchingSelector$3(t1.invokedGetters.$index(0, memberName), member, t2)) {
          this.registerClosurizedMember$2(member, t2.globalDependencies);
          this.internalAddToWorkList$1(member);
          return;
        }
        t3 = this.instanceFunctionsByName;
        t3.$indexSet(0, memberName, t3.putIfAbsent$2(memberName, new K.Enqueuer_processInstantiatedClassMember_closure()).prepend$1(member));
        if (t1.hasMatchingSelector$3(t1.invokedNames.$index(0, memberName), member, t2)) {
          this.internalAddToWorkList$1(member);
          return;
        }
      } else if (t1 === C.ElementKind_getter_0) {
        t1 = this.universe;
        t2 = this.compiler;
        if (t1.hasMatchingSelector$3(t1.invokedGetters.$index(0, memberName), member, t2)) {
          this.internalAddToWorkList$1(member);
          return;
        }
        if (t1.hasMatchingSelector$3(t1.invokedNames.$index(0, memberName), member, t2)) {
          this.internalAddToWorkList$1(member);
          return;
        }
      } else if (t1 === C.ElementKind_setter_0) {
        t1 = this.universe;
        if (t1.hasMatchingSelector$3(t1.invokedSetters.$index(0, memberName), member, this.compiler)) {
          this.internalAddToWorkList$1(member);
          return;
        }
      }
      t1 = this.instanceMembersByName;
      t1.$indexSet(0, memberName, t1.putIfAbsent$2(memberName, new K.Enqueuer_processInstantiatedClassMember_closure0()).prepend$1(member));
    }, "call$2", "get$processInstantiatedClassMember", 4, 0, 51],
    enableNoSuchMethod$1: function(element) {
    },
    enableIsolateSupport$0: function() {
    },
    onRegisterInstantiatedClass$1: function(cls) {
      this.task.measure$1(new K.Enqueuer_onRegisterInstantiatedClass_closure(this, cls));
    },
    registerNewSelector$2: function(selector, selectorsMap) {
      var $name, selectors, t1;
      $name = selector.name;
      selectors = selectorsMap.putIfAbsent$2($name, new K.Enqueuer_registerNewSelector_closure());
      t1 = J.getInterceptor$asx(selectors);
      if (t1.contains$1(selectors, selector) !== true) {
        t1.add$1(selectors, selector);
        this.handleUnseenSelector$2($name, selector);
      }
    },
    registerInvocation$1: function(selector) {
      this.task.measure$1(new K.Enqueuer_registerInvocation_closure(this, selector));
    },
    registerInvokedGetter$1: function(selector) {
      this.task.measure$1(new K.Enqueuer_registerInvokedGetter_closure(this, selector));
    },
    registerInvokedSetter$1: function(selector) {
      this.task.measure$1(new K.Enqueuer_registerInvokedSetter_closure(this, selector));
    },
    logEnqueueReflectiveAction$2: function(action, msg) {
    },
    logEnqueueReflectiveAction$1: function(action) {
      return this.logEnqueueReflectiveAction$2(action, "");
    },
    enqueueReflectiveMember$2: function(element, enclosingWasIncluded) {
      var t1, selector;
      if (this.shouldIncludeElementDueToMirrors$2$includedEnclosing(element, enclosingWasIncluded))
        if (element.get$kind(element) === C.ElementKind_typedef_32) {
          t1 = this.compiler;
          element.ensureResolved$1(t1);
          t1.world.allTypedefs.add$1(0, element);
        } else if (O.Elements_isStaticOrTopLevel(element))
          this.registerStaticUse$1(element.get$declaration());
        else if (element.get$isInstanceMember()) {
          selector = Z.Selector_Selector$fromElement(element, this.compiler);
          t1 = selector.kind;
          if (t1 === C.SelectorKind_getter_0)
            this.registerInvokedGetter$1(selector);
          else if (t1 === C.SelectorKind_setter_1)
            this.registerInvokedSetter$1(selector);
          else
            this.registerInvocation$1(selector);
          if (element.kind === C.ElementKind_field_1)
            this.registerInvokedSetter$1(Z.Selector_Selector(C.SelectorKind_setter_1, element.name, element.get$library(), 1, null));
        }
    },
    enqueueReflectiveElementsInClass$3: function(cls, recents, enclosingWasIncluded) {
      var t1, includeClass, decl;
      t1 = cls.get$library().canonicalUri;
      if (t1.scheme === "dart" && C.JSString_methods.startsWith$1(t1._path, "_") || cls.get$isInjected())
        return;
      includeClass = this.shouldIncludeElementDueToMirrors$2$includedEnclosing(cls, enclosingWasIncluded);
      if (includeClass) {
        this.logEnqueueReflectiveAction$2(cls, "register");
        decl = cls.get$declaration();
        t1 = this.compiler;
        decl.ensureResolved$1(t1);
        this.registerInstantiatedType$3$mirrorUsage(decl.get$rawType(), t1.mirrorDependencies, true);
      }
      if (J.contains$1$asx(recents, cls.get$declaration())) {
        this.logEnqueueReflectiveAction$2(cls, "members");
        cls.get$constructors().forEach$1(0, new K.Enqueuer_enqueueReflectiveElementsInClass_closure(this, includeClass));
        cls.forEachClassMember$1(new K.Enqueuer_enqueueReflectiveElementsInClass_closure0(this, includeClass));
      }
    },
    enqueueReflectiveSpecialClasses$0: function() {
      var t1, classes, t2, t3, cls;
      t1 = this.compiler;
      classes = t1.backend.get$classesRequiredForReflection();
      for (t2 = H.setRuntimeTypeInfo(new H.ListIterator(classes, classes.length, 0, null), [H.getTypeArgumentByIndex(classes, 0)]), t3 = t1.mirrorDependencies; t2.moveNext$0();) {
        cls = t2.__internal$_current;
        if (t1.backend.referencedFromMirrorSystem$1(cls)) {
          cls.ensureResolved$1(t1);
          this.registerInstantiatedType$3$mirrorUsage(cls.get$rawType(), t3, true);
        }
      }
    },
    enqueueReflectiveElementsInLibrary$2: function(lib, recents) {
      lib.forEachLocalMember$1(new K.Enqueuer_enqueueReflectiveElementsInLibrary_closure(this, recents, this.shouldIncludeElementDueToMirrors$2$includedEnclosing(lib, false)));
    },
    enqueueReflectiveElements$1: function(recents) {
      var t1, t2;
      t1 = {};
      t1.recents_0 = recents;
      if (!this.hasEnqueuedReflectiveElements) {
        this.logEnqueueReflectiveAction$1("!START enqueueAll");
        t2 = this.seenClasses;
        recents = t2._newSet$0();
        recents.addAll$1(0, t2);
        t1.recents_0 = recents;
        t2 = this.compiler;
        t2.log$1("Enqueuing everything");
        for (t2 = t2.libraryLoader.libraryCanonicalUriMap, t2 = t2.get$values(t2), t2 = H.setRuntimeTypeInfo(new H.MappedIterator(null, J.get$iterator$ax(t2._iterable), t2._f), [H.getTypeArgumentByIndex(t2, 0), H.getTypeArgumentByIndex(t2, 1)]); t2.moveNext$0();)
          this.enqueueReflectiveElementsInLibrary$2(t2.__internal$_current, t1.recents_0);
        this.enqueueReflectiveSpecialClasses$0();
        this.hasEnqueuedReflectiveElements = true;
        this.hasEnqueuedReflectiveStaticFields = true;
        this.logEnqueueReflectiveAction$1("!DONE enqueueAll");
      } else if (C.JSArray_methods.get$isNotEmpty(recents)) {
        this.logEnqueueReflectiveAction$1("!START enqueueRecents");
        J.forEach$1$ax(t1.recents_0, new K.Enqueuer_enqueueReflectiveElements_closure(t1, this));
        this.logEnqueueReflectiveAction$1("!DONE enqueueRecents");
      }
    },
    enqueueReflectiveStaticFields$1: function(elements) {
      var t1;
      if (this.hasEnqueuedReflectiveStaticFields)
        return;
      this.hasEnqueuedReflectiveStaticFields = true;
      for (t1 = H.setRuntimeTypeInfo(new H.ListIterator(elements, elements.length, 0, null), [H.getTypeArgumentByIndex(elements, 0)]); t1.moveNext$0();)
        this.enqueueReflectiveMember$2(t1.__internal$_current, true);
    },
    processLink$3: function(map, memberName, f) {
      var members, remaining, t1;
      members = map.$index(0, memberName);
      if (members != null) {
        map.$indexSet(0, memberName, C.C_Link);
        remaining = H.setRuntimeTypeInfo(new E.LinkBuilderImplementation(null, null, 0), [null]);
        for (; t1 = J.getInterceptor$asx(members), !t1.get$isEmpty(members); members = members.get$tail())
          if (f.call$1(t1.get$head(members)) !== true)
            remaining.addLast$1(t1.get$head(members));
        map.$indexSet(0, memberName, remaining.toLink$1(map.$index(0, memberName)));
      }
    },
    handleUnseenSelector$2: function(methodName, selector) {
      this.processLink$3(this.instanceMembersByName, methodName, new K.Enqueuer_handleUnseenSelector_closure(this, selector));
      if (selector.kind === C.SelectorKind_getter_0)
        this.processLink$3(this.instanceFunctionsByName, methodName, new K.Enqueuer_handleUnseenSelector_closure0(this, selector));
    },
    registerStaticUse$1: [function(element) {
      if (element == null)
        return;
      this.internalAddToWorkList$1(element);
      this.compiler.backend.registerStaticUse$2(element, this);
    }, "call$1", "get$registerStaticUse", 2, 0, 47],
    registerGetOfStaticFunction$1: function(element) {
      this.registerStaticUse$1(element);
      this.compiler.backend.registerGetOfStaticFunction$1(this);
      this.universe.staticFunctionsNeedingGetter.add$1(0, element);
    },
    registerSelectorUse$1: function(selector) {
      var t1 = selector.kind;
      if (t1 === C.SelectorKind_getter_0)
        this.registerInvokedGetter$1(selector);
      else if (t1 === C.SelectorKind_setter_1)
        this.registerInvokedSetter$1(selector);
      else
        this.registerInvocation$1(selector);
    },
    registerIsCheck$2: function(type, registry) {
      this.universe.isChecks.add$1(0, type.unalias$1(this.compiler));
    },
    registerClosurizedMember$2: function(element, registry) {
      this.registerIfGeneric$2(element, registry);
      this.compiler.backend.registerBoundClosure$1(this);
      this.universe.closurizedMembers.add$1(0, element);
    },
    registerIfGeneric$2: function(element, registry) {
      var t1 = this.compiler;
      if (element.computeType$1(t1).get$containsTypeVariables()) {
        t1.backend.registerGenericClosure$3(element, this, registry);
        this.universe.genericClosures.add$1(0, element);
      }
    },
    forEach$1: function(_, f) {
      var t1, recents, t2;
      do {
        for (; t1 = this.get$queue(), !t1.get$isEmpty(t1);)
          f.call$1(this.get$queue().removeLast$0(0));
        t1 = this.recentClasses;
        recents = P.List_List$from(t1, false, H.getRuntimeTypeArgument(t1, "IterableBase", 0));
        t1._setlet$_contents = C.C__SetletMarker;
        t1._extra = null;
        if (!this.onQueueEmpty$1(recents))
          t1.addAll$1(0, recents);
        t2 = this.get$queue();
      } while (!t2.get$isEmpty(t2) || !t1.get$isEmpty(t1));
    },
    onQueueEmpty$1: function(recentClasses) {
      return this.compiler.backend.onQueueEmpty$2(this, recentClasses);
    },
    toString$0: function(_) {
      return "Enqueuer(" + this.name + ")";
    }
  },
  Enqueuer_registerInstantiatedType_closure: {
    "^": "Closure:23;this_0,type_1,registry_2,mirrorUsage_3",
    call$0: function() {
      var t1, cls, t2, t3;
      t1 = this.type_1;
      cls = t1.get$element();
      this.registry_2.registerDependency$1(cls);
      t2 = this.this_0;
      if (cls.get$resolutionState() === 0)
        t2.compiler.resolver.resolveClass$1(cls);
      t3 = t2.universe;
      t3.instantiatedTypes.add$1(0, t1);
      if ((cls.get$modifiers().flags & 2) === 0 || cls.get$nativeTagInfo() != null || this.mirrorUsage_3)
        t3.instantiatedClasses.add$1(0, cls);
      t2.onRegisterInstantiatedClass$1(cls);
    },
    $isFunction: true
  },
  Enqueuer_processInstantiatedClassMember_closure: {
    "^": "Closure:23;",
    call$0: function() {
      return C.C_Link;
    },
    $isFunction: true
  },
  Enqueuer_processInstantiatedClassMember_closure0: {
    "^": "Closure:23;",
    call$0: function() {
      return C.C_Link;
    },
    $isFunction: true
  },
  Enqueuer_onRegisterInstantiatedClass_closure: {
    "^": "Closure:23;this_0,cls_1",
    call$0: function() {
      var t1, t2, supertypes;
      t1 = this.this_0;
      t2 = this.cls_1;
      if (t1.seenClasses.contains$1(0, t2))
        return;
      if (t2.resolutionState === 0)
        t1.compiler.resolver.resolveClass$1(t2);
      t1 = new K.Enqueuer_onRegisterInstantiatedClass__processClass(t1);
      t1.call$1(t2);
      for (supertypes = t2.allSupertypesAndSelf._supertypes; !supertypes.get$isEmpty(supertypes); supertypes = supertypes.get$tail())
        t1.call$1(supertypes.get$head(supertypes).get$element());
    },
    $isFunction: true
  },
  Enqueuer_onRegisterInstantiatedClass__processClass: {
    "^": "Closure:45;this_2",
    call$1: function(cls) {
      var t1, t2, t3;
      t1 = this.this_2;
      t2 = t1.seenClasses;
      if (t2.contains$1(0, cls))
        return;
      t2.add$1(0, cls);
      t1.recentClasses.add$1(0, cls);
      t2 = t1.compiler;
      cls.ensureResolved$1(t2);
      cls.get$implementation(cls).forEachMember$1(t1.get$processInstantiatedClassMember());
      if (t1.get$isResolutionQueue()) {
        t3 = t2.resolver;
        cls.computeAllClassMembers$1(t3.compiler);
        if (cls.get$isMixinApplication())
          t3.checkMixinApplication$1(cls);
        else
          t3.checkClassMembers$1(cls);
      }
      t2.backend.registerInstantiatedClass$3(cls, t1, t2.globalDependencies);
    },
    $isFunction: true
  },
  Enqueuer_registerNewSelector_closure: {
    "^": "Closure:23;",
    call$0: function() {
      return H.setRuntimeTypeInfo(new N.Setlet(C.C__SetletMarker, null), [Z.Selector]);
    },
    $isFunction: true
  },
  Enqueuer_registerInvocation_closure: {
    "^": "Closure:23;this_0,selector_1",
    call$0: function() {
      var t1 = this.this_0;
      t1.registerNewSelector$2(this.selector_1, t1.universe.invokedNames);
    },
    $isFunction: true
  },
  Enqueuer_registerInvokedGetter_closure: {
    "^": "Closure:23;this_0,selector_1",
    call$0: function() {
      var t1 = this.this_0;
      t1.registerNewSelector$2(this.selector_1, t1.universe.invokedGetters);
    },
    $isFunction: true
  },
  Enqueuer_registerInvokedSetter_closure: {
    "^": "Closure:23;this_0,selector_1",
    call$0: function() {
      var t1 = this.this_0;
      t1.registerNewSelector$2(this.selector_1, t1.universe.invokedSetters);
    },
    $isFunction: true
  },
  Enqueuer_enqueueReflectiveElementsInClass_closure: {
    "^": "Closure:77;this_0,includeClass_1",
    call$1: function(element) {
      var t1 = this.this_0;
      if (t1.shouldIncludeElementDueToMirrors$2$includedEnclosing(element, this.includeClass_1)) {
        t1.logEnqueueReflectiveAction$1(element);
        t1.registerInstantiatedType$3$mirrorUsage(element.get$declaration().get$enclosingClass().get$rawType(), t1.compiler.mirrorDependencies, true);
        t1.registerStaticUse$1(element.get$declaration());
      }
    },
    $isFunction: true
  },
  Enqueuer_enqueueReflectiveElementsInClass_closure0: {
    "^": "Closure:86;this_2,includeClass_3",
    call$1: function(member) {
      this.this_2.enqueueReflectiveMember$2(member.get$element(), this.includeClass_3);
    },
    $isFunction: true
  },
  Enqueuer_enqueueReflectiveElementsInLibrary_closure: {
    "^": "Closure:77;this_0,recents_1,includeLibrary_2",
    call$1: function(member) {
      var t1, t2;
      t1 = this.this_0;
      t2 = this.includeLibrary_2;
      if (J.get$kind$x(member) === C.ElementKind_class_4)
        t1.enqueueReflectiveElementsInClass$3(member, this.recents_1, t2);
      else
        t1.enqueueReflectiveMember$2(member, t2);
    },
    $isFunction: true
  },
  Enqueuer_enqueueReflectiveElements_closure: {
    "^": "Closure:87;box_0,this_1",
    call$1: function(cls) {
      var t1 = this.this_1;
      t1.enqueueReflectiveElementsInClass$3(cls, this.box_0.recents_0, t1.shouldIncludeElementDueToMirrors$2$includedEnclosing(cls.get$library(), false));
    },
    $isFunction: true
  },
  Enqueuer_handleUnseenSelector_closure: {
    "^": "Closure:77;this_0,selector_1",
    call$1: function(member) {
      var t1, t2, t3;
      t1 = this.selector_1;
      t2 = this.this_0;
      t3 = t2.compiler;
      if (t1.appliesUnnamed$2(member, t3)) {
        if (member.get$isFunction() && t1.kind === C.SelectorKind_getter_0)
          t2.registerClosurizedMember$2(member, t3.globalDependencies);
        if (member.get$kind(member) === C.ElementKind_field_1 && member.get$enclosingClass().get$isNative()) {
          t1 = t1.kind;
          t1 = t1 === C.SelectorKind_getter_0 || t1 === C.SelectorKind_call_2;
          t3 = t2.nativeEnqueuer;
          if (t1) {
            t3.registerFieldLoad$1(member);
            t2.nativeEnqueuer.registerFieldStore$1(member);
          } else {
            t3.registerFieldStore$1(member);
            t2.nativeEnqueuer.registerFieldLoad$1(member);
          }
        }
        t2.internalAddToWorkList$1(member);
        return true;
      }
      return false;
    },
    $isFunction: true
  },
  Enqueuer_handleUnseenSelector_closure0: {
    "^": "Closure:77;this_2,selector_3",
    call$1: function(member) {
      var t1, t2;
      t1 = this.this_2;
      t2 = t1.compiler;
      if (this.selector_3.appliesUnnamed$2(member, t2)) {
        t1.registerClosurizedMember$2(member, t2.globalDependencies);
        return true;
      }
      return false;
    },
    $isFunction: true
  },
  ResolutionEnqueuer: {
    "^": "Enqueuer;resolvedElements,queue<,deferredTaskQueue,name,compiler,itemCompilationContextCreator,instanceMembersByName,instanceFunctionsByName,seenClasses,recentClasses,universe,queueIsClosed,task,nativeEnqueuer,hasEnqueuedReflectiveElements,hasEnqueuedReflectiveStaticFields",
    get$isResolutionQueue: function() {
      return true;
    },
    isProcessed$1: function(member) {
      return this.resolvedElements.contains$1(0, member);
    },
    isLive$1: [function(element) {
      if (this.seenClasses.contains$1(0, element))
        return true;
      if (this.resolvedElements.contains$1(0, element.get$analyzableElement().get$declaration()))
        return true;
      return false;
    }, "call$1", "get$isLive", 2, 0, 76],
    shouldIncludeElementDueToMirrors$2$includedEnclosing: function(element, includedEnclosing) {
      return includedEnclosing || this.compiler.backend.requiredByMirrorSystem$1(element);
    },
    internalAddToWorkList$1: function(element) {
      var t1, library, t2, uri;
      if (this.resolvedElements.contains$1(0, element.get$analyzableElement().get$declaration()))
        return false;
      if (this.queueIsClosed)
        throw H.wrapException(O.SpannableAssertionFailure$(element, "Resolution work list is closed. Trying to add " + element.toString$0(0) + "."));
      t1 = this.compiler;
      t1.world.registerUsedElement$1(element);
      this.queue._add$1(new K.ResolutionWorkItem(null, this.itemCompilationContextCreator$0(), element));
      library = element.get$library();
      if (!t1.hasIsolateSupport)
        t2 = element.kind !== C.ElementKind_field_1 || !element.get$isConst();
      else
        t2 = false;
      if (t2) {
        uri = library.canonicalUri.toString$0(0);
        if (uri === "dart:isolate") {
          t1.hasIsolateSupport = true;
          t1.backend.enableIsolateSupport$1(this);
        } else if (uri === "dart:async") {
          t2 = element.name;
          if (t2 === "_createTimer" || t2 === "_createPeriodicTimer") {
            t1.hasIsolateSupport = true;
            t1.backend.enableIsolateSupport$1(this);
          }
        }
      }
      if (element.get$isGetter() && element.name === "runtimeType") {
        t1.enabledRuntimeType = true;
        t1.backend.registerRuntimeType$2(this, t1.globalDependencies);
      } else if (element === t1.functionApplyMethod)
        t1.enabledFunctionApply = true;
      this.nativeEnqueuer.registerElement$1(0, element);
      return true;
    },
    enableIsolateSupport$0: function() {
      var t1 = this.compiler;
      t1.hasIsolateSupport = true;
      t1.backend.enableIsolateSupport$1(this);
    },
    enableNoSuchMethod$1: function(element) {
      var t1 = this.compiler;
      if (t1.enabledNoSuchMethod)
        return;
      if (t1.backend.isDefaultNoSuchMethodImplementation$1(element))
        return;
      t1.enabledNoSuchMethod = true;
      t1.backend.enableNoSuchMethod$2(element, this);
    },
    onQueueEmpty$1: function(recentClasses) {
      this.emptyDeferredTaskQueue$0();
      return K.Enqueuer.prototype.onQueueEmpty$1.call(this, recentClasses);
    },
    emptyDeferredTaskQueue$0: function() {
      var t1, t2, task;
      for (t1 = this.deferredTaskQueue, t2 = this.compiler; t1._head !== t1._tail;) {
        task = t1.removeFirst$0();
        t2.withCurrentElement$2(task.get$element(), J.get$action$x(task));
      }
    },
    _logSpecificSummary$1: function(log) {
      log.call$1("Resolved " + this.resolvedElements._collection$_length + " elements.");
    }
  },
  CodegenEnqueuer: {
    "^": "Enqueuer;queue<,generatedCode<,newlyEnqueuedElements,name,compiler,itemCompilationContextCreator,instanceMembersByName,instanceFunctionsByName,seenClasses,recentClasses,universe,queueIsClosed,task,nativeEnqueuer,hasEnqueuedReflectiveElements,hasEnqueuedReflectiveStaticFields",
    isProcessed$1: function(member) {
      return member.get$isAbstract() || this.generatedCode.containsKey$1(member);
    },
    shouldIncludeElementDueToMirrors$2$includedEnclosing: function(element, includedEnclosing) {
      return this.compiler.backend.isAccessibleByReflection$1(element);
    },
    internalAddToWorkList$1: function(element) {
      var t1, workItem;
      t1 = this.compiler;
      if (t1.hasIncrementalSupport)
        this.newlyEnqueuedElements.add$1(0, element);
      if (element.isForeign$1(t1))
        return false;
      if (element.kind === C.ElementKind_field_1 && element.get$isInstanceMember())
        if (!t1.enableTypeAssertions || element.get$enclosingElement().get$isClosure())
          return false;
      if (this.queueIsClosed)
        throw H.wrapException(O.SpannableAssertionFailure$(element, "Codegen work list is closed. Trying to add " + element.toString$0(0)));
      t1 = this.itemCompilationContextCreator$0();
      workItem = new K.CodegenWorkItem(null, element.get$resolvedAst().elements, t1, element);
      workItem.CodegenWorkItem$2(element, t1);
      this.queue._add$1(workItem);
      return true;
    },
    _logSpecificSummary$1: function(log) {
      log.call$1("Compiled " + this.generatedCode._collection$_length + " methods.");
    }
  },
  QueueFilter: {
    "^": "Object;"
  },
  ResolvedVisitor: {
    "^": "Visitor;compiler<,elements>",
    visitSend$1: function(node) {
      var element, t1, t2;
      this.elements.toString;
      element = node.get$_secret_tree_element$_element();
      t1 = this.elements._asserts;
      if (t1 != null && t1.contains$1(0, node) === true)
        return this.visitAssert$1(node);
      else {
        t1 = this.elements._types;
        if ((t1 != null ? t1.$index(0, node) : null) != null)
          return this.visitTypeLiteralSend$1(node);
        else {
          t1 = node.receiver;
          if (t1 != null && t1.isSuper$0())
            return this.visitSuperSend$1(node);
          else if (!!J.getInterceptor(node.selector).$isOperator)
            return this.visitOperatorSend$1(node);
          else if (node.argumentsNode == null)
            if (!(element == null || element.get$isErroneous()) && element.get$impliesType())
              return this.visitTypePrefixSend$1(node);
            else
              return this.visitGetterSend$1(node);
          else {
            t1 = element == null;
            t2 = !t1;
            if (t2 && Y.Initializers_isConstructorRedirect(node))
              return this.visitStaticSend$1(node);
            else if (O.Elements_isClosureSend(node, element))
              return this.visitClosureSend$1(node);
            else if (!t2 || element.get$isErroneous())
              if (t1)
                return this.visitDynamicSend$1(node);
              else
                return this.visitStaticSend$1(node);
            else if (element.get$isInstanceMember())
              return this.visitDynamicSend$1(node);
            else if (!element.get$isInstanceMember())
              return this.visitStaticSend$1(node);
            else {
              this.internalError$2$node("Cannot generate code for send", node);
              return;
            }
          }
        }
      }
    },
    visitNode$1: function(node) {
      this.internalError$2$node("Unhandled node", node);
      return;
    }
  },
  Script: {
    "^": "Object;file,readableUri,resourceUri",
    get$text: function(_) {
      var t1 = this.file;
      return t1 == null ? null : t1.slowText$0();
    },
    get$name: function(_) {
      var t1 = this.file;
      return t1 == null ? null : t1.filename;
    }
  },
  TreeValidatorTask: {
    "^": "CompilerTask;compiler,watch,profilerTag"
  },
  TypeCheckerTask: {
    "^": "CompilerTask;compiler,watch,profilerTag",
    get$name: function(_) {
      return "Type checker";
    },
    check$1: function(elements) {
      var element = elements.get$analyzedElement();
      this.compiler.withCurrentElement$2(element, new K.TypeCheckerTask_check_closure(this, elements, element));
    }
  },
  TypeCheckerTask_check_closure: {
    "^": "Closure:23;this_0,elements_1,element_2",
    call$0: function() {
      var t1 = this.this_0;
      t1.measure$1(new K.TypeCheckerTask_check__closure(t1, this.elements_1, this.element_2));
    },
    $isFunction: true
  },
  TypeCheckerTask_check__closure: {
    "^": "Closure:23;this_3,elements_4,element_5",
    call$0: function() {
      var t1, tree, t2, t3, t4, t5, t6, t7, t8, visitor;
      t1 = this.element_5;
      tree = t1.get$node();
      t2 = this.this_3.compiler;
      t3 = this.elements_4;
      t4 = t2.types;
      t5 = P.LinkedHashMap_LinkedHashMap(null, null, null, Y.Node, [P.List, K.TypePromotion]);
      t6 = P.LinkedHashMap_LinkedHashMap(null, null, null, O.VariableElement, [O.Link, K.TypePromotion]);
      t7 = P.LinkedHashSet_LinkedHashSet(null, null, null, K.TypePromotion);
      t8 = t3.analyzedElement;
      t8 = t8 != null ? t8.get$enclosingClass() : null;
      visitor = new K.TypeCheckerVisitor(t2, t3, t4, null, null, t8, null, null, C.C_Link0, false, null, null, null, null, null, null, t5, t6, t7);
      visitor.TypeCheckerVisitor$3(t2, t3, t4);
      if (t1.get$kind(t1) === C.ElementKind_field_1)
        visitor.analyzingInitializer = true;
      tree.accept$1(0, visitor);
    },
    $isFunction: true
  },
  MemberKind: {
    "^": "Object;name>",
    toString$0: function(_) {
      return this.name;
    },
    static: {"^": "MemberKind_METHOD,MemberKind_OPERATOR,MemberKind_GETTER,MemberKind_SETTER"}
  },
  ElementAccess: {
    "^": "Object;",
    isCallable$1: function(compiler) {
      var t1, t2, t3;
      if (this.get$element() != null) {
        t1 = this.get$element();
        t1 = t1.get$kind(t1) === C.ElementKind_abstract_field_1;
      } else
        t1 = false;
      if (t1)
        if (this.get$element().get$getter() == null)
          return false;
      t1 = compiler.types;
      t2 = this.computeType$1(compiler);
      t3 = compiler.functionClass.computeType$1(compiler);
      t1 = t1.subtypeVisitor;
      return t1.isSubtype$2(t2, t3) || t1.isSubtype$2(t3, t2);
    }
  },
  MemberAccess: {
    "^": "ElementAccess;member",
    get$element: function() {
      return J.get$first$ax(this.member.get$declarations()).get$element();
    },
    computeType$1: function(compiler) {
      var t1 = this.member;
      return t1.get$type(t1);
    },
    toString$0: function(_) {
      return "MemberAccess(" + this.member.toString$0(0) + ")";
    }
  },
  DynamicAccess: {
    "^": "Object;",
    get$element: function() {
      return;
    },
    computeType$1: function(compiler) {
      return C.C_DynamicType;
    },
    isCallable$1: function(compiler) {
      return true;
    },
    toString$0: function(_) {
      return "DynamicAccess";
    }
  },
  AssertAccess: {
    "^": "Object;",
    get$element: function() {
      return;
    },
    computeType$1: function(compiler) {
      return V.FunctionType$internal(null, C.C_VoidType, H.setRuntimeTypeInfo([C.C_DynamicType], [V.DartType]), C.List_empty3, C.List_empty0, C.List_empty3);
    },
    isCallable$1: function(compiler) {
      return true;
    },
    toString$0: function(_) {
      return "AssertAccess";
    }
  },
  ResolvedAccess: {
    "^": "ElementAccess;element<",
    computeType$1: function(compiler) {
      var t1, functionType;
      t1 = this.element;
      if (t1.get$isGetter())
        return t1.computeType$1(compiler).get$returnType();
      else if (t1.get$kind(t1) === C.ElementKind_setter_0) {
        functionType = t1.computeType$1(compiler);
        if (functionType.get$parameterTypes().length !== 1)
          return C.C_DynamicType;
        return J.get$first$ax(functionType.get$parameterTypes());
      } else
        return t1.computeType$1(compiler);
    },
    toString$0: function(_) {
      return "ResolvedAccess(" + this.element.toString$0(0) + ")";
    }
  },
  PromotedAccess: {
    "^": "ElementAccess;element<,type>",
    computeType$1: function(compiler) {
      return this.type;
    },
    toString$0: function(_) {
      return "PromotedAccess(" + this.element.toString$0(0) + "," + J.toString$0(this.type) + ")";
    }
  },
  TypeAccess: {
    "^": "ElementAccess;type>",
    get$element: function() {
      return this.type.get$element();
    },
    computeType$1: function(compiler) {
      return this.type;
    },
    toString$0: function(_) {
      return "TypeAccess(" + J.toString$0(this.type) + ")";
    }
  },
  TypeLiteralAccess: {
    "^": "ElementAccess;type>",
    get$element: function() {
      return this.type.get$element();
    },
    computeType$1: function(compiler) {
      return compiler.typeClass.get$rawType();
    },
    toString$0: function(_) {
      return "TypeLiteralAccess(" + J.toString$0(this.type) + ")";
    }
  },
  FunctionCallAccess: {
    "^": "Object;element<,type>",
    computeType$1: function(compiler) {
      return this.type;
    },
    isCallable$1: function(compiler) {
      return true;
    },
    toString$0: function(_) {
      return "FunctionAccess(" + J.toString$0(this.element) + ", " + this.type.toString$0(0) + ")";
    }
  },
  TypePromotion: {
    "^": "Object;node<,variable<,type>,messages<",
    toString$0: function(_) {
      var t1 = "Promote " + this.variable.toString$0(0) + " to " + J.toString$0(this.type);
      return t1 + (this.messages.length === 0 ? "" : " (invalid)");
    }
  },
  TypePromotionMessage: {
    "^": "Object;diagnostic<,spannable,messageKind,messageArguments"
  },
  TypeCheckerVisitor: {
    "^": "Visitor;compiler<,elements>,types<,lastSeenNode,expectedReturnType,currentClass,thisType@,superType,cascadeTypes,analyzingInitializer,intType,doubleType,boolType,stringType,objectType,listType,shownTypePromotionsMap,typePromotionsMap,reportedTypePromotions",
    showTypePromotion$2: function(node, typePromotion) {
      J.add$1$ax(this.shownTypePromotionsMap.putIfAbsent$2(node, new K.TypeCheckerVisitor_showTypePromotion_closure()), typePromotion);
    },
    registerKnownTypePromotion$1: function(typePromotion) {
      var variable, t1;
      variable = typePromotion.variable;
      t1 = this.typePromotionsMap;
      t1.$indexSet(0, variable, t1.putIfAbsent$2(variable, new K.TypeCheckerVisitor_registerKnownTypePromotion_closure()).prepend$1(typePromotion));
    },
    getShownTypePromotionsFor$1: function(node) {
      var shownTypePromotions = this.shownTypePromotionsMap.$index(0, node);
      return shownTypePromotions != null ? shownTypePromotions : C.List_empty;
    },
    getKnownTypePromotion$1: function(element) {
      var promotions, t1, typePromotion;
      promotions = this.typePromotionsMap.$index(0, element);
      if (promotions != null)
        for (; t1 = J.getInterceptor$asx(promotions), !t1.get$isEmpty(promotions);) {
          typePromotion = t1.get$head(promotions);
          if (typePromotion.get$messages().length === 0)
            return typePromotion;
          promotions = promotions.get$tail();
        }
      return;
    },
    getKnownType$1: function(element) {
      var typePromotion = this.getKnownTypePromotion$1(element);
      if (typePromotion != null)
        return typePromotion.type;
      return element.get$type(element);
    },
    reportTypePromotionHint$1: function(typePromotion) {
      var t1, t2, message;
      t1 = this.reportedTypePromotions;
      if (!t1.contains$1(0, typePromotion)) {
        t1.add$1(0, typePromotion);
        t1 = typePromotion.messages;
        t2 = new H.ListIterator(t1, t1.length, 0, null);
        t2.$builtinTypeInfo = [H.getTypeArgumentByIndex(t1, 0)];
        t1 = this.compiler;
        for (; t2.moveNext$0();) {
          message = t2.__internal$_current;
          switch (message.get$diagnostic()) {
            case C.Diagnostic_4_hint:
              t1.reportDiagnosticInternal$4(message.spannable, message.messageKind, message.messageArguments, C.Diagnostic_4_hint);
              break;
            case C.Diagnostic_8_info:
              t1.reportDiagnosticInternal$4(message.spannable, message.messageKind, message.messageArguments, C.Diagnostic_8_info);
              break;
          }
        }
      }
    },
    analyze$2$inInitializer: function(node, inInitializer) {
      var t1, t2, previouslyInitializer, result;
      if (node == null) {
        t1 = this.lastSeenNode;
        t2 = this.compiler;
        if (t1 != null)
          t2.internalError$2(t1, "Unexpected node: null");
        else
          t2.internalError$2(this.elements.analyzedElement, "Unexpected node: null");
      } else
        this.lastSeenNode = node;
      previouslyInitializer = this.analyzingInitializer;
      this.analyzingInitializer = inInitializer;
      result = J.accept$1$x(node, this);
      this.analyzingInitializer = previouslyInitializer;
      if (result == null)
        this.compiler.internalError$2(node, "Type is null.");
      return result;
    },
    analyze$1: function(node) {
      return this.analyze$2$inInitializer(node, false);
    },
    checkTypePromotion$3$checkAccesses: function(node, typePromotion, checkAccesses) {
      var variable, variableName, t1, potentialMutationsIn, t2, t3, potentialMutationsInClosures, accesses, mutations;
      variable = typePromotion.variable;
      variableName = variable.get$name(variable);
      t1 = this.elements;
      potentialMutationsIn = t1.getPotentialMutationsIn$2(node, variable);
      t2 = J.getInterceptor$asx(potentialMutationsIn);
      if (!t2.get$isEmpty(potentialMutationsIn)) {
        t3 = typePromotion.messages;
        t3.push(new K.TypePromotionMessage(C.Diagnostic_4_hint, typePromotion.node, C.MessageKind_WR80, P.LinkedHashMap_LinkedHashMap$_literal(["variableName", variableName, "shownType", typePromotion.type], null, null)));
        for (t2 = t2.get$iterator(potentialMutationsIn); t2.moveNext$0();)
          t3.push(new K.TypePromotionMessage(C.Diagnostic_8_info, t2.get$current(), C.MessageKind_yXb, P.LinkedHashMap_LinkedHashMap$_literal(["variableName", variableName], null, null)));
      }
      potentialMutationsInClosures = t1.getPotentialMutationsInClosure$1(variable);
      t2 = J.getInterceptor$asx(potentialMutationsInClosures);
      if (!t2.get$isEmpty(potentialMutationsInClosures)) {
        t3 = typePromotion.messages;
        t3.push(new K.TypePromotionMessage(C.Diagnostic_4_hint, typePromotion.node, C.MessageKind_ahM, P.LinkedHashMap_LinkedHashMap$_literal(["variableName", variableName, "shownType", typePromotion.type], null, null)));
        for (t2 = t2.get$iterator(potentialMutationsInClosures); t2.moveNext$0();)
          t3.push(new K.TypePromotionMessage(C.Diagnostic_8_info, t2.get$current(), C.MessageKind_ifn, P.LinkedHashMap_LinkedHashMap$_literal(["variableName", variableName], null, null)));
      }
      if (checkAccesses) {
        accesses = t1.getAccessesByClosureIn$2(node, variable);
        mutations = t1.getPotentialMutations$1(variable);
        t1 = J.getInterceptor$asx(accesses);
        if (!t1.get$isEmpty(accesses) && !J.get$isEmpty$asx(mutations)) {
          t2 = typePromotion.messages;
          t2.push(new K.TypePromotionMessage(C.Diagnostic_4_hint, typePromotion.node, C.MessageKind_3fE, P.LinkedHashMap_LinkedHashMap$_literal(["variableName", variableName, "shownType", typePromotion.type], null, null)));
          for (t1 = t1.get$iterator(accesses); t1.moveNext$0();)
            t2.push(new K.TypePromotionMessage(C.Diagnostic_8_info, t1.get$current(), C.MessageKind_xKU, P.LinkedHashMap_LinkedHashMap$_literal(["variableName", variableName], null, null)));
          for (t1 = J.get$iterator$ax(mutations); t1.moveNext$0();)
            t2.push(new K.TypePromotionMessage(C.Diagnostic_8_info, t1.get$current(), C.MessageKind_yXb, P.LinkedHashMap_LinkedHashMap$_literal(["variableName", variableName], null, null)));
        }
      }
    },
    checkTypePromotion$2: function(node, typePromotion) {
      return this.checkTypePromotion$3$checkAccesses(node, typePromotion, false);
    },
    reshowTypePromotions$3: function(node, left, right) {
      var t1, typePromotion, t2, t3, t4, t5, typePromotion0;
      for (t1 = J.get$iterator$ax(this.getShownTypePromotionsFor$1(left)); t1.moveNext$0();) {
        typePromotion = t1.get$current();
        t2 = typePromotion.get$node();
        t3 = typePromotion.get$variable();
        t4 = J.get$type$x(typePromotion);
        t5 = [];
        t5.$builtinTypeInfo = [K.TypePromotionMessage];
        typePromotion0 = new K.TypePromotion(t2, t3, t4, t5);
        C.JSArray_methods.addAll$1(t5, typePromotion.get$messages());
        this.checkTypePromotion$2(right, typePromotion0);
        this.showTypePromotion$2(node, typePromotion0);
      }
      for (t1 = J.get$iterator$ax(this.getShownTypePromotionsFor$1(right)); t1.moveNext$0();) {
        typePromotion = t1.get$current();
        t2 = typePromotion.get$node();
        t3 = typePromotion.get$variable();
        t4 = J.get$type$x(typePromotion);
        t5 = [];
        t5.$builtinTypeInfo = [K.TypePromotionMessage];
        typePromotion0 = new K.TypePromotion(t2, t3, t4, t5);
        C.JSArray_methods.addAll$1(t5, typePromotion.get$messages());
        this.checkTypePromotion$2(right, typePromotion0);
        this.showTypePromotion$2(node, typePromotion0);
      }
    },
    analyzeInPromotedContext$2: function(context, node) {
      var t1, knownForNode, typePromotion, t2, t3, t4, t5, typePromotion0, type, variable, knownTypes;
      for (t1 = J.get$iterator$ax(this.getShownTypePromotionsFor$1(context)), knownForNode = C.C_Link1; t1.moveNext$0();) {
        typePromotion = t1.get$current();
        t2 = typePromotion.get$node();
        t3 = typePromotion.get$variable();
        t4 = J.get$type$x(typePromotion);
        t5 = [];
        t5.$builtinTypeInfo = [K.TypePromotionMessage];
        typePromotion0 = new K.TypePromotion(t2, t3, t4, t5);
        C.JSArray_methods.addAll$1(t5, typePromotion.get$messages());
        this.checkTypePromotion$3$checkAccesses(node, typePromotion0, true);
        knownForNode = knownForNode.prepend$1(typePromotion0);
        this.registerKnownTypePromotion$1(typePromotion0);
      }
      type = this.analyze$1(node);
      for (t1 = this.typePromotionsMap; !knownForNode.get$isEmpty(knownForNode);) {
        variable = knownForNode.get$head(knownForNode).get$variable();
        knownTypes = t1.$index(0, variable).get$tail();
        if (knownTypes.get$isEmpty(knownTypes))
          t1.remove$1(0, variable);
        else
          t1.$indexSet(0, variable, knownTypes);
        knownForNode = knownForNode.get$tail();
      }
      return type;
    },
    checkAssignable$4$isConst: function(spannable, from, to, isConst) {
      var t1 = this.types.subtypeVisitor;
      if (!(t1.isSubtype$2(from, to) || t1.isSubtype$2(to, from))) {
        t1 = this.compiler;
        if (t1.enableTypeAssertions && isConst)
          t1.reportDiagnosticInternal$4(spannable, C.MessageKind_Yeh, P.LinkedHashMap_LinkedHashMap$_literal(["fromType", from, "toType", to], null, null), C.Diagnostic_1_error);
        else
          t1.reportDiagnosticInternal$4(spannable, C.MessageKind_Yeh, P.LinkedHashMap_LinkedHashMap$_literal(["fromType", from, "toType", to], null, null), C.Diagnostic_2_warning);
        return false;
      }
      return true;
    },
    checkAssignable$3: function(spannable, from, to) {
      return this.checkAssignable$4$isConst(spannable, from, to, false);
    },
    visitBlock$1: function(node) {
      return this.analyze$1(node.statements);
    },
    visitCascade$1: function(node) {
      var t1, type;
      this.analyze$1(node.expression);
      t1 = this.cascadeTypes;
      type = t1.get$head(t1);
      this.cascadeTypes = this.cascadeTypes.get$tail();
      return type;
    },
    visitCascadeReceiver$1: function(node) {
      var type = this.analyze$1(node.expression);
      this.cascadeTypes = this.cascadeTypes.prepend$1(type);
      return type;
    },
    visitDoWhile$1: function(node) {
      var t1;
      this.analyze$1(node.body);
      t1 = node.condition;
      this.checkAssignable$3(t1, this.analyze$1(t1), this.boolType);
      return C.C_StatementType;
    },
    visitExpressionStatement$1: function(node) {
      this.analyze$1(node.expression);
      return C.C_StatementType;
    },
    visitFor$1: function(node) {
      var t1 = node.initializer;
      if (t1 != null)
        this.analyze$1(t1);
      if (node.get$condition() != null) {
        t1 = node.get$condition();
        this.checkAssignable$3(t1, this.analyze$1(t1), this.boolType);
      }
      this.analyze$1(node.update);
      return this.analyze$1(node.body);
    },
    visitFunctionDeclaration$1: function(node) {
      this.analyze$1(node.$function);
      return C.C_StatementType;
    },
    visitFunctionExpression$1: function(node) {
      var element, t1, type, returnType, functionType, previous;
      element = node.get$_secret_tree_element$_element();
      if (element == null || element.get$isErroneous())
        return C.C_DynamicType;
      if (element.get$kind(element) === C.ElementKind_generative_constructor_16 || element.kind === C.ElementKind_generative_constructor_body_0) {
        element.get$functionSignature().forEachParameter$1(new K.TypeCheckerVisitor_visitFunctionExpression_closure(this));
        t1 = node.initializers;
        if (t1 != null)
          this.analyze$2$inInitializer(t1, true);
        type = C.C_DynamicType;
        returnType = C.C_VoidType;
      } else {
        functionType = element.computeType$1(this.compiler);
        returnType = functionType.returnType;
        type = functionType;
      }
      previous = this.expectedReturnType;
      this.expectedReturnType = returnType;
      this.analyze$1(node.body);
      this.expectedReturnType = previous;
      return type;
    },
    visitIdentifier$1: function(node) {
      var t1 = node.token;
      if (t1.get$value(t1) === "this")
        return this.thisType;
      else if (t1.get$value(t1) === "super")
        return this.superType;
      else
        return node.get$_secret_tree_element$_element().computeType$1(this.compiler);
    },
    visitIf$1: function(node) {
      var condition, thenPart, t1;
      condition = node.get$condition().expression;
      thenPart = node.get$thenPart();
      t1 = node.condition;
      this.checkAssignable$3(t1, this.analyze$1(t1), this.boolType);
      this.analyzeInPromotedContext$2(condition, thenPart);
      t1 = node.elsePart;
      if (t1 != null)
        this.analyze$1(t1);
      return C.C_StatementType;
    },
    checkPrivateAccess$3: function(node, element, $name) {
      var t1, t2;
      if ($name != null)
        if (!C.JSString_methods.get$isEmpty($name) && C.JSString_methods.codeUnitAt$1($name, 0) === 95) {
          t1 = element.get$library();
          t2 = this.elements.analyzedElement.get$library();
          t2 = t1 == null ? t2 != null : t1 !== t2;
          t1 = t2;
        } else
          t1 = false;
      else
        t1 = false;
      if (t1)
        this.compiler.reportDiagnosticInternal$4(node, C.MessageKind_jV0, P.LinkedHashMap_LinkedHashMap$_literal(["name", $name, "libraryName", element.get$library().getLibraryOrScriptName$0()], null, null), C.Diagnostic_2_warning);
    },
    lookupMember$6$lookupClassMember: function(node, receiverType, $name, memberKind, receiverElement, lookupClassMember) {
      var t1, memberName, t2, t3, t4, t5, unaliasedBound, $interface, access, t6, typePromotions, typePromotion;
      t1 = {};
      if (receiverType.get$treatAsDynamic())
        return C.C_DynamicAccess;
      memberName = O.Name_Name($name, this.elements.analyzedElement.get$library(), memberKind === C.MemberKind_setter);
      t2 = new K.TypeCheckerVisitor_lookupMember_computeUnaliasedBound(this);
      t3 = new K.TypeCheckerVisitor_lookupMember_computeInterfaceType(this, node);
      t4 = new K.TypeCheckerVisitor_lookupMember_lookupMemberSignature(this, lookupClassMember);
      t5 = new K.TypeCheckerVisitor_lookupMember_getAccess(this, receiverElement, memberName, t4);
      unaliasedBound = t2.call$1(receiverType);
      if (unaliasedBound.get$treatAsDynamic())
        return new K.DynamicAccess();
      $interface = t3.call$1(unaliasedBound);
      access = t5.call$3(memberName, unaliasedBound, $interface);
      if (access != null)
        return access;
      if (receiverElement != null)
        t6 = receiverElement.get$kind(receiverElement) === C.ElementKind_variable_1 || receiverElement.kind === C.ElementKind_parameter_1;
      else
        t6 = false;
      if (t6) {
        typePromotions = this.typePromotionsMap.$index(0, receiverElement);
        if (typePromotions != null)
          for (; t6 = J.getInterceptor$asx(typePromotions), !t6.get$isEmpty(typePromotions);) {
            typePromotion = t6.get$head(typePromotions);
            if (typePromotion.get$messages().length !== 0) {
              unaliasedBound = t2.call$1(typePromotion.type);
              if (!unaliasedBound.get$treatAsDynamic())
                if (t5.call$3(memberName, unaliasedBound, t3.call$1(unaliasedBound)) != null)
                  this.reportTypePromotionHint$1(typePromotion);
            }
            typePromotions = typePromotions.get$tail();
          }
      }
      if (!$interface.get$element().get$isProxy() && !this.analyzingInitializer) {
        t1.foundPrivateMember_0 = false;
        if (memberName.get$isPrivate()) {
          t2 = new K.TypeCheckerVisitor_lookupMember_findPrivateMember(t1, this, node, $name, memberName);
          $interface.get$element().computeAllClassMembers$1(this.compiler);
          if (lookupClassMember)
            $interface.get$element().forEachClassMember$1(t2);
          else
            $interface.get$element().forEachInterfaceMember$1(t2);
        }
        if (!t1.foundPrivateMember_0)
          switch (memberKind) {
            case C.MemberKind_method:
              this.compiler.reportDiagnosticInternal$4(node, C.MessageKind_IyK, P.LinkedHashMap_LinkedHashMap$_literal(["className", receiverType.get$name(receiverType), "memberName", $name], null, null), C.Diagnostic_2_warning);
              break;
            case C.MemberKind_operator:
              this.compiler.reportDiagnosticInternal$4(node, C.MessageKind_yT2, P.LinkedHashMap_LinkedHashMap$_literal(["className", receiverType.get$name(receiverType), "memberName", $name], null, null), C.Diagnostic_2_warning);
              break;
            case C.MemberKind_getter:
              t1 = this.compiler;
              if (t4.call$2(memberName.get$setter(), $interface) != null)
                t1.reportDiagnosticInternal$4(node, C.MessageKind_Pn6, P.LinkedHashMap_LinkedHashMap$_literal(["className", receiverType.get$name(receiverType), "memberName", $name], null, null), C.Diagnostic_2_warning);
              else
                t1.reportDiagnosticInternal$4(node, C.MessageKind_PTQ, P.LinkedHashMap_LinkedHashMap$_literal(["className", receiverType.get$name(receiverType), "memberName", $name], null, null), C.Diagnostic_2_warning);
              break;
            case C.MemberKind_setter:
              this.compiler.reportDiagnosticInternal$4(node, C.MessageKind_hU4, P.LinkedHashMap_LinkedHashMap$_literal(["className", receiverType.get$name(receiverType), "memberName", $name], null, null), C.Diagnostic_2_warning);
              break;
          }
      }
      return C.C_DynamicAccess;
    },
    lookupMember$5: function(node, receiverType, name, memberKind, receiverElement) {
      return this.lookupMember$6$lookupClassMember(node, receiverType, name, memberKind, receiverElement, false);
    },
    analyzeArguments$4: function(send, element, type, argumentTypes) {
      var $arguments, t1, unaliasedType, t2, parameterTypes, optionalParameterTypes, error, argument, namedArgument, t3, argumentName, namedParameterType, argumentType;
      $arguments = send.argumentsNode.nodes;
      t1 = this.compiler;
      unaliasedType = type.unalias$1(t1);
      if (unaliasedType.get$kind(unaliasedType) === C.TypeKind_function) {
        t2 = unaliasedType.get$parameterTypes();
        parameterTypes = H.setRuntimeTypeInfo(new H.ListIterator(t2, t2.length, 0, null), [H.getTypeArgumentByIndex(t2, 0)]);
        t2 = unaliasedType.optionalParameterTypes;
        optionalParameterTypes = H.setRuntimeTypeInfo(new H.ListIterator(t2, t2.length, 0, null), [H.getTypeArgumentByIndex(t2, 0)]);
        for (t2 = argumentTypes != null, error = false; !$arguments.get$isEmpty($arguments);) {
          argument = $arguments.get$head($arguments);
          namedArgument = argument.asNamedArgument$0();
          if (namedArgument != null) {
            argument = namedArgument.expression;
            t3 = namedArgument.name.token;
            argumentName = t3.get$value(t3);
            namedParameterType = unaliasedType.getNamedParameterType$1(argumentName);
            if (namedParameterType == null) {
              t1.reportDiagnosticInternal$4(argument, C.MessageKind_8h5, P.LinkedHashMap_LinkedHashMap$_literal(["argumentName", argumentName], null, null), C.Diagnostic_2_warning);
              argumentType = this.analyze$1(argument);
              if (t2)
                argumentTypes.addLast$1(argumentType);
              error = true;
            } else {
              argumentType = this.analyze$1(argument);
              if (t2)
                argumentTypes.addLast$1(argumentType);
              if (!this.checkAssignable$3(argument, argumentType, namedParameterType))
                error = true;
            }
          } else if (!parameterTypes.moveNext$0())
            if (!optionalParameterTypes.moveNext$0()) {
              t1.reportDiagnosticInternal$4(argument, C.MessageKind_MmD, C.Map_empty, C.Diagnostic_2_warning);
              argumentType = this.analyze$1(argument);
              if (t2)
                argumentTypes.addLast$1(argumentType);
              error = true;
            } else {
              argumentType = this.analyze$1(argument);
              if (t2)
                argumentTypes.addLast$1(argumentType);
              if (!this.checkAssignable$3(argument, argumentType, optionalParameterTypes.__internal$_current))
                error = true;
            }
          else {
            argumentType = this.analyze$1(argument);
            if (t2)
              argumentTypes.addLast$1(argumentType);
            if (!this.checkAssignable$3(argument, argumentType, parameterTypes.__internal$_current))
              error = true;
          }
          $arguments = $arguments.get$tail();
        }
        if (parameterTypes.moveNext$0()) {
          t1.reportDiagnosticInternal$4(send, C.MessageKind_4Nc, P.LinkedHashMap_LinkedHashMap$_literal(["argumentType", parameterTypes.__internal$_current], null, null), C.Diagnostic_2_warning);
          error = true;
        }
        if (error) {
          if (element == null)
            element = type.get$element();
          else if (type.get$element().kind === C.ElementKind_typedef_32) {
            t1.reportDiagnosticInternal$4(element, C.MessageKind_56y, P.LinkedHashMap_LinkedHashMap$_literal(["name", element.get$name(element)], null, null), C.Diagnostic_8_info);
            element = type.get$element();
          }
          t1.reportDiagnosticInternal$4(element, C.MessageKind_xw8, C.Map_empty, C.Diagnostic_8_info);
        }
      } else
        for (t1 = argumentTypes != null; !$arguments.get$isEmpty($arguments);) {
          argumentType = this.analyze$1($arguments.get$head($arguments));
          if (t1)
            argumentTypes.addLast$1(argumentType);
          $arguments = $arguments.get$tail();
        }
    },
    analyzeArguments$3: function(send, element, type) {
      return this.analyzeArguments$4(send, element, type, null);
    },
    analyzeInvocation$3: function(node, elementAccess, argumentTypes) {
      var t1, type, t2;
      t1 = this.compiler;
      type = elementAccess.computeType$1(t1);
      if (elementAccess.isCallable$1(t1))
        this.analyzeArguments$4(node, elementAccess.get$element(), type, argumentTypes);
      else {
        t2 = elementAccess.get$element();
        t1.reportDiagnosticInternal$4(node, C.MessageKind_giZ, P.LinkedHashMap_LinkedHashMap$_literal(["elementName", t2.get$name(t2)], null, null), C.Diagnostic_2_warning);
        this.analyzeArguments$4(node, elementAccess.get$element(), C.C_DynamicType, argumentTypes);
      }
      type = type.unalias$1(t1);
      if (type.get$kind(type) === C.TypeKind_function)
        return type.get$returnType();
      else
        return C.C_DynamicType;
    },
    analyzeInvocation$2: function(node, elementAccess) {
      return this.analyzeInvocation$3(node, elementAccess, null);
    },
    computeAccess$5$lookupClassMember: function(node, $name, element, memberKind, lookupClassMember) {
      var t1, t2, receiverElement, receiverType;
      t1 = element != null;
      if (t1 && element.get$isErroneous())
        return C.C_DynamicAccess;
      t2 = node.receiver;
      if (t2 != null) {
        receiverElement = t2.get$_secret_tree_element$_element();
        if (receiverElement != null)
          if (receiverElement.get$kind(receiverElement) === C.ElementKind_prefix_8)
            return this.computeResolvedAccess$4(node, $name, element, memberKind);
        receiverType = this.analyze$1(t2);
        if (receiverType.get$treatAsDynamic() || receiverType.get$kind(receiverType) === C.TypeKind_void)
          return C.C_DynamicAccess;
        receiverType.get$kind(receiverType);
        t2 = t2.get$_secret_tree_element$_element();
        if (!lookupClassMember)
          t1 = t1 && element.get$isStatic();
        else
          t1 = true;
        return this.lookupMember$6$lookupClassMember(node, receiverType, $name, memberKind, t2, t1);
      } else
        return this.computeResolvedAccess$4(node, $name, element, memberKind);
    },
    computeAccess$4: function(node, name, element, memberKind) {
      return this.computeAccess$5$lookupClassMember(node, name, element, memberKind, false);
    },
    computeResolvedAccess$4: function(node, $name, element, memberKind) {
      var t1, t2;
      if (element == null)
        return this.lookupMember$5(node, this.thisType, $name, memberKind, null);
      else if (element.get$isErroneous())
        return C.C_DynamicAccess;
      else if (element.get$impliesType()) {
        t1 = this.elements;
        t2 = t1._types;
        if ((t2 != null ? t2.$index(0, node) : null) != null) {
          t1 = t1._types;
          t1 = t1 != null ? t1.$index(0, node) : null;
          return new K.TypeLiteralAccess(t1);
        }
        this.checkPrivateAccess$3(node, element, $name);
        return this.createPromotedAccess$1(element);
      } else if (element.get$isClassMember())
        return this.lookupMember$6$lookupClassMember(node, this.thisType, $name, memberKind, null, (element.get$modifiers().flags & 1) !== 0);
      else if (element.get$isFunction()) {
        this.checkPrivateAccess$3(node, element, $name);
        return this.createPromotedAccess$1(element);
      } else {
        t1 = element.kind;
        if (t1 === C.ElementKind_variable_1 || t1 === C.ElementKind_parameter_1 || t1 === C.ElementKind_field_1) {
          this.checkPrivateAccess$3(node, element, $name);
          return this.createPromotedAccess$1(element);
        } else if (element.get$isGetter() || t1 === C.ElementKind_setter_0) {
          this.checkPrivateAccess$3(node, element, $name);
          return this.createPromotedAccess$1(element);
        } else
          this.compiler.internalError$2(element, "Unexpected element kind " + J.toString$0(t1) + ".");
      }
    },
    createPromotedAccess$1: function(element) {
      var typePromotion;
      if (element.get$kind(element) === C.ElementKind_variable_1 || element.kind === C.ElementKind_parameter_1) {
        typePromotion = this.getKnownTypePromotion$1(element);
        if (typePromotion != null)
          return new K.PromotedAccess(element, typePromotion.type);
      }
      return new K.ResolvedAccess(element);
    },
    computeAccessType$5$lookupClassMember: function(node, $name, element, memberKind, lookupClassMember) {
      var t1, type, t2, t3;
      t1 = this.compiler;
      type = this.computeAccess$5$lookupClassMember(node, $name, element, memberKind, lookupClassMember).computeType$1(t1);
      if (type == null) {
        t2 = "Type is null on access of " + H.S($name) + " on ";
        t3 = P.StringBuffer$("");
        new Y.Unparser(t3, true, false, true, 0, H.setRuntimeTypeInfo([""], [P.String]), "  ").visit$1(node);
        t1.internalError$2(node, t2 + t3._contents + ".");
      }
      return type;
    },
    computeAccessType$4: function(node, name, element, memberKind) {
      return this.computeAccessType$5$lookupClassMember(node, name, element, memberKind, false);
    },
    computeMoreSpecificType$2: function(shownType, knownType) {
      var t1, t2, shownTypeGeneric;
      if (knownType.get$kind(knownType) === C.TypeKind_interface)
        if (shownType.get$kind(shownType) === C.TypeKind_interface) {
          t1 = shownType.asRaw$0();
          t2 = this.types.subtypeVisitor;
          t1 = t1.get$treatAsDynamic() || t2.isMoreSpecific$2(t1, knownType) === true;
        } else
          t1 = false;
      else
        t1 = false;
      if (t1) {
        shownTypeGeneric = new V.MoreSpecificSubtypeVisitor(this.compiler, null).computeMoreSpecific$2(shownType.get$element(), knownType);
        if (shownTypeGeneric != null && this.types.moreSpecificVisitor.isMoreSpecific$2(shownTypeGeneric, knownType) === true)
          return shownTypeGeneric;
      }
      return;
    },
    visitSend$1: function(node) {
      var t1, t2, element, t3, receiverType, $name, t4, variable, parentheses, knownType, shownType, variableName, shownTypeSuggestion, receiver, argument, argumentType, operatorName, access, argumentTypesBuilder, resultType;
      t1 = this.elements;
      t2 = t1._asserts;
      if (t2 != null && t2.contains$1(0, node) === true)
        return this.analyzeInvocation$2(node, C.C_AssertAccess);
      element = node.get$_secret_tree_element$_element();
      t2 = element != null;
      if (t2)
        t3 = element.get$kind(element) === C.ElementKind_generative_constructor_16 || element.get$isFactoryConstructor();
      else
        t3 = false;
      if (t3) {
        t1 = node.receiver;
        if (t1 != null)
          receiverType = this.analyze$1(t1);
        else
          receiverType = node.selector.isSuper$0() ? this.superType : this.thisType;
        this.analyzeArguments$3(node, element, this.computeConstructorType$2(element, receiverType));
        return C.C_DynamicType;
      }
      if (O.Elements_isClosureSend(node, element))
        if (t2)
          return this.analyzeInvocation$2(node, this.createPromotedAccess$1(element));
        else
          return this.analyzeInvocation$2(node, new K.TypeAccess(this.analyze$1(node.selector)));
      t2 = node.selector;
      t3 = t2.asIdentifier$0().token;
      $name = t3.get$value(t3);
      t4 = !!t2.$isOperator;
      if (t4 && $name === "is") {
        t3 = node.receiver;
        this.analyze$1(t3);
        if (t4) {
          t2 = t2.asOperator$0().token;
          t2 = t2.get$value(t2) === "is";
        } else
          t2 = false;
        if (t2) {
          t2 = node.argumentsNode.nodes;
          t2 = t2.get$head(t2).asSend$0() != null;
        } else
          t2 = false;
        if (!t2) {
          variable = t3.get$_secret_tree_element$_element();
          if (variable == null) {
            parentheses = t3.asParenthesizedExpression$0();
            for (; parentheses != null;) {
              t2 = parentheses.expression;
              variable = t2.get$_secret_tree_element$_element();
              if (variable != null)
                break;
              parentheses = t2.asParenthesizedExpression$0();
            }
          }
          if (variable != null)
            t2 = variable.get$kind(variable) === C.ElementKind_variable_1 || variable.kind === C.ElementKind_parameter_1;
          else
            t2 = false;
          if (t2) {
            knownType = this.getKnownType$1(variable);
            if (knownType.get$kind(knownType) !== C.TypeKind_dynamic) {
              t2 = node.argumentsNode.nodes;
              t2 = t2.get$head(t2);
              t1 = t1._types;
              shownType = t1 != null ? t1.$index(0, t2) : null;
              t1 = H.setRuntimeTypeInfo([], [K.TypePromotionMessage]);
              t2 = this.types;
              if (t2.moreSpecificVisitor.isMoreSpecific$2(shownType, knownType) !== true) {
                variableName = variable.get$name(variable);
                t2 = t2.subtypeVisitor;
                if (!(shownType.get$treatAsDynamic() || t2.isMoreSpecific$2(shownType, knownType) === true))
                  t1.push(new K.TypePromotionMessage(C.Diagnostic_4_hint, node, C.MessageKind_gld, P.LinkedHashMap_LinkedHashMap$_literal(["variableName", variableName, "shownType", shownType, "knownType", knownType], null, null)));
                else {
                  shownTypeSuggestion = this.computeMoreSpecificType$2(shownType, knownType);
                  if (shownTypeSuggestion != null)
                    t1.push(new K.TypePromotionMessage(C.Diagnostic_4_hint, node, C.MessageKind_Djp, P.LinkedHashMap_LinkedHashMap$_literal(["variableName", variableName, "shownType", shownType, "shownTypeSuggestion", shownTypeSuggestion, "knownType", knownType], null, null)));
                  else
                    t1.push(new K.TypePromotionMessage(C.Diagnostic_4_hint, node, C.MessageKind_2Vk, P.LinkedHashMap_LinkedHashMap$_literal(["variableName", variableName, "shownType", shownType, "knownType", knownType], null, null)));
                }
              }
              this.showTypePromotion$2(node, new K.TypePromotion(node, variable, shownType, t1));
            }
          }
        }
        return this.boolType;
      }
      if (t4 && $name === "as") {
        this.analyze$1(node.receiver);
        t2 = node.argumentsNode.nodes;
        t2 = t2.get$head(t2);
        t1 = t1._types;
        return t1 != null ? t1.$index(0, t2) : null;
      } else if (t4) {
        receiver = node.receiver;
        receiverType = this.analyze$1(receiver);
        if ($name === "==" || $name === "!=" || $name === "===" || $name === "!==") {
          t1 = node.argumentsNode.nodes;
          this.analyze$1(t1.get$head(t1));
          return this.boolType;
        } else if ($name === "||") {
          this.checkAssignable$3(receiver, receiverType, this.boolType);
          t1 = node.argumentsNode.nodes;
          argument = t1.get$head(t1);
          this.checkAssignable$3(argument, this.analyze$1(argument), this.boolType);
          return this.boolType;
        } else if ($name === "&&") {
          this.checkAssignable$3(receiver, receiverType, this.boolType);
          t1 = node.argumentsNode.nodes;
          argument = t1.get$head(t1);
          argumentType = this.analyzeInPromotedContext$2(receiver, argument);
          this.reshowTypePromotions$3(node, receiver, argument);
          this.checkAssignable$3(argument, argumentType, this.boolType);
          return this.boolType;
        } else if ($name === "!") {
          this.checkAssignable$3(receiver, receiverType, this.boolType);
          return this.boolType;
        } else if ($name === "?")
          return this.boolType;
        operatorName = t3.get$value(t3);
        if ($name === "-") {
          t1 = node.argumentsNode.nodes;
          t1 = t1.get$isEmpty(t1);
        } else
          t1 = false;
        if (t1)
          operatorName = "unary-";
        access = receiverType.get$kind(receiverType) === C.TypeKind_void ? C.C_DynamicAccess : this.lookupMember$5(node, receiverType, operatorName, C.MemberKind_operator, null);
        argumentTypesBuilder = H.setRuntimeTypeInfo(new E.LinkBuilderImplementation(null, null, 0), [null]);
        resultType = this.analyzeInvocation$3(node, access, argumentTypesBuilder);
        t1 = receiverType.get$element();
        t2 = this.compiler;
        t3 = t2.intClass;
        if (t1 == null ? t3 == null : t1 === t3)
          if ($name === "+" || operatorName === "-" || $name === "*" || $name === "%") {
            t1 = argumentTypesBuilder.toLink$0();
            argumentType = t1.get$head(t1);
            t1 = argumentType.get$element();
            t3 = t2.intClass;
            if (t1 == null ? t3 == null : t1 === t3)
              return this.intType;
            else {
              t1 = argumentType.get$element();
              t2 = t2.doubleClass;
              if (t1 == null ? t2 == null : t1 === t2)
                return this.doubleType;
            }
          }
        return resultType;
      } else if (node.argumentsNode == null)
        return this.computeAccess$4(node, t3.get$value(t3), element, C.MemberKind_getter).computeType$1(this.compiler);
      else
        return this.analyzeInvocation$2(node, this.computeAccess$4(node, t3.get$value(t3), element, C.MemberKind_method));
    },
    checkAssignmentOperator$4: function(node, operatorName, valueNode, value) {
      var setterElement, t1, getterElement, t2, getter, setter, operator, result;
      setterElement = node.get$_secret_tree_element$_element();
      t1 = node.selector;
      getterElement = t1.get$_secret_tree_element$_element();
      t2 = t1.get$token();
      getter = this.computeAccessType$4(node, t2.get$value(t2), getterElement, C.MemberKind_getter);
      t1 = t1.get$token();
      setter = this.computeAccessType$4(node, t1.get$value(t1), setterElement, C.MemberKind_setter);
      operator = this.lookupMember$5(node, getter, operatorName, C.MemberKind_operator, null).computeType$1(this.compiler);
      if (!!J.getInterceptor(operator).$isFunctionType) {
        result = operator.returnType;
        t1 = operator.parameterTypes;
        if (!this.checkAssignable$3(valueNode, value, t1.length === 0 ? C.C_DynamicType : C.JSArray_methods.get$first(t1))) {
          t1 = J.getInterceptor(node.argumentsNode);
          t1 = !(!!t1.$isPrefix0 || !!t1.$isPostfix0);
        } else
          t1 = true;
        if (t1)
          this.checkAssignable$3(node.assignmentOperator, result, setter);
        return !!J.getInterceptor(node.argumentsNode).$isPostfix0 ? getter : result;
      }
      return C.C_DynamicType;
    },
    checkIndexAssignmentOperator$4: function(node, operatorName, valueNode, value) {
      var base, t1, t2, keyNode, key, indexGet, t3, indexGetKey, validKey, element, operator, validValue, result, indexSet, indexSetKey, indexSetValue;
      base = this.analyze$1(node.receiver);
      t1 = node.argumentsNode;
      t2 = t1.nodes;
      keyNode = t2.get$head(t2);
      key = this.analyze$1(keyNode);
      t2 = this.compiler;
      indexGet = this.lookupMember$5(node, base, "[]", C.MemberKind_operator, null).computeType$1(t2);
      if (!!J.getInterceptor(indexGet).$isFunctionType) {
        t3 = indexGet.parameterTypes;
        indexGetKey = t3.length === 0 ? C.C_DynamicType : C.JSArray_methods.get$first(t3);
        validKey = this.checkAssignable$3(keyNode, key, indexGetKey);
        element = indexGet.returnType;
        operator = this.lookupMember$5(node, element, operatorName, C.MemberKind_operator, null).computeType$1(t2);
        if (!!J.getInterceptor(operator).$isFunctionType) {
          t3 = operator.parameterTypes;
          validValue = this.checkAssignable$3(valueNode, value, t3.length === 0 ? C.C_DynamicType : C.JSArray_methods.get$first(t3));
          result = operator.returnType;
          indexSet = this.lookupMember$5(node, base, "[]=", C.MemberKind_operator, null).computeType$1(t2);
          if (!!J.getInterceptor(indexSet).$isFunctionType) {
            t2 = indexSet.parameterTypes;
            indexSetKey = t2.length === 0 ? C.C_DynamicType : C.JSArray_methods.get$first(t2);
            indexSetValue = t2.length < 2 ? C.C_DynamicType : t2[1];
            if (validKey || !J.$eq(indexGetKey, indexSetKey))
              this.checkAssignable$3(keyNode, key, indexSetKey);
            if (!validValue) {
              t2 = J.getInterceptor(t1);
              t2 = !(!!t2.$isPrefix0 || !!t2.$isPostfix0);
            } else
              t2 = true;
            if (t2)
              this.checkAssignable$3(node.assignmentOperator, result, indexSetValue);
          }
          return !!J.getInterceptor(t1).$isPostfix0 ? element : result;
        }
      }
      return C.C_DynamicType;
    },
    visitSendSet$1: function(node) {
      var element, selector, t1, t2, $name, base, keyNode, key, value, indexSet, target, operatorName, t3, valueNode;
      element = node.get$_secret_tree_element$_element();
      selector = node.selector;
      t1 = node.assignmentOperator;
      t2 = t1.token;
      $name = t2.get$value(t2);
      if ($name === "=") {
        if (!!J.getInterceptor(selector).$isOperator) {
          t2 = selector.asOperator$0().token;
          t2 = t2.get$value(t2) === "[]";
        } else
          t2 = false;
        if (t2) {
          base = this.analyze$1(node.receiver);
          t2 = node.argumentsNode.nodes;
          keyNode = t2.get$head(t2);
          key = this.analyze$1(keyNode);
          t2 = t2.get$tail();
          value = this.analyze$1(t2.get$head(t2));
          indexSet = this.lookupMember$5(node, base, "[]=", C.MemberKind_operator, null).computeType$1(this.compiler);
          if (!!J.getInterceptor(indexSet).$isFunctionType) {
            t2 = indexSet.parameterTypes;
            this.checkAssignable$3(keyNode, key, t2.length === 0 ? C.C_DynamicType : C.JSArray_methods.get$first(t2));
            this.checkAssignable$3(t1, value, t2.length < 2 ? C.C_DynamicType : t2[1]);
          }
          return value;
        } else {
          if (this.analyzingInitializer) {
            t2 = selector.get$token();
            target = this.computeAccessType$5$lookupClassMember(node, t2.get$value(t2), element, C.MemberKind_getter, true);
          } else {
            t2 = selector.get$token();
            target = this.computeAccessType$4(node, t2.get$value(t2), element, C.MemberKind_setter);
          }
          t2 = node.argumentsNode.nodes;
          value = this.analyze$1(t2.get$head(t2));
          this.checkAssignable$3(t1, value, target);
          return value;
        }
      } else {
        t2 = $name === "++";
        if (t2 || $name === "--") {
          operatorName = t2 ? "+" : "-";
          if (!!J.getInterceptor(selector).$isOperator) {
            t2 = selector.asOperator$0().token;
            t2 = t2.get$value(t2) === "[]";
          } else
            t2 = false;
          t3 = this.intType;
          if (t2)
            return this.checkIndexAssignmentOperator$4(node, operatorName, t1, t3);
          else
            return this.checkAssignmentOperator$4(node, operatorName, t1, t3);
        } else {
          switch ($name) {
            case "+=":
              operatorName = "+";
              break;
            case "-=":
              operatorName = "-";
              break;
            case "*=":
              operatorName = "*";
              break;
            case "/=":
              operatorName = "/";
              break;
            case "%=":
              operatorName = "%";
              break;
            case "~/=":
              operatorName = "~/";
              break;
            case "&=":
              operatorName = "&";
              break;
            case "|=":
              operatorName = "|";
              break;
            case "^=":
              operatorName = "^";
              break;
            case "<<=":
              operatorName = "<<";
              break;
            case ">>=":
              operatorName = ">>";
              break;
            default:
              this.compiler.internalError$2(node, "Unexpected assignment operator " + H.S($name) + ".");
              operatorName = null;
          }
          if (!!J.getInterceptor(selector).$isOperator) {
            t1 = selector.asOperator$0().token;
            t1 = t1.get$value(t1) === "[]";
          } else
            t1 = false;
          t2 = node.argumentsNode;
          if (t1) {
            t1 = t2.nodes.get$tail();
            valueNode = t1.get$head(t1);
            return this.checkIndexAssignmentOperator$4(node, operatorName, valueNode, this.analyze$1(valueNode));
          } else {
            t1 = t2.nodes;
            valueNode = t1.get$head(t1);
            return this.checkAssignmentOperator$4(node, operatorName, valueNode, this.analyze$1(valueNode));
          }
        }
      }
    },
    visitLiteralInt$1: function(node) {
      return this.intType;
    },
    visitLiteralDouble$1: function(node) {
      return this.doubleType;
    },
    visitLiteralBool$1: function(node) {
      return this.boolType;
    },
    visitLiteralString$1: function(node) {
      return this.stringType;
    },
    visitStringJuxtaposition$1: function(node) {
      this.analyze$1(node.first);
      this.analyze$1(node.second);
      return this.stringType;
    },
    visitLiteralNull$1: function(node) {
      return C.C_DynamicType;
    },
    visitLiteralSymbol$1: function(node) {
      return this.compiler.symbolClass.get$rawType();
    },
    computeConstructorType$2: function($constructor, type) {
      var constructorType, receiverElement, t1;
      if ($constructor.get$isErroneous())
        return C.C_DynamicType;
      constructorType = $constructor.computeType$1(this.compiler);
      if (type.get$kind(type) === C.TypeKind_interface)
        if ($constructor.get$isSynthesized()) {
          receiverElement = type.get$element();
          for (; receiverElement.get$isMixinApplication();)
            receiverElement = receiverElement.get$supertype().get$element();
          t1 = type.asInstanceOf$1(receiverElement);
          constructorType.toString;
          constructorType = constructorType.subst$2(t1.typeArguments, t1.get$element().get$typeVariables());
        } else {
          constructorType.toString;
          constructorType = constructorType.subst$2(type.get$typeArguments(), type.get$element().get$typeVariables());
        }
      return constructorType;
    },
    visitNewExpression$1: function(node) {
      var t1, element, t2, newType;
      t1 = node.send;
      element = t1.get$_secret_tree_element$_element();
      if (element == null || element.get$isErroneous())
        return C.C_DynamicType;
      this.checkPrivateAccess$3(node, element, element.get$name(element));
      t2 = this.elements._types;
      newType = t2 != null ? t2.$index(0, node) : null;
      this.analyzeArguments$3(t1, element, this.computeConstructorType$2(element, newType));
      return newType;
    },
    visitLiteralList$1: function(node) {
      var t1, listType, listElementType, link, element;
      t1 = this.elements._types;
      listType = t1 != null ? t1.$index(0, node) : null;
      t1 = listType.get$typeArguments();
      listElementType = t1.length === 0 ? C.C_DynamicType : J.get$first$ax(t1);
      for (link = node.get$elements(node).nodes, t1 = node.constKeyword != null; !link.get$isEmpty(link); link = link.get$tail()) {
        element = link.get$head(link);
        this.checkAssignable$4$isConst(element, this.analyze$1(element), listElementType, t1);
      }
      return listType;
    },
    visitNodeList$1: function(node) {
      var link;
      for (link = node.nodes; !link.get$isEmpty(link); link = link.get$tail())
        this.analyze$2$inInitializer(link.get$head(link), this.analyzingInitializer);
      return C.C_StatementType;
    },
    visitRedirectingFactoryBody$1: function(node) {
      return C.C_StatementType;
    },
    visitRethrow$1: function(node) {
      return C.C_StatementType;
    },
    visitReturn$1: function(node) {
      var expression, t1, expressionType, element, t2;
      if (node.get$beginToken().get$stringValue() === "native")
        return C.C_StatementType;
      expression = node.expression;
      t1 = this.expectedReturnType;
      t1 = t1.get$kind(t1);
      if (expression != null) {
        expressionType = this.analyze$1(expression);
        element = this.elements.analyzedElement;
        if (element != null && J.get$kind$x(element) === C.ElementKind_generative_constructor_16)
          ;
        else {
          if (t1 === C.TypeKind_void) {
            t1 = this.types.subtypeVisitor;
            t1 = !(t1.isSubtype$2(expressionType, C.C_VoidType) || t1.isSubtype$2(C.C_VoidType, expressionType));
          } else
            t1 = false;
          if (t1)
            this.compiler.reportDiagnosticInternal$4(expression, C.MessageKind_uCu, C.Map_empty, C.Diagnostic_2_warning);
          else
            this.checkAssignable$3(expression, expressionType, this.expectedReturnType);
        }
      } else {
        t1 = this.expectedReturnType;
        t2 = this.types.subtypeVisitor;
        if (!(t2.isSubtype$2(t1, C.C_VoidType) || t2.isSubtype$2(C.C_VoidType, t1)))
          this.compiler.reportDiagnosticInternal$4(node, C.MessageKind_w4L, P.LinkedHashMap_LinkedHashMap$_literal(["returnType", this.expectedReturnType], null, null), C.Diagnostic_2_warning);
      }
      return C.C_StatementType;
    },
    visitThrow$1: function(node) {
      this.analyze$1(node.get$expression());
      return C.C_DynamicType;
    },
    visitTypeAnnotation$1: function(node) {
      var t1 = this.elements._types;
      return t1 != null ? t1.$index(0, node) : null;
    },
    visitVariableDefinitions$1: function(node) {
      var t1, type, link, definition, type0;
      t1 = node.type;
      type = t1 != null ? this.analyze$1(t1) : C.C_DynamicType;
      if (type.get$kind(type) === C.TypeKind_void) {
        this.compiler.reportDiagnosticInternal$4(t1, C.MessageKind_kXN, C.Map_empty, C.Diagnostic_2_warning);
        type = C.C_DynamicType;
      }
      for (link = node.definitions.nodes; !link.get$isEmpty(link); link = link.get$tail()) {
        definition = link.get$head(link);
        t1 = J.getInterceptor(definition);
        K.invariant(definition, !!t1.$isIdentifier || !!t1.$isSendSet, "expected identifier or initialization");
        if (!!t1.$isSendSet) {
          t1 = definition.argumentsNode.nodes;
          t1 = t1.get$head(t1);
          type0 = this.analyze$1(t1);
          if (type0.get$kind(type0) === C.TypeKind_void)
            this.compiler.reportDiagnosticInternal$4(t1, C.MessageKind_e4R, C.Map_empty, C.Diagnostic_2_warning);
          this.checkAssignable$3(definition.assignmentOperator, type0, type);
        }
      }
      return C.C_StatementType;
    },
    visitWhile$1: function(node) {
      var t1 = node.condition;
      this.checkAssignable$3(t1, this.analyze$1(t1), this.boolType);
      this.analyze$1(node.body);
      t1.asParenthesizedExpression$0().expression;
      return C.C_StatementType;
    },
    visitParenthesizedExpression$1: function(node) {
      var expression, type, t1;
      expression = node.expression;
      type = this.analyze$1(expression);
      for (t1 = J.get$iterator$ax(this.getShownTypePromotionsFor$1(expression)); t1.moveNext$0();)
        this.showTypePromotion$2(node, t1.get$current());
      return type;
    },
    visitConditional$1: function(node) {
      var condition, thenType, elseType;
      condition = node.condition;
      this.checkAssignable$3(condition, this.analyze$1(condition), this.boolType);
      thenType = this.analyzeInPromotedContext$2(condition, node.thenExpression);
      elseType = this.analyze$1(node.elseExpression);
      return this.compiler.types.computeLeastUpperBound$2(thenType, elseType);
    },
    visitStringInterpolation$1: function(node) {
      this.visitLiteralString$1(node.string);
      this.visitNodeList$1(node.parts);
      return this.stringType;
    },
    visitStringInterpolationPart$1: function(node) {
      node.expression.accept$1(0, this);
      this.visitLiteralString$1(node.string);
      return this.stringType;
    },
    visitEmptyStatement$1: function(node) {
      return C.C_StatementType;
    },
    visitBreakStatement$1: function(node) {
      return C.C_StatementType;
    },
    visitContinueStatement$1: function(node) {
      return C.C_StatementType;
    },
    visitForIn$1: function(node) {
      this.analyze$1(node.expression);
      this.analyze$1(node.body);
      return C.C_StatementType;
    },
    visitLabeledStatement$1: function(node) {
      return this.analyze$1(node.statement);
    },
    visitLiteralMap$1: function(node) {
      var t1, mapType, mapKeyType, mapValueType, isConst, link, entry, keyType, valueType;
      t1 = this.elements._types;
      mapType = t1 != null ? t1.$index(0, node) : null;
      t1 = mapType.get$typeArguments();
      mapKeyType = t1.length === 0 ? C.C_DynamicType : J.get$first$ax(t1);
      t1 = mapType.get$typeArguments();
      mapValueType = t1.length < 2 ? C.C_DynamicType : t1[1];
      isConst = node.constKeyword != null;
      for (link = node.entries.nodes; !link.get$isEmpty(link); link = link.get$tail()) {
        entry = link.get$head(link);
        t1 = J.getInterceptor$x(entry);
        keyType = this.analyze$1(t1.get$key(entry));
        this.checkAssignable$4$isConst(t1.get$key(entry), keyType, mapKeyType, isConst);
        valueType = this.analyze$1(t1.get$value(entry));
        this.checkAssignable$4$isConst(t1.get$value(entry), valueType, mapValueType, isConst);
      }
      return mapType;
    },
    visitNamedArgument$1: function(node) {
      return this.analyze$1(node.expression);
    },
    visitSwitchStatement$1: function(node) {
      var expressionType, t1, switchCase, t2, t3, caseMatch;
      expressionType = this.analyze$1(node.parenthesizedExpression.expression);
      for (t1 = node.cases.nodes, t1.toString, t1 = H.setRuntimeTypeInfo(new E.LinkIterator(null, t1), [H.getTypeArgumentByIndex(t1, 0)]); t1.moveNext$0();) {
        switchCase = t1._util_implementation$_current;
        t2 = switchCase.get$labelsAndCases().nodes;
        t2.toString;
        t3 = new E.LinkIterator(null, t2);
        t3.$builtinTypeInfo = [H.getTypeArgumentByIndex(t2, 0)];
        for (; t3.moveNext$0();) {
          caseMatch = t3._util_implementation$_current.asCaseMatch$0();
          if (caseMatch == null)
            continue;
          this.checkAssignable$3(caseMatch, expressionType, this.analyze$1(caseMatch.expression));
        }
        this.analyze$1(switchCase);
      }
      return C.C_StatementType;
    },
    visitSwitchCase$1: function(node) {
      return this.analyze$1(node.statements);
    },
    visitTryStatement$1: function(node) {
      var t1;
      this.analyze$1(node.tryBlock);
      for (t1 = node.catchBlocks.nodes, t1.toString, t1 = H.setRuntimeTypeInfo(new E.LinkIterator(null, t1), [H.getTypeArgumentByIndex(t1, 0)]); t1.moveNext$0();)
        this.analyze$1(t1._util_implementation$_current);
      t1 = node.finallyBlock;
      if (t1 != null)
        this.analyze$1(t1);
      return C.C_StatementType;
    },
    visitCatchBlock$1: function(node) {
      return this.analyze$1(node.block);
    },
    visitTypedef$1: function(node) {
    },
    visitNode$1: function(node) {
      this.compiler.internalError$2(node, "Unexpected node " + P.Object.prototype.toString$0.call(node, node) + " in the type checker.");
    },
    TypeCheckerVisitor$3: function(compiler, elements, types) {
      var t1 = this.compiler;
      this.intType = t1.intClass.computeType$1(t1);
      this.doubleType = t1.doubleClass.computeType$1(t1);
      this.boolType = t1.boolClass.computeType$1(t1);
      this.stringType = t1.stringClass.computeType$1(t1);
      this.objectType = t1.objectClass.computeType$1(t1);
      this.listType = t1.listClass.computeType$1(t1);
      t1 = this.currentClass;
      if (t1 != null) {
        this.thisType = t1.get$thisType();
        this.superType = t1.get$supertype();
      }
    },
    $asVisitor: function() {
      return [V.DartType];
    }
  },
  TypeCheckerVisitor_showTypePromotion_closure: {
    "^": "Closure:23;",
    call$0: function() {
      return H.setRuntimeTypeInfo([], [K.TypePromotion]);
    },
    $isFunction: true
  },
  TypeCheckerVisitor_registerKnownTypePromotion_closure: {
    "^": "Closure:23;",
    call$0: function() {
      return C.C_Link1;
    },
    $isFunction: true
  },
  TypeCheckerVisitor_visitFunctionExpression_closure: {
    "^": "Closure:50;this_0",
    call$1: function(parameter) {
      var t1, t2;
      t1 = J.getInterceptor$x(parameter);
      if (t1.get$kind(parameter) === C.ElementKind_initializing_formal_1) {
        t2 = this.this_0;
        t2.checkAssignable$3(parameter, t1.get$type(parameter), parameter.get$fieldElement().computeType$1(t2.compiler));
      }
    },
    $isFunction: true
  },
  TypeCheckerVisitor_lookupMember_computeUnaliasedBound: {
    "^": "Closure:88;this_1",
    call$1: function(type) {
      var t1, type0;
      for (t1 = this.this_1.compiler, type0 = type; type0.get$kind(type0) === C.TypeKind_kuk;) {
        type0 = type0.get$element().boundCache;
        if (J.$eq(type0, type))
          type0 = t1.objectClass.get$rawType();
      }
      if (type0.get$kind(type0) === C.TypeKind_malformed)
        return C.C_DynamicType;
      return type0.unalias$1(t1);
    },
    $isFunction: true
  },
  TypeCheckerVisitor_lookupMember_computeInterfaceType: {
    "^": "Closure:89;this_2,node_3",
    call$1: function(type) {
      return type.get$kind(type) === C.TypeKind_function ? this.this_2.compiler.functionClass.get$rawType() : type;
    },
    $isFunction: true
  },
  TypeCheckerVisitor_lookupMember_lookupMemberSignature: {
    "^": "Closure:90;this_4,lookupClassMember_5",
    call$2: function($name, $interface) {
      var t1 = this.this_4;
      A.MembersCreator_computeClassMembersByName(t1.compiler, $interface.get$element(), $name.text);
      return this.lookupClassMember_5 || t1.analyzingInitializer ? $interface.lookupClassMember$1($name) : $interface.lookupInterfaceMember$1($name);
    },
    $isFunction: true
  },
  TypeCheckerVisitor_lookupMember_getAccess: {
    "^": "Closure:91;this_6,receiverElement_7,memberName_8,lookupMemberSignature_9",
    call$3: function($name, unaliasedBound, $interface) {
      var member, t1, t2;
      member = this.lookupMemberSignature_9.call$2(this.memberName_8, $interface);
      if (member != null)
        return new K.MemberAccess(member);
      if ($name.$eq(0, C.PublicName_call_false)) {
        if (unaliasedBound.get$kind(unaliasedBound) === C.TypeKind_function)
          return new K.FunctionCallAccess(this.receiverElement_7, unaliasedBound);
        t1 = this.this_6;
        t2 = t1.compiler.functionClass.get$rawType();
        t1 = t1.types.subtypeVisitor;
        if ($interface.get$treatAsDynamic() || t1.isMoreSpecific$2($interface, t2) === true)
          return new K.FunctionCallAccess(null, C.C_DynamicType);
      }
      return;
    },
    $isFunction: true
  },
  TypeCheckerVisitor_lookupMember_findPrivateMember: {
    "^": "Closure:92;box_0,this_10,node_11,name_12,memberName_13",
    call$1: function(member) {
      var t1, t2, t3, t4, t5;
      t1 = this.memberName_13;
      t2 = J.getInterceptor$x(member);
      t3 = t2.get$name(member);
      t4 = t1.text;
      t5 = t3.text;
      if ((t4 == null ? t5 == null : t4 === t5) && t1.isSetter === t3.isSetter) {
        this.this_10.compiler.reportDiagnosticInternal$4(this.node_11, C.MessageKind_jV0, P.LinkedHashMap_LinkedHashMap$_literal(["name", this.name_12, "libraryName", t2.get$name(member).get$library().getLibraryOrScriptName$0()], null, null), C.Diagnostic_2_warning);
        this.box_0.foundPrivateMember_0 = true;
      }
    },
    $isFunction: true
  },
  MessageKind: {
    "^": "Object;template,howToFix,examples",
    toString$0: function(_) {
      return this.template;
    },
    message$2: function(_, $arguments, terse) {
      return K.Message$(this, $arguments, terse);
    },
    message$1: function($receiver, arguments) {
      return this.message$2($receiver, arguments, false);
    },
    static: {"^": "MessageKind_GENERIC,MessageKind_NOT_ASSIGNABLE,MessageKind_VOID_EXPRESSION,MessageKind_VOID_VARIABLE,MessageKind_RETURN_VALUE_IN_VOID,MessageKind_RETURN_NOTHING,MessageKind_MISSING_ARGUMENT,MessageKind_ADDITIONAL_ARGUMENT,MessageKind_NAMED_ARGUMENT_NOT_FOUND,MessageKind_MEMBER_NOT_FOUND,MessageKind_METHOD_NOT_FOUND,MessageKind_OPERATOR_NOT_FOUND,MessageKind_SETTER_NOT_FOUND,MessageKind_GETTER_NOT_FOUND,MessageKind_NOT_CALLABLE,MessageKind_MEMBER_NOT_STATIC,MessageKind_NO_INSTANCE_AVAILABLE,MessageKind_PRIVATE_ACCESS,MessageKind_THIS_IS_THE_DECLARATION,MessageKind_THIS_IS_THE_METHOD,MessageKind_CANNOT_RESOLVE,MessageKind_CANNOT_RESOLVE_CONSTRUCTOR,MessageKind_CANNOT_RESOLVE_CONSTRUCTOR_FOR_IMPLICIT,MessageKind_INVALID_UNNAMED_CONSTRUCTOR_NAME,MessageKind_INVALID_CONSTRUCTOR_NAME,MessageKind_CANNOT_RESOLVE_TYPE,MessageKind_DUPLICATE_DEFINITION,MessageKind_EXISTING_DEFINITION,MessageKind_DUPLICATE_IMPORT,MessageKind_HIDDEN_IMPORT,MessageKind_HIDDEN_IMPLICIT_IMPORT,MessageKind_DUPLICATE_EXPORT,MessageKind_DUPLICATE_EXPORT_CONT,MessageKind_DUPLICATE_EXPORT_DECL,MessageKind_NOT_A_TYPE,MessageKind_NOT_A_PREFIX,MessageKind_CANNOT_FIND_CONSTRUCTOR,MessageKind_CYCLIC_CLASS_HIERARCHY,MessageKind_CYCLIC_REDIRECTING_FACTORY,MessageKind_INVALID_RECEIVER_IN_INITIALIZER,MessageKind_NO_SUPER_IN_STATIC,MessageKind_DUPLICATE_INITIALIZER,MessageKind_ALREADY_INITIALIZED,MessageKind_INIT_STATIC_FIELD,MessageKind_NOT_A_FIELD,MessageKind_CONSTRUCTOR_CALL_EXPECTED,MessageKind_INVALID_FOR_IN,MessageKind_INVALID_INITIALIZER,MessageKind_FUNCTION_WITH_INITIALIZER,MessageKind_REDIRECTING_CONSTRUCTOR_CYCLE,MessageKind_REDIRECTING_CONSTRUCTOR_HAS_BODY,MessageKind_CONST_CONSTRUCTOR_HAS_BODY,MessageKind_REDIRECTING_CONSTRUCTOR_HAS_INITIALIZER,MessageKind_SUPER_INITIALIZER_IN_OBJECT,MessageKind_DUPLICATE_SUPER_INITIALIZER,MessageKind_INVALID_CONSTRUCTOR_ARGUMENTS,MessageKind_NO_MATCHING_CONSTRUCTOR,MessageKind_NO_MATCHING_CONSTRUCTOR_FOR_IMPLICIT,MessageKind_CONST_CALLS_NON_CONST,MessageKind_CONST_CONSTRUCTOR_WITH_NONFINAL_FIELDS,MessageKind_CONST_CONSTRUCTOR_WITH_NONFINAL_FIELDS_FIELD,MessageKind_CONST_CONSTRUCTOR_WITH_NONFINAL_FIELDS_CONSTRUCTOR,MessageKind_INITIALIZING_FORMAL_NOT_ALLOWED,MessageKind_INVALID_PARAMETER,MessageKind_NOT_INSTANCE_FIELD,MessageKind_NO_CATCH_NOR_FINALLY,MessageKind_EMPTY_CATCH_DECLARATION,MessageKind_EXTRA_CATCH_DECLARATION,MessageKind_PARAMETER_WITH_TYPE_IN_CATCH,MessageKind_PARAMETER_WITH_MODIFIER_IN_CATCH,MessageKind_OPTIONAL_PARAMETER_IN_CATCH,MessageKind_THROW_WITHOUT_EXPRESSION,MessageKind_UNBOUND_LABEL,MessageKind_NO_BREAK_TARGET,MessageKind_NO_CONTINUE_TARGET,MessageKind_EXISTING_LABEL,MessageKind_DUPLICATE_LABEL,MessageKind_UNUSED_LABEL,MessageKind_INVALID_CONTINUE,MessageKind_INVALID_BREAK,MessageKind_DUPLICATE_TYPE_VARIABLE_NAME,MessageKind_TYPE_VARIABLE_WITHIN_STATIC_MEMBER,MessageKind_TYPE_VARIABLE_IN_CONSTANT,MessageKind_INVALID_TYPE_VARIABLE_BOUND,MessageKind_INVALID_USE_OF_SUPER,MessageKind_INVALID_CASE_DEFAULT,MessageKind_SWITCH_CASE_TYPES_NOT_EQUAL,MessageKind_SWITCH_CASE_TYPES_NOT_EQUAL_CASE,MessageKind_SWITCH_CASE_FORBIDDEN,MessageKind_SWITCH_CASE_VALUE_OVERRIDES_EQUALS,MessageKind_INVALID_ARGUMENT_AFTER_NAMED,MessageKind_NOT_A_COMPILE_TIME_CONSTANT,MessageKind_DEFERRED_COMPILE_TIME_CONSTANT,MessageKind_DEFERRED_COMPILE_TIME_CONSTANT_CONSTRUCTION,MessageKind_CYCLIC_COMPILE_TIME_CONSTANTS,MessageKind_CONSTRUCTOR_IS_NOT_CONST,MessageKind_CONST_MAP_KEY_OVERRIDES_EQUALS,MessageKind_NO_SUCH_LIBRARY_MEMBER,MessageKind_CANNOT_INSTANTIATE_TYPEDEF,MessageKind_REQUIRED_PARAMETER_WITH_DEFAULT,MessageKind_NAMED_PARAMETER_WITH_EQUALS,MessageKind_POSITIONAL_PARAMETER_WITH_EQUALS,MessageKind_TYPEDEF_FORMAL_WITH_DEFAULT,MessageKind_FUNCTION_TYPE_FORMAL_WITH_DEFAULT,MessageKind_REDIRECTING_FACTORY_WITH_DEFAULT,MessageKind_FORMAL_DECLARED_CONST,MessageKind_FORMAL_DECLARED_STATIC,MessageKind_FINAL_FUNCTION_TYPE_PARAMETER,MessageKind_VAR_FUNCTION_TYPE_PARAMETER,MessageKind_CANNOT_INSTANTIATE_TYPE_VARIABLE,MessageKind_CYCLIC_TYPE_VARIABLE,MessageKind_CYCLIC_TYPEDEF,MessageKind_CYCLIC_TYPEDEF_ONE,MessageKind_CLASS_NAME_EXPECTED,MessageKind_CANNOT_EXTEND,MessageKind_CANNOT_IMPLEMENT,MessageKind_CANNOT_EXTEND_MALFORMED,MessageKind_CANNOT_IMPLEMENT_MALFORMED,MessageKind_CANNOT_MIXIN_MALFORMED,MessageKind_CANNOT_MIXIN,MessageKind_DUPLICATE_EXTENDS_IMPLEMENTS,MessageKind_DUPLICATE_IMPLEMENTS,MessageKind_MULTI_INHERITANCE,MessageKind_ILLEGAL_SUPER_SEND,MessageKind_NO_SUCH_SUPER_MEMBER,MessageKind_ADDITIONAL_TYPE_ARGUMENT,MessageKind_MISSING_TYPE_ARGUMENT,MessageKind_TYPE_ARGUMENT_COUNT_MISMATCH,MessageKind_GETTER_MISMATCH,MessageKind_SETTER_MISMATCH,MessageKind_ILLEGAL_SETTER_FORMALS,MessageKind_NO_STATIC_OVERRIDE,MessageKind_NO_STATIC_OVERRIDE_CONT,MessageKind_INSTANCE_STATIC_SAME_NAME,MessageKind_INSTANCE_STATIC_SAME_NAME_CONT,MessageKind_INVALID_OVERRIDE_METHOD,MessageKind_INVALID_OVERRIDDEN_METHOD,MessageKind_INVALID_OVERRIDE_GETTER,MessageKind_INVALID_OVERRIDDEN_GETTER,MessageKind_INVALID_OVERRIDE_GETTER_WITH_FIELD,MessageKind_INVALID_OVERRIDE_FIELD_WITH_GETTER,MessageKind_INVALID_OVERRIDE_SETTER,MessageKind_INVALID_OVERRIDDEN_SETTER,MessageKind_INVALID_OVERRIDE_SETTER_WITH_FIELD,MessageKind_INVALID_OVERRIDE_FIELD_WITH_SETTER,MessageKind_INVALID_OVERRIDE_FIELD,MessageKind_INVALID_OVERRIDDEN_FIELD,MessageKind_CANNOT_OVERRIDE_FIELD_WITH_METHOD,MessageKind_CANNOT_OVERRIDE_FIELD_WITH_METHOD_CONT,MessageKind_CANNOT_OVERRIDE_METHOD_WITH_FIELD,MessageKind_CANNOT_OVERRIDE_METHOD_WITH_FIELD_CONT,MessageKind_CANNOT_OVERRIDE_GETTER_WITH_METHOD,MessageKind_CANNOT_OVERRIDE_GETTER_WITH_METHOD_CONT,MessageKind_CANNOT_OVERRIDE_METHOD_WITH_GETTER,MessageKind_CANNOT_OVERRIDE_METHOD_WITH_GETTER_CONT,MessageKind_MISSING_FORMALS,MessageKind_EXTRA_FORMALS,MessageKind_UNARY_OPERATOR_BAD_ARITY,MessageKind_MINUS_OPERATOR_BAD_ARITY,MessageKind_BINARY_OPERATOR_BAD_ARITY,MessageKind_TERNARY_OPERATOR_BAD_ARITY,MessageKind_OPERATOR_OPTIONAL_PARAMETERS,MessageKind_OPERATOR_NAMED_PARAMETERS,MessageKind_CONSTRUCTOR_WITH_RETURN_TYPE,MessageKind_CANNOT_RETURN_FROM_CONSTRUCTOR,MessageKind_ILLEGAL_FINAL_METHOD_MODIFIER,MessageKind_ILLEGAL_CONST_FIELD_MODIFIER,MessageKind_ILLEGAL_CONSTRUCTOR_MODIFIERS,MessageKind_ILLEGAL_MIXIN_APPLICATION_MODIFIERS,MessageKind_ILLEGAL_MIXIN_SUPERCLASS,MessageKind_ILLEGAL_MIXIN_OBJECT,MessageKind_ILLEGAL_MIXIN_CONSTRUCTOR,MessageKind_ILLEGAL_MIXIN_CYCLE,MessageKind_ILLEGAL_MIXIN_WITH_SUPER,MessageKind_ILLEGAL_MIXIN_SUPER_USE,MessageKind_PARAMETER_NAME_EXPECTED,MessageKind_CANNOT_RESOLVE_GETTER,MessageKind_CANNOT_RESOLVE_SETTER,MessageKind_ASSIGNING_METHOD,MessageKind_ASSIGNING_TYPE,MessageKind_VOID_NOT_ALLOWED,MessageKind_NULL_NOT_ALLOWED,MessageKind_BEFORE_TOP_LEVEL,MessageKind_LIBRARY_NAME_MISMATCH,MessageKind_MISSING_LIBRARY_NAME,MessageKind_THIS_IS_THE_PART_OF_TAG,MessageKind_MISSING_PART_OF_TAG,MessageKind_DUPLICATED_PART_OF,MessageKind_ILLEGAL_DIRECTIVE,MessageKind_DUPLICATED_LIBRARY_NAME,MessageKind_DUPLICATED_RESOURCE,MessageKind_DUPLICATED_LIBRARY_RESOURCE,MessageKind_INVALID_SOURCE_FILE_LOCATION,MessageKind_TOP_LEVEL_VARIABLE_DECLARED_STATIC,MessageKind_REFERENCE_IN_INITIALIZATION,MessageKind_CONST_WITHOUT_INITIALIZER,MessageKind_FINAL_WITHOUT_INITIALIZER,MessageKind_MEMBER_USES_CLASS_NAME,MessageKind_WRONG_NUMBER_OF_ARGUMENTS_FOR_ASSERT,MessageKind_ASSERT_IS_GIVEN_NAMED_ARGUMENTS,MessageKind_FACTORY_REDIRECTION_IN_NON_FACTORY,MessageKind_MISSING_FACTORY_KEYWORD,MessageKind_DEFERRED_LIBRARY_DART_2_DART,MessageKind_DEFERRED_LIBRARY_WITHOUT_PREFIX,MessageKind_DEFERRED_LIBRARY_DUPLICATE_PREFIX,MessageKind_DEFERRED_TYPE_ANNOTATION,MessageKind_ILLEGAL_STATIC,MessageKind_STATIC_FUNCTION_BLOAT,MessageKind_NON_CONST_BLOAT,MessageKind_STRING_EXPECTED,MessageKind_PRIVATE_IDENTIFIER,MessageKind_PRIVATE_NAMED_PARAMETER,MessageKind_UNSUPPORTED_LITERAL_SYMBOL,MessageKind_INVALID_SYMBOL,MessageKind_AMBIGUOUS_REEXPORT,MessageKind_AMBIGUOUS_LOCATION,MessageKind_IMPORTED_HERE,MessageKind_OVERRIDE_EQUALS_NOT_HASH_CODE,MessageKind_PACKAGE_ROOT_NOT_SET,MessageKind_INTERNAL_LIBRARY_FROM,MessageKind_INTERNAL_LIBRARY,MessageKind_LIBRARY_NOT_FOUND,MessageKind_UNSUPPORTED_EQ_EQ_EQ,MessageKind_UNSUPPORTED_BANG_EQ_EQ,MessageKind_UNSUPPORTED_PREFIX_PLUS,MessageKind_UNSUPPORTED_THROW_WITHOUT_EXP,MessageKind_DEPRECATED_TYPEDEF_MIXIN_SYNTAX,MessageKind_MIRRORS_EXPECTED_STRING,MessageKind_MIRRORS_EXPECTED_STRING_OR_TYPE,MessageKind_MIRRORS_EXPECTED_STRING_OR_LIST,MessageKind_MIRRORS_EXPECTED_STRING_TYPE_OR_LIST,MessageKind_MIRRORS_CANNOT_RESOLVE_IN_CURRENT_LIBRARY,MessageKind_MIRRORS_CANNOT_RESOLVE_IN_LIBRARY,MessageKind_MIRRORS_CANNOT_FIND_IN_ELEMENT,MessageKind_READ_SCRIPT_ERROR,MessageKind_EXTRANEOUS_MODIFIER,MessageKind_EXTRANEOUS_MODIFIER_REPLACE,MessageKind_ABSTRACT_CLASS_INSTANTIATION,MessageKind_BODY_EXPECTED,MessageKind_MIRROR_BLOAT,MessageKind_MIRROR_IMPORT,MessageKind_MIRROR_IMPORT_NO_USAGE,MessageKind_WRONG_ARGUMENT_FOR_JS_INTERCEPTOR_CONSTANT,MessageKind_EXPECTED_IDENTIFIER_NOT_RESERVED_WORD,MessageKind_NAMED_FUNCTION_EXPRESSION,MessageKind_UNUSED_METHOD,MessageKind_UNUSED_CLASS,MessageKind_UNUSED_TYPEDEF,MessageKind_ABSTRACT_METHOD,MessageKind_ABSTRACT_GETTER,MessageKind_ABSTRACT_SETTER,MessageKind_INHERIT_GETTER_AND_METHOD,MessageKind_INHERITED_METHOD,MessageKind_INHERITED_EXPLICIT_GETTER,MessageKind_INHERITED_IMPLICIT_GETTER,MessageKind_UNIMPLEMENTED_METHOD_ONE,MessageKind_UNIMPLEMENTED_METHOD,MessageKind_UNIMPLEMENTED_METHOD_CONT,MessageKind_UNIMPLEMENTED_SETTER_ONE,MessageKind_UNIMPLEMENTED_SETTER,MessageKind_UNIMPLEMENTED_EXPLICIT_SETTER,MessageKind_UNIMPLEMENTED_IMPLICIT_SETTER,MessageKind_UNIMPLEMENTED_GETTER_ONE,MessageKind_UNIMPLEMENTED_GETTER,MessageKind_UNIMPLEMENTED_EXPLICIT_GETTER,MessageKind_UNIMPLEMENTED_IMPLICIT_GETTER,MessageKind_EQUAL_MAP_ENTRY_KEY,MessageKind_BAD_INPUT_CHARACTER,MessageKind_UNTERMINATED_STRING,MessageKind_UNMATCHED_TOKEN,MessageKind_UNTERMINATED_TOKEN,MessageKind_EXPONENT_MISSING,MessageKind_HEX_DIGIT_EXPECTED,MessageKind_MALFORMED_STRING_LITERAL,MessageKind_UNTERMINATED_COMMENT,MessageKind_MISSING_TOKEN_BEFORE_THIS,MessageKind_MISSING_TOKEN_AFTER_THIS,MessageKind_CONSIDER_ANALYZE_ALL,MessageKind_MISSING_MAIN,MessageKind_MAIN_NOT_A_FUNCTION,MessageKind_MAIN_WITH_EXTRA_PARAMETER,MessageKind_COMPILER_CRASHED,MessageKind_PLEASE_REPORT_THE_CRASH,MessageKind_POTENTIAL_MUTATION,MessageKind_POTENTIAL_MUTATION_HERE,MessageKind_POTENTIAL_MUTATION_IN_CLOSURE,MessageKind_POTENTIAL_MUTATION_IN_CLOSURE_HERE,MessageKind_ACCESSED_IN_CLOSURE,MessageKind_ACCESSED_IN_CLOSURE_HERE,MessageKind_NOT_MORE_SPECIFIC,MessageKind_NOT_MORE_SPECIFIC_SUBTYPE,MessageKind_NOT_MORE_SPECIFIC_SUGGESTION,MessageKind_HIDDEN_WARNINGS_HINTS,MessageKind_HIDDEN_WARNINGS,MessageKind_HIDDEN_HINTS,MessageKind_PREAMBLE,MessageKind_PATCH_RETURN_TYPE_MISMATCH,MessageKind_PATCH_REQUIRED_PARAMETER_COUNT_MISMATCH,MessageKind_PATCH_OPTIONAL_PARAMETER_COUNT_MISMATCH,MessageKind_PATCH_OPTIONAL_PARAMETER_NAMED_MISMATCH,MessageKind_PATCH_PARAMETER_MISMATCH,MessageKind_PATCH_PARAMETER_TYPE_MISMATCH,MessageKind_PATCH_EXTERNAL_WITHOUT_IMPLEMENTATION,MessageKind_PATCH_POINT_TO_FUNCTION,MessageKind_PATCH_POINT_TO_CLASS,MessageKind_PATCH_POINT_TO_GETTER,MessageKind_PATCH_POINT_TO_SETTER,MessageKind_PATCH_POINT_TO_CONSTRUCTOR,MessageKind_PATCH_POINT_TO_PARAMETER,MessageKind_PATCH_NON_EXISTING,MessageKind_PATCH_NONPATCHABLE,MessageKind_PATCH_NON_EXTERNAL,MessageKind_PATCH_NON_CLASS,MessageKind_PATCH_NON_GETTER,MessageKind_PATCH_NO_GETTER,MessageKind_PATCH_NON_SETTER,MessageKind_PATCH_NO_SETTER,MessageKind_PATCH_NON_CONSTRUCTOR,MessageKind_PATCH_NON_FUNCTION,MessageKind_CALL_NOT_SUPPORTED_ON_NATIVE_CLASS"}
  },
  Message: {
    "^": "Object;kind>,arguments<,terse,message",
    computeMessage$0: function() {
      var t1, t2, t3, t4;
      t1 = {};
      if (this.message == null) {
        t2 = this.kind;
        this.message = t2.template;
        t3 = this.arguments;
        t3.forEach$1(0, new K.Message_computeMessage_closure(this));
        if (!this.terse) {
          t4 = t2.howToFix;
          t4 = t4 != null && t4 !== "";
        } else
          t4 = false;
        if (t4) {
          t1.howToFix_0 = t2.howToFix;
          t3.forEach$1(0, new K.Message_computeMessage_closure0(t1));
          this.message = H.S(this.message) + "\n" + H.S(t1.howToFix_0);
        }
      }
      return this.message;
    },
    toString$0: function(_) {
      return this.computeMessage$0();
    },
    $eq: function(_, other) {
      var t1, t2;
      if (other == null)
        return false;
      if (!J.getInterceptor(other).$isMessage)
        return false;
      if (this.kind === other.kind) {
        t1 = this.computeMessage$0();
        t2 = other.computeMessage$0();
        t2 = t1 == null ? t2 == null : t1 === t2;
        t1 = t2;
      } else
        t1 = false;
      return t1;
    },
    get$hashCode: function(_) {
      return H.throwExpression(P.UnsupportedError$("Message.hashCode"));
    },
    Message$3: function(kind, $arguments, terse) {
    },
    $isMessage: true,
    static: {Message$: function(kind, $arguments, terse) {
        var t1 = new K.Message(kind, $arguments, terse, null);
        t1.Message$3(kind, $arguments, terse);
        return t1;
      }, Message_convertToString: function(value) {
        var t1 = J.getInterceptor(value);
        if (!!t1.$isErrorToken)
          return value.get$assertionMessage();
        return H.S(!!t1.$isToken ? t1.get$value(value) : value);
      }}
  },
  Message_computeMessage_closure: {
    "^": "Closure:19;this_1",
    call$2: function(key, value) {
      var t1, t2, t3, t4;
      t1 = this.this_1;
      t2 = t1.message;
      t3 = "#{" + H.S(key) + "}";
      t4 = K.Message_convertToString(value);
      t2.toString;
      t1.message = H.stringReplaceAllUnchecked(t2, t3, t4);
    },
    $isFunction: true
  },
  Message_computeMessage_closure0: {
    "^": "Closure:19;box_0",
    call$2: function(key, value) {
      var t1, t2, t3, t4;
      t1 = this.box_0;
      t2 = t1.howToFix_0;
      t3 = "#{" + H.S(key) + "}";
      t4 = K.Message_convertToString(value);
      t2.toString;
      t1.howToFix_0 = H.stringReplaceAllUnchecked(t2, t3, t4);
    },
    $isFunction: true
  },
  World: {
    "^": "Object;compiler<,allFunctions,functionsCalledInLoop,sideEffects<,allTypedefs,mixinUses,_typesImplementedBySubclasses,_subclasses,_subtypes,_dart2js$_supertypes,sideEffectsFreeElements,elementsThatCannotThrow,functionsThatMightBePassedToApply,alreadyPopulated",
    subclassesOf$1: [function(cls) {
      return this._subclasses.$index(0, cls.get$declaration());
    }, "call$1", "get$subclassesOf", 2, 0, 93],
    subtypesOf$1: [function(cls) {
      return this._subtypes.$index(0, cls.get$declaration());
    }, "call$1", "get$subtypesOf", 2, 0, 93],
    populate$0: function() {
      this.compiler.enqueuer.resolution.seenClasses.forEach$1(0, new K.World_populate_addSubtypes(this));
    },
    commonSupertypesOf$2: function(x, y) {
      var t1, t2, xSet, ySet, t3, smallSet;
      t1 = {};
      t2 = this._dart2js$_supertypes;
      xSet = t2.$index(0, x.get$declaration());
      if (xSet == null)
        return C.List_empty5;
      ySet = t2.$index(0, y.get$declaration());
      if (ySet == null)
        return C.List_empty5;
      t1.largeSet_0 = null;
      t2 = J.get$length$asx(xSet);
      t3 = J.get$length$asx(ySet);
      if (typeof t2 !== "number")
        return t2.$le();
      if (typeof t3 !== "number")
        return H.iae(t3);
      if (t2 <= t3) {
        t1.largeSet_0 = ySet;
        smallSet = xSet;
      } else {
        t1.largeSet_0 = xSet;
        smallSet = ySet;
      }
      return J.where$1$ax(smallSet, new K.World_commonSupertypesOf_closure(t1));
    },
    registerMixinUse$2: function(mixinApplication, mixin) {
      J.add$1$ax(this.mixinUses.putIfAbsent$2(mixin, new K.World_registerMixinUse_closure()), mixinApplication);
    },
    isUsedAsMixin$1: function(cls) {
      var uses = this.mixinUses.$index(0, cls);
      return uses != null && !J.get$isEmpty$asx(uses);
    },
    hasAnySubclass$1: function(cls) {
      var classes = this._subclasses.$index(0, cls.get$declaration());
      return classes != null && !J.get$isEmpty$asx(classes);
    },
    hasAnySubtype$1: function(cls) {
      var classes = this._subtypes.$index(0, cls.get$declaration());
      return classes != null && !J.get$isEmpty$asx(classes);
    },
    hasAnySubclassThatImplements$2: function(superclass, type) {
      var subclasses = this._typesImplementedBySubclasses.$index(0, superclass.get$declaration());
      if (subclasses == null)
        return false;
      return J.contains$1$asx(subclasses, type);
    },
    hasAnySubclassOfMixinUseThatImplements$2: function(cls, type) {
      var uses = this.mixinUses.$index(0, cls);
      if ((uses == null || J.get$isEmpty$asx(uses)) === true)
        return false;
      return J.any$1$ax(uses, new K.World_hasAnySubclassOfMixinUseThatImplements_closure(this, type));
    },
    hasAnySubclassThatMixes$2: function(superclass, other) {
      var uses = this.mixinUses.$index(0, other);
      return uses != null && J.any$1$ax(uses, new K.World_hasAnySubclassThatMixes_closure(superclass));
    },
    isSubtype$2: [function(supertype, test) {
      var subtypes = this._subtypes.$index(0, supertype.get$declaration());
      return subtypes != null && J.contains$1$asx(subtypes, test.get$declaration()) === true;
    }, "call$2", "get$isSubtype", 4, 0, 94],
    registerUsedElement$1: function(element) {
      if (element.get$isInstanceMember() && !element.get$isAbstract())
        this.allFunctions.add$1(0, element);
    },
    locateSingleElement$1: function(selector) {
      var mask = selector.get$mask() == null ? new B.FlatTypeMask(this.compiler.objectClass, 5) : selector.get$mask();
      return mask.locateSingleElement$2(selector, this.compiler);
    },
    addFunctionCalledInLoop$1: [function(element) {
      this.functionsCalledInLoop.add$1(0, element.get$declaration());
    }, "call$1", "get$addFunctionCalledInLoop", 2, 0, 47],
    fieldNeverChanges$1: function(element) {
      var t1, t2;
      if (element.get$kind(element) !== C.ElementKind_field_1)
        return false;
      if (element.get$isNative())
        return false;
      if ((element.get$modifiers().flags & 4) === 0)
        if ((element.get$modifiers().flags & 16) === 0)
          if (element.get$isInstanceMember()) {
            t1 = this.compiler;
            t2 = t1.enqueuer.resolution.universe;
            t1 = !t2.hasMatchingSelector$3(t2.invokedSetters.$index(0, element.name), element, t1);
          } else
            t1 = false;
        else
          t1 = true;
      else
        t1 = true;
      return t1;
    },
    getSideEffectsOfElement$1: function(element) {
      return this.sideEffects.putIfAbsent$2(element.get$declaration(), new K.World_getSideEffectsOfElement_closure());
    },
    registerSideEffects$2: function(element, effects) {
      if (this.sideEffectsFreeElements.contains$1(0, element))
        return;
      this.sideEffects.$indexSet(0, element.get$declaration(), effects);
    },
    getSideEffectsOfSelector$1: function(selector) {
      var t1, sideEffects, t2, t3, e, t4;
      if (selector.get$isClosureCall()) {
        t1 = new Z.SideEffects(0);
        t1.flags = 7;
        t1.setDependsOnSomething$0();
        return t1;
      }
      sideEffects = new Z.SideEffects(0);
      for (t1 = J.get$iterator$ax(this.allFunctions.query$1(0, selector).functions), t2 = selector.kind, t3 = t2 === C.SelectorKind_setter_1, t2 = t2 === C.SelectorKind_getter_0; t1.moveNext$0();) {
        e = t1.get$current();
        if (J.get$kind$x(e) === C.ElementKind_field_1)
          if (t2) {
            if (!this.fieldNeverChanges$1(e))
              sideEffects.flags = (sideEffects.flags | 16) >>> 0;
          } else {
            t4 = sideEffects.flags;
            if (t3)
              sideEffects.flags = (t4 | 2) >>> 0;
            else {
              t4 = (t4 | 7) >>> 0;
              sideEffects.flags = t4;
              sideEffects.flags = (t4 | 56) >>> 0;
            }
          }
        else {
          t4 = this.getSideEffectsOfElement$1(e);
          sideEffects.flags = (sideEffects.flags | t4.flags) >>> 0;
        }
      }
      return sideEffects;
    },
    getMightBePassedToApply$1: function(element) {
      if (!!element.$isSynthesizedCallMethodElementX)
        return this.getMightBePassedToApply$1(element.expression);
      return this.functionsThatMightBePassedToApply.contains$1(0, element);
    }
  },
  World_populate_addSubtypes: {
    "^": "Closure:45;this_0",
    call$1: function(cls) {
      var t1, t2, t3, t4, type, supertypesOfClass, subtypesOfSupertype, typesImplementedBySubclassesOfCls;
      t1 = this.this_0;
      t2 = t1.compiler;
      if (t2.hasIncrementalSupport && !t1.alreadyPopulated.add$1(0, cls))
        return;
      if (cls.get$resolutionState() !== 2)
        t2.internalError$2(cls, "Class \"" + H.S(cls.get$name(cls)) + "\" is not resolved.");
      for (t2 = cls.get$allSupertypesAndSelf()._supertypes, t2.toString, t2 = H.setRuntimeTypeInfo(new E.LinkIterator(null, t2), [H.getTypeArgumentByIndex(t2, 0)]), t3 = t1._dart2js$_supertypes, t4 = t1._subtypes; t2.moveNext$0();) {
        type = t2._util_implementation$_current;
        supertypesOfClass = t3.putIfAbsent$2(cls, new K.World_populate_addSubtypes_closure());
        subtypesOfSupertype = t4.putIfAbsent$2(type.get$element(), new K.World_populate_addSubtypes_closure0());
        J.add$1$ax(supertypesOfClass, type.get$element());
        J.add$1$ax(subtypesOfSupertype, cls);
      }
      type = cls.supertype;
      for (t2 = t1._subclasses, t1 = t1._typesImplementedBySubclasses; type != null;) {
        J.add$1$ax(t2.putIfAbsent$2(type.get$element(), new K.World_populate_addSubtypes_closure1()), cls);
        typesImplementedBySubclassesOfCls = t1.putIfAbsent$2(type.get$element(), new K.World_populate_addSubtypes_closure2());
        t3 = cls.allSupertypesAndSelf._supertypes;
        t3.toString;
        t4 = new E.LinkIterator(null, t3);
        t4.$builtinTypeInfo = [H.getTypeArgumentByIndex(t3, 0)];
        t3 = J.getInterceptor$ax(typesImplementedBySubclassesOfCls);
        for (; t4.moveNext$0();)
          t3.add$1(typesImplementedBySubclassesOfCls, t4._util_implementation$_current.get$element());
        type = type.get$element().get$supertype();
      }
    },
    $isFunction: true
  },
  World_populate_addSubtypes_closure: {
    "^": "Closure:23;",
    call$0: function() {
      return P.LinkedHashSet_LinkedHashSet(null, null, null, O.ClassElement);
    },
    $isFunction: true
  },
  World_populate_addSubtypes_closure0: {
    "^": "Closure:23;",
    call$0: function() {
      return P.LinkedHashSet_LinkedHashSet(null, null, null, O.ClassElement);
    },
    $isFunction: true
  },
  World_populate_addSubtypes_closure1: {
    "^": "Closure:23;",
    call$0: function() {
      return P.LinkedHashSet_LinkedHashSet(null, null, null, O.ClassElement);
    },
    $isFunction: true
  },
  World_populate_addSubtypes_closure2: {
    "^": "Closure:23;",
    call$0: function() {
      return P.LinkedHashSet_LinkedHashSet(null, null, null, O.ClassElement);
    },
    $isFunction: true
  },
  World_commonSupertypesOf_closure: {
    "^": "Closure:87;box_0",
    call$1: function(each) {
      return this.box_0.largeSet_0.contains$1(0, each);
    },
    $isFunction: true
  },
  World_registerMixinUse_closure: {
    "^": "Closure:23;",
    call$0: function() {
      return P.LinkedHashSet_LinkedHashSet(null, null, null, O.MixinApplicationElement);
    },
    $isFunction: true
  },
  World_hasAnySubclassOfMixinUseThatImplements_closure: {
    "^": "Closure:13;this_0,type_1",
    call$1: function(use) {
      return this.this_0.hasAnySubclassThatImplements$2(use, this.type_1);
    },
    $isFunction: true
  },
  World_hasAnySubclassThatMixes_closure: {
    "^": "Closure:13;superclass_0",
    call$1: function(each) {
      return each.isSubclassOf$1(this.superclass_0);
    },
    $isFunction: true
  },
  World_getSideEffectsOfElement_closure: {
    "^": "Closure:23;",
    call$0: function() {
      var t1 = new Z.SideEffects(0);
      t1.flags = 7;
      t1.setDependsOnSomething$0();
      return t1;
    },
    $isFunction: true
  }
}],
["dart2js._js_primitives", "dart:_js_primitives", , H, {
  "^": "",
  printString: function(string) {
    if (typeof dartPrint == "function") {
      dartPrint(string);
      return;
    }
    if (typeof console == "object" && typeof console.log != "undefined") {
      console.log(string);
      return;
    }
    if (typeof window == "object")
      return;
    if (typeof print == "function") {
      print(string);
      return;
    }
    throw "Unable to print message: " + String(string);
  }
}],
["dart2js.ir_builder", "package:compiler/implementation/cps_ir/cps_ir_builder.dart", , K, {
  "^": "",
  IrBuilderTask: {
    "^": "CompilerTask;nodes>,compiler,watch,profilerTag",
    get$name: function(_) {
      return "IR builder";
    },
    buildNodes$1$useNewBackend: function(useNewBackend) {
      var t1;
      if (useNewBackend || false) {
        t1 = this.compiler;
        t1 = !!J.getInterceptor(t1.backend).$isDartBackend && !t1.enableTypeAssertions && !t1.enableConcreteTypeInference;
      } else
        t1 = false;
      if (!t1)
        return;
      this.measure$1(new K.IrBuilderTask_buildNodes_closure(this));
    },
    buildNodes$0: function() {
      return this.buildNodes$1$useNewBackend(false);
    },
    canBuild$1: function(element) {
      var $function, t1;
      $function = element.asFunctionElement$0();
      if ($function == null)
        return false;
      if (!this.compiler.backend.shouldOutput$1($function))
        return false;
      if (element.get$isGetter() || element.kind === C.ElementKind_setter_0)
        return false;
      if ($function._isNative)
        return false;
      t1 = !!$function.$isConstructorElement;
      if (t1 && $function.get$isRedirectingFactory())
        return false;
      if (t1 && ($function.get$modifiers().flags & 32) !== 0)
        return false;
      return true;
    }
  },
  IrBuilderTask_buildNodes_closure: {
    "^": "Closure:23;this_0",
    call$0: function() {
      var t1 = this.this_0;
      t1.compiler.enqueuer.resolution.resolvedElements.forEach$1(0, new K.IrBuilderTask_buildNodes__closure(t1));
    },
    $isFunction: true
  },
  IrBuilderTask_buildNodes__closure: {
    "^": "Closure:95;this_1",
    call$1: function(element) {
      var t1, t2, t3, t4, builder, kind, $function;
      t1 = this.this_1;
      if (t1.canBuild$1(element)) {
        t2 = element.get$resolvedAst();
        element = element.get$implementation(element);
        t3 = J.getInterceptor(element);
        t4 = t1.compiler;
        builder = K.IrBuilder$(t2.elements, t4, (!!t3.$isFunctionElement ? element.get$patch() != null ? element.get$patch() : element : element).get$compilationUnit().get$script().file);
        kind = t3.get$kind(element);
        if (kind === C.ElementKind_generative_constructor_16)
          $function = null;
        else if (element.get$isDeferredLoaderGetter())
          $function = null;
        else if (kind === C.ElementKind_generative_constructor_body_0 || kind === C.ElementKind_function_2 || kind === C.ElementKind_getter_0 || kind === C.ElementKind_setter_0)
          $function = builder.buildFunction$1(element);
        else {
          if (kind === C.ElementKind_field_1)
            ;
          else
            t4.internalError$2(element, "Unexpected element kind " + J.toString$0(kind) + ".");
          $function = null;
        }
        if ($function != null) {
          t1.nodes.$indexSet(0, element, $function);
          t4.tracer.traceCompilation$3(element.name, null, t4);
          t4.tracer.traceGraph$2("IR Builder", $function);
        }
      }
    },
    $isFunction: true
  },
  _GetterElements: {
    "^": "Object;result,index>,receiver<"
  },
  Environment: {
    "^": "Object;variable2index,index2variable,index2value<",
    get$length: function(_) {
      return this.index2variable.length;
    },
    $index: function(_, index) {
      var t1 = this.index2value;
      if (index >>> 0 !== index || index >= t1.length)
        return H.ioore(t1, index);
      return t1[index];
    },
    extend$2: function(element, value) {
      var t1 = this.index2variable;
      this.variable2index.$indexSet(0, element, t1.length);
      t1.push(element);
      this.index2value.push(value);
    },
    lookup$1: function(element) {
      var t1, t2;
      t1 = this.index2value;
      t2 = this.variable2index.$index(0, element);
      if (t2 >>> 0 !== t2 || t2 >= t1.length)
        return H.ioore(t1, t2);
      return t1[t2];
    },
    static: {Environment$empty: function() {
        return new K.Environment(P.LinkedHashMap_LinkedHashMap$_empty(O.Element, P.$int), H.setRuntimeTypeInfo([], [O.Element]), H.setRuntimeTypeInfo([], [D.Primitive]));
      }}
  },
  JumpCollector: {
    "^": "Object;target>,_invocations,_environments",
    get$isEmpty: function(_) {
      return this._invocations.length === 0;
    },
    get$length: function(_) {
      return this._invocations.length;
    },
    addJump$1: function(builder) {
      var t1, invoke;
      t1 = $.Node_hashCount + 1 & 1073741823;
      $.Node_hashCount = t1;
      invoke = new D.InvokeContinuation(null, null, false, t1, null);
      builder.add$1(0, invoke);
      this._invocations.push(invoke);
      this._environments.push(builder.environment);
      builder.current = null;
    }
  },
  IrBuilder: {
    "^": "ResolvedVisitor;sourceFile,returnContinuation,parameters<,root<,current@,environment<,breakCollectors,constantBuilder,localConstants,currentFunction,closureLocals,_currentCascadeReceiver,compiler,elements",
    buildFunction$1: function(functionElement) {
      return this.nullIfGiveup$1(new K.IrBuilder_buildFunction_closure(this, functionElement));
    },
    buildFunctionInternal$1: function(element) {
      var $function, signature, defaults, t1, t2;
      this.currentFunction = element;
      $function = element.get$node();
      $function.accept$1(0, this.closureLocals);
      this.current = null;
      this.root = null;
      signature = element.get$functionSignature();
      signature.orderedForEachParameter$1(new K.IrBuilder_buildFunctionInternal_closure(this));
      defaults = H.setRuntimeTypeInfo([], [M.ConstExp]);
      H.IterableMixinWorkaround_forEach(signature.orderedOptionalParameters, new K.IrBuilder_buildFunctionInternal_closure0(this, defaults));
      $function.get$body($function).accept$1(0, this);
      this.ensureReturn$1($function);
      t1 = this.root;
      t2 = $.Node_hashCount + 1 & 1073741823;
      $.Node_hashCount = t2;
      return new D.FunctionDefinition(element, this.returnContinuation, this.parameters, t1, this.localConstants, defaults, t2, null);
    },
    add$1: function(_, expr) {
      if (this.root == null) {
        this.current = expr;
        this.root = expr;
      } else
        this.current = this.current.plug$1(expr);
    },
    ensureReturn$1: function(node) {
      var t1, t2, constant;
      if (!(this.root == null || this.current != null))
        return;
      t1 = this.compiler.backend.get$constantSystem().createNull$0();
      t2 = $.Node_hashCount + 1 & 1073741823;
      $.Node_hashCount = t2;
      constant = new D.Constant1(new M.PrimitiveConstExp(t1), t1, null, null, null, t2, null);
      t2 = t2 + 1 & 1073741823;
      $.Node_hashCount = t2;
      this.add$1(0, new D.LetPrim(constant, null, t2, null));
      this.add$1(0, D.InvokeContinuation$(this.returnContinuation, [constant], false));
      this.current = null;
    },
    visit$1: [function(node) {
      return J.accept$1$x(node, this);
    }, "call$1", "get$visit", 2, 0, 96],
    visitBlock$1: function(node) {
      var t1;
      for (t1 = node.statements.nodes, t1.toString, t1 = H.setRuntimeTypeInfo(new E.LinkIterator(null, t1), [H.getTypeArgumentByIndex(t1, 0)]); t1.moveNext$0();) {
        J.accept$1$x(t1._util_implementation$_current, this);
        if (!(this.root == null || this.current != null))
          return;
      }
      return;
    },
    visitBreakStatement$1: function(node) {
      var t1, target, t2, collector;
      t1 = this.elements._usedTargets;
      target = t1 != null ? t1.$index(0, node) : null;
      for (t1 = this.breakCollectors, t1 = H.setRuntimeTypeInfo(new H.ListIterator(t1, t1.length, 0, null), [H.getTypeArgumentByIndex(t1, 0)]), t2 = J.getInterceptor(target); t1.moveNext$0();) {
        collector = t1.__internal$_current;
        if (t2.$eq(target, J.get$target$x(collector))) {
          collector.addJump$1(this);
          return;
        }
      }
      this.compiler.internalError$2(node, "'break' target not found");
    },
    visitEmptyStatement$1: function(node) {
      return;
    },
    visitExpressionStatement$1: function(node) {
      node.expression.accept$1(0, this);
      return;
    },
    createJoin$2: function(environmentLength, jumps) {
      var t1, t2, t3, first, second, common, i, candidate, t4, parameters, index, index0, join, currentEnvironment, invoke, $arguments, i0, t5, t6;
      t1 = {};
      t2 = jumps._environments;
      t3 = t2.length;
      if (0 >= t3)
        return H.ioore(t2, 0);
      first = t2[0];
      if (1 >= t3)
        return H.ioore(t2, 1);
      second = t2[1];
      t1.parameterCount_0 = 0;
      common = P.List_List$generate(environmentLength, new K.IrBuilder_createJoin_closure(t1, first, second), true, D.Primitive);
      if (t1.parameterCount_0 < environmentLength)
        for (i = 0; i < environmentLength; ++i) {
          if (i >= common.length)
            return H.ioore(common, i);
          candidate = common[i];
          if (candidate == null)
            continue;
          t3 = new H.IterableMixinWorkaround();
          t3.$builtinTypeInfo = [H.getTypeArgumentByIndex(t2, 0)];
          t4 = new H.SubListIterable(t2, 2, null);
          t4.$builtinTypeInfo = [H.getTypeArgumentByIndex(t3, 0)];
          t3 = new H.ListIterator(t4, t4.get$length(t4), 0, null);
          t3.$builtinTypeInfo = [H.getRuntimeTypeArgument(t4, "ListIterable", 0)];
          for (; t3.moveNext$0();) {
            t4 = t3.__internal$_current.get$index2value();
            if (i >= t4.length)
              return H.ioore(t4, i);
            if (candidate !== t4[i]) {
              if (i >= common.length)
                return H.ioore(common, i);
              common[i] = null;
              ++t1.parameterCount_0;
              break;
            }
          }
          if (t1.parameterCount_0 >= environmentLength)
            break;
        }
      parameters = H.setRuntimeTypeInfo([], [D.Parameter1]);
      C.JSArray_methods.set$length(parameters, t1.parameterCount_0);
      for (index = 0, i = 0; i < environmentLength; ++i) {
        if (i >= common.length)
          return H.ioore(common, i);
        if (common[i] == null) {
          index0 = index + 1;
          t3 = first.index2variable;
          if (i >= t3.length)
            return H.ioore(t3, i);
          t3 = t3[i];
          t4 = $.Node_hashCount + 1 & 1073741823;
          $.Node_hashCount = t4;
          t4 = new D.Parameter1(null, null, null, t4, null);
          t4.hint = t3;
          if (index >= parameters.length)
            return H.ioore(parameters, index);
          parameters[index] = t4;
          index = index0;
        }
      }
      t3 = $.Node_hashCount + 1 & 1073741823;
      $.Node_hashCount = t3;
      join = new D.Continuation(parameters, null, false, null, t3, null);
      for (t3 = jumps._invocations, i = 0; i < t3.length; ++i) {
        if (i >= t2.length)
          return H.ioore(t2, i);
        currentEnvironment = t2[i];
        invoke = t3[i];
        $arguments = [];
        $arguments.$builtinTypeInfo = [D.Reference];
        C.JSArray_methods.set$length($arguments, t1.parameterCount_0);
        for (index = 0, i0 = 0; i0 < environmentLength; ++i0) {
          if (i0 >= common.length)
            return H.ioore(common, i0);
          if (common[i0] == null) {
            index0 = index + 1;
            t4 = currentEnvironment.index2value;
            if (i0 >= t4.length)
              return H.ioore(t4, i0);
            t4 = t4[i0];
            t5 = new D.Reference(t4, null, null, null);
            t6 = t4.firstRef;
            t5.next = t6;
            if (t6 != null)
              t6.previous = t5;
            t4.firstRef = t5;
            if (index >= $arguments.length)
              return H.ioore($arguments, index);
            $arguments[index] = t5;
            index = index0;
          }
        }
        t4 = new D.Reference(join, null, null, null);
        t5 = join.firstRef;
        t4.next = t5;
        if (t5 != null)
          t5.previous = t4;
        join.firstRef = t4;
        invoke.continuation = t4;
        invoke.arguments = $arguments;
      }
      for (t1 = this.environment, t2 = t1.index2variable.length, t3 = common.length, t4 = parameters.length, index = 0, i = 0; i < t2; ++i) {
        if (i >= t3)
          return H.ioore(common, i);
        if (common[i] == null) {
          t5 = t1.index2value;
          index0 = index + 1;
          if (index >= t4)
            return H.ioore(parameters, index);
          t6 = parameters[index];
          if (i >= t5.length)
            return H.ioore(t5, i);
          t5[i] = t6;
          index = index0;
        }
      }
      return join;
    },
    invokeRecursiveJoin$2: function(join, contexts) {
      var t1, t2, context, t3;
      for (t1 = H.setRuntimeTypeInfo(new H.ListIterator(contexts, 1, 0, null), [H.getTypeArgumentByIndex(contexts, 0)]), t2 = join.parameters; t1.moveNext$0();) {
        context = t1.__internal$_current;
        t3 = D.InvokeContinuation$(join, C.JSArray_methods.sublist$2(context.get$environment().index2value, 0, t2.length), true);
        if (context.get$root() == null) {
          context.set$current(t3);
          context.root = t3;
        } else
          context.current = context.get$current().plug$1(t3);
        context.set$current(null);
      }
    },
    visitFor$1: function(node) {
      var t1, t2, t3, t4, definition, condBuilder, condition, breakCollector, bodyBuilder, n, bodyContinuation, exitContinuation, t5, t6, t7, branch, letJoin, loopContinuation;
      t1 = node.initializer;
      t2 = J.getInterceptor(t1);
      if (!!t2.$isVariableDefinitions)
        for (t3 = t1.get$definitions().nodes, t3.toString, t3 = H.setRuntimeTypeInfo(new E.LinkIterator(null, t3), [H.getTypeArgumentByIndex(t3, 0)]), t4 = this.closureLocals.usedFromClosure; t3.moveNext$0();) {
          definition = t3._util_implementation$_current;
          this.elements.toString;
          if (t4.contains$1(0, definition.get$_secret_tree_element$_element()))
            return this.giveup$2(definition, "Closure variable in for loop initializer");
        }
      if (t1 != null)
        t2.accept$1(t1, this);
      condBuilder = K.IrBuilder$recursive(this);
      if (node.get$condition() == null) {
        t1 = this.compiler.backend.get$constantSystem().createBool$1(true);
        t2 = $.Node_hashCount + 1 & 1073741823;
        $.Node_hashCount = t2;
        condition = new D.Constant1(new M.PrimitiveConstExp(t1), t1, null, null, null, t2, null);
        t2 = t2 + 1 & 1073741823;
        $.Node_hashCount = t2;
        condBuilder.add$1(0, new D.LetPrim(condition, null, t2, null));
      } else
        condition = node.get$condition().accept$1(0, condBuilder);
      t1 = this.elements._definedTargets;
      t1 = t1 != null ? t1.$index(0, node) : null;
      breakCollector = new K.JumpCollector(t1, H.setRuntimeTypeInfo([], [D.InvokeContinuation]), H.setRuntimeTypeInfo([], [K.Environment]));
      t1 = this.breakCollectors;
      t1.push(breakCollector);
      bodyBuilder = K.IrBuilder$delimited(condBuilder);
      node.body.accept$1(0, bodyBuilder);
      for (t2 = node.update.nodes, t2.toString, t2 = H.setRuntimeTypeInfo(new E.LinkIterator(null, t2), [H.getTypeArgumentByIndex(t2, 0)]); t2.moveNext$0();) {
        n = t2._util_implementation$_current;
        if (!(bodyBuilder.root == null || bodyBuilder.current != null))
          break;
        J.accept$1$x(n, bodyBuilder);
      }
      if (0 >= t1.length)
        return H.ioore(t1, 0);
      t1.pop();
      t1 = $.Node_hashCount + 1 & 1073741823;
      $.Node_hashCount = t1;
      bodyContinuation = new D.Continuation([], null, false, null, t1, null);
      t1 = t1 + 1 & 1073741823;
      $.Node_hashCount = t1;
      exitContinuation = new D.Continuation([], null, false, null, t1, null);
      t1 = D.Reference$(condition);
      t2 = $.Node_hashCount + 1 & 1073741823;
      $.Node_hashCount = t2;
      t3 = D.Reference$(bodyContinuation);
      t4 = D.Reference$(exitContinuation);
      t5 = $.Node_hashCount + 1 & 1073741823;
      $.Node_hashCount = t5;
      t6 = t5 + 1 & 1073741823;
      $.Node_hashCount = t6;
      t7 = t6 + 1 & 1073741823;
      $.Node_hashCount = t7;
      branch = new D.LetCont(exitContinuation, new D.LetCont(bodyContinuation, new D.Branch(new D.IsTrue(t1, t2, null), t3, t4, t5, null), t6, null), t7, null);
      if (breakCollector._invocations.length === 0) {
        condBuilder.add$1(0, branch);
        letJoin = null;
      } else {
        t1 = t7 + 1 & 1073741823;
        $.Node_hashCount = t1;
        letJoin = new D.LetCont(null, branch, t1, null);
        condBuilder.add$1(0, letJoin);
        condBuilder.current = branch;
      }
      t1 = $.Node_hashCount + 1 & 1073741823;
      $.Node_hashCount = t1;
      loopContinuation = new D.Continuation(condBuilder.parameters, null, false, null, t1, null);
      if (bodyBuilder.root == null || bodyBuilder.current != null)
        this.invokeRecursiveJoin$2(loopContinuation, [bodyBuilder]);
      bodyContinuation.body = bodyBuilder.root;
      loopContinuation.body = condBuilder.root;
      t1 = D.InvokeContinuation$(loopContinuation, this.environment.index2value, false);
      t2 = $.Node_hashCount + 1 & 1073741823;
      $.Node_hashCount = t2;
      this.add$1(0, new D.LetCont(loopContinuation, t1, t2, null));
      if (letJoin == null) {
        this.current = condBuilder.current;
        this.environment = condBuilder.environment;
      } else {
        this.current = branch;
        this.environment = condBuilder.environment;
        breakCollector.addJump$1(this);
        letJoin.continuation = this.createJoin$2(this.environment.index2variable.length, breakCollector);
        this.current = letJoin;
      }
      return;
    },
    visitIf$1: function(node) {
      var condition, thenBuilder, elseBuilder, t1, thenContinuation, elseContinuation, t2, t3, t4, t5, t6, letElse, letThen, jumps, joinContinuation, result;
      condition = node.get$condition().accept$1(0, this);
      thenBuilder = K.IrBuilder$delimited(this);
      elseBuilder = K.IrBuilder$delimited(this);
      node.get$thenPart().accept$1(0, thenBuilder);
      t1 = node.elsePart;
      if (t1 != null)
        t1.accept$1(0, elseBuilder);
      t1 = $.Node_hashCount + 1 & 1073741823;
      $.Node_hashCount = t1;
      thenContinuation = new D.Continuation([], null, false, null, t1, null);
      t1 = t1 + 1 & 1073741823;
      $.Node_hashCount = t1;
      elseContinuation = new D.Continuation([], null, false, null, t1, null);
      t1 = D.Reference$(condition);
      t2 = $.Node_hashCount + 1 & 1073741823;
      $.Node_hashCount = t2;
      t3 = D.Reference$(thenContinuation);
      t4 = D.Reference$(elseContinuation);
      t5 = $.Node_hashCount + 1 & 1073741823;
      $.Node_hashCount = t5;
      t6 = t5 + 1 & 1073741823;
      $.Node_hashCount = t6;
      letElse = new D.LetCont(elseContinuation, new D.Branch(new D.IsTrue(t1, t2, null), t3, t4, t5, null), t6, null);
      t6 = t6 + 1 & 1073741823;
      $.Node_hashCount = t6;
      letThen = new D.LetCont(thenContinuation, letElse, t6, null);
      if (thenBuilder.root == null || thenBuilder.current != null)
        t1 = elseBuilder.root == null || elseBuilder.current != null;
      else
        t1 = false;
      if (t1) {
        jumps = new K.JumpCollector(null, H.setRuntimeTypeInfo([], [D.InvokeContinuation]), H.setRuntimeTypeInfo([], [K.Environment]));
        jumps.addJump$1(thenBuilder);
        jumps.addJump$1(elseBuilder);
        joinContinuation = this.createJoin$2(this.environment.index2variable.length, jumps);
        t1 = $.Node_hashCount + 1 & 1073741823;
        $.Node_hashCount = t1;
        result = new D.LetCont(joinContinuation, letThen, t1, null);
      } else {
        result = letThen;
        joinContinuation = null;
      }
      thenContinuation.body = thenBuilder.root;
      elseContinuation.body = elseBuilder.root;
      this.add$1(0, result);
      if (joinContinuation == null) {
        t1 = thenBuilder.root == null;
        if (t1 || thenBuilder.current != null) {
          this.current = t1 ? letThen : thenBuilder.current;
          this.environment = thenBuilder.environment;
        } else {
          t1 = elseBuilder.root == null;
          if (t1 || elseBuilder.current != null) {
            this.current = t1 ? letElse : elseBuilder.current;
            this.environment = elseBuilder.environment;
          } else
            this.current = null;
        }
      }
      return;
    },
    visitLabeledStatement$1: function(node) {
      var body, t1;
      body = node.statement;
      t1 = J.getInterceptor(body);
      return !!t1.$isLoop ? t1.accept$1(body, this) : this.giveup$2(node, "labeled statement");
    },
    visitWhile$1: function(node) {
      var condBuilder, condition, t1, t2, breakCollector, bodyBuilder, bodyContinuation, exitContinuation, t3, t4, t5, t6, t7, t8, branch, letJoin, loopContinuation;
      condBuilder = K.IrBuilder$recursive(this);
      condition = node.condition.accept$1(0, condBuilder);
      t1 = this.elements._definedTargets;
      t1 = t1 != null ? t1.$index(0, node) : null;
      t2 = H.setRuntimeTypeInfo([], [D.InvokeContinuation]);
      breakCollector = new K.JumpCollector(t1, t2, H.setRuntimeTypeInfo([], [K.Environment]));
      t1 = this.breakCollectors;
      t1.push(breakCollector);
      bodyBuilder = K.IrBuilder$delimited(condBuilder);
      node.body.accept$1(0, bodyBuilder);
      if (0 >= t1.length)
        return H.ioore(t1, 0);
      t1.pop();
      t1 = $.Node_hashCount + 1 & 1073741823;
      $.Node_hashCount = t1;
      bodyContinuation = new D.Continuation([], null, false, null, t1, null);
      t1 = t1 + 1 & 1073741823;
      $.Node_hashCount = t1;
      exitContinuation = new D.Continuation([], null, false, null, t1, null);
      t1 = D.Reference$(condition);
      t3 = $.Node_hashCount + 1 & 1073741823;
      $.Node_hashCount = t3;
      t4 = D.Reference$(bodyContinuation);
      t5 = D.Reference$(exitContinuation);
      t6 = $.Node_hashCount + 1 & 1073741823;
      $.Node_hashCount = t6;
      t7 = t6 + 1 & 1073741823;
      $.Node_hashCount = t7;
      t8 = t7 + 1 & 1073741823;
      $.Node_hashCount = t8;
      branch = new D.LetCont(exitContinuation, new D.LetCont(bodyContinuation, new D.Branch(new D.IsTrue(t1, t3, null), t4, t5, t6, null), t7, null), t8, null);
      if (t2.length === 0) {
        condBuilder.add$1(0, branch);
        letJoin = null;
      } else {
        t1 = t8 + 1 & 1073741823;
        $.Node_hashCount = t1;
        letJoin = new D.LetCont(null, branch, t1, null);
        condBuilder.add$1(0, letJoin);
        condBuilder.current = branch;
      }
      t1 = $.Node_hashCount + 1 & 1073741823;
      $.Node_hashCount = t1;
      loopContinuation = new D.Continuation(condBuilder.parameters, null, false, null, t1, null);
      if (bodyBuilder.root == null || bodyBuilder.current != null)
        this.invokeRecursiveJoin$2(loopContinuation, [bodyBuilder]);
      bodyContinuation.body = bodyBuilder.root;
      loopContinuation.body = condBuilder.root;
      t1 = D.InvokeContinuation$(loopContinuation, this.environment.index2value, false);
      t2 = $.Node_hashCount + 1 & 1073741823;
      $.Node_hashCount = t2;
      this.add$1(0, new D.LetCont(loopContinuation, t1, t2, null));
      if (letJoin == null) {
        this.current = condBuilder.current;
        this.environment = condBuilder.environment;
      } else {
        this.current = branch;
        this.environment = condBuilder.environment;
        breakCollector.addJump$1(this);
        letJoin.continuation = this.createJoin$2(this.environment.index2variable.length, breakCollector);
        this.current = letJoin;
      }
      return;
    },
    visitVariableDefinitions$1: function(node) {
      var t1, t2, definition, element, t3, t4, initialValue, t5;
      if ((node.modifiers.flags & 16) !== 0)
        for (t1 = node.definitions.nodes, t1.toString, t1 = H.setRuntimeTypeInfo(new E.LinkIterator(null, t1), [H.getTypeArgumentByIndex(t1, 0)]), t2 = this.localConstants; t1.moveNext$0();) {
          definition = t1._util_implementation$_current;
          this.elements.toString;
          element = definition.get$_secret_tree_element$_element();
          t3 = this.constantBuilder;
          t4 = definition.get$argumentsNode().nodes;
          t4 = t4.get$head(t4);
          t3.toString;
          t2.push(new M.ConstDeclaration(element, J.accept$1$x(t4, t3)));
        }
      else
        for (t1 = node.definitions.nodes, t1.toString, t1 = H.setRuntimeTypeInfo(new E.LinkIterator(null, t1), [H.getTypeArgumentByIndex(t1, 0)]), t2 = this.closureLocals.usedFromClosure, t3 = this.compiler; t1.moveNext$0();) {
          definition = t1._util_implementation$_current;
          this.elements.toString;
          element = definition.get$_secret_tree_element$_element();
          if (!!definition.$isSendSet) {
            t4 = definition.argumentsNode.nodes;
            initialValue = J.accept$1$x(t4.get$head(t4), this);
          } else {
            t4 = t3.backend.get$constantSystem().createNull$0();
            t5 = $.Node_hashCount + 1 & 1073741823;
            $.Node_hashCount = t5;
            initialValue = new D.Constant1(new M.PrimitiveConstExp(t4), t4, null, null, null, t5, null);
            t5 = t5 + 1 & 1073741823;
            $.Node_hashCount = t5;
            t5 = new D.LetPrim(initialValue, null, t5, null);
            if (this.root == null) {
              this.current = t5;
              this.root = t5;
            } else
              this.current = this.current.plug$1(t5);
          }
          if (t2.contains$1(0, element)) {
            t4 = new D.Reference(initialValue, null, null, null);
            t5 = initialValue.firstRef;
            t4.next = t5;
            if (t5 != null)
              t5.previous = t4;
            initialValue.firstRef = t4;
            t5 = $.Node_hashCount + 1 & 1073741823;
            $.Node_hashCount = t5;
            t5 = new D.SetClosureVariable(element, t4, null, true, t5, null);
            if (this.root == null) {
              this.current = t5;
              this.root = t5;
            } else
              this.current = this.current.plug$1(t5);
          } else {
            if (initialValue.get$hint() == null)
              initialValue.hint = element;
            this.environment.extend$2(element, initialValue);
          }
        }
      return;
    },
    visitReturn$1: function(node) {
      var t1, t2, value;
      t1 = node.get$beginToken();
      if (t1.get$value(t1) === "native")
        return this.giveup$2(node, "Native return");
      t1 = node.expression;
      if (t1 == null) {
        t1 = this.compiler.backend.get$constantSystem().createNull$0();
        t2 = $.Node_hashCount + 1 & 1073741823;
        $.Node_hashCount = t2;
        value = new D.Constant1(new M.PrimitiveConstExp(t1), t1, null, null, null, t2, null);
        t2 = t2 + 1 & 1073741823;
        $.Node_hashCount = t2;
        this.add$1(0, new D.LetPrim(value, null, t2, null));
      } else
        value = t1.accept$1(0, this);
      this.add$1(0, D.InvokeContinuation$(this.returnContinuation, [value], false));
      this.current = null;
      return;
    },
    visitConditional$1: function(node) {
      var condition, thenBuilder, elseBuilder, thenValue, elseValue, jumps, joinContinuation, t1, thenContinuation, elseContinuation, t2, t3, t4, t5, t6, t7, t8;
      condition = node.condition.accept$1(0, this);
      thenBuilder = K.IrBuilder$delimited(this);
      elseBuilder = K.IrBuilder$delimited(this);
      thenValue = node.thenExpression.accept$1(0, thenBuilder);
      elseValue = node.elseExpression.accept$1(0, elseBuilder);
      thenBuilder.environment.extend$2(null, thenValue);
      elseBuilder.environment.extend$2(null, elseValue);
      jumps = new K.JumpCollector(null, H.setRuntimeTypeInfo([], [D.InvokeContinuation]), H.setRuntimeTypeInfo([], [K.Environment]));
      jumps.addJump$1(thenBuilder);
      jumps.addJump$1(elseBuilder);
      joinContinuation = this.createJoin$2(this.environment.index2variable.length + 1, jumps);
      t1 = $.Node_hashCount + 1 & 1073741823;
      $.Node_hashCount = t1;
      thenContinuation = new D.Continuation([], null, false, null, t1, null);
      t1 = t1 + 1 & 1073741823;
      $.Node_hashCount = t1;
      elseContinuation = new D.Continuation([], null, false, null, t1, null);
      thenContinuation.body = thenBuilder.root;
      elseContinuation.body = elseBuilder.root;
      t1 = D.Reference$(condition);
      t2 = $.Node_hashCount + 1 & 1073741823;
      $.Node_hashCount = t2;
      t3 = D.Reference$(thenContinuation);
      t4 = D.Reference$(elseContinuation);
      t5 = $.Node_hashCount + 1 & 1073741823;
      $.Node_hashCount = t5;
      t6 = t5 + 1 & 1073741823;
      $.Node_hashCount = t6;
      t7 = t6 + 1 & 1073741823;
      $.Node_hashCount = t7;
      t8 = t7 + 1 & 1073741823;
      $.Node_hashCount = t8;
      this.add$1(0, new D.LetCont(joinContinuation, new D.LetCont(thenContinuation, new D.LetCont(elseContinuation, new D.Branch(new D.IsTrue(t1, t2, null), t3, t4, t5, null), t6, null), t7, null), t8, null));
      return J.$eq(thenValue, elseValue) ? thenValue : C.JSArray_methods.get$last(joinContinuation.parameters);
    },
    visitLiteralBool$1: function(node) {
      return this.translateConstant$1(node);
    },
    visitLiteralDouble$1: function(node) {
      return this.translateConstant$1(node);
    },
    visitLiteralInt$1: function(node) {
      return this.translateConstant$1(node);
    },
    visitLiteralNull$1: function(node) {
      return this.translateConstant$1(node);
    },
    visitLiteralString$1: function(node) {
      return this.translateConstant$1(node);
    },
    visitLiteralList$1: function(node) {
      var values, t1, type, t2, result;
      if (node.get$constKeyword() != null)
        return this.translateConstant$1(node);
      values = node.elements.nodes.mapToList$1(this.get$visit());
      t1 = this.elements._types;
      type = t1 != null ? t1.$index(0, node) : null;
      t1 = D._referenceList(values);
      t2 = $.Node_hashCount + 1 & 1073741823;
      $.Node_hashCount = t2;
      result = new D.LiteralList1(type, t1, null, null, null, t2, null);
      t2 = t2 + 1 & 1073741823;
      $.Node_hashCount = t2;
      this.add$1(0, new D.LetPrim(result, null, t2, null));
      return result;
    },
    visitLiteralMap$1: function(node) {
      var keys, values, t1, type, t2, t3, result;
      if (node.constKeyword != null)
        return this.translateConstant$1(node);
      keys = H.setRuntimeTypeInfo([], [D.Primitive]);
      values = H.setRuntimeTypeInfo([], [D.Primitive]);
      node.entries.nodes.forEach$1(0, new K.IrBuilder_visitLiteralMap_closure(this, keys, values));
      t1 = this.elements._types;
      type = t1 != null ? t1.$index(0, node) : null;
      t1 = D._referenceList(keys);
      t2 = D._referenceList(values);
      t3 = $.Node_hashCount + 1 & 1073741823;
      $.Node_hashCount = t3;
      result = new D.LiteralMap1(type, t1, t2, null, null, null, t3, null);
      t3 = t3 + 1 & 1073741823;
      $.Node_hashCount = t3;
      this.add$1(0, new D.LetPrim(result, null, t3, null));
      return result;
    },
    visitLiteralSymbol$1: function(node) {
      return this.translateConstant$1(node);
    },
    visitIdentifier$1: function(node) {
      return this.lookupThis$0();
    },
    visitParenthesizedExpression$1: function(node) {
      return node.expression.accept$1(0, this);
    },
    visitCascadeReceiver$1: function(node) {
      var t1 = node.expression.accept$1(0, this);
      this._currentCascadeReceiver = t1;
      return t1;
    },
    visitCascade$1: function(node) {
      var oldCascadeReceiver, receiver;
      oldCascadeReceiver = this._currentCascadeReceiver;
      node.expression.accept$1(0, this);
      receiver = this._currentCascadeReceiver;
      this._currentCascadeReceiver = oldCascadeReceiver;
      return receiver;
    },
    lookupThis$0: function() {
      var t1, result;
      t1 = $.Node_hashCount + 1 & 1073741823;
      $.Node_hashCount = t1;
      result = new D.This2(null, null, null, t1, null);
      t1 = t1 + 1 & 1073741823;
      $.Node_hashCount = t1;
      this.add$1(0, new D.LetPrim(result, null, t1, null));
      return result;
    },
    visitAssert$1: function(node) {
      return this.giveup$2(node, "Assert");
    },
    visitNamedArgument$1: function(node) {
      return node.expression.accept$1(0, this);
    },
    continueWithExpression$1: function(build) {
      var t1, v, k, expression;
      t1 = $.Node_hashCount + 1 & 1073741823;
      $.Node_hashCount = t1;
      v = new D.Parameter1(null, null, null, t1, null);
      v.hint = null;
      t1 = $.Node_hashCount + 1 & 1073741823;
      $.Node_hashCount = t1;
      k = new D.Continuation([v], null, false, null, t1, null);
      expression = build.call$1(k);
      t1 = $.Node_hashCount + 1 & 1073741823;
      $.Node_hashCount = t1;
      this.add$1(0, new D.LetCont(k, expression, t1, null));
      return v;
    },
    translateClosureCall$3: function(receiver, closureSelector, $arguments) {
      return this.continueWithExpression$1(new K.IrBuilder_translateClosureCall_closure(receiver, Z.Selector_Selector(closureSelector.kind, "call", closureSelector.library, closureSelector.argumentCount, closureSelector.namedArguments), $arguments.nodes.mapToList$2$growable(this.get$visit(), false)));
    },
    visitClosureSend$1: function(node) {
      var element, closureTarget, t1, closureSelector;
      this.elements.toString;
      element = node.get$_secret_tree_element$_element();
      if (element == null)
        closureTarget = node.selector.accept$1(0, this);
      else if (this.closureLocals.usedFromClosure.contains$1(0, element)) {
        t1 = $.Node_hashCount + 1 & 1073741823;
        $.Node_hashCount = t1;
        closureTarget = new D.GetClosureVariable(element, null, null, null, t1, null);
        t1 = t1 + 1 & 1073741823;
        $.Node_hashCount = t1;
        this.add$1(0, new D.LetPrim(closureTarget, null, t1, null));
      } else
        closureTarget = this.environment.lookup$1(element);
      t1 = this.elements._selectors;
      closureSelector = t1 != null ? t1.$index(0, node) : null;
      return this.translateClosureCall$3(closureTarget, closureSelector, node.argumentsNode);
    },
    visitReceiver$1: function(node) {
      if (node == null)
        return this.lookupThis$0();
      if (node.isSuper$0())
        return;
      return node.accept$1(0, this);
    },
    createDynamicInvoke$5: function(node, selector, receiver, k, $arguments) {
      var t1, t2, t3;
      t1 = node.receiver;
      if (t1 != null && t1.isSuper$0()) {
        t1 = D.Reference$(k);
        t2 = D._referenceList($arguments);
        t3 = $.Node_hashCount + 1 & 1073741823;
        $.Node_hashCount = t3;
        t3 = new D.InvokeSuperMethod(selector, t1, t2, t3, null);
        t3.InvokeSuperMethod$3(selector, k, $arguments);
        t1 = t3;
      } else
        t1 = D.InvokeMethod$(receiver, selector, k, $arguments);
      return t1;
    },
    visitDynamicSend$1: function(node) {
      var t1, selector, receiver, $arguments;
      t1 = this.elements._selectors;
      selector = t1 != null ? t1.$index(0, node) : null;
      receiver = this.visitReceiver$1(node.receiver);
      $arguments = H.setRuntimeTypeInfo([], [D.Primitive]);
      for (t1 = node.argumentsNode.nodes, t1.toString, t1 = H.setRuntimeTypeInfo(new E.LinkIterator(null, t1), [H.getTypeArgumentByIndex(t1, 0)]); t1.moveNext$0();)
        $arguments.push(J.accept$1$x(t1._util_implementation$_current, this));
      return this.continueWithExpression$1(new K.IrBuilder_visitDynamicSend_closure(this, node, selector, receiver, $arguments));
    },
    translateGetter$2: function(node, selector) {
      var t1, element, t2, result, index, $arguments;
      t1 = {};
      this.elements.toString;
      element = node.get$_secret_tree_element$_element();
      t1.receiver_0 = null;
      t2 = element != null;
      if (t2 && element.get$isConst()) {
        result = this.translateConstant$1(node);
        index = null;
      } else if (this.closureLocals.usedFromClosure.contains$1(0, element)) {
        t2 = $.Node_hashCount + 1 & 1073741823;
        $.Node_hashCount = t2;
        result = new D.GetClosureVariable(element, null, null, null, t2, null);
        t2 = t2 + 1 & 1073741823;
        $.Node_hashCount = t2;
        this.add$1(0, new D.LetPrim(result, null, t2, null));
        index = null;
      } else if (O.Elements_isLocal(element)) {
        result = this.environment.lookup$1(element);
        index = null;
      } else {
        if (t2)
          if (!O.Elements_isInstanceField(element))
            if (!O.Elements_isInstanceMethod(element))
              if (!(selector.kind === C.SelectorKind_index_4 && selector.argumentCount === 1)) {
                t2 = node.receiver;
                t2 = t2 != null && t2.isSuper$0();
              } else
                t2 = true;
            else
              t2 = true;
          else
            t2 = true;
        else
          t2 = true;
        if (t2) {
          t1.receiver_0 = this.visitReceiver$1(node.receiver);
          $arguments = H.setRuntimeTypeInfo([], [D.Primitive]);
          if (selector.kind === C.SelectorKind_index_4 && selector.argumentCount === 1) {
            t2 = node.argumentsNode.nodes;
            index = J.accept$1$x(t2.get$head(t2), this);
            $arguments.push(index);
          } else
            index = null;
          result = this.continueWithExpression$1(new K.IrBuilder_translateGetter_closure(t1, this, node, selector, $arguments));
        } else {
          if (element.get$kind(element) === C.ElementKind_field_1 || element.get$isGetter() || element.get$isErroneous() || element.kind === C.ElementKind_setter_0)
            result = this.continueWithExpression$1(new K.IrBuilder_translateGetter_closure0(selector, element));
          else if (O.Elements_isStaticOrTopLevelFunction(element))
            result = this.translateConstant$1(node);
          else
            throw H.wrapException("Unexpected SendSet getter: " + node.toString$0(0) + ", " + element.toString$0(0));
          index = null;
        }
      }
      return new K._GetterElements(result, index, t1.receiver_0);
    },
    visitGetterSend$1: function(node) {
      var t1 = this.elements._selectors;
      return this.translateGetter$2(node, t1 != null ? t1.$index(0, node) : null).result;
    },
    buildNegation$1: function(condition) {
      var t1, resultParameter, joinContinuation, thenContinuation, elseContinuation, t2, t3, trueConstant, falseConstant, t4, t5, t6, t7, t8;
      t1 = $.Node_hashCount + 1 & 1073741823;
      $.Node_hashCount = t1;
      resultParameter = new D.Parameter1(null, null, null, t1, null);
      resultParameter.hint = null;
      t1 = $.Node_hashCount + 1 & 1073741823;
      $.Node_hashCount = t1;
      joinContinuation = new D.Continuation([resultParameter], null, false, null, t1, null);
      t1 = t1 + 1 & 1073741823;
      $.Node_hashCount = t1;
      thenContinuation = new D.Continuation([], null, false, null, t1, null);
      t1 = t1 + 1 & 1073741823;
      $.Node_hashCount = t1;
      elseContinuation = new D.Continuation([], null, false, null, t1, null);
      t1 = this.compiler;
      t2 = t1.backend.get$constantSystem().createBool$1(true);
      t3 = $.Node_hashCount + 1 & 1073741823;
      $.Node_hashCount = t3;
      trueConstant = new D.Constant1(new M.PrimitiveConstExp(t2), t2, null, null, null, t3, null);
      t1 = t1.backend.get$constantSystem().createBool$1(false);
      t3 = $.Node_hashCount + 1 & 1073741823;
      $.Node_hashCount = t3;
      falseConstant = new D.Constant1(new M.PrimitiveConstExp(t1), t1, null, null, null, t3, null);
      t3 = t3 + 1 & 1073741823;
      $.Node_hashCount = t3;
      t3 = new D.LetPrim(falseConstant, null, t3, null);
      t3.body = D.InvokeContinuation$(joinContinuation, [falseConstant], false);
      thenContinuation.body = t3;
      t3 = $.Node_hashCount + 1 & 1073741823;
      $.Node_hashCount = t3;
      t3 = new D.LetPrim(trueConstant, null, t3, null);
      t3.body = D.InvokeContinuation$(joinContinuation, [trueConstant], false);
      elseContinuation.body = t3;
      t3 = D.Reference$(condition);
      t1 = $.Node_hashCount + 1 & 1073741823;
      $.Node_hashCount = t1;
      t2 = D.Reference$(thenContinuation);
      t4 = D.Reference$(elseContinuation);
      t5 = $.Node_hashCount + 1 & 1073741823;
      $.Node_hashCount = t5;
      t6 = t5 + 1 & 1073741823;
      $.Node_hashCount = t6;
      t7 = t6 + 1 & 1073741823;
      $.Node_hashCount = t7;
      t8 = t7 + 1 & 1073741823;
      $.Node_hashCount = t8;
      this.add$1(0, new D.LetCont(joinContinuation, new D.LetCont(thenContinuation, new D.LetCont(elseContinuation, new D.Branch(new D.IsTrue(t3, t1, null), t2, t4, t5, null), t6, null), t7, null), t8, null));
      return resultParameter;
    },
    visitOperatorSend$1: function(node) {
      var op, t1, leftValue, rightBuilder, rightValue, emptyBuilder, rightTrueBuilder, rightFalseBuilder, t2, t3, leftBool, rightTrue, rightFalse, jumps, joinContinuation, leftTrueContinuation, leftFalseContinuation, rightTrueContinuation, rightFalseContinuation, t4, t5, t6, t7, t8, type, check;
      op = node.selector;
      t1 = op.get$token();
      if (Y.isUserDefinableOperator(t1.get$value(t1)))
        return this.visitDynamicSend$1(node);
      t1 = op.get$token();
      if (t1.get$value(t1) !== "&&") {
        t1 = op.get$token();
        t1 = t1.get$value(t1) === "||";
      } else
        t1 = true;
      if (t1) {
        t1 = node.argumentsNode.nodes;
        t1 = t1.get$head(t1);
        leftValue = node.receiver.accept$1(0, this);
        rightBuilder = K.IrBuilder$delimited(this);
        rightValue = J.accept$1$x(t1, rightBuilder);
        emptyBuilder = K.IrBuilder$delimited(this);
        rightTrueBuilder = K.IrBuilder$delimited(rightBuilder);
        rightFalseBuilder = K.IrBuilder$delimited(rightBuilder);
        t1 = this.compiler;
        t2 = t1.backend.get$constantSystem();
        t3 = op.get$token();
        t3 = t2.createBool$1(t3.get$value(t3) === "||");
        t2 = $.Node_hashCount + 1 & 1073741823;
        $.Node_hashCount = t2;
        leftBool = new D.Constant1(new M.PrimitiveConstExp(t3), t3, null, null, null, t2, null);
        t2 = t1.backend.get$constantSystem().createBool$1(true);
        t3 = $.Node_hashCount + 1 & 1073741823;
        $.Node_hashCount = t3;
        rightTrue = new D.Constant1(new M.PrimitiveConstExp(t2), t2, null, null, null, t3, null);
        t1 = t1.backend.get$constantSystem().createBool$1(false);
        t3 = $.Node_hashCount + 1 & 1073741823;
        $.Node_hashCount = t3;
        rightFalse = new D.Constant1(new M.PrimitiveConstExp(t1), t1, null, null, null, t3, null);
        t3 = t3 + 1 & 1073741823;
        $.Node_hashCount = t3;
        emptyBuilder.add$1(0, new D.LetPrim(leftBool, null, t3, null));
        t3 = $.Node_hashCount + 1 & 1073741823;
        $.Node_hashCount = t3;
        rightTrueBuilder.add$1(0, new D.LetPrim(rightTrue, null, t3, null));
        t3 = $.Node_hashCount + 1 & 1073741823;
        $.Node_hashCount = t3;
        rightFalseBuilder.add$1(0, new D.LetPrim(rightFalse, null, t3, null));
        emptyBuilder.environment.extend$2(null, leftBool);
        rightTrueBuilder.environment.extend$2(null, rightTrue);
        rightFalseBuilder.environment.extend$2(null, rightFalse);
        jumps = new K.JumpCollector(null, H.setRuntimeTypeInfo([], [D.InvokeContinuation]), H.setRuntimeTypeInfo([], [K.Environment]));
        jumps.addJump$1(emptyBuilder);
        jumps.addJump$1(rightTrueBuilder);
        jumps.addJump$1(rightFalseBuilder);
        joinContinuation = this.createJoin$2(this.environment.index2variable.length + 1, jumps);
        t3 = $.Node_hashCount + 1 & 1073741823;
        $.Node_hashCount = t3;
        leftTrueContinuation = new D.Continuation([], null, false, null, t3, null);
        t3 = t3 + 1 & 1073741823;
        $.Node_hashCount = t3;
        leftFalseContinuation = new D.Continuation([], null, false, null, t3, null);
        t3 = t3 + 1 & 1073741823;
        $.Node_hashCount = t3;
        rightTrueContinuation = new D.Continuation([], null, false, null, t3, null);
        t3 = t3 + 1 & 1073741823;
        $.Node_hashCount = t3;
        rightFalseContinuation = new D.Continuation([], null, false, null, t3, null);
        rightTrueContinuation.body = rightTrueBuilder.root;
        rightFalseContinuation.body = rightFalseBuilder.root;
        t3 = D.Reference$(rightValue);
        t1 = $.Node_hashCount + 1 & 1073741823;
        $.Node_hashCount = t1;
        t2 = D.Reference$(rightTrueContinuation);
        t4 = D.Reference$(rightFalseContinuation);
        t5 = $.Node_hashCount + 1 & 1073741823;
        $.Node_hashCount = t5;
        t6 = t5 + 1 & 1073741823;
        $.Node_hashCount = t6;
        t7 = t6 + 1 & 1073741823;
        $.Node_hashCount = t7;
        rightBuilder.add$1(0, new D.LetCont(rightTrueContinuation, new D.LetCont(rightFalseContinuation, new D.Branch(new D.IsTrue(t3, t1, null), t2, t4, t5, null), t6, null), t7, null));
        t1 = op.get$token();
        if (t1.get$value(t1) === "&&") {
          leftTrueContinuation.body = rightBuilder.root;
          leftFalseContinuation.body = emptyBuilder.root;
        } else {
          leftTrueContinuation.body = emptyBuilder.root;
          leftFalseContinuation.body = rightBuilder.root;
        }
        t1 = D.Reference$(leftValue);
        t2 = $.Node_hashCount + 1 & 1073741823;
        $.Node_hashCount = t2;
        t3 = D.Reference$(leftTrueContinuation);
        t4 = D.Reference$(leftFalseContinuation);
        t5 = $.Node_hashCount + 1 & 1073741823;
        $.Node_hashCount = t5;
        t6 = t5 + 1 & 1073741823;
        $.Node_hashCount = t6;
        t7 = t6 + 1 & 1073741823;
        $.Node_hashCount = t7;
        t8 = t7 + 1 & 1073741823;
        $.Node_hashCount = t8;
        this.add$1(0, new D.LetCont(joinContinuation, new D.LetCont(leftTrueContinuation, new D.LetCont(leftFalseContinuation, new D.Branch(new D.IsTrue(t1, t2, null), t3, t4, t5, null), t6, null), t7, null), t8, null));
        return C.JSArray_methods.get$last(joinContinuation.parameters);
      }
      t1 = op.get$token();
      if (t1.get$value(t1) === "!")
        return this.buildNegation$1(node.receiver.accept$1(0, this));
      t1 = op.get$token();
      if (t1.get$value(t1) === "!=")
        return this.buildNegation$1(this.visitDynamicSend$1(node));
      t1 = op.get$token();
      if (t1.get$value(t1) !== "is") {
        t1 = op.get$token();
        t1 = t1.get$value(t1) === "as";
      } else
        t1 = true;
      if (t1) {
        t1 = this.elements;
        t2 = node.get$typeAnnotationFromIsCheckOrCast();
        t1 = t1._types;
        type = t1 != null ? t1.$index(0, t2) : null;
        check = this.continueWithExpression$1(new K.IrBuilder_visitOperatorSend_closure(op, type, node.receiver.accept$1(0, this)));
        if (!!op.$isOperator) {
          t1 = op.asOperator$0().token;
          t1 = t1.get$value(t1) === "is";
        } else
          t1 = false;
        if (t1) {
          t1 = node.argumentsNode.nodes;
          t1 = t1.get$head(t1).asSend$0() != null;
        } else
          t1 = false;
        return t1 ? this.buildNegation$1(check) : check;
      }
    },
    visitStaticSend$1: function(node) {
      var element, t1, selector;
      this.elements.toString;
      element = node.get$_secret_tree_element$_element();
      if (element.isForeign$1(this.compiler))
        return this.giveup$2(node, "StaticSend: foreign");
      t1 = this.elements._selectors;
      selector = t1 != null ? t1.$index(0, node) : null;
      return this.continueWithExpression$1(new K.IrBuilder_visitStaticSend_closure(element, selector, node.argumentsNode.nodes.mapToList$2$growable(this.get$visit(), false)));
    },
    visitSuperSend$1: function(node) {
      if (node.argumentsNode == null)
        return this.visitGetterSend$1(node);
      else
        return this.visitDynamicSend$1(node);
    },
    visitTypePrefixSend$1: function(node) {
      this.compiler.internalError$2(node, "visitTypePrefixSend should not be called.");
    },
    visitTypeLiteralSend$1: function(node) {
      var t1, type, t2, prim;
      if (node.argumentsNode != null)
        return this.giveup$2(node, "Type literal invoked as function");
      t1 = this.elements._types;
      type = t1 != null ? t1.$index(0, node) : null;
      if (!!J.getInterceptor(type).$isTypeVariableType) {
        t1 = type.element;
        t2 = $.Node_hashCount + 1 & 1073741823;
        $.Node_hashCount = t2;
        prim = new D.ReifyTypeVar0(t1, null, null, null, t2, null);
        t2 = t2 + 1 & 1073741823;
        $.Node_hashCount = t2;
        this.add$1(0, new D.LetPrim(prim, null, t2, null));
        return prim;
      } else
        return this.translateConstant$1(node);
    },
    visitSendSet$1: function(node) {
      var t1, element, op, t2, selector, operatorSelector, getterSelector, t3, t4, t5, assignArg, index, originalValue, getterResult, arg, valueToStore, k, invoke, $arguments;
      t1 = {};
      this.elements.toString;
      element = node.get$_secret_tree_element$_element();
      op = node.assignmentOperator;
      t1.receiver_0 = null;
      t1.valueToStore_1 = null;
      t2 = this.elements._selectors;
      selector = t2 != null ? t2.$index(0, node) : null;
      t2 = this.elements._selectors;
      operatorSelector = t2 != null ? t2.$index(0, op) : null;
      t2 = this.elements._selectors;
      getterSelector = t2 != null ? t2.$index(0, node.selector) : null;
      t2 = J.getInterceptor$x(selector);
      t3 = t2.get$kind(selector) === C.SelectorKind_index_4 && selector.get$argumentCount() === 2;
      t4 = node.argumentsNode;
      if (t3) {
        t3 = t4.nodes;
        t5 = t3.get$tail();
        assignArg = t5.get$head(t5);
      } else {
        t3 = t4.nodes;
        assignArg = t3.get$head(t3);
      }
      t5 = op.token;
      if (t5.get$value(t5) === "=") {
        if (t2.get$kind(selector) === C.SelectorKind_index_4 && selector.get$argumentCount() === 2) {
          t1.receiver_0 = this.visitReceiver$1(node.receiver);
          index = J.accept$1$x(t3.get$head(t3), this);
        } else {
          if (element == null || O.Elements_isInstanceField(element))
            t1.receiver_0 = this.visitReceiver$1(node.receiver);
          index = null;
        }
        t1.valueToStore_1 = J.accept$1$x(assignArg, this);
        originalValue = null;
      } else {
        getterResult = this.translateGetter$2(node, getterSelector);
        index = getterResult.index;
        t1.receiver_0 = getterResult.receiver;
        originalValue = getterResult.result;
        if (C.JSArray_methods.contains$1(C.List_p2F, t5.get$value(t5))) {
          t2 = this.compiler.backend.get$constantSystem().createInt$1(1);
          t3 = $.Node_hashCount + 1 & 1073741823;
          $.Node_hashCount = t3;
          arg = new D.Constant1(new M.PrimitiveConstExp(t2), t2, null, null, null, t3, null);
          t3 = t3 + 1 & 1073741823;
          $.Node_hashCount = t3;
          this.add$1(0, new D.LetPrim(arg, null, t3, null));
        } else
          arg = J.accept$1$x(assignArg, this);
        t2 = $.Node_hashCount + 1 & 1073741823;
        $.Node_hashCount = t2;
        valueToStore = new D.Parameter1(null, null, null, t2, null);
        valueToStore.hint = null;
        t1.valueToStore_1 = valueToStore;
        t2 = $.Node_hashCount + 1 & 1073741823;
        $.Node_hashCount = t2;
        k = new D.Continuation([valueToStore], null, false, null, t2, null);
        invoke = D.InvokeMethod$(originalValue, operatorSelector, k, [arg]);
        t2 = $.Node_hashCount + 1 & 1073741823;
        $.Node_hashCount = t2;
        this.add$1(0, new D.LetCont(k, invoke, t2, null));
      }
      if (this.closureLocals.usedFromClosure.contains$1(0, element)) {
        t2 = D.Reference$(t1.valueToStore_1);
        t3 = $.Node_hashCount + 1 & 1073741823;
        $.Node_hashCount = t3;
        this.add$1(0, new D.SetClosureVariable(element, t2, null, false, t3, null));
      } else if (O.Elements_isLocal(element)) {
        t2 = t1.valueToStore_1;
        if (t2.hint == null)
          t2.hint = element;
        t3 = this.environment;
        t5 = t3.index2value;
        t3 = t3.variable2index.$index(0, element);
        if (t3 >>> 0 !== t3 || t3 >= t5.length)
          return H.ioore(t5, t3);
        t5[t3] = t2;
      } else {
        t2 = node.receiver;
        t2 = !(t2 != null && t2.isSuper$0()) && element != null && element.get$isErroneous() || O.Elements_isStaticOrTopLevel(element);
        t3 = this.elements;
        if (t2) {
          t2 = t3._selectors;
          selector = t2 != null ? t2.$index(0, node) : null;
          this.continueWithExpression$1(new K.IrBuilder_visitSendSet_closure(t1, element, selector));
        } else {
          t2 = t3._selectors;
          selector = t2 != null ? t2.$index(0, node) : null;
          t2 = J.get$kind$x(selector) === C.SelectorKind_index_4 && selector.get$argumentCount() === 2;
          t3 = t1.valueToStore_1;
          $arguments = t2 ? [index, t3] : [t3];
          this.continueWithExpression$1(new K.IrBuilder_visitSendSet_closure0(t1, this, node, selector, $arguments));
        }
      }
      if (!!J.getInterceptor(t4).$isPostfix0)
        return originalValue;
      else
        return t1.valueToStore_1;
    },
    visitNewExpression$1: function(node) {
      var t1, element, t2, selector, type;
      if (node.get$isConst())
        return this.translateConstant$1(node);
      t1 = node.send;
      this.elements.toString;
      element = t1.get$_secret_tree_element$_element();
      t2 = this.elements._selectors;
      selector = t2 != null ? t2.$index(0, t1) : null;
      t2 = this.elements._types;
      type = t2 != null ? t2.$index(0, node) : null;
      return this.continueWithExpression$1(new K.IrBuilder_visitNewExpression_closure(element, selector, type, t1.argumentsNode.nodes.mapToList$2$growable(this.get$visit(), false)));
    },
    visitStringJuxtaposition$1: function(node) {
      return this.continueWithExpression$1(new K.IrBuilder_visitStringJuxtaposition_closure(node.first.accept$1(0, this), node.second.accept$1(0, this)));
    },
    visitStringInterpolation$1: function(node) {
      var $arguments, t1, it, part;
      $arguments = [];
      $arguments.push(this.translateConstant$1(node.string));
      t1 = node.parts.nodes;
      t1.toString;
      it = H.setRuntimeTypeInfo(new E.LinkIterator(null, t1), [H.getTypeArgumentByIndex(t1, 0)]);
      for (; it.moveNext$0();) {
        part = it._util_implementation$_current;
        $arguments.push(J.accept$1$x(part.get$expression(), this));
        $arguments.push(this.translateConstant$1(part.get$string()));
      }
      return this.continueWithExpression$1(new K.IrBuilder_visitStringInterpolation_closure($arguments));
    },
    translateConstant$2: function(node, value) {
      var t1, t2, primitive;
      value = this.compiler.backend.get$constantCompilerTask().compileNode$2(node, this.elements);
      t1 = this.constantBuilder;
      t1.toString;
      t1 = node.accept$1(0, t1);
      t2 = $.Node_hashCount + 1 & 1073741823;
      $.Node_hashCount = t2;
      primitive = new D.Constant1(t1, value, null, null, null, t2, null);
      t2 = t2 + 1 & 1073741823;
      $.Node_hashCount = t2;
      this.add$1(0, new D.LetPrim(primitive, null, t2, null));
      return primitive;
    },
    translateConstant$1: function(node) {
      return this.translateConstant$2(node, null);
    },
    makeSubFunction$1: function(node) {
      var t1 = K.IrBuilder$(this.elements, this.compiler, this.sourceFile);
      this.elements.toString;
      return t1.buildFunctionInternal$1(node.get$_secret_tree_element$_element());
    },
    visitFunctionExpression$1: function(node) {
      var inner, t1, prim;
      this.elements.toString;
      node.get$_secret_tree_element$_element();
      inner = this.makeSubFunction$1(node);
      t1 = $.Node_hashCount + 1 & 1073741823;
      $.Node_hashCount = t1;
      prim = new D.CreateFunction(inner, null, null, null, t1, null);
      t1 = t1 + 1 & 1073741823;
      $.Node_hashCount = t1;
      this.add$1(0, new D.LetPrim(prim, null, t1, null));
      return prim;
    },
    visitFunctionDeclaration$1: function(node) {
      var t1, element, inner, t2, prim;
      t1 = node.$function;
      this.elements.toString;
      element = t1.get$_secret_tree_element$_element();
      inner = this.makeSubFunction$1(t1);
      t1 = this.closureLocals.usedFromClosure.contains$1(0, element);
      t2 = $.Node_hashCount;
      if (t1) {
        t1 = t2 + 1 & 1073741823;
        $.Node_hashCount = t1;
        this.add$1(0, new D.DeclareFunction(element, inner, null, t1, null));
      } else {
        t1 = t2 + 1 & 1073741823;
        $.Node_hashCount = t1;
        prim = new D.CreateFunction(inner, null, null, null, t1, null);
        t1 = t1 + 1 & 1073741823;
        $.Node_hashCount = t1;
        this.add$1(0, new D.LetPrim(prim, null, t1, null));
        this.environment.extend$2(element, prim);
        if (prim.hint == null)
          prim.hint = element;
      }
      return;
    },
    giveup$2: function(node, reason) {
      throw H.wrapException("IrNode builder aborted");
    },
    giveup$1: function(node) {
      return this.giveup$2(node, null);
    },
    nullIfGiveup$1: function(action) {
      var e, t1, exception;
      try {
        t1 = action.call$0();
        return t1;
      } catch (exception) {
        t1 = H.unwrapException(exception);
        e = t1;
        if (J.$eq(e, "IrNode builder aborted"))
          return;
        throw exception;
      }

    },
    internalError$2$node: function(reason, node) {
      this.giveup$1(node);
    },
    IrBuilder$recursive$1: function($parent) {
      var t1, t2, element, t3, parameter;
      for (t1 = $parent.environment.index2variable, t1 = H.setRuntimeTypeInfo(new H.ListIterator(t1, t1.length, 0, null), [H.getTypeArgumentByIndex(t1, 0)]), t2 = this.parameters; t1.moveNext$0();) {
        element = t1.__internal$_current;
        t3 = $.Node_hashCount + 1 & 1073741823;
        $.Node_hashCount = t3;
        parameter = new D.Parameter1(null, null, null, t3, null);
        parameter.hint = element;
        t2.push(parameter);
        this.environment.extend$2(element, parameter);
      }
    },
    IrBuilder$3: function(elements, compiler, sourceFile) {
      var t1 = this.compiler;
      this.constantBuilder = new K.ConstExpBuilder(this, this.elements, t1.backend.get$constantSystem(), t1.backend.get$constantCompilerTask());
    },
    $asResolvedVisitor: function() {
      return [D.Primitive];
    },
    $asVisitor: function() {
      return [D.Primitive];
    },
    static: {"^": "IrBuilder_ABORT_IRNODE_BUILDER", IrBuilder$: function(elements, compiler, sourceFile) {
        var t1, t2;
        t1 = $.Node_hashCount + 1 & 1073741823;
        $.Node_hashCount = t1;
        t1 = new D.Parameter1(null, null, null, t1, null);
        t1.hint = null;
        t1 = H.setRuntimeTypeInfo([t1], [D.Parameter1]);
        t2 = $.Node_hashCount + 1 & 1073741823;
        $.Node_hashCount = t2;
        t2 = new K.IrBuilder(sourceFile, new D.Continuation(t1, null, false, null, t2, null), H.setRuntimeTypeInfo([], [D.Parameter1]), null, null, K.Environment$empty(), H.setRuntimeTypeInfo([], [K.JumpCollector]), null, H.setRuntimeTypeInfo([], [M.ConstDeclaration]), null, new K.DetectClosureVariables(elements, null, P.LinkedHashSet_LinkedHashSet(null, null, null, O.Local), P.LinkedHashSet_LinkedHashSet(null, null, null, O.FunctionElement)), null, compiler, elements);
        t2.IrBuilder$3(elements, compiler, sourceFile);
        return t2;
      }, IrBuilder$delimited: function($parent) {
        var t1, t2;
        t1 = H.setRuntimeTypeInfo([], [D.Parameter1]);
        t2 = $parent.environment;
        return new K.IrBuilder($parent.sourceFile, $parent.returnContinuation, t1, null, null, new K.Environment(t2.variable2index, P.List_List$from(t2.index2variable, true, O.Element), P.List_List$from(t2.index2value, true, D.Primitive)), $parent.breakCollectors, $parent.constantBuilder, $parent.localConstants, $parent.currentFunction, $parent.closureLocals, null, $parent.compiler, $parent.elements);
      }, IrBuilder$recursive: function($parent) {
        var t1 = new K.IrBuilder($parent.sourceFile, $parent.returnContinuation, H.setRuntimeTypeInfo([], [D.Parameter1]), null, null, K.Environment$empty(), $parent.breakCollectors, $parent.constantBuilder, $parent.localConstants, $parent.currentFunction, $parent.closureLocals, null, $parent.compiler, $parent.elements);
        t1.IrBuilder$recursive$1($parent);
        return t1;
      }}
  },
  IrBuilder_buildFunction_closure: {
    "^": "Closure:23;this_0,functionElement_1",
    call$0: function() {
      return this.this_0.buildFunctionInternal$1(this.functionElement_1);
    },
    $isFunction: true
  },
  IrBuilder_buildFunctionInternal_closure: {
    "^": "Closure:50;this_0",
    call$1: function(parameterElement) {
      var t1, parameter, t2, t3;
      t1 = $.Node_hashCount + 1 & 1073741823;
      $.Node_hashCount = t1;
      parameter = new D.Parameter1(null, null, null, t1, null);
      parameter.hint = parameterElement;
      t1 = this.this_0;
      t1.parameters.push(parameter);
      if (t1.closureLocals.usedFromClosure.contains$1(0, parameterElement)) {
        t2 = D.Reference$(parameter);
        t3 = $.Node_hashCount + 1 & 1073741823;
        $.Node_hashCount = t3;
        t1.add$1(0, new D.SetClosureVariable(parameterElement, t2, null, false, t3, null));
      } else
        t1.environment.extend$2(parameterElement, parameter);
    },
    $isFunction: true
  },
  IrBuilder_buildFunctionInternal_closure0: {
    "^": "Closure:50;this_1,defaults_2",
    call$1: function(element) {
      var t1, t2, t3;
      t1 = this.defaults_2;
      t2 = this.this_1;
      if (element.get$initializer() != null) {
        t2 = t2.constantBuilder;
        t3 = element.get$initializer();
        t2.toString;
        t1.push(t3.accept$1(0, t2));
      } else
        t1.push(new M.PrimitiveConstExp(t2.compiler.backend.get$constantSystem().createNull$0()));
    },
    $isFunction: true
  },
  IrBuilder_createJoin_closure: {
    "^": "Closure:13;box_0,first_1,second_2",
    call$1: function(i) {
      var t1, candidate;
      t1 = this.first_1.index2value;
      if (i >= t1.length)
        return H.ioore(t1, i);
      candidate = t1[i];
      t1 = this.second_2.index2value;
      if (i >= t1.length)
        return H.ioore(t1, i);
      if (J.$eq(t1[i], candidate))
        return candidate;
      else {
        ++this.box_0.parameterCount_0;
        return;
      }
    },
    $isFunction: true
  },
  IrBuilder_visitLiteralMap_closure: {
    "^": "Closure:97;this_0,keys_1,values_2",
    call$1: function(node) {
      var t1, t2;
      t1 = this.this_0;
      t2 = J.getInterceptor$x(node);
      this.keys_1.push(J.accept$1$x(t2.get$key(node), t1));
      this.values_2.push(t2.get$value(node).accept$1(0, t1));
    },
    $isFunction: true
  },
  IrBuilder_translateClosureCall_closure: {
    "^": "Closure:13;receiver_0,namedCallSelector_1,args_2",
    call$1: function(k) {
      return D.InvokeMethod$(this.receiver_0, this.namedCallSelector_1, k, this.args_2);
    },
    $isFunction: true
  },
  IrBuilder_visitDynamicSend_closure: {
    "^": "Closure:13;this_0,node_1,selector_2,receiver_3,arguments_4",
    call$1: function(k) {
      return this.this_0.createDynamicInvoke$5(this.node_1, this.selector_2, this.receiver_3, k, this.arguments_4);
    },
    $isFunction: true
  },
  IrBuilder_translateGetter_closure: {
    "^": "Closure:13;box_0,this_1,node_2,selector_3,arguments_4",
    call$1: function(k) {
      return this.this_1.createDynamicInvoke$5(this.node_2, this.selector_3, this.box_0.receiver_0, k, this.arguments_4);
    },
    $isFunction: true
  },
  IrBuilder_translateGetter_closure0: {
    "^": "Closure:13;selector_5,element_6",
    call$1: function(k) {
      return D.InvokeStatic$(this.element_6, this.selector_5, k, []);
    },
    $isFunction: true
  },
  IrBuilder_visitOperatorSend_closure: {
    "^": "Closure:13;op_0,type_1,receiver_2",
    call$1: function(k) {
      var t1, t2, t3, t4, t5, t6;
      t1 = this.op_0.token;
      t1 = t1.get$value(t1);
      t2 = this.receiver_2;
      t3 = this.type_1;
      t4 = D.Reference$(t2);
      t5 = D.Reference$(k);
      t6 = $.Node_hashCount + 1 & 1073741823;
      $.Node_hashCount = t6;
      t6 = new D.TypeOperator0(t4, t3, t5, t1, t6, null);
      t6.TypeOperator$4(t1, t2, t3, k);
      return t6;
    },
    $isFunction: true
  },
  IrBuilder_visitStaticSend_closure: {
    "^": "Closure:13;element_0,selector_1,arguments_2",
    call$1: function(k) {
      return D.InvokeStatic$(this.element_0, this.selector_1, k, this.arguments_2);
    },
    $isFunction: true
  },
  IrBuilder_visitSendSet_closure: {
    "^": "Closure:13;box_0,element_1,selector_2",
    call$1: function(k) {
      return D.InvokeStatic$(this.element_1, this.selector_2, k, [this.box_0.valueToStore_1]);
    },
    $isFunction: true
  },
  IrBuilder_visitSendSet_closure0: {
    "^": "Closure:13;box_0,this_3,node_4,selector_5,arguments_6",
    call$1: function(k) {
      return this.this_3.createDynamicInvoke$5(this.node_4, this.selector_5, this.box_0.receiver_0, k, this.arguments_6);
    },
    $isFunction: true
  },
  IrBuilder_visitNewExpression_closure: {
    "^": "Closure:13;element_0,selector_1,type_2,args_3",
    call$1: function(k) {
      var t1, t2, t3, t4, t5, t6, t7;
      t1 = this.type_2;
      t2 = this.element_0;
      t3 = this.selector_1;
      t4 = this.args_3;
      t5 = D.Reference$(k);
      t6 = D._referenceList(t4);
      t7 = $.Node_hashCount + 1 & 1073741823;
      $.Node_hashCount = t7;
      t7 = new D.InvokeConstructor(t1, t2, t5, t6, t3, t7, null);
      t7.InvokeConstructor$5(t1, t2, t3, k, t4);
      return t7;
    },
    $isFunction: true
  },
  IrBuilder_visitStringJuxtaposition_closure: {
    "^": "Closure:13;first_0,second_1",
    call$1: function(k) {
      var t1, t2, t3;
      t1 = D.Reference$(k);
      t2 = D._referenceList([this.first_0, this.second_1]);
      t3 = $.Node_hashCount + 1 & 1073741823;
      $.Node_hashCount = t3;
      return new D.ConcatenateStrings(t1, t2, t3, null);
    },
    $isFunction: true
  },
  IrBuilder_visitStringInterpolation_closure: {
    "^": "Closure:13;arguments_0",
    call$1: function(k) {
      var t1, t2, t3;
      t1 = D.Reference$(k);
      t2 = D._referenceList(this.arguments_0);
      t3 = $.Node_hashCount + 1 & 1073741823;
      $.Node_hashCount = t3;
      return new D.ConcatenateStrings(t1, t2, t3, null);
    },
    $isFunction: true
  },
  ConstExpBuilder: {
    "^": "Visitor;parent>,elements>,constantSystem,constantCompiler",
    isSmallConstant$1: function(constant) {
      var t1, string;
      t1 = J.getInterceptor(constant);
      if (!!t1.$isBoolConstant || !!t1.$isNullConstant)
        return true;
      if (!!t1.$isIntConstant) {
        t1 = constant.value;
        if (typeof t1 !== "number")
          return H.iae(t1);
        return -10 < t1 && t1 < 100;
      }
      if (!!t1.$isDoubleConstant) {
        t1 = constant.value;
        return t1 === 0 || t1 === 1;
      }
      if (!!t1.$isStringConstant) {
        string = constant.value;
        t1 = J.getInterceptor(string);
        if (!!t1.$isLiteralDartString)
          return string.string.length < 4;
        if (!!t1.$isSourceBasedDartString)
          return t1.get$length(string) < 4;
      }
      return false;
    },
    visit$1: [function(node) {
      return J.accept$1$x(node, this);
    }, "call$1", "get$visit", 2, 0, 98],
    visitStringJuxtaposition$1: function(node) {
      return new M.ConcatenateConstExp([node.first.accept$1(0, this), node.second.accept$1(0, this)]);
    },
    visitStringInterpolation$1: function(node) {
      var $arguments, t1, t2, it, part;
      $arguments = H.setRuntimeTypeInfo([], [M.ConstExp]);
      t1 = this.constantSystem;
      $arguments.push(new M.PrimitiveConstExp(t1.createString$1(node.string.dartString)));
      t2 = node.parts.nodes;
      t2.toString;
      it = H.setRuntimeTypeInfo(new E.LinkIterator(null, t2), [H.getTypeArgumentByIndex(t2, 0)]);
      for (; it.moveNext$0();) {
        part = it._util_implementation$_current;
        $arguments.push(J.accept$1$x(part.get$expression(), this));
        $arguments.push(new M.PrimitiveConstExp(t1.createString$1(part.get$string().dartString)));
      }
      return new M.ConcatenateConstExp($arguments);
    },
    visitNewExpression$1: function(node) {
      var t1, t2, element, t3, selector, type;
      t1 = this.elements;
      t2 = node.send;
      t1.toString;
      element = t2.get$_secret_tree_element$_element();
      if (element == null || element.get$isErroneous())
        throw H.wrapException(this.parent.giveup$2(node, "const NewExpression: unresolved constructor"));
      t3 = t1._selectors;
      selector = t3 != null ? t3.$index(0, t2) : null;
      t1 = t1._types;
      type = t1 != null ? t1.$index(0, node) : null;
      return new M.ConstructorConstExp(type, element, selector, t2.argumentsNode.nodes.mapToList$2$growable(this.get$visit(), false));
    },
    visitNamedArgument$1: function(node) {
      return node.expression.accept$1(0, this);
    },
    visitSend$1: function(node) {
      var t1, element, value, type;
      t1 = this.elements;
      t1.toString;
      element = node.get$_secret_tree_element$_element();
      if (!!J.getInterceptor(node.selector).$isOperator)
        return new M.PrimitiveConstExp(this.constantCompiler.compileNode$2(node, t1));
      if (O.Elements_isStaticOrTopLevelFunction(element))
        return new M.FunctionConstExp(element);
      if (O.Elements_isLocal(element) || O.Elements_isStaticOrTopLevelField(element)) {
        value = this.constantCompiler.getConstantForVariable$1(element);
        if (this.isSmallConstant$1(value))
          return new M.PrimitiveConstExp(value);
        else
          return new M.VariableConstExp(element);
      }
      t1 = t1._types;
      type = t1 != null ? t1.$index(0, node) : null;
      if (type != null) {
        t1 = new M.TypeConstExp(type);
        t1.TypeConstExp$1(type);
        return t1;
      }
      throw H.wrapException("Unexpected constant Send: " + node.toString$0(0));
    },
    visitParenthesizedExpression$1: function(node) {
      return node.expression.accept$1(0, this);
    },
    visitLiteralList$1: function(node) {
      var values, t1, type;
      values = node.get$elements(node).nodes.mapToList$1(this.get$visit());
      t1 = this.elements._types;
      type = t1 != null ? t1.$index(0, node) : null;
      return new M.ListConstExp(type, values);
    },
    visitLiteralMap$1: function(node) {
      var keys, values, t1, type;
      keys = H.setRuntimeTypeInfo([], [M.ConstExp]);
      values = H.setRuntimeTypeInfo([], [M.ConstExp]);
      node.entries.nodes.forEach$1(0, new K.ConstExpBuilder_visitLiteralMap_closure(this, keys, values));
      t1 = this.elements._types;
      type = t1 != null ? t1.$index(0, node) : null;
      return new M.MapConstExp(type, keys, values);
    },
    visitLiteralSymbol$1: function(node) {
      return new M.SymbolConstExp(node.get$slowNameString());
    },
    visitLiteralInt$1: function(node) {
      return new M.PrimitiveConstExp(this.constantSystem.createInt$1(node.get$value(node)));
    },
    visitLiteralDouble$1: function(node) {
      return new M.PrimitiveConstExp(this.constantSystem.createDouble$1(node.get$value(node)));
    },
    visitLiteralString$1: function(node) {
      return new M.PrimitiveConstExp(this.constantSystem.createString$1(node.dartString));
    },
    visitLiteralBool$1: function(node) {
      return new M.PrimitiveConstExp(this.constantSystem.createBool$1(node.get$value(node)));
    },
    visitLiteralNull$1: function(node) {
      return new M.PrimitiveConstExp(this.constantSystem.createNull$0());
    },
    visitConditional$1: function(node) {
      return (this.constantCompiler.compileNode$2(node.condition, this.elements).get$isTrue() ? node.thenExpression : node.elseExpression).accept$1(0, this);
    },
    visitNode$1: function(node) {
      throw H.wrapException("Unexpected constant: " + node.toString$0(0));
    },
    $asVisitor: function() {
      return [M.ConstExp];
    }
  },
  ConstExpBuilder_visitLiteralMap_closure: {
    "^": "Closure:97;this_0,keys_1,values_2",
    call$1: function(node) {
      var t1, t2;
      t1 = this.this_0;
      t2 = J.getInterceptor$x(node);
      this.keys_1.push(J.accept$1$x(t2.get$key(node), t1));
      this.values_2.push(t2.get$value(node).accept$1(0, t1));
    },
    $isFunction: true
  },
  DetectClosureVariables: {
    "^": "Visitor;elements>,currentFunction,usedFromClosure,recursiveFunctions",
    visitNode$1: function(node) {
      node.visitChildren$1(this);
    },
    visitSend$1: function(node) {
      var element, t1, t2;
      this.elements.toString;
      element = node.get$_secret_tree_element$_element();
      if (O.Elements_isLocal(element))
        if (!element.get$isConst()) {
          t1 = element.get$enclosingElement();
          t2 = this.currentFunction;
          t2 = t1 == null ? t2 != null : t1 !== t2;
          t1 = t2;
        } else
          t1 = false;
      else
        t1 = false;
      if (t1)
        this.usedFromClosure.add$1(0, element);
      node.visitChildren$1(this);
    },
    visitFunctionExpression$1: function(node) {
      var oldFunction = this.currentFunction;
      this.elements.toString;
      this.currentFunction = node.get$_secret_tree_element$_element();
      node.body.accept$1(0, this);
      this.currentFunction = oldFunction;
    },
    $asVisitor: function() {
      return [null];
    }
  }
}],
["dart2js.ir_nodes", "package:compiler/implementation/cps_ir/cps_ir_nodes.dart", , D, {
  "^": "",
  _referenceList: function(definitions) {
    return H.setRuntimeTypeInfo(new H.MappedListIterable(definitions, new D._referenceList_closure()), [null, null]).toList$0(0);
  },
  Node4: {
    "^": "Object;hashCode>,parent*"
  },
  Expression3: {
    "^": "Node4;",
    plug$1: function(expr) {
      return H.throwExpression("impossible");
    }
  },
  Definition: {
    "^": "Node4;firstRef<",
    get$hasExactlyOneUse: function() {
      var t1 = this.firstRef;
      return t1 != null && t1.next == null;
    },
    substituteFor$1: function(other) {
      var current, current0, t1;
      if (other.get$firstRef() == null)
        return;
      current = other.firstRef;
      do {
        current.definition = this;
        current0 = current.next;
        if (current0 != null) {
          current = current0;
          continue;
        } else
          break;
      } while (true);
      t1 = this.firstRef;
      current.next = t1;
      if (t1 != null)
        t1.previous = current;
      this.firstRef = other.firstRef;
    }
  },
  Primitive: {
    "^": "Definition;hint<,registerIndex<",
    $isPrimitive: true
  },
  Reference: {
    "^": "Object;definition<,previous,next<,parent*",
    unlink$0: function() {
      var t1, t2;
      t1 = this.previous;
      t2 = this.next;
      if (t1 == null)
        this.definition.firstRef = t2;
      else
        t1.next = t2;
      t2 = this.next;
      if (t2 != null)
        t2.previous = t1;
    },
    Reference$1: function(definition) {
      var t1, t2;
      t1 = this.definition;
      t2 = t1.firstRef;
      this.next = t2;
      if (t2 != null)
        t2.previous = this;
      t1.firstRef = this;
    },
    static: {Reference$: function(definition) {
        var t1 = new D.Reference(definition, null, null, null);
        t1.Reference$1(definition);
        return t1;
      }}
  },
  LetPrim: {
    "^": "Expression3;primitive<,body*,hashCode,parent",
    plug$1: function(expr) {
      this.body = expr;
      return expr;
    },
    accept$1: function(_, visitor) {
      return visitor.visitLetPrim$1(this);
    },
    $isLetPrim: true
  },
  LetCont: {
    "^": "Expression3;continuation<,body*,hashCode,parent",
    plug$1: function(expr) {
      this.continuation.body = expr;
      return expr;
    },
    accept$1: function(_, visitor) {
      return visitor.visitLetCont$1(this);
    },
    $isLetCont: true
  },
  InvokeStatic0: {
    "^": "Expression3;target>,selector<,continuation<,arguments<,hashCode,parent",
    accept$1: function(_, visitor) {
      return visitor.visitInvokeStatic$1(this);
    },
    InvokeStatic$4: function(target, selector, cont, args) {
    },
    static: {InvokeStatic$: function(target, selector, cont, args) {
        var t1, t2, t3;
        t1 = D.Reference$(cont);
        t2 = D._referenceList(args);
        t3 = $.Node_hashCount + 1 & 1073741823;
        $.Node_hashCount = t3;
        t3 = new D.InvokeStatic0(target, selector, t1, t2, t3, null);
        t3.InvokeStatic$4(target, selector, cont, args);
        return t3;
      }}
  },
  InvokeMethod0: {
    "^": "Expression3;receiver<,selector<,continuation<,arguments<,hashCode,parent",
    accept$1: function(_, visitor) {
      return visitor.visitInvokeMethod$1(this);
    },
    InvokeMethod$4: function(receiver, selector, cont, args) {
    },
    static: {InvokeMethod$: function(receiver, selector, cont, args) {
        var t1, t2, t3, t4;
        t1 = D.Reference$(receiver);
        t2 = D.Reference$(cont);
        t3 = D._referenceList(args);
        t4 = $.Node_hashCount + 1 & 1073741823;
        $.Node_hashCount = t4;
        t4 = new D.InvokeMethod0(t1, selector, t2, t3, t4, null);
        t4.InvokeMethod$4(receiver, selector, cont, args);
        return t4;
      }}
  },
  InvokeSuperMethod: {
    "^": "Expression3;selector<,continuation<,arguments<,hashCode,parent",
    accept$1: function(_, visitor) {
      return visitor.visitInvokeSuperMethod$1(this);
    },
    InvokeSuperMethod$3: function(selector, cont, args) {
    }
  },
  InvokeConstructor: {
    "^": "Expression3;type>,target>,continuation<,arguments<,selector<,hashCode,parent",
    accept$1: function(_, visitor) {
      return visitor.visitInvokeConstructor$1(this);
    },
    InvokeConstructor$5: function(type, target, selector, cont, args) {
    }
  },
  TypeOperator0: {
    "^": "Expression3;receiver<,type>,continuation<,operator>,hashCode,parent",
    accept$1: function(_, visitor) {
      return visitor.visitTypeOperator$1(this);
    },
    TypeOperator$4: function(operator, receiver, type, cont) {
    }
  },
  ConcatenateStrings: {
    "^": "Expression3;continuation<,arguments<,hashCode,parent",
    accept$1: function(_, visitor) {
      return visitor.visitConcatenateStrings$1(this);
    }
  },
  GetClosureVariable: {
    "^": "Primitive;variable<,hint,registerIndex,firstRef,hashCode,parent",
    accept$1: function(_, visitor) {
      return visitor.visitGetClosureVariable$1(this);
    }
  },
  SetClosureVariable: {
    "^": "Expression3;variable<,value>,body*,isDeclaration<,hashCode,parent",
    accept$1: function(_, visitor) {
      return visitor.visitSetClosureVariable$1(this);
    },
    plug$1: function(expr) {
      this.body = expr;
      return expr;
    }
  },
  DeclareFunction: {
    "^": "Expression3;variable<,definition<,body*,hashCode,parent",
    plug$1: function(expr) {
      this.body = expr;
      return expr;
    },
    accept$1: function(_, visitor) {
      return visitor.visitDeclareFunction$1(this);
    }
  },
  InvokeContinuation: {
    "^": "Expression3;continuation<,arguments<,isRecursive<,hashCode,parent",
    accept$1: function(_, visitor) {
      return visitor.visitInvokeContinuation$1(this);
    },
    InvokeContinuation$3$recursive: function(cont, args, recursive) {
      if (recursive)
        cont.isRecursive = true;
    },
    $isInvokeContinuation: true,
    static: {InvokeContinuation$: function(cont, args, recursive) {
        var t1, t2, t3;
        t1 = D.Reference$(cont);
        t2 = D._referenceList(args);
        t3 = $.Node_hashCount + 1 & 1073741823;
        $.Node_hashCount = t3;
        t3 = new D.InvokeContinuation(t1, t2, recursive, t3, null);
        t3.InvokeContinuation$3$recursive(cont, args, recursive);
        return t3;
      }}
  },
  Condition: {
    "^": "Node4;"
  },
  IsTrue: {
    "^": "Condition;value>,hashCode,parent",
    accept$1: function(_, visitor) {
      return visitor.visitIsTrue$1(this);
    }
  },
  Branch: {
    "^": "Expression3;condition,trueContinuation,falseContinuation,hashCode,parent",
    accept$1: function(_, visitor) {
      return visitor.visitBranch$1(this);
    }
  },
  Constant1: {
    "^": "Primitive;expression<,value>,hint,registerIndex,firstRef,hashCode,parent",
    accept$1: function(_, visitor) {
      return visitor.visitConstant$1(this);
    }
  },
  This2: {
    "^": "Primitive;hint,registerIndex,firstRef,hashCode,parent",
    accept$1: function(_, visitor) {
      return visitor.visitThis$1(this);
    }
  },
  ReifyTypeVar0: {
    "^": "Primitive;typeVariable,hint,registerIndex,firstRef,hashCode,parent",
    get$constant: function() {
      return;
    },
    accept$1: function(_, visitor) {
      return visitor.visitReifyTypeVar$1(this);
    }
  },
  LiteralList1: {
    "^": "Primitive;type>,values>,hint,registerIndex,firstRef,hashCode,parent",
    accept$1: function(_, visitor) {
      return visitor.visitLiteralList$1(this);
    }
  },
  LiteralMap1: {
    "^": "Primitive;type>,keys<,values>,hint,registerIndex,firstRef,hashCode,parent",
    accept$1: function(_, visitor) {
      return visitor.visitLiteralMap$1(this);
    }
  },
  CreateFunction: {
    "^": "Primitive;definition<,hint,registerIndex,firstRef,hashCode,parent",
    accept$1: function(_, visitor) {
      return visitor.visitCreateFunction$1(this);
    }
  },
  Parameter1: {
    "^": "Primitive;hint,registerIndex,firstRef,hashCode,parent",
    accept$1: function(_, visitor) {
      return visitor.visitParameter$1(this);
    },
    $isParameter1: true
  },
  Continuation: {
    "^": "Definition;parameters<,body*,isRecursive<,firstRef,hashCode,parent",
    accept$1: function(_, visitor) {
      return visitor.visitContinuation$1(this);
    },
    $isContinuation: true
  },
  FunctionDefinition: {
    "^": "Node4;element<,returnContinuation,parameters<,body*,localConstants,defaultParameterValues,hashCode,parent",
    accept$1: function(_, visitor) {
      return visitor.visitFunctionDefinition$1(this);
    },
    $isFunctionDefinition: true
  },
  _referenceList_closure: {
    "^": "Closure:13;",
    call$1: function(e) {
      return D.Reference$(e);
    },
    $isFunction: true
  },
  Visitor1: {
    "^": "Object;",
    visitNode$1: function(node) {
      return;
    },
    visitPrimitive$1: function(node) {
      return this.visitNode$1(node);
    },
    visitFunctionDefinition$1: function(node) {
      return this.visitNode$1(node);
    },
    visitLetPrim$1: function(node) {
      return this.visitNode$1(node);
    },
    visitLetCont$1: function(node) {
      return this.visitNode$1(node);
    },
    visitInvokeStatic$1: function(node) {
      return this.visitNode$1(node);
    },
    visitInvokeContinuation$1: function(node) {
      return this.visitNode$1(node);
    },
    visitInvokeMethod$1: function(node) {
      return this.visitNode$1(node);
    },
    visitInvokeSuperMethod$1: function(node) {
      return this.visitNode$1(node);
    },
    visitInvokeConstructor$1: function(node) {
      return this.visitNode$1(node);
    },
    visitConcatenateStrings$1: function(node) {
      return this.visitNode$1(node);
    },
    visitBranch$1: function(node) {
      return this.visitNode$1(node);
    },
    visitTypeOperator$1: function(node) {
      return this.visitNode$1(node);
    },
    visitSetClosureVariable$1: function(node) {
      return this.visitNode$1(node);
    },
    visitDeclareFunction$1: function(node) {
      return this.visitNode$1(node);
    },
    visitLiteralList$1: function(node) {
      return this.visitNode$1(node);
    },
    visitLiteralMap$1: function(node) {
      return this.visitNode$1(node);
    },
    visitConstant$1: function(node) {
      return this.visitNode$1(node);
    },
    visitThis$1: function(node) {
      return this.visitNode$1(node);
    },
    visitReifyTypeVar$1: function(node) {
      return this.visitNode$1(node);
    },
    visitCreateFunction$1: function(node) {
      return this.visitNode$1(node);
    },
    visitGetClosureVariable$1: function(node) {
      return this.visitNode$1(node);
    },
    visitParameter$1: function(node) {
      return this.visitNode$1(node);
    },
    visitContinuation$1: function(node) {
      return this.visitNode$1(node);
    },
    visitIsTrue$1: function(node) {
      return this.visitNode$1(node);
    }
  },
  RecursiveVisitor0: {
    "^": "Visitor1;",
    visitNode$1: function(node) {
      throw H.wrapException("RecursiveVisitor is stale, add missing visit overrides");
    },
    processReference$1: [function(ref) {
    }, "call$1", "get$processReference", 2, 0, 99],
    processFunctionDefinition$1: function(node) {
    },
    visitFunctionDefinition$1: function(node) {
      this.processFunctionDefinition$1(node);
      H.IterableMixinWorkaround_forEach(node.parameters, this.get$visitParameter());
      node.body.accept$1(0, this);
    },
    processLetPrim$1: function(node) {
    },
    visitLetPrim$1: function(node) {
      this.processLetPrim$1(node);
      node.primitive.accept$1(0, this);
      node.body.accept$1(0, this);
    },
    processLetCont$1: function(node) {
    },
    visitLetCont$1: function(node) {
      this.processLetCont$1(node);
      node.continuation.accept$1(0, this);
      node.body.accept$1(0, this);
    },
    processInvokeStatic$1: function(node) {
    },
    visitInvokeStatic$1: function(node) {
      this.processInvokeStatic$1(node);
      this.processReference$1(node.get$continuation());
      H.IterableMixinWorkaround_forEach(node.arguments, this.get$processReference());
    },
    processInvokeContinuation$1: function(node) {
    },
    visitInvokeContinuation$1: function(node) {
      var t1, t2;
      this.processInvokeContinuation$1(node);
      this.processReference$1(node.continuation);
      t1 = node.arguments;
      t2 = this.get$processReference();
      t1.toString;
      H.IterableMixinWorkaround_forEach(t1, t2);
    },
    processInvokeMethod$1: function(node) {
    },
    visitInvokeMethod$1: function(node) {
      this.processInvokeMethod$1(node);
      this.processReference$1(node.receiver);
      this.processReference$1(node.continuation);
      H.IterableMixinWorkaround_forEach(node.arguments, this.get$processReference());
    },
    processInvokeSuperMethod$1: function(node) {
    },
    visitInvokeSuperMethod$1: function(node) {
      this.processInvokeSuperMethod$1(node);
      this.processReference$1(node.continuation);
      H.IterableMixinWorkaround_forEach(node.arguments, this.get$processReference());
    },
    processInvokeConstructor$1: function(node) {
    },
    visitInvokeConstructor$1: function(node) {
      this.processInvokeConstructor$1(node);
      this.processReference$1(node.continuation);
      H.IterableMixinWorkaround_forEach(node.arguments, this.get$processReference());
    },
    processConcatenateStrings$1: function(node) {
    },
    visitConcatenateStrings$1: function(node) {
      this.processConcatenateStrings$1(node);
      this.processReference$1(node.continuation);
      H.IterableMixinWorkaround_forEach(node.arguments, this.get$processReference());
    },
    processBranch$1: function(node) {
    },
    visitBranch$1: function(node) {
      this.processBranch$1(node);
      this.processReference$1(node.trueContinuation);
      this.processReference$1(node.falseContinuation);
      node.condition.accept$1(0, this);
    },
    processTypeOperator$1: function(node) {
    },
    visitTypeOperator$1: function(node) {
      this.processTypeOperator$1(node);
      this.processReference$1(node.continuation);
      this.processReference$1(node.receiver);
    },
    processSetClosureVariable$1: function(node) {
    },
    visitSetClosureVariable$1: function(node) {
      this.processSetClosureVariable$1(node);
      this.processReference$1(node.value);
      node.body.accept$1(0, this);
    },
    processDeclareFunction$1: function(node) {
    },
    visitDeclareFunction$1: function(node) {
      this.processDeclareFunction$1(node);
      node.definition.accept$1(0, this);
      node.body.accept$1(0, this);
    },
    processLiteralList$1: function(node) {
    },
    visitLiteralList$1: function(node) {
      this.processLiteralList$1(node);
      H.IterableMixinWorkaround_forEach(node.get$values(node), this.get$processReference());
    },
    processLiteralMap$1: function(node) {
    },
    visitLiteralMap$1: function(node) {
      var t1, t2, i;
      this.processLiteralMap$1(node);
      for (t1 = node.keys, t2 = node.values, i = 0; i < t1.length; ++i) {
        this.processReference$1(t1[i]);
        if (i >= t2.length)
          return H.ioore(t2, i);
        this.processReference$1(t2[i]);
      }
    },
    visitConstant$1: function(node) {
      return;
    },
    visitThis$1: function(node) {
      return;
    },
    visitReifyTypeVar$1: function(node) {
      return;
    },
    processCreateFunction$1: function(node) {
    },
    visitCreateFunction$1: function(node) {
      this.processCreateFunction$1(node);
      node.definition.accept$1(0, this);
    },
    visitGetClosureVariable$1: function(node) {
      return;
    },
    visitParameter$1: [function(node) {
      return;
    }, "call$1", "get$visitParameter", 2, 0, 100],
    processContinuation$1: function(node) {
    },
    visitContinuation$1: function(node) {
      this.processContinuation$1(node);
      H.IterableMixinWorkaround_forEach(node.parameters, this.get$visitParameter());
      node.body.accept$1(0, this);
    },
    processIsTrue$1: function(node) {
    },
    visitIsTrue$1: function(node) {
      this.processIsTrue$1(node);
      this.processReference$1(node.value);
    },
    $asVisitor1: function() {
      return [null];
    }
  },
  RegisterArray: {
    "^": "Object;nextIndex,freeStack",
    makeIndex$0: function() {
      var t1, t2;
      t1 = this.freeStack;
      t2 = t1.length;
      if (t2 === 0)
        return this.nextIndex++;
      else {
        if (0 >= t2)
          return H.ioore(t1, 0);
        return t1.pop();
      }
    }
  },
  RegisterAllocator: {
    "^": "Visitor1;elementRegisters",
    getRegisterArray$1: function(element) {
      var t1, registers;
      t1 = this.elementRegisters;
      registers = t1.$index(0, element);
      if (registers == null) {
        registers = new D.RegisterArray(0, H.setRuntimeTypeInfo([], [P.$int]));
        t1.$indexSet(0, element, registers);
      }
      return registers;
    },
    allocate$1: [function(primitive) {
      if (primitive.get$registerIndex() == null)
        primitive.registerIndex = this.getRegisterArray$1(primitive.hint).makeIndex$0();
    }, "call$1", "get$allocate", 2, 0, 101],
    release$1: function(primitive) {
      if (primitive.get$hint() == null)
        return;
      if (primitive.registerIndex != null)
        this.getRegisterArray$1(primitive.hint).freeStack.push(primitive.registerIndex);
    },
    visitReference$1: [function(reference) {
      var t1 = reference.get$definition();
      if (t1.get$registerIndex() == null)
        t1.registerIndex = this.getRegisterArray$1(t1.hint).makeIndex$0();
    }, "call$1", "get$visitReference", 2, 0, 102],
    visitFunctionDefinition$1: function(node) {
      node.body.accept$1(0, this);
      H.IterableMixinWorkaround_forEach(node.parameters, this.get$allocate());
      this.elementRegisters.clear$0(0);
    },
    visitLetPrim$1: function(node) {
      var t1;
      node.body.accept$1(0, this);
      t1 = node.primitive;
      this.release$1(t1);
      t1.accept$1(0, this);
    },
    visitLetCont$1: function(node) {
      node.continuation.accept$1(0, this);
      node.body.accept$1(0, this);
    },
    visitInvokeStatic$1: function(node) {
      H.IterableMixinWorkaround_forEach(node.get$arguments(), this.get$visitReference());
    },
    visitInvokeContinuation$1: function(node) {
      var t1, t2;
      t1 = node.arguments;
      t2 = this.get$visitReference();
      t1.toString;
      H.IterableMixinWorkaround_forEach(t1, t2);
    },
    visitInvokeMethod$1: function(node) {
      this.allocate$1(node.receiver.definition);
      H.IterableMixinWorkaround_forEach(node.arguments, this.get$visitReference());
    },
    visitInvokeSuperMethod$1: function(node) {
      H.IterableMixinWorkaround_forEach(node.arguments, this.get$visitReference());
    },
    visitInvokeConstructor$1: function(node) {
      H.IterableMixinWorkaround_forEach(node.arguments, this.get$visitReference());
    },
    visitConcatenateStrings$1: function(node) {
      H.IterableMixinWorkaround_forEach(node.arguments, this.get$visitReference());
    },
    visitBranch$1: function(node) {
      node.condition.accept$1(0, this);
    },
    visitLiteralList$1: function(node) {
      H.IterableMixinWorkaround_forEach(node.get$values(node), this.get$visitReference());
    },
    visitLiteralMap$1: function(node) {
      var t1, t2, i, t3;
      for (t1 = node.keys, t2 = node.values, i = 0; i < t1.length; ++i) {
        t3 = t1[i].get$definition();
        if (t3.get$registerIndex() == null)
          t3.registerIndex = this.getRegisterArray$1(t3.hint).makeIndex$0();
        if (i >= t2.length)
          return H.ioore(t2, i);
        t3 = t2[i].get$definition();
        if (t3.get$registerIndex() == null)
          t3.registerIndex = this.getRegisterArray$1(t3.hint).makeIndex$0();
      }
    },
    visitTypeOperator$1: function(node) {
      this.allocate$1(node.receiver.definition);
    },
    visitConstant$1: function(node) {
    },
    visitThis$1: function(node) {
    },
    visitReifyTypeVar$1: function(node) {
    },
    visitCreateFunction$1: function(node) {
      node.definition.accept$1(0, new D.RegisterAllocator(P.LinkedHashMap_LinkedHashMap$_empty(O.Element, D.RegisterArray)));
    },
    visitGetClosureVariable$1: function(node) {
    },
    visitSetClosureVariable$1: function(node) {
      node.body.accept$1(0, this);
      this.allocate$1(node.value.definition);
    },
    visitDeclareFunction$1: function(node) {
      node.definition.accept$1(0, new D.RegisterAllocator(P.LinkedHashMap_LinkedHashMap$_empty(O.Element, D.RegisterArray)));
      node.body.accept$1(0, this);
    },
    visitParameter$1: function(node) {
      throw H.wrapException("Parameters should not be visited by RegisterAllocator");
    },
    visitContinuation$1: function(node) {
      var t1, i;
      node.body.accept$1(0, this);
      for (t1 = node.parameters, i = t1.length - 1; i >= 0; --i) {
        if (i >= t1.length)
          return H.ioore(t1, i);
        this.release$1(t1[i]);
      }
    },
    visitIsTrue$1: function(node) {
      this.allocate$1(node.value.definition);
    },
    $asVisitor1: function() {
      return [null];
    }
  }
}],
["dart2js.ir_tracer", "package:compiler/implementation/cps_ir/cps_ir_tracer.dart", , S, {
  "^": "",
  IRTracer: {
    "^": "TracerUtil;output<,names,tracer$TracerUtil$_ind",
    traceGraph$2: function($name, graph) {
      this.tag$2(0, "cfg", new S.IRTracer_traceGraph_closure(this, $name, graph));
    },
    visitFunctionDefinition$1: function(f) {
      var t1, t2, builder;
      t1 = new S.Names0(P.LinkedHashMap_LinkedHashMap$_empty(null, null), P.LinkedHashMap_LinkedHashMap$_literal(["r", 0, "B", 0, "v", 0, "x", 0], null, null));
      this.names = t1;
      t2 = P.LinkedHashMap_LinkedHashMap$_empty(D.Continuation, S.Block3);
      builder = new S.BlockCollector0(null, t2, null, t1);
      f.accept$1(0, builder);
      this.printNode$1(builder.entry);
      for (t1 = t2.get$values(t2), t1 = H.setRuntimeTypeInfo(new H.MappedIterator(null, J.get$iterator$ax(t1._iterable), t1._f), [H.getTypeArgumentByIndex(t1, 0), H.getTypeArgumentByIndex(t1, 1)]); t1.moveNext$0();)
        this.printNode$1(t1.__internal$_current);
      this.names = null;
    },
    countUses$1: function(definition) {
      var ref, count;
      ref = definition.firstRef;
      for (count = 0; ref != null;) {
        ++count;
        ref = ref.next;
      }
      return count;
    },
    printNode$1: function(block) {
      var t1, t2;
      t1 = this.tracer$TracerUtil$_ind;
      t2 = this.output;
      t2.add$1(0, t1.get$indentation());
      t2.add$1(0, "begin_block");
      t2.add$1(0, "\n");
      ++t1._indentLevel;
      new S.IRTracer_printNode_closure(this, block).call$0();
      --t1._indentLevel;
      t2.add$1(0, t1.get$indentation());
      t2.add$1(0, "end_block");
      t2.add$1(0, "\n");
    },
    printStmt$2: function(resultVar, contents) {
      var t1 = this.output;
      t1.add$1(0, this.tracer$TracerUtil$_ind.get$indentation());
      t1.add$1(0, "0 0 " + resultVar + " " + contents + " <|@\n");
    },
    visitLetPrim$1: function(node) {
      var t1, id;
      t1 = node.primitive;
      id = this.names.name$1(0, t1);
      this.printStmt$2(id, "LetPrim " + id + " = " + H.S(t1.accept$1(0, this)));
      node.body.accept$1(0, this);
    },
    visitLetCont$1: function(node) {
      node.body.accept$1(0, this);
    },
    visitInvokeStatic$1: function(node) {
      var dummy, callName, args, kont;
      dummy = this.names.name$1(0, node);
      callName = node.get$selector().name;
      args = H.setRuntimeTypeInfo(new H.MappedListIterable(node.get$arguments(), this.get$formatReference()), [null, null]).join$1(0, ", ");
      kont = this.formatReference$1(node.continuation);
      this.printStmt$2(dummy, "InvokeStatic " + H.S(callName) + " (" + args + ") " + kont);
    },
    visitInvokeMethod$1: function(node) {
      var dummy, receiver, callName, args, kont;
      dummy = this.names.name$1(0, node);
      receiver = this.formatReference$1(node.receiver);
      callName = node.selector.name;
      args = H.setRuntimeTypeInfo(new H.MappedListIterable(node.arguments, this.get$formatReference()), [null, null]).join$1(0, ", ");
      kont = this.formatReference$1(node.continuation);
      this.printStmt$2(dummy, "InvokeMethod " + receiver + " " + H.S(callName) + " (" + args + ") " + kont);
    },
    visitInvokeSuperMethod$1: function(node) {
      var dummy, callName, args, kont;
      dummy = this.names.name$1(0, node);
      callName = node.selector.name;
      args = H.setRuntimeTypeInfo(new H.MappedListIterable(node.arguments, this.get$formatReference()), [null, null]).join$1(0, ", ");
      kont = this.formatReference$1(node.continuation);
      this.printStmt$2(dummy, "InvokeSuperMethod " + H.S(callName) + " (" + args + ") " + kont);
    },
    visitInvokeConstructor$1: function(node) {
      var dummy, t1, t2, callName, args, kont;
      dummy = this.names.name$1(0, node);
      t1 = node.target;
      t2 = node.type;
      callName = J.get$isEmpty$asx(t1.get$name(t1)) ? J.toString$0(t2) : J.toString$0(t2) + "." + H.S(t1.name);
      args = H.setRuntimeTypeInfo(new H.MappedListIterable(node.arguments, this.get$formatReference()), [null, null]).join$1(0, ", ");
      kont = this.formatReference$1(node.continuation);
      this.printStmt$2(dummy, "InvokeConstructor " + H.S(callName) + " (" + args + ") " + kont);
    },
    visitConcatenateStrings$1: function(node) {
      var dummy, args, kont;
      dummy = this.names.name$1(0, node);
      args = H.setRuntimeTypeInfo(new H.MappedListIterable(node.arguments, this.get$formatReference()), [null, null]).join$1(0, ", ");
      kont = this.formatReference$1(node.continuation);
      this.printStmt$2(dummy, "ConcatenateStrings (" + args + ") " + kont);
    },
    visitLiteralList$1: function(node) {
      this.printStmt$2(this.names.name$1(0, node), "LiteralList (" + H.setRuntimeTypeInfo(new H.MappedListIterable(node.get$values(node), this.get$formatReference()), [null, null]).join$1(0, ", ") + ")");
    },
    visitLiteralMap$1: function(node) {
      var dummy, entries, t1, t2, i, key, value;
      dummy = this.names.name$1(0, node);
      entries = H.setRuntimeTypeInfo([], [P.String]);
      for (t1 = node.values, t2 = node.keys, i = 0; i < t1.length; ++i) {
        if (i >= t2.length)
          return H.ioore(t2, i);
        key = this.formatReference$1(t2[i]);
        if (i >= t1.length)
          return H.ioore(t1, i);
        value = this.formatReference$1(t1[i]);
        entries.push(key + ": " + value);
      }
      this.printStmt$2(dummy, "LiteralMap (" + C.JSArray_methods.join$1(entries, ", ") + ")");
    },
    visitTypeOperator$1: function(node) {
      var dummy, receiver;
      dummy = this.names.name$1(0, node);
      H.setRuntimeTypeInfo([], [P.String]);
      receiver = this.formatReference$1(node.receiver);
      this.printStmt$2(dummy, "TypeOperator (" + H.S(node.operator) + " " + receiver + " " + J.toString$0(node.type) + ")");
    },
    visitInvokeContinuation$1: function(node) {
      var dummy, kont, t1, t2, args;
      dummy = this.names.name$1(0, node);
      kont = this.formatReference$1(node.continuation);
      t1 = node.arguments;
      t2 = this.get$formatReference();
      t1.toString;
      args = H.setRuntimeTypeInfo(new H.MappedListIterable(t1, t2), [null, null]).join$1(0, ", ");
      this.printStmt$2(dummy, "InvokeContinuation " + kont + " (" + args + ")");
    },
    visitBranch$1: function(node) {
      var dummy, condition, trueCont, falseCont;
      dummy = this.names.name$1(0, node);
      condition = node.condition.accept$1(0, this);
      trueCont = this.formatReference$1(node.trueContinuation);
      falseCont = this.formatReference$1(node.falseContinuation);
      this.printStmt$2(dummy, "Branch " + H.S(condition) + " (" + trueCont + ", " + falseCont + ")");
    },
    visitSetClosureVariable$1: function(node) {
      var dummy, t1, variable, value;
      dummy = this.names.name$1(0, node);
      t1 = node.variable;
      variable = t1.get$name(t1);
      value = this.formatReference$1(node.value);
      this.printStmt$2(dummy, "SetClosureVariable " + H.S(variable) + " = " + value);
      node.body.accept$1(0, this);
    },
    visitDeclareFunction$1: function(node) {
      var t1 = node.variable;
      this.printStmt$2(this.names.name$1(0, node), "DeclareFunction " + H.S(t1.get$name(t1)));
      node.body.accept$1(0, this);
    },
    formatReference$1: [function(ref) {
      var target = ref.get$definition();
      if (!!J.getInterceptor(target).$isContinuation && target.body == null)
        return "return";
      else
        return this.names.name$1(0, ref.get$definition());
    }, "call$1", "get$formatReference", 2, 0, 103],
    visitConstant$1: function(node) {
      return "Constant " + J.toString$0(node.get$value(node));
    },
    visitParameter$1: function(node) {
      return "Parameter " + this.names.name$1(0, node);
    },
    visitContinuation$1: function(node) {
      return "Continuation " + this.names.name$1(0, node);
    },
    visitIsTrue$1: function(node) {
      return "IsTrue(" + this.names.name$1(0, node.value.definition) + ")";
    },
    visitThis$1: function(node) {
      return "This";
    },
    visitReifyTypeVar$1: function(node) {
      return "ReifyTypeVar " + H.S(node.typeVariable.name);
    },
    visitCreateFunction$1: function(node) {
      return "CreateFunction " + H.S(node.definition.element.name);
    },
    visitGetClosureVariable$1: function(node) {
      var t1 = node.variable;
      return "GetClosureVariable " + H.S(t1.get$name(t1));
    },
    visitPrimitive$1: function(p) {
    }
  },
  IRTracer_traceGraph_closure: {
    "^": "Closure:23;this_0,name_1,graph_2",
    call$0: function() {
      var t1, t2, t3;
      t1 = this.this_0;
      t2 = "name " + t1.formatPrty$1(this.name_1);
      t3 = t1.output;
      t3.add$1(0, t1.tracer$TracerUtil$_ind.get$indentation());
      t3.add$1(0, t2);
      t3.add$1(0, "\n");
      t1.visitFunctionDefinition$1(this.graph_2);
    },
    $isFunction: true
  },
  IRTracer_printNode_closure: {
    "^": "Closure:23;this_0,block_1",
    call$0: function() {
      var t1, t2, t3, t4, t5;
      t1 = this.this_0;
      t2 = this.block_1;
      t3 = "name " + t1.formatPrty$1(t2.name);
      t4 = t1.tracer$TracerUtil$_ind;
      t5 = t1.output;
      t5.add$1(0, t4.get$indentation());
      t5.add$1(0, t3);
      t5.add$1(0, "\n");
      t3 = "from_bci " + t1.formatPrty$1(-1);
      t5.add$1(0, t4.get$indentation());
      t5.add$1(0, t3);
      t5.add$1(0, "\n");
      t3 = "to_bci " + t1.formatPrty$1(-1);
      t5.add$1(0, t4.get$indentation());
      t5.add$1(0, t3);
      t5.add$1(0, "\n");
      t3 = "predecessors " + t1.formatPrty$1(H.setRuntimeTypeInfo(new H.MappedListIterable(t2.pred, new S.IRTracer_printNode__closure()), [null, null]));
      t5.add$1(0, t4.get$indentation());
      t5.add$1(0, t3);
      t5.add$1(0, "\n");
      t3 = "successors " + t1.formatPrty$1(H.setRuntimeTypeInfo(new H.MappedListIterable(t2.succ, new S.IRTracer_printNode__closure0()), [null, null]));
      t5.add$1(0, t4.get$indentation());
      t5.add$1(0, t3);
      t5.add$1(0, "\n");
      t5.add$1(0, t4.get$indentation());
      t5.add$1(0, "xhandlers");
      t5.add$1(0, "\n");
      t5.add$1(0, t4.get$indentation());
      t5.add$1(0, "flags");
      t5.add$1(0, "\n");
      t1.tag$2(0, "states", new S.IRTracer_printNode__closure1(t1));
      t1.tag$2(0, "HIR", new S.IRTracer_printNode__closure2(t1, t2));
    },
    $isFunction: true
  },
  IRTracer_printNode__closure: {
    "^": "Closure:13;",
    call$1: function(n) {
      return J.get$name$x(n);
    },
    $isFunction: true
  },
  IRTracer_printNode__closure0: {
    "^": "Closure:13;",
    call$1: function(n) {
      return J.get$name$x(n);
    },
    $isFunction: true
  },
  IRTracer_printNode__closure1: {
    "^": "Closure:23;this_2",
    call$0: function() {
      var t1 = this.this_2;
      t1.tag$2(0, "locals", new S.IRTracer_printNode___closure(t1));
    },
    $isFunction: true
  },
  IRTracer_printNode___closure: {
    "^": "Closure:23;this_3",
    call$0: function() {
      var t1, t2, t3, t4;
      t1 = this.this_3;
      t2 = "size " + t1.formatPrty$1(0);
      t3 = t1.tracer$TracerUtil$_ind;
      t4 = t1.output;
      t4.add$1(0, t3.get$indentation());
      t4.add$1(0, t2);
      t4.add$1(0, "\n");
      t1 = "method " + t1.formatPrty$1("None");
      t4.add$1(0, t3.get$indentation());
      t4.add$1(0, t1);
      t4.add$1(0, "\n");
    },
    $isFunction: true
  },
  IRTracer_printNode__closure2: {
    "^": "Closure:23;this_4,block_5",
    call$0: function() {
      var t1, t2, t3, t4, t5, param, $name, t6;
      for (t1 = this.block_5, t2 = t1.parameters, t2 = H.setRuntimeTypeInfo(new H.ListIterator(t2, t2.length, 0, null), [H.getTypeArgumentByIndex(t2, 0)]), t3 = this.this_4, t4 = t3.tracer$TracerUtil$_ind, t5 = t3.output; t2.moveNext$0();) {
        param = t2.__internal$_current;
        $name = t3.names.name$1(0, param);
        t6 = "Parameter " + $name + " [useCount=" + t3.countUses$1(param) + "]";
        t5.add$1(0, t4.get$indentation());
        t5.add$1(0, "0 0 " + $name + " " + t6 + " <|@\n");
      }
      t1.body.accept$1(0, t3);
    },
    $isFunction: true
  },
  Names0: {
    "^": "Object;names,counters",
    prefix$1: [function(x) {
      var t1 = J.getInterceptor(x);
      if (!!t1.$isParameter1)
        return "r";
      if (!!t1.$isContinuation || !!t1.$isFunctionDefinition)
        return "B";
      if (!!t1.$isPrimitive)
        return "v";
      return "x";
    }, "call$1", "get$prefix", 2, 0, 104],
    name$1: [function(_, x) {
      var t1, nam, pref, t2, id;
      t1 = this.names;
      nam = t1.$index(0, x);
      if (nam == null) {
        pref = this.prefix$1(x);
        t2 = this.counters;
        id = t2.$index(0, pref);
        if (typeof id !== "number")
          return id.$add();
        t2.$indexSet(0, pref, id + 1);
        nam = pref + id;
        t1.$indexSet(0, x, nam);
      }
      return nam;
    }, "call$1", "get$name", 2, 0, 104]
  },
  Block3: {
    "^": "Object;name>,parameters<,body>,succ,pred"
  },
  BlockCollector0: {
    "^": "Visitor1;entry,cont2block,current_block,names",
    getBlock$1: function(c) {
      var t1, block;
      t1 = this.cont2block;
      block = t1.$index(0, c);
      if (block == null) {
        block = new S.Block3(this.names.name$1(0, c), c.parameters, c.body, H.setRuntimeTypeInfo([], [S.Block3]), H.setRuntimeTypeInfo([], [S.Block3]));
        t1.$indexSet(0, c, block);
      }
      return block;
    },
    visitFunctionDefinition$1: function(f) {
      var t1 = new S.Block3(this.names.name$1(0, f), [], f.body, H.setRuntimeTypeInfo([], [S.Block3]), H.setRuntimeTypeInfo([], [S.Block3]));
      this.current_block = t1;
      this.entry = t1;
      f.body.accept$1(0, this);
    },
    visitLetPrim$1: function(exp) {
      exp.body.accept$1(0, this);
    },
    visitLetCont$1: function(exp) {
      exp.continuation.accept$1(0, this);
      exp.body.accept$1(0, this);
    },
    addEdgeToContinuation$1: function(continuation) {
      var target, t1, t2;
      target = continuation.definition;
      if (!!J.getInterceptor(target).$isContinuation && target.body != null) {
        t1 = this.current_block;
        t2 = this.getBlock$1(target);
        t1.succ.push(t2);
        t2.pred.push(t1);
      }
    },
    visitInvokeStatic$1: function(exp) {
      this.addEdgeToContinuation$1(exp.get$continuation());
    },
    visitInvokeMethod$1: function(exp) {
      this.addEdgeToContinuation$1(exp.continuation);
    },
    visitInvokeConstructor$1: function(exp) {
      this.addEdgeToContinuation$1(exp.continuation);
    },
    visitConcatenateStrings$1: function(exp) {
      this.addEdgeToContinuation$1(exp.continuation);
    },
    visitInvokeContinuation$1: function(exp) {
      this.addEdgeToContinuation$1(exp.continuation);
    },
    visitSetClosureVariable$1: function(exp) {
      exp.body.accept$1(0, this);
    },
    visitDeclareFunction$1: function(exp) {
      exp.body.accept$1(0, this);
    },
    visitBranch$1: function(exp) {
      var trueTarget, t1, t2, falseTarget;
      trueTarget = exp.trueContinuation.definition;
      if (trueTarget.get$body(trueTarget) != null) {
        t1 = this.current_block;
        t2 = this.getBlock$1(trueTarget);
        t1.succ.push(t2);
        t2.pred.push(t1);
      }
      falseTarget = exp.falseContinuation.definition;
      if (falseTarget.get$body(falseTarget) != null) {
        t1 = this.current_block;
        t2 = this.getBlock$1(falseTarget);
        t1.succ.push(t2);
        t2.pred.push(t1);
      }
    },
    visitContinuation$1: function(c) {
      var old_node = this.current_block;
      this.current_block = this.getBlock$1(c);
      c.body.accept$1(0, this);
      this.current_block = old_node;
    },
    $asVisitor1: function() {
      return [null];
    }
  }
}],
["dart2js.js_emitter", "package:compiler/implementation/js_emitter/js_emitter.dart", , K, {
  "^": "",
  computeMixinClass: [function(mixinApplication) {
    var mixin = mixinApplication.get$mixin();
    for (; mixin.get$isMixinApplication();)
      mixin = mixin.get$mixinType() != null ? mixin.mixinType.get$element() : null;
    return mixin;
  }, "call$1", "computeMixinClass$closure", 2, 0, 18],
  getReflectionDataParser: function(classesCollector, backend) {
    var namer, metadataField, reflectableField, defaultValuesField, methodsWithOptionalArgumentsField, unmangledNameIndex, t1, processStatics, addStubs, compiler, element, $name, tearOffAccessExpression, printer, tearOffAccessText, tearOffGlobalObject, tearOffGlobalObjectName, t2, t3, parser, statement, t4, tearOffCode, $init;
    namer = backend.namer;
    metadataField = "\"" + namer.metadataField + "\"";
    reflectableField = namer.reflectableField;
    defaultValuesField = namer.defaultValuesField;
    methodsWithOptionalArgumentsField = namer.methodsWithOptionalArgumentsField;
    unmangledNameIndex = backend.mustRetainMetadata ? " 3 * optionalParameterCount + 2 * requiredParameterCount + 3" : " 2 * optionalParameterCount + requiredParameterCount + 3";
    t1 = namer.classDescriptorProperty;
    processStatics = "    function processStatics(descriptor) {\n      for (var property in descriptor) {\n        if (!hasOwnProperty.call(descriptor, property)) continue;\n        if (property === \"" + t1 + "\") continue;\n        var element = descriptor[property];\n        var firstChar = property.substring(0, 1);\n        var previousProperty;\n        if (firstChar === \"+\") {\n          mangledGlobalNames[previousProperty] = property.substring(1);\n          var flag = descriptor[property];\n          if (flag > 0)\n            descriptor[previousProperty]." + reflectableField + " = flag;\n          if (element && element.length)\n            init.typeInformation[previousProperty] = element;\n        } else if (firstChar === \"@\") {\n          property = property.substring(1);\n          " + namer.currentIsolate + "[property][" + metadataField + "] = element;\n        } else if (firstChar === \"*\") {\n          globalObject[previousProperty]." + defaultValuesField + " = element;\n          var optionalMethods = descriptor." + methodsWithOptionalArgumentsField + ";\n          if (!optionalMethods) {\n            descriptor." + methodsWithOptionalArgumentsField + " = optionalMethods = {}\n          }\n          optionalMethods[property] = previousProperty;\n        } else if (typeof element === \"function\") {\n          globalObject[previousProperty = property] = element;\n          functions.push(property);\n          init.globalFunctions[property] = element;\n        } else if (element.constructor === Array) {\n          addStubs(globalObject, element, property,\n                   true, descriptor, functions);\n        } else {\n          previousProperty = property;\n          var newDesc = {};\n          var previousProp;\n          for (var prop in element) {\n            if (!hasOwnProperty.call(element, prop)) continue;\n            firstChar = prop.substring(0, 1);\n            if (prop === \"static\") {\n              processStatics(init.statics[property] = element[prop]);\n            } else if (firstChar === \"+\") {\n              mangledNames[previousProp] = prop.substring(1);\n              var flag = element[prop];\n              if (flag > 0)\n                element[previousProp]." + reflectableField + " = flag;\n            } else if (firstChar === \"@\" && prop !== \"@\") {\n              newDesc[prop.substring(1)][" + metadataField + "] = element[prop];\n            } else if (firstChar === \"*\") {\n              newDesc[previousProp]." + defaultValuesField + " = element[prop];\n              var optionalMethods = newDesc." + methodsWithOptionalArgumentsField + ";\n              if (!optionalMethods) {\n                newDesc." + methodsWithOptionalArgumentsField + " = optionalMethods={}\n              }\n              optionalMethods[prop] = previousProp;\n            } else {\n              var elem = element[prop];\n              if (prop !== \"" + t1 + "\" &&\n                  elem != null &&\n                  elem.constructor === Array &&\n                  prop !== \"<>\") {\n                addStubs(newDesc, elem, prop, false, element, []);\n              } else {\n                newDesc[previousProp = prop] = elem;\n              }\n            }\n          }\n          " + H.S(classesCollector) + "[property] = [globalObject, newDesc];\n          classes.push(property);\n        }\n      }\n    }\n";
    addStubs = "  function addStubs(descriptor, array, name, isStatic,\n                    originalDescriptor, functions) {\n    var f, funcs =\n        [originalDescriptor[name] =\n        descriptor[name] = f = " + K.readChecked("array", "0", "result != null && typeof result != \"function\"", "function") + "];\n    f.$stubName = name;\n    functions.push(name);\n    for (var index = 0; index < array.length; index += 2) {\n      f = array[index + 1];\n      if (typeof f != \"function\") break;\n      f.$stubName = " + K.readChecked("array", "index + 2", "result != null && typeof result != \"string\"", "string") + ";\n      funcs.push(f);\n      if (f.$stubName) {\n        originalDescriptor[f.$stubName] = descriptor[f.$stubName] = f;\n        functions.push(f.$stubName);\n      }\n    }\n    for (var i = 0; i < funcs.length; index++, i++) {\n      funcs[i].$callName = " + K.readChecked("array", "index + 1", "result != null && typeof result != \"string\"", "string") + ";\n    }\n    var getterStubName = " + K.readChecked("array", "++index", "result != null && typeof result != \"string\"", "string") + ";\n    array = array.slice(++index);\n    var requiredParameterInfo = " + K.readChecked("array", "0", "result != null && (typeof result != \"number\" || (result|0) !== result)", "int") + ";\n    var requiredParameterCount = requiredParameterInfo >> 1;\n    var isAccessor = (requiredParameterInfo & 1) === 1;\n    var isSetter = requiredParameterInfo === 3;\n    var isGetter = requiredParameterInfo === 1;\n    var optionalParameterInfo = " + K.readChecked("array", "1", "result != null && (typeof result != \"number\" || (result|0) !== result)", "int") + ";\n    var optionalParameterCount = optionalParameterInfo >> 1;\n    var optionalParametersAreNamed = (optionalParameterInfo & 1) === 1;\n    var isIntercepted =\n           requiredParameterCount + optionalParameterCount != funcs[0].length;\n    var functionTypeIndex = " + K.readChecked("array", "2", "result != null && (typeof result != \"number\" || (result|0) !== result) && typeof result != \"function\"", "function or int") + ";\n    var unmangledNameIndex = " + unmangledNameIndex + ";\n    var isReflectable = array.length > unmangledNameIndex;\n\n    if (getterStubName) {\n      f = tearOff(funcs, array, isStatic, name, isIntercepted);\n      descriptor[name].$getter = f;\n      f.$getterStub = true;\n      // Used to create an isolate using spawnFunction.\n      if (isStatic) init.globalFunctions[name] = f;\n      originalDescriptor[getterStubName] = descriptor[getterStubName] = f;\n      funcs.push(f);\n      if (getterStubName) functions.push(getterStubName);\n      f.$stubName = getterStubName;\n      f.$callName = null;\n      if (isIntercepted) init.interceptedNames[getterStubName] = true;\n    }\n    if (isReflectable) {\n      for (var i = 0; i < funcs.length; i++) {\n        funcs[i]." + reflectableField + " = 1;\n        funcs[i].$reflectionInfo = array;\n      }\n      var mangledNames = isStatic ? init.mangledGlobalNames : init.mangledNames;\n      var unmangledName = " + K.readChecked("array", "unmangledNameIndex", "result != null && typeof result != \"string\"", "string") + ";\n      // The function is either a getter, a setter, or a method.\n      // If it is a method, it might also have a tear-off closure.\n      // The unmangledName is the same as the getter-name.\n      var reflectionName = unmangledName;\n      if (getterStubName) mangledNames[getterStubName] = reflectionName;\n      if (isSetter) {\n        reflectionName += \"=\";\n      } else if (!isGetter) {\n        reflectionName += \":\" + requiredParameterCount +\n          \":\" + optionalParameterCount;\n      }\n      mangledNames[name] = reflectionName;\n      funcs[0].$reflectionName = reflectionName;\n      funcs[0].$metadataIndex = unmangledNameIndex + 1;\n      if (optionalParameterCount) descriptor[unmangledName + \"*\"] = funcs[0];\n    }\n  }\n";
    compiler = backend.compiler;
    element = backend.jsHelperLibrary.findLocal$1("closureFromTearOff");
    if (element != null) {
      $name = namer.getNameX$1(element);
      tearOffAccessExpression = new Q.PropertyAccess(new Q.VariableUse(namer.globalObjectFor$1(element), null, null), new Q.LiteralString0("\"" + H.S($name) + "\"", null, null), null, null);
      printer = Q.Printer$(compiler, null, true);
      printer.visit$1(tearOffAccessExpression);
      tearOffAccessText = printer.outBuffer.buffer._contents;
      tearOffGlobalObject = namer.globalObjectFor$1(element);
      tearOffGlobalObjectName = tearOffGlobalObject;
    } else {
      tearOffAccessExpression = C.C_JsBuilder.call$1("function() { throw 'Helper \\'closureFromTearOff\\' missing.' }");
      tearOffAccessText = "function() { throw 'Helper \\'closureFromTearOff\\' missing.' }";
      tearOffGlobalObjectName = "MissingHelperFunction";
      tearOffGlobalObject = "(function() { throw 'Helper \\'closureFromTearOff\\' missing.' }())";
    }
    t2 = "    function tearOffGetterNoCsp(funcs, reflectionInfo, name, isIntercepted) {\n      return isIntercepted\n          ? new Function(\"funcs\", \"reflectionInfo\", \"name\",\n                         \"" + H.S(tearOffGlobalObjectName) + "\", \"c\",\n              \"return function tearOff_\" + name + (functionCounter++)+ \"(x) {\" +\n                \"if (c === null) c = " + tearOffAccessText + "(\" +\n                    \"this, funcs, reflectionInfo, false, [x], name);\" +\n                \"return new c(this, funcs[0], x, name);\" +\n              \"}\")(funcs, reflectionInfo, name, " + H.S(tearOffGlobalObject) + ", null)\n          : new Function(\"funcs\", \"reflectionInfo\", \"name\",\n                         \"" + H.S(tearOffGlobalObjectName) + "\", \"c\",\n              \"return function tearOff_\" + name + (functionCounter++)+ \"() {\" +\n                \"if (c === null) c = " + tearOffAccessText + "(\" +\n                    \"this, funcs, reflectionInfo, false, [], name);\" +\n                \"return new c(this, funcs[0], null, name);\" +\n              \"}\")(funcs, reflectionInfo, name, " + H.S(tearOffGlobalObject) + ", null);\n    }";
    t3 = [];
    t3.$builtinTypeInfo = [Q.InterpolatedNode];
    parser = new Q.MiniJsParser(-1, null, 0, 0, false, t2, t3);
    parser.getToken$0();
    statement = parser.statement$0();
    t2 = new Q.Template(t2, false, false, statement, null, -1);
    t3 = P.LinkedHashSet_LinkedHashSet(null, null, null, Q.Node0);
    t4 = [];
    t4.$builtinTypeInfo = [Q.InterpolatedNode];
    t3 = new Q.InterpolatedNodeAnalysis(t3, t4, 0);
    statement.accept$1(0, t3);
    t2.instantiator = new Q.InstantiatorGeneratorVisitor(false, t3).visit$1(statement);
    t2.positionalArgumentCount = t3.count;
    tearOffCode = [t2.instantiate$1([]), C.C_JsBuilder.statement$2("    function tearOffGetterCsp(funcs, reflectionInfo, name, isIntercepted) {\n      var cache = null;\n      return isIntercepted\n          ? function(x) {\n              if (cache === null) cache = #(\n                  this, funcs, reflectionInfo, false, [x], name);\n              return new cache(this, funcs[0], x, name);\n            }\n          : function() {\n              if (cache === null) cache = #(\n                  this, funcs, reflectionInfo, false, [], name);\n              return new cache(this, funcs[0], null, name);\n            };\n    }", [tearOffAccessExpression, tearOffAccessExpression]), C.C_JsBuilder.statement$2("    function tearOff(funcs, reflectionInfo, isStatic, name, isIntercepted) {\n      var cache;\n      return isStatic\n          ? function() {\n              if (cache === void 0) cache = #(\n                  this, funcs, reflectionInfo, true, [], name).prototype;\n              return cache;\n            }\n          : tearOffGetter(funcs, reflectionInfo, name, isIntercepted);\n    }", tearOffAccessExpression)];
    tearOffCode.$builtinTypeInfo = [Q.Statement];
    $init = "  var functionCounter = 0;\n  var tearOffGetter = (typeof dart_precompiled == \"function\")\n      ? tearOffGetterCsp : tearOffGetterNoCsp;\n  if (!init.libraries) init.libraries = [];\n  if (!init.mangledNames) init.mangledNames = map();\n  if (!init.mangledGlobalNames) init.mangledGlobalNames = map();\n  if (!init.statics) init.statics = map();\n  if (!init.typeInformation) init.typeInformation = map();\n  if (!init.globalFunctions) init.globalFunctions = map();\n  if (!init.interceptedNames) init.interceptedNames = map();\n  var libraries = init.libraries;\n  var mangledNames = init.mangledNames;\n  var mangledGlobalNames = init.mangledGlobalNames;\n  var hasOwnProperty = Object.prototype.hasOwnProperty;\n  var length = reflectionData.length;\n  for (var i = 0; i < length; i++) {\n    var data = reflectionData[i];\n\n// [data] contains these elements:\n// 0. The library name (not unique).\n// 1. The library URI (unique).\n// 2. A function returning the metadata associated with this library.\n// 3. The global object to use for this library.\n// 4. An object literal listing the members of the library.\n// 5. This element is optional and if present it is true and signals that this\n// library is the root library (see dart:mirrors IsolateMirror.rootLibrary).\n//\n// The entries of [data] are built in [assembleProgram] above.\n\n    var name = data[0];\n    var uri = data[1];\n    var metadata = data[2];\n    var globalObject = data[3];\n    var descriptor = data[4];\n    var isRoot = !!data[5];\n    var fields = descriptor && descriptor[\"" + t1 + "\"];\n    if (fields instanceof Array) fields = fields[0];\n    var classes = [];\n    var functions = [];\n    processStatics(descriptor);\n    libraries.push([name, uri, classes, functions, metadata, fields, isRoot,\n                    globalObject]);\n  }\n";
    return C.C_JsBuilder.call$2("(function (reflectionData) {\n  \"use strict\";\n  // [map] returns an object literal that V8 shouldn not try to optimize with a\n// hidden class. This prevents a potential performance problem where V8 tries\n// to build a hidden class for an object used as a hashMap.\n\n  function map(x){x={x:x};delete x.x;return x}\n\n  " + processStatics + "\n  " + addStubs + "\n  #; // tearOffCode\n  " + $init + "\n})", [tearOffCode]);
  },
  readChecked: function(array, index, check, type) {
    return array + "[" + index + "]";
  },
  ClassBuilder: {
    "^": "Object;properties<,fields<,superName<,functionType<,fieldMetadata,element<,namer,isTrivial<",
    addProperty$2: [function($name, value) {
      var property = new Q.Property(new Q.LiteralString0("\"" + H.S($name) + "\"", null, null), value, null, null);
      this.properties.push(property);
      return property;
    }, "call$2", "get$addProperty", 4, 0, 105],
    toObjectInitializer$0: function() {
      var buffer, t1, classData, t2, fieldsAndProperties;
      buffer = P.StringBuffer$("");
      t1 = this.superName;
      if (t1 != null) {
        buffer.write$1(H.S(t1));
        t1 = this.functionType;
        if (t1 != null)
          buffer.write$1(":" + H.S(t1));
        buffer.write$1(";");
      }
      buffer.writeAll$2(this.fields, ",");
      classData = new Q.LiteralString0("\"" + buffer._contents + "\"", null, null);
      t1 = this.fieldMetadata;
      if (t1 != null) {
        t2 = [classData];
        C.JSArray_methods.addAll$1(t2, t1);
        classData = new Q.ArrayInitializer(t2.length, Q.ArrayInitializer__convert(t2), null, null);
      }
      fieldsAndProperties = [new Q.Property(new Q.LiteralString0("\"" + this.namer.classDescriptorProperty + "\"", null, null), classData, null, null)];
      C.JSArray_methods.addAll$1(fieldsAndProperties, this.properties);
      return new Q.ObjectInitializer(fieldsAndProperties, false, null, null);
    }
  },
  ClassEmitter: {
    "^": "CodeEmitterHelper;task",
    generateClass$3: function(classElement, properties, additionalProperties) {
      var onlyForRti, t1, className, superclass, superName, mixinName, builder, $name, $function;
      onlyForRti = this.task.typeTestEmitter.rtiNeededClasses.contains$1(0, classElement);
      t1 = this.task;
      t1.needsDefineClass = true;
      className = t1.namer.getNameX$1(classElement);
      superclass = classElement.get$superclass();
      superName = superclass != null ? this.task.namer.getNameX$1(superclass) : "";
      if (classElement.get$isMixinApplication()) {
        mixinName = this.task.namer.getNameX$1(K.computeMixinClass(classElement));
        superName = H.S(superName) + "+" + H.S(mixinName);
        this.task.needsMixinSupport = true;
      }
      t1 = this.task.namer;
      builder = new K.ClassBuilder(H.setRuntimeTypeInfo([], [Q.Property]), H.setRuntimeTypeInfo([], [P.String]), null, null, null, classElement, t1, false);
      this.emitClassConstructor$3$onlyForRti(classElement, builder, onlyForRti);
      this.emitFields$4$onlyForRti(classElement, builder, superName, onlyForRti);
      this.emitClassGettersSetters$3$onlyForRti(classElement, builder, onlyForRti);
      this.emitInstanceMembers$3$onlyForRti(classElement, builder, onlyForRti);
      this.task.typeTestEmitter.emitIsTests$2(classElement, builder);
      if (additionalProperties != null)
        J.forEach$1$ax(additionalProperties, builder.get$addProperty());
      if (classElement === this.task.compiler.backend.get$closureClass()) {
        $name = this.task.namer.getMappedInstanceName$1("call");
        $function = C.C_JsBuilder.call$1("function() { return this; }");
        builder.addProperty$2(this.task.namer.get$getterPrefix() + H.S($name), $function);
      }
      this.emitTypeVariableReaders$2(classElement, builder);
      this.emitClassBuilderWithReflectionData$4(className, classElement, builder, properties);
    },
    emitClassConstructor$3$onlyForRti: function(classElement, builder, onlyForRti) {
      var fields, constructorName, constructorAst;
      fields = H.setRuntimeTypeInfo([], [P.String]);
      if (!onlyForRti && classElement.nativeTagInfo == null)
        this.visitFields$3(classElement, false, new K.ClassEmitter_emitClassConstructor_closure(fields));
      constructorName = this.task.namer.getNameX$1(classElement);
      constructorAst = C.C_JsBuilder.call$2("function(#) { #; }", [fields, C.JSArray_methods.map$1(fields, new K.ClassEmitter_emitClassConstructor_closure0())]);
      this.task.emitPrecompiledConstructor$2(constructorName, constructorAst);
    },
    emitClassConstructor$2: function(classElement, builder) {
      return this.emitClassConstructor$3$onlyForRti(classElement, builder, false);
    },
    emitFields$6$classIsNative$emitStatics$onlyForRti: function(element, builder, superName, classIsNative, emitStatics, onlyForRti) {
      var t1, fieldMetadata;
      t1 = {};
      if (element.get$kind(element) === C.ElementKind_library_0)
        ;
      else if (element.kind !== C.ElementKind_class_4)
        throw H.wrapException(O.SpannableAssertionFailure$(element, "Must be a ClassElement or a LibraryElement"));
      if (emitStatics)
        ;
      else
        builder.superName = superName;
      fieldMetadata = [];
      t1.hasMetadata_0 = false;
      t1.fieldsAdded_1 = false;
      if (!onlyForRti)
        this.visitFields$3(element, emitStatics, new K.ClassEmitter_emitFields_closure(t1, this, element, builder, classIsNative, fieldMetadata));
      if (t1.hasMetadata_0)
        builder.fieldMetadata = fieldMetadata;
      return t1.fieldsAdded_1;
    },
    emitFields$4$emitStatics: function(element, builder, superName, emitStatics) {
      return this.emitFields$6$classIsNative$emitStatics$onlyForRti(element, builder, superName, false, emitStatics, false);
    },
    emitFields$4$onlyForRti: function(element, builder, superName, onlyForRti) {
      return this.emitFields$6$classIsNative$emitStatics$onlyForRti(element, builder, superName, false, false, onlyForRti);
    },
    emitFields$4$classIsNative: function(element, builder, superName, classIsNative) {
      return this.emitFields$6$classIsNative$emitStatics$onlyForRti(element, builder, superName, classIsNative, false, false);
    },
    emitClassGettersSetters$3$onlyForRti: function(classElement, builder, onlyForRti) {
      if (onlyForRti)
        return;
      this.visitFields$3(classElement, false, new K.ClassEmitter_emitClassGettersSetters_closure(this, builder));
    },
    emitClassGettersSetters$2: function(classElement, builder) {
      return this.emitClassGettersSetters$3$onlyForRti(classElement, builder, false);
    },
    emitInstanceMembers$3$onlyForRti: function(classElement, builder, onlyForRti) {
      var t1, t2;
      if (onlyForRti || classElement.get$isMixinApplication())
        return;
      classElement.get$implementation(classElement).forEachMember$2$includeBackendMembers(new K.ClassEmitter_emitInstanceMembers_visitMember(this, classElement, builder), true);
      t1 = this.task;
      t2 = t1.compiler;
      if (classElement === t2.objectClass && t2.enabledNoSuchMethod)
        if (!t1.nativeEmitter.handleNoSuchMethod)
          t1.nsmEmitter.emitNoSuchMethodHandlers$1(builder.get$addProperty());
    },
    emitInstanceMembers$2: function(classElement, builder) {
      return this.emitInstanceMembers$3$onlyForRti(classElement, builder, false);
    },
    emitClassBuilderWithReflectionData$4: function(className, classElement, classBuilder, enclosingBuilder) {
      var metadata, typeVars, result, typeVariableProperties, superclass, t1, t2, statics, staticsBuilder, initializer, property, classPropertyLists, classProperties, propertyValue, reflectionName, types, $interface;
      metadata = this.task.metadataEmitter.buildMetadataFunction$1(classElement);
      if (metadata != null)
        classBuilder.addProperty$2("@", metadata);
      if (this.task.compiler.backend.isAccessibleByReflection$1(classElement)) {
        typeVars = classElement.get$typeVariables();
        result = this.task.compiler.backend.get$typeVariableHandler().typeVariables.$index(0, classElement);
        if (result == null)
          result = C.List_empty7;
        typeVariableProperties = J.map$1$ax(result, C.C_JsBuilder.get$number());
        superclass = classElement.get$superclass();
        t1 = superclass == null;
        t2 = J.getInterceptor$asx(typeVariableProperties);
        if (!(t2.get$length(typeVariableProperties) !== 0 && t1))
          t1 = !t1 && !O.equalElements(superclass.get$typeVariables(), typeVars);
        else
          t1 = true;
        if (t1)
          classBuilder.addProperty$2("<>", new Q.ArrayInitializer(t2.get$length(typeVariableProperties), Q.ArrayInitializer__convert(typeVariableProperties), null, null));
      }
      statics = H.setRuntimeTypeInfo([], [Q.Property]);
      t1 = this.task.namer;
      staticsBuilder = new K.ClassBuilder(H.setRuntimeTypeInfo([], [Q.Property]), H.setRuntimeTypeInfo([], [P.String]), null, null, null, classElement, t1, false);
      if (this.emitFields$4$emitStatics(classElement, staticsBuilder, null, true)) {
        initializer = staticsBuilder.toObjectInitializer$0();
        this.task.compiler.dumpInfoTask.registerElementAst$2(classElement, initializer);
        property = C.JSArray_methods.get$single(initializer.properties);
        this.task.compiler.dumpInfoTask.registerElementAst$2(classElement, property);
        statics.push(property);
      }
      classPropertyLists = this.task.elementDescriptors.remove$1(0, classElement);
      if (classPropertyLists != null)
        for (t1 = J.get$iterator$ax(J.get$values$x(classPropertyLists)); t1.moveNext$0();) {
          classProperties = t1.get$current();
          if (classProperties != null)
            C.JSArray_methods.addAll$1(statics, classProperties.get$properties());
        }
      if (statics.length !== 0)
        classBuilder.addProperty$2("static", new Q.ObjectInitializer(statics, true, null, null));
      propertyValue = classBuilder.toObjectInitializer$0();
      this.task.compiler.dumpInfoTask.registerElementAst$2(classBuilder.element, propertyValue);
      enclosingBuilder.addProperty$2(className, propertyValue);
      reflectionName = this.task.getReflectionName$2(classElement, className);
      if (reflectionName != null)
        if (!this.task.compiler.backend.isAccessibleByReflection$1(classElement))
          enclosingBuilder.addProperty$2("+" + reflectionName, new Q.LiteralNumber("0", null, null));
        else {
          types = H.setRuntimeTypeInfo([], [P.$int]);
          if (classElement.get$supertype() != null)
            types.push(this.task.metadataEmitter.reifyType$1(classElement.supertype));
          for (t1 = classElement.interfaces, t1.toString, t1 = H.setRuntimeTypeInfo(new E.LinkIterator(null, t1), [H.getTypeArgumentByIndex(t1, 0)]); t1.moveNext$0();) {
            $interface = t1._util_implementation$_current;
            types.push(this.task.metadataEmitter.reifyType$1($interface));
          }
          t1 = "+" + reflectionName;
          t2 = H.setRuntimeTypeInfo(new H.MappedListIterable(types, C.C_JsBuilder.get$number()), [null, null]);
          enclosingBuilder.addProperty$2(t1, new Q.ArrayInitializer(t2.get$length(t2), Q.ArrayInitializer__convert(t2), null, null));
        }
    },
    visitFields$3: function(element, visitStatics, f) {
      var t1, isInstantiated, t2;
      t1 = {};
      t1.isClass_0 = false;
      t1.isLibrary_1 = false;
      if (element.get$kind(element) === C.ElementKind_class_4)
        t1.isClass_0 = true;
      else if (element.kind === C.ElementKind_library_0)
        t1.isLibrary_1 = true;
      else
        throw H.wrapException(O.SpannableAssertionFailure$(element, "Expected a ClassElement or a LibraryElement."));
      isInstantiated = this.task.compiler.enqueuer.codegen.universe.instantiatedClasses.contains$1(0, element);
      t2 = new K.ClassEmitter_visitFields_visitField(t1, this, element, f, isInstantiated);
      if (t1.isLibrary_1)
        element.get$implementation(element).forEachLocalMember$1(new K.ClassEmitter_visitFields_closure(t2, element));
      else if (visitStatics)
        element.get$implementation(element).forEachStaticField$1(t2);
      else
        element.get$implementation(element).forEachInstanceField$2$includeSuperAndInjectedMembers(t2, isInstantiated);
    },
    recordMangledField$3: function(member, accessorName, memberName) {
      var t1, t2;
      t1 = this.task.compiler.backend;
      if (!(t1.get$isTreeShakingDisabled() && t1.isAccessibleByReflection$1(member)))
        return;
      t1 = member.get$isInstanceMember();
      t2 = this.task;
      if (t1)
        t2.mangledFieldNames.putIfAbsent$2(t2.namer.get$getterPrefix() + H.S(accessorName), new K.ClassEmitter_recordMangledField_closure(memberName));
      else
        t2.mangledGlobalFieldNames.putIfAbsent$2(accessorName, new K.ClassEmitter_recordMangledField_closure0(memberName));
    },
    fieldNeedsGetter$1: function(field) {
      var t1, t2;
      if (!!field.$isClosureFieldElement)
        return false;
      t1 = this.task.compiler.backend;
      if (!(t1.get$isTreeShakingDisabled() && t1.isAccessibleByReflection$1(field))) {
        t1 = this.task.compiler;
        t2 = t1.enqueuer.codegen.universe;
        t1 = t2.hasMatchingSelector$3(t2.invokedGetters.$index(0, field.get$name(field)), field, t1);
      } else
        t1 = true;
      return t1;
    },
    fieldNeedsSetter$1: function(field) {
      var t1, t2;
      if (!!field.$isClosureFieldElement)
        return false;
      if (!field.get$isFinal() && (field.get$modifiers().flags & 16) === 0) {
        t1 = this.task.compiler.backend;
        if (!(t1.get$isTreeShakingDisabled() && t1.isAccessibleByReflection$1(field))) {
          t1 = this.task.compiler;
          t2 = t1.enqueuer.codegen.universe;
          t1 = t2.hasMatchingSelector$3(t2.invokedSetters.$index(0, field.name), field, t1);
        } else
          t1 = true;
      } else
        t1 = false;
      return t1;
    },
    canAvoidGeneratedCheckedSetter$1: function(member) {
      var type, t1, t2;
      if (!member.get$isInstanceMember())
        return true;
      type = member.get$type(member);
      if (!type.get$treatAsDynamic()) {
        t1 = type.get$element();
        t2 = this.task.compiler.objectClass;
        t2 = t1 == null ? t2 == null : t1 === t2;
        t1 = t2;
      } else
        t1 = true;
      return t1;
    },
    emitTypeVariableReaders$2: function(cls, builder) {
      var t1, superclass, t2, t3, parameter, t4, t5, $name, index, substitution, computeTypeVariable, element, name0, t6, property;
      for (t1 = builder.properties, superclass = cls; superclass != null;) {
        t2 = superclass.get$typeVariables();
        t3 = new H.ListIterator(t2, t2.length, 0, null);
        t3.$builtinTypeInfo = [H.getTypeArgumentByIndex(t2, 0)];
        for (; t3.moveNext$0();) {
          parameter = t3.__internal$_current;
          if (this.task.readTypeVariables.contains$1(0, parameter.get$element())) {
            t2 = parameter.get$element();
            t4 = this.task.namer;
            t5 = t2.enclosingElement;
            $name = "$tv_" + H.S(t4.getMappedInstanceName$1(t4.privateName$2(t5.get$library(), t2.name)));
            index = new Q.LiteralNumber("" + Z.RuntimeTypes_getTypeVariableIndex(t2), null, null);
            substitution = this.task.compiler.backend.get$rti().computeSubstitution$3$alwaysGenerateFunction(cls, t5, true);
            computeTypeVariable = substitution != null ? C.C_JsBuilder.call$2("#[#]", [C.C_JsBuilder.call$2("#.apply(null, this.$builtinTypeInfo)", substitution.getCode$2(this.task.compiler.backend.get$rti(), true)), index]) : C.C_JsBuilder.call$2("this.$builtinTypeInfo && this.$builtinTypeInfo[#]", index);
            t4 = this.task;
            t5 = t4.namer;
            element = t4.compiler.backend.get$jsHelperLibrary().findLocal$1("convertRtiToRuntimeType");
            name0 = t5.getNameX$1(element);
            t5 = t5.globalObjectFor$1(element);
            t4 = "\"" + H.S(name0) + "\"";
            t6 = this.task.compiler.dumpInfoTask;
            t4 = C.C_JsBuilder.call$2("function () { return #(#) }", [new Q.PropertyAccess(new Q.VariableUse(t5, null, null), new Q.LiteralString0(t4, null, null), null, null), computeTypeVariable]);
            property = new Q.Property(new Q.LiteralString0("\"" + $name + "\"", null, null), t4, null, null);
            t1.push(property);
            t6.registerElementAst$2(t2, property);
          }
        }
        superclass = superclass.get$superclass();
      }
    }
  },
  ClassEmitter_emitClassConstructor_closure: {
    "^": "Closure:106;fields_0",
    call$6: function(member, $name, accessorName, needsGetter, needsSetter, needsCheckedSetter) {
      this.fields_0.push($name);
    },
    $isFunction: true
  },
  ClassEmitter_emitClassConstructor_closure0: {
    "^": "Closure:13;",
    call$1: function($name) {
      return C.C_JsBuilder.call$2("this.# = #", [$name, $name]);
    },
    $isFunction: true
  },
  ClassEmitter_emitFields_closure: {
    "^": "Closure:107;box_0,this_1,element_2,builder_3,classIsNative_4,fieldMetadata_5",
    call$6: function(field, $name, accessorName, needsGetter, needsSetter, needsCheckedSetter) {
      var needsAccessor, t1, metadata, t2, fieldName, fieldCode, t3, isIntercepted, getterCode, setterCode, code, type, reflectionMarker, builtFieldname;
      needsAccessor = needsGetter || needsSetter;
      if (!this.classIsNative_4 || needsAccessor) {
        t1 = this.this_1;
        metadata = t1.task.metadataEmitter.buildMetadataFunction$1(field);
        if (metadata != null)
          this.box_0.hasMetadata_0 = true;
        else
          metadata = new Q.LiteralNull(null, null);
        this.fieldMetadata_5.push(metadata);
        t2 = field.name;
        t1.recordMangledField$3(field, accessorName, t1.task.namer.privateName$2(field.get$library(), t2));
        if (!needsAccessor) {
          fieldName = $name;
          fieldCode = "";
        } else {
          fieldName = ($name == null ? accessorName != null : $name !== accessorName) ? H.S(accessorName) + ":" + H.S($name) : $name;
          if (t1.task.compiler.backend.fieldHasInterceptedGetter$1(field)) {
            t3 = t1.task;
            t3.interceptorEmitter.interceptorInvocationNames.add$1(0, t3.namer.getterName$1(field));
          }
          if (t1.task.compiler.backend.fieldHasInterceptedGetter$1(field)) {
            t3 = t1.task;
            t3.interceptorEmitter.interceptorInvocationNames.add$1(0, t3.namer.setterName$1(field));
          }
          if (needsGetter)
            if (field.get$isInstanceMember()) {
              isIntercepted = t1.task.compiler.backend.fieldHasInterceptedGetter$1(field);
              getterCode = isIntercepted ? 2 : 0;
              getterCode += t1.task.compiler.backend.isInterceptorClass$1(this.element_2) ? 0 : 1;
              if (isIntercepted) {
                t3 = t1.task;
                t3.interceptorEmitter.interceptorInvocationNames.add$1(0, t3.namer.getterName$1(field));
              }
            } else
              getterCode = 1;
          else
            getterCode = 0;
          if (needsSetter)
            if (field.get$isInstanceMember()) {
              isIntercepted = t1.task.compiler.backend.get$interceptedElements().$index(0, t2) != null;
              setterCode = isIntercepted ? 2 : 0;
              setterCode += t1.task.compiler.backend.isInterceptorClass$1(this.element_2) ? 0 : 1;
              if (isIntercepted) {
                t2 = t1.task;
                t2.interceptorEmitter.interceptorInvocationNames.add$1(0, t2.namer.setterName$1(field));
              }
            } else
              setterCode = 1;
          else
            setterCode = 0;
          code = getterCode + (setterCode << 2 >>> 0);
          if (code === 0) {
            t1.task.compiler.internalError$2(field, "Field code is 0 (" + this.element_2.toString$0(0) + "/" + field.toString$0(0) + ").");
            fieldCode = "";
          } else {
            t2 = code - 1;
            if (t2 < 0 || t2 >= 15)
              return H.ioore("<=>?@{|}~%&'()*", t2);
            fieldCode = "<=>?@{|}~%&'()*"[t2];
          }
        }
        if (t1.task.compiler.backend.isAccessibleByReflection$1(field)) {
          type = field.get$type(field);
          reflectionMarker = "-" + H.S(t1.task.metadataEmitter.reifyType$1(type));
        } else
          reflectionMarker = "";
        builtFieldname = H.S(fieldName) + fieldCode + reflectionMarker;
        this.builder_3.fields.push(builtFieldname);
        t1.task.compiler.dumpInfoTask._fieldNameToSize.$indexSet(0, field, builtFieldname.length + 1);
        this.box_0.fieldsAdded_1 = true;
      }
    },
    $isFunction: true
  },
  ClassEmitter_emitClassGettersSetters_closure: {
    "^": "Closure:107;this_0,builder_1",
    call$6: function(member, $name, accessorName, needsGetter, needsSetter, needsCheckedSetter) {
      var t1 = this.this_0;
      t1.task.compiler.withCurrentElement$2(member, new K.ClassEmitter_emitClassGettersSetters__closure(t1, this.builder_1, member, $name, accessorName, needsGetter, needsSetter, needsCheckedSetter));
    },
    $isFunction: true
  },
  ClassEmitter_emitClassGettersSetters__closure: {
    "^": "Closure:23;this_2,builder_3,member_4,name_5,accessorName_6,needsGetter_7,needsSetter_8,needsCheckedSetter_9",
    call$0: function() {
      var t1, t2, t3, code, setterName, selector, reflectionName, reflectable, getterName, cls, className, receiver, args;
      if (this.needsCheckedSetter_9) {
        t1 = this.this_2;
        t2 = this.member_4;
        t3 = this.builder_3;
        code = t1.task.compiler.backend.compiler.enqueuer.codegen.generatedCode.$index(0, t2);
        setterName = t1.task.namer.get$setterPrefix() + H.S(this.accessorName_6);
        t1.task.compiler.dumpInfoTask.registerElementAst$2(t2, t3.addProperty$2(setterName, code));
        selector = Z.Selector_Selector(C.SelectorKind_setter_1, t2.get$name(t2), t2.get$library(), 1, null);
        reflectionName = t1.task.getReflectionName$2(selector, setterName);
        if (reflectionName != null) {
          reflectable = C.C_JsBuilder.call$1(t1.task.compiler.backend.isAccessibleByReflection$1(t2) ? "1" : "0");
          t3.addProperty$2("+" + reflectionName, reflectable);
        }
      }
      if (this.needsGetter_7) {
        t1 = this.this_2;
        t2 = this.member_4;
        getterName = t1.task.namer.get$getterPrefix() + H.S(this.accessorName_6);
        cls = t2.get$enclosingClass();
        className = t1.task.namer.getNameX$1(cls);
        receiver = t1.task.compiler.backend.isInterceptorClass$1(cls) ? "receiver" : "this";
        args = t1.task.compiler.backend.isInterceptedMethod$1(t2) ? ["receiver"] : [];
        t1.task.precompiledFunction.push(C.C_JsBuilder.call$2("#.prototype.# = function(#) { return #.# }", [className, getterName, args, receiver, this.name_5]));
        if (t1.task.compiler.backend.isAccessibleByReflection$1(t2)) {
          t1 = t1.task;
          t1.precompiledFunction.push(C.C_JsBuilder.call$2("#.prototype.#." + t1.namer.reflectableField + " = 1", [className, getterName]));
        }
      }
      if (this.needsSetter_8) {
        t1 = this.this_2;
        t2 = this.member_4;
        setterName = t1.task.namer.get$setterPrefix() + H.S(this.accessorName_6);
        cls = t2.get$enclosingClass();
        className = t1.task.namer.getNameX$1(cls);
        receiver = t1.task.compiler.backend.isInterceptorClass$1(cls) ? "receiver" : "this";
        args = t1.task.compiler.backend.isInterceptedMethod$1(t2) ? ["receiver"] : [];
        t1.task.precompiledFunction.push(C.C_JsBuilder.call$2("#.prototype.# = function(#, v) { return #.# = v; }", [className, setterName, args, receiver, this.name_5]));
        if (t1.task.compiler.backend.isAccessibleByReflection$1(t2)) {
          t1 = t1.task;
          t1.precompiledFunction.push(C.C_JsBuilder.call$2("#.prototype.#." + t1.namer.reflectableField + " = 1", [className, setterName]));
        }
      }
    },
    $isFunction: true
  },
  ClassEmitter_emitInstanceMembers_visitMember: {
    "^": "Closure:51;this_0,classElement_1,builder_2",
    call$2: function(enclosing, member) {
      if (member.get$isInstanceMember())
        this.this_0.task.containerBuilder.addMember$2(member, this.builder_2);
    },
    $isFunction: true
  },
  ClassEmitter_visitFields_visitField: {
    "^": "Closure:108;box_0,this_1,element_2,f_3,isInstantiated_4",
    call$2: function(holder, field) {
      var t1, isMixinNativeField, needsGetter, needsSetter, t2, accessorName, fieldName, needsCheckedSetter;
      field.get$name(field);
      t1 = this.box_0;
      isMixinNativeField = t1.isClass_0 && this.element_2.get$isNative() && holder.get$isMixinApplication();
      if (t1.isLibrary_1 || isMixinNativeField || holder === this.element_2) {
        t1 = this.this_1;
        needsGetter = t1.fieldNeedsGetter$1(field);
        needsSetter = t1.fieldNeedsSetter$1(field);
      } else {
        needsGetter = false;
        needsSetter = false;
      }
      if (this.isInstantiated_4 && !holder.get$isNative() || needsGetter || needsSetter) {
        t1 = this.this_1;
        t2 = t1.task.namer;
        accessorName = field.get$isInstanceMember() ? t2.instanceFieldAccessorName$1(field) : t2.getNameX$1(field);
        t2 = t1.task.namer;
        fieldName = field.get$isInstanceMember() ? t2.instanceFieldPropertyName$1(field) : t2.getNameX$1(field);
        if (t1.task.compiler.enableTypeAssertions && needsSetter && !t1.canAvoidGeneratedCheckedSetter$1(field)) {
          needsSetter = false;
          needsCheckedSetter = true;
        } else
          needsCheckedSetter = false;
        this.f_3.call$6(field, fieldName, accessorName, needsGetter, needsSetter, needsCheckedSetter);
      }
    },
    $isFunction: true
  },
  ClassEmitter_visitFields_closure: {
    "^": "Closure:77;visitField_5,library_6",
    call$1: function(member) {
      if (J.get$kind$x(member) === C.ElementKind_field_1)
        this.visitField_5.call$2(this.library_6, member);
    },
    $isFunction: true
  },
  ClassEmitter_recordMangledField_closure: {
    "^": "Closure:23;memberName_0",
    call$0: function() {
      return this.memberName_0;
    },
    $isFunction: true
  },
  ClassEmitter_recordMangledField_closure0: {
    "^": "Closure:23;memberName_1",
    call$0: function() {
      return this.memberName_1;
    },
    $isFunction: true
  },
  CodeEmitterHelper: {
    "^": "Object;",
    get$backend: function() {
      return this.task.compiler.backend;
    },
    get$compiler: function() {
      return this.task.compiler;
    }
  },
  CodeEmitterTask: {
    "^": "CompilerTask;containerBuilder,classEmitter,nsmEmitter,typeTestEmitter,interceptorEmitter,metadataEmitter,cachedEmittedConstants,cachedEmittedConstantsBuffer,cachedClassBuilders,cachedElements,needsDefineClass,needsMixinSupport,needsLazyInitializer,namer,constantEmitter,nativeEmitter,outputBuffers,deferredConstants,isolateProperties,classesCollector,neededClasses,outputClassLists,outputConstantLists,nativeClasses,mangledFieldNames,mangledGlobalFieldNames,recordedMangledNames,additionalProperties,readTypeVariables,instantiatedClasses,typedefsNeededForReflection,precompiledFunction,precompiledConstructorNames,hasMakeConstantList,elementDescriptors,generateSourceMap,compiler,watch,profilerTag",
    get$backend: function() {
      return this.compiler.backend;
    },
    getBuffer$1: function(outputUnit) {
      return this.outputBuffers.putIfAbsent$2(outputUnit, new K.CodeEmitterTask_getBuffer_closure());
    },
    get$name: function(_) {
      return "CodeEmitter";
    },
    buildDefineClassAndFinishClassFunctionsIfNecessary$0: function() {
      var defineClass, t1, t2, receiverParamName, valueParamName, t3, t4, t5, t6, t7, t8, specProperty;
      if (!this.needsDefineClass)
        return [];
      defineClass = C.C_JsBuilder.call$1("function(name, cls, fields) {\n      var accessors = [];\n\n      var str = \"function \" + cls + \"(\";\n      var body = \"\";\n\n      for (var i = 0; i < fields.length; i++) {\n        if(i != 0) str += \", \";\n\n        var field = generateAccessor(fields[i], accessors, cls);\n        var parameter = \"parameter_\" + field;\n        str += parameter;\n        body += (\"this.\" + field + \" = \" + parameter + \";\\n\");\n      }\n      str += \") {\\n\" + body + \"}\\n\";\n      str += cls + \".builtin$cls=\\\"\" + name + \"\\\";\\n\";\n      str += \"$desc=$collectedClasses.\" + cls + \";\\n\";\n      str += \"if($desc instanceof Array) $desc = $desc[1];\\n\";\n      str += cls + \".prototype = $desc;\\n\";\n      if (typeof defineClass.name != \"string\") {\n        str += cls + \".name=\\\"\" + cls + \"\\\";\\n\";\n      }\n      str += accessors.join(\"\");\n\n      return str;\n    }");
      t1 = this.compiler;
      t2 = t1.enableMinification;
      receiverParamName = t2 ? "r" : "receiver";
      valueParamName = t2 ? "v" : "value";
      t3 = this.namer;
      t4 = "      function generateAccessor(fieldDescriptor, accessors, cls) {\n        var fieldInformation = fieldDescriptor.split(\"-\");\n        var field = fieldInformation[0];\n        var len = field.length;\n        var code = field.charCodeAt(len - 1);\n        var reflectable;\n        if (fieldInformation.length > 1) reflectable = true;\n             else reflectable = false;\n        code = ((code >= 60) && (code <= 64))\n              ? code - 59\n              : ((code >= 123) && (code <= 126))\n                ? code - 117\n                : ((code >= 37) && (code <= 43))\n                  ? code - 27\n                  : 0;\n\n        if (code) {  // needsAccessor\n          var getterCode = code & 3;\n          var setterCode = code >> 2;\n          var accessorName = field = field.substring(0, len - 1);\n\n          var divider = field.indexOf(\":\");\n          if (divider > 0) { // Colon never in first position.\n            accessorName = field.substring(0, divider);\n            field = field.substring(divider + 1);\n          }\n\n          if (getterCode) {  // needsGetter\n            var args = (getterCode & 2) ? \"" + receiverParamName + "\" : \"\";\n            var receiver = (getterCode & 1) ? \"this\" : \"" + receiverParamName + "\";\n            var body = \"return \" + receiver + \".\" + field;\n            var property =\n                cls + \".prototype." + t3.get$getterPrefix() + "\" + accessorName + \"=\";\n            var fn = \"function(\" + args + \"){\" + body + \"}\";\n            if (reflectable)\n              accessors.push(property + \"$reflectable(\" + fn + \");\\n\");\n            else\n              accessors.push(property + fn + \";\\n\");\n          }\n\n          if (setterCode) {  // needsSetter\n            var args = (setterCode & 2)\n                ? \"" + receiverParamName + ",";
      t4 = t4 + (t2 ? "" : " ") + valueParamName + "\"\n                : \"" + valueParamName + "\";\n            var receiver = (setterCode & 1) ? \"this\" : \"" + receiverParamName + "\";\n            var body = receiver + \".\" + field + \"";
      t4 = t4 + (t2 ? "" : " ") + "=";
      t4 = [C.C_JsBuilder.statement$1(t4 + (t2 ? "" : " ") + valueParamName + "\";\n            var property =\n                cls + \".prototype." + t3.get$setterPrefix() + "\" + accessorName + \"=\";\n            var fn = \"function(\" + args + \"){\" + body + \"}\";\n            if (reflectable)\n              accessors.push(property + \"$reflectable(\" + fn + \");\\n\");\n            else\n              accessors.push(property + fn + \";\\n\");\n          }\n        }\n\n        return field;\n      }"), C.C_JsBuilder.call$1(t3.get$isolateName() + "." + t3.get$isolatePropertiesName() + ".$generateAccessor = generateAccessor"), new Q.FunctionDeclaration(new Q.VariableDeclaration("defineClass", null, null), defineClass, null, null)];
      C.JSArray_methods.addAll$1(t4, [C.C_JsBuilder.call$1("        var inheritFrom = function() {\n          function tmp() {}\n          var hasOwnProperty = Object.prototype.hasOwnProperty;\n          return function (constructor, superConstructor) {\n            tmp.prototype = superConstructor.prototype;\n            var object = new tmp();\n            var properties = constructor.prototype;\n            for (var member in properties)\n              if (hasOwnProperty.call(properties, member))\n                object[member] = properties[member];\n            object.constructor = constructor;\n            constructor.prototype = object;\n            return object;\n          };\n        }()\n      ")]);
      t5 = t3.get$isolateName() + ".$finishClasses = #";
      t6 = "      function(collectedClasses, isolateProperties, existingIsolateProperties) {\n        var pendingClasses = {};\n        if (!init.allClasses) init.allClasses = {};\n        var allClasses = init.allClasses;\n\n        if (#)  // DEBUG_FAST_OBJECTS\n          print(\"Number of classes: \" +\n              Object.getOwnPropertyNames($$).length);\n\n        var hasOwnProperty = Object.prototype.hasOwnProperty;\n\n        if (typeof dart_precompiled == \"function\") {\n          var constructors = dart_precompiled(collectedClasses);\n        } else {\n          var combinedConstructorFunction =\n             \"function $reflectable(fn){fn." + t3.reflectableField + "=1;return fn};\\n\"+\n             \"var $desc;\\n\";\n          var constructorsList = [];\n        }\n\n        for (var cls in collectedClasses) {\n          if (hasOwnProperty.call(collectedClasses, cls)) {\n            var desc = collectedClasses[cls];\n            if (desc instanceof Array) desc = desc[1];\n\n            /* The 'fields' are either a constructor function or a\n             * string encoding fields, constructor and superclass.  Get\n             * the superclass and the fields in the format\n             *   '[name/]Super;field1,field2'\n             * from the CLASS_DESCRIPTOR_PROPERTY property on the descriptor.\n             * The 'name/' is optional and contains the name that should be used\n             * when printing the runtime type string.  It is used, for example,\n             * to print the runtime type JSInt as 'int'.\n             */\n            var classData = desc[\"" + t3.classDescriptorProperty + "\"],\n                supr, name = cls, fields = classData;\n            if (#)  // backend.hasRetainedMetadata\n              if (typeof classData == \"object\" &&\n                  classData instanceof Array) {\n                classData = fields = classData[0];\n              }\n            if (typeof classData == \"string\") {\n              var split = classData.split(\"/\");\n              if (split.length == 2) {\n                name = split[0];\n                fields = split[1];\n              }\n            }\n\n            var s = fields.split(\";\");\n            fields = s[1] == \"\" ? [] : s[1].split(\",\");\n            supr = s[0];\n            split = supr.split(\":\");\n            if (split.length == 2) {\n              supr = split[0];\n              var functionSignature = split[1];\n              if (functionSignature)\n                desc.$signature = (function(s) {\n                    return function(){ return init.metadata[s]; };\n                  })(functionSignature);\n            }\n\n            if (#)  // needsMixinSupport\n              if (supr && supr.indexOf(\"+\") > 0) {\n                s = supr.split(\"+\");\n                supr = s[0];\n                var mixin = collectedClasses[s[1]];\n                if (mixin instanceof Array) mixin = mixin[1];\n                for(var d in mixin) {\n                  if (hasOwnProperty.call(mixin, d) &&\n                      !hasOwnProperty.call(desc, d))\n                    desc[d] = mixin[d];\n                }\n              }\n\n            if (typeof dart_precompiled != \"function\") {\n              combinedConstructorFunction += defineClass(name, cls, fields);\n              constructorsList.push(cls);\n            }\n            if (supr) pendingClasses[cls] = supr;\n          }\n        }\n\n        if (typeof dart_precompiled != \"function\") {\n          combinedConstructorFunction +=\n             \"return [\\n  \" + constructorsList.join(\",\\n  \") + \"\\n]\";\n           var constructors =\n            new Function(\"$collectedClasses\", combinedConstructorFunction)\n            (collectedClasses);\n          combinedConstructorFunction = null;\n        }\n\n        for (var i = 0; i < constructors.length; i++) {\n          var constructor = constructors[i];\n          var cls = constructor.name;\n          var desc = collectedClasses[cls];\n          var globalObject = isolateProperties;\n          if (desc instanceof Array) {\n            globalObject = desc[0] || isolateProperties;\n            desc = desc[1];\n          }\n          if (#) //backend.isTreeShakingDisabled,\n            constructor[\"" + t3.metadataField + "\"] = desc;\n          allClasses[cls] = constructor;\n          globalObject[cls] = constructor;\n        }\n\n        constructors = null;\n\n        var finishedClasses = {};\n        init.interceptorsByTag = Object.create(null);\n        init.leafTags = {};\n\n        #;  // buildFinishClass(),\n\n        #;  // buildTrivialNsmHandlers()\n\n        for (var cls in pendingClasses) finishClass(cls);\n      }";
      t7 = t1.backend.get$hasRetainedMetadata();
      t8 = this.needsMixinSupport;
      t1 = t1.backend.get$isTreeShakingDisabled();
      specProperty = "\"" + t3.nativeSpecProperty + "\"";
      C.JSArray_methods.addAll$1(t4, [C.C_JsBuilder.call$2(t5, C.C_JsBuilder.call$2(t6, [false, t7, t8, t1, C.C_JsBuilder.statement$2("      function finishClass(cls) {\n\n        // TODO(8540): Remove this work around.\n        // Opera does not support 'getOwnPropertyNames'. Therefore we use\n        //   hasOwnProperty instead.\n        var hasOwnProperty = Object.prototype.hasOwnProperty;\n\n        if (hasOwnProperty.call(finishedClasses, cls)) return;\n\n        finishedClasses[cls] = true;\n\n        var superclass = pendingClasses[cls];\n\n        // The superclass is only false (empty string) for the Dart Object\n        // class.  The minifier together with noSuchMethod can put methods on\n        // the Object.prototype object, and they show through here, so we check\n        // that we have a string.\n        if (!superclass || typeof superclass != \"string\") return;\n        finishClass(superclass);\n        var constructor = allClasses[cls];\n        var superConstructor = allClasses[superclass];\n\n        if (!superConstructor)\n          superConstructor = existingIsolateProperties[superclass];\n\n        var prototype = inheritFrom(constructor, superConstructor);\n\n        if (#) {  // !nativeClasses.isEmpty,\n          // The property looks like this:\n          //\n          // HtmlElement: {\n          //     \"%\": \"HTMLDivElement|HTMLAnchorElement;HTMLElement;FancyButton\"\n          //\n          // The first two semicolon-separated parts contain dispatch tags, the\n          // third contains the JavaScript names for classes.\n          //\n          // The tags indicate that JavaScript objects with the dispatch tags\n          // (usually constructor names) HTMLDivElement, HTMLAnchorElement and\n          // HTMLElement all map to the Dart native class named HtmlElement.\n          // The first set is for effective leaf nodes in the hierarchy, the\n          // second set is non-leaf nodes.\n          //\n          // The third part contains the JavaScript names of Dart classes that\n          // extend the native class. Here, FancyButton extends HtmlElement, so\n          // the runtime needs to know that window.HTMLElement.prototype is the\n          // prototype that needs to be extended in creating the custom element.\n          //\n          // The information is used to build tables referenced by\n          // getNativeInterceptor and custom element support.\n          if (hasOwnProperty.call(prototype, " + specProperty + ")) {\n            var nativeSpec = prototype[" + specProperty + "].split(\";\");\n            if (nativeSpec[0]) {\n              var tags = nativeSpec[0].split(\"|\");\n              for (var i = 0; i < tags.length; i++) {\n                init.interceptorsByTag[tags[i]] = constructor;\n                init.leafTags[tags[i]] = true;\n              }\n            }\n            if (nativeSpec[1]) {\n              tags = nativeSpec[1].split(\"|\");\n              if (#) {  // User subclassing of native classes?\n                if (nativeSpec[2]) {\n                  var subclasses = nativeSpec[2].split(\"|\");\n                  for (var i = 0; i < subclasses.length; i++) {\n                    var subclass = allClasses[subclasses[i]];\n                    subclass.$nativeSuperclassTag = tags[0];\n                  }\n                }\n                for (i = 0; i < tags.length; i++) {\n                  init.interceptorsByTag[tags[i]] = constructor;\n                  init.leafTags[tags[i]] = false;\n                }\n              }\n            }\n          }\n        }\n      }", [this.nativeClasses.length !== 0, true]), this.nsmEmitter.buildTrivialNsmHandlers$0()]))]);
      return t4;
    },
    buildLazyInitializerFunctionIfNecessary$0: function() {
      var t1, t2, isolate, t3, t4, cyclicThrow;
      if (!this.needsLazyInitializer)
        return [];
      t1 = this.namer;
      t2 = C.C_JsBuilder.call$1(t1.get$isolateName() + ".$lazy");
      isolate = t1.currentIsolate;
      t3 = this.compiler;
      t4 = t3.backend;
      cyclicThrow = t1.elementAccess$1(t4.find$2(0, t4.get$jsHelperLibrary(), "throwCyclicInit"));
      return [C.C_JsBuilder.call$2("# = #", [t2, C.C_JsBuilder.call$2("      function (prototype, staticName, fieldName, getterName, lazyValue) {\n        if (#) {\n          if (!init.lazies) init.lazies = {};\n          init.lazies[fieldName] = getterName;\n        }\n\n        var sentinelUndefined = {};\n        var sentinelInProgress = {};\n        prototype[fieldName] = sentinelUndefined;\n\n        prototype[getterName] = function () {\n          var result = " + isolate + "[fieldName];\n          try {\n            if (result === sentinelUndefined) {\n              " + isolate + "[fieldName] = sentinelInProgress;\n\n              try {\n                result = " + isolate + "[fieldName] = lazyValue();\n              } finally {\n                // Use try-finally, not try-catch/throw as it destroys the\n                // stack trace.\n                if (result === sentinelUndefined)\n                  if (" + isolate + "[fieldName] === sentinelInProgress)\n                    " + isolate + "[fieldName] = null;\n              }\n            } else {\n              if (result === sentinelInProgress)\n                #(staticName);\n            }\n\n            return result;\n          } finally {\n            " + isolate + "[getterName] = function() { return this[fieldName]; };\n          }\n        }\n      }\n    ", [t3.backend.get$isTreeShakingDisabled(), cyclicThrow])])];
    },
    _isNativeTypeNeedingReflectionName$1: function(element) {
      var t1;
      if (element.get$kind(element) !== C.ElementKind_class_4)
        return false;
      t1 = this.compiler;
      return element === t1.intClass || element === t1.doubleClass || element === t1.numClass || element === t1.stringClass || element === t1.boolClass || element === t1.nullClass || element === t1.listClass;
    },
    getReflectionName$2: function(elementOrSelector, mangledName) {
      var t1, $name, t2;
      t1 = J.getInterceptor$x(elementOrSelector);
      $name = t1.get$name(elementOrSelector);
      t2 = this.compiler;
      if (!t2.backend.shouldRetainName$1($name))
        if (!!t1.$isElement)
          t1 = J.$eq($name, "") && t2.backend.isAccessibleByReflection$1(elementOrSelector) || this._isNativeTypeNeedingReflectionName$1(elementOrSelector);
        else
          t1 = false;
      else
        t1 = true;
      if (t1) {
        this.recordedMangledNames.add$1(0, mangledName);
        return this.getReflectionNameInternal$2(elementOrSelector, mangledName);
      }
      return;
    },
    getReflectionNameInternal$2: function(elementOrSelector, mangledName) {
      var t1, t2, t3, base, getter, requiredParameterCount, namedArguments, optionalParameterCount, isConstructor, signature, names, suffix;
      t1 = {};
      t2 = this.namer;
      t3 = J.getInterceptor$x(elementOrSelector);
      t1.name_0 = t2.privateName$2(elementOrSelector.get$library(), t3.get$name(elementOrSelector));
      if (elementOrSelector.get$isGetter())
        return t1.name_0;
      if (elementOrSelector.get$isSetter()) {
        if (!J.getInterceptor$s(mangledName).startsWith$1(mangledName, t2.get$setterPrefix()))
          return H.S(t1.name_0) + "=";
        base = C.JSString_methods.substring$1(mangledName, t2.get$setterPrefix().length);
        getter = t2.get$getterPrefix() + base;
        this.mangledFieldNames.putIfAbsent$2(getter, new K.CodeEmitterTask_getReflectionNameInternal_closure(t1));
        this.recordedMangledNames.add$1(0, getter);
        return H.S(t1.name_0) + "=";
      }
      if (!!t3.$isElement && elementOrSelector.get$isClosure())
        return " " + H.S(mangledName);
      t2 = !!t3.$isSelector;
      if (t2 || elementOrSelector.get$isFunction() || elementOrSelector.get$isConstructor()) {
        if (t2) {
          requiredParameterCount = elementOrSelector.argumentCount;
          namedArguments = this.namedParametersAsReflectionNames$1(elementOrSelector);
          optionalParameterCount = 0;
          isConstructor = false;
        } else {
          if (t3.get$kind(elementOrSelector) === C.ElementKind_generative_constructor_16 || elementOrSelector.get$isFactoryConstructor()) {
            t1.name_0 = O.Elements_reconstructConstructorName(elementOrSelector);
            isConstructor = true;
          } else
            isConstructor = false;
          signature = elementOrSelector.get$functionSignature();
          requiredParameterCount = signature.get$requiredParameterCount();
          optionalParameterCount = signature.optionalParameterCount;
          if (signature.optionalParametersAreNamed) {
            names = [];
            for (t2 = signature.optionalParameters, t2.toString, t2 = H.setRuntimeTypeInfo(new E.LinkIterator(null, t2), [H.getTypeArgumentByIndex(t2, 0)]); t2.moveNext$0();)
              names.push(J.get$name$x(t2._util_implementation$_current));
            namedArguments = this.namedParametersAsReflectionNames$1(Z.Selector_Selector(C.SelectorKind_call_2, elementOrSelector.name, elementOrSelector.get$enclosingElement().get$library(), requiredParameterCount, names));
          } else {
            requiredParameterCount += optionalParameterCount;
            optionalParameterCount = 0;
            namedArguments = "";
          }
        }
        suffix = H.S(t1.name_0) + ":" + requiredParameterCount + ":" + optionalParameterCount + namedArguments;
        return isConstructor ? "new " + suffix : suffix;
      }
      if (t3.get$kind(elementOrSelector) === C.ElementKind_generative_constructor_body_0)
        return;
      else if (t3.get$kind(elementOrSelector) === C.ElementKind_class_4) {
        if (elementOrSelector.get$isUnnamedMixinApplication())
          return;
        return elementOrSelector.name;
      } else if (t3.get$kind(elementOrSelector) === C.ElementKind_typedef_32)
        return t3.get$name(elementOrSelector);
      throw H.wrapException(this.compiler.internalError$2(elementOrSelector, "Do not know how to reflect on this " + H.S(elementOrSelector) + "."));
    },
    namedParametersAsReflectionNames$1: function(selector) {
      if (selector.getOrderedNamedArguments$0().length === 0)
        return "";
      return ":" + C.JSArray_methods.join$1(selector.getOrderedNamedArguments$0(), ":");
    },
    generateClass$2: function(classElement, properties) {
      this.compiler.withCurrentElement$2(classElement, new K.CodeEmitterTask_generateClass_closure(this, classElement, properties));
    },
    computeClassFilter$0: function() {
      var t1, unneededClasses, needed, t2, interceptor;
      t1 = this.compiler;
      if (t1.backend.get$isTreeShakingDisabled())
        return new K.CodeEmitterTask_computeClassFilter_closure();
      unneededClasses = P.LinkedHashSet_LinkedHashSet(null, null, null, O.ClassElement);
      unneededClasses.add$1(0, t1.boolClass);
      needed = P.LinkedHashSet_LinkedHashSet(null, null, null, O.ClassElement);
      t1.backend.get$specializedGetInterceptors().forEach$1(0, new K.CodeEmitterTask_computeClassFilter_closure0(needed));
      needed.addAll$1(0, this.interceptorEmitter.interceptorsReferencedFromConstants$0());
      for (t2 = t1.backend.get$_interceptedClasses(), t2 = H.setRuntimeTypeInfo(new P.LinkedHashSetIterator(t2, t2._modifications, null, null), [null]), t2._cell = t2._set._first; t2.moveNext$0();) {
        interceptor = t2._collection$_current;
        if (!needed.contains$1(0, interceptor) && !J.$eq(interceptor, t1.objectClass))
          unneededClasses.add$1(0, interceptor);
      }
      unneededClasses.add$1(0, t1.backend.get$jsMutableArrayClass());
      unneededClasses.add$1(0, t1.backend.get$jsFixedArrayClass());
      unneededClasses.add$1(0, t1.backend.get$jsExtendableArrayClass());
      unneededClasses.add$1(0, t1.backend.get$jsUInt32Class());
      unneededClasses.add$1(0, t1.backend.get$jsUInt31Class());
      unneededClasses.add$1(0, t1.backend.get$jsPositiveIntClass());
      return new K.CodeEmitterTask_computeClassFilter_closure1(unneededClasses);
    },
    emitStaticFunctions$0: function() {
      var t1, t2, t3, element, t4, t5;
      t1 = this.compiler.backend.compiler.enqueuer.codegen.generatedCode;
      t1 = H.setRuntimeTypeInfo(new P.LinkedHashMapKeyIterable(t1), [H.getTypeArgumentByIndex(t1, 0)]);
      t1 = H.setRuntimeTypeInfo(new H.WhereIterable(t1, new K.CodeEmitterTask_emitStaticFunctions_isStaticFunction()), [H.getRuntimeTypeArgument(t1, "IterableBase", 0)]).toList$0(0);
      H.IterableMixinWorkaround_sortList(t1, O.Elements_compareByPosition$closure());
      t1 = H.setRuntimeTypeInfo(new H.ListIterator(t1, t1.length, 0, null), [H.getTypeArgumentByIndex(t1, 0)]);
      t2 = this.containerBuilder;
      t3 = this.namer;
      for (; t1.moveNext$0();) {
        element = t1.__internal$_current;
        t4 = [];
        t4.$builtinTypeInfo = [Q.Property];
        t5 = [];
        t5.$builtinTypeInfo = [P.String];
        t2.addMember$2(element, new K.ClassBuilder(t4, t5, null, null, null, element, t3, false));
        C.JSArray_methods.addAll$1(this.getElementDescriptor$1(element).properties, t4);
      }
    },
    emitStaticNonFinalFieldInitializations$1: function(buffer) {
      var t1, handler, t2, element, t3;
      t1 = this.compiler;
      handler = t1.backend.get$constantCompilerTask().jsConstantCompiler;
      t2 = handler.getStaticNonFinalFieldsForEmission$0().toList$0(0);
      H.IterableMixinWorkaround_sortList(t2, O.Elements_compareByPosition$closure());
      t2 = H.setRuntimeTypeInfo(new H.ListIterator(t2, t2.length, 0, null), [H.getTypeArgumentByIndex(t2, 0)]);
      for (; t2.moveNext$0();) {
        element = t2.__internal$_current;
        t3 = J.getInterceptor(element);
        if (t3.$eq(element, t1.backend.get$interceptedNames()))
          continue;
        if (t3.$eq(element, t1.backend.get$mapTypeToInterceptor()))
          continue;
        t1.withCurrentElement$2(element, new K.CodeEmitterTask_emitStaticNonFinalFieldInitializations_closure(this, buffer, handler, element));
      }
    },
    emitLazilyInitializedStaticFields$1: function(buffer) {
      var t1, lazyFields, t2, t3, t4, element, code, t5, t6, t7, t8, t9, t10, $init, printer;
      t1 = this.compiler;
      lazyFields = P.List_List$from(t1.backend.get$constantCompilerTask().jsConstantCompiler.lazyStatics, true, O.VariableElement);
      if (lazyFields.length !== 0) {
        this.needsLazyInitializer = true;
        t2 = C.JSArray_methods.toList$0(lazyFields);
        H.IterableMixinWorkaround_sortList(t2, O.Elements_compareByPosition$closure());
        t2 = H.setRuntimeTypeInfo(new H.ListIterator(t2, t2.length, 0, null), [H.getTypeArgumentByIndex(t2, 0)]);
        t3 = t1.enableMinification;
        t4 = this.namer;
        for (; t2.moveNext$0();) {
          element = t2.__internal$_current;
          code = t1.backend.compiler.enqueuer.codegen.generatedCode.$index(0, element);
          if (code == null)
            continue;
          t5 = C.C_JsBuilder.call$1(t4.get$isolateName() + ".$lazy");
          t6 = C.C_JsBuilder.call$1(this.isolateProperties);
          t7 = "\"" + H.S(J.get$name$x(element)) + "\"";
          t8 = "\"" + H.S(t4.getNameX$1(element)) + "\"";
          t9 = "\"" + H.S(t4.getMappedGlobalName$1(t4.get$getterPrefix() + H.S(t4.getNameX$1(element)))) + "\"";
          t10 = [];
          $init = C.C_JsBuilder.call$2("#(#,#,#,#,#,#)", [t5, t6, new Q.LiteralString0(t7, null, null), new Q.LiteralString0(t8, null, null), new Q.LiteralString0(t9, null, null), code, t10]);
          printer = Q.Printer$(t1, t1.dumpInfoTask, true);
          printer.visit$1($init);
          buffer.write$1(printer.outBuffer);
          buffer.write$1(t3 ? "\n" : ";\n");
        }
      }
    },
    emitCompileTimeConstants$2: function(buffer, outputUnit) {
      var constants, t1, t2, isMainBuffer, t3, t4, t5, t6, t7, constant, $name, t8, $init, printer;
      constants = this.outputConstantLists.$index(0, outputUnit);
      if (constants == null)
        return;
      t1 = this.compiler;
      t2 = this.getBuffer$1(t1.deferredLoadTask.mainOutputUnit);
      isMainBuffer = buffer == null ? t2 == null : buffer === t2;
      t2 = t1.hasIncrementalSupport;
      if (t2 && isMainBuffer)
        buffer = this.cachedEmittedConstantsBuffer;
      for (t3 = J.get$iterator$ax(constants), t4 = t1.enableMinification, t5 = this.constantEmitter, t6 = this.namer, t7 = this.cachedEmittedConstants; t3.moveNext$0();) {
        constant = t3.get$current();
        if (t2 && isMainBuffer) {
          if (t7.contains$1(0, constant))
            continue;
          t7.add$1(0, constant);
        }
        $name = t6.constantName$1(constant);
        if (constant.get$isList())
          this.emitMakeConstantListIfNotEmitted$1(buffer);
        t8 = t5._literalEmitter;
        t8.toString;
        $init = C.C_JsBuilder.call$2("#.# = #", ["C", $name, constant.accept$1(0, t8)]);
        printer = Q.Printer$(t1, t1.dumpInfoTask, true);
        printer.visit$1($init);
        buffer.write$1(printer.outBuffer);
        buffer.write$1(t4 ? "\n" : ";\n");
      }
      if (t2 && isMainBuffer)
        this.getBuffer$1(t1.deferredLoadTask.mainOutputUnit).write$1(this.cachedEmittedConstantsBuffer);
    },
    isConstantInlinedOrAlreadyEmitted$1: function(constant) {
      if (constant.get$isFunction())
        return true;
      if (constant.get$isPrimitive())
        return true;
      if (constant.get$isDummy())
        return true;
      if (this.namer.constantName$1(constant) == null)
        return true;
      return false;
    },
    compareConstants$2: [function(a, b) {
      var cmp1, cmp2, t1, r;
      cmp1 = this.isConstantInlinedOrAlreadyEmitted$1(a) ? 0 : 1;
      cmp2 = this.isConstantInlinedOrAlreadyEmitted$1(b) ? 0 : 1;
      if (cmp1 + cmp2 < 2)
        return cmp1 - cmp2;
      if (a.get$isInterceptor() !== b.get$isInterceptor())
        return a.get$isInterceptor() ? -1 : 1;
      t1 = this.namer;
      r = C.JSString_methods.compareTo$1(t1.constantLongName$1(a), t1.constantLongName$1(b));
      if (r !== 0)
        return r;
      return J.compareTo$1$ns(t1.constantName$1(a), t1.constantName$1(b));
    }, "call$2", "get$compareConstants", 4, 0, 109],
    emitMakeConstantListIfNotEmitted$1: function(buffer) {
      var t1, t2, printer;
      if (this.hasMakeConstantList)
        return;
      this.hasMakeConstantList = true;
      t1 = this.namer;
      t1 = C.C_JsBuilder.statement$2("#.# = function(list) {\n                                     list.immutable$list = #;\n                                     list.fixed$length = #;\n                                     return list;\n                                   }", [t1.get$isolateName(), t1.getMappedInstanceName$1("makeConstantList"), "init", "init"]);
      t2 = this.compiler;
      printer = Q.Printer$(t2, t2.dumpInfoTask, true);
      printer.visit$1(t1);
      buffer.write$1(printer.outBuffer);
      buffer.write$1(t2.enableMinification ? "\n" : ";\n");
    },
    emitMain$1: function(buffer) {
      var t1, main, t2, isolateMain, mainAccess, mainCallClosure, invokeMain;
      t1 = this.compiler;
      if (t1.get$isMockCompilation())
        return;
      main = t1.mainFunction;
      t2 = this.namer;
      if (t1.hasIsolateSupport) {
        isolateMain = t1.backend.get$isolateHelperLibrary().find$1(0, "startRootIsolate");
        mainAccess = C.C_JsBuilder.call$2("#.#()", [t2.globalObjectFor$1(main), t2.getStaticClosureName$1(main)]);
        mainCallClosure = C.C_JsBuilder.call$2("function(a){ #(#, a); }", [t2.elementAccess$1(isolateMain), mainAccess]);
      } else
        mainCallClosure = t2.elementAccess$1(main);
      if (t1.backend.get$needToInitializeIsolateAffinityTag()) {
        buffer.write$1(Q.prettyPrint(C.C_JsBuilder.call$1("      !function() {\n        // On V8, the 'intern' function converts a string to a symbol, which\n        // makes property access much faster.\n        function intern(s) {\n          var o = {};\n          o[s] = 1;\n          return Object.keys(convertToFastObject(o))[0];\n        }\n\n        init.getIsolateTag = function(name) {\n          return intern(\"___dart_\" + name + init.isolateTag);\n        };\n\n        // To ensure that different programs loaded into the same context (page)\n        // use distinct dispatch properies, we place an object on `Object` to\n        // contain the names already in use.\n        var tableProperty = \"___dart_isolate_tags_\";\n        var usedProperties = Object[tableProperty] ||\n            (Object[tableProperty] = Object.create(null));\n\n        var rootProperty = \"_ZxYxX\";\n        for (var i = 0; ; i++) {\n          var property = intern(rootProperty + \"_\" + i + \"_\");\n          if (!(property in usedProperties)) {\n            usedProperties[property] = 1;\n            init.isolateTag = property;\n            break;\n          }\n        }\n      }()\n    "), t1, true, t1.dumpInfoTask));
        buffer.write$1(t1.enableMinification ? "\n" : ";\n");
      }
      if (t1.backend.get$needToInitializeDispatchProperty()) {
        buffer.write$1(Q.prettyPrint(C.C_JsBuilder.call$1("init.dispatchPropertyName = init.getIsolateTag(\"dispatch_record\")"), t1, true, t1.dumpInfoTask));
        buffer.write$1(t1.enableMinification ? "\n" : ";\n");
      }
      buffer.write$1(Q.prettyPrint(new Q.Comment("BEGIN invoke [main].", null, null), t1, true, null));
      t2 = t1.enableMinification;
      invokeMain = C.C_JsBuilder.statement$2("(function (callback) {\n  if (typeof document === \"undefined\") {\n    callback(null);\n    return;\n  }\n  if (document.currentScript) {\n    callback(document.currentScript);\n    return;\n  }\n\n  var scripts = document.scripts;\n  function onLoad(event) {\n    for (var i = 0; i < scripts.length; ++i) {\n      scripts[i].removeEventListener(\"load\", onLoad, false);\n    }\n    callback(event.target);\n  }\n  for (var i = 0; i < scripts.length; ++i) {\n    scripts[i].addEventListener(\"load\", onLoad, false);\n  }\n})(function(currentScript) {\n  init.currentScript = currentScript;\n\n  if (typeof dartMainRunner === \"function\") {\n    dartMainRunner(#, []);\n  } else {\n    #([]);\n  }\n})" + (t2 ? "\n" : ";\n"), [mainCallClosure, mainCallClosure]);
      buffer.write$1(";");
      buffer.write$1(Q.prettyPrint(invokeMain, t1, true, t1.dumpInfoTask));
      buffer.write$1(t2 ? "\n" : ";\n");
      buffer.write$1(Q.prettyPrint(new Q.Comment("END invoke [main].", null, null), t1, true, null));
    },
    computeNeededConstants$0: function() {
      var t1, handler, constants, t2, constant, constantUnit;
      t1 = this.compiler;
      handler = t1.backend.get$constantCompilerTask().jsConstantCompiler;
      constants = handler.getConstantsForEmission$1(t1.hasIncrementalSupport ? null : this.get$compareConstants());
      for (t2 = H.setRuntimeTypeInfo(new H.ListIterator(constants, constants.length, 0, null), [H.getTypeArgumentByIndex(constants, 0)]); t2.moveNext$0();) {
        constant = t2.__internal$_current;
        if (this.isConstantInlinedOrAlreadyEmitted$1(constant))
          continue;
        constantUnit = t1.deferredLoadTask.outputUnitForConstant$1(constant);
        if (constantUnit == null)
          constantUnit = t1.deferredLoadTask.mainOutputUnit;
        J.add$1$ax(this.outputConstantLists.putIfAbsent$2(constantUnit, new K.CodeEmitterTask_computeNeededConstants_closure()), constant);
      }
    },
    computeNeededDeclarations$0: function() {
      var t1, t2, t3, mixinClasses, noSuchMethodSelector, element, member, sortedClasses, t4, t5;
      t1 = this.compiler;
      t2 = t1.world.allTypedefs;
      t2 = H.setRuntimeTypeInfo(new H.WhereIterable(t2, t1.backend.get$isAccessibleByReflection()), [H.getTypeArgumentByIndex(t2, 0)]);
      t2 = C.JSArray_methods.toList$0(P.List_List$from(t2, true, H.getRuntimeTypeArgument(t2, "IterableBase", 0)));
      H.IterableMixinWorkaround_sortList(t2, O.Elements_compareByPosition$closure());
      this.typedefsNeededForReflection = t2;
      t2 = t1.enqueuer.codegen.universe.instantiatedClasses;
      t2 = H.setRuntimeTypeInfo(new H.WhereIterable(t2, this.computeClassFilter$0()), [H.getTypeArgumentByIndex(t2, 0)]);
      t3 = P.LinkedHashSet_LinkedHashSet(null, null, null, H.getRuntimeTypeArgument(t2, "IterableBase", 0));
      t3.addAll$1(0, t2);
      this.instantiatedClasses = t3;
      new K.CodeEmitterTask_computeNeededDeclarations_addClassesWithSuperclasses(new K.CodeEmitterTask_computeNeededDeclarations_addClassWithSuperclasses(this)).call$1(t3);
      t3 = this.neededClasses;
      t2 = H.setRuntimeTypeInfo(new H.WhereIterable(t3, new K.CodeEmitterTask_computeNeededDeclarations_closure()), [H.getTypeArgumentByIndex(t3, 0)]);
      t2 = H.MappedIterable_MappedIterable(t2, K.computeMixinClass$closure(), H.getRuntimeTypeArgument(t2, "IterableBase", 0), null);
      mixinClasses = P.LinkedHashSet_LinkedHashSet(null, null, null, H.getRuntimeTypeArgument(t2, "IterableBase", 0));
      mixinClasses.addAll$1(0, t2);
      t3.addAll$1(0, mixinClasses);
      if (t1.enabledNoSuchMethod) {
        noSuchMethodSelector = t1.noSuchMethodSelector;
        for (t2 = H.setRuntimeTypeInfo(new P.LinkedHashSetIterator(t3, t3._modifications, null, null), [null]), t2._cell = t2._set._first; t2.moveNext$0();) {
          element = t2._collection$_current;
          if (!element.get$isNative())
            continue;
          member = element.lookupLocalMember$1("noSuchMethod");
          if (member == null)
            continue;
          if (noSuchMethodSelector.applies$2(member, t1)) {
            this.nativeEmitter.handleNoSuchMethod = true;
            break;
          }
        }
      }
      t2 = this.typeTestEmitter;
      t2.computeRtiNeededClasses$0();
      t2 = t2.rtiNeededClasses;
      t2.removeAll$1(t3);
      t3.addAll$1(0, t2);
      if (t3.contains$1(0, t1.backend.get$jsIntClass()))
        t3.add$1(0, t1.intClass);
      if (t3.contains$1(0, t1.backend.get$jsDoubleClass()))
        t3.add$1(0, t1.doubleClass);
      if (t3.contains$1(0, t1.backend.get$jsNumberClass()))
        t3.add$1(0, t1.numClass);
      if (t3.contains$1(0, t1.backend.get$jsStringClass()))
        t3.add$1(0, t1.stringClass);
      if (t3.contains$1(0, t1.backend.get$jsBoolClass()))
        t3.add$1(0, t1.boolClass);
      if (t3.contains$1(0, t1.backend.get$jsArrayClass()))
        t3.add$1(0, t1.listClass);
      sortedClasses = t3.toList$0(0);
      H.IterableMixinWorkaround_sortList(sortedClasses, O.Elements_compareByPosition$closure());
      for (t3 = H.setRuntimeTypeInfo(new H.ListIterator(sortedClasses, sortedClasses.length, 0, null), [H.getTypeArgumentByIndex(sortedClasses, 0)]), t4 = this.outputClassLists, t5 = this.nativeClasses; t3.moveNext$0();) {
        element = t3.__internal$_current;
        if (t2.contains$1(0, element))
          J.add$1$ax(t4.putIfAbsent$2(t1.deferredLoadTask.mainOutputUnit, new K.CodeEmitterTask_computeNeededDeclarations_closure0()), element);
        else if (O.Elements_isNativeOrExtendsNative(element)) {
          t5.push(element);
          if (!element.get$isNative())
            J.add$1$ax(t4.putIfAbsent$2(t1.deferredLoadTask.mainOutputUnit, new K.CodeEmitterTask_computeNeededDeclarations_closure1()), element);
        } else
          J.add$1$ax(t4.putIfAbsent$2(t1.deferredLoadTask.outputUnitForElement$1(element), new K.CodeEmitterTask_computeNeededDeclarations_closure2()), element);
      }
    },
    writeLibraryDescriptors$2: function(library, libraryDescriptorBuffers) {
      var t1, t2, uri, descriptors, libraryName, t3, t4, t5, outputUnit, descriptor, metadata, initializers, libraryDescriptorBuffer, t6, printer;
      t1 = this.compiler;
      t2 = t1.enableMinification;
      if (!t2 || t1.backend.get$mustRetainUris()) {
        uri = library.get$canonicalUri();
        if (uri.scheme === "file" && t1.outputUri != null)
          uri = X.relativize(t1.outputUri, library.canonicalUri, false);
      } else
        uri = "";
      descriptors = this.elementDescriptors.$index(0, library);
      libraryName = !t2 || t1.backend.get$mustRetainLibraryNames() ? library.getLibraryName$0() : "";
      t3 = t1.deferredLoadTask.allOutputUnits;
      t4 = new P.LinkedHashSetIterator(t3, t3._modifications, null, null);
      t4.$builtinTypeInfo = [null];
      t4._cell = t3._first;
      t3 = this.namer;
      t5 = this.metadataEmitter;
      for (; t4.moveNext$0();) {
        outputUnit = t4._collection$_current;
        if (descriptors.containsKey$1(outputUnit) !== true)
          continue;
        descriptor = descriptors.$index(0, outputUnit);
        metadata = t5.buildMetadataFunction$1(library);
        initializers = descriptor.toObjectInitializer$0();
        libraryDescriptorBuffer = libraryDescriptorBuffers.putIfAbsent$2(outputUnit, new K.CodeEmitterTask_writeLibraryDescriptors_closure());
        t1.dumpInfoTask.registerElementAst$2(library, metadata);
        t1.dumpInfoTask.registerElementAst$2(library, initializers);
        t6 = "[\"" + libraryName + "\",";
        libraryDescriptorBuffer.write$1(t6 + (t2 ? "" : " "));
        t6 = "\"" + H.S(uri) + "\",";
        libraryDescriptorBuffer.write$1(t6 + (t2 ? "" : " "));
        if (metadata == null)
          t6 = "";
        else {
          printer = Q.Printer$(t1, t1.dumpInfoTask, true);
          printer.visit$1(metadata);
          t6 = printer.outBuffer;
        }
        libraryDescriptorBuffer.write$1(t6);
        libraryDescriptorBuffer.write$1("," + (t2 ? "" : " "));
        libraryDescriptorBuffer.write$1(t3.globalObjectFor$1(library));
        libraryDescriptorBuffer.write$1("," + (t2 ? "" : " "));
        printer = Q.Printer$(t1, t1.dumpInfoTask, true);
        printer.visit$1(initializers);
        libraryDescriptorBuffer.write$1(printer.outBuffer);
        t6 = t1.mainApp;
        if (library == null ? t6 == null : library === t6)
          t6 = "," + (t2 ? "" : "\n") + "1";
        else
          t6 = "";
        libraryDescriptorBuffer.write$1(t6);
        libraryDescriptorBuffer.write$1("]," + (t2 ? "" : "\n"));
      }
    },
    emitPrecompiledConstructor$2: function(constructorName, constructorAst) {
      var t1 = this.precompiledFunction;
      t1.push(new Q.FunctionDeclaration(new Q.VariableDeclaration(constructorName, null, null), constructorAst, null, null));
      t1.push(C.C_JsBuilder.statement$2("{\n          #.builtin$cls = #;\n          if (!\"name\" in #)\n              #.name = #;\n          $desc=$collectedClasses.#;\n          if ($desc instanceof Array) $desc = $desc[1];\n          #.prototype = $desc;\n        }", [constructorName, new Q.LiteralString0("\"" + H.S(constructorName) + "\"", null, null), constructorName, constructorName, new Q.LiteralString0("\"" + H.S(constructorName) + "\"", null, null), constructorName, constructorName]));
      this.precompiledConstructorNames.push(C.C_JsBuilder.call$2("#", constructorName));
    },
    assembleProgram$0: function() {
      this.measure$1(new K.CodeEmitterTask_assembleProgram_closure(this));
    },
    generateSourceMapTag$2: function(sourceMapUri, fileUri) {
      if (sourceMapUri != null && fileUri != null)
        return "\n//# sourceMappingURL=" + X.relativize(fileUri, sourceMapUri, false) + "\n";
      return "";
    },
    getElementDescriptorForOutputUnit$2: function(element, outputUnit) {
      return this.elementDescriptors.putIfAbsent$2(element, new K.CodeEmitterTask_getElementDescriptorForOutputUnit_closure()).putIfAbsent$2(outputUnit, new K.CodeEmitterTask_getElementDescriptorForOutputUnit_closure0(this, element));
    },
    getElementDescriptor$1: function(element) {
      var owner, cls;
      owner = element.get$library();
      if (!element.get$isTopLevel() && !element.get$isNative()) {
        cls = element.get$enclosingClassOrCompilationUnit().get$declaration();
        if (this.compiler.enqueuer.codegen.universe.instantiatedClasses.contains$1(0, cls) && !cls.get$isNative())
          owner = cls;
      }
      if (owner == null)
        this.compiler.internalError$2(element, "Owner is null.");
      return this.getElementDescriptorForOutputUnit$2(owner, this.compiler.deferredLoadTask.outputUnitForElement$1(element));
    },
    emitDeferredCode$1: function(libraryDescriptorBuffers) {
      var t1, t2, t3, t4, t5, t6, t7, t8, t9, outputUnit, libraryDescriptorBuffer, t10, t11, outputBuffer, oldClassesCollector, printer, code;
      for (t1 = this.compiler, t2 = t1.deferredLoadTask.allOutputUnits, t2 = H.setRuntimeTypeInfo(new P.LinkedHashSetIterator(t2, t2._modifications, null, null), [null]), t2._cell = t2._set._first, t3 = this.typeTestEmitter, t4 = t1.buildId, t5 = t4 !== "build number could not be determined", t6 = t1.enableMinification, t7 = this.namer, t8 = t7.currentIsolate, t9 = this.outputClassLists; t2.moveNext$0();) {
        outputUnit = t2._collection$_current;
        if (J.$eq(outputUnit, t1.deferredLoadTask.mainOutputUnit))
          continue;
        libraryDescriptorBuffer = libraryDescriptorBuffers.$index(0, outputUnit);
        t10 = new P.StringBuffer("");
        t10._contents = "";
        t11 = [];
        t11.$builtinTypeInfo = [K.CodeBufferMarker];
        outputBuffer = new K.CodeBuffer(t10, t11, 0, 0);
        oldClassesCollector = this.classesCollector;
        this.classesCollector = "$$";
        outputBuffer.write$1("// Generated by dart2js, the Dart to JavaScript compiler" + (t5 ? " version: " + H.S(t4) : "") + ".\n");
        if (libraryDescriptorBuffer != null) {
          t10 = "var old" + t8;
          t10 = t10 + (t6 ? "" : " ") + "=";
          t10 = t10 + (t6 ? "" : " ") + t8;
          t10 = t10 + (t6 ? "\n" : ";\n") + t8;
          t10 = t10 + (t6 ? "" : " ") + "=";
          t10 = t10 + (t6 ? "" : " ") + t7.get$isolateName() + ".prototype";
          t10 += t6 ? "\n" : ";\n";
          t10 = t10 + (t6 ? "" : "\n") + H.S(this.classesCollector);
          t10 = t10 + (t6 ? "" : " ") + "=";
          t10 = t10 + (t6 ? "" : " ") + "{};";
          outputBuffer.write$1(t10 + (t6 ? "" : "\n"));
          outputBuffer.write$1("(");
          t10 = K.getReflectionDataParser(this.classesCollector, t1.backend);
          printer = Q.Printer$(t1, t1.dumpInfoTask, true);
          printer.visit$1(t10);
          outputBuffer.write$1(printer.outBuffer);
          outputBuffer.write$1(")");
          outputBuffer.write$1("([" + (t6 ? "" : "\n"));
          outputBuffer.addBuffer$1(libraryDescriptorBuffer);
          outputBuffer.write$1("])" + (t6 ? "\n" : ";\n"));
          if (t9.containsKey$1(outputUnit)) {
            t10 = t7.get$isolateName() + ".$finishClasses(" + H.S(this.classesCollector) + ",";
            t10 = t10 + (t6 ? "" : " ") + t8 + ",";
            t10 = t10 + (t6 ? "" : " ") + (t7.get$isolateName() + "." + t7.get$isolatePropertiesName()) + ")";
            outputBuffer.write$1(t10 + (t6 ? "\n" : ";\n"));
          }
          t10 = H.S(this.classesCollector);
          t10 = t10 + (t6 ? "" : " ") + "=";
          t10 = t10 + (t6 ? "" : " ") + "null";
          t10 += t6 ? "\n" : ";\n";
          t10 = t10 + (t6 ? "" : "\n") + t8;
          t10 = t10 + (t6 ? "" : " ") + "=";
          t10 = t10 + (t6 ? "" : " ") + "old" + t8;
          outputBuffer.write$1(t10 + (t6 ? "\n" : ";\n"));
        }
        this.classesCollector = oldClassesCollector;
        t3.emitRuntimeTypeSupport$2(outputBuffer, outputUnit);
        this.emitCompileTimeConstants$2(outputBuffer, outputUnit);
        code = outputBuffer.buffer._contents;
        this.outputBuffers.$indexSet(0, outputUnit, outputBuffer);
        t10 = t1.outputProvider$2(outputUnit.partFileName$1(t1), "part.js");
        t11 = J.getInterceptor$ax(t10);
        t11.add$1(t10, code);
        t11.close$0(t10);
      }
    },
    buildGeneratedBy$0: function() {
      var t1 = this.compiler.buildId;
      return "// Generated by dart2js, the Dart to JavaScript compiler" + (t1 !== "build number could not be determined" ? " version: " + H.S(t1) : "") + ".\n";
    },
    outputSourceMap$5: function(code, buffer, $name, sourceMapUri, fileUri) {
      var compiledFile, sourceMapBuilder, sourceMap, t1, t2;
      if (!this.generateSourceMap)
        return;
      compiledFile = new A.StringSourceFile(code, null, null);
      sourceMapBuilder = new T.SourceMapBuilder(sourceMapUri, fileUri, compiledFile, null, null, null, null, null, null, null, null, null, null, null, null);
      sourceMapBuilder.SourceMapBuilder$3(sourceMapUri, fileUri, compiledFile);
      buffer.forEachSourceLocation$1(sourceMapBuilder.get$addMapping());
      sourceMap = sourceMapBuilder.build$0();
      t1 = this.compiler.outputProvider$2($name, "js.map");
      t2 = J.getInterceptor$ax(t1);
      t2.add$1(t1, sourceMap);
      t2.close$0(t1);
    },
    invalidateCaches$0: function() {
      var t1, t2, element;
      t1 = this.compiler;
      if (!t1.hasIncrementalSupport)
        return;
      if (this.cachedElements._collection$_length === 0)
        return;
      for (t1 = t1.enqueuer.codegen.newlyEnqueuedElements, t1 = H.setRuntimeTypeInfo(new P.HashSetIterator(t1, t1._computeElements$0(), 0, null), [H.getTypeArgumentByIndex(t1, 0)]), t2 = this.cachedClassBuilders; t1.moveNext$0();) {
        element = t1._collection$_current;
        if (element.get$isInstanceMember()) {
          t2.remove$1(0, element.get$enclosingClass());
          this.nativeEmitter.cachedBuilders.remove$1(0, element.get$enclosingClass());
        }
      }
    },
    CodeEmitterTask$3: function(compiler, namer, generateSourceMap) {
      var t1, t2, t3, t4, t5, t6, t7;
      t1 = P.LinkedHashSet_LinkedHashSet(null, null, null, O.ClassElement);
      t2 = P.LinkedHashMap_LinkedHashMap(null, null, null, O.ClassElement, [P.List, O.ClassElement]);
      t3 = P.LinkedHashMap_LinkedHashMap(null, null, null, O.ClassElement, [P.List, O.ClassElement]);
      t4 = P.LinkedHashSet_LinkedHashSet(null, null, null, O.FunctionElement);
      t5 = P.StringBuffer$("");
      t6 = H.setRuntimeTypeInfo([], [K.CodeBufferMarker]);
      t7 = this.compiler.cacheStrategy.hasIncrementalSupport ? H.setRuntimeTypeInfo(new P._IdentityHashMap(0, null, null, null, null), [null, null]) : null;
      this.nativeEmitter = new Z.NativeEmitter(t7, this, new K.CodeBuffer(t5, t6, 0, 0), t1, t2, t3, t4, false);
      this.containerBuilder.task = this;
      this.classEmitter.task = this;
      this.nsmEmitter.task = this;
      this.typeTestEmitter.task = this;
      this.interceptorEmitter.task = this;
      this.metadataEmitter.task = this;
      t4 = $.get$templateManager();
      t4.expressionTemplates.clear$0(0);
      t4.statementTemplates.clear$0(0);
    }
  },
  CodeEmitterTask_getBuffer_closure: {
    "^": "Closure:23;",
    call$0: function() {
      return new K.CodeBuffer(P.StringBuffer$(""), H.setRuntimeTypeInfo([], [K.CodeBufferMarker]), 0, 0);
    },
    $isFunction: true
  },
  CodeEmitterTask_getReflectionNameInternal_closure: {
    "^": "Closure:23;box_0",
    call$0: function() {
      return this.box_0.name_0;
    },
    $isFunction: true
  },
  CodeEmitterTask_generateClass_closure: {
    "^": "Closure:23;this_0,classElement_1,properties_2",
    call$0: function() {
      var t1, t2, t3, builder;
      t1 = this.this_0;
      t2 = this.classElement_1;
      t3 = this.properties_2;
      if (t1.compiler.hasIncrementalSupport) {
        builder = t1.cachedClassBuilders.putIfAbsent$2(t2, new K.CodeEmitterTask_generateClass__closure(t1, t2));
        K.invariant(t2, builder.get$fields().length === 0, null);
        K.invariant(t2, builder.get$superName() == null, null);
        K.invariant(t2, builder.functionType == null, null);
        K.invariant(t2, builder.fieldMetadata == null, null);
        C.JSArray_methods.addAll$1(t3.properties, builder.properties);
      } else
        t1.classEmitter.generateClass$3(t2, t3, t1.additionalProperties.$index(0, t2));
    },
    $isFunction: true
  },
  CodeEmitterTask_generateClass__closure: {
    "^": "Closure:23;this_3,classElement_4",
    call$0: function() {
      var t1, t2, builder;
      t1 = this.classElement_4;
      t2 = this.this_3;
      builder = new K.ClassBuilder(H.setRuntimeTypeInfo([], [Q.Property]), H.setRuntimeTypeInfo([], [P.String]), null, null, null, t1, t2.namer, false);
      t2.classEmitter.generateClass$3(t1, builder, t2.additionalProperties.$index(0, t1));
      return builder;
    },
    $isFunction: true
  },
  CodeEmitterTask_computeClassFilter_closure: {
    "^": "Closure:87;",
    call$1: function(cls) {
      return true;
    },
    $isFunction: true
  },
  CodeEmitterTask_computeClassFilter_closure0: {
    "^": "Closure:110;needed_0",
    call$2: function(_, elements) {
      this.needed_0.addAll$1(0, elements);
    },
    $isFunction: true
  },
  CodeEmitterTask_computeClassFilter_closure1: {
    "^": "Closure:87;unneededClasses_1",
    call$1: function(cls) {
      return !this.unneededClasses_1.contains$1(0, cls);
    },
    $isFunction: true
  },
  CodeEmitterTask_emitStaticFunctions_isStaticFunction: {
    "^": "Closure:76;",
    call$1: function(element) {
      return !element.get$isInstanceMember() && element.kind !== C.ElementKind_field_1;
    },
    $isFunction: true
  },
  CodeEmitterTask_emitStaticNonFinalFieldInitializations_closure: {
    "^": "Closure:23;this_0,buffer_1,handler_2,element_3",
    call$0: function() {
      var t1, t2, initialValue, t3, t4, t5;
      t1 = this.handler_2;
      t2 = this.element_3;
      initialValue = t1.initialVariableValues.$index(0, t2.get$declaration());
      if (initialValue == null)
        t1.compiler.internalError$2(t2, "No initial value for given element.");
      t1 = this.this_0;
      t3 = H.S(t1.isolateProperties) + ".# = #";
      t2 = t1.namer.getNameX$1(t2);
      t4 = t1.constantEmitter._referenceEmitter;
      t4.toString;
      t5 = this.buffer_1;
      t1 = t1.compiler;
      t5.write$1(Q.prettyPrint(C.C_JsBuilder.call$2(t3, [t2, J.accept$1$x(initialValue, t4)]), t1, true, t1.dumpInfoTask));
      t5.write$1(t1.enableMinification ? "\n" : ";\n");
    },
    $isFunction: true
  },
  CodeEmitterTask_computeNeededConstants_closure: {
    "^": "Closure:23;",
    call$0: function() {
      return H.setRuntimeTypeInfo([], [K.Constant]);
    },
    $isFunction: true
  },
  CodeEmitterTask_computeNeededDeclarations_addClassWithSuperclasses: {
    "^": "Closure:45;this_0",
    call$1: function(cls) {
      var t1, superclass;
      t1 = this.this_0.neededClasses;
      t1.add$1(0, cls);
      for (superclass = cls.get$superclass(); superclass != null; superclass = superclass.get$superclass())
        t1.add$1(0, superclass);
    },
    $isFunction: true
  },
  CodeEmitterTask_computeNeededDeclarations_addClassesWithSuperclasses: {
    "^": "Closure:111;addClassWithSuperclasses_1",
    call$1: function(classes) {
      var t1, t2;
      for (t1 = H.setRuntimeTypeInfo(new P.LinkedHashSetIterator(classes, classes._modifications, null, null), [null]), t1._cell = t1._set._first, t2 = this.addClassWithSuperclasses_1; t1.moveNext$0();)
        t2.call$1(t1._collection$_current);
    },
    $isFunction: true
  },
  CodeEmitterTask_computeNeededDeclarations_closure: {
    "^": "Closure:87;",
    call$1: function(element) {
      return element.get$isMixinApplication();
    },
    $isFunction: true
  },
  CodeEmitterTask_computeNeededDeclarations_closure0: {
    "^": "Closure:23;",
    call$0: function() {
      return H.setRuntimeTypeInfo([], [O.ClassElement]);
    },
    $isFunction: true
  },
  CodeEmitterTask_computeNeededDeclarations_closure1: {
    "^": "Closure:23;",
    call$0: function() {
      return H.setRuntimeTypeInfo([], [O.ClassElement]);
    },
    $isFunction: true
  },
  CodeEmitterTask_computeNeededDeclarations_closure2: {
    "^": "Closure:23;",
    call$0: function() {
      return H.setRuntimeTypeInfo([], [O.ClassElement]);
    },
    $isFunction: true
  },
  CodeEmitterTask_writeLibraryDescriptors_closure: {
    "^": "Closure:23;",
    call$0: function() {
      return new K.CodeBuffer(P.StringBuffer$(""), H.setRuntimeTypeInfo([], [K.CodeBufferMarker]), 0, 0);
    },
    $isFunction: true
  },
  CodeEmitterTask_assembleProgram_closure: {
    "^": "Closure:23;this_0",
    call$0: function() {
      var t1, t2, t3, mainOutputUnit, t4, t5, t6, globalObject, t7, t8, t9, nativeBuffer, element, libraryDescriptorBuffers, oldClassesCollector, t10, t11, builder, initializer, typedef, mainUnit, library, typeReference, t12, mangledName, reflectionName, t13, t14, keys, properties, key, sortedElements, pendingStatics, loadId, outputUnits, outputUnit, isolate, debugCode, convertToFastObject, precompiledFunctionAst, assembledCode, sourceMapTags, cspBuffer;
      t1 = this.this_0;
      t1.invalidateCaches$0();
      t2 = t1.typeTestEmitter;
      t2.computeRequiredTypeChecks$0();
      t1.computeNeededDeclarations$0();
      t3 = t1.compiler;
      mainOutputUnit = t3.deferredLoadTask.mainOutputUnit;
      t1.getBuffer$1(mainOutputUnit).write$1(t1.buildGeneratedBy$0());
      t1.getBuffer$1(t3.deferredLoadTask.mainOutputUnit).write$1(Q.prettyPrint(new Q.Comment("// The code supports the following hooks:\n// dartPrint(message):\n//    if this function is defined it is called instead of the Dart [print]\n//    method.\n//\n// dartMainRunner(main, args):\n//    if this function is defined, the Dart [main] method will not be invoked\n//    directly. Instead, a closure that will invoke [main], and its arguments\n//    [args] is passed to [dartMainRunner].\n", null, null), t3, true, null));
      t4 = t3.deferredLoadTask;
      if (!t4.splitProgram) {
        t4 = t1.getBuffer$1(t4.mainOutputUnit);
        t5 = "(function(" + t1.namer.currentIsolate + ")";
        t6 = t3.enableMinification;
        t5 = t5 + (t6 ? "" : " ") + "{";
        t4.write$1(t5 + (t6 ? "" : "\n"));
      }
      t4 = t1.getBuffer$1(t3.deferredLoadTask.mainOutputUnit);
      t5 = t3.enableMinification;
      t6 = "function dart(){" + (t5 ? "" : " ") + "this.x";
      t6 = t6 + (t5 ? "" : " ") + "=";
      t6 = t6 + (t5 ? "" : " ") + "0";
      t4.write$1(t6 + (t5 ? "" : " ") + "}");
      for (t4 = H.setRuntimeTypeInfo(new H.ListIterator(C.List_69t, 25, 0, null), [H.getTypeArgumentByIndex(C.List_69t, 0)]); t4.moveNext$0();) {
        globalObject = t4.__internal$_current;
        t6 = t1.getBuffer$1(t3.deferredLoadTask.mainOutputUnit);
        t7 = "var " + H.S(globalObject);
        t7 = t7 + (t5 ? "" : " ") + "=";
        t7 = t7 + (t5 ? "" : " ") + "new dart";
        t6.write$1(t7 + (t5 ? "\n" : ";\n"));
        t7 = "delete " + H.S(globalObject) + ".x";
        t6.write$1(t7 + (t5 ? "\n" : ";\n"));
      }
      t4 = t1.getBuffer$1(t3.deferredLoadTask.mainOutputUnit);
      t6 = t1.namer;
      t7 = "function " + t6.get$isolateName() + "()";
      t4.write$1(t7 + (t5 ? "" : " ") + "{}\n");
      t4 = t1.getBuffer$1(t3.deferredLoadTask.mainOutputUnit);
      t7 = "init()" + (t5 ? "\n" : ";\n");
      t4.write$1(t7 + (t5 ? "" : "\n"));
      t4 = t6.currentIsolate;
      t1.isolateProperties = t4;
      t7 = t1.getBuffer$1(t3.deferredLoadTask.mainOutputUnit);
      t8 = H.S(t1.isolateProperties);
      t8 = t8 + (t5 ? "" : " ") + "=";
      t8 = t8 + (t5 ? "" : " ") + (t6.get$isolateName() + "." + t6.get$isolatePropertiesName());
      t7.write$1(t8 + (t5 ? "\n" : ";\n"));
      t1.emitStaticFunctions$0();
      t7 = t1.nativeClasses;
      if (t7.length === 0)
        if (t3.enqueuer.codegen.universe.staticFunctionsNeedingGetter._collection$_length === 0) {
          t8 = t1.outputClassLists;
          t8 = t8.get$values(t8).every$1(0, new K.CodeEmitterTask_assembleProgram__closure()) && t1.typedefsNeededForReflection.length === 0;
        } else
          t8 = false;
      else
        t8 = false;
      if (!t8) {
        t1.classesCollector = "$$";
        t8 = t1.getBuffer$1(t3.deferredLoadTask.mainOutputUnit);
        t9 = "var " + H.S(t1.classesCollector);
        t9 = t9 + (t5 ? "" : " ") + "=";
        t9 = t9 + (t5 ? "" : " ") + "{}";
        t9 += t5 ? "\n" : ";\n";
        t8.write$1(t9 + (t5 ? "" : "\n"));
      }
      nativeBuffer = new K.CodeBuffer(P.StringBuffer$(""), H.setRuntimeTypeInfo([], [K.CodeBufferMarker]), 0, 0);
      if (t7.length !== 0) {
        nativeBuffer.write$1(Q.prettyPrint(new Q.Comment("Native classes", null, null), t3, true, null));
        t1.getBuffer$1(t3.deferredLoadTask.mainOutputUnit).write$1(Q.prettyPrint(new Q.Comment("Native classes", null, null), t3, true, null));
        t1.nativeEmitter.generateNativeClasses$3(t7, t1.getBuffer$1(t3.deferredLoadTask.mainOutputUnit), t1.additionalProperties);
      }
      for (t7 = t1.outputClassLists, t7 = t7.get$values(t7), t7 = H.setRuntimeTypeInfo(new H.MappedIterator(null, J.get$iterator$ax(t7._iterable), t7._f), [H.getTypeArgumentByIndex(t7, 0), H.getTypeArgumentByIndex(t7, 1)]); t7.moveNext$0();)
        for (t8 = J.get$iterator$ax(t7.__internal$_current); t8.moveNext$0();) {
          element = t8.get$current();
          t1.generateClass$2(element, t1.getElementDescriptor$1(element));
        }
      t1.nativeEmitter.assembleCode$1(nativeBuffer);
      t1.classesCollector = "classesCollector should not be used from now on";
      libraryDescriptorBuffers = P.LinkedHashMap_LinkedHashMap(null, null, null, B.OutputUnit, K.CodeBuffer);
      t7 = t1.elementDescriptors;
      if (t7._collection$_length !== 0) {
        oldClassesCollector = t1.classesCollector;
        t1.classesCollector = "$$";
        if (t5)
          t1.getBuffer$1(t3.deferredLoadTask.mainOutputUnit).write$1(";");
        for (t8 = H.setRuntimeTypeInfo(new P.LinkedHashMapKeyIterable(t7), [H.getTypeArgumentByIndex(t7, 0)]), t9 = t8._map, t8 = H.setRuntimeTypeInfo(new P.LinkedHashMapKeyIterator(t9, t9._modifications, null, null), [H.getTypeArgumentByIndex(t8, 0)]), t8._cell = t8._map._first, t9 = t1.classEmitter; t8.moveNext$0();) {
          element = t8._collection$_current;
          if (J.get$kind$x(element) === C.ElementKind_library_0) {
            t10 = [];
            t10.$builtinTypeInfo = [Q.Property];
            t11 = [];
            t11.$builtinTypeInfo = [P.String];
            builder = new K.ClassBuilder(t10, t11, null, null, null, element, t6, false);
            if (t9.emitFields$4$emitStatics(element, builder, null, true)) {
              initializer = builder.toObjectInitializer$0();
              t3.dumpInfoTask.registerElementAst$2(element, initializer);
              C.JSArray_methods.addAll$1(t1.getElementDescriptorForOutputUnit$2(element, mainOutputUnit).properties, initializer.properties);
            }
          }
        }
        for (t8 = t1.typedefsNeededForReflection, t8 = H.setRuntimeTypeInfo(new H.ListIterator(t8, t8.length, 0, null), [H.getTypeArgumentByIndex(t8, 0)]), t9 = t1.metadataEmitter, t10 = t6.classDescriptorProperty; t8.moveNext$0();) {
          typedef = t8.__internal$_current;
          mainUnit = t3.deferredLoadTask.mainOutputUnit;
          library = typedef.get$library();
          typeReference = ":" + H.S(t9.reifyType$1(typedef.get$alias())) + ";";
          t11 = "\"" + t10 + "\"";
          t12 = "\"" + typeReference + "\"";
          mangledName = t6.getNameX$1(typedef);
          reflectionName = t1.getReflectionName$2(typedef, mangledName);
          t13 = t1.getElementDescriptorForOutputUnit$2(library, mainUnit);
          t13.toString;
          t14 = "\"" + H.S(mangledName) + "\"";
          t13 = t13.properties;
          t13.push(new Q.Property(new Q.LiteralString0(t14, null, null), new Q.ObjectInitializer([new Q.Property(new Q.LiteralString0(t11, null, null), new Q.LiteralString0(t12, null, null), null, null)], true, null, null), null, null));
          t13.push(new Q.Property(new Q.LiteralString0("\"" + ("+" + H.S(reflectionName)) + "\"", null, null), new Q.LiteralString0("\"\"", null, null), null, null));
          t1.emitPrecompiledConstructor$2(mangledName, C.C_JsBuilder.call$1("function() {}"));
        }
        t8 = t1.mangledFieldNames;
        if (!t8.get$isEmpty(t8)) {
          keys = t8.get$keys().toList$0(0);
          H.IterableMixinWorkaround_sortList(keys, null);
          properties = [];
          for (t9 = H.setRuntimeTypeInfo(new H.ListIterator(keys, keys.length, 0, null), [H.getTypeArgumentByIndex(keys, 0)]); t9.moveNext$0();) {
            key = t9.__internal$_current;
            t10 = "\"" + H.S(t8.$index(0, key)) + "\"";
            properties.push(new Q.Property(new Q.LiteralString0("\"" + H.S(key) + "\"", null, null), new Q.LiteralString0(t10, null, null), null, null));
          }
          t1.getBuffer$1(t3.deferredLoadTask.mainOutputUnit).write$1(Q.prettyPrint(C.C_JsBuilder.statement$2("init.mangledNames = #", new Q.ObjectInitializer(properties, true, null, null)), t3, true, t3.dumpInfoTask));
          if (t5)
            t1.getBuffer$1(t3.deferredLoadTask.mainOutputUnit).write$1(";");
        }
        t8 = t1.mangledGlobalFieldNames;
        if (!t8.get$isEmpty(t8)) {
          keys = t8.get$keys().toList$0(0);
          H.IterableMixinWorkaround_sortList(keys, null);
          properties = [];
          for (t9 = H.setRuntimeTypeInfo(new H.ListIterator(keys, keys.length, 0, null), [H.getTypeArgumentByIndex(keys, 0)]); t9.moveNext$0();) {
            key = t9.__internal$_current;
            t10 = "\"" + H.S(t8.$index(0, key)) + "\"";
            properties.push(new Q.Property(new Q.LiteralString0("\"" + H.S(key) + "\"", null, null), new Q.LiteralString0(t10, null, null), null, null));
          }
          t1.getBuffer$1(t3.deferredLoadTask.mainOutputUnit).write$1(Q.prettyPrint(C.C_JsBuilder.statement$2("init.mangledGlobalNames = #", new Q.ObjectInitializer(properties, true, null, null)), t3, true, t3.dumpInfoTask));
          if (t5)
            t1.getBuffer$1(t3.deferredLoadTask.mainOutputUnit).write$1(";");
        }
        sortedElements = H.setRuntimeTypeInfo(new P.LinkedHashMapKeyIterable(t7), [H.getTypeArgumentByIndex(t7, 0)]).toList$0(0);
        H.IterableMixinWorkaround_sortList(sortedElements, O.Elements_compareByPosition$closure());
        if (!t3.hasIncrementalSupport) {
          pendingStatics = H.setRuntimeTypeInfo(new H.WhereIterable(sortedElements, new K.CodeEmitterTask_assembleProgram__closure0(t1)), [H.getTypeArgumentByIndex(H.setRuntimeTypeInfo(new H.IterableMixinWorkaround(), [H.getTypeArgumentByIndex(sortedElements, 0)]), 0)]);
          pendingStatics.forEach$1(0, new K.CodeEmitterTask_assembleProgram__closure1(t1));
        } else
          pendingStatics = null;
        for (t8 = H.setRuntimeTypeInfo(new H.WhereIterable(sortedElements, new K.CodeEmitterTask_assembleProgram__closure2()), [H.getTypeArgumentByIndex(H.setRuntimeTypeInfo(new H.IterableMixinWorkaround(), [H.getTypeArgumentByIndex(sortedElements, 0)]), 0)]), t8 = H.setRuntimeTypeInfo(new H.WhereIterator(J.get$iterator$ax(t8._iterable), t8._f), [H.getTypeArgumentByIndex(t8, 0)]), t9 = t8._iterator; t8.moveNext$0();) {
          library = t9.get$current();
          t1.writeLibraryDescriptors$2(library, libraryDescriptorBuffers);
          t7.$indexSet(0, library, C.Map_empty);
        }
        if (pendingStatics != null && pendingStatics.get$iterator(pendingStatics).moveNext$0())
          t3.internalError$2(pendingStatics.get$first(pendingStatics), "Pending statics (see above).");
        t7 = t1.getBuffer$1(t3.deferredLoadTask.mainOutputUnit);
        t7.write$1("(");
        t7.write$1(Q.prettyPrint(K.getReflectionDataParser(t1.classesCollector, t3.backend), t3, true, null));
        t7.write$1(")");
        t7.write$1("([" + (t5 ? "" : "\n"));
        t7.write$1(libraryDescriptorBuffers.$index(0, mainOutputUnit));
        t7.write$1("])" + (t5 ? "\n" : ";\n"));
        t7 = t1.getBuffer$1(t3.deferredLoadTask.mainOutputUnit);
        if (t1.needsDefineClass) {
          t8 = t6.get$isolateName() + ".$finishClasses(" + H.S(t1.classesCollector) + ",";
          t8 = t8 + (t5 ? "" : " ") + H.S(t1.isolateProperties) + ",";
          t8 = t8 + (t5 ? "" : " ") + "null)";
          t7.write$1(t8 + (t5 ? "\n" : ";\n"));
          t8 = H.S(t1.classesCollector);
          t8 = t8 + (t5 ? "" : " ") + "=";
          t8 = t8 + (t5 ? "" : " ") + "null";
          t8 += t5 ? "\n" : ";\n";
          t7.write$1(t8 + (t5 ? "" : "\n"));
        }
        t1.classesCollector = oldClassesCollector;
      }
      t2.emitRuntimeTypeSupport$2(t1.getBuffer$1(t3.deferredLoadTask.mainOutputUnit), mainOutputUnit);
      t2 = t1.interceptorEmitter;
      t2.emitGetInterceptorMethods$1(t1.getBuffer$1(t3.deferredLoadTask.mainOutputUnit));
      t2.emitOneShotInterceptors$1(t1.getBuffer$1(t3.deferredLoadTask.mainOutputUnit));
      t1.computeNeededConstants$0();
      t1.emitCompileTimeConstants$2(t1.getBuffer$1(t3.deferredLoadTask.mainOutputUnit), mainOutputUnit);
      t1.getBuffer$1(t3.deferredLoadTask.mainOutputUnit).write$1("$.libraries_to_load = {");
      for (t7 = t3.deferredLoadTask.hunksToLoad, t7 = H.setRuntimeTypeInfo(new P.LinkedHashMapKeyIterable(t7), [H.getTypeArgumentByIndex(t7, 0)]), t8 = t7._map, t7 = H.setRuntimeTypeInfo(new P.LinkedHashMapKeyIterator(t8, t8._modifications, null, null), [H.getTypeArgumentByIndex(t7, 0)]), t7._cell = t7._map._first; t7.moveNext$0();) {
        loadId = t7._collection$_current;
        t1.getBuffer$1(t3.deferredLoadTask.mainOutputUnit).write$1("\"" + H.S(loadId) + "\":[");
        for (t8 = J.get$iterator$ax(t3.deferredLoadTask.hunksToLoad.$index(0, loadId)); t8.moveNext$0();) {
          outputUnits = t8.get$current();
          t1.getBuffer$1(t3.deferredLoadTask.mainOutputUnit).write$1("[");
          for (t9 = J.get$iterator$ax(outputUnits); t9.moveNext$0();) {
            outputUnit = t9.get$current();
            t1.getBuffer$1(t3.deferredLoadTask.mainOutputUnit).write$1("\"" + outputUnit.partFileName$1(t3) + ".part.js\", ");
          }
          t1.getBuffer$1(t3.deferredLoadTask.mainOutputUnit).write$1("],");
        }
        t1.getBuffer$1(t3.deferredLoadTask.mainOutputUnit).write$1("],\n");
      }
      t7 = t1.getBuffer$1(t3.deferredLoadTask.mainOutputUnit);
      t7.write$1("}" + (t5 ? "\n" : ";\n"));
      t1.emitStaticNonFinalFieldInitializations$1(t1.getBuffer$1(t3.deferredLoadTask.mainOutputUnit));
      t2.emitInterceptedNames$1(t1.getBuffer$1(t3.deferredLoadTask.mainOutputUnit));
      t2.emitMapTypeToInterceptor$1(t1.getBuffer$1(t3.deferredLoadTask.mainOutputUnit));
      t1.emitLazilyInitializedStaticFields$1(t1.getBuffer$1(t3.deferredLoadTask.mainOutputUnit));
      t1.getBuffer$1(t3.deferredLoadTask.mainOutputUnit).write$1(nativeBuffer);
      t1.metadataEmitter.emitMetadata$1(t1.getBuffer$1(t3.deferredLoadTask.mainOutputUnit));
      t1.isolateProperties = t6.get$isolateName() + "." + t6.get$isolatePropertiesName();
      t2 = t1.getBuffer$1(t3.deferredLoadTask.mainOutputUnit);
      t7 = t4 + (t5 ? "" : " ") + "=";
      t7 = t7 + (t5 ? "" : " ") + "null";
      t2.write$1(t7 + (t5 ? "\n" : ";\n"));
      t2 = t1.getBuffer$1(t3.deferredLoadTask.mainOutputUnit);
      isolate = t6.get$isolateName();
      t7 = isolate + " = " + (t6.get$isolateName() + ".$finishIsolateConstructor") + "(" + isolate + ")";
      t2.write$1(t7 + (t5 ? "\n" : ";\n"));
      t2 = t1.getBuffer$1(t3.deferredLoadTask.mainOutputUnit);
      t4 = t4 + (t5 ? "" : " ") + "=";
      t4 = t4 + (t5 ? "" : " ") + "new " + t6.get$isolateName() + "()";
      t2.write$1(t4 + (t5 ? "\n" : ";\n"));
      debugCode = H.setRuntimeTypeInfo([], [Q.Statement]);
      convertToFastObject = C.C_JsBuilder.statement$2("      function convertToFastObject(properties) {\n        // Create an instance that uses 'properties' as prototype. This should\n        // make 'properties' a fast object.\n        function MyClass() {};\n        MyClass.prototype = properties;\n        new MyClass();\n        #;\n        return properties;\n      }", [debugCode]);
      t1.getBuffer$1(t3.deferredLoadTask.mainOutputUnit).write$1(Q.prettyPrint(convertToFastObject, t3, true, null));
      t2 = t1.getBuffer$1(t3.deferredLoadTask.mainOutputUnit);
      t2.write$1(t5 ? "\n" : ";\n");
      for (t2 = H.setRuntimeTypeInfo(new H.ListIterator(C.List_69t, 25, 0, null), [H.getTypeArgumentByIndex(C.List_69t, 0)]); t2.moveNext$0();) {
        globalObject = t2.__internal$_current;
        t4 = t1.getBuffer$1(t3.deferredLoadTask.mainOutputUnit);
        t7 = H.S(globalObject) + " = convertToFastObject(" + H.S(globalObject) + ")";
        t4.write$1(t7 + (t5 ? "\n" : ";\n"));
      }
      t2 = t1.precompiledConstructorNames;
      precompiledFunctionAst = C.C_JsBuilder.statement$2("      function dart_precompiled($collectedClasses) {\n        var $desc;\n        #;\n        return #;\n      }", [t1.precompiledFunction, new Q.ArrayInitializer(t2.length, Q.ArrayInitializer__convert(t2), null, null)]);
      t2 = t1.getBuffer$1(t3.deferredLoadTask.mainOutputUnit);
      t2.write$1(Q.prettyPrint(C.C_JsBuilder.statement$2("      function init() {\n        " + H.S(t1.isolateProperties) + " = {};\n        #; #; #;\n      }", [t1.buildDefineClassAndFinishClassFunctionsIfNecessary$0(), t1.buildLazyInitializerFunctionIfNecessary$0(), [C.C_JsBuilder.call$2(t6.get$isolateName() + ".$finishIsolateConstructor = #", C.C_JsBuilder.call$2("      function (oldIsolate) {\n        var isolateProperties = oldIsolate.#;\n        function Isolate() {\n          var hasOwnProperty = Object.prototype.hasOwnProperty;\n          for (var staticName in isolateProperties)\n            if (hasOwnProperty.call(isolateProperties, staticName))\n              this[staticName] = isolateProperties[staticName];\n          // Use the newly created object as prototype. In Chrome,\n          // this creates a hidden class for the object and makes\n          // sure it is fast to access.\n          function ForceEfficientMap() {}\n          ForceEfficientMap.prototype = this;\n          new ForceEfficientMap();\n        }\n        Isolate.prototype = oldIsolate.prototype;\n        Isolate.prototype.constructor = Isolate;\n        Isolate.# = isolateProperties;\n        if (#)\n          Isolate.# = oldIsolate.#;\n        if (#)\n          Isolate.# = oldIsolate.#;\n        return Isolate;\n      }", [t6.get$isolatePropertiesName(), t6.get$isolatePropertiesName(), t1.needsDefineClass, "$finishClasses", "$finishClasses", t1.hasMakeConstantList, t6.getMappedInstanceName$1("makeConstantList"), t6.getMappedInstanceName$1("makeConstantList")]))]]), t3, true, t3.dumpInfoTask).buffer._contents);
      if (t5)
        t2.write$1("\n");
      t1.emitMain$1(t1.getBuffer$1(t3.deferredLoadTask.mainOutputUnit));
      t2 = t3.deferredLoadTask;
      if (!t2.splitProgram)
        t1.getBuffer$1(t2.mainOutputUnit).write$1("})()\n");
      else
        t1.getBuffer$1(t2.mainOutputUnit).write$1("\n");
      t2 = t3.useContentSecurityPolicy;
      if (t2)
        t1.getBuffer$1(t3.deferredLoadTask.mainOutputUnit).write$1(Q.prettyPrint(precompiledFunctionAst, t3, false, t3.dumpInfoTask).buffer._contents);
      assembledCode = t1.getBuffer$1(t3.deferredLoadTask.mainOutputUnit).buffer._contents;
      if (t1.generateSourceMap) {
        t4 = t3.sourceMapUri;
        t5 = t3.outputUri;
        t1.outputSourceMap$5(assembledCode, t1.getBuffer$1(t3.deferredLoadTask.mainOutputUnit), "", t4, t5);
        sourceMapTags = t1.generateSourceMapTag$2(t4, t5);
      } else
        sourceMapTags = "";
      t1.getBuffer$1(t3.deferredLoadTask.mainOutputUnit).write$1(sourceMapTags);
      assembledCode = t1.getBuffer$1(t3.deferredLoadTask.mainOutputUnit).buffer._contents;
      t4 = t3.outputProvider$2("", "js");
      t5 = J.getInterceptor$ax(t4);
      t5.add$1(t4, assembledCode);
      t5.close$0(t4);
      t3.assembledCode = assembledCode;
      if (!t2) {
        cspBuffer = new K.CodeBuffer(P.StringBuffer$(""), H.setRuntimeTypeInfo([], [K.CodeBufferMarker]), 0, 0);
        cspBuffer.write$1(t1.getBuffer$1(t3.deferredLoadTask.mainOutputUnit));
        cspBuffer.write$1("{\n  var message =\n      'Deprecation: Automatic generation of output for Content Security\\n' +\n      'Policy is deprecated and will be removed with the next development\\n' +\n      'release. Use the --csp option to generate CSP restricted output.';\n  if (typeof dartPrint == \"function\") {\n    dartPrint(message);\n  } else if (typeof console == \"object\" && typeof console.log == \"function\") {\n    console.log(message);\n  } else if (typeof print == \"function\") {\n    print(message);\n  }\n}\n");
        cspBuffer.write$1(Q.prettyPrint(precompiledFunctionAst, t3, false, null).buffer._contents);
        t2 = t3.outputProvider$2("", "precompiled.js");
        t4 = J.getInterceptor$ax(t2);
        t4.add$1(t2, cspBuffer.buffer._contents);
        t4.close$0(t2);
      }
      t1.emitDeferredCode$1(libraryDescriptorBuffers);
      if (t3.backend.get$requiresPreamble() && !t3.backend.get$htmlLibraryIsLoaded())
        t3.reportDiagnosticInternal$4(C._SpannableSentinel_fBD, C.MessageKind_mdN, C.Map_empty, C.Diagnostic_4_hint);
    },
    $isFunction: true
  },
  CodeEmitterTask_assembleProgram__closure: {
    "^": "Closure:13;",
    call$1: function(classList) {
      return J.get$isEmpty$asx(classList);
    },
    $isFunction: true
  },
  CodeEmitterTask_assembleProgram__closure0: {
    "^": "Closure:13;this_1",
    call$1: function(element) {
      return !element.get$isLibrary() && J.any$1$ax(J.get$values$x(this.this_1.elementDescriptors.$index(0, element)), new K.CodeEmitterTask_assembleProgram___closure()) === true;
    },
    $isFunction: true
  },
  CodeEmitterTask_assembleProgram___closure: {
    "^": "Closure:13;",
    call$1: function(descriptor) {
      return descriptor != null;
    },
    $isFunction: true
  },
  CodeEmitterTask_assembleProgram__closure1: {
    "^": "Closure:13;this_2",
    call$1: function(element) {
      this.this_2.compiler.reportDiagnosticInternal$4(element, C.MessageKind_wwi, P.LinkedHashMap_LinkedHashMap$_literal(["text", "Pending statics."], null, null), C.Diagnostic_8_info);
      return;
    },
    $isFunction: true
  },
  CodeEmitterTask_assembleProgram__closure2: {
    "^": "Closure:13;",
    call$1: function(element) {
      return element.get$isLibrary();
    },
    $isFunction: true
  },
  CodeEmitterTask_getElementDescriptorForOutputUnit_closure: {
    "^": "Closure:23;",
    call$0: function() {
      return P.LinkedHashMap_LinkedHashMap(null, null, null, B.OutputUnit, K.ClassBuilder);
    },
    $isFunction: true
  },
  CodeEmitterTask_getElementDescriptorForOutputUnit_closure0: {
    "^": "Closure:23;this_0,element_1",
    call$0: function() {
      return new K.ClassBuilder(H.setRuntimeTypeInfo([], [Q.Property]), H.setRuntimeTypeInfo([], [P.String]), null, null, null, this.element_1, this.this_0.namer, false);
    },
    $isFunction: true
  },
  ContainerBuilder: {
    "^": "CodeEmitterHelper;staticGetters,methodClosures,task",
    addParameterStub$4: function(member, selector, addStub, alreadyGenerated) {
      var t1, parameters, t2, t3, positionalArgumentCount, handler, names, invocationName, isInterceptedMethod, extraArgumentCount, parametersBuffer, argumentsBuffer, optionalParameterStart, statements, target, receiver, $arguments, body, superClass, methodName, $name;
      t1 = {};
      parameters = member.get$functionSignature();
      t2 = selector.argumentCount;
      t3 = selector.namedArguments;
      positionalArgumentCount = t2 - t3.length;
      if (positionalArgumentCount === parameters.get$parameterCount())
        return;
      if (parameters.optionalParametersAreNamed && t3.length === parameters.optionalParameterCount)
        return;
      handler = this.task.compiler.backend.get$constantCompilerTask().jsConstantCompiler;
      names = selector.getOrderedNamedArguments$0();
      invocationName = this.task.namer.invocationName$1(selector);
      if (alreadyGenerated.contains$1(0, invocationName))
        return;
      alreadyGenerated.add$1(0, invocationName);
      isInterceptedMethod = this.task.compiler.backend.isInterceptedMethod$1(member);
      extraArgumentCount = isInterceptedMethod ? 1 : 0;
      parametersBuffer = Array(t2 + extraArgumentCount);
      parametersBuffer.fixed$length = init;
      parametersBuffer.$builtinTypeInfo = [Q.Parameter];
      t2 = parameters.requiredParameterCount + parameters.optionalParameterCount + extraArgumentCount;
      argumentsBuffer = Array(t2);
      argumentsBuffer.fixed$length = init;
      argumentsBuffer.$builtinTypeInfo = [Q.Expression];
      t1.count_0 = 0;
      if (isInterceptedMethod) {
        t1.count_0 = 1;
        parametersBuffer[0] = new Q.Parameter("$receiver", null, null);
        t3 = C.C_JsBuilder.call$2("#", "$receiver");
        if (0 >= t2)
          return H.ioore(argumentsBuffer, 0);
        argumentsBuffer[0] = t3;
        this.task.interceptorEmitter.interceptorInvocationNames.add$1(0, invocationName);
      }
      optionalParameterStart = positionalArgumentCount + extraArgumentCount;
      t1.indexOfLastOptionalArgumentInParameters_1 = optionalParameterStart - 1;
      t3 = new K.ContainerBuilder_addParameterStub_closure(t1, this, handler, names, "$receiver", parametersBuffer, argumentsBuffer, optionalParameterStart);
      parameters.forEachRequiredParameter$1(t3);
      H.IterableMixinWorkaround_forEach(parameters.orderedOptionalParameters, t3);
      if (member._fixedBackendName != null) {
        t3 = this.task.nativeEmitter;
        t1 = t1.indexOfLastOptionalArgumentInParameters_1;
        t3.toString;
        member.get$enclosingClass();
        statements = [];
        statements.$builtinTypeInfo = [Q.Statement];
        t3.potentiallyConvertDartClosuresToJs$3(statements, member, parametersBuffer);
        target = member._fixedBackendName;
        ++t1;
        if (isInterceptedMethod) {
          if (0 >= t2)
            return H.ioore(argumentsBuffer, 0);
          receiver = argumentsBuffer[0];
          $arguments = C.JSArray_methods.sublist$2(argumentsBuffer, 1, t1);
        } else {
          receiver = C.C_JsBuilder.call$1("this");
          $arguments = C.JSArray_methods.sublist$2(argumentsBuffer, 0, t1);
        }
        statements.push(C.C_JsBuilder.statement$2("return #.#(#)", [receiver, target, $arguments]));
        body = statements;
      } else if (member.get$isInstanceMember())
        if (this.task.compiler.enqueuer.codegen.universe.methodsNeedingSuperGetter.contains$1(0, member)) {
          superClass = member.get$enclosingClass();
          methodName = this.task.namer.getNameX$1(member);
          t1 = this.task.compiler.backend.get$namer();
          $name = t1.getNameX$1(superClass);
          body = C.C_JsBuilder.statement$2("return #.prototype.#.call(this, #);", [new Q.PropertyAccess(new Q.VariableUse(t1.globalObjectFor$1(superClass), null, null), new Q.LiteralString0("\"" + H.S($name) + "\"", null, null), null, null), methodName, argumentsBuffer]);
        } else
          body = C.C_JsBuilder.statement$2("return this.#(#);", [this.task.namer.getNameX$1(member), argumentsBuffer]);
      else {
        t1 = this.task.namer;
        $name = t1.getNameX$1(member);
        body = C.C_JsBuilder.statement$2("return #(#)", [new Q.PropertyAccess(new Q.VariableUse(t1.globalObjectFor$1(member), null, null), new Q.LiteralString0("\"" + H.S($name) + "\"", null, null), null, null), argumentsBuffer]);
      }
      addStub.call$2(selector, C.C_JsBuilder.call$2("function(#) { #; }", [parametersBuffer, body]));
    },
    addParameterStubs$3: function(member, defineStub, canTearOff) {
      var cls, t1, t2, selectors, callSelectors, untypedSelectors, selector;
      if (member.get$enclosingElement().get$isClosure()) {
        cls = member.get$enclosingElement();
        t1 = cls.get$supertype().get$element();
        t2 = this.task.compiler.backend.get$boundClosureClass();
        if (t1 == null ? t2 == null : t1 === t2)
          this.task.compiler.internalError$2(cls.get$methodElement(), "Bound closure1.");
        if (cls.get$methodElement().get$isInstanceMember())
          this.task.compiler.internalError$2(cls.methodElement, "Bound closure2.");
      }
      selectors = member.get$isInstanceMember() ? this.task.compiler.enqueuer.codegen.universe.invokedNames.$index(0, member.name) : null;
      t1 = new K.ContainerBuilder_addParameterStubs_callSelectorsAsNamed(this, member, canTearOff);
      if (selectors == null) {
        selectors = t1.call$0();
        if (selectors == null)
          return;
      } else {
        callSelectors = t1.call$0();
        if (callSelectors != null)
          selectors = selectors.union$1(callSelectors);
      }
      untypedSelectors = P.LinkedHashSet_LinkedHashSet(null, null, null, Z.Selector);
      if (selectors != null)
        for (t1 = J.get$iterator$ax(selectors); t1.moveNext$0();) {
          selector = t1.get$current();
          if (!selector.appliesUnnamed$2(member, this.task.compiler))
            continue;
          if (untypedSelectors.add$1(0, selector.get$asUntyped()))
            this.addParameterStub$4(member, selector, defineStub, P.LinkedHashSet_LinkedHashSet(null, null, null, P.String));
        }
      if (canTearOff) {
        t1 = this.task;
        t2 = t1.compiler.enqueuer.codegen;
        t1.namer;
        selectors = t2.universe.invokedNames.$index(0, "call");
        if (selectors != null)
          for (t1 = J.get$iterator$ax(selectors), t2 = member.name; t1.moveNext$0();) {
            selector = t1.get$current();
            selector = Z.Selector_Selector(C.SelectorKind_call_2, t2, member.get$enclosingElement().get$library(), selector.get$argumentCount(), selector.get$namedArguments());
            if (!selector.appliesUnnamed$2(member, this.task.compiler))
              continue;
            if (untypedSelectors.add$1(0, selector))
              this.addParameterStub$4(member, selector, defineStub, P.LinkedHashSet_LinkedHashSet(null, null, null, P.String));
          }
      }
    },
    addParameterStubs$2: function(member, defineStub) {
      return this.addParameterStubs$3(member, defineStub, false);
    },
    emitCallStubForGetter$3: function(member, selectors, addProperty) {
      var isInterceptedMethod, t1, generatedSelectors, t2, selector, invocationName, t3, callSelector, closureCallName, parameters, $arguments, i, $name, $function;
      member.get$library();
      isInterceptedMethod = this.task.compiler.backend.isInterceptedMethod$1(member);
      t1 = new K.ContainerBuilder_emitCallStubForGetter_buildGetter(this, member, isInterceptedMethod, this.task.compiler.backend.isInterceptorClass$1(member.get$enclosingClass()), "$receiver");
      generatedSelectors = P.LinkedHashSet_LinkedHashSet(null, null, null, Z.Selector);
      for (t2 = selectors.get$iterator(selectors); t2.moveNext$0();) {
        selector = t2.get$current();
        if (selector.applies$2(member, this.task.compiler)) {
          selector = selector.get$asUntyped();
          if (generatedSelectors.contains$1(0, selector))
            continue;
          generatedSelectors.add$1(0, selector);
          invocationName = this.task.namer.invocationName$1(selector);
          t3 = selector.argumentCount;
          callSelector = Z.Selector_Selector(C.SelectorKind_call_2, "call", null, t3, selector.namedArguments);
          closureCallName = this.task.namer.invocationName$1(callSelector);
          parameters = [];
          parameters.$builtinTypeInfo = [Q.Parameter];
          $arguments = [];
          $arguments.$builtinTypeInfo = [Q.Expression];
          if (isInterceptedMethod)
            parameters.push(new Q.Parameter("$receiver", null, null));
          for (i = 0; i < t3; ++i) {
            $name = "arg" + i;
            parameters.push(new Q.Parameter($name, null, null));
            $arguments.push(C.C_JsBuilder.call$2("#", $name));
          }
          $function = C.C_JsBuilder.call$2("function(#) { return #.#(#); }", [parameters, t1.call$0(), closureCallName, $arguments]);
          this.task.compiler.dumpInfoTask.registerElementAst$2(member, addProperty.call$2(invocationName, $function));
        }
      }
    },
    addMember$2: function(member, builder) {
      var t1, selectors;
      if (member.get$kind(member) === C.ElementKind_field_1)
        ;
      else {
        if (!member.get$isFunction()) {
          t1 = member.kind;
          t1 = t1 === C.ElementKind_generative_constructor_body_0 || t1 === C.ElementKind_generative_constructor_16 || member.get$isGetter() || t1 === C.ElementKind_setter_0;
        } else
          t1 = true;
        if (t1)
          this.addMemberMethod$2(member, builder);
        else
          this.task.compiler.internalError$2(member, "Unexpected kind: \"" + J.toString$0(member.kind) + "\".");
      }
      if (member.get$isInstanceMember())
        if (member.get$isGetter() || member.kind === C.ElementKind_field_1) {
          selectors = this.task.compiler.enqueuer.codegen.universe.invokedNames.$index(0, member.name);
          if (selectors != null && !J.get$isEmpty$asx(selectors))
            this.emitCallStubForGetter$3(member, selectors, builder.get$addProperty());
        }
    },
    addMemberMethod$2: function(member, builder) {
      var t1, code, $name, t2, parameters, t3, isNotApplyTarget, canBeReflected, isClosure, tearOffName, t4, t5, canTearOff, canBeApplied, expressions, callSelector, callSelectorString, requiredParameterCount, optionalParameterCount, tearOffInfo, memberType, thisAccess, memberTypeExpression, reflectionName;
      t1 = {};
      if (member.get$isAbstract())
        return;
      code = this.task.compiler.backend.compiler.enqueuer.codegen.generatedCode.$index(0, member);
      if (code == null)
        return;
      $name = this.task.namer.getNameX$1(member);
      t2 = this.task.interceptorEmitter;
      if (t2.task.compiler.backend.isInterceptedMethod$1(member))
        t2.interceptorInvocationNames.add$1(0, $name);
      parameters = member.get$functionSignature();
      t2 = parameters.get$optionalParameters();
      t2 = t2.get$isEmpty(t2);
      t1.canTearOff_0 = false;
      if (member.get$isFunction()) {
        t3 = member.kind;
        isNotApplyTarget = t3 === C.ElementKind_generative_constructor_16 || member.get$isFactoryConstructor() || member.get$isGetter() || t3 === C.ElementKind_setter_0;
      } else
        isNotApplyTarget = true;
      canBeReflected = this.task.compiler.backend.isAccessibleByReflection$1(member);
      if (isNotApplyTarget) {
        t1.canTearOff_0 = false;
        isClosure = false;
        tearOffName = null;
      } else if (member.get$isInstanceMember())
        if (member.get$enclosingClass().get$isClosure()) {
          t1.canTearOff_0 = false;
          isClosure = true;
          tearOffName = null;
        } else {
          t3 = this.task.compiler;
          t4 = t3.enqueuer.codegen.universe;
          t5 = member.name;
          if (!t4.hasMatchingSelector$3(t4.invokedGetters.$index(0, t5), member, t3))
            if (canBeReflected) {
              t3 = !(t5 === "unary-" || Y.isUserDefinableOperator(t5));
              canTearOff = t3;
            } else
              canTearOff = false;
          else
            canTearOff = true;
          t1.canTearOff_0 = canTearOff;
          tearOffName = this.task.namer.getterName$1(member);
          isClosure = false;
        }
      else {
        t1.canTearOff_0 = this.task.compiler.enqueuer.codegen.universe.staticFunctionsNeedingGetter.contains$1(0, member) || canBeReflected;
        tearOffName = this.task.namer.getStaticClosureName$1(member);
        isClosure = false;
      }
      t3 = this.task.compiler;
      canBeApplied = t3.enabledFunctionApply && t3.world.getMightBePassedToApply$1(member);
      t3 = t1.canTearOff_0;
      if (!(t3 || canBeReflected || canBeApplied)) {
        this.task.compiler.dumpInfoTask.registerElementAst$2(member, builder.addProperty$2($name, code));
        if (!t2)
          this.addParameterStubs$2(member, new K.ContainerBuilder_addMemberMethod_closure(this, member, builder));
        return;
      }
      if (t3)
        ;
      expressions = H.setRuntimeTypeInfo([], [Q.Expression]);
      if (member.get$isFunction()) {
        t3 = Z.Selector_Selector$fromElement(member, this.task.compiler);
        callSelector = Z.Selector_Selector(C.SelectorKind_call_2, "call", null, t3.argumentCount, t3.namedArguments);
        callSelectorString = "\"" + H.S(this.task.namer.invocationName$1(callSelector)) + "\"";
      } else
        callSelectorString = "null";
      requiredParameterCount = parameters.requiredParameterCount << 1 >>> 0;
      if (member.get$isGetter() || member.kind === C.ElementKind_setter_0)
        ++requiredParameterCount;
      optionalParameterCount = parameters.optionalParameterCount << 1 >>> 0;
      if (parameters.optionalParametersAreNamed)
        ++optionalParameterCount;
      expressions.push(code);
      tearOffInfo = [new Q.LiteralString0(callSelectorString, null, null)];
      if (!t2 || t1.canTearOff_0)
        this.addParameterStubs$3(member, new K.ContainerBuilder_addMemberMethod_closure0(t1, this, member, expressions, tearOffInfo), t1.canTearOff_0);
      if (t1.canTearOff_0 || canBeReflected) {
        if (member.kind === C.ElementKind_generative_constructor_body_0) {
          t1 = member.get$$constructor();
          memberType = t1.get$type(t1);
        } else
          memberType = member.get$type(member);
        if (memberType.get$typeVariableOccurrence() != null) {
          thisAccess = C.C_JsBuilder.call$1("this.$receiver");
          memberTypeExpression = this.task.compiler.backend.get$rti().getSignatureEncoding$2(memberType, thisAccess);
        } else
          memberTypeExpression = new Q.LiteralNumber(H.S(this.task.metadataEmitter.reifyType$1(memberType)), null, null);
      } else
        memberTypeExpression = C.C_JsBuilder.call$1("null");
      C.JSArray_methods.addAll$1(expressions, tearOffInfo);
      expressions.push(tearOffName == null || member.get$isGetter() || member.kind === C.ElementKind_setter_0 ? C.C_JsBuilder.call$1("null") : new Q.LiteralString0("\"" + H.S(tearOffName) + "\"", null, null));
      expressions.push(new Q.LiteralNumber("" + requiredParameterCount, null, null));
      expressions.push(new Q.LiteralNumber("" + optionalParameterCount, null, null));
      expressions.push(memberTypeExpression);
      C.JSArray_methods.addAll$1(expressions, H.setRuntimeTypeInfo(new H.MappedListIterable(this.task.metadataEmitter.reifyDefaultArguments$1(member), C.C_JsBuilder.get$number()), [null, null]));
      if (canBeReflected || canBeApplied) {
        t1 = new K.ContainerBuilder_addMemberMethod_closure1(this, expressions);
        parameters.forEachRequiredParameter$1(t1);
        parameters.forEachOptionalParameter$1(t1);
      }
      if (canBeReflected) {
        t1 = member.kind === C.ElementKind_generative_constructor_16 || member.get$isFactoryConstructor();
        t2 = this.task;
        if (t1) {
          t2.getReflectionName$2(member, $name);
          reflectionName = new Q.LiteralString0("\"new " + H.S(O.Elements_reconstructConstructorName(member)) + "\"", null, null);
        } else
          reflectionName = new Q.LiteralString0("\"" + H.S(t2.namer.privateName$2(member.get$enclosingElement().get$library(), member.name)) + "\"", null, null);
        expressions.push(reflectionName);
        C.JSArray_methods.addAll$1(expressions, J.map$1$ax(this.task.metadataEmitter.computeMetadata$1(member), C.C_JsBuilder.get$number()));
      } else if (isClosure && canBeApplied)
        expressions.push(new Q.LiteralString0("\"" + H.S(this.task.namer.privateName$2(member.get$enclosingElement().get$library(), member.name)) + "\"", null, null));
      t1 = expressions.length;
      t2 = Q.ArrayInitializer__convert(expressions);
      this.task.compiler.dumpInfoTask.registerElementAst$2(member, builder.addProperty$2($name, new Q.ArrayInitializer(t1, t2, null, null)));
    }
  },
  ContainerBuilder_addParameterStub_closure: {
    "^": "Closure:50;box_0,this_1,handler_2,names_3,receiverArgumentName_4,parametersBuffer_5,argumentsBuffer_6,optionalParameterStart_7",
    call$1: function(element) {
      var t1, t2, t3, jsName, t4, t5, index, indexOfLastOptionalArgumentInParameters, value;
      t1 = this.this_1;
      t2 = t1.task.compiler.backend.get$namer();
      t3 = J.getInterceptor$x(element);
      jsName = t2._safeName$2(t3.get$name(element), t2.get$jsReserved());
      t2 = this.box_0;
      t4 = t2.count_0;
      t5 = this.optionalParameterStart_7;
      if (t4 < t5) {
        t1 = this.parametersBuffer_5;
        if (t4 >= t1.length)
          return H.ioore(t1, t4);
        t1[t4] = new Q.Parameter(jsName, null, null);
        t1 = this.argumentsBuffer_6;
        t3 = C.C_JsBuilder.call$2("#", jsName);
        if (t4 >= t1.length)
          return H.ioore(t1, t4);
        t1[t4] = t3;
      } else {
        t4 = this.names_3;
        index = H.Lists_indexOf(t4, t3.get$name(element), 0, t4.length);
        if (index !== -1) {
          indexOfLastOptionalArgumentInParameters = t2.count_0;
          t2.indexOfLastOptionalArgumentInParameters_1 = indexOfLastOptionalArgumentInParameters;
          t1 = this.argumentsBuffer_6;
          t3 = C.C_JsBuilder.call$2("#", jsName);
          if (indexOfLastOptionalArgumentInParameters >= t1.length)
            return H.ioore(t1, indexOfLastOptionalArgumentInParameters);
          t1[indexOfLastOptionalArgumentInParameters] = t3;
          t3 = this.parametersBuffer_5;
          t5 += index;
          if (t5 < 0 || t5 >= t3.length)
            return H.ioore(t3, t5);
          t3[t5] = new Q.Parameter(jsName, null, null);
        } else {
          value = this.handler_2.initialVariableValues.$index(0, element.get$declaration());
          if (value == null) {
            t3 = this.argumentsBuffer_6;
            t4 = t2.count_0;
            t1 = t1.task.constantEmitter._referenceEmitter;
            t1.toString;
            t1 = C.C_NullConstant.accept$1(0, t1);
            if (t4 >= t3.length)
              return H.ioore(t3, t4);
            t3[t4] = t1;
          } else {
            if (!value.get$isNull())
              t2.indexOfLastOptionalArgumentInParameters_1 = t2.count_0;
            t3 = this.argumentsBuffer_6;
            t4 = t2.count_0;
            t1 = t1.task.constantEmitter._referenceEmitter;
            t1.toString;
            t1 = J.accept$1$x(value, t1);
            if (t4 >= t3.length)
              return H.ioore(t3, t4);
            t3[t4] = t1;
          }
        }
      }
      ++t2.count_0;
    },
    $isFunction: true
  },
  ContainerBuilder_addParameterStubs_callSelectorsAsNamed: {
    "^": "Closure:112;this_0,member_1,canTearOff_2",
    call$0: function() {
      var t1, t2, callSelectors;
      if (!this.canTearOff_2)
        return;
      t1 = this.this_0.task;
      t2 = t1.compiler.enqueuer.codegen;
      t1.namer;
      callSelectors = t2.universe.invokedNames.$index(0, "call");
      if (callSelectors == null)
        return;
      t1 = J.map$1$ax(callSelectors, new K.ContainerBuilder_addParameterStubs_callSelectorsAsNamed_closure(this.member_1));
      t2 = P.LinkedHashSet_LinkedHashSet(null, null, null, H.getRuntimeTypeArgument(t1, "IterableBase", 0));
      t2.addAll$1(0, t1);
      return t2;
    },
    $isFunction: true
  },
  ContainerBuilder_addParameterStubs_callSelectorsAsNamed_closure: {
    "^": "Closure:113;member_3",
    call$1: function(callSelector) {
      var t1 = this.member_3;
      return Z.Selector_Selector(C.SelectorKind_call_2, t1.name, t1.get$enclosingElement().get$library(), callSelector.get$argumentCount(), callSelector.get$namedArguments());
    },
    $isFunction: true
  },
  ContainerBuilder_emitCallStubForGetter_buildGetter: {
    "^": "Closure:114;this_0,member_1,isInterceptedMethod_2,isInterceptorClass_3,receiverArgumentName_4",
    call$0: function() {
      var receiver, t1, t2, getterName;
      receiver = C.C_JsBuilder.call$1(this.isInterceptorClass_3 ? this.receiverArgumentName_4 : "this");
      t1 = this.member_1;
      t2 = this.this_0;
      if (t1.get$isGetter()) {
        getterName = t2.task.namer.getterName$1(t1);
        if (this.isInterceptedMethod_2)
          return C.C_JsBuilder.call$2("this.#(#)", [getterName, receiver]);
        return C.C_JsBuilder.call$2("#.#()", [receiver, getterName]);
      } else
        return C.C_JsBuilder.call$2("#.#", [receiver, t2.task.namer.instanceFieldPropertyName$1(t1)]);
    },
    $isFunction: true
  },
  ContainerBuilder_addMemberMethod_closure: {
    "^": "Closure:115;this_1,member_2,builder_3",
    call$2: function(selector, $function) {
      var t1 = this.this_1.task;
      t1.compiler.dumpInfoTask.registerElementAst$2(this.member_2, this.builder_3.addProperty$2(t1.namer.invocationName$1(selector), $function));
    },
    $isFunction: true
  },
  ContainerBuilder_addMemberMethod_closure0: {
    "^": "Closure:115;box_0,this_4,member_5,expressions_6,tearOffInfo_7",
    call$2: function(selector, $function) {
      var t1, t2, t3, callSelectors, callSelector, callSelectorString;
      t1 = this.expressions_6;
      t1.push($function);
      t2 = this.member_5;
      if (t2.get$isInstanceMember()) {
        t3 = this.this_4;
        t3.task.compiler.enqueuer.codegen.universe.invokedNames.$index(0, t2.name);
        t1.push(new Q.LiteralString0("\"" + H.S(t3.task.namer.invocationName$1(selector)) + "\"", null, null));
      } else
        t1.push(C.C_JsBuilder.call$1("null"));
      t1 = this.this_4;
      t2 = t1.task;
      t3 = t2.compiler.enqueuer.codegen;
      t2.namer;
      callSelectors = t3.universe.invokedNames.$index(0, "call");
      callSelector = Z.Selector_Selector(C.SelectorKind_call_2, "call", null, selector.argumentCount, selector.namedArguments);
      callSelectorString = this.box_0.canTearOff_0 && callSelectors != null && J.contains$1$asx(callSelectors, callSelector) === true ? "\"" + H.S(t1.task.namer.invocationName$1(callSelector)) + "\"" : "null";
      this.tearOffInfo_7.push(new Q.LiteralString0(callSelectorString, null, null));
    },
    $isFunction: true
  },
  ContainerBuilder_addMemberMethod_closure1: {
    "^": "Closure:77;this_8,expressions_9",
    call$1: function(parameter) {
      var t1, t2, t3, metadataIndices;
      t1 = this.expressions_9;
      t2 = this.this_8;
      t1.push(new Q.LiteralNumber(H.S(t2.task.metadataEmitter.addGlobalMetadata$1("\"" + H.S(J.get$name$x(parameter)) + "\"")), null, null));
      if (t2.task.compiler.backend.get$mustRetainMetadata()) {
        t3 = parameter.get$metadata();
        t3.toString;
        metadataIndices = H.setRuntimeTypeInfo(new E.MappedLinkIterable(new K.ContainerBuilder_addMemberMethod__closure(t2), t3), [H.getTypeArgumentByIndex(t3, 0), null]);
        t3 = H.MappedIterable_MappedIterable(metadataIndices, C.C_JsBuilder.get$number(), H.getRuntimeTypeArgument(metadataIndices, "IterableBase", 0), null);
        t1.push(new Q.ArrayInitializer(t3.get$length(t3), Q.ArrayInitializer__convert(t3), null, null));
      }
    },
    $isFunction: true
  },
  ContainerBuilder_addMemberMethod__closure: {
    "^": "Closure:116;this_10",
    call$1: function(annotation) {
      var t1, constant;
      t1 = this.this_10;
      constant = t1.task.compiler.backend.get$constantCompilerTask().jsConstantCompiler.metadataConstantMap.$index(0, annotation);
      t1.task.compiler.backend.get$constantCompilerTask().jsConstantCompiler.compiledConstants.add$1(0, constant);
      return t1.task.metadataEmitter.reifyMetadata$1(annotation);
    },
    $isFunction: true
  },
  InterceptorEmitter: {
    "^": "CodeEmitterHelper;interceptorInvocationNames,task",
    interceptorsReferencedFromConstants$0: function() {
      var classes, constants, t1, constant;
      classes = P.LinkedHashSet_LinkedHashSet(null, null, null, O.ClassElement);
      constants = this.task.compiler.backend.get$constantCompilerTask().jsConstantCompiler.getConstantsForEmission$0();
      for (t1 = H.setRuntimeTypeInfo(new H.ListIterator(constants, constants.length, 0, null), [H.getTypeArgumentByIndex(constants, 0)]); t1.moveNext$0();) {
        constant = t1.__internal$_current;
        if (!!J.getInterceptor(constant).$isInterceptorConstant)
          classes.add$1(0, constant.dispatchedType.get$element());
      }
      return classes;
    },
    emitGetInterceptorMethod$3: function(buffer, key, classes) {
      var t1, t2, anyNativeClasses, t3, hasArray, hasBool, hasDouble, hasInt, hasNull, hasNumber, hasString, hasNative, cls, t4, statements, interceptorForNumber, $name, jsUnknown, printer;
      t1 = new K.InterceptorEmitter_emitGetInterceptorMethod_interceptorFor(this);
      t2 = new K.InterceptorEmitter_emitGetInterceptorMethod_buildInterceptorCheck(this, t1);
      anyNativeClasses = this.task.compiler.enqueuer.codegen.nativeEnqueuer.hasInstantiatedNativeClasses$0();
      for (t3 = classes.get$iterator(classes), hasArray = false, hasBool = false, hasDouble = false, hasInt = false, hasNull = false, hasNumber = false, hasString = false, hasNative = false; t3.moveNext$0();) {
        cls = t3.get$current();
        t4 = J.getInterceptor(cls);
        if (t4.$eq(cls, this.task.compiler.backend.get$jsArrayClass()) || t4.$eq(cls, this.task.compiler.backend.get$jsMutableArrayClass()) || t4.$eq(cls, this.task.compiler.backend.get$jsFixedArrayClass()) || t4.$eq(cls, this.task.compiler.backend.get$jsExtendableArrayClass()))
          hasArray = true;
        else if (t4.$eq(cls, this.task.compiler.backend.get$jsBoolClass()))
          hasBool = true;
        else if (t4.$eq(cls, this.task.compiler.backend.get$jsDoubleClass()))
          hasDouble = true;
        else if (t4.$eq(cls, this.task.compiler.backend.get$jsIntClass()))
          hasInt = true;
        else if (t4.$eq(cls, this.task.compiler.backend.get$jsNullClass()))
          hasNull = true;
        else if (t4.$eq(cls, this.task.compiler.backend.get$jsNumberClass()))
          hasNumber = true;
        else if (t4.$eq(cls, this.task.compiler.backend.get$jsStringClass()))
          hasString = true;
        else if (anyNativeClasses)
          hasNative = O.Elements_isNativeOrExtendsNative(cls) ? true : hasNative;
      }
      if (hasDouble)
        hasNumber = true;
      if (hasInt)
        hasNumber = true;
      if (classes.containsAll$1(this.task.compiler.backend.get$_interceptedClasses()))
        hasNative = anyNativeClasses;
      statements = [];
      statements.$builtinTypeInfo = [Q.Statement];
      if (hasNumber) {
        t3 = this.task;
        interceptorForNumber = t1.call$1(hasDouble ? t3.compiler.backend.get$jsDoubleClass() : t3.compiler.backend.get$jsNumberClass());
        statements.push(C.C_JsBuilder.statement$2("if (typeof receiver == \"number\") #;", hasInt ? C.C_JsBuilder.statement$2("{\n            if (Math.floor(receiver) == receiver) return #;\n            return #;\n        }", [t1.call$1(this.task.compiler.backend.get$jsIntClass()), interceptorForNumber]) : C.C_JsBuilder.statement$2("return #", interceptorForNumber)));
      }
      if (hasString)
        statements.push(t2.call$1(this.task.compiler.backend.get$jsStringClass()));
      if (hasNull)
        statements.push(t2.call$1(this.task.compiler.backend.get$jsNullClass()));
      else
        statements.push(C.C_JsBuilder.statement$1("if (receiver == null) return receiver"));
      if (hasBool)
        statements.push(t2.call$1(this.task.compiler.backend.get$jsBoolClass()));
      if (hasArray)
        statements.push(t2.call$1(this.task.compiler.backend.get$jsArrayClass()));
      t2 = this.task;
      if (hasNative) {
        t1 = t2.namer;
        t2 = t2.compiler.objectClass;
        $name = t1.getNameX$1(t2);
        t2 = t1.globalObjectFor$1(t2);
        t1 = "\"" + H.S($name) + "\"";
        t3 = this.task;
        t4 = t3.namer;
        t3 = t3.compiler.backend.get$getNativeInterceptorMethod();
        $name = t4.getNameX$1(t3);
        statements.push(C.C_JsBuilder.statement$2("{\n          if (typeof receiver != \"object\") return receiver;\n          if (receiver instanceof #) return receiver;\n          return #(receiver);\n      }", [new Q.PropertyAccess(new Q.VariableUse(t2, null, null), new Q.LiteralString0(t1, null, null), null, null), new Q.PropertyAccess(new Q.VariableUse(t4.globalObjectFor$1(t3), null, null), new Q.LiteralString0("\"" + H.S($name) + "\"", null, null), null, null)]));
      } else {
        jsUnknown = t2.compiler.backend.get$jsUnknownJavaScriptObjectClass();
        if (this.task.compiler.enqueuer.codegen.universe.instantiatedClasses.contains$1(0, jsUnknown)) {
          t2 = this.task;
          t3 = t2.namer;
          t2 = t2.compiler.objectClass;
          $name = t3.getNameX$1(t2);
          statements.push(C.C_JsBuilder.statement$2("if (!(receiver instanceof #)) return #;", [new Q.PropertyAccess(new Q.VariableUse(t3.globalObjectFor$1(t2), null, null), new Q.LiteralString0("\"" + H.S($name) + "\"", null, null), null, null), t1.call$1(jsUnknown)]));
        }
        statements.push(C.C_JsBuilder.statement$1("return receiver"));
      }
      t1 = this.task;
      t1 = C.C_JsBuilder.call$2(H.S(t1.namer.globalObjectFor$1(t1.compiler.backend.get$interceptorsLibrary())) + ".# =\n              function(receiver) { #; }", [key, statements]);
      printer = Q.Printer$(this.task.compiler, null, true);
      printer.visit$1(t1);
      buffer.write$1(printer.outBuffer);
      buffer.write$1(this.task.compiler.enableMinification ? "\n" : ";\n");
    },
    emitGetInterceptorMethods$1: function(buffer) {
      var specializedGetInterceptors, t1, $name;
      buffer.write$1(Q.prettyPrint(new Q.Comment("getInterceptor methods", null, null), this.task.compiler, true, null));
      specializedGetInterceptors = this.task.compiler.backend.get$specializedGetInterceptors();
      t1 = H.setRuntimeTypeInfo(new P.LinkedHashMapKeyIterable(specializedGetInterceptors), [H.getTypeArgumentByIndex(specializedGetInterceptors, 0)]);
      t1 = P.List_List$from(t1, true, H.getRuntimeTypeArgument(t1, "IterableBase", 0));
      H.IterableMixinWorkaround_sortList(t1, null);
      t1 = H.setRuntimeTypeInfo(new H.ListIterator(t1, t1.length, 0, null), [H.getTypeArgumentByIndex(t1, 0)]);
      for (; t1.moveNext$0();) {
        $name = t1.__internal$_current;
        this.emitGetInterceptorMethod$3(buffer, $name, specializedGetInterceptors.$index(0, $name));
      }
    },
    fastPathForOneShotInterceptor$2: function(selector, classes) {
      var t1, $name, result, t2, containsArray, containsString, containsJsIndexable, arrayCheck, indexableCheck, t3, typeCheck;
      t1 = selector.kind;
      if (t1 === C.SelectorKind_operator_3) {
        $name = selector.name;
        if ($name === "==")
          return C.C_JsBuilder.statement$1("{\n          if (receiver == null) return a0 == null;\n          if (typeof receiver != \"object\")\n            return a0 != null && receiver === a0;\n        }");
        if (classes.contains$1(0, this.task.compiler.backend.get$jsIntClass()) !== true && classes.contains$1(0, this.task.compiler.backend.get$jsNumberClass()) !== true && classes.contains$1(0, this.task.compiler.backend.get$jsDoubleClass()) !== true)
          return;
        if (selector.argumentCount === 1) {
          if ($name === "~/" || $name === "<<" || $name === "%" || $name === ">>")
            return;
          result = C.C_JsBuilder.call$1("receiver " + H.S($name) + " a0");
          return C.C_JsBuilder.statement$2("if (typeof receiver == \"number\" && typeof a0 == \"number\")  return #;", $name === "&" || $name === "|" || $name === "^" ? C.C_JsBuilder.call$2("# >>> 0", result) : result);
        } else if ($name === "unary-")
          return C.C_JsBuilder.statement$1("if (typeof receiver == \"number\") return -receiver");
        else
          return C.C_JsBuilder.statement$1("          if (typeof receiver == \"number\" && Math.floor(receiver) == receiver)\n            return (~receiver) >>> 0;\n          ");
      } else {
        t1 = t1 === C.SelectorKind_index_4;
        if (!(t1 && selector.argumentCount === 1))
          t2 = t1 && selector.argumentCount === 2;
        else
          t2 = true;
        if (t2) {
          containsArray = classes.contains$1(0, this.task.compiler.backend.get$jsArrayClass());
          containsString = classes.contains$1(0, this.task.compiler.backend.get$jsStringClass());
          containsJsIndexable = classes.any$1(0, new K.InterceptorEmitter_fastPathForOneShotInterceptor_closure(this));
          if (t1 && selector.argumentCount === 2)
            t2 = this.task.compiler.enableTypeAssertions || containsArray !== true;
          else
            t2 = false;
          if (t2)
            return;
          t2 = containsArray === true;
          if (!t2 && containsString !== true)
            return;
          arrayCheck = C.C_JsBuilder.call$1("receiver.constructor == Array");
          indexableCheck = this.task.compiler.backend.generateIsJsIndexableCall$2(C.C_JsBuilder.call$1("receiver"), C.C_JsBuilder.call$1("receiver"));
          t3 = new K.InterceptorEmitter_fastPathForOneShotInterceptor_orExp();
          if (t1 && selector.argumentCount === 1) {
            typeCheck = t2 ? arrayCheck : null;
            if (containsString === true)
              typeCheck = t3.call$2(typeCheck, C.C_JsBuilder.call$1("typeof receiver == \"string\""));
            return C.C_JsBuilder.statement$2("          if (#)\n            if ((a0 >>> 0) === a0 && a0 < receiver.length)\n              return receiver[a0];\n          ", containsJsIndexable ? t3.call$2(typeCheck, indexableCheck) : typeCheck);
          } else {
            typeCheck = t2 ? arrayCheck : null;
            return C.C_JsBuilder.statement$2("          if (# && !receiver.immutable$list &&\n              (a0 >>> 0) === a0 && a0 < receiver.length)\n            return receiver[a0] = a1;\n          ", containsJsIndexable ? t3.call$2(typeCheck, indexableCheck) : typeCheck);
          }
        }
      }
      return;
    },
    emitOneShotInterceptors$1: function(buffer) {
      var t1, names, $name, selector, t2, classes, t3, getInterceptorName, parameterNames, i, invocationName, globalObject, optimizedPath, assignment, printer;
      t1 = this.task.compiler.backend.get$oneShotInterceptors();
      t1 = H.setRuntimeTypeInfo(new P.LinkedHashMapKeyIterable(t1), [H.getTypeArgumentByIndex(t1, 0)]);
      names = P.List_List$from(t1, true, H.getRuntimeTypeArgument(t1, "IterableBase", 0));
      H.IterableMixinWorkaround_sortList(names, null);
      for (t1 = H.setRuntimeTypeInfo(new H.ListIterator(names, names.length, 0, null), [H.getTypeArgumentByIndex(names, 0)]); t1.moveNext$0();) {
        $name = t1.__internal$_current;
        selector = this.task.compiler.backend.get$oneShotInterceptors().$index(0, $name);
        t2 = J.getInterceptor$x(selector);
        classes = this.task.compiler.backend.getInterceptedClassesOn$1(t2.get$name(selector));
        t3 = this.task;
        getInterceptorName = t3.namer.getInterceptorName$2(t3.compiler.backend.get$getInterceptorMethod(), classes);
        parameterNames = [];
        parameterNames.$builtinTypeInfo = [P.String];
        parameterNames.push("receiver");
        if (t2.get$kind(selector) === C.SelectorKind_setter_1)
          parameterNames.push("value");
        else {
          i = 0;
          while (true) {
            t2 = selector.get$argumentCount();
            if (typeof t2 !== "number")
              return H.iae(t2);
            if (!(i < t2))
              break;
            parameterNames.push("a" + i);
            ++i;
          }
        }
        invocationName = this.task.compiler.backend.get$namer().invocationName$1(selector);
        t2 = this.task;
        globalObject = t2.namer.globalObjectFor$1(t2.compiler.backend.get$interceptorsLibrary());
        optimizedPath = this.fastPathForOneShotInterceptor$2(selector, classes);
        if (optimizedPath == null)
          optimizedPath = C.C_JsBuilder.statement$1(";");
        assignment = C.C_JsBuilder.call$2(H.S(globalObject) + ".# = function(#) {  #;  return #.#(receiver).#(#) }", [$name, parameterNames, optimizedPath, globalObject, getInterceptorName, invocationName, parameterNames]);
        printer = Q.Printer$(this.task.compiler, null, true);
        printer.visit$1(assignment);
        buffer.write$1(printer.outBuffer);
        buffer.write$1(this.task.compiler.enableMinification ? "\n" : ";\n");
      }
    },
    emitInterceptedNames$1: function(buffer) {
      var t1, t2, $name, invocationNames, elements;
      t1 = {};
      t2 = this.task.compiler;
      if (!t2.enabledInvokeOn)
        return;
      $name = t2.backend.get$namer().getNameX$1(this.task.compiler.backend.get$interceptedNames());
      t1.index_0 = 0;
      invocationNames = this.interceptorInvocationNames.toList$0(0);
      H.IterableMixinWorkaround_sortList(invocationNames, null);
      elements = H.setRuntimeTypeInfo(new H.MappedListIterable(invocationNames, new K.InterceptorEmitter_emitInterceptedNames_closure(t1)), [null, null]).toList$0(0);
      t1 = invocationNames.length;
      buffer.write$1(Q.prettyPrint(C.C_JsBuilder.call$2(H.S(this.task.isolateProperties) + ".# = #", [$name, new Q.ArrayInitializer(t1, elements, null, null)]), this.task.compiler, true, null));
      buffer.write$1(this.task.compiler.enableMinification ? "\n" : ";\n");
    },
    emitMapTypeToInterceptor$1: function(buffer) {
      var t1, elements, constants, t2, constant, t3, element, t4, $name, properties, member, t5;
      t1 = this.task.compiler.backend.get$customElementsAnalysis().codegenJoin;
      if (!t1.demanded)
        return;
      elements = H.setRuntimeTypeInfo([], [Q.Expression]);
      constants = this.task.compiler.backend.get$constantCompilerTask().jsConstantCompiler.getConstantsForEmission$1(this.task.get$compareConstants());
      for (t2 = H.setRuntimeTypeInfo(new H.ListIterator(constants, constants.length, 0, null), [H.getTypeArgumentByIndex(constants, 0)]); t2.moveNext$0();) {
        constant = t2.__internal$_current;
        t3 = J.getInterceptor(constant);
        if (!!t3.$isTypeConstant) {
          element = constant.representedType.get$element();
          if (!!J.getInterceptor(element).$isClassElement) {
            if (!t1.activeClasses.contains$1(0, element))
              continue;
            t4 = this.task.compiler.backend.get$emitter().constantEmitter._referenceEmitter;
            t4.toString;
            elements.push(t3.accept$1(constant, t4));
            t4 = this.task.namer;
            $name = t4.getNameX$1(element);
            elements.push(new Q.PropertyAccess(new Q.VariableUse(t4.globalObjectFor$1(element), null, null), new Q.LiteralString0("\"" + H.S($name) + "\"", null, null), null, null));
            properties = [];
            t3 = t1.computeEscapingConstructors$1(element);
            t4 = new H.ListIterator(t3, t3.length, 0, null);
            t4.$builtinTypeInfo = [H.getTypeArgumentByIndex(t3, 0)];
            for (; t4.moveNext$0();) {
              member = t4.__internal$_current;
              t3 = "\"" + H.S(J.get$name$x(member)) + "\"";
              t5 = this.task.compiler.backend.get$namer();
              $name = t5.getNameX$1(member);
              properties.push(new Q.Property(new Q.LiteralString0(t3, null, null), new Q.PropertyAccess(new Q.VariableUse(t5.globalObjectFor$1(member), null, null), new Q.LiteralString0("\"" + H.S($name) + "\"", null, null), null, null), null, null));
            }
            elements.push(new Q.ObjectInitializer(properties, true, null, null));
          }
        }
      }
      t1 = elements.length;
      t2 = Q.ArrayInitializer__convert(elements);
      $name = this.task.compiler.backend.get$namer().getNameX$1(this.task.compiler.backend.get$mapTypeToInterceptor());
      buffer.write$1(Q.prettyPrint(C.C_JsBuilder.call$2(H.S(this.task.isolateProperties) + ".# = #", [$name, new Q.ArrayInitializer(t1, t2, null, null)]), this.task.compiler, true, null));
      buffer.write$1(this.task.compiler.enableMinification ? "\n" : ";\n");
    }
  },
  InterceptorEmitter_emitGetInterceptorMethod_interceptorFor: {
    "^": "Closure:117;this_0",
    call$1: function(cls) {
      return C.C_JsBuilder.call$2("#.prototype", this.this_0.task.namer.elementAccess$1(cls));
    },
    $isFunction: true
  },
  InterceptorEmitter_emitGetInterceptorMethod_buildInterceptorCheck: {
    "^": "Closure:118;this_1,interceptorFor_2",
    call$1: function(cls) {
      var t1, t2, condition;
      t1 = this.this_1;
      t2 = t1.task.compiler.backend.get$jsBoolClass();
      if (cls == null ? t2 == null : cls === t2)
        condition = C.C_JsBuilder.call$1("(typeof receiver) == \"boolean\"");
      else {
        t2 = t1.task.compiler.backend.get$jsIntClass();
        if (cls == null ? t2 != null : cls !== t2) {
          t2 = t1.task.compiler.backend.get$jsDoubleClass();
          if (cls == null ? t2 != null : cls !== t2) {
            t2 = t1.task.compiler.backend.get$jsNumberClass();
            t2 = cls == null ? t2 == null : cls === t2;
          } else
            t2 = true;
        } else
          t2 = true;
        if (t2)
          throw H.wrapException("internal error");
        else {
          t2 = t1.task.compiler.backend.get$jsArrayClass();
          if (cls == null ? t2 != null : cls !== t2) {
            t2 = t1.task.compiler.backend.get$jsMutableArrayClass();
            if (cls == null ? t2 != null : cls !== t2) {
              t2 = t1.task.compiler.backend.get$jsFixedArrayClass();
              if (cls == null ? t2 != null : cls !== t2) {
                t2 = t1.task.compiler.backend.get$jsExtendableArrayClass();
                t2 = cls == null ? t2 == null : cls === t2;
              } else
                t2 = true;
            } else
              t2 = true;
          } else
            t2 = true;
          if (t2)
            condition = C.C_JsBuilder.call$1("receiver.constructor == Array");
          else {
            t2 = t1.task.compiler.backend.get$jsStringClass();
            if (cls == null ? t2 == null : cls === t2)
              condition = C.C_JsBuilder.call$1("(typeof receiver) == \"string\"");
            else {
              t1 = t1.task.compiler.backend.get$jsNullClass();
              if (cls == null ? t1 == null : cls === t1)
                condition = C.C_JsBuilder.call$1("receiver == null");
              else
                throw H.wrapException("internal error");
            }
          }
        }
      }
      return C.C_JsBuilder.statement$2("if (#) return #", [condition, this.interceptorFor_2.call$1(cls)]);
    },
    $isFunction: true
  },
  InterceptorEmitter_fastPathForOneShotInterceptor_closure: {
    "^": "Closure:13;this_0",
    call$1: function(cls) {
      var t1 = this.this_0.task.compiler;
      return t1.world.isSubtype$2(t1.backend.get$jsIndexingBehaviorInterface(), cls);
    },
    $isFunction: true
  },
  InterceptorEmitter_fastPathForOneShotInterceptor_orExp: {
    "^": "Closure:119;",
    call$2: function(left, right) {
      return left == null ? right : C.C_JsBuilder.call$2("# || #", [left, right]);
    },
    $isFunction: true
  },
  InterceptorEmitter_emitInterceptedNames_closure: {
    "^": "Closure:0;box_0",
    call$1: function(invocationName) {
      var t1 = "\"" + H.S(invocationName) + "\"";
      return new Q.ArrayElement(this.box_0.index_0++, new Q.LiteralString0(t1, null, null), null, null);
    },
    $isFunction: true
  },
  MetadataEmitter: {
    "^": "CodeEmitterHelper;globalMetadata,globalMetadataMap,task",
    buildMetadataFunction$1: function(element) {
      if (!this.task.compiler.backend.retainMetadataOf$1(element))
        return;
      return this.task.compiler.withCurrentElement$2(element, new K.MetadataEmitter_buildMetadataFunction_closure(this, element));
    },
    reifyDefaultArguments$1: function($function) {
      var signature, defaultValues, t1, element, value, stringRepresentation, t2, printer;
      signature = $function.get$functionSignature();
      if (signature.get$optionalParameterCount() === 0)
        return C.List_empty;
      defaultValues = H.setRuntimeTypeInfo([], [P.$int]);
      for (t1 = signature.optionalParameters, t1.toString, t1 = H.setRuntimeTypeInfo(new E.LinkIterator(null, t1), [H.getTypeArgumentByIndex(t1, 0)]); t1.moveNext$0();) {
        element = t1._util_implementation$_current;
        value = this.task.compiler.backend.get$constantCompilerTask().jsConstantCompiler.initialVariableValues.$index(0, element.get$declaration());
        if (value == null)
          stringRepresentation = "null";
        else {
          t2 = this.task.constantEmitter._referenceEmitter;
          t2.toString;
          t2 = J.accept$1$x(value, t2);
          printer = Q.Printer$(this.task.compiler, null, true);
          printer.visit$1(t2);
          stringRepresentation = printer.outBuffer.buffer._contents;
        }
        defaultValues.push(this.addGlobalMetadata$1(stringRepresentation));
      }
      return defaultValues;
    },
    reifyMetadata$1: function(annotation) {
      var value, t1, printer;
      value = this.task.compiler.backend.get$constantCompilerTask().jsConstantCompiler.metadataConstantMap.$index(0, annotation);
      if (value == null)
        this.task.compiler.internalError$2(annotation, "Annotation value is null.");
      t1 = this.task.constantEmitter._referenceEmitter;
      t1.toString;
      t1 = J.accept$1$x(value, t1);
      printer = Q.Printer$(this.task.compiler, null, true);
      printer.visit$1(t1);
      return this.addGlobalMetadata$1(printer.outBuffer.buffer._contents);
    },
    reifyType$1: function(type) {
      return this.addGlobalMetadata$1(Q.prettyPrint(this.task.compiler.backend.get$rti().representationGenerator.getTypeRepresentation$2(type, new K.MetadataEmitter_reifyType_closure(this)), this.task.compiler, true, null).buffer._contents);
    },
    addGlobalMetadata$1: function(string) {
      return this.globalMetadataMap.putIfAbsent$2(string, new K.MetadataEmitter_addGlobalMetadata_closure(this, string));
    },
    emitMetadata$1: function(buffer) {
      var t1, t2, metadata;
      t1 = this.task.compiler.enableMinification;
      t2 = "init.metadata" + (t1 ? "" : " ") + "=";
      buffer.write$1(t2 + (t1 ? "" : " ") + "[");
      for (t1 = this.globalMetadata, t1 = H.setRuntimeTypeInfo(new H.ListIterator(t1, t1.length, 0, null), [H.getTypeArgumentByIndex(t1, 0)]); t1.moveNext$0();) {
        metadata = t1.__internal$_current;
        if (typeof metadata === "string") {
          if (metadata !== "null")
            buffer.write$1(metadata);
        } else
          throw H.wrapException("Unexpected value in metadata: " + H.S(P.Error_safeToString(metadata)));
        buffer.write$1("," + (this.task.compiler.enableMinification ? "" : "\n"));
      }
      buffer.write$1("];" + (this.task.compiler.enableMinification ? "" : "\n"));
    },
    computeMetadata$1: function(element) {
      return this.task.compiler.withCurrentElement$2(element, new K.MetadataEmitter_computeMetadata_closure(this, element));
    }
  },
  MetadataEmitter_buildMetadataFunction_closure: {
    "^": "Closure:23;this_0,element_1",
    call$0: function() {
      var metadata, link, t1, annotation, value, t2;
      metadata = [];
      link = this.element_1.get$metadata();
      if (link != null)
        for (t1 = this.this_0; !link.get$isEmpty(link); link = link.get$tail()) {
          annotation = link.get$head(link);
          value = t1.task.compiler.backend.get$constantCompilerTask().jsConstantCompiler.metadataConstantMap.$index(0, annotation);
          t2 = t1.task;
          if (value == null)
            t2.compiler.internalError$2(annotation, "Annotation value is null.");
          else {
            t2 = t2.constantEmitter._referenceEmitter;
            t2.toString;
            metadata.push(J.accept$1$x(value, t2));
          }
        }
      t1 = metadata.length;
      if (t1 === 0)
        return;
      return C.C_JsBuilder.call$2("function() { return # }", new Q.ArrayInitializer(t1, Q.ArrayInitializer__convert(metadata), null, null));
    },
    $isFunction: true
  },
  MetadataEmitter_reifyType_closure: {
    "^": "Closure:13;this_0",
    call$1: function(variable) {
      return new Q.LiteralNumber(H.S(this.this_0.task.compiler.backend.get$typeVariableHandler().reifyTypeVariable$1(variable.get$element())), null, null);
    },
    $isFunction: true
  },
  MetadataEmitter_addGlobalMetadata_closure: {
    "^": "Closure:23;this_0,string_1",
    call$0: function() {
      var t1 = this.this_0.globalMetadata;
      t1.push(this.string_1);
      return t1.length - 1;
    },
    $isFunction: true
  },
  MetadataEmitter_computeMetadata_closure: {
    "^": "Closure:23;this_0,element_1",
    call$0: function() {
      var t1, t2, metadata, link;
      t1 = this.this_0;
      t2 = this.element_1;
      if (!t1.task.compiler.backend.retainMetadataOf$1(t2))
        return C.List_empty7;
      metadata = H.setRuntimeTypeInfo([], [P.$int]);
      link = t2.get$metadata();
      if (link != null)
        for (; !link.get$isEmpty(link); link = link.get$tail())
          metadata.push(t1.reifyMetadata$1(link.get$head(link)));
      return metadata;
    },
    $isFunction: true
  },
  NsmEmitter: {
    "^": "CodeEmitterHelper;trivialNsmHandlers,task",
    emitNoSuchMethodHandlers$1: function(addProperty) {
      var t1, noSuchMethodName, addedJsNames, t2, jsName, selector, method, reflectionName, accessible, t3;
      t1 = this.task;
      if (t1.compiler.enqueuer.codegen.universe.instantiatedClasses._collection$_length === 0)
        return;
      noSuchMethodName = t1.namer.publicInstanceMethodNameByArity$2("noSuchMethod", 1);
      addedJsNames = P.LinkedHashMap_LinkedHashMap(null, null, null, P.String, Z.Selector);
      t1 = new K.NsmEmitter_emitNoSuchMethodHandlers_addNoSuchMethodHandlers(this, addedJsNames);
      this.task.compiler.enqueuer.codegen.universe.invokedNames.forEach$1(0, t1);
      this.task.compiler.enqueuer.codegen.universe.invokedGetters.forEach$1(0, t1);
      this.task.compiler.enqueuer.codegen.universe.invokedSetters.forEach$1(0, t1);
      t1 = new K.NsmEmitter_emitNoSuchMethodHandlers_generateMethod(this, noSuchMethodName, addedJsNames._collection$_length < 10);
      t2 = H.setRuntimeTypeInfo(new P.LinkedHashMapKeyIterable(addedJsNames), [H.getTypeArgumentByIndex(addedJsNames, 0)]);
      t2 = P.List_List$from(t2, true, H.getRuntimeTypeArgument(t2, "IterableBase", 0));
      H.IterableMixinWorkaround_sortList(t2, null);
      t2 = H.setRuntimeTypeInfo(new H.ListIterator(t2, t2.length, 0, null), [H.getTypeArgumentByIndex(t2, 0)]);
      for (; t2.moveNext$0();) {
        jsName = t2.__internal$_current;
        selector = addedJsNames.$index(0, jsName);
        method = t1.call$2(jsName, selector);
        if (method != null) {
          addProperty.call$2(jsName, method);
          reflectionName = this.task.getReflectionName$2(selector, jsName);
          if (reflectionName != null) {
            accessible = J.any$1$ax(this.task.compiler.world.allFunctions.query$1(0, selector).functions, new K.NsmEmitter_emitNoSuchMethodHandlers_closure(this));
            t3 = "+" + reflectionName;
            addProperty.call$2(t3, C.C_JsBuilder.call$1(accessible ? "2" : "0"));
          }
        }
      }
    },
    isTrivialNsmHandler$4: function(type, argNames, selector, internalName) {
      var t1;
      if (this.task.compiler.backend.get$interceptedElements().$index(0, selector.name) != null) {
        t1 = this.task;
        if (!t1.compiler.enableMinification)
          return false;
        if (t1.namer.invocationName$1(selector).length > 4)
          return false;
      }
      if (argNames.length !== 0)
        return false;
      t1 = this.task.namer.get$getterPrefix();
      if (0 >= t1.length)
        return H.ioore(t1, 0);
      if (J.getInterceptor$s(internalName).startsWith$1(internalName, t1[0]))
        return type === 1;
      t1 = this.task.namer.get$setterPrefix();
      if (0 >= t1.length)
        return H.ioore(t1, 0);
      if (C.JSString_methods.startsWith$1(internalName, t1[0]))
        return type === 2;
      return type === 0;
    },
    buildTrivialNsmHandlers$0: function() {
      var statements, t1, firstNormalSelector, i, t2, t3, shorts, diffEncoding, minify, useDiffEncoding, t4, t5, previous, nameCounter, $short, base63, base26Diff, objectClass, createInvocationMirror, noSuchMethodName, longs, whatToPatch, sliceOffsetArguments, sliceOffsetParams;
      statements = H.setRuntimeTypeInfo([], [Q.Statement]);
      t1 = this.trivialNsmHandlers;
      if (t1.length === 0)
        return statements;
      H.IterableMixinWorkaround_sortList(t1, new K.NsmEmitter_buildTrivialNsmHandlers_closure(this));
      firstNormalSelector = t1.length;
      for (i = 0; i < t1.length; ++i) {
        t2 = this.task.compiler.backend;
        t3 = t1[i];
        if (t2.get$interceptedElements().$index(0, t3.name) == null) {
          firstNormalSelector = i;
          break;
        }
      }
      shorts = H.setRuntimeTypeInfo(new H.MappedListIterable(t1, new K.NsmEmitter_buildTrivialNsmHandlers_closure0(this)), [null, null]);
      H.setRuntimeTypeInfo([], [P.String]);
      diffEncoding = P.StringBuffer$("");
      t2 = new K.NsmEmitter_buildTrivialNsmHandlers_fromBase88(this);
      t3 = new K.NsmEmitter_buildTrivialNsmHandlers_toBase26();
      minify = this.task.compiler.enableMinification;
      useDiffEncoding = minify && J.get$length$asx(shorts._source) > 30;
      for (t4 = H.setRuntimeTypeInfo(new H.ListIterator(shorts, shorts.get$length(shorts), 0, null), [H.getRuntimeTypeArgument(shorts, "ListIterable", 0)]), t5 = !useDiffEncoding, previous = 0, nameCounter = 0; t4.moveNext$0();) {
        $short = t4.__internal$_current;
        if (useDiffEncoding && nameCounter === firstNormalSelector) {
          diffEncoding._contents += ".";
          previous = 0;
        }
        if (J.get$length$asx($short) <= 4 && useDiffEncoding) {
          base63 = t2.call$1($short);
          base26Diff = t3.call$1(J.$sub$n(base63, previous));
          diffEncoding._contents += typeof base26Diff === "string" ? base26Diff : H.S(base26Diff);
          previous = base63;
        } else {
          if (!t5 || diffEncoding._contents.length !== 0)
            diffEncoding._contents += ",";
          diffEncoding._contents += typeof $short === "string" ? $short : H.S($short);
        }
        ++nameCounter;
      }
      t2 = this.task;
      t3 = t2.compiler;
      objectClass = t3.objectClass;
      t2 = t2.namer;
      t3 = t3.backend;
      createInvocationMirror = t2.elementAccess$1(t3.find$2(0, t3.get$jsHelperLibrary(), "createInvocationMirror"));
      noSuchMethodName = this.task.namer.publicInstanceMethodNameByArity$2("noSuchMethod", 1);
      if (useDiffEncoding)
        statements.push(C.C_JsBuilder.statement$2("{\n          var objectClassObject =\n                  collectedClasses[#],    // # is name of class Object.\n              shortNames = #.split(\",\"),  // # is diffEncoding.\n              nameNumber = 0,\n              diffEncodedString = shortNames[0],\n              calculatedShortNames = [0, 1];    // 0, 1 are args for splice.\n          // If we are loading a deferred library the object class will not be in\n          // the collectedClasses so objectClassObject is undefined, and we skip\n          // setting up the names.\n\n          if (objectClassObject) {\n            if (objectClassObject instanceof Array)\n              objectClassObject = objectClassObject[1];\n            for (var i = 0; i < diffEncodedString.length; i++) {\n              var codes = [],\n                  diff = 0,\n                  digit = diffEncodedString.charCodeAt(i);\n              if (digit == 46) {\n                nameNumber = 0;\n                digit = diffEncodedString.charCodeAt(++i);\n              }\n              for (; digit <= 90;) {\n                diff *= 26;\n                diff += (digit - 65);\n                digit = diffEncodedString.charCodeAt(++i);\n              }\n              diff *= 26;\n              diff += (digit - 97);\n              nameNumber += diff;\n              for (var remaining = nameNumber;\n                   remaining > 0;\n                   remaining = (remaining / 88) | 0) {\n                codes.unshift(35 + remaining % 88);\n              }\n              calculatedShortNames.push(\n                String.fromCharCode.apply(String, codes));\n            }\n            shortNames.splice.apply(shortNames, calculatedShortNames);\n          }\n        }", [new Q.LiteralString0("\"" + H.S(this.task.namer.getNameX$1(objectClass)) + "\"", null, null), new Q.LiteralString0("\"" + H.S(diffEncoding) + "\"", null, null)]));
      else {
        longs = H.setRuntimeTypeInfo(new H.MappedListIterable(t1, new K.NsmEmitter_buildTrivialNsmHandlers_closure1()), [null, null]);
        statements.push(C.C_JsBuilder.statement$2("var objectClassObject = collectedClasses[#],    shortNames = #.split(\",\")", [new Q.LiteralString0("\"" + H.S(this.task.namer.getNameX$1(objectClass)) + "\"", null, null), new Q.LiteralString0("\"" + H.S(diffEncoding) + "\"", null, null)]));
        if (!minify)
          statements.push(C.C_JsBuilder.statement$2("var longNames = #.split(\",\")", new Q.LiteralString0("\"" + longs.join$1(0, ",") + "\"", null, null)));
        statements.push(C.C_JsBuilder.statement$1("if (objectClassObject instanceof Array)  objectClassObject = objectClassObject[1];"));
      }
      whatToPatch = this.task.nativeEmitter.handleNoSuchMethod ? "Object.prototype" : "objectClassObject";
      if (firstNormalSelector === 0)
        sliceOffsetArguments = [];
      else
        sliceOffsetArguments = firstNormalSelector === J.get$length$asx(shorts._source) ? [new Q.LiteralNumber("1", null, null)] : [C.C_JsBuilder.call$2("(j < #) ? 1 : 0", new Q.LiteralNumber("" + firstNormalSelector, null, null))];
      sliceOffsetParams = sliceOffsetArguments.length === 0 ? [] : ["sliceOffset"];
      t1 = this.task.namer.get$getterPrefix();
      if (0 >= t1.length)
        return H.ioore(t1, 0);
      t1 = "      // If we are loading a deferred library the object class will not be in\n      // the collectedClasses so objectClassObject is undefined, and we skip\n      // setting up the names.\n      if (objectClassObject) {\n        for (var j = 0; j < shortNames.length; j++) {\n          var type = 0;\n          var short = shortNames[j];\n          if (short[0] == \"" + t1[0] + "\") type = 1;\n          if (short[0] == \"";
      t2 = this.task.namer.get$setterPrefix();
      if (0 >= t2.length)
        return H.ioore(t2, 0);
      t2 = t1 + t2[0] + "\") type = 2;\n          // Generate call to:\n          //\n          //     createInvocationMirror(String name, internalName, type,\n          //         arguments, argumentNames)\n          //\n          " + whatToPatch + "[short] = (function(name, short, type, #) {\n              return function() {\n                return this.#(this,\n                    #(name, short, type,\n                      Array.prototype.slice.call(arguments, #),\n                      []));\n              }\n          })(#[j], short, type, #);\n        }\n      }";
      statements.push(C.C_JsBuilder.statement$2(t2, [sliceOffsetParams, noSuchMethodName, createInvocationMirror, sliceOffsetParams, minify ? "shortNames" : "longNames", sliceOffsetArguments]));
      return statements;
    },
    static: {"^": "NsmEmitter_VERY_FEW_NO_SUCH_METHOD_HANDLERS,NsmEmitter_MAX_MINIFIED_LENGTH_FOR_DIFF_ENCODING"}
  },
  NsmEmitter_emitNoSuchMethodHandlers_addNoSuchMethodHandlers: {
    "^": "Closure:120;this_0,addedJsNames_1",
    call$2: function(ignore, selectors) {
      var t1, t2, t3, selector, mask, jsName, reflectionName;
      t1 = this.this_0;
      t1.task.compiler.objectClass.get$rawType();
      for (t2 = J.get$iterator$ax(selectors), t3 = this.addedJsNames_1; t2.moveNext$0();) {
        selector = t2.get$current();
        mask = selector.get$mask();
        if (mask == null)
          mask = new B.FlatTypeMask(t1.task.compiler.objectClass, 5);
        if (!mask.needsNoSuchMethodHandling$2(selector, t1.task.compiler))
          continue;
        jsName = t1.task.namer.invocationName$1(selector);
        t3.$indexSet(0, jsName, selector);
        reflectionName = t1.task.getReflectionName$2(selector, jsName);
        if (reflectionName != null)
          t1.task.mangledFieldNames.$indexSet(0, jsName, reflectionName);
      }
    },
    $isFunction: true
  },
  NsmEmitter_emitNoSuchMethodHandlers_generateMethod: {
    "^": "Closure:121;this_2,noSuchMethodName_3,haveVeryFewNoSuchMemberHandlers_4",
    call$2: function(jsName, selector) {
      var type, parameterNames, argNames, t1, methodName, methodName0, internalName, reflectionName, t2, t3, t4, t5, t6, expression;
      type = selector.get$invocationMirrorKind();
      parameterNames = P.List_List$generate(selector.argumentCount, new K.NsmEmitter_emitNoSuchMethodHandlers_generateMethod_closure(), true, null);
      argNames = H.setRuntimeTypeInfo(new H.MappedListIterable(selector.getOrderedNamedArguments$0(), new K.NsmEmitter_emitNoSuchMethodHandlers_generateMethod_closure0()), [null, null]).toList$0(0);
      t1 = selector.kind;
      methodName = selector.name;
      methodName0 = t1 === C.SelectorKind_setter_1 ? H.S(methodName) + "=" : methodName;
      t1 = this.this_2;
      internalName = t1.task.namer.invocationName$1(selector);
      reflectionName = t1.task.getReflectionName$2(selector, internalName);
      if (!this.haveVeryFewNoSuchMemberHandlers_4 && t1.isTrivialNsmHandler$4(type, argNames, selector, internalName) && reflectionName == null) {
        t1.trivialNsmHandlers.push(selector);
        return;
      }
      t2 = t1.task;
      t3 = t2.namer;
      t2 = t2.compiler.backend;
      t2 = t3.elementAccess$1(t2.find$2(0, t2.get$jsHelperLibrary(), "createInvocationMirror"));
      t3 = "\"" + H.S(t1.task.compiler.enableMinification ? internalName : methodName0) + "\"";
      t4 = "\"" + H.S(internalName) + "\"";
      t5 = "" + type;
      t6 = H.setRuntimeTypeInfo(new H.MappedListIterable(parameterNames, C.C_JsBuilder), [null, null]);
      expression = C.C_JsBuilder.call$2("this.#(this, #(#, #, #, #, #))", [this.noSuchMethodName_3, t2, new Q.LiteralString0(t3, null, null), new Q.LiteralString0(t4, null, null), new Q.LiteralNumber(t5, null, null), new Q.ArrayInitializer(t6.get$length(t6), Q.ArrayInitializer__convert(t6), null, null), new Q.ArrayInitializer(argNames.length, Q.ArrayInitializer__convert(argNames), null, null)]);
      if (t1.task.compiler.backend.get$interceptedElements().$index(0, methodName) != null)
        return C.C_JsBuilder.call$2("function($receiver, #) { return # }", [parameterNames, expression]);
      else
        return C.C_JsBuilder.call$2("function(#) { return # }", [parameterNames, expression]);
    },
    $isFunction: true
  },
  NsmEmitter_emitNoSuchMethodHandlers_generateMethod_closure: {
    "^": "Closure:13;",
    call$1: function(i) {
      return "$" + i;
    },
    $isFunction: true
  },
  NsmEmitter_emitNoSuchMethodHandlers_generateMethod_closure0: {
    "^": "Closure:0;",
    call$1: function($name) {
      return new Q.LiteralString0("\"" + H.S($name) + "\"", null, null);
    },
    $isFunction: true
  },
  NsmEmitter_emitNoSuchMethodHandlers_closure: {
    "^": "Closure:77;this_5",
    call$1: function(e) {
      return this.this_5.task.compiler.backend.isAccessibleByReflection$1(e);
    },
    $isFunction: true
  },
  NsmEmitter_buildTrivialNsmHandlers_closure: {
    "^": "Closure:19;this_0",
    call$2: function(a, b) {
      var t1, t2, t3, aIsIntercepted, aName, bName;
      t1 = this.this_0;
      t2 = t1.task.compiler.backend;
      t3 = J.get$name$x(a);
      aIsIntercepted = t2.get$interceptedElements().$index(0, t3) != null;
      t3 = t1.task.compiler.backend;
      t2 = J.get$name$x(b);
      if (aIsIntercepted !== (t3.get$interceptedElements().$index(0, t2) != null))
        return aIsIntercepted ? -1 : 1;
      aName = t1.task.namer.invocationName$1(a);
      bName = t1.task.namer.invocationName$1(b);
      t1 = aName.length;
      t2 = bName.length;
      if (t1 !== t2)
        return t1 - t2;
      return J.compareTo$1$ns(aName, bName);
    },
    $isFunction: true
  },
  NsmEmitter_buildTrivialNsmHandlers_closure0: {
    "^": "Closure:13;this_1",
    call$1: function(selector) {
      return this.this_1.task.namer.invocationName$1(selector);
    },
    $isFunction: true
  },
  NsmEmitter_buildTrivialNsmHandlers_fromBase88: {
    "^": "Closure:122;this_2",
    call$1: function(x) {
      var t1, answer, i;
      for (t1 = x.length, answer = 0, i = 0; i < t1; ++i)
        answer = answer * 88 + (C.JSString_methods.codeUnitAt$1(x, i) - 35);
      return answer;
    },
    $isFunction: true
  },
  NsmEmitter_buildTrivialNsmHandlers_toBase26: {
    "^": "Closure:64;",
    call$1: function(x) {
      var encodingChars, c;
      encodingChars = H.setRuntimeTypeInfo([], [P.$int]);
      encodingChars.push(97 + C.JSInt_methods.$mod(x, 26));
      for (c = x; true;) {
        c = C.JSInt_methods._tdivFast$1(c, 26);
        if (c === 0)
          break;
        encodingChars.push(65 + C.JSInt_methods.$mod(c, 26));
      }
      return P.String_String$fromCharCodes(H.setRuntimeTypeInfo(new H.ReversedListIterable(encodingChars), [H.getTypeArgumentByIndex(H.setRuntimeTypeInfo(new H.IterableMixinWorkaround(), [H.getTypeArgumentByIndex(encodingChars, 0)]), 0)]).toList$0(0));
    },
    $isFunction: true
  },
  NsmEmitter_buildTrivialNsmHandlers_closure1: {
    "^": "Closure:13;",
    call$1: function(selector) {
      return selector.get$invocationMirrorMemberName();
    },
    $isFunction: true
  },
  TypeTestEmitter: {
    "^": "CodeEmitterHelper;checkedClasses,checkedFunctionTypes,checkedGenericFunctionTypes,checkedNonGenericFunctionTypes,rtiNeededClasses,cachedClassesUsingTypeVariableTests,task",
    get$classesUsingTypeVariableTests: function() {
      var t1, t2;
      t1 = this.cachedClassesUsingTypeVariableTests;
      if (t1 == null) {
        t1 = this.task.compiler.enqueuer.codegen.universe.isChecks;
        t2 = new H.WhereIterable(t1, new K.TypeTestEmitter_classesUsingTypeVariableTests_closure());
        t2.$builtinTypeInfo = [H.getTypeArgumentByIndex(t1, 0)];
        t1 = H.MappedIterable_MappedIterable(t2, new K.TypeTestEmitter_classesUsingTypeVariableTests_closure0(), H.getRuntimeTypeArgument(t2, "IterableBase", 0), null);
        t1 = P.List_List$from(t1, true, H.getRuntimeTypeArgument(t1, "IterableBase", 0));
        this.cachedClassesUsingTypeVariableTests = t1;
      }
      return t1;
    },
    emitIsTests$2: function(classElement, builder) {
      this.generateIsTestsOn$4(classElement, new K.TypeTestEmitter_emitIsTests_generateIsTest(this, classElement, builder), new K.TypeTestEmitter_emitIsTests_generateFunctionTypeSignature(this, builder), new K.TypeTestEmitter_emitIsTests_generateSubstitution(this, classElement, builder));
    },
    generateIsTestsOn$4: function(cls, emitIsTest, emitFunctionTypeSignature, emitSubstitution) {
      var superclass, emitted, t1, supertype, t2, t3, check, generated, $call, callType;
      if (this.checkedClasses.contains$1(0, cls)) {
        emitIsTest.call$1(cls);
        emitSubstitution.call$1(cls);
      }
      this.task.compiler.backend.get$rti();
      superclass = cls.get$superclass();
      if (superclass != null && superclass !== this.task.compiler.objectClass && new K.TypeTestEmitter_generateIsTestsOn_haveSameTypeVariables(this).call$2(cls, superclass) !== true) {
        emitted = P.LinkedHashSet_LinkedHashSet(null, null, null, O.ClassElement);
        for (; superclass != null;) {
          t1 = this.task.compiler.backend;
          if (t1.get$rti().classesNeedingRti.contains$1(0, superclass.get$declaration()) || t1.compiler.enabledRuntimeType) {
            emitSubstitution.call$2$emitNull(superclass, true);
            emitted.add$1(0, superclass);
          }
          superclass = superclass.get$superclass();
        }
        for (t1 = cls.allSupertypesAndSelf._supertypes, t1.toString, t1 = H.setRuntimeTypeInfo(new E.LinkIterator(null, t1), [H.getTypeArgumentByIndex(t1, 0)]); t1.moveNext$0();) {
          supertype = t1._util_implementation$_current;
          superclass = supertype.get$element();
          if (J.contains$1$asx(this.get$classesUsingTypeVariableTests(), superclass)) {
            emitSubstitution.call$2$emitNull(superclass, true);
            emitted.add$1(0, superclass);
          }
          t2 = this.checkedClasses;
          t3 = new P.LinkedHashSetIterator(t2, t2._modifications, null, null);
          t3.$builtinTypeInfo = [null];
          t3._cell = t2._first;
          for (; t3.moveNext$0();) {
            check = t3._collection$_current;
            t2 = supertype.get$element();
            if ((t2 == null ? check == null : t2 === check) && !emitted.contains$1(0, check)) {
              emitSubstitution.call$2$emitNull(check, true);
              emitted.add$1(0, check);
            }
          }
        }
        emitSubstitution = new K.TypeTestEmitter_generateIsTestsOn_emitNothing();
      }
      generated = P.LinkedHashSet_LinkedHashSet(null, null, null, O.Element);
      if (this.checkedClasses.contains$1(0, this.task.compiler.functionClass) || this.checkedFunctionTypes._collection$_length !== 0) {
        $call = cls.lookupLocalMember$1("call");
        if ($call == null)
          $call = cls.lookupBackendMember$1("call");
        if ($call != null && $call.get$isFunction()) {
          this.generateInterfacesIsTests$4(this.task.compiler.functionClass, emitIsTest, emitSubstitution, generated);
          callType = $call.computeType$1(this.task.compiler);
          this.generateFunctionTypeTests$4($call, callType, this.getFunctionTypeChecksOn$1(callType), emitFunctionTypeSignature);
        }
      }
      for (t1 = cls.interfaces, t1.toString, t1 = H.setRuntimeTypeInfo(new E.LinkIterator(null, t1), [H.getTypeArgumentByIndex(t1, 0)]); t1.moveNext$0();)
        this.generateInterfacesIsTests$4(t1._util_implementation$_current.get$element(), emitIsTest, emitSubstitution, generated);
    },
    generateInterfacesIsTests$4: function(cls, emitIsTest, emitSubstitution, alreadyGenerated) {
      var t1, t2, t3, element, superclass;
      t1 = new K.TypeTestEmitter_generateInterfacesIsTests_tryEmitTest(this, emitIsTest, emitSubstitution, alreadyGenerated);
      t1.call$1(cls);
      t2 = cls.get$interfaces();
      t2.toString;
      t3 = new E.LinkIterator(null, t2);
      t3.$builtinTypeInfo = [H.getTypeArgumentByIndex(t2, 0)];
      for (; t3.moveNext$0();) {
        element = t3._util_implementation$_current.get$element();
        t1.call$1(element);
        this.generateInterfacesIsTests$4(element, emitIsTest, emitSubstitution, alreadyGenerated);
      }
      t2 = cls.supertype;
      superclass = t2 == null ? null : t2.get$element();
      if (superclass != null) {
        t1.call$1(superclass);
        this.generateInterfacesIsTests$4(superclass, emitIsTest, emitSubstitution, alreadyGenerated);
      }
    },
    getFunctionTypeChecksOn$1: function(type) {
      var functionTypeMap, t1, functionType, maybeSubtype;
      functionTypeMap = P.LinkedHashMap_LinkedHashMap(null, null, null, V.FunctionType, P.bool);
      for (t1 = this.checkedFunctionTypes, t1 = H.setRuntimeTypeInfo(new P.LinkedHashSetIterator(t1, t1._modifications, null, null), [null]), t1._cell = t1._set._first; t1.moveNext$0();) {
        functionType = t1._collection$_current;
        maybeSubtype = this.task.compiler.types.computeSubtypeRelation$2(type, functionType);
        if (maybeSubtype === 1)
          functionTypeMap.$indexSet(0, functionType, true);
        else if (maybeSubtype === 0)
          functionTypeMap.$indexSet(0, functionType, false);
      }
      return functionTypeMap;
    },
    generateFunctionTypeTests$4: function(method, methodType, functionTypeChecks, emitFunctionTypeSignature) {
      functionTypeChecks.forEach$1(0, new K.TypeTestEmitter_generateFunctionTypeTests_closure(this));
      emitFunctionTypeSignature.call$2(method, methodType);
    },
    registerDynamicFunctionTypeCheck$1: function(functionType) {
      var classElement = V.Types_getClassContext(functionType);
      if (classElement != null)
        J.add$1$ax(this.checkedGenericFunctionTypes.putIfAbsent$2(classElement, new K.TypeTestEmitter_registerDynamicFunctionTypeCheck_closure()), functionType);
      else
        this.checkedNonGenericFunctionTypes.add$1(0, functionType);
    },
    emitRuntimeTypeSupport$2: function(buffer, outputUnit) {
      var rti, typeChecks, variables, statements, t1, t2, t3, cls, properties, result, check, checkedClass, substitution, body, $name, holder, nameAndValue, t4;
      buffer.write$1(Q.prettyPrint(new Q.Comment("Runtime type support", null, null), this.task.compiler, true, null));
      rti = this.task.compiler.backend.get$rti();
      typeChecks = rti.get$requiredChecks();
      variables = C.C_JsBuilder.statement$1("var TRUE = !0, _;");
      statements = H.setRuntimeTypeInfo([], [Q.Statement]);
      for (t1 = typeChecks.map, t2 = H.setRuntimeTypeInfo(new P.LinkedHashMapKeyIterable(t1), [H.getTypeArgumentByIndex(t1, 0)]), t3 = t2._map, t2 = H.setRuntimeTypeInfo(new P.LinkedHashMapKeyIterator(t3, t3._modifications, null, null), [H.getTypeArgumentByIndex(t2, 0)]), t2._cell = t2._map._first; t2.moveNext$0();) {
        cls = t2._collection$_current;
        if (!J.$eq(this.task.compiler.deferredLoadTask.outputUnitForElement$1(cls), outputUnit))
          continue;
        properties = [];
        properties.$builtinTypeInfo = [P.List];
        result = t1.$index(0, cls);
        t3 = J.get$iterator$ax(result != null ? result : C.List_empty6);
        for (; t3.moveNext$0();) {
          check = t3.get$current();
          checkedClass = check.get$cls();
          properties.push(["$is" + H.S(this.task.namer.getRuntimeTypeName$1(checkedClass)), C.C_JsBuilder.call$1("TRUE")]);
          substitution = check.get$substitution();
          if (substitution != null) {
            body = substitution.getCode$2(rti, false);
            properties.push(["$as" + H.S(this.task.namer.getNameX$1(checkedClass)), body]);
          }
        }
        t3 = this.task.namer;
        $name = t3.getNameX$1(cls);
        holder = new Q.PropertyAccess(new Q.VariableUse(t3.globalObjectFor$1(cls), null, null), new Q.LiteralString0("\"" + H.S($name) + "\"", null, null), null, null);
        if (properties.length > 1) {
          statements.push(C.C_JsBuilder.statement$2("_ = #;", holder));
          holder = C.C_JsBuilder.call$2("#", "_");
        }
        t3 = new H.ListIterator(properties, properties.length, 0, null);
        t3.$builtinTypeInfo = [H.getTypeArgumentByIndex(properties, 0)];
        for (; t3.moveNext$0();) {
          nameAndValue = t3.__internal$_current;
          t4 = J.getInterceptor$asx(nameAndValue);
          statements.push(C.C_JsBuilder.statement$2("#.# = #", [holder, t4.$index(nameAndValue, 0), t4.$index(nameAndValue, 1)]));
        }
      }
      if (statements.length !== 0) {
        buffer.write$1(";");
        buffer.write$1(Q.prettyPrint(C.C_JsBuilder.statement$2("(function() { #; #; })()", [variables, statements]), this.task.compiler, true, null));
        buffer.write$1(this.task.compiler.enableMinification ? "\n" : ";\n");
      }
    },
    classesModifiedByEmitRuntimeTypeSupport$0: function() {
      var typeChecks, result, t1, t2, t3, cls, result0;
      typeChecks = this.task.compiler.backend.get$rti().get$requiredChecks();
      result = P.LinkedHashSet_LinkedHashSet(null, null, null, O.ClassElement);
      for (t1 = typeChecks.map, t2 = H.setRuntimeTypeInfo(new P.LinkedHashMapKeyIterable(t1), [H.getTypeArgumentByIndex(t1, 0)]), t3 = t2._map, t2 = H.setRuntimeTypeInfo(new P.LinkedHashMapKeyIterator(t3, t3._modifications, null, null), [H.getTypeArgumentByIndex(t2, 0)]), t2._cell = t2._map._first; t2.moveNext$0();) {
        cls = t2._collection$_current;
        result0 = t1.$index(0, cls);
        t3 = J.get$iterator$ax(result0 != null ? result0 : C.List_empty6);
        $loop$1: {
          if (t3.moveNext$0()) {
            t3.get$current();
            result.add$1(0, cls);
            break $loop$1;
          }
        }
      }
      return result;
    },
    computeRtiNeededClasses$0: function() {
      var t1, rti, t2, requiredArgumentClasses, requiredChecks, contextClass;
      t1 = new K.TypeTestEmitter_computeRtiNeededClasses_addClassWithSuperclasses(this);
      rti = this.task.compiler.backend.get$rti();
      t2 = rti.getClassesUsedInSubstitutions$2(this.task.compiler.backend, rti.get$requiredChecks());
      requiredArgumentClasses = P.LinkedHashSet_LinkedHashSet(null, null, null, O.ClassElement);
      requiredArgumentClasses.addAll$1(0, t2);
      requiredArgumentClasses.addAll$1(0, rti.directlyInstantiatedArguments);
      requiredArgumentClasses.addAll$1(0, rti.checkedArguments);
      requiredArgumentClasses.forEach$1(0, t1);
      t2 = this.rtiNeededClasses;
      requiredChecks = rti.computeChecks$2(t2, this.checkedClasses);
      new K.TypeTestEmitter_computeRtiNeededClasses_addClassesWithSuperclasses(t1).call$1(rti.getClassesUsedInSubstitutions$2(this.task.compiler.backend, requiredChecks));
      for (t1 = this.checkedFunctionTypes, t1 = H.setRuntimeTypeInfo(new P.LinkedHashSetIterator(t1, t1._modifications, null, null), [null]), t1._cell = t1._set._first; t1.moveNext$0();) {
        contextClass = V.Types_getClassContext(t1._collection$_current);
        if (contextClass != null)
          t2.add$1(0, contextClass);
      }
      t1 = this.task.compiler.backend.compiler.enqueuer.codegen.generatedCode;
      t1 = H.setRuntimeTypeInfo(new P.LinkedHashMapKeyIterable(t1), [H.getTypeArgumentByIndex(t1, 0)]);
      H.setRuntimeTypeInfo(new H.WhereIterable(t1, new K.TypeTestEmitter_computeRtiNeededClasses_closure(this, new K.TypeTestEmitter_computeRtiNeededClasses_canTearOff(this))), [H.getRuntimeTypeArgument(t1, "IterableBase", 0)]).forEach$1(0, new K.TypeTestEmitter_computeRtiNeededClasses_closure0(this));
      return t2;
    },
    computeRequiredTypeChecks$0: function() {
      this.task.compiler.backend.get$rti().addImplicitChecks$2(this.task.compiler.enqueuer.codegen.universe, this.get$classesUsingTypeVariableTests());
      this.checkedClasses = P.LinkedHashSet_LinkedHashSet(null, null, null, O.ClassElement);
      this.checkedFunctionTypes = P.LinkedHashSet_LinkedHashSet(null, null, null, V.FunctionType);
      this.task.compiler.enqueuer.codegen.universe.isChecks.forEach$1(0, new K.TypeTestEmitter_computeRequiredTypeChecks_closure(this));
    },
    static: {"^": "TypeTestEmitter_MAX_FUNCTION_TYPE_PREDICATES"}
  },
  TypeTestEmitter_classesUsingTypeVariableTests_closure: {
    "^": "Closure:123;",
    call$1: function(t) {
      return !!J.getInterceptor(t).$isTypeVariableType;
    },
    $isFunction: true
  },
  TypeTestEmitter_classesUsingTypeVariableTests_closure0: {
    "^": "Closure:37;",
    call$1: function(v) {
      return v.get$element().get$enclosingClass();
    },
    $isFunction: true
  },
  TypeTestEmitter_emitIsTests_generateIsTest: {
    "^": "Closure:47;this_0,classElement_1,builder_2",
    call$1: function(other) {
      var t1, t2;
      t1 = this.this_0.task;
      t2 = t1.compiler.objectClass;
      if ((other == null ? t2 == null : other === t2) && other !== this.classElement_1)
        return;
      this.builder_2.addProperty$2("$is" + H.S(t1.namer.getRuntimeTypeName$1(other)), C.C_JsBuilder.call$1("true"));
    },
    $isFunction: true
  },
  TypeTestEmitter_emitIsTests_generateFunctionTypeSignature: {
    "^": "Closure:124;this_3,builder_4",
    call$2: function(method, type) {
      var thisAccess, node, t1, closureData, t2, thisLocal, encoding;
      thisAccess = new Q.This("this", null, null);
      node = method.get$node();
      t1 = this.this_3;
      closureData = t1.task.compiler.closureToClassMapper.closureMappingCache.$index(0, node);
      if (closureData != null) {
        t2 = closureData.get$thisLocal();
        thisLocal = closureData._freeVariableMapping.$index(0, t2);
        if (thisLocal != null)
          thisAccess = C.C_JsBuilder.call$2("this.#", t1.task.namer.instanceFieldPropertyName$1(thisLocal));
      }
      encoding = t1.task.compiler.backend.get$rti().getSignatureEncoding$2(type, thisAccess);
      t1.task.namer;
      t2 = this.builder_4;
      if (type.get$typeVariableOccurrence() == null)
        t2.functionType = H.S(t1.task.metadataEmitter.reifyType$1(type));
      else
        t2.addProperty$2("$signature", encoding);
    },
    $isFunction: true
  },
  TypeTestEmitter_emitIsTests_generateSubstitution: {
    "^": "Closure:125;this_5,classElement_6,builder_7",
    call$2$emitNull: function(cls, emitNull) {
      var t1, rti, needsNativeCheck, expression, t2;
      if (cls.get$typeVariables().length === 0)
        return;
      t1 = this.this_5;
      rti = t1.task.compiler.backend.get$rti();
      needsNativeCheck = t1.task.nativeEmitter.requiresNativeIsCheck$1(cls);
      expression = rti.getSupertypeSubstitution$3$alwaysGenerateFunction(this.classElement_6, cls, true);
      if (expression == null)
        t2 = emitNull || needsNativeCheck;
      else
        t2 = false;
      if (t2)
        expression = new Q.LiteralNull(null, null);
      if (expression != null)
        this.builder_7.addProperty$2("$as" + H.S(t1.task.namer.getNameX$1(cls)), expression);
    },
    call$1: function(cls) {
      return this.call$2$emitNull(cls, false);
    },
    $isFunction: true
  },
  TypeTestEmitter_generateIsTestsOn_haveSameTypeVariables: {
    "^": "Closure:94;this_0",
    call$2: function(a, b) {
      if (a.get$isClosure())
        return true;
      return this.this_0.task.compiler.backend.get$rti().isTrivialSubstitution$2(a, b);
    },
    $isFunction: true
  },
  TypeTestEmitter_generateIsTestsOn_emitNothing: {
    "^": "Closure:126;",
    call$2$emitNull: function(_, emitNull) {
    },
    call$1: function(_) {
      return this.call$2$emitNull(_, null);
    },
    $isFunction: true
  },
  TypeTestEmitter_generateInterfacesIsTests_tryEmitTest: {
    "^": "Closure:45;this_0,emitIsTest_1,emitSubstitution_2,alreadyGenerated_3",
    call$1: function(check) {
      var t1 = this.alreadyGenerated_3;
      if (!t1.contains$1(0, check) && this.this_0.checkedClasses.contains$1(0, check)) {
        t1.add$1(0, check);
        this.emitIsTest_1.call$1(check);
        this.emitSubstitution_2.call$1(check);
      }
    },
    $isFunction: true
  },
  TypeTestEmitter_generateFunctionTypeTests_closure: {
    "^": "Closure:127;this_0",
    call$2: function(functionType, knownSubtype) {
      this.this_0.registerDynamicFunctionTypeCheck$1(functionType);
    },
    $isFunction: true
  },
  TypeTestEmitter_registerDynamicFunctionTypeCheck_closure: {
    "^": "Closure:23;",
    call$0: function() {
      return P.LinkedHashSet_LinkedHashSet(null, null, null, V.FunctionType);
    },
    $isFunction: true
  },
  TypeTestEmitter_computeRtiNeededClasses_addClassWithSuperclasses: {
    "^": "Closure:45;this_0",
    call$1: function(cls) {
      var t1, superclass;
      t1 = this.this_0.rtiNeededClasses;
      t1.add$1(0, cls);
      for (superclass = cls.get$superclass(); superclass != null; superclass = superclass.get$superclass())
        t1.add$1(0, superclass);
    },
    $isFunction: true
  },
  TypeTestEmitter_computeRtiNeededClasses_addClassesWithSuperclasses: {
    "^": "Closure:111;addClassWithSuperclasses_1",
    call$1: function(classes) {
      var t1, t2;
      for (t1 = H.setRuntimeTypeInfo(new P.LinkedHashSetIterator(classes, classes._modifications, null, null), [null]), t1._cell = t1._set._first, t2 = this.addClassWithSuperclasses_1; t1.moveNext$0();)
        t2.call$1(t1._collection$_current);
    },
    $isFunction: true
  },
  TypeTestEmitter_computeRtiNeededClasses_canTearOff: {
    "^": "Closure:76;this_2",
    call$1: function($function) {
      var t1, t2;
      if ($function.get$isFunction())
        t1 = $function.get$kind($function) === C.ElementKind_generative_constructor_16 || $function.get$isFactoryConstructor() || $function.get$isGetter() || $function.kind === C.ElementKind_setter_0;
      else
        t1 = true;
      if (t1)
        return false;
      else if ($function.get$isInstanceMember())
        if (!$function.get$enclosingClass().get$isClosure()) {
          t1 = this.this_2.task.compiler;
          t2 = t1.enqueuer.codegen.universe;
          return t2.hasMatchingSelector$3(t2.invokedGetters.$index(0, $function.name), $function, t1);
        }
      return false;
    },
    $isFunction: true
  },
  TypeTestEmitter_computeRtiNeededClasses_closure: {
    "^": "Closure:13;this_3,canTearOff_4",
    call$1: function(element) {
      var t1 = J.getInterceptor(element);
      if (!!t1.$isFunctionElement)
        if (!t1.$isConstructorBodyElement)
          t1 = this.canTearOff_4.call$1(element) === true || this.this_3.task.compiler.backend.isAccessibleByReflection$1(element);
        else
          t1 = false;
      else
        t1 = false;
      return t1;
    },
    $isFunction: true
  },
  TypeTestEmitter_computeRtiNeededClasses_closure0: {
    "^": "Closure:128;this_5",
    call$1: function($function) {
      var t1, type, t2, t3, cls;
      t1 = this.this_5;
      type = $function.computeType$1(t1.task.compiler);
      for (t2 = t1.task.compiler.backend.get$rti().compiler.backend, t3 = P.LinkedHashSet_LinkedHashSet(null, null, null, O.ClassElement), J.accept$2$x(type, new Z.FunctionArgumentCollector(t2, t3), false), t3 = H.setRuntimeTypeInfo(new P.LinkedHashSetIterator(t3, t3._modifications, null, null), [null]), t3._cell = t3._set._first, t1 = t1.rtiNeededClasses; t3.moveNext$0();) {
        cls = t3._collection$_current;
        for (; cls != null;) {
          t1.add$1(0, cls);
          cls = cls.get$superclass();
        }
      }
    },
    $isFunction: true
  },
  TypeTestEmitter_computeRequiredTypeChecks_closure: {
    "^": "Closure:123;this_0",
    call$1: function(t) {
      var t1 = J.getInterceptor(t);
      if (!!t1.$isInterfaceType)
        this.this_0.checkedClasses.add$1(0, t.get$element());
      else if (!!t1.$isFunctionType)
        this.this_0.checkedFunctionTypes.add$1(0, t);
    },
    $isFunction: true
  }
}],
["dart2js.library_loader", "package:compiler/implementation/library_loader.dart", , Z, {
  "^": "",
  CombinatorFilter: {
    "^": "Object;",
    exclude$1: function(element) {
      return false;
    },
    static: {CombinatorFilter_CombinatorFilter$fromTag: function(tag) {
        var t1, t2, show, nameSet, combinator, set, t3, t4, identifier;
        if (tag == null || tag.combinators == null)
          return C.C_CombinatorFilter;
        for (t1 = tag.combinators.nodes, t1.toString, t2 = H.setRuntimeTypeInfo(new E.LinkIterator(null, t1), [H.getTypeArgumentByIndex(t1, 0)]), show = false, nameSet = null; t2.moveNext$0();) {
          combinator = t2._util_implementation$_current;
          if (combinator.get$keywordToken().get$stringValue() === "show") {
            set = P.LinkedHashSet_LinkedHashSet(null, null, null, P.String);
            t3 = combinator.get$identifiers().nodes;
            t3.toString;
            t4 = new E.LinkIterator(null, t3);
            t4.$builtinTypeInfo = [H.getTypeArgumentByIndex(t3, 0)];
            for (; t4.moveNext$0();) {
              t3 = t4._util_implementation$_current.get$token();
              set.add$1(0, t3.get$value(t3));
            }
            nameSet = nameSet == null ? set : nameSet.intersection$1(0, set);
            show = true;
          }
        }
        if (nameSet == null)
          nameSet = P.LinkedHashSet_LinkedHashSet(null, null, null, P.String);
        for (t1 = H.setRuntimeTypeInfo(new E.LinkIterator(null, t1), [H.getTypeArgumentByIndex(t1, 0)]); t1.moveNext$0();) {
          combinator = t1._util_implementation$_current;
          if (combinator.get$keywordToken().get$stringValue() === "hide") {
            t2 = combinator.get$identifiers().nodes;
            t2.toString;
            t3 = new E.LinkIterator(null, t2);
            t3.$builtinTypeInfo = [H.getTypeArgumentByIndex(t2, 0)];
            for (; t3.moveNext$0();) {
              identifier = t3._util_implementation$_current;
              if (show) {
                t2 = identifier.get$token();
                nameSet.remove$1(0, t2.get$value(t2));
              } else {
                t2 = identifier.get$token();
                nameSet.add$1(0, t2.get$value(t2));
              }
            }
          }
        }
        return show ? new Z.ShowFilter(nameSet) : new Z.HideFilter(nameSet);
      }}
  },
  ShowFilter: {
    "^": "CombinatorFilter;includedNames",
    exclude$1: function(element) {
      return !this.includedNames.contains$1(0, element.get$name(element));
    }
  },
  HideFilter: {
    "^": "CombinatorFilter;excludedNames",
    exclude$1: function(element) {
      return this.excludedNames.contains$1(0, element.get$name(element));
    }
  },
  _LibraryLoaderTask: {
    "^": "CompilerTask;libraryCanonicalUriMap,libraryResourceUriMap,libraryNames,currentHandler,compiler,watch,profilerTag",
    get$name: function(_) {
      return "LibraryLoader";
    },
    reset$1$reuseLibrary: function(_, reuseLibrary) {
      var t1, libraries;
      t1 = this.libraryCanonicalUriMap;
      libraries = P.List_List$from(t1.get$values(t1), true, null);
      t1.clear$0(0);
      this.libraryResourceUriMap.clear$0(0);
      this.libraryNames.clear$0(0);
      H.setRuntimeTypeInfo(new H.WhereIterable(libraries, reuseLibrary), [H.getTypeArgumentByIndex(H.setRuntimeTypeInfo(new H.IterableMixinWorkaround(), [H.getTypeArgumentByIndex(libraries, 0)]), 0)]).forEach$1(0, this.get$mapLibrary());
    },
    mapLibrary$1: [function(library) {
      this.libraryCanonicalUriMap.$indexSet(0, library.get$canonicalUri(), library);
      this.libraryResourceUriMap.$indexSet(0, library.entryCompilationUnit.script.resourceUri, library);
      this.libraryNames.$indexSet(0, library.getLibraryOrScriptName$0(), library);
    }, "call$1", "get$mapLibrary", 2, 0, 129],
    loadLibrary$1: function(resolvedUri) {
      return this.measure$1(new Z._LibraryLoaderTask_loadLibrary_closure(this, resolvedUri));
    },
    processLibraryTags$2: function(handler, library) {
      var t1, libraryDependencies, t2;
      t1 = {};
      t1.tagState_0 = 0;
      t1.importsDartCore_1 = false;
      libraryDependencies = H.setRuntimeTypeInfo(new E.LinkBuilderImplementation(null, null, 0), [null]);
      t2 = library.entryCompilationUnit.script;
      return P.Future_forEach(library.get$tags(), new Z._LibraryLoaderTask_processLibraryTags_closure(t1, this, library, new Z._LibraryLoaderTask_processLibraryTags_checkTag(t1, this), libraryDependencies, t2.readableUri)).then$1(new Z._LibraryLoaderTask_processLibraryTags_closure0(this, handler, library)).then$1(new Z._LibraryLoaderTask_processLibraryTags_closure1(t1, this, handler, library)).then$1(new Z._LibraryLoaderTask_processLibraryTags_closure2(this, handler, library, libraryDependencies));
    },
    checkDuplicatedLibraryName$1: function(library) {
      var t1, resourceUri, tag, existing, t2, $name;
      t1 = {};
      resourceUri = library.entryCompilationUnit.script.resourceUri;
      tag = library.libraryTag;
      existing = this.libraryResourceUriMap.putIfAbsent$2(resourceUri, new Z._LibraryLoaderTask_checkDuplicatedLibraryName_closure(library));
      t1.existing_0 = existing;
      if (existing !== library) {
        t2 = this.compiler;
        if (tag != null)
          t2.withCurrentElement$2(library, new Z._LibraryLoaderTask_checkDuplicatedLibraryName_closure0(t1, this, library, resourceUri, tag));
        else
          t2.reportDiagnosticInternal$4(library, C.MessageKind_k2M, P.LinkedHashMap_LinkedHashMap$_literal(["resourceUri", resourceUri, "canonicalUri1", library.canonicalUri, "canonicalUri2", existing.get$canonicalUri()], null, null), C.Diagnostic_4_hint);
      } else if (tag != null) {
        $name = library.getLibraryOrScriptName$0();
        existing = this.libraryNames.putIfAbsent$2($name, new Z._LibraryLoaderTask_checkDuplicatedLibraryName_closure1(library));
        t1.existing_0 = existing;
        if (existing !== library) {
          t2 = this.compiler;
          t2.withCurrentElement$2(library, new Z._LibraryLoaderTask_checkDuplicatedLibraryName_closure2(this, tag, $name));
          t2.withCurrentElement$2(t1.existing_0, new Z._LibraryLoaderTask_checkDuplicatedLibraryName_closure3(t1, this, $name));
        }
      }
    },
    scanPart$3: function(part, resolvedUri, library) {
      var t1, readableUri;
      if (resolvedUri.scheme !== "") {
        t1 = resolvedUri._fragment;
        t1 = (t1 == null ? "" : t1) === "";
      } else
        t1 = false;
      if (!t1)
        throw H.wrapException(P.ArgumentError$(resolvedUri));
      t1 = this.compiler;
      readableUri = t1.translateResolvedUri$3(library, resolvedUri, part);
      if (readableUri == null)
        return P._Future$immediate(null, null);
      return t1.withCurrentElement$2(library, new Z._LibraryLoaderTask_scanPart_closure(this, part, library, readableUri));
    },
    registerLibraryFromTag$3: function(handler, library, tag) {
      return this.createLibrary$4(handler, library, library.entryCompilationUnit.script.readableUri.resolveUri$1(P.Uri_parse(tag.get$uri().get$dartString().slowToString$0())), tag.get$uri()).then$1(new Z._LibraryLoaderTask_registerLibraryFromTag_closure(this, handler, library, tag));
    },
    createLibrary$4: function(handler, importingLibrary, resolvedUri, node) {
      var t1, readableUri, library;
      t1 = this.compiler;
      readableUri = t1.translateResolvedUri$3(importingLibrary, resolvedUri, node);
      if (readableUri == null)
        return P._Future$immediate(null, null);
      library = this.libraryCanonicalUriMap.$index(0, resolvedUri);
      if (library != null)
        return P._Future$immediate(library, null);
      return t1.withCurrentElement$2(importingLibrary, new Z._LibraryLoaderTask_createLibrary_closure(this, handler, resolvedUri, node, readableUri));
    },
    createLibrary$3: function(handler, importingLibrary, resolvedUri) {
      return this.createLibrary$4(handler, importingLibrary, resolvedUri, null);
    }
  },
  _LibraryLoaderTask_loadLibrary_closure: {
    "^": "Closure:23;this_0,resolvedUri_1",
    call$0: function() {
      var t1, t2;
      t1 = this.this_0;
      t2 = new Z.LibraryDependencyHandler(t1, P.LinkedHashMap_LinkedHashMap(null, null, null, O.LibraryElement, Z.LibraryDependencyNode));
      t1.currentHandler = t2;
      return t1.createLibrary$3(t2, null, this.resolvedUri_1).then$1(new Z._LibraryLoaderTask_loadLibrary__closure(t1));
    },
    $isFunction: true
  },
  _LibraryLoaderTask_loadLibrary__closure: {
    "^": "Closure:79;this_2",
    call$1: function(library) {
      var t1 = this.this_2;
      return t1.compiler.withCurrentElement$2(library, new Z._LibraryLoaderTask_loadLibrary___closure(t1, library));
    },
    $isFunction: true
  },
  _LibraryLoaderTask_loadLibrary___closure: {
    "^": "Closure:23;this_3,library_4",
    call$0: function() {
      var t1 = this.this_3;
      return t1.measure$1(new Z._LibraryLoaderTask_loadLibrary____closure(t1, this.library_4));
    },
    $isFunction: true
  },
  _LibraryLoaderTask_loadLibrary____closure: {
    "^": "Closure:23;this_5,library_6",
    call$0: function() {
      var t1, loadedLibraries, t2;
      t1 = this.this_5;
      t1.currentHandler.computeExports$0();
      loadedLibraries = P.LinkedHashMap_LinkedHashMap$_empty(P.Uri, O.LibraryElement);
      t2 = t1.currentHandler.nodeMap;
      H.setRuntimeTypeInfo(new P.LinkedHashMapKeyIterable(t2), [H.getTypeArgumentByIndex(t2, 0)]).forEach$1(0, new Z._LibraryLoaderTask_loadLibrary_____closure(loadedLibraries));
      t1.currentHandler = null;
      return t1.compiler.onLibrariesLoaded$1(loadedLibraries).then$1(new Z._LibraryLoaderTask_loadLibrary_____closure0(this.library_6));
    },
    $isFunction: true
  },
  _LibraryLoaderTask_loadLibrary_____closure: {
    "^": "Closure:79;loadedLibraries_7",
    call$1: function(loadedLibrary) {
      this.loadedLibraries_7.$indexSet(0, loadedLibrary.get$canonicalUri(), loadedLibrary);
    },
    $isFunction: true
  },
  _LibraryLoaderTask_loadLibrary_____closure0: {
    "^": "Closure:13;library_8",
    call$1: function(_) {
      return this.library_8;
    },
    $isFunction: true
  },
  _LibraryLoaderTask_processLibraryTags_checkTag: {
    "^": "Closure:130;box_0,this_1",
    call$2: function(value, tag) {
      if (this.box_0.tagState_0 > value)
        this.this_1.compiler.reportFatalError$3(tag, C.MessageKind_wwi, P.LinkedHashMap_LinkedHashMap$_literal(["text", "Error: Out of order."], null, null));
      if (value >= 5)
        return H.ioore(C.List_yTu, value);
      return C.List_yTu[value];
    },
    $isFunction: true
  },
  _LibraryLoaderTask_processLibraryTags_closure: {
    "^": "Closure:131;box_0,this_2,library_3,checkTag_4,libraryDependencies_5,base_6",
    call$1: function(tag) {
      var t1, t2;
      t1 = this.this_2;
      t2 = this.library_3;
      return t1.compiler.withCurrentElement$2(t2, new Z._LibraryLoaderTask_processLibraryTags__closure1(this.box_0, t1, t2, this.checkTag_4, this.libraryDependencies_5, this.base_6, tag));
    },
    $isFunction: true
  },
  _LibraryLoaderTask_processLibraryTags__closure1: {
    "^": "Closure:23;box_0,this_7,library_8,checkTag_9,libraryDependencies_10,base_11,tag_12",
    call$0: function() {
      var t1, t2, resolvedUri;
      t1 = this.tag_12;
      if (t1.get$isImport()) {
        t2 = this.box_0;
        t2.tagState_0 = this.checkTag_9.call$2(2, t1);
        if (t1.get$uri().get$dartString().slowToString$0() === "dart:core")
          t2.importsDartCore_1 = true;
        this.libraryDependencies_10.addLast$1(t1);
      } else if (t1.get$isExport()) {
        this.box_0.tagState_0 = this.checkTag_9.call$2(2, t1);
        this.libraryDependencies_10.addLast$1(t1);
      } else if (t1.get$isLibraryName()) {
        this.box_0.tagState_0 = this.checkTag_9.call$2(1, t1);
        t2 = this.library_8;
        if (t2.libraryTag != null)
          this.this_7.compiler.internalError$2(t1, "Duplicated library declaration.");
        else
          t2.libraryTag = t1;
      } else {
        t2 = this.this_7;
        if (t1.get$isPart()) {
          resolvedUri = this.base_11.resolveUri$1(P.Uri_parse(t1.get$uri().get$dartString().slowToString$0()));
          this.box_0.tagState_0 = this.checkTag_9.call$2(3, t1);
          return t2.scanPart$3(t1, resolvedUri, this.library_8);
        } else
          t2.compiler.internalError$2(t1, "Unhandled library tag.");
      }
    },
    $isFunction: true
  },
  _LibraryLoaderTask_processLibraryTags_closure0: {
    "^": "Closure:13;this_13,handler_14,library_15",
    call$1: function(_) {
      var t1, t2, uri;
      t1 = this.this_13.compiler;
      t2 = this.library_15;
      uri = t2.canonicalUri;
      if (uri.$eq(0, $.get$Compiler_DART_CORE())) {
        t1.initializeCoreClasses$0();
        t1.identicalFunction = t1.coreLibrary.find$1(0, "identical");
      } else if (uri.$eq(0, $.get$Compiler_DART_INTERNAL()))
        t1.symbolImplementationClass = t1.findRequiredElement$2(t2, "Symbol");
      else if (uri.$eq(0, $.get$Compiler_DART_MIRRORS())) {
        t1.mirrorSystemClass = t1.findRequiredElement$2(t2, "MirrorSystem");
        t1.mirrorsUsedClass = t1.findRequiredElement$2(t2, "MirrorsUsed");
      } else if (uri.$eq(0, $.get$Compiler_DART_ASYNC()))
        t1.deferredLibraryClass = t1.findRequiredElement$2(t2, "DeferredLibrary");
      else if (uri.$eq(0, $.get$Compiler_DART_NATIVE_TYPED_DATA()))
        t1.typedDataClass = t1.findRequiredElement$2(t2, "NativeTypedData");
      else if (uri.$eq(0, $.get$JavaScriptBackend_DART_JS_HELPER()))
        t1.nativeAnnotationClass = t1.findRequiredElement$2(t2, "Native");
      return t1.backend.onLibraryScanned$2(t2, this.handler_14);
    },
    $isFunction: true
  },
  _LibraryLoaderTask_processLibraryTags_closure1: {
    "^": "Closure:13;box_0,this_16,handler_17,library_18",
    call$1: function(_) {
      var t1, t2;
      t1 = this.this_16;
      t2 = this.library_18;
      return t1.compiler.withCurrentElement$2(t2, new Z._LibraryLoaderTask_processLibraryTags__closure0(this.box_0, t1, this.handler_17, t2));
    },
    $isFunction: true
  },
  _LibraryLoaderTask_processLibraryTags__closure0: {
    "^": "Closure:23;box_0,this_19,handler_20,library_21",
    call$0: function() {
      var t1, t2, t3;
      t1 = this.this_19;
      t2 = this.library_21;
      t1.checkDuplicatedLibraryName$1(t2);
      if (!this.box_0.importsDartCore_1 && !t2.canonicalUri.$eq(0, $.get$Compiler_DART_CORE())) {
        t3 = this.handler_20;
        return t1.createLibrary$3(t3, null, $.get$Compiler_DART_CORE()).then$1(new Z._LibraryLoaderTask_processLibraryTags___closure0(t3, t2));
      }
    },
    $isFunction: true
  },
  _LibraryLoaderTask_processLibraryTags___closure0: {
    "^": "Closure:79;handler_22,library_23",
    call$1: function(coreLibrary) {
      this.handler_22.registerDependency$3(this.library_23, null, coreLibrary);
    },
    $isFunction: true
  },
  _LibraryLoaderTask_processLibraryTags_closure2: {
    "^": "Closure:13;this_24,handler_25,library_26,libraryDependencies_27",
    call$1: function(_) {
      return P.Future_forEach(this.libraryDependencies_27.toList$0(0), new Z._LibraryLoaderTask_processLibraryTags__closure(this.this_24, this.handler_25, this.library_26));
    },
    $isFunction: true
  },
  _LibraryLoaderTask_processLibraryTags__closure: {
    "^": "Closure:13;this_28,handler_29,library_30",
    call$1: function(tag) {
      var t1, t2;
      t1 = this.this_28;
      t2 = this.library_30;
      return t1.compiler.withCurrentElement$2(t2, new Z._LibraryLoaderTask_processLibraryTags___closure(t1, this.handler_29, t2, tag));
    },
    $isFunction: true
  },
  _LibraryLoaderTask_processLibraryTags___closure: {
    "^": "Closure:23;this_31,handler_32,library_33,tag_34",
    call$0: function() {
      return this.this_31.registerLibraryFromTag$3(this.handler_32, this.library_33, this.tag_34);
    },
    $isFunction: true
  },
  _LibraryLoaderTask_checkDuplicatedLibraryName_closure: {
    "^": "Closure:23;library_1",
    call$0: function() {
      return this.library_1;
    },
    $isFunction: true
  },
  _LibraryLoaderTask_checkDuplicatedLibraryName_closure0: {
    "^": "Closure:23;box_0,this_2,library_3,resourceUri_4,tag_5",
    call$0: function() {
      var t1 = this.tag_5.name;
      this.this_2.compiler.reportDiagnosticInternal$4(t1, C.MessageKind_wEh, P.LinkedHashMap_LinkedHashMap$_literal(["libraryName", t1, "resourceUri", this.resourceUri_4, "canonicalUri1", this.library_3.canonicalUri, "canonicalUri2", this.box_0.existing_0.get$canonicalUri()], null, null), C.Diagnostic_2_warning);
    },
    $isFunction: true
  },
  _LibraryLoaderTask_checkDuplicatedLibraryName_closure1: {
    "^": "Closure:23;library_6",
    call$0: function() {
      return this.library_6;
    },
    $isFunction: true
  },
  _LibraryLoaderTask_checkDuplicatedLibraryName_closure2: {
    "^": "Closure:23;this_7,tag_8,name_9",
    call$0: function() {
      this.this_7.compiler.reportDiagnosticInternal$4(this.tag_8.name, C.MessageKind_bti, P.LinkedHashMap_LinkedHashMap$_literal(["libraryName", this.name_9], null, null), C.Diagnostic_2_warning);
    },
    $isFunction: true
  },
  _LibraryLoaderTask_checkDuplicatedLibraryName_closure3: {
    "^": "Closure:23;box_0,this_10,name_11",
    call$0: function() {
      this.this_10.compiler.reportDiagnosticInternal$4(this.box_0.existing_0.get$libraryTag().name, C.MessageKind_bti, P.LinkedHashMap_LinkedHashMap$_literal(["libraryName", this.name_11], null, null), C.Diagnostic_2_warning);
    },
    $isFunction: true
  },
  _LibraryLoaderTask_scanPart_closure: {
    "^": "Closure:23;this_0,part_1,library_2,readableUri_3",
    call$0: function() {
      var t1 = this.this_0;
      return t1.compiler.readScript$2(this.part_1, this.readableUri_3).then$1(new Z._LibraryLoaderTask_scanPart__closure(t1, this.library_2));
    },
    $isFunction: true
  },
  _LibraryLoaderTask_scanPart__closure: {
    "^": "Closure:132;this_4,library_5",
    call$1: function(sourceScript) {
      var unit, t1;
      if (sourceScript == null)
        return;
      unit = U.CompilationUnitElementX$(sourceScript, this.library_5);
      t1 = this.this_4;
      t1.compiler.withCurrentElement$2(unit, new Z._LibraryLoaderTask_scanPart___closure(t1, unit));
    },
    $isFunction: true
  },
  _LibraryLoaderTask_scanPart___closure: {
    "^": "Closure:23;this_6,unit_7",
    call$0: function() {
      var t1, t2;
      t1 = this.this_6.compiler;
      t2 = this.unit_7;
      t1.scanner.scan$1(t2);
      if (t2.partTag == null)
        t1.reportDiagnosticInternal$4(t2, C.MessageKind_cWx, C.Map_empty, C.Diagnostic_1_error);
    },
    $isFunction: true
  },
  _LibraryLoaderTask_registerLibraryFromTag_closure: {
    "^": "Closure:79;this_0,handler_1,library_2,tag_3",
    call$1: function(loadedLibrary) {
      var t1;
      if (loadedLibrary == null)
        return;
      t1 = this.library_2;
      this.this_0.compiler.withCurrentElement$2(t1, new Z._LibraryLoaderTask_registerLibraryFromTag__closure(this.handler_1, t1, this.tag_3, loadedLibrary));
    },
    $isFunction: true
  },
  _LibraryLoaderTask_registerLibraryFromTag__closure: {
    "^": "Closure:23;handler_4,library_5,tag_6,loadedLibrary_7",
    call$0: function() {
      this.handler_4.registerDependency$3(this.library_5, this.tag_6, this.loadedLibrary_7);
    },
    $isFunction: true
  },
  _LibraryLoaderTask_createLibrary_closure: {
    "^": "Closure:23;this_0,handler_1,resolvedUri_2,node_3,readableUri_4",
    call$0: function() {
      var t1 = this.this_0;
      return t1.compiler.readScript$2(this.node_3, this.readableUri_4).then$1(new Z._LibraryLoaderTask_createLibrary__closure(t1, this.handler_1, this.resolvedUri_2));
    },
    $isFunction: true
  },
  _LibraryLoaderTask_createLibrary__closure: {
    "^": "Closure:132;this_5,handler_6,resolvedUri_7",
    call$1: function(script) {
      var t1, element, t2, t3;
      if (script == null)
        return;
      t1 = this.resolvedUri_7;
      element = U.LibraryElementX$(script, t1, null);
      t2 = this.this_5;
      t3 = this.handler_6;
      t2.compiler.withCurrentElement$2(element, new Z._LibraryLoaderTask_createLibrary___closure(t2, t3, t1, element));
      return t2.processLibraryTags$2(t3, element).then$1(new Z._LibraryLoaderTask_createLibrary___closure0(t2, t3, element));
    },
    $isFunction: true
  },
  _LibraryLoaderTask_createLibrary___closure: {
    "^": "Closure:23;this_8,handler_9,resolvedUri_10,element_11",
    call$0: function() {
      var t1, t2, libraryName, t3, compilationUnit, canonicalUri, resolvedUri;
      t1 = this.element_11;
      this.handler_9.registerNewLibrary$1(t1);
      t2 = t1.canonicalUri;
      libraryName = t2.toString$0(0);
      t3 = t1.entryCompilationUnit.script.file;
      if (J.contains$1$asx(t3 == null ? null : t3.filename, "dart/tests/compiler/dart2js_native") || libraryName === "dart:async" || libraryName === "dart:html" || libraryName === "dart:html_common" || libraryName === "dart:indexed_db" || libraryName === "dart:js" || libraryName === "dart:svg" || libraryName === "dart:_native_typed_data" || libraryName === "dart:web_audio" || libraryName === "dart:web_gl" || libraryName === "dart:web_sql")
        t1.canUseNative = true;
      t3 = this.this_8;
      t3.libraryCanonicalUriMap.$indexSet(0, this.resolvedUri_10, t1);
      t3 = t3.compiler.scanner;
      t3.toString;
      compilationUnit = t1.entryCompilationUnit;
      canonicalUri = t2.toString$0(0);
      resolvedUri = compilationUnit.script.readableUri.toString$0(0);
      if (canonicalUri === resolvedUri)
        t3.compiler.log$1("Scanning library " + canonicalUri);
      else
        t3.compiler.log$1("Scanning library " + canonicalUri + " (" + resolvedUri + ")");
      t3.scan$1(compilationUnit);
    },
    $isFunction: true
  },
  _LibraryLoaderTask_createLibrary___closure0: {
    "^": "Closure:13;this_12,handler_13,element_14",
    call$1: function(_) {
      var t1 = this.element_14;
      this.this_12.compiler.withCurrentElement$2(t1, new Z._LibraryLoaderTask_createLibrary____closure(this.handler_13, t1));
      return t1;
    },
    $isFunction: true
  },
  _LibraryLoaderTask_createLibrary____closure: {
    "^": "Closure:23;handler_15,element_16",
    call$0: function() {
      this.handler_15.nodeMap.$index(0, this.element_16).registerInitialExports$0();
    },
    $isFunction: true
  },
  ImportLink: {
    "^": "Object;$import,importedLibrary",
    importLibrary$2: function(compiler, importingLibrary) {
      var t1, t2, combinatorFilter, t3, prefix, existingElement, t4, t5, t6, prefixElement;
      t1 = {};
      t2 = this.$import;
      combinatorFilter = Z.CombinatorFilter_CombinatorFilter$fromTag(t2);
      if (t2 != null && t2.prefix != null) {
        t3 = t2.prefix.token;
        prefix = t3.get$value(t3);
        existingElement = importingLibrary.find$1(0, prefix);
        t1.prefixElement_0 = null;
        if (existingElement == null || existingElement.get$kind(existingElement) !== C.ElementKind_prefix_8) {
          t3 = importingLibrary.entryCompilationUnit;
          t4 = t2.importKeyword;
          t5 = P.LinkedHashMap_LinkedHashMap(null, null, null, P.String, O.Element);
          t6 = $.ElementX_elementHashCode + 1;
          $.ElementX_elementHashCode = t6;
          prefixElement = new U.PrefixElementX(t4, new U.ImportScope(t5), null, prefix, C.ElementKind_prefix_8, t3, t6, C.C_Link2, null, false);
          t1.prefixElement_0 = prefixElement;
          t3 = prefixElement;
        } else {
          t1.prefixElement_0 = existingElement;
          t3 = existingElement;
        }
        importingLibrary.localScope.add$2(0, t3, compiler);
        this.importedLibrary.forEachExport$1(new Z.ImportLink_importLibrary_closure(t1, this, compiler, combinatorFilter));
        if (t2.isDeferred === true) {
          t3 = t1.prefixElement_0;
          t4 = $.get$Modifiers_EMPTY();
          t5 = H.setRuntimeTypeInfo([], [O.FunctionElement]);
          t6 = $.ElementX_elementHashCode + 1;
          $.ElementX_elementHashCode = t6;
          t3.addImport$3(new U.DeferredLoaderGetterElementX(t3, null, null, t4, t5, null, true, null, null, null, "loadLibrary", C.ElementKind_function_2, t3, t6, C.C_Link2, null, false), t2, compiler);
          t1.prefixElement_0.markAsDeferred$1(t2);
        }
      } else
        this.importedLibrary.forEachExport$1(new Z.ImportLink_importLibrary_closure0(this, compiler, importingLibrary, combinatorFilter));
    }
  },
  ImportLink_importLibrary_closure: {
    "^": "Closure:77;box_0,this_1,compiler_2,combinatorFilter_3",
    call$1: function(element) {
      if (this.combinatorFilter_3.exclude$1(element))
        return;
      this.box_0.prefixElement_0.addImport$3(element, this.this_1.$import, this.compiler_2);
    },
    $isFunction: true
  },
  ImportLink_importLibrary_closure0: {
    "^": "Closure:77;this_4,compiler_5,importingLibrary_6,combinatorFilter_7",
    call$1: function(element) {
      var t1, t2;
      t1 = this.compiler_5;
      t2 = this.importingLibrary_6;
      t1.withCurrentElement$2(t2, new Z.ImportLink_importLibrary__closure(this.this_4, t1, t2, this.combinatorFilter_7, element));
    },
    $isFunction: true
  },
  ImportLink_importLibrary__closure: {
    "^": "Closure:23;this_8,compiler_9,importingLibrary_10,combinatorFilter_11,element_12",
    call$0: function() {
      var t1, t2;
      t1 = this.element_12;
      if (this.combinatorFilter_11.exclude$1(t1))
        return;
      t2 = this.importingLibrary_10;
      t2.importScope.addImport$4(t2, t1, this.this_8.$import, this.compiler_9);
    },
    $isFunction: true
  },
  ExportLink: {
    "^": "Object;$export,combinatorFilter,exportNode",
    exportElement$1: function(element) {
      if (this.combinatorFilter.exclude$1(element))
        return false;
      return this.exportNode.addElementToPendingExports$2(element, this.$export);
    }
  },
  LibraryDependencyNode: {
    "^": "Object;library<,hashCode>,imports@,dependencies<,exportScope<,exporters,pendingExportMap<",
    registerInitialExports$0: function() {
      var t1, t2, t3;
      for (t1 = this.library.getNonPrivateElementsInScope$0(), t1 = H.setRuntimeTypeInfo(new H.WhereIterator(J.get$iterator$ax(t1._iterable), t1._f), [H.getTypeArgumentByIndex(t1, 0)]), t2 = t1._iterator, t3 = this.pendingExportMap; t1.moveNext$0();)
        t3.$indexSet(0, t2.get$current(), C.C_Link21);
    },
    registerHandledExports$3: function(exportedLibraryElement, $export, filter) {
      var t1, t2, exportedElement;
      for (t1 = exportedLibraryElement.get$exports(), t1.toString, t1 = H.setRuntimeTypeInfo(new E.LinkIterator(null, t1), [H.getTypeArgumentByIndex(t1, 0)]), t2 = this.pendingExportMap; t1.moveNext$0();) {
        exportedElement = t1._util_implementation$_current;
        if (!filter.exclude$1(exportedElement))
          t2.$indexSet(0, exportedElement, t2.putIfAbsent$2(exportedElement, new Z.LibraryDependencyNode_registerHandledExports_closure()).prepend$1($export));
      }
    },
    registerImports$1: function(compiler) {
      var t1, t2;
      for (t1 = this.imports, t1 = H.setRuntimeTypeInfo(new E.LinkIterator(null, t1), [H.getTypeArgumentByIndex(t1, 0)]), t2 = this.library; t1.moveNext$0();)
        t1._util_implementation$_current.importLibrary$2(compiler, t2);
    },
    addElementToExportScope$3: function(compiler, element, exports) {
      var $name, t1, t2, t3, existingElement, t4, t5, existingExports;
      $name = element.get$name(element);
      t1 = new Z.LibraryDependencyNode_addElementToExportScope_reportDuplicateExport(this, compiler, $name);
      t2 = new Z.LibraryDependencyNode_addElementToExportScope_reportDuplicateExportDecl(this, compiler, $name);
      t3 = this.exportScope;
      existingElement = t3.$index(0, $name);
      if (existingElement != null && existingElement !== element)
        if (existingElement.get$isErroneous()) {
          t1.call$2(element, exports);
          t2.call$2(element, exports);
          element = existingElement;
        } else {
          t4 = this.library;
          if (existingElement.get$library() === t4)
            ;
          else {
            t5 = this.exporters;
            if (element.get$library() === t4) {
              t3.$indexSet(0, $name, element);
              t5.$indexSet(0, element, exports);
            } else {
              existingExports = t5.$index(0, existingElement);
              t1.call$2(existingElement, existingExports);
              t1.call$3$reportError(element, exports, false);
              t2.call$2(existingElement, existingExports);
              t2.call$2(element, exports);
              t1 = P.LinkedHashMap_LinkedHashMap$_literal(["name", $name], null, null);
              t2 = $.ElementX_elementHashCode + 1;
              $.ElementX_elementHashCode = t2;
              element = new U.ErroneousElementX(C.MessageKind_2No0, t1, null, $name, C.ElementKind_error_0, t4, t2, C.C_Link2, null, false);
              t3.$indexSet(0, $name, element);
            }
          }
        }
      else {
        t3.$indexSet(0, $name, element);
        this.exporters.$indexSet(0, element, exports);
      }
      return element;
    },
    propagateElement$1: function(element) {
      var t1, change;
      for (t1 = this.dependencies, t1 = H.setRuntimeTypeInfo(new E.LinkIterator(null, t1), [H.getTypeArgumentByIndex(t1, 0)]), change = false; t1.moveNext$0();)
        if (t1._util_implementation$_current.exportElement$1(element))
          change = true;
      return change;
    },
    addElementToPendingExports$2: function(element, $export) {
      var t1, t2;
      t1 = {};
      t1.changed_0 = false;
      if (this.exportScope.$index(0, element.get$name(element)) !== element) {
        t2 = this.pendingExportMap;
        t2.$indexSet(0, element, t2.putIfAbsent$2(element, new Z.LibraryDependencyNode_addElementToPendingExports_closure(t1)).prepend$1($export));
      }
      return t1.changed_0;
    },
    static: {"^": "LibraryDependencyNode_hashCodeCounter"}
  },
  LibraryDependencyNode_registerHandledExports_closure: {
    "^": "Closure:23;",
    call$0: function() {
      return C.C_Link21;
    },
    $isFunction: true
  },
  LibraryDependencyNode_addElementToExportScope_reportDuplicateExport: {
    "^": "Closure:133;this_1,compiler_2,name_3",
    call$3$reportError: function(duplicate, duplicateExports, reportError) {
      var t1, t2;
      t1 = {};
      t1.reportError_0 = reportError;
      t2 = this.compiler_2;
      t2.withCurrentElement$2(this.this_1.library, new Z.LibraryDependencyNode_addElementToExportScope_reportDuplicateExport_closure(t1, t2, this.name_3, duplicateExports));
    },
    call$2: function(duplicate, duplicateExports) {
      return this.call$3$reportError(duplicate, duplicateExports, true);
    },
    $isFunction: true
  },
  LibraryDependencyNode_addElementToExportScope_reportDuplicateExport_closure: {
    "^": "Closure:23;box_0,compiler_4,name_5,duplicateExports_6",
    call$0: function() {
      var t1, t2, t3, t4, $export;
      for (t1 = this.duplicateExports_6, t1.toString, t1 = H.setRuntimeTypeInfo(new E.LinkIterator(null, t1), [H.getTypeArgumentByIndex(t1, 0)]), t2 = this.compiler_4, t3 = this.name_5, t4 = this.box_0; t1.moveNext$0();) {
        $export = t1._util_implementation$_current;
        if (t4.reportError_0) {
          t2.reportDiagnosticInternal$4($export, C.MessageKind_2No0, P.LinkedHashMap_LinkedHashMap$_literal(["name", t3], null, null), C.Diagnostic_1_error);
          t4.reportError_0 = false;
        } else
          t2.reportDiagnosticInternal$4($export, C.MessageKind_zre, P.LinkedHashMap_LinkedHashMap$_literal(["name", t3], null, null), C.Diagnostic_8_info);
      }
    },
    $isFunction: true
  },
  LibraryDependencyNode_addElementToExportScope_reportDuplicateExportDecl: {
    "^": "Closure:134;this_7,compiler_8,name_9",
    call$2: function(duplicate, duplicateExports) {
      this.compiler_8.reportDiagnosticInternal$4(duplicate, C.MessageKind_CBD, P.LinkedHashMap_LinkedHashMap$_literal(["name", this.name_9, "uriString", duplicateExports.get$head(duplicateExports).get$uri()], null, null), C.Diagnostic_8_info);
    },
    $isFunction: true
  },
  LibraryDependencyNode_addElementToPendingExports_closure: {
    "^": "Closure:23;box_0",
    call$0: function() {
      this.box_0.changed_0 = true;
      return C.C_Link21;
    },
    $isFunction: true
  },
  LibraryDependencyHandler: {
    "^": "Object;task,nodeMap",
    get$compiler: function() {
      return this.task.compiler;
    },
    computeExports$0: function() {
      var t1, t2, tasks;
      t1 = {};
      t1.changed_0 = true;
      for (t2 = this.nodeMap; t1.changed_0;) {
        t1.changed_0 = false;
        tasks = P.LinkedHashMap_LinkedHashMap(null, null, null, Z.LibraryDependencyNode, [P.Map, O.Element, [O.Link, Y.Export]]);
        t2.forEach$1(0, new Z.LibraryDependencyHandler_computeExports_closure(tasks));
        tasks.forEach$1(0, new Z.LibraryDependencyHandler_computeExports_closure0(t1, this));
      }
      t2.forEach$1(0, new Z.LibraryDependencyHandler_computeExports_closure1());
      t2.forEach$1(0, new Z.LibraryDependencyHandler_computeExports_closure2(this));
    },
    registerDependency$3: function(library, tag, loadedLibrary) {
      var t1, t2, exportingNode, exportedNode, importingNode;
      t1 = tag != null;
      if (t1)
        library.tagMapping.$indexSet(0, tag, loadedLibrary);
      t2 = J.getInterceptor(tag);
      if (!!t2.$isExport) {
        t1 = this.nodeMap;
        exportingNode = t1.$index(0, library);
        if (loadedLibrary.get$exportsHandled()) {
          exportingNode.registerHandledExports$3(loadedLibrary, tag, Z.CombinatorFilter_CombinatorFilter$fromTag(tag));
          return;
        }
        exportedNode = t1.$index(0, loadedLibrary);
        exportedNode.dependencies = exportedNode.get$dependencies().prepend$1(new Z.ExportLink(tag, Z.CombinatorFilter_CombinatorFilter$fromTag(tag), exportingNode));
      } else if (!t1 || !!t2.$isImport) {
        importingNode = this.nodeMap.$index(0, library);
        importingNode.set$imports(importingNode.get$imports().prepend$1(new Z.ImportLink(tag, loadedLibrary)));
      }
    },
    registerNewLibrary$1: function(library) {
      var t1, uri;
      t1 = $.LibraryDependencyNode_hashCodeCounter + 1;
      $.LibraryDependencyNode_hashCodeCounter = t1;
      this.nodeMap.$indexSet(0, library, new Z.LibraryDependencyNode(library, t1, C.C_Link19, C.C_Link20, P.LinkedHashMap_LinkedHashMap(null, null, null, P.String, O.Element), P.LinkedHashMap_LinkedHashMap(null, null, null, O.Element, [O.Link, Y.Export]), P.LinkedHashMap_LinkedHashMap(null, null, null, O.Element, [O.Link, Y.Export])));
      t1 = this.task.compiler;
      uri = library.canonicalUri;
      if (uri.$eq(0, $.get$Compiler_DART_CORE()))
        t1.coreLibrary = library;
      else if (uri.$eq(0, $.get$Compiler_DART_NATIVE_TYPED_DATA()))
        t1.typedDataLibrary = library;
      else if (uri.$eq(0, $.get$Compiler_DART_MIRRORS()))
        t1.mirrorsLibrary = library;
      t1.backend.onLibraryCreated$1(library);
    }
  },
  LibraryDependencyHandler_computeExports_closure: {
    "^": "Closure:135;tasks_1",
    call$2: function(_, node) {
      var t1, pendingExports;
      t1 = node.get$pendingExportMap();
      pendingExports = P.LinkedHashMap_LinkedHashMap(null, null, null, O.Element, [O.Link, Y.Export]);
      pendingExports.addAll$1(0, t1);
      node.pendingExportMap.clear$0(0);
      this.tasks_1.$indexSet(0, node, pendingExports);
    },
    $isFunction: true
  },
  LibraryDependencyHandler_computeExports_closure0: {
    "^": "Closure:136;box_0,this_2",
    call$2: function(node, pendingExports) {
      J.forEach$1$ax(pendingExports, new Z.LibraryDependencyHandler_computeExports__closure(this.box_0, this.this_2, node));
    },
    $isFunction: true
  },
  LibraryDependencyHandler_computeExports__closure: {
    "^": "Closure:137;box_0,this_3,node_4",
    call$2: function(element, exports) {
      var t1 = this.node_4;
      if (t1.propagateElement$1(t1.addElementToExportScope$3(this.this_3.task.compiler, element, exports)))
        this.box_0.changed_0 = true;
    },
    $isFunction: true
  },
  LibraryDependencyHandler_computeExports_closure1: {
    "^": "Closure:138;",
    call$2: function(library, node) {
      var t1, t2;
      t1 = node.get$library();
      t2 = node.get$exportScope();
      t2 = t2.get$values(t2);
      t1.setExports$1(P.List_List$from(t2, true, H.getRuntimeTypeArgument(t2, "IterableBase", 0)));
    },
    $isFunction: true
  },
  LibraryDependencyHandler_computeExports_closure2: {
    "^": "Closure:138;this_5",
    call$2: function(library, node) {
      node.registerImports$1(this.this_5.task.compiler);
    },
    $isFunction: true
  }
}],
["dart2js.mirrors_used", "package:compiler/implementation/mirrors_used.dart", , F, {
  "^": "",
  MirrorUsageAnalyzerTask: {
    "^": "CompilerTask;librariesWithUsage,analyzer,compiler,watch,profilerTag",
    analyzeUsage$1: function(mainApp) {
      var t1, symbols, targets, metaTargets, t2, t3, t4;
      if (mainApp == null || this.compiler.mirrorsLibrary == null)
        return;
      this.measure$1(this.analyzer.get$run());
      t1 = this.analyzer.mergedMirrorUsage;
      symbols = t1.symbols;
      targets = t1.targets;
      metaTargets = t1.metaTargets;
      t1 = this.compiler.backend;
      if (symbols == null)
        t2 = null;
      else {
        t2 = P.LinkedHashSet_LinkedHashSet(null, null, null, P.String);
        t2.addAll$1(0, symbols);
      }
      if (targets == null)
        t3 = null;
      else {
        t3 = P.LinkedHashSet_LinkedHashSet(null, null, null, O.Element);
        t3.addAll$1(0, targets);
      }
      if (metaTargets == null)
        t4 = null;
      else {
        t4 = P.LinkedHashSet_LinkedHashSet(null, null, null, O.Element);
        t4.addAll$1(0, metaTargets);
      }
      t1.registerMirrorUsage$3(t2, t3, t4);
      this.librariesWithUsage = this.analyzer.librariesWithUsage;
    },
    hasMirrorUsage$1: function(element) {
      var library, t1;
      library = element.get$library();
      t1 = library.canonicalUri;
      if (!(t1.scheme === "dart" && C.JSString_methods.startsWith$1(t1._path, "_"))) {
        t1 = this.librariesWithUsage;
        t1 = t1 != null && t1.contains$1(0, library);
      } else
        t1 = true;
      return t1;
    },
    validate$2: function(node, mapping) {
      var t1, t2, named, constantCompiler, t3, value, builder;
      for (t1 = node.send.argumentsNode.nodes, t1.toString, t1 = H.setRuntimeTypeInfo(new E.LinkIterator(null, t1), [H.getTypeArgumentByIndex(t1, 0)]), t2 = this.compiler; t1.moveNext$0();) {
        named = t1._util_implementation$_current.asNamedArgument$0();
        if (named == null)
          continue;
        constantCompiler = t2.resolver.constantCompiler;
        t3 = named.expression;
        value = constantCompiler.compileNode$2(t3, mapping);
        builder = new F.MirrorUsageBuilder(this.analyzer, mapping.analyzedElement.get$library(), t3, value, mapping);
        t3 = named.name.token;
        if (t3.get$value(t3) === "symbols")
          this.analyzer.cachedStrings.$indexSet(0, value, builder.convertConstantToUsageList$2$onlyStrings(value, true));
        else if (t3.get$value(t3) === "targets")
          this.analyzer.cachedElements.$indexSet(0, value, builder.resolveUsageList$1(builder.convertConstantToUsageList$1(value)));
        else if (t3.get$value(t3) === "metaTargets")
          this.analyzer.cachedElements.$indexSet(0, value, builder.resolveUsageList$1(builder.convertConstantToUsageList$1(value)));
        else if (t3.get$value(t3) === "override")
          this.analyzer.cachedElements.$indexSet(0, value, builder.resolveUsageList$1(builder.convertConstantToUsageList$1(value)));
      }
    }
  },
  MirrorUsageAnalyzer: {
    "^": "Object;compiler<,task,wildcard,librariesWithUsage,cachedStrings,cachedElements,mergedMirrorUsage",
    run$0: [function() {
      var t1, usageMap, librariesWithoutUsage;
      t1 = this.compiler.libraryLoader.libraryCanonicalUriMap;
      t1 = t1.get$values(t1);
      this.wildcard = P.List_List$from(t1, true, H.getRuntimeTypeArgument(t1, "IterableBase", 0));
      usageMap = this.collectMirrorsUsedAnnotation$0();
      this.propagateOverrides$1(usageMap);
      librariesWithoutUsage = P.LinkedHashSet_LinkedHashSet(null, null, null, O.LibraryElement);
      usageMap.forEach$1(0, new F.MirrorUsageAnalyzer_run_closure(librariesWithoutUsage));
      if (librariesWithoutUsage._collection$_length === 0)
        this.mergedMirrorUsage = this.mergeUsages$1(usageMap);
      else
        this.mergedMirrorUsage = new F.MirrorUsage(null, null, null, null);
    }, "call$0", "get$run", 0, 0, 7],
    collectMirrorsUsedAnnotation$0: function() {
      var result, t1, t2, library, t3, t4, importTag;
      result = P.LinkedHashMap_LinkedHashMap(null, null, null, O.LibraryElement, [P.List, F.MirrorUsage]);
      for (t1 = this.compiler, t2 = t1.libraryLoader.libraryCanonicalUriMap, t2 = t2.get$values(t2), t2 = H.setRuntimeTypeInfo(new H.MappedIterator(null, J.get$iterator$ax(t2._iterable), t2._f), [H.getTypeArgumentByIndex(t2, 0), H.getTypeArgumentByIndex(t2, 1)]); t2.moveNext$0();) {
        library = t2.__internal$_current;
        if (library.get$isInternalLibrary())
          continue;
        t3 = library.tagsCache;
        if (t3 == null) {
          t3 = library.tagsBuilder.toList$0(0);
          library.tagsCache = t3;
          library.tagsBuilder = null;
        }
        t4 = new H.ListIterator(t3, t3.length, 0, null);
        t4.$builtinTypeInfo = [H.getTypeArgumentByIndex(t3, 0)];
        for (; t4.moveNext$0();) {
          importTag = t4.__internal$_current.asImport$0();
          if (importTag == null)
            continue;
          t1.withCurrentElement$2(library, new F.MirrorUsageAnalyzer_collectMirrorsUsedAnnotation_closure(this, result, library, importTag));
        }
      }
      return result;
    },
    propagateOverrides$1: function(usageMap) {
      var propagatedOverrides = P.LinkedHashMap_LinkedHashMap(null, null, null, O.LibraryElement, [P.List, F.MirrorUsage]);
      usageMap.forEach$1(0, new F.MirrorUsageAnalyzer_propagateOverrides_closure(this, propagatedOverrides));
      propagatedOverrides.forEach$1(0, new F.MirrorUsageAnalyzer_propagateOverrides_closure0(usageMap));
    },
    mirrorsUsedOnLibraryTag$2: function(library, tag) {
      var t1, result, t2, t3, t4, metadata, element, t5, fields, symbolsField, targetsField, metaTargetsField, overrideField;
      t1 = this.compiler;
      if (!J.$eq(library.tagMapping.$index(0, tag), t1.mirrorsLibrary))
        return;
      result = H.setRuntimeTypeInfo([], [F.MirrorUsage]);
      for (t2 = tag.metadata, t2.toString, t2 = H.setRuntimeTypeInfo(new E.LinkIterator(null, t2), [H.getTypeArgumentByIndex(t2, 0)]), t3 = this.cachedStrings, t4 = this.cachedElements; t2.moveNext$0();) {
        metadata = t2._util_implementation$_current;
        metadata.ensureResolved$1(t1);
        element = metadata.get$value(metadata).computeType$1(t1).get$element();
        t5 = t1.mirrorsUsedClass;
        if (element == null ? t5 == null : element === t5) {
          fields = metadata.value.get$fieldElements();
          symbolsField = t1.mirrorsUsedClass.lookupLocalMember$1("symbols");
          targetsField = t1.mirrorsUsedClass.lookupLocalMember$1("targets");
          metaTargetsField = t1.mirrorsUsedClass.lookupLocalMember$1("metaTargets");
          overrideField = t1.mirrorsUsedClass.lookupLocalMember$1("override");
          result.push(new F.MirrorUsage(t3.$index(0, fields.$index(0, symbolsField)), t4.$index(0, fields.$index(0, targetsField)), t4.$index(0, fields.$index(0, metaTargetsField)), t4.$index(0, fields.$index(0, overrideField))));
        }
      }
      return result;
    },
    mergeUsages$1: function(usageMap) {
      var usagesToMerge, result, t1;
      usagesToMerge = P.LinkedHashSet_LinkedHashSet(null, null, null, F.MirrorUsage);
      usageMap.forEach$1(0, new F.MirrorUsageAnalyzer_mergeUsages_closure(this, usagesToMerge));
      if (usagesToMerge._collection$_length === 0)
        return new F.MirrorUsage(null, this.wildcard, null, null);
      else {
        result = new F.MirrorUsage(null, null, null, null);
        for (t1 = H.setRuntimeTypeInfo(new P.LinkedHashSetIterator(usagesToMerge, usagesToMerge._modifications, null, null), [null]), t1._cell = t1._set._first; t1.moveNext$0();)
          result = this.merge$2(result, t1._collection$_current);
        return result;
      }
    },
    merge$2: function(a, b) {
      var symbols, t1, symbols0, t2, targets, metaTargets;
      symbols = a.symbols;
      t1 = symbols == null;
      if (t1 && a.targets == null && a.metaTargets == null)
        return b;
      else {
        symbols0 = b.symbols;
        t2 = symbols0 == null;
        if (t2 && b.targets == null && b.metaTargets == null)
          return a;
      }
      if (t1)
        symbols = symbols0;
      else if (!t2)
        J.addAll$1$ax(symbols, symbols0);
      targets = a.targets;
      if (targets == null)
        targets = b.targets;
      else if (targets !== this.wildcard && b.targets != null)
        J.addAll$1$ax(targets, b.targets);
      metaTargets = a.metaTargets;
      if (metaTargets == null)
        metaTargets = b.metaTargets;
      else if (metaTargets !== this.wildcard && b.metaTargets != null)
        J.addAll$1$ax(metaTargets, b.metaTargets);
      return new F.MirrorUsage(symbols, targets, metaTargets, null);
    },
    static: {MirrorUsageAnalyzer$: function(compiler, task) {
        return new F.MirrorUsageAnalyzer(compiler, task, null, P.LinkedHashSet_LinkedHashSet(null, null, null, O.LibraryElement), P.LinkedHashMap_LinkedHashMap(null, null, null, K.Constant, [P.List, P.String]), P.LinkedHashMap_LinkedHashMap(null, null, null, K.Constant, [P.List, O.Element]), null);
      }}
  },
  MirrorUsageAnalyzer_run_closure: {
    "^": "Closure:139;librariesWithoutUsage_0",
    call$2: function(library, usage) {
      if (J.get$isEmpty$asx(usage))
        this.librariesWithoutUsage_0.add$1(0, library);
    },
    $isFunction: true
  },
  MirrorUsageAnalyzer_collectMirrorsUsedAnnotation_closure: {
    "^": "Closure:23;this_0,result_1,library_2,importTag_3",
    call$0: function() {
      var t1, usages, t2, existing;
      t1 = this.library_2;
      usages = this.this_0.mirrorsUsedOnLibraryTag$2(t1, this.importTag_3);
      if (usages != null) {
        t2 = this.result_1;
        existing = t2.$index(0, t1);
        if (existing != null)
          J.addAll$1$ax(existing, usages);
        else
          t2.$indexSet(0, t1, usages);
      }
    },
    $isFunction: true
  },
  MirrorUsageAnalyzer_propagateOverrides_closure: {
    "^": "Closure:139;this_0,propagatedOverrides_1",
    call$2: function(library, usages) {
      var t1, t2, t3, usage, override, t4, t5, overridden;
      for (t1 = J.get$iterator$ax(usages), t2 = this.propagatedOverrides_1, t3 = this.this_0; t1.moveNext$0();) {
        usage = t1.get$current();
        override = usage.get$override();
        if (override == null)
          continue;
        t4 = t3.wildcard;
        if (override === t4) {
          t5 = new H.ListIterator(t4, t4.length, 0, null);
          t5.$builtinTypeInfo = [H.getTypeArgumentByIndex(t4, 0)];
          for (; t5.moveNext$0();) {
            overridden = t5.__internal$_current;
            if (!J.$eq(overridden, library))
              J.add$1$ax(t2.putIfAbsent$2(overridden, new F.MirrorUsageAnalyzer_propagateOverrides__closure0()), usage);
          }
        } else
          for (t4 = J.get$iterator$ax(override); t4.moveNext$0();)
            J.add$1$ax(t2.putIfAbsent$2(t4.get$current(), new F.MirrorUsageAnalyzer_propagateOverrides__closure1()), usage);
      }
    },
    $isFunction: true
  },
  MirrorUsageAnalyzer_propagateOverrides__closure0: {
    "^": "Closure:23;",
    call$0: function() {
      return H.setRuntimeTypeInfo([], [F.MirrorUsage]);
    },
    $isFunction: true
  },
  MirrorUsageAnalyzer_propagateOverrides__closure1: {
    "^": "Closure:23;",
    call$0: function() {
      return H.setRuntimeTypeInfo([], [F.MirrorUsage]);
    },
    $isFunction: true
  },
  MirrorUsageAnalyzer_propagateOverrides_closure0: {
    "^": "Closure:139;usageMap_2",
    call$2: function(overridden, overriddenUsages) {
      J.addAll$1$ax(this.usageMap_2.putIfAbsent$2(overridden, new F.MirrorUsageAnalyzer_propagateOverrides__closure()), overriddenUsages);
    },
    $isFunction: true
  },
  MirrorUsageAnalyzer_propagateOverrides__closure: {
    "^": "Closure:23;",
    call$0: function() {
      return H.setRuntimeTypeInfo([], [F.MirrorUsage]);
    },
    $isFunction: true
  },
  MirrorUsageAnalyzer_mergeUsages_closure: {
    "^": "Closure:139;this_0,usagesToMerge_1",
    call$2: function(library, usages) {
      this.this_0.librariesWithUsage.add$1(0, library);
      this.usagesToMerge_1.addAll$1(0, usages);
    },
    $isFunction: true
  },
  MirrorUsage: {
    "^": "Object;symbols,targets,metaTargets,override<",
    toString$0: function(_) {
      return "MirrorUsage(symbols = " + H.S(this.symbols) + ", targets = " + H.S(this.targets) + ", metaTargets = " + H.S(this.metaTargets) + ", override = " + H.S(this.override) + ")";
    }
  },
  MirrorUsageBuilder: {
    "^": "Object;analyzer,enclosingLibrary,spannable,constant<,elements>",
    get$compiler: function() {
      return this.analyzer.compiler;
    },
    convertConstantToUsageList$2$onlyStrings: function(constant, onlyStrings) {
      var result, t1, t2, entry, node, kind, iterable;
      if (constant.get$isNull())
        return;
      else if (constant.get$isList()) {
        result = onlyStrings ? H.setRuntimeTypeInfo([], [P.String]) : [];
        for (t1 = constant.get$entries(constant), t1 = H.setRuntimeTypeInfo(new H.ListIterator(t1, t1.length, 0, null), [H.getTypeArgumentByIndex(t1, 0)]), t2 = !onlyStrings; t1.moveNext$0();) {
          entry = t1.__internal$_current;
          if (entry.get$isString())
            result.push(entry.get$value(entry).slowToString$0());
          else if (t2 && entry.get$isType())
            result.push(entry.get$representedType());
          else {
            node = this.positionOf$1(entry);
            kind = onlyStrings ? C.MessageKind_l2M : C.MessageKind_Gx4;
            this.analyzer.compiler.reportDiagnosticInternal$4(node, kind, P.LinkedHashMap_LinkedHashMap$_literal(["name", node, "type", this.apiTypeOf$1(entry)], null, null), C.Diagnostic_4_hint);
          }
        }
        return result;
      } else if (!onlyStrings && constant.get$isType())
        return [constant.get$representedType()];
      else if (constant.get$isString()) {
        iterable = H.setRuntimeTypeInfo(new H.MappedListIterable(constant.get$value(constant).slowToString$0().split(","), new F.MirrorUsageBuilder_convertConstantToUsageList_closure()), [null, null]);
        return onlyStrings ? P.List_List$from(iterable, true, P.String) : iterable.toList$0(0);
      } else {
        node = this.positionOf$1(constant);
        kind = onlyStrings ? C.MessageKind_ijq : C.MessageKind_8sC;
        this.analyzer.compiler.reportDiagnosticInternal$4(node, kind, P.LinkedHashMap_LinkedHashMap$_literal(["name", node, "type", this.apiTypeOf$1(constant)], null, null), C.Diagnostic_4_hint);
        return;
      }
    },
    convertConstantToUsageList$1: function(constant) {
      return this.convertConstantToUsageList$2$onlyStrings(constant, false);
    },
    apiTypeOf$1: function(constant) {
      var t1, type, library, t2, cls, supertype;
      t1 = this.analyzer.compiler;
      type = constant.computeType$1(t1);
      library = type.get$element().get$library();
      if (type.get$kind(type) === C.TypeKind_interface) {
        t2 = library.canonicalUri;
        t2 = t2.scheme === "dart" && C.JSString_methods.startsWith$1(t2._path, "_");
      } else
        t2 = false;
      if (t2) {
        cls = type.get$element();
        cls.ensureResolved$1(t1);
        t1 = cls.get$allSupertypesAndSelf()._supertypes;
        t1.toString;
        t2 = new E.LinkIterator(null, t1);
        t2.$builtinTypeInfo = [H.getTypeArgumentByIndex(t1, 0)];
        for (; t2.moveNext$0();) {
          supertype = t2._util_implementation$_current;
          if (J.get$kind$x(supertype) === C.TypeKind_interface) {
            t1 = supertype.get$element().get$library().canonicalUri;
            t1 = !(t1.scheme === "dart" && C.JSString_methods.startsWith$1(t1._path, "_"));
          } else
            t1 = false;
          if (t1)
            return type.asInstanceOf$1(supertype.get$element());
        }
      }
      return type;
    },
    resolveUsageList$1: function(list) {
      var t1, result, t2, entry, t3, t4, t5, libraryCandiate, libraryNameCandiate, l, libraryName, e;
      if (list == null)
        return;
      t1 = list.length;
      if (t1 === 1) {
        if (0 >= t1)
          return H.ioore(list, 0);
        t1 = J.$eq(list[0], "*");
      } else
        t1 = false;
      if (t1)
        return this.analyzer.wildcard;
      result = H.setRuntimeTypeInfo([], [O.Element]);
      for (t1 = H.setRuntimeTypeInfo(new H.ListIterator(list, list.length, 0, null), [H.getTypeArgumentByIndex(list, 0)]), t2 = this.analyzer; t1.moveNext$0();) {
        entry = t1.__internal$_current;
        t3 = J.getInterceptor(entry);
        if (!!t3.$isDartType)
          result.push(entry.get$element());
        else {
          t4 = t2.compiler.libraryLoader.libraryCanonicalUriMap;
          t4 = t4.get$values(t4);
          t5 = new H.MappedIterator(null, J.get$iterator$ax(t4._iterable), t4._f);
          t5.$builtinTypeInfo = [H.getTypeArgumentByIndex(t4, 0), H.getTypeArgumentByIndex(t4, 1)];
          libraryCandiate = null;
          libraryNameCandiate = null;
          for (; t5.moveNext$0();) {
            l = t5.__internal$_current;
            if (l.hasLibraryName$0()) {
              libraryName = l.getLibraryOrScriptName$0();
              if (t3.$eq(entry, libraryName)) {
                libraryNameCandiate = libraryName;
                libraryCandiate = l;
                break;
              } else if (t3.startsWith$1(entry, libraryName + "."))
                if (libraryNameCandiate == null || libraryNameCandiate.length < libraryName.length) {
                  libraryNameCandiate = libraryName;
                  libraryCandiate = l;
                }
            }
          }
          if (libraryNameCandiate == null ? entry == null : libraryNameCandiate === entry)
            e = libraryCandiate;
          else
            e = libraryNameCandiate != null ? this.resolveLocalExpression$2(libraryCandiate, t3.substring$1(entry, libraryNameCandiate.length + 1).split(".")) : this.resolveExpression$1(entry);
          if (e != null)
            result.push(e);
        }
      }
      return result;
    },
    resolveExpression$1: function(expression) {
      var identifiers, element;
      identifiers = expression.split(".");
      if (0 >= identifiers.length)
        return H.ioore(identifiers, 0);
      element = this.enclosingLibrary.find$1(0, identifiers[0]);
      if (element == null) {
        this.analyzer.compiler.reportDiagnosticInternal$4(this.spannable, C.MessageKind_c2k, P.LinkedHashMap_LinkedHashMap$_literal(["name", expression], null, null), C.Diagnostic_4_hint);
        return;
      } else {
        if (identifiers.length === 1)
          return element;
        return this.resolveLocalExpression$2(element, C.JSArray_methods.sublist$1(identifiers, 1));
      }
    },
    resolveLocalExpression$2: function(element, identifiers) {
      var t1, current, identifier, e, t2;
      t1 = new H.ListIterator(identifiers, identifiers.length, 0, null);
      t1.$builtinTypeInfo = [H.getTypeArgumentByIndex(identifiers, 0)];
      current = element;
      for (; t1.moveNext$0(); current = e) {
        identifier = t1.__internal$_current;
        e = this.findLocalMemberIn$2(current, identifier);
        if (e == null) {
          t1 = this.analyzer;
          t2 = this.spannable;
          if (current.get$kind(current) === C.ElementKind_library_0) {
            t1 = t1.compiler;
            if (0 >= identifiers.length)
              return H.ioore(identifiers, 0);
            t1.reportDiagnosticInternal$4(t2, C.MessageKind_00, P.LinkedHashMap_LinkedHashMap$_literal(["name", identifiers[0], "library", current.getLibraryOrScriptName$0()], null, null), C.Diagnostic_4_hint);
          } else
            t1.compiler.reportDiagnosticInternal$4(t2, C.MessageKind_27z, P.LinkedHashMap_LinkedHashMap$_literal(["name", identifier, "element", current.name], null, null), C.Diagnostic_4_hint);
          return current;
        }
      }
      return current;
    },
    findLocalMemberIn$2: function(element, $name) {
      if (!!J.getInterceptor(element).$isScopeContainerElement) {
        if (element.get$isClass())
          element.ensureResolved$1(this.analyzer.compiler);
        return element.localLookup$1($name);
      }
      return;
    },
    positionOf$1: function(constant) {
      var t1, t2;
      t1 = {};
      t1.node_0 = null;
      t2 = this.elements._constants;
      if (t2 != null)
        t2.forEach$1(0, new F.MirrorUsageBuilder_positionOf_closure(t1, constant));
      t1 = t1.node_0;
      if (t1 == null)
        return this.spannable;
      return t1;
    }
  },
  MirrorUsageBuilder_convertConstantToUsageList_closure: {
    "^": "Closure:13;",
    call$1: function(e) {
      return J.trim$0$s(e);
    },
    $isFunction: true
  },
  MirrorUsageBuilder_positionOf_closure: {
    "^": "Closure:140;box_0,constant_1",
    call$2: function(n, c) {
      var t1 = this.box_0;
      if (t1.node_0 == null && J.$eq(c, this.constant_1))
        t1.node_0 = n;
    },
    $isFunction: true
  }
}],
["dart2js.optimizers", "package:compiler/implementation/cps_ir/optimizers.dart", , X, {
  "^": "",
  _isBetaContLin: function(node) {
    var cont, t1;
    cont = node.get$continuation();
    t1 = cont.firstRef;
    if (!(t1 != null && t1.next == null))
      return false;
    t1 = t1.parent;
    if (!!J.getInterceptor(t1).$isInvokeContinuation) {
      t1 = t1.get$continuation().definition;
      return cont == null ? t1 == null : cont === t1;
    }
    return false;
  },
  _isEtaCont: function(node) {
    var cont, t1, invokedCont, t2, t3, i, t4, t5;
    cont = node.get$continuation();
    t1 = cont.body;
    if (!J.getInterceptor(t1).$isInvokeContinuation)
      return false;
    invokedCont = t1.get$continuation().definition;
    if (invokedCont.get$body(invokedCont) == null)
      return false;
    if (t1.get$isRecursive())
      return false;
    t2 = cont.parameters;
    t3 = t2.length;
    if (t3 !== t1.arguments.length)
      return false;
    for (i = 0; i < t3; ++i, t3 = t4) {
      t3 = t1.arguments;
      if (i >= t3.length)
        return H.ioore(t3, i);
      t3 = t3[i].get$definition();
      t4 = t2.length;
      if (i >= t4)
        return H.ioore(t2, i);
      t5 = t2[i];
      if (t3 == null ? t5 != null : t3 !== t5)
        return false;
    }
    return true;
  },
  RedundantPhiEliminator: {
    "^": "RecursiveVisitor0;cont2invokes,ref2cont,workSet",
    rewrite$1: function(root) {
      var t1, t2, t3, cont;
      root.accept$1(0, this);
      t1 = this.workSet;
      t2 = this.cont2invokes;
      t1.addAll$1(0, t2.get$keys());
      for (; t1._collection$_length !== 0;) {
        t3 = t1._first;
        if (t3 == null)
          H.throwExpression(P.StateError$("No elements"));
        cont = t3._element;
        t1.remove$1(0, cont);
        if (J.get$body$x(cont) == null)
          continue;
        this._processContinuation$2(cont, t2.$index(0, cont));
      }
    },
    _processContinuation$2: function(cont, invokes) {
      var t1, t2, t3, t4, t5, dst, src, uniqueDefinition, t6, t7, invoke, t8, oldDefinition, ref, thatCont;
      t1 = new X.RedundantPhiEliminator__processContinuation_uniqueDefinitionOf(cont, invokes);
      for (t2 = cont.parameters, t3 = J.getInterceptor$ax(invokes), t4 = this.ref2cont, t5 = this.workSet, dst = 0, src = 0; src < t2.length; ++src) {
        uniqueDefinition = t1.call$1(src);
        if (uniqueDefinition == null) {
          t6 = t2.length;
          if (src >= t6)
            return H.ioore(t2, src);
          t7 = t2[src];
          if (dst >= t6)
            return H.ioore(t2, dst);
          t2[dst] = t7;
          for (t6 = t3.get$iterator(invokes); t6.moveNext$0();) {
            invoke = t6.get$current();
            t7 = invoke.get$arguments();
            t8 = invoke.get$arguments();
            if (src >= t8.length)
              return H.ioore(t8, src);
            t8 = t8[src];
            if (dst >= t7.length)
              return H.ioore(t7, dst);
            t7[dst] = t8;
          }
          ++dst;
          continue;
        }
        if (src >= t2.length)
          return H.ioore(t2, src);
        oldDefinition = t2[src];
        for (ref = oldDefinition.get$firstRef(); ref != null; ref = ref.next) {
          thatCont = t4.$index(0, ref);
          if (thatCont != null && thatCont !== cont)
            t5.add$1(0, thatCont);
        }
        uniqueDefinition.substituteFor$1(oldDefinition);
        for (t6 = t3.get$iterator(invokes); t6.moveNext$0();) {
          t7 = t6.get$current().get$arguments();
          if (src >= t7.length)
            return H.ioore(t7, src);
          t7[src].unlink$0();
        }
      }
      C.JSArray_methods.set$length(t2, dst);
      for (t1 = t3.get$iterator(invokes); t1.moveNext$0();)
        J.set$length$asx(t1.get$current().get$arguments(), dst);
    },
    visitInvokeContinuation$1: function(node) {
      var t1;
      J.add$1$ax(this.cont2invokes.putIfAbsent$2(node.continuation.definition, new X.RedundantPhiEliminator_visitInvokeContinuation_closure()), node);
      t1 = node.arguments;
      t1.toString;
      H.IterableMixinWorkaround_forEach(t1, new X.RedundantPhiEliminator_visitInvokeContinuation_closure0(this, node));
    }
  },
  RedundantPhiEliminator__processContinuation_uniqueDefinitionOf: {
    "^": "Closure:141;cont_0,invokes_1",
    call$1: function(i) {
      var t1, t2, value, t3, def;
      for (t1 = J.get$iterator$ax(this.invokes_1), t2 = this.cont_0.parameters, value = null; t1.moveNext$0();) {
        t3 = t1.get$current().get$arguments();
        if (i >= t3.length)
          return H.ioore(t3, i);
        def = t3[i].get$definition();
        if (i >= t2.length)
          return H.ioore(t2, i);
        if (J.$eq(t2[i], def))
          continue;
        else if (value == null)
          value = def;
        else if (value !== def)
          return;
      }
      return value;
    },
    $isFunction: true
  },
  RedundantPhiEliminator_visitInvokeContinuation_closure: {
    "^": "Closure:23;",
    call$0: function() {
      return H.setRuntimeTypeInfo([], [D.InvokeContinuation]);
    },
    $isFunction: true
  },
  RedundantPhiEliminator_visitInvokeContinuation_closure0: {
    "^": "Closure:99;this_0,node_1",
    call$1: function(ref) {
      this.this_0.ref2cont.$indexSet(0, ref, this.node_1.continuation.definition);
    },
    $isFunction: true
  },
  ShrinkingReducer: {
    "^": "Object;_redexVisitor,_worklist",
    rewrite$1: function(root) {
      var t1, t2, task;
      t1 = P.LinkedHashSet_LinkedHashSet(null, null, null, X._ReductionTask);
      this._worklist = t1;
      this._redexVisitor = new X._RedexVisitor(t1);
      root.accept$1(0, new X._ParentVisitor());
      this._redexVisitor.visitFunctionDefinition$1(root);
      for (; t1 = this._worklist, t1._collection$_length !== 0;) {
        t2 = t1._first;
        if (t2 == null)
          H.throwExpression(P.StateError$("No elements"));
        task = t2._element;
        t1.remove$1(0, task);
        this._processTask$1(task);
      }
    },
    _removeNode$1: function(node) {
      var body, $parent;
      body = node.get$body(node);
      $parent = node.parent;
      body.parent = $parent;
      $parent.set$body(0, body);
      node.parent = $.get$ShrinkingReducer__DELETED();
    },
    _processTask$1: function(task) {
      var t1, t2, t3;
      t1 = task.node;
      t2 = t1.parent;
      t3 = $.get$ShrinkingReducer__DELETED();
      if (t2 == null ? t3 == null : t2 === t3)
        return;
      switch (task.kind) {
        case C._ReductionKind_yP5:
          this._removeNode$1(t1);
          t2 = this._worklist;
          t1.get$primitive().accept$1(0, new X._RemovalRedexVisitor(t2));
          break;
        case C._ReductionKind_RsV:
          this._removeNode$1(t1);
          t2 = this._worklist;
          t1.get$continuation().accept$1(0, new X._RemovalRedexVisitor(t2));
          break;
        case C._ReductionKind_Yqr:
          this._reduceBetaContLin$1(task);
          break;
        case C._ReductionKind_Jmi:
          this._reduceEtaCont$1(task);
          break;
      }
    },
    _reduceBetaContLin$1: function(task) {
      var t1, cont, invoke, invokeParent, t2, i, t3;
      t1 = task.node;
      if (!X._isBetaContLin(t1))
        return;
      cont = t1.get$continuation();
      this._removeNode$1(t1);
      invoke = cont.firstRef.parent;
      t1 = J.getInterceptor$x(invoke);
      invokeParent = t1.get$parent(invoke);
      t2 = cont.body;
      t2.parent = invokeParent;
      J.set$body$x(invokeParent, t2);
      for (i = 0; i < invoke.get$arguments().length; ++i) {
        t2 = invoke.get$arguments();
        if (i >= t2.length)
          return H.ioore(t2, i);
        t2 = t2[i].get$definition();
        t3 = cont.parameters;
        if (i >= t3.length)
          return H.ioore(t3, i);
        t2.substituteFor$1(t3[i]);
      }
      t1.accept$1(invoke, new X._RemovalRedexVisitor(this._worklist));
    },
    _reduceEtaCont$1: function(task) {
      var t1, cont;
      t1 = task.node;
      if (!X._isEtaCont(t1))
        return;
      cont = t1.get$continuation();
      this._removeNode$1(t1);
      cont.body.get$continuation().definition.substituteFor$1(cont);
      cont.accept$1(0, new X._RemovalRedexVisitor(this._worklist));
    },
    static: {"^": "ShrinkingReducer__DELETED"}
  },
  _RedexVisitor: {
    "^": "RecursiveVisitor0;worklist",
    processLetPrim$1: function(node) {
      var t1, t2;
      t1 = node.parent;
      t2 = $.get$ShrinkingReducer__DELETED();
      if (t1 == null ? t2 == null : t1 === t2)
        return;
      else if (node.primitive.firstRef == null)
        this.worklist.add$1(0, new X._ReductionTask(C._ReductionKind_yP5, node));
    },
    processLetCont$1: function(node) {
      var t1, t2;
      t1 = node.parent;
      t2 = $.get$ShrinkingReducer__DELETED();
      if (t1 == null ? t2 == null : t1 === t2)
        return;
      else if (node.continuation.firstRef == null)
        this.worklist.add$1(0, new X._ReductionTask(C._ReductionKind_RsV, node));
      else if (X._isEtaCont(node))
        this.worklist.add$1(0, new X._ReductionTask(C._ReductionKind_Jmi, node));
      else if (X._isBetaContLin(node))
        this.worklist.add$1(0, new X._ReductionTask(C._ReductionKind_Yqr, node));
    }
  },
  _RemovalRedexVisitor: {
    "^": "_RedexVisitor;worklist",
    processLetPrim$1: function(node) {
      node.parent = $.get$ShrinkingReducer__DELETED();
    },
    processLetCont$1: function(node) {
      node.parent = $.get$ShrinkingReducer__DELETED();
    },
    processReference$1: [function(reference) {
      var t1, t2, $parent;
      reference.unlink$0();
      t1 = reference.definition;
      t2 = J.getInterceptor(t1);
      if (!!t2.$isPrimitive) {
        $parent = t1.parent;
        if (!!J.getInterceptor($parent).$isLetPrim && $parent.primitive.firstRef == null)
          this.worklist.add$1(0, new X._ReductionTask(C._ReductionKind_yP5, $parent));
      } else if (!!t2.$isContinuation) {
        if (t1.get$isRecursive()) {
          t2 = t1.firstRef;
          t2 = t2 == null || t2.next == null;
        } else
          t2 = false;
        if (t2)
          t1.isRecursive = false;
        $parent = t1.parent;
        if (!!J.getInterceptor($parent).$isLetCont && $parent.continuation.firstRef == null)
          this.worklist.add$1(0, new X._ReductionTask(C._ReductionKind_RsV, $parent));
      }
    }, "call$1", "get$processReference", 2, 0, 102]
  },
  _ParentVisitor: {
    "^": "RecursiveVisitor0;",
    processFunctionDefinition$1: function(node) {
      node.body.parent = node;
      H.IterableMixinWorkaround_forEach(node.parameters, new X._ParentVisitor_processFunctionDefinition_closure(node));
    },
    processLetPrim$1: function(node) {
      node.primitive.parent = node;
      node.body.parent = node;
    },
    processLetCont$1: function(node) {
      node.continuation.parent = node;
      node.body.parent = node;
    },
    processInvokeStatic$1: function(node) {
      node.continuation.parent = node;
      H.IterableMixinWorkaround_forEach(node.arguments, new X._ParentVisitor_processInvokeStatic_closure(node));
    },
    processInvokeContinuation$1: function(node) {
      var t1;
      node.continuation.parent = node;
      t1 = node.arguments;
      t1.toString;
      H.IterableMixinWorkaround_forEach(t1, new X._ParentVisitor_processInvokeContinuation_closure(node));
    },
    processInvokeMethod$1: function(node) {
      node.receiver.parent = node;
      node.continuation.parent = node;
      H.IterableMixinWorkaround_forEach(node.arguments, new X._ParentVisitor_processInvokeMethod_closure(node));
    },
    processInvokeSuperMethod$1: function(node) {
      node.continuation.parent = node;
      H.IterableMixinWorkaround_forEach(node.arguments, new X._ParentVisitor_processInvokeSuperMethod_closure(node));
    },
    processInvokeConstructor$1: function(node) {
      node.continuation.parent = node;
      H.IterableMixinWorkaround_forEach(node.arguments, new X._ParentVisitor_processInvokeConstructor_closure(node));
    },
    processConcatenateStrings$1: function(node) {
      node.continuation.parent = node;
      H.IterableMixinWorkaround_forEach(node.arguments, new X._ParentVisitor_processConcatenateStrings_closure(node));
    },
    processBranch$1: function(node) {
      node.condition.parent = node;
      node.trueContinuation.parent = node;
      node.falseContinuation.parent = node;
    },
    processTypeOperator$1: function(node) {
      node.continuation.parent = node;
      node.receiver.parent = node;
    },
    processSetClosureVariable$1: function(node) {
      node.body.parent = node;
      node.value.parent = node;
    },
    processDeclareFunction$1: function(node) {
      node.definition.parent = node;
      node.body.parent = node;
    },
    processLiteralList$1: function(node) {
      H.IterableMixinWorkaround_forEach(node.values, new X._ParentVisitor_processLiteralList_closure(node));
    },
    processLiteralMap$1: function(node) {
      H.IterableMixinWorkaround_forEach(node.values, new X._ParentVisitor_processLiteralMap_closure(node));
      H.IterableMixinWorkaround_forEach(node.keys, new X._ParentVisitor_processLiteralMap_closure0(node));
    },
    processCreateFunction$1: function(node) {
      node.definition.parent = node;
    },
    processContinuation$1: function(node) {
      node.body.parent = node;
      H.IterableMixinWorkaround_forEach(node.parameters, new X._ParentVisitor_processContinuation_closure(node));
    },
    processIsTrue$1: function(node) {
      node.value.parent = node;
    }
  },
  _ParentVisitor_processFunctionDefinition_closure: {
    "^": "Closure:100;node_0",
    call$1: function(p) {
      var t1 = this.node_0;
      J.set$parent$x(p, t1);
      return t1;
    },
    $isFunction: true
  },
  _ParentVisitor_processInvokeStatic_closure: {
    "^": "Closure:99;node_0",
    call$1: function(ref) {
      var t1 = this.node_0;
      J.set$parent$x(ref, t1);
      return t1;
    },
    $isFunction: true
  },
  _ParentVisitor_processInvokeContinuation_closure: {
    "^": "Closure:99;node_0",
    call$1: function(ref) {
      var t1 = this.node_0;
      J.set$parent$x(ref, t1);
      return t1;
    },
    $isFunction: true
  },
  _ParentVisitor_processInvokeMethod_closure: {
    "^": "Closure:99;node_0",
    call$1: function(ref) {
      var t1 = this.node_0;
      J.set$parent$x(ref, t1);
      return t1;
    },
    $isFunction: true
  },
  _ParentVisitor_processInvokeSuperMethod_closure: {
    "^": "Closure:99;node_0",
    call$1: function(ref) {
      var t1 = this.node_0;
      J.set$parent$x(ref, t1);
      return t1;
    },
    $isFunction: true
  },
  _ParentVisitor_processInvokeConstructor_closure: {
    "^": "Closure:99;node_0",
    call$1: function(ref) {
      var t1 = this.node_0;
      J.set$parent$x(ref, t1);
      return t1;
    },
    $isFunction: true
  },
  _ParentVisitor_processConcatenateStrings_closure: {
    "^": "Closure:99;node_0",
    call$1: function(ref) {
      var t1 = this.node_0;
      J.set$parent$x(ref, t1);
      return t1;
    },
    $isFunction: true
  },
  _ParentVisitor_processLiteralList_closure: {
    "^": "Closure:99;node_0",
    call$1: function(ref) {
      var t1 = this.node_0;
      J.set$parent$x(ref, t1);
      return t1;
    },
    $isFunction: true
  },
  _ParentVisitor_processLiteralMap_closure: {
    "^": "Closure:99;node_0",
    call$1: function(ref) {
      var t1 = this.node_0;
      J.set$parent$x(ref, t1);
      return t1;
    },
    $isFunction: true
  },
  _ParentVisitor_processLiteralMap_closure0: {
    "^": "Closure:99;node_1",
    call$1: function(ref) {
      var t1 = this.node_1;
      J.set$parent$x(ref, t1);
      return t1;
    },
    $isFunction: true
  },
  _ParentVisitor_processContinuation_closure: {
    "^": "Closure:100;node_0",
    call$1: function(param) {
      var t1 = this.node_0;
      J.set$parent$x(param, t1);
      return t1;
    },
    $isFunction: true
  },
  _ReductionKind: {
    "^": "Object;name>,hashCode>",
    toString$0: function(_) {
      return this.name;
    },
    static: {"^": "_ReductionKind_DEAD_VAL,_ReductionKind_DEAD_CONT,_ReductionKind_BETA_CONT_LIN,_ReductionKind_ETA_CONT"}
  },
  _ReductionTask: {
    "^": "Object;kind>,node<",
    get$hashCode: function(_) {
      return (this.node.hashCode << 2 | this.kind.hashCode) >>> 0;
    },
    $eq: function(_, that) {
      if (that == null)
        return false;
      return J.get$kind$x(that) === this.kind && that.get$node() === this.node;
    },
    toString$0: function(_) {
      return this.kind.name + ": " + H.Primitives_objectToString(this.node);
    }
  },
  _DeletedNode: {
    "^": "Node4;hashCode,parent",
    accept$1: function(_, _0) {
      return;
    }
  }
}],
["dart2js.util", "package:compiler/implementation/util/util.dart", , O, {
  "^": "",
  equalElements: function(a, b) {
    var index, t1;
    if (a.length !== b.length)
      return false;
    for (index = 0; index < a.length; ++index) {
      t1 = a[index];
      if (index >= b.length)
        return H.ioore(b, index);
      if (!J.$eq(t1, b[index]))
        return false;
    }
    return true;
  },
  writeJsonEscapedCharsOn: function(string, buffer) {
    var t1, i, code;
    for (t1 = string.length, i = 0; i < t1; ++i) {
      code = C.JSString_methods.codeUnitAt$1(string, i);
      if (code < 32 || code === 127 || code === 34 || code === 8232 || code === 8233 || code === 92 || code >= 128) {
        new O.writeJsonEscapedCharsOn_writeEscapedOn(new O.writeJsonEscapedCharsOn_addCodeUnitEscaped()).call$2(string, buffer);
        return;
      }
    }
    buffer._contents += string;
  },
  computeHashCode: function(part1, part2, part3, part4, part5) {
    var t1 = J.get$hashCode$(part1);
    part2 = J.get$hashCode$(part2);
    if (typeof t1 !== "number")
      return t1.$xor();
    return (t1 ^ part2 ^ J.get$hashCode$(part3) ^ J.get$hashCode$(part4) ^ J.get$hashCode$(part5)) & 1073741823;
  },
  Indentation: {
    "^": "Object;_indentLevel,_indentList,_indentationUnit",
    get$indentation: function() {
      var t1, i, t2, t3;
      for (t1 = this._indentList, i = t1.length, t2 = this._indentationUnit; t3 = this._indentLevel, i <= t3; ++i) {
        t3 = i - 1;
        if (t3 < 0 || t3 >= t1.length)
          return H.ioore(t1, t3);
        t1.push(t1[t3] + t2);
      }
      if (t3 < 0 || t3 >= t1.length)
        return H.ioore(t1, t3);
      return t1[t3];
    }
  },
  Link: {
    "^": "Object;",
    get$head: function(_) {
      return;
    },
    get$tail: function() {
      return;
    },
    prepend$1: function(element) {
      return E.LinkEntry$(element, this, H.getTypeArgumentByIndex(this, 0));
    },
    get$iterator: function(_) {
      var t1 = new E.LinkIterator(null, this);
      t1.$builtinTypeInfo = this.$builtinTypeInfo;
      return t1;
    },
    printOn$2: function(buffer, separatedBy) {
    },
    toList$1$growable: function(_, growable) {
      var t1, result, i, link, i0;
      if (!growable) {
        t1 = Array(this.slowLength$0());
        t1.fixed$length = init;
        result = H.setRuntimeTypeInfo(t1, [H.getTypeArgumentByIndex(this, 0)]);
      } else {
        result = H.setRuntimeTypeInfo([], [H.getTypeArgumentByIndex(this, 0)]);
        C.JSArray_methods.set$length(result, this.slowLength$0());
      }
      for (i = 0, link = this; !link.get$isEmpty(link); link = link.get$tail(), i = i0) {
        i0 = i + 1;
        t1 = link.get$head(link);
        if (i >= result.length)
          return H.ioore(result, i);
        result[i] = t1;
      }
      return result;
    },
    toList$0: function($receiver) {
      return this.toList$1$growable($receiver, true);
    },
    map$1: function(_, fn) {
      return H.setRuntimeTypeInfo(new E.MappedLinkIterable(fn, this), [H.getTypeArgumentByIndex(this, 0), null]);
    },
    mapToList$2$growable: function(fn, growable) {
      var result, i, link, i0, t1;
      if (!growable) {
        result = Array(this.slowLength$0());
        result.fixed$length = init;
      } else {
        result = [];
        C.JSArray_methods.set$length(result, this.slowLength$0());
      }
      for (i = 0, link = this; !link.get$isEmpty(link); link = link.get$tail(), i = i0) {
        i0 = i + 1;
        t1 = fn.call$1(link.get$head(link));
        if (i >= result.length)
          return H.ioore(result, i);
        result[i] = t1;
      }
      return result;
    },
    mapToList$1: function(fn) {
      return this.mapToList$2$growable(fn, true);
    },
    mapToSet$1: function(fn) {
      var result, link;
      result = P.LinkedHashSet_LinkedHashSet(null, null, null, null);
      for (link = this; !link.get$isEmpty(link); link = link.get$tail())
        result.add$1(0, fn.call$1(link.get$head(link)));
      return result;
    },
    get$isEmpty: function(_) {
      return true;
    },
    reverse$0: function() {
      return this;
    },
    skip$1: function(_, n) {
      if (n === 0)
        return this;
      throw H.wrapException(P.RangeError$("Index " + H.S(n) + " out of range"));
    },
    forEach$1: function(_, f) {
    },
    $eq: function(_, other) {
      var t1;
      if (other == null)
        return false;
      t1 = H.checkSubtype(other, "$isLink", [H.getTypeArgumentByIndex(this, 0)], "$asLink");
      if (!t1)
        return false;
      return J.get$isEmpty$asx(other);
    },
    get$hashCode: function(_) {
      return H.throwExpression(P.UnsupportedError$("Link.hashCode"));
    },
    toString$0: function(_) {
      return "[]";
    },
    get$length: function(_) {
      throw H.wrapException(P.UnsupportedError$("get:length"));
    },
    slowLength$0: function() {
      return 0;
    },
    contains$1: function(_, element) {
      var link;
      for (link = this; !link.get$isEmpty(link); link = link.get$tail())
        if (J.$eq(link.get$head(link), element))
          return true;
      return false;
    },
    get$single: function(_) {
      var t1;
      if (this.get$isEmpty(this))
        throw H.wrapException(P.StateError$("No elements"));
      t1 = this.get$tail();
      if (!t1.get$isEmpty(t1))
        throw H.wrapException(P.StateError$("More than one element"));
      return this.get$head(this);
    },
    get$first: function(_) {
      if (this.get$isEmpty(this))
        throw H.wrapException(P.StateError$("No elements"));
      return this.get$head(this);
    },
    every$1: function(_, f) {
      var link;
      for (link = this; !link.get$isEmpty(link); link = link.get$tail())
        if (f.call$1(link.get$head(link)) !== true)
          return false;
      return true;
    },
    $isLink: true
  },
  Spannable: {
    "^": "Object;"
  },
  _SpannableSentinel: {
    "^": "Object;name>",
    toString$0: function(_) {
      return this.name;
    }
  },
  SpannableAssertionFailure: {
    "^": "Object;node<,message",
    toString$0: function(_) {
      var t1 = this.message;
      return "Assertion failure" + (t1 != null ? ": " + H.S(t1) : "");
    },
    $isSpannableAssertionFailure: true,
    static: {SpannableAssertionFailure$: function(node, message) {
        return new O.SpannableAssertionFailure(node, message);
      }}
  },
  writeJsonEscapedCharsOn_addCodeUnitEscaped: {
    "^": "Closure:142;",
    call$2: function(buffer, code) {
      buffer.write$1("\\u");
      if (code < 4096) {
        buffer.write$1("0");
        if (code < 256) {
          buffer.write$1("0");
          if (code < 16)
            buffer.write$1("0");
        }
      }
      buffer.write$1(C.JSInt_methods.toRadixString$1(code, 16));
    },
    $isFunction: true
  },
  writeJsonEscapedCharsOn_writeEscapedOn: {
    "^": "Closure:143;addCodeUnitEscaped_0",
    call$2: function(string, buffer) {
      var t1, t2, i, code, t3;
      for (t1 = string.length, t2 = this.addCodeUnitEscaped_0, i = 0; i < t1; ++i) {
        if (i >= t1)
          H.throwExpression(P.RangeError$value(i));
        code = string.charCodeAt(i);
        if (code === 34)
          buffer._contents += "\\\"";
        else if (code === 9)
          buffer._contents += "\\t";
        else if (code === 10)
          buffer._contents += "\\n";
        else if (code === 13)
          buffer._contents += "\\r";
        else if (code === 127)
          t2.call$2(buffer, 127);
        else if (code === 8232)
          t2.call$2(buffer, 8232);
        else if (code === 8233)
          t2.call$2(buffer, 8233);
        else if (code === 92)
          buffer._contents += "\\\\";
        else if (code < 32)
          t2.call$2(buffer, code);
        else if (code < 127) {
          t3 = H.Primitives_stringFromCharCode(code);
          buffer._contents += t3;
        } else
          t2.call$2(buffer, code);
      }
    },
    $isFunction: true
  }
}],
["dart2js.util.maplet", "package:compiler/implementation/util/maplet.dart", , M, {
  "^": "",
  Maplet: {
    "^": "MapBase;_maplet$_key,_maplet$_value,_maplet$_extra",
    get$isEmpty: function(_) {
      var t1 = this._maplet$_extra;
      if (t1 == null)
        return C.C__MapletMarker === this._maplet$_key;
      else if (C.C__MapletMarker === t1)
        return J.get$isEmpty$asx(this._maplet$_key);
      else
        return t1 === 0;
    },
    get$length: function(_) {
      var t1 = this._maplet$_extra;
      if (t1 == null)
        return C.C__MapletMarker === this._maplet$_key ? 0 : 1;
      else if (C.C__MapletMarker === t1)
        return J.get$length$asx(this._maplet$_key);
      else
        return t1;
    },
    containsKey$1: function(key) {
      var remaining, i, candidate;
      remaining = this._maplet$_extra;
      if (remaining == null)
        return J.$eq(this._maplet$_key, key);
      else if (C.C__MapletMarker === remaining)
        return this._maplet$_key.containsKey$1(key);
      else {
        i = 0;
        while (true) {
          if (typeof remaining !== "number")
            return remaining.$gt();
          if (!(remaining > 0 && i < 8))
            break;
          c$0: {
            candidate = J.$index$asx(this._maplet$_key, i);
            if (C.C__MapletMarker === candidate)
              break c$0;
            if (J.$eq(candidate, key))
              return true;
            --remaining;
          }
          ++i;
        }
        return false;
      }
    },
    $index: function(_, key) {
      var remaining, i, candidate;
      remaining = this._maplet$_extra;
      if (remaining == null)
        return J.$eq(this._maplet$_key, key) ? this._maplet$_value : null;
      else if (C.C__MapletMarker === remaining)
        return J.$index$asx(this._maplet$_key, key);
      else {
        i = 0;
        while (true) {
          if (typeof remaining !== "number")
            return remaining.$gt();
          if (!(remaining > 0 && i < 8))
            break;
          c$0: {
            candidate = J.$index$asx(this._maplet$_key, i);
            if (C.C__MapletMarker === candidate)
              break c$0;
            if (J.$eq(candidate, key))
              return J.$index$asx(this._maplet$_key, i + 8);
            --remaining;
          }
          ++i;
        }
        return;
      }
    },
    $indexSet: function(_, key, value) {
      var remaining, t1, list, index, copyTo, copyFrom, candidate, t2, map;
      remaining = this._maplet$_extra;
      if (remaining == null) {
        t1 = this._maplet$_key;
        if (C.C__MapletMarker === t1) {
          this._maplet$_key = key;
          this._maplet$_value = value;
        } else if (J.$eq(t1, key))
          this._maplet$_value = value;
        else {
          list = Array(16);
          list.fixed$length = init;
          list[0] = this._maplet$_key;
          list[1] = key;
          list[8] = this._maplet$_value;
          list[9] = value;
          this._maplet$_key = list;
          this._maplet$_value = null;
          this._maplet$_extra = 2;
        }
      } else if (C.C__MapletMarker === remaining)
        J.$indexSet$ax(this._maplet$_key, key, value);
      else {
        index = 0;
        copyTo = null;
        copyFrom = null;
        while (true) {
          if (typeof remaining !== "number")
            return remaining.$gt();
          if (!(remaining > 0 && index < 8))
            break;
          candidate = J.$index$asx(this._maplet$_key, index);
          if (C.C__MapletMarker === candidate)
            if (copyFrom === index) {
              if (typeof copyFrom !== "number")
                return copyFrom.$add();
              ++copyFrom;
            } else {
              copyFrom = index + 1;
              copyTo = index;
            }
          else if (J.$eq(candidate, key)) {
            J.$indexSet$ax(this._maplet$_key, 8 + index, value);
            return;
          } else
            --remaining;
          ++index;
        }
        if (index < 8) {
          J.$indexSet$ax(this._maplet$_key, index, key);
          J.$indexSet$ax(this._maplet$_key, 8 + index, value);
          t1 = this._maplet$_extra;
          if (typeof t1 !== "number")
            return t1.$add();
          this._maplet$_extra = t1 + 1;
        } else {
          t1 = this._maplet$_extra;
          if (typeof t1 !== "number")
            return t1.$lt();
          if (t1 < 8) {
            while (true) {
              if (typeof copyFrom !== "number")
                return copyFrom.$lt();
              if (!(copyFrom < 8))
                break;
              t1 = this._maplet$_key;
              t2 = J.getInterceptor$asx(t1);
              t2.$indexSet(t1, copyTo, t2.$index(t1, copyFrom));
              t1 = this._maplet$_key;
              if (typeof copyTo !== "number")
                return H.iae(copyTo);
              t2 = J.getInterceptor$asx(t1);
              t2.$indexSet(t1, 8 + copyTo, t2.$index(t1, 8 + copyFrom));
              ++copyTo;
              ++copyFrom;
            }
            J.$indexSet$ax(this._maplet$_key, copyTo, key);
            t1 = this._maplet$_key;
            if (typeof copyTo !== "number")
              return H.iae(copyTo);
            J.$indexSet$ax(t1, 8 + copyTo, value);
            ++copyTo;
            t1 = this._maplet$_extra;
            if (typeof t1 !== "number")
              return t1.$add();
            this._maplet$_extra = t1 + 1;
            for (; copyTo < 8;) {
              t1 = this._maplet$_key;
              t2 = J.getInterceptor$ax(t1);
              t2.$indexSet(t1, 8 + copyTo, null);
              t2.$indexSet(t1, copyTo, null);
              ++copyTo;
            }
          } else {
            map = P.LinkedHashMap_LinkedHashMap(null, null, null, null, null);
            this.forEach$1(0, new M.Maplet_operator$indexSet_closure(map));
            map.$indexSet(0, key, value);
            this._maplet$_key = map;
            this._maplet$_extra = C.C__MapletMarker;
          }
        }
      }
    },
    remove$1: function(_, key) {
      var remaining, result, i, candidate, valueIndex, t1;
      remaining = this._maplet$_extra;
      if (remaining == null) {
        if (!J.$eq(this._maplet$_key, key))
          return;
        this._maplet$_key = C.C__MapletMarker;
        result = this._maplet$_value;
        this._maplet$_value = null;
        return result;
      } else if (C.C__MapletMarker === remaining)
        return J.remove$1$ax(this._maplet$_key, key);
      else {
        i = 0;
        while (true) {
          if (typeof remaining !== "number")
            return remaining.$gt();
          if (!(remaining > 0 && i < 8))
            break;
          c$0: {
            candidate = J.$index$asx(this._maplet$_key, i);
            if (C.C__MapletMarker === candidate)
              break c$0;
            if (J.$eq(candidate, key)) {
              valueIndex = 8 + i;
              result = J.$index$asx(this._maplet$_key, valueIndex);
              J.$indexSet$ax(this._maplet$_key, i, C.C__MapletMarker);
              J.$indexSet$ax(this._maplet$_key, valueIndex, null);
              t1 = this._maplet$_extra;
              if (typeof t1 !== "number")
                return t1.$sub();
              this._maplet$_extra = t1 - 1;
              return result;
            }
            --remaining;
          }
          ++i;
        }
        return;
      }
    },
    forEach$1: function(_, action) {
      var remaining, t1, i, candidate;
      remaining = this._maplet$_extra;
      if (remaining == null) {
        t1 = this._maplet$_key;
        if (C.C__MapletMarker !== t1)
          action.call$2(t1, this._maplet$_value);
      } else if (C.C__MapletMarker === remaining)
        J.forEach$1$ax(this._maplet$_key, action);
      else {
        i = 0;
        while (true) {
          if (typeof remaining !== "number")
            return remaining.$gt();
          if (!(remaining > 0 && i < 8))
            break;
          c$0: {
            candidate = J.$index$asx(this._maplet$_key, i);
            if (C.C__MapletMarker === candidate)
              break c$0;
            action.call$2(candidate, J.$index$asx(this._maplet$_key, 8 + i));
            --remaining;
          }
          ++i;
        }
      }
    },
    clear$0: function(_) {
      this._maplet$_key = C.C__MapletMarker;
      this._maplet$_extra = null;
      this._maplet$_value = null;
    },
    get$keys: function() {
      return H.setRuntimeTypeInfo(new M._MapletKeyIterable(this), [H.getTypeArgumentByIndex(this, 0)]);
    },
    static: {"^": "Maplet__MARKER,Maplet_CAPACITY"}
  },
  Maplet_operator$indexSet_closure: {
    "^": "Closure:19;map_0",
    call$2: function(eachKey, eachValue) {
      this.map_0.$indexSet(0, eachKey, eachValue);
      return eachValue;
    },
    $isFunction: true
  },
  _MapletMarker: {
    "^": "Object;"
  },
  _MapletKeyIterable: {
    "^": "IterableBase;maplet",
    get$iterator: function(_) {
      var t1, t2;
      t1 = this.maplet;
      t2 = t1._maplet$_extra;
      if (t2 == null) {
        t1 = new M._MapletSingleIterator(t1._maplet$_key, null);
        t1.$builtinTypeInfo = this.$builtinTypeInfo;
        return t1;
      } else {
        t1 = t1._maplet$_key;
        if (C.C__MapletMarker === t2)
          return J.get$iterator$ax(t1.get$keys());
        else {
          t1 = new M._MapletListIterator(t1, t2, 0, null);
          t1.$builtinTypeInfo = this.$builtinTypeInfo;
          return t1;
        }
      }
    }
  },
  _MapletSingleIterator: {
    "^": "Object;_maplet$_element,_maplet$_current",
    get$current: function() {
      return this._maplet$_current;
    },
    moveNext$0: function() {
      var t1 = this._maplet$_element;
      if (C.C__MapletMarker === t1) {
        this._maplet$_current = null;
        return false;
      }
      this._maplet$_current = t1;
      this._maplet$_element = C.C__MapletMarker;
      return true;
    }
  },
  _MapletListIterator: {
    "^": "Object;_maplet$_list,_maplet$_remaining,_maplet$_index,_maplet$_current",
    get$current: function() {
      return this._maplet$_current;
    },
    moveNext$0: function() {
      var t1, t2, t3, candidate;
      t1 = this._maplet$_list;
      t2 = J.getInterceptor$asx(t1);
      while (true) {
        t3 = this._maplet$_remaining;
        if (typeof t3 !== "number")
          return t3.$gt();
        if (!(t3 > 0))
          break;
        candidate = t2.$index(t1, this._maplet$_index++);
        if (C.C__MapletMarker !== candidate) {
          this._maplet$_current = candidate;
          t1 = this._maplet$_remaining;
          if (typeof t1 !== "number")
            return t1.$sub();
          this._maplet$_remaining = t1 - 1;
          return true;
        }
      }
      this._maplet$_current = null;
      return false;
    }
  }
}],
["dart2js.util.setlet", "package:compiler/implementation/util/setlet.dart", , N, {
  "^": "",
  Setlet: {
    "^": "IterableBase;_setlet$_contents,_extra",
    get$iterator: function(_) {
      var t1, t2;
      t1 = this._extra;
      if (t1 == null) {
        t1 = new N._SetletSingleIterator(this._setlet$_contents, null);
        t1.$builtinTypeInfo = this.$builtinTypeInfo;
        return t1;
      } else {
        t2 = this._setlet$_contents;
        if (C.C__SetletMarker === t1)
          return J.get$iterator$ax(t2);
        else {
          t1 = new N._SetletListIterator(t2, t1, 0, null);
          t1.$builtinTypeInfo = this.$builtinTypeInfo;
          return t1;
        }
      }
    },
    get$length: function(_) {
      var t1 = this._extra;
      if (t1 == null)
        return C.C__SetletMarker === this._setlet$_contents ? 0 : 1;
      else if (C.C__SetletMarker === t1)
        return J.get$length$asx(this._setlet$_contents);
      else
        return t1;
    },
    get$isEmpty: function(_) {
      var t1 = this._extra;
      if (t1 == null)
        return C.C__SetletMarker === this._setlet$_contents;
      else if (C.C__SetletMarker === t1)
        return J.get$isEmpty$asx(this._setlet$_contents);
      else
        return t1 === 0;
    },
    contains$1: function(_, element) {
      var remaining, i, candidate;
      remaining = this._extra;
      if (remaining == null)
        return J.$eq(this._setlet$_contents, element);
      else if (C.C__SetletMarker === remaining)
        return J.contains$1$asx(this._setlet$_contents, element);
      else {
        i = 0;
        while (true) {
          if (typeof remaining !== "number")
            return remaining.$gt();
          if (!(remaining > 0 && i < 8))
            break;
          c$0: {
            candidate = J.$index$asx(this._setlet$_contents, i);
            if (C.C__SetletMarker === candidate)
              break c$0;
            if (J.$eq(candidate, element))
              return true;
            --remaining;
          }
          ++i;
        }
        return false;
      }
    },
    add$1: function(_, element) {
      var remaining, t1, list, index, copyTo, copyFrom, index0, candidate, copyTo0, copyFrom0, t2;
      remaining = this._extra;
      if (remaining == null) {
        t1 = this._setlet$_contents;
        if (C.C__SetletMarker === t1) {
          this._setlet$_contents = element;
          return true;
        } else if (J.$eq(t1, element))
          return false;
        else {
          list = Array(8);
          list.fixed$length = init;
          list[0] = this._setlet$_contents;
          list[1] = element;
          this._setlet$_contents = list;
          this._extra = 2;
          return true;
        }
      } else if (C.C__SetletMarker === remaining)
        return J.add$1$ax(this._setlet$_contents, element);
      else {
        index = 0;
        copyTo = null;
        copyFrom = null;
        while (true) {
          if (typeof remaining !== "number")
            return remaining.$gt();
          if (!(remaining > 0 && index < 8))
            break;
          c$0: {
            index0 = index + 1;
            candidate = J.$index$asx(this._setlet$_contents, index);
            if (C.C__SetletMarker === candidate) {
              copyTo0 = index0 - 1;
              if (copyFrom === copyTo0) {
                if (typeof copyFrom !== "number")
                  return copyFrom.$add();
                ++copyFrom;
              } else {
                copyFrom = index0;
                copyTo = copyTo0;
              }
              break c$0;
            } else if (J.$eq(candidate, element))
              return false;
            --remaining;
          }
          index = index0;
        }
        if (index < 8) {
          J.$indexSet$ax(this._setlet$_contents, index, element);
          t1 = this._extra;
          if (typeof t1 !== "number")
            return t1.$add();
          this._extra = t1 + 1;
        } else {
          t1 = this._extra;
          if (typeof t1 !== "number")
            return t1.$lt();
          if (t1 < 8) {
            while (true) {
              if (typeof copyFrom !== "number")
                return copyFrom.$lt();
              if (!(copyFrom < 8))
                break;
              t1 = this._setlet$_contents;
              if (typeof copyTo !== "number")
                return copyTo.$add();
              copyTo0 = copyTo + 1;
              copyFrom0 = copyFrom + 1;
              t2 = J.getInterceptor$asx(t1);
              t2.$indexSet(t1, copyTo, t2.$index(t1, copyFrom));
              copyFrom = copyFrom0;
              copyTo = copyTo0;
            }
            t1 = this._setlet$_contents;
            if (typeof copyTo !== "number")
              return copyTo.$add();
            copyTo0 = copyTo + 1;
            J.$indexSet$ax(t1, copyTo, element);
            t1 = this._extra;
            if (typeof t1 !== "number")
              return t1.$add();
            this._extra = t1 + 1;
            for (copyTo = copyTo0; copyTo < 8; copyTo = copyTo0) {
              copyTo0 = copyTo + 1;
              J.$indexSet$ax(this._setlet$_contents, copyTo, null);
            }
          } else {
            t1 = P.LinkedHashSet_LinkedHashSet(null, null, null, H.getTypeArgumentByIndex(this, 0));
            t1.addAll$1(0, this._setlet$_contents);
            t1.add$1(0, element);
            this._setlet$_contents = t1;
            this._extra = C.C__SetletMarker;
          }
        }
        return true;
      }
    },
    addAll$1: function(_, elements) {
      J.forEach$1$ax(elements, new N.Setlet_addAll_closure(this));
    },
    lookup$1: function(element) {
      var remaining, i, candidate;
      remaining = this._extra;
      if (remaining == null)
        return J.$eq(this._setlet$_contents, element) ? this._setlet$_contents : null;
      else if (C.C__SetletMarker === remaining)
        return this._setlet$_contents.lookup$1(element);
      else {
        i = 0;
        while (true) {
          if (typeof remaining !== "number")
            return remaining.$gt();
          if (!(remaining > 0 && i < 8))
            break;
          c$0: {
            candidate = J.$index$asx(this._setlet$_contents, i);
            if (C.C__SetletMarker === candidate)
              break c$0;
            if (J.$eq(candidate, element))
              return candidate;
            --remaining;
          }
          ++i;
        }
        return;
      }
    },
    remove$1: function(_, element) {
      var remaining, i, candidate, t1;
      remaining = this._extra;
      if (remaining == null)
        if (J.$eq(this._setlet$_contents, element)) {
          this._setlet$_contents = C.C__SetletMarker;
          return true;
        } else
          return false;
      else if (C.C__SetletMarker === remaining)
        return J.remove$1$ax(this._setlet$_contents, element);
      else {
        i = 0;
        while (true) {
          if (typeof remaining !== "number")
            return remaining.$gt();
          if (!(remaining > 0 && i < 8))
            break;
          c$0: {
            candidate = J.$index$asx(this._setlet$_contents, i);
            if (C.C__SetletMarker === candidate)
              break c$0;
            if (J.$eq(candidate, element)) {
              J.$indexSet$ax(this._setlet$_contents, i, C.C__SetletMarker);
              t1 = this._extra;
              if (typeof t1 !== "number")
                return t1.$sub();
              this._extra = t1 - 1;
              return true;
            }
            --remaining;
          }
          ++i;
        }
        return false;
      }
    },
    removeWhere$1: function(_, test) {
      var remaining, i, candidate, t1;
      remaining = this._extra;
      if (remaining == null) {
        if (test.call$1(this._setlet$_contents) === true)
          this._setlet$_contents = C.C__SetletMarker;
      } else if (C.C__SetletMarker === remaining)
        J.removeWhere$1$ax(this._setlet$_contents, test);
      else {
        i = 0;
        while (true) {
          if (typeof remaining !== "number")
            return remaining.$gt();
          if (!(remaining > 0 && i < 8))
            break;
          c$0: {
            candidate = J.$index$asx(this._setlet$_contents, i);
            if (C.C__SetletMarker === candidate)
              break c$0;
            if (test.call$1(candidate) === true) {
              J.$indexSet$ax(this._setlet$_contents, i, C.C__SetletMarker);
              t1 = this._extra;
              if (typeof t1 !== "number")
                return t1.$sub();
              this._extra = t1 - 1;
            }
            --remaining;
          }
          ++i;
        }
      }
    },
    retainAll$1: function(elements) {
      this.removeWhere$1(0, new N.Setlet_retainAll_closure(this, elements));
    },
    forEach$1: function(_, action) {
      var remaining, t1, i, element;
      remaining = this._extra;
      if (remaining == null) {
        t1 = this._setlet$_contents;
        if (C.C__SetletMarker !== t1)
          action.call$1(t1);
      } else if (C.C__SetletMarker === remaining)
        J.forEach$1$ax(this._setlet$_contents, action);
      else {
        i = 0;
        while (true) {
          if (typeof remaining !== "number")
            return remaining.$gt();
          if (!(remaining > 0 && i < 8))
            break;
          c$0: {
            element = J.$index$asx(this._setlet$_contents, i);
            if (C.C__SetletMarker === element)
              break c$0;
            action.call$1(element);
            --remaining;
          }
          ++i;
        }
      }
    },
    containsAll$1: function(other) {
      var t1;
      for (t1 = other.get$iterator(other); t1.moveNext$0();)
        if (this.contains$1(0, t1.get$current()) !== true)
          return false;
      return true;
    },
    clear$0: function(_) {
      this._setlet$_contents = C.C__SetletMarker;
      this._extra = null;
    },
    union$1: function(other) {
      var t1 = P.LinkedHashSet_LinkedHashSet(null, null, null, H.getTypeArgumentByIndex(this, 0));
      t1.addAll$1(0, this);
      t1.addAll$1(0, other);
      return t1;
    },
    intersection$1: function(_, other) {
      var t1, t2;
      t1 = H.setRuntimeTypeInfo(new H.WhereIterable(this, new N.Setlet_intersection_closure(other)), [H.getRuntimeTypeArgument(this, "IterableBase", 0)]);
      t2 = new N.Setlet(C.C__SetletMarker, null);
      t2.$builtinTypeInfo = this.$builtinTypeInfo;
      t2.addAll$1(0, t1);
      return t2;
    },
    $isEfficientLength: true,
    $isIterable: true,
    $asIterable: null,
    static: {"^": "Setlet__MARKER,Setlet_CAPACITY"}
  },
  Setlet_addAll_closure: {
    "^": "Closure:13;this_0",
    call$1: function(each) {
      return this.this_0.add$1(0, each);
    },
    $isFunction: true
  },
  Setlet_retainAll_closure: {
    "^": "Closure;this_0,set_1",
    call$1: function(element) {
      this.set_1.contains$1(0, element);
      return true;
    },
    $isFunction: true,
    $signature: function() {
      return H.computeSignature(function(E) {
        return {func: "dynamic__E", args: [E]};
      }, this.this_0, "Setlet");
    }
  },
  Setlet_intersection_closure: {
    "^": "Closure:13;other_0",
    call$1: function(e) {
      return this.other_0.contains$1(0, e);
    },
    $isFunction: true
  },
  _SetletMarker: {
    "^": "Object;",
    toString$0: function(_) {
      return "-";
    }
  },
  _SetletSingleIterator: {
    "^": "Object;_setlet$_element,_setlet$_current",
    get$current: function() {
      return this._setlet$_current;
    },
    moveNext$0: function() {
      var t1 = this._setlet$_element;
      if (C.C__SetletMarker === t1) {
        this._setlet$_current = null;
        return false;
      }
      this._setlet$_current = t1;
      this._setlet$_element = C.C__SetletMarker;
      return true;
    }
  },
  _SetletListIterator: {
    "^": "Object;_list,_remaining,_setlet$_index,_setlet$_current",
    get$current: function() {
      return this._setlet$_current;
    },
    moveNext$0: function() {
      var t1, t2, t3, candidate;
      t1 = this._list;
      t2 = J.getInterceptor$asx(t1);
      while (true) {
        t3 = this._remaining;
        if (typeof t3 !== "number")
          return t3.$gt();
        if (!(t3 > 0))
          break;
        candidate = t2.$index(t1, this._setlet$_index++);
        if (C.C__SetletMarker !== candidate) {
          this._setlet$_current = candidate;
          t1 = this._remaining;
          if (typeof t1 !== "number")
            return t1.$sub();
          this._remaining = t1 - 1;
          return true;
        }
      }
      this._setlet$_current = null;
      return false;
    }
  }
}],
["dart2js_incremental", "package:dart2js_incremental/dart2js_incremental.dart", , D, {
  "^": "",
  reuseCompiler: function(cachedCompiler, diagnosticHandler, environment, inputProvider, libraryRoot, options, outputProvider, packageRoot, packagesAreImmutable) {
    var t1, old, result, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15, t16, t17, t18, t19, t20, t21, t22, t23, t24, t25, t26, t27, t28, t29, t30, t31, t32, t33, t34, t35, t36, t37, t38, compiler, backend;
    t1 = P._FakeUserTag__FakeUserTag("_reuseCompiler");
    old = $.get$_currentTag();
    $._currentTag = t1;
    if (libraryRoot == null)
      throw H.wrapException("Missing libraryRoot");
    outputProvider = K.NullSink_outputProvider$closure();
    environment = P.LinkedHashMap_LinkedHashMap$_empty(null, null);
    t1 = cachedCompiler != null;
    if (!t1 || !cachedCompiler.libraryRoot.$eq(0, libraryRoot) || !cachedCompiler.hasIncrementalSupport || cachedCompiler.hasCrashed || cachedCompiler.compilerWasCancelled || cachedCompiler.enqueuer.resolution.hasEnqueuedReflectiveElements || cachedCompiler.deferredLoadTask.splitProgram) {
      if (t1 && cachedCompiler.hasIncrementalSupport) {
        P.print("***FLUSH***");
        if (cachedCompiler.hasCrashed)
          P.print("Unable to reuse compiler due to crash.");
        else if (cachedCompiler.compilerWasCancelled)
          P.print("Unable to reuse compiler due to cancel.");
        else if (cachedCompiler.enqueuer.resolution.hasEnqueuedReflectiveElements)
          P.print("Unable to reuse compiler due to dart:mirrors.");
        else if (cachedCompiler.deferredLoadTask.splitProgram)
          P.print("Unable to reuse compiler due to deferred loading.");
        else
          P.print("Unable to reuse compiler.");
      }
      result = S.Compiler_extractCsvOption(options, "--categories=");
      if (result.length === 0)
        result = ["Client"];
      C.JSArray_methods.add$1(result, "Shared");
      C.JSArray_methods.add$1(result, "Internal");
      t1 = P.LinkedHashSet_LinkedHashSet(null, null, null, P.String);
      t1.addAll$1(0, result);
      t2 = J.getInterceptor$asx(options);
      t3 = t2.indexOf$1(options, "--enable-checked-mode") >= 0;
      t4 = t2.indexOf$1(options, "--enable-checked-mode") >= 0;
      t5 = t2.indexOf$1(options, "--trust-type-annotations") >= 0;
      t6 = t2.indexOf$1(options, "--minify") >= 0;
      t7 = t2.indexOf$1(options, "--disable-native-live-type-analysis") < 0;
      t8 = t2.indexOf$1(options, "--output-type=dart") >= 0;
      t9 = t2.indexOf$1(options, "--no-source-maps");
      t10 = t2.indexOf$1(options, "--analyze-all") >= 0;
      t11 = t2.indexOf$1(options, "--analyze-only") >= 0;
      t12 = t2.indexOf$1(options, "--analyze-main") >= 0;
      t13 = t2.indexOf$1(options, "--analyze-signatures-only") >= 0;
      t14 = S.Compiler_extractCsvOption(options, "--force-strip=");
      t15 = t2.indexOf$1(options, "--enable-concrete-type-inference") >= 0;
      t16 = t2.indexOf$1(options, "--disable-type-inference") >= 0;
      t17 = t2.indexOf$1(options, "--preserve-comments") >= 0;
      t18 = t2.indexOf$1(options, "--verbose") >= 0;
      t19 = S.Compiler_extractUriOption(options, "--source-map=");
      t20 = S.Compiler_extractUriOption(options, "--out=");
      t21 = t2.indexOf$1(options, "--terse") >= 0;
      t22 = t2.indexOf$1(options, "--dump-info") >= 0;
      t23 = S.Compiler_extractStringOption(options, "--build-id=", "build number could not be determined");
      t24 = t2.indexOf$1(options, "--show-package-warnings") >= 0;
      t25 = t2.indexOf$1(options, "--csp") >= 0;
      t26 = t2.indexOf$1(options, "--incremental-support") >= 0;
      t2 = t2.indexOf$1(options, "--suppress-warnings") >= 0;
      H.Primitives_initTicker();
      $.Stopwatch__frequency = $.Primitives_timerFrequency;
      t27 = P.LinkedHashMap_LinkedHashMap(null, null, null, K.TokenKey, Y.Token);
      t28 = $.TreeElementMapping__hashCodeCounter + 1;
      $.TreeElementMapping__hashCodeCounter = t28;
      t29 = P.LinkedHashMap_LinkedHashMap$_empty(P.Uri, K.SuppressionInfo);
      t30 = Z.Selector_Selector(C.SelectorKind_getter_0, "iterator", null, 0, null);
      t31 = Z.Selector_Selector(C.SelectorKind_getter_0, "current", null, 0, null);
      t32 = Z.Selector_Selector(C.SelectorKind_call_2, "moveNext", null, 0, null);
      t33 = Z.Selector_Selector(C.SelectorKind_call_2, "noSuchMethod", null, 1, null);
      t34 = Z.Selector_Selector(C.SelectorKind_call_2, "validated", null, 1, null);
      t35 = Z.Selector_Selector(C.SelectorKind_call_2, "fromEnvironment", null, 2, null);
      t36 = new P.Stopwatch(null, null);
      H.Primitives_initTicker();
      $.Stopwatch__frequency = $.Primitives_timerFrequency;
      t36.start$0(0);
      t37 = t16 || t8;
      t38 = t11 || t13 || t10;
      compiler = new S.Compiler(inputProvider, diagnosticHandler, libraryRoot, packageRoot, options, environment, false, t1, new P.Stopwatch(null, null), 0, null, null, null, new S.CacheStrategy(t26), new K.TokenMap(t27), null, new A.ResolutionRegistry(null, new A.TreeElementMapping(null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, t28)), t6, t3, t4, t5, t15, t37, t22, t25, 5, t10, t38, t12, t13, t7, false, t17, t18, t19, t20, t21, t24, false, t29, t2, t26, outputProvider, false, false, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, t23, new K.QueueFilter(), t30, t31, t32, t33, t34, t35, false, false, false, false, false, t36, null, false, false, false, null, null);
      compiler.Compiler$27$analyzeAllFlag$analyzeMain$analyzeOnly$analyzeSignaturesOnly$buildId$disableTypeInferenceFlag$dumpInfo$emitJavaScript$enableConcreteTypeInference$enableMinification$enableNativeLiveTypeAnalysis$enableTypeAssertions$enableUserAssertions$generateSourceMap$hasIncrementalSupport$maxConcreteTypeSize$outputProvider$outputUri$preserveComments$showPackageWarnings$sourceMapUri$strips$suppressWarnings$terseDiagnostics$trustTypeAnnotations$useContentSecurityPolicy$verbose(t10, t12, t11, t13, t23, t16, t22, !t8, t15, t6, t7, t3, t4, t9 < 0, t26, 5, outputProvider, t20, t17, t24, t19, t14, t2, t21, t5, t25, t18);
      compiler.Compiler$7(inputProvider, outputProvider, diagnosticHandler, libraryRoot, packageRoot, options, environment);
    } else {
      cachedCompiler.outputProvider = outputProvider;
      cachedCompiler.provider = inputProvider;
      cachedCompiler.handler = diagnosticHandler;
      t1 = cachedCompiler.enqueuer;
      t2 = t1.resolution;
      t2.queueIsClosed = false;
      t2.hasEnqueuedReflectiveElements = false;
      t2.hasEnqueuedReflectiveStaticFields = false;
      t1 = t1.codegen;
      t1.queueIsClosed = false;
      t1.hasEnqueuedReflectiveElements = false;
      t1.hasEnqueuedReflectiveStaticFields = false;
      cachedCompiler.assembledCode = null;
      cachedCompiler.compilationFailed = false;
      backend = cachedCompiler.backend;
      t1 = backend.get$emitter();
      t2 = backend.compiler.enqueuer.codegen.generatedCode;
      t1.cachedElements.addAll$1(0, H.setRuntimeTypeInfo(new P.LinkedHashMapKeyIterable(t2), [H.getTypeArgumentByIndex(t2, 0)]));
      cachedCompiler.enqueuer.codegen.newlyEnqueuedElements.clear$0(0);
      t2 = backend.emitter.containerBuilder;
      t2.staticGetters.clear$0(0);
      t2.methodClosures.clear$0(0);
      C.JSArray_methods.set$length(backend.emitter.nsmEmitter.trivialNsmHandlers, 0);
      t2 = backend.emitter.typeTestEmitter;
      t2.checkedClasses = null;
      t2.checkedFunctionTypes = null;
      t2.checkedGenericFunctionTypes.clear$0(0);
      t2.checkedNonGenericFunctionTypes.clear$0(0);
      t2.rtiNeededClasses.clear$0(0);
      t2.cachedClassesUsingTypeVariableTests = null;
      backend.emitter.interceptorEmitter.interceptorInvocationNames.clear$0(0);
      t2 = backend.emitter.metadataEmitter;
      C.JSArray_methods.set$length(t2.globalMetadata, 0);
      t2.globalMetadataMap.clear$0(0);
      t2 = backend.emitter.nativeEmitter;
      t2.nativeBuffer.clear$0(0);
      t2.nativeClasses.clear$0(0);
      t2.nativeMethods.clear$0(0);
      t2 = backend.emitter;
      t2.outputBuffers.clear$0(0);
      t2.deferredConstants.clear$0(0);
      t2.isolateProperties = null;
      t2.classesCollector = null;
      t2.neededClasses.clear$0(0);
      t2.outputClassLists.clear$0(0);
      C.JSArray_methods.set$length(t2.nativeClasses, 0);
      t2.mangledFieldNames.clear$0(0);
      t2.mangledGlobalFieldNames.clear$0(0);
      t2.recordedMangledNames.clear$0(0);
      t2.additionalProperties.clear$0(0);
      t2.readTypeVariables.clear$0(0);
      t2.instantiatedClasses = null;
      C.JSArray_methods.set$length(t2.precompiledFunction, 0);
      C.JSArray_methods.set$length(t2.precompiledConstructorNames, 0);
      t2.hasMakeConstantList = false;
      t2.elementDescriptors.clear$0(0);
      backend.preMirrorsMethodCount = 0;
      cachedCompiler.libraryLoader.reset$1$reuseLibrary(0, new D.reuseCompiler_closure(packagesAreImmutable));
      compiler = cachedCompiler;
    }
    old.toString;
    $.get$_currentTag();
    $._currentTag = old;
    return compiler;
  },
  reuseCompiler_closure: {
    "^": "Closure:79;packagesAreImmutable_0",
    call$1: function(library) {
      var t1;
      if (!library.get$isPlatformLibrary())
        t1 = this.packagesAreImmutable_0 && library.canonicalUri.scheme === "package";
      else
        t1 = true;
      return t1;
    },
    $isFunction: true
  }
}],
["dart_backend", "package:compiler/implementation/dart_backend/dart_backend.dart", , G, {
  "^": "",
  compareBy: function(f) {
    return new G.compareBy_closure(f);
  },
  sorted: function(l, comparison) {
    var result, t1;
    result = P.List_List$from(l, true, null);
    t1 = result.length - 1;
    if (t1 - 0 <= 32)
      H.Sort__insertionSort(result, 0, t1, comparison);
    else
      H.Sort__dualPivotQuicksort(result, 0, t1, comparison);
    return result;
  },
  compareElements: [function(e0, e1) {
    var result = G.compareBy(new G.compareElements_closure()).call$2(e0, e1);
    if (!J.$eq(result, 0))
      return result;
    return G.compareBy(new G.compareElements_closure0()).call$2(e0, e1);
  }, "call$2", "compareElements$closure", 4, 0, 19],
  _compareNodes: function() {
    return G.compareBy(new G._compareNodes_closure());
  },
  generateMiniId: function(index) {
    var resultBuilder, t1, t2;
    if (index < 52)
      return "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz"[index];
    resultBuilder = new P.StringBuffer("");
    resultBuilder._contents = "";
    t1 = C.JSInt_methods.$mod(index, 52);
    t1 = H.Primitives_stringFromCharCode("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz".charCodeAt(t1));
    resultBuilder._contents = t1;
    index = C.JSInt_methods._tdivFast$1(index, 52);
    for (; index >= 64;) {
      t1 = C.JSInt_methods.$mod(index, 64);
      t1 = H.Primitives_stringFromCharCode("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789_$".charCodeAt(t1));
      t1 = resultBuilder._contents += t1;
      index = C.JSInt_methods._tdivFast$1(index, 64);
    }
    if (index < 0)
      return H.ioore("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789_$", index);
    t2 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789_$"[index];
    t1 += t2;
    resultBuilder._contents = t1;
    return t1;
  },
  ElementAst: {
    "^": "Object;ast<,treeElements<"
  },
  DartBackend: {
    "^": "Backend;tasks<,forceStripTypes,stripAsserts,outputAst,memberNodes,placeholderRenamer,useMirrorHelperLibrary<,mirrorRenamer,mirrorHelperLibrary,mirrorHelperGetNameFunction<,mirrorHelperSymbolsMap<,constantCompilerTask<,resolutionCallbacks<,usedTypeLiterals,compiler,classesRequiredForReflection",
    get$constantSystem: function() {
      return this.constantCompilerTask.constantCompiler.constantSystem;
    },
    get$constants: function() {
      return this.constantCompilerTask;
    },
    isSafeToRemoveTypeDeclarations$1: function(classMembers) {
      var t1, typeErrorElement, processedTypes, workQueue, t2, type, element;
      t1 = this.compiler;
      typeErrorElement = t1.coreLibrary.find$1(0, "TypeError");
      if (classMembers.containsKey$1(typeErrorElement) || t1.enqueuer.resolution.universe.isChecks.any$1(0, new G.DartBackend_isSafeToRemoveTypeDeclarations_closure(typeErrorElement)))
        return false;
      processedTypes = P.LinkedHashSet_LinkedHashSet(null, null, null, V.DartType);
      workQueue = H.setRuntimeTypeInfo([], [V.DartType]);
      t2 = H.setRuntimeTypeInfo(new P.LinkedHashMapKeyIterable(classMembers), [H.getTypeArgumentByIndex(classMembers, 0)]);
      C.JSArray_methods.addAll$1(workQueue, H.MappedIterable_MappedIterable(t2, new G.DartBackend_isSafeToRemoveTypeDeclarations_closure0(), H.getRuntimeTypeArgument(t2, "IterableBase", 0), null));
      C.JSArray_methods.addAll$1(workQueue, t1.enqueuer.resolution.universe.isChecks);
      for (; t1 = workQueue.length, t1 !== 0;) {
        if (0 >= t1)
          return H.ioore(workQueue, 0);
        type = workQueue.pop();
        if (processedTypes.contains$1(0, type))
          continue;
        processedTypes.add$1(0, type);
        t1 = J.getInterceptor(type);
        if (!!t1.$isFunctionType)
          return false;
        if (!!t1.$isTypedefType)
          return false;
        if (!!t1.$isInterfaceType) {
          H.IterableMixinWorkaround_forEach(type.typeArguments, C.JSArray_methods.get$add(workQueue));
          element = type.get$element();
          if (element.get$allSupertypesAndSelf()._supertypes != null)
            element.allSupertypesAndSelf._supertypes.forEach$1(0, C.JSArray_methods.get$add(workQueue));
        }
      }
      return true;
    },
    classNeedsRti$1: function(cls) {
      return false;
    },
    methodNeedsRti$1: function($function) {
      return false;
    },
    enqueueHelpers$2: function(world, registry) {
      var t1, coreLibrary, t2;
      t1 = this.compiler;
      coreLibrary = t1.coreLibrary;
      for (t2 = H.setRuntimeTypeInfo(new H.ListIterator(C.List_D72, 6, 0, null), [H.getTypeArgumentByIndex(C.List_D72, 0)]); t2.moveNext$0();)
        coreLibrary.findLocal$1(t2.__internal$_current).ensureResolved$1(t1);
      world.registerInvocation$1(Z.Selector_Selector(C.SelectorKind_call_2, "toString", null, 0, null));
      world.registerInvokedGetter$1(Z.Selector_Selector(C.SelectorKind_getter_0, "hashCode", null, 0, null));
      world.registerInvocation$1(Z.Selector_Selector(C.SelectorKind_operator_3, O.Elements_constructOperatorName("==", false), null, 1, null));
      world.registerInvocation$1(Z.Selector_Selector(C.SelectorKind_call_2, "compareTo", null, 1, null));
    },
    codegen$1: function(work) {
    },
    isUserLibrary$1: [function(lib) {
      return !lib.get$isPlatformLibrary();
    }, "call$1", "get$isUserLibrary", 2, 0, 144],
    shouldOutput$1: function(element) {
      var t1, t2;
      if (!(!element.get$library().get$isPlatformLibrary() && !element.get$isSynthesized() && !element.$isAbstractFieldElement)) {
        t1 = element.get$library();
        t2 = this.mirrorHelperLibrary;
        t2 = t1 == null ? t2 == null : t1 === t2;
        t1 = t2;
      } else
        t1 = true;
      return t1;
    },
    assembleProgram$0: function() {
      var t1, fixedMemberNames, reexportingLibraries, t2, t3, library, t4, t5, t6, $export, t7, element, optionalParameters, optional, elementAsts, topLevelElements, classMembers, emitNoMembersFor, synthesizedIdentifier, classElement, member, classNode, $constructor, t8, t9, t10, t11, t12, collector, shouldCutDeclarationTypes, sortedTopLevels, sortedClassMembers, sb, topLevel, topLevelNodes, members, unparser, i, node;
      t1 = {};
      fixedMemberNames = P.LinkedHashSet_LinkedHashSet(null, null, null, P.String);
      reexportingLibraries = P.LinkedHashMap_LinkedHashMap$_empty(O.Element, O.LibraryElement);
      for (t2 = this.compiler, t3 = t2.libraryLoader.libraryCanonicalUriMap, t3 = t3.get$values(t3), t3 = H.setRuntimeTypeInfo(new H.MappedIterator(null, J.get$iterator$ax(t3._iterable), t3._f), [H.getTypeArgumentByIndex(t3, 0), H.getTypeArgumentByIndex(t3, 1)]); t3.moveNext$0();) {
        library = t3.__internal$_current;
        if (!library.get$isPlatformLibrary())
          continue;
        library.forEachLocalMember$1(new G.DartBackend_assembleProgram_closure(this, fixedMemberNames));
        t4 = library.slotForExports;
        t4.toString;
        t5 = new E.LinkIterator(null, t4);
        t5.$builtinTypeInfo = [H.getTypeArgumentByIndex(t4, 0)];
        t4 = library.canonicalUri;
        t6 = t4.scheme === "dart";
        t4 = t4._path;
        for (; t5.moveNext$0();) {
          $export = t5._util_implementation$_current;
          if (!(t6 && C.JSString_methods.startsWith$1(t4, "_"))) {
            t7 = $export.get$library().canonicalUri;
            t7 = t7.scheme === "dart" && C.JSString_methods.startsWith$1(t7._path, "_");
          } else
            t7 = false;
          if (t7)
            reexportingLibraries.$indexSet(0, $export, library);
        }
      }
      for (t3 = t2.enqueuer.resolution.resolvedElements, t3 = H.setRuntimeTypeInfo(new P.LinkedHashSetIterator(t3, t3._modifications, null, null), [null]), t3._cell = t3._set._first; t3.moveNext$0();) {
        element = t3._collection$_current;
        if (!element.get$isConstructor())
          continue;
        optionalParameters = element.get$functionSignature().get$optionalParameters();
        optionalParameters.toString;
        t4 = new E.LinkIterator(null, optionalParameters);
        t4.$builtinTypeInfo = [H.getTypeArgumentByIndex(optionalParameters, 0)];
        for (; t4.moveNext$0();) {
          optional = t4._util_implementation$_current;
          if (!optional.get$isInitializingFormal())
            continue;
          fixedMemberNames.add$1(0, optional.get$name(optional));
        }
      }
      fixedMemberNames.add$1(0, "call");
      fixedMemberNames.add$1(0, "srcType");
      fixedMemberNames.add$1(0, "dstType");
      if (this.useMirrorHelperLibrary && t2.mirrorsLibrary != null)
        this.mirrorRenamer = new V.MirrorRenamer(P.LinkedHashMap_LinkedHashMap(null, null, null, P.String, P.String), H.setRuntimeTypeInfo([], [Y.Node]), null, null, t2, this);
      else
        this.useMirrorHelperLibrary = false;
      elementAsts = P.LinkedHashMap_LinkedHashMap(null, null, null, O.Element, G.ElementAst);
      topLevelElements = P.LinkedHashSet_LinkedHashSet(null, null, null, O.Element);
      classMembers = P.LinkedHashMap_LinkedHashMap(null, null, null, O.ClassElement, [P.Set, O.Element]);
      t1.newTypedefElementCallback_0 = null;
      t1.newClassElementCallback_1 = null;
      t3 = new G.DartBackend_assembleProgram_processElement(t1, this, elementAsts);
      t4 = new G.DartBackend_assembleProgram_addTopLevel(topLevelElements, t3);
      t5 = new G.DartBackend_assembleProgram_addClass(classMembers, t4);
      t1.newTypedefElementCallback_0 = new G.DartBackend_assembleProgram_closure0(this, t4);
      t1.newClassElementCallback_1 = new G.DartBackend_assembleProgram_closure1(this, t5);
      t2.enqueuer.resolution.universe.instantiatedClasses.forEach$1(0, new G.DartBackend_assembleProgram_closure2(this, t5));
      t2.enqueuer.resolution.resolvedElements.forEach$1(0, new G.DartBackend_assembleProgram_closure3(this, new G.DartBackend_assembleProgram_parse(this), classMembers, t3, t4, t5));
      emitNoMembersFor = P.LinkedHashSet_LinkedHashSet(null, null, null, O.ClassElement);
      this.usedTypeLiterals.forEach$1(0, new G.DartBackend_assembleProgram_closure4(this, topLevelElements, t5, emitNoMembersFor));
      t5 = Y.StringToken_canonicalizedString("", false);
      t4 = $.Node__HASH_COUNTER + 1;
      $.Node__HASH_COUNTER = t4;
      synthesizedIdentifier = new Y.Identifier(new Y.StringToken(t5, C.PrecedenceInfo_identifier_0_97, -1, null), null, t4);
      $NextClassElement$0:
        for (t1 = H.setRuntimeTypeInfo(new P.LinkedHashMapKeyIterable(classMembers), [H.getTypeArgumentByIndex(classMembers, 0)]), t3 = t1._map, t1 = H.setRuntimeTypeInfo(new P.LinkedHashMapKeyIterator(t3, t3._modifications, null, null), [H.getTypeArgumentByIndex(t1, 0)]), t1._cell = t1._map._first; t1.moveNext$0();) {
          classElement = t1._collection$_current;
          if (emitNoMembersFor.contains$1(0, classElement))
            continue;
          for (t3 = J.get$iterator$ax(classMembers.$index(0, classElement)); t3.moveNext$0();) {
            member = t3.get$current();
            if (J.get$kind$x(member) === C.ElementKind_generative_constructor_16 || member.get$isFactoryConstructor())
              continue $NextClassElement$0;
          }
          t3 = classElement.get$constructors();
          if (t3.get$isEmpty(t3))
            continue $NextClassElement$0;
          classNode = classElement.get$node();
          t3 = classElement.name;
          t4 = $.get$Modifiers_EMPTY();
          t5 = [];
          t5.$builtinTypeInfo = [O.FunctionElement];
          t6 = $.ElementX_elementHashCode + 1;
          $.ElementX_elementHashCode = t6;
          $constructor = new U.SynthesizedConstructorElementX(null, false, null, null, null, null, null, t4, t5, null, false, null, null, null, t3, C.ElementKind_generative_constructor_16, classElement, t6, C.C_Link2, null, false);
          $constructor.typeCache = new V.FunctionType($constructor, C.C_VoidType, C.List_empty3, C.List_empty3, C.List_empty0, C.List_empty3);
          t3 = classNode.get$name(classNode);
          t5 = $.Node__HASH_COUNTER + 1;
          $.Node__HASH_COUNTER = t5;
          t6 = Y.StringToken_canonicalizedString("(", false);
          t7 = Y.StringToken_canonicalizedString(")", false);
          t8 = $.Node__HASH_COUNTER + 1;
          $.Node__HASH_COUNTER = t8;
          t9 = Y.StringToken_canonicalizedString(";", false);
          t10 = $.Node__HASH_COUNTER + 1;
          $.Node__HASH_COUNTER = t10;
          t11 = t10 + 1;
          $.Node__HASH_COUNTER = t11;
          t12 = $.TreeElementMapping__hashCodeCounter + 1;
          $.TreeElementMapping__hashCodeCounter = t12;
          elementAsts.$indexSet(0, $constructor, new G.ElementAst(new Y.FunctionExpression(new Y.Send(t3, synthesizedIdentifier, null, null, t5), new Y.NodeList(C.C_Link3, new Y.StringToken(t6, C.PrecedenceInfo_wYn, -1, null), new Y.StringToken(t7, C.PrecedenceInfo_MIj, -1, null), null, t8), new Y.EmptyStatement0(new Y.StringToken(t9, C.PrecedenceInfo_kuc, -1, null), t10), null, t4, null, null, null, t11), new A.TreeElementMapping(null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, t12)));
        }
      t1 = P.LinkedHashSet_LinkedHashSet(null, null, null, Y.Node);
      t3 = P.LinkedHashSet_LinkedHashSet(null, null, null, Y.Node);
      collector = new G.PlaceholderCollector(t2, fixedMemberNames, elementAsts, t1, t3, P.LinkedHashMap_LinkedHashMap(null, null, null, O.Element, [P.Set, Y.Node]), P.LinkedHashMap_LinkedHashMap(null, null, null, O.FunctionElement, G.FunctionScope), P.LinkedHashMap_LinkedHashMap(null, null, null, O.LibraryElement, [P.Set, Y.Identifier]), H.setRuntimeTypeInfo([], [G.DeclarationTypePlaceholder]), P.LinkedHashMap_LinkedHashMap(null, null, null, P.String, [P.Set, Y.Identifier]), H.setRuntimeTypeInfo([], [G.ConstructorPlaceholder]), null, null, null, null);
      t3.add$1(0, synthesizedIdentifier);
      topLevelElements.forEach$1(0, new G.DartBackend_assembleProgram_makePlaceholders(this, classMembers, collector));
      t1 = this.forceStripTypes;
      if (!t1)
        shouldCutDeclarationTypes = t2.enableMinification && this.isSafeToRemoveTypeDeclarations$1(classMembers);
      else
        shouldCutDeclarationTypes = true;
      t3 = new G.PlaceholderRenamer(P.LinkedHashMap_LinkedHashMap(null, null, null, Y.Node, P.String), P.LinkedHashSet_LinkedHashSet(null, null, null, O.LibraryElement), t2, fixedMemberNames, reexportingLibraries, shouldCutDeclarationTypes, P.LinkedHashMap_LinkedHashMap(null, null, null, O.Entity, P.String), P.LinkedHashMap_LinkedHashMap(null, null, null, O.Entity, [P.Map, P.String, P.String]), null, null, null);
      this.placeholderRenamer = t3;
      t3.computeRenames$1(collector);
      sortedTopLevels = G.sorted(topLevelElements, G.compareElements$closure());
      sortedClassMembers = P.LinkedHashMap_LinkedHashMap(null, null, null, O.ClassElement, [P.List, O.Element]);
      classMembers.forEach$1(0, new G.DartBackend_assembleProgram_closure5(sortedClassMembers));
      if (this.outputAst) {
        sb = P.StringBuffer$("");
        t1 = new G.DartBackend_assembleProgram_outputElement(this, sb);
        for (t3 = H.setRuntimeTypeInfo(new H.ListIterator(sortedTopLevels, sortedTopLevels.length, 0, null), [H.getTypeArgumentByIndex(sortedTopLevels, 0)]); t3.moveNext$0();) {
          topLevel = t3.__internal$_current;
          if (topLevel.get$isClass() === true && !emitNoMembersFor.contains$1(0, topLevel))
            J.forEach$1$ax(sortedClassMembers.$index(0, topLevel), t1);
          else
            t1.call$1(topLevel);
        }
        t2.assembledCode = "<Program>\n" + H.S(sb) + "</Program>\n";
        return;
      }
      topLevelNodes = H.setRuntimeTypeInfo([], [Y.Node]);
      for (t3 = H.setRuntimeTypeInfo(new H.ListIterator(sortedTopLevels, sortedTopLevels.length, 0, null), [H.getTypeArgumentByIndex(sortedTopLevels, 0)]), t4 = this.memberNodes; t3.moveNext$0();) {
        element = t3.__internal$_current;
        topLevelNodes.push(elementAsts.$index(0, element).get$ast());
        if (element.get$isClass() === true && !element.get$isMixinApplication()) {
          members = [];
          members.$builtinTypeInfo = [Y.Node];
          for (t5 = J.get$iterator$ax(sortedClassMembers.$index(0, element)); t5.moveNext$0();)
            members.push(elementAsts.$index(0, t5.get$current()).get$ast());
          t4.$indexSet(0, elementAsts.$index(0, element).get$ast(), members);
        }
      }
      if (this.useMirrorHelperLibrary)
        this.mirrorRenamer.addRenames$3(this.placeholderRenamer.renames, topLevelNodes, collector);
      t3 = this.placeholderRenamer.renames;
      t5 = t2.enableMinification;
      t6 = P.StringBuffer$("");
      unparser = new G.EmitterUnparser(t3, t6, t5, t1, true, 0, H.setRuntimeTypeInfo([""], [P.String]), "  ");
      for (t1 = this.placeholderRenamer.platformImports, t1 = H.setRuntimeTypeInfo(new P.LinkedHashSetIterator(t1, t1._modifications, null, null), [null]), t1._cell = t1._set._first, t5 = !t5; t1.moveNext$0();) {
        library = t1._collection$_current;
        if (library.get$isPlatformLibrary()) {
          t3 = library.canonicalUri;
          t3 = !(t3.scheme === "dart" && C.JSString_methods.startsWith$1(t3._path, "_"));
        } else
          t3 = false;
        if (t3) {
          t3 = library.canonicalUri.toString$0(0);
          unparser.write$1("import \"" + t3 + "\";");
          if (t5) {
            t6._contents += "\n";
            unparser.onEmptyLine = true;
          }
        }
      }
      for (i = 0; i < sortedTopLevels.length; ++i) {
        if (i >= topLevelNodes.length)
          return H.ioore(topLevelNodes, i);
        node = topLevelNodes[i];
        if (!!J.getInterceptor(node).$isClassNode)
          unparser.unparseClassWithBody$2(node, t4.$index(0, node));
        else
          unparser.visit$1(node);
        if (t5) {
          t6._contents += "\n";
          unparser.onEmptyLine = true;
        }
      }
      t2.assembledCode = t6._contents;
      t1 = t2.outputProvider$2("", "dart");
      t3 = J.getInterceptor$ax(t1);
      t3.add$1(t1, t2.assembledCode);
      t3.close$0(t1);
      this.logResultBundleSizeInfo$1(topLevelElements);
    },
    logResultBundleSizeInfo$1: function(topLevelElements) {
      var t1, t2, referencedLibraries, t3, nonPlatformSize, t4, t5, percentage;
      t1 = this.compiler;
      t2 = t1.libraryLoader.libraryCanonicalUriMap;
      t2 = t2.get$values(t2);
      referencedLibraries = H.setRuntimeTypeInfo(new H.WhereIterable(t2, this.get$isUserLibrary()), [H.getRuntimeTypeArgument(t2, "IterableBase", 0)]);
      for (t2 = H.setRuntimeTypeInfo(new H.WhereIterator(J.get$iterator$ax(referencedLibraries._iterable), referencedLibraries._f), [H.getTypeArgumentByIndex(referencedLibraries, 0)]), t3 = t2._iterator, nonPlatformSize = 0; t2.moveNext$0();) {
        t4 = t3.get$current().get$compilationUnits();
        t5 = new E.LinkIterator(null, t4);
        t5.$builtinTypeInfo = [H.getTypeArgumentByIndex(t4, 0)];
        for (; t5.moveNext$0();) {
          t4 = t5._util_implementation$_current.get$script().file;
          nonPlatformSize += t4.get$length(t4);
        }
      }
      percentage = C.JSInt_methods.$tdiv(t1.assembledCode.length * 100, nonPlatformSize);
      t1.log$1("[DartBackend] " + ("Total used non-platform files size: " + nonPlatformSize + " bytes, bundle size: " + t1.assembledCode.length + " bytes (" + percentage + "%)"));
    },
    onLibrariesLoaded$1: function(loadedLibraries) {
      var t1;
      loadedLibraries.get$values(loadedLibraries).forEach$1(0, new G.DartBackend_onLibrariesLoaded_closure(this));
      if (this.useMirrorHelperLibrary && loadedLibraries.containsKey$1($.get$Compiler_DART_MIRRORS())) {
        t1 = this.compiler;
        return t1.libraryLoader.loadLibrary$1(t1.translateResolvedUri$3(loadedLibraries.$index(0, $.get$Compiler_DART_MIRRORS()), $.get$MirrorRenamer_DART_MIRROR_HELPER(), null)).then$1(new G.DartBackend_onLibrariesLoaded_closure0(this));
      }
      return P._Future$immediate(null, null);
    },
    registerMirrorHelperElement$2: function(element, node) {
      var t1, t2, t3;
      if (this.mirrorHelperLibrary != null) {
        t1 = element.get$library();
        t2 = this.mirrorHelperLibrary;
        t2 = t1 == null ? t2 == null : t1 === t2;
        t1 = t2;
      } else
        t1 = false;
      if (t1) {
        t1 = this.mirrorRenamer;
        t2 = t1.backend;
        t3 = t2.mirrorHelperGetNameFunction;
        if (element == null ? t3 == null : element === t3)
          t1.mirrorHelperGetNameFunctionNode = node;
        else {
          t2 = t2.mirrorHelperSymbolsMap;
          if (element == null ? t2 == null : element === t2)
            t1.mirrorHelperSymbolsMapNode = node;
        }
      }
    },
    registerStaticUse$2: function(element, enqueuer) {
      if (this.useMirrorHelperLibrary && element === this.compiler.mirrorSystemGetNameFunction)
        enqueuer.internalAddToWorkList$1(this.mirrorHelperGetNameFunction);
    },
    DartBackend$2: function(compiler, strips) {
      this.resolutionCallbacks = new G.DartResolutionCallbacks(this);
    },
    $isDartBackend: true
  },
  DartBackend_isSafeToRemoveTypeDeclarations_closure: {
    "^": "Closure:123;typeErrorElement_0",
    call$1: function(type) {
      var t1, t2;
      t1 = type.get$element();
      t2 = this.typeErrorElement_0;
      return t1 == null ? t2 == null : t1 === t2;
    },
    $isFunction: true
  },
  DartBackend_isSafeToRemoveTypeDeclarations_closure0: {
    "^": "Closure:13;",
    call$1: function(classElement) {
      return classElement.get$thisType();
    },
    $isFunction: true
  },
  DartBackend_assembleProgram_closure: {
    "^": "Closure:77;this_1,fixedMemberNames_2",
    call$1: function(element) {
      var t1 = J.getInterceptor$x(element);
      if (t1.get$kind(element) === C.ElementKind_class_4)
        element.forEachLocalMember$1(new G.DartBackend_assembleProgram__closure(this.fixedMemberNames_2));
      this.fixedMemberNames_2.add$1(0, t1.get$name(element));
    },
    $isFunction: true
  },
  DartBackend_assembleProgram__closure: {
    "^": "Closure:13;fixedMemberNames_3",
    call$1: function(member) {
      var $name = J.get$name$x(member);
      if (!J.startsWith$1$s($name, "operator$"))
        this.fixedMemberNames_3.add$1(0, C.JSArray_methods.get$last($name.split("$")));
    },
    $isFunction: true
  },
  DartBackend_assembleProgram_parse: {
    "^": "Closure:145;this_4",
    call$1: function(element) {
      var t1, t2, $function, builder, definition, treeElements, t3, t4, t5, t6, t7, backendAst;
      t1 = this.this_4.compiler;
      t2 = J.getInterceptor$x(element);
      if (!t1.irBuilder.nodes.containsKey$1(t2.get$implementation(element)))
        return new G.ElementAst(element.get$resolvedAst().node, element.get$resolvedAst().elements);
      else {
        $function = t1.irBuilder.nodes.$index(0, t2.get$implementation(element));
        new X.RedundantPhiEliminator(P.LinkedHashMap_LinkedHashMap$_empty(D.Continuation, [P.List, D.InvokeContinuation]), P.LinkedHashMap_LinkedHashMap$_empty(D.Reference, D.Continuation), P.LinkedHashSet_LinkedHashSet(null, null, null, D.Continuation)).rewrite$1($function);
        t1.tracer.traceCompilation$3(t2.get$name(element), null, t1);
        t1.tracer.traceGraph$2("Redundant phi elimination", $function);
        new X.ShrinkingReducer(null, null).rewrite$1($function);
        t1.tracer.traceGraph$2("Shrinking reductions", $function);
        $function.accept$1(0, new D.RegisterAllocator(P.LinkedHashMap_LinkedHashMap$_empty(O.Element, D.RegisterArray)));
        builder = new X.Builder(t1, P.LinkedHashMap_LinkedHashMap$_empty(O.Element, [P.List, M.Variable]), P.LinkedHashMap_LinkedHashMap$_empty(O.Local, M.Variable), P.LinkedHashMap_LinkedHashMap$_empty(D.Continuation, M.Label0), null, null, null, null);
        $function.accept$1(0, builder);
        definition = builder.$function;
        t1.tracer.traceGraph$2("Tree builder", definition);
        new E.StatementRewriter(null, P.LinkedHashMap_LinkedHashMap$_empty(M.Label0, M.Jump)).rewrite$1(definition);
        t1.tracer.traceGraph$2("Statement rewriter", definition);
        t2 = new E.CopyPropagator(P.LinkedHashMap_LinkedHashMap$_empty(M.Variable, M.Assign), P.LinkedHashMap_LinkedHashMap$_empty(M.Variable, M.Assign), null);
        t2.functionElement = definition.element;
        t2.visitFunctionDefinition$1(definition);
        t1.tracer.traceGraph$2("Copy propagation", definition);
        t2 = P.LinkedHashSet_LinkedHashSet(null, null, null, M.Label0);
        definition.body = definition.body.accept$1(0, new R.LoopRewriter(t2));
        t1.tracer.traceGraph$2("Loop rewriter", definition);
        definition.body = definition.body.accept$1(0, new A.LogicalRewriter(null));
        t1.tracer.traceGraph$2("Logical rewriter", definition);
        new Y.UnshadowParameters(P.LinkedHashMap_LinkedHashMap$_empty(P.String, M.Variable), P.LinkedHashSet_LinkedHashSet(null, null, null, M.Variable), P.LinkedHashSet_LinkedHashSet(null, null, null, M.Variable)).visitFunctionDefinition$1(definition);
        t1.tracer.traceGraph$2("Unshadow parameters", definition);
        t1 = $.TreeElementMapping__hashCodeCounter + 1;
        $.TreeElementMapping__hashCodeCounter = t1;
        treeElements = new A.TreeElementMapping(element, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, t1);
        t1 = H.setRuntimeTypeInfo([], [F.VariableDeclaration0]);
        t2 = P.LinkedHashMap_LinkedHashMap$_empty(M.Variable, P.String);
        t3 = P.LinkedHashMap_LinkedHashMap$_empty(O.VariableElement, P.String);
        t4 = P.LinkedHashSet_LinkedHashSet(null, null, null, M.Variable);
        t5 = H.setRuntimeTypeInfo([], [F.Statement1]);
        t6 = $.get$Modifiers_EMPTY();
        t7 = P.LinkedHashSet_LinkedHashSet(null, null, null, M.Label0);
        backendAst = new Y.ASTEmitter(t1, t2, t3, t4, P.LinkedHashSet_LinkedHashSet(null, null, null, P.String), t5, null, new U.VariableList(null, null, t6, C.C_Link2), null, t7, null, null).emit$1(definition);
        return new G.ElementAst(new D.TreePrinter(treeElements, D.TreePrinter_makeGroup(C.PrecedenceInfo_wYn, C.PrecedenceInfo_MIj), D.TreePrinter_makeGroup(C.PrecedenceInfo_qJU, C.PrecedenceInfo_atK), D.TreePrinter_makeGroup(C.PrecedenceInfo_atn, C.PrecedenceInfo_6L0), D.TreePrinter_makeGroup(C.PrecedenceInfo_S9I, C.PrecedenceInfo_TG0), new Y.SymbolToken(C.PrecedenceInfo_kuc, -1, null), new Y.SymbolToken(C.PrecedenceInfo_CRA, -1, null), new Y.SymbolToken(C.PrecedenceInfo_3u5, -1, null), new Y.SymbolToken(C.PrecedenceInfo_pmZ, -1, null), new Y.SymbolToken(C.PrecedenceInfo_YfA, -1, null), new Y.SymbolToken(C.PrecedenceInfo_Mr4, -1, null), new Y.SymbolToken(C.PrecedenceInfo_xw8, -1, null), new Y.StringToken(Y.StringToken_canonicalizedString("new", false), C.PrecedenceInfo_identifier_0_97, -1, null), new Y.StringToken(Y.StringToken_canonicalizedString("const", false), C.PrecedenceInfo_identifier_0_97, -1, null), new Y.StringToken(Y.StringToken_canonicalizedString("throw", false), C.PrecedenceInfo_identifier_0_97, -1, null), new Y.StringToken(Y.StringToken_canonicalizedString("rethrow", false), C.PrecedenceInfo_identifier_0_97, -1, null), new Y.StringToken(Y.StringToken_canonicalizedString("break", false), C.PrecedenceInfo_identifier_0_97, -1, null), new Y.StringToken(Y.StringToken_canonicalizedString("continue", false), C.PrecedenceInfo_identifier_0_97, -1, null), new Y.StringToken(Y.StringToken_canonicalizedString("do", false), C.PrecedenceInfo_identifier_0_97, -1, null), new Y.StringToken(Y.StringToken_canonicalizedString("while", false), C.PrecedenceInfo_identifier_0_97, -1, null), new Y.StringToken(Y.StringToken_canonicalizedString("if", false), C.PrecedenceInfo_identifier_0_97, -1, null), new Y.StringToken(Y.StringToken_canonicalizedString("else", false), C.PrecedenceInfo_identifier_0_97, -1, null), new Y.StringToken(Y.StringToken_canonicalizedString("for", false), C.PrecedenceInfo_identifier_0_97, -1, null), new Y.StringToken(Y.StringToken_canonicalizedString("in", false), C.PrecedenceInfo_identifier_0_97, -1, null), new Y.StringToken(Y.StringToken_canonicalizedString("return", false), C.PrecedenceInfo_identifier_0_97, -1, null), new Y.StringToken(Y.StringToken_canonicalizedString("switch", false), C.PrecedenceInfo_identifier_0_97, -1, null), new Y.StringToken(Y.StringToken_canonicalizedString("case", false), C.PrecedenceInfo_identifier_0_97, -1, null), new Y.StringToken(Y.StringToken_canonicalizedString("default", false), C.PrecedenceInfo_identifier_0_97, -1, null), new Y.StringToken(Y.StringToken_canonicalizedString("try", false), C.PrecedenceInfo_identifier_0_97, -1, null), new Y.StringToken(Y.StringToken_canonicalizedString("catch", false), C.PrecedenceInfo_identifier_0_97, -1, null), new Y.StringToken(Y.StringToken_canonicalizedString("on", false), C.PrecedenceInfo_identifier_0_97, -1, null), new Y.StringToken(Y.StringToken_canonicalizedString("finally", false), C.PrecedenceInfo_identifier_0_97, -1, null), new Y.SymbolToken(C.PrecedenceInfo_sx4, -1, null)).makeExp$2(backendAst, 1), treeElements);
      }
    },
    $isFunction: true
  },
  DartBackend_assembleProgram_processElement: {
    "^": "Closure:146;box_0,this_5,elementAsts_6",
    call$2: function(element, elementAst) {
      var t1 = this.box_0;
      new G.ReferencedElementCollector(this.this_5.compiler, element, elementAst, t1.newTypedefElementCallback_0, t1.newClassElementCallback_1).collect$0();
      this.elementAsts_6.$indexSet(0, element, elementAst);
    },
    $isFunction: true
  },
  DartBackend_assembleProgram_addTopLevel: {
    "^": "Closure:147;topLevelElements_7,processElement_8",
    call$2: function(element, elementAst) {
      var t1 = this.topLevelElements_7;
      if (t1.contains$1(0, element))
        return;
      t1.add$1(0, element);
      this.processElement_8.call$2(element, elementAst);
    },
    $isFunction: true
  },
  DartBackend_assembleProgram_addClass: {
    "^": "Closure:87;classMembers_9,addTopLevel_10",
    call$1: function(classElement) {
      this.addTopLevel_10.call$2(classElement, new G.ElementAst(classElement.get$resolvedAst().node, classElement.get$resolvedAst().elements));
      this.classMembers_9.putIfAbsent$2(classElement, new G.DartBackend_assembleProgram_addClass_closure());
    },
    $isFunction: true
  },
  DartBackend_assembleProgram_addClass_closure: {
    "^": "Closure:23;",
    call$0: function() {
      return P.LinkedHashSet_LinkedHashSet(null, null, null, null);
    },
    $isFunction: true
  },
  DartBackend_assembleProgram_closure0: {
    "^": "Closure:148;this_11,addTopLevel_12",
    call$1: function(element) {
      if (!this.this_11.shouldOutput$1(element))
        return;
      this.addTopLevel_12.call$2(element, new G.ElementAst(element.get$resolvedAst().node, element.get$resolvedAst().elements));
    },
    $isFunction: true
  },
  DartBackend_assembleProgram_closure1: {
    "^": "Closure:87;this_13,addClass_14",
    call$1: function(classElement) {
      if (!this.this_13.shouldOutput$1(classElement))
        return;
      this.addClass_14.call$1(classElement);
    },
    $isFunction: true
  },
  DartBackend_assembleProgram_closure2: {
    "^": "Closure:87;this_15,addClass_16",
    call$1: function(classElement) {
      if (this.this_15.shouldOutput$1(classElement))
        this.addClass_16.call$1(classElement);
    },
    $isFunction: true
  },
  DartBackend_assembleProgram_closure3: {
    "^": "Closure:13;this_17,parse_18,classMembers_19,processElement_20,addTopLevel_21,addClass_22",
    call$1: function(element) {
      var t1, elementAst, enclosingClass;
      t1 = this.this_17;
      if (!t1.shouldOutput$1(element) || !t1.compiler.enqueuer.resolution.resolvedElements.contains$1(0, element.get$analyzableElement().get$declaration()))
        return;
      elementAst = this.parse_18.call$1(element);
      if (element.get$isClassMember()) {
        enclosingClass = element.get$enclosingClass();
        this.addClass_22.call$1(enclosingClass);
        J.add$1$ax(this.classMembers_19.$index(0, enclosingClass), element);
        this.processElement_20.call$2(element, elementAst);
      } else if (element.get$isTopLevel())
        this.addTopLevel_21.call$2(element, elementAst);
    },
    $isFunction: true
  },
  DartBackend_assembleProgram_closure4: {
    "^": "Closure:87;this_23,topLevelElements_24,addClass_25,emitNoMembersFor_26",
    call$1: function(element) {
      if (this.this_23.shouldOutput$1(element)) {
        if (!this.topLevelElements_24.contains$1(0, element))
          this.emitNoMembersFor_26.add$1(0, element);
        this.addClass_25.call$1(element);
      }
    },
    $isFunction: true
  },
  DartBackend_assembleProgram_makePlaceholders: {
    "^": "Closure:13;this_27,classMembers_28,collector_29",
    call$1: function(element) {
      var t1, oldUseHelper, t2, t3;
      t1 = this.this_27;
      oldUseHelper = t1.useMirrorHelperLibrary;
      if (oldUseHelper) {
        t2 = element.get$library();
        t3 = t1.mirrorHelperLibrary;
        t3 = t2 == null ? t3 != null : t2 !== t3;
        t2 = t3;
      } else
        t2 = false;
      t1.useMirrorHelperLibrary = t2;
      this.collector_29.collect$1(element);
      t1.useMirrorHelperLibrary = oldUseHelper;
      if (element.get$isClass() === true)
        J.forEach$1$ax(this.classMembers_28.$index(0, element), this);
    },
    $isFunction: true
  },
  DartBackend_assembleProgram_closure5: {
    "^": "Closure:19;sortedClassMembers_30",
    call$2: function(classElement, members) {
      this.sortedClassMembers_30.$indexSet(0, classElement, G.sorted(members, G.compareElements$closure()));
    },
    $isFunction: true
  },
  DartBackend_assembleProgram_outputElement: {
    "^": "Closure:13;this_31,sb_32",
    call$1: function(element) {
      var t1 = element.parseNode$1(this.this_31.compiler);
      t1.toString;
      this.sb_32.write$1(Y.PrettyPrinter_prettyPrint(t1));
    },
    $isFunction: true
  },
  DartBackend_onLibrariesLoaded_closure: {
    "^": "Closure:79;this_0",
    call$1: function(library) {
      if (library.get$isPlatformLibrary())
        library.forEachLocalMember$1(new G.DartBackend_onLibrariesLoaded__closure(this.this_0));
    },
    $isFunction: true
  },
  DartBackend_onLibrariesLoaded__closure: {
    "^": "Closure:77;this_1",
    call$1: function(element) {
      if (J.get$kind$x(element) === C.ElementKind_class_4)
        element.ensureResolved$1(this.this_1.compiler);
    },
    $isFunction: true
  },
  DartBackend_onLibrariesLoaded_closure0: {
    "^": "Closure:79;this_2",
    call$1: function(element) {
      var t1 = this.this_2;
      t1.mirrorHelperLibrary = element;
      t1.mirrorHelperGetNameFunction = J.find$1$x(element, "helperGetName");
      t1.mirrorHelperSymbolsMap = t1.mirrorHelperLibrary.find$1(0, "_SYMBOLS");
    },
    $isFunction: true
  },
  DartResolutionCallbacks: {
    "^": "ResolutionCallbacks;backend<",
    onTypeLiteral$2: function(type, registry) {
      if (type.get$kind(type) === C.TypeKind_interface)
        this.backend.usedTypeLiterals.add$1(0, type.get$element());
    }
  },
  EmitterUnparser: {
    "^": "Unparser;renames,sb,minify,stripTypes,onEmptyLine,_indentLevel,_indentList,_indentationUnit",
    visit$1: function(node) {
      if (node != null && this.renames.containsKey$1(node))
        this.write$1(this.renames.$index(0, node));
      else
        Y.Unparser.prototype.visit$1.call(this, node);
    },
    unparseSendReceiver$2$spacesNeeded: function(node, spacesNeeded) {
      var t1 = node.receiver;
      if (t1 != null && J.$eq(this.renames.$index(0, t1), ""))
        return;
      Y.Unparser.prototype.unparseSendReceiver$2$spacesNeeded.call(this, node, spacesNeeded);
    },
    unparseSendReceiver$1: function(node) {
      return this.unparseSendReceiver$2$spacesNeeded(node, false);
    },
    unparseFunctionName$1: function($name) {
      if ($name != null && this.renames.containsKey$1($name))
        this.write$1(this.renames.$index(0, $name));
      else
        Y.Unparser.prototype.unparseFunctionName$1.call(this, $name);
    }
  },
  ReferencedElementCollector: {
    "^": "Visitor;compiler<,element<,elementAst,newTypedefElementCallback,newClassElementCallback",
    newTypedefElementCallback$1: function(arg0) {
      return this.newTypedefElementCallback.call$1(arg0);
    },
    newClassElementCallback$1: function(arg0) {
      return this.newClassElementCallback.call$1(arg0);
    },
    visitNode$1: function(node) {
      node.visitChildren$1(this);
    },
    visitTypeAnnotation$1: function(typeAnnotation) {
      var t1, type;
      t1 = this.elementAst.treeElements._types;
      type = t1 != null ? t1.$index(0, typeAnnotation) : null;
      t1 = J.getInterceptor$x(type);
      if (t1.get$kind(type) === C.TypeKind_typedef)
        this.newTypedefElementCallback$1(type.get$element());
      if (t1.get$kind(type) === C.TypeKind_interface)
        this.newClassElementCallback$1(type.get$element());
      typeAnnotation.visitChildren$1(this);
    },
    collect$0: function() {
      this.compiler.withCurrentElement$2(this.element, new G.ReferencedElementCollector_collect_closure(this));
    },
    $asVisitor: function() {
      return [null];
    }
  },
  ReferencedElementCollector_collect_closure: {
    "^": "Closure:23;this_0",
    call$0: function() {
      var t1 = this.this_0;
      t1.elementAst.ast.accept$1(0, t1);
    },
    $isFunction: true
  },
  compareBy_closure: {
    "^": "Closure:19;f_0",
    call$2: function(x, y) {
      var t1 = this.f_0;
      return J.compareTo$1$ns(t1.call$1(x), t1.call$1(y));
    },
    $isFunction: true
  },
  compareElements_closure: {
    "^": "Closure:13;",
    call$1: function(e) {
      return e.get$library().canonicalUri.toString$0(0);
    },
    $isFunction: true
  },
  compareElements_closure0: {
    "^": "Closure:13;",
    call$1: function(e) {
      return J.get$position$x(e).get$charOffset();
    },
    $isFunction: true
  },
  DartConstantTask: {
    "^": "ConstantCompilerTask;constantCompiler,compiler,watch,profilerTag",
    get$name: function(_) {
      return "ConstantHandler";
    },
    getConstantForVariable$1: function(element) {
      return this.constantCompiler.initialVariableValues.$index(0, element.get$declaration());
    },
    getConstantForNode$2: function(node, elements) {
      var t1 = elements._constants;
      return t1 != null ? t1.$index(0, node) : null;
    },
    getConstantForMetadata$1: function(metadata) {
      return metadata.get$value(metadata);
    },
    compileConstant$1: function(element) {
      return this.measure$1(new G.DartConstantTask_compileConstant_closure(this, element));
    },
    compileVariable$1: function(element) {
      this.measure$1(new G.DartConstantTask_compileVariable_closure(this, element));
    },
    compileNode$2: function(node, elements) {
      return this.measure$1(new G.DartConstantTask_compileNode_closure(this, node, elements));
    },
    compileMetadata$3: function(metadata, node, elements) {
      return this.measure$1(new G.DartConstantTask_compileMetadata_closure(this, metadata, node, elements));
    }
  },
  DartConstantTask_compileConstant_closure: {
    "^": "Closure:23;this_0,element_1",
    call$0: function() {
      return this.this_0.constantCompiler.compileVariable$2$isConst(this.element_1, true);
    },
    $isFunction: true
  },
  DartConstantTask_compileVariable_closure: {
    "^": "Closure:23;this_0,element_1",
    call$0: function() {
      this.this_0.constantCompiler.compileVariable$1(this.element_1);
    },
    $isFunction: true
  },
  DartConstantTask_compileNode_closure: {
    "^": "Closure:23;this_0,node_1,elements_2",
    call$0: function() {
      return this.this_0.constantCompiler.compileNodeWithDefinitions$2(this.node_1, this.elements_2);
    },
    $isFunction: true
  },
  DartConstantTask_compileMetadata_closure: {
    "^": "Closure:23;this_0,metadata_1,node_2,elements_3",
    call$0: function() {
      return this.this_0.constantCompiler.compileNodeWithDefinitions$2(this.node_2, this.elements_3);
    },
    $isFunction: true
  },
  LocalPlaceholder: {
    "^": "Object;identifier<,nodes>",
    get$hashCode: function(_) {
      return J.get$hashCode$(this.identifier);
    },
    toString$0: function(_) {
      return "local_placeholder[id(" + H.S(this.identifier) + "), nodes(" + P.IterableBase_iterableToFullString(this.nodes, "{", "}") + ")]";
    }
  },
  FunctionScope: {
    "^": "Object;parameterIdentifiers<,localPlaceholders<",
    registerParameter$1: function(node) {
      var t1 = node.token;
      this.parameterIdentifiers.add$1(0, t1.get$value(t1));
    }
  },
  ConstructorPlaceholder: {
    "^": "Object;node<,element<"
  },
  DeclarationTypePlaceholder: {
    "^": "Object;typeNode<,requiresVar"
  },
  SendVisitor: {
    "^": "ResolvedVisitor;collector,compiler,elements",
    visitOperatorSend$1: function(node) {
    },
    visitSuperSend$1: function(node) {
      var element, t1, t2;
      this.elements.toString;
      element = node.get$_secret_tree_element$_element();
      if (element != null)
        t1 = element.get$kind(element) === C.ElementKind_generative_constructor_16 || element.get$isFactoryConstructor();
      else
        t1 = false;
      t2 = this.collector;
      if (t1)
        t2.tryMakeConstructorPlaceholder$2(node, element);
      else
        t2.tryMakeMemberPlaceholder$1(node.selector);
    },
    visitDynamicSend$1: function(node) {
      var element;
      this.elements.toString;
      element = node.get$_secret_tree_element$_element();
      if (element == null || !element.get$isErroneous())
        this.collector.tryMakeMemberPlaceholder$1(node.selector);
    },
    visitClosureSend$1: function(node) {
      var element;
      this.elements.toString;
      element = node.get$_secret_tree_element$_element();
      if (element != null)
        this.collector.tryMakeLocalPlaceholder$2(element, node.selector);
    },
    visitGetterSend$1: function(node) {
      var element, t1;
      this.elements.toString;
      element = node.get$_secret_tree_element$_element();
      if (element == null)
        this.collector.tryMakeMemberPlaceholder$1(node.selector);
      else if (element.get$isErroneous()) {
        this.collector.unresolvedNodes.add$1(0, node);
        return;
      } else if (element.get$kind(element) === C.ElementKind_prefix_8)
        this.collector.makeErasePrefixPlaceholder$1(node);
      else if (O.Elements_isStaticOrTopLevel(element))
        this.collector.makeElementPlaceholder$2(node.selector, element);
      else if (!element.get$isTopLevel())
        if (element.get$isInstanceMember())
          this.collector.tryMakeMemberPlaceholder$1(node.selector);
        else {
          t1 = node.selector;
          if (!!J.getInterceptor(t1).$isIdentifier)
            this.collector.tryMakeLocalPlaceholder$2(element, t1);
        }
    },
    visitAssert$1: function(node) {
      this.visitStaticSend$1(node);
    },
    visitStaticSend$1: function(node) {
      var element, t1, t2, t3;
      this.elements.toString;
      element = node.get$_secret_tree_element$_element();
      t1 = this.collector;
      t2 = t1.compiler.backend;
      if (t2.get$useMirrorHelperLibrary()) {
        t2 = t2.mirrorRenamer;
        t3 = t2.compiler.mirrorSystemGetNameFunction;
        if (element == null ? t3 == null : element === t3)
          t2.mirrorSystemGetNameNodes.push(node);
      }
      if (!(element == null || element.get$isErroneous())) {
        t2 = this.elements._asserts;
        t2 = t2 != null && t2.contains$1(0, node) === true || element.get$isDeferredLoaderGetter();
      } else
        t2 = true;
      if (t2)
        return;
      if (element.get$kind(element) === C.ElementKind_generative_constructor_16 || element.get$isFactoryConstructor() || element.get$isFactoryConstructor()) {
        t2 = node.receiver;
        if (!!J.getInterceptor(t2).$isIdentifier) {
          t2 = t2.asIdentifier$0().token;
          t2 = t2.get$value(t2) === "this";
        } else
          t2 = false;
        if (t2)
          t1.tryMakeConstructorPlaceholder$2(node, element);
        return;
      }
      t1.makeElementPlaceholder$2(node.selector, element);
      if (element.get$isTopLevel() && node.receiver != null)
        t1.makeErasePrefixPlaceholder$1(node.receiver);
    },
    internalError$2$node: function(reason, node) {
      this.collector.compiler.internalError$2(node, reason);
    },
    visitTypePrefixSend$1: function(node) {
      this.elements.toString;
      this.collector.makeElementPlaceholder$2(node, node.get$_secret_tree_element$_element());
    },
    visitTypeLiteralSend$1: function(node) {
      var t1, type, t2, t3;
      t1 = this.elements._types;
      type = t1 != null ? t1.$index(0, node) : null;
      t1 = J.getInterceptor$x(type);
      if (t1.get$kind(type) !== C.TypeKind_dynamic) {
        t2 = node.selector;
        t3 = this.collector;
        if (!!t1.$isTypeVariableType)
          t3.makeTypeVariablePlaceholder$2(t2, type);
        else
          t3.makeTypePlaceholder$2(t2, type);
      }
    },
    $asResolvedVisitor: function() {
      return [null];
    },
    $asVisitor: function() {
      return [null];
    }
  },
  PlaceholderCollector: {
    "^": "Visitor;compiler<,fixedMemberNames,elementAsts,prefixNodesToErase,unresolvedNodes,elementNodes,functionScopes,privateNodes,declarationTypePlaceholders,memberPlaceholders,constructorPlaceholders,currentLocalPlaceholders,currentElement,topmostEnclosingFunction,treeElements<",
    get$backend: function() {
      return this.compiler.backend;
    },
    get$currentFunctionScope: function() {
      return this.functionScopes.putIfAbsent$2(this.topmostEnclosingFunction, new G.PlaceholderCollector_currentFunctionScope_closure());
    },
    collect$1: function(element) {
      var elementAst, elementNode, t1, bodyAsRedirectingFactoryBody, redirectTarget, t2, definition, $name;
      this.currentElement = element;
      this.topmostEnclosingFunction = null;
      elementAst = this.elementAsts.$index(0, element);
      this.treeElements = elementAst.get$treeElements();
      elementNode = elementAst.get$ast();
      t1 = J.getInterceptor(element);
      if (!!t1.$isFunctionElement) {
        if (t1.get$kind(element) === C.ElementKind_generative_constructor_16 || element.get$isFactoryConstructor()) {
          element.get$enclosingClass().get$thisType().asRaw$0();
          this.tryMakeConstructorPlaceholder$2(elementNode.get$name(elementNode), element);
          bodyAsRedirectingFactoryBody = elementNode.get$body(elementNode).asRedirectingFactoryBody$0();
          if (bodyAsRedirectingFactoryBody != null) {
            redirectTarget = element.get$immediateRedirectionTarget();
            redirectTarget.get$enclosingClass().get$thisType().asRaw$0();
            this.tryMakeConstructorPlaceholder$2(bodyAsRedirectingFactoryBody.constructorReference, redirectTarget);
          }
        } else if (O.Elements_isStaticOrTopLevel(element))
          this.makeElementPlaceholder$2(elementNode.get$name(elementNode), element);
        else if (element.get$isClassMember())
          if (!!J.getInterceptor(elementNode.get$name(elementNode)).$isIdentifier)
            this.tryMakeMemberPlaceholder$1(elementNode.get$name(elementNode));
      } else if (!!t1.$isVariableElement) {
        t2 = elementNode.get$definitions().nodes;
        definition = t2.get$head(t2);
        $name = !!J.getInterceptor(definition).$isIdentifier ? definition : definition.asSend$0().selector;
        if (O.Elements_isStaticOrTopLevel(element))
          this.makeElementPlaceholder$2($name, element);
        else if (O.Elements_isInstanceField(element))
          this.tryMakeMemberPlaceholder$1($name);
        this.makeVarDeclarationTypePlaceholder$1(elementNode);
      }
      this.currentLocalPlaceholders = P.LinkedHashMap_LinkedHashMap(null, null, null, P.String, G.LocalPlaceholder);
      if (!(!!t1.$isConstructorElement && element.get$isRedirectingFactory()))
        this.compiler.withCurrentElement$2(element, new G.PlaceholderCollector_collect_closure(this, elementNode));
      t2 = this.compiler;
      if (t1.$eq(element, t2.backend.get$mirrorHelperSymbolsMap()))
        t2.backend.registerMirrorHelperElement$2(element, elementNode);
    },
    tryMakeLocalPlaceholder$2: function(element, node) {
      var t1;
      if (element.get$kind(element) === C.ElementKind_parameter_1) {
        if (element.get$enclosingElement() != null) {
          t1 = element.get$enclosingElement();
          t1 = t1.get$kind(t1) === C.ElementKind_typedef_32;
        } else
          t1 = false;
        t1 = !t1 && new G.PlaceholderCollector_tryMakeLocalPlaceholder_isNamedOptionalParameter(element).call$0() === true;
      } else
        t1 = false;
      if (t1)
        this.get$currentFunctionScope().registerParameter$1(node);
      else {
        if (O.Elements_isLocal(element)) {
          if (element.get$enclosingElement() != null) {
            t1 = element.get$enclosingElement();
            t1 = t1.get$kind(t1) === C.ElementKind_typedef_32;
          } else
            t1 = false;
          t1 = !t1;
        } else
          t1 = false;
        if (t1)
          this.makeLocalPlaceholder$1(node);
      }
    },
    tryMakeMemberPlaceholder$1: function(node) {
      var t1, identifier;
      if (!!J.getInterceptor(node).$isOperator)
        return;
      t1 = node.get$token();
      identifier = t1.get$value(t1);
      if (this.fixedMemberNames.contains$1(0, identifier))
        return;
      J.add$1$ax(this.memberPlaceholders.putIfAbsent$2(identifier, new G.PlaceholderCollector_tryMakeMemberPlaceholder_closure()), node);
    },
    makeTypePlaceholder$2: function(node, type) {
      var send = node.asSend$0();
      if (send != null) {
        this.makeErasePrefixPlaceholder$1(send.receiver);
        node = send.selector;
      }
      this.makeElementPlaceholder$2(node, type.get$element());
    },
    makeTypeVariablePlaceholder$2: function(node, type) {
      var send = node.asSend$0();
      if (send != null) {
        this.makeErasePrefixPlaceholder$1(send.receiver);
        node = send.selector;
      }
      this.tryMakeMemberPlaceholder$1(node);
    },
    makeOmitDeclarationTypePlaceholder$1: function(type) {
      if (type == null)
        return;
      this.declarationTypePlaceholders.push(new G.DeclarationTypePlaceholder(type, false));
    },
    makeVarDeclarationTypePlaceholder$1: function(node) {
      var t1, t2;
      if (node.get$type(node) == null)
        return;
      t1 = this.treeElements;
      t2 = node.get$definitions().nodes;
      t2 = t2.get$head(t2);
      t1.toString;
      t2.get$_secret_tree_element$_element();
      t1 = node.get$modifiers().flags;
      t1 = (t1 & 4) !== 0 || (t1 & 16) !== 0;
      this.declarationTypePlaceholders.push(new G.DeclarationTypePlaceholder(node.get$type(node), !t1));
    },
    makeErasePrefixPlaceholder$1: function(node) {
      this.prefixNodesToErase.add$1(0, node);
    },
    makeElementPlaceholder$2: function(node, element) {
      var library, t1;
      library = element.get$library();
      t1 = this.compiler;
      if (element === t1.mainFunction)
        return;
      t1 = t1.coreLibrary;
      if (library == null ? t1 == null : library === t1)
        return;
      if (library.canonicalUri.scheme === "dart" && !element.get$isTopLevel())
        return;
      if (element.get$isGetter() || element.kind === C.ElementKind_setter_0)
        element = H.interceptedTypeCast(element, "$isFunctionElement").get$abstractField();
      J.add$1$ax(this.elementNodes.putIfAbsent$2(element, new G.PlaceholderCollector_makeElementPlaceholder_closure()), node);
    },
    tryMakePrivateIdentifier$2: function(node, element) {
      var t1;
      if (!!J.getInterceptor(node).$isIdentifier)
        if (!O.Elements_isStaticOrTopLevel(element))
          if (!O.Elements_isLocal(element)) {
            t1 = node.token;
            t1 = t1.get$value(t1);
            t1 = !J.getInterceptor$asx(t1).get$isEmpty(t1) && C.JSString_methods.codeUnitAt$1(t1, 0) === 95;
          } else
            t1 = false;
        else
          t1 = false;
      else
        t1 = false;
      if (t1)
        J.add$1$ax(this.privateNodes.putIfAbsent$2(this.currentElement.get$library(), new G.PlaceholderCollector_tryMakePrivateIdentifier_closure()), node);
    },
    makeLocalPlaceholder$1: function(identifier) {
      J.add$1$ax(J.get$nodes$x(new G.PlaceholderCollector_makeLocalPlaceholder_getLocalPlaceholder(this, identifier).call$0()), identifier);
    },
    findDefiningConstructor$1: function(element) {
      for (; element.get$definingConstructor() != null;)
        element = element.get$definingConstructor();
      return element;
    },
    tryMakeConstructorPlaceholder$2: function(node, element) {
      var t1, prefix, prefix0, className, constructorName, receiverElement, t2;
      t1 = element != null;
      if (!t1 || element.get$isErroneous()) {
        this.unresolvedNodes.add$1(0, node);
        return;
      }
      if (!!J.getInterceptor(node).$isSend) {
        prefix = node.receiver;
        if (!!J.getInterceptor(prefix).$isSend) {
          prefix0 = prefix.get$receiver();
          className = prefix.selector;
          constructorName = node.selector;
          prefix = prefix0;
        } else {
          this.treeElements.toString;
          receiverElement = prefix.get$_secret_tree_element$_element();
          t2 = receiverElement != null && receiverElement.get$kind(receiverElement) === C.ElementKind_prefix_8;
          className = node.selector;
          if (t2)
            constructorName = null;
          else {
            constructorName = className;
            className = prefix;
            prefix = null;
          }
        }
      } else {
        className = node;
        prefix = null;
        constructorName = null;
      }
      if (prefix != null)
        this.makeErasePrefixPlaceholder$1(prefix);
      t2 = J.getInterceptor(className);
      if (!!t2.$isTypeAnnotation)
        this.visitTypeAnnotation$1(className);
      else if (!t1 || element.get$isErroneous())
        ;
      else if (className.isThis$0() || className.isSuper$0())
        ;
      else if (!!t2.$isIdentifier)
        this.makeElementPlaceholder$2(className, element.get$contextClass());
      else
        throw H.wrapException("Bad type of constructor name " + H.S(className));
      if (constructorName != null) {
        this.constructorPlaceholders.push(new G.ConstructorPlaceholder(constructorName, this.findDefiningConstructor$1(element)));
        this.tryMakePrivateIdentifier$2(constructorName, element);
      }
    },
    visitNode$1: function(node) {
      node.visitChildren$1(this);
    },
    visitNewExpression$1: function(node) {
      var send, t1, $constructor, t2, optionalParameters, named, $name, nameAsString, parameter, t3;
      send = node.send;
      t1 = this.treeElements._types;
      if (t1 != null)
        t1.$index(0, node);
      this.treeElements.toString;
      $constructor = send.get$_secret_tree_element$_element();
      t1 = $constructor != null && $constructor.get$isErroneous();
      t2 = send.selector;
      if (!t1) {
        this.tryMakeConstructorPlaceholder$2(t2, $constructor);
        optionalParameters = $constructor.get$functionSignature().get$optionalParameters();
        for (t1 = send.argumentsNode.nodes, t1.toString, t1 = H.setRuntimeTypeInfo(new E.LinkIterator(null, t1), [H.getTypeArgumentByIndex(t1, 0)]); t1.moveNext$0();) {
          named = t1._util_implementation$_current.asNamedArgument$0();
          if (named == null)
            continue;
          $name = named.name;
          t2 = $name.token;
          nameAsString = t2.get$value(t2);
          optionalParameters.toString;
          t2 = new E.LinkIterator(null, optionalParameters);
          t2.$builtinTypeInfo = [H.getTypeArgumentByIndex(optionalParameters, 0)];
          for (; t2.moveNext$0();) {
            parameter = t2._util_implementation$_current;
            if (parameter.get$isInitializingFormal()) {
              t3 = parameter.get$name(parameter);
              if (t3 == null ? nameAsString == null : t3 === nameAsString) {
                this.tryMakeMemberPlaceholder$1($name);
                break;
              }
            }
          }
        }
      } else
        this.unresolvedNodes.add$1(0, t2);
      t1 = send.argumentsNode;
      if (t1 == null)
        ;
      else
        this.visitNodeList$1(t1);
    },
    visitSend$1: function(send) {
      this.treeElements.toString;
      this.tryMakePrivateIdentifier$2(send.selector, send.get$_secret_tree_element$_element());
      new G.SendVisitor(this, this.compiler, this.treeElements).visitSend$1(send);
      send.visitChildren$1(this);
    },
    visitSendSet$1: function(send) {
      var element, t1, identifier;
      this.treeElements.toString;
      element = send.get$_secret_tree_element$_element();
      if (element != null && element.get$isErroneous()) {
        this.treeElements.toString;
        element = send.selector.get$_secret_tree_element$_element();
      }
      t1 = send.selector;
      this.tryMakePrivateIdentifier$2(t1, element);
      if (element == null) {
        if (send.receiver != null)
          this.tryMakeMemberPlaceholder$1(t1);
      } else if (!element.get$isErroneous())
        if (O.Elements_isStaticOrTopLevel(element))
          this.makeElementPlaceholder$2(t1, element);
        else {
          identifier = t1.asIdentifier$0();
          if (identifier == null)
            identifier = t1.asFunctionExpression$0().name;
          if (O.Elements_isInstanceField(element))
            this.tryMakeMemberPlaceholder$1(identifier);
          else
            this.tryMakeLocalPlaceholder$2(element, identifier);
        }
      send.visitChildren$1(this);
    },
    visitTypeAnnotation$1: function(node) {
      var t1, type, t2;
      t1 = this.treeElements._types;
      type = t1 != null ? t1.$index(0, node) : null;
      t1 = J.getInterceptor$x(type);
      if (t1.get$kind(type) !== C.TypeKind_void)
        if (!type.get$treatAsDynamic()) {
          t2 = node.typeName;
          if (!!t1.$isTypeVariableType)
            this.makeTypeVariablePlaceholder$2(t2, type);
          else
            this.makeTypePlaceholder$2(t2, type);
        } else if (t1.get$kind(type) !== C.TypeKind_dynamic)
          this.unresolvedNodes.add$1(0, node.typeName);
      t1 = node.typeArguments;
      if (t1 == null)
        ;
      else
        this.visitNodeList$1(t1);
    },
    visitVariableDefinitions$1: function(node) {
      var t1, definition, definitionElement, send, t2, identifier, t3;
      for (t1 = node.definitions.nodes, t1.toString, t1 = H.setRuntimeTypeInfo(new E.LinkIterator(null, t1), [H.getTypeArgumentByIndex(t1, 0)]); t1.moveNext$0();) {
        definition = t1._util_implementation$_current;
        this.treeElements.toString;
        definitionElement = definition.get$_secret_tree_element$_element();
        if (definitionElement == null)
          continue;
        send = definition.asSend$0();
        t2 = !!definition.$isIdentifier;
        if (t2)
          identifier = definition;
        else if (!!definition.$isSend) {
          t3 = send.selector;
          t3 = !!J.getInterceptor(t3).$isIdentifier ? t3 : null;
          identifier = t3;
        } else
          identifier = null;
        this.tryMakePrivateIdentifier$2(identifier, definitionElement);
        if (send != null) {
          t2 = send.selector;
          if (!!J.getInterceptor(t2).$isIdentifier)
            if (definitionElement.get$kind(definitionElement) === C.ElementKind_initializing_formal_1)
              this.tryMakeMemberPlaceholder$1(t2);
            else
              this.tryMakeLocalPlaceholder$2(definitionElement, t2);
          else if (definitionElement.get$kind(definitionElement) === C.ElementKind_initializing_formal_1)
            this.tryMakeMemberPlaceholder$1(t2.asFunctionExpression$0().name);
        } else if (t2)
          this.tryMakeLocalPlaceholder$2(definitionElement, definition);
        else if (!!definition.$isFunctionExpression)
          ;
        else
          this.compiler.internalError$2(null, "Unexpected definition structure " + H.S(definition));
      }
      node.visitChildren$1(this);
    },
    visitFunctionExpression$1: function(node) {
      var element, t1, t2;
      this.treeElements.toString;
      element = node.get$_secret_tree_element$_element();
      if (element != null) {
        t1 = node.name;
        this.tryMakePrivateIdentifier$2(t1, element);
        t2 = this.compiler;
        if (element === t2.backend.get$mirrorHelperGetNameFunction())
          t2.backend.registerMirrorHelperElement$2(element, node);
        if (this.topmostEnclosingFunction == null)
          this.topmostEnclosingFunction = element;
        if (element !== this.currentElement)
          if (t1 != null)
            this.tryMakeLocalPlaceholder$2(element, t1);
      }
      node.visitChildren$1(this);
      t1 = node.name;
      if (t1 == null || new G.PlaceholderCollector_visitFunctionExpression_isKeyword().call$1(t1.asIdentifier$0()) !== true)
        this.makeOmitDeclarationTypePlaceholder$1(node.returnType);
      this.collectFunctionParameters$1(node.parameters);
    },
    collectFunctionParameters$1: function(parameters) {
      var t1, t2, parameter;
      if (parameters == null)
        return;
      t1 = parameters.nodes;
      t1.toString;
      t2 = new E.LinkIterator(null, t1);
      t2.$builtinTypeInfo = [H.getTypeArgumentByIndex(t1, 0)];
      for (; t2.moveNext$0();) {
        parameter = t2._util_implementation$_current;
        if (!!J.getInterceptor(parameter).$isNodeList)
          this.collectFunctionParameters$1(parameter);
        else
          this.makeOmitDeclarationTypePlaceholder$1(parameter.asVariableDefinitions$0().type);
      }
    },
    visitClassNode$1: function(node) {
      this.makeElementPlaceholder$2(node.name, this.currentElement);
      node.visitChildren$1(this);
    },
    visitNamedMixinApplication$1: function(node) {
      this.makeElementPlaceholder$2(node.name, this.currentElement);
      node.visitChildren$1(this);
    },
    visitTypeVariable$1: function(node) {
      var t1, type;
      t1 = this.treeElements._types;
      type = t1 != null ? t1.$index(0, node) : null;
      this.makeTypeVariablePlaceholder$2(node.name, type);
      node.visitChildren$1(this);
    },
    visitTypedef$1: function(node) {
      this.makeElementPlaceholder$2(node.name, this.currentElement);
      node.visitChildren$1(this);
      this.makeOmitDeclarationTypePlaceholder$1(node.returnType);
      this.collectFunctionParameters$1(node.formals);
    },
    visitBlock$1: function(node) {
      var t1, t2, statement;
      for (t1 = node.statements, t2 = t1.nodes, t2.toString, t2 = H.setRuntimeTypeInfo(new E.LinkIterator(null, t2), [H.getTypeArgumentByIndex(t2, 0)]); t2.moveNext$0();) {
        statement = t2._util_implementation$_current;
        if (!!J.getInterceptor(statement).$isVariableDefinitions)
          this.makeVarDeclarationTypePlaceholder$1(statement);
      }
      this.visitNodeList$1(t1);
    },
    $asVisitor: function() {
      return [null];
    }
  },
  PlaceholderCollector_currentFunctionScope_closure: {
    "^": "Closure:23;",
    call$0: function() {
      return new G.FunctionScope(P.LinkedHashSet_LinkedHashSet(null, null, null, P.String), P.LinkedHashSet_LinkedHashSet(null, null, null, G.LocalPlaceholder));
    },
    $isFunction: true
  },
  PlaceholderCollector_collect_closure: {
    "^": "Closure:23;this_0,elementNode_1",
    call$0: function() {
      this.elementNode_1.accept$1(0, this.this_0);
    },
    $isFunction: true
  },
  PlaceholderCollector_tryMakeLocalPlaceholder_isNamedOptionalParameter: {
    "^": "Closure:42;element_0",
    call$0: function() {
      var t1, signature, t2;
      t1 = this.element_0;
      signature = t1.get$enclosingElement().get$functionSignature();
      if (!signature.get$optionalParametersAreNamed())
        return false;
      for (t2 = signature.optionalParameters, t2.toString, t2 = H.setRuntimeTypeInfo(new E.LinkIterator(null, t2), [H.getTypeArgumentByIndex(t2, 0)]); t2.moveNext$0();)
        if (t2._util_implementation$_current === t1)
          return true;
      return false;
    },
    $isFunction: true
  },
  PlaceholderCollector_tryMakeMemberPlaceholder_closure: {
    "^": "Closure:23;",
    call$0: function() {
      return P.LinkedHashSet_LinkedHashSet(null, null, null, Y.Identifier);
    },
    $isFunction: true
  },
  PlaceholderCollector_makeElementPlaceholder_closure: {
    "^": "Closure:23;",
    call$0: function() {
      return P.LinkedHashSet_LinkedHashSet(null, null, null, Y.Node);
    },
    $isFunction: true
  },
  PlaceholderCollector_tryMakePrivateIdentifier_closure: {
    "^": "Closure:23;",
    call$0: function() {
      return P.LinkedHashSet_LinkedHashSet(null, null, null, Y.Identifier);
    },
    $isFunction: true
  },
  PlaceholderCollector_makeLocalPlaceholder_getLocalPlaceholder: {
    "^": "Closure:149;this_0,identifier_1",
    call$0: function() {
      var t1, $name;
      t1 = this.identifier_1.token;
      $name = t1.get$value(t1);
      t1 = this.this_0;
      return t1.currentLocalPlaceholders.putIfAbsent$2($name, new G.PlaceholderCollector_makeLocalPlaceholder_getLocalPlaceholder_closure(t1, $name));
    },
    $isFunction: true
  },
  PlaceholderCollector_makeLocalPlaceholder_getLocalPlaceholder_closure: {
    "^": "Closure:23;this_2,name_3",
    call$0: function() {
      var localPlaceholder = new G.LocalPlaceholder(this.name_3, P.LinkedHashSet_LinkedHashSet(null, null, null, Y.Node));
      this.this_2.get$currentFunctionScope().get$localPlaceholders().add$1(0, localPlaceholder);
      return localPlaceholder;
    },
    $isFunction: true
  },
  PlaceholderCollector_visitFunctionExpression_isKeyword: {
    "^": "Closure:150;",
    call$1: function(id) {
      var t1, t2;
      if (id != null) {
        t1 = Y.Keyword_keywords();
        t2 = id.token;
        t2 = t1.$index(0, t2.get$value(t2)) != null;
        t1 = t2;
      } else
        t1 = false;
      return t1;
    },
    $isFunction: true
  },
  _compareNodes_closure: {
    "^": "Closure:13;",
    call$1: function(n) {
      return n.getBeginToken$0().charOffset;
    },
    $isFunction: true
  },
  Renamable: {
    "^": "Object;nodes>",
    compareTo$1: function(_, other) {
      var t1, t2, nodesDiff, typeDiff;
      t1 = J.getInterceptor$x(other);
      t2 = this.nodes;
      nodesDiff = J.compareTo$1$ns(J.get$length$asx(t1.get$nodes(other)), t2.get$length(t2));
      if (nodesDiff !== 0)
        return nodesDiff;
      typeDiff = C.JSInt_methods.compareTo$1(this.get$kind(this), t1.get$kind(other));
      return typeDiff !== 0 ? typeDiff : this.compareInternals$1(other);
    }
  },
  GlobalRenamable: {
    "^": "Renamable;entity<,RENAMABLE_TYPE_ELEMENT,RENAMABLE_TYPE_MEMBER,RENAMABLE_TYPE_LOCAL,nodes",
    compareInternals$1: function(other) {
      return G.compareElements(this.entity, other.get$entity());
    },
    get$kind: function(_) {
      return this.RENAMABLE_TYPE_ELEMENT;
    },
    createNewName$1: function(placeholderRenamer) {
      return placeholderRenamer._renameGlobal$1(this.entity);
    }
  },
  MemberRenamable: {
    "^": "Renamable;identifier<,RENAMABLE_TYPE_ELEMENT,RENAMABLE_TYPE_MEMBER,RENAMABLE_TYPE_LOCAL,nodes",
    compareInternals$1: function(other) {
      return J.compareTo$1$ns(this.identifier, other.get$identifier());
    },
    get$kind: function(_) {
      return this.RENAMABLE_TYPE_MEMBER;
    },
    createNewName$1: function(placeholderRenamer) {
      var t1, t2;
      t1 = placeholderRenamer._generator;
      t2 = placeholderRenamer._forbiddenIdentifiers;
      return t1.generate$2(this.identifier, t2.get$contains(t2));
    }
  },
  LocalRenamable: {
    "^": "Renamable;RENAMABLE_TYPE_ELEMENT,RENAMABLE_TYPE_MEMBER,RENAMABLE_TYPE_LOCAL,nodes",
    compareInternals$1: function(other) {
      var t1, t2, t3;
      t1 = G._compareNodes();
      t2 = G.sorted(this.nodes, G._compareNodes());
      if (0 >= t2.length)
        return H.ioore(t2, 0);
      t2 = t2[0];
      t3 = G.sorted(other.nodes, G._compareNodes());
      if (0 >= t3.length)
        return H.ioore(t3, 0);
      return t1.call$2(t2, t3[0]);
    },
    get$kind: function(_) {
      return this.RENAMABLE_TYPE_LOCAL;
    },
    createNewName$1: function(placeholderRenamer) {
      return placeholderRenamer._generateUniqueTopLevelName$1("");
    }
  },
  PlaceholderRenamer: {
    "^": "Object;renames,platformImports,_compiler,fixedMemberNames,reexportingLibraries,cutDeclarationTypes,_renamedCache,_privateCache,_forbiddenIdentifiers,_allNamedParameterIdentifiers,_generator",
    _renameNodes$2: function(nodes, renamer) {
      var t1, result, t2, node;
      t1 = G._compareNodes();
      result = P.List_List$from(nodes, true, null);
      t2 = result.length - 1;
      if (t2 - 0 <= 32)
        H.Sort__insertionSort(result, 0, t2, t1);
      else
        H.Sort__dualPivotQuicksort(result, 0, t2, t1);
      t1 = new H.ListIterator(result, result.length, 0, null);
      t1.$builtinTypeInfo = [H.getTypeArgumentByIndex(result, 0)];
      t2 = this.renames;
      for (; t1.moveNext$0();) {
        node = t1.__internal$_current;
        t2.$indexSet(0, node, renamer.call$1(node));
      }
    },
    _generateUniqueTopLevelName$1: function(originalName) {
      var newName = this._generator.generate$2(originalName, new G.PlaceholderRenamer__generateUniqueTopLevelName_closure(this));
      this._forbiddenIdentifiers.add$1(0, newName);
      return newName;
    },
    _getPrivateName$2: function(library, originalName) {
      return this._privateCache.putIfAbsent$2(library, new G.PlaceholderRenamer__getPrivateName_closure()).putIfAbsent$2(originalName, new G.PlaceholderRenamer__getPrivateName_closure0(this, originalName));
    },
    _renameConstructor$1: function(placeholder) {
      var t1 = placeholder.element;
      if (t1.get$name(t1) === "")
        return "";
      return this._renameGlobal$1(t1);
    },
    _renameGlobal$1: function(entity) {
      var library, t1;
      if (!!J.getInterceptor(entity).$isElement) {
        library = entity.get$library();
        t1 = this.reexportingLibraries;
        if (t1.containsKey$1(entity))
          library = t1.$index(0, entity);
        t1 = library.canonicalUri;
        if (t1.scheme === "dart") {
          if (library !== this._compiler.coreLibrary)
            this.platformImports.add$1(0, library);
          if (C.JSString_methods.startsWith$1(t1._path, "_"))
            throw H.wrapException(O.SpannableAssertionFailure$(entity, "Internal library " + H.S(library) + " should never have been imported from the code compiled by dart2dart."));
          return entity.name;
        }
      }
      return this._renamedCache.putIfAbsent$2(entity, new G.PlaceholderRenamer__renameGlobal_closure(this, entity));
    },
    _computeMinifiedRenames$1: function(placeholderCollector) {
      var t1, allLocals, t2, t3, result, currentSortedNodes, i, renamables, renamable, newName;
      this._generator = new G.MinifyingGenerator(0);
      t1 = placeholderCollector.functionScopes;
      allLocals = P.List_List$generate(t1.get$values(t1).fold$2(0, 0, new G.PlaceholderRenamer__computeMinifiedRenames_closure()), new G.PlaceholderRenamer__computeMinifiedRenames_closure0(), true, [P.Set, Y.Node]);
      for (t1 = t1.get$values(t1), t1 = H.setRuntimeTypeInfo(new H.MappedIterator(null, J.get$iterator$ax(t1._iterable), t1._f), [H.getTypeArgumentByIndex(t1, 0), H.getTypeArgumentByIndex(t1, 1)]); t1.moveNext$0();) {
        t2 = t1.__internal$_current.get$localPlaceholders();
        t3 = G.compareBy(new G.PlaceholderRenamer__computeMinifiedRenames_closure1());
        result = P.List_List$from(t2, true, null);
        t2 = result.length - 1;
        if (t2 - 0 <= 32)
          H.Sort__insertionSort(result, 0, t2, t3);
        else
          H.Sort__dualPivotQuicksort(result, 0, t2, t3);
        t2 = new H.MappedListIterable(result, new G.PlaceholderRenamer__computeMinifiedRenames_closure2());
        t2.$builtinTypeInfo = [null, null];
        currentSortedNodes = t2.toList$0(0);
        for (i = 0; i < currentSortedNodes.length; ++i) {
          if (i >= allLocals.length)
            return H.ioore(allLocals, i);
          J.addAll$1$ax(allLocals[i], currentSortedNodes[i]);
        }
      }
      renamables = H.setRuntimeTypeInfo([], [G.Renamable]);
      placeholderCollector.elementNodes.forEach$1(0, new G.PlaceholderRenamer__computeMinifiedRenames_closure3(renamables));
      placeholderCollector.memberPlaceholders.forEach$1(0, new G.PlaceholderRenamer__computeMinifiedRenames_closure4(renamables));
      for (t1 = H.setRuntimeTypeInfo(new H.ListIterator(allLocals, allLocals.length, 0, null), [H.getTypeArgumentByIndex(allLocals, 0)]); t1.moveNext$0();)
        renamables.push(new G.LocalRenamable(1, 2, 3, t1.__internal$_current));
      H.IterableMixinWorkaround_sortList(renamables, null);
      for (t1 = H.setRuntimeTypeInfo(new H.ListIterator(renamables, renamables.length, 0, null), [H.getTypeArgumentByIndex(renamables, 0)]); t1.moveNext$0();) {
        renamable = t1.__internal$_current;
        newName = renamable.createNewName$1(this);
        this._renameNodes$2(renamable.nodes, new G.PlaceholderRenamer__computeMinifiedRenames_closure5(newName));
      }
    },
    _computeNonMinifiedRenames$1: function(placeholderCollector) {
      this._generator = new G.ConservativeGenerator();
      placeholderCollector.elementNodes.forEach$1(0, new G.PlaceholderRenamer__computeNonMinifiedRenames_closure(this));
      placeholderCollector.functionScopes.forEach$1(0, new G.PlaceholderRenamer__computeNonMinifiedRenames_closure0(this));
      placeholderCollector.memberPlaceholders.forEach$1(0, new G.PlaceholderRenamer__computeNonMinifiedRenames_closure1(this));
    },
    computeRenames$1: function(placeholderCollector) {
      var t1, functionScope, t2, placeholder, t3;
      this._allNamedParameterIdentifiers = P.LinkedHashSet_LinkedHashSet(null, null, null, P.String);
      for (t1 = placeholderCollector.functionScopes, t1 = t1.get$values(t1), t1 = H.setRuntimeTypeInfo(new H.MappedIterator(null, J.get$iterator$ax(t1._iterable), t1._f), [H.getTypeArgumentByIndex(t1, 0), H.getTypeArgumentByIndex(t1, 1)]); t1.moveNext$0();) {
        functionScope = t1.__internal$_current;
        this._allNamedParameterIdentifiers.addAll$1(0, functionScope.get$parameterIdentifiers());
      }
      t1 = P.LinkedHashSet_LinkedHashSet(null, null, null, P.String);
      t1.addAll$1(0, this.fixedMemberNames);
      this._forbiddenIdentifiers = t1;
      t2 = Y.Keyword_keywords();
      t2.toString;
      t1.addAll$1(0, H.setRuntimeTypeInfo(new P.LinkedHashMapKeyIterable(t2), [H.getTypeArgumentByIndex(t2, 0)]));
      this._forbiddenIdentifiers.add$1(0, "main");
      if (this._compiler.enableMinification)
        this._computeMinifiedRenames$1(placeholderCollector);
      else
        this._computeNonMinifiedRenames$1(placeholderCollector);
      for (t1 = placeholderCollector.constructorPlaceholders, t1 = H.setRuntimeTypeInfo(new H.ListIterator(t1, t1.length, 0, null), [H.getTypeArgumentByIndex(t1, 0)]), t2 = this.renames; t1.moveNext$0();) {
        placeholder = t1.__internal$_current;
        t2.$indexSet(0, placeholder.get$node(), this._renameConstructor$1(placeholder));
      }
      placeholderCollector.privateNodes.forEach$1(0, new G.PlaceholderRenamer_computeRenames_closure(this));
      for (t1 = placeholderCollector.unresolvedNodes, t1 = H.setRuntimeTypeInfo(new P.LinkedHashSetIterator(t1, t1._modifications, null, null), [null]), t1._cell = t1._set._first; t1.moveNext$0();)
        t2.$indexSet(0, t1._collection$_current, this._generateUniqueTopLevelName$1("Unresolved"));
      for (t1 = placeholderCollector.prefixNodesToErase, t1 = H.setRuntimeTypeInfo(new P.LinkedHashSetIterator(t1, t1._modifications, null, null), [null]), t1._cell = t1._set._first; t1.moveNext$0();)
        t2.$indexSet(0, t1._collection$_current, "");
      if (this.cutDeclarationTypes)
        for (t1 = placeholderCollector.declarationTypePlaceholders, t1 = H.setRuntimeTypeInfo(new H.ListIterator(t1, t1.length, 0, null), [H.getTypeArgumentByIndex(t1, 0)]); t1.moveNext$0();) {
          placeholder = t1.__internal$_current;
          t3 = placeholder.get$typeNode();
          t2.$indexSet(0, t3, placeholder.requiresVar ? "var" : "");
        }
    }
  },
  PlaceholderRenamer__generateUniqueTopLevelName_closure: {
    "^": "Closure:13;this_0",
    call$1: function($name) {
      var t1 = this.this_0;
      return t1._forbiddenIdentifiers.contains$1(0, $name) || t1._allNamedParameterIdentifiers.contains$1(0, $name);
    },
    $isFunction: true
  },
  PlaceholderRenamer__getPrivateName_closure: {
    "^": "Closure:23;",
    call$0: function() {
      return P.LinkedHashMap_LinkedHashMap(null, null, null, P.String, P.String);
    },
    $isFunction: true
  },
  PlaceholderRenamer__getPrivateName_closure0: {
    "^": "Closure:23;this_0,originalName_1",
    call$0: function() {
      return this.this_0._generateUniqueTopLevelName$1(this.originalName_1);
    },
    $isFunction: true
  },
  PlaceholderRenamer__renameGlobal_closure: {
    "^": "Closure:23;this_0,entity_1",
    call$0: function() {
      var t1 = this.entity_1;
      return this.this_0._generateUniqueTopLevelName$1(t1.get$name(t1));
    },
    $isFunction: true
  },
  PlaceholderRenamer__computeMinifiedRenames_closure: {
    "^": "Closure:19;",
    call$2: function(a, b) {
      return P.max(a, b.get$localPlaceholders()._collection$_length);
    },
    $isFunction: true
  },
  PlaceholderRenamer__computeMinifiedRenames_closure0: {
    "^": "Closure:13;",
    call$1: function(_) {
      return P.LinkedHashSet_LinkedHashSet(null, null, null, Y.Node);
    },
    $isFunction: true
  },
  PlaceholderRenamer__computeMinifiedRenames_closure1: {
    "^": "Closure:151;",
    call$1: function(ph) {
      return -J.get$nodes$x(ph)._collection$_length;
    },
    $isFunction: true
  },
  PlaceholderRenamer__computeMinifiedRenames_closure2: {
    "^": "Closure:151;",
    call$1: function(ph) {
      return J.get$nodes$x(ph);
    },
    $isFunction: true
  },
  PlaceholderRenamer__computeMinifiedRenames_closure3: {
    "^": "Closure:152;renamables_0",
    call$2: function(element, nodes) {
      this.renamables_0.push(new G.GlobalRenamable(element, 1, 2, 3, nodes));
    },
    $isFunction: true
  },
  PlaceholderRenamer__computeMinifiedRenames_closure4: {
    "^": "Closure:153;renamables_1",
    call$2: function(memberName, identifiers) {
      this.renamables_1.push(new G.MemberRenamable(memberName, 1, 2, 3, identifiers));
    },
    $isFunction: true
  },
  PlaceholderRenamer__computeMinifiedRenames_closure5: {
    "^": "Closure:13;newName_2",
    call$1: function(_) {
      return this.newName_2;
    },
    $isFunction: true
  },
  PlaceholderRenamer__computeNonMinifiedRenames_closure: {
    "^": "Closure:152;this_0",
    call$2: function(element, nodes) {
      var t1 = this.this_0;
      t1._renameNodes$2(nodes, new G.PlaceholderRenamer__computeNonMinifiedRenames__closure3(t1, element));
    },
    $isFunction: true
  },
  PlaceholderRenamer__computeNonMinifiedRenames__closure3: {
    "^": "Closure:13;this_1,element_2",
    call$1: function(_) {
      return this.this_1._renameGlobal$1(this.element_2);
    },
    $isFunction: true
  },
  PlaceholderRenamer__computeNonMinifiedRenames_closure0: {
    "^": "Closure:19;this_3",
    call$2: function(functionElement, functionScope) {
      var memberIdentifiers, placeholders, usedLocalIdentifiers, t1, t2, placeholder, nextId;
      memberIdentifiers = P.LinkedHashSet_LinkedHashSet(null, null, null, P.String);
      placeholders = functionScope.get$localPlaceholders();
      if (functionElement.get$enclosingClass() != null)
        functionElement.get$enclosingClass().forEachMember$1(new G.PlaceholderRenamer__computeNonMinifiedRenames__closure0(memberIdentifiers));
      usedLocalIdentifiers = P.LinkedHashSet_LinkedHashSet(null, null, null, P.String);
      for (t1 = H.setRuntimeTypeInfo(new P.LinkedHashSetIterator(placeholders, placeholders._modifications, null, null), [null]), t1._cell = t1._set._first, t2 = this.this_3; t1.moveNext$0();) {
        placeholder = t1._collection$_current;
        nextId = t2._generator.generate$2(placeholder.get$identifier(), new G.PlaceholderRenamer__computeNonMinifiedRenames__closure1(t2, functionScope, memberIdentifiers, usedLocalIdentifiers));
        usedLocalIdentifiers.add$1(0, nextId);
        t2._renameNodes$2(placeholder.get$nodes(placeholder), new G.PlaceholderRenamer__computeNonMinifiedRenames__closure2(nextId));
      }
    },
    $isFunction: true
  },
  PlaceholderRenamer__computeNonMinifiedRenames__closure0: {
    "^": "Closure:19;memberIdentifiers_4",
    call$2: function(enclosingClass, member) {
      this.memberIdentifiers_4.add$1(0, J.get$name$x(member));
    },
    $isFunction: true
  },
  PlaceholderRenamer__computeNonMinifiedRenames__closure1: {
    "^": "Closure:13;this_5,functionScope_6,memberIdentifiers_7,usedLocalIdentifiers_8",
    call$1: function($name) {
      return this.functionScope_6.parameterIdentifiers.contains$1(0, $name) || this.this_5._forbiddenIdentifiers.contains$1(0, $name) || this.usedLocalIdentifiers_8.contains$1(0, $name) || this.memberIdentifiers_7.contains$1(0, $name);
    },
    $isFunction: true
  },
  PlaceholderRenamer__computeNonMinifiedRenames__closure2: {
    "^": "Closure:13;nextId_9",
    call$1: function(_) {
      return this.nextId_9;
    },
    $isFunction: true
  },
  PlaceholderRenamer__computeNonMinifiedRenames_closure1: {
    "^": "Closure:19;this_10",
    call$2: function(identifier, nodes) {
      var t1, t2, t3;
      t1 = this.this_10;
      t2 = t1._generator;
      t3 = t1._forbiddenIdentifiers;
      t1._renameNodes$2(nodes, new G.PlaceholderRenamer__computeNonMinifiedRenames__closure(t2.generate$2(identifier, t3.get$contains(t3))));
    },
    $isFunction: true
  },
  PlaceholderRenamer__computeNonMinifiedRenames__closure: {
    "^": "Closure:13;newIdentifier_11",
    call$1: function(_) {
      return this.newIdentifier_11;
    },
    $isFunction: true
  },
  PlaceholderRenamer_computeRenames_closure: {
    "^": "Closure:154;this_0",
    call$2: function(library, identifiers) {
      var t1, t2, t3, identifier, t4;
      for (t1 = J.get$iterator$ax(identifiers), t2 = this.this_0, t3 = t2.renames; t1.moveNext$0();) {
        identifier = t1.get$current();
        t4 = identifier.get$token();
        t3.$indexSet(0, identifier, t2._getPrivateName$2(library, t4.get$value(t4)));
      }
    },
    $isFunction: true
  },
  ConservativeGenerator: {
    "^": "Object;",
    generate$2: function(originalName, isForbidden) {
      var result, index, index0;
      for (result = originalName, index = 0; isForbidden.call$1(result) === true; index = index0) {
        index0 = index + 1;
        result = H.S(originalName) + "_" + G.generateMiniId(index);
      }
      return result;
    }
  },
  MinifyingGenerator: {
    "^": "Object;index>",
    generate$2: function(originalName, isForbidden) {
      var result;
      do
        result = G.generateMiniId(this.index++);
      while (isForbidden.call$1(result) === true);
      return result;
    }
  }
}],
["dart_tree_printer", "package:compiler/implementation/dart_backend/backend_ast_to_frontend_ast.dart", , D, {
  "^": "",
  TreePrinter: {
    "^": "Object;treeElements<,openParen,openBrace,openBracket,lt,semicolon,indexToken,question,colon,hash,bang,eq,newToken,constToken,throwToken,rethrowToken,breakToken,continueToken,doToken,whileToken,ifToken,elseToken,forToken,inToken,returnToken,switchToken,caseToken,defaultToken,tryToken,catchToken,onToken,finallyToken,newBackendComment",
    setElement$3: function(node, element, source) {
      if (element == null)
        throw H.wrapException("Missing element from " + source.toString$0(0));
      this.treeElements.$indexSet(0, node, element);
    },
    setType$3: function(node, type, source) {
      if (type == null)
        throw H.wrapException("Missing type from " + source.toString$0(0));
      this.treeElements.setType$2(node, type);
    },
    makeLink$1: function(nodes) {
      var builder, t1;
      builder = H.setRuntimeTypeInfo(new E.LinkBuilderImplementation(null, null, 0), [null]);
      for (t1 = J.get$iterator$ax(nodes); t1.moveNext$0();)
        builder.addLast$1(t1.__internal$_current);
      return builder.toLink$0();
    },
    makeName$1: function($name) {
      var names, node, i, t1, t2, t3;
      if ($name == null)
        return;
      names = C.JSArray_methods.toList$1$growable($name.split("."), false);
      if (0 >= names.length)
        return H.ioore(names, 0);
      node = D.TreePrinter_makeIdentifier(names[0]);
      for (i = 1; i < names.length; ++i) {
        t1 = Y.StringToken_canonicalizedString(names[i], false);
        t2 = $.Node__HASH_COUNTER + 1;
        $.Node__HASH_COUNTER = t2;
        t3 = t2 + 1;
        $.Node__HASH_COUNTER = t3;
        node = new Y.Send(node, new Y.Identifier(new Y.StringToken(t1, C.PrecedenceInfo_identifier_0_97, -1, null), null, t2), null, null, t3);
      }
      return node;
    },
    unopToken$1: function(operatorName) {
      switch (operatorName) {
        case "-":
          return new Y.SymbolToken(C.PrecedenceInfo_06W, -1, null);
        case "~":
          return new Y.SymbolToken(C.PrecedenceInfo_FeL, -1, null);
        case "!":
          return this.bang;
        default:
          throw H.wrapException("Unrecognized unary operator: " + H.S(operatorName));
      }
    },
    makeStaticReceiver$1: function(element) {
      var t1, t2, send;
      if (!!J.getInterceptor(element.get$enclosingElement()).$isClassElement) {
        t1 = element.get$enclosingElement();
        t1 = D.TreePrinter_makeIdentifier(t1.get$name(t1));
        t2 = $.Node__HASH_COUNTER + 1;
        $.Node__HASH_COUNTER = t2;
        send = new Y.Send(null, t1, null, null, t2);
        this.treeElements.$indexSet(0, send, element.get$enclosingElement());
        return send;
      } else
        return;
    },
    makeArgument$1: [function(arg) {
      var t1, t2, t3;
      t1 = J.getInterceptor(arg);
      if (!!t1.$isExpression1)
        return this.makeExp$2(arg, 1);
      else if (!!t1.$isNamedArgument0) {
        t1 = D.TreePrinter_makeIdentifier(arg.name);
        t2 = this.makeExp$2(arg.expression, 1);
        t3 = $.Node__HASH_COUNTER + 1;
        $.Node__HASH_COUNTER = t3;
        return new Y.NamedArgument(t1, t2, this.colon, t3);
      } else
        throw H.wrapException("Unrecognized argument type: " + H.S(arg));
    }, "call$1", "get$makeArgument", 2, 0, 155],
    makeExpression$1: [function(exp) {
      return this.makeExp$2(exp, 1);
    }, "call$1", "get$makeExpression", 2, 0, 156],
    makeExp$3$beginStmt: function(exp, minPrecedence, beginStmt) {
      var t1, result, precedence, needParen, left, receiver, selector, t2, t3, $arguments, element, t4, t5, deltaLeft, t6, callee, send, t7, body, lvalue, innerBeginStmt, argument, op, t0, value, tok, typeArgs, optionalElement, rightOperand, operator;
      t1 = J.getInterceptor(exp);
      if (!!t1.$isSuperReceiver) {
        result = D.TreePrinter_makeIdentifier("super");
        precedence = 21;
        needParen = false;
      } else if (!!t1.$isAssignment0) {
        left = exp.left;
        t1 = !!left.$isIdentifier0;
        if (t1) {
          receiver = this.makeStaticReceiver$1(left.element);
          selector = D.TreePrinter_makeIdentifier(left.name);
          t2 = this.makeLink$1([this.makeExp$2(exp.right, 1)]);
          t3 = $.Node__HASH_COUNTER + 1;
          $.Node__HASH_COUNTER = t3;
          $arguments = new Y.NodeList(t2, null, null, "", t3);
          element = left.element;
        } else {
          if (!!left.$isFieldExpression) {
            receiver = this.makeExp$3$beginStmt(left.object, 20, beginStmt);
            selector = D.TreePrinter_makeIdentifier(left.fieldName);
            t2 = this.makeLink$1([this.makeExp$2(exp.right, 1)]);
            t3 = $.Node__HASH_COUNTER + 1;
            $.Node__HASH_COUNTER = t3;
            $arguments = new Y.NodeList(t2, null, null, "", t3);
          } else if (!!left.$isIndexExpression) {
            receiver = this.makeExp$3$beginStmt(left.object, 20, beginStmt);
            t2 = $.Node__HASH_COUNTER + 1;
            $.Node__HASH_COUNTER = t2;
            selector = new Y.Operator(this.indexToken, null, t2);
            t2 = this.makeExp$2(left.index, 1);
            t3 = this.makeExp$2(exp.right, 1);
            t4 = this.openBracket;
            t5 = t4.endGroup;
            t3 = this.makeLink$1([t2, t3]);
            t2 = $.Node__HASH_COUNTER + 1;
            $.Node__HASH_COUNTER = t2;
            $arguments = new Y.NodeList(t3, t4, t5, ",", t2);
          } else
            throw H.wrapException("Unexpected left-hand side of assignment: " + left.toString$0(0));
          element = null;
        }
        t2 = D.TreePrinter_assignmentToken(exp.operator);
        t3 = $.Node__HASH_COUNTER + 1;
        $.Node__HASH_COUNTER = t3;
        t4 = t3 + 1;
        $.Node__HASH_COUNTER = t4;
        result = new Y.SendSet(new Y.Operator(t2, null, t3), receiver, selector, $arguments, null, t4);
        if (t1)
          this.setElement$3(result, element, exp);
        precedence = 1;
        needParen = false;
      } else if (!!t1.$isBinaryOperator) {
        t1 = exp.operator;
        precedence = C.Map_qwccO.$index(0, t1);
        deltaLeft = precedence !== 6 && precedence !== 7 ? 0 : 1;
        t2 = J.getInterceptor$ns(precedence);
        t3 = this.makeExp$3$beginStmt(exp.left, t2.$add(precedence, deltaLeft), beginStmt);
        t1 = D.TreePrinter_binopToken(t1);
        t4 = $.Node__HASH_COUNTER + 1;
        $.Node__HASH_COUNTER = t4;
        t2 = this.makeLink$1([this.makeExp$2(exp.right, t2.$add(precedence, 1))]);
        t5 = $.Node__HASH_COUNTER + 1;
        $.Node__HASH_COUNTER = t5;
        t6 = t5 + 1;
        $.Node__HASH_COUNTER = t6;
        result = new Y.Send(t3, new Y.Operator(t1, null, t4), new Y.NodeList(t2, null, null, "", t5), null, t6);
        needParen = false;
      } else if (!!t1.$isCallFunction) {
        callee = exp.callee;
        t1 = !!J.getInterceptor(callee).$isIdentifier0;
        if (t1) {
          receiver = this.makeStaticReceiver$1(callee.element);
          selector = D.TreePrinter_makeIdentifier(callee.name);
          element = callee.element;
        } else {
          selector = this.makeExp$3$beginStmt(callee, 21, beginStmt);
          element = null;
          receiver = null;
        }
        t2 = H.setRuntimeTypeInfo(new H.MappedListIterable(exp.arguments, this.get$makeArgument()), [null, null]);
        t3 = this.openParen;
        t4 = t3.endGroup;
        t2 = this.makeLink$1(t2);
        t5 = $.Node__HASH_COUNTER + 1;
        $.Node__HASH_COUNTER = t5;
        t6 = t5 + 1;
        $.Node__HASH_COUNTER = t6;
        result = new Y.Send(receiver, selector, new Y.NodeList(t2, t3, t4, ",", t5), null, t6);
        if (t1)
          this.setElement$3(result, element, exp);
        precedence = 21;
        needParen = false;
      } else if (!!t1.$isCallMethod) {
        t1 = exp.object;
        receiver = !!J.getInterceptor(t1).$isThis0 ? null : this.makeExp$3$beginStmt(t1, 20, beginStmt);
        t1 = D.TreePrinter_makeIdentifier(exp.methodName);
        t2 = H.setRuntimeTypeInfo(new H.MappedListIterable(exp.arguments, this.get$makeArgument()), [null, null]);
        t3 = this.openParen;
        t4 = t3.endGroup;
        t2 = this.makeLink$1(t2);
        t5 = $.Node__HASH_COUNTER + 1;
        $.Node__HASH_COUNTER = t5;
        t6 = t5 + 1;
        $.Node__HASH_COUNTER = t6;
        result = new Y.Send(receiver, t1, new Y.NodeList(t2, t3, t4, ",", t5), null, t6);
        precedence = 21;
        needParen = false;
      } else if (!!t1.$isCallNew) {
        t1 = exp.type;
        selector = this.makeName$1(t1.name);
        t1 = t1.typeArguments;
        if (t1.length > 0) {
          t1 = H.setRuntimeTypeInfo(new H.MappedListIterable(t1, this.get$makeType()), [null, null]);
          t2 = this.lt;
          t3 = t2.endGroup;
          t1 = this.makeLink$1(t1);
          t4 = $.Node__HASH_COUNTER + 1;
          $.Node__HASH_COUNTER = t4;
          t5 = t4 + 1;
          $.Node__HASH_COUNTER = t5;
          selector = new Y.TypeAnnotation(selector, new Y.NodeList(t1, t2, t3, ",", t4), t5);
          this.setType$3(selector, exp.dartType, exp);
        }
        t1 = exp.constructorName;
        if (t1 != null) {
          t1 = D.TreePrinter_makeIdentifier(t1);
          t2 = $.Node__HASH_COUNTER + 1;
          $.Node__HASH_COUNTER = t2;
          selector = new Y.Send(selector, t1, null, null, t2);
        }
        t1 = H.setRuntimeTypeInfo(new H.MappedListIterable(exp.arguments, this.get$makeArgument()), [null, null]);
        t2 = this.openParen;
        t3 = t2.endGroup;
        t1 = this.makeLink$1(t1);
        t4 = $.Node__HASH_COUNTER + 1;
        $.Node__HASH_COUNTER = t4;
        t5 = t4 + 1;
        $.Node__HASH_COUNTER = t5;
        send = new Y.Send(null, selector, new Y.NodeList(t1, t2, t3, ",", t4), null, t5);
        t1 = exp.isConst ? this.constToken : this.newToken;
        ++t5;
        $.Node__HASH_COUNTER = t5;
        result = new Y.NewExpression(t1, send, t5);
        this.setType$3(result, exp.dartType, exp);
        this.setElement$3(send, exp.$constructor, exp);
        precedence = 21;
        needParen = false;
      } else if (!!t1.$isCallStatic) {
        t1 = this.makeStaticReceiver$1(exp.element);
        t2 = D.TreePrinter_makeIdentifier(exp.methodName);
        t3 = H.setRuntimeTypeInfo(new H.MappedListIterable(exp.arguments, this.get$makeArgument()), [null, null]);
        t4 = this.openParen;
        t5 = t4.endGroup;
        t3 = this.makeLink$1(t3);
        t6 = $.Node__HASH_COUNTER + 1;
        $.Node__HASH_COUNTER = t6;
        t7 = t6 + 1;
        $.Node__HASH_COUNTER = t7;
        result = new Y.Send(t1, t2, new Y.NodeList(t3, t4, t5, ",", t6), null, t7);
        this.setElement$3(result, exp.element, exp);
        precedence = 21;
        needParen = false;
      } else if (!!t1.$isConditional1) {
        t1 = this.makeExp$3$beginStmt(exp.condition, 3, beginStmt);
        t2 = this.makeExp$2(exp.thenExpression, 1);
        t3 = this.makeExp$2(exp.elseExpression, 1);
        t4 = $.Node__HASH_COUNTER + 1;
        $.Node__HASH_COUNTER = t4;
        result = new Y.Conditional0(t1, t2, t3, this.question, this.colon, t4);
        precedence = 2;
        needParen = false;
      } else if (!!t1.$isFieldExpression) {
        t1 = exp.object;
        receiver = !!J.getInterceptor(t1).$isThis0 ? null : this.makeExp$3$beginStmt(t1, 20, beginStmt);
        t1 = D.TreePrinter_makeIdentifier(exp.fieldName);
        t2 = $.Node__HASH_COUNTER + 1;
        $.Node__HASH_COUNTER = t2;
        result = new Y.Send(receiver, t1, null, null, t2);
        precedence = 20;
        needParen = false;
      } else if (!!t1.$isFunctionExpression0) {
        needParen = beginStmt && exp.name != null && true;
        t1 = exp.element;
        if (t1 != null) {
          t1 = t1.get$node();
          t1 = !!J.getInterceptor(t1.get$body(t1)).$isEmptyStatement0;
        } else
          t1 = false;
        if (t1) {
          t1 = exp.element.get$node();
          body = t1.get$body(t1);
        } else
          body = this.makeFunctionBody$1(exp.body);
        t1 = this.functionName$1(exp);
        t2 = this.makeParameters$1(exp.parameters);
        t3 = exp.returnType;
        if (t3 != null) {
          t4 = exp.element;
          t4 = t4.kind === C.ElementKind_generative_constructor_16 || t4.get$isFactoryConstructor();
        } else
          t4 = true;
        t3 = t4 ? null : this.makeType$1(t3);
        t4 = this.makeFunctionModifiers$1(exp);
        t5 = $.Node__HASH_COUNTER + 1;
        $.Node__HASH_COUNTER = t5;
        result = new Y.FunctionExpression(t1, t2, body, t3, t4, null, null, null, t5);
        this.setElement$3(result, exp.element, exp);
        precedence = 20;
      } else if (!!t1.$isIdentifier0) {
        t1 = this.makeStaticReceiver$1(exp.element);
        t2 = D.TreePrinter_makeIdentifier(exp.name);
        t3 = $.Node__HASH_COUNTER + 1;
        $.Node__HASH_COUNTER = t3;
        result = new Y.Send(t1, t2, null, null, t3);
        this.setElement$3(result, exp.element, exp);
        precedence = 21;
        needParen = false;
      } else if (!!t1.$isIncrement) {
        lvalue = exp.expression;
        innerBeginStmt = beginStmt && !exp.isPrefix;
        t1 = !!lvalue.$isIdentifier0;
        if (t1) {
          receiver = this.makeStaticReceiver$1(lvalue.element);
          selector = D.TreePrinter_makeIdentifier(lvalue.name);
          argument = null;
        } else if (!!lvalue.$isFieldExpression) {
          receiver = this.makeExp$3$beginStmt(lvalue.object, 20, innerBeginStmt);
          selector = D.TreePrinter_makeIdentifier(lvalue.fieldName);
          argument = null;
        } else if (!!lvalue.$isIndexExpression) {
          receiver = this.makeExp$3$beginStmt(lvalue.object, 20, innerBeginStmt);
          t2 = $.Node__HASH_COUNTER + 1;
          $.Node__HASH_COUNTER = t2;
          selector = new Y.Operator(this.indexToken, null, t2);
          argument = this.makeExp$2(lvalue.index, 1);
        } else
          throw H.wrapException("Unrecognized left-hand side: " + lvalue.toString$0(0));
        t2 = D.TreePrinter_incrementToken(exp.operator);
        t3 = $.Node__HASH_COUNTER + 1;
        $.Node__HASH_COUNTER = t3;
        op = new Y.Operator(t2, null, t3);
        if (exp.isPrefix) {
          if (argument == null) {
            t2 = t3 + 1;
            $.Node__HASH_COUNTER = t2;
            t3 = new Y.Prefix0(C.C_Link3, null, null, null, t2);
            t0 = t3;
            t3 = t2;
            t2 = t0;
          } else {
            t2 = E.LinkEntry$(argument, C.C_Link3, H.getTypeArgumentByIndex(C.C_Link3, 0));
            ++t3;
            $.Node__HASH_COUNTER = t3;
            t2 = new Y.Prefix0(t2, null, null, null, t3);
          }
          ++t3;
          $.Node__HASH_COUNTER = t3;
          result = new Y.SendSet(op, receiver, selector, t2, null, t3);
          precedence = 14;
        } else {
          if (argument == null) {
            t2 = t3 + 1;
            $.Node__HASH_COUNTER = t2;
            t3 = new Y.Postfix0(C.C_Link3, null, null, null, t2);
            t0 = t3;
            t3 = t2;
            t2 = t0;
          } else {
            t2 = E.LinkEntry$(argument, C.C_Link3, H.getTypeArgumentByIndex(C.C_Link3, 0));
            ++t3;
            $.Node__HASH_COUNTER = t3;
            t2 = new Y.Postfix0(t2, null, null, null, t3);
          }
          ++t3;
          $.Node__HASH_COUNTER = t3;
          result = new Y.SendSet(op, receiver, selector, t2, null, t3);
          precedence = 15;
        }
        if (t1)
          this.setElement$3(result, lvalue.element, exp);
        needParen = false;
      } else if (!!t1.$isIndexExpression) {
        t1 = this.makeExp$3$beginStmt(exp.object, 20, beginStmt);
        t2 = $.Node__HASH_COUNTER + 1;
        $.Node__HASH_COUNTER = t2;
        t3 = this.makeExp$2(exp.index, 1);
        t4 = this.openBracket;
        t5 = t4.endGroup;
        t3 = this.makeLink$1([t3]);
        t6 = $.Node__HASH_COUNTER + 1;
        $.Node__HASH_COUNTER = t6;
        t7 = t6 + 1;
        $.Node__HASH_COUNTER = t7;
        result = new Y.Send(t1, new Y.Operator(this.indexToken, null, t2), new Y.NodeList(t3, t4, t5, ",", t6), null, t7);
        precedence = 21;
        needParen = false;
      } else if (!!t1.$isLiteral0) {
        value = exp.value;
        tok = new Y.StringToken(Y.StringToken_canonicalizedString(H.S(value.get$value(value)), false), C.PrecedenceInfo_string_0_39, -1, null);
        if (!!value.$isStringConstant) {
          result = this.unparseStringLiteral$1(exp);
          precedence = 21;
        } else if (!!value.$isIntConstant) {
          t1 = $.Node__HASH_COUNTER + 1;
          $.Node__HASH_COUNTER = t1;
          result = new Y.LiteralInt(tok, null, t1);
          precedence = 21;
        } else if (!!value.$isDoubleConstant) {
          t1 = value.value;
          if (t1 === 1 / 0) {
            tok = new Y.StringToken(Y.StringToken_canonicalizedString("1/0.0", false), C.PrecedenceInfo_string_0_39, -1, null);
            precedence = 13;
          } else if (t1 === -1 / 0) {
            tok = new Y.StringToken(Y.StringToken_canonicalizedString("-1/0.0", false), C.PrecedenceInfo_string_0_39, -1, null);
            precedence = 13;
          } else if (isNaN(t1)) {
            tok = new Y.StringToken(Y.StringToken_canonicalizedString("0/0.0", false), C.PrecedenceInfo_string_0_39, -1, null);
            precedence = 13;
          } else
            precedence = 21;
          t1 = $.Node__HASH_COUNTER + 1;
          $.Node__HASH_COUNTER = t1;
          result = new Y.LiteralDouble(tok, null, t1);
        } else {
          if (!!value.$isBoolConstant) {
            t1 = $.Node__HASH_COUNTER + 1;
            $.Node__HASH_COUNTER = t1;
            result = new Y.LiteralBool0(tok, null, t1);
          } else if (!!value.$isNullConstant) {
            t1 = $.Node__HASH_COUNTER + 1;
            $.Node__HASH_COUNTER = t1;
            result = new Y.LiteralNull0(tok, null, t1);
          } else
            throw H.wrapException("Unrecognized constant: " + value.toString$0(0));
          precedence = 21;
        }
        needParen = false;
      } else if (!!t1.$isLiteralList0) {
        t1 = exp.typeArgument;
        if (t1 != null) {
          t1 = this.makeType$1(t1);
          t2 = this.lt;
          t3 = t2.endGroup;
          t1 = this.makeLink$1([t1]);
          t4 = $.Node__HASH_COUNTER + 1;
          $.Node__HASH_COUNTER = t4;
          typeArgs = new Y.NodeList(t1, t2, t3, ",", t4);
        } else
          typeArgs = null;
        t1 = H.setRuntimeTypeInfo(new H.MappedListIterable(exp.values, this.get$makeExpression()), [null, null]);
        t2 = this.openBracket;
        t3 = t2.endGroup;
        t1 = this.makeLink$1(t1);
        t4 = $.Node__HASH_COUNTER + 1;
        $.Node__HASH_COUNTER = t4;
        t5 = exp.isConst ? this.constToken : null;
        t6 = t4 + 1;
        $.Node__HASH_COUNTER = t6;
        result = new Y.LiteralList(typeArgs, new Y.NodeList(t1, t2, t3, ",", t4), t5, t6);
        precedence = 20;
        needParen = false;
      } else if (!!t1.$isLiteralMap0) {
        needParen = beginStmt && true;
        t1 = exp.typeArguments;
        if (t1 != null && t1.length > 0) {
          t2 = this.get$makeType();
          t1.toString;
          t2 = H.setRuntimeTypeInfo(new H.MappedListIterable(t1, t2), [null, null]);
          t1 = this.lt;
          t3 = t1.endGroup;
          t2 = this.makeLink$1(t2);
          t4 = $.Node__HASH_COUNTER + 1;
          $.Node__HASH_COUNTER = t4;
          typeArgs = new Y.NodeList(t2, t1, t3, ",", t4);
        } else
          typeArgs = null;
        t1 = H.setRuntimeTypeInfo(new H.MappedListIterable(exp.entries, this.get$makeLiteralMapEntry()), [null, null]);
        t2 = this.openBrace;
        t3 = t2.endGroup;
        t1 = this.makeLink$1(t1);
        t4 = $.Node__HASH_COUNTER + 1;
        $.Node__HASH_COUNTER = t4;
        t5 = exp.isConst ? this.constToken : null;
        t6 = t4 + 1;
        $.Node__HASH_COUNTER = t6;
        result = new Y.LiteralMap(typeArgs, new Y.NodeList(t1, t2, t3, ",", t4), t5, t6);
        precedence = 20;
      } else {
        if (!!t1.$isLiteralSymbol0) {
          t1 = this.makeLink$1(H.setRuntimeTypeInfo(new H.MappedListIterable(exp.id.split("."), D.TreePrinter_makeIdentifier$closure()), [null, null]));
          t2 = $.Node__HASH_COUNTER + 1;
          $.Node__HASH_COUNTER = t2;
          t3 = t2 + 1;
          $.Node__HASH_COUNTER = t3;
          result = new Y.LiteralSymbol(this.hash, new Y.NodeList(t1, null, null, ".", t2), t3);
          precedence = 20;
        } else if (!!t1.$isLiteralType) {
          optionalElement = exp.type.get$element();
          t1 = optionalElement == null;
          t2 = t1 ? null : this.makeStaticReceiver$1(optionalElement);
          t3 = D.TreePrinter_makeIdentifier(exp.name);
          t4 = $.Node__HASH_COUNTER + 1;
          $.Node__HASH_COUNTER = t4;
          result = new Y.Send(t2, t3, null, null, t4);
          this.treeElements.setType$2(result, exp.type);
          if (!t1)
            this.setElement$3(result, optionalElement, exp);
          precedence = 19;
        } else if (!!t1.$isReifyTypeVar) {
          t1 = D.TreePrinter_makeIdentifier(exp.name);
          t2 = $.Node__HASH_COUNTER + 1;
          $.Node__HASH_COUNTER = t2;
          result = new Y.Send(null, t1, null, null, t2);
          this.setElement$3(result, exp.element, exp);
          t2 = exp.element;
          this.setType$3(result, t2.get$type(t2), exp);
          precedence = 20;
        } else if (!!t1.$isStringConcat) {
          result = this.unparseStringLiteral$1(exp);
          precedence = 20;
        } else if (!!t1.$isThis0) {
          result = D.TreePrinter_makeIdentifier("this");
          precedence = 21;
        } else if (!!t1.$isTypeOperator) {
          rightOperand = this.makeType$1(exp.type);
          t1 = exp.operator;
          if (t1 === "is!") {
            t1 = D.TreePrinter_typeOpToken("is");
            t2 = $.Node__HASH_COUNTER + 1;
            $.Node__HASH_COUNTER = t2;
            operator = new Y.Operator(t1, null, t2);
            ++t2;
            $.Node__HASH_COUNTER = t2;
            t1 = this.makeLink$1([]);
            t3 = $.Node__HASH_COUNTER + 1;
            $.Node__HASH_COUNTER = t3;
            t4 = t3 + 1;
            $.Node__HASH_COUNTER = t4;
            rightOperand = new Y.Send(rightOperand, new Y.Operator(this.bang, null, t2), new Y.NodeList(t1, null, null, "", t3), null, t4);
          } else {
            t1 = D.TreePrinter_typeOpToken(t1);
            t2 = $.Node__HASH_COUNTER + 1;
            $.Node__HASH_COUNTER = t2;
            operator = new Y.Operator(t1, null, t2);
          }
          t1 = this.makeExp$3$beginStmt(exp.expression, 8, beginStmt);
          t2 = this.makeLink$1([rightOperand]);
          t3 = $.Node__HASH_COUNTER + 1;
          $.Node__HASH_COUNTER = t3;
          t4 = t3 + 1;
          $.Node__HASH_COUNTER = t4;
          result = new Y.Send(t1, operator, new Y.NodeList(t2, null, null, "", t3), null, t4);
          precedence = 7;
        } else {
          if (!!t1.$isUnaryOperator) {
            t1 = this.makeExp$2(exp.operand, 14);
            t2 = this.unopToken$1(exp.operatorName);
            t3 = $.Node__HASH_COUNTER + 1;
            $.Node__HASH_COUNTER = t3;
            t4 = t3 + 1;
            $.Node__HASH_COUNTER = t4;
            t5 = new Y.Prefix0(C.C_Link3, null, null, null, t4);
            t0 = t5;
            t5 = t4;
            t4 = t0;
            ++t5;
            $.Node__HASH_COUNTER = t5;
            result = new Y.Send(t1, new Y.Operator(t2, null, t3), t4, null, t5);
          } else
            throw H.wrapException("Unknown expression type: " + t1.toString$0(exp));
          precedence = 14;
        }
        needParen = false;
      }
      if (needParen || J.$lt$n(precedence, minPrecedence)) {
        t1 = $.Node__HASH_COUNTER + 1;
        $.Node__HASH_COUNTER = t1;
        result = new Y.ParenthesizedExpression(result, this.openParen, t1);
      }
      return result;
    },
    makeExp$2: function(exp, minPrecedence) {
      return this.makeExp$3$beginStmt(exp, minPrecedence, false);
    },
    makeVerbatimStringLiteral$1: function(verbatim) {
      var t1, t2;
      t1 = Y.StringToken_canonicalizedString(verbatim, false);
      t2 = $.Node__HASH_COUNTER + 1;
      $.Node__HASH_COUNTER = t2;
      return new Y.LiteralString(new Y.StringToken(t1, C.PrecedenceInfo_string_0_39, -1, null), null, t2);
    },
    makeLiteralMapEntry$1: [function(en) {
      var t1, t2, t3;
      t1 = J.getInterceptor$x(en);
      t2 = this.makeExp$2(t1.get$key(en), 1);
      t1 = this.makeExp$2(t1.get$value(en), 1);
      t3 = $.Node__HASH_COUNTER + 1;
      $.Node__HASH_COUNTER = t3;
      return new Y.LiteralMapEntry(t2, t1, this.colon, t3);
    }, "call$1", "get$makeLiteralMapEntry", 2, 0, 157],
    makeFunctionBody$1: function(stmt) {
      var t1, t2, t3;
      t1 = this.makeLink$1([this.makeBlock$1(stmt)]);
      t2 = $.Node__HASH_COUNTER + 1;
      $.Node__HASH_COUNTER = t2;
      t3 = t2 + 1;
      $.Node__HASH_COUNTER = t3;
      return new Y.Block0(new Y.NodeList(t1, this.newBackendComment, null, "", t2), t3);
    },
    makeBlock$1: function(stmt) {
      return this.makeStatement$1(stmt);
    },
    addBlockMember$2: function(stmt, accumulator) {
      var t1, t2;
      if (!!J.getInterceptor(stmt).$isBlock1 && !H.IterableMixinWorkaround_any(stmt.statements, F.Unparser_definesVariable$closure())) {
        t1 = stmt.get$statements();
        t2 = new H.ListIterator(t1, t1.length, 0, null);
        t2.$builtinTypeInfo = [H.getTypeArgumentByIndex(t1, 0)];
        for (; t2.moveNext$0();)
          this.addBlockMember$2(t2.__internal$_current, accumulator);
      } else
        accumulator.push(this.makeStatement$1(stmt));
    },
    isEmptyStatement$1: [function(stmt) {
      var t1 = !!J.getInterceptor(stmt).$isBlock1 && H.IterableMixinWorkaround_every(stmt.statements, this.get$isEmptyStatement());
      return t1;
    }, "call$1", "get$isEmptyStatement", 2, 0, 4],
    makeStatement$2$shortIf: function(stmt, shortIf) {
      var t1, body, t2, t3, t4, t5, t6, t7, t8, t9, t10, $function, node, labels, inner;
      t1 = J.getInterceptor(stmt);
      if (!!t1.$isBlock1) {
        body = H.setRuntimeTypeInfo([], [Y.Node]);
        for (t1 = stmt.statements, t1 = H.setRuntimeTypeInfo(new H.ListIterator(t1, t1.length, 0, null), [H.getTypeArgumentByIndex(t1, 0)]); t1.moveNext$0();)
          this.addBlockMember$2(t1.__internal$_current, body);
        t1 = this.openBrace;
        t2 = t1.endGroup;
        t3 = this.makeLink$1(body);
        t4 = $.Node__HASH_COUNTER + 1;
        $.Node__HASH_COUNTER = t4;
        t5 = t4 + 1;
        $.Node__HASH_COUNTER = t5;
        return new Y.Block0(new Y.NodeList(t3, t1, t2, "", t4), t5);
      } else if (!!t1.$isBreak0) {
        t1 = stmt.label;
        t1 = t1 == null ? null : D.TreePrinter_makeIdentifier(t1);
        t2 = $.Node__HASH_COUNTER + 1;
        $.Node__HASH_COUNTER = t2;
        return new Y.BreakStatement(t1, this.breakToken, this.semicolon, t2);
      } else if (!!t1.$isContinue0) {
        t1 = stmt.label;
        t1 = t1 == null ? null : D.TreePrinter_makeIdentifier(t1);
        t2 = $.Node__HASH_COUNTER + 1;
        $.Node__HASH_COUNTER = t2;
        return new Y.ContinueStatement(t1, this.continueToken, this.semicolon, t2);
      } else if (!!t1.$isExpressionStatement1) {
        t1 = this.makeExp$3$beginStmt(stmt.expression, 1, true);
        t2 = $.Node__HASH_COUNTER + 1;
        $.Node__HASH_COUNTER = t2;
        return new Y.ExpressionStatement0(t1, this.semicolon, t2);
      } else if (!!t1.$isFunctionDeclaration1) {
        t1 = stmt.$function;
        t2 = t1.name;
        t2 = t2 != null ? D.TreePrinter_makeIdentifier(t2) : null;
        t3 = this.makeParameters$1(t1.parameters);
        t4 = this.makeFunctionBody$1(t1.body);
        t5 = t1.returnType;
        t5 = t5 != null ? this.makeType$1(t5) : null;
        t6 = this.makeLink$1([]);
        t7 = $.Node__HASH_COUNTER + 1;
        $.Node__HASH_COUNTER = t7;
        t8 = Y.Modifiers_computeFlags(t6);
        t9 = $.Node__HASH_COUNTER + 1;
        $.Node__HASH_COUNTER = t9;
        t10 = t9 + 1;
        $.Node__HASH_COUNTER = t10;
        $function = new Y.FunctionExpression(t2, t3, t4, t5, new Y.Modifiers(new Y.NodeList(t6, null, null, "", t7), t8, t9), null, null, null, t10);
        this.setElement$3($function, t1.element, stmt);
        t1 = $.Node__HASH_COUNTER + 1;
        $.Node__HASH_COUNTER = t1;
        return new Y.FunctionDeclaration0($function, t1);
      } else if (!!t1.$isIf1) {
        t1 = stmt.elseStatement;
        t2 = this.isEmptyStatement$1(t1);
        t3 = stmt.condition;
        t4 = stmt.thenStatement;
        if (t2) {
          t1 = this.makeExp$2(t3, 1);
          t2 = $.Node__HASH_COUNTER + 1;
          $.Node__HASH_COUNTER = t2;
          t4 = this.makeStatement$1(t4);
          t3 = $.Node__HASH_COUNTER + 1;
          $.Node__HASH_COUNTER = t3;
          node = new Y.If0(new Y.ParenthesizedExpression(t1, this.openParen, t2), t4, null, this.ifToken, null, t3);
          if (shortIf === true)
            return node;
          else {
            t1 = this.openBrace;
            t2 = t1.endGroup;
            t3 = this.makeLink$1([node]);
            t4 = $.Node__HASH_COUNTER + 1;
            $.Node__HASH_COUNTER = t4;
            t5 = t4 + 1;
            $.Node__HASH_COUNTER = t5;
            return new Y.Block0(new Y.NodeList(t3, t1, t2, "", t4), t5);
          }
        } else {
          t2 = this.makeExp$2(t3, 1);
          t3 = $.Node__HASH_COUNTER + 1;
          $.Node__HASH_COUNTER = t3;
          t4 = this.makeStatement$2$shortIf(t4, false);
          t1 = this.makeStatement$2$shortIf(t1, shortIf);
          t5 = $.Node__HASH_COUNTER + 1;
          $.Node__HASH_COUNTER = t5;
          return new Y.If0(new Y.ParenthesizedExpression(t2, this.openParen, t3), t4, t1, this.ifToken, this.elseToken, t5);
        }
      } else if (!!t1.$isLabeledStatement0) {
        labels = [];
        for (t1 = this.colon, inner = stmt; !!inner.$isLabeledStatement0;) {
          H.interceptedTypeCast(inner, "$isLabeledStatement0");
          t2 = Y.StringToken_canonicalizedString(inner.label, false);
          t3 = $.Node__HASH_COUNTER + 1;
          $.Node__HASH_COUNTER = t3;
          t4 = t3 + 1;
          $.Node__HASH_COUNTER = t4;
          labels.push(new Y.Label(new Y.Identifier(new Y.StringToken(t2, C.PrecedenceInfo_identifier_0_97, -1, null), null, t3), t1, t4));
          inner = inner.statement;
        }
        t1 = this.makeLink$1(labels);
        t2 = $.Node__HASH_COUNTER + 1;
        $.Node__HASH_COUNTER = t2;
        t3 = this.makeStatement$2$shortIf(inner, shortIf);
        t4 = $.Node__HASH_COUNTER + 1;
        $.Node__HASH_COUNTER = t4;
        return new Y.LabeledStatement(new Y.NodeList(t1, null, null, "", t2), t3, t4);
      } else if (!!t1.$isReturn1) {
        t1 = stmt.expression;
        t1 = t1 == null ? null : this.makeExp$2(t1, 1);
        t2 = $.Node__HASH_COUNTER + 1;
        $.Node__HASH_COUNTER = t2;
        return new Y.Return0(t1, this.returnToken, this.semicolon, t2);
      } else if (!!t1.$isVariableDeclarations)
        return this.makeVariableDeclarations$3$endToken$useVar(stmt, this.semicolon, true);
      else if (!!t1.$isWhile0) {
        t1 = this.makeExp$2(stmt.condition, 1);
        t2 = $.Node__HASH_COUNTER + 1;
        $.Node__HASH_COUNTER = t2;
        t3 = this.makeStatement$2$shortIf(stmt.body, shortIf);
        t4 = $.Node__HASH_COUNTER + 1;
        $.Node__HASH_COUNTER = t4;
        return new Y.While(this.whileToken, new Y.ParenthesizedExpression(t1, this.openParen, t2), t3, t4);
      } else
        throw H.wrapException("Unrecognized statement: " + t1.toString$0(stmt));
    },
    makeStatement$1: function(stmt) {
      return this.makeStatement$2$shortIf(stmt, true);
    },
    makeVariableDeclaration$1: [function(vd) {
      var id, t1, t2, t3, t4, send;
      id = D.TreePrinter_makeIdentifier(J.get$name$x(vd));
      this.setElement$3(id, vd.get$element(), vd);
      if (vd.get$initializer() == null)
        return id;
      t1 = $.Node__HASH_COUNTER + 1;
      $.Node__HASH_COUNTER = t1;
      t2 = this.makeLink$1([this.makeExp$2(vd.get$initializer(), 1)]);
      t3 = $.Node__HASH_COUNTER + 1;
      $.Node__HASH_COUNTER = t3;
      t4 = t3 + 1;
      $.Node__HASH_COUNTER = t4;
      send = new Y.SendSet(new Y.Operator(this.eq, null, t1), null, id, new Y.NodeList(t2, null, null, "", t3), null, t4);
      this.setElement$3(send, vd.get$element(), vd);
      return send;
    }, "call$1", "get$makeVariableDeclaration", 2, 0, 158],
    makeVariableDeclarations$3$endToken$useVar: function(decl, endToken, useVar) {
      var t1, nodes, t2, t3, t4, t5, t6, t7;
      t1 = useVar && true;
      nodes = [];
      if (decl.isConst)
        nodes.push(D.TreePrinter_makeIdentifier("const"));
      if (decl.isFinal)
        nodes.push(D.TreePrinter_makeIdentifier("final"));
      if (t1 && nodes.length === 0)
        nodes.push(D.TreePrinter_makeIdentifier("var"));
      t1 = this.makeLink$1(nodes);
      t2 = $.Node__HASH_COUNTER + 1;
      $.Node__HASH_COUNTER = t2;
      t3 = Y.Modifiers_computeFlags(t1);
      t4 = $.Node__HASH_COUNTER + 1;
      $.Node__HASH_COUNTER = t4;
      t5 = this.makeLink$1(H.setRuntimeTypeInfo(new H.MappedListIterable(decl.declarations, this.get$makeVariableDeclaration()), [null, null]));
      t6 = $.Node__HASH_COUNTER + 1;
      $.Node__HASH_COUNTER = t6;
      t7 = t6 + 1;
      $.Node__HASH_COUNTER = t7;
      return new Y.VariableDefinitions(null, null, new Y.Modifiers(new Y.NodeList(t1, null, null, "", t2), t3, t4), new Y.NodeList(t5, null, endToken, ",", t6), t7);
    },
    makeType$1: [function(type) {
      var t1, t2, t3, t4, typeArgs, result;
      if (type.get$typeArguments().length > 0) {
        t1 = H.setRuntimeTypeInfo(new H.MappedListIterable(type.get$typeArguments(), this.get$makeType()), [null, null]);
        t2 = this.lt;
        t3 = t2.endGroup;
        t1 = this.makeLink$1(t1);
        t4 = $.Node__HASH_COUNTER + 1;
        $.Node__HASH_COUNTER = t4;
        typeArgs = new Y.NodeList(t1, t2, t3, ",", t4);
      } else
        typeArgs = null;
      t1 = D.TreePrinter_makeIdentifier(J.get$name$x(type));
      t2 = $.Node__HASH_COUNTER + 1;
      $.Node__HASH_COUNTER = t2;
      result = new Y.TypeAnnotation(t1, typeArgs, t2);
      this.setType$3(result, type.get$dartType(), type);
      return result;
    }, "call$1", "get$makeType", 2, 0, 159],
    makeParameters$1: function(params) {
      var nodes, t1, t2, assign, $open, $close, t3, t4;
      nodes = H.setRuntimeTypeInfo(new H.MappedListIterable(params.requiredParameters, this.get$makeParameter()), [null, null]).toList$0(0);
      t1 = params.optionalParameters;
      if (t1.length > 0) {
        t2 = params.hasNamedParameters;
        assign = t2 ? this.colon : this.eq;
        $open = t2 ? this.openBrace : this.openBracket;
        $close = t2 ? this.openBrace.endGroup : this.openBracket.endGroup;
        t1 = this.makeLink$1(H.setRuntimeTypeInfo(new H.MappedListIterable(t1, new D.TreePrinter_makeParameters_closure(this, assign)), [null, null]));
        t2 = $.Node__HASH_COUNTER + 1;
        $.Node__HASH_COUNTER = t2;
        C.JSArray_methods.add$1(nodes, new Y.NodeList(t1, $open, $close, ",", t2));
      }
      t1 = this.openParen;
      t2 = t1.endGroup;
      t3 = this.makeLink$1(nodes);
      t4 = $.Node__HASH_COUNTER + 1;
      $.Node__HASH_COUNTER = t4;
      return new Y.NodeList(t3, t1, t2, ",", t4);
    },
    makeParameter$2: [function(param, assignOperator) {
      var t1, t2, t3, t4, t5, t6, t7, t8, t9, definition;
      if (param.get$parameters() != null) {
        t1 = J.getInterceptor$x(param);
        t2 = D.TreePrinter_makeIdentifier(t1.get$name(param));
        t3 = this.makeParameters$1(param.get$parameters());
        t4 = t1.get$type(param) == null ? null : this.makeType$1(t1.get$type(param));
        t5 = this.makeLink$1([]);
        t6 = $.Node__HASH_COUNTER + 1;
        $.Node__HASH_COUNTER = t6;
        t7 = Y.Modifiers_computeFlags(t5);
        t8 = $.Node__HASH_COUNTER + 1;
        $.Node__HASH_COUNTER = t8;
        t9 = t8 + 1;
        $.Node__HASH_COUNTER = t9;
        definition = new Y.FunctionExpression(t2, t3, null, t4, new Y.Modifiers(new Y.NodeList(t5, null, null, "", t6), t7, t8), null, null, null, t9);
        this.setElement$3(definition, param.get$element(), param);
        if (t1.get$defaultValue(param) != null) {
          t2 = $.Node__HASH_COUNTER + 1;
          $.Node__HASH_COUNTER = t2;
          t1 = this.makeLink$1([this.makeExp$2(t1.get$defaultValue(param), 1)]);
          t3 = $.Node__HASH_COUNTER + 1;
          $.Node__HASH_COUNTER = t3;
          t4 = t3 + 1;
          $.Node__HASH_COUNTER = t4;
          return new Y.SendSet(new Y.Operator(assignOperator, null, t2), null, definition, new Y.NodeList(t1, null, null, "", t3), null, t4);
        } else {
          t1 = this.makeLink$1([]);
          t2 = $.Node__HASH_COUNTER + 1;
          $.Node__HASH_COUNTER = t2;
          t3 = Y.Modifiers_computeFlags(t1);
          t4 = $.Node__HASH_COUNTER + 1;
          $.Node__HASH_COUNTER = t4;
          t5 = this.makeLink$1([definition]);
          t6 = $.Node__HASH_COUNTER + 1;
          $.Node__HASH_COUNTER = t6;
          t7 = t6 + 1;
          $.Node__HASH_COUNTER = t7;
          return new Y.VariableDefinitions(null, null, new Y.Modifiers(new Y.NodeList(t1, null, null, "", t2), t3, t4), new Y.NodeList(t5, null, null, "", t6), t7);
        }
      } else {
        t1 = J.getInterceptor$x(param);
        if (t1.get$defaultValue(param) != null) {
          t2 = D.TreePrinter_makeIdentifier(t1.get$name(param));
          t3 = $.Node__HASH_COUNTER + 1;
          $.Node__HASH_COUNTER = t3;
          t4 = this.makeLink$1([this.makeExp$2(t1.get$defaultValue(param), 1)]);
          t5 = $.Node__HASH_COUNTER + 1;
          $.Node__HASH_COUNTER = t5;
          t6 = t5 + 1;
          $.Node__HASH_COUNTER = t6;
          definition = new Y.SendSet(new Y.Operator(assignOperator, null, t3), null, t2, new Y.NodeList(t4, null, null, "", t5), null, t6);
        } else
          definition = D.TreePrinter_makeIdentifier(t1.get$name(param));
        this.setElement$3(definition, param.get$element(), param);
        t1 = t1.get$type(param) == null ? null : this.makeType$1(t1.get$type(param));
        t2 = this.makeLink$1([]);
        t3 = $.Node__HASH_COUNTER + 1;
        $.Node__HASH_COUNTER = t3;
        t4 = Y.Modifiers_computeFlags(t2);
        t5 = $.Node__HASH_COUNTER + 1;
        $.Node__HASH_COUNTER = t5;
        t6 = this.makeLink$1([definition]);
        t7 = $.Node__HASH_COUNTER + 1;
        $.Node__HASH_COUNTER = t7;
        t8 = t7 + 1;
        $.Node__HASH_COUNTER = t8;
        return new Y.VariableDefinitions(null, t1, new Y.Modifiers(new Y.NodeList(t2, null, null, "", t3), t4, t5), new Y.NodeList(t6, null, null, "", t7), t8);
      }
    }, function(param) {
      return this.makeParameter$2(param, null);
    }, "makeParameter$1", "call$2", "call$1", "get$makeParameter", 2, 2, 160, 10],
    makeFunctionModifiers$1: function(exp) {
      var t1, t2, t3, t4, modifiers;
      if (exp.element == null) {
        t1 = this.makeLink$1([]);
        t2 = $.Node__HASH_COUNTER + 1;
        $.Node__HASH_COUNTER = t2;
        t3 = Y.Modifiers_computeFlags(t1);
        t4 = $.Node__HASH_COUNTER + 1;
        $.Node__HASH_COUNTER = t4;
        return new Y.Modifiers(new Y.NodeList(t1, null, null, "", t2), t3, t4);
      }
      modifiers = H.setRuntimeTypeInfo([], [Y.Node]);
      t1 = exp.element;
      if (!!J.getInterceptor(t1).$isConstructorElement && (t1.get$modifiers().flags & 32) !== 0)
        modifiers.push(D.TreePrinter_makeIdentifier("factory"));
      if ((exp.element.get$modifiers().flags & 1) !== 0)
        modifiers.push(D.TreePrinter_makeIdentifier("static"));
      t1 = this.makeLink$1(modifiers);
      t2 = $.Node__HASH_COUNTER + 1;
      $.Node__HASH_COUNTER = t2;
      t3 = Y.Modifiers_computeFlags(t1);
      t4 = $.Node__HASH_COUNTER + 1;
      $.Node__HASH_COUNTER = t4;
      return new Y.Modifiers(new Y.NodeList(t1, null, null, "", t2), t3, t4);
    },
    functionName$1: function(exp) {
      var $name = exp.name;
      if ($name == null)
        return;
      if (Y.isUserDefinableOperator($name))
        return D.TreePrinter_makeOperator("operator" + $name);
      else if ($name === "unary-")
        return D.TreePrinter_makeOperator("operator-");
      return D.TreePrinter_makeIdentifier($name);
    },
    unparseStringLiteral$1: function(exp) {
      var output = F.Unparser_analyzeStringLiteral(exp);
      return new D.TreePrinter_unparseStringLiteral_printStringChunk(this, output.parts).call$1(output.chunk);
    },
    static: {TreePrinter_makeGroup: function($open, $close) {
        var openTok = new Y.BeginGroupToken(null, $open, -1, null);
        openTok.endGroup = new Y.SymbolToken($close, -1, null);
        return openTok;
      }, TreePrinter_makeIdentifier: [function($name) {
        var t1, t2;
        t1 = Y.StringToken_canonicalizedString($name, false);
        t2 = $.Node__HASH_COUNTER + 1;
        $.Node__HASH_COUNTER = t2;
        return new Y.Identifier(new Y.StringToken(t1, C.PrecedenceInfo_identifier_0_97, -1, null), null, t2);
      }, "call$1", "TreePrinter_makeIdentifier$closure", 2, 0, 20], TreePrinter_makeOperator: function($name) {
        var t1, t2;
        t1 = Y.StringToken_canonicalizedString($name, false);
        t2 = $.Node__HASH_COUNTER + 1;
        $.Node__HASH_COUNTER = t2;
        return new Y.Operator(new Y.StringToken(t1, C.PrecedenceInfo_identifier_0_97, -1, null), null, t2);
      }, TreePrinter_assignmentToken: function(operatorName) {
        switch (operatorName) {
          case "=":
            return new Y.SymbolToken(C.PrecedenceInfo_xw8, -1, null);
          case "+=":
            return new Y.SymbolToken(C.PrecedenceInfo_iHe, -1, null);
          case "-=":
            return new Y.SymbolToken(C.PrecedenceInfo_ij7, -1, null);
          case "*=":
            return new Y.SymbolToken(C.PrecedenceInfo_WZn, -1, null);
          case "/=":
            return new Y.SymbolToken(C.PrecedenceInfo_kCU, -1, null);
          case "~/=":
            return new Y.SymbolToken(C.PrecedenceInfo_DqM, -1, null);
          case "%=":
            return new Y.SymbolToken(C.PrecedenceInfo_k6K, -1, null);
          case "&=":
            return new Y.SymbolToken(C.PrecedenceInfo_sxw, -1, null);
          case "^=":
            return new Y.SymbolToken(C.PrecedenceInfo_OJ0, -1, null);
          case "|=":
            return new Y.SymbolToken(C.PrecedenceInfo_YwG, -1, null);
          case ">>=":
            return new Y.SymbolToken(C.PrecedenceInfo_TVl, -1, null);
          case "<<=":
            return new Y.SymbolToken(C.PrecedenceInfo_TLM, -1, null);
          default:
            throw H.wrapException("Unrecognized assignment operator: " + operatorName);
        }
      }, TreePrinter_binopToken: function(operatorName) {
        switch (operatorName) {
          case "+":
            return new Y.SymbolToken(C.PrecedenceInfo_W2j, -1, null);
          case "-":
            return new Y.SymbolToken(C.PrecedenceInfo_06W, -1, null);
          case "*":
            return new Y.SymbolToken(C.PrecedenceInfo_sUe, -1, null);
          case "/":
            return new Y.SymbolToken(C.PrecedenceInfo_9Uv, -1, null);
          case "~/":
            return new Y.SymbolToken(C.PrecedenceInfo_8cP, -1, null);
          case "%":
            return new Y.SymbolToken(C.PrecedenceInfo_4AN, -1, null);
          case "&":
            return new Y.SymbolToken(C.PrecedenceInfo_1nr, -1, null);
          case "^":
            return new Y.SymbolToken(C.PrecedenceInfo_Nm5, -1, null);
          case "|":
            return new Y.SymbolToken(C.PrecedenceInfo_P1e, -1, null);
          case ">>":
            return new Y.SymbolToken(C.PrecedenceInfo_A0t, -1, null);
          case "<<":
            return new Y.SymbolToken(C.PrecedenceInfo_cD9, -1, null);
          case "==":
            return new Y.SymbolToken(C.PrecedenceInfo_43h, -1, null);
          case "!=":
            return new Y.SymbolToken(C.PrecedenceInfo_zPV, -1, null);
          case ">":
            return new Y.SymbolToken(C.PrecedenceInfo_TG0, -1, null);
          case ">=":
            return new Y.SymbolToken(C.PrecedenceInfo_qBT, -1, null);
          case "<":
            return new Y.SymbolToken(C.PrecedenceInfo_S9I, -1, null);
          case "<=":
            return new Y.SymbolToken(C.PrecedenceInfo_1Vp, -1, null);
          case "&&":
            return new Y.SymbolToken(C.PrecedenceInfo_v9T, -1, null);
          case "||":
            return new Y.SymbolToken(C.PrecedenceInfo_Ogk, -1, null);
          default:
            throw H.wrapException("Unrecognized binary operator: " + H.S(operatorName));
        }
      }, TreePrinter_incrementToken: function(operatorName) {
        switch (operatorName) {
          case "++":
            return new Y.SymbolToken(C.PrecedenceInfo_ivD, -1, null);
          case "--":
            return new Y.SymbolToken(C.PrecedenceInfo_ifx, -1, null);
          default:
            throw H.wrapException("Unrecognized increment operator: " + operatorName);
        }
      }, TreePrinter_typeOpToken: function(operatorName) {
        switch (operatorName) {
          case "is":
            return new Y.SymbolToken(C.PrecedenceInfo_is_7_107, -1, null);
          case "as":
            return new Y.SymbolToken(C.PrecedenceInfo_as_7_107, -1, null);
          default:
            throw H.wrapException("Unrecognized type operator: " + H.S(operatorName));
        }
      }}
  },
  TreePrinter_makeParameters_closure: {
    "^": "Closure:13;this_0,assign_1",
    call$1: function(p) {
      return this.this_0.makeParameter$2(p, this.assign_1);
    },
    $isFunction: true
  },
  TreePrinter_unparseStringLiteral_printStringChunk: {
    "^": "Closure:161;this_0,parts_1",
    call$1: function(chunk) {
      var t1, raw, quoteCode, literalParts, sb, i, t2, t3, startIndex, t4, t5, t6, firstLiteral, currentInterpolation, part, t7, t8, lit, node;
      t1 = chunk.quoting;
      raw = t1.raw;
      quoteCode = t1.quote;
      literalParts = [];
      sb = P.StringBuffer$("");
      if (raw)
        sb.write$1("r");
      for (t1 = t1.leftQuoteCharCount, i = 0; i < t1; ++i) {
        t2 = quoteCode === 34 ? "\"" : "'";
        sb._contents += t2;
      }
      t2 = chunk.previous;
      t3 = t2 != null;
      startIndex = t3 ? t2.endIndex : 0;
      for (t4 = chunk.endIndex, t5 = this.parts_1, t6 = this.this_0, i = startIndex, firstLiteral = null, currentInterpolation = null; i < t4; ++i) {
        if (i >= t5.length)
          return H.ioore(t5, i);
        part = t5[i];
        if (!!J.getInterceptor(part).$isExpression1) {
          t7 = Y.StringToken_canonicalizedString(sb._contents, false);
          t8 = $.Node__HASH_COUNTER + 1;
          $.Node__HASH_COUNTER = t8;
          lit = new Y.LiteralString(new Y.StringToken(t7, C.PrecedenceInfo_string_0_39, -1, null), null, t8);
          if (currentInterpolation != null) {
            t7 = t8 + 1;
            $.Node__HASH_COUNTER = t7;
            literalParts.push(new Y.StringInterpolationPart(currentInterpolation, lit, t7));
          } else
            firstLiteral = lit;
          sb._contents = "";
          currentInterpolation = t6.makeExp$2(part, 1);
        } else {
          t7 = F.Unparser_getEscapedCharacter(part, quoteCode, raw);
          sb._contents += t7;
        }
      }
      t1 = t1 > 2;
      i = 0;
      while (true) {
        if (!(i < (t1 ? 3 : 1)))
          break;
        t4 = quoteCode === 34 ? "\"" : "'";
        sb._contents += t4;
        ++i;
      }
      lit = t6.makeVerbatimStringLiteral$1(sb._contents);
      if (firstLiteral == null)
        node = lit;
      else {
        t1 = $.Node__HASH_COUNTER + 1;
        $.Node__HASH_COUNTER = t1;
        literalParts.push(new Y.StringInterpolationPart(currentInterpolation, lit, t1));
        t6 = t6.makeLink$1(literalParts);
        t1 = $.Node__HASH_COUNTER + 1;
        $.Node__HASH_COUNTER = t1;
        t4 = t1 + 1;
        $.Node__HASH_COUNTER = t4;
        node = new Y.StringInterpolation(firstLiteral, new Y.NodeList(t6, null, null, "", t1), t4);
      }
      if (t3) {
        t1 = this.call$1(t2);
        t2 = $.Node__HASH_COUNTER + 1;
        $.Node__HASH_COUNTER = t2;
        return new Y.StringJuxtaposition(t1, node, null, null, t2);
      } else
        return node;
    },
    $isFunction: true
  }
}],
["dart_types", "package:compiler/implementation/dart_types.dart", , V, {
  "^": "",
  DartType_visitList: function(types, visitor, argument) {
    var t1;
    for (t1 = H.setRuntimeTypeInfo(new H.ListIterator(types, types.length, 0, null), [H.getTypeArgumentByIndex(types, 0)]); t1.moveNext$0();)
      J.accept$2$x(t1.__internal$_current, visitor, argument);
  },
  TypeKind: {
    "^": "Object;id>",
    toString$0: function(_) {
      return this.id;
    },
    static: {"^": "TypeKind_FUNCTION,TypeKind_INTERFACE,TypeKind_STATEMENT,TypeKind_TYPEDEF,TypeKind_TYPE_VARIABLE,TypeKind_MALFORMED_TYPE,TypeKind_DYNAMIC,TypeKind_VOID"}
  },
  DartType: {
    "^": "Object;",
    substByContext$1: function(type) {
      return this.subst$2(type.get$typeArguments(), type.get$element().get$typeVariables());
    },
    get$isRaw: function() {
      return true;
    },
    asRaw$0: function() {
      return this;
    },
    get$treatAsRaw: function() {
      return this.get$isRaw();
    },
    get$treatAsDynamic: function() {
      return false;
    },
    get$isDynamic: function() {
      return this.get$kind(this) === C.TypeKind_dynamic;
    },
    get$isVoid: function() {
      return this.get$kind(this) === C.TypeKind_void;
    },
    get$typeVariableOccurrence: function() {
      return;
    },
    forEachTypeVariable$1: function(f) {
    },
    _findTypeVariableOccurrence$1: function(types) {
      var t1, typeVariable;
      for (t1 = H.setRuntimeTypeInfo(new H.ListIterator(types, types.length, 0, null), [H.getTypeArgumentByIndex(types, 0)]); t1.moveNext$0();) {
        typeVariable = t1.__internal$_current.get$typeVariableOccurrence();
        if (typeVariable != null)
          return typeVariable;
      }
      return;
    },
    get$containsTypeVariables: function() {
      return this.get$typeVariableOccurrence() != null;
    },
    $isDartType: true
  },
  TypeVariableType: {
    "^": "DartType;element<",
    get$kind: function(_) {
      return C.TypeKind_kuk;
    },
    get$name: function(_) {
      return this.element.name;
    },
    subst$2: function($arguments, parameters) {
      var index, parameter, argument;
      if (parameters.length === 0)
        return this;
      for (index = 0; index < $arguments.length; ++index) {
        if (index >= parameters.length)
          return H.ioore(parameters, index);
        parameter = parameters[index];
        argument = $arguments[index];
        if (J.$eq(parameter, this))
          return argument;
      }
      return this;
    },
    unalias$1: function(compiler) {
      return this;
    },
    get$typeVariableOccurrence: function() {
      return this;
    },
    forEachTypeVariable$1: function(f) {
      f.call$1(this);
    },
    accept$2: function(_, visitor, argument) {
      return visitor.visitTypeVariableType$2(this, argument);
    },
    get$hashCode: function(_) {
      return 17 * this.element.hashCode;
    },
    $eq: function(_, other) {
      if (other == null)
        return false;
      if (!J.getInterceptor(other).$isTypeVariableType)
        return false;
      return other.element === this.element;
    },
    toString$0: function(_) {
      return this.element.name;
    },
    $isTypeVariableType: true
  },
  StatementType: {
    "^": "DartType;",
    get$element: function() {
      return;
    },
    get$kind: function(_) {
      return C.TypeKind_statement;
    },
    get$name: function(_) {
      return "statement";
    },
    subst$2: function($arguments, parameters) {
      return this;
    },
    unalias$1: function(compiler) {
      return this;
    },
    accept$2: function(_, visitor, argument) {
      return visitor.visitStatementType$2(this, argument);
    }
  },
  VoidType: {
    "^": "DartType;",
    get$kind: function(_) {
      return C.TypeKind_void;
    },
    get$name: function(_) {
      return "void";
    },
    get$element: function() {
      return;
    },
    subst$2: function($arguments, parameters) {
      return this;
    },
    unalias$1: function(compiler) {
      return this;
    },
    accept$2: function(_, visitor, argument) {
      return visitor.visitVoidType$2(this, argument);
    },
    toString$0: function(_) {
      return "void";
    },
    $isVoidType: true
  },
  MalformedType: {
    "^": "DartType;element<,userProvidedBadType,typeArguments<,hashCode>",
    get$kind: function(_) {
      return C.TypeKind_malformed;
    },
    get$name: function(_) {
      return this.element.name;
    },
    subst$2: function($arguments, parameters) {
      return this;
    },
    get$treatAsDynamic: function() {
      return true;
    },
    unalias$1: function(compiler) {
      return this;
    },
    accept$2: function(_, visitor, argument) {
      return visitor.visitMalformedType$2(this, argument);
    },
    toString$0: function(_) {
      var sb, t1, t2;
      sb = P.StringBuffer$("");
      t1 = this.typeArguments;
      if (t1 != null) {
        t2 = this.userProvidedBadType;
        if (t2 != null)
          sb.write$1(t2.get$name(t2));
        else
          sb.write$1(this.element.name);
        if (t1.length !== 0) {
          sb.write$1("<");
          sb.write$1(J.join$1$ax(t1, ", "));
          sb.write$1(">");
        }
      } else
        sb.write$1(J.toString$0(this.userProvidedBadType));
      return sb._contents;
    },
    $isMalformedType: true,
    static: {"^": "MalformedType_nextHash"}
  },
  GenericType: {
    "^": "DartType;element<,typeArguments<",
    subst$2: function($arguments, parameters) {
      var t1, newTypeArguments;
      t1 = this.typeArguments;
      if (t1.length === 0)
        return this;
      if (parameters.length === 0)
        return this;
      newTypeArguments = V.Types_substTypes(t1, $arguments, parameters);
      if (t1 !== newTypeArguments)
        return this.createInstantiation$1(newTypeArguments);
      return this;
    },
    get$typeVariableOccurrence: function() {
      return this._findTypeVariableOccurrence$1(this.typeArguments);
    },
    forEachTypeVariable$1: function(f) {
      var t1;
      for (t1 = this.typeArguments, t1 = H.setRuntimeTypeInfo(new H.ListIterator(t1, t1.length, 0, null), [H.getTypeArgumentByIndex(t1, 0)]); t1.moveNext$0();)
        t1.__internal$_current.forEachTypeVariable$1(f);
    },
    toString$0: function(_) {
      var sb, t1;
      sb = P.StringBuffer$("");
      sb.write$1(this.get$name(this));
      t1 = this.typeArguments;
      if (!(t1.length === 0 || this === this.get$element().get$rawType())) {
        sb.write$1("<");
        sb.write$1(C.JSArray_methods.join$1(t1, ", "));
        sb.write$1(">");
      }
      return sb._contents;
    },
    get$hashCode: function(_) {
      var hash, t1, argument, argumentHash;
      hash = J.get$hashCode$(this.get$element());
      for (t1 = this.typeArguments, t1 = H.setRuntimeTypeInfo(new H.ListIterator(t1, t1.length, 0, null), [H.getTypeArgumentByIndex(t1, 0)]); t1.moveNext$0();) {
        argument = t1.__internal$_current;
        argumentHash = argument != null ? J.get$hashCode$(argument) : 0;
        if (typeof hash !== "number")
          return H.iae(hash);
        if (typeof argumentHash !== "number")
          return H.iae(argumentHash);
        hash = 17 * hash + 3 * argumentHash;
      }
      return hash;
    },
    $eq: function(_, other) {
      var t1, t2;
      if (other == null)
        return false;
      t1 = J.getInterceptor(other);
      if (!t1.$isGenericType)
        return false;
      if (this.get$kind(this) === t1.get$kind(other)) {
        t1 = this.get$element();
        t2 = other.get$element();
        t1 = (t1 == null ? t2 == null : t1 === t2) && O.equalElements(this.typeArguments, other.typeArguments);
      } else
        t1 = false;
      return t1;
    },
    get$isRaw: function() {
      return this.typeArguments.length === 0 || this === this.get$element().get$rawType();
    },
    asRaw$0: function() {
      return this.get$element().get$rawType();
    },
    get$treatAsRaw: function() {
      var t1 = this.typeArguments;
      if (t1.length === 0 || this === this.get$element().get$rawType())
        return true;
      for (t1 = H.setRuntimeTypeInfo(new H.ListIterator(t1, t1.length, 0, null), [H.getTypeArgumentByIndex(t1, 0)]); t1.moveNext$0();)
        if (!t1.__internal$_current.get$treatAsDynamic())
          return false;
      return true;
    },
    GenericType$3$checkTypeArgumentCount: function(element, typeArguments, checkTypeArgumentCount) {
    },
    $isGenericType: true
  },
  InterfaceType: {
    "^": "GenericType;element,typeArguments",
    get$element: function() {
      return this.element;
    },
    get$kind: function(_) {
      return C.TypeKind_interface;
    },
    get$name: function(_) {
      return this.element.name;
    },
    createInstantiation$1: function(newTypeArguments) {
      var t1, t2;
      t1 = this.element;
      t2 = new V.InterfaceType(t1, newTypeArguments);
      t2.GenericType$3$checkTypeArgumentCount(t1, newTypeArguments, true);
      return t2;
    },
    asInstanceOf$1: function(other) {
      var t1, supertype, $arguments, t2;
      other = other.get$declaration();
      t1 = this.element;
      if (t1 == null ? other == null : t1 === other)
        return this;
      supertype = this.element.asInstanceOf$1(other);
      if (supertype != null) {
        $arguments = V.Types_substTypes(supertype.typeArguments, this.typeArguments, this.element.get$typeVariables());
        t1 = supertype.get$element();
        t2 = new V.InterfaceType(t1, $arguments);
        t2.GenericType$3$checkTypeArgumentCount(t1, $arguments, true);
        return t2;
      }
      return;
    },
    unalias$1: function(compiler) {
      return this;
    },
    lookupInterfaceMember$1: function($name) {
      var member = this.element.lookupInterfaceMember$1($name);
      if (member != null && this.typeArguments.length !== 0)
        return new V.InterfaceMember(this, member);
      return member;
    },
    lookupClassMember$1: function($name) {
      var member = this.element.lookupClassMember$1($name);
      if (member != null && this.typeArguments.length !== 0)
        return new V.InterfaceMember(this, member);
      return member;
    },
    get$hashCode: function(_) {
      return V.GenericType.prototype.get$hashCode.call(this, this);
    },
    asRaw$0: function() {
      return V.GenericType.prototype.asRaw$0.call(this);
    },
    accept$2: function(_, visitor, argument) {
      return visitor.visitInterfaceType$2(this, argument);
    },
    get$callType: function() {
      var type = this.element.get$callType();
      return type != null && this.typeArguments.length !== 0 ? type.subst$2(this.typeArguments, this.get$element().get$typeVariables()) : type;
    },
    $isInterfaceType: true
  },
  BadInterfaceType: {
    "^": "InterfaceType;userProvidedBadType,element,typeArguments",
    toString$0: function(_) {
      return this.userProvidedBadType.toString$0(0);
    }
  },
  BadTypedefType: {
    "^": "TypedefType;userProvidedBadType,element,typeArguments",
    toString$0: function(_) {
      return this.userProvidedBadType.toString$0(0);
    }
  },
  FunctionType: {
    "^": "DartType;element<,returnType<,parameterTypes<,optionalParameterTypes<,namedParameters<,namedParameterTypes",
    get$kind: function(_) {
      return C.TypeKind_function;
    },
    getNamedParameterType$1: function($name) {
      var t1, i;
      for (t1 = this.namedParameters, i = 0; i < t1.length; ++i)
        if (J.$eq(t1[i], $name)) {
          t1 = this.namedParameterTypes;
          if (i >= t1.length)
            return H.ioore(t1, i);
          return t1[i];
        }
      return;
    },
    subst$2: function($arguments, parameters) {
      var t1, newReturnType, changed, t2, newParameterTypes, t3, newOptionalParameterTypes, t4, newNamedParameterTypes;
      if (parameters.length === 0)
        return this;
      t1 = this.returnType;
      newReturnType = t1.subst$2($arguments, parameters);
      t1 = newReturnType === t1;
      changed = !t1;
      t2 = this.parameterTypes;
      newParameterTypes = V.Types_substTypes(t2, $arguments, parameters);
      t3 = this.optionalParameterTypes;
      newOptionalParameterTypes = V.Types_substTypes(t3, $arguments, parameters);
      t4 = this.namedParameterTypes;
      newNamedParameterTypes = V.Types_substTypes(t4, $arguments, parameters);
      if (t1)
        t1 = t2 !== newParameterTypes || t3 !== newOptionalParameterTypes || t4 !== newNamedParameterTypes;
      else
        t1 = false;
      if (t1 ? true : changed)
        return V.FunctionType$internal(this.element, newReturnType, newParameterTypes, newOptionalParameterTypes, this.namedParameters, newNamedParameterTypes);
      return this;
    },
    unalias$1: function(compiler) {
      return this;
    },
    get$typeVariableOccurrence: function() {
      var typeVariableType = this.returnType.get$typeVariableOccurrence();
      if (typeVariableType != null)
        return typeVariableType;
      typeVariableType = this._findTypeVariableOccurrence$1(this.parameterTypes);
      if (typeVariableType != null)
        return typeVariableType;
      typeVariableType = this._findTypeVariableOccurrence$1(this.optionalParameterTypes);
      if (typeVariableType != null)
        return typeVariableType;
      return this._findTypeVariableOccurrence$1(this.namedParameterTypes);
    },
    forEachTypeVariable$1: function(f) {
      this.returnType.forEachTypeVariable$1(f);
      H.IterableMixinWorkaround_forEach(this.parameterTypes, new V.FunctionType_forEachTypeVariable_closure(f));
      H.IterableMixinWorkaround_forEach(this.optionalParameterTypes, new V.FunctionType_forEachTypeVariable_closure0(f));
      H.IterableMixinWorkaround_forEach(this.namedParameterTypes, new V.FunctionType_forEachTypeVariable_closure1(f));
    },
    accept$2: function(_, visitor, argument) {
      return visitor.visitFunctionType$2(this, argument);
    },
    visitChildren$2: function(visitor, argument) {
      this.returnType.accept$2(0, visitor, argument);
      V.DartType_visitList(this.parameterTypes, visitor, argument);
      V.DartType_visitList(this.optionalParameterTypes, visitor, argument);
      V.DartType_visitList(this.namedParameterTypes, visitor, argument);
    },
    toString$0: function(_) {
      var sb, t1, first, t2, i, str, t3;
      sb = P.StringBuffer$("");
      sb.write$1("(");
      t1 = this.parameterTypes;
      sb.write$1(C.JSArray_methods.join$1(t1, ", "));
      first = t1.length === 0;
      t1 = this.optionalParameterTypes;
      if (t1.length !== 0) {
        if (!first)
          sb.write$1(", ");
        sb.write$1("[");
        sb.write$1(C.JSArray_methods.join$1(t1, ", "));
        sb.write$1("]");
        first = false;
      }
      t1 = this.namedParameterTypes;
      if (t1.length !== 0) {
        if (!first)
          sb.write$1(", ");
        sb.write$1("{");
        for (t2 = this.namedParameters, first = true, i = 0; i < t2.length; ++i, first = false) {
          if (!first)
            sb._contents += ", ";
          if (i >= t1.length)
            return H.ioore(t1, i);
          str = t1[i];
          t3 = sb._contents += typeof str === "string" ? str : H.S(str);
          sb._contents = t3 + " ";
          if (i >= t2.length)
            return H.ioore(t2, i);
          str = t2[i];
          sb._contents += typeof str === "string" ? str : H.S(str);
        }
        sb.write$1("}");
      }
      sb.write$1(") -> " + J.toString$0(this.returnType));
      return sb._contents;
    },
    get$name: function(_) {
      return "Function";
    },
    computeArity$0: function() {
      var t1 = {};
      t1.arity_0 = 0;
      H.IterableMixinWorkaround_forEach(this.parameterTypes, new V.FunctionType_computeArity_closure(t1));
      return t1.arity_0;
    },
    get$hashCode: function(_) {
      var t1, hash, t2;
      t1 = J.get$hashCode$(this.returnType);
      if (typeof t1 !== "number")
        return H.iae(t1);
      hash = 3 * t1;
      for (t1 = this.parameterTypes, t1 = H.setRuntimeTypeInfo(new H.ListIterator(t1, t1.length, 0, null), [H.getTypeArgumentByIndex(t1, 0)]); t1.moveNext$0();) {
        t2 = J.get$hashCode$(t1.__internal$_current);
        if (typeof t2 !== "number")
          return H.iae(t2);
        hash = 17 * hash + 5 * t2;
      }
      for (t1 = this.optionalParameterTypes, t1 = H.setRuntimeTypeInfo(new H.ListIterator(t1, t1.length, 0, null), [H.getTypeArgumentByIndex(t1, 0)]); t1.moveNext$0();) {
        t2 = J.get$hashCode$(t1.__internal$_current);
        if (typeof t2 !== "number")
          return H.iae(t2);
        hash = 19 * hash + 7 * t2;
      }
      for (t1 = this.namedParameters, t1 = H.setRuntimeTypeInfo(new H.ListIterator(t1, t1.length, 0, null), [H.getTypeArgumentByIndex(t1, 0)]); t1.moveNext$0();)
        hash = 23 * hash + 11 * J.get$hashCode$(t1.__internal$_current);
      for (t1 = this.namedParameterTypes, t1 = H.setRuntimeTypeInfo(new H.ListIterator(t1, t1.length, 0, null), [H.getTypeArgumentByIndex(t1, 0)]); t1.moveNext$0();) {
        t2 = J.get$hashCode$(t1.__internal$_current);
        if (typeof t2 !== "number")
          return H.iae(t2);
        hash = 29 * hash + 13 * t2;
      }
      return hash;
    },
    $eq: function(_, other) {
      if (other == null)
        return false;
      if (!J.getInterceptor(other).$isFunctionType)
        return false;
      return J.$eq(this.returnType, other.returnType) && O.equalElements(this.parameterTypes, other.parameterTypes) && O.equalElements(this.optionalParameterTypes, other.optionalParameterTypes) && O.equalElements(this.namedParameters, other.namedParameters) && O.equalElements(this.namedParameterTypes, other.namedParameterTypes);
    },
    FunctionType$internal$6: function(element, returnType, parameterTypes, optionalParameterTypes, namedParameters, namedParameterTypes) {
    },
    $isFunctionType: true,
    static: {FunctionType_FunctionType: function(element, returnType, parameterTypes, optionalParameterTypes, namedParameters, namedParameterTypes) {
        return new V.FunctionType(element, returnType, parameterTypes, optionalParameterTypes, namedParameters, namedParameterTypes);
      }, FunctionType$internal: function(element, returnType, parameterTypes, optionalParameterTypes, namedParameters, namedParameterTypes) {
        var t1 = new V.FunctionType(element, returnType, parameterTypes, optionalParameterTypes, namedParameters, namedParameterTypes);
        t1.FunctionType$internal$6(element, returnType, parameterTypes, optionalParameterTypes, namedParameters, namedParameterTypes);
        return t1;
      }}
  },
  FunctionType_forEachTypeVariable_closure: {
    "^": "Closure:123;f_0",
    call$1: function(type) {
      type.forEachTypeVariable$1(this.f_0);
    },
    $isFunction: true
  },
  FunctionType_forEachTypeVariable_closure0: {
    "^": "Closure:123;f_1",
    call$1: function(type) {
      type.forEachTypeVariable$1(this.f_1);
    },
    $isFunction: true
  },
  FunctionType_forEachTypeVariable_closure1: {
    "^": "Closure:123;f_2",
    call$1: function(type) {
      type.forEachTypeVariable$1(this.f_2);
    },
    $isFunction: true
  },
  FunctionType_computeArity_closure: {
    "^": "Closure:13;box_0",
    call$1: function(_) {
      ++this.box_0.arity_0;
    },
    $isFunction: true
  },
  TypedefType: {
    "^": "GenericType;element,typeArguments",
    get$element: function() {
      return this.element;
    },
    get$kind: function(_) {
      return C.TypeKind_typedef;
    },
    get$name: function(_) {
      return this.element.name;
    },
    createInstantiation$1: function(newTypeArguments) {
      var t1, t2;
      t1 = this.element;
      t2 = new V.TypedefType(t1, newTypeArguments);
      t2.GenericType$3$checkTypeArgumentCount(t1, newTypeArguments, true);
      return t2;
    },
    unalias$1: function(compiler) {
      var t1 = this.element;
      if (t1.get$resolutionState() === 0)
        compiler.resolver.resolve$1(t1);
      this.element.checkCyclicReference$1(compiler);
      return this.element.get$alias().unalias$1(compiler).subst$2(this.typeArguments, this.get$element().get$typeVariables());
    },
    get$hashCode: function(_) {
      return V.GenericType.prototype.get$hashCode.call(this, this);
    },
    asRaw$0: function() {
      return V.GenericType.prototype.asRaw$0.call(this);
    },
    accept$2: function(_, visitor, argument) {
      return visitor.visitTypedefType$2(this, argument);
    },
    $isTypedefType: true
  },
  DynamicType: {
    "^": "DartType;",
    get$element: function() {
      return;
    },
    get$name: function(_) {
      return "dynamic";
    },
    get$treatAsDynamic: function() {
      return true;
    },
    get$kind: function(_) {
      return C.TypeKind_dynamic;
    },
    unalias$1: function(compiler) {
      return this;
    },
    subst$2: function($arguments, parameters) {
      return this;
    },
    accept$2: function(_, visitor, argument) {
      return visitor.visitDynamicType$2(this, argument);
    },
    toString$0: function(_) {
      return "dynamic";
    },
    $isDynamicType: true
  },
  InterfaceMember: {
    "^": "Object;instance,member",
    get$name: function(_) {
      var t1 = this.member;
      return t1.get$name(t1);
    },
    get$type: function(_) {
      var t1, t2;
      t1 = this.member;
      t1 = t1.get$type(t1);
      t2 = this.instance;
      t1.toString;
      return t1.subst$2(t2.typeArguments, t2.get$element().get$typeVariables());
    },
    get$functionType: function() {
      var t1, t2;
      t1 = this.member.get$functionType();
      t2 = this.instance;
      t1.toString;
      return t1.subst$2(t2.typeArguments, t2.get$element().get$typeVariables());
    },
    get$isGetter: function() {
      return this.member.get$isGetter();
    },
    get$isSetter: function() {
      return this.member.get$isSetter();
    },
    get$isMethod: function() {
      return this.member.get$isMethod();
    },
    get$declarations: function() {
      return this.member.get$declarations();
    }
  },
  DartTypeVisitor: {
    "^": "Object;",
    visitVoidType$2: function(type, argument) {
      return this.visitType$2(type, argument);
    },
    visitTypeVariableType$2: function(type, argument) {
      return this.visitType$2(type, argument);
    },
    visitFunctionType$2: function(type, argument) {
      return this.visitType$2(type, argument);
    },
    visitMalformedType$2: function(type, argument) {
      return this.visitType$2(type, argument);
    },
    visitStatementType$2: function(type, argument) {
      return this.visitType$2(type, argument);
    },
    visitGenericType$2: function(type, argument) {
      return this.visitType$2(type, argument);
    },
    visitInterfaceType$2: function(type, argument) {
      return this.visitGenericType$2(type, argument);
    },
    visitTypedefType$2: function(type, argument) {
      return this.visitGenericType$2(type, argument);
    },
    visitDynamicType$2: function(type, argument) {
      return this.visitType$2(type, argument);
    }
  },
  AbstractTypeRelation: {
    "^": "DartTypeVisitor;compiler<",
    visitType$2: function(t, s) {
      throw H.wrapException("internal error: unknown type kind " + t.get$kind(t).toString$0(0));
    },
    visitVoidType$2: function(t, s) {
      return false;
    },
    visitMalformedType$2: function(t, s) {
      return true;
    },
    visitInterfaceType$2: function(t, s) {
      var t1, instance;
      t1 = t.element;
      if (t1.get$resolutionState() === 0)
        this.compiler.resolver.resolveClass$1(t1);
      if (!!J.getInterceptor(s).$isInterfaceType) {
        instance = t.asInstanceOf$1(s.get$element());
        return instance != null && new V.AbstractTypeRelation_visitInterfaceType_checkTypeArguments(this).call$2(instance, s) === true;
      } else
        return false;
    },
    visitFunctionType$2: function(t, s) {
      var t1, t2, t3, t4, sps, t5, tNames, tTypes, sTypes, tIndex, sIndex;
      t1 = {};
      t2 = J.getInterceptor(s);
      if (!!t2.$isInterfaceType) {
        t3 = s.get$element();
        t4 = this.compiler.functionClass;
        t4 = t3 == null ? t4 == null : t3 === t4;
        t3 = t4;
      } else
        t3 = false;
      if (t3)
        return true;
      if (!t2.$isFunctionType)
        return false;
      if (this.invalidFunctionReturnTypes$2(t.returnType, s.returnType))
        return false;
      t2 = t.parameterTypes;
      t1.tps_0 = H.setRuntimeTypeInfo(new H.ListIterator(t2, t2.length, 0, null), [H.getTypeArgumentByIndex(t2, 0)]);
      t2 = s.parameterTypes;
      sps = H.setRuntimeTypeInfo(new H.ListIterator(t2, t2.length, 0, null), [H.getTypeArgumentByIndex(t2, 0)]);
      t1.sps_1 = sps;
      t1.sNotEmpty_2 = sps.moveNext$0();
      t1.tNotEmpty_3 = t1.tps_0.moveNext$0();
      t2 = new V.AbstractTypeRelation_visitFunctionType_tNext(t1);
      t3 = new V.AbstractTypeRelation_visitFunctionType_sNext(t1);
      t4 = new V.AbstractTypeRelation_visitFunctionType_incompatibleParameters(t1, this, t2, t3);
      if (t4.call$0() === true)
        return false;
      if (t1.tNotEmpty_3)
        return false;
      t5 = s.namedParameters;
      if (t5.length !== 0) {
        if (t1.sNotEmpty_2)
          return false;
        tNames = t.namedParameters;
        tTypes = t.namedParameterTypes;
        sTypes = s.namedParameterTypes;
        tIndex = 0;
        sIndex = 0;
        while (true) {
          t1 = tNames.length;
          if (!(tIndex < t1 && sIndex < t5.length))
            break;
          if (tIndex >= t1)
            return H.ioore(tNames, tIndex);
          t1 = tNames[tIndex];
          if (sIndex >= t5.length)
            return H.ioore(t5, sIndex);
          if (J.$eq(t1, t5[sIndex])) {
            if (tIndex >= tTypes.length)
              return H.ioore(tTypes, tIndex);
            t1 = tTypes[tIndex];
            if (sIndex >= sTypes.length)
              return H.ioore(sTypes, sIndex);
            if (this.invalidFunctionParameterTypes$2(t1, sTypes[sIndex]))
              return false;
            ++sIndex;
          }
          ++tIndex;
        }
        if (sIndex < t5.length)
          return false;
      } else {
        t5 = t.optionalParameterTypes;
        t1.tps_0 = H.setRuntimeTypeInfo(new H.ListIterator(t5, t5.length, 0, null), [H.getTypeArgumentByIndex(t5, 0)]);
        t2.call$0();
        if (t4.call$0() === true)
          return false;
        if (t1.sNotEmpty_2)
          return false;
        t2 = s.optionalParameterTypes;
        t5 = t2.length;
        if (t5 !== 0) {
          t1.sps_1 = H.setRuntimeTypeInfo(new H.ListIterator(t2, t5, 0, null), [H.getTypeArgumentByIndex(t2, 0)]);
          t3.call$0();
          if (t4.call$0() === true)
            return false;
          if (t1.sNotEmpty_2)
            return false;
        }
      }
      return true;
    },
    visitTypeVariableType$2: function(t, s) {
      var t1, bound, seenTypeVariables, element, t2;
      t1 = t.element;
      bound = t1.get$bound();
      if (bound.get$kind(bound) === C.TypeKind_kuk) {
        seenTypeVariables = P.LinkedHashSet_LinkedHashSet(null, null, null, O.TypeVariableElement);
        seenTypeVariables.add$1(0, t1);
        for (; bound.get$kind(bound) === C.TypeKind_kuk;) {
          element = bound.get$element();
          t1 = bound.get$element();
          t2 = s.get$element();
          if (t1 == null ? t2 == null : t1 === t2)
            return true;
          if (seenTypeVariables.contains$1(0, element))
            return false;
          seenTypeVariables.add$1(0, element);
          bound = element.get$boundCache();
        }
      }
      if (this.invalidTypeVariableBounds$2(bound, s))
        return false;
      return true;
    },
    $asDartTypeVisitor: function() {
      return [P.bool, V.DartType];
    }
  },
  AbstractTypeRelation_visitInterfaceType_checkTypeArguments: {
    "^": "Closure:162;this_0",
    call$2: function(instance, other) {
      var tTypeArgs, sTypeArgs, t1, i, t2;
      tTypeArgs = instance.typeArguments;
      sTypeArgs = other.typeArguments;
      for (t1 = this.this_0, i = 0; i < tTypeArgs.length; ++i) {
        t2 = tTypeArgs[i];
        if (i >= sTypeArgs.length)
          return H.ioore(sTypeArgs, i);
        if (t1.invalidTypeArguments$2(t2, sTypeArgs[i]))
          return false;
      }
      return true;
    },
    $isFunction: true
  },
  AbstractTypeRelation_visitFunctionType_tNext: {
    "^": "Closure:23;box_0",
    call$0: function() {
      var t1, tNotEmpty;
      t1 = this.box_0;
      tNotEmpty = t1.tps_0.moveNext$0();
      t1.tNotEmpty_3 = tNotEmpty;
      return tNotEmpty;
    },
    $isFunction: true
  },
  AbstractTypeRelation_visitFunctionType_sNext: {
    "^": "Closure:23;box_0",
    call$0: function() {
      var t1, sNotEmpty;
      t1 = this.box_0;
      sNotEmpty = t1.sps_1.moveNext$0();
      t1.sNotEmpty_2 = sNotEmpty;
      return sNotEmpty;
    },
    $isFunction: true
  },
  AbstractTypeRelation_visitFunctionType_incompatibleParameters: {
    "^": "Closure:42;box_0,this_1,tNext_2,sNext_3",
    call$0: function() {
      var t1, t2, t3, t4;
      t1 = this.tNext_2;
      t2 = this.sNext_3;
      t3 = this.this_1;
      t4 = this.box_0;
      while (true) {
        if (!(t4.tNotEmpty_3 && t4.sNotEmpty_2))
          break;
        if (t3.invalidFunctionParameterTypes$2(t4.tps_0.__internal$_current, t4.sps_1.__internal$_current))
          return true;
        t1.call$0();
        t2.call$0();
      }
      return false;
    },
    $isFunction: true
  },
  MoreSpecificVisitor: {
    "^": "AbstractTypeRelation;compiler",
    isMoreSpecific$2: function(t, s) {
      var t1, t2, t3;
      if (t == null ? s != null : t !== s)
        if (!s.get$treatAsDynamic()) {
          t1 = t.get$element();
          t2 = this.compiler.nullClass;
          t2 = t1 == null ? t2 == null : t1 === t2;
          t1 = t2;
        } else
          t1 = true;
      else
        t1 = true;
      if (t1)
        return true;
      if (t.get$kind(t) === C.TypeKind_void || s.get$kind(s) === C.TypeKind_void)
        return false;
      if (t.get$treatAsDynamic())
        return false;
      t1 = s.get$element();
      t2 = this.compiler;
      t3 = t2.objectClass;
      if (t1 == null ? t3 == null : t1 === t3)
        return true;
      return t.unalias$1(t2).accept$2(0, this, s.unalias$1(t2));
    },
    invalidTypeArguments$2: function(t, s) {
      return this.isMoreSpecific$2(t, s) !== true;
    },
    invalidFunctionReturnTypes$2: function(t, s) {
      if (s.get$treatAsDynamic() && t.get$kind(t) === C.TypeKind_void)
        return true;
      return s.get$kind(s) !== C.TypeKind_void && this.isMoreSpecific$2(t, s) !== true;
    },
    invalidFunctionParameterTypes$2: function(t, s) {
      return this.isMoreSpecific$2(t, s) !== true;
    },
    invalidTypeVariableBounds$2: function(bound, s) {
      return this.isMoreSpecific$2(bound, s) !== true;
    }
  },
  SubtypeVisitor: {
    "^": "MoreSpecificVisitor;compiler",
    isSubtype$2: [function(t, s) {
      return t.get$treatAsDynamic() || this.isMoreSpecific$2(t, s) === true;
    }, "call$2", "get$isSubtype", 4, 0, 163],
    isAssignable$2: [function(t, s) {
      return this.isSubtype$2(t, s) || this.isSubtype$2(s, t);
    }, "call$2", "get$isAssignable", 4, 0, 163],
    invalidTypeArguments$2: function(t, s) {
      return !this.isSubtype$2(t, s);
    },
    invalidFunctionReturnTypes$2: function(t, s) {
      var t1;
      if (s.get$kind(s) !== C.TypeKind_void)
        t1 = !(this.isSubtype$2(t, s) || this.isSubtype$2(s, t));
      else
        t1 = false;
      return t1;
    },
    invalidFunctionParameterTypes$2: function(t, s) {
      return !(this.isSubtype$2(t, s) || this.isSubtype$2(s, t));
    },
    invalidTypeVariableBounds$2: function(bound, s) {
      return !this.isSubtype$2(bound, s);
    },
    visitInterfaceType$2: function(t, s) {
      var t1, t2, t3, callType;
      if (V.AbstractTypeRelation.prototype.visitInterfaceType$2.call(this, t, s))
        return true;
      t1 = J.getInterceptor(s);
      if (!!t1.$isInterfaceType) {
        t2 = s.get$element();
        t3 = this.compiler.functionClass;
        t2 = (t2 == null ? t3 == null : t2 === t3) && t.element.get$callType() != null;
      } else
        t2 = false;
      if (t2)
        return true;
      else if (!!t1.$isFunctionType) {
        callType = t.get$callType();
        return callType != null && this.isSubtype$2(callType, s);
      }
      return false;
    }
  },
  Types: {
    "^": "Object;compiler<,moreSpecificVisitor,subtypeVisitor,potentialSubtypeVisitor",
    getMostSpecific$2: function(t, s) {
      var t1 = this.moreSpecificVisitor;
      if (t1.isMoreSpecific$2(t, s) === true)
        return t;
      else if (t1.isMoreSpecific$2(s, t) === true)
        return s;
      else
        return;
    },
    isSubtype$2: [function(t, s) {
      return t.get$treatAsDynamic() || this.subtypeVisitor.isMoreSpecific$2(t, s) === true;
    }, "call$2", "get$isSubtype", 4, 0, 163],
    isAssignable$2: [function(r, s) {
      var t1 = this.subtypeVisitor;
      return t1.isSubtype$2(r, s) || t1.isSubtype$2(s, r);
    }, "call$2", "get$isAssignable", 4, 0, 163],
    computeSubtypeRelation$2: function(t, s) {
      if (t.get$treatAsDynamic() || this.subtypeVisitor.isMoreSpecific$2(t, s) === true)
        return 1;
      return this.potentialSubtypeVisitor.isSubtype$2(t, s) ? 0 : -1;
    },
    checkTypeVariableBounds$2: function(type, checkTypeVariableBound) {
      var element, typeArguments, typeVariables, index, typeVariable, t1, bound;
      element = type.get$element();
      typeArguments = type.typeArguments;
      typeVariables = element.get$typeVariables();
      for (index = 0; index < typeArguments.length; ++index) {
        if (index >= typeVariables.length)
          return H.ioore(typeVariables, index);
        typeVariable = typeVariables[index];
        t1 = typeVariable.get$element().boundCache;
        t1.toString;
        bound = t1.subst$2(typeArguments, type.get$element().get$typeVariables());
        if (index >= typeArguments.length)
          return H.ioore(typeArguments, index);
        checkTypeVariableBound.call$4(type, typeArguments[index], typeVariable, bound);
      }
    },
    computeLeastUpperBoundInterfaces$2: function(a, b) {
      var t1, aClass, bClass, maxCommonDepth, depth, aTypeSet;
      t1 = new V.Types_computeLeastUpperBoundInterfaces_getSupertypesAtDepth();
      aClass = a.get$element();
      bClass = b.get$element();
      maxCommonDepth = P.min(aClass.get$allSupertypesAndSelf()._levels.length - 1, bClass.get$allSupertypesAndSelf()._levels.length - 1);
      for (depth = maxCommonDepth; depth >= 0; --depth) {
        aTypeSet = t1.call$2(a, depth);
        aTypeSet.retainAll$1(t1.call$2(b, depth));
        if (aTypeSet.get$_collection$_length() === 1) {
          if (aTypeSet.get$_first() == null)
            H.throwExpression(P.StateError$("No elements"));
          return aTypeSet._first._element;
        }
      }
      K.invariant(C._SpannableSentinel_0, false, "No least upper bound computed for " + H.S(a) + " and " + H.S(b) + ".");
      return;
    },
    computeLeastUpperBoundsTypes$2: function(a, b) {
      var t1, prefixLength, types, index, t2;
      t1 = a.length;
      if (t1 === 0 || b.length === 0)
        return C.List_empty3;
      prefixLength = P.min(t1, b.length);
      t1 = Array(prefixLength);
      t1.fixed$length = init;
      types = H.setRuntimeTypeInfo(t1, [V.DartType]);
      for (t1 = types.length, index = 0; index < prefixLength; ++index) {
        if (index >= a.length)
          return H.ioore(a, index);
        t2 = a[index];
        if (index >= b.length)
          return H.ioore(b, index);
        t2 = this.computeLeastUpperBound$2(t2, b[index]);
        if (index >= t1)
          return H.ioore(types, index);
        types[index] = t2;
      }
      return types;
    },
    computeLeastUpperBoundFunctionTypes$2: function(a, b) {
      var returnType, parameterTypes, optionalParameterTypes, namedParameters, aNamedParameters, bNamedParameters, namedParameterTypes, aNamedParameterTypes, bNamedParameterTypes, aIndex, bIndex, t1, aNamedParameter, result;
      if (a.get$parameterTypes().length !== b.get$parameterTypes().length)
        return this.compiler.functionClass.get$rawType();
      returnType = this.computeLeastUpperBound$2(a.returnType, b.returnType);
      parameterTypes = this.computeLeastUpperBoundsTypes$2(a.parameterTypes, b.parameterTypes);
      optionalParameterTypes = this.computeLeastUpperBoundsTypes$2(a.optionalParameterTypes, b.optionalParameterTypes);
      namedParameters = H.setRuntimeTypeInfo([], [P.String]);
      aNamedParameters = a.namedParameters;
      bNamedParameters = b.namedParameters;
      namedParameterTypes = H.setRuntimeTypeInfo([], [V.DartType]);
      aNamedParameterTypes = a.namedParameterTypes;
      bNamedParameterTypes = b.namedParameterTypes;
      P.min(aNamedParameterTypes.length, bNamedParameterTypes.length);
      aIndex = 0;
      bIndex = 0;
      while (true) {
        t1 = aNamedParameters.length;
        if (!(aIndex < t1 && bIndex < bNamedParameters.length))
          break;
        if (aIndex >= t1)
          return H.ioore(aNamedParameters, aIndex);
        aNamedParameter = aNamedParameters[aIndex];
        if (bIndex >= bNamedParameters.length)
          return H.ioore(bNamedParameters, bIndex);
        result = J.compareTo$1$ns(aNamedParameter, bNamedParameters[bIndex]);
        if (result === 0) {
          namedParameters.push(aNamedParameter);
          if (aIndex >= aNamedParameterTypes.length)
            return H.ioore(aNamedParameterTypes, aIndex);
          t1 = aNamedParameterTypes[aIndex];
          if (bIndex >= bNamedParameterTypes.length)
            return H.ioore(bNamedParameterTypes, bIndex);
          namedParameterTypes.push(this.computeLeastUpperBound$2(t1, bNamedParameterTypes[bIndex]));
        }
        if (result <= 0)
          ++aIndex;
        if (result >= 0)
          ++bIndex;
      }
      return V.FunctionType$internal(null, returnType, parameterTypes, optionalParameterTypes, namedParameters, namedParameterTypes);
    },
    computeLeastUpperBoundTypeVariableTypes$2: function(a, b) {
      var typeVariableBounds = P.LinkedHashSet_LinkedHashSet(null, null, null, V.DartType);
      for (; a.get$kind(a) === C.TypeKind_kuk;) {
        if (a.$eq(0, b))
          return a;
        typeVariableBounds.add$1(0, a);
        a = a.get$element().get$boundCache();
      }
      for (; b.get$kind(b) === C.TypeKind_kuk;) {
        if (typeVariableBounds.contains$1(0, b))
          return b;
        b = b.get$element().get$boundCache();
      }
      return this.computeLeastUpperBound$2(a, b);
    },
    computeLeastUpperBound$2: function(a, b) {
      var t1 = J.getInterceptor(a);
      if (t1.$eq(a, b))
        return a;
      if (t1.get$kind(a) === C.TypeKind_kuk || J.get$kind$x(b) === C.TypeKind_kuk)
        return this.computeLeastUpperBoundTypeVariableTypes$2(a, b);
      t1 = this.compiler;
      a = a.unalias$1(t1);
      b = b.unalias$1(t1);
      if (a.get$treatAsDynamic() || b.get$treatAsDynamic())
        return C.C_DynamicType;
      if (a.get$kind(a) === C.TypeKind_void || b.get$kind(b) === C.TypeKind_void)
        return C.C_VoidType;
      if (a.get$kind(a) === C.TypeKind_function && b.get$kind(b) === C.TypeKind_function)
        return this.computeLeastUpperBoundFunctionTypes$2(a, b);
      if (a.get$kind(a) === C.TypeKind_function)
        a = t1.functionClass.get$rawType();
      if (b.get$kind(b) === C.TypeKind_function)
        b = t1.functionClass.get$rawType();
      if (a.get$kind(a) === C.TypeKind_interface && b.get$kind(b) === C.TypeKind_interface)
        return this.computeLeastUpperBoundInterfaces$2(a, b);
      return C.C_DynamicType;
    },
    static: {"^": "Types_IS_SUBTYPE,Types_MAYBE_SUBTYPE,Types_NOT_SUBTYPE", Types_substTypes: function(types, $arguments, parameters) {
        var t1, result;
        t1 = {};
        t1.changed_0 = false;
        result = P.List_List$generate(types.length, new V.Types_substTypes_closure(t1, types, $arguments, parameters), true, V.DartType);
        return t1.changed_0 ? result : types;
      }, Types_getClassContext: function(type) {
        var typeVariable = type.get$typeVariableOccurrence();
        if (typeVariable == null)
          return;
        return typeVariable.element.enclosingElement;
      }}
  },
  Types_substTypes_closure: {
    "^": "Closure:13;box_0,types_1,arguments_2,parameters_3",
    call$1: function(index) {
      var t1, type, argument;
      t1 = this.types_1;
      if (index >= t1.length)
        return H.ioore(t1, index);
      type = t1[index];
      argument = type.subst$2(this.arguments_2, this.parameters_3);
      t1 = this.box_0;
      if (!t1.changed_0 && argument !== type)
        t1.changed_0 = true;
      return argument;
    },
    $isFunction: true
  },
  Types_computeLeastUpperBoundInterfaces_getSupertypesAtDepth: {
    "^": "Closure:164;",
    call$2: function(type, depth) {
      var types, set;
      types = type.get$element().get$allSupertypesAndSelf();
      set = P.LinkedHashSet_LinkedHashSet(null, null, null, V.DartType);
      types.forEach$2(0, depth, new V.Types_computeLeastUpperBoundInterfaces_getSupertypesAtDepth_closure(type, set));
      return set;
    },
    $isFunction: true
  },
  Types_computeLeastUpperBoundInterfaces_getSupertypesAtDepth_closure: {
    "^": "Closure:123;type_0,set_1",
    call$1: function(supertype) {
      var t1 = this.type_0;
      supertype.toString;
      this.set_1.add$1(0, supertype.subst$2(t1.typeArguments, t1.get$element().get$typeVariables()));
    },
    $isFunction: true
  },
  PotentialSubtypeVisitor: {
    "^": "SubtypeVisitor;compiler",
    isSubtype$2: [function(t, s) {
      if (!!J.getInterceptor(t).$isTypeVariableType || !!J.getInterceptor(s).$isTypeVariableType)
        return true;
      return V.SubtypeVisitor.prototype.isSubtype$2.call(this, t, s);
    }, "call$2", "get$isSubtype", 4, 0, 163]
  },
  MoreSpecificSubtypeVisitor: {
    "^": "DartTypeVisitor;compiler<,constraintMap",
    computeMoreSpecific$2: function(element, supertype) {
      var supertypeInstance, variables, typeArguments;
      supertypeInstance = element.get$thisType().asInstanceOf$1(supertype.get$element());
      if (supertypeInstance == null)
        return;
      this.constraintMap = P.LinkedHashMap_LinkedHashMap(null, null, null, V.TypeVariableType, V.DartType);
      H.IterableMixinWorkaround_forEach(element.get$typeVariables(), new V.MoreSpecificSubtypeVisitor_computeMoreSpecific_closure(this));
      if (this.visitInterfaceType$2(supertypeInstance, supertype) === true) {
        variables = element.get$typeVariables();
        typeArguments = P.List_List$generate(variables.length, new V.MoreSpecificSubtypeVisitor_computeMoreSpecific_closure0(this, variables), true, V.DartType);
        return element.get$thisType().createInstantiation$1(typeArguments);
      }
      return;
    },
    visitType$2: function(type, argument) {
      return this.compiler.types.moreSpecificVisitor.isMoreSpecific$2(type, argument);
    },
    visitTypes$2: function(a, b) {
      var prefixLength, index, t1;
      prefixLength = P.min(a.length, b.length);
      for (index = 0; index < prefixLength; ++index) {
        if (index >= a.length)
          return H.ioore(a, index);
        t1 = a[index];
        if (index >= b.length)
          return H.ioore(b, index);
        if (J.accept$2$x(t1, this, b[index]) !== true)
          return false;
      }
      t1 = a.length;
      return prefixLength === t1 && t1 === b.length;
    },
    visitTypeVariableType$2: function(type, argument) {
      var constraint = this.compiler.types.getMostSpecific$2(this.constraintMap.$index(0, type), argument);
      this.constraintMap.$indexSet(0, type, constraint);
      return constraint != null;
    },
    visitFunctionType$2: function(type, argument) {
      var t1, t2, t3, t4, t5;
      if (!!J.getInterceptor(argument).$isFunctionType) {
        t1 = type.parameterTypes;
        t2 = t1.length;
        t3 = argument.parameterTypes;
        if (t2 !== t3.length)
          return false;
        t2 = type.optionalParameterTypes;
        t4 = t2.length;
        t5 = argument.optionalParameterTypes;
        if (t4 !== t5.length)
          return false;
        if (type.namedParameters !== argument.namedParameters)
          return false;
        if (type.returnType.accept$2(0, this, argument.returnType) !== true)
          return false;
        if (this.visitTypes$2(t1, t3))
          return false;
        if (this.visitTypes$2(t2, t5))
          return false;
        return this.visitTypes$2(type.namedParameterTypes, argument.namedParameterTypes);
      }
      return false;
    },
    visitGenericType$2: function(type, argument) {
      var t1, t2;
      if (!!J.getInterceptor(argument).$isGenericType) {
        t1 = type.get$element();
        t2 = argument.get$element();
        if (t1 == null ? t2 != null : t1 !== t2)
          return false;
        return this.visitTypes$2(type.typeArguments, argument.typeArguments);
      }
      return false;
    },
    $asDartTypeVisitor: function() {
      return [P.bool, V.DartType];
    }
  },
  MoreSpecificSubtypeVisitor_computeMoreSpecific_closure: {
    "^": "Closure:37;this_0",
    call$1: function(typeVariable) {
      this.this_0.constraintMap.$indexSet(0, typeVariable, C.C_DynamicType);
    },
    $isFunction: true
  },
  MoreSpecificSubtypeVisitor_computeMoreSpecific_closure0: {
    "^": "Closure:165;this_1,variables_2",
    call$1: function(index) {
      var t1, t2;
      t1 = this.this_1.constraintMap;
      t2 = this.variables_2;
      if (index >= t2.length)
        return H.ioore(t2, index);
      return t1.$index(0, t2[index]);
    },
    $isFunction: true
  },
  TypeDeclarationFormatter: {
    "^": "DartTypeVisitor;usedNames,sb",
    format$2: function(_, type, $name) {
      this.sb = P.StringBuffer$("");
      this.usedNames = P.LinkedHashSet_LinkedHashSet(null, null, null, P.String);
      type.accept$2(0, this, $name);
      this.usedNames = null;
      return J.toString$0(this.sb);
    },
    createName$1: function($name) {
      var index, index0, proposal;
      if (!this.usedNames.contains$1(0, $name)) {
        this.usedNames.add$1(0, $name);
        return $name;
      }
      index = this.usedNames._collection$_length;
      do {
        index0 = index + 1;
        proposal = $name + index;
        if (this.usedNames.contains$1(0, proposal)) {
          index = index0;
          continue;
        } else
          break;
      } while (true);
      this.usedNames.add$1(0, proposal);
      return proposal;
    },
    visitTypes$2: function(types, prefix) {
      var t1, needsComma, type, t2;
      for (t1 = H.setRuntimeTypeInfo(new H.ListIterator(types, types.length, 0, null), [H.getTypeArgumentByIndex(types, 0)]), needsComma = false; t1.moveNext$0(); needsComma = true) {
        type = t1.__internal$_current;
        if (needsComma) {
          t2 = this.sb;
          t2.toString;
          t2._contents += ", ";
        }
        J.accept$2$x(type, this, prefix);
      }
    },
    visitType$2: function(type, $name) {
      var t1 = this.sb;
      if ($name == null)
        t1.write$1(type);
      else
        t1.write$1(type.toString$0(0) + " " + this.createName$1($name));
    },
    visitGenericType$2: function(type, $name) {
      this.sb.write$1(type.get$name(type));
      if (!type.get$treatAsRaw()) {
        this.sb.write$1("<");
        this.visitTypes$2(type.typeArguments, null);
        this.sb.write$1(">");
      }
      if ($name != null) {
        this.sb.write$1(" ");
        this.sb.write$1(this.createName$1($name));
      }
    },
    visitFunctionType$2: function(type, $name) {
      var t1, needsComma, namedParameters, index, t2;
      type.returnType.accept$2(0, this, null);
      this.sb.write$1(" ");
      t1 = this.sb;
      if ($name != null)
        t1.write$1($name);
      else
        t1.write$1(this.createName$1("f"));
      this.sb.write$1("(");
      t1 = type.parameterTypes;
      this.visitTypes$2(t1, "a");
      needsComma = t1.length !== 0;
      t1 = type.optionalParameterTypes;
      if (t1.length !== 0) {
        if (needsComma)
          this.sb.write$1(", ");
        this.sb.write$1("[");
        this.visitTypes$2(t1, "a");
        this.sb.write$1("]");
        needsComma = true;
      }
      t1 = type.namedParameterTypes;
      if (t1.length !== 0) {
        if (needsComma)
          this.sb.write$1(", ");
        this.sb.write$1("{");
        namedParameters = type.namedParameters;
        for (needsComma = false, index = 0; index < namedParameters.length; ++index, needsComma = true) {
          if (needsComma) {
            t2 = this.sb;
            t2.toString;
            t2._contents += ", ";
          }
          if (index >= t1.length)
            return H.ioore(t1, index);
          J.accept$2$x(t1[index], this, namedParameters[index]);
        }
        this.sb.write$1("}");
      }
      this.sb.write$1(")");
    },
    $asDartTypeVisitor: function() {
      return [null, P.String];
    }
  }
}],
["deferred_load", "package:compiler/implementation/deferred_load.dart", , B, {
  "^": "",
  OutputUnit: {
    "^": "Object;imports<,name>",
    partFileName$1: function(compiler) {
      var t1, outPath, outName;
      t1 = compiler.outputUri;
      outPath = t1 != null ? t1._path : "out";
      outName = C.JSString_methods.substring$1(outPath, C.JSString_methods.lastIndexOf$1(outPath, "/") + 1);
      if (this.$eq(0, compiler.deferredLoadTask.mainOutputUnit))
        return outName;
      else
        return outName + "_" + H.S(this.name);
    },
    toString$0: function(_) {
      return "OutputUnit(" + H.S(this.name) + ")";
    },
    $eq: function(_, other) {
      var t1, t2, t3;
      if (other == null)
        return false;
      t1 = this.imports;
      t2 = t1.get$length(t1);
      t3 = other.get$imports();
      t3 = t3.get$length(t3);
      return (t2 == null ? t3 == null : t2 === t3) && t1.containsAll$1(other.get$imports());
    },
    get$hashCode: function(_) {
      var t1, sum, t2;
      for (t1 = this.imports, t1 = t1.get$iterator(t1), sum = 0; t1.moveNext$0();) {
        t2 = J.get$hashCode$(t1.get$current());
        if (typeof t2 !== "number")
          return H.iae(t2);
        sum = sum + t2 & 1073741823;
      }
      return sum;
    }
  },
  DeferredLoadTask: {
    "^": "CompilerTask;_fakeMainImport,mainOutputUnit,allOutputUnits,splitProgram,hunksToLoad,importDeferName,_elementToOutputUnit,_constantToOutputUnit,_allDeferredImports,_importedDeferredBy,_constantsDeferredBy,_mainElements,compiler,watch,profilerTag",
    get$name: function(_) {
      return "Deferred Loading";
    },
    get$backend: function() {
      return this.compiler.backend;
    },
    outputUnitForElement$1: function(element) {
      var t1, t2;
      if (!this.splitProgram)
        return this.mainOutputUnit;
      element = element.get$implementation(element);
      for (t1 = this._elementToOutputUnit; !t1.containsKey$1(element);) {
        if (element.get$enclosingElement() == null) {
          t1.$indexSet(0, element, this.mainOutputUnit);
          break;
        }
        t2 = element.get$enclosingElement();
        element = t2.get$implementation(t2);
      }
      return t1.$index(0, element);
    },
    outputUnitForConstant$1: function(constant) {
      if (!this.splitProgram)
        return this.mainOutputUnit;
      return this._constantToOutputUnit.$index(0, constant);
    },
    _addImportToOutputUnitOfElement$2: function(element, $import) {
      if ($import === this._fakeMainImport)
        this._elementToOutputUnit.$indexSet(0, element, this.mainOutputUnit);
      this._elementToOutputUnit.putIfAbsent$2(element, new B.DeferredLoadTask__addImportToOutputUnitOfElement_closure()).get$imports().add$1(0, $import);
    },
    _addImportToOutputUnitOfConstant$2: function(constant, $import) {
      if ($import === this._fakeMainImport)
        this._constantToOutputUnit.$indexSet(0, constant, this.mainOutputUnit);
      this._constantToOutputUnit.putIfAbsent$2(constant, new B.DeferredLoadTask__addImportToOutputUnitOfConstant_closure()).get$imports().add$1(0, $import);
    },
    _isImportDeferred$1: [function($import) {
      return this._allDeferredImports.containsKey$1($import);
    }, "call$1", "get$_isImportDeferred", 2, 0, 166],
    _markIfDeferred$2: function($import, library) {
      var metadataList, t1, t2, t3, t4, t5, t6, metadata, element, t7, maybePrefix;
      if ($import.isDeferred === true) {
        this._allDeferredImports.$indexSet(0, $import, library.tagMapping.$index(0, $import));
        return;
      }
      metadataList = $import.metadata;
      if (metadataList == null)
        return;
      t1 = new E.LinkIterator(null, metadataList);
      t1.$builtinTypeInfo = [H.getTypeArgumentByIndex(metadataList, 0)];
      t2 = this.compiler;
      t3 = this._allDeferredImports;
      t4 = library.tagMapping;
      t5 = $import.prefix;
      t6 = J.getInterceptor(t5);
      for (; t1.moveNext$0();) {
        metadata = t1._util_implementation$_current;
        metadata.ensureResolved$1(t2);
        element = metadata.get$value(metadata).computeType$1(t2).get$element();
        t7 = t2.deferredLibraryClass;
        if (element == null ? t7 == null : element === t7) {
          t3.$indexSet(0, $import, t4.$index(0, $import));
          maybePrefix = library.find$1(0, t6.toString$0(t5));
          if (maybePrefix != null && maybePrefix.get$kind(maybePrefix) === C.ElementKind_prefix_8)
            maybePrefix.markAsDeferred$1($import);
        }
      }
    },
    _isExplicitlyDeferred$2: function(element, library) {
      var imports, t1;
      if (element.get$isClassMember())
        element = element.get$enclosingClass();
      if (element.get$isGetter() || element.get$kind(element) === C.ElementKind_setter_0)
        element = H.interceptedTypeCast(element, "$isFunctionElement").get$abstractField();
      imports = library.importers.importers.$index(0, element);
      imports = imports != null ? imports : C.C_Link15;
      t1 = J.getInterceptor$asx(imports);
      if (t1.get$isEmpty(imports))
        return false;
      return t1.every$1(imports, this.get$_isImportDeferred());
    },
    _collectAllElementsAndConstantsResolvedFrom$4: function(element, elements, constants, isMirrorUsage) {
      var t1, t2, t3, t4, metadata, constant, cls;
      t1 = new B.DeferredLoadTask__collectAllElementsAndConstantsResolvedFrom_addConstants(elements, constants);
      t2 = new B.DeferredLoadTask__collectAllElementsAndConstantsResolvedFrom_collectDependencies(this, elements, t1);
      for (t3 = element.get$metadata(), t3.toString, t3 = H.setRuntimeTypeInfo(new E.LinkIterator(null, t3), [H.getTypeArgumentByIndex(t3, 0)]), t4 = this.compiler; t3.moveNext$0();) {
        metadata = t3._util_implementation$_current;
        constant = t4.backend.get$constants().getConstantForMetadata$1(metadata);
        if (constant != null)
          t1.call$1(constant);
      }
      t1 = element.kind;
      if (t1 === C.ElementKind_class_4) {
        t2 = new B.DeferredLoadTask__collectAllElementsAndConstantsResolvedFrom_addLiveInstanceMember(this, isMirrorUsage, t2);
        cls = element.get$declaration();
        cls.forEachLocalMember$1(t2);
        if (cls.get$implementation(cls) !== cls)
          cls.get$implementation(cls).forEachLocalMember$1(t2);
        for (t2 = cls.get$implementation(cls).get$allSupertypes(), t2.toString, t2 = H.setRuntimeTypeInfo(new E.LinkIterator(null, t2), [H.getTypeArgumentByIndex(t2, 0)]); t2.moveNext$0();) {
          t3 = t2._util_implementation$_current.get$element();
          elements.add$1(0, t3.get$implementation(t3));
        }
        elements.add$1(0, cls.get$implementation(cls));
      } else if (O.Elements_isStaticOrTopLevel(element) || t1 === C.ElementKind_generative_constructor_16 || element.get$isFactoryConstructor())
        t2.call$1(element);
      if (t1 === C.ElementKind_generative_constructor_16) {
        t1 = element.get$enclosingClass();
        this._collectAllElementsAndConstantsResolvedFrom$4(t1.get$implementation(t1), elements, constants, isMirrorUsage);
      }
    },
    _nonDeferredReachableLibraries$1: function(root) {
      var result = P.LinkedHashSet_LinkedHashSet(null, null, null, O.LibraryElement);
      new B.DeferredLoadTask__nonDeferredReachableLibraries_traverseLibrary(this, result).call$1(root);
      result.add$1(0, this.compiler.coreLibrary);
      return result;
    },
    _mapDependencies$3$isMirrorUsage: function(element, $import, isMirrorUsage) {
      var elements, constants, dependentElements, library, t1, dependency, imports, t2, t3;
      elements = this._importedDeferredBy.putIfAbsent$2($import, new B.DeferredLoadTask__mapDependencies_closure());
      constants = this._constantsDeferredBy.putIfAbsent$2($import, new B.DeferredLoadTask__mapDependencies_closure0());
      if (!isMirrorUsage && J.contains$1$asx(elements, element) === true)
        return;
      if ($import !== this._fakeMainImport && this._mainElements.contains$1(0, element))
        return;
      J.add$1$ax(elements, element);
      dependentElements = P.LinkedHashSet_LinkedHashSet(null, null, null, O.Element);
      this._collectAllElementsAndConstantsResolvedFrom$4(element, dependentElements, constants, isMirrorUsage);
      library = element.get$library();
      t1 = new P.LinkedHashSetIterator(dependentElements, dependentElements._modifications, null, null);
      t1.$builtinTypeInfo = [null];
      t1._cell = dependentElements._first;
      for (; t1.moveNext$0();) {
        dependency = t1._collection$_current;
        if (this._isExplicitlyDeferred$2(dependency, library)) {
          element = dependency.get$isClassMember() ? dependency.get$enclosingClass() : dependency;
          if (element.get$isGetter() || element.get$kind(element) === C.ElementKind_setter_0)
            element = H.interceptedTypeCast(element, "$isFunctionElement").get$abstractField();
          imports = library.importers.importers.$index(0, element);
          t2 = imports != null ? imports : C.C_Link15;
          t3 = new E.LinkIterator(null, t2);
          t3.$builtinTypeInfo = [H.getTypeArgumentByIndex(t2, 0)];
          for (; t3.moveNext$0();)
            this._mapDependencies$2(dependency, t3._util_implementation$_current);
        } else
          this._mapDependencies$2(dependency, $import);
      }
    },
    _mapDependencies$2: function(element, $import) {
      return this._mapDependencies$3$isMirrorUsage(element, $import, false);
    },
    _addMirrorElements$0: function() {
      var t1, t2, t3, t4, deferredImport, t5;
      t1 = new B.DeferredLoadTask__addMirrorElements_handleLibrary(this, new B.DeferredLoadTask__addMirrorElements_mapDependenciesIfResolved(this));
      for (t2 = this._allDeferredImports, t3 = H.setRuntimeTypeInfo(new P.LinkedHashMapKeyIterable(t2), [H.getTypeArgumentByIndex(t2, 0)]), t4 = t3._map, t3 = H.setRuntimeTypeInfo(new P.LinkedHashMapKeyIterator(t4, t4._modifications, null, null), [H.getTypeArgumentByIndex(t3, 0)]), t3._cell = t3._map._first; t3.moveNext$0();) {
        deferredImport = t3._collection$_current;
        t4 = this._nonDeferredReachableLibraries$1(t2.$index(0, deferredImport));
        t5 = new P.LinkedHashSetIterator(t4, t4._modifications, null, null);
        t5.$builtinTypeInfo = [null];
        t5._cell = t4._first;
        for (; t5.moveNext$0();)
          t1.call$2(t5._collection$_current, deferredImport);
      }
    },
    _assignNamesToOutputUnits$1: function(allOutputUnits) {
      var t1, t2, t3, t4, t5, sortedOutputUnits, $import, t6, t7, lastNumberOfImports, currentLastList, outputUnit;
      t1 = new B.DeferredLoadTask__assignNamesToOutputUnits_makeUnique();
      t2 = new B.DeferredLoadTask__assignNamesToOutputUnits_computeImportDeferName(this, P.LinkedHashSet_LinkedHashSet(null, null, null, P.String), t1);
      t1 = new B.DeferredLoadTask__assignNamesToOutputUnits_computeOutputUnitName(this, t1, P.LinkedHashSet_LinkedHashSet(null, null, null, P.String), P.LinkedHashMap_LinkedHashMap(null, null, null, B.OutputUnit, P.String));
      for (t3 = this._allDeferredImports, t4 = H.setRuntimeTypeInfo(new P.LinkedHashMapKeyIterable(t3), [H.getTypeArgumentByIndex(t3, 0)]), t5 = t4._map, t4 = H.setRuntimeTypeInfo(new P.LinkedHashMapKeyIterator(t5, t5._modifications, null, null), [H.getTypeArgumentByIndex(t4, 0)]), t4._cell = t4._map._first; t4.moveNext$0();)
        t2.call$1(t4._collection$_current);
      for (t2 = H.setRuntimeTypeInfo(new P.LinkedHashSetIterator(allOutputUnits, allOutputUnits._modifications, null, null), [null]), t2._cell = t2._set._first; t2.moveNext$0();)
        t1.call$1(t2._collection$_current);
      sortedOutputUnits = P.List_List$from(allOutputUnits, true, null);
      H.IterableMixinWorkaround_sortList(sortedOutputUnits, new B.DeferredLoadTask__assignNamesToOutputUnits_closure());
      for (t1 = H.setRuntimeTypeInfo(new P.LinkedHashMapKeyIterable(t3), [H.getTypeArgumentByIndex(t3, 0)]), t2 = t1._map, t1 = H.setRuntimeTypeInfo(new P.LinkedHashMapKeyIterator(t2, t2._modifications, null, null), [H.getTypeArgumentByIndex(t1, 0)]), t1._cell = t1._map._first, t2 = this.mainOutputUnit, t3 = this.hunksToLoad, t4 = this.importDeferName, t5 = this._fakeMainImport; t1.moveNext$0();) {
        $import = t1._collection$_current;
        if (J.$eq($import, t5))
          continue;
        t6 = t4.$index(0, $import);
        t7 = [];
        t7.$builtinTypeInfo = [[P.List, B.OutputUnit]];
        t3.$indexSet(0, t6, t7);
        t6 = new H.ListIterator(sortedOutputUnits, sortedOutputUnits.length, 0, null);
        t6.$builtinTypeInfo = [H.getTypeArgumentByIndex(sortedOutputUnits, 0)];
        lastNumberOfImports = 0;
        currentLastList = null;
        for (; t6.moveNext$0();) {
          outputUnit = t6.__internal$_current;
          if (J.$eq(outputUnit, t2))
            continue;
          if (outputUnit.get$imports().contains$1(0, $import) === true) {
            t7 = outputUnit.get$imports();
            t7 = t7.get$length(t7);
            if (t7 == null ? lastNumberOfImports != null : t7 !== lastNumberOfImports) {
              t7 = outputUnit.get$imports();
              lastNumberOfImports = t7.get$length(t7);
              currentLastList = [];
              currentLastList.$builtinTypeInfo = [B.OutputUnit];
              J.add$1$ax(t3.$index(0, t4.$index(0, $import)), currentLastList);
            }
            currentLastList.push(outputUnit);
          }
        }
      }
    },
    onResolutionComplete$1: function(main) {
      var mainLibrary;
      if (!this.splitProgram) {
        this.allOutputUnits.add$1(0, this.mainOutputUnit);
        return;
      }
      if (main == null)
        return;
      mainLibrary = main.get$library();
      this._importedDeferredBy = P.LinkedHashMap_LinkedHashMap(null, null, null, Y.Import, [P.Set, O.Element]);
      this._constantsDeferredBy = P.LinkedHashMap_LinkedHashMap(null, null, null, Y.Import, [P.Set, K.Constant]);
      this._importedDeferredBy.$indexSet(0, this._fakeMainImport, this._mainElements);
      this.measureElement$2(mainLibrary, new B.DeferredLoadTask_onResolutionComplete_closure(this));
    },
    ensureMetadataResolved$1: function(compiler) {
      var t1, t2, usedPrefixes, prefixDeferredImport, library, backend, t3;
      t1 = {};
      t2 = compiler.mainApp;
      if (t2 == null)
        return;
      this._allDeferredImports.$indexSet(0, this._fakeMainImport, t2);
      t1.lastDeferred_0 = null;
      usedPrefixes = H.setRuntimeTypeInfo(new N.Setlet(C.C__SetletMarker, null), [P.String]);
      prefixDeferredImport = P.LinkedHashMap_LinkedHashMap(null, null, null, P.String, Y.Import);
      for (t2 = compiler.libraryLoader.libraryCanonicalUriMap, t2 = t2.get$values(t2), t2 = H.setRuntimeTypeInfo(new H.MappedIterator(null, J.get$iterator$ax(t2._iterable), t2._f), [H.getTypeArgumentByIndex(t2, 0), H.getTypeArgumentByIndex(t2, 1)]); t2.moveNext$0();) {
        library = t2.__internal$_current;
        compiler.withCurrentElement$2(library, new B.DeferredLoadTask_ensureMetadataResolved_closure(t1, this, compiler, usedPrefixes, prefixDeferredImport, library));
      }
      backend = compiler.backend;
      if (this.splitProgram && !!J.getInterceptor(backend).$isJavaScriptBackend) {
        t2 = compiler.globalDependencies;
        backend.enqueueInResolution$2(backend.find$2(0, backend.get$jsHelperLibrary(), "checkDeferredIsLoaded"), t2);
        t3 = backend.compiler;
        backend.enqueueClass$3(t3.enqueuer.resolution, t3.stringClass, t2);
      }
      if (this.splitProgram && !!J.getInterceptor(backend).$isDartBackend) {
        compiler.reportDiagnosticInternal$4(t1.lastDeferred_0, C.MessageKind_aVU, C.Map_empty, C.Diagnostic_2_warning);
        this.splitProgram = false;
      }
    },
    deferredPrefixElement$2: function(send, elements) {
      var element, identifier, maybePrefix;
      element = elements.$index(0, send);
      if (element != null && element.get$isDeferredLoaderGetter())
        return;
      identifier = new B.DeferredLoadTask_deferredPrefixElement_firstNode().call$1(send).asIdentifier$0();
      if (identifier == null)
        return;
      maybePrefix = elements.$index(0, identifier);
      if (maybePrefix != null && maybePrefix.get$kind(maybePrefix) === C.ElementKind_prefix_8)
        if (maybePrefix.get$isDeferred())
          return maybePrefix;
      return;
    }
  },
  DeferredLoadTask__addImportToOutputUnitOfElement_closure: {
    "^": "Closure:23;",
    call$0: function() {
      return new B.OutputUnit(H.setRuntimeTypeInfo(new N.Setlet(C.C__SetletMarker, null), [Y.Import]), null);
    },
    $isFunction: true
  },
  DeferredLoadTask__addImportToOutputUnitOfConstant_closure: {
    "^": "Closure:23;",
    call$0: function() {
      return new B.OutputUnit(H.setRuntimeTypeInfo(new N.Setlet(C.C__SetletMarker, null), [Y.Import]), null);
    },
    $isFunction: true
  },
  DeferredLoadTask__collectAllElementsAndConstantsResolvedFrom_addConstants: {
    "^": "Closure:167;elements_0,constants_1",
    call$1: function(constant) {
      var t1 = this.constants_1;
      if (t1.contains$1(0, constant) === true)
        return;
      t1.add$1(0, constant);
      if (!!J.getInterceptor(constant).$isConstructedConstant)
        this.elements_0.add$1(0, constant.type.get$element());
      H.IterableMixinWorkaround_forEach(constant.getDependencies$0(), this);
    },
    $isFunction: true
  },
  DeferredLoadTask__collectAllElementsAndConstantsResolvedFrom_collectDependencies: {
    "^": "Closure:47;this_2,elements_3,addConstants_4",
    call$1: function(element) {
      var t1, treeElements, t2, dependency;
      t1 = J.getInterceptor(element);
      if (!t1.$isAstElement)
        return;
      if (!t1.$isTypedefElement && !this.this_2.compiler.enqueuer.resolution.resolvedElements.contains$1(0, element.get$analyzableElement().get$declaration()))
        return;
      treeElements = element.get$resolvedAst().elements;
      t1 = treeElements._resolution$_elements;
      t1 = J.get$iterator$ax(t1 != null ? t1 : C.List_empty8);
      t2 = this.elements_3;
      for (; t1.moveNext$0();) {
        dependency = t1.get$current();
        if (O.Elements_isLocal(dependency) && !dependency.get$isFunction())
          continue;
        if (dependency.get$isErroneous())
          continue;
        if (dependency.get$kind(dependency) === C.ElementKind_type_variable_128)
          continue;
        t2.add$1(0, dependency);
      }
      t1 = treeElements._constants;
      if (t1 != null)
        t1.forEach$1(0, new B.DeferredLoadTask__collectAllElementsAndConstantsResolvedFrom_collectDependencies_closure(this.this_2, this.addConstants_4, treeElements));
      t1 = treeElements._otherDependencies;
      t2.addAll$1(0, t1 != null ? t1 : C.List_empty8);
    },
    $isFunction: true
  },
  DeferredLoadTask__collectAllElementsAndConstantsResolvedFrom_collectDependencies_closure: {
    "^": "Closure:168;this_5,addConstants_6,treeElements_7",
    call$2: function(node, _) {
      this.addConstants_6.call$1(this.this_5.compiler.backend.get$constants().getConstantForNode$2(node, this.treeElements_7));
    },
    $isFunction: true
  },
  DeferredLoadTask__collectAllElementsAndConstantsResolvedFrom_addLiveInstanceMember: {
    "^": "Closure:47;this_8,isMirrorUsage_9,collectDependencies_10",
    call$1: function(element) {
      if (!this.this_8.compiler.enqueuer.resolution.isLive$1(element))
        return;
      if (!this.isMirrorUsage_9 && !element.get$isInstanceMember())
        return;
      this.collectDependencies_10.call$1(J.get$implementation$x(element));
    },
    $isFunction: true
  },
  DeferredLoadTask__nonDeferredReachableLibraries_traverseLibrary: {
    "^": "Closure:129;this_0,result_1",
    call$1: function(library) {
      var t1 = this.result_1;
      if (t1.contains$1(0, library))
        return;
      t1.add$1(0, library);
      t1 = new B.DeferredLoadTask__nonDeferredReachableLibraries_traverseLibrary_iterateTags(this.this_0, this);
      t1.call$1(library);
      if (library.get$isPatched())
        t1.call$1(library.get$implementation(library));
    },
    $isFunction: true
  },
  DeferredLoadTask__nonDeferredReachableLibraries_traverseLibrary_iterateTags: {
    "^": "Closure:79;this_2,traverseLibrary_3",
    call$1: function(library) {
      var t1, t2, t3, t4, tag, t5;
      for (t1 = library.get$tags(), t1 = H.setRuntimeTypeInfo(new H.ListIterator(t1, t1.length, 0, null), [H.getTypeArgumentByIndex(t1, 0)]), t2 = this.this_2._allDeferredImports, t3 = library.tagMapping, t4 = this.traverseLibrary_3; t1.moveNext$0();) {
        tag = t1.__internal$_current;
        t5 = J.getInterceptor(tag);
        if (!t5.$isLibraryDependency)
          continue;
        if (!(!!t5.$isImport && t2.containsKey$1(tag)))
          t4.call$1(t3.$index(0, tag));
      }
    },
    $isFunction: true
  },
  DeferredLoadTask__mapDependencies_closure: {
    "^": "Closure:23;",
    call$0: function() {
      return P.LinkedHashSet_LinkedHashSet(null, null, null, O.Element);
    },
    $isFunction: true
  },
  DeferredLoadTask__mapDependencies_closure0: {
    "^": "Closure:23;",
    call$0: function() {
      return P.LinkedHashSet_LinkedHashSet(null, null, null, K.Constant);
    },
    $isFunction: true
  },
  DeferredLoadTask__addMirrorElements_mapDependenciesIfResolved: {
    "^": "Closure:169;this_0",
    call$2: function(element, deferredImport) {
      var t1;
      if (!!J.getInterceptor(element).$isAnalyzableElementX && !element.get$hasTreeElements())
        return;
      t1 = this.this_0;
      if (t1.compiler.backend.isAccessibleByReflection$1(element))
        t1._mapDependencies$3$isMirrorUsage(element, deferredImport, true);
    },
    $isFunction: true
  },
  DeferredLoadTask__addMirrorElements_handleLibrary: {
    "^": "Closure:170;this_1,mapDependenciesIfResolved_2",
    call$2: function(library, deferredImport) {
      var t1, t2, t3, metadata, constant, t4, t5;
      library.get$implementation(library).forEachLocalMember$1(new B.DeferredLoadTask__addMirrorElements_handleLibrary_closure(this.mapDependenciesIfResolved_2, deferredImport));
      for (t1 = library.get$metadata(), t1.toString, t1 = H.setRuntimeTypeInfo(new E.LinkIterator(null, t1), [H.getTypeArgumentByIndex(t1, 0)]), t2 = this.this_1, t3 = t2.compiler; t1.moveNext$0();) {
        metadata = t1._util_implementation$_current;
        constant = t3.backend.get$constants().getConstantForMetadata$1(metadata);
        if (constant != null)
          t2._mapDependencies$2(constant.computeType$1(t3).get$element(), deferredImport);
      }
      for (t1 = library.get$tags(), t1 = H.setRuntimeTypeInfo(new H.ListIterator(t1, t1.length, 0, null), [H.getTypeArgumentByIndex(t1, 0)]); t1.moveNext$0();) {
        t4 = t1.__internal$_current.get$metadata();
        t4.toString;
        t5 = new E.LinkIterator(null, t4);
        t5.$builtinTypeInfo = [H.getTypeArgumentByIndex(t4, 0)];
        for (; t5.moveNext$0();) {
          metadata = t5._util_implementation$_current;
          constant = t3.backend.get$constants().getConstantForMetadata$1(metadata);
          if (constant != null)
            t2._mapDependencies$2(constant.computeType$1(t3).get$element(), deferredImport);
        }
      }
    },
    $isFunction: true
  },
  DeferredLoadTask__addMirrorElements_handleLibrary_closure: {
    "^": "Closure:77;mapDependenciesIfResolved_3,deferredImport_4",
    call$1: function(element) {
      this.mapDependenciesIfResolved_3.call$2(element, this.deferredImport_4);
    },
    $isFunction: true
  },
  DeferredLoadTask__assignNamesToOutputUnits_makeUnique: {
    "^": "Closure:171;",
    call$2: function(suggestedName, usedNames) {
      var result, counter;
      if (usedNames.contains$1(0, suggestedName))
        for (result = suggestedName, counter = 0; usedNames.contains$1(0, result);) {
          ++counter;
          result = H.S(suggestedName) + counter;
        }
      else
        result = suggestedName;
      usedNames.add$1(0, result);
      return result;
    },
    $isFunction: true
  },
  DeferredLoadTask__assignNamesToOutputUnits_computeImportDeferName: {
    "^": "Closure:172;this_0,usedImportNames_1,makeUnique_2",
    call$1: function($import) {
      var t1, result, metadatas, t2, t3, metadata, element, t4;
      t1 = this.this_0;
      if ($import === t1._fakeMainImport)
        result = "main";
      else if ($import.isDeferred === true)
        result = J.toString$0($import.prefix);
      else {
        metadatas = $import.metadata;
        metadatas.toString;
        t2 = H.setRuntimeTypeInfo(new E.LinkIterator(null, metadatas), [H.getTypeArgumentByIndex(metadatas, 0)]);
        t3 = t1.compiler;
        while (true) {
          if (!t2.moveNext$0()) {
            result = null;
            break;
          }
          metadata = t2._util_implementation$_current;
          metadata.ensureResolved$1(t3);
          element = metadata.get$value(metadata).computeType$1(t3).get$element();
          t4 = t3.deferredLibraryClass;
          if (element == null ? t4 == null : element === t4) {
            t2 = metadata.value.get$fields();
            if (0 >= t2.length)
              return H.ioore(t2, 0);
            result = J.get$value$x(t2[0]).slowToString$0();
            break;
          }
        }
      }
      t1.importDeferName.$indexSet(0, $import, this.makeUnique_2.call$2(result, this.usedImportNames_1));
    },
    $isFunction: true
  },
  DeferredLoadTask__assignNamesToOutputUnits_computeOutputUnitName: {
    "^": "Closure:173;this_3,makeUnique_4,usedOutputUnitNames_5,generatedNames_6",
    call$1: function(outputUnit) {
      var t1, t2, importNames, suggestedName;
      t1 = this.generatedNames_6;
      if (t1.$index(0, outputUnit) != null)
        return;
      t2 = outputUnit.imports;
      importNames = H.MappedIterable_MappedIterable(t2, new B.DeferredLoadTask__assignNamesToOutputUnits_computeOutputUnitName_closure(this.this_3), H.getRuntimeTypeArgument(t2, "IterableBase", 0), null);
      suggestedName = importNames.join$1(0, "_");
      if (suggestedName.length > 15)
        suggestedName = H.MappedIterable_MappedIterable(importNames, new B.DeferredLoadTask__assignNamesToOutputUnits_computeOutputUnitName_closure0(), H.getRuntimeTypeArgument(importNames, "IterableBase", 0), null).join$1(0, "_");
      if (suggestedName.length > 15)
        suggestedName = C.JSString_methods.substring$2(suggestedName, 0, 15);
      t2 = this.makeUnique_4.call$2(suggestedName, this.usedOutputUnitNames_5);
      outputUnit.name = t2;
      t1.$indexSet(0, outputUnit, t2);
    },
    $isFunction: true
  },
  DeferredLoadTask__assignNamesToOutputUnits_computeOutputUnitName_closure: {
    "^": "Closure:13;this_7",
    call$1: function($import) {
      return this.this_7.importDeferName.$index(0, $import);
    },
    $isFunction: true
  },
  DeferredLoadTask__assignNamesToOutputUnits_computeOutputUnitName_closure0: {
    "^": "Closure:13;",
    call$1: function($name) {
      var t1 = J.getInterceptor$asx($name);
      return t1.substring$2($name, 0, P.min(2, t1.get$length($name)));
    },
    $isFunction: true
  },
  DeferredLoadTask__assignNamesToOutputUnits_closure: {
    "^": "Closure:19;",
    call$2: function(a, b) {
      var t1, t2;
      t1 = b.get$imports();
      t1 = t1.get$length(t1);
      t2 = a.get$imports();
      t2 = t2.get$length(t2);
      if (typeof t1 !== "number")
        return t1.$sub();
      if (typeof t2 !== "number")
        return H.iae(t2);
      return t1 - t2;
    },
    $isFunction: true
  },
  DeferredLoadTask_onResolutionComplete_closure: {
    "^": "Closure:23;this_0",
    call$0: function() {
      var t1, t2, t3, t4, allConstants, $import, constant;
      t1 = this.this_0;
      t2 = t1.compiler;
      t3 = t1._fakeMainImport;
      t1._mapDependencies$2(t2.mainFunction, t3);
      t4 = t2.globalDependencies.treeElements._otherDependencies;
      t4 = J.get$iterator$ax(t4 != null ? t4 : C.List_empty8);
      for (; t4.moveNext$0();)
        t1._mapDependencies$2(t4.get$current(), t3);
      if (t2.mirrorsLibrary != null)
        t1._addMirrorElements$0();
      allConstants = P.LinkedHashSet_LinkedHashSet(null, null, null, K.Constant);
      for (t2 = t1._importedDeferredBy, t2.toString, t2 = H.setRuntimeTypeInfo(new P.LinkedHashMapKeyIterable(t2), [H.getTypeArgumentByIndex(t2, 0)]), t3 = t2._map, t2 = H.setRuntimeTypeInfo(new P.LinkedHashMapKeyIterator(t3, t3._modifications, null, null), [H.getTypeArgumentByIndex(t2, 0)]), t2._cell = t2._map._first; t2.moveNext$0();) {
        $import = t2._collection$_current;
        for (t3 = J.get$iterator$ax(t1._importedDeferredBy.$index(0, $import)); t3.moveNext$0();)
          t1._addImportToOutputUnitOfElement$2(t3.get$current(), $import);
        for (t3 = J.get$iterator$ax(t1._constantsDeferredBy.$index(0, $import)); t3.moveNext$0();) {
          constant = t3.get$current();
          allConstants.add$1(0, constant);
          t1._addImportToOutputUnitOfConstant$2(constant, $import);
        }
      }
      t1._importedDeferredBy = null;
      t1._constantsDeferredBy = null;
      for (t2 = t1._elementToOutputUnit, t2 = t2.get$values(t2), t2 = H.setRuntimeTypeInfo(new H.MappedIterator(null, J.get$iterator$ax(t2._iterable), t2._f), [H.getTypeArgumentByIndex(t2, 0), H.getTypeArgumentByIndex(t2, 1)]), t3 = t1.allOutputUnits; t2.moveNext$0();)
        t3.add$1(0, t2.__internal$_current);
      for (t2 = t1._constantToOutputUnit, t2 = t2.get$values(t2), t2 = H.setRuntimeTypeInfo(new H.MappedIterator(null, J.get$iterator$ax(t2._iterable), t2._f), [H.getTypeArgumentByIndex(t2, 0), H.getTypeArgumentByIndex(t2, 1)]); t2.moveNext$0();)
        t3.add$1(0, t2.__internal$_current);
      t1._assignNamesToOutputUnits$1(t3);
    },
    $isFunction: true
  },
  DeferredLoadTask_ensureMetadataResolved_closure: {
    "^": "Closure:23;box_0,this_1,compiler_2,usedPrefixes_3,prefixDeferredImport_4,library_5",
    call$0: function() {
      var t1, t2, t3, t4, t5, t6, t7, t8, tag, t9, prefix, previousDeferredImport, isDeferred, t10;
      t1 = this.prefixDeferredImport_4;
      t1.clear$0(0);
      t2 = this.usedPrefixes_3;
      t2._setlet$_contents = C.C__SetletMarker;
      t2._extra = null;
      for (t3 = this.library_5, t4 = t3.get$tags(), t4 = H.setRuntimeTypeInfo(new H.ListIterator(t4, t4.length, 0, null), [H.getTypeArgumentByIndex(t4, 0)]), t5 = this.this_1, t6 = t5._allDeferredImports, t7 = this.box_0, t8 = this.compiler_2; t4.moveNext$0();) {
        tag = t4.__internal$_current;
        if (!J.getInterceptor(tag).$isImport)
          continue;
        t5._markIfDeferred$2(tag, t3);
        t9 = tag.prefix;
        prefix = t9 != null ? J.toString$0(t9) : null;
        previousDeferredImport = t1.$index(0, prefix);
        isDeferred = t6.containsKey$1(tag);
        if (isDeferred) {
          if (prefix == null)
            t8.reportDiagnosticInternal$4(tag, C.MessageKind_kWM, C.Map_empty, C.Diagnostic_1_error);
          else
            t1.$indexSet(0, prefix, tag);
          t5.splitProgram = true;
          t7.lastDeferred_0 = tag;
        }
        if (prefix != null) {
          t9 = previousDeferredImport == null;
          if (t9)
            t10 = isDeferred && t2.contains$1(0, prefix) === true;
          else
            t10 = true;
          if (t10)
            t8.reportDiagnosticInternal$4((!t9 ? previousDeferredImport : tag).get$prefix(), C.MessageKind_eQ2, C.Map_empty, C.Diagnostic_1_error);
          t2.add$1(0, prefix);
        }
      }
    },
    $isFunction: true
  },
  DeferredLoadTask_deferredPrefixElement_firstNode: {
    "^": "Closure:174;",
    call$1: function(node) {
      var receiverFirst;
      if (!J.getInterceptor(node).$isSend)
        return node;
      else {
        receiverFirst = this.call$1(node.receiver);
        if (receiverFirst != null)
          return receiverFirst;
        else
          return this.call$1(node.selector);
      }
    },
    $isFunction: true
  }
}],
["dump_info", "package:compiler/implementation/dump_info.dart", , E, {
  "^": "",
  IdMapper: {
    "^": "Object;_idToElement<,_elementToId,_idCounter,name>",
    get$elements: function(_) {
      return this._elementToId.get$keys();
    },
    add$1: function(_, e) {
      var t1 = this._elementToId;
      if (t1.containsKey$1(e))
        return this.name + ("/" + H.S(t1.$index(0, e)));
      this._idToElement.$indexSet(0, this._idCounter, e);
      t1.$indexSet(0, e, this._idCounter);
      t1 = ++this._idCounter;
      return this.name + ("/" + (t1 - 1));
    }
  },
  GroupedIdMapper: {
    "^": "Object;_library,_typedef,_field,_class,_function,_outputUnit",
    _toJson$1: function(elementToJson) {
      var json, m, t1, mapper, innerMapper;
      json = P.LinkedHashMap_LinkedHashMap$_empty(null, null);
      m = [this._library, this._typedef, this._field, this._class, this._function];
      for (t1 = H.setRuntimeTypeInfo(new H.ListIterator(m, 5, 0, null), [H.getTypeArgumentByIndex(m, 0)]); t1.moveNext$0();) {
        mapper = t1.__internal$_current;
        innerMapper = P.LinkedHashMap_LinkedHashMap$_empty(null, null);
        mapper.get$_idToElement().forEach$1(0, new E.GroupedIdMapper__toJson_closure(elementToJson, innerMapper));
        json.$indexSet(0, mapper.name, innerMapper);
      }
      return json;
    }
  },
  GroupedIdMapper__toJson_closure: {
    "^": "Closure:19;elementToJson_0,innerMapper_1",
    call$2: function(k, v) {
      var elementJson = this.elementToJson_0.process$1(v);
      if (elementJson != null)
        this.innerMapper_1.$indexSet(0, H.S(k), elementJson);
    },
    $isFunction: true
  },
  ElementToJsonVisitor: {
    "^": "ElementVisitor;mapper,compiler<,jsonCache,codeCache,programSize,compilationMoment,dart2jsVersion,compilationDuration,dumpInfoDuration",
    process$1: function(element) {
      return this.jsonCache.putIfAbsent$2(element, new E.ElementToJsonVisitor_process_closure(this, element));
    },
    idOf$1: function(element) {
      var t1 = this.jsonCache;
      if (t1.containsKey$1(element) && t1.$index(0, element) != null)
        return J.$index$asx(t1.$index(0, element), "id");
      else
        return;
    },
    visitElement$1: function(element) {
      return;
    },
    visitConstructorBodyElement$1: function(e) {
      return this.visitFunctionElement$1(e.$constructor);
    },
    visitLibraryElement$1: function(element) {
      var id, children, libname, size, contentsOfLibrary;
      id = this.mapper._library.add$1(0, element);
      children = H.setRuntimeTypeInfo([], [P.String]);
      libname = element.getLibraryName$0();
      if (libname === "")
        libname = "<unnamed>";
      size = this.compiler.dumpInfoTask.sizeOf$1(element);
      contentsOfLibrary = element.get$isPatched() ? element.modelx$PatchMixin$patch : element;
      contentsOfLibrary.forEachLocalMember$1(new E.ElementToJsonVisitor_visitLibraryElement_closure(this, children));
      if (children.length === 0 && this.compiler.dumpInfoTask.selectorsFromElement.containsKey$1(element) !== true)
        return;
      return P.LinkedHashMap_LinkedHashMap$_literal(["kind", "library", "name", libname, "size", size, "id", id, "children", children], null, null);
    },
    visitTypedefElement$1: function(element) {
      var id, t1;
      id = this.mapper._typedef.add$1(0, element);
      t1 = element.alias;
      return t1 == null ? null : P.LinkedHashMap_LinkedHashMap$_literal(["id", id, "type", J.toString$0(t1), "kind", "typedef", "name", element.name], null, null);
    },
    visitFieldElement$1: function(element) {
      var t1, id, children, emittedCode, inferredType, size, code, t2, childJson, t3, outputUnit;
      t1 = this.mapper;
      id = t1._field.add$1(0, element);
      children = [];
      emittedCode = this.compiler.dumpInfoTask.codeOf$1(element);
      inferredType = this.compiler.typesTask.getGuaranteedTypeOfElement$1(element);
      if (inferredType == null || inferredType.get$isEmpty(inferredType) || (element.get$modifiers().flags & 16) !== 0)
        return;
      size = this.compiler.dumpInfoTask.sizeOf$1(element);
      if (emittedCode != null) {
        code = emittedCode._contents;
        if (typeof size !== "number")
          return size.$add();
        size += code.length;
      } else
        code = null;
      for (t2 = element.nestedClosures, t2 = H.setRuntimeTypeInfo(new H.ListIterator(t2, t2.length, 0, null), [H.getTypeArgumentByIndex(t2, 0)]); t2.moveNext$0();) {
        childJson = this.process$1(t2.__internal$_current);
        if (childJson != null) {
          children.push(childJson.$index(0, "id"));
          if (childJson.containsKey$1("size") === true) {
            t3 = childJson.$index(0, "size");
            if (typeof size !== "number")
              return size.$add();
            if (typeof t3 !== "number")
              return H.iae(t3);
            size += t3;
          }
        }
      }
      outputUnit = this.compiler.deferredLoadTask.outputUnitForElement$1(element);
      return P.LinkedHashMap_LinkedHashMap$_literal(["id", id, "kind", "field", "type", J.toString$0(element.get$type(element)), "inferredType", J.toString$0(inferredType), "name", element.name, "children", children, "size", size, "code", code, "outputUnit", t1._outputUnit.add$1(0, outputUnit)], null, null);
    },
    visitClassElement$1: function(element) {
      var t1, t2, id, children, modifiers, outputUnit;
      t1 = {};
      t2 = this.mapper;
      id = t2._class.add$1(0, element);
      children = [];
      t1.size_0 = this.compiler.dumpInfoTask.sizeOf$1(element);
      if (!this.compiler.backend.get$emitter().neededClasses.contains$1(0, element))
        return;
      modifiers = P.LinkedHashMap_LinkedHashMap$_literal(["abstract", (element.get$modifiers().flags & 2) !== 0], null, null);
      element.forEachLocalMember$1(new E.ElementToJsonVisitor_visitClassElement_closure(t1, this, children));
      outputUnit = this.compiler.deferredLoadTask.outputUnitForElement$1(element);
      return P.LinkedHashMap_LinkedHashMap$_literal(["name", element.name, "size", t1.size_0, "kind", "class", "modifiers", modifiers, "children", children, "id", id, "outputUnit", t2._outputUnit.add$1(0, outputUnit)], null, null);
    },
    visitFunctionElement$1: function(element) {
      var t1, id, t2, $name, children, parameters, emittedCode, size, modifiers, enclosingElement, kind, t3, signature, returnType, inferredReturnType, sideEffects, code, child, outputUnit;
      t1 = this.mapper;
      id = t1._function.add$1(0, element);
      t2 = J.getInterceptor$x(element);
      $name = t2.get$name(element);
      children = [];
      parameters = [];
      emittedCode = this.compiler.dumpInfoTask.codeOf$1(element);
      size = this.compiler.dumpInfoTask.sizeOf$1(element);
      modifiers = P.LinkedHashMap_LinkedHashMap$_literal(["static", element.get$isStatic(), "const", element.get$isConst(), "factory", element.get$isFactoryConstructor(), "external", element.get$isPatched()], null, null);
      enclosingElement = element.get$enclosingElement();
      if (enclosingElement.get$kind(enclosingElement) === C.ElementKind_field_1 || enclosingElement.get$isFunction() || element.get$isClosure() || enclosingElement.kind === C.ElementKind_generative_constructor_16 || enclosingElement.get$isFactoryConstructor()) {
        $name = "<unnamed>";
        kind = "closure";
      } else
        kind = enclosingElement.kind === C.ElementKind_class_4 ? "method" : "function";
      if (element.get$isConstructor()) {
        if (J.$eq($name, "")) {
          t3 = element.get$enclosingElement();
          H.S(t3.get$name(t3));
        } else {
          t3 = element.get$enclosingElement();
          H.S(t3.get$name(t3));
          H.S(element.name);
        }
        kind = "constructor";
      }
      if (emittedCode != null) {
        signature = element.get$functionSignature();
        returnType = J.toString$0(signature.get$type(signature).returnType);
        signature.forEachParameter$1(new E.ElementToJsonVisitor_visitFunctionElement_closure(this, parameters));
        inferredReturnType = J.toString$0(this.compiler.typesTask.getGuaranteedReturnTypeOfElement$1(element));
        sideEffects = J.toString$0(this.compiler.world.getSideEffectsOfElement$1(element));
        code = emittedCode._contents;
      } else {
        inferredReturnType = null;
        returnType = null;
        sideEffects = null;
        code = "";
      }
      if (!!t2.$isMemberElement)
        for (t2 = element.get$nestedClosures(), t2 = H.setRuntimeTypeInfo(new H.ListIterator(t2, t2.length, 0, null), [H.getTypeArgumentByIndex(t2, 0)]); t2.moveNext$0();) {
          child = this.process$1(t2.__internal$_current);
          if (child != null) {
            children.push(child.$index(0, "id"));
            t3 = child.$index(0, "size");
            if (typeof size !== "number")
              return size.$add();
            if (typeof t3 !== "number")
              return H.iae(t3);
            size += t3;
          }
        }
      if (size === 0 && this.compiler.dumpInfoTask.selectorsFromElement.containsKey$1(element) !== true)
        return;
      outputUnit = this.compiler.deferredLoadTask.outputUnitForElement$1(element);
      return P.LinkedHashMap_LinkedHashMap$_literal(["kind", kind, "name", $name, "id", id, "modifiers", modifiers, "children", children, "size", size, "returnType", returnType, "inferredReturnType", inferredReturnType, "parameters", parameters, "sideEffects", sideEffects, "code", code, "type", J.toString$0(element.get$type(element)), "outputUnit", t1._outputUnit.add$1(0, outputUnit)], null, null);
    },
    ElementToJsonVisitor$1: function(compiler) {
      var backend, t1, t2;
      this.compiler = compiler;
      backend = compiler.backend;
      if (!!J.getInterceptor(backend).$isJavaScriptBackend) {
        t1 = backend.emitter.outputBuffers;
        this.programSize = t1.get$values(t1).fold$2(0, 0, new E.ElementToJsonVisitor_closure());
      } else
        this.programSize = compiler.assembledCode.length;
      t1 = new P.DateTime(Date.now(), false);
      t1.DateTime$_now$0();
      this.compilationMoment = t1;
      t1 = compiler.buildId;
      this.dart2jsVersion = t1 !== "build number could not be determined" ? t1 : null;
      t1 = compiler.totalCompileTime.get$elapsedTicks();
      t2 = $.Stopwatch__frequency;
      if (typeof t2 !== "number")
        return H.iae(t2);
      this.compilationDuration = P.Duration$(0, 0, C.JSInt_methods.$tdiv(t1 * 1000000, t2), 0, 0, 0);
      for (t1 = compiler.libraryLoader.libraryCanonicalUriMap, t1 = t1.get$values(t1), t1 = P.List_List$from(t1, true, H.getRuntimeTypeArgument(t1, "IterableBase", 0)), t1 = H.setRuntimeTypeInfo(new H.ListIterator(t1, t1.length, 0, null), [H.getTypeArgumentByIndex(t1, 0)]); t1.moveNext$0();)
        J.accept$1$x(t1.__internal$_current, this);
      t1 = new P.DateTime(Date.now(), false);
      t1.DateTime$_now$0();
      this.dumpInfoDuration = t1.difference$1(this.compilationMoment);
    },
    $asElementVisitor: function() {
      return [[P.Map, P.String, null]];
    },
    static: {ElementToJsonVisitor$: function(compiler) {
        var t1 = new E.ElementToJsonVisitor(new E.GroupedIdMapper(H.setRuntimeTypeInfo(new E.IdMapper(P.LinkedHashMap_LinkedHashMap$_empty(null, null), P.LinkedHashMap_LinkedHashMap$_empty(null, null), 0, "library"), [null]), H.setRuntimeTypeInfo(new E.IdMapper(P.LinkedHashMap_LinkedHashMap$_empty(null, null), P.LinkedHashMap_LinkedHashMap$_empty(null, null), 0, "typedef"), [null]), H.setRuntimeTypeInfo(new E.IdMapper(P.LinkedHashMap_LinkedHashMap$_empty(null, null), P.LinkedHashMap_LinkedHashMap$_empty(null, null), 0, "field"), [null]), H.setRuntimeTypeInfo(new E.IdMapper(P.LinkedHashMap_LinkedHashMap$_empty(null, null), P.LinkedHashMap_LinkedHashMap$_empty(null, null), 0, "class"), [null]), H.setRuntimeTypeInfo(new E.IdMapper(P.LinkedHashMap_LinkedHashMap$_empty(null, null), P.LinkedHashMap_LinkedHashMap$_empty(null, null), 0, "function"), [null]), H.setRuntimeTypeInfo(new E.IdMapper(P.LinkedHashMap_LinkedHashMap$_empty(null, null), P.LinkedHashMap_LinkedHashMap$_empty(null, null), 0, "outputUnit"), [null])), null, P.LinkedHashMap_LinkedHashMap$_empty(null, null), null, null, null, null, null, null);
        t1.ElementToJsonVisitor$1(compiler);
        return t1;
      }}
  },
  ElementToJsonVisitor_closure: {
    "^": "Closure:19;",
    call$2: function(a, b) {
      return J.$add$ns(a, J.get$length$asx(b));
    },
    $isFunction: true
  },
  ElementToJsonVisitor_process_closure: {
    "^": "Closure:23;this_0,element_1",
    call$0: function() {
      return this.element_1.accept$1(0, this.this_0);
    },
    $isFunction: true
  },
  ElementToJsonVisitor_visitLibraryElement_closure: {
    "^": "Closure:77;this_0,children_1",
    call$1: function(member) {
      var childJson = this.this_0.process$1(member);
      if (childJson == null)
        return;
      this.children_1.push(childJson.$index(0, "id"));
    },
    $isFunction: true
  },
  ElementToJsonVisitor_visitClassElement_closure: {
    "^": "Closure:77;box_0,this_1,children_2",
    call$1: function(member) {
      var t1, childJson, t2, t3, closure, child, processedParent, t4, t5;
      t1 = this.this_1;
      childJson = t1.process$1(member);
      if (childJson != null) {
        this.children_2.push(childJson.$index(0, "id"));
        if (!!J.getInterceptor(member).$isMemberElement)
          for (t2 = member.get$nestedClosures(), t2 = H.setRuntimeTypeInfo(new H.ListIterator(t2, t2.length, 0, null), [H.getTypeArgumentByIndex(t2, 0)]), t3 = this.box_0; t2.moveNext$0();) {
            closure = t2.__internal$_current;
            child = t1.process$1(closure);
            processedParent = t1.process$1(closure.get$enclosingElement());
            if (processedParent != null)
              child.$indexSet(0, "name", H.S(processedParent.$index(0, "name")) + "." + H.S(child.$index(0, "name")));
            if (child != null) {
              t4 = t3.size_0;
              t5 = child.$index(0, "size");
              if (typeof t4 !== "number")
                return t4.$add();
              if (typeof t5 !== "number")
                return H.iae(t5);
              t3.size_0 = t4 + t5;
            }
          }
      }
    },
    $isFunction: true
  },
  ElementToJsonVisitor_visitFunctionElement_closure: {
    "^": "Closure:13;this_0,parameters_1",
    call$1: function(parameter) {
      this.parameters_1.push(P.LinkedHashMap_LinkedHashMap$_literal(["name", J.get$name$x(parameter), "type", J.toString$0(this.this_0.compiler.typesTask.getGuaranteedTypeOfElement$1(parameter))], null, null));
    },
    $isFunction: true
  },
  Selection: {
    "^": "Object;selectedElement<,selector<"
  },
  DumpInfoTask: {
    "^": "CompilerTask;name>,infoCollector,_tracking,_elementToNodes,_nodeToSize,_nodeBeforeSize,_fieldNameToSize,selectorsFromElement,compiler,watch,profilerTag",
    elementUsesSelector$2: function(element, selector) {
      if (this.compiler.dumpInfo)
        J.add$1$ax(this.selectorsFromElement.putIfAbsent$2(element, new E.DumpInfoTask_elementUsesSelector_closure()), selector);
    },
    getRetaining$1: function(element) {
      var t1 = this.selectorsFromElement;
      if (t1.containsKey$1(element) !== true)
        return C.List_empty4;
      else
        return J.expand$1$ax(t1.$index(0, element), new E.DumpInfoTask_getRetaining_closure(this));
    },
    isTracking$1: function(code) {
      if (this.compiler.dumpInfo)
        return this._tracking.contains$1(0, code);
      else
        return false;
    },
    registerElementAst$2: function(element, code) {
      if (this.compiler.dumpInfo) {
        J.add$1$ax(this._elementToNodes.putIfAbsent$2(element, new E.DumpInfoTask_registerElementAst_closure()), code);
        this._tracking.add$1(0, code);
      }
    },
    sizeOf$1: function(element) {
      var t1 = this._fieldNameToSize;
      if (t1.containsKey$1(element))
        return t1.$index(0, element);
      t1 = this._elementToNodes;
      if (t1.containsKey$1(element))
        return J.fold$2$ax(J.map$1$ax(t1.$index(0, element), this.get$sizeOfNode()), 0, new E.DumpInfoTask_sizeOf_closure());
      else
        return 0;
    },
    sizeOfNode$1: [function(node) {
      var t1 = this._nodeToSize;
      if (t1.containsKey$1(node))
        return t1.$index(0, node);
      else
        return 0;
    }, "call$1", "get$sizeOfNode", 2, 0, 175],
    codeOf$1: function(element) {
      var code, sb, t1, t2, ast, printer, t3;
      code = this._elementToNodes.$index(0, element);
      if (code == null)
        return;
      sb = P.StringBuffer$("");
      for (t1 = J.get$iterator$ax(code), t2 = this.compiler; t1.moveNext$0();) {
        ast = t1.get$current();
        printer = Q.Printer$(t2, null, true);
        printer.visit$1(ast);
        t3 = printer.outBuffer.buffer._contents;
        t3 = sb._contents += t3;
        sb._contents = t3 + "\n";
      }
      return sb;
    },
    dumpInfo$0: function() {
      this.measure$1(new E.DumpInfoTask_dumpInfo_closure(this));
    },
    dumpInfoJson$1: function(buffer) {
      var startToJsonTime, holding, t1, fn, pulling, t2, fnId, outputUnits, backend, outputUnit, outJson, toJsonDuration;
      startToJsonTime = new P.DateTime(Date.now(), false);
      startToJsonTime.DateTime$_now$0();
      holding = P.LinkedHashMap_LinkedHashMap$_empty(P.String, [P.List, P.String]);
      for (t1 = this.infoCollector.mapper._function._elementToId.get$keys(), t1 = t1.get$iterator(t1); t1.moveNext$0();) {
        fn = t1.get$current();
        pulling = this.getRetaining$1(fn);
        t2 = J.getInterceptor$asx(pulling);
        if (t2.get$length(pulling) > 0) {
          fnId = this.infoCollector.idOf$1(fn);
          if (fnId != null) {
            t2 = t2.map$1(pulling, new E.DumpInfoTask_dumpInfoJson_closure(this)).where$1(0, new E.DumpInfoTask_dumpInfoJson_closure0());
            holding.$indexSet(0, fnId, P.List_List$from(t2, true, H.getRuntimeTypeArgument(t2, "IterableBase", 0)));
          }
        }
      }
      outputUnits = H.setRuntimeTypeInfo([], [[P.Map, P.String, null]]);
      t1 = this.compiler;
      backend = t1.backend;
      for (t2 = this.infoCollector.mapper._outputUnit._elementToId.get$keys(), t2 = t2.get$iterator(t2); t2.moveNext$0();) {
        outputUnit = t2.get$current();
        outputUnits.push(P.LinkedHashMap_LinkedHashMap$_literal(["id", this.infoCollector.mapper._outputUnit.add$1(0, outputUnit), "name", J.get$name$x(outputUnit), "size", J.get$length$asx(backend.get$emitter().outputBuffers.$index(0, outputUnit))], P.String, null));
      }
      t2 = this.infoCollector;
      outJson = P.LinkedHashMap_LinkedHashMap$_literal(["elements", t2.mapper._toJson$1(t2), "holding", holding, "outputUnits", outputUnits, "dump_version", 3], null, null);
      t2 = new P.DateTime(Date.now(), false);
      t2.DateTime$_now$0();
      toJsonDuration = t2.difference$1(startToJsonTime);
      t2 = this.infoCollector;
      outJson.$indexSet(0, "program", P.LinkedHashMap_LinkedHashMap$_literal(["size", t2.programSize, "dart2jsVersion", t2.dart2jsVersion, "compilationMoment", t2.compilationMoment.toString$0(0), "compilationDuration", this.infoCollector.compilationDuration.toString$0(0), "toJsonDuration", toJsonDuration.toString$0(0), "dumpInfoDuration", this.infoCollector.dumpInfoDuration.toString$0(0), "noSuchMethodEnabled", t1.enabledNoSuchMethod], P.String, null));
      new P._JsonEncoderSink(C.JsonEncoder_null_null.indent, C.JsonEncoder_null_null._toEncodableFunction, new P._StringSinkConversionSink(buffer), false).add$1(0, outJson);
    }
  },
  DumpInfoTask_elementUsesSelector_closure: {
    "^": "Closure:23;",
    call$0: function() {
      return P.LinkedHashSet_LinkedHashSet(null, null, null, Z.Selector);
    },
    $isFunction: true
  },
  DumpInfoTask_getRetaining_closure: {
    "^": "Closure:13;this_0",
    call$1: function(selector) {
      return J.map$1$ax(this.this_0.compiler.world.allFunctions.query$1(0, selector).functions, new E.DumpInfoTask_getRetaining__closure(selector));
    },
    $isFunction: true
  },
  DumpInfoTask_getRetaining__closure: {
    "^": "Closure:13;selector_1",
    call$1: function(element) {
      return new E.Selection(element, this.selector_1);
    },
    $isFunction: true
  },
  DumpInfoTask_registerElementAst_closure: {
    "^": "Closure:23;",
    call$0: function() {
      return H.setRuntimeTypeInfo([], [Q.Node0]);
    },
    $isFunction: true
  },
  DumpInfoTask_sizeOf_closure: {
    "^": "Closure:19;",
    call$2: function(a, b) {
      return J.$add$ns(a, b);
    },
    $isFunction: true
  },
  DumpInfoTask_dumpInfo_closure: {
    "^": "Closure:23;this_0",
    call$0: function() {
      var t1, jsonBuffer, t2;
      t1 = this.this_0;
      if (t1.infoCollector == null)
        t1.infoCollector = E.ElementToJsonVisitor$(t1.compiler);
      jsonBuffer = P.StringBuffer$("");
      t1.dumpInfoJson$1(jsonBuffer);
      t1 = t1.compiler.outputProvider$2("", "info.json");
      t2 = J.getInterceptor$ax(t1);
      t2.add$1(t1, jsonBuffer._contents);
      t2.close$0(t1);
    },
    $isFunction: true
  },
  DumpInfoTask_dumpInfoJson_closure: {
    "^": "Closure:13;this_0",
    call$1: function(selection) {
      return P.LinkedHashMap_LinkedHashMap$_literal(["id", this.this_0.infoCollector.idOf$1(selection.get$selectedElement()), "mask", J.toString$0(selection.selector.get$mask())], P.String, P.String);
    },
    $isFunction: true
  },
  DumpInfoTask_dumpInfoJson_closure0: {
    "^": "Closure:13;",
    call$1: function(a) {
      return J.$index$asx(a, "id") != null;
    },
    $isFunction: true
  }
}],
["elements", "package:compiler/implementation/elements/elements.dart", , O, {
  "^": "",
  Elements_unwrap: function(element, listener, spannable) {
    return element != null && element.get$kind(element) === C.ElementKind_warn_on_use_0 ? element.unwrap$2(listener, spannable) : element;
  },
  Elements_isTypedef: function(e) {
    return e != null && e.get$kind(e) === C.ElementKind_typedef_32;
  },
  Elements_isLocal: function(element) {
    var t1;
    if (!(element == null || element.get$isErroneous()))
      if (!element.get$isInstanceMember())
        if (!O.Elements_isStaticOrTopLevelField(element))
          if (!(O.Elements_isStaticOrTopLevel(element) && element.kind === C.ElementKind_function_2)) {
            t1 = element.kind;
            t1 = t1 === C.ElementKind_variable_1 || t1 === C.ElementKind_parameter_1 || t1 === C.ElementKind_function_2;
          } else
            t1 = false;
        else
          t1 = false;
      else
        t1 = false;
    else
      t1 = false;
    return t1;
  },
  Elements_isInstanceField: function(element) {
    var t1;
    if (!element.get$isErroneous())
      if (element.get$isInstanceMember()) {
        t1 = element.kind;
        t1 = t1 === C.ElementKind_field_1 || t1 === C.ElementKind_getter_0 || t1 === C.ElementKind_setter_0;
      } else
        t1 = false;
    else
      t1 = false;
    return t1;
  },
  Elements_isStaticOrTopLevel: function(element) {
    var t1 = element != null;
    if (!(!t1 || element.get$isErroneous()) && element.get$isStatic())
      return true;
    if (!(!t1 || element.get$isErroneous()))
      if (element.get$kind(element) !== C.ElementKind_ambiguous_0)
        if (!element.get$isInstanceMember())
          if (element.kind !== C.ElementKind_prefix_8)
            if (element.get$enclosingElement() != null) {
              t1 = element.get$enclosingElement();
              if (t1.get$kind(t1) !== C.ElementKind_class_4) {
                t1 = element.get$enclosingElement();
                if (t1.get$kind(t1) !== C.ElementKind_compilation_unit_0) {
                  t1 = element.get$enclosingElement();
                  if (t1.get$kind(t1) !== C.ElementKind_library_0) {
                    t1 = element.get$enclosingElement();
                    t1 = t1.get$kind(t1) === C.ElementKind_prefix_8;
                  } else
                    t1 = true;
                } else
                  t1 = true;
              } else
                t1 = true;
            } else
              t1 = false;
          else
            t1 = false;
        else
          t1 = false;
      else
        t1 = false;
    else
      t1 = false;
    return t1;
  },
  Elements_isInStaticContext: function(element) {
    var outer;
    if (element == null || element.get$isErroneous())
      return true;
    outer = (element.get$enclosingElement().get$isClosure() ? element.get$enclosingElement().get$methodElement() : element).get$outermostEnclosingMemberOrTopLevel();
    if (outer == null || outer.get$isErroneous())
      return true;
    if (outer.get$isTopLevel())
      return true;
    if (outer.kind === C.ElementKind_generative_constructor_16)
      return false;
    if (outer.get$isInstanceMember())
      return false;
    return true;
  },
  Elements_isStaticOrTopLevelField: function(element) {
    var t1;
    if (O.Elements_isStaticOrTopLevel(element))
      if (element.get$kind(element) !== C.ElementKind_field_1) {
        t1 = element.kind;
        t1 = t1 === C.ElementKind_getter_0 || t1 === C.ElementKind_setter_0;
      } else
        t1 = true;
    else
      t1 = false;
    return t1;
  },
  Elements_isStaticOrTopLevelFunction: function(element) {
    return O.Elements_isStaticOrTopLevel(element) && element.get$kind(element) === C.ElementKind_function_2;
  },
  Elements_isInstanceMethod: function(element) {
    return !(element == null || element.get$isErroneous()) && element.get$isInstanceMember() && element.kind === C.ElementKind_function_2;
  },
  Elements_isNativeOrExtendsNative: function(element) {
    if (element == null)
      return false;
    if (element.get$isNative())
      return true;
    return O.Elements_isNativeOrExtendsNative(element.get$superclass());
  },
  Elements_isInstanceSend: function(send, elements) {
    var element;
    elements.toString;
    element = send.get$_secret_tree_element$_element();
    if (element == null)
      return !O.Elements_isClosureSend(send, element);
    return O.Elements_isInstanceMethod(element) || O.Elements_isInstanceField(element);
  },
  Elements_isClosureSend: function(send, element) {
    var selector, t1;
    if (send.argumentsNode == null)
      return false;
    if (send.receiver != null)
      return false;
    selector = send.selector;
    if (selector.isThis$0())
      return true;
    t1 = element == null;
    if (t1 && selector.asIdentifier$0() == null)
      return true;
    if (t1)
      return false;
    return O.Elements_isLocal(element);
  },
  Elements_reconstructConstructorNameSourceString: function(element) {
    var t1;
    if (element.name === "") {
      t1 = element.get$enclosingClass();
      return t1.get$name(t1);
    } else
      return O.Elements_reconstructConstructorName(element);
  },
  Elements_reconstructConstructorName: function(element) {
    var t1, className;
    t1 = element.get$enclosingClass();
    className = t1.get$name(t1);
    t1 = element.name;
    if (t1 === "")
      return className;
    else
      return H.S(className) + "$" + H.S(t1);
  },
  Elements_constructorNameForDiagnostics: function(className, constructorName) {
    return constructorName === "" ? className : H.S(className) + "." + H.S(constructorName);
  },
  Elements_operatorNameToIdentifier: function($name) {
    if ($name == null)
      return $name;
    else if ($name === "==")
      return "operator$eq";
    else if ($name === "~")
      return "operator$not";
    else if ($name === "[]")
      return "operator$index";
    else if ($name === "[]=")
      return "operator$indexSet";
    else if ($name === "*")
      return "operator$mul";
    else if ($name === "/")
      return "operator$div";
    else if ($name === "%")
      return "operator$mod";
    else if ($name === "~/")
      return "operator$tdiv";
    else if ($name === "+")
      return "operator$add";
    else if ($name === "<<")
      return "operator$shl";
    else if ($name === ">>")
      return "operator$shr";
    else if ($name === ">=")
      return "operator$ge";
    else if ($name === ">")
      return "operator$gt";
    else if ($name === "<=")
      return "operator$le";
    else if ($name === "<")
      return "operator$lt";
    else if ($name === "&")
      return "operator$and";
    else if ($name === "^")
      return "operator$xor";
    else if ($name === "|")
      return "operator$or";
    else if ($name === "-")
      return "operator$sub";
    else if ($name === "unary-")
      return "operator$negate";
    else
      return $name;
  },
  Elements_constructOperatorNameOrNull: function(op, isUnary) {
    if (op === "-")
      return isUnary ? "unary-" : op;
    else if (Y.isUserDefinableOperator(op))
      return op;
    else
      return;
  },
  Elements_constructOperatorName: function(op, isUnary) {
    var operatorName = O.Elements_constructOperatorNameOrNull(op, isUnary);
    if (operatorName == null)
      throw H.wrapException("Unhandled operator: " + H.S(op));
    else
      return operatorName;
  },
  Elements_mapToUserOperatorOrNull: function(op) {
    if (op === "!=")
      return "==";
    if (op === "*=")
      return "*";
    if (op === "/=")
      return "/";
    if (op === "%=")
      return "%";
    if (op === "~/=")
      return "~/";
    if (op === "+=")
      return "+";
    if (op === "-=")
      return "-";
    if (op === "<<=")
      return "<<";
    if (op === ">>=")
      return ">>";
    if (op === "&=")
      return "&";
    if (op === "^=")
      return "^";
    if (op === "|=")
      return "|";
    return;
  },
  Elements_isNumberOrStringSupertype: function(element, compiler) {
    var t1 = compiler.coreLibrary.find$1(0, "Comparable");
    return element == null ? t1 == null : element === t1;
  },
  Elements_isStringOnlySupertype: function(element, compiler) {
    var t1 = compiler.coreLibrary.find$1(0, "Pattern");
    return element == null ? t1 == null : element === t1;
  },
  Elements_isListSupertype: function(element, compiler) {
    var t1 = compiler.coreLibrary.find$1(0, "Iterable");
    return element == null ? t1 == null : element === t1;
  },
  Elements_compareByPosition: [function(a, b) {
    var r, positionA, positionB, offsetA;
    if (a == null ? b == null : a === b)
      return 0;
    r = a.get$library().compareTo$1(0, b.get$library());
    if (r !== 0)
      return r;
    r = a.get$compilationUnit().compareTo$1(0, b.get$compilationUnit());
    if (r !== 0)
      return r;
    positionA = a.get$position(a);
    positionB = b.get$position(b);
    offsetA = positionA == null ? -1 : positionA.charOffset;
    r = C.JSInt_methods.compareTo$1(offsetA, positionB == null ? -1 : positionB.charOffset);
    if (r !== 0)
      return r;
    r = J.compareTo$1$ns(a.name, b.name);
    if (r !== 0)
      return r;
    return J.compareTo$1$ns(a.get$hashCode(a), b.get$hashCode(b));
  }, "call$2", "Elements_compareByPosition$closure", 4, 0, 21],
  Elements_isFixedListConstructorCall: function(element, node, compiler) {
    var t1 = compiler.get$unnamedListConstructor();
    if (element == null ? t1 == null : element === t1)
      if (!J.getInterceptor(node.selector).$isOperator && node.argumentsNode != null) {
        t1 = node.argumentsNode.nodes;
        if (!t1.get$isEmpty(t1)) {
          t1 = t1.get$tail();
          t1 = t1.get$isEmpty(t1);
        } else
          t1 = false;
      } else
        t1 = false;
    else
      t1 = false;
    return t1;
  },
  Elements_isFilledListConstructorCall: function(element, node, compiler) {
    var t1, t2;
    t1 = compiler.get$filledListConstructor();
    if (element == null ? t1 == null : element === t1)
      if (!J.getInterceptor(node.selector).$isOperator && node.argumentsNode != null) {
        t1 = node.argumentsNode.nodes;
        if (!t1.get$isEmpty(t1)) {
          t2 = t1.get$tail();
          if (!t2.get$isEmpty(t2)) {
            t1 = t1.get$tail().get$tail();
            t1 = t1.get$isEmpty(t1);
          } else
            t1 = false;
        } else
          t1 = false;
      } else
        t1 = false;
    else
      t1 = false;
    return t1;
  },
  Elements_isConstructorOfTypedArraySubclass: function(element, compiler) {
    var $constructor, cls, t1, t2;
    if (compiler.typedDataLibrary == null)
      return false;
    if (!(element.get$kind(element) === C.ElementKind_generative_constructor_16 || element.get$isFactoryConstructor()))
      return false;
    $constructor = element.get$implementation(element).get$effectiveTarget();
    cls = $constructor.get$enclosingClass();
    t1 = cls.get$library();
    t2 = compiler.typedDataLibrary;
    return (t1 == null ? t2 == null : t1 === t2) && cls.get$isNative() && compiler.world.isSubtype$2(compiler.typedDataClass, cls) && compiler.world.isSubtype$2(compiler.listClass, cls) && $constructor.name === "";
  },
  Elements_switchStatementHasContinue: function(node, elements) {
    var t1, t2, t3, label, labelElement;
    for (t1 = node.cases.nodes, t1.toString, t1 = H.setRuntimeTypeInfo(new E.LinkIterator(null, t1), [H.getTypeArgumentByIndex(t1, 0)]); t1.moveNext$0();) {
      t2 = t1._util_implementation$_current.get$labelsAndCases().nodes;
      t2.toString;
      t3 = new E.LinkIterator(null, t2);
      t3.$builtinTypeInfo = [H.getTypeArgumentByIndex(t2, 0)];
      for (; t3.moveNext$0();) {
        label = t3._util_implementation$_current.asLabel$0();
        if (label != null) {
          t2 = elements._definedLabels;
          labelElement = t2 != null ? t2.$index(0, label) : null;
          if (labelElement != null && labelElement.get$isContinueTarget())
            return true;
        }
      }
    }
    return false;
  },
  Elements_isUnusedLabel: function(node, elements) {
    var body, t1, element;
    body = node.statement;
    t1 = elements._definedTargets;
    element = t1 != null ? t1.$index(0, body) : null;
    if (element != null) {
      t1 = element.get$statement();
      t1 = t1 == null ? body != null : t1 !== body;
    } else
      t1 = true;
    return t1;
  },
  Name_Name: function(text, library, isSetter) {
    if (!J.getInterceptor$asx(text).get$isEmpty(text) && C.JSString_methods.codeUnitAt$1(text, 0) === 95)
      return new O.PrivateName(library, text, isSetter);
    return new O.PublicName(text, isSetter);
  },
  ElementKind: {
    "^": "Object;id>,category",
    toString$0: function(_) {
      return this.id;
    },
    static: {"^": "ElementKind_VARIABLE,ElementKind_PARAMETER,ElementKind_INITIALIZING_FORMAL,ElementKind_FUNCTION,ElementKind_CLASS,ElementKind_GENERATIVE_CONSTRUCTOR,ElementKind_FIELD,ElementKind_FIELD_LIST,ElementKind_GENERATIVE_CONSTRUCTOR_BODY,ElementKind_COMPILATION_UNIT,ElementKind_GETTER,ElementKind_SETTER,ElementKind_TYPE_VARIABLE,ElementKind_ABSTRACT_FIELD,ElementKind_LIBRARY,ElementKind_PREFIX,ElementKind_TYPEDEF,ElementKind_AMBIGUOUS,ElementKind_WARN_ON_USE,ElementKind_ERROR"}
  },
  Entity: {
    "^": "Object;"
  },
  Element: {
    "^": "Object;",
    get$isLibrary: function() {
      return this.get$kind(this) === C.ElementKind_library_0;
    },
    get$isClass: function() {
      return this.get$kind(this) === C.ElementKind_class_4;
    },
    isClass$0: function() {
      return this.get$isClass().call$0();
    },
    get$isTypedef: function() {
      return this.get$kind(this) === C.ElementKind_typedef_32;
    },
    get$isFunction: function() {
      return this.get$kind(this) === C.ElementKind_function_2;
    },
    get$isGetter: function() {
      return this.get$kind(this) === C.ElementKind_getter_0;
    },
    get$isSetter: function() {
      return this.get$kind(this) === C.ElementKind_setter_0;
    },
    get$isConstructor: function() {
      return this.get$kind(this) === C.ElementKind_generative_constructor_16 || this.get$isFactoryConstructor();
    },
    get$isGenerativeConstructor: function() {
      return this.get$kind(this) === C.ElementKind_generative_constructor_16;
    },
    get$isField: function() {
      return this.get$kind(this) === C.ElementKind_field_1;
    },
    get$isInitializingFormal: function() {
      return this.get$kind(this) === C.ElementKind_initializing_formal_1;
    },
    get$isErroneous: function() {
      return this.get$kind(this) === C.ElementKind_error_0;
    },
    $isElement: true
  },
  ScopeContainerElement: {
    "^": "Object;",
    $isScopeContainerElement: true,
    $isElement: true
  },
  CompilationUnitElement: {
    "^": "Element;"
  },
  LibraryElement: {
    "^": "Element;",
    $isElement: true,
    $isScopeContainerElement: true
  },
  TypedefElement: {
    "^": "Element;",
    $isTypedefElement: true,
    $isElement: true,
    $isAstElement: true
  },
  ExecutableElement: {
    "^": "Element;",
    $isAstElement: true,
    $isElement: true
  },
  LocalElement: {
    "^": "Element;",
    $isLocalElement: true,
    $isLocal: true,
    $isElement: true
  },
  VariableElement: {
    "^": "ExecutableElement;",
    $isVariableElement: true
  },
  Local: {
    "^": "Entity;",
    $isLocal: true
  },
  LocalVariableElement: {
    "^": "VariableElement;",
    $isLocalElement: true,
    $isLocal: true,
    $isElement: true
  },
  FieldElement: {
    "^": "VariableElement;",
    $isFieldElement: true,
    $isMemberElement: true,
    $isAstElement: true,
    $isElement: true
  },
  FormalElement: {
    "^": "Element;",
    $isAstElement: true,
    $isElement: true
  },
  ParameterElement: {
    "^": "Element;",
    $isParameterElement: true,
    $isLocalElement: true,
    $isLocal: true,
    $isElement: true,
    $isAstElement: true,
    $isVariableElement: true
  },
  FunctionElement: {
    "^": "Element;",
    $isFunctionElement: true,
    $isAstElement: true,
    $isElement: true
  },
  LocalFunctionElement: {
    "^": "FunctionElement;",
    $isLocalElement: true,
    $isLocal: true,
    $isElement: true
  },
  ConstructorElement: {
    "^": "FunctionElement;",
    $isConstructorElement: true,
    $isMemberElement: true,
    $isAstElement: true,
    $isElement: true
  },
  TypeDeclarationElement: {
    "^": "Element;",
    $isAstElement: true,
    $isElement: true
  },
  ClassElement: {
    "^": "TypeDeclarationElement;",
    $isClassElement: true,
    $isScopeContainerElement: true,
    $isElement: true
  },
  MixinApplicationElement: {
    "^": "ClassElement;",
    $isMixinApplicationElement: true
  },
  LabelDefinition: {
    "^": "Entity;"
  },
  JumpTarget: {
    "^": "Local;"
  },
  TypeVariableElement: {
    "^": "Element;",
    $isElement: true,
    $isAstElement: true
  },
  MetadataAnnotation: {
    "^": "Object;",
    $isMetadataAnnotation: true
  },
  TypedElement: {
    "^": "Element;"
  },
  AnalyzableElement: {
    "^": "Element;"
  },
  AstElement: {
    "^": "AnalyzableElement;",
    $isAstElement: true
  },
  ResolvedAst: {
    "^": "Object;element<,node<,elements>"
  },
  MemberSignature: {
    "^": "Object;"
  },
  Member: {
    "^": "MemberSignature;",
    $isMember: true
  },
  Name: {
    "^": "Object;"
  },
  PublicName: {
    "^": "Object;text>,isSetter<",
    get$getter: function() {
      return this.isSetter ? new O.PublicName(this.text, false) : this;
    },
    get$setter: function() {
      return this.isSetter ? this : new O.PublicName(this.text, true);
    },
    isAccessibleFrom$1: function(element) {
      return true;
    },
    get$isPrivate: function() {
      return false;
    },
    get$hashCode: function(_) {
      return J.get$hashCode$(this.text) + 11 * C.JSBool_methods.get$hashCode(this.isSetter);
    },
    $eq: function(_, other) {
      var t1, t2;
      if (other == null)
        return false;
      if (!J.getInterceptor(other).$isPublicName)
        return false;
      t1 = this.text;
      t2 = other.text;
      return (t1 == null ? t2 == null : t1 === t2) && this.isSetter === other.isSetter;
    },
    toString$0: function(_) {
      var t1 = this.text;
      return this.isSetter ? H.S(t1) + "=" : t1;
    },
    $isPublicName: true
  },
  PrivateName: {
    "^": "PublicName;library<,text,isSetter",
    get$getter: function() {
      return this.isSetter ? new O.PrivateName(this.library, this.text, false) : this;
    },
    get$setter: function() {
      return this.isSetter ? this : new O.PrivateName(this.library, this.text, true);
    },
    isAccessibleFrom$1: function(element) {
      var t1 = this.library;
      return t1 == null ? element == null : t1 === element;
    },
    get$isPrivate: function() {
      return true;
    },
    get$hashCode: function(_) {
      return O.PublicName.prototype.get$hashCode.call(this, this) + 13 * J.get$hashCode$(this.library);
    },
    $eq: function(_, other) {
      var t1, t2;
      if (other == null)
        return false;
      if (!J.getInterceptor(other).$isPrivateName)
        return false;
      if (O.PublicName.prototype.$eq.call(this, this, other)) {
        t1 = this.library;
        t2 = other.library;
        t2 = t1 == null ? t2 == null : t1 === t2;
        t1 = t2;
      } else
        t1 = false;
      return t1;
    },
    toString$0: function(_) {
      return this.library.getLibraryName$0() + "#" + H.S(O.PublicName.prototype.toString$0.call(this, this));
    },
    $isPrivateName: true
  }
}],
["elements.modelx", "package:compiler/implementation/elements/modelx.dart", , U, {
  "^": "",
  ElementX_findNameToken: function(token, isConstructor, $name, enclosingClassName) {
    var needle, t, t1;
    needle = isConstructor ? enclosingClassName : $name;
    if (needle === "unary-")
      needle = "-";
    for (t = token; 0 !== t.get$info().kind; t = t.next) {
      if (!t.$isErrorToken) {
        t1 = t.get$value(t);
        t1 = needle == null ? t1 == null : needle === t1;
      } else
        t1 = false;
      if (t1)
        return t;
    }
    return token;
  },
  ElementX: {
    "^": "Element;name>,kind>,enclosingElement<,hashCode>,metadata@",
    get$modifiers: function() {
      return $.get$Modifiers_EMPTY();
    },
    parseNode$1: function(listener) {
      listener.internalError$2(this, "parseNode not implemented on " + this.toString$0(0) + ".");
    },
    computeType$1: function(compiler) {
      compiler.internalError$2(this, "computeType not implemented on " + this.toString$0(0) + ".");
    },
    addMetadata$1: function(annotation) {
      annotation.set$annotatedElement(this);
      this.addMetadataInternal$1(annotation);
    },
    addMetadataInternal$1: function(annotation) {
      this.set$metadata(this.get$metadata().prepend$1(annotation));
    },
    get$isClosure: function() {
      return false;
    },
    get$isClassMember: function() {
      if (this.get$enclosingElement() != null) {
        var t1 = this.get$enclosingElement();
        t1 = t1.get$kind(t1) === C.ElementKind_class_4;
      } else
        t1 = false;
      return t1;
    },
    get$isInstanceMember: function() {
      return false;
    },
    get$isDeferredLoaderGetter: function() {
      return false;
    },
    get$isFactoryConstructor: function() {
      return (this.get$modifiers().flags & 32) !== 0;
    },
    get$isConst: function() {
      return (this.get$modifiers().flags & 16) !== 0;
    },
    get$isFinal: function() {
      return (this.get$modifiers().flags & 4) !== 0;
    },
    get$isStatic: function() {
      return (this.get$modifiers().flags & 1) !== 0;
    },
    get$impliesType: function() {
      return (this.kind.category & 164) !== 0;
    },
    get$isPatched: function() {
      return false;
    },
    get$isPatch: function() {
      return false;
    },
    get$isDeclaration: function() {
      return true;
    },
    get$isInjected: function() {
      return !this.get$isPatch() && this.get$implementationLibrary().get$isPatch();
    },
    get$implementation: function(_) {
      return this;
    },
    get$declaration: function() {
      return this;
    },
    get$patch: function() {
      throw H.wrapException(P.UnsupportedError$("patch is not supported on " + this.toString$0(0)));
    },
    get$origin: function(_) {
      throw H.wrapException(P.UnsupportedError$("origin is not supported on " + this.toString$0(0)));
    },
    get$isSynthesized: function() {
      return false;
    },
    get$isMixinApplication: function() {
      return false;
    },
    get$isTopLevel: function() {
      if (this.get$enclosingElement() != null) {
        var t1 = this.get$enclosingElement();
        t1 = t1.get$kind(t1) === C.ElementKind_compilation_unit_0;
      } else
        t1 = false;
      return t1;
    },
    get$isAssignable: function() {
      if ((this.get$modifiers().flags & 4) !== 0 || (this.get$modifiers().flags & 16) !== 0)
        return false;
      if (this.get$isFunction() || this.kind === C.ElementKind_generative_constructor_16)
        return false;
      return true;
    },
    get$position: function(_) {
      return;
    },
    get$compilationUnit: function() {
      for (var element = this; element.get$kind(element) !== C.ElementKind_compilation_unit_0;)
        element = element.get$enclosingElement();
      return element;
    },
    get$library: function() {
      return this.get$enclosingElement().get$library();
    },
    get$implementationLibrary: function() {
      for (var element = this; element.get$kind(element) !== C.ElementKind_library_0;)
        element = element.get$enclosingElement();
      return element;
    },
    get$enclosingClass: function() {
      for (var e = this; e != null; e = e.get$enclosingElement())
        if (e.get$kind(e) === C.ElementKind_class_4)
          return e;
      return;
    },
    get$enclosingClassOrCompilationUnit: function() {
      for (var e = this; e != null; e = e.get$enclosingElement())
        if (e.get$kind(e) === C.ElementKind_class_4 || e.kind === C.ElementKind_compilation_unit_0)
          return e;
      return;
    },
    get$outermostEnclosingMemberOrTopLevel: function() {
      for (var e = this; e != null; e = e.get$enclosingElement())
        if (e.get$isClassMember() || e.get$isTopLevel())
          return e;
      return;
    },
    get$contextClass: function() {
      var cls, e;
      for (cls = null, e = this; e != null; e = e.get$enclosingElement())
        if (e.get$kind(e) === C.ElementKind_class_4)
          cls = e.get$declaration();
      return cls;
    },
    buildScope$0: function() {
      return this.get$enclosingElement().buildScope$0();
    },
    toString$0: function(_) {
      var nameText, t1, holderName;
      nameText = this.name;
      nameText = nameText != null ? nameText : "?";
      if (this.get$enclosingElement() != null && !this.get$isTopLevel()) {
        t1 = this.get$enclosingElement();
        if (t1.get$name(t1) != null) {
          t1 = this.get$enclosingElement();
          holderName = t1.get$name(t1);
        } else {
          t1 = this.get$enclosingElement();
          holderName = J.toString$0(t1.get$kind(t1)) + "?";
        }
        return J.toString$0(this.kind) + "(" + H.S(holderName) + "#" + H.S(nameText) + ")";
      } else
        return J.toString$0(this.kind) + "(" + H.S(nameText) + ")";
    },
    get$isNative: function() {
      return this._isNative;
    },
    get$hasFixedBackendName: function() {
      return this._fixedBackendName != null;
    },
    get$fixedBackendName: function() {
      return this._fixedBackendName;
    },
    setNative$1: function($name) {
      this._isNative = true;
      this._fixedBackendName = $name;
    },
    asFunctionElement$0: function() {
      return;
    },
    get$isAbstract: function() {
      return (this.get$modifiers().flags & 2) !== 0;
    },
    isForeign$1: function(compiler) {
      return compiler.backend.isForeign$1(this);
    },
    diagnose$2: function(context, listener) {
    },
    get$hasTreeElements: function() {
      return this.get$analyzableElement().get$hasTreeElements();
    },
    get$treeElements: function() {
      return this.get$analyzableElement().get$treeElements();
    },
    get$analyzableElement: function() {
      var element, t1;
      element = this.get$outermostEnclosingMemberOrTopLevel();
      t1 = element.kind;
      if (t1 === C.ElementKind_abstract_field_1 || t1 === C.ElementKind_prefix_8)
        return element.get$library();
      return element;
    }
  },
  ErroneousElementX: {
    "^": "ElementX;messageKind<,messageArguments<,abstractField@,name,kind,enclosingElement,hashCode,metadata,_fixedBackendName,_isNative",
    get$isSynthesized: function() {
      return true;
    },
    unsupported$0: function() {
      throw H.wrapException("unsupported operation on erroneous element");
    },
    get$metadata: function() {
      return this.unsupported$0();
    },
    get$node: function() {
      return this.unsupported$0();
    },
    get$resolvedAst: function() {
      return this.unsupported$0();
    },
    get$type: function(_) {
      return this.unsupported$0();
    },
    get$functionSignature: function() {
      return this.unsupported$0();
    },
    get$patch: function() {
      return;
    },
    get$origin: function(_) {
      return this;
    },
    get$immediateRedirectionTarget: function() {
      return this.unsupported$0();
    },
    get$nestedClosures: function() {
      return this.unsupported$0();
    },
    get$memberContext: function() {
      return this.unsupported$0();
    },
    get$executableContext: function() {
      return this.unsupported$0();
    },
    get$isRedirectingFactory: function() {
      return this.unsupported$0();
    },
    computeSignature$1: function(compiler) {
      return this.unsupported$0();
    },
    get$effectiveTarget: function() {
      return this;
    },
    computeEffectiveTargetType$1: function(newType) {
      return this.unsupported$0();
    },
    get$definingConstructor: function() {
      return;
    },
    asFunctionElement$0: function() {
      return this;
    },
    toString$0: function(_) {
      return "<" + H.S(this.name) + ": " + K.Message$(this.messageKind, this.messageArguments, false).computeMessage$0() + ">";
    },
    accept$1: function(_, visitor) {
      return visitor.visitFunctionElement$1(this);
    },
    $isErroneousElement: true,
    $isConstructorElement: true,
    $isMemberElement: true,
    $isAstElement: true,
    $isElement: true,
    $isFunctionElement: true
  },
  WrappedMessage: {
    "^": "Object;spannable,messageKind,messageArguments"
  },
  WarnOnUseElementX: {
    "^": "ElementX;warning,info<,wrappedElement,name,kind,enclosingElement,hashCode,metadata,_fixedBackendName,_isNative",
    unwrap$2: function(listener, usageSpannable) {
      var unwrapped, t1, spannable;
      unwrapped = this.wrappedElement;
      t1 = this.warning;
      spannable = t1.spannable;
      if (spannable == null)
        spannable = usageSpannable;
      listener.reportDiagnosticInternal$4(spannable, t1.messageKind, t1.messageArguments, C.Diagnostic_2_warning);
      t1 = this.info;
      spannable = t1.spannable;
      if (spannable == null)
        spannable = usageSpannable;
      listener.reportDiagnosticInternal$4(spannable, t1.messageKind, t1.messageArguments, C.Diagnostic_8_info);
      return unwrapped.get$kind(unwrapped) === C.ElementKind_warn_on_use_0 ? unwrapped.unwrap$2(listener, usageSpannable) : unwrapped;
    },
    accept$1: function(_, visitor) {
      return visitor.visitElement$1(this);
    },
    $isElement: true
  },
  AmbiguousElementX: {
    "^": "ElementX;messageKind<,messageArguments<,existingElement,newElement<,name,kind,enclosingElement,hashCode,metadata,_fixedBackendName,_isNative",
    flatten$0: function() {
      var set, element;
      set = H.setRuntimeTypeInfo(new N.Setlet(C.C__SetletMarker, null), [null]);
      for (element = this; element.get$kind(element) === C.ElementKind_ambiguous_0;) {
        set.add$1(0, element.get$newElement());
        element = element.existingElement;
      }
      set.add$1(0, element);
      return set;
    },
    diagnose$2: function(context, listener) {
      var ambiguousElements, code, importer, t1, t2, element, $arguments, imports;
      ambiguousElements = this.flatten$0();
      code = ambiguousElements.get$length(ambiguousElements) === 1 ? C.MessageKind_HRf : C.MessageKind_XXT;
      importer = context.get$library();
      for (t1 = ambiguousElements.get$iterator(ambiguousElements); t1.moveNext$0();) {
        t2 = {};
        element = t1.get$current();
        $arguments = P.LinkedHashMap_LinkedHashMap$_literal(["name", J.get$name$x(element)], null, null);
        listener.reportDiagnosticInternal$4(element, code, $arguments, C.Diagnostic_8_info);
        imports = importer.importers.importers.$index(0, element);
        t2.importers_0 = imports != null ? imports : C.C_Link15;
        listener.withCurrentElement$2(importer, new U.AmbiguousElementX_diagnose_closure(t2, listener, $arguments));
      }
    },
    accept$1: function(_, visitor) {
      return visitor.visitElement$1(this);
    },
    $isElement: true
  },
  AmbiguousElementX_diagnose_closure: {
    "^": "Closure:23;box_0,listener_1,arguments_2",
    call$0: function() {
      var t1, t2, t3, t4;
      for (t1 = this.box_0, t2 = this.listener_1, t3 = this.arguments_2; t4 = t1.importers_0, !t4.get$isEmpty(t4); t1.importers_0 = t1.importers_0.get$tail()) {
        t4 = t1.importers_0;
        t2.reportDiagnosticInternal$4(t4.get$head(t4), C.MessageKind_mJ11, t3, C.Diagnostic_8_info);
      }
    },
    $isFunction: true
  },
  ScopeX: {
    "^": "Object;contents",
    get$isEmpty: function(_) {
      return this.contents._collection$_length === 0;
    },
    get$values: function(_) {
      var t1 = this.contents;
      return t1.get$values(t1);
    },
    lookup$1: function($name) {
      return this.contents.$index(0, $name);
    },
    add$2: function(_, element, listener) {
      var t1, $name, t2, existing;
      t1 = J.getInterceptor$x(element);
      $name = t1.get$name(element);
      t1 = element.get$isGetter() || t1.get$kind(element) === C.ElementKind_setter_0;
      t2 = this.contents;
      if (t1)
        this.addAccessor$3(element, t2.$index(0, $name), listener);
      else {
        existing = t2.putIfAbsent$2($name, new U.ScopeX_add_closure(element));
        if (existing !== element) {
          listener.reportDiagnosticInternal$4(element, C.MessageKind_c0h, P.LinkedHashMap_LinkedHashMap$_literal(["name", $name], null, null), C.Diagnostic_1_error);
          listener.reportDiagnosticInternal$4(existing, C.MessageKind_3bx, P.LinkedHashMap_LinkedHashMap$_literal(["name", $name], null, null), C.Diagnostic_8_info);
        }
      }
    },
    addAccessor$3: function(accessor, existing, listener) {
      var t1, container, field;
      t1 = new U.ScopeX_addAccessor_reportError(accessor, listener);
      if (existing != null)
        if (J.get$kind$x(existing) !== C.ElementKind_abstract_field_1)
          t1.call$1(existing);
        else {
          accessor.set$abstractField(existing);
          if (accessor.get$isGetter()) {
            if (existing.get$getter() != null && existing.get$getter() !== accessor)
              t1.call$1(existing.get$getter());
            existing.set$getter(accessor);
          } else {
            if (existing.get$setter() != null && existing.get$setter() !== accessor)
              t1.call$1(existing.get$setter());
            existing.set$setter(accessor);
          }
        }
      else {
        container = accessor.get$enclosingClassOrCompilationUnit();
        t1 = $.ElementX_elementHashCode + 1;
        $.ElementX_elementHashCode = t1;
        field = new U.AbstractFieldElementX(null, null, accessor.name, C.ElementKind_abstract_field_1, container, t1, C.C_Link2, null, false);
        accessor.set$abstractField(field);
        if (accessor.get$isGetter())
          field.getter = accessor;
        else
          field.setter = accessor;
        this.add$2(0, field, listener);
      }
    }
  },
  ScopeX_add_closure: {
    "^": "Closure:23;element_0",
    call$0: function() {
      return this.element_0;
    },
    $isFunction: true
  },
  ScopeX_addAccessor_reportError: {
    "^": "Closure:47;accessor_0,listener_1",
    call$1: function(other) {
      var t1, t2, t3;
      t1 = this.listener_1;
      t2 = this.accessor_0;
      t3 = t2.name;
      t1.reportDiagnosticInternal$4(t2, C.MessageKind_c0h, P.LinkedHashMap_LinkedHashMap$_literal(["name", t3], null, null), C.Diagnostic_1_error);
      t1.reportFatalError$3(other, C.MessageKind_3bx, P.LinkedHashMap_LinkedHashMap$_literal(["name", t3], null, null));
    },
    $isFunction: true
  },
  CompilationUnitElementX: {
    "^": "ElementX;script<,partTag,localMembers,name,kind,enclosingElement,hashCode,metadata,_fixedBackendName,_isNative",
    forEachLocalMember$1: function(f) {
      this.localMembers.forEach$1(0, f);
    },
    addMember$2: function(element, listener) {
      var t1;
      this.localMembers = this.localMembers.prepend$1(element);
      t1 = this.enclosingElement;
      if (t1.get$isPatch())
        this.get$implementationLibrary().addMember$2(element, listener);
      else {
        t1 = t1.get$library();
        t1.localMembers = t1.localMembers.prepend$1(element);
        t1.localScope.add$2(0, element, listener);
      }
    },
    setPartOf$2: function(tag, listener) {
      var library, t1, libraryTag, actualName, expectedName;
      library = this.enclosingElement;
      if (library.get$entryCompilationUnit() === this) {
        listener.reportDiagnosticInternal$4(tag, C.MessageKind_FKl, C.Map_empty, C.Diagnostic_1_error);
        return;
      }
      t1 = this.localMembers;
      if (!t1.get$isEmpty(t1)) {
        listener.reportDiagnosticInternal$4(tag, C.MessageKind_UEe, C.Map_empty, C.Diagnostic_1_error);
        return;
      }
      if (this.partTag != null) {
        listener.reportDiagnosticInternal$4(tag, C.MessageKind_USZ, C.Map_empty, C.Diagnostic_2_warning);
        return;
      }
      this.partTag = tag;
      libraryTag = library.libraryTag;
      t1 = tag.name;
      actualName = J.toString$0(t1);
      if (libraryTag != null) {
        expectedName = J.toString$0(libraryTag.name);
        if (expectedName !== actualName)
          listener.reportDiagnosticInternal$4(t1, C.MessageKind_GXH, P.LinkedHashMap_LinkedHashMap$_literal(["libraryName", expectedName], null, null), C.Diagnostic_2_warning);
      } else {
        listener.reportDiagnosticInternal$4(library, C.MessageKind_NMc, P.LinkedHashMap_LinkedHashMap$_literal(["libraryName", actualName], null, null), C.Diagnostic_2_warning);
        listener.reportDiagnosticInternal$4(t1, C.MessageKind_W1e, C.Map_empty, C.Diagnostic_8_info);
      }
    },
    get$hasMembers: function() {
      var t1 = this.localMembers;
      return !t1.get$isEmpty(t1);
    },
    compareTo$1: function(_, other) {
      if (this === other)
        return 0;
      return C.JSString_methods.compareTo$1(this.script.readableUri.toString$0(0), other.get$script().readableUri.toString$0(0));
    },
    get$analyzableElement: function() {
      return this.enclosingElement.get$library();
    },
    accept$1: function(_, visitor) {
      return visitor.visitElement$1(this);
    },
    CompilationUnitElementX$2: function(script, library) {
      library.compilationUnits = library.compilationUnits.prepend$1(this);
    },
    $isElement: true,
    static: {CompilationUnitElementX$: function(script, library) {
        var t1, t2;
        t1 = script.file;
        t1 = t1 == null ? null : t1.filename;
        t2 = $.ElementX_elementHashCode + 1;
        $.ElementX_elementHashCode = t2;
        t2 = new U.CompilationUnitElementX(script, null, C.C_Link, t1, C.ElementKind_compilation_unit_0, library, t2, C.C_Link2, null, false);
        t2.CompilationUnitElementX$2(script, library);
        return t2;
      }}
  },
  Importers: {
    "^": "Object;importers",
    getImports$1: function(element) {
      var imports = this.importers.$index(0, element);
      return imports != null ? imports : C.C_Link15;
    },
    registerImport$2: function(element, $import) {
      var t1;
      if ($import == null)
        return;
      t1 = this.importers;
      t1.$indexSet(0, element, t1.putIfAbsent$2(element, new U.Importers_registerImport_closure()).prepend$1($import));
    }
  },
  Importers_registerImport_closure: {
    "^": "Closure:23;",
    call$0: function() {
      return C.C_Link15;
    },
    $isFunction: true
  },
  ImportScope: {
    "^": "Object;importScope",
    addImport$4: function(enclosingElement, element, $import, listener) {
      var importers, $name, t1, existing, t2, t3, t4, existingImport, ambiguousElement;
      importers = enclosingElement.get$library().importers;
      $name = element.get$name(element);
      if (element.get$isDeferredLoaderGetter())
        this.importScope.remove$1(0, $name);
      t1 = this.importScope;
      existing = t1.putIfAbsent$2($name, new U.ImportScope_addImport_closure(element));
      importers.registerImport$2(element, $import);
      t2 = new U.ImportScope_addImport_registerWarnOnUseElement(this, enclosingElement, listener, importers, $name);
      t3 = J.getInterceptor(existing);
      if (!t3.$eq(existing, element)) {
        t4 = importers.getImports$1(existing);
        existingImport = t4.get$head(t4);
        if (existing.get$library().canonicalUri.scheme === "dart" && element.get$library().canonicalUri.scheme !== "dart")
          t2.call$4($import, C.MessageKind_kSE0, element, existing);
        else if (existing.get$library().canonicalUri.scheme !== "dart" && element.get$library().canonicalUri.scheme === "dart")
          if ($import == null)
            t2.call$4(existingImport, C.MessageKind_yXb0, existing, element);
          else
            t2.call$4($import, C.MessageKind_kSE0, existing, element);
        else {
          t2 = P.LinkedHashMap_LinkedHashMap$_literal(["name", $name], null, null);
          t3 = t3.get$name(existing);
          t4 = $.ElementX_elementHashCode + 1;
          $.ElementX_elementHashCode = t4;
          ambiguousElement = new U.AmbiguousElementX(C.MessageKind_laS, t2, existing, element, t3, C.ElementKind_ambiguous_0, enclosingElement, t4, C.C_Link2, null, false);
          t1.$indexSet(0, $name, ambiguousElement);
          importers.registerImport$2(ambiguousElement, $import);
          importers.registerImport$2(ambiguousElement, existingImport);
        }
      }
    },
    $index: function(_, $name) {
      return this.importScope.$index(0, $name);
    }
  },
  ImportScope_addImport_closure: {
    "^": "Closure:23;element_0",
    call$0: function() {
      return this.element_0;
    },
    $isFunction: true
  },
  ImportScope_addImport_registerWarnOnUseElement: {
    "^": "Closure:176;this_1,enclosingElement_2,listener_3,importers_4,name_5",
    call$4: function($import, messageKind, hidingElement, hiddenElement) {
      var t1, t2, t3, t4, t5, element;
      t1 = this.name_5;
      t2 = P.LinkedHashMap_LinkedHashMap$_literal(["name", t1, "hiddenUri", hiddenElement.get$library().canonicalUri, "hidingUri", hidingElement.get$library().canonicalUri], null, null);
      t3 = this.listener_3.spanFromSpannable$1($import);
      t4 = P.LinkedHashMap_LinkedHashMap$_literal(["name", t1], null, null);
      t5 = $.ElementX_elementHashCode + 1;
      $.ElementX_elementHashCode = t5;
      element = new U.WarnOnUseElementX(new U.WrappedMessage(null, messageKind, t2), new U.WrappedMessage(t3, C.MessageKind_mJ11, t4), hidingElement, hidingElement.name, C.ElementKind_warn_on_use_0, this.enclosingElement_2, t5, C.C_Link2, null, false);
      this.this_1.importScope.$indexSet(0, t1, element);
      this.importers_4.registerImport$2(element, $import);
    },
    $isFunction: true
  },
  LibraryElementX: {
    "^": "ElementX_AnalyzableElementX_PatchMixin;canonicalUri<,entryCompilationUnit<,compilationUnits<,tagsBuilder,tagsCache,libraryTag<,canUseNative,localMembers<,localScope<,importScope<,importers,slotForExports,tagMapping,modelx$PatchMixin$patch,modelx$PatchMixin$origin,resolution$AnalyzableElementX$_treeElements,name,kind,enclosingElement,hashCode,metadata,_fixedBackendName,_isNative",
    get$metadata: function() {
      var t1 = this.libraryTag;
      return t1 == null ? this.metadata : t1.metadata;
    },
    set$metadata: function(value) {
      throw H.wrapException(O.SpannableAssertionFailure$(this, "Cannot set metadata on Library"));
    },
    get$compilationUnit: function() {
      return this.entryCompilationUnit;
    },
    get$analyzableElement: function() {
      return this;
    },
    addTag$2: function(tag, listener) {
      if (this.tagsCache != null)
        listener.internalError$2(tag, "Library tags for " + this.toString$0(0) + " have already been computed.");
      this.tagsBuilder.addLast$1(tag);
    },
    get$tags: function() {
      var t1 = this.tagsCache;
      if (t1 == null) {
        t1 = this.tagsBuilder.toList$0(0);
        this.tagsCache = t1;
        this.tagsBuilder = null;
      }
      return t1;
    },
    addMember$2: function(element, listener) {
      this.localMembers = this.localMembers.prepend$1(element);
      this.localScope.add$2(0, element, listener);
    },
    localLookup$1: function(elementName) {
      var result = this.localScope.contents.$index(0, elementName);
      return result == null && this.get$isPatch() ? this.modelx$PatchMixin$origin.localLookup$1(elementName) : result;
    },
    get$exportsHandled: function() {
      return this.slotForExports != null;
    },
    get$exports: function() {
      return this.slotForExports;
    },
    setExports$1: function(exportedElements) {
      var builder, t1;
      builder = H.setRuntimeTypeInfo(new E.LinkBuilderImplementation(null, null, 0), [null]);
      for (t1 = H.setRuntimeTypeInfo(new H.ListIterator(exportedElements, exportedElements.length, 0, null), [H.getTypeArgumentByIndex(exportedElements, 0)]); t1.moveNext$0();)
        builder.addLast$1(t1.__internal$_current);
      this.slotForExports = builder.toLink$0();
    },
    get$library: function() {
      return this.get$isPatch() ? this.modelx$PatchMixin$origin : this;
    },
    find$1: function(_, elementName) {
      var result = this.localScope.contents.$index(0, elementName);
      if (result != null)
        return result;
      if (this.modelx$PatchMixin$origin != null) {
        result = this.modelx$PatchMixin$origin.get$localScope().contents.$index(0, elementName);
        if (result != null)
          return result;
      }
      result = this.importScope.importScope.$index(0, elementName);
      if (result != null)
        return result;
      if (this.modelx$PatchMixin$origin != null) {
        result = this.modelx$PatchMixin$origin.get$importScope().importScope.$index(0, elementName);
        if (result != null)
          return result;
      }
      return;
    },
    findLocal$1: function(elementName) {
      var result = this.localScope.contents.$index(0, elementName);
      if (result == null || result.get$library() !== this)
        return;
      return result;
    },
    findExported$1: function(elementName) {
      var link, element;
      for (link = this.get$exports(); !link.get$isEmpty(link); link = link.get$tail()) {
        element = link.get$head(link);
        if (J.get$name$x(element) === elementName)
          return element;
      }
      return;
    },
    forEachExport$1: function(f) {
      this.get$exports().forEach$1(0, new U.LibraryElementX_forEachExport_closure(f));
    },
    forEachLocalMember$1: function(f) {
      if (this.get$isPatch()) {
        this.modelx$PatchMixin$origin.get$localMembers().forEach$1(0, f);
        this.localMembers.forEach$1(0, new U.LibraryElementX_forEachLocalMember_filterPatch(f));
      } else
        this.localMembers.forEach$1(0, f);
    },
    getNonPrivateElementsInScope$0: function() {
      var t1 = this.localScope.contents;
      t1 = t1.get$values(t1);
      return H.setRuntimeTypeInfo(new H.WhereIterable(t1, new U.LibraryElementX_getNonPrivateElementsInScope_closure()), [H.getRuntimeTypeArgument(t1, "IterableBase", 0)]);
    },
    hasLibraryName$0: function() {
      return this.libraryTag != null;
    },
    getLibraryName$0: function() {
      var t1 = this.libraryTag;
      if (t1 == null)
        return "";
      return J.toString$0(t1.name);
    },
    getLibraryOrScriptName$0: function() {
      var t1, path;
      t1 = this.libraryTag;
      if (t1 != null)
        return J.toString$0(t1.name);
      else {
        path = this.canonicalUri._path;
        return C.JSString_methods.substring$1(path, C.JSString_methods.lastIndexOf$1(path, "/") + 1);
      }
    },
    buildScope$0: function() {
      return new A.LibraryScope(this);
    },
    get$isPlatformLibrary: function() {
      return this.canonicalUri.scheme === "dart";
    },
    get$isInternalLibrary: function() {
      var t1 = this.canonicalUri;
      return t1.scheme === "dart" && C.JSString_methods.startsWith$1(t1._path, "_");
    },
    toString$0: function(_) {
      var t1;
      if (this.modelx$PatchMixin$origin != null)
        return "patch library(" + this.canonicalUri.toString$0(0) + ")";
      else {
        t1 = this.canonicalUri;
        if (this.modelx$PatchMixin$patch != null)
          return "origin library(" + t1.toString$0(0) + ")";
        else
          return "library(" + t1.toString$0(0) + ")";
      }
    },
    compareTo$1: function(_, other) {
      if (this === other)
        return 0;
      return C.JSString_methods.compareTo$1(this.getLibraryOrScriptName$0(), other.getLibraryOrScriptName$0());
    },
    accept$1: function(_, visitor) {
      return visitor.visitLibraryElement$1(this);
    },
    get$patch: function() {
      return this.modelx$PatchMixin$patch;
    },
    get$origin: function(_) {
      return this.modelx$PatchMixin$origin;
    },
    LibraryElementX$3: function(script, canonicalUri, origin) {
      this.entryCompilationUnit = U.CompilationUnitElementX$(script, this);
      if (origin != null)
        origin.applyPatch$1(this);
    },
    $isElement: true,
    $isScopeContainerElement: true,
    static: {LibraryElementX$: function(script, canonicalUri, origin) {
        var t1, t2, t3, t4, t5, t6, t7, t8;
        t1 = H.setRuntimeTypeInfo(new E.LinkBuilderImplementation(null, null, 0), [null]);
        t2 = P.LinkedHashMap_LinkedHashMap(null, null, null, P.String, O.Element);
        t3 = P.LinkedHashMap_LinkedHashMap(null, null, null, P.String, O.Element);
        t4 = P.LinkedHashMap_LinkedHashMap(null, null, null, O.Element, [O.Link, Y.Import]);
        t5 = P.LinkedHashMap_LinkedHashMap(null, null, null, Y.LibraryDependency, O.LibraryElement);
        t6 = canonicalUri == null ? script.readableUri : canonicalUri;
        t7 = script.file;
        t7 = t7 == null ? null : t7.filename;
        t8 = $.ElementX_elementHashCode + 1;
        $.ElementX_elementHashCode = t8;
        t8 = new U.LibraryElementX(t6, null, C.C_Link18, t1, null, null, false, C.C_Link, new U.ScopeX(t2), new U.ImportScope(t3), new U.Importers(t4), null, t5, null, null, null, t7, C.ElementKind_library_0, null, t8, C.C_Link2, null, false);
        t8.LibraryElementX$3(script, canonicalUri, origin);
        return t8;
      }}
  },
  ElementX_AnalyzableElementX: {
    "^": "ElementX+AnalyzableElementX;_treeElements:resolution$AnalyzableElementX$_treeElements<",
    $isAnalyzableElementX: true,
    $isElement: true
  },
  ElementX_AnalyzableElementX_PatchMixin: {
    "^": "ElementX_AnalyzableElementX+PatchMixin;patch:modelx$PatchMixin$patch<,origin:modelx$PatchMixin$origin>",
    $isElement: true
  },
  LibraryElementX_forEachExport_closure: {
    "^": "Closure:77;f_0",
    call$1: function(e) {
      return this.f_0.call$1(e);
    },
    $isFunction: true
  },
  LibraryElementX_forEachLocalMember_filterPatch: {
    "^": "Closure:47;f_0",
    call$1: function(element) {
      if (!element.get$isPatch())
        this.f_0.call$1(element);
    },
    $isFunction: true
  },
  LibraryElementX_getNonPrivateElementsInScope_closure: {
    "^": "Closure:77;",
    call$1: function(element) {
      var t1, t2;
      t1 = J.get$name$x(element);
      t2 = J.getInterceptor$asx(t1);
      return !(!t2.get$isEmpty(t1) && t2.codeUnitAt$1(t1, 0) === 95);
    },
    $isFunction: true
  },
  PrefixElementX: {
    "^": "ElementX;firstPosition,importScope,_deferredImport<,name,kind,enclosingElement,hashCode,metadata,_fixedBackendName,_isNative",
    get$isDeferred: function() {
      return this._deferredImport != null;
    },
    get$deferredImport: function() {
      return this._deferredImport;
    },
    lookupLocalMember$1: function(memberName) {
      return this.importScope.importScope.$index(0, memberName);
    },
    computeType$1: function(compiler) {
      return C.C_DynamicType;
    },
    get$position: function(_) {
      return this.firstPosition;
    },
    addImport$3: function(element, $import, listener) {
      this.importScope.addImport$4(this, element, $import, listener);
    },
    accept$1: function(_, visitor) {
      return visitor.visitElement$1(this);
    },
    markAsDeferred$1: function(deferredImport) {
      this._deferredImport = deferredImport;
    },
    $isElement: true
  },
  TypedefElementX: {
    "^": "ElementX_AstElementMixin_AnalyzableElementX_TypeDeclarationElementX;alias<,resolutionState<,functionSignature@",
    get$node: function() {
      return this.cachedNode;
    },
    computeType$1: function(compiler) {
      if (this.get$thisTypeCache() != null)
        return this.get$thisTypeCache();
      this.setThisAndRawTypes$2(compiler, this.createTypeVariables$1(this.parseNode$1(compiler).get$typeParameters()));
      if (this.resolutionState === 0)
        compiler.resolver.resolve$1(this);
      return this.get$thisTypeCache();
    },
    ensureResolved$1: function(compiler) {
      if (this.resolutionState === 0)
        compiler.resolver.resolve$1(this);
    },
    createType$1: function(typeArguments) {
      var t1 = new V.TypedefType(this, typeArguments);
      t1.GenericType$3$checkTypeArgumentCount(this, typeArguments, true);
      return t1;
    },
    buildScope$0: function() {
      return new A.TypeDeclarationScope(this, this.enclosingElement.buildScope$0());
    },
    checkCyclicReference$1: function(compiler) {
      var t1;
      if (this.hasBeenCheckedForCycles)
        return;
      t1 = this.computeType$1(compiler);
      t1.toString;
      new A.TypedefCyclicVisitor(compiler, this, false, C.C_Link12, 0, C.C_Link8).visitTypedefType$2(t1, null);
      this.hasBeenCheckedForCycles = true;
    },
    accept$1: function(_, visitor) {
      return visitor.visitTypedefElement$1(this);
    },
    get$definingElement: function() {
      return this;
    },
    $isTypedefElement: true,
    $isElement: true,
    $isAstElement: true
  },
  ElementX_AstElementMixin: {
    "^": "ElementX+AstElementMixin;",
    $isAstElement: true,
    $isElement: true
  },
  ElementX_AstElementMixin_AnalyzableElementX: {
    "^": "ElementX_AstElementMixin+AnalyzableElementX;_treeElements:resolution$AnalyzableElementX$_treeElements<",
    $isAnalyzableElementX: true,
    $isElement: true
  },
  ElementX_AstElementMixin_AnalyzableElementX_TypeDeclarationElementX: {
    "^": "ElementX_AstElementMixin_AnalyzableElementX+TypeDeclarationElementX;thisTypeCache:modelx$TypeDeclarationElementX$thisTypeCache@,rawTypeCache:modelx$TypeDeclarationElementX$rawTypeCache?",
    $isAstElement: true,
    $isElement: true
  },
  VariableList: {
    "^": "Object;definitions<,type>,modifiers<,metadata@",
    parseNode$2: function(element, listener) {
      return this.definitions;
    },
    computeType$2: function(element, compiler) {
      return this.type;
    },
    VariableList$node$2: function(node, type) {
    }
  },
  VariableElementX: {
    "^": "ElementX_AstElementMixin0;token<,variables<",
    get$modifiers: function() {
      return this.variables.modifiers;
    },
    get$metadata: function() {
      return this.variables.metadata;
    },
    addMetadataInternal$1: function(annotation) {
      var t1 = this.variables;
      t1.metadata = t1.metadata.prepend$1(annotation);
    },
    get$definingElement: function() {
      return this;
    },
    get$node: function() {
      return this.definitionsCache;
    },
    get$initializer: function() {
      return this.initializerCache;
    },
    parseNode$1: function(listener) {
      var t1 = this.definitionsCache;
      if (t1 != null)
        return t1;
      this.createDefinitions$1(this.variables.parseNode$2(this, listener));
      return this.definitionsCache;
    },
    createDefinitions$1: function(definitions) {
      var link, t1, node, count, initializedIdentifier, identifier, sendSet, t2, t3, t4, t5, t6, t7;
      for (link = definitions.get$definitions().nodes, t1 = this.name, node = null, count = 0; !link.get$isEmpty(link); link = link.get$tail()) {
        initializedIdentifier = link.get$head(link);
        identifier = initializedIdentifier.asIdentifier$0();
        if (identifier == null) {
          sendSet = initializedIdentifier.asSendSet$0();
          t2 = sendSet.selector.asIdentifier$0().token;
          t2 = t2.get$value(t2);
          if (t1 == null ? t2 == null : t1 === t2) {
            t2 = sendSet.argumentsNode.nodes;
            if (t2.get$isEmpty(t2))
              H.throwExpression(P.StateError$("No elements"));
            this.initializerCache = t2.get$head(t2);
            node = initializedIdentifier;
          }
        } else {
          t2 = identifier.token;
          t2 = t2.get$value(t2);
          if (t1 == null ? t2 == null : t1 === t2)
            node = initializedIdentifier;
        }
        ++count;
      }
      K.invariant(definitions, node != null, "Could not find '" + H.S(t1) + "'.");
      if (count === 1)
        this.definitionsCache = definitions;
      else {
        t1 = definitions.get$type(definitions);
        t2 = definitions.get$modifiers();
        t3 = definitions.get$definitions();
        t4 = E.LinkEntry$(node, C.C_Link3, H.getTypeArgumentByIndex(C.C_Link3, 0));
        t5 = definitions.get$definitions();
        t6 = $.Node__HASH_COUNTER + 1;
        $.Node__HASH_COUNTER = t6;
        t7 = t6 + 1;
        $.Node__HASH_COUNTER = t7;
        this.definitionsCache = new Y.VariableDefinitions(null, t1, t2, new Y.NodeList(t4, t3.beginToken, t5.endToken, null, t6), t7);
      }
    },
    computeType$1: function(compiler) {
      var t1 = this.variables.type;
      if (t1 != null)
        return t1;
      return compiler.withCurrentElement$2(this, new U.VariableElementX_computeType_closure(this, compiler));
    },
    get$type: function(_) {
      return this.variables.type;
    },
    get$isInstanceMember: function() {
      var t1 = this.enclosingElement;
      return t1 != null && t1.get$kind(t1) === C.ElementKind_class_4 && (this.get$modifiers().flags & 1) === 0;
    },
    get$position: function(_) {
      return this.token;
    },
    accept$1: function(_, visitor) {
      return visitor.visitElement$1(this);
    },
    $isVariableElement: true,
    $isAstElement: true,
    $isElement: true
  },
  ElementX_AstElementMixin0: {
    "^": "ElementX+AstElementMixin;",
    $isAstElement: true,
    $isElement: true
  },
  VariableElementX_computeType_closure: {
    "^": "Closure:23;this_0,compiler_1",
    call$0: function() {
      var t1, t2;
      t1 = this.this_0;
      t2 = this.compiler_1;
      t1.parseNode$1(t2);
      return t1.variables.computeType$2(t1, t2);
    },
    $isFunction: true
  },
  LocalVariableElementX: {
    "^": "VariableElementX;token,variables,definitionsCache,initializerCache,name,kind,enclosingElement,hashCode,metadata,_fixedBackendName,_isNative",
    get$executableContext: function() {
      return this.enclosingElement;
    },
    get$memberContext: function() {
      return this.enclosingElement.get$memberContext();
    },
    $isLocalElement: true,
    $isLocal: true,
    $isElement: true,
    $isVariableElement: true,
    $isAstElement: true
  },
  FieldElementX: {
    "^": "VariableElementX_AnalyzableElementX;nestedClosures<,resolution$AnalyzableElementX$_treeElements,token,variables,definitionsCache,initializerCache,name,kind,enclosingElement,hashCode,metadata,_fixedBackendName,_isNative",
    accept$1: function(_, visitor) {
      return visitor.visitFieldElement$1(this);
    },
    get$memberContext: function() {
      return this;
    },
    $isFieldElement: true,
    $isMemberElement: true,
    $isAstElement: true,
    $isElement: true,
    $isVariableElement: true
  },
  VariableElementX_AnalyzableElementX: {
    "^": "VariableElementX+AnalyzableElementX;_treeElements:resolution$AnalyzableElementX$_treeElements<",
    $isAnalyzableElementX: true,
    $isElement: true
  },
  FormalElementX: {
    "^": "ElementX_AstElementMixin1;definitions<,identifier<,typeCache<,functionSignatureCache<,name,kind,enclosingElement,hashCode,metadata,_fixedBackendName,_isNative",
    get$functionDeclaration: function() {
      return this.enclosingElement;
    },
    get$modifiers: function() {
      return this.definitions.modifiers;
    },
    get$position: function(_) {
      return this.identifier.token;
    },
    parseNode$1: function(listener) {
      return this.definitions;
    },
    computeType$1: function(compiler) {
      return this.get$type(this);
    },
    get$type: function(_) {
      return this.typeCache;
    },
    get$functionSignature: function() {
      return this.functionSignatureCache;
    },
    get$node: function() {
      return this.definitions;
    },
    get$functionType: function() {
      return this.get$type(this);
    },
    accept$1: function(_, visitor) {
      return visitor.visitElement$1(this);
    },
    get$definingElement: function() {
      return this.get$declaration();
    },
    $isAstElement: true,
    $isElement: true
  },
  ElementX_AstElementMixin1: {
    "^": "ElementX+AstElementMixin;",
    $isAstElement: true,
    $isElement: true
  },
  ParameterElementX: {
    "^": "FormalElementX_PatchMixin;initializer<",
    get$functionDeclaration: function() {
      return this.enclosingElement;
    },
    get$executableContext: function() {
      return this.enclosingElement;
    },
    get$memberContext: function() {
      return this.enclosingElement.get$memberContext();
    },
    accept$1: function(_, visitor) {
      return visitor.visitElement$1(this);
    },
    $isParameterElement: true,
    $isLocalElement: true,
    $isLocal: true,
    $isElement: true,
    $isAstElement: true,
    $isVariableElement: true
  },
  FormalElementX_PatchMixin: {
    "^": "FormalElementX+PatchMixin;patch:modelx$PatchMixin$patch<,origin:modelx$PatchMixin$origin>",
    $isElement: true
  },
  LocalParameterElementX: {
    "^": "ParameterElementX;initializer,modelx$PatchMixin$patch,modelx$PatchMixin$origin,definitions,identifier,typeCache,functionSignatureCache,name,kind,enclosingElement,hashCode,metadata,_fixedBackendName,_isNative",
    $isLocalElement: true,
    $isLocal: true,
    $isElement: true,
    $isVariableElement: true,
    $isAstElement: true,
    $isParameterElement: true
  },
  InitializingFormalElementX: {
    "^": "ParameterElementX;fieldElement<,initializer,modelx$PatchMixin$patch,modelx$PatchMixin$origin,definitions,identifier,typeCache,functionSignatureCache,name,kind,enclosingElement,hashCode,metadata,_fixedBackendName,_isNative",
    accept$1: function(_, visitor) {
      return visitor.visitElement$1(this);
    },
    get$memberContext: function() {
      return this.enclosingElement;
    },
    $isParameterElement: true,
    $isLocalElement: true,
    $isLocal: true,
    $isElement: true,
    $isAstElement: true,
    $isVariableElement: true
  },
  AbstractFieldElementX: {
    "^": "ElementX;getter@,setter@,name,kind,enclosingElement,hashCode,metadata,_fixedBackendName,_isNative",
    computeType$1: function(compiler) {
      throw H.wrapException("internal error: AbstractFieldElement has no type");
    },
    parseNode$1: function(listener) {
      throw H.wrapException("internal error: AbstractFieldElement has no node");
    },
    get$position: function(_) {
      var t1, t2;
      t1 = this.getter;
      if (t1 != null) {
        t1 = t1.get$compilationUnit();
        t2 = this.get$compilationUnit();
        t2 = t1 == null ? t2 == null : t1 === t2;
        t1 = t2;
      } else
        t1 = false;
      if (t1) {
        t1 = this.getter;
        return t1.get$position(t1);
      } else {
        t1 = this.setter;
        return t1.get$position(t1);
      }
    },
    get$modifiers: function() {
      var t1, t2, t3;
      t1 = this.getter;
      if (t1 != null) {
        t1 = t1.get$modifiers().nodes;
        t2 = this.getter.get$modifiers().flags;
        t3 = $.Node__HASH_COUNTER + 1;
        $.Node__HASH_COUNTER = t3;
        return new Y.Modifiers(t1, (t2 | 2) >>> 0, t3);
      } else {
        t1 = this.setter.get$modifiers().nodes;
        t2 = this.setter.get$modifiers().flags;
        t3 = $.Node__HASH_COUNTER + 1;
        $.Node__HASH_COUNTER = t3;
        return new Y.Modifiers(t1, (t2 | 2) >>> 0, t3);
      }
    },
    get$isInstanceMember: function() {
      var t1 = this.enclosingElement;
      return t1 != null && t1.get$kind(t1) === C.ElementKind_class_4 && (this.get$modifiers().flags & 1) === 0;
    },
    accept$1: function(_, visitor) {
      return visitor.visitElement$1(this);
    },
    get$isAbstract: function() {
      var t1 = this.getter;
      if (!(t1 != null && t1.get$isAbstract())) {
        t1 = this.setter;
        t1 = t1 != null && t1.get$isAbstract();
      } else
        t1 = true;
      return t1;
    },
    $isAbstractFieldElement: true,
    $isElement: true
  },
  FunctionSignatureX: {
    "^": "Object;requiredParameters<,optionalParameters<,requiredParameterCount<,optionalParameterCount<,optionalParametersAreNamed<,orderedOptionalParameters<,type>",
    forEachRequiredParameter$1: function($function) {
      var link;
      for (link = this.requiredParameters; !link.get$isEmpty(link); link = link.get$tail())
        $function.call$1(link.get$head(link));
    },
    forEachOptionalParameter$1: function($function) {
      var link;
      for (link = this.optionalParameters; !link.get$isEmpty(link); link = link.get$tail())
        $function.call$1(link.get$head(link));
    },
    get$firstOptionalParameter: function() {
      var t1 = this.optionalParameters;
      return t1.get$head(t1);
    },
    forEachParameter$1: function($function) {
      this.forEachRequiredParameter$1($function);
      this.forEachOptionalParameter$1($function);
    },
    orderedForEachParameter$1: function($function) {
      this.forEachRequiredParameter$1($function);
      H.IterableMixinWorkaround_forEach(this.orderedOptionalParameters, $function);
    },
    get$parameterCount: function() {
      return this.requiredParameterCount + this.optionalParameterCount;
    },
    isCompatibleWith$1: function(signature) {
      var names, t1, otherTotalCount;
      if (this.optionalParametersAreNamed) {
        if (!signature.get$optionalParametersAreNamed())
          return this.requiredParameterCount === signature.requiredParameterCount + signature.optionalParameterCount;
        if (this.requiredParameterCount !== signature.requiredParameterCount)
          return false;
        names = this.optionalParameters.mapToSet$1(new U.FunctionSignatureX_isCompatibleWith_closure());
        for (t1 = signature.optionalParameters, t1.toString, t1 = H.setRuntimeTypeInfo(new E.LinkIterator(null, t1), [H.getTypeArgumentByIndex(t1, 0)]); t1.moveNext$0();)
          if (!names.contains$1(0, J.get$name$x(t1._util_implementation$_current)))
            return false;
      } else {
        if (signature.get$optionalParametersAreNamed())
          return false;
        otherTotalCount = signature.requiredParameterCount + signature.optionalParameterCount;
        t1 = this.requiredParameterCount;
        return t1 <= otherTotalCount && t1 + this.optionalParameterCount >= otherTotalCount;
      }
      return true;
    }
  },
  FunctionSignatureX_isCompatibleWith_closure: {
    "^": "Closure:77;",
    call$1: function(element) {
      return J.get$name$x(element);
    },
    $isFunction: true
  },
  BaseFunctionElementX: {
    "^": "ElementX_PatchMixin_AstElementMixin;typeCache<,modifiers<,nestedClosures<,functionSignatureCache<,abstractField@",
    get$isInstanceMember: function() {
      if (this.get$isClassMember())
        var t1 = !(this.kind === C.ElementKind_generative_constructor_16 || this.get$isFactoryConstructor()) && (this.modifiers.flags & 1) === 0;
      else
        t1 = false;
      return t1;
    },
    computeSignature$1: function(compiler) {
      var t1 = this.functionSignatureCache;
      if (t1 != null)
        return t1;
      compiler.withCurrentElement$2(this, new U.BaseFunctionElementX_computeSignature_closure(this, compiler));
      return this.functionSignatureCache;
    },
    get$functionSignature: function() {
      return this.functionSignatureCache;
    },
    computeType$1: function(compiler) {
      var t1 = this.typeCache;
      if (t1 != null)
        return t1;
      t1 = this.computeSignature$1(compiler);
      t1 = t1.get$type(t1);
      this.typeCache = t1;
      return t1;
    },
    get$type: function(_) {
      return this.typeCache;
    },
    asFunctionElement$0: function() {
      return this;
    },
    toString$0: function(_) {
      if (this.get$isPatch())
        return "patch " + U.ElementX.prototype.toString$0.call(this, this);
      else if (this.get$isPatched())
        return "origin " + U.ElementX.prototype.toString$0.call(this, this);
      else
        return U.ElementX.prototype.toString$0.call(this, this);
    },
    get$isAbstract: function() {
      if ((this.modifiers.flags & 64) === 0)
        var t1 = (this.get$isFunction() || this.get$isGetter() || this.kind === C.ElementKind_setter_0) && this._hasNoBody;
      else
        t1 = false;
      return t1;
    },
    accept$1: function(_, visitor) {
      return visitor.visitFunctionElement$1(this);
    },
    get$definingElement: function() {
      return this.get$implementation(this);
    },
    $isFunctionElement: true,
    $isAstElement: true,
    $isElement: true
  },
  ElementX_PatchMixin: {
    "^": "ElementX+PatchMixin;patch:modelx$PatchMixin$patch<,origin:modelx$PatchMixin$origin>",
    $isElement: true
  },
  ElementX_PatchMixin_AstElementMixin: {
    "^": "ElementX_PatchMixin+AstElementMixin;",
    $isAstElement: true,
    $isElement: true
  },
  BaseFunctionElementX_computeSignature_closure: {
    "^": "Closure:23;this_0,compiler_1",
    call$0: function() {
      var t1 = this.this_0;
      t1.functionSignatureCache = this.compiler_1.resolveSignature$1(t1);
    },
    $isFunction: true
  },
  FunctionElementX: {
    "^": "BaseFunctionElementX_AnalyzableElementX;",
    get$memberContext: function() {
      return this;
    },
    $isMemberElement: true,
    $isAstElement: true,
    $isElement: true
  },
  BaseFunctionElementX_AnalyzableElementX: {
    "^": "BaseFunctionElementX+AnalyzableElementX;_treeElements:resolution$AnalyzableElementX$_treeElements<",
    $isAnalyzableElementX: true,
    $isElement: true
  },
  LocalFunctionElementX: {
    "^": "BaseFunctionElementX;node<,typeCache,modifiers,nestedClosures,functionSignatureCache,_hasNoBody,abstractField,modelx$PatchMixin$patch,modelx$PatchMixin$origin,name,kind,enclosingElement,hashCode,metadata,_fixedBackendName,_isNative",
    get$executableContext: function() {
      return this.enclosingElement;
    },
    get$memberContext: function() {
      return this.enclosingElement.get$memberContext();
    },
    parseNode$1: function(listener) {
      return this.node;
    },
    get$position: function(_) {
      var t1 = this.node;
      if (t1.get$name(t1) != null)
        return t1.get$name(t1).getBeginToken$0();
      else
        return t1.getBeginToken$0();
    },
    $isLocalElement: true,
    $isLocal: true,
    $isElement: true,
    $isFunctionElement: true,
    $isAstElement: true
  },
  ConstructorElementX: {
    "^": "FunctionElementX;immediateRedirectionTarget@,internalEffectiveTarget<",
    get$isRedirectingFactory: function() {
      return this.immediateRedirectionTarget != null;
    },
    get$effectiveTarget: function() {
      var t1 = this.immediateRedirectionTarget;
      if (t1 != null && t1.get$isErroneous())
        return this.immediateRedirectionTarget;
      return this.immediateRedirectionTarget != null ? this.internalEffectiveTarget : this;
    },
    computeEffectiveTargetType$1: function(newType) {
      var t1;
      if (this.immediateRedirectionTarget == null)
        return newType;
      t1 = this.effectiveTargetType;
      t1.toString;
      return t1.subst$2(newType.typeArguments, newType.get$element().get$typeVariables());
    },
    get$definingConstructor: function() {
      return;
    },
    get$enclosingClass: function() {
      return this.enclosingElement;
    },
    $isConstructorElement: true,
    $isMemberElement: true,
    $isAstElement: true,
    $isElement: true,
    $isFunctionElement: true
  },
  DeferredLoaderGetterElementX: {
    "^": "FunctionElementX;prefix<,resolution$AnalyzableElementX$_treeElements,typeCache,modifiers,nestedClosures,functionSignatureCache,_hasNoBody,abstractField,modelx$PatchMixin$patch,modelx$PatchMixin$origin,name,kind,enclosingElement,hashCode,metadata,_fixedBackendName,_isNative",
    computeSignature$1: function(compiler) {
      if (this.functionSignatureCache != null)
        return this.get$functionSignature();
      compiler.withCurrentElement$2(this, new U.DeferredLoaderGetterElementX_computeSignature_closure(this));
      return this.functionSignatureCache;
    },
    get$isClassMember: function() {
      return false;
    },
    isForeign$1: function(compiler) {
      return true;
    },
    get$isSynthesized: function() {
      return true;
    },
    get$isFunction: function() {
      return false;
    },
    get$isDeferredLoaderGetter: function() {
      return true;
    },
    get$isGetter: function() {
      return true;
    },
    get$position: function(_) {
      return;
    },
    parseNode$1: function(listener) {
      return;
    },
    get$node: function() {
      return;
    }
  },
  DeferredLoaderGetterElementX_computeSignature_closure: {
    "^": "Closure:23;this_0",
    call$0: function() {
      var t1 = this.this_0;
      t1.functionSignatureCache = new U.FunctionSignatureX(C.C_Link10, C.C_Link10, 0, 0, false, [], V.FunctionType_FunctionType(t1, C.C_DynamicType, C.List_empty3, C.List_empty3, C.List_empty0, C.List_empty3));
    },
    $isFunction: true
  },
  ConstructorBodyElementX: {
    "^": "BaseFunctionElementX;$constructor<,typeCache,modifiers,nestedClosures,functionSignatureCache,_hasNoBody,abstractField,modelx$PatchMixin$patch,modelx$PatchMixin$origin,name,kind,enclosingElement,hashCode,metadata,_fixedBackendName,_isNative",
    get$node: function() {
      return this.$constructor.get$node();
    },
    get$isInstanceMember: function() {
      return true;
    },
    computeType$1: function(compiler) {
      compiler.internalError$2(this, this.toString$0(0) + ".computeType.");
    },
    get$position: function(_) {
      var t1 = this.$constructor;
      return t1.get$position(t1);
    },
    get$outermostEnclosingMemberOrTopLevel: function() {
      return this.$constructor;
    },
    get$analyzableElement: function() {
      return this.$constructor.get$analyzableElement();
    },
    accept$1: function(_, visitor) {
      return visitor.visitConstructorBodyElement$1(this);
    },
    get$memberContext: function() {
      return this.$constructor;
    },
    $isConstructorBodyElement: true,
    $isFunctionElement: true,
    $isAstElement: true,
    $isElement: true
  },
  SynthesizedConstructorElementX: {
    "^": "ConstructorElementX;definingConstructor<,isDefaultConstructor,immediateRedirectionTarget,internalEffectiveTarget,effectiveTargetType,resolution$AnalyzableElementX$_treeElements,typeCache,modifiers,nestedClosures,functionSignatureCache,_hasNoBody,abstractField,modelx$PatchMixin$patch,modelx$PatchMixin$origin,name,kind,enclosingElement,hashCode,metadata,_fixedBackendName,_isNative",
    parseNode$1: function(listener) {
      return;
    },
    get$node: function() {
      return;
    },
    get$position: function(_) {
      var t1 = this.enclosingElement;
      return t1.get$position(t1);
    },
    get$isSynthesized: function() {
      return true;
    },
    computeSignature$1: function(compiler) {
      var t1 = this.functionSignatureCache;
      if (t1 != null)
        return t1;
      if (this.isDefaultConstructor) {
        t1 = new U.FunctionSignatureX(C.C_Link, C.C_Link, 0, 0, false, C.List_empty8, V.FunctionType_FunctionType(this, this.enclosingElement.get$thisType(), C.List_empty3, C.List_empty3, C.List_empty0, C.List_empty3));
        this.functionSignatureCache = t1;
        return t1;
      }
      t1 = this.definingConstructor;
      if (t1.get$isErroneous()) {
        t1 = compiler.objectClass.localLookup$1("").computeSignature$1(compiler);
        this.functionSignatureCache = t1;
        return t1;
      }
      t1 = t1.computeSignature$1(compiler);
      this.functionSignatureCache = t1;
      return t1;
    },
    accept$1: function(_, visitor) {
      return visitor.visitFunctionElement$1(this);
    }
  },
  TypeDeclarationElementX: {
    "^": "Object;thisTypeCache:modelx$TypeDeclarationElementX$thisTypeCache@,rawTypeCache:modelx$TypeDeclarationElementX$rawTypeCache?",
    get$thisType: function() {
      return this.modelx$TypeDeclarationElementX$thisTypeCache;
    },
    get$rawType: function() {
      return this.modelx$TypeDeclarationElementX$rawTypeCache;
    },
    setThisAndRawTypes$2: function(compiler, typeParameters) {
      var t1, t2;
      t1 = this.createType$1(typeParameters);
      this.modelx$TypeDeclarationElementX$thisTypeCache = t1;
      t2 = typeParameters.length;
      if (t2 === 0)
        this.modelx$TypeDeclarationElementX$rawTypeCache = t1;
      else
        this.modelx$TypeDeclarationElementX$rawTypeCache = this.createType$1(P.List_List$filled(t2, C.C_DynamicType, null));
    },
    get$typeVariables: function() {
      return this.get$thisType().typeArguments;
    },
    createTypeVariables$1: function(parameters) {
      var t1, nodes;
      t1 = {};
      if (parameters == null)
        return C.List_empty3;
      nodes = parameters.nodes;
      t1.nodes_0 = nodes;
      return P.List_List$generate(nodes.slowLength$0(), new U.TypeDeclarationElementX_createTypeVariables_closure(t1, this), false, null);
    },
    get$isResolved: function() {
      return this.get$resolutionState() === 2;
    },
    $isAstElement: true,
    $isElement: true
  },
  TypeDeclarationElementX_createTypeVariables_closure: {
    "^": "Closure:13;box_0,this_1",
    call$1: function(_) {
      var t1, t2, node, variableName, variableElement, variableType;
      t1 = this.box_0;
      t2 = t1.nodes_0;
      node = t2.get$head(t2);
      t2 = J.get$name$x(node).token;
      variableName = t2.get$value(t2);
      t1.nodes_0 = t1.nodes_0.get$tail();
      t1 = $.ElementX_elementHashCode + 1;
      $.ElementX_elementHashCode = t1;
      variableElement = new U.TypeVariableElementX(node, null, null, variableName, C.ElementKind_type_variable_128, this.this_1, t1, C.C_Link2, null, false);
      variableType = new V.TypeVariableType(variableElement);
      variableElement.typeCache = variableType;
      return variableType;
    },
    $isFunction: true
  },
  BaseClassElementX: {
    "^": "ElementX_AstElementMixin_AnalyzableElementX_TypeDeclarationElementX_PatchMixin_ClassMemberMixin;id>,supertype<,interfaces<,nativeTagInfo<,supertypeLoadState?,resolutionState@,isProxy<,allSupertypesAndSelf<",
    get$allSupertypes: function() {
      return this.allSupertypesAndSelf._supertypes;
    },
    get$hierarchyDepth: function() {
      return this.allSupertypesAndSelf._levels.length - 1;
    },
    get$hashCode: function(_) {
      return this.id;
    },
    get$isUnnamedMixinApplication: function() {
      return false;
    },
    computeType$1: function(compiler) {
      if (this.get$thisTypeCache() == null)
        this.computeThisAndRawType$2(compiler, this.computeTypeParameters$1(compiler));
      return this.get$thisTypeCache();
    },
    computeThisAndRawType$2: function(compiler, typeVariables) {
      if (this.get$thisTypeCache() == null)
        if (this.get$origin(this) == null)
          this.setThisAndRawTypes$2(compiler, typeVariables);
        else {
          this.set$thisTypeCache(this.get$origin(this).computeType$1(compiler));
          this.set$rawTypeCache(this.get$origin(this).get$rawType());
        }
    },
    createType$1: function(typeArguments) {
      var t1 = new V.InterfaceType(this, typeArguments);
      t1.GenericType$3$checkTypeArgumentCount(this, typeArguments, true);
      return t1;
    },
    asInstanceOf$1: function(cls) {
      if (cls === this)
        return this.get$thisType();
      return this.allSupertypesAndSelf.asInstanceOf$1(cls);
    },
    isObject$1: [function(compiler) {
      var t1, t2;
      t1 = this.get$declaration();
      t2 = compiler.objectClass;
      return t1 == null ? t2 == null : t1 === t2;
    }, "call$1", "get$isObject", 2, 0, 177],
    ensureResolved$1: function(compiler) {
      if (this.resolutionState === 0)
        compiler.resolver.resolveClass$1(this);
    },
    addBackendMember$1: function(member) {
      this.backendMembers = this.backendMembers.prepend$1(member);
    },
    lookupLocalMember$1: function(memberName) {
      var result, t1;
      result = this.localLookup$1(memberName);
      if (result != null)
        t1 = result.get$kind(result) === C.ElementKind_generative_constructor_16 || result.get$isFactoryConstructor();
      else
        t1 = false;
      if (t1)
        return;
      return result;
    },
    lookupBackendMember$1: function(memberName) {
      var t1, element;
      for (t1 = this.backendMembers, t1 = H.setRuntimeTypeInfo(new E.LinkIterator(null, t1), [H.getTypeArgumentByIndex(t1, 0)]); t1.moveNext$0();) {
        element = t1._util_implementation$_current;
        if (J.get$name$x(element) === memberName)
          return element;
      }
      return;
    },
    lookupSuperMember$1: function(memberName) {
      return this.lookupSuperMemberInLibrary$2(memberName, this.get$enclosingElement().get$library());
    },
    lookupSuperMemberInLibrary$2: function(memberName, library) {
      var isPrivate, s, t1, e;
      isPrivate = !J.getInterceptor$asx(memberName).get$isEmpty(memberName) && C.JSString_methods.codeUnitAt$1(memberName, 0) === 95;
      s = this.get$superclass();
      while (s != null) {
        c$0: {
          if (isPrivate) {
            t1 = s.get$enclosingElement().get$library();
            t1 = library == null ? t1 != null : library !== t1;
          } else
            t1 = false;
          if (t1)
            break c$0;
          e = s.lookupLocalMember$1(memberName);
          if (e == null)
            break c$0;
          if (e.get$isStatic())
            break c$0;
          return e;
        }
        s = s.get$supertype() == null ? null : s.supertype.get$element();
      }
      return;
    },
    lookupSelector$2: function(selector, compiler) {
      return this.internalLookupSelector$3(selector, compiler, false);
    },
    lookupSuperSelector$2: function(selector, compiler) {
      return this.internalLookupSelector$3(selector, compiler, true);
    },
    internalLookupSelector$3: function(selector, compiler, isSuperLookup) {
      var $name, isPrivate, library, current, member, t1, getter, setter;
      $name = selector.name;
      isPrivate = !J.getInterceptor$asx($name).get$isEmpty($name) && C.JSString_methods.codeUnitAt$1($name, 0) === 95;
      library = selector.library;
      current = isSuperLookup ? this.get$superclass() : this;
      while (current != null) {
        c$0: {
          member = current.lookupLocalMember$1($name);
          if (member == null && current.get$isPatched())
            member = current.get$patch().lookupLocalMember$1($name);
          if (member == null)
            break c$0;
          if (isPrivate) {
            t1 = member.get$library();
            t1 = library == null ? t1 != null : library !== t1;
          } else
            t1 = false;
          if (t1)
            break c$0;
          if (member.get$isStatic() && this !== current)
            break c$0;
          if (member.kind === C.ElementKind_abstract_field_1) {
            getter = member.get$getter();
            setter = member.setter;
            if (selector.kind === C.SelectorKind_setter_1) {
              if (setter != null && !setter.get$isAbstract())
                return setter;
            } else if (getter != null && !getter.get$isAbstract())
              return getter;
          } else if (!member.get$isAbstract())
            return member;
        }
        current = current.get$supertype() == null ? null : current.supertype.get$element();
      }
      return;
    },
    lookupMember$1: function(memberName) {
      var localMember = this.lookupLocalMember$1(memberName);
      return localMember == null ? this.lookupSuperMemberInLibrary$2(memberName, this.get$enclosingElement().get$library()) : localMember;
    },
    hasFieldShadowedBy$1: function(fieldMember) {
      var fieldName, isPrivate, memberLibrary, lookupClass, foundMember, t1;
      fieldName = fieldMember.name;
      isPrivate = !J.getInterceptor$asx(fieldName).get$isEmpty(fieldName) && C.JSString_methods.codeUnitAt$1(fieldName, 0) === 95;
      memberLibrary = fieldMember.get$library();
      lookupClass = this.get$superclass();
      for (; lookupClass != null;) {
        foundMember = lookupClass.lookupLocalMember$1(fieldName);
        if (foundMember != null)
          if (foundMember.get$kind(foundMember) === C.ElementKind_field_1) {
            if (isPrivate) {
              t1 = foundMember.get$library();
              t1 = memberLibrary == null ? t1 == null : memberLibrary === t1;
            } else
              t1 = true;
            if (t1)
              return true;
          }
        lookupClass = lookupClass.get$supertype() == null ? null : lookupClass.supertype.get$element();
      }
      return false;
    },
    lookupConstructor$2: function(selector, noMatch) {
      var t1, result, t2;
      t1 = selector.name;
      result = this.localLookup$1(t1);
      if (result != null)
        if (result.get$kind(result) === C.ElementKind_generative_constructor_16 || result.get$isFactoryConstructor())
          if (!J.getInterceptor$asx(t1).get$isEmpty(t1) && C.JSString_methods.codeUnitAt$1(t1, 0) === 95) {
            t1 = result.get$library();
            t2 = selector.library;
            t2 = t1 == null ? t2 != null : t1 !== t2;
            t1 = t2;
          } else
            t1 = false;
        else
          t1 = true;
      else
        t1 = true;
      if (t1)
        result = noMatch != null ? noMatch.call$1(result) : null;
      return result;
    },
    lookupConstructor$1: function(selector) {
      return this.lookupConstructor$2(selector, null);
    },
    get$constructors: function() {
      var t1 = {};
      t1.result_0 = C.C_Link;
      this.forEachMember$1(new U.BaseClassElementX_constructors_closure(t1));
      return t1.result_0;
    },
    get$superclass: function() {
      var t1 = this.supertype;
      return t1 == null ? null : t1.get$element();
    },
    forEachMember$3$includeBackendMembers$includeSuperAndInjectedMembers: function(f, includeBackendMembers, includeSuperAndInjectedMembers) {
      var t1, includeInjectedMembers, classElement, t2;
      t1 = {};
      includeInjectedMembers = includeSuperAndInjectedMembers || this.get$isPatch();
      classElement = this.get$declaration();
      t1.classElement_0 = classElement;
      t2 = classElement;
      do {
        t2.forEachLocalMember$1(new U.BaseClassElementX_forEachMember_closure(t1, f));
        if (includeBackendMembers)
          t1.classElement_0.forEachBackendMember$1(new U.BaseClassElementX_forEachMember_closure0(t1, f));
        if (includeInjectedMembers)
          if (t1.classElement_0.get$patch() != null)
            t1.classElement_0.get$patch().forEachLocalMember$1(new U.BaseClassElementX_forEachMember_closure1(t1, f));
        classElement = includeSuperAndInjectedMembers ? t1.classElement_0.get$superclass() : null;
        t1.classElement_0 = classElement;
        if (classElement != null) {
          t2 = classElement;
          continue;
        } else
          break;
      } while (true);
    },
    forEachMember$1: function(f) {
      return this.forEachMember$3$includeBackendMembers$includeSuperAndInjectedMembers(f, false, false);
    },
    forEachMember$2$includeSuperAndInjectedMembers: function(f, includeSuperAndInjectedMembers) {
      return this.forEachMember$3$includeBackendMembers$includeSuperAndInjectedMembers(f, false, includeSuperAndInjectedMembers);
    },
    forEachMember$2$includeBackendMembers: function(f, includeBackendMembers) {
      return this.forEachMember$3$includeBackendMembers$includeSuperAndInjectedMembers(f, includeBackendMembers, false);
    },
    forEachInstanceField$2$includeSuperAndInjectedMembers: function(f, includeSuperAndInjectedMembers) {
      this.forEachMember$2$includeSuperAndInjectedMembers(new U.BaseClassElementX_forEachInstanceField_fieldFilter(f), includeSuperAndInjectedMembers);
    },
    forEachInstanceField$1: function(f) {
      return this.forEachInstanceField$2$includeSuperAndInjectedMembers(f, false);
    },
    forEachStaticField$1: function(f) {
      this.forEachMember$1(new U.BaseClassElementX_forEachStaticField_fieldFilter(f));
    },
    forEachBackendMember$1: function(f) {
      this.backendMembers.forEach$1(0, f);
    },
    implementsInterface$1: function(intrface) {
      var t1;
      for (t1 = this.allSupertypesAndSelf._supertypes, t1.toString, t1 = H.setRuntimeTypeInfo(new E.LinkIterator(null, t1), [H.getTypeArgumentByIndex(t1, 0)]); t1.moveNext$0();)
        if (t1._util_implementation$_current.get$element() === intrface)
          return true;
      return false;
    },
    isSubclassOf$1: function(cls) {
      var s;
      cls = cls.get$declaration();
      for (s = this.get$declaration(); s != null; s = s.get$superclass())
        if (s == null ? cls == null : s === cls)
          return true;
      return false;
    },
    get$isNative: function() {
      return this.nativeTagInfo != null;
    },
    setNative$1: function($name) {
      this.nativeTagInfo = $name;
    },
    get$callType: function() {
      var member = this.lookupInterfaceMember$1(C.PublicName_call_false);
      return member != null && member.get$isMethod() ? member.get$type(member) : null;
    },
    get$patch: function() {
      return this.modelx$PatchMixin$patch;
    },
    get$origin: function(_) {
      return this.modelx$PatchMixin$origin;
    },
    get$definingElement: function() {
      return this.get$declaration();
    },
    $isClassElement: true,
    $isScopeContainerElement: true,
    $isElement: true,
    $isAstElement: true
  },
  ElementX_AstElementMixin2: {
    "^": "ElementX+AstElementMixin;",
    $isAstElement: true,
    $isElement: true
  },
  ElementX_AstElementMixin_AnalyzableElementX0: {
    "^": "ElementX_AstElementMixin2+AnalyzableElementX;_treeElements:resolution$AnalyzableElementX$_treeElements<",
    $isAnalyzableElementX: true,
    $isElement: true
  },
  ElementX_AstElementMixin_AnalyzableElementX_TypeDeclarationElementX0: {
    "^": "ElementX_AstElementMixin_AnalyzableElementX0+TypeDeclarationElementX;thisTypeCache:modelx$TypeDeclarationElementX$thisTypeCache@,rawTypeCache:modelx$TypeDeclarationElementX$rawTypeCache?",
    $isAstElement: true,
    $isElement: true
  },
  ElementX_AstElementMixin_AnalyzableElementX_TypeDeclarationElementX_PatchMixin: {
    "^": "ElementX_AstElementMixin_AnalyzableElementX_TypeDeclarationElementX0+PatchMixin;patch:modelx$PatchMixin$patch<,origin:modelx$PatchMixin$origin>",
    $isElement: true
  },
  ElementX_AstElementMixin_AnalyzableElementX_TypeDeclarationElementX_PatchMixin_ClassMemberMixin: {
    "^": "ElementX_AstElementMixin_AnalyzableElementX_TypeDeclarationElementX_PatchMixin+ClassMemberMixin;interfaceMembersAreClassMembers:compute_members$ClassMemberMixin$interfaceMembersAreClassMembers<",
    $isClassElement: true,
    $isScopeContainerElement: true,
    $isElement: true,
    $isAstElement: true
  },
  BaseClassElementX_constructors_closure: {
    "^": "Closure:48;box_0",
    call$2: function(_, member) {
      var t1;
      if (J.get$kind$x(member) === C.ElementKind_generative_constructor_16 || member.get$isFactoryConstructor()) {
        t1 = this.box_0;
        t1.result_0 = t1.result_0.prepend$1(member);
      }
    },
    $isFunction: true
  },
  BaseClassElementX_forEachMember_closure: {
    "^": "Closure:13;box_0,f_1",
    call$1: function(e) {
      return this.f_1.call$2(this.box_0.classElement_0, e);
    },
    $isFunction: true
  },
  BaseClassElementX_forEachMember_closure0: {
    "^": "Closure:13;box_0,f_2",
    call$1: function(e) {
      return this.f_2.call$2(this.box_0.classElement_0, e);
    },
    $isFunction: true
  },
  BaseClassElementX_forEachMember_closure1: {
    "^": "Closure:13;box_0,f_3",
    call$1: function(e) {
      if (!e.get$isPatch())
        this.f_3.call$2(this.box_0.classElement_0, e);
    },
    $isFunction: true
  },
  BaseClassElementX_forEachInstanceField_fieldFilter: {
    "^": "Closure:51;f_0",
    call$2: function(enclosingClass, member) {
      if (member.get$isInstanceMember() && member.kind === C.ElementKind_field_1)
        this.f_0.call$2(enclosingClass, member);
    },
    $isFunction: true
  },
  BaseClassElementX_forEachStaticField_fieldFilter: {
    "^": "Closure:51;f_0",
    call$2: function(enclosingClass, member) {
      if (!member.get$isInstanceMember() && member.kind === C.ElementKind_field_1)
        this.f_0.call$2(enclosingClass, member);
    },
    $isFunction: true
  },
  ClassElementX: {
    "^": "BaseClassElementX;localScope<",
    get$localMembers: function() {
      var t1 = this.localMembersCache;
      if (t1 == null) {
        t1 = this.localMembersReversed.reverse$0();
        this.localMembersCache = t1;
      }
      return t1;
    },
    get$isMixinApplication: function() {
      return false;
    },
    addMember$2: function(element, listener) {
      var t1, t2;
      this.localMembersCache = null;
      this.localMembersReversed = this.localMembersReversed.prepend$1(element);
      if (element.get$kind(element) === C.ElementKind_field_1) {
        t1 = element.get$name(element);
        t2 = this.name;
        t2 = t1 == null ? t2 == null : t1 === t2;
        t1 = t2;
      } else
        t1 = false;
      if (t1)
        listener.reportDiagnosticInternal$4(element, C.MessageKind_bTF, C.Map_empty, C.Diagnostic_1_error);
      this.localScope.add$2(0, element, listener);
    },
    localLookup$1: function(elementName) {
      var result = this.localScope.contents.$index(0, elementName);
      return result == null && this.get$isPatch() ? this.modelx$PatchMixin$origin.localLookup$1(elementName) : result;
    },
    forEachLocalMember$1: function(f) {
      this.get$localMembers().forEach$1(0, f);
    },
    get$hasConstructor: function() {
      for (var t1 = this.localScope.contents, t1 = t1.get$values(t1), t1 = H.setRuntimeTypeInfo(new H.MappedIterator(null, J.get$iterator$ax(t1._iterable), t1._f), [H.getTypeArgumentByIndex(t1, 0), H.getTypeArgumentByIndex(t1, 1)]); t1.moveNext$0();)
        if (t1.__internal$_current.get$isConstructor())
          return true;
      return false;
    },
    setDefaultConstructor$2: function($constructor, compiler) {
      this.addMember$2($constructor, compiler);
    },
    computeTypeParameters$1: function(compiler) {
      return this.createTypeVariables$1(this.parseNode$1(compiler).get$typeParameters());
    },
    buildScope$0: function() {
      return new A.ClassScope(this, this.get$enclosingElement().buildScope$0());
    },
    toString$0: function(_) {
      if (this.modelx$PatchMixin$origin != null)
        return "patch " + U.ElementX.prototype.toString$0.call(this, this);
      else if (this.modelx$PatchMixin$patch != null)
        return "origin " + U.ElementX.prototype.toString$0.call(this, this);
      else
        return U.ElementX.prototype.toString$0.call(this, this);
    }
  },
  MixinApplicationElementX: {
    "^": "BaseClassElementX;node<,modifiers<,constructors<,mixinType@,id,supertype,interfaces,nativeTagInfo,supertypeLoadState,resolutionState,isProxy,hasIncompleteHierarchy,backendMembers,allSupertypesAndSelf,compute_members$ClassMemberMixin$computedMemberNames,compute_members$ClassMemberMixin$interfaceMembersAreClassMembers,compute_members$ClassMemberMixin$classMembers,compute_members$ClassMemberMixin$interfaceMembers,modelx$PatchMixin$patch,modelx$PatchMixin$origin,modelx$TypeDeclarationElementX$thisTypeCache,modelx$TypeDeclarationElementX$rawTypeCache,resolution$AnalyzableElementX$_treeElements,name,kind,enclosingElement,hashCode,metadata,_fixedBackendName,_isNative",
    get$mixin: function() {
      var t1 = this.mixinType;
      return t1 != null ? t1.get$element() : null;
    },
    get$isMixinApplication: function() {
      return true;
    },
    get$isUnnamedMixinApplication: function() {
      return !J.getInterceptor(this.node).$isNamedMixinApplication;
    },
    get$hasConstructor: function() {
      var t1 = this.constructors;
      return !t1.get$isEmpty(t1);
    },
    get$patch: function() {
      return;
    },
    get$origin: function(_) {
      return;
    },
    get$position: function(_) {
      return this.node.getBeginToken$0();
    },
    parseNode$1: function(listener) {
      return this.node;
    },
    lookupLocalConstructor$1: function($name) {
      var link;
      for (link = this.constructors; !link.get$isEmpty(link); link = link.get$tail())
        if (J.$eq(J.get$name$x(link.get$head(link)), $name))
          return link.get$head(link);
      return;
    },
    localLookup$1: function($name) {
      var $constructor, t1, mixedInElement;
      $constructor = this.lookupLocalConstructor$1($name);
      if ($constructor != null)
        return $constructor;
      t1 = this.mixinType;
      if ((t1 != null ? t1.get$element() : null) == null)
        return;
      t1 = this.mixinType;
      mixedInElement = (t1 != null ? t1.get$element() : null).localLookup$1($name);
      if (mixedInElement == null)
        return;
      return mixedInElement.get$isInstanceMember() ? mixedInElement : null;
    },
    forEachLocalMember$1: function(f) {
      var t1;
      this.constructors.forEach$1(0, f);
      t1 = this.mixinType;
      if ((t1 != null ? t1.get$element() : null) != null) {
        t1 = this.mixinType;
        t1 = t1 != null ? t1.get$element() : null;
        t1.forEachLocalMember$1(new U.MixinApplicationElementX_forEachLocalMember_closure(f));
      }
    },
    setDefaultConstructor$2: function($constructor, compiler) {
      this.constructors = this.constructors.prepend$1($constructor);
    },
    computeTypeParameters$1: function(compiler) {
      var t1, named;
      t1 = this.node;
      named = t1.asNamedMixinApplication$0();
      if (named == null)
        throw H.wrapException(O.SpannableAssertionFailure$(t1, "Type variables on unnamed mixin applications must be set on creation."));
      return this.createTypeVariables$1(named.typeParameters);
    },
    accept$1: function(_, visitor) {
      return visitor.visitClassElement$1(this);
    },
    $isMixinApplicationElement: true,
    $isClassElement: true,
    $isScopeContainerElement: true,
    $isElement: true,
    $isAstElement: true
  },
  MixinApplicationElementX_forEachLocalMember_closure: {
    "^": "Closure:77;f_0",
    call$1: function(mixedInElement) {
      if (mixedInElement.get$isInstanceMember())
        this.f_0.call$1(mixedInElement);
    },
    $isFunction: true
  },
  LabelDefinitionX: {
    "^": "Object;label>,labelName<,target>,isBreakTarget@,isContinueTarget@",
    get$name: function(_) {
      var t1 = this.label;
      if (t1 == null)
        t1 = this.labelName;
      else {
        t1 = t1.identifier.token;
        t1 = t1.get$value(t1);
      }
      return t1;
    },
    get$isTarget: function() {
      return this.isBreakTarget || this.isContinueTarget;
    },
    toString$0: function(_) {
      var t1 = this.label;
      if (t1 == null)
        t1 = this.labelName;
      else {
        t1 = t1.identifier.token;
        t1 = t1.get$value(t1);
      }
      return "Label:" + H.S(t1);
    }
  },
  JumpTargetX: {
    "^": "Object;executableContext<,statement<,nestingLevel<,labels>,isBreakTarget@,isContinueTarget@",
    get$name: function(_) {
      return "target";
    },
    get$isTarget: function() {
      return this.isBreakTarget || this.isContinueTarget;
    },
    addLabel$2: function(label, labelName) {
      var result = new U.LabelDefinitionX(label, labelName, this, false, false);
      this.labels = this.labels.prepend$1(result);
      return result;
    },
    get$isSwitch: function() {
      return !!J.getInterceptor(this.statement).$isSwitchStatement;
    },
    toString$0: function(_) {
      return "Target:" + J.toString$0(this.statement);
    },
    $isLocal: true
  },
  TypeVariableElementX: {
    "^": "ElementX_AstElementMixin3;node<,typeCache,boundCache<,name,kind,enclosingElement,hashCode,metadata,_fixedBackendName,_isNative",
    computeType$1: function(compiler) {
      return this.get$type(this);
    },
    get$type: function(_) {
      return this.typeCache;
    },
    get$bound: function() {
      return this.boundCache;
    },
    parseNode$1: function(compiler) {
      return this.node;
    },
    toString$0: function(_) {
      return J.toString$0(this.enclosingElement) + "." + H.S(this.name);
    },
    get$position: function(_) {
      return this.node.name.token;
    },
    accept$1: function(_, visitor) {
      return visitor.visitElement$1(this);
    },
    get$definingElement: function() {
      return this;
    },
    $isElement: true,
    $isAstElement: true
  },
  ElementX_AstElementMixin3: {
    "^": "ElementX+AstElementMixin;",
    $isAstElement: true,
    $isElement: true
  },
  MetadataAnnotationX: {
    "^": "Object;value>,annotatedElement@,resolutionState<",
    ensureResolved$1: function(compiler) {
      if (this.resolutionState === 0)
        compiler.resolver.resolveMetadataAnnotation$1(this);
      return this;
    },
    toString$0: function(_) {
      return "MetadataAnnotation(" + J.toString$0(this.value) + ", " + H.S(this.resolutionState) + ")";
    },
    $isMetadataAnnotation: true
  },
  ParameterMetadataAnnotation: {
    "^": "MetadataAnnotationX;metadata<,value,annotatedElement,resolutionState",
    parseNode$1: function(listener) {
      return this.metadata.expression;
    },
    get$beginToken: function() {
      return this.metadata.token;
    },
    get$endToken: function() {
      return this.metadata.expression.getEndToken$0();
    }
  },
  PatchMixin: {
    "^": "Object;patch:modelx$PatchMixin$patch<,origin:modelx$PatchMixin$origin>",
    get$isPatch: function() {
      return this.get$origin(this) != null;
    },
    get$isPatched: function() {
      return this.get$patch() != null;
    },
    get$isDeclaration: function() {
      return !this.get$isPatch();
    },
    get$implementation: function(_) {
      return this.get$isPatched() ? this.get$patch() : this;
    },
    get$declaration: function() {
      return this.get$isPatch() ? this.get$origin(this) : this;
    },
    applyPatch$1: function(patch) {
      this.modelx$PatchMixin$patch = patch;
      patch.modelx$PatchMixin$origin = this;
    },
    $isElement: true
  },
  AstElementMixin: {
    "^": "Object;",
    get$resolvedAst: function() {
      return new O.ResolvedAst(this.get$declaration(), this.get$definingElement().get$node(), this.get$definingElement().get$treeElements());
    },
    $isAstElement: true,
    $isElement: true
  }
}],
["html_common", "dart:html_common", , P, {
  "^": "",
  Device_isWebKit: function() {
    var t1 = $.Device__isWebKit;
    if (t1 == null) {
      t1 = $.Device__isOpera;
      if (t1 == null) {
        t1 = J.contains$2$asx(window.navigator.userAgent, "Opera", 0);
        $.Device__isOpera = t1;
      }
      t1 = t1 !== true && J.contains$2$asx(window.navigator.userAgent, "WebKit", 0);
      $.Device__isWebKit = t1;
    }
    return t1;
  }
}],
["inferrer_visitor", "package:compiler/implementation/inferrer/inferrer_visitor.dart", , X, {
  "^": "",
  TypeSystem: {
    "^": "Object;"
  },
  VariableScope: {
    "^": "Object;variables,parent>,block<",
    $index: function(_, variable) {
      var t1, result;
      t1 = this.variables;
      if (t1 != null) {
        result = t1.$index(0, variable);
        t1 = result == null;
      } else {
        result = null;
        t1 = true;
      }
      if (t1) {
        t1 = this.parent;
        return t1 == null ? null : t1.$index(0, variable);
      }
      return result;
    },
    $indexSet: function(_, variable, mask) {
      var t1 = this.variables;
      if (t1 == null) {
        t1 = P.LinkedHashMap_LinkedHashMap(null, null, null, O.Local, H.getTypeArgumentByIndex(this, 0));
        this.variables = t1;
      }
      t1.$indexSet(0, variable, mask);
    },
    forEachOwnLocal$1: function(f) {
      var t1 = this.variables;
      if (t1 == null)
        return;
      t1.forEach$1(0, f);
    },
    forEachLocalUntilNode$3: function(node, f, seenLocals) {
      var t1, t2;
      t1 = {};
      t1.seenLocals_0 = seenLocals;
      if (seenLocals == null)
        t1.seenLocals_0 = H.setRuntimeTypeInfo(new N.Setlet(C.C__SetletMarker, null), [O.Local]);
      t2 = this.variables;
      if (t2 != null)
        t2.forEach$1(0, new X.VariableScope_forEachLocalUntilNode_closure(t1, f));
      t2 = this.block;
      if (t2 == null ? node == null : t2 === node)
        return;
      t2 = this.parent;
      if (t2 != null)
        t2.forEachLocalUntilNode$3(node, f, t1.seenLocals_0);
    },
    forEachLocalUntilNode$2: function(node, f) {
      return this.forEachLocalUntilNode$3(node, f, null);
    },
    updates$1: function(variable) {
      var t1 = this.variables;
      if (t1 == null)
        return false;
      return t1.containsKey$1(variable);
    },
    toString$0: function(_) {
      var t1, rest;
      t1 = this.parent;
      rest = t1 == null ? "null" : J.toString$0(t1);
      return J.toString$0(this.variables) + " " + rest;
    },
    static: {VariableScope$deepCopyOf: function(other, $T) {
        var t1, t2, t3;
        t1 = other.variables;
        if (t1 == null)
          t1 = null;
        else {
          t2 = P.LinkedHashMap_LinkedHashMap(null, null, null, O.Local, $T);
          t2.addAll$1(0, t1);
          t1 = t2;
        }
        t2 = other.block;
        t3 = other.parent;
        t3 = t3 == null ? null : X.VariableScope$deepCopyOf(t3, $T);
        return H.setRuntimeTypeInfo(new X.VariableScope(t1, t3, t2), [$T]);
      }}
  },
  VariableScope_forEachLocalUntilNode_closure: {
    "^": "Closure:19;box_0,f_1",
    call$2: function(variable, type) {
      var t1 = this.box_0;
      if (t1.seenLocals_0.contains$1(0, variable) === true)
        return;
      t1.seenLocals_0.add$1(0, variable);
      this.f_1.call$2(variable, type);
    },
    $isFunction: true
  },
  FieldInitializationScope: {
    "^": "Object;types<,fields<,isThisExposed",
    updateField$2: function(field, type) {
      var t1;
      if (this.isThisExposed)
        return;
      t1 = this.fields;
      if (t1 == null) {
        t1 = P.LinkedHashMap_LinkedHashMap(null, null, null, O.Element, H.getTypeArgumentByIndex(this, 0));
        this.fields = t1;
      }
      t1.$indexSet(0, field, type);
    },
    forEach$1: function(_, f) {
      var t1 = this.fields;
      if (t1 == null)
        return;
      t1.forEach$1(0, f);
    },
    mergeDiamondFlow$2: function(thenScope, elseScope) {
      var t1 = {};
      t1.elseScope_0 = elseScope;
      if (this.isThisExposed)
        return;
      if (elseScope == null || elseScope.fields == null)
        t1.elseScope_0 = this;
      thenScope.forEach$1(0, new X.FieldInitializationScope_mergeDiamondFlow_closure(t1, this));
      this.isThisExposed = thenScope.isThisExposed || t1.elseScope_0.isThisExposed;
    },
    static: {FieldInitializationScope_FieldInitializationScope$from: function(other, $T) {
        if (other == null)
          return;
        return H.setRuntimeTypeInfo(new X.FieldInitializationScope(other.types, null, other.isThisExposed), [$T]);
      }}
  },
  FieldInitializationScope_mergeDiamondFlow_closure: {
    "^": "Closure;box_0,this_1",
    call$2: function(field, type) {
      var t1, otherType;
      t1 = this.box_0.elseScope_0.fields;
      otherType = t1 == null ? null : t1.$index(0, field);
      if (otherType == null)
        return;
      t1 = this.this_1;
      t1.updateField$2(field, t1.types.allocateDiamondPhi$2(type, otherType));
    },
    $isFunction: true,
    $signature: function() {
      return H.computeSignature(function(T) {
        return {func: "dynamic__Element_T", args: [O.Element, T]};
      }, this.this_1, "FieldInitializationScope");
    }
  },
  ArgumentsTypes: {
    "^": "Object;positional<,named",
    get$length: function(_) {
      var t1, t2;
      t1 = this.positional.length;
      t2 = this.named;
      t2 = t2.get$length(t2);
      if (typeof t2 !== "number")
        return H.iae(t2);
      return t1 + t2;
    },
    toString$0: function(_) {
      return "{ positional = " + H.S(this.positional) + ", named = " + J.toString$0(this.named) + " }";
    },
    $eq: function(_, other) {
      var t1, t2, t3, t4, i;
      if (other == null)
        return false;
      t1 = this.positional;
      if (t1.length !== other.get$positional().length)
        return false;
      t2 = this.named;
      t3 = t2.get$length(t2);
      t4 = other.named;
      t4 = t4.get$length(t4);
      if (t3 == null ? t4 != null : t3 !== t4)
        return false;
      for (t3 = other.positional, i = 0; i < t1.length; ++i) {
        t4 = t1[i];
        if (i >= t3.length)
          return H.ioore(t3, i);
        if (!J.$eq(t4, t3[i]))
          return false;
      }
      t2.forEach$1(0, new X.ArgumentsTypes_operator$eq_closure(other));
      return true;
    },
    get$hashCode: function(_) {
      return H.throwExpression(P.UnsupportedError$("ArgumentsTypes.hashCode"));
    },
    hasOnePositionalArgumentThatMatches$1: function(f) {
      var t1, t2;
      t1 = this.named;
      if (t1.get$isEmpty(t1)) {
        t1 = this.positional;
        t2 = t1.length;
        if (t2 === 1) {
          if (0 >= t2)
            return H.ioore(t1, 0);
          t1 = f.call$1(t1[0]) === true;
        } else
          t1 = false;
      } else
        t1 = false;
      return t1;
    },
    forEach$1: function(_, f) {
      var t1;
      H.IterableMixinWorkaround_forEach(this.positional, f);
      t1 = this.named;
      J.forEach$1$ax(t1.get$values(t1), f);
    },
    every$1: function(_, f) {
      var t1;
      if (H.IterableMixinWorkaround_every(this.positional, f)) {
        t1 = this.named;
        t1 = J.every$1$ax(t1.get$values(t1), f);
      } else
        t1 = false;
      return t1;
    },
    contains$1: function(_, type) {
      return C.JSArray_methods.contains$1(this.positional, type) || this.named.containsValue$1(type);
    },
    ArgumentsTypes$2: function(positional, named, $T) {
    },
    static: {ArgumentsTypes$: function(positional, named, $T) {
        var t1 = named == null || named.get$isEmpty(named) ? C.Map_empty : named;
        t1 = H.setRuntimeTypeInfo(new X.ArgumentsTypes(positional, t1), [$T]);
        t1.ArgumentsTypes$2(positional, named, $T);
        return t1;
      }}
  },
  ArgumentsTypes_operator$eq_closure: {
    "^": "Closure:19;other_0",
    call$2: function($name, type) {
      if (!J.$eq(this.other_0.named.$index(0, $name), type))
        return false;
    },
    $isFunction: true
  },
  LocalsHandler: {
    "^": "Object;compiler<,types<,inferrer,locals<,captured,capturedAndBoxed,fieldScope,tryBlock,seenReturnOrThrow<,seenBreakOrContinue",
    use$1: function(local) {
      var t1 = this.capturedAndBoxed;
      if (t1.containsKey$1(local))
        return this.inferrer.typeOfElement$1(t1.$index(0, local));
      else {
        if (this.captured.containsKey$1(local))
          this.inferrer.recordCapturedLocalRead$1(local);
        return this.locals.$index(0, local);
      }
    },
    update$3: function(local, type, node) {
      var t1, t2, t3, existing, inputType;
      t1 = {};
      t1.type_0 = type;
      t2 = this.compiler;
      if (t2.trustTypeAnnotations || t2.enableTypeAssertions)
        t1.type_0 = this.types.narrowType$2(type, J.get$type$x(local));
      t2 = new X.LocalsHandler_update_updateLocal(t1, this, local);
      t3 = this.capturedAndBoxed;
      if (t3.containsKey$1(local))
        this.inferrer.recordTypeOfNonFinalField$3(node, t3.$index(0, local), t1.type_0);
      else {
        t3 = this.tryBlock;
        if (t3 != null) {
          existing = t3.locals.parent.$index(0, local);
          if (existing != null) {
            t3 = this.types;
            inputType = t3.addPhiInput$3(local, t3.allocatePhi$3(this.tryBlock.locals.block, local, existing), t1.type_0);
            this.tryBlock.locals.parent.$indexSet(0, local, inputType);
          }
          t2.call$0();
        } else
          t2.call$0();
      }
    },
    mergeDiamondFlow$2: function(thenBranch, elseBranch) {
      var t1, t2;
      t1 = this.fieldScope;
      if (t1 != null && elseBranch != null)
        t1.mergeDiamondFlow$2(thenBranch.fieldScope, elseBranch.fieldScope);
      t1 = thenBranch.seenReturnOrThrow && elseBranch != null && elseBranch.seenReturnOrThrow;
      this.seenReturnOrThrow = t1;
      t2 = thenBranch.seenBreakOrContinue && elseBranch != null && elseBranch.seenBreakOrContinue;
      this.seenBreakOrContinue = t2;
      if (t1 || t2)
        return;
      t1 = new X.LocalsHandler_mergeDiamondFlow_inPlaceUpdateOneBranch(this);
      if (thenBranch.seenReturnOrThrow || thenBranch.seenBreakOrContinue) {
        if (elseBranch == null)
          return;
        t1.call$1(elseBranch);
      } else if (elseBranch == null)
        new X.LocalsHandler_mergeDiamondFlow_mergeOneBranch(this).call$1(thenBranch);
      else if (elseBranch.seenReturnOrThrow || elseBranch.seenBreakOrContinue)
        t1.call$1(thenBranch);
      else {
        t1 = new X.LocalsHandler_mergeDiamondFlow_mergeLocal(this, thenBranch, elseBranch);
        thenBranch.locals.forEachOwnLocal$1(new X.LocalsHandler_mergeDiamondFlow_closure(t1));
        elseBranch.locals.forEachOwnLocal$1(new X.LocalsHandler_mergeDiamondFlow_closure0(thenBranch, t1));
      }
    },
    mergeAfterBreaks$2$keepOwnLocals: function(handlers, keepOwnLocals) {
      var t1, seenLocals, t2, allBranchesAbort, handler;
      t1 = this.locals;
      seenLocals = H.setRuntimeTypeInfo(new N.Setlet(C.C__SetletMarker, null), [O.Local]);
      if (keepOwnLocals && !this.seenReturnOrThrow)
        this.mergeHandler$2(this, seenLocals);
      for (t2 = H.setRuntimeTypeInfo(new H.ListIterator(handlers, handlers.length, 0, null), [H.getTypeArgumentByIndex(handlers, 0)]), allBranchesAbort = true; t2.moveNext$0();) {
        handler = t2.__internal$_current;
        allBranchesAbort = allBranchesAbort && handler.get$seenReturnOrThrow();
        this.mergeHandler$2(handler, seenLocals);
      }
      t1.forEachLocalUntilNode$2(null, new X.LocalsHandler_mergeAfterBreaks_closure(this, t1.block, seenLocals));
      if (allBranchesAbort)
        t1 = !keepOwnLocals || this.seenReturnOrThrow;
      else
        t1 = false;
      this.seenReturnOrThrow = t1;
    },
    mergeAfterBreaks$1: function(handlers) {
      return this.mergeAfterBreaks$2$keepOwnLocals(handlers, true);
    },
    mergeHandler$2: function(other, seen) {
      var t1 = {};
      if (other.get$seenReturnOrThrow())
        return false;
      t1.changed_0 = false;
      other.locals.forEachLocalUntilNode$2(this.locals.block, new X.LocalsHandler_mergeHandler_closure(t1, this, seen));
      return t1.changed_0;
    },
    mergeHandler$1: function(other) {
      return this.mergeHandler$2(other, null);
    },
    mergeAll$1: function(handlers) {
      var t1 = {};
      t1.changed_0 = false;
      H.IterableMixinWorkaround_forEach(handlers, new X.LocalsHandler_mergeAll_closure(t1, this));
      return t1.changed_0;
    },
    startLoop$1: function(loop) {
      this.locals.forEachLocalUntilNode$2(null, new X.LocalsHandler_startLoop_closure(this, loop));
    },
    endLoop$1: function(loop) {
      this.locals.forEachLocalUntilNode$2(null, new X.LocalsHandler_endLoop_closure(this, loop));
    },
    LocalsHandler$from$3$useOtherTryBlock: function(other, block, useOtherTryBlock, $T) {
      this.tryBlock = useOtherTryBlock ? other.tryBlock : this;
    },
    static: {LocalsHandler$from: function(other, block, useOtherTryBlock, $T) {
        var t1, t2, t3, t4, t5, t6;
        t1 = H.setRuntimeTypeInfo(new X.VariableScope(null, other.locals, block), [$T]);
        t2 = X.FieldInitializationScope_FieldInitializationScope$from(other.fieldScope, $T);
        t3 = other.captured;
        t4 = other.capturedAndBoxed;
        t5 = other.types;
        t6 = other.inferrer;
        t2 = H.setRuntimeTypeInfo(new X.LocalsHandler(other.compiler, t5, t6, t1, t3, t4, t2, null, false, false), [$T]);
        t2.LocalsHandler$from$3$useOtherTryBlock(other, block, useOtherTryBlock, $T);
        return t2;
      }, LocalsHandler$deepCopyOf: function(other, $T) {
        var t1, t2, t3, t4, t5, t6, t7;
        t1 = X.VariableScope$deepCopyOf(other.locals, $T);
        t2 = X.FieldInitializationScope_FieldInitializationScope$from(other.fieldScope, $T);
        t3 = other.captured;
        t4 = other.capturedAndBoxed;
        t5 = other.tryBlock;
        t6 = other.types;
        t7 = other.inferrer;
        return H.setRuntimeTypeInfo(new X.LocalsHandler(other.compiler, t6, t7, t1, t3, t4, t2, t5, false, false), [$T]);
      }}
  },
  LocalsHandler_update_updateLocal: {
    "^": "Closure:23;box_0,this_1,local_2",
    call$0: function() {
      var t1, t2, t3, currentType, t4;
      t1 = this.this_1;
      t2 = t1.locals;
      t3 = this.local_2;
      currentType = t2.$index(0, t3);
      t4 = this.box_0;
      t2.$indexSet(0, t3, t4.type_0);
      if (!J.$eq(currentType, t4.type_0))
        t1.inferrer.recordLocalUpdate$2(t3, t4.type_0);
    },
    $isFunction: true
  },
  LocalsHandler_mergeDiamondFlow_mergeOneBranch: {
    "^": "Closure;this_0",
    call$1: function(other) {
      other.locals.forEachOwnLocal$1(new X.LocalsHandler_mergeDiamondFlow_mergeOneBranch_closure(this.this_0));
    },
    $isFunction: true,
    $signature: function() {
      return H.computeSignature(function(T) {
        return {func: "void__LocalsHandler", void: true, args: [[X.LocalsHandler, T]]};
      }, this.this_0, "LocalsHandler");
    }
  },
  LocalsHandler_mergeDiamondFlow_mergeOneBranch_closure: {
    "^": "Closure;this_1",
    call$2: function(local, type) {
      var t1, t2, myType;
      t1 = this.this_1;
      t2 = t1.locals;
      myType = t2.$index(0, local);
      if (myType == null)
        return;
      if (J.$eq(type, myType))
        return;
      t2.$indexSet(0, local, t1.types.allocateDiamondPhi$2(myType, type));
    },
    $isFunction: true,
    $signature: function() {
      return H.computeSignature(function(T) {
        return {func: "dynamic__Local_T", args: [O.Local, T]};
      }, this.this_1, "LocalsHandler");
    }
  },
  LocalsHandler_mergeDiamondFlow_inPlaceUpdateOneBranch: {
    "^": "Closure;this_2",
    call$1: function(other) {
      other.locals.forEachOwnLocal$1(new X.LocalsHandler_mergeDiamondFlow_inPlaceUpdateOneBranch_closure(this.this_2));
    },
    $isFunction: true,
    $signature: function() {
      return H.computeSignature(function(T) {
        return {func: "void__LocalsHandler", void: true, args: [[X.LocalsHandler, T]]};
      }, this.this_2, "LocalsHandler");
    }
  },
  LocalsHandler_mergeDiamondFlow_inPlaceUpdateOneBranch_closure: {
    "^": "Closure;this_3",
    call$2: function(local, type) {
      var t1, myType;
      t1 = this.this_3.locals;
      myType = t1.$index(0, local);
      if (myType == null)
        return;
      if (J.$eq(type, myType))
        return;
      t1.$indexSet(0, local, type);
    },
    $isFunction: true,
    $signature: function() {
      return H.computeSignature(function(T) {
        return {func: "dynamic__Local_T", args: [O.Local, T]};
      }, this.this_3, "LocalsHandler");
    }
  },
  LocalsHandler_mergeDiamondFlow_mergeLocal: {
    "^": "Closure:178;this_4,thenBranch_5,elseBranch_6",
    call$1: function(local) {
      var t1, t2, elseType, thenType;
      t1 = this.this_4;
      t2 = t1.locals;
      if (t2.$index(0, local) == null)
        return;
      elseType = this.elseBranch_6.locals.$index(0, local);
      thenType = this.thenBranch_5.locals.$index(0, local);
      if (J.$eq(thenType, elseType))
        t2.$indexSet(0, local, thenType);
      else
        t2.$indexSet(0, local, t1.types.allocateDiamondPhi$2(thenType, elseType));
    },
    $isFunction: true
  },
  LocalsHandler_mergeDiamondFlow_closure: {
    "^": "Closure:179;mergeLocal_7",
    call$2: function(local, _) {
      this.mergeLocal_7.call$1(local);
    },
    $isFunction: true
  },
  LocalsHandler_mergeDiamondFlow_closure0: {
    "^": "Closure:179;thenBranch_8,mergeLocal_9",
    call$2: function(local, _) {
      if (!this.thenBranch_8.locals.updates$1(local))
        this.mergeLocal_9.call$1(local);
    },
    $isFunction: true
  },
  LocalsHandler_mergeAfterBreaks_closure: {
    "^": "Closure;this_0,level_1,seenLocals_2",
    call$2: function(variable, type) {
      var t1, newType;
      if (this.seenLocals_2.contains$1(0, variable) !== true)
        return;
      t1 = this.this_0;
      newType = t1.types.simplifyPhi$3(this.level_1, variable, type);
      if (!J.$eq(newType, type))
        t1.locals.$indexSet(0, variable, newType);
    },
    $isFunction: true,
    $signature: function() {
      return H.computeSignature(function(T) {
        return {func: "dynamic__Local_T", args: [O.Local, T]};
      }, this.this_0, "LocalsHandler");
    }
  },
  LocalsHandler_mergeHandler_closure: {
    "^": "Closure:19;box_0,this_1,seen_2",
    call$2: function(local, otherType) {
      var t1, t2, myType, t3, t4, newType;
      t1 = this.this_1;
      t2 = t1.locals;
      myType = t2.$index(0, local);
      if (myType == null)
        return;
      t3 = this.seen_2;
      t4 = t3 != null && t3.contains$1(0, local) !== true;
      t1 = t1.types;
      if (t4) {
        newType = t1.allocatePhi$3(t2.block, local, otherType);
        t3.add$1(0, local);
      } else
        newType = t1.addPhiInput$3(local, myType, otherType);
      if (!J.$eq(newType, myType)) {
        this.box_0.changed_0 = true;
        t2.$indexSet(0, local, newType);
      }
    },
    $isFunction: true
  },
  LocalsHandler_mergeAll_closure: {
    "^": "Closure:13;box_0,this_1",
    call$1: function(other) {
      var changed = this.this_1.mergeHandler$1(other) || this.box_0.changed_0;
      this.box_0.changed_0 = changed;
    },
    $isFunction: true
  },
  LocalsHandler_startLoop_closure: {
    "^": "Closure;this_0,loop_1",
    call$2: function(variable, type) {
      var t1, newType;
      t1 = this.this_0;
      newType = t1.types.allocatePhi$3(this.loop_1, variable, type);
      if (!J.$eq(newType, type))
        t1.locals.$indexSet(0, variable, newType);
    },
    $isFunction: true,
    $signature: function() {
      return H.computeSignature(function(T) {
        return {func: "dynamic__Local_T", args: [O.Local, T]};
      }, this.this_0, "LocalsHandler");
    }
  },
  LocalsHandler_endLoop_closure: {
    "^": "Closure;this_0,loop_1",
    call$2: function(variable, type) {
      var t1, newType;
      t1 = this.this_0;
      newType = t1.types.simplifyPhi$3(this.loop_1, variable, type);
      if (!J.$eq(newType, type))
        t1.locals.$indexSet(0, variable, newType);
    },
    $isFunction: true,
    $signature: function() {
      return H.computeSignature(function(T) {
        return {func: "dynamic__Local_T", args: [O.Local, T]};
      }, this.this_0, "LocalsHandler");
    }
  },
  InferrerVisitor: {
    "^": "ResolvedVisitor;types<,inferrer<,locals<",
    get$inLoop: function() {
      return this.loopLevel > 0;
    },
    visitAssert$1: function(node) {
      if (!this.compiler.enableUserAssertions)
        return this.types.get$nullType();
      return this.visitStaticSend$1(node);
    },
    visitNode$1: function(node) {
      return node.visitChildren$1(this);
    },
    visitNewExpression$1: function(node) {
      return this.visitSend$1(node.send);
    },
    visitFunctionDeclaration$1: function(node) {
      var t1 = this.locals;
      this.elements.toString;
      t1.update$3(node.get$_secret_tree_element$_element(), this.types.get$functionType(), node);
      t1 = node.$function;
      return t1 == null ? null : t1.accept$1(0, this);
    },
    visitLiteralString$1: function(node) {
      return this.types.stringLiteralType$1(node.dartString);
    },
    visitStringInterpolation$1: function(node) {
      this.visitLiteralString$1(node.string);
      this.visitNodeList$1(node.parts);
      return this.types.get$stringType();
    },
    visitStringJuxtaposition$1: function(node) {
      node.first.accept$1(0, this);
      node.second.accept$1(0, this);
      return this.types.get$stringType();
    },
    visitLiteralBool$1: function(node) {
      return this.types.get$boolType();
    },
    visitLiteralDouble$1: function(node) {
      var t1 = this.compiler;
      return this.types.getConcreteTypeFor$1(t1.backend.get$constantSystem().createDouble$1(node.get$value(node)).computeMask$1(t1));
    },
    visitLiteralInt$1: function(node) {
      var t1 = this.compiler;
      return this.types.getConcreteTypeFor$1(t1.backend.get$constantSystem().createInt$1(node.get$value(node)).computeMask$1(t1));
    },
    visitLiteralList$1: function(node) {
      var t1;
      node.visitChildren$1(this);
      t1 = this.types;
      return node.constKeyword != null ? t1.get$constListType() : t1.get$growableListType();
    },
    visitLiteralMap$1: function(node) {
      var t1;
      node.visitChildren$1(this);
      t1 = this.types;
      return node.constKeyword != null ? t1.get$constMapType() : t1.get$mapType();
    },
    visitLiteralNull$1: function(node) {
      return this.types.get$nullType();
    },
    visitLiteralSymbol$1: function(node) {
      return this.types.nonNullSubtype$1(this.compiler.symbolClass);
    },
    visitTypePrefixSend$1: function(node) {
      return this.types.get$dynamicType();
    },
    visitTypeLiteralSend$1: function(node) {
      return this.types.get$typeType();
    },
    get$outermostElement: function() {
      var t1 = this.analyzedElement.get$outermostEnclosingMemberOrTopLevel();
      return t1.get$implementation(t1);
    },
    get$thisType: function() {
      var t1, cls, t2;
      t1 = this._thisType;
      if (t1 != null)
        return t1;
      cls = this.get$outermostElement().get$enclosingClass();
      t1 = this.compiler;
      if (t1.world.isUsedAsMixin$1(cls)) {
        t1 = this.types.nonNullSubtype$1(cls);
        this._thisType = t1;
        return t1;
      } else {
        t2 = this.types;
        if (t1.world.hasAnySubclass$1(cls)) {
          t1 = t2.nonNullSubclass$1(cls);
          this._thisType = t1;
          return t1;
        } else {
          t1 = t2.nonNullExact$1(cls);
          this._thisType = t1;
          return t1;
        }
      }
    },
    get$superType: function() {
      var t1 = this._superType;
      if (t1 != null)
        return t1;
      t1 = this.types.nonNullExact$1(this.get$outermostElement().get$enclosingClass().get$superclass());
      this._superType = t1;
      return t1;
    },
    visitIdentifier$1: function(node) {
      var t1, element;
      t1 = node.token;
      if (t1.get$value(t1) === "this")
        return this.get$thisType();
      else if (t1.get$value(t1) === "super")
        return this.get$superType();
      else {
        this.elements.toString;
        element = node.get$_secret_tree_element$_element();
        if (O.Elements_isLocal(element))
          return this.locals.use$1(element);
        return;
      }
    },
    potentiallyAddIsCheck$1: function(node) {
      if (!this.accumulateIsChecks)
        return;
      this.elements.toString;
      if (!O.Elements_isLocal(node.receiver.get$_secret_tree_element$_element()))
        return;
      this.isChecks.push(node);
    },
    potentiallyAddNullCheck$2: function(node, receiver) {
      if (!this.accumulateIsChecks)
        return;
      this.elements.toString;
      if (!O.Elements_isLocal(receiver.get$_secret_tree_element$_element()))
        return;
      this.isChecks.push(node);
    },
    updateIsChecks$2$usePositive: function(tests, usePositive) {
      var t1, t2, t3, t4, t5, node, t6, t7, type, receiverElement, argumentElement, operator, objectType;
      t1 = new X.InferrerVisitor_updateIsChecks_narrow(this);
      if (tests == null)
        return;
      for (t2 = H.setRuntimeTypeInfo(new H.ListIterator(tests, tests.length, 0, null), [H.getTypeArgumentByIndex(tests, 0)]), t3 = this.compiler, t4 = !usePositive, t5 = this.types; t2.moveNext$0();) {
        node = t2.__internal$_current;
        if (!!J.getInterceptor(node.get$selector()).$isOperator) {
          t6 = node.get$selector().asOperator$0().token;
          t6 = t6.get$value(t6) === "is";
        } else
          t6 = false;
        if (t6) {
          if (!!J.getInterceptor(node.get$selector()).$isOperator) {
            t6 = node.get$selector().asOperator$0().token;
            t6 = t6.get$value(t6) === "is";
          } else
            t6 = false;
          if (t6) {
            t6 = node.get$argumentsNode().nodes;
            t6 = t6.get$head(t6).asSend$0() != null;
          } else
            t6 = false;
          if (t6) {
            if (usePositive)
              continue;
          } else if (t4)
            continue;
          t6 = this.elements;
          t7 = node.get$typeAnnotationFromIsCheckOrCast();
          t6 = t6._types;
          type = t6 != null ? t6.$index(0, t7) : null;
          t6 = this.elements;
          t7 = node.receiver;
          t6.toString;
          t1.call$3(t7.get$_secret_tree_element$_element(), type, node);
        } else {
          t6 = this.elements;
          t7 = node.get$receiver();
          t6.toString;
          receiverElement = t7.get$_secret_tree_element$_element();
          t7 = this.elements;
          t6 = node.get$argumentsNode().nodes;
          if (t6.get$isEmpty(t6))
            H.throwExpression(P.StateError$("No elements"));
          t6 = t6.get$head(t6);
          t7.toString;
          argumentElement = t6.get$_secret_tree_element$_element();
          t6 = node.selector.asOperator$0().token;
          operator = t6.get$value(t6);
          if (!(operator === "==" && usePositive))
            t6 = operator === "!=" && t4;
          else
            t6 = true;
          if (t6) {
            if (O.Elements_isLocal(receiverElement))
              this.locals.update$3(receiverElement, t5.get$nullType(), node);
            if (O.Elements_isLocal(argumentElement))
              this.locals.update$3(argumentElement, t5.get$nullType(), node);
          } else {
            objectType = t3.objectClass.get$rawType();
            if (O.Elements_isLocal(receiverElement))
              t1.call$3(receiverElement, objectType, node);
            if (O.Elements_isLocal(argumentElement))
              t1.call$3(argumentElement, objectType, node);
          }
        }
      }
    },
    visitOperatorSend$1: function(node) {
      var op, t1, oldAccumulateIsChecks, oldIsChecks, t2, saved, tests, isSimple, receiverType, type;
      op = node.selector;
      t1 = op.get$token();
      if ("[]" === t1.get$value(t1))
        return this.visitDynamicSend$1(node);
      else {
        t1 = op.get$token();
        if ("&&" === t1.get$value(t1)) {
          this.conditionIsSimple = false;
          oldAccumulateIsChecks = this.accumulateIsChecks;
          oldIsChecks = this.isChecks;
          t1 = !oldAccumulateIsChecks;
          if (t1) {
            this.accumulateIsChecks = true;
            this.isChecks = H.setRuntimeTypeInfo([], [Y.Send]);
          }
          t2 = node.receiver;
          if (t2 == null)
            ;
          else
            t2.accept$1(0, this);
          saved = this.locals;
          this.locals = X.LocalsHandler$from(saved, node, true, H.getRuntimeTypeArgument(this, "InferrerVisitor", 0));
          this.updateIsChecks$2$usePositive(this.isChecks, true);
          if (t1) {
            this.accumulateIsChecks = false;
            this.isChecks = oldIsChecks;
          }
          t1 = node.argumentsNode.nodes;
          t1 = t1.get$head(t1);
          if (t1 == null)
            ;
          else
            J.accept$1$x(t1, this);
          saved.mergeDiamondFlow$2(this.locals, null);
          this.locals = saved;
          return this.types.get$boolType();
        } else {
          t1 = op.get$token();
          if ("||" === t1.get$value(t1)) {
            this.conditionIsSimple = false;
            tests = H.setRuntimeTypeInfo([], [Y.Send]);
            isSimple = this.handleCondition$2(node.receiver, tests);
            saved = this.locals;
            this.locals = X.LocalsHandler$from(saved, node, true, H.getRuntimeTypeArgument(this, "InferrerVisitor", 0));
            if (isSimple)
              this.updateIsChecks$2$usePositive(tests, false);
            oldAccumulateIsChecks = this.accumulateIsChecks;
            this.accumulateIsChecks = false;
            t1 = node.argumentsNode.nodes;
            t1 = t1.get$head(t1);
            if (t1 == null)
              ;
            else
              J.accept$1$x(t1, this);
            this.accumulateIsChecks = oldAccumulateIsChecks;
            saved.mergeDiamondFlow$2(this.locals, null);
            this.locals = saved;
            return this.types.get$boolType();
          } else {
            t1 = op.get$token();
            if ("!" === t1.get$value(t1)) {
              oldAccumulateIsChecks = this.accumulateIsChecks;
              this.accumulateIsChecks = false;
              node.visitChildren$1(this);
              this.accumulateIsChecks = oldAccumulateIsChecks;
              return this.types.get$boolType();
            } else {
              t1 = op.get$token();
              if ("is" === t1.get$value(t1)) {
                this.potentiallyAddIsCheck$1(node);
                node.visitChildren$1(this);
                return this.types.get$boolType();
              } else {
                t1 = op.get$token();
                if ("as" === t1.get$value(t1)) {
                  t1 = node.receiver;
                  receiverType = t1 == null ? null : t1.accept$1(0, this);
                  t1 = this.elements;
                  t2 = node.argumentsNode.nodes;
                  t2 = t2.get$head(t2);
                  t1 = t1._types;
                  type = t1 != null ? t1.$index(0, t2) : null;
                  return this.types.narrowType$2(receiverType, type);
                } else if (!!J.getInterceptor(node.argumentsNode).$isPrefix0)
                  return this.visitDynamicSend$1(node);
                else {
                  t1 = op.get$token();
                  if ("===" !== t1.get$value(t1)) {
                    t1 = op.get$token();
                    t1 = "!==" === t1.get$value(t1);
                  } else
                    t1 = true;
                  if (t1) {
                    node.visitChildren$1(this);
                    return this.types.get$boolType();
                  } else {
                    t1 = op.get$token();
                    if ("!=" === t1.get$value(t1)) {
                      this.visitDynamicSend$1(node);
                      return this.types.get$boolType();
                    } else
                      return this.visitDynamicSend$1(node);
                  }
                }
              }
            }
          }
        }
      }
    },
    visitTypeAnnotation$1: function(node) {
    },
    visitConditional$1: function(node) {
      var tests, simpleCondition, saved, t1, firstType, thenLocals, secondType;
      tests = H.setRuntimeTypeInfo([], [Y.Send]);
      simpleCondition = this.handleCondition$2(node.condition, tests);
      saved = this.locals;
      this.locals = X.LocalsHandler$from(saved, node, true, H.getRuntimeTypeArgument(this, "InferrerVisitor", 0));
      this.updateIsChecks$2$usePositive(tests, true);
      t1 = node.thenExpression;
      firstType = t1 == null ? null : t1.accept$1(0, this);
      thenLocals = this.locals;
      this.locals = X.LocalsHandler$from(saved, node, true, H.getRuntimeTypeArgument(this, "InferrerVisitor", 0));
      if (simpleCondition)
        this.updateIsChecks$2$usePositive(tests, false);
      t1 = node.elseExpression;
      secondType = t1 == null ? null : t1.accept$1(0, this);
      saved.mergeDiamondFlow$2(thenLocals, this.locals);
      this.locals = saved;
      return this.types.allocateDiamondPhi$2(firstType, secondType);
    },
    visitVariableDefinitions$1: function(node) {
      var link, t1, definition, t2;
      for (link = node.definitions.nodes, t1 = this.types; !link.get$isEmpty(link); link = link.get$tail()) {
        definition = link.get$head(link);
        t2 = J.getInterceptor(definition);
        if (!!t2.$isIdentifier) {
          t2 = this.locals;
          this.elements.toString;
          t2.update$3(definition.get$_secret_tree_element$_element(), t1.get$nullType(), node);
        } else if (definition == null)
          ;
        else
          t2.accept$1(definition, this);
      }
      return;
    },
    handleCondition$2: function(node, tests) {
      var oldConditionIsSimple, oldAccumulateIsChecks, oldIsChecks, simpleCondition;
      oldConditionIsSimple = this.conditionIsSimple;
      oldAccumulateIsChecks = this.accumulateIsChecks;
      oldIsChecks = this.isChecks;
      this.accumulateIsChecks = true;
      this.conditionIsSimple = true;
      this.isChecks = tests;
      if (node == null)
        ;
      else
        node.accept$1(0, this);
      simpleCondition = this.conditionIsSimple;
      this.accumulateIsChecks = oldAccumulateIsChecks;
      this.isChecks = oldIsChecks;
      this.conditionIsSimple = oldConditionIsSimple;
      return simpleCondition;
    },
    visitIf$1: function(node) {
      var tests, simpleCondition, saved, t1, thenLocals;
      tests = H.setRuntimeTypeInfo([], [Y.Send]);
      simpleCondition = this.handleCondition$2(node.get$condition(), tests);
      saved = this.locals;
      this.locals = X.LocalsHandler$from(saved, node, true, H.getRuntimeTypeArgument(this, "InferrerVisitor", 0));
      this.updateIsChecks$2$usePositive(tests, true);
      t1 = node.get$thenPart();
      if (t1 == null)
        ;
      else
        t1.accept$1(0, this);
      thenLocals = this.locals;
      this.locals = X.LocalsHandler$from(saved, node, true, H.getRuntimeTypeArgument(this, "InferrerVisitor", 0));
      if (simpleCondition)
        this.updateIsChecks$2$usePositive(tests, false);
      t1 = node.elsePart;
      if (t1 == null)
        ;
      else
        t1.accept$1(0, this);
      saved.mergeDiamondFlow$2(thenLocals, this.locals);
      this.locals = saved;
      return;
    },
    setupBreaksAndContinues$1: function(element) {
      var t1;
      if (element == null)
        return;
      if (element.get$isContinueTarget()) {
        t1 = [];
        t1.$builtinTypeInfo = [X.LocalsHandler];
        this.continuesFor.$indexSet(0, element, t1);
      }
      if (element.isBreakTarget) {
        t1 = [];
        t1.$builtinTypeInfo = [X.LocalsHandler];
        this.breaksFor.$indexSet(0, element, t1);
      }
    },
    getBreaks$1: function(element) {
      var list = H.setRuntimeTypeInfo([this.locals], [[X.LocalsHandler, H.getRuntimeTypeArgument(this, "InferrerVisitor", 0)]]);
      if (element == null)
        return list;
      if (!element.get$isBreakTarget())
        return list;
      C.JSArray_methods.addAll$1(list, this.breaksFor.$index(0, element));
      return list;
    },
    getLoopBackEdges$1: function(element) {
      var list = [this.locals];
      list.$builtinTypeInfo = [[X.LocalsHandler, H.getRuntimeTypeArgument(this, "InferrerVisitor", 0)]];
      if (element == null)
        return list;
      if (!element.get$isContinueTarget())
        return list;
      C.JSArray_methods.addAll$1(list, this.continuesFor.$index(0, element));
      return list;
    },
    handleLoop$2: function(node, logic) {
      var t1, target, saved;
      ++this.loopLevel;
      t1 = this.elements._definedTargets;
      target = t1 != null ? t1.$index(0, node) : null;
      saved = this.locals;
      saved.startLoop$1(node);
      do {
        this.setupBreaksAndContinues$1(target);
        this.locals = X.LocalsHandler$from(saved, node, true, H.getRuntimeTypeArgument(this, "InferrerVisitor", 0));
        logic.call$0();
      } while (saved.mergeAll$1(this.getLoopBackEdges$1(target)));
      --this.loopLevel;
      saved.endLoop$1(node);
      t1 = node.asDoWhile$0();
      saved.mergeAfterBreaks$2$keepOwnLocals(this.getBreaks$1(target), t1 == null);
      this.locals = saved;
      this.continuesFor.remove$1(0, target);
      this.breaksFor.remove$1(0, target);
      return;
    },
    visitWhile$1: function(node) {
      return this.handleLoop$2(node, new X.InferrerVisitor_visitWhile_closure(this, node));
    },
    visitDoWhile$1: function(node) {
      return this.handleLoop$2(node, new X.InferrerVisitor_visitDoWhile_closure(this, node));
    },
    visitFor$1: function(node) {
      var t1 = node.initializer;
      if (t1 == null)
        ;
      else
        t1.accept$1(0, this);
      return this.handleLoop$2(node, new X.InferrerVisitor_visitFor_closure(this, node));
    },
    visitTryStatement$1: function(node) {
      var saved, t1, catchBlock;
      saved = this.locals;
      this.locals = X.LocalsHandler$from(saved, node, false, H.getRuntimeTypeArgument(this, "InferrerVisitor", 0));
      t1 = node.tryBlock;
      if (t1 == null)
        ;
      else
        t1.accept$1(0, this);
      saved.mergeDiamondFlow$2(this.locals, null);
      this.locals = saved;
      for (t1 = node.catchBlocks.nodes, t1.toString, t1 = H.setRuntimeTypeInfo(new E.LinkIterator(null, t1), [H.getTypeArgumentByIndex(t1, 0)]); t1.moveNext$0();) {
        catchBlock = t1._util_implementation$_current;
        saved = this.locals;
        this.locals = X.LocalsHandler$from(saved, catchBlock, true, H.getRuntimeTypeArgument(this, "InferrerVisitor", 0));
        if (catchBlock == null)
          ;
        else
          J.accept$1$x(catchBlock, this);
        saved.mergeDiamondFlow$2(this.locals, null);
        this.locals = saved;
      }
      t1 = node.finallyBlock;
      if (t1 == null)
        ;
      else
        t1.accept$1(0, this);
      return;
    },
    visitThrow$1: function(node) {
      node.get$expression().accept$1(0, this);
      this.locals.seenReturnOrThrow = true;
      return this.types.nonNullEmpty$0();
    },
    visitCatchBlock$1: function(node) {
      var exception, t1, type, t2, mask, trace;
      exception = node.get$exception();
      if (exception != null) {
        t1 = this.elements._types;
        type = t1 != null ? t1.$index(0, node.type) : null;
        t1 = type == null || type.get$treatAsDynamic() || type.get$kind(type) === C.TypeKind_kuk;
        t2 = this.types;
        mask = t1 ? t2.get$dynamicType() : t2.nonNullSubtype$1(type.get$element());
        t1 = this.locals;
        this.elements.toString;
        t1.update$3(exception.get$_secret_tree_element$_element(), mask, node);
      }
      trace = node.get$trace();
      if (trace != null) {
        t1 = this.locals;
        this.elements.toString;
        t1.update$3(trace.get$_secret_tree_element$_element(), this.types.get$dynamicType(), node);
      }
      t1 = node.block;
      if (t1 == null)
        ;
      else
        t1.accept$1(0, this);
      return;
    },
    visitParenthesizedExpression$1: function(node) {
      var t1 = node.expression;
      return t1 == null ? null : t1.accept$1(0, this);
    },
    visitBlock$1: function(node) {
      var t1, statement, t2;
      for (t1 = node.statements.nodes, t1.toString, t1 = H.setRuntimeTypeInfo(new E.LinkIterator(null, t1), [H.getTypeArgumentByIndex(t1, 0)]); t1.moveNext$0();) {
        statement = t1._util_implementation$_current;
        if (statement == null)
          ;
        else
          J.accept$1$x(statement, this);
        t2 = this.locals;
        if (t2.seenReturnOrThrow || t2.seenBreakOrContinue)
          break;
      }
      return;
    },
    visitLabeledStatement$1: function(node) {
      var body, t1, t2, targetElement;
      body = node.statement;
      t1 = J.getInterceptor(body);
      if (!!t1.$isLoop || !!t1.$isSwitchStatement || O.Elements_isUnusedLabel(node, this.elements))
        if (body == null)
          ;
        else
          t1.accept$1(body, this);
      else {
        t2 = this.elements._definedTargets;
        targetElement = t2 != null ? t2.$index(0, body) : null;
        this.setupBreaksAndContinues$1(targetElement);
        if (body == null)
          ;
        else
          t1.accept$1(body, this);
        this.locals.mergeAfterBreaks$1(this.getBreaks$1(targetElement));
        this.continuesFor.remove$1(0, targetElement);
        this.breaksFor.remove$1(0, targetElement);
      }
      return;
    },
    visitBreakStatement$1: function(node) {
      var t1, target;
      t1 = this.elements._usedTargets;
      target = t1 != null ? t1.$index(0, node) : null;
      this.locals.seenBreakOrContinue = true;
      J.add$1$ax(this.breaksFor.$index(0, target), X.LocalsHandler$deepCopyOf(this.locals, H.getRuntimeTypeArgument(this, "InferrerVisitor", 0)));
      return;
    },
    visitContinueStatement$1: function(node) {
      var t1, target;
      t1 = this.elements._usedTargets;
      target = t1 != null ? t1.$index(0, node) : null;
      this.locals.seenBreakOrContinue = true;
      J.add$1$ax(this.continuesFor.$index(0, target), X.LocalsHandler$deepCopyOf(this.locals, H.getRuntimeTypeArgument(this, "InferrerVisitor", 0)));
      return;
    },
    internalError$2$node: function(reason, node) {
      this.compiler.internalError$2(node, reason);
    },
    visitSwitchStatement$1: function(node) {
      var t1, t2, t3, changed, switchCase, saved, localsToMerge, hasDefaultCase;
      t1 = node.parenthesizedExpression;
      if (t1 == null)
        ;
      else
        t1.accept$1(0, this);
      t1 = this.elements._definedTargets;
      this.setupBreaksAndContinues$1(t1 != null ? t1.$index(0, node) : null);
      if (O.Elements_switchStatementHasContinue(node, this.elements)) {
        t1 = new X.InferrerVisitor_visitSwitchStatement_forEachLabeledCase(this, node);
        t1.call$1(new X.InferrerVisitor_visitSwitchStatement_closure(this));
        this.locals.startLoop$1(node);
        t2 = node.cases.nodes;
        t2.toString;
        do {
          t3 = new E.LinkIterator(null, t2);
          t3.$builtinTypeInfo = [H.getTypeArgumentByIndex(t2, 0)];
          changed = false;
          for (; t3.moveNext$0();) {
            switchCase = t3._util_implementation$_current;
            saved = this.locals;
            this.locals = X.LocalsHandler$from(saved, switchCase, true, H.getRuntimeTypeArgument(this, "InferrerVisitor", 0));
            if (switchCase == null)
              ;
            else
              J.accept$1$x(switchCase, this);
            changed = saved.mergeAll$1([this.locals]) || changed;
            this.locals = saved;
          }
        } while (changed);
        this.locals.endLoop$1(node);
        t1.call$1(new X.InferrerVisitor_visitSwitchStatement_closure0(this));
      } else {
        saved = this.locals;
        localsToMerge = H.setRuntimeTypeInfo([], [[X.LocalsHandler, H.getRuntimeTypeArgument(this, "InferrerVisitor", 0)]]);
        for (t1 = node.cases.nodes, t1.toString, t1 = H.setRuntimeTypeInfo(new E.LinkIterator(null, t1), [H.getTypeArgumentByIndex(t1, 0)]), hasDefaultCase = false; t1.moveNext$0();) {
          switchCase = t1._util_implementation$_current;
          if (switchCase.get$defaultKeyword() != null)
            hasDefaultCase = true;
          this.locals = X.LocalsHandler$from(saved, switchCase, true, H.getRuntimeTypeArgument(this, "InferrerVisitor", 0));
          switchCase.accept$1(0, this);
          localsToMerge.push(this.locals);
        }
        saved.mergeAfterBreaks$2$keepOwnLocals(localsToMerge, !hasDefaultCase);
        this.locals = saved;
      }
      t1 = this.elements._definedTargets;
      t1 = t1 != null ? t1.$index(0, node) : null;
      this.continuesFor.remove$1(0, t1);
      this.breaksFor.remove$1(0, t1);
      return;
    },
    visitCascadeReceiver$1: function(node) {
      var t1, type;
      t1 = node.expression;
      type = t1 == null ? null : t1.accept$1(0, this);
      this.cascadeReceiverStack.push(type);
      return type;
    },
    visitCascade$1: function(node) {
      var t1 = node.expression;
      if (t1 == null)
        ;
      else
        t1.accept$1(0, this);
      t1 = this.cascadeReceiverStack;
      if (0 >= t1.length)
        return H.ioore(t1, 0);
      return t1.pop();
    },
    InferrerVisitor$5: function(analyzedElement, inferrer, types, compiler, handler, $T, $E) {
      var node, fieldScope;
      if (handler != null)
        return;
      node = analyzedElement.get$node();
      fieldScope = analyzedElement.get$isGenerativeConstructor() ? H.setRuntimeTypeInfo(new X.FieldInitializationScope(this.types, null, false), [$T]) : null;
      this.locals = H.setRuntimeTypeInfo(new X.LocalsHandler(compiler, this.types, this.get$inferrer(), H.setRuntimeTypeInfo(new X.VariableScope(null, null, node), [$T]), P.LinkedHashMap_LinkedHashMap(null, null, null, O.Local, O.Element), P.LinkedHashMap_LinkedHashMap(null, null, null, O.Local, O.Element), fieldScope, null, false, false), [$T]);
    },
    $asResolvedVisitor: function($T, $E) {
      return [$T];
    },
    $asVisitor: function($T, $E) {
      return [$T];
    }
  },
  InferrerVisitor_updateIsChecks_narrow: {
    "^": "Closure:180;this_0",
    call$3: function(element, type, node) {
      var t1, newType;
      if (!!J.getInterceptor(element).$isLocalElement) {
        t1 = this.this_0;
        newType = t1.types.narrowType$3$isNullable(t1.locals.use$1(element), type, false);
        t1.locals.update$3(element, newType, node);
      }
    },
    $isFunction: true
  },
  InferrerVisitor_visitWhile_closure: {
    "^": "Closure:23;this_0,node_1",
    call$0: function() {
      var tests, t1, t2;
      tests = H.setRuntimeTypeInfo([], [Y.Send]);
      t1 = this.this_0;
      t2 = this.node_1;
      t1.handleCondition$2(t2.condition, tests);
      t1.updateIsChecks$2$usePositive(tests, true);
      t2 = t2.body;
      if (t2 == null)
        ;
      else
        t2.accept$1(0, t1);
    },
    $isFunction: true
  },
  InferrerVisitor_visitDoWhile_closure: {
    "^": "Closure:23;this_0,node_1",
    call$0: function() {
      var t1, t2, t3, tests;
      t1 = this.this_0;
      t2 = this.node_1;
      t3 = t2.body;
      if (t3 == null)
        ;
      else
        t3.accept$1(0, t1);
      tests = H.setRuntimeTypeInfo([], [Y.Send]);
      t1.handleCondition$2(t2.condition, tests);
      t1.updateIsChecks$2$usePositive(tests, true);
    },
    $isFunction: true
  },
  InferrerVisitor_visitFor_closure: {
    "^": "Closure:23;this_0,node_1",
    call$0: function() {
      var tests, t1, t2, t3;
      tests = H.setRuntimeTypeInfo([], [Y.Send]);
      t1 = this.this_0;
      t2 = this.node_1;
      t1.handleCondition$2(t2.get$condition(), tests);
      t1.updateIsChecks$2$usePositive(tests, true);
      t3 = t2.body;
      if (t3 == null)
        ;
      else
        t3.accept$1(0, t1);
      t2.update.accept$1(0, t1);
    },
    $isFunction: true
  },
  InferrerVisitor_visitSwitchStatement_forEachLabeledCase: {
    "^": "Closure:181;this_0,node_1",
    call$1: function(action) {
      var t1, t2, t3, t4, labelOrCase, labelElement;
      for (t1 = this.node_1.cases.nodes, t1.toString, t1 = H.setRuntimeTypeInfo(new E.LinkIterator(null, t1), [H.getTypeArgumentByIndex(t1, 0)]), t2 = this.this_0; t1.moveNext$0();) {
        t3 = t1._util_implementation$_current.get$labelsAndCases().nodes;
        t3.toString;
        t4 = new E.LinkIterator(null, t3);
        t4.$builtinTypeInfo = [H.getTypeArgumentByIndex(t3, 0)];
        for (; t4.moveNext$0();) {
          labelOrCase = t4._util_implementation$_current;
          if (labelOrCase.asLabel$0() == null)
            continue;
          t3 = t2.elements._definedLabels;
          labelElement = t3 != null ? t3.$index(0, labelOrCase) : null;
          if (labelElement != null)
            action.call$1(J.get$target$x(labelElement));
        }
      }
    },
    $isFunction: true
  },
  InferrerVisitor_visitSwitchStatement_closure: {
    "^": "Closure:182;this_2",
    call$1: function(target) {
      this.this_2.setupBreaksAndContinues$1(target);
    },
    $isFunction: true
  },
  InferrerVisitor_visitSwitchStatement_closure0: {
    "^": "Closure:182;this_3",
    call$1: function(target) {
      var t1 = this.this_3;
      t1.continuesFor.remove$1(0, target);
      t1.breaksFor.remove$1(0, target);
    },
    $isFunction: true
  }
}],
["js", "package:compiler/implementation/js/js.dart", , Q, {
  "^": "",
  prettyPrint: function(node, compiler, allowVariableMinification, monitor) {
    var printer = Q.Printer$(compiler, monitor, allowVariableMinification);
    printer.visit$1(node);
    return printer.outBuffer;
  },
  JsBuilder: {
    "^": "Object:186;",
    call$2: function(source, $arguments) {
      var template = this._findExpressionTemplate$1(source);
      if ($arguments == null)
        return template.instantiate$1([]);
      return template.instantiate$1(!!J.getInterceptor($arguments).$isList ? $arguments : [$arguments]);
    },
    call$1: function(source) {
      return this.call$2(source, null);
    },
    statement$2: [function(source, $arguments) {
      var template = this._findStatementTemplate$1(source);
      if ($arguments == null)
        return template.instantiate$1([]);
      return template.instantiate$1(!!J.getInterceptor($arguments).$isList ? $arguments : [$arguments]);
    }, function(source) {
      return this.statement$2(source, null);
    }, "statement$1", "call$2", "call$1", "get$statement", 2, 2, 183, 10],
    parseForeignJS$1: function(source) {
      if (J.startsWith$1$s(source, "throw "))
        return this._findStatementTemplate$1(source);
      else
        return this._findExpressionTemplate$1(source);
    },
    _findExpressionTemplate$1: function(source) {
      var template, expression, t1;
      template = $.get$templateManager().expressionTemplates.$index(0, source);
      if (template == null) {
        expression = Q.MiniJsParser$(source).expression$0();
        t1 = $.get$templateManager();
        t1.toString;
        template = new Q.Template(source, true, false, expression, null, -1);
        template._compile$0();
        t1.expressionTemplates.$indexSet(0, source, template);
      }
      return template;
    },
    _findStatementTemplate$1: function(source) {
      var template, statement, t1;
      template = $.get$templateManager().statementTemplates.$index(0, source);
      if (template == null) {
        statement = Q.MiniJsParser$(source).statement$0();
        t1 = $.get$templateManager();
        t1.toString;
        template = new Q.Template(source, false, false, statement, null, -1);
        template._compile$0();
        t1.statementTemplates.$indexSet(0, source, template);
      }
      return template;
    },
    uncachedExpressionTemplate$1: function(source) {
      var t1 = new Q.Template(source, true, false, Q.MiniJsParser$(source).expression$0(), null, -1);
      t1._compile$0();
      return t1;
    },
    escapedString$1: function(value) {
      return new Q.LiteralString0("\"" + H.stringReplaceAllFuncUnchecked(value, new H.JSSyntaxRegExp("\n|\"|\\|0|\u0008|\t|\u000b", H.JSSyntaxRegExp_makeNative("\n|\"|\\|0|\u0008|\t|\u000b", false, true, false), null, null), new Q.JsBuilder_escapedString_closure(), null) + "\"", null, null);
    },
    string$1: [function(value) {
      return new Q.LiteralString0("\"" + H.S(value) + "\"", null, null);
    }, "call$1", "get$string", 2, 0, 184],
    number$1: [function(value) {
      return new Q.LiteralNumber(H.S(value), null, null);
    }, "call$1", "get$number", 2, 0, 185],
    $isFunction: true
  },
  JsBuilder_escapedString_closure: {
    "^": "Closure:13;",
    call$1: function(match) {
      switch (match.group$1(0)) {
        case "\n":
          return "\\n";
        case "\\":
          return "\\\\";
        case "\"":
          return "\\\"";
        case "0":
          return "\\0";
        case "\u0008":
          return "\\b";
        case "\t":
          return "\\t";
        case "\u000c":
          return "\\f";
        case "\u000b":
          return "\\v";
      }
    },
    $isFunction: true
  },
  MiniJsParserError: {
    "^": "Object;parser,message",
    toString$0: function(_) {
      var t1, pos, src, newlinePos, lastLineStart, line, prefix, spaces;
      t1 = this.parser;
      pos = t1.lastPosition;
      src = t1.src;
      newlinePos = J.getInterceptor$asx(src).indexOf$2(src, "\n", pos);
      if (newlinePos >= pos)
        src = C.JSString_methods.substring$2(src, 0, newlinePos);
      lastLineStart = C.JSString_methods.lastIndexOf$1(src, "\n");
      line = lastLineStart >= 0 ? C.JSString_methods.substring$1(src, lastLineStart + 1) : src;
      prefix = C.JSString_methods.substring$2(line, 0, pos - (src.length - line.length));
      t1 = H.JSSyntaxRegExp_makeNative("[^\\t]", false, true, false);
      spaces = H.stringReplaceAllUnchecked(prefix, new H.JSSyntaxRegExp("[^\\t]", t1, null, null), " ");
      return "Error in MiniJsParser:\n" + src + "\n" + spaces + "^\n" + spaces + this.message + "\n";
    },
    static: {MiniJsParserError$: function(parser, message) {
        return new Q.MiniJsParserError(parser, message);
      }}
  },
  MiniJsParser: {
    "^": "Object;lastCategory,lastToken,lastPosition,position>,skippedNewline,src,interpolatedValues",
    getDelimited$1: function(startPosition) {
      var t1, delimiter, t2, t3, currentCode, escaped;
      this.position = startPosition;
      t1 = this.src;
      delimiter = J.getInterceptor$s(t1).codeUnitAt$1(t1, startPosition);
      do {
        t2 = ++this.position;
        t3 = t1.length;
        if (t2 >= t3)
          this.error$1(0, "Unterminated literal");
        currentCode = C.JSString_methods.codeUnitAt$1(t1, this.position);
        if (currentCode === 10)
          this.error$1(0, "Unterminated literal");
        if (currentCode === 92) {
          if (++this.position >= t3)
            this.error$1(0, "Unterminated literal");
          escaped = C.JSString_methods.codeUnitAt$1(t1, this.position);
          if (escaped === 120 || escaped === 88 || escaped === 117 || escaped === 85 || Q.MiniJsParser_category(escaped) === 1)
            this.error$1(0, "Numeric and hex escapes are not allowed in literals");
        }
      } while (currentCode !== delimiter);
      t2 = ++this.position;
      return C.JSString_methods.substring$2(t1, this.lastPosition, t2);
    },
    getToken$0: function() {
      var t1, t2, t3, nextPosition, code, nextPosition0, t4, cat, t5, t6, newCat;
      this.skippedNewline = false;
      for (t1 = this.src, t2 = J.getInterceptor$asx(t1); true;) {
        t3 = this.position;
        nextPosition = t1.length;
        if (t3 >= nextPosition)
          break;
        code = t2.codeUnitAt$1(t1, t3);
        if (code === 47 && this.position + 1 < nextPosition)
          if (C.JSString_methods.codeUnitAt$1(t1, this.position + 1) === 47) {
            nextPosition0 = C.JSString_methods.indexOf$2(t1, "\n", this.position);
            this.position = nextPosition0 === -1 ? nextPosition : nextPosition0;
            continue;
          } else if (C.JSString_methods.codeUnitAt$1(t1, this.position + 1) === 42) {
            nextPosition = C.JSString_methods.indexOf$2(t1, "*/", this.position + 2);
            if (nextPosition === -1)
              this.error$1(0, "Unterminated comment");
            this.position = nextPosition + 2;
            continue;
          }
        if (Q.MiniJsParser_category(code) !== 17)
          break;
        if (code === 10)
          this.skippedNewline = true;
        ++this.position;
      }
      t3 = this.position;
      t4 = t1.length;
      if (t3 === t4) {
        this.lastCategory = -1;
        this.lastToken = null;
        this.lastPosition = t3;
        return;
      }
      code = t2.codeUnitAt$1(t1, t3);
      t2 = this.position;
      this.lastPosition = t2;
      if (code === 39 || code === 34) {
        this.lastCategory = 2;
        this.lastToken = this.getDelimited$1(t2);
      } else if (code === 48 && t2 + 2 < t4 && C.JSString_methods.codeUnitAt$1(t1, t2 + 1) === 120) {
        for (t2 = this.position += 2; t2 < t4; t2 = ++this.position) {
          cat = Q.MiniJsParser_category(C.JSString_methods.codeUnitAt$1(t1, t2));
          if (cat !== 1 && cat !== 0)
            break;
        }
        this.lastCategory = 1;
        t1 = C.JSString_methods.substring$2(t1, this.lastPosition, this.position);
        this.lastToken = t1;
        H.Primitives_parseInt(t1, null, new Q.MiniJsParser_getToken_closure(this));
      } else if (code === 47) {
        this.lastCategory = 3;
        t2 = ++this.position;
        if (t2 < t4 && C.JSString_methods.codeUnitAt$1(t1, t2) === 61)
          ++this.position;
        this.lastToken = C.JSString_methods.substring$2(t1, this.lastPosition, this.position);
      } else {
        cat = Q.MiniJsParser_category(C.JSString_methods.codeUnitAt$1(t1, this.position));
        t2 = cat < 5;
        t3 = cat === 0;
        t5 = cat === 1;
        do {
          t6 = ++this.position;
          if (t6 === t4)
            break;
          code = C.JSString_methods.codeUnitAt$1(t1, t6);
          newCat = code === 33 || code === 47 ? -1 : Q.MiniJsParser_category(code);
          if (t2)
            if (cat !== newCat)
              if (!(t3 && newCat === 1))
                t6 = t5 && newCat === 5;
              else
                t6 = true;
            else
              t6 = true;
          else
            t6 = false;
        } while (t6);
        this.lastCategory = cat;
        t1 = C.JSString_methods.substring$2(t1, this.lastPosition, this.position);
        this.lastToken = t1;
        if (t5)
          H.Primitives_parseDouble(t1, new Q.MiniJsParser_getToken_closure0(this));
        else if (cat === 3) {
          t2 = $.get$MiniJsParser_BINARY_PRECEDENCE();
          if (t2.$index(0, t1) == null && !$.get$MiniJsParser_UNARY_OPERATORS().contains$1(0, this.lastToken))
            this.error$1(0, "Unknown operator");
          if (t2.$index(0, this.lastToken) === 17)
            this.lastCategory = 4;
        } else if (t3)
          if ($.get$MiniJsParser_OPERATORS_THAT_LOOK_LIKE_IDENTIFIERS().contains$1(0, t1))
            this.lastCategory = 3;
      }
    },
    expectCategory$1: function(cat) {
      if (cat !== this.lastCategory)
        this.error$1(0, "Expected " + Q.MiniJsParser_categoryToString(cat));
      this.getToken$0();
    },
    acceptCategory$1: function(cat) {
      if (cat === this.lastCategory) {
        this.getToken$0();
        return true;
      }
      return false;
    },
    expectSemicolon$0: function() {
      if (this.acceptSemicolon$0())
        return;
      this.error$1(0, "Expected SEMICOLON");
    },
    acceptSemicolon$0: function() {
      var t1 = this.lastCategory;
      if (9 === t1)
        return true;
      if (-1 === t1)
        return true;
      if (this.skippedNewline)
        this.error$1(0, "No automatic semicolon insertion at preceding newline");
      return this.acceptCategory$1(15);
    },
    acceptString$1: function(string) {
      if (this.lastToken === string) {
        this.getToken$0();
        return true;
      }
      return false;
    },
    error$1: [function(_, message) {
      throw H.wrapException(Q.MiniJsParserError$(this, message));
    }, "call$1", "get$error", 2, 0, 8],
    parsePrimary$0: function() {
      var last, expression, values, regexp, flags, t1;
      last = this.lastToken;
      if (this.acceptCategory$1(0))
        if (last === "true")
          return new Q.LiteralBool(true, null, null);
        else if (last === "false")
          return new Q.LiteralBool(false, null, null);
        else if (last === "null")
          return new Q.LiteralNull(null, null);
        else if (last === "function")
          return this.parseFunctionExpression$0();
        else
          return new Q.VariableUse(last, null, null);
      else if (this.acceptCategory$1(6)) {
        expression = this.parseExpression$0();
        this.expectCategory$1(7);
        return expression;
      } else if (this.acceptCategory$1(2))
        return new Q.LiteralString0(last, null, null);
      else if (this.acceptCategory$1(1))
        return new Q.LiteralNumber(last, null, null);
      else if (this.acceptCategory$1(8))
        return this.parseObjectInitializer$0();
      else if (this.acceptCategory$1(10)) {
        values = H.setRuntimeTypeInfo([], [Q.ArrayElement]);
        if (!this.acceptCategory$1(11)) {
          do
            values.push(new Q.ArrayElement(values.length, this.parseAssignment$0(), null, null));
          while (this.acceptCategory$1(12));
          this.expectCategory$1(11);
        }
        return new Q.ArrayInitializer(values.length, values, null, null);
      } else if (last != null && C.JSString_methods.startsWith$1(last, "/")) {
        regexp = this.getDelimited$1(this.lastPosition);
        this.getToken$0();
        flags = this.lastToken;
        return new Q.RegExpLiteral(C.JSString_methods.$add(regexp, !this.acceptCategory$1(0) ? "" : flags), null, null);
      } else if (this.acceptCategory$1(16)) {
        t1 = this.interpolatedValues;
        expression = new Q.InterpolatedExpression(t1.length, null, null);
        t1.push(expression);
        return expression;
      } else
        this.error$1(0, "Expected primary expression");
    },
    parseFunctionExpression$0: function() {
      var last = this.lastToken;
      if (this.acceptCategory$1(0))
        return new Q.NamedFunction(new Q.VariableDeclaration(last, null, null), this.parseFun$0(), null, null);
      return this.parseFun$0();
    },
    parseFun$0: function() {
      var params, t1, parameter, argumentName;
      params = H.setRuntimeTypeInfo([], [Q.Parameter]);
      this.expectCategory$1(6);
      if (!this.acceptCategory$1(7))
        for (t1 = this.interpolatedValues; true;) {
          if (this.acceptCategory$1(16)) {
            parameter = new Q.InterpolatedParameter(t1.length, null, null);
            t1.push(parameter);
            params.push(parameter);
          } else {
            argumentName = this.lastToken;
            if (0 !== this.lastCategory)
              this.error$1(0, "Expected " + Q.MiniJsParser_categoryToString(0));
            this.getToken$0();
            params.push(new Q.Parameter(argumentName, null, null));
          }
          if (this.acceptCategory$1(12))
            continue;
          if (7 !== this.lastCategory)
            this.error$1(0, "Expected " + Q.MiniJsParser_categoryToString(7));
          this.getToken$0();
          break;
        }
      this.expectCategory$1(8);
      return new Q.Fun(params, this.parseBlock$0(), null, null);
    },
    parseObjectInitializer$0: function() {
      var properties, identifier, propertyName, t1, interpolatedLiteral;
      properties = H.setRuntimeTypeInfo([], [Q.Property]);
      for (; true;) {
        if (this.acceptCategory$1(9))
          break;
        identifier = this.lastToken;
        if (this.acceptCategory$1(0))
          propertyName = new Q.LiteralString0("\"" + H.S(identifier) + "\"", null, null);
        else if (this.acceptCategory$1(2))
          propertyName = new Q.LiteralString0(identifier, null, null);
        else if (this.acceptCategory$1(3))
          propertyName = new Q.LiteralString0("\"" + H.S(identifier) + "\"", null, null);
        else if (this.acceptCategory$1(16)) {
          t1 = this.interpolatedValues;
          interpolatedLiteral = new Q.InterpolatedLiteral(t1.length, null, null);
          t1.push(interpolatedLiteral);
          propertyName = interpolatedLiteral;
        } else {
          this.error$1(0, "Expected property name");
          propertyName = null;
        }
        if (14 !== this.lastCategory)
          this.error$1(0, "Expected " + Q.MiniJsParser_categoryToString(14));
        this.getToken$0();
        properties.push(new Q.Property(propertyName, this.parseAssignment$0(), null, null));
        if (this.acceptCategory$1(9))
          break;
        if (12 !== this.lastCategory)
          this.error$1(0, "Expected " + Q.MiniJsParser_categoryToString(12));
        this.getToken$0();
      }
      return new Q.ObjectInitializer(properties, true, null, null);
    },
    parseMember$0: function() {
      var receiver, inBraces;
      receiver = this.parsePrimary$0();
      for (; true;)
        if (this.acceptCategory$1(5))
          receiver = this.getDotRhs$1(receiver);
        else if (this.acceptCategory$1(10)) {
          inBraces = this.parseExpression$0();
          if (11 !== this.lastCategory)
            this.error$1(0, "Expected " + Q.MiniJsParser_categoryToString(11));
          this.getToken$0();
          receiver = new Q.PropertyAccess(receiver, inBraces, null, null);
        } else
          break;
      return receiver;
    },
    parseCall$0: function() {
      var $constructor, receiver, $arguments, t1, inBraces;
      $constructor = this.acceptString$1("new");
      receiver = this.parseMember$0();
      for (; true;)
        if (this.acceptCategory$1(6)) {
          $arguments = [];
          $arguments.$builtinTypeInfo = [Q.Expression];
          if (!this.acceptCategory$1(7))
            for (; true;) {
              $arguments.push(this.parseAssignment$0());
              if (this.acceptCategory$1(7))
                break;
              if (12 !== this.lastCategory)
                this.error$1(0, "Expected " + Q.MiniJsParser_categoryToString(12));
              this.getToken$0();
            }
          receiver = $constructor ? new Q.New(receiver, $arguments, null, null) : new Q.Call(receiver, $arguments, null, null);
          $constructor = false;
        } else {
          t1 = !$constructor;
          if (t1 && this.acceptCategory$1(10)) {
            inBraces = this.parseExpression$0();
            if (11 !== this.lastCategory)
              this.error$1(0, "Expected " + Q.MiniJsParser_categoryToString(11));
            this.getToken$0();
            receiver = new Q.PropertyAccess(receiver, inBraces, null, null);
          } else if (t1 && this.acceptCategory$1(5))
            receiver = this.getDotRhs$1(receiver);
          else {
            if ($constructor)
              this.error$1(0, "Parentheses are required for new");
            break;
          }
        }
      return receiver;
    },
    getDotRhs$1: function(receiver) {
      var t1, property, identifier;
      if (this.acceptCategory$1(16)) {
        t1 = this.interpolatedValues;
        property = new Q.InterpolatedSelector(t1.length, null, null);
        t1.push(property);
        return new Q.PropertyAccess(receiver, property, null, null);
      }
      identifier = this.lastToken;
      if (this.acceptCategory$1(3)) {
        if (!$.get$MiniJsParser_OPERATORS_THAT_LOOK_LIKE_IDENTIFIERS().contains$1(0, identifier))
          this.error$1(0, "Expected alphanumeric identifier");
      } else {
        if (0 !== this.lastCategory)
          this.error$1(0, "Expected " + Q.MiniJsParser_categoryToString(0));
        this.getToken$0();
      }
      return new Q.PropertyAccess(receiver, new Q.LiteralString0("\"" + H.S(identifier) + "\"", null, null), null, null);
    },
    parsePostfix$0: function() {
      var expression, operator, t1;
      expression = this.parseCall$0();
      operator = this.lastToken;
      if (this.lastCategory === 3)
        if (!this.skippedNewline)
          t1 = this.acceptString$1("++") || this.acceptString$1("--");
        else
          t1 = false;
      else
        t1 = false;
      if (t1)
        return new Q.Postfix(operator, expression, null, null);
      return expression;
    },
    parseUnaryHigh$0: function() {
      var operator, t1;
      operator = this.lastToken;
      if (this.lastCategory === 3)
        if ($.get$MiniJsParser_UNARY_OPERATORS().contains$1(0, operator))
          t1 = this.acceptString$1("++") || this.acceptString$1("--");
        else
          t1 = false;
      else
        t1 = false;
      if (t1)
        return new Q.Prefix(operator, this.parsePostfix$0(), null, null);
      return this.parsePostfix$0();
    },
    parseUnaryLow$0: function() {
      var operator = this.lastToken;
      if (this.lastCategory === 3 && $.get$MiniJsParser_UNARY_OPERATORS().contains$1(0, operator) && operator !== "++" && operator !== "--") {
        if (3 !== this.lastCategory)
          this.error$1(0, "Expected " + Q.MiniJsParser_categoryToString(3));
        this.getToken$0();
        return new Q.Prefix(operator, this.parseUnaryLow$0(), null, null);
      }
      return this.parseUnaryHigh$0();
    },
    parseBinary$1: function(maxPrecedence) {
      var lhs, minPrecedence, lastSymbol, rhs, symbol, t1, t2;
      lhs = this.parseUnaryLow$0();
      for (minPrecedence = null, lastSymbol = null, rhs = null; true;) {
        symbol = this.lastToken;
        if (this.lastCategory === 3) {
          t1 = $.get$MiniJsParser_BINARY_PRECEDENCE();
          if (t1.containsKey$1(symbol)) {
            t1 = t1.$index(0, symbol);
            if (typeof t1 !== "number")
              return t1.$gt();
            if (typeof maxPrecedence !== "number")
              return H.iae(maxPrecedence);
            t1 = t1 > maxPrecedence;
          } else
            t1 = true;
        } else
          t1 = true;
        if (t1)
          break;
        if (3 !== this.lastCategory)
          this.error$1(0, "Expected " + Q.MiniJsParser_categoryToString(3));
        this.getToken$0();
        t1 = rhs != null;
        if (t1) {
          t2 = $.get$MiniJsParser_BINARY_PRECEDENCE().$index(0, symbol);
          if (typeof t2 !== "number")
            return t2.$ge();
          if (typeof minPrecedence !== "number")
            return H.iae(minPrecedence);
          t2 = t2 >= minPrecedence;
        } else
          t2 = true;
        if (t2) {
          if (t1)
            lhs = new Q.Binary(lastSymbol, lhs, rhs, null, null);
          minPrecedence = $.get$MiniJsParser_BINARY_PRECEDENCE().$index(0, symbol);
          rhs = this.parseUnaryLow$0();
          lastSymbol = symbol;
        } else
          rhs = new Q.Binary(symbol, rhs, this.parseBinary$1($.get$MiniJsParser_BINARY_PRECEDENCE().$index(0, symbol)), null, null);
      }
      if (rhs == null)
        return lhs;
      return new Q.Binary(lastSymbol, lhs, rhs, null, null);
    },
    parseConditional$0: function() {
      var lhs, ifTrue;
      lhs = this.parseBinary$1($.MiniJsParser_HIGHEST_PARSE_BINARY_PRECEDENCE);
      if (!this.acceptCategory$1(13))
        return lhs;
      ifTrue = this.parseAssignment$0();
      this.expectCategory$1(14);
      return new Q.Conditional(lhs, ifTrue, this.parseAssignment$0(), null, null);
    },
    parseAssignment$0: function() {
      var lhs, assignmentOperator, rhs;
      lhs = this.parseConditional$0();
      assignmentOperator = this.lastToken;
      if (this.acceptCategory$1(4)) {
        rhs = this.parseAssignment$0();
        if (assignmentOperator === "=")
          return new Q.Assignment(lhs, null, rhs, null, null);
        else
          return new Q.Assignment(lhs, J.substring$2$s(assignmentOperator, 0, assignmentOperator.length - 1), rhs, null, null);
      }
      return lhs;
    },
    parseExpression$0: function() {
      var expression = this.parseAssignment$0();
      for (; this.acceptCategory$1(12);)
        expression = new Q.Binary(",", expression, this.parseAssignment$0(), null, null);
      return expression;
    },
    parseVariableDeclarationList$0: function() {
      var firstVariable = this.lastToken;
      this.expectCategory$1(0);
      return this.finishVariableDeclarationList$1(firstVariable);
    },
    finishVariableDeclarationList$1: function(firstVariable) {
      var initialization, t1, variable;
      initialization = [];
      t1 = new Q.MiniJsParser_finishVariableDeclarationList_declare(this, initialization);
      t1.call$1(firstVariable);
      for (; this.acceptCategory$1(12);) {
        variable = this.lastToken;
        if (0 !== this.lastCategory)
          this.error$1(0, "Expected " + Q.MiniJsParser_categoryToString(0));
        this.getToken$0();
        t1.call$1(variable);
      }
      return new Q.VariableDeclarationList(initialization, null, null);
    },
    parseVarDeclarationOrExpression$0: function() {
      if (this.acceptString$1("var"))
        return this.parseVariableDeclarationList$0();
      else
        return this.parseExpression$0();
    },
    expression$0: [function() {
      var expression, t1;
      expression = this.parseVarDeclarationOrExpression$0();
      t1 = this.lastCategory;
      if (t1 !== -1 || this.position !== this.src.length)
        this.error$1(0, "Unparsed junk: " + Q.MiniJsParser_categoryToString(t1));
      return expression;
    }, "call$0", "get$expression", 0, 0, 114],
    statement$0: [function() {
      var statement, t1;
      statement = this.parseStatement$0();
      t1 = this.lastCategory;
      if (t1 !== -1 || this.position !== this.src.length)
        this.error$1(0, "Unparsed junk: " + Q.MiniJsParser_categoryToString(t1));
      return statement;
    }, "call$0", "get$statement", 0, 0, 187],
    parseBlock$0: function() {
      var statements = H.setRuntimeTypeInfo([], [Q.Statement]);
      for (; !this.acceptCategory$1(9);)
        statements.push(this.parseStatement$0());
      return new Q.Block(statements, null, null);
    },
    parseStatement$0: function() {
      var expression, $name, body, identifier, catchPart, finallyPart, firstVariable, declarations, t1, statement, t2, t3;
      if (this.acceptCategory$1(8))
        return this.parseBlock$0();
      if (this.acceptCategory$1(15))
        return new Q.EmptyStatement(null, null);
      if (this.lastCategory === 0) {
        if (this.acceptString$1("return"))
          return this.parseReturn$0();
        if (this.acceptString$1("throw")) {
          if (this.skippedNewline)
            this.error$1(0, "throw expression must be on same line");
          expression = this.parseExpression$0();
          this.expectSemicolon$0();
          return new Q.Throw(expression, null, null);
        }
        if (this.acceptString$1("break"))
          return this.parseBreakOrContinue$1(new Q.MiniJsParser_parseStatement_closure());
        if (this.acceptString$1("continue"))
          return this.parseBreakOrContinue$1(new Q.MiniJsParser_parseStatement_closure0());
        if (this.acceptString$1("if"))
          return this.parseIfThenElse$0();
        if (this.acceptString$1("for"))
          return this.parseFor$0();
        if (this.acceptString$1("function")) {
          $name = this.lastToken;
          if (0 !== this.lastCategory)
            this.error$1(0, "Expected " + Q.MiniJsParser_categoryToString(0));
          this.getToken$0();
          return new Q.FunctionDeclaration(new Q.VariableDeclaration($name, null, null), this.parseFun$0(), null, null);
        }
        if (this.acceptString$1("try")) {
          if (8 !== this.lastCategory)
            this.error$1(0, "Expected " + Q.MiniJsParser_categoryToString(8));
          this.getToken$0();
          body = this.parseBlock$0();
          if (this.acceptString$1("catch")) {
            if (6 !== this.lastCategory)
              this.error$1(0, "Expected " + Q.MiniJsParser_categoryToString(6));
            this.getToken$0();
            identifier = this.lastToken;
            if (0 !== this.lastCategory)
              this.error$1(0, "Expected " + Q.MiniJsParser_categoryToString(0));
            this.getToken$0();
            if (7 !== this.lastCategory)
              this.error$1(0, "Expected " + Q.MiniJsParser_categoryToString(7));
            this.getToken$0();
            if (8 !== this.lastCategory)
              this.error$1(0, "Expected " + Q.MiniJsParser_categoryToString(8));
            this.getToken$0();
            catchPart = new Q.Catch(new Q.VariableDeclaration(identifier, null, null), this.parseBlock$0(), null, null);
          } else
            catchPart = null;
          if (this.acceptString$1("finally")) {
            if (8 !== this.lastCategory)
              this.error$1(0, "Expected " + Q.MiniJsParser_categoryToString(8));
            this.getToken$0();
            finallyPart = this.parseBlock$0();
          } else {
            if (catchPart == null)
              this.error$1(0, "expected 'finally'");
            finallyPart = null;
          }
          return new Q.Try(body, catchPart, finallyPart, null, null);
        }
        if (this.acceptString$1("var")) {
          firstVariable = this.lastToken;
          if (0 !== this.lastCategory)
            this.error$1(0, "Expected " + Q.MiniJsParser_categoryToString(0));
          this.getToken$0();
          declarations = this.finishVariableDeclarationList$1(firstVariable);
          this.expectSemicolon$0();
          return new Q.ExpressionStatement(declarations, null, null);
        }
        t1 = this.lastToken;
        if (t1 === "case" || t1 === "do" || t1 === "while" || t1 === "switch" || t1 === "with")
          this.error$1(0, "Not implemented in mini parser");
      }
      t1 = this.lastCategory;
      expression = this.parseExpression$0();
      this.expectSemicolon$0();
      if (t1 === 16)
        if (!!J.getInterceptor(expression).$isInterpolatedExpression) {
          statement = new Q.InterpolatedStatement(expression.name, null, null);
          t1 = this.interpolatedValues;
          t2 = t1.length;
          t3 = t2 - 1;
          if (t3 < 0)
            return H.ioore(t1, t3);
          t1[t3] = statement;
          return statement;
        }
      return new Q.ExpressionStatement(expression, null, null);
    },
    parseReturn$0: function() {
      if (this.acceptSemicolon$0())
        return new Q.Return(null, null, null);
      var expression = this.parseExpression$0();
      this.expectSemicolon$0();
      return new Q.Return(expression, null, null);
    },
    parseBreakOrContinue$1: function($constructor) {
      var identifier = this.lastToken;
      if (!this.skippedNewline && this.acceptCategory$1(0)) {
        this.expectSemicolon$0();
        return $constructor.call$1(identifier);
      }
      this.expectSemicolon$0();
      return $constructor.call$1(null);
    },
    parseIfThenElse$0: function() {
      var condition, thenStatement;
      this.expectCategory$1(6);
      condition = this.parseExpression$0();
      this.expectCategory$1(7);
      thenStatement = this.parseStatement$0();
      if (this.acceptString$1("else"))
        return new Q.If(condition, thenStatement, this.parseStatement$0(), null, null);
      else
        return new Q.If(condition, thenStatement, new Q.EmptyStatement(null, null), null, null);
    },
    parseFor$0: function() {
      var t1, identifier, objectExpression, declarations, $init;
      t1 = new Q.MiniJsParser_parseFor_finishFor(this);
      this.expectCategory$1(6);
      if (this.acceptCategory$1(15))
        return t1.call$1(null);
      if (this.acceptString$1("var")) {
        identifier = this.lastToken;
        this.expectCategory$1(0);
        if (this.acceptString$1("in")) {
          objectExpression = this.parseExpression$0();
          this.expectCategory$1(7);
          return new Q.ForIn(new Q.VariableDeclarationList([new Q.VariableInitialization(new Q.VariableDeclaration(identifier, null, null), null, null, null, null)], null, null), objectExpression, this.parseStatement$0(), null, null);
        }
        declarations = this.finishVariableDeclarationList$1(identifier);
        this.expectCategory$1(15);
        return t1.call$1(declarations);
      }
      $init = this.parseExpression$0();
      this.expectCategory$1(15);
      return t1.call$1($init);
    },
    MiniJsParser$1: function(src) {
      this.getToken$0();
    },
    static: {"^": "MiniJsParser_NONE,MiniJsParser_ALPHA,MiniJsParser_NUMERIC,MiniJsParser_STRING,MiniJsParser_SYMBOL,MiniJsParser_ASSIGNMENT,MiniJsParser_DOT,MiniJsParser_LPAREN,MiniJsParser_RPAREN,MiniJsParser_LBRACE,MiniJsParser_RBRACE,MiniJsParser_LSQUARE,MiniJsParser_RSQUARE,MiniJsParser_COMMA,MiniJsParser_QUERY,MiniJsParser_COLON,MiniJsParser_SEMICOLON,MiniJsParser_HASH,MiniJsParser_WHITESPACE,MiniJsParser_OTHER,MiniJsParser_CATEGORIES,MiniJsParser_HIGHEST_PARSE_BINARY_PRECEDENCE,MiniJsParser_BINARY_PRECEDENCE,MiniJsParser_UNARY_OPERATORS,MiniJsParser_OPERATORS_THAT_LOOK_LIKE_IDENTIFIERS", MiniJsParser$: function(src) {
        var t1 = new Q.MiniJsParser(-1, null, 0, 0, false, src, H.setRuntimeTypeInfo([], [Q.InterpolatedNode]));
        t1.MiniJsParser$1(src);
        return t1;
      }, MiniJsParser_categoryToString: function(cat) {
        switch (cat) {
          case -1:
            return "NONE";
          case 0:
            return "ALPHA";
          case 1:
            return "NUMERIC";
          case 3:
            return "SYMBOL";
          case 4:
            return "ASSIGNMENT";
          case 5:
            return "DOT";
          case 6:
            return "LPAREN";
          case 7:
            return "RPAREN";
          case 8:
            return "LBRACE";
          case 9:
            return "RBRACE";
          case 10:
            return "LSQUARE";
          case 11:
            return "RSQUARE";
          case 2:
            return "STRING";
          case 12:
            return "COMMA";
          case 13:
            return "QUERY";
          case 14:
            return "COLON";
          case 15:
            return "SEMICOLON";
          case 16:
            return "HASH";
          case 17:
            return "WHITESPACE";
          case 18:
            return "OTHER";
        }
        return "Unknown: " + cat;
      }, MiniJsParser_category: function(code) {
        if (code >= 127)
          return 18;
        return C.List_mJb[code];
      }}
  },
  MiniJsParser_getToken_closure: {
    "^": "Closure:13;this_0",
    call$1: function(_) {
      this.this_0.error$1(0, "Unparseable number");
    },
    $isFunction: true
  },
  MiniJsParser_getToken_closure0: {
    "^": "Closure:13;this_1",
    call$1: function(_) {
      this.this_1.error$1(0, "Unparseable number");
    },
    $isFunction: true
  },
  MiniJsParser_finishVariableDeclarationList_declare: {
    "^": "Closure:66;this_0,initialization_1",
    call$1: function(variable) {
      var t1, initializer;
      t1 = this.this_0;
      initializer = t1.acceptString$1("=") ? t1.parseAssignment$0() : null;
      this.initialization_1.push(new Q.VariableInitialization(new Q.VariableDeclaration(variable, null, null), null, initializer, null, null));
    },
    $isFunction: true
  },
  MiniJsParser_parseStatement_closure: {
    "^": "Closure:13;",
    call$1: function(label) {
      return new Q.Break(label, null, null);
    },
    $isFunction: true
  },
  MiniJsParser_parseStatement_closure0: {
    "^": "Closure:13;",
    call$1: function(label) {
      return new Q.Continue(label, null, null);
    },
    $isFunction: true
  },
  MiniJsParser_parseFor_finishFor: {
    "^": "Closure:188;this_0",
    call$1: function($init) {
      var t1, condition, update;
      t1 = this.this_0;
      if (!t1.acceptCategory$1(15)) {
        condition = t1.parseExpression$0();
        t1.expectCategory$1(15);
      } else
        condition = null;
      if (!t1.acceptCategory$1(7)) {
        update = t1.parseExpression$0();
        t1.expectCategory$1(7);
      } else
        update = null;
      return new Q.For($init, condition, update, t1.parseStatement$0(), null, null);
    },
    $isFunction: true
  },
  BaseVisitor: {
    "^": "Object;",
    visitNode$1: function(node) {
      node.visitChildren$1(this);
      return;
    },
    visitBlock$1: function(node) {
      return this.visitNode$1(node);
    },
    visitExpressionStatement$1: function(node) {
      return this.visitNode$1(node);
    },
    visitEmptyStatement$1: function(node) {
      return this.visitNode$1(node);
    },
    visitIf$1: function(node) {
      return this.visitNode$1(node);
    },
    visitFor$1: function(node) {
      return this.visitNode$1(node);
    },
    visitForIn$1: function(node) {
      return this.visitNode$1(node);
    },
    visitWhile$1: function(node) {
      return this.visitNode$1(node);
    },
    visitDo$1: function(node) {
      return this.visitNode$1(node);
    },
    visitContinue$1: function(node) {
      return this.visitNode$1(node);
    },
    visitBreak$1: function(node) {
      return this.visitNode$1(node);
    },
    visitReturn$1: function(node) {
      return this.visitNode$1(node);
    },
    visitThrow$1: function(node) {
      return this.visitNode$1(node);
    },
    visitTry$1: function(node) {
      return this.visitNode$1(node);
    },
    visitSwitch$1: function(node) {
      return this.visitNode$1(node);
    },
    visitFunctionDeclaration$1: function(node) {
      return this.visitNode$1(node);
    },
    visitLabeledStatement$1: function(node) {
      return this.visitNode$1(node);
    },
    visitLiteralStatement$1: function(node) {
      return this.visitNode$1(node);
    },
    visitCatch$1: function(node) {
      return this.visitNode$1(node);
    },
    visitCase$1: function(node) {
      return this.visitNode$1(node);
    },
    visitDefault$1: function(node) {
      return this.visitNode$1(node);
    },
    visitExpression$1: function(node) {
      return this.visitNode$1(node);
    },
    visitLiteralExpression$1: function(node) {
      return this.visitExpression$1(node);
    },
    visitVariableDeclarationList$1: function(node) {
      return this.visitExpression$1(node);
    },
    visitAssignment$1: function(node) {
      return this.visitExpression$1(node);
    },
    visitVariableInitialization$1: function(node) {
      if (node.value != null)
        return this.visitAssignment$1(node);
      else
        return this.visitExpression$1(node);
    },
    visitConditional$1: function(node) {
      return this.visitExpression$1(node);
    },
    visitNew$1: function(node) {
      return this.visitExpression$1(node);
    },
    visitCall$1: function(node) {
      return this.visitExpression$1(node);
    },
    visitBinary$1: function(node) {
      return this.visitExpression$1(node);
    },
    visitPrefix$1: function(node) {
      return this.visitExpression$1(node);
    },
    visitPostfix$1: function(node) {
      return this.visitExpression$1(node);
    },
    visitAccess$1: function(node) {
      return this.visitExpression$1(node);
    },
    visitVariableUse$1: function(node) {
      return this.visitExpression$1(node);
    },
    visitVariableDeclaration$1: function(node) {
      return this.visitExpression$1(node);
    },
    visitParameter$1: function(node) {
      return this.visitVariableDeclaration$1(node);
    },
    visitThis$1: function(node) {
      return this.visitVariableDeclaration$1(node);
    },
    visitNamedFunction$1: function(node) {
      return this.visitExpression$1(node);
    },
    visitFun$1: function(node) {
      return this.visitExpression$1(node);
    },
    visitLiteralBool$1: function(node) {
      return this.visitExpression$1(node);
    },
    visitLiteralString$1: function(node) {
      return this.visitExpression$1(node);
    },
    visitLiteralNumber$1: function(node) {
      return this.visitExpression$1(node);
    },
    visitLiteralNull$1: function(node) {
      return this.visitExpression$1(node);
    },
    visitArrayInitializer$1: function(node) {
      return this.visitExpression$1(node);
    },
    visitArrayElement$1: function(node) {
      return this.visitNode$1(node);
    },
    visitObjectInitializer$1: function(node) {
      return this.visitExpression$1(node);
    },
    visitProperty$1: function(node) {
      return this.visitNode$1(node);
    },
    visitRegExpLiteral$1: function(node) {
      return this.visitExpression$1(node);
    },
    visitInterpolatedNode$1: function(node) {
      return this.visitNode$1(node);
    },
    visitInterpolatedExpression$1: function(node) {
      return this.visitInterpolatedNode$1(node);
    },
    visitInterpolatedLiteral$1: function(node) {
      return this.visitInterpolatedNode$1(node);
    },
    visitInterpolatedParameter$1: function(node) {
      return this.visitInterpolatedNode$1(node);
    },
    visitInterpolatedSelector$1: function(node) {
      return this.visitInterpolatedNode$1(node);
    },
    visitInterpolatedStatement$1: function(node) {
      return this.visitInterpolatedNode$1(node);
    },
    visitComment$1: function(node) {
      return;
    }
  },
  Node0: {
    "^": "Object;_sourcePosition<,_endSourcePosition<",
    get$sourcePosition: function() {
      return this._sourcePosition;
    },
    withPosition$2: function(sourcePosition, endSourcePosition) {
      var t1, clone;
      t1 = this._sourcePosition;
      if (sourcePosition == null ? t1 == null : sourcePosition === t1) {
        t1 = this._endSourcePosition;
        t1 = endSourcePosition == null ? t1 == null : endSourcePosition === t1;
      } else
        t1 = false;
      if (t1)
        return this;
      clone = this._clone$0();
      clone._sourcePosition = sourcePosition;
      clone._endSourcePosition = endSourcePosition;
      return clone;
    },
    get$isCommaOperator: function() {
      return false;
    },
    toStatement$0: function() {
      throw H.wrapException(P.UnsupportedError$("toStatement"));
    },
    $isNode0: true
  },
  Statement: {
    "^": "Node0;",
    toStatement$0: function() {
      return this;
    },
    withPosition$2: function(sourcePosition, endSourcePosition) {
      return Q.Node0.prototype.withPosition$2.call(this, sourcePosition, endSourcePosition);
    },
    $isStatement: true
  },
  Block: {
    "^": "Statement;statements,_sourcePosition,_endSourcePosition",
    accept$1: function(_, visitor) {
      return visitor.visitBlock$1(this);
    },
    visitChildren$1: function(visitor) {
      var t1;
      for (t1 = this.statements, t1 = H.setRuntimeTypeInfo(new H.ListIterator(t1, t1.length, 0, null), [H.getTypeArgumentByIndex(t1, 0)]); t1.moveNext$0();)
        J.accept$1$x(t1.__internal$_current, visitor);
    },
    _clone$0: function() {
      return new Q.Block(this.statements, null, null);
    },
    $isBlock: true
  },
  ExpressionStatement: {
    "^": "Statement;expression<,_sourcePosition,_endSourcePosition",
    accept$1: function(_, visitor) {
      return visitor.visitExpressionStatement$1(this);
    },
    visitChildren$1: function(visitor) {
      this.expression.accept$1(0, visitor);
    },
    _clone$0: function() {
      return new Q.ExpressionStatement(this.expression, null, null);
    },
    $isExpressionStatement: true
  },
  EmptyStatement: {
    "^": "Statement;_sourcePosition,_endSourcePosition",
    accept$1: function(_, visitor) {
      return visitor.visitEmptyStatement$1(this);
    },
    visitChildren$1: function(visitor) {
    },
    _clone$0: function() {
      return new Q.EmptyStatement(null, null);
    },
    $isEmptyStatement: true
  },
  If: {
    "^": "Statement;condition<,then,otherwise<,_sourcePosition,_endSourcePosition",
    then$2$onError: function(arg0, arg1) {
      return this.then.call$2$onError(arg0, arg1);
    },
    then$1: function(arg0) {
      return this.then.call$1(arg0);
    },
    accept$1: function(_, visitor) {
      return visitor.visitIf$1(this);
    },
    visitChildren$1: function(visitor) {
      this.condition.accept$1(0, visitor);
      this.then.accept$1(0, visitor);
      this.otherwise.accept$1(0, visitor);
    },
    _clone$0: function() {
      return new Q.If(this.condition, this.then, this.otherwise, null, null);
    },
    $isIf: true
  },
  Loop0: {
    "^": "Statement;body>"
  },
  For: {
    "^": "Loop0;init<,condition,update,body,_sourcePosition,_endSourcePosition",
    accept$1: function(_, visitor) {
      return visitor.visitFor$1(this);
    },
    visitChildren$1: function(visitor) {
      var t1 = this.init;
      if (t1 != null)
        t1.accept$1(0, visitor);
      t1 = this.condition;
      if (t1 != null)
        t1.accept$1(0, visitor);
      t1 = this.update;
      if (t1 != null)
        t1.accept$1(0, visitor);
      this.body.accept$1(0, visitor);
    },
    _clone$0: function() {
      return new Q.For(this.init, this.condition, this.update, this.body, null, null);
    }
  },
  ForIn: {
    "^": "Loop0;leftHandSide<,object,body,_sourcePosition,_endSourcePosition",
    accept$1: function(_, visitor) {
      return visitor.visitForIn$1(this);
    },
    visitChildren$1: function(visitor) {
      this.leftHandSide.accept$1(0, visitor);
      this.object.accept$1(0, visitor);
      this.body.accept$1(0, visitor);
    },
    _clone$0: function() {
      return new Q.ForIn(this.leftHandSide, this.object, this.body, null, null);
    }
  },
  While1: {
    "^": "Loop0;condition,body,_sourcePosition,_endSourcePosition",
    accept$1: function(_, visitor) {
      return visitor.visitWhile$1(this);
    },
    visitChildren$1: function(visitor) {
      this.condition.accept$1(0, visitor);
      this.body.accept$1(0, visitor);
    },
    _clone$0: function() {
      return new Q.While1(this.condition, this.body, null, null);
    }
  },
  Do: {
    "^": "Loop0;condition,body,_sourcePosition,_endSourcePosition",
    accept$1: function(_, visitor) {
      return visitor.visitDo$1(this);
    },
    visitChildren$1: function(visitor) {
      this.body.accept$1(0, visitor);
      this.condition.accept$1(0, visitor);
    },
    _clone$0: function() {
      return new Q.Do(this.condition, this.body, null, null);
    },
    $isDo: true
  },
  Continue: {
    "^": "Statement;targetLabel<,_sourcePosition,_endSourcePosition",
    accept$1: function(_, visitor) {
      return visitor.visitContinue$1(this);
    },
    visitChildren$1: function(visitor) {
    },
    _clone$0: function() {
      return new Q.Continue(this.targetLabel, null, null);
    }
  },
  Break: {
    "^": "Statement;targetLabel<,_sourcePosition,_endSourcePosition",
    accept$1: function(_, visitor) {
      return visitor.visitBreak$1(this);
    },
    visitChildren$1: function(visitor) {
    },
    _clone$0: function() {
      return new Q.Break(this.targetLabel, null, null);
    }
  },
  Return: {
    "^": "Statement;value>,_sourcePosition,_endSourcePosition",
    accept$1: function(_, visitor) {
      return visitor.visitReturn$1(this);
    },
    visitChildren$1: function(visitor) {
      var t1 = this.value;
      if (t1 != null)
        t1.accept$1(0, visitor);
    },
    _clone$0: function() {
      return new Q.Return(this.value, null, null);
    }
  },
  Throw: {
    "^": "Statement;expression<,_sourcePosition,_endSourcePosition",
    accept$1: function(_, visitor) {
      return visitor.visitThrow$1(this);
    },
    visitChildren$1: function(visitor) {
      this.expression.accept$1(0, visitor);
    },
    _clone$0: function() {
      return new Q.Throw(this.expression, null, null);
    }
  },
  Try: {
    "^": "Statement;body>,catchPart,finallyPart<,_sourcePosition,_endSourcePosition",
    accept$1: function(_, visitor) {
      return visitor.visitTry$1(this);
    },
    visitChildren$1: function(visitor) {
      var t1 = this.body;
      t1.toString;
      visitor.visitBlock$1(t1);
      t1 = this.catchPart;
      if (t1 != null) {
        t1.toString;
        visitor.visitCatch$1(t1);
      }
      t1 = this.finallyPart;
      if (t1 != null) {
        t1.toString;
        visitor.visitBlock$1(t1);
      }
    },
    _clone$0: function() {
      return new Q.Try(this.body, this.catchPart, this.finallyPart, null, null);
    }
  },
  Catch: {
    "^": "Node0;declaration<,body>,_sourcePosition,_endSourcePosition",
    accept$1: function(_, visitor) {
      return visitor.visitCatch$1(this);
    },
    visitChildren$1: function(visitor) {
      var t1;
      this.declaration.accept$1(0, visitor);
      t1 = this.body;
      t1.toString;
      visitor.visitBlock$1(t1);
    },
    _clone$0: function() {
      return new Q.Catch(this.declaration, this.body, null, null);
    }
  },
  Switch: {
    "^": "Statement;key>,cases,_sourcePosition,_endSourcePosition",
    accept$1: function(_, visitor) {
      return visitor.visitSwitch$1(this);
    },
    visitChildren$1: function(visitor) {
      var t1;
      this.key.accept$1(0, visitor);
      for (t1 = this.cases, t1 = H.setRuntimeTypeInfo(new H.ListIterator(t1, t1.length, 0, null), [H.getTypeArgumentByIndex(t1, 0)]); t1.moveNext$0();)
        J.accept$1$x(t1.__internal$_current, visitor);
    },
    _clone$0: function() {
      return new Q.Switch(this.key, this.cases, null, null);
    }
  },
  SwitchClause: {
    "^": "Node0;body>"
  },
  Case: {
    "^": "SwitchClause;expression<,body,_sourcePosition,_endSourcePosition",
    accept$1: function(_, visitor) {
      return visitor.visitCase$1(this);
    },
    visitChildren$1: function(visitor) {
      this.expression.accept$1(0, visitor);
      visitor.visitBlock$1(this.body);
    },
    _clone$0: function() {
      return new Q.Case(this.expression, this.body, null, null);
    }
  },
  Default: {
    "^": "SwitchClause;body,_sourcePosition,_endSourcePosition",
    accept$1: function(_, visitor) {
      return visitor.visitDefault$1(this);
    },
    visitChildren$1: function(visitor) {
      visitor.visitBlock$1(this.body);
    },
    _clone$0: function() {
      return new Q.Default(this.body, null, null);
    }
  },
  FunctionDeclaration: {
    "^": "Statement;name>,$function<,_sourcePosition,_endSourcePosition",
    accept$1: function(_, visitor) {
      return visitor.visitFunctionDeclaration$1(this);
    },
    visitChildren$1: function(visitor) {
      var t1;
      this.name.accept$1(0, visitor);
      t1 = this.$function;
      t1.toString;
      visitor.visitFun$1(t1);
    },
    _clone$0: function() {
      return new Q.FunctionDeclaration(this.name, this.$function, null, null);
    }
  },
  LabeledStatement2: {
    "^": "Statement;label,body>,_sourcePosition,_endSourcePosition",
    accept$1: function(_, visitor) {
      return visitor.visitLabeledStatement$1(this);
    },
    visitChildren$1: function(visitor) {
      this.body.accept$1(0, visitor);
    },
    _clone$0: function() {
      return new Q.LabeledStatement2(this.label, this.body, null, null);
    }
  },
  LiteralStatement: {
    "^": "Statement;code,_sourcePosition,_endSourcePosition",
    accept$1: function(_, visitor) {
      return visitor.visitLiteralStatement$1(this);
    },
    visitChildren$1: function(visitor) {
    },
    _clone$0: function() {
      return new Q.LiteralStatement(this.code, null, null);
    }
  },
  Expression: {
    "^": "Node0;",
    toStatement$0: function() {
      return new Q.ExpressionStatement(this, null, null);
    },
    withPosition$2: function(sourcePosition, endSourcePosition) {
      return Q.Node0.prototype.withPosition$2.call(this, sourcePosition, endSourcePosition);
    },
    $isExpression: true
  },
  LiteralExpression: {
    "^": "Expression;template,inputs<,_sourcePosition,_endSourcePosition",
    accept$1: function(_, visitor) {
      return visitor.visitLiteralExpression$1(this);
    },
    visitChildren$1: function(visitor) {
      var t1;
      for (t1 = this.inputs, t1 = H.setRuntimeTypeInfo(new H.ListIterator(t1, 0, 0, null), [H.getTypeArgumentByIndex(t1, 0)]); t1.moveNext$0();)
        J.accept$1$x(t1.__internal$_current, visitor);
    },
    _clone$0: function() {
      return new Q.LiteralExpression(this.template, this.inputs, null, null);
    },
    get$precedenceLevel: function() {
      return 14;
    }
  },
  VariableDeclarationList: {
    "^": "Expression;declarations,_sourcePosition,_endSourcePosition",
    accept$1: function(_, visitor) {
      return visitor.visitVariableDeclarationList$1(this);
    },
    visitChildren$1: function(visitor) {
      var t1, declaration;
      for (t1 = this.declarations, t1 = H.setRuntimeTypeInfo(new H.ListIterator(t1, t1.length, 0, null), [H.getTypeArgumentByIndex(t1, 0)]); t1.moveNext$0();) {
        declaration = t1.__internal$_current;
        declaration.toString;
        visitor.visitVariableInitialization$1(declaration);
      }
    },
    _clone$0: function() {
      return new Q.VariableDeclarationList(this.declarations, null, null);
    },
    get$precedenceLevel: function() {
      return 0;
    }
  },
  Assignment: {
    "^": "Expression;leftHandSide<,op<,value>,_sourcePosition,_endSourcePosition",
    get$precedenceLevel: function() {
      return 1;
    },
    accept$1: function(_, visitor) {
      return visitor.visitAssignment$1(this);
    },
    visitChildren$1: function(visitor) {
      var t1;
      this.leftHandSide.accept$1(0, visitor);
      t1 = this.value;
      if (t1 != null)
        t1.accept$1(0, visitor);
    },
    _clone$0: function() {
      return new Q.Assignment(this.leftHandSide, this.op, this.value, null, null);
    },
    $isAssignment: true
  },
  VariableInitialization: {
    "^": "Assignment;leftHandSide,op,value,_sourcePosition,_endSourcePosition",
    get$declaration: function() {
      return this.leftHandSide;
    },
    accept$1: function(_, visitor) {
      return visitor.visitVariableInitialization$1(this);
    },
    _clone$0: function() {
      return new Q.VariableInitialization(this.leftHandSide, null, this.value, null, null);
    }
  },
  Conditional: {
    "^": "Expression;condition,then,otherwise,_sourcePosition,_endSourcePosition",
    then$2$onError: function(arg0, arg1) {
      return this.then.call$2$onError(arg0, arg1);
    },
    then$1: function(arg0) {
      return this.then.call$1(arg0);
    },
    accept$1: function(_, visitor) {
      return visitor.visitConditional$1(this);
    },
    visitChildren$1: function(visitor) {
      this.condition.accept$1(0, visitor);
      this.then.accept$1(0, visitor);
      this.otherwise.accept$1(0, visitor);
    },
    _clone$0: function() {
      return new Q.Conditional(this.condition, this.then, this.otherwise, null, null);
    },
    get$precedenceLevel: function() {
      return 1;
    }
  },
  Call: {
    "^": "Expression;target>,arguments<,_sourcePosition,_endSourcePosition",
    accept$1: function(_, visitor) {
      return visitor.visitCall$1(this);
    },
    visitChildren$1: function(visitor) {
      var t1;
      this.target.accept$1(0, visitor);
      for (t1 = this.arguments, t1 = H.setRuntimeTypeInfo(new H.ListIterator(t1, t1.length, 0, null), [H.getTypeArgumentByIndex(t1, 0)]); t1.moveNext$0();)
        J.accept$1$x(t1.__internal$_current, visitor);
    },
    _clone$0: function() {
      return new Q.Call(this.target, this.arguments, null, null);
    },
    get$precedenceLevel: function() {
      return 13;
    }
  },
  New: {
    "^": "Call;target,arguments,_sourcePosition,_endSourcePosition",
    accept$1: function(_, visitor) {
      return visitor.visitNew$1(this);
    },
    _clone$0: function() {
      return new Q.New(this.target, this.arguments, null, null);
    }
  },
  Binary: {
    "^": "Expression;op<,left>,right>,_sourcePosition,_endSourcePosition",
    accept$1: function(_, visitor) {
      return visitor.visitBinary$1(this);
    },
    _clone$0: function() {
      return new Q.Binary(this.op, this.left, this.right, null, null);
    },
    visitChildren$1: function(visitor) {
      this.left.accept$1(0, visitor);
      this.right.accept$1(0, visitor);
    },
    get$isCommaOperator: function() {
      return this.op === ",";
    },
    get$precedenceLevel: function() {
      var t1 = this.op;
      switch (t1) {
        case "*":
        case "/":
        case "%":
          return 11;
        case "+":
        case "-":
          return 10;
        case "<<":
        case ">>":
        case ">>>":
          return 9;
        case "<":
        case ">":
        case "<=":
        case ">=":
        case "instanceof":
        case "in":
          return 8;
        case "==":
        case "===":
        case "!=":
        case "!==":
          return 7;
        case "&":
          return 6;
        case "^":
          return 5;
        case "|":
          return 4;
        case "&&":
          return 3;
        case "||":
          return 2;
        case ",":
          return 0;
        default:
          throw H.wrapException(K.CompilerCancelledException$("Internal Error: Unhandled binary operator: " + H.S(t1)));
      }
    },
    $isBinary: true
  },
  Prefix: {
    "^": "Expression;op<,argument,_sourcePosition,_endSourcePosition",
    accept$1: function(_, visitor) {
      return visitor.visitPrefix$1(this);
    },
    _clone$0: function() {
      return new Q.Prefix(this.op, this.argument, null, null);
    },
    visitChildren$1: function(visitor) {
      this.argument.accept$1(0, visitor);
    },
    get$precedenceLevel: function() {
      return 12;
    }
  },
  Postfix: {
    "^": "Expression;op<,argument,_sourcePosition,_endSourcePosition",
    accept$1: function(_, visitor) {
      return visitor.visitPostfix$1(this);
    },
    _clone$0: function() {
      return new Q.Postfix(this.op, this.argument, null, null);
    },
    visitChildren$1: function(visitor) {
      this.argument.accept$1(0, visitor);
    },
    get$precedenceLevel: function() {
      return 12;
    }
  },
  VariableReference: {
    "^": "Expression;name>",
    get$precedenceLevel: function() {
      return 14;
    },
    visitChildren$1: function(visitor) {
    },
    $isVariableReference: true
  },
  VariableUse: {
    "^": "VariableReference;name,_sourcePosition,_endSourcePosition",
    accept$1: function(_, visitor) {
      return visitor.visitVariableUse$1(this);
    },
    _clone$0: function() {
      return new Q.VariableUse(this.name, null, null);
    },
    toString$0: function(_) {
      return "VariableUse(" + H.S(this.name) + ")";
    },
    $isVariableUse: true
  },
  VariableDeclaration: {
    "^": "VariableReference;name,_sourcePosition,_endSourcePosition",
    accept$1: function(_, visitor) {
      return visitor.visitVariableDeclaration$1(this);
    },
    _clone$0: function() {
      return new Q.VariableDeclaration(this.name, null, null);
    }
  },
  Parameter: {
    "^": "VariableDeclaration;name,_sourcePosition,_endSourcePosition",
    accept$1: function(_, visitor) {
      return visitor.visitParameter$1(this);
    },
    _clone$0: function() {
      return new Q.Parameter(this.name, null, null);
    },
    $isParameter: true
  },
  This: {
    "^": "Parameter;name,_sourcePosition,_endSourcePosition",
    accept$1: function(_, visitor) {
      return visitor.visitThis$1(this);
    },
    _clone$0: function() {
      return new Q.This("this", null, null);
    }
  },
  NamedFunction: {
    "^": "Expression;name>,$function<,_sourcePosition,_endSourcePosition",
    accept$1: function(_, visitor) {
      return visitor.visitNamedFunction$1(this);
    },
    visitChildren$1: function(visitor) {
      var t1;
      this.name.accept$1(0, visitor);
      t1 = this.$function;
      t1.toString;
      visitor.visitFun$1(t1);
    },
    _clone$0: function() {
      return new Q.NamedFunction(this.name, this.$function, null, null);
    },
    get$precedenceLevel: function() {
      return 13;
    },
    $isNamedFunction: true
  },
  Fun: {
    "^": "Expression;params,body>,_sourcePosition,_endSourcePosition",
    accept$1: function(_, visitor) {
      return visitor.visitFun$1(this);
    },
    visitChildren$1: function(visitor) {
      var t1;
      for (t1 = this.params, t1 = H.setRuntimeTypeInfo(new H.ListIterator(t1, t1.length, 0, null), [H.getTypeArgumentByIndex(t1, 0)]); t1.moveNext$0();)
        J.accept$1$x(t1.__internal$_current, visitor);
      t1 = this.body;
      t1.toString;
      visitor.visitBlock$1(t1);
    },
    _clone$0: function() {
      return new Q.Fun(this.params, this.body, null, null);
    },
    get$precedenceLevel: function() {
      return 13;
    },
    $isFun: true
  },
  PropertyAccess: {
    "^": "Expression;receiver<,selector<,_sourcePosition,_endSourcePosition",
    accept$1: function(_, visitor) {
      return visitor.visitAccess$1(this);
    },
    visitChildren$1: function(visitor) {
      this.receiver.accept$1(0, visitor);
      this.selector.accept$1(0, visitor);
    },
    _clone$0: function() {
      return new Q.PropertyAccess(this.receiver, this.selector, null, null);
    },
    get$precedenceLevel: function() {
      return 13;
    }
  },
  Literal: {
    "^": "Expression;",
    visitChildren$1: function(visitor) {
    },
    get$precedenceLevel: function() {
      return 14;
    },
    $isLiteral: true
  },
  LiteralBool: {
    "^": "Literal;value>,_sourcePosition,_endSourcePosition",
    accept$1: function(_, visitor) {
      return visitor.visitLiteralBool$1(this);
    },
    _clone$0: function() {
      return new Q.LiteralBool(this.value, null, null);
    }
  },
  LiteralNull: {
    "^": "Literal;_sourcePosition,_endSourcePosition",
    accept$1: function(_, visitor) {
      return visitor.visitLiteralNull$1(this);
    },
    _clone$0: function() {
      return new Q.LiteralNull(null, null);
    }
  },
  LiteralString0: {
    "^": "Literal;value>,_sourcePosition,_endSourcePosition",
    accept$1: function(_, visitor) {
      return visitor.visitLiteralString$1(this);
    },
    _clone$0: function() {
      return new Q.LiteralString0(this.value, null, null);
    },
    $isLiteralString0: true
  },
  LiteralNumber: {
    "^": "Literal;value>,_sourcePosition,_endSourcePosition",
    accept$1: function(_, visitor) {
      return visitor.visitLiteralNumber$1(this);
    },
    _clone$0: function() {
      return new Q.LiteralNumber(this.value, null, null);
    },
    $isLiteralNumber: true
  },
  ArrayInitializer: {
    "^": "Expression;length>,elements>,_sourcePosition,_endSourcePosition",
    accept$1: function(_, visitor) {
      return visitor.visitArrayInitializer$1(this);
    },
    visitChildren$1: function(visitor) {
      var t1, element;
      for (t1 = this.elements, t1 = H.setRuntimeTypeInfo(new H.ListIterator(t1, t1.length, 0, null), [H.getTypeArgumentByIndex(t1, 0)]); t1.moveNext$0();) {
        element = t1.__internal$_current;
        element.toString;
        visitor.visitArrayElement$1(element);
      }
    },
    _clone$0: function() {
      return new Q.ArrayInitializer(this.length, this.elements, null, null);
    },
    get$precedenceLevel: function() {
      return 14;
    },
    static: {ArrayInitializer__convert: function(expressions) {
        var t1 = {};
        t1.index_0 = 0;
        return J.map$1$ax(expressions, new Q.ArrayInitializer__convert_closure(t1)).toList$0(0);
      }}
  },
  ArrayInitializer__convert_closure: {
    "^": "Closure:13;box_0",
    call$1: function(expression) {
      return new Q.ArrayElement(this.box_0.index_0++, expression, null, null);
    },
    $isFunction: true
  },
  ArrayElement: {
    "^": "Node0;index>,value>,_sourcePosition,_endSourcePosition",
    accept$1: function(_, visitor) {
      return visitor.visitArrayElement$1(this);
    },
    visitChildren$1: function(visitor) {
      this.value.accept$1(0, visitor);
    },
    _clone$0: function() {
      return new Q.ArrayElement(this.index, this.value, null, null);
    }
  },
  ObjectInitializer: {
    "^": "Expression;properties<,isOneLiner,_sourcePosition,_endSourcePosition",
    accept$1: function(_, visitor) {
      return visitor.visitObjectInitializer$1(this);
    },
    visitChildren$1: function(visitor) {
      var t1, $init;
      for (t1 = this.properties, t1 = H.setRuntimeTypeInfo(new H.ListIterator(t1, t1.length, 0, null), [H.getTypeArgumentByIndex(t1, 0)]); t1.moveNext$0();) {
        $init = t1.__internal$_current;
        $init.toString;
        visitor.visitProperty$1($init);
      }
    },
    _clone$0: function() {
      return new Q.ObjectInitializer(this.properties, this.isOneLiner, null, null);
    },
    get$precedenceLevel: function() {
      return 14;
    },
    $isObjectInitializer: true
  },
  Property: {
    "^": "Node0;name>,value>,_sourcePosition,_endSourcePosition",
    accept$1: function(_, visitor) {
      return visitor.visitProperty$1(this);
    },
    visitChildren$1: function(visitor) {
      this.name.accept$1(0, visitor);
      this.value.accept$1(0, visitor);
    },
    _clone$0: function() {
      return new Q.Property(this.name, this.value, null, null);
    }
  },
  InterpolatedNode: {
    "^": "Object;",
    $isNode0: true
  },
  InterpolatedExpression: {
    "^": "Expression;name>,_sourcePosition,_endSourcePosition",
    accept$1: function(_, visitor) {
      return visitor.visitInterpolatedExpression$1(this);
    },
    visitChildren$1: function(visitor) {
    },
    _clone$0: function() {
      return new Q.InterpolatedExpression(this.name, null, null);
    },
    get$precedenceLevel: function() {
      return 14;
    },
    $isInterpolatedExpression: true,
    $isNode0: true
  },
  InterpolatedLiteral: {
    "^": "Literal;name>,_sourcePosition,_endSourcePosition",
    accept$1: function(_, visitor) {
      return visitor.visitInterpolatedLiteral$1(this);
    },
    visitChildren$1: function(visitor) {
    },
    _clone$0: function() {
      return new Q.InterpolatedLiteral(this.name, null, null);
    },
    $isNode0: true
  },
  InterpolatedParameter: {
    "^": "Expression;name>,_sourcePosition,_endSourcePosition",
    accept$1: function(_, visitor) {
      return visitor.visitInterpolatedParameter$1(this);
    },
    visitChildren$1: function(visitor) {
    },
    _clone$0: function() {
      return new Q.InterpolatedParameter(this.name, null, null);
    },
    get$precedenceLevel: function() {
      return 14;
    },
    $isNode0: true,
    $isParameter: true,
    $isVariableReference: true,
    $isExpression: true
  },
  InterpolatedSelector: {
    "^": "Expression;name>,_sourcePosition,_endSourcePosition",
    accept$1: function(_, visitor) {
      return visitor.visitInterpolatedSelector$1(this);
    },
    visitChildren$1: function(visitor) {
    },
    _clone$0: function() {
      return new Q.InterpolatedSelector(this.name, null, null);
    },
    get$precedenceLevel: function() {
      return 14;
    },
    $isNode0: true
  },
  InterpolatedStatement: {
    "^": "Statement;name>,_sourcePosition,_endSourcePosition",
    accept$1: function(_, visitor) {
      return visitor.visitInterpolatedStatement$1(this);
    },
    visitChildren$1: function(visitor) {
    },
    _clone$0: function() {
      return new Q.InterpolatedStatement(this.name, null, null);
    },
    $isInterpolatedStatement: true,
    $isNode0: true
  },
  RegExpLiteral: {
    "^": "Expression;pattern,_sourcePosition,_endSourcePosition",
    accept$1: function(_, visitor) {
      return visitor.visitRegExpLiteral$1(this);
    },
    visitChildren$1: function(visitor) {
    },
    _clone$0: function() {
      return new Q.RegExpLiteral(this.pattern, null, null);
    },
    get$precedenceLevel: function() {
      return 14;
    }
  },
  Comment: {
    "^": "Statement;comment,_sourcePosition,_endSourcePosition",
    accept$1: function(_, visitor) {
      return visitor.visitComment$1(this);
    },
    _clone$0: function() {
      return new Q.Comment(this.comment, null, null);
    },
    visitChildren$1: function(visitor) {
    }
  },
  Printer: {
    "^": "Indentation;shouldCompressOutput,compiler<,outBuffer,inForInit,atStatementBegin,danglingElseVisitor,localNamer,pendingSemicolon,pendingSpace,monitor,lastAddedString,_indentLevel,_indentList,_indentationUnit",
    get$lastCharCode: function() {
      var t1 = this.lastAddedString;
      if (t1 == null)
        return 0;
      return J.codeUnitAt$1$s(t1, t1.length - 1);
    },
    out$1: function(str) {
      var t1, t2;
      t1 = J.getInterceptor(str);
      if (!t1.$eq(str, "")) {
        if (this.pendingSemicolon)
          if (!this.shouldCompressOutput)
            this.outBuffer.write$1(";");
          else if (!t1.$eq(str, "}")) {
            t1 = $.get$Printer_expressionContinuationRegExp()._nativeRegExp;
            if (typeof str !== "string")
              H.throwExpression(P.ArgumentError$(str));
            t2 = this.outBuffer;
            if (t1.test(str))
              t2.write$1(";");
            else
              t2.write$1("\n");
          }
        if (this.pendingSpace)
          if (this.shouldCompressOutput) {
            t1 = $.get$Printer_identifierCharacterRegExp()._nativeRegExp;
            if (typeof str !== "string")
              H.throwExpression(P.ArgumentError$(str));
            t1 = t1.test(str);
          } else
            t1 = true;
        else
          t1 = false;
        if (t1)
          this.outBuffer.write$1(" ");
        this.pendingSpace = false;
        this.pendingSemicolon = false;
        this.outBuffer.write$1(str);
        this.lastAddedString = str;
      }
    },
    outSemicolonLn$0: function() {
      if (this.shouldCompressOutput)
        this.pendingSemicolon = true;
      else {
        this.out$1(";");
        this.out$1("\n");
      }
    },
    beginSourceRange$1: function(node) {
      var t1, t2;
      t1 = node._sourcePosition;
      if (t1 != null) {
        t2 = this.outBuffer;
        ++t2.mappedRangeCounter;
        t2.setSourceLocation$1(t1);
      }
    },
    endSourceRange$1: function(node) {
      var t1 = node._endSourcePosition;
      if (t1 != null)
        this.outBuffer.setSourceLocation$1(t1);
      if (node._sourcePosition != null)
        --this.outBuffer.mappedRangeCounter;
    },
    visit$1: [function(node) {
      var t1, t2, t3;
      if (node.get$_sourcePosition() != null) {
        t1 = this.outBuffer;
        ++t1.mappedRangeCounter;
        t1.setSourceLocation$1(node._sourcePosition);
      }
      t1 = this.monitor;
      t2 = t1 != null;
      if (t2) {
        t3 = this.outBuffer.buffer._contents;
        if (t1.isTracking$1(node))
          t1._nodeBeforeSize.$indexSet(0, node, t3.length);
      }
      node.accept$1(0, this);
      if (t2) {
        t2 = this.outBuffer.buffer._contents;
        if (t1.isTracking$1(node)) {
          t3 = t1._nodeBeforeSize.$index(0, node);
          if (typeof t3 !== "number")
            return H.iae(t3);
          if (t1.compiler.dumpInfo)
            t1._nodeToSize.$indexSet(0, node, t2.length - t3);
        }
      }
      t1 = node._endSourcePosition;
      if (t1 != null)
        this.outBuffer.setSourceLocation$1(t1);
      if (node._sourcePosition != null)
        --this.outBuffer.mappedRangeCounter;
    }, "call$1", "get$visit", 2, 0, 189],
    visitCommaSeparated$4$newAtStatementBegin$newInForInit: function(nodes, hasRequiredType, newAtStatementBegin, newInForInit) {
      var i;
      for (i = 0; i < nodes.length; ++i) {
        if (i !== 0) {
          this.atStatementBegin = false;
          this.out$1(",");
          if (!this.shouldCompressOutput)
            this.out$1(" ");
        }
        if (i >= nodes.length)
          return H.ioore(nodes, i);
        this.visitNestedExpression$4$newAtStatementBegin$newInForInit(nodes[i], hasRequiredType, newAtStatementBegin, newInForInit);
      }
    },
    blockBody$3$needsNewline$needsSeparation: function(body, needsNewline, needsSeparation) {
      var t1;
      if (!!J.getInterceptor(body).$isBlock) {
        if (!this.shouldCompressOutput)
          this.out$1(" ");
        this.blockOut$3(body, false, needsNewline);
        return true;
      }
      t1 = this.shouldCompressOutput;
      if (t1 && needsSeparation)
        this.out$1(" ");
      else if (!t1)
        this.out$1("\n");
      ++this._indentLevel;
      new Q.Printer_blockBody_closure(this, body).call$0();
      --this._indentLevel;
      return false;
    },
    blockOutWithoutBraces$1: [function(node) {
      if (!!J.getInterceptor(node).$isBlock) {
        this.beginSourceRange$1(node);
        H.IterableMixinWorkaround_forEach(node.statements, this.get$blockOutWithoutBraces());
        this.endSourceRange$1(node);
      } else
        this.visit$1(node);
    }, "call$1", "get$blockOutWithoutBraces", 2, 0, 190],
    blockOut$3: function(node, shouldIndent, needsNewline) {
      var t1;
      if (shouldIndent)
        if (!this.shouldCompressOutput)
          this.out$1(this.get$indentation());
      this.beginSourceRange$1(node);
      this.out$1("{");
      t1 = !this.shouldCompressOutput;
      if (t1)
        this.out$1("\n");
      ++this._indentLevel;
      new Q.Printer_blockOut_closure(this, node).call$0();
      --this._indentLevel;
      if (t1)
        this.out$1(this.get$indentation());
      this.out$1("}");
      this.endSourceRange$1(node);
      if (needsNewline)
        if (t1)
          this.out$1("\n");
    },
    visitBlock$1: function(block) {
      this.blockOut$3(block, true, true);
    },
    visitExpressionStatement$1: function(expressionStatement) {
      if (!this.shouldCompressOutput)
        this.out$1(this.get$indentation());
      this.visitNestedExpression$4$newAtStatementBegin$newInForInit(expressionStatement.expression, 0, true, false);
      this.outSemicolonLn$0();
    },
    visitEmptyStatement$1: function(nop) {
      var t1 = !this.shouldCompressOutput;
      if (t1)
        this.out$1(this.get$indentation());
      this.out$1(";");
      if (t1)
        this.out$1("\n");
    },
    ifOut$2: function(node, shouldIndent) {
      var then, elsePart, t1, t2, hasElse, t3, thenWasBlock;
      then = node.then;
      elsePart = node.otherwise;
      t1 = J.getInterceptor(elsePart);
      t2 = !!t1.$isEmptyStatement;
      hasElse = !t2;
      if (hasElse)
        if (then.accept$1(0, this.danglingElseVisitor) === true || !!then.$isDo)
          then = new Q.Block(H.setRuntimeTypeInfo([then], [Q.Statement]), null, null);
      if (shouldIndent)
        if (!this.shouldCompressOutput)
          this.out$1(this.get$indentation());
      this.out$1("if");
      t3 = !this.shouldCompressOutput;
      if (t3)
        this.out$1(" ");
      this.out$1("(");
      this.visitNestedExpression$4$newAtStatementBegin$newInForInit(node.condition, 0, false, false);
      this.out$1(")");
      thenWasBlock = this.blockBody$3$needsNewline$needsSeparation(then, t2, false);
      if (hasElse) {
        if (thenWasBlock) {
          if (t3)
            this.out$1(" ");
        } else if (t3)
          this.out$1(this.get$indentation());
        this.out$1("else");
        if (!!t1.$isIf) {
          this.pendingSpace = true;
          this.ifOut$2(elsePart, false);
        } else
          this.blockBody$3$needsNewline$needsSeparation(elsePart, true, true);
      }
    },
    visitIf$1: function(node) {
      this.ifOut$2(node, true);
    },
    visitFor$1: function(loop) {
      var t1, t2;
      t1 = !this.shouldCompressOutput;
      if (t1)
        this.out$1(this.get$indentation());
      this.out$1("for");
      if (t1)
        this.out$1(" ");
      this.out$1("(");
      if (loop.get$init() != null)
        this.visitNestedExpression$4$newAtStatementBegin$newInForInit(loop.init, 0, false, true);
      this.out$1(";");
      t2 = loop.condition;
      if (t2 != null) {
        if (t1)
          this.out$1(" ");
        this.visitNestedExpression$4$newAtStatementBegin$newInForInit(t2, 0, false, false);
      }
      this.out$1(";");
      t2 = loop.update;
      if (t2 != null) {
        if (t1)
          this.out$1(" ");
        this.visitNestedExpression$4$newAtStatementBegin$newInForInit(t2, 0, false, false);
      }
      this.out$1(")");
      this.blockBody$3$needsNewline$needsSeparation(loop.body, true, false);
    },
    visitForIn$1: function(loop) {
      var t1 = !this.shouldCompressOutput;
      if (t1)
        this.out$1(this.get$indentation());
      this.out$1("for");
      if (t1)
        this.out$1(" ");
      this.out$1("(");
      this.visitNestedExpression$4$newAtStatementBegin$newInForInit(loop.leftHandSide, 0, false, true);
      this.out$1(" in");
      this.pendingSpace = true;
      this.visitNestedExpression$4$newAtStatementBegin$newInForInit(loop.object, 0, false, false);
      this.out$1(")");
      this.blockBody$3$needsNewline$needsSeparation(loop.body, true, false);
    },
    visitWhile$1: function(loop) {
      var t1 = !this.shouldCompressOutput;
      if (t1)
        this.out$1(this.get$indentation());
      this.out$1("while");
      if (t1)
        this.out$1(" ");
      this.out$1("(");
      this.visitNestedExpression$4$newAtStatementBegin$newInForInit(loop.condition, 0, false, false);
      this.out$1(")");
      this.blockBody$3$needsNewline$needsSeparation(loop.body, true, false);
    },
    visitDo$1: function(loop) {
      var t1 = !this.shouldCompressOutput;
      if (t1)
        this.out$1(this.get$indentation());
      this.out$1("do");
      if (this.blockBody$3$needsNewline$needsSeparation(loop.body, false, true)) {
        if (t1)
          this.out$1(" ");
      } else if (t1)
        this.out$1(this.get$indentation());
      this.out$1("while");
      if (t1)
        this.out$1(" ");
      this.out$1("(");
      this.visitNestedExpression$4$newAtStatementBegin$newInForInit(loop.condition, 0, false, false);
      this.out$1(")");
      this.outSemicolonLn$0();
    },
    visitContinue$1: function(node) {
      var t1;
      if (node.get$targetLabel() == null) {
        if (!this.shouldCompressOutput)
          this.out$1(this.get$indentation());
        this.out$1("continue");
      } else {
        t1 = "continue " + H.S(node.targetLabel);
        if (!this.shouldCompressOutput)
          this.out$1(this.get$indentation());
        this.out$1(t1);
      }
      this.outSemicolonLn$0();
    },
    visitBreak$1: function(node) {
      var t1;
      if (node.get$targetLabel() == null) {
        if (!this.shouldCompressOutput)
          this.out$1(this.get$indentation());
        this.out$1("break");
      } else {
        t1 = "break " + H.S(node.targetLabel);
        if (!this.shouldCompressOutput)
          this.out$1(this.get$indentation());
        this.out$1(t1);
      }
      this.outSemicolonLn$0();
    },
    visitReturn$1: function(node) {
      if (node.get$value(node) == null) {
        if (!this.shouldCompressOutput)
          this.out$1(this.get$indentation());
        this.out$1("return");
      } else {
        if (!this.shouldCompressOutput)
          this.out$1(this.get$indentation());
        this.out$1("return");
        this.pendingSpace = true;
        this.visitNestedExpression$4$newAtStatementBegin$newInForInit(node.value, 0, false, false);
      }
      this.outSemicolonLn$0();
    },
    visitThrow$1: function(node) {
      if (!this.shouldCompressOutput)
        this.out$1(this.get$indentation());
      this.out$1("throw");
      this.pendingSpace = true;
      this.visitNestedExpression$4$newAtStatementBegin$newInForInit(node.get$expression(), 0, false, false);
      this.outSemicolonLn$0();
    },
    visitTry$1: function(node) {
      var t1, t2;
      t1 = !this.shouldCompressOutput;
      if (t1)
        this.out$1(this.get$indentation());
      this.out$1("try");
      this.blockBody$3$needsNewline$needsSeparation(node.get$body(node), false, true);
      t2 = node.catchPart;
      if (t2 != null)
        this.visit$1(t2);
      t2 = node.finallyPart;
      if (t2 != null) {
        if (t1)
          this.out$1(" ");
        this.out$1("finally");
        this.blockBody$3$needsNewline$needsSeparation(t2, true, true);
      } else if (t1)
        this.out$1("\n");
    },
    visitCatch$1: function(node) {
      var t1 = !this.shouldCompressOutput;
      if (t1)
        this.out$1(" ");
      this.out$1("catch");
      if (t1)
        this.out$1(" ");
      this.out$1("(");
      this.visitNestedExpression$4$newAtStatementBegin$newInForInit(node.declaration, 0, false, false);
      this.out$1(")");
      this.blockBody$3$needsNewline$needsSeparation(node.body, true, false);
    },
    visitSwitch$1: function(node) {
      var t1 = !this.shouldCompressOutput;
      if (t1)
        this.out$1(this.get$indentation());
      this.out$1("switch");
      if (t1)
        this.out$1(" ");
      this.out$1("(");
      this.visitNestedExpression$4$newAtStatementBegin$newInForInit(node.get$key(node), 0, false, false);
      this.out$1(")");
      if (t1)
        this.out$1(" ");
      this.out$1("{");
      if (t1)
        this.out$1("\n");
      ++this._indentLevel;
      new Q.Printer_visitSwitch_closure(this, node).call$0();
      --this._indentLevel;
      if (t1)
        this.out$1(this.get$indentation());
      this.out$1("}");
      if (t1)
        this.out$1("\n");
    },
    visitCase$1: function(node) {
      var t1 = !this.shouldCompressOutput;
      if (t1)
        this.out$1(this.get$indentation());
      this.out$1("case");
      this.pendingSpace = true;
      this.visitNestedExpression$4$newAtStatementBegin$newInForInit(node.expression, 0, false, false);
      this.out$1(":");
      if (t1)
        this.out$1("\n");
      if (node.body.statements.length !== 0) {
        ++this._indentLevel;
        new Q.Printer_visitCase_closure(this, node).call$0();
        --this._indentLevel;
      }
    },
    visitDefault$1: function(node) {
      var t1 = !this.shouldCompressOutput;
      if (t1)
        this.out$1(this.get$indentation());
      this.out$1("default:");
      if (t1)
        this.out$1("\n");
      if (node.body.statements.length !== 0) {
        ++this._indentLevel;
        new Q.Printer_visitDefault_closure(this, node).call$0();
        --this._indentLevel;
      }
    },
    visitLabeledStatement$1: function(node) {
      var t1 = node.label + ":";
      if (!this.shouldCompressOutput)
        this.out$1(this.get$indentation());
      this.out$1(t1);
      this.blockBody$3$needsNewline$needsSeparation(node.body, true, false);
    },
    functionOut$3: function(fun, $name, vars) {
      var t1, t2;
      this.out$1("function");
      if ($name != null) {
        this.out$1(" ");
        this.visitNestedExpression$4$newAtStatementBegin$newInForInit($name, 14, false, false);
      }
      t1 = this.localNamer;
      t1.enterScope$1(vars);
      this.out$1("(");
      t2 = fun.params;
      this.visitCommaSeparated$4$newAtStatementBegin$newInForInit(t2, 14, false, false);
      this.out$1(")");
      this.blockBody$3$needsNewline$needsSeparation(fun.body, false, false);
      t1.leaveScope$0();
    },
    visitFunctionDeclaration$1: function(declaration) {
      var vars, t1, t2;
      vars = Q.VarCollector$();
      t1 = declaration.$function;
      vars.collectVarsInFunction$1(t1);
      t2 = !this.shouldCompressOutput;
      if (t2)
        this.out$1(this.get$indentation());
      this.functionOut$3(t1, declaration.name, vars);
      if (t2)
        this.out$1("\n");
    },
    visitNestedExpression$4$newAtStatementBegin$newInForInit: function(node, requiredPrecedence, newAtStatementBegin, newInForInit) {
      var t1, needsParentheses;
      if (!(requiredPrecedence !== 0 && node.get$precedenceLevel() < requiredPrecedence))
        if (!(newInForInit && !!J.getInterceptor(node).$isBinary && node.op === "in")) {
          if (newAtStatementBegin) {
            t1 = J.getInterceptor(node);
            t1 = !!t1.$isNamedFunction || !!t1.$isFun || !!t1.$isObjectInitializer;
          } else
            t1 = false;
          needsParentheses = t1;
        } else
          needsParentheses = true;
      else
        needsParentheses = true;
      if (needsParentheses) {
        this.inForInit = false;
        this.atStatementBegin = false;
        this.out$1("(");
        this.visit$1(node);
        this.out$1(")");
      } else {
        this.inForInit = newInForInit;
        this.atStatementBegin = newAtStatementBegin;
        this.visit$1(node);
      }
    },
    visitVariableDeclarationList$1: function(list) {
      this.out$1("var ");
      this.visitCommaSeparated$4$newAtStatementBegin$newInForInit(list.declarations, 1, false, this.inForInit);
    },
    visitAssignment$1: function(assignment) {
      var t1, t2, op;
      t1 = this.inForInit;
      this.visitNestedExpression$4$newAtStatementBegin$newInForInit(assignment.leftHandSide, 13, this.atStatementBegin, t1);
      t1 = assignment.value;
      if (t1 != null) {
        t2 = !this.shouldCompressOutput;
        if (t2)
          this.out$1(" ");
        op = assignment.op;
        if (op != null)
          this.out$1(op);
        this.out$1("=");
        if (t2)
          this.out$1(" ");
        this.visitNestedExpression$4$newAtStatementBegin$newInForInit(t1, 1, false, this.inForInit);
      }
    },
    visitVariableInitialization$1: function(initialization) {
      this.visitAssignment$1(initialization);
    },
    visitConditional$1: function(cond) {
      var t1 = this.inForInit;
      this.visitNestedExpression$4$newAtStatementBegin$newInForInit(cond.condition, 2, this.atStatementBegin, t1);
      t1 = !this.shouldCompressOutput;
      if (t1)
        this.out$1(" ");
      this.out$1("?");
      if (t1)
        this.out$1(" ");
      this.visitNestedExpression$4$newAtStatementBegin$newInForInit(cond.then, 1, false, false);
      if (t1)
        this.out$1(" ");
      this.out$1(":");
      if (t1)
        this.out$1(" ");
      this.visitNestedExpression$4$newAtStatementBegin$newInForInit(cond.otherwise, 1, false, this.inForInit);
    },
    visitNew$1: function(node) {
      this.out$1("new ");
      this.visitNestedExpression$4$newAtStatementBegin$newInForInit(node.target, 13, false, this.inForInit);
      this.out$1("(");
      this.visitCommaSeparated$4$newAtStatementBegin$newInForInit(node.arguments, 1, false, false);
      this.out$1(")");
    },
    visitCall$1: function($call) {
      var t1 = this.inForInit;
      this.visitNestedExpression$4$newAtStatementBegin$newInForInit($call.target, 13, this.atStatementBegin, t1);
      this.out$1("(");
      this.visitCommaSeparated$4$newAtStatementBegin$newInForInit($call.arguments, 1, false, false);
      this.out$1(")");
    },
    visitBinary$1: function(binary) {
      var op, leftPrecedenceRequirement, rightPrecedenceRequirement, leftSpace, t1;
      op = binary.op;
      switch (op) {
        case ",":
          leftPrecedenceRequirement = 0;
          rightPrecedenceRequirement = 0;
          leftSpace = false;
          break;
        case "||":
          leftPrecedenceRequirement = 2;
          rightPrecedenceRequirement = 2;
          leftSpace = true;
          break;
        case "&&":
          leftPrecedenceRequirement = 3;
          rightPrecedenceRequirement = 3;
          leftSpace = true;
          break;
        case "|":
          leftPrecedenceRequirement = 4;
          rightPrecedenceRequirement = 4;
          leftSpace = true;
          break;
        case "^":
          leftPrecedenceRequirement = 5;
          rightPrecedenceRequirement = 5;
          leftSpace = true;
          break;
        case "&":
          leftPrecedenceRequirement = 6;
          rightPrecedenceRequirement = 6;
          leftSpace = true;
          break;
        case "==":
        case "!=":
        case "===":
        case "!==":
          leftPrecedenceRequirement = 7;
          rightPrecedenceRequirement = 8;
          leftSpace = true;
          break;
        case "<":
        case ">":
        case "<=":
        case ">=":
        case "instanceof":
        case "in":
          leftPrecedenceRequirement = 8;
          rightPrecedenceRequirement = 9;
          leftSpace = true;
          break;
        case ">>":
        case "<<":
        case ">>>":
          leftPrecedenceRequirement = 9;
          rightPrecedenceRequirement = 10;
          leftSpace = true;
          break;
        case "+":
        case "-":
          leftPrecedenceRequirement = 10;
          rightPrecedenceRequirement = 11;
          leftSpace = true;
          break;
        case "*":
        case "/":
        case "%":
          leftPrecedenceRequirement = 11;
          rightPrecedenceRequirement = 12;
          leftSpace = true;
          break;
        default:
          this.compiler.internalError$2(C._SpannableSentinel_fBD, "Forgot operator: " + H.S(op));
          leftPrecedenceRequirement = null;
          rightPrecedenceRequirement = null;
          leftSpace = true;
      }
      t1 = this.inForInit;
      this.visitNestedExpression$4$newAtStatementBegin$newInForInit(binary.left, leftPrecedenceRequirement, this.atStatementBegin, t1);
      if (op === "in" || op === "instanceof") {
        this.out$1(" ");
        this.out$1(op);
        this.out$1(" ");
      } else {
        if (leftSpace)
          if (!this.shouldCompressOutput)
            this.out$1(" ");
        this.out$1(op);
        if (!this.shouldCompressOutput)
          this.out$1(" ");
      }
      this.visitNestedExpression$4$newAtStatementBegin$newInForInit(binary.right, rightPrecedenceRequirement, false, this.inForInit);
    },
    visitPrefix$1: function(unary) {
      var op = unary.op;
      switch (op) {
        case "delete":
        case "void":
        case "typeof":
          this.out$1(op);
          this.out$1(" ");
          break;
        case "+":
        case "++":
          if (this.get$lastCharCode() === 43)
            this.out$1(" ");
          this.out$1(op);
          break;
        case "-":
        case "--":
          if (this.get$lastCharCode() === 45)
            this.out$1(" ");
          this.out$1(op);
          break;
        default:
          this.out$1(op);
      }
      this.visitNestedExpression$4$newAtStatementBegin$newInForInit(unary.argument, 12, false, this.inForInit);
    },
    visitPostfix$1: function(postfix) {
      var t1 = this.inForInit;
      this.visitNestedExpression$4$newAtStatementBegin$newInForInit(postfix.argument, 13, this.atStatementBegin, t1);
      this.out$1(postfix.op);
    },
    visitVariableUse$1: function(ref) {
      this.out$1(this.localNamer.getName$1(ref.name));
    },
    visitThis$1: function(node) {
      this.out$1("this");
    },
    visitVariableDeclaration$1: function(decl) {
      this.out$1(this.localNamer.getName$1(decl.name));
    },
    visitParameter$1: function(param) {
      this.out$1(this.localNamer.getName$1(param.name));
    },
    isValidJavaScriptId$1: function(field) {
      var t1, t2, i, charCode, t3;
      t1 = field.length;
      if (t1 < 3)
        return false;
      for (t2 = t1 - 1, i = 1; i < t2; ++i) {
        if (i >= t1)
          H.throwExpression(P.RangeError$value(i));
        charCode = field.charCodeAt(i);
        if (!(97 <= charCode && charCode <= 122))
          if (!(65 <= charCode && charCode <= 90))
            if (charCode !== 36)
              if (charCode !== 95)
                t3 = i !== 1 && 48 <= charCode && charCode <= 57;
              else
                t3 = true;
            else
              t3 = true;
          else
            t3 = true;
        else
          t3 = true;
        if (!t3)
          return false;
      }
      if (field === "\"super\"")
        return false;
      return true;
    },
    visitAccess$1: function(access) {
      var t1, t2, selector, fieldWithQuotes;
      t1 = access.receiver;
      t2 = this.inForInit;
      this.visitNestedExpression$4$newAtStatementBegin$newInForInit(t1, 13, this.atStatementBegin, t2);
      selector = access.selector;
      if (!!J.getInterceptor(selector).$isLiteralString0) {
        fieldWithQuotes = selector.value;
        if (this.isValidJavaScriptId$1(fieldWithQuotes)) {
          if (!!J.getInterceptor(t1).$isLiteralNumber)
            this.out$1(" ");
          this.out$1(".");
          this.out$1(J.substring$2$s(fieldWithQuotes, 1, fieldWithQuotes.length - 1));
          return;
        }
      }
      this.out$1("[");
      this.visitNestedExpression$4$newAtStatementBegin$newInForInit(selector, 0, false, false);
      this.out$1("]");
    },
    visitNamedFunction$1: function(namedFunction) {
      var vars, t1;
      vars = Q.VarCollector$();
      t1 = namedFunction.$function;
      vars.collectVarsInFunction$1(t1);
      this.functionOut$3(t1, namedFunction.name, vars);
    },
    visitFun$1: function(fun) {
      var vars = Q.VarCollector$();
      vars.collectVarsInFunction$1(fun);
      this.functionOut$3(fun, null, vars);
    },
    visitLiteralBool$1: function(node) {
      this.out$1(node.value ? "true" : "false");
    },
    visitLiteralString$1: function(node) {
      this.out$1(node.value);
    },
    visitLiteralNumber$1: function(node) {
      var t1 = node.value;
      if (J.codeUnitAt$1$s(t1, 0) === 45 && this.get$lastCharCode() === 45)
        this.out$1(" ");
      this.out$1(t1);
    },
    visitLiteralNull$1: function(node) {
      this.out$1("null");
    },
    visitArrayInitializer$1: function(node) {
      var elements, t1, t2, elementIndex, i;
      this.out$1("[");
      elements = node.elements;
      t1 = node.length;
      if (typeof t1 !== "number")
        return H.iae(t1);
      t2 = !this.shouldCompressOutput;
      elementIndex = 0;
      i = 0;
      for (; i < t1; ++i)
        if (elementIndex < elements.length && J.get$index$x(elements[elementIndex]) === i) {
          if (elementIndex >= elements.length)
            return H.ioore(elements, elementIndex);
          this.visitNestedExpression$4$newAtStatementBegin$newInForInit(J.get$value$x(elements[elementIndex]), 1, false, false);
          ++elementIndex;
          if (i !== t1 - 1) {
            this.out$1(",");
            if (t2)
              this.out$1(" ");
          }
        } else
          this.out$1(",");
      this.out$1("]");
    },
    visitArrayElement$1: function(node) {
      throw H.wrapException("Unreachable");
    },
    visitObjectInitializer$1: function(node) {
      var properties, t1, t2, t3, i, t4;
      properties = node.properties;
      this.out$1("{");
      ++this._indentLevel;
      for (t1 = node.isOneLiner, t2 = !t1, t3 = !this.shouldCompressOutput, i = 0; t4 = properties.length, i < t4; ++i) {
        J.get$value$x(properties[i]);
        if (i !== 0) {
          this.out$1(",");
          if (t1)
            if (t3)
              this.out$1(" ");
        }
        if (t2) {
          this.out$1("\n");
          if (t3)
            this.out$1(this.get$indentation());
        }
        if (i >= properties.length)
          return H.ioore(properties, i);
        this.visit$1(properties[i]);
      }
      --this._indentLevel;
      if (t2 && t4 !== 0) {
        if (t3)
          this.out$1("\n");
        if (t3)
          this.out$1(this.get$indentation());
      }
      this.out$1("}");
    },
    visitProperty$1: function(node) {
      var t1, t2, $name;
      t1 = node.name;
      t2 = J.getInterceptor(t1);
      if (!!t2.$isLiteralString0) {
        $name = t2.get$value(t1);
        if (this.isValidJavaScriptId$1($name))
          this.out$1(J.substring$2$s($name, 1, $name.length - 1));
        else
          this.out$1($name);
      } else
        this.out$1(t2.get$value(t1));
      this.out$1(":");
      if (!this.shouldCompressOutput)
        this.out$1(" ");
      this.visitNestedExpression$4$newAtStatementBegin$newInForInit(node.value, 1, false, false);
    },
    visitRegExpLiteral$1: function(node) {
      this.out$1(node.pattern);
    },
    visitLiteralExpression$1: function(node) {
      var template, inputs, parts, i;
      template = node.template;
      inputs = node.inputs;
      parts = template.split("#");
      if (parts.length !== 1)
        this.compiler.internalError$2(C._SpannableSentinel_fBD, "Wrong number of arguments for JS: " + template);
      if (0 >= parts.length)
        return H.ioore(parts, 0);
      this.out$1(parts[0]);
      for (i = 0; false;) {
        if (i >= 0)
          return H.ioore(inputs, i);
        this.visit$1(inputs[i]);
        ++i;
        if (i >= parts.length)
          return H.ioore(parts, i);
        this.out$1(parts[i]);
      }
    },
    visitLiteralStatement$1: function(node) {
      this.out$1(node.code);
      if (!this.shouldCompressOutput)
        this.out$1("\n");
    },
    visitInterpolatedExpression$1: function(node) {
      this.out$1("#" + node.name);
      return;
    },
    visitInterpolatedLiteral$1: function(node) {
      this.out$1("#" + node.name);
      return;
    },
    visitInterpolatedParameter$1: function(node) {
      this.out$1("#" + node.name);
      return;
    },
    visitInterpolatedSelector$1: function(node) {
      this.out$1("#" + node.name);
      return;
    },
    visitInterpolatedStatement$1: function(node) {
      this.out$1("#" + node.name);
      if (!this.shouldCompressOutput)
        this.out$1("\n");
    },
    visitComment$1: function(node) {
      var comment, t1, line, t2;
      if (this.shouldCompressOutput)
        return;
      comment = C.JSString_methods.trim$0(node.comment);
      if (comment.length === 0)
        return;
      for (t1 = comment.split("\n"), t1 = H.setRuntimeTypeInfo(new H.ListIterator(t1, t1.length, 0, null), [H.getTypeArgumentByIndex(t1, 0)]); t1.moveNext$0();) {
        line = t1.__internal$_current;
        t2 = J.getInterceptor$s(line);
        if (C.JSString_methods.startsWith$1(comment, "//")) {
          t2 = t2.trim$0(line);
          this.out$1(this.get$indentation());
          this.out$1(t2);
          this.out$1("\n");
        } else {
          t2 = "// " + t2.trim$0(line);
          this.out$1(this.get$indentation());
          this.out$1(t2);
          this.out$1("\n");
        }
      }
    },
    static: {"^": "Printer_identifierCharacterRegExp,Printer_expressionContinuationRegExp", Printer$: function(compiler, monitor, allowVariableMinification) {
        var t1, t2, t3, t4;
        t1 = compiler.enableMinification;
        t2 = P.StringBuffer$("");
        t3 = H.setRuntimeTypeInfo([], [K.CodeBufferMarker]);
        t4 = t1 && allowVariableMinification ? new Q.MinifyRenamer([], [], [], 0, 0) : new Q.IdentityNamer();
        return new Q.Printer(t1, compiler, new K.CodeBuffer(t2, t3, 0, 0), false, false, new Q.DanglingElseVisitor(compiler), t4, false, false, monitor, null, 0, H.setRuntimeTypeInfo([""], [P.String]), "  ");
      }}
  },
  Printer_blockBody_closure: {
    "^": "Closure:23;this_0,body_1",
    call$0: function() {
      return this.this_0.visit$1(this.body_1);
    },
    $isFunction: true
  },
  Printer_blockOut_closure: {
    "^": "Closure:23;this_0,node_1",
    call$0: function() {
      return H.IterableMixinWorkaround_forEach(this.node_1.statements, this.this_0.get$blockOutWithoutBraces());
    },
    $isFunction: true
  },
  Printer_visitSwitch_closure: {
    "^": "Closure:23;this_0,node_1",
    call$0: function() {
      H.IterableMixinWorkaround_forEach(this.node_1.cases, this.this_0.get$visit());
      return;
    },
    $isFunction: true
  },
  Printer_visitCase_closure: {
    "^": "Closure:23;this_0,node_1",
    call$0: function() {
      return this.this_0.blockOutWithoutBraces$1(this.node_1.body);
    },
    $isFunction: true
  },
  Printer_visitDefault_closure: {
    "^": "Closure:23;this_0,node_1",
    call$0: function() {
      return this.this_0.blockOutWithoutBraces$1(this.node_1.body);
    },
    $isFunction: true
  },
  OrderedSet: {
    "^": "Object;set,list",
    add$1: function(_, x) {
      var t1 = this.set;
      if (!t1.contains$1(0, x)) {
        t1.add$1(0, x);
        this.list.push(x);
      }
    },
    forEach$1: function(_, fun) {
      H.IterableMixinWorkaround_forEach(this.list, fun);
    },
    static: {OrderedSet$: function($T) {
        return H.setRuntimeTypeInfo(new Q.OrderedSet(P.LinkedHashSet_LinkedHashSet(null, null, null, $T), H.setRuntimeTypeInfo([], [$T])), [$T]);
      }}
  },
  VarCollector: {
    "^": "BaseVisitor;nested,vars,params",
    collectVarsInFunction$1: function(fun) {
      var t1, t2, t3, i, t4;
      if (!this.nested) {
        this.nested = true;
        t1 = fun.params;
        for (t2 = this.params, t3 = t2.set, t2 = t2.list, i = 0; i < t1.length; ++i) {
          t4 = J.get$name$x(t1[i]);
          if (!t3.contains$1(0, t4)) {
            t3.add$1(0, t4);
            t2.push(t4);
          }
        }
        this.visitNode$1(fun.body);
        this.nested = false;
      }
    },
    visitFunctionDeclaration$1: function(declaration) {
      this.collectVarsInFunction$1(declaration.$function);
    },
    visitNamedFunction$1: function(namedFunction) {
      this.collectVarsInFunction$1(namedFunction.$function);
    },
    visitFun$1: function(fun) {
      this.collectVarsInFunction$1(fun);
    },
    visitThis$1: function(node) {
    },
    visitVariableDeclaration$1: function(decl) {
      this.vars.add$1(0, decl.name);
    },
    $asBaseVisitor: function() {
      return [null];
    },
    static: {VarCollector$: function() {
        return new Q.VarCollector(false, Q.OrderedSet$(P.String), Q.OrderedSet$(P.String));
      }}
  },
  DanglingElseVisitor: {
    "^": "BaseVisitor;compiler<",
    visitNode$1: function(node) {
      this.compiler.internalError$2(C._SpannableSentinel_fBD, "Forgot node: " + J.toString$0(node));
    },
    visitBlock$1: function(node) {
      return false;
    },
    visitExpressionStatement$1: function(node) {
      return false;
    },
    visitEmptyStatement$1: function(node) {
      return false;
    },
    visitIf$1: function(node) {
      if (!!J.getInterceptor(node.get$otherwise()).$isEmptyStatement)
        return true;
      return node.otherwise.accept$1(0, this);
    },
    visitFor$1: function(node) {
      return node.get$body(node).accept$1(0, this);
    },
    visitForIn$1: function(node) {
      return node.body.accept$1(0, this);
    },
    visitWhile$1: function(node) {
      return node.body.accept$1(0, this);
    },
    visitDo$1: function(node) {
      return false;
    },
    visitContinue$1: function(node) {
      return false;
    },
    visitBreak$1: function(node) {
      return false;
    },
    visitReturn$1: function(node) {
      return false;
    },
    visitThrow$1: function(node) {
      return false;
    },
    visitTry$1: function(node) {
      var t1;
      if (node.get$finallyPart() != null) {
        t1 = node.finallyPart;
        t1.toString;
        return this.visitBlock$1(t1);
      } else {
        t1 = node.catchPart;
        t1.toString;
        return this.visitCatch$1(t1);
      }
    },
    visitCatch$1: function(node) {
      var t1 = node.body;
      t1.toString;
      return this.visitBlock$1(t1);
    },
    visitSwitch$1: function(node) {
      return false;
    },
    visitCase$1: function(node) {
      return false;
    },
    visitDefault$1: function(node) {
      return false;
    },
    visitFunctionDeclaration$1: function(node) {
      return false;
    },
    visitLabeledStatement$1: function(node) {
      return node.body.accept$1(0, this);
    },
    visitLiteralStatement$1: function(node) {
      return true;
    },
    visitExpression$1: function(node) {
      return false;
    },
    $asBaseVisitor: function() {
      return [P.bool];
    }
  },
  IdentityNamer: {
    "^": "Object;",
    getName$1: function(oldName) {
      return oldName;
    },
    enterScope$1: function(vars) {
    },
    leaveScope$0: function() {
    }
  },
  MinifyRenamer: {
    "^": "Object;maps,parameterNumberStack,variableNumberStack,parameterNumber,variableNumber",
    enterScope$1: function(vars) {
      this.maps.push(P.LinkedHashMap_LinkedHashMap(null, null, null, P.String, P.String));
      this.variableNumberStack.push(this.variableNumber);
      this.parameterNumberStack.push(this.parameterNumber);
      H.IterableMixinWorkaround_forEach(vars.vars.list, this.get$declareVariable());
      H.IterableMixinWorkaround_forEach(vars.params.list, this.get$declareParameter());
    },
    leaveScope$0: function() {
      var t1 = this.maps;
      if (0 >= t1.length)
        return H.ioore(t1, 0);
      t1.pop();
      t1 = this.variableNumberStack;
      if (0 >= t1.length)
        return H.ioore(t1, 0);
      this.variableNumber = t1.pop();
      t1 = this.parameterNumberStack;
      if (0 >= t1.length)
        return H.ioore(t1, 0);
      this.parameterNumber = t1.pop();
    },
    getName$1: function(oldName) {
      var t1, i, replacement;
      for (t1 = this.maps, i = t1.length - 1; i >= 0; --i) {
        if (i >= t1.length)
          return H.ioore(t1, i);
        replacement = t1[i].$index(0, oldName);
        if (replacement != null)
          return replacement;
      }
      return oldName;
    },
    declareVariable$1: [function(oldName) {
      var t1, t2, newName;
      if (J.getInterceptor$s(oldName).startsWith$1(oldName, "$") && C.JSString_methods.endsWith$1(oldName, "$"))
        return oldName;
      t1 = this.variableNumber;
      t2 = t1 + this.parameterNumber;
      newName = t2 < 26 ? this.getNameNumber$2(oldName, 25 - t1) : this.getNameNumber$2(oldName, t2);
      ++this.variableNumber;
      return newName;
    }, "call$1", "get$declareVariable", 2, 0, 3],
    declareParameter$1: [function(oldName) {
      var t1, t2, newName;
      if (J.getInterceptor$s(oldName).startsWith$1(oldName, "$") && C.JSString_methods.endsWith$1(oldName, "$"))
        return oldName;
      t1 = this.variableNumber;
      t2 = this.parameterNumber;
      t1 += t2;
      newName = t1 < 26 ? this.getNameNumber$2(oldName, t2) : this.getNameNumber$2(oldName, t1);
      ++this.parameterNumber;
      return newName;
    }, "call$1", "get$declareParameter", 2, 0, 3],
    getNameNumber$2: function(oldName, n) {
      var t1, newName, digit, alphaChars, nameSpaceSize, codes, i, t2;
      t1 = this.maps;
      if (t1.length === 0)
        return oldName;
      if (n < 26)
        newName = P.String_String$fromCharCodes([Q.MinifyRenamer_nthLetter(n)]);
      else {
        n -= 26;
        digit = C.JSInt_methods.$mod(n, 10);
        n = C.JSInt_methods._tdivFast$1(n, 10);
        for (alphaChars = 1, nameSpaceSize = 26; n >= nameSpaceSize;) {
          n -= nameSpaceSize;
          ++alphaChars;
          nameSpaceSize *= 26;
        }
        codes = H.setRuntimeTypeInfo([], [P.$int]);
        for (i = 0; i < alphaChars; ++i) {
          nameSpaceSize = C.JSInt_methods._tdivFast$1(nameSpaceSize, 26);
          t2 = C.JSInt_methods.$mod(C.JSInt_methods.$tdiv(n, nameSpaceSize), 26);
          codes.push(97 + t2);
        }
        codes.push(48 + digit);
        newName = P.String_String$fromCharCodes(codes);
      }
      C.JSArray_methods.get$last(t1).$indexSet(0, oldName, newName);
      return newName;
    },
    static: {"^": "MinifyRenamer_LOWER_CASE_LETTERS,MinifyRenamer_LETTERS,MinifyRenamer_DIGITS", MinifyRenamer_nthLetter: function(n) {
        return n < 26 ? 97 + n : 65 + n - 26;
      }}
  },
  TemplateManager: {
    "^": "Object;expressionTemplates,statementTemplates",
    clear$0: function(_) {
      this.expressionTemplates.clear$0(0);
      this.statementTemplates.clear$0(0);
    }
  },
  Template: {
    "^": "Object;source>,isExpression,forceCopy,ast<,instantiator,positionalArgumentCount",
    instantiator$1: function(arg0) {
      return this.instantiator.call$1(arg0);
    },
    _compile$0: function() {
      var t1 = new Q.InterpolatedNodeAnalysis(P.LinkedHashSet_LinkedHashSet(null, null, null, Q.Node0), H.setRuntimeTypeInfo([], [Q.InterpolatedNode]), 0);
      this.instantiator = new Q.InstantiatorGeneratorVisitor(this.forceCopy, t1).compile$1(this.ast);
      this.positionalArgumentCount = t1.count;
    },
    instantiate$1: function($arguments) {
      var t1 = J.getInterceptor$asx($arguments);
      if (t1.get$length($arguments) !== this.positionalArgumentCount)
        throw H.wrapException("Wrong number of template arguments, given " + t1.get$length($arguments) + ", expected " + this.positionalArgumentCount);
      return this.instantiator$1($arguments);
    },
    Template$withExpressionResult$1: function(ast) {
      this.positionalArgumentCount = 0;
      this.instantiator = new Q.Template$withExpressionResult_closure(this);
    },
    Template$withStatementResult$1: function(ast) {
      this.positionalArgumentCount = 0;
      this.instantiator = new Q.Template$withStatementResult_closure(this);
    },
    static: {Template$withExpressionResult: function(ast) {
        var t1 = new Q.Template(null, true, false, ast, null, -1);
        t1.Template$withExpressionResult$1(ast);
        return t1;
      }, Template$withStatementResult: function(ast) {
        var t1 = new Q.Template(null, false, false, ast, null, -1);
        t1.Template$withStatementResult$1(ast);
        return t1;
      }}
  },
  Template$withExpressionResult_closure: {
    "^": "Closure:13;this_0",
    call$1: function($arguments) {
      return this.this_0.ast;
    },
    $isFunction: true
  },
  Template$withStatementResult_closure: {
    "^": "Closure:13;this_0",
    call$1: function($arguments) {
      return this.this_0.ast;
    },
    $isFunction: true
  },
  InstantiatorGeneratorVisitor: {
    "^": "Object;forceCopy,analysis",
    compile$1: function(node) {
      node.accept$1(0, this.analysis);
      return this.visit$1(node);
    },
    visit$1: [function(node) {
      if (this.forceCopy || this.analysis.containsInterpolatedNode.contains$1(0, node))
        return J.accept$1$x(node, this);
      return Q.InstantiatorGeneratorVisitor_same(node);
    }, "call$1", "get$visit", 2, 0, 191],
    visitNullable$1: function(node) {
      if (node == null)
        return Q.InstantiatorGeneratorVisitor_makeNull$closure();
      return this.visit$1(node);
    },
    visitSplayable$1: [function(node) {
      return this.visit$1(node);
    }, "call$1", "get$visitSplayable", 2, 0, 191],
    visitInterpolatedExpression$1: function(node) {
      return new Q.InstantiatorGeneratorVisitor_visitInterpolatedExpression_closure(node.name);
    },
    visitSplayableExpression$1: [function(node) {
      if (!!J.getInterceptor(node).$isInterpolatedExpression)
        return new Q.InstantiatorGeneratorVisitor_visitSplayableExpression_closure(node.name);
      return this.visit$1(node);
    }, "call$1", "get$visitSplayableExpression", 2, 0, 191],
    visitInterpolatedLiteral$1: function(node) {
      return new Q.InstantiatorGeneratorVisitor_visitInterpolatedLiteral_closure(node.name);
    },
    visitInterpolatedParameter$1: function(node) {
      return new Q.InstantiatorGeneratorVisitor_visitInterpolatedParameter_closure(node.name);
    },
    visitInterpolatedSelector$1: function(node) {
      return new Q.InstantiatorGeneratorVisitor_visitInterpolatedSelector_closure(node.name);
    },
    visitInterpolatedStatement$1: function(node) {
      return new Q.InstantiatorGeneratorVisitor_visitInterpolatedStatement_closure(node.name);
    },
    visitSplayableStatement$1: [function(node) {
      if (!!J.getInterceptor(node).$isInterpolatedStatement)
        return new Q.InstantiatorGeneratorVisitor_visitSplayableStatement_closure(node.name);
      return this.visit$1(node);
    }, "call$1", "get$visitSplayableStatement", 2, 0, 191],
    visitBlock$1: function(node) {
      return new Q.InstantiatorGeneratorVisitor_visitBlock_closure(H.setRuntimeTypeInfo(new H.MappedListIterable(node.statements, this.get$visitSplayableStatement()), [null, null]).toList$0(0));
    },
    visitExpressionStatement$1: function(node) {
      return new Q.InstantiatorGeneratorVisitor_visitExpressionStatement_closure(this.visit$1(node.expression));
    },
    visitEmptyStatement$1: function(node) {
      return new Q.InstantiatorGeneratorVisitor_visitEmptyStatement_closure();
    },
    visitIf$1: function(node) {
      if (!!J.getInterceptor(node.get$condition()).$isInterpolatedExpression)
        return this.visitIfConditionalCompilation$1(node);
      else
        return this.visitIfNormal$1(node);
    },
    visitIfConditionalCompilation$1: function(node) {
      return new Q.InstantiatorGeneratorVisitor_visitIfConditionalCompilation_closure(new Q.InstantiatorGeneratorVisitor_visitIfConditionalCompilation_compileCondition().call$1(node.condition), this.visit$1(node.then), this.visit$1(node.otherwise));
    },
    visitIfNormal$1: function(node) {
      return new Q.InstantiatorGeneratorVisitor_visitIfNormal_closure(this.visit$1(node.condition), this.visit$1(node.then), this.visit$1(node.otherwise));
    },
    visitFor$1: function(node) {
      return new Q.InstantiatorGeneratorVisitor_visitFor_closure(this.visitNullable$1(node.get$init()), this.visitNullable$1(node.condition), this.visitNullable$1(node.update), this.visit$1(node.body));
    },
    visitForIn$1: function(node) {
      return new Q.InstantiatorGeneratorVisitor_visitForIn_closure(this.visit$1(node.leftHandSide), this.visit$1(node.object), this.visit$1(node.body));
    },
    TODO$1: function($name) {
      throw H.wrapException(P.UnimplementedError$(this.toString$0(0) + "." + $name));
    },
    visitWhile$1: function(node) {
      return this.TODO$1("visitWhile");
    },
    visitDo$1: function(node) {
      return this.TODO$1("visitDo");
    },
    visitContinue$1: function(node) {
      return new Q.InstantiatorGeneratorVisitor_visitContinue_closure(node);
    },
    visitBreak$1: function(node) {
      return new Q.InstantiatorGeneratorVisitor_visitBreak_closure(node);
    },
    visitReturn$1: function(node) {
      return new Q.InstantiatorGeneratorVisitor_visitReturn_closure(this.visitNullable$1(node.get$value(node)));
    },
    visitThrow$1: function(node) {
      return new Q.InstantiatorGeneratorVisitor_visitThrow_closure(this.visit$1(node.get$expression()));
    },
    visitTry$1: function(node) {
      return new Q.InstantiatorGeneratorVisitor_visitTry_closure(this.visit$1(node.get$body(node)), this.visitNullable$1(node.catchPart), this.visitNullable$1(node.finallyPart));
    },
    visitCatch$1: function(node) {
      return new Q.InstantiatorGeneratorVisitor_visitCatch_closure(this.visit$1(node.declaration), this.visit$1(node.body));
    },
    visitSwitch$1: function(node) {
      return this.TODO$1("visitSwitch");
    },
    visitCase$1: function(node) {
      return this.TODO$1("visitCase");
    },
    visitDefault$1: function(node) {
      return this.TODO$1("visitDefault");
    },
    visitFunctionDeclaration$1: function(node) {
      return new Q.InstantiatorGeneratorVisitor_visitFunctionDeclaration_closure(this.visit$1(node.name), this.visit$1(node.$function));
    },
    visitLabeledStatement$1: function(node) {
      return this.TODO$1("visitLabeledStatement");
    },
    visitLiteralStatement$1: function(node) {
      return this.TODO$1("visitLiteralStatement");
    },
    visitLiteralExpression$1: function(node) {
      return this.TODO$1("visitLiteralExpression");
    },
    visitVariableDeclarationList$1: function(node) {
      return new Q.InstantiatorGeneratorVisitor_visitVariableDeclarationList_closure(H.setRuntimeTypeInfo(new H.MappedListIterable(node.declarations, this.get$visit()), [null, null]).toList$0(0));
    },
    visitAssignment$1: function(node) {
      return new Q.InstantiatorGeneratorVisitor_visitAssignment_closure(this.visit$1(node.leftHandSide), node.op, this.visitNullable$1(node.value));
    },
    visitVariableInitialization$1: function(node) {
      return new Q.InstantiatorGeneratorVisitor_visitVariableInitialization_closure(this.visit$1(node.leftHandSide), this.visitNullable$1(node.value));
    },
    visitConditional$1: function(cond) {
      return new Q.InstantiatorGeneratorVisitor_visitConditional_closure(this.visit$1(cond.condition), this.visit$1(cond.then), this.visit$1(cond.otherwise));
    },
    visitNew$1: function(node) {
      return this.handleCallOrNew$2(node, new Q.InstantiatorGeneratorVisitor_visitNew_closure());
    },
    visitCall$1: function(node) {
      return this.handleCallOrNew$2(node, new Q.InstantiatorGeneratorVisitor_visitCall_closure());
    },
    handleCallOrNew$2: function(node, finish) {
      return new Q.InstantiatorGeneratorVisitor_handleCallOrNew_closure(finish, this.visit$1(node.target), H.setRuntimeTypeInfo(new H.MappedListIterable(node.arguments, this.get$visitSplayableExpression()), [null, null]).toList$0(0));
    },
    visitBinary$1: function(node) {
      return new Q.InstantiatorGeneratorVisitor_visitBinary_closure(this.visit$1(node.left), this.visit$1(node.right), node.op);
    },
    visitPrefix$1: function(node) {
      return new Q.InstantiatorGeneratorVisitor_visitPrefix_closure(this.visit$1(node.argument), node.op);
    },
    visitPostfix$1: function(node) {
      return new Q.InstantiatorGeneratorVisitor_visitPostfix_closure(this.visit$1(node.argument), node.op);
    },
    visitVariableUse$1: function(node) {
      return new Q.InstantiatorGeneratorVisitor_visitVariableUse_closure(node);
    },
    visitThis$1: function(node) {
      return new Q.InstantiatorGeneratorVisitor_visitThis_closure();
    },
    visitVariableDeclaration$1: function(node) {
      return new Q.InstantiatorGeneratorVisitor_visitVariableDeclaration_closure(node);
    },
    visitParameter$1: function(node) {
      return new Q.InstantiatorGeneratorVisitor_visitParameter_closure(node);
    },
    visitAccess$1: function(node) {
      return new Q.InstantiatorGeneratorVisitor_visitAccess_closure(this.visit$1(node.receiver), this.visit$1(node.selector));
    },
    visitNamedFunction$1: function(node) {
      return new Q.InstantiatorGeneratorVisitor_visitNamedFunction_closure(this.visit$1(node.name), this.visit$1(node.$function));
    },
    visitFun$1: function(node) {
      return new Q.InstantiatorGeneratorVisitor_visitFun_closure(H.setRuntimeTypeInfo(new H.MappedListIterable(node.params, this.get$visitSplayable()), [null, null]).toList$0(0), this.visit$1(node.body));
    },
    visitLiteralBool$1: function(node) {
      return new Q.InstantiatorGeneratorVisitor_visitLiteralBool_closure(node);
    },
    visitLiteralString$1: function(node) {
      return new Q.InstantiatorGeneratorVisitor_visitLiteralString_closure(node);
    },
    visitLiteralNumber$1: function(node) {
      return new Q.InstantiatorGeneratorVisitor_visitLiteralNumber_closure(node);
    },
    visitLiteralNull$1: function(node) {
      return new Q.InstantiatorGeneratorVisitor_visitLiteralNull_closure();
    },
    visitArrayInitializer$1: function(node) {
      return new Q.InstantiatorGeneratorVisitor_visitArrayInitializer_closure(H.setRuntimeTypeInfo(new H.MappedListIterable(node.elements, new Q.InstantiatorGeneratorVisitor_visitArrayInitializer_closure0(this)), [null, null]).toList$0(0));
    },
    visitArrayElement$1: function(node) {
      throw H.wrapException("Should not get here");
    },
    visitObjectInitializer$1: function(node) {
      return new Q.InstantiatorGeneratorVisitor_visitObjectInitializer_closure(H.setRuntimeTypeInfo(new H.MappedListIterable(node.properties, this.get$visitSplayable()), [null, null]).toList$0(0), node.isOneLiner);
    },
    visitProperty$1: function(node) {
      return new Q.InstantiatorGeneratorVisitor_visitProperty_closure(this.visit$1(node.name), this.visit$1(node.value));
    },
    visitRegExpLiteral$1: function(node) {
      return new Q.InstantiatorGeneratorVisitor_visitRegExpLiteral_closure(node);
    },
    visitComment$1: function(node) {
      return this.TODO$1("visitComment");
    },
    static: {"^": "InstantiatorGeneratorVisitor_identiferRE", InstantiatorGeneratorVisitor_error: function(message) {
        throw H.wrapException(message);
      }, InstantiatorGeneratorVisitor_same: function(node) {
        return new Q.InstantiatorGeneratorVisitor_same_closure(node);
      }, InstantiatorGeneratorVisitor_makeNull: [function($arguments) {
        return;
      }, "call$1", "InstantiatorGeneratorVisitor_makeNull$closure", 2, 0, 22]}
  },
  InstantiatorGeneratorVisitor_same_closure: {
    "^": "Closure:13;node_0",
    call$1: function($arguments) {
      return this.node_0;
    },
    $isFunction: true
  },
  InstantiatorGeneratorVisitor_visitInterpolatedExpression_closure: {
    "^": "Closure:13;position_0",
    call$1: function($arguments) {
      var t1, value;
      t1 = this.position_0;
      value = J.$index$asx($arguments, t1);
      if (!!J.getInterceptor(value).$isExpression)
        return value;
      if (typeof value === "string")
        return new Q.VariableUse(value, null, null);
      Q.InstantiatorGeneratorVisitor_error("Interpolated value #" + t1 + " is not an Expression: " + H.S(value));
    },
    $isFunction: true
  },
  InstantiatorGeneratorVisitor_visitSplayableExpression_closure: {
    "^": "Closure:13;position_0",
    call$1: function($arguments) {
      var t1, value, t2;
      t1 = this.position_0;
      value = J.$index$asx($arguments, t1);
      t1 = new Q.InstantiatorGeneratorVisitor_visitSplayableExpression__toExpression(t1, value);
      t2 = J.getInterceptor(value);
      if (!!t2.$isIterable)
        return t2.map$1(value, t1);
      return t1.call$1(value);
    },
    $isFunction: true
  },
  InstantiatorGeneratorVisitor_visitSplayableExpression__toExpression: {
    "^": "Closure:192;position_1,value_2",
    call$1: function(item) {
      if (!!J.getInterceptor(item).$isExpression)
        return item;
      if (typeof item === "string")
        return new Q.VariableUse(item, null, null);
      return Q.InstantiatorGeneratorVisitor_error("Interpolated value #" + this.position_1 + " is not an Expression or List of Expressions: " + H.S(this.value_2));
    },
    $isFunction: true
  },
  InstantiatorGeneratorVisitor_visitInterpolatedLiteral_closure: {
    "^": "Closure:13;position_0",
    call$1: function($arguments) {
      var t1, value;
      t1 = this.position_0;
      value = J.$index$asx($arguments, t1);
      if (!!J.getInterceptor(value).$isLiteral)
        return value;
      Q.InstantiatorGeneratorVisitor_error("Interpolated value #" + t1 + " is not a Literal: " + H.S(value));
    },
    $isFunction: true
  },
  InstantiatorGeneratorVisitor_visitInterpolatedParameter_closure: {
    "^": "Closure:13;position_0",
    call$1: function($arguments) {
      var t1, value, t2;
      t1 = this.position_0;
      value = J.$index$asx($arguments, t1);
      t1 = new Q.InstantiatorGeneratorVisitor_visitInterpolatedParameter__toParameter(t1, value);
      t2 = J.getInterceptor(value);
      if (!!t2.$isIterable)
        return t2.map$1(value, t1);
      return t1.call$1(value);
    },
    $isFunction: true
  },
  InstantiatorGeneratorVisitor_visitInterpolatedParameter__toParameter: {
    "^": "Closure:193;position_1,value_2",
    call$1: function(item) {
      if (!!J.getInterceptor(item).$isParameter)
        return item;
      if (typeof item === "string")
        return new Q.Parameter(item, null, null);
      Q.InstantiatorGeneratorVisitor_error("Interpolated value #" + this.position_1 + " is not a Parameter or List of Parameters: " + H.S(this.value_2));
    },
    $isFunction: true
  },
  InstantiatorGeneratorVisitor_visitInterpolatedSelector_closure: {
    "^": "Closure:13;position_0",
    call$1: function($arguments) {
      var t1, value;
      t1 = this.position_0;
      value = J.$index$asx($arguments, t1);
      if (!!J.getInterceptor(value).$isExpression)
        return value;
      if (typeof value === "string")
        return new Q.LiteralString0("\"" + value + "\"", null, null);
      Q.InstantiatorGeneratorVisitor_error("Interpolated value #" + t1 + " is not a selector: " + H.S(value));
    },
    $isFunction: true
  },
  InstantiatorGeneratorVisitor_visitInterpolatedStatement_closure: {
    "^": "Closure:13;position_0",
    call$1: function($arguments) {
      var t1, value;
      t1 = this.position_0;
      value = J.$index$asx($arguments, t1);
      if (!!J.getInterceptor(value).$isNode0)
        return value.toStatement$0();
      Q.InstantiatorGeneratorVisitor_error("Interpolated value #" + t1 + " is not a Statement: " + H.S(value));
    },
    $isFunction: true
  },
  InstantiatorGeneratorVisitor_visitSplayableStatement_closure: {
    "^": "Closure:13;position_0",
    call$1: function($arguments) {
      var t1, value, t2;
      t1 = this.position_0;
      value = J.$index$asx($arguments, t1);
      t1 = new Q.InstantiatorGeneratorVisitor_visitSplayableStatement__toStatement(t1, value);
      t2 = J.getInterceptor(value);
      if (!!t2.$isIterable)
        return t2.map$1(value, t1);
      return t1.call$1(value);
    },
    $isFunction: true
  },
  InstantiatorGeneratorVisitor_visitSplayableStatement__toStatement: {
    "^": "Closure:194;position_1,value_2",
    call$1: function(item) {
      var t1 = J.getInterceptor(item);
      if (!!t1.$isStatement)
        return item;
      if (!!t1.$isExpression)
        return item.toStatement$0();
      Q.InstantiatorGeneratorVisitor_error("Interpolated value #" + this.position_1 + " is not a Statement or List of Statements: " + H.S(this.value_2));
    },
    $isFunction: true
  },
  InstantiatorGeneratorVisitor_visitBlock_closure: {
    "^": "Closure:13;instantiators_0",
    call$1: function($arguments) {
      var statements, t1, t2;
      statements = H.setRuntimeTypeInfo([], [Q.Statement]);
      t1 = new Q.InstantiatorGeneratorVisitor_visitBlock__add(statements);
      for (t2 = this.instantiators_0, t2 = H.setRuntimeTypeInfo(new H.ListIterator(t2, t2.length, 0, null), [H.getTypeArgumentByIndex(t2, 0)]); t2.moveNext$0();)
        t1.call$1(t2.__internal$_current.call$1($arguments));
      return new Q.Block(statements, null, null);
    },
    $isFunction: true
  },
  InstantiatorGeneratorVisitor_visitBlock__add: {
    "^": "Closure:8;statements_1",
    call$1: function(node) {
      var t1, t2;
      t1 = J.getInterceptor(node);
      if (!!t1.$isEmptyStatement)
        return;
      if (!!t1.$isIterable)
        C.JSArray_methods.addAll$1(this.statements_1, node);
      else {
        t2 = this.statements_1;
        if (!!t1.$isBlock)
          C.JSArray_methods.addAll$1(t2, node.statements);
        else
          t2.push(node.toStatement$0());
      }
    },
    $isFunction: true
  },
  InstantiatorGeneratorVisitor_visitExpressionStatement_closure: {
    "^": "Closure:13;buildExpression_0",
    call$1: function($arguments) {
      return this.buildExpression_0.call$1($arguments).toStatement$0();
    },
    $isFunction: true
  },
  InstantiatorGeneratorVisitor_visitEmptyStatement_closure: {
    "^": "Closure:13;",
    call$1: function($arguments) {
      return new Q.EmptyStatement(null, null);
    },
    $isFunction: true
  },
  InstantiatorGeneratorVisitor_visitIfConditionalCompilation_compileCondition: {
    "^": "Closure:195;",
    call$1: function(node) {
      return new Q.InstantiatorGeneratorVisitor_visitIfConditionalCompilation_compileCondition_closure(node.get$name(node));
    },
    $isFunction: true
  },
  InstantiatorGeneratorVisitor_visitIfConditionalCompilation_compileCondition_closure: {
    "^": "Closure:13;position_0",
    call$1: function($arguments) {
      var t1, value;
      t1 = this.position_0;
      value = J.$index$asx($arguments, t1);
      if (typeof value === "boolean")
        return value;
      if (!!J.getInterceptor(value).$isExpression)
        return value;
      if (typeof value === "string")
        return new Q.VariableUse(value, null, null);
      Q.InstantiatorGeneratorVisitor_error("Interpolated value #" + t1 + " is not an Expression: " + H.S(value));
    },
    $isFunction: true
  },
  InstantiatorGeneratorVisitor_visitIfConditionalCompilation_closure: {
    "^": "Closure:13;makeCondition_1,makeThen_2,makeOtherwise_3",
    call$1: function($arguments) {
      var condition = this.makeCondition_1.call$1($arguments);
      if (typeof condition === "boolean")
        if (condition)
          return this.makeThen_2.call$1($arguments);
        else
          return this.makeOtherwise_3.call$1($arguments);
      return new Q.If(condition, this.makeThen_2.call$1($arguments), this.makeOtherwise_3.call$1($arguments), null, null);
    },
    $isFunction: true
  },
  InstantiatorGeneratorVisitor_visitIfNormal_closure: {
    "^": "Closure:13;makeCondition_0,makeThen_1,makeOtherwise_2",
    call$1: function($arguments) {
      return new Q.If(this.makeCondition_0.call$1($arguments), this.makeThen_1.call$1($arguments), this.makeOtherwise_2.call$1($arguments), null, null);
    },
    $isFunction: true
  },
  InstantiatorGeneratorVisitor_visitFor_closure: {
    "^": "Closure:13;makeInit_0,makeCondition_1,makeUpdate_2,makeBody_3",
    call$1: function($arguments) {
      return new Q.For(this.makeInit_0.call$1($arguments), this.makeCondition_1.call$1($arguments), this.makeUpdate_2.call$1($arguments), this.makeBody_3.call$1($arguments), null, null);
    },
    $isFunction: true
  },
  InstantiatorGeneratorVisitor_visitForIn_closure: {
    "^": "Closure:13;makeLeftHandSide_0,makeObject_1,makeBody_2",
    call$1: function($arguments) {
      return new Q.ForIn(this.makeLeftHandSide_0.call$1($arguments), this.makeObject_1.call$1($arguments), this.makeBody_2.call$1($arguments), null, null);
    },
    $isFunction: true
  },
  InstantiatorGeneratorVisitor_visitContinue_closure: {
    "^": "Closure:13;node_0",
    call$1: function($arguments) {
      return new Q.Continue(this.node_0.targetLabel, null, null);
    },
    $isFunction: true
  },
  InstantiatorGeneratorVisitor_visitBreak_closure: {
    "^": "Closure:13;node_0",
    call$1: function($arguments) {
      return new Q.Break(this.node_0.targetLabel, null, null);
    },
    $isFunction: true
  },
  InstantiatorGeneratorVisitor_visitReturn_closure: {
    "^": "Closure:13;makeExpression_0",
    call$1: function($arguments) {
      return new Q.Return(this.makeExpression_0.call$1($arguments), null, null);
    },
    $isFunction: true
  },
  InstantiatorGeneratorVisitor_visitThrow_closure: {
    "^": "Closure:13;makeExpression_0",
    call$1: function($arguments) {
      return new Q.Throw(this.makeExpression_0.call$1($arguments), null, null);
    },
    $isFunction: true
  },
  InstantiatorGeneratorVisitor_visitTry_closure: {
    "^": "Closure:13;makeBody_0,makeCatch_1,makeFinally_2",
    call$1: function($arguments) {
      return new Q.Try(this.makeBody_0.call$1($arguments), this.makeCatch_1.call$1($arguments), this.makeFinally_2.call$1($arguments), null, null);
    },
    $isFunction: true
  },
  InstantiatorGeneratorVisitor_visitCatch_closure: {
    "^": "Closure:13;makeDeclaration_0,makeBody_1",
    call$1: function($arguments) {
      return new Q.Catch(this.makeDeclaration_0.call$1($arguments), this.makeBody_1.call$1($arguments), null, null);
    },
    $isFunction: true
  },
  InstantiatorGeneratorVisitor_visitFunctionDeclaration_closure: {
    "^": "Closure:13;makeName_0,makeFunction_1",
    call$1: function($arguments) {
      return new Q.FunctionDeclaration(this.makeName_0.call$1($arguments), this.makeFunction_1.call$1($arguments), null, null);
    },
    $isFunction: true
  },
  InstantiatorGeneratorVisitor_visitVariableDeclarationList_closure: {
    "^": "Closure:13;declarationMakers_0",
    call$1: function($arguments) {
      var declarations, t1;
      declarations = H.setRuntimeTypeInfo([], [Q.VariableInitialization]);
      for (t1 = this.declarationMakers_0, t1 = H.setRuntimeTypeInfo(new H.ListIterator(t1, t1.length, 0, null), [H.getTypeArgumentByIndex(t1, 0)]); t1.moveNext$0();)
        declarations.push(t1.__internal$_current.call$1($arguments));
      return new Q.VariableDeclarationList(declarations, null, null);
    },
    $isFunction: true
  },
  InstantiatorGeneratorVisitor_visitAssignment_closure: {
    "^": "Closure:13;makeLeftHandSide_0,op_1,makeValue_2",
    call$1: function($arguments) {
      return new Q.Assignment(this.makeLeftHandSide_0.call$1($arguments), this.op_1, this.makeValue_2.call$1($arguments), null, null);
    },
    $isFunction: true
  },
  InstantiatorGeneratorVisitor_visitVariableInitialization_closure: {
    "^": "Closure:13;makeDeclaration_0,makeValue_1",
    call$1: function($arguments) {
      return new Q.VariableInitialization(this.makeDeclaration_0.call$1($arguments), null, this.makeValue_1.call$1($arguments), null, null);
    },
    $isFunction: true
  },
  InstantiatorGeneratorVisitor_visitConditional_closure: {
    "^": "Closure:13;makeCondition_0,makeThen_1,makeOtherwise_2",
    call$1: function($arguments) {
      return new Q.Conditional(this.makeCondition_0.call$1($arguments), this.makeThen_1.call$1($arguments), this.makeOtherwise_2.call$1($arguments), null, null);
    },
    $isFunction: true
  },
  InstantiatorGeneratorVisitor_visitNew_closure: {
    "^": "Closure:19;",
    call$2: function(target, $arguments) {
      return new Q.New(target, $arguments, null, null);
    },
    $isFunction: true
  },
  InstantiatorGeneratorVisitor_visitCall_closure: {
    "^": "Closure:19;",
    call$2: function(target, $arguments) {
      return new Q.Call(target, $arguments, null, null);
    },
    $isFunction: true
  },
  InstantiatorGeneratorVisitor_handleCallOrNew_closure: {
    "^": "Closure:13;finish_0,makeTarget_1,argumentMakers_2",
    call$1: function($arguments) {
      var target, callArguments, t1, result;
      target = this.makeTarget_1.call$1($arguments);
      callArguments = H.setRuntimeTypeInfo([], [Q.Expression]);
      for (t1 = this.argumentMakers_2, t1 = H.setRuntimeTypeInfo(new H.ListIterator(t1, t1.length, 0, null), [H.getTypeArgumentByIndex(t1, 0)]); t1.moveNext$0();) {
        result = t1.__internal$_current.call$1($arguments);
        if (!!J.getInterceptor(result).$isIterable)
          C.JSArray_methods.addAll$1(callArguments, result);
        else
          callArguments.push(result);
      }
      return this.finish_0.call$2(target, C.JSArray_methods.toList$1$growable(callArguments, false));
    },
    $isFunction: true
  },
  InstantiatorGeneratorVisitor_visitBinary_closure: {
    "^": "Closure:13;makeLeft_0,makeRight_1,op_2",
    call$1: function($arguments) {
      return new Q.Binary(this.op_2, this.makeLeft_0.call$1($arguments), this.makeRight_1.call$1($arguments), null, null);
    },
    $isFunction: true
  },
  InstantiatorGeneratorVisitor_visitPrefix_closure: {
    "^": "Closure:13;makeOperand_0,op_1",
    call$1: function($arguments) {
      return new Q.Prefix(this.op_1, this.makeOperand_0.call$1($arguments), null, null);
    },
    $isFunction: true
  },
  InstantiatorGeneratorVisitor_visitPostfix_closure: {
    "^": "Closure:13;makeOperand_0,op_1",
    call$1: function($arguments) {
      return new Q.Postfix(this.op_1, this.makeOperand_0.call$1($arguments), null, null);
    },
    $isFunction: true
  },
  InstantiatorGeneratorVisitor_visitVariableUse_closure: {
    "^": "Closure:13;node_0",
    call$1: function($arguments) {
      return new Q.VariableUse(this.node_0.name, null, null);
    },
    $isFunction: true
  },
  InstantiatorGeneratorVisitor_visitThis_closure: {
    "^": "Closure:13;",
    call$1: function($arguments) {
      return new Q.This("this", null, null);
    },
    $isFunction: true
  },
  InstantiatorGeneratorVisitor_visitVariableDeclaration_closure: {
    "^": "Closure:13;node_0",
    call$1: function($arguments) {
      return new Q.VariableDeclaration(this.node_0.name, null, null);
    },
    $isFunction: true
  },
  InstantiatorGeneratorVisitor_visitParameter_closure: {
    "^": "Closure:13;node_0",
    call$1: function($arguments) {
      return new Q.Parameter(this.node_0.name, null, null);
    },
    $isFunction: true
  },
  InstantiatorGeneratorVisitor_visitAccess_closure: {
    "^": "Closure:13;makeReceiver_0,makeSelector_1",
    call$1: function($arguments) {
      return new Q.PropertyAccess(this.makeReceiver_0.call$1($arguments), this.makeSelector_1.call$1($arguments), null, null);
    },
    $isFunction: true
  },
  InstantiatorGeneratorVisitor_visitNamedFunction_closure: {
    "^": "Closure:13;makeDeclaration_0,makeFunction_1",
    call$1: function($arguments) {
      return new Q.NamedFunction(this.makeDeclaration_0.call$1($arguments), this.makeFunction_1.call$1($arguments), null, null);
    },
    $isFunction: true
  },
  InstantiatorGeneratorVisitor_visitFun_closure: {
    "^": "Closure:13;paramMakers_0,makeBody_1",
    call$1: function($arguments) {
      var params, t1, result;
      params = H.setRuntimeTypeInfo([], [Q.Parameter]);
      for (t1 = this.paramMakers_0, t1 = H.setRuntimeTypeInfo(new H.ListIterator(t1, t1.length, 0, null), [H.getTypeArgumentByIndex(t1, 0)]); t1.moveNext$0();) {
        result = t1.__internal$_current.call$1($arguments);
        if (!!J.getInterceptor(result).$isIterable)
          C.JSArray_methods.addAll$1(params, result);
        else
          params.push(result);
      }
      return new Q.Fun(params, this.makeBody_1.call$1($arguments), null, null);
    },
    $isFunction: true
  },
  InstantiatorGeneratorVisitor_visitLiteralBool_closure: {
    "^": "Closure:13;node_0",
    call$1: function($arguments) {
      return new Q.LiteralBool(this.node_0.value, null, null);
    },
    $isFunction: true
  },
  InstantiatorGeneratorVisitor_visitLiteralString_closure: {
    "^": "Closure:13;node_0",
    call$1: function($arguments) {
      return new Q.LiteralString0(this.node_0.value, null, null);
    },
    $isFunction: true
  },
  InstantiatorGeneratorVisitor_visitLiteralNumber_closure: {
    "^": "Closure:13;node_0",
    call$1: function($arguments) {
      return new Q.LiteralNumber(this.node_0.value, null, null);
    },
    $isFunction: true
  },
  InstantiatorGeneratorVisitor_visitLiteralNull_closure: {
    "^": "Closure:13;",
    call$1: function($arguments) {
      return new Q.LiteralNull(null, null);
    },
    $isFunction: true
  },
  InstantiatorGeneratorVisitor_visitArrayInitializer_closure0: {
    "^": "Closure:196;this_0",
    call$1: function(element) {
      return this.this_0.visit$1(J.get$value$x(element));
    },
    $isFunction: true
  },
  InstantiatorGeneratorVisitor_visitArrayInitializer_closure: {
    "^": "Closure:13;elementMakers_1",
    call$1: function($arguments) {
      var elements, t1, t2;
      elements = H.setRuntimeTypeInfo([], [Q.ArrayElement]);
      t1 = new Q.InstantiatorGeneratorVisitor_visitArrayInitializer__add(elements);
      for (t2 = this.elementMakers_1, t2 = H.setRuntimeTypeInfo(new H.ListIterator(t2, t2.length, 0, null), [H.getTypeArgumentByIndex(t2, 0)]); t2.moveNext$0();)
        t1.call$1(t2.__internal$_current.call$1($arguments));
      return new Q.ArrayInitializer(elements.length, elements, null, null);
    },
    $isFunction: true
  },
  InstantiatorGeneratorVisitor_visitArrayInitializer__add: {
    "^": "Closure:197;elements_2",
    call$1: function(value) {
      var t1 = this.elements_2;
      t1.push(new Q.ArrayElement(t1.length, value, null, null));
    },
    $isFunction: true
  },
  InstantiatorGeneratorVisitor_visitObjectInitializer_closure: {
    "^": "Closure:13;propertyMakers_0,isOneLiner_1",
    call$1: function($arguments) {
      var properties, t1, result;
      properties = H.setRuntimeTypeInfo([], [Q.Property]);
      for (t1 = this.propertyMakers_0, t1 = H.setRuntimeTypeInfo(new H.ListIterator(t1, t1.length, 0, null), [H.getTypeArgumentByIndex(t1, 0)]); t1.moveNext$0();) {
        result = t1.__internal$_current.call$1($arguments);
        if (!!J.getInterceptor(result).$isIterable)
          C.JSArray_methods.addAll$1(properties, result);
        else
          properties.push(result);
      }
      return new Q.ObjectInitializer(properties, this.isOneLiner_1, null, null);
    },
    $isFunction: true
  },
  InstantiatorGeneratorVisitor_visitProperty_closure: {
    "^": "Closure:13;makeName_0,makeValue_1",
    call$1: function($arguments) {
      return new Q.Property(this.makeName_0.call$1($arguments), this.makeValue_1.call$1($arguments), null, null);
    },
    $isFunction: true
  },
  InstantiatorGeneratorVisitor_visitRegExpLiteral_closure: {
    "^": "Closure:13;node_0",
    call$1: function($arguments) {
      return new Q.RegExpLiteral(this.node_0.pattern, null, null);
    },
    $isFunction: true
  },
  InterpolatedNodeAnalysis: {
    "^": "BaseVisitor;containsInterpolatedNode,interpolatedNodes,count",
    visitNode$1: function(node) {
      var before = this.count;
      node.visitChildren$1(this);
      if (this.count !== before)
        this.containsInterpolatedNode.add$1(0, node);
      return;
    },
    visitInterpolatedNode$1: function(node) {
      this.interpolatedNodes.push(node);
      this.containsInterpolatedNode.add$1(0, node);
      ++this.count;
    },
    $asBaseVisitor: function() {
      return [null];
    }
  }
}],
["js_backend", "package:compiler/implementation/js_backend/js_backend.dart", , Z, {
  "^": "",
  JavaScriptItemCompilationContext: {
    "^": "ItemCompilationContext;boundsChecked,allocatedFixedLists<"
  },
  FunctionInlineCache: {
    "^": "Object;canBeInlined,canBeInlinedInsideLoop",
    markAsNonInlinable$2$insideLoop: function(element, insideLoop) {
      var t1, t2;
      t1 = insideLoop == null || insideLoop;
      t2 = this.canBeInlined;
      if (t1) {
        t2.$indexSet(0, element, false);
        this.canBeInlinedInsideLoop.$indexSet(0, element, false);
      } else
        t2.$indexSet(0, element, false);
    }
  },
  JavaScriptBackend: {
    "^": "Backend;builder,optimizer<,generator,emitter<,inlineCache,jsHelperLibrary<,interceptorsLibrary<,foreignLibrary,isolateHelperLibrary<,closureClass<,boundClosureClass<,assertMethod<,invokeOnMethod,jsInterceptorClass<,jsStringClass<,jsArrayClass<,jsNumberClass<,jsIntClass<,jsDoubleClass<,jsNullClass<,jsBoolClass<,jsPlainJavaScriptObjectClass,jsUnknownJavaScriptObjectClass<,jsIndexableClass<,jsMutableIndexableClass<,jsMutableArrayClass<,jsFixedArrayClass<,jsExtendableArrayClass<,jsPositiveIntClass<,jsUInt32Class<,jsUInt31Class<,jsIndexableLength,jsArrayTypedConstructor,jsArrayRemoveLast,jsArrayAdd,jsStringSplit,jsStringToString,jsStringOperatorAdd,objectEquals,typeLiteralClass,mapLiteralClass,constMapLiteralClass,typeVariableClass,mapLiteralConstructor,mapLiteralConstructorEmpty,noSideEffectsClass,noThrowsClass,noInlineClass,irRepresentationClass,getInterceptorMethod<,interceptedNames<,jsInvocationMirrorClass,traceHelper,mapTypeToInterceptor<,indexablePrimitiveType,readableArrayType,mutableArrayType,fixedArrayType,extendableArrayType,nonNullType<,implementationClasses,getNativeInterceptorMethod<,needToInitializeIsolateAffinityTag<,needToInitializeDispatchProperty<,getIsolateAffinityTagMarker,namer<,jsIndexingBehaviorInterface<,oneShotInterceptors<,interceptedElements<,interceptedMixinElements,specializedGetInterceptors<,_interceptedClasses<,classesMixedIntoInterceptedClasses<,specialOperatorEqClasses,rti<,disableTreeShakingMarker,preserveNamesMarker,preserveMetadataMarker,preserveUrisMarker,preserveLibraryNamesMarker,requiresPreambleMarker,mustRetainMetadata<,hasRetainedMetadata<,mustRetainUris<,mustRetainLibraryNames<,mustPreserveNames,isTreeShakingDisabled<,hasInsufficientMirrorsUsed,requiresPreamble<,htmlLibraryIsLoaded<,metadataConstants,targetsUsed,metaTargetsUsed,_membersNeededForReflection,symbolsUsed,helpersUsed,checkedModeHelperByName,typeVariableHandler<,preMirrorsMethodCount,customElementsAnalysis<,constantCompilerTask<,resolutionCallbacks<,interceptedClassesCache,compiler,classesRequiredForReflection",
    get$classesRequiredForReflection: function() {
      return [this.closureClass, this.jsIndexableClass];
    },
    get$tasks: function() {
      return H.setRuntimeTypeInfo([this.builder, this.optimizer, this.generator, this.emitter], [K.CompilerTask]);
    },
    get$constantSystem: function() {
      return this.constantCompilerTask.jsConstantCompiler.constantSystem;
    },
    get$constants: function() {
      return this.constantCompilerTask.jsConstantCompiler;
    },
    find$2: function(_, library, $name) {
      return library.findLocal$1($name);
    },
    isForeign$1: function(element) {
      var t1, t2;
      t1 = element.get$library();
      t2 = this.foreignLibrary;
      return t1 == null ? t2 == null : t1 === t2;
    },
    isBackendLibrary$1: function(library) {
      var t1 = this.interceptorsLibrary;
      if (library == null ? t1 != null : library !== t1) {
        t1 = this.jsHelperLibrary;
        t1 = library == null ? t1 == null : library === t1;
      } else
        t1 = true;
      return t1;
    },
    usedByBackend$1: function(element) {
      var t1;
      if (element.get$kind(element) !== C.ElementKind_parameter_1) {
        t1 = element.kind;
        t1 = t1 === C.ElementKind_initializing_formal_1 || t1 === C.ElementKind_field_1;
      } else
        t1 = true;
      if (t1)
        if (this.usedByBackend$1(element.get$enclosingElement()))
          return true;
      return this.helpersUsed.contains$1(0, element.get$declaration());
    },
    invokedReflectively$1: function(element) {
      var t1;
      if (element.get$kind(element) === C.ElementKind_parameter_1 || element.kind === C.ElementKind_initializing_formal_1)
        if (this.invokedReflectively$1(element.get$functionDeclaration()))
          return true;
      if (element.kind === C.ElementKind_field_1) {
        if (O.Elements_isStaticOrTopLevel(element))
          t1 = element.get$isFinal() || (element.get$modifiers().flags & 16) !== 0;
        else
          t1 = false;
        if (t1)
          return false;
      }
      return this.isAccessibleByReflection$1(element.get$declaration());
    },
    canBeUsedForGlobalOptimizations$1: function(element) {
      return !this.usedByBackend$1(element) && !this.invokedReflectively$1(element);
    },
    isInterceptorClass$1: function(element) {
      if (element == null)
        return false;
      if (O.Elements_isNativeOrExtendsNative(element))
        return true;
      if (this._interceptedClasses.contains$1(0, element))
        return true;
      if (this.classesMixedIntoInterceptedClasses.contains$1(0, element))
        return true;
      return false;
    },
    isInterceptedMethod$1: function(element) {
      if (!element.get$isInstanceMember())
        return false;
      if (element.kind === C.ElementKind_generative_constructor_body_0)
        return O.Elements_isNativeOrExtendsNative(element.get$enclosingClass());
      return this.interceptedElements.$index(0, element.name) != null;
    },
    fieldHasInterceptedGetter$1: function(element) {
      return this.interceptedElements.$index(0, element.get$name(element)) != null;
    },
    isInterceptedMixinSelector$1: function(selector) {
      var elements, t1;
      elements = this.interceptedMixinElements.putIfAbsent$2(selector.name, new Z.JavaScriptBackend_isInterceptedMixinSelector_closure(this, selector));
      if (elements == null)
        return false;
      t1 = J.getInterceptor$asx(elements);
      if (t1.get$isEmpty(elements))
        return false;
      return t1.any$1(elements, new Z.JavaScriptBackend_isInterceptedMixinSelector_closure0(this, selector));
    },
    getInterceptedClassesOn$1: function($name) {
      var intercepted = this.interceptedElements.$index(0, $name);
      if (intercepted == null)
        return;
      return this.interceptedClassesCache.putIfAbsent$2($name, new Z.JavaScriptBackend_getInterceptedClassesOn_closure(this, intercepted));
    },
    nativeSubclassesOfMixin$1: function(mixin) {
      var t1, uses, t2, result, use, subclasses, t3, subclass;
      t1 = this.compiler;
      uses = t1.world.mixinUses.$index(0, mixin);
      if (uses == null)
        return;
      for (t2 = J.get$iterator$ax(uses), result = null; t2.moveNext$0();) {
        use = t2.get$current();
        subclasses = t1.world._subclasses.$index(0, use.get$declaration());
        if (subclasses != null)
          for (t3 = J.get$iterator$ax(subclasses); t3.moveNext$0();) {
            subclass = t3.get$current();
            if (O.Elements_isNativeOrExtendsNative(subclass)) {
              if (result == null)
                result = P.LinkedHashSet_LinkedHashSet(null, null, null, O.ClassElement);
              result.add$1(0, subclass);
            }
          }
      }
      return result;
    },
    validateInterceptorImplementsAllObjectMethods$1: function(interceptorClass) {
      var t1;
      if (interceptorClass == null)
        return;
      t1 = this.compiler;
      interceptorClass.ensureResolved$1(t1);
      t1.objectClass.forEachMember$1(new Z.JavaScriptBackend_validateInterceptorImplementsAllObjectMethods_closure(this, interceptorClass));
    },
    addInterceptorsForNativeClassMembers$2: function(cls, enqueuer) {
      var t1;
      if (enqueuer.get$isResolutionQueue()) {
        if (cls.resolutionState === 0)
          this.compiler.resolver.resolveClass$1(cls);
        cls.forEachMember$2$includeSuperAndInjectedMembers(new Z.JavaScriptBackend_addInterceptorsForNativeClassMembers_closure(this), true);
        for (t1 = this.classesMixedIntoInterceptedClasses; cls != null; cls = cls.get$superclass())
          if (cls.get$isMixinApplication())
            t1.add$1(0, cls.get$mixinType() != null ? cls.mixinType.get$element() : null);
      }
    },
    addInterceptors$3: function(cls, enqueuer, registry) {
      var t1;
      if (enqueuer.get$isResolutionQueue()) {
        t1 = this._interceptedClasses;
        t1.add$1(0, this.jsInterceptorClass);
        t1.add$1(0, cls);
        cls.ensureResolved$1(this.compiler);
        cls.forEachMember$2$includeSuperAndInjectedMembers(new Z.JavaScriptBackend_addInterceptors_closure(this), true);
      }
      this.enqueueClass$3(enqueuer, cls, registry);
    },
    registerSpecializedGetInterceptor$1: function(classes) {
      var $name, t1;
      $name = this.namer.getInterceptorName$2(this.getInterceptorMethod, classes);
      t1 = this.specializedGetInterceptors;
      if (J.contains$1$asx(classes, this.jsInterceptorClass) === true)
        t1.$indexSet(0, $name, this._interceptedClasses);
      else
        t1.$indexSet(0, $name, classes);
    },
    registerCompileTimeConstant$2: function(constant, registry) {
      var t1, t2;
      this.registerInstantiatedConstantType$2(constant.computeType$1(this.compiler), registry);
      if (constant.get$isFunction())
        registry.registerGetOfStaticFunction$1(constant.get$element());
      else if (constant.get$isInterceptor())
        this.registerInstantiatedConstantType$2(constant.get$dispatchedType(), registry);
      else if (constant.get$isType()) {
        this.enqueueInResolution$2(this.jsHelperLibrary.findLocal$1("createRuntimeType"), registry);
        registry.registerInstantiation$1(this.typeLiteralClass.get$rawType());
      }
      t1 = constant.getDependencies$0();
      t2 = new H.ListIterator(t1, t1.length, 0, null);
      t2.$builtinTypeInfo = [H.getTypeArgumentByIndex(t1, 0)];
      for (; t2.moveNext$0();)
        this.registerCompileTimeConstant$2(t2.__internal$_current, registry);
    },
    registerInstantiatedConstantType$2: function(type, registry) {
      var instantiatedType, t1, t2;
      instantiatedType = type.get$kind(type) === C.TypeKind_function ? this.compiler.functionClass.get$rawType() : type;
      if (!!type.$isInterfaceType) {
        registry.registerInstantiation$1(instantiatedType);
        if (!type.get$treatAsRaw())
          t1 = this.rti.classesNeedingRti.contains$1(0, type.get$element().get$declaration()) || this.compiler.enabledRuntimeType;
        else
          t1 = false;
        if (t1)
          registry.registerStaticInvocation$1(this.find$2(0, this.jsHelperLibrary, "setRuntimeTypeInfo"));
        t1 = type.get$element();
        t2 = this.typeLiteralClass;
        if (t1 == null ? t2 == null : t1 === t2)
          registry.registerStaticInvocation$1(this.find$2(0, this.jsHelperLibrary, "createRuntimeType"));
      }
    },
    registerMetadataConstant$3: function(constant, annotatedElement, registry) {
      this.registerCompileTimeConstant$2(constant, registry);
      this.metadataConstants.push(new Z.Dependency(constant, annotatedElement));
    },
    registerInstantiatedClass$3: function(cls, enqueuer, registry) {
      var t1, t2;
      if (cls.get$typeVariables().length !== 0) {
        t1 = this.typeVariableHandler.typeVariableClasses;
        if (t1 != null)
          t1.push(cls);
      }
      if (enqueuer.get$isResolutionQueue()) {
        t1 = this.compiler;
        if (cls === t1.intClass || cls === t1.doubleClass || cls === t1.numClass)
          this.enqueue$3(enqueuer, this.find$2(0, this.jsHelperLibrary, "iae"), registry);
        else {
          t2 = t1.listClass;
          if (cls === t2 || cls === t1.stringClass) {
            this.enqueue$3(enqueuer, this.find$2(0, this.jsHelperLibrary, "ioore"), registry);
            this.enqueue$3(enqueuer, this.find$2(0, this.jsHelperLibrary, "iae"), registry);
          } else if (cls === t1.functionClass)
            this.enqueueClass$3(enqueuer, this.closureClass, registry);
          else if (cls === t1.mapClass) {
            this.enqueueClass$3(enqueuer, t2, registry);
            this.enqueueClass$3(enqueuer, this.mapLiteralClass, registry);
            this.rti.registerRtiDependency$2(this.mapLiteralClass, cls);
          } else {
            t2 = this.boundClosureClass;
            if (cls === t2)
              this.enqueueClass$3(enqueuer, t2, registry);
            else if (O.Elements_isNativeOrExtendsNative(cls)) {
              this.enqueue$3(enqueuer, this.getNativeInterceptorMethod, registry);
              this.enqueueClass$3(enqueuer, this.jsInterceptorClass, t1.globalDependencies);
              this.enqueueClass$3(enqueuer, this.jsPlainJavaScriptObjectClass, registry);
            } else if (cls === this.mapLiteralClass) {
              t1 = new Z.JavaScriptBackend_registerInstantiatedClass_getFactory(this, cls);
              this.mapLiteralConstructor = t1.call$2("_literal", 1);
              this.mapLiteralConstructorEmpty = t1.call$2("_empty", 0);
              this.enqueueInResolution$2(this.mapLiteralConstructor, registry);
              this.enqueueInResolution$2(this.mapLiteralConstructorEmpty, registry);
            }
          }
        }
      }
      if (cls === this.closureClass)
        this.enqueue$3(enqueuer, this.find$2(0, this.jsHelperLibrary, "closureFromTearOff"), registry);
      t1 = this.compiler;
      if (cls === t1.stringClass || cls === this.jsStringClass)
        this.addInterceptors$3(this.jsStringClass, enqueuer, registry);
      else if (cls === t1.listClass || cls === this.jsArrayClass || cls === this.jsFixedArrayClass || cls === this.jsExtendableArrayClass) {
        this.addInterceptors$3(this.jsArrayClass, enqueuer, registry);
        this.addInterceptors$3(this.jsMutableArrayClass, enqueuer, registry);
        this.addInterceptors$3(this.jsFixedArrayClass, enqueuer, registry);
        this.addInterceptors$3(this.jsExtendableArrayClass, enqueuer, registry);
      } else if (cls === t1.intClass || cls === this.jsIntClass) {
        this.addInterceptors$3(this.jsIntClass, enqueuer, registry);
        this.addInterceptors$3(this.jsPositiveIntClass, enqueuer, registry);
        this.addInterceptors$3(this.jsUInt32Class, enqueuer, registry);
        this.addInterceptors$3(this.jsUInt31Class, enqueuer, registry);
        this.addInterceptors$3(this.jsNumberClass, enqueuer, registry);
      } else if (cls === t1.doubleClass || cls === this.jsDoubleClass) {
        this.addInterceptors$3(this.jsDoubleClass, enqueuer, registry);
        this.addInterceptors$3(this.jsNumberClass, enqueuer, registry);
      } else if (cls === t1.boolClass || cls === this.jsBoolClass)
        this.addInterceptors$3(this.jsBoolClass, enqueuer, registry);
      else if (cls === t1.nullClass || cls === this.jsNullClass)
        this.addInterceptors$3(this.jsNullClass, enqueuer, registry);
      else if (cls === t1.numClass || cls === this.jsNumberClass) {
        this.addInterceptors$3(this.jsIntClass, enqueuer, registry);
        this.addInterceptors$3(this.jsPositiveIntClass, enqueuer, registry);
        this.addInterceptors$3(this.jsUInt32Class, enqueuer, registry);
        this.addInterceptors$3(this.jsUInt31Class, enqueuer, registry);
        this.addInterceptors$3(this.jsDoubleClass, enqueuer, registry);
        this.addInterceptors$3(this.jsNumberClass, enqueuer, registry);
      } else {
        t1 = this.jsPlainJavaScriptObjectClass;
        if (cls === t1)
          this.addInterceptors$3(t1, enqueuer, registry);
        else {
          t1 = this.jsUnknownJavaScriptObjectClass;
          if (cls === t1)
            this.addInterceptors$3(t1, enqueuer, registry);
          else if (O.Elements_isNativeOrExtendsNative(cls))
            this.addInterceptorsForNativeClassMembers$2(cls, enqueuer);
          else if (cls === this.jsIndexingBehaviorInterface)
            this.enqueue$3(enqueuer, this.find$2(0, this.jsHelperLibrary, "isJsIndexable"), registry);
        }
      }
      this.customElementsAnalysis.registerInstantiatedClass$2(cls, enqueuer);
    },
    registerUseInterceptor$1: function(enqueuer) {
      var registry;
      if (!enqueuer.nativeEnqueuer.hasInstantiatedNativeClasses$0())
        return;
      registry = this.compiler.globalDependencies;
      this.enqueue$3(enqueuer, this.getNativeInterceptorMethod, registry);
      this.enqueueClass$3(enqueuer, this.jsPlainJavaScriptObjectClass, registry);
      this.needToInitializeIsolateAffinityTag = true;
      this.needToInitializeDispatchProperty = true;
    },
    createItemCompilationContext$0: [function() {
      return new Z.JavaScriptItemCompilationContext(P.LinkedHashSet_LinkedHashSet(null, null, null, B.HInstruction), P.LinkedHashSet_LinkedHashSet(null, null, null, B.HInstruction));
    }, "call$0", "get$createItemCompilationContext", 0, 0, 198],
    enqueueHelpers$2: function(world, registry) {
      var e;
      this.addInterceptors$3(this.jsBoolClass, world, registry);
      this.addInterceptors$3(this.jsNullClass, world, registry);
      if (this.compiler.enableTypeAssertions) {
        e = this.find$2(0, this.jsHelperLibrary, "boolConversionCheck");
        if (e != null)
          this.enqueue$3(world, e, registry);
      }
      this.registerCheckedModeHelpers$1(registry);
    },
    onResolutionComplete$0: function() {
      K.Backend.prototype.onResolutionComplete$0.call(this);
      this.computeMembersNeededForReflection$0();
      this.rti.computeClassesNeedingRti$0();
    },
    registerGetRuntimeTypeArgument$1: function(registry) {
      this.enqueueInResolution$2(this.find$2(0, this.jsHelperLibrary, "getRuntimeTypeArgument"), registry);
      this.enqueueInResolution$2(this.find$2(0, this.jsHelperLibrary, "getTypeArgumentByIndex"), registry);
      this.enqueueInResolution$2(this.find$2(0, this.jsHelperLibrary, "copyTypeArguments"), registry);
    },
    registerGenericCallMethod$3: function(callMethod, enqueuer, registry) {
      if (enqueuer.get$isResolutionQueue() || this.rti.methodsNeedingRti.contains$1(0, callMethod) || this.compiler.enabledRuntimeType)
        this.registerComputeSignature$2(enqueuer, registry);
    },
    registerGenericClosure$3: function(closure, enqueuer, registry) {
      if (enqueuer.get$isResolutionQueue() || this.rti.methodsNeedingRti.contains$1(0, closure) || this.compiler.enabledRuntimeType)
        this.registerComputeSignature$2(enqueuer, registry);
    },
    registerBoundClosure$1: function(enqueuer) {
      var t1, t2;
      t1 = this.boundClosureClass;
      t2 = this.compiler.globalDependencies;
      t1.ensureResolved$1(enqueuer.compiler);
      enqueuer.registerInstantiatedType$3$mirrorUsage(t1.get$rawType(), t2, false);
    },
    registerGetOfStaticFunction$1: function(enqueuer) {
      var t1, t2;
      t1 = this.closureClass;
      t2 = this.compiler.globalDependencies;
      t1.ensureResolved$1(enqueuer.compiler);
      enqueuer.registerInstantiatedType$3$mirrorUsage(t1.get$rawType(), t2, false);
    },
    registerComputeSignature$2: function(enqueuer, registry) {
      this.enqueue$3(enqueuer, this.find$2(0, this.jsHelperLibrary, "setRuntimeTypeInfo"), registry);
      this.enqueue$3(enqueuer, this.find$2(0, this.jsHelperLibrary, "getRuntimeTypeInfo"), registry);
      this.enqueue$3(enqueuer, this.find$2(0, this.jsHelperLibrary, "computeSignature"), registry);
      this.enqueue$3(enqueuer, this.find$2(0, this.jsHelperLibrary, "getRuntimeTypeArguments"), registry);
      this.enqueueClass$3(enqueuer, this.compiler.listClass, registry);
    },
    registerRuntimeType$2: function(enqueuer, registry) {
      this.registerComputeSignature$2(enqueuer, registry);
      this.enqueueInResolution$2(this.find$2(0, this.jsHelperLibrary, "setRuntimeTypeInfo"), registry);
      this.enqueueInResolution$2(this.find$2(0, this.jsHelperLibrary, "getRuntimeTypeInfo"), registry);
      this.registerGetRuntimeTypeArgument$1(registry);
      this.enqueueClass$3(enqueuer, this.compiler.listClass, registry);
    },
    registerIsCheckForCodegen$3: function(type, world, registry) {
      var t1, helper, backend, t2;
      t1 = this.compiler;
      type = type.unalias$1(t1);
      this.enqueueClass$3(world, t1.boolClass, registry);
      if (t1.enableTypeAssertions) {
        helper = this.getCheckedModeHelperInternal$3$nativeCheckOnly$typeCast(type, false, false);
        if (helper != null) {
          backend = t1.backend;
          t2 = helper.name;
          this.enqueue$3(world, backend.find$2(0, backend.get$jsHelperLibrary(), t2), registry);
        }
        helper = this.getCheckedModeHelperInternal$3$nativeCheckOnly$typeCast(type, true, false);
        if (helper != null) {
          backend = t1.backend;
          t2 = helper.name;
          this.enqueue$3(world, backend.find$2(0, backend.get$jsHelperLibrary(), t2), registry);
        }
      }
      if (!type.get$treatAsRaw() || type.get$typeVariableOccurrence() != null)
        this.enqueueClass$3(world, t1.listClass, registry);
      if (type.get$element() != null && type.get$element().get$isNative())
        this.enqueue$3(world, this.find$2(0, this.jsHelperLibrary, "defineProperty"), registry);
    },
    enableNoSuchMethod$2: function(context, world) {
      var t1 = this.compiler;
      this.enqueue$3(world, this.find$2(0, this.jsHelperLibrary, "createInvocationMirror"), t1.globalDependencies);
      world.registerInvocation$1(t1.noSuchMethodSelector);
    },
    enableIsolateSupport$1: function(enqueuer) {
      var t1, t2, $name, element;
      if (enqueuer.get$isResolutionQueue())
        for (t1 = H.setRuntimeTypeInfo(new H.ListIterator(C.List_MIo, 3, 0, null), [H.getTypeArgumentByIndex(C.List_MIo, 0)]), t2 = this.compiler; t1.moveNext$0();) {
          $name = t1.__internal$_current;
          element = this.isolateHelperLibrary.findLocal$1($name);
          enqueuer.internalAddToWorkList$1(element);
          t2.globalDependencies.treeElements.registerDependency$1(element);
        }
      else
        enqueuer.internalAddToWorkList$1(this.find$2(0, this.isolateHelperLibrary, "startRootIsolate"));
    },
    isAssertMethod$1: function(element) {
      return element === this.assertMethod;
    },
    registerRequiredType$2: function(type, enclosingElement) {
      var contextClass = V.Types_getClassContext(type);
      if (contextClass != null)
        this.rti.registerRtiDependency$2(type.get$element(), contextClass);
    },
    registerClassUsingVariableExpression$1: function(cls) {
      this.rti.classesUsingTypeVariableExpression.add$1(0, cls);
    },
    classNeedsRti$1: function(cls) {
      return this.rti.classesNeedingRti.contains$1(0, cls.get$declaration()) || this.compiler.enabledRuntimeType;
    },
    isDefaultNoSuchMethodImplementation$1: function(element) {
      var classElement, t1;
      classElement = element.get$enclosingClass();
      t1 = this.compiler.objectClass;
      if (classElement == null ? t1 != null : classElement !== t1) {
        t1 = this.jsInterceptorClass;
        if (classElement == null ? t1 != null : classElement !== t1) {
          t1 = this.jsNullClass;
          t1 = classElement == null ? t1 == null : classElement === t1;
        } else
          t1 = true;
      } else
        t1 = true;
      return t1;
    },
    isDefaultEqualityImplementation$1: [function(element) {
      var classElement, t1;
      classElement = element.get$enclosingClass();
      t1 = this.compiler.objectClass;
      if (classElement == null ? t1 != null : classElement !== t1) {
        t1 = this.jsInterceptorClass;
        if (classElement == null ? t1 != null : classElement !== t1) {
          t1 = this.jsNullClass;
          t1 = classElement == null ? t1 == null : classElement === t1;
        } else
          t1 = true;
      } else
        t1 = true;
      return t1;
    }, "call$1", "get$isDefaultEqualityImplementation", 2, 0, 76],
    methodNeedsRti$1: function($function) {
      return this.rti.methodsNeedingRti.contains$1(0, $function) || this.compiler.enabledRuntimeType;
    },
    registerBackendUse$1: function(element) {
      var t1;
      if (element != null) {
        t1 = this.helpersUsed;
        t1.add$1(0, element.get$declaration());
        if (element.get$kind(element) === C.ElementKind_class_4 && element.get$isPatched())
          t1.add$1(0, element.get$implementation(element));
      }
      return element;
    },
    enqueue$3: function(enqueuer, e, registry) {
      if (e == null)
        return;
      this.registerBackendUse$1(e);
      enqueuer.internalAddToWorkList$1(e);
      registry.registerDependency$1(e);
    },
    enqueueInResolution$2: function(e, registry) {
      if (e == null)
        return;
      this.enqueue$3(this.compiler.enqueuer.resolution, e, registry);
    },
    enqueueClass$3: function(enqueuer, cls, registry) {
      var t1, t2, t3;
      if (cls == null)
        return;
      this.registerBackendUse$1(cls);
      t1 = this.helpersUsed;
      t1.add$1(0, cls.get$declaration());
      t2 = cls.get$declaration();
      t3 = cls.get$implementation(cls);
      if (t2 == null ? t3 != null : t2 !== t3)
        t1.add$1(0, cls.get$implementation(cls));
      cls.ensureResolved$1(enqueuer.compiler);
      enqueuer.registerInstantiatedType$3$mirrorUsage(cls.get$rawType(), registry, false);
    },
    codegen$1: function(work) {
      var element, kind, t1, t2, initialValue, graph, code;
      element = work.element;
      kind = element.get$kind(element);
      if (kind === C.ElementKind_typedef_32)
        return;
      if (element.kind === C.ElementKind_generative_constructor_16 || element.get$isFactoryConstructor()) {
        t1 = element.get$enclosingClass();
        t2 = this.jsNullClass;
        t2 = t1 == null ? t2 == null : t1 === t2;
        t1 = t2;
      } else
        t1 = false;
      if (t1)
        return;
      if (kind.category === 1) {
        initialValue = this.constantCompilerTask.jsConstantCompiler.initialVariableValues.$index(0, element.get$declaration());
        if (initialValue != null) {
          this.registerCompileTimeConstant$2(initialValue, work.registry);
          this.constantCompilerTask.jsConstantCompiler.compiledConstants.add$1(0, initialValue);
          if (O.Elements_isStaticOrTopLevel(element))
            return;
        } else
          this.compiler.enqueuer.codegen.registerStaticUse$1(this.find$2(0, this.jsHelperLibrary, "throwCyclicInit"));
      }
      graph = this.builder.build$1(work);
      this.optimizer.optimize$2(work, graph);
      code = this.generator.generateCode$2(work, graph);
      this.compiler.enqueuer.codegen.generatedCode.$indexSet(0, element, code);
    },
    nativeResolutionEnqueuer$1: function(world) {
      var t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12;
      t1 = this.compiler;
      t2 = P.LinkedHashMap_LinkedHashMap(null, null, null, P.String, O.ClassElement);
      t3 = P.LinkedHashSet_LinkedHashSet(null, null, null, O.ClassElement);
      t4 = P.LinkedHashSet_LinkedHashSet(null, null, null, O.ClassElement);
      t5 = P.LinkedHashSet_LinkedHashSet(null, null, null, O.ClassElement);
      t6 = P.LinkedHashSet_LinkedHashSet(null, null, null, O.ClassElement);
      t7 = P.LinkedHashSet_LinkedHashSet(null, null, null, O.ClassElement);
      t8 = P.LinkedHashMap_LinkedHashMap(null, null, null, O.ClassElement, [P.Set, O.ClassElement]);
      t9 = P.LinkedHashSet_LinkedHashSet(null, null, null, null);
      t10 = H.setRuntimeTypeInfo(new P.ListQueue(null, 0, 0, 0), [null]);
      t10.ListQueue$1(null, null);
      t11 = P.LinkedHashMap_LinkedHashMap(null, null, null, Y.Node, L.NativeBehavior);
      t12 = t1.cacheStrategy.hasIncrementalSupport ? H.setRuntimeTypeInfo(new P._IdentityHashSet(0, null, null, null, null), [null]) : null;
      return new L.NativeResolutionEnqueuer(t2, t3, t4, t5, t6, t12, t7, t8, t9, t10, false, t11, world, t1, t1.enableNativeLiveTypeAnalysis, null, null, null);
    },
    nativeCodegenEnqueuer$1: function(world) {
      var t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13;
      t1 = this.compiler;
      t2 = this.emitter;
      t3 = P.LinkedHashSet_LinkedHashSet(null, null, null, O.ClassElement);
      t4 = P.LinkedHashSet_LinkedHashSet(null, null, null, O.ClassElement);
      t5 = P.LinkedHashSet_LinkedHashSet(null, null, null, O.ClassElement);
      t6 = P.LinkedHashSet_LinkedHashSet(null, null, null, O.ClassElement);
      t7 = P.LinkedHashSet_LinkedHashSet(null, null, null, O.ClassElement);
      t8 = P.LinkedHashSet_LinkedHashSet(null, null, null, O.ClassElement);
      t9 = P.LinkedHashMap_LinkedHashMap(null, null, null, O.ClassElement, [P.Set, O.ClassElement]);
      t10 = P.LinkedHashSet_LinkedHashSet(null, null, null, null);
      t11 = H.setRuntimeTypeInfo(new P.ListQueue(null, 0, 0, 0), [null]);
      t11.ListQueue$1(null, null);
      t12 = P.LinkedHashMap_LinkedHashMap(null, null, null, Y.Node, L.NativeBehavior);
      t13 = t1.cacheStrategy.hasIncrementalSupport ? H.setRuntimeTypeInfo(new P._IdentityHashSet(0, null, null, null, null), [null]) : null;
      return new L.NativeCodegenEnqueuer(t2, t3, t4, t5, t6, t7, t13, t8, t9, t10, t11, false, t12, world, t1, t1.enableNativeLiveTypeAnalysis, null, null, null);
    },
    defaultSuperclass$1: function(element) {
      return element.nativeTagInfo != null ? this.jsInterceptorClass : this.compiler.objectClass;
    },
    assembleProgram$0: function() {
      var t1, totalMethodCount, t2, mirrorCount, library, t3, t4, tag, importTag, t5, library0, t6, kind;
      this.emitter.assembleProgram$0();
      t1 = this.compiler;
      totalMethodCount = t1.enqueuer.codegen.generatedCode._collection$_length;
      t2 = this.preMirrorsMethodCount;
      if (totalMethodCount !== t2) {
        mirrorCount = totalMethodCount - t2;
        t1.reportDiagnosticInternal$4(t1.mainApp, C.MessageKind_map, P.LinkedHashMap_LinkedHashMap$_literal(["count", mirrorCount, "total", totalMethodCount, "percentage", C.JSNumber_methods.toInt$0(C.JSInt_methods.roundToDouble$0(mirrorCount / totalMethodCount * 100))], null, null), C.Diagnostic_4_hint);
        for (t2 = t1.libraryLoader.libraryCanonicalUriMap, t2 = t2.get$values(t2), t2 = H.setRuntimeTypeInfo(new H.MappedIterator(null, J.get$iterator$ax(t2._iterable), t2._f), [H.getTypeArgumentByIndex(t2, 0), H.getTypeArgumentByIndex(t2, 1)]); t2.moveNext$0();) {
          library = t2.__internal$_current;
          if (library.get$isInternalLibrary())
            continue;
          t3 = library.tagsCache;
          if (t3 == null) {
            t3 = library.tagsBuilder.toList$0(0);
            library.tagsCache = t3;
            library.tagsBuilder = null;
          }
          t4 = new H.ListIterator(t3, t3.length, 0, null);
          t4.$builtinTypeInfo = [H.getTypeArgumentByIndex(t3, 0)];
          t3 = library.tagMapping;
          for (; t4.moveNext$0();) {
            tag = t4.__internal$_current;
            importTag = tag.asImport$0();
            if (importTag == null)
              continue;
            if (!J.$eq(t3.$index(0, tag), t1.mirrorsLibrary))
              continue;
            t5 = t1.mirrorUsageAnalyzerTask;
            t5.toString;
            library0 = library.get$library();
            t6 = library0.canonicalUri;
            if (!(t6.scheme === "dart" && C.JSString_methods.startsWith$1(t6._path, "_"))) {
              t5 = t5.librariesWithUsage;
              t5 = t5 != null && t5.contains$1(0, library0);
            } else
              t5 = true;
            kind = t5 ? C.MessageKind_MUs : C.MessageKind_YZn;
            t1.withCurrentElement$2(library, new Z.JavaScriptBackend_assembleProgram_closure(this, importTag, kind));
          }
        }
      }
    },
    getDartClass$1: function(element) {
      var t1, dartClass;
      for (t1 = this.implementationClasses.get$keys(), t1 = t1.get$iterator(t1); t1.moveNext$0();) {
        dartClass = t1.get$current();
        if (element === this.implementationClasses.$index(0, dartClass))
          return dartClass;
      }
      return element;
    },
    getCheckedModeHelperInternal$3$nativeCheckOnly$typeCast: function(type, nativeCheckOnly, typeCast) {
      var $name = this.getCheckedModeHelperNameInternal$3$nativeCheckOnly$typeCast(type, nativeCheckOnly, typeCast);
      if ($name == null)
        return;
      return this.checkedModeHelperByName.$index(0, $name);
    },
    getCheckedModeHelperNameInternal$3$nativeCheckOnly$typeCast: function(type, nativeCheckOnly, typeCast) {
      var element, t1, t2;
      if (type.get$kind(type) === C.TypeKind_malformed)
        return "checkMalformedType";
      element = type.get$element();
      if (!nativeCheckOnly)
        this.emitter.nativeEmitter.requiresNativeIsCheck$1(element);
      if (type.get$kind(type) === C.TypeKind_void) {
        if (nativeCheckOnly)
          return;
        return "voidTypeCheck";
      } else {
        t1 = this.jsStringClass;
        if (element == null ? t1 != null : element !== t1) {
          t1 = this.compiler.stringClass;
          t1 = element == null ? t1 == null : element === t1;
        } else
          t1 = true;
        if (t1) {
          if (nativeCheckOnly)
            return;
          return typeCast ? "stringTypeCast" : "stringTypeCheck";
        } else {
          t1 = this.jsDoubleClass;
          if (element == null ? t1 != null : element !== t1) {
            t1 = this.compiler.doubleClass;
            t1 = element == null ? t1 == null : element === t1;
          } else
            t1 = true;
          if (t1) {
            if (nativeCheckOnly)
              return;
            return typeCast ? "doubleTypeCast" : "doubleTypeCheck";
          } else {
            t1 = this.jsNumberClass;
            if (element == null ? t1 != null : element !== t1) {
              t1 = this.compiler.numClass;
              t1 = element == null ? t1 == null : element === t1;
            } else
              t1 = true;
            if (t1) {
              if (nativeCheckOnly)
                return;
              return typeCast ? "numTypeCast" : "numTypeCheck";
            } else {
              t1 = this.jsBoolClass;
              if (element == null ? t1 != null : element !== t1) {
                t1 = this.compiler.boolClass;
                t1 = element == null ? t1 == null : element === t1;
              } else
                t1 = true;
              if (t1) {
                if (nativeCheckOnly)
                  return;
                return typeCast ? "boolTypeCast" : "boolTypeCheck";
              } else {
                t1 = this.jsIntClass;
                if (element == null ? t1 != null : element !== t1) {
                  t1 = this.compiler.intClass;
                  if (element == null ? t1 != null : element !== t1) {
                    t1 = this.jsUInt32Class;
                    if (element == null ? t1 != null : element !== t1) {
                      t1 = this.jsUInt31Class;
                      if (element == null ? t1 != null : element !== t1) {
                        t1 = this.jsPositiveIntClass;
                        t1 = element == null ? t1 == null : element === t1;
                      } else
                        t1 = true;
                    } else
                      t1 = true;
                  } else
                    t1 = true;
                } else
                  t1 = true;
                if (t1) {
                  if (nativeCheckOnly)
                    return;
                  return typeCast ? "intTypeCast" : "intTypeCheck";
                } else {
                  t1 = this.compiler;
                  if (O.Elements_isNumberOrStringSupertype(element, t1))
                    return typeCast ? "numberOrStringSuperNativeTypeCast" : "numberOrStringSuperNativeTypeCheck";
                  else if (O.Elements_isStringOnlySupertype(element, t1))
                    return typeCast ? "stringSuperNativeTypeCast" : "stringSuperNativeTypeCheck";
                  else {
                    t2 = t1.listClass;
                    if (element == null ? t2 != null : element !== t2) {
                      t2 = this.jsArrayClass;
                      t2 = element == null ? t2 == null : element === t2;
                    } else
                      t2 = true;
                    if (t2 && type.get$treatAsRaw()) {
                      if (nativeCheckOnly)
                        return;
                      return typeCast ? "listTypeCast" : "listTypeCheck";
                    } else if (O.Elements_isListSupertype(element, t1))
                      return typeCast ? "listSuperNativeTypeCast" : "listSuperNativeTypeCheck";
                    else if (type.get$kind(type) === C.TypeKind_interface && !type.get$treatAsRaw())
                      return typeCast ? "subtypeCast" : "assertSubtype";
                    else if (type.get$kind(type) === C.TypeKind_kuk)
                      return typeCast ? "subtypeOfRuntimeTypeCast" : "assertSubtypeOfRuntimeType";
                    else if (type.get$kind(type) === C.TypeKind_function)
                      return;
                    else
                      return typeCast ? "interceptedTypeCast" : "interceptedTypeCheck";
                  }
                }
              }
            }
          }
        }
      }
    },
    registerCheckedModeHelpers$1: function(registry) {
      var t1, t2, helper, backend, t3;
      for (t1 = H.setRuntimeTypeInfo(new H.ListIterator(C.List_4vz, 34, 0, null), [H.getTypeArgumentByIndex(C.List_4vz, 0)]), t2 = this.compiler; t1.moveNext$0();) {
        helper = t1.__internal$_current;
        backend = t2.backend;
        t3 = J.get$name$x(helper);
        this.enqueueInResolution$2(backend.get$jsHelperLibrary().findLocal$1(t3), registry);
      }
    },
    isNullImplementation$1: function(cls) {
      return J.$eq(cls, this.jsNullClass);
    },
    get$intImplementation: function() {
      return this.jsIntClass;
    },
    get$uint32Implementation: function() {
      return this.jsUInt32Class;
    },
    get$uint31Implementation: function() {
      return this.jsUInt31Class;
    },
    get$positiveIntImplementation: function() {
      return this.jsPositiveIntClass;
    },
    get$doubleImplementation: function() {
      return this.jsDoubleClass;
    },
    get$numImplementation: function() {
      return this.jsNumberClass;
    },
    get$stringImplementation: function() {
      return this.jsStringClass;
    },
    get$listImplementation: function() {
      return this.jsArrayClass;
    },
    get$constListImplementation: function() {
      return this.jsArrayClass;
    },
    get$fixedListImplementation: function() {
      return this.jsFixedArrayClass;
    },
    get$growableListImplementation: function() {
      return this.jsExtendableArrayClass;
    },
    get$mapImplementation: function() {
      return this.mapLiteralClass;
    },
    get$constMapImplementation: function() {
      return this.constMapLiteralClass;
    },
    get$typeImplementation: function() {
      return this.typeLiteralClass;
    },
    get$boolImplementation: function() {
      return this.jsBoolClass;
    },
    get$nullImplementation: function() {
      return this.jsNullClass;
    },
    registerStaticUse$2: function(element, enqueuer) {
      var t1, t2;
      t1 = this.disableTreeShakingMarker;
      if (element == null ? t1 == null : element === t1) {
        this.compiler.disableTypeInferenceForMirrors = true;
        this.isTreeShakingDisabled = true;
        this.typeVariableHandler.onTreeShakingDisabled$1(enqueuer);
      } else {
        t1 = this.preserveNamesMarker;
        if (element == null ? t1 == null : element === t1)
          this.mustPreserveNames = true;
        else {
          t1 = this.preserveMetadataMarker;
          if (element == null ? t1 == null : element === t1)
            this.mustRetainMetadata = true;
          else {
            t1 = this.preserveUrisMarker;
            if (element == null ? t1 == null : element === t1)
              this.mustRetainUris = true;
            else {
              t1 = this.preserveLibraryNamesMarker;
              if (element == null ? t1 == null : element === t1)
                this.mustRetainLibraryNames = true;
              else {
                t1 = this.getIsolateAffinityTagMarker;
                if (element == null ? t1 == null : element === t1)
                  this.needToInitializeIsolateAffinityTag = true;
                else if (element.get$isDeferredLoaderGetter()) {
                  t1 = this.compiler;
                  if (t1.loadLibraryFunction == null) {
                    t2 = this.find$2(0, this.jsHelperLibrary, "_loadLibraryWrapper");
                    t1.loadLibraryFunction = t2;
                    this.enqueueInResolution$2(t2, t1.globalDependencies);
                  }
                } else if (element === this.requiresPreambleMarker)
                  this.requiresPreamble = true;
              }
            }
          }
        }
      }
      t1 = this.customElementsAnalysis;
      if (!t1.fetchedTableAccessorMethod) {
        t1.fetchedTableAccessorMethod = true;
        t2 = t1.backend;
        t1.tableAccessorMethod = t2.find$2(0, t2.interceptorsLibrary, "findIndexForNativeSubclassType");
      }
      t2 = t1.tableAccessorMethod;
      if (element == null ? t2 == null : element === t2)
        (enqueuer.get$isResolutionQueue() ? t1.resolutionJoin : t1.codegenJoin).demanded = true;
    },
    registerConstSymbol$2: function($name, registry) {
      var t1 = this.symbolsUsed;
      t1.add$1(0, $name);
      if (J.getInterceptor$s($name).endsWith$1($name, "="))
        t1.add$1(0, C.JSString_methods.substring$2($name, 0, $name.length - 1));
    },
    registerNewSymbol$1: function(registry) {
    },
    shouldRetainName$1: function($name) {
      if (this.hasInsufficientMirrorsUsed)
        return this.mustPreserveNames;
      if ($name === "")
        return false;
      return this.symbolsUsed.contains$1(0, $name);
    },
    retainMetadataOf$1: [function(element) {
      var t1, t2, metadata, constant;
      t1 = this.mustRetainMetadata;
      if (t1)
        this.hasRetainedMetadata = true;
      if (t1 && this.referencedFromMirrorSystem$1(element)) {
        for (t1 = element.get$metadata(), t1.toString, t1 = H.setRuntimeTypeInfo(new E.LinkIterator(null, t1), [H.getTypeArgumentByIndex(t1, 0)]), t2 = this.compiler; t1.moveNext$0();) {
          metadata = t1._util_implementation$_current;
          metadata.ensureResolved$1(t2);
          constant = this.constantCompilerTask.jsConstantCompiler.metadataConstantMap.$index(0, metadata);
          this.constantCompilerTask.jsConstantCompiler.compiledConstants.add$1(0, constant);
        }
        return true;
      }
      return false;
    }, "call$1", "get$retainMetadataOf", 2, 0, 76],
    onLibraryCreated$1: function(library) {
      var uri = library.canonicalUri;
      if (uri.$eq(0, $.get$JavaScriptBackend_DART_JS_HELPER()))
        this.jsHelperLibrary = library;
      else if (uri.$eq(0, $.get$JavaScriptBackend_DART_INTERCEPTORS()))
        this.interceptorsLibrary = library;
      else if (uri.$eq(0, $.get$JavaScriptBackend_DART_FOREIGN_HELPER()))
        this.foreignLibrary = library;
      else if (uri.$eq(0, $.get$JavaScriptBackend_DART_ISOLATE_HELPER()))
        this.isolateHelperLibrary = library;
    },
    initializeHelperClasses$0: function() {
      var missingHelperClasses, t1;
      missingHelperClasses = [];
      t1 = new Z.JavaScriptBackend_initializeHelperClasses_lookupHelperClass(this, missingHelperClasses);
      this.jsInvocationMirrorClass = t1.call$1("JSInvocationMirror");
      this.boundClosureClass = t1.call$1("BoundClosure");
      this.closureClass = t1.call$1("Closure");
      if (missingHelperClasses.length !== 0)
        this.compiler.internalError$2(this.jsHelperLibrary, "dart:_js_helper library does not contain required classes: " + H.S(missingHelperClasses));
    },
    onLibraryScanned$2: function(library, loader) {
      return K.Backend.prototype.onLibraryScanned$2.call(this, library, loader).then$1(new Z.JavaScriptBackend_onLibraryScanned_closure(this, library));
    },
    onLibrariesLoaded$1: function(loadedLibraries) {
      var t1, t2;
      if (!loadedLibraries.containsKey$1($.get$Compiler_DART_CORE()))
        return P._Future$immediate(null, null);
      t1 = this.jsInvocationMirrorClass;
      if (t1 != null) {
        t1.ensureResolved$1(this.compiler);
        this.invokeOnMethod = this.jsInvocationMirrorClass.lookupLocalMember$1("_getCachedInvocation");
      }
      t1 = this.compiler;
      this.mapLiteralClass = t1.coreLibrary.find$1(0, "LinkedHashMap");
      t2 = P.LinkedHashMap_LinkedHashMap$_empty(O.ClassElement, O.ClassElement);
      this.implementationClasses = t2;
      t2.$indexSet(0, t1.intClass, this.jsIntClass);
      this.implementationClasses.$indexSet(0, t1.boolClass, this.jsBoolClass);
      this.implementationClasses.$indexSet(0, t1.numClass, this.jsNumberClass);
      this.implementationClasses.$indexSet(0, t1.doubleClass, this.jsDoubleClass);
      this.implementationClasses.$indexSet(0, t1.stringClass, this.jsStringClass);
      this.implementationClasses.$indexSet(0, t1.listClass, this.jsArrayClass);
      this.implementationClasses.$indexSet(0, t1.nullClass, this.jsNullClass);
      this.inlineCache.markAsNonInlinable$2$insideLoop(this.getInterceptorMethod, true);
      t2 = this.jsFixedArrayClass;
      if (t2 != null)
        t2.ensureResolved$1(t1);
      t2 = this.jsExtendableArrayClass;
      if (t2 != null)
        t2.ensureResolved$1(t1);
      this.jsIndexableClass.ensureResolved$1(t1);
      t2 = t1.lookupElementIn$2(this.jsIndexableClass, "length");
      this.jsIndexableLength = t2;
      if (t2.get$kind(t2) === C.ElementKind_abstract_field_1)
        this.jsIndexableLength = this.jsIndexableLength.get$getter();
      this.jsArrayClass.ensureResolved$1(t1);
      this.jsArrayTypedConstructor = t1.lookupElementIn$2(this.jsArrayClass, "typed");
      this.jsArrayRemoveLast = t1.lookupElementIn$2(this.jsArrayClass, "removeLast");
      this.jsArrayAdd = t1.lookupElementIn$2(this.jsArrayClass, "add");
      this.jsStringClass.ensureResolved$1(t1);
      this.jsStringSplit = t1.lookupElementIn$2(this.jsStringClass, "split");
      this.jsStringOperatorAdd = t1.lookupElementIn$2(this.jsStringClass, "+");
      this.jsStringToString = t1.lookupElementIn$2(this.jsStringClass, "toString");
      this.objectEquals = t1.lookupElementIn$2(t1.objectClass, "==");
      t2 = this.specialOperatorEqClasses;
      t2.add$1(0, t1.objectClass);
      t2.add$1(0, this.jsInterceptorClass);
      t2.add$1(0, this.jsNullClass);
      this.indexablePrimitiveType = new B.FlatTypeMask(this.jsIndexableClass, 6);
      this.readableArrayType = new B.FlatTypeMask(this.jsArrayClass, 4);
      this.mutableArrayType = new B.FlatTypeMask(this.jsMutableArrayClass, 4);
      this.fixedArrayType = new B.FlatTypeMask(this.jsFixedArrayClass, 2);
      this.extendableArrayType = new B.FlatTypeMask(this.jsExtendableArrayClass, 2);
      this.nonNullType = t1.typesTask.get$dynamicType().nonNullable$0();
      this.validateInterceptorImplementsAllObjectMethods$1(this.jsInterceptorClass);
      this.validateInterceptorImplementsAllObjectMethods$1(this.jsNullClass);
      return P._Future$immediate(null, null);
    },
    registerMirrorUsage$3: function(symbols, targets, metaTargets) {
      var t1, t2, target;
      t1 = symbols == null;
      if (t1 && targets == null && metaTargets == null) {
        this.hasInsufficientMirrorsUsed = true;
        return;
      }
      if (!t1)
        this.symbolsUsed.addAll$1(0, symbols);
      if (targets != null)
        for (t1 = H.setRuntimeTypeInfo(new P.LinkedHashSetIterator(targets, targets._modifications, null, null), [null]), t1._cell = t1._set._first, t2 = this.targetsUsed; t1.moveNext$0();) {
          target = t1._collection$_current;
          if (J.get$kind$x(target) === C.ElementKind_abstract_field_1) {
            t2.add$1(0, target.get$getter());
            t2.add$1(0, target.get$setter());
          } else
            t2.add$1(0, target);
        }
      if (metaTargets != null)
        this.metaTargetsUsed.addAll$1(0, metaTargets);
    },
    isAccessibleByReflection$1: [function(element) {
      var t1;
      if (J.get$kind$x(element) === C.ElementKind_class_4)
        element = this.getDartClass$1(element);
      t1 = J.getInterceptor(element);
      if (!!t1.$isSynthesizedCallMethodElementX)
        element = element.expression;
      else if (!!t1.$isClosureClassElement)
        element = element.methodElement;
      return J.contains$1$asx(this._membersNeededForReflection, element);
    }, "call$1", "get$isAccessibleByReflection", 2, 0, 76],
    requiredByMirrorSystem$1: function(element) {
      return this.hasInsufficientMirrorsUsed && this.isTreeShakingDisabled || this.matchesMirrorsMetaTarget$1(element) || this.targetsUsed.contains$1(0, element);
    },
    referencedFromMirrorSystem$2: [function(element, recursive) {
      var enclosing, t1;
      enclosing = recursive ? element.get$enclosingElement() : null;
      if (!this.hasInsufficientMirrorsUsed)
        if (!this.matchesMirrorsMetaTarget$1(element))
          if (!this.targetsUsed.contains$1(0, element))
            t1 = enclosing != null && this.referencedFromMirrorSystem$1(enclosing);
          else
            t1 = true;
        else
          t1 = true;
      else
        t1 = true;
      return t1;
    }, function(element) {
      return this.referencedFromMirrorSystem$2(element, true);
    }, "referencedFromMirrorSystem$1", "call$2", "call$1", "get$referencedFromMirrorSystem", 2, 2, 199, 200],
    matchesMirrorsMetaTarget$1: function(element) {
      var t1, link, t2, metadata, value;
      t1 = this.metaTargetsUsed;
      if (t1._collection$_length === 0)
        return false;
      for (link = element.get$metadata(), t2 = this.compiler; !link.get$isEmpty(link); link = link.get$tail()) {
        metadata = link.get$head(link);
        metadata.ensureResolved$1(t2);
        value = metadata.get$value(metadata);
        if (value == null)
          continue;
        if (t1.contains$1(0, value.computeType$1(t2).get$element()))
          return true;
      }
      return false;
    },
    computeMembersNeededForReflection$0: function() {
      var t1, closureMap, t2, closure, reflectableMembers, resolution, foundClosure, cls, t3, memberNames, classes, closures, lib;
      if (this._membersNeededForReflection != null)
        return;
      t1 = this.compiler;
      if (t1.mirrorsLibrary == null)
        this._membersNeededForReflection = C.List_empty;
      closureMap = P.LinkedHashMap_LinkedHashMap(null, null, null, O.ClassElement, [P.List, O.LocalFunctionElement]);
      for (t2 = t1.enqueuer.resolution.universe.allClosures, t2 = H.setRuntimeTypeInfo(new P.LinkedHashSetIterator(t2, t2._modifications, null, null), [null]), t2._cell = t2._set._first; t2.moveNext$0();) {
        closure = t2._collection$_current;
        J.add$1$ax(closureMap.putIfAbsent$2(closure.get$enclosingClass(), new Z.JavaScriptBackend_computeMembersNeededForReflection_closure()), closure);
      }
      reflectableMembers = P.LinkedHashSet_LinkedHashSet(null, null, null, O.Element);
      resolution = t1.enqueuer.resolution;
      for (t2 = resolution.universe.instantiatedClasses, t2 = H.setRuntimeTypeInfo(new P.LinkedHashSetIterator(t2, t2._modifications, null, null), [null]), t2._cell = t2._set._first, foundClosure = false; t2.moveNext$0();) {
        cls = t2._collection$_current;
        t3 = cls.get$library().canonicalUri;
        if (t3.scheme === "dart" && C.JSString_methods.startsWith$1(t3._path, "_") || cls.get$isInjected())
          continue;
        if (this.referencedFromMirrorSystem$1(cls)) {
          memberNames = P.LinkedHashSet_LinkedHashSet(null, null, null, O.Name);
          reflectableMembers.add$1(0, cls);
          cls.get$constructors().forEach$1(0, new Z.JavaScriptBackend_computeMembersNeededForReflection_closure0(reflectableMembers, resolution));
          cls.forEachClassMember$1(new Z.JavaScriptBackend_computeMembersNeededForReflection_closure1(reflectableMembers, resolution, memberNames));
          classes = t1.world._subtypes.$index(0, cls.get$declaration());
          if (classes != null && !J.get$isEmpty$asx(classes))
            for (t3 = J.get$iterator$ax(t1.world._subtypes.$index(0, cls.get$declaration())); t3.moveNext$0();)
              t3.get$current().forEachClassMember$1(new Z.JavaScriptBackend_computeMembersNeededForReflection_closure2(this, reflectableMembers, resolution, memberNames));
          closures = closureMap.$index(0, cls);
          if (closures != null) {
            reflectableMembers.addAll$1(0, closures);
            foundClosure = true;
          }
        } else {
          cls.get$constructors().forEach$1(0, new Z.JavaScriptBackend_computeMembersNeededForReflection_closure3(this, reflectableMembers));
          cls.forEachClassMember$1(new Z.JavaScriptBackend_computeMembersNeededForReflection_closure4(this, reflectableMembers));
          closures = closureMap.$index(0, cls);
          if (closures != null)
            for (t3 = J.get$iterator$ax(closures); t3.moveNext$0();) {
              closure = t3.get$current();
              if (this.referencedFromMirrorSystem$2(closure.get$memberContext(), false)) {
                reflectableMembers.add$1(0, closure);
                foundClosure = true;
              }
            }
        }
      }
      for (t2 = t1.libraryLoader.libraryCanonicalUriMap, t2 = t2.get$values(t2), t2 = H.setRuntimeTypeInfo(new H.MappedIterator(null, J.get$iterator$ax(t2._iterable), t2._f), [H.getTypeArgumentByIndex(t2, 0), H.getTypeArgumentByIndex(t2, 1)]); t2.moveNext$0();) {
        lib = t2.__internal$_current;
        if (lib.get$isInternalLibrary())
          continue;
        lib.forEachLocalMember$1(new Z.JavaScriptBackend_computeMembersNeededForReflection_closure5(this, reflectableMembers));
      }
      if (closureMap.containsKey$1(null))
        for (t2 = J.get$iterator$ax(closureMap.$index(0, null)); t2.moveNext$0();) {
          closure = t2.get$current();
          if (this.referencedFromMirrorSystem$1(closure)) {
            reflectableMembers.add$1(0, closure);
            foundClosure = true;
          }
        }
      if (foundClosure)
        reflectableMembers.add$1(0, this.closureClass);
      if (t1.enqueuer.resolution.universe.closurizedMembers.any$1(0, reflectableMembers.get$contains(reflectableMembers)))
        reflectableMembers.add$1(0, this.boundClosureClass);
      t1 = t1.world.allTypedefs;
      reflectableMembers.addAll$1(0, H.setRuntimeTypeInfo(new H.WhereIterable(t1, this.get$referencedFromMirrorSystem()), [H.getTypeArgumentByIndex(t1, 0)]));
      for (t1 = H.setRuntimeTypeInfo(new P.LinkedHashSetIterator(reflectableMembers, reflectableMembers._modifications, null, null), [null]), t1._cell = t1._set._first, t2 = this.symbolsUsed; t1.moveNext$0();)
        t2.add$1(0, J.get$name$x(t1._collection$_current));
      this._membersNeededForReflection = reflectableMembers;
    },
    generateIsJsIndexableCall$2: function(use1, use2) {
      var $arguments = H.setRuntimeTypeInfo([use1, new Q.PropertyAccess(use2, C.C_JsBuilder.call$1("init.dispatchPropertyName"), null, null)], [Q.Expression]);
      return new Q.Call(this.namer.elementAccess$1(this.find$2(0, this.jsHelperLibrary, "isJsIndexable")), $arguments, null, null);
    },
    couldBeTypedArray$1: function(mask) {
      var t1, t2;
      t1 = new Z.JavaScriptBackend_couldBeTypedArray_intersects(this);
      t2 = this.compiler.typedDataClass;
      return t2 != null && t1.call$2(mask, new B.FlatTypeMask(t2, 7)) === true && t1.call$2(mask, new B.FlatTypeMask(this.jsIndexingBehaviorInterface, 7)) === true;
    },
    _findStaticFieldTargets$0: function() {
      var staticFields, t1, t2, target, t3;
      staticFields = [];
      t1 = new Z.JavaScriptBackend__findStaticFieldTargets_addFieldsInContainer(staticFields);
      for (t2 = this.targetsUsed, t2 = H.setRuntimeTypeInfo(new P.LinkedHashSetIterator(t2, t2._modifications, null, null), [null]), t2._cell = t2._set._first; t2.moveNext$0();) {
        target = t2._collection$_current;
        if (target == null)
          continue;
        t3 = J.getInterceptor$x(target);
        if (t3.get$kind(target) === C.ElementKind_field_1)
          staticFields.push(target);
        else if (t3.get$kind(target) === C.ElementKind_library_0 || t3.get$kind(target) === C.ElementKind_class_4)
          t1.call$1(target);
      }
      return staticFields;
    },
    onQueueEmpty$2: function(enqueuer, recentClasses) {
      var t1, t2, t3, dependency;
      t1 = this.customElementsAnalysis;
      t1.toString;
      (enqueuer.get$isResolutionQueue() ? t1.resolutionJoin : t1.codegenJoin).flush$1(enqueuer);
      t1 = enqueuer.get$queue();
      if (t1._head !== t1._tail)
        return false;
      if (!enqueuer.get$isResolutionQueue() && this.preMirrorsMethodCount === 0)
        this.preMirrorsMethodCount = this.compiler.enqueuer.codegen.generatedCode._collection$_length;
      if (this.isTreeShakingDisabled)
        enqueuer.enqueueReflectiveElements$1(recentClasses);
      else if (this.targetsUsed._collection$_length !== 0 && enqueuer.get$isResolutionQueue())
        enqueuer.enqueueReflectiveStaticFields$1(this._findStaticFieldTargets$0());
      if (this.mustPreserveNames)
        this.compiler.log$1("Preserving names.");
      if (this.mustRetainMetadata) {
        t1 = this.compiler;
        t1.log$1("Retaining metadata.");
        t2 = t1.libraryLoader.libraryCanonicalUriMap;
        t2.get$values(t2).forEach$1(0, this.get$retainMetadataOf());
        if (!enqueuer.get$isResolutionQueue()) {
          for (t2 = this.metadataConstants, t3 = H.setRuntimeTypeInfo(new H.ListIterator(t2, t2.length, 0, null), [H.getTypeArgumentByIndex(t2, 0)]); t3.moveNext$0();) {
            dependency = t3.__internal$_current;
            this.registerCompileTimeConstant$2(dependency.get$constant(), new K.CodegenRegistry(t1, dependency.get$annotatedElement().get$analyzableElement().get$treeElements()));
          }
          C.JSArray_methods.set$length(t2, 0);
        }
      }
      return true;
    },
    onElementResolved$2: function(element, elements) {
      var library, t1, t2, t3, t4, t5, hasNoInline, hasNoThrows, hasNoSideEffects, metadata, value, cls, t6;
      library = element.get$library();
      if (library.canonicalUri.scheme !== "dart" && !library.canUseNative)
        return;
      for (t1 = element.get$metadata(), t1.toString, t1 = H.setRuntimeTypeInfo(new E.LinkIterator(null, t1), [H.getTypeArgumentByIndex(t1, 0)]), t2 = this.compiler, t3 = element.kind === C.ElementKind_function_2, t4 = this.inlineCache, t5 = t4.canBeInlined, t4 = t4.canBeInlinedInsideLoop, hasNoInline = false, hasNoThrows = false, hasNoSideEffects = false; t1.moveNext$0();) {
        metadata = t1._util_implementation$_current;
        metadata.ensureResolved$1(t2);
        if (!metadata.get$value(metadata).get$isConstructedObject())
          continue;
        value = metadata.value;
        cls = value.get$type(value).get$element();
        t6 = this.noInlineClass;
        if (cls == null ? t6 == null : cls === t6) {
          t5.$indexSet(0, element, false);
          t4.$indexSet(0, element, false);
          hasNoInline = true;
        } else {
          t6 = this.noThrowsClass;
          if (cls == null ? t6 == null : cls === t6) {
            if (!(O.Elements_isStaticOrTopLevel(element) && t3))
              t2.internalError$2(element, "@NoThrows() is currently limited to top-level or static functions");
            t2.world.elementsThatCannotThrow.add$1(0, element);
            hasNoThrows = true;
          } else {
            t6 = this.noSideEffectsClass;
            if (cls == null ? t6 == null : cls === t6) {
              t6 = t2.world;
              t6.sideEffects.$indexSet(0, element.get$declaration(), new Z.SideEffects(0));
              t6.sideEffectsFreeElements.add$1(0, element);
              hasNoSideEffects = true;
            }
          }
        }
      }
      if (hasNoThrows && !hasNoInline)
        t2.internalError$2(element, "@NoThrows() should always be combined with @NoInline.");
      if (hasNoSideEffects && !hasNoInline)
        t2.internalError$2(element, "@NoSideEffects() should always be combined with @NoInline.");
      if (element === this.invokeOnMethod)
        t2.enabledInvokeOn = true;
    },
    helperForBadMain$0: function() {
      return this.find$2(0, this.jsHelperLibrary, "badMain");
    },
    helperForMissingMain$0: function() {
      return this.find$2(0, this.jsHelperLibrary, "missingMain");
    },
    helperForMainArity$0: function() {
      return this.find$2(0, this.jsHelperLibrary, "mainHasTooManyParameters");
    },
    JavaScriptBackend$2: function(compiler, generateSourceMap) {
      var t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15, t16, t17, t18, t19, t20, t21, t22, t23, t24, t25, t26, t27, t28, t29, t30, t31, t32;
      t1 = this.namer;
      t2 = P.LinkedHashMap_LinkedHashMap(null, null, null, O.Element, O.Element);
      t3 = P.LinkedHashMap_LinkedHashMap$_empty(P.String, O.Element);
      t4 = H.setRuntimeTypeInfo([], [Z.Selector]);
      t5 = P.LinkedHashMap_LinkedHashMap(null, null, null, O.ClassElement, [P.Set, V.FunctionType]);
      t6 = P.LinkedHashSet_LinkedHashSet(null, null, null, V.FunctionType);
      t7 = P.LinkedHashSet_LinkedHashSet(null, null, null, O.ClassElement);
      t8 = P.LinkedHashSet_LinkedHashSet(null, null, null, P.String);
      t9 = P.LinkedHashMap_LinkedHashMap$_empty(P.String, P.$int);
      t10 = P.StringBuffer$("");
      t11 = H.setRuntimeTypeInfo([], [K.CodeBufferMarker]);
      t12 = P.LinkedHashMap_LinkedHashMap(null, null, null, B.OutputUnit, K.CodeBuffer);
      t13 = P.StringBuffer$("");
      t14 = H.setRuntimeTypeInfo([], [K.CodeBufferMarker]);
      t15 = P.LinkedHashSet_LinkedHashSet(null, null, null, O.ClassElement);
      t16 = P.LinkedHashMap_LinkedHashMap(null, null, null, B.OutputUnit, [P.List, O.ClassElement]);
      t17 = P.LinkedHashMap_LinkedHashMap(null, null, null, B.OutputUnit, [P.List, K.Constant]);
      t18 = H.setRuntimeTypeInfo([], [O.ClassElement]);
      t19 = P.LinkedHashMap_LinkedHashMap$_empty(P.String, P.String);
      t20 = P.LinkedHashMap_LinkedHashMap$_empty(P.String, P.String);
      t21 = P.LinkedHashSet_LinkedHashSet(null, null, null, P.String);
      t22 = P.LinkedHashMap_LinkedHashMap(null, null, null, O.ClassElement, [P.Map, P.String, Q.Expression]);
      t23 = P.LinkedHashSet_LinkedHashSet(null, null, null, O.TypeVariableElement);
      t24 = H.setRuntimeTypeInfo([], [Q.Node0]);
      t25 = H.setRuntimeTypeInfo([], [Q.Expression]);
      t26 = P.LinkedHashMap_LinkedHashMap(null, null, null, O.Element, [P.Map, B.OutputUnit, K.ClassBuilder]);
      t27 = new Z.ConstantEmitter(null, null);
      t27.ConstantEmitter$2(compiler, t1);
      t28 = compiler.cacheStrategy.hasIncrementalSupport;
      t29 = t28 ? H.setRuntimeTypeInfo(new P._IdentityHashSet(0, null, null, null, null), [null]) : null;
      t30 = t28 ? H.setRuntimeTypeInfo(new P._IdentityHashMap(0, null, null, null, null), [null, null]) : null;
      t28 = t28 ? H.setRuntimeTypeInfo(new P._IdentityHashSet(0, null, null, null, null), [null]) : null;
      t31 = compiler.verbose;
      if (t31) {
        t32 = new P.Stopwatch(null, null);
        H.Primitives_initTicker();
        $.Stopwatch__frequency = $.Primitives_timerFrequency;
      } else
        t32 = null;
      t32 = new K.CodeEmitterTask(new K.ContainerBuilder(t2, t3, null), new K.ClassEmitter(null), new K.NsmEmitter(t4, null), new K.TypeTestEmitter(null, null, t5, t6, t7, null, null), new K.InterceptorEmitter(t8, null), new K.MetadataEmitter([], t9, null), t29, new K.CodeBuffer(t10, t11, 0, 0), t30, t28, false, false, false, t1, t27, null, t12, new K.CodeBuffer(t13, t14, 0, 0), null, null, t15, t16, t17, t18, t19, t20, t21, t22, t23, null, null, t24, t25, false, t26, generateSourceMap, compiler, t32, null);
      t32.CodeEmitterTask$3(compiler, t1, generateSourceMap);
      this.emitter = t32;
      t1 = this.compiler;
      t2 = t1.verbose;
      if (t2) {
        t3 = new P.Stopwatch(null, null);
        H.Primitives_initTicker();
        $.Stopwatch__frequency = $.Primitives_timerFrequency;
      } else
        t3 = null;
      this.builder = new B.SsaBuilderTask(t32, this, t1, t3, null);
      t3 = P.LinkedHashMap_LinkedHashMap$_empty(B.HInstruction, B.Range);
      if (t2) {
        t4 = new P.Stopwatch(null, null);
        H.Primitives_initTicker();
        $.Stopwatch__frequency = $.Primitives_timerFrequency;
      } else
        t4 = null;
      this.optimizer = new B.SsaOptimizerTask(this, t3, t1, t4, null);
      if (t2) {
        t2 = new P.Stopwatch(null, null);
        H.Primitives_initTicker();
        $.Stopwatch__frequency = $.Primitives_timerFrequency;
      } else
        t2 = null;
      this.generator = new B.SsaCodeGeneratorTask(this, t1, t2, null);
      this.typeVariableHandler = new Z.TypeVariableHandler(this, null, null, H.setRuntimeTypeInfo([], [O.ClassElement]), P.LinkedHashMap_LinkedHashMap(null, null, null, O.ClassElement, [P.List, P.$int]), P.LinkedHashMap_LinkedHashMap(null, null, null, O.TypeVariableElement, P.$int));
      t1 = new Z.CustomElementsAnalysis(this, t1, new Z.CustomElementsAnalysisJoin(this, P.LinkedHashSet_LinkedHashSet(null, null, null, O.ClassElement), P.LinkedHashSet_LinkedHashSet(null, null, null, O.ClassElement), false, false, P.LinkedHashSet_LinkedHashSet(null, null, null, O.ClassElement)), new Z.CustomElementsAnalysisJoin(this, P.LinkedHashSet_LinkedHashSet(null, null, null, O.ClassElement), P.LinkedHashSet_LinkedHashSet(null, null, null, O.ClassElement), false, false, P.LinkedHashSet_LinkedHashSet(null, null, null, O.ClassElement)), false, null);
      t1.CustomElementsAnalysis$1(this);
      this.customElementsAnalysis = t1;
      t1 = P.LinkedHashMap_LinkedHashMap(null, null, null, O.VariableElement, K.Constant);
      t2 = P.LinkedHashSet_LinkedHashSet(null, null, null, O.VariableElement);
      t3 = P.LinkedHashSet_LinkedHashSet(null, null, null, K.Constant);
      t4 = P.LinkedHashSet_LinkedHashSet(null, null, null, O.VariableElement);
      t5 = P.LinkedHashMap_LinkedHashMap(null, null, null, Y.Node, K.Constant);
      t6 = P.LinkedHashMap_LinkedHashMap(null, null, null, O.MetadataAnnotation, K.Constant);
      t7 = P.LinkedHashMap_LinkedHashMap(null, null, null, O.VariableElement, K.Constant);
      t8 = P.LinkedHashSet_LinkedHashSet(null, null, null, O.VariableElement);
      if (t31) {
        t9 = new P.Stopwatch(null, null);
        H.Primitives_initTicker();
        $.Stopwatch__frequency = $.Primitives_timerFrequency;
      } else
        t9 = null;
      this.constantCompilerTask = new Z.JavaScriptConstantTask(new K.DartConstantCompiler(compiler, C.DartConstantSystem_CJj, t1, t2), new Z.JavaScriptConstantCompiler(t3, t4, t5, t6, compiler, C.JavaScriptConstantSystem_2Vk, t7, t8), compiler, t9, null);
      this.resolutionCallbacks = new Z.JavaScriptionResolutionCallbacks(this);
    },
    $isJavaScriptBackend: true,
    static: {"^": "JavaScriptBackend_DART_JS_HELPER,JavaScriptBackend_DART_INTERCEPTORS,JavaScriptBackend_DART_FOREIGN_HELPER,JavaScriptBackend_DART_JS_MIRRORS,JavaScriptBackend_DART_JS_NAMES,JavaScriptBackend_DART_ISOLATE_HELPER,JavaScriptBackend_DART_HTML,JavaScriptBackend_INVOKE_ON,JavaScriptBackend_START_ROOT_ISOLATE,JavaScriptBackend_TRACE_CALLS,JavaScriptBackend_checkedModeHelpers"}
  },
  closure: {
    "^": "Closure:13;",
    call$1: function(helper) {
      return J.get$name$x(helper);
    },
    $isFunction: true
  },
  JavaScriptBackend_isInterceptedMixinSelector_closure: {
    "^": "Closure:23;this_0,selector_1",
    call$0: function() {
      var t1, elements, t2;
      t1 = this.this_0;
      elements = t1.interceptedElements.$index(0, this.selector_1.name);
      if (elements == null)
        return;
      t1 = J.where$1$ax(elements, new Z.JavaScriptBackend_isInterceptedMixinSelector__closure(t1));
      t2 = P.LinkedHashSet_LinkedHashSet(null, null, null, H.getRuntimeTypeArgument(t1, "IterableBase", 0));
      t2.addAll$1(0, t1);
      return t2;
    },
    $isFunction: true
  },
  JavaScriptBackend_isInterceptedMixinSelector__closure: {
    "^": "Closure:13;this_2",
    call$1: function(element) {
      return this.this_2.classesMixedIntoInterceptedClasses.contains$1(0, element.get$enclosingClass());
    },
    $isFunction: true
  },
  JavaScriptBackend_isInterceptedMixinSelector_closure0: {
    "^": "Closure:13;this_3,selector_4",
    call$1: function(element) {
      return this.selector_4.applies$2(element, this.this_3.compiler);
    },
    $isFunction: true
  },
  JavaScriptBackend_getInterceptedClassesOn_closure: {
    "^": "Closure:23;this_0,intercepted_1",
    call$0: function() {
      var result, t1, t2, t3, t4, classElement, nativeSubclasses;
      result = P.LinkedHashSet_LinkedHashSet(null, null, null, O.ClassElement);
      for (t1 = this.intercepted_1, t1 = t1.get$iterator(t1), t2 = this.this_0, t3 = t2.classesMixedIntoInterceptedClasses, t4 = t2._interceptedClasses; t1.moveNext$0();) {
        classElement = t1.get$current().get$enclosingClass();
        if (O.Elements_isNativeOrExtendsNative(classElement) || t4.contains$1(0, classElement))
          result.add$1(0, classElement);
        if (t3.contains$1(0, classElement)) {
          nativeSubclasses = t2.nativeSubclassesOfMixin$1(classElement);
          if (nativeSubclasses != null)
            result.addAll$1(0, nativeSubclasses);
        }
      }
      return result;
    },
    $isFunction: true
  },
  JavaScriptBackend_validateInterceptorImplementsAllObjectMethods_closure: {
    "^": "Closure:48;this_0,interceptorClass_1",
    call$2: function(_, member) {
      var t1 = J.getInterceptor$x(member);
      if (t1.get$kind(member) === C.ElementKind_generative_constructor_16)
        return;
      this.interceptorClass_1.lookupMember$1(t1.get$name(member));
    },
    $isFunction: true
  },
  JavaScriptBackend_addInterceptorsForNativeClassMembers_closure: {
    "^": "Closure:74;this_0",
    call$2: function(classElement, member) {
      var t1, t2, t3;
      t1 = J.getInterceptor$x(member);
      if (t1.get$name(member) === "call") {
        this.this_0.compiler.reportDiagnosticInternal$4(member, C.MessageKind_iGN, C.Map_empty, C.Diagnostic_1_error);
        return;
      }
      if (member.get$isSynthesized())
        return;
      t2 = this.this_0;
      t3 = t2.compiler.objectClass;
      if (classElement == null ? t3 == null : classElement === t3)
        return;
      J.add$1$ax(t2.interceptedElements.putIfAbsent$2(t1.get$name(member), new Z.JavaScriptBackend_addInterceptorsForNativeClassMembers__closure()), member);
    },
    $isFunction: true
  },
  JavaScriptBackend_addInterceptorsForNativeClassMembers__closure: {
    "^": "Closure:23;",
    call$0: function() {
      return P.LinkedHashSet_LinkedHashSet(null, null, null, O.Element);
    },
    $isFunction: true
  },
  JavaScriptBackend_addInterceptors_closure: {
    "^": "Closure:74;this_0",
    call$2: function(classElement, member) {
      var t1, t2;
      t1 = this.this_0;
      t2 = t1.compiler.objectClass;
      if (classElement == null ? t2 == null : classElement === t2)
        return;
      J.add$1$ax(t1.interceptedElements.putIfAbsent$2(J.get$name$x(member), new Z.JavaScriptBackend_addInterceptors__closure()), member);
    },
    $isFunction: true
  },
  JavaScriptBackend_addInterceptors__closure: {
    "^": "Closure:23;",
    call$0: function() {
      return P.LinkedHashSet_LinkedHashSet(null, null, null, O.Element);
    },
    $isFunction: true
  },
  JavaScriptBackend_registerInstantiatedClass_getFactory: {
    "^": "Closure:201;this_0,cls_1",
    call$2: function($name, arity) {
      var implementation, t1;
      implementation = this.cls_1;
      if (implementation.get$patch() != null)
        implementation = implementation.get$patch();
      t1 = this.this_0;
      return implementation.lookupConstructor$2(Z.Selector_Selector(C.SelectorKind_call_2, $name, t1.mapLiteralClass.get$library(), arity, null), new Z.JavaScriptBackend_registerInstantiatedClass_getFactory_closure(t1, $name));
    },
    $isFunction: true
  },
  JavaScriptBackend_registerInstantiatedClass_getFactory_closure: {
    "^": "Closure:13;this_2,name_3",
    call$1: function(element) {
      var t1, t2;
      t1 = this.this_2;
      t2 = t1.mapLiteralClass;
      t1.compiler.internalError$2(t2, "Map literal class " + J.toString$0(t2) + " missing '" + this.name_3 + "' constructor  " + t1.mapLiteralClass.get$constructors().toString$0(0));
    },
    $isFunction: true
  },
  JavaScriptBackend_assembleProgram_closure: {
    "^": "Closure:23;this_0,importTag_1,kind_2",
    call$0: function() {
      this.this_0.compiler.reportDiagnosticInternal$4(this.importTag_1, this.kind_2, C.Map_empty, C.Diagnostic_8_info);
    },
    $isFunction: true
  },
  JavaScriptBackend_initializeHelperClasses_lookupHelperClass: {
    "^": "Closure:80;this_0,missingHelperClasses_1",
    call$1: function($name) {
      var t1, result;
      t1 = this.this_0;
      result = t1.find$2(0, t1.jsHelperLibrary, $name);
      if (result == null)
        this.missingHelperClasses_1.push($name);
      return result;
    },
    $isFunction: true
  },
  JavaScriptBackend_onLibraryScanned_closure: {
    "^": "Closure:13;this_0,library_1",
    call$1: function(_) {
      var t1, uri, t2, t3, t4, t5;
      t1 = this.library_1;
      uri = t1.canonicalUri;
      t2 = this.this_0;
      t3 = new Z.JavaScriptBackend_onLibraryScanned__findVariable(t2, t1);
      t4 = new Z.JavaScriptBackend_onLibraryScanned__findMethod(t2, t1);
      t5 = new Z.JavaScriptBackend_onLibraryScanned__findClass(t2, t1);
      if (uri.$eq(0, $.get$JavaScriptBackend_DART_INTERCEPTORS())) {
        t2.getInterceptorMethod = t4.call$1("getInterceptor");
        t2.interceptedNames = t3.call$1("interceptedNames");
        t2.mapTypeToInterceptor = t3.call$1("mapTypeToInterceptor");
        t2.getNativeInterceptorMethod = t4.call$1("getNativeInterceptor");
        t2.jsInterceptorClass = t5.call$1("Interceptor");
        t2.jsStringClass = t5.call$1("JSString");
        t2.jsArrayClass = t5.call$1("JSArray");
        t2.jsIntClass = t5.call$1("JSInt");
        t2.jsPositiveIntClass = t5.call$1("JSPositiveInt");
        t2.jsUInt32Class = t5.call$1("JSUInt32");
        t2.jsUInt31Class = t5.call$1("JSUInt31");
        t2.jsDoubleClass = t5.call$1("JSDouble");
        t2.jsNumberClass = t5.call$1("JSNumber");
        t2.jsNullClass = t5.call$1("JSNull");
        t2.jsBoolClass = t5.call$1("JSBool");
        t2.jsMutableArrayClass = t5.call$1("JSMutableArray");
        t2.jsFixedArrayClass = t5.call$1("JSFixedArray");
        t2.jsExtendableArrayClass = t5.call$1("JSExtendableArray");
        t2.jsPlainJavaScriptObjectClass = t5.call$1("PlainJavaScriptObject");
        t2.jsUnknownJavaScriptObjectClass = t5.call$1("UnknownJavaScriptObject");
        t2.jsIndexableClass = t5.call$1("JSIndexable");
        t2.jsMutableIndexableClass = t5.call$1("JSMutableIndexable");
      } else if (uri.$eq(0, $.get$JavaScriptBackend_DART_JS_HELPER())) {
        t2.initializeHelperClasses$0();
        t2.assertMethod = t2.find$2(0, t2.jsHelperLibrary, "assertHelper");
        t2.typeLiteralClass = t5.call$1("TypeImpl");
        t2.constMapLiteralClass = t5.call$1("ConstantMap");
        t2.typeVariableClass = t5.call$1("TypeVariable");
        t2.jsIndexingBehaviorInterface = t5.call$1("JavaScriptIndexingBehavior");
        t2.noSideEffectsClass = t5.call$1("NoSideEffects");
        t2.noThrowsClass = t5.call$1("NoThrows");
        t2.noInlineClass = t5.call$1("NoInline");
        t2.irRepresentationClass = t5.call$1("IrRepresentation");
        t2.getIsolateAffinityTagMarker = t4.call$1("getIsolateAffinityTag");
        t2.requiresPreambleMarker = t4.call$1("requiresPreamble");
      } else if (uri.$eq(0, $.get$JavaScriptBackend_DART_JS_MIRRORS())) {
        t2.disableTreeShakingMarker = t2.find$2(0, t1, "disableTreeShaking");
        t2.preserveMetadataMarker = t2.find$2(0, t1, "preserveMetadata");
        t2.preserveUrisMarker = t2.find$2(0, t1, "preserveUris");
        t2.preserveLibraryNamesMarker = t2.find$2(0, t1, "preserveLibraryNames");
      } else if (uri.$eq(0, $.get$JavaScriptBackend_DART_JS_NAMES()))
        t2.preserveNamesMarker = t2.find$2(0, t1, "preserveNames");
      else if (uri.$eq(0, $.get$JavaScriptBackend_DART_HTML()))
        t2.htmlLibraryIsLoaded = true;
    },
    $isFunction: true
  },
  JavaScriptBackend_onLibraryScanned__findVariable: {
    "^": "Closure:202;this_2,library_3",
    call$1: function($name) {
      return this.this_2.find$2(0, this.library_3, $name);
    },
    $isFunction: true
  },
  JavaScriptBackend_onLibraryScanned__findMethod: {
    "^": "Closure:203;this_4,library_5",
    call$1: function($name) {
      return this.this_4.find$2(0, this.library_5, $name);
    },
    $isFunction: true
  },
  JavaScriptBackend_onLibraryScanned__findClass: {
    "^": "Closure:80;this_6,library_7",
    call$1: function($name) {
      return this.this_6.find$2(0, this.library_7, $name);
    },
    $isFunction: true
  },
  JavaScriptBackend_computeMembersNeededForReflection_closure: {
    "^": "Closure:23;",
    call$0: function() {
      return [];
    },
    $isFunction: true
  },
  JavaScriptBackend_computeMembersNeededForReflection_closure0: {
    "^": "Closure:77;reflectableMembers_0,resolution_1",
    call$1: function($constructor) {
      if (this.resolution_1.isLive$1($constructor))
        this.reflectableMembers_0.add$1(0, $constructor);
    },
    $isFunction: true
  },
  JavaScriptBackend_computeMembersNeededForReflection_closure1: {
    "^": "Closure:86;reflectableMembers_2,resolution_3,memberNames_4",
    call$1: function(member) {
      if (this.resolution_3.isLive$1(member.get$element())) {
        this.memberNames_4.add$1(0, J.get$name$x(member));
        this.reflectableMembers_2.add$1(0, member.get$element());
      }
    },
    $isFunction: true
  },
  JavaScriptBackend_computeMembersNeededForReflection_closure2: {
    "^": "Closure:86;this_5,reflectableMembers_6,resolution_7,memberNames_8",
    call$1: function(member) {
      if (this.memberNames_8.contains$1(0, J.get$name$x(member)))
        this.reflectableMembers_6.add$1(0, member.get$element());
    },
    $isFunction: true
  },
  JavaScriptBackend_computeMembersNeededForReflection_closure3: {
    "^": "Closure:204;this_9,reflectableMembers_10",
    call$1: function(element) {
      var t1 = this.this_9;
      if (!t1.compiler.enqueuer.resolution.isLive$1(element))
        return;
      if (t1.referencedFromMirrorSystem$2(element, false))
        this.reflectableMembers_10.add$1(0, element);
    },
    $isFunction: true
  },
  JavaScriptBackend_computeMembersNeededForReflection_closure4: {
    "^": "Closure:86;this_11,reflectableMembers_12",
    call$1: function(member) {
      var t1 = this.this_11;
      if (!t1.compiler.enqueuer.resolution.isLive$1(member.get$element()))
        return;
      if (t1.referencedFromMirrorSystem$2(member.get$element(), false))
        this.reflectableMembers_12.add$1(0, member.get$element());
    },
    $isFunction: true
  },
  JavaScriptBackend_computeMembersNeededForReflection_closure5: {
    "^": "Closure:77;this_13,reflectableMembers_14",
    call$1: function(member) {
      var t1;
      if (J.get$kind$x(member) !== C.ElementKind_class_4) {
        t1 = this.this_13;
        t1 = t1.compiler.enqueuer.resolution.isLive$1(member) && t1.referencedFromMirrorSystem$1(member);
      } else
        t1 = false;
      if (t1)
        this.reflectableMembers_14.add$1(0, member);
    },
    $isFunction: true
  },
  JavaScriptBackend_couldBeTypedArray_intersects: {
    "^": "Closure:205;this_0",
    call$2: function(type1, type2) {
      var t1 = type1.intersection$2(0, type2, this.this_0.compiler);
      return !t1.get$isEmpty(t1);
    },
    $isFunction: true
  },
  JavaScriptBackend__findStaticFieldTargets_addFieldsInContainer: {
    "^": "Closure:206;staticFields_0",
    call$1: function(container) {
      container.forEachLocalMember$1(new Z.JavaScriptBackend__findStaticFieldTargets_addFieldsInContainer_closure(this.staticFields_0, this));
    },
    $isFunction: true
  },
  JavaScriptBackend__findStaticFieldTargets_addFieldsInContainer_closure: {
    "^": "Closure:77;staticFields_1,addFieldsInContainer_2",
    call$1: function(member) {
      if (!member.get$isInstanceMember() && member.kind === C.ElementKind_field_1)
        this.staticFields_1.push(member);
      else if (member.kind === C.ElementKind_class_4)
        this.addFieldsInContainer_2.call$1(member);
    },
    $isFunction: true
  },
  JavaScriptionResolutionCallbacks: {
    "^": "ResolutionCallbacks;backend<",
    registerBackendInstantiation$2: function(element, registry) {
      var t1 = this.backend;
      t1.registerBackendUse$1(element);
      element.ensureResolved$1(t1.compiler);
      t1 = element.get$rawType();
      registry.compiler.enqueuer.resolution.registerInstantiatedType$2(t1, registry);
    },
    onAssert$2: function(node, registry) {
      var t1 = this.backend;
      registry.registerStaticInvocation$1(t1.registerBackendUse$1(t1.assertMethod));
    },
    onStringInterpolation$1: function(registry) {
      var t1 = this.backend;
      registry.registerStaticInvocation$1(t1.registerBackendUse$1(t1.find$2(0, t1.jsHelperLibrary, "S")));
    },
    onCatchStatement$1: function(registry) {
      var t1 = this.backend;
      registry.registerStaticInvocation$1(t1.registerBackendUse$1(t1.find$2(0, t1.jsHelperLibrary, "unwrapException")));
      this.registerBackendInstantiation$2(t1.jsPlainJavaScriptObjectClass, registry);
      this.registerBackendInstantiation$2(t1.jsUnknownJavaScriptObjectClass, registry);
    },
    onThrowExpression$1: function(registry) {
      var t1 = this.backend;
      registry.registerStaticInvocation$1(t1.registerBackendUse$1(t1.find$2(0, t1.jsHelperLibrary, "wrapException")));
      registry.registerStaticInvocation$1(t1.registerBackendUse$1(t1.find$2(0, t1.jsHelperLibrary, "throwExpression")));
    },
    onLazyField$1: function(registry) {
      var t1 = this.backend;
      registry.registerStaticInvocation$1(t1.registerBackendUse$1(t1.find$2(0, t1.jsHelperLibrary, "throwCyclicInit")));
    },
    onTypeLiteral$2: function(type, registry) {
      var t1 = this.backend;
      this.registerBackendInstantiation$2(t1.typeLiteralClass, registry);
      registry.registerStaticInvocation$1(t1.registerBackendUse$1(t1.find$2(0, t1.jsHelperLibrary, "createRuntimeType")));
      if (type.get$kind(type) === C.TypeKind_typedef)
        t1.compiler.world.allTypedefs.add$1(0, type.get$element());
      t1.customElementsAnalysis.registerTypeLiteral$2(type, registry);
    },
    onStackTraceInCatch$1: function(registry) {
      var t1 = this.backend;
      registry.registerStaticInvocation$1(t1.registerBackendUse$1(t1.find$2(0, t1.jsHelperLibrary, "getTraceFromException")));
    },
    onTypeVariableExpression$1: function(registry) {
      var t1 = this.backend;
      registry.registerStaticInvocation$1(t1.registerBackendUse$1(t1.find$2(0, t1.jsHelperLibrary, "setRuntimeTypeInfo")));
      registry.registerStaticInvocation$1(t1.registerBackendUse$1(t1.find$2(0, t1.jsHelperLibrary, "getRuntimeTypeInfo")));
      t1.registerGetRuntimeTypeArgument$1(registry);
      this.registerBackendInstantiation$2(t1.compiler.listClass, registry);
      registry.registerStaticInvocation$1(t1.registerBackendUse$1(t1.find$2(0, t1.jsHelperLibrary, "runtimeTypeToString")));
      registry.registerStaticInvocation$1(t1.registerBackendUse$1(t1.find$2(0, t1.jsHelperLibrary, "createRuntimeType")));
    },
    onIsCheck$2: function(type, registry) {
      var t1, t2, inCheckedMode;
      t1 = this.backend;
      t2 = t1.compiler;
      type = type.unalias$1(t2);
      this.registerBackendInstantiation$2(t2.boolClass, registry);
      inCheckedMode = t2.enableTypeAssertions;
      if (inCheckedMode)
        registry.registerStaticInvocation$1(t1.registerBackendUse$1(t1.find$2(0, t1.jsHelperLibrary, "throwRuntimeError")));
      if (type.get$kind(type) === C.TypeKind_malformed)
        registry.registerStaticInvocation$1(t1.registerBackendUse$1(t1.find$2(0, t1.jsHelperLibrary, "throwTypeError")));
      if (!type.get$treatAsRaw() || type.get$typeVariableOccurrence() != null) {
        registry.registerStaticInvocation$1(t1.registerBackendUse$1(t1.find$2(0, t1.jsHelperLibrary, "setRuntimeTypeInfo")));
        registry.registerStaticInvocation$1(t1.registerBackendUse$1(t1.find$2(0, t1.jsHelperLibrary, "getRuntimeTypeInfo")));
        t1.registerGetRuntimeTypeArgument$1(registry);
        if (inCheckedMode)
          registry.registerStaticInvocation$1(t1.registerBackendUse$1(t1.find$2(0, t1.jsHelperLibrary, "assertSubtype")));
        registry.registerStaticInvocation$1(t1.registerBackendUse$1(t1.find$2(0, t1.jsHelperLibrary, "checkSubtype")));
        if (type.get$kind(type) === C.TypeKind_kuk) {
          registry.registerStaticInvocation$1(t1.registerBackendUse$1(t1.find$2(0, t1.jsHelperLibrary, "checkSubtypeOfRuntimeType")));
          if (inCheckedMode)
            registry.registerStaticInvocation$1(t1.registerBackendUse$1(t1.find$2(0, t1.jsHelperLibrary, "assertSubtypeOfRuntimeType")));
        }
        this.registerBackendInstantiation$2(t2.listClass, registry);
      }
      if (!!type.$isFunctionType)
        registry.registerStaticInvocation$1(t1.registerBackendUse$1(t1.find$2(0, t1.jsHelperLibrary, "functionTypeTestMetaHelper")));
      if (type.get$element() != null && type.get$element().get$isNative())
        registry.registerStaticInvocation$1(t1.registerBackendUse$1(t1.find$2(0, t1.jsHelperLibrary, "defineProperty")));
    },
    onTypeVariableBoundCheck$1: function(registry) {
      var t1 = this.backend;
      registry.registerStaticInvocation$1(t1.registerBackendUse$1(t1.find$2(0, t1.jsHelperLibrary, "throwTypeError")));
      registry.registerStaticInvocation$1(t1.registerBackendUse$1(t1.find$2(0, t1.jsHelperLibrary, "assertIsSubtype")));
    },
    onAbstractClassInstantiation$1: function(registry) {
      var t1 = this.backend;
      registry.registerStaticInvocation$1(t1.registerBackendUse$1(t1.find$2(0, t1.jsHelperLibrary, "throwAbstractClassInstantiationError")));
      this.registerBackendInstantiation$2(t1.compiler.stringClass, registry);
    },
    onFallThroughError$1: function(registry) {
      var t1 = this.backend;
      registry.registerStaticInvocation$1(t1.registerBackendUse$1(t1.find$2(0, t1.jsHelperLibrary, "getFallThroughError")));
    },
    onAsCheck$2: function(type, registry) {
      var t1 = this.backend;
      registry.registerStaticInvocation$1(t1.registerBackendUse$1(t1.find$2(0, t1.jsHelperLibrary, "throwRuntimeError")));
    },
    onThrowNoSuchMethod$1: function(registry) {
      var t1 = this.backend;
      registry.registerStaticInvocation$1(t1.registerBackendUse$1(t1.find$2(0, t1.jsHelperLibrary, "throwNoSuchMethod")));
      t1 = t1.compiler;
      this.registerBackendInstantiation$2(t1.listClass, registry);
      this.registerBackendInstantiation$2(t1.stringClass, registry);
    },
    onThrowRuntimeError$1: function(registry) {
      var t1 = this.backend;
      registry.registerStaticInvocation$1(t1.registerBackendUse$1(t1.find$2(0, t1.jsHelperLibrary, "throwRuntimeError")));
      this.registerBackendInstantiation$2(t1.compiler.stringClass, registry);
    },
    onSuperNoSuchMethod$1: function(registry) {
      var t1, t2;
      t1 = this.backend;
      registry.registerStaticInvocation$1(t1.registerBackendUse$1(t1.find$2(0, t1.jsHelperLibrary, "createInvocationMirror")));
      t2 = t1.compiler;
      registry.registerStaticInvocation$1(t1.registerBackendUse$1(t2.objectClass.lookupLocalMember$1("noSuchMethod")));
      this.registerBackendInstantiation$2(t2.listClass, registry);
    },
    onConstantMap$1: function(registry) {
      var t1 = new Z.JavaScriptionResolutionCallbacks_onConstantMap_enqueue(this, registry);
      t1.call$1("ConstantMap");
      t1.call$1("ConstantProtoMap");
      t1.call$1("ConstantStringMap");
      t1.call$1("GeneralConstantMap");
    },
    onSymbolConstructor$1: function(registry) {
      var t1 = this.backend;
      registry.registerStaticInvocation$1(t1.registerBackendUse$1(t1.compiler.symbolValidatedConstructor));
    }
  },
  JavaScriptionResolutionCallbacks_onConstantMap_enqueue: {
    "^": "Closure:66;this_0,registry_1",
    call$1: function($name) {
      var t1, t2;
      t1 = this.this_0;
      t2 = t1.backend;
      t1.registerBackendInstantiation$2(t2.find$2(0, t2.jsHelperLibrary, $name), this.registry_1);
    },
    $isFunction: true
  },
  Dependency: {
    "^": "Object;constant<,annotatedElement<"
  },
  CheckedModeHelper: {
    "^": "Object;name>",
    generateAdditionalArguments$3: function(codegen, node, $arguments) {
    },
    static: {"^": "CheckedModeHelper_helpers"}
  },
  MalformedCheckedModeHelper: {
    "^": "CheckedModeHelper;name",
    generateAdditionalArguments$3: function(codegen, node, $arguments) {
      var element = node.typeExpression.get$element();
      $arguments.push(C.C_JsBuilder.escapedString$1(K.Message$(element.get$messageKind(), element.get$messageArguments(), false).computeMessage$0()));
    }
  },
  PropertyCheckedModeHelper: {
    "^": "CheckedModeHelper;name",
    generateAdditionalArguments$3: function(codegen, node, $arguments) {
      $arguments.push(new Q.LiteralString0("\"" + codegen.backend.namer.operatorIsType$1(node.typeExpression) + "\"", null, null));
    }
  },
  TypeVariableCheckedModeHelper: {
    "^": "CheckedModeHelper;name",
    generateAdditionalArguments$3: function(codegen, node, $arguments) {
      var t1 = node.inputs;
      if (1 >= t1.length)
        return H.ioore(t1, 1);
      codegen.use$1(t1[1]);
      t1 = codegen.expressionStack;
      if (0 >= t1.length)
        return H.ioore(t1, 0);
      $arguments.push(t1.pop());
    }
  },
  SubtypeCheckedModeHelper: {
    "^": "CheckedModeHelper;name",
    generateAdditionalArguments$3: function(codegen, node, $arguments) {
      var element, t1, t2;
      element = node.typeExpression.get$element();
      t1 = codegen.backend.namer;
      $arguments.push(new Q.LiteralString0("\"" + ("$is" + H.S(t1.getRuntimeTypeName$1(element))) + "\"", null, null));
      t2 = node.inputs;
      if (1 >= t2.length)
        return H.ioore(t2, 1);
      codegen.use$1(t2[1]);
      t2 = codegen.expressionStack;
      if (0 >= t2.length)
        return H.ioore(t2, 0);
      $arguments.push(t2.pop());
      $arguments.push(new Q.LiteralString0("\"" + ("$as" + H.S(t1.getNameX$1(element))) + "\"", null, null));
    }
  },
  ConstantEmitter: {
    "^": "Object;_referenceEmitter,_literalEmitter",
    ConstantEmitter$2: function(compiler, namer) {
      this._literalEmitter = new Z.ConstantLiteralEmitter(compiler, namer, this);
      this._referenceEmitter = new Z.ConstantReferenceEmitter(compiler, namer, this);
    }
  },
  ConstantReferenceEmitter: {
    "^": "Object;compiler<,namer,constantEmitter",
    emitCanonicalVersion$1: function(constant) {
      return new Q.PropertyAccess(new Q.VariableUse("C", null, null), new Q.LiteralString0("\"" + H.S(this.namer.constantName$1(constant)) + "\"", null, null), null, null);
    },
    visitFunction$1: function(constant) {
      var t1, t2;
      t1 = this.namer;
      t2 = constant.element;
      return C.C_JsBuilder.call$2("#.#()", [t1.globalObjectFor$1(t2), t1.getStaticClosureName$1(t2)]);
    },
    visitNull$1: function(constant) {
      var t1 = this.constantEmitter._literalEmitter;
      t1.toString;
      return constant.accept$1(0, t1);
    },
    visitInt$1: function(constant) {
      var t1 = this.constantEmitter._literalEmitter;
      t1.toString;
      return constant.accept$1(0, t1);
    },
    visitDouble$1: function(constant) {
      var t1 = this.constantEmitter._literalEmitter;
      t1.toString;
      return constant.accept$1(0, t1);
    },
    visitTrue$1: function(constant) {
      var t1 = this.constantEmitter._literalEmitter;
      t1.toString;
      return constant.accept$1(0, t1);
    },
    visitFalse$1: function(constant) {
      var t1 = this.constantEmitter._literalEmitter;
      t1.toString;
      return constant.accept$1(0, t1);
    },
    visitString$1: function(constant) {
      var t1 = this.constantEmitter._literalEmitter;
      t1.toString;
      return constant.accept$1(0, t1);
    },
    visitList$1: function(constant) {
      return this.emitCanonicalVersion$1(constant);
    },
    visitMap$1: function(constant) {
      return this.emitCanonicalVersion$1(constant);
    },
    visitType$1: function(constant) {
      return this.emitCanonicalVersion$1(constant);
    },
    visitConstructed$1: function(constant) {
      return this.emitCanonicalVersion$1(constant);
    },
    visitInterceptor$1: function(constant) {
      return this.emitCanonicalVersion$1(constant);
    },
    visitDummy$1: function(constant) {
      var t1 = this.constantEmitter._literalEmitter;
      t1.toString;
      return constant.accept$1(0, t1);
    },
    visitDeferred$1: function(constant) {
      return this.emitCanonicalVersion$1(constant);
    }
  },
  ConstantLiteralEmitter: {
    "^": "Object;compiler<,namer,constantEmitter",
    visitFunction$1: function(constant) {
      this.compiler.internalError$2(C._SpannableSentinel_fBD, "The function constant does not need specific JS code.");
    },
    visitNull$1: function(constant) {
      return new Q.LiteralNull(null, null);
    },
    visitInt$1: function(constant) {
      return new Q.LiteralNumber(H.S(constant.value), null, null);
    },
    visitDouble$1: function(constant) {
      var value = constant.value;
      if (isNaN(value))
        return C.C_JsBuilder.call$1("0/0");
      else if (value === 1 / 0)
        return C.C_JsBuilder.call$1("1/0");
      else if (value === -1 / 0)
        return C.C_JsBuilder.call$1("-1/0");
      else
        return new Q.LiteralNumber(H.S(value), null, null);
    },
    visitTrue$1: function(constant) {
      if (this.compiler.enableMinification)
        return C.C_JsBuilder.call$1("!0");
      else
        return C.C_JsBuilder.call$1("true");
    },
    visitFalse$1: function(constant) {
      if (this.compiler.enableMinification)
        return C.C_JsBuilder.call$1("!1");
      else
        return C.C_JsBuilder.call$1("false");
    },
    visitString$1: function(constant) {
      var sb = P.StringBuffer$("");
      O.writeJsonEscapedCharsOn(constant.value.slowToString$0(), sb);
      return new Q.LiteralString0("\"" + sb._contents + "\"", null, null);
    },
    visitList$1: function(constant) {
      var t1, t2, t3;
      t1 = this.namer;
      t2 = t1.get$isolateName();
      t1 = "\"" + H.S(t1.getMappedInstanceName$1("makeConstantList")) + "\"";
      t3 = this._js_backend$_array$1(constant.entries);
      return this.maybeAddTypeArguments$2(constant.type, new Q.Call(new Q.PropertyAccess(new Q.VariableUse(t2, null, null), new Q.LiteralString0(t1, null, null), null, null), [new Q.ArrayInitializer(t3.length, Q.ArrayInitializer__convert(t3), null, null)], null, null));
    },
    visitMap$1: function(constant) {
      var t1, t2, classElement, className, $arguments;
      t1 = {};
      t2 = constant.type;
      classElement = t2.get$element();
      className = classElement.name;
      $arguments = H.setRuntimeTypeInfo([], [Q.Expression]);
      t1.emittedArgumentCount_0 = 0;
      classElement.get$implementation(classElement).forEachInstanceField$2$includeSuperAndInjectedMembers(new Z.ConstantLiteralEmitter_visitMap_closure(t1, this, constant, new Z.ConstantLiteralEmitter_visitMap_jsMap(this, constant), new Z.ConstantLiteralEmitter_visitMap_jsGeneralMap(this, constant), className, $arguments), true);
      if (!(className === "ConstantStringMap" && t1.emittedArgumentCount_0 !== 3))
        if (!(className === "ConstantProtoMap" && t1.emittedArgumentCount_0 !== 4))
          t1 = className === "GeneralConstantMap" && t1.emittedArgumentCount_0 !== 1;
        else
          t1 = true;
      else
        t1 = true;
      if (t1)
        this.compiler.internalError$2(classElement, "Compiler and " + H.S(className) + " disagree on number of fields.");
      return this.maybeAddTypeArguments$2(t2, new Q.New(this.namer.elementAccess$1(classElement), $arguments, null, null));
    },
    get$backend: function() {
      return this.compiler.backend;
    },
    visitType$1: function(constant) {
      var t1, t2, t3;
      t1 = "'" + H.S(this.namer.getRuntimeTypeName$1(constant.representedType.get$element())) + "'";
      t2 = this.compiler;
      t3 = t2.backend;
      t3 = t3.find$2(0, t3.get$jsHelperLibrary(), "createRuntimeType");
      return new Q.Call(t2.backend.get$namer().elementAccess$1(t3), [new Q.LiteralString0(t1, null, null)], null, null);
    },
    visitInterceptor$1: function(constant) {
      return new Q.PropertyAccess(this.namer.elementAccess$1(constant.get$dispatchedType().get$element()), new Q.LiteralString0("\"prototype\"", null, null), null, null);
    },
    visitDummy$1: function(constant) {
      return new Q.LiteralNumber("0", null, null);
    },
    visitConstructed$1: function(constant) {
      var t1, element;
      t1 = constant.type;
      element = t1.get$element();
      if (element.isForeign$1(this.compiler) && element.name === "JS_CONST") {
        t1 = constant.fields;
        if (0 >= t1.length)
          return H.ioore(t1, 0);
        return new Q.LiteralExpression(J.replaceAll$2$s(J.get$value$x(t1[0]).slowToString$0(), $.get$ConstantLiteralEmitter_COMMENT_RE(), ""), C.List_empty, null, null);
      }
      return this.maybeAddTypeArguments$2(t1, new Q.New(this.namer.elementAccess$1(t1.get$element()), this._js_backend$_array$1(constant.fields), null, null));
    },
    _js_backend$_array$1: function(values) {
      var valueList, t1, i, t2, t3;
      valueList = H.setRuntimeTypeInfo([], [Q.Expression]);
      for (t1 = this.constantEmitter, i = 0; i < values.length; ++i) {
        t2 = values[i];
        t3 = t1._referenceEmitter;
        t3.toString;
        valueList.push(J.accept$1$x(t2, t3));
      }
      return valueList;
    },
    maybeAddTypeArguments$2: function(type, value) {
      var t1, t2, rti, t3;
      if (!!J.getInterceptor(type).$isInterfaceType)
        if (!type.get$treatAsRaw()) {
          t1 = this.compiler.backend;
          t2 = type.get$element();
          t1 = t1.get$rti().classesNeedingRti.contains$1(0, t2.get$declaration()) || t1.compiler.enabledRuntimeType;
        } else
          t1 = false;
      else
        t1 = false;
      if (t1) {
        t1 = this.compiler;
        rti = t1.backend.get$rti();
        t2 = "[" + H.setRuntimeTypeInfo(new H.MappedListIterable(type.get$typeArguments(), new Z.ConstantLiteralEmitter_maybeAddTypeArguments_closure(rti)), [null, null]).join$1(0, ", ") + "]";
        t3 = t1.backend;
        t3 = t3.find$2(0, t3.get$jsHelperLibrary(), "setRuntimeTypeInfo");
        return new Q.Call(t1.backend.get$namer().elementAccess$1(t3), [value, new Q.LiteralString0(t2, null, null)], null, null);
      }
      return value;
    },
    visitDeferred$1: function(constant) {
      var t1 = this.constantEmitter._referenceEmitter;
      t1.toString;
      return constant.referenced.accept$1(0, t1);
    },
    static: {"^": "ConstantLiteralEmitter_COMMENT_RE"}
  },
  ConstantLiteralEmitter_visitMap_jsMap: {
    "^": "Closure:114;this_1,constant_2",
    call$0: function() {
      var properties, t1, t2, t3, t4, i, key, t5, keyExpression, t6;
      properties = H.setRuntimeTypeInfo([], [Q.Property]);
      for (t1 = this.constant_2, t2 = t1.keys, t3 = this.this_1, t4 = t3.constantEmitter, t1 = t1.values, i = 0; i < t2.length; ++i) {
        key = t2[i];
        t5 = J.getInterceptor$x(key);
        if (J.$eq(t5.get$value(key), C.LiteralDartString___proto__))
          continue;
        keyExpression = t5.accept$1(key, t3);
        if (i >= t1.length)
          return H.ioore(t1, i);
        t5 = t1[i];
        t6 = t4._referenceEmitter;
        t6.toString;
        properties.push(new Q.Property(keyExpression, J.accept$1$x(t5, t6), null, null));
      }
      return new Q.ObjectInitializer(properties, true, null, null);
    },
    $isFunction: true
  },
  ConstantLiteralEmitter_visitMap_jsGeneralMap: {
    "^": "Closure:114;this_3,constant_4",
    call$0: function() {
      var data, t1, t2, t3, i, t4, t5, keyExpression, valueExpression;
      data = H.setRuntimeTypeInfo([], [Q.Expression]);
      for (t1 = this.constant_4, t2 = t1.keys, t3 = this.this_3.constantEmitter, t1 = t1.values, i = 0; i < t2.length; ++i) {
        t4 = t2[i];
        t5 = t3._referenceEmitter;
        t5.toString;
        keyExpression = J.accept$1$x(t4, t5);
        if (i >= t1.length)
          return H.ioore(t1, i);
        t5 = t1[i];
        t4 = t3._referenceEmitter;
        t4.toString;
        valueExpression = J.accept$1$x(t5, t4);
        data.push(keyExpression);
        data.push(valueExpression);
      }
      return new Q.ArrayInitializer(data.length, Q.ArrayInitializer__convert(data), null, null);
    },
    $isFunction: true
  },
  ConstantLiteralEmitter_visitMap_closure: {
    "^": "Closure:74;box_0,this_5,constant_6,jsMap_7,jsGeneralMap_8,className_9,arguments_10",
    call$2: function(enclosing, field) {
      var t1 = field.name;
      if (t1 === "length")
        this.arguments_10.push(new Q.LiteralNumber("" + this.constant_6.keyList.entries.length, null, null));
      else if (t1 === "_jsObject")
        this.arguments_10.push(this.jsMap_7.call$0());
      else if (t1 === "_keys") {
        t1 = this.this_5.constantEmitter._referenceEmitter;
        t1.toString;
        this.arguments_10.push(this.constant_6.keyList.accept$1(0, t1));
      } else if (t1 === "_protoValue") {
        t1 = this.this_5.constantEmitter._referenceEmitter;
        t1.toString;
        this.arguments_10.push(this.constant_6.protoValue.accept$1(0, t1));
      } else if (t1 === "_jsData")
        this.arguments_10.push(this.jsGeneralMap_8.call$0());
      else
        this.this_5.compiler.internalError$2(field, "Compiler has unexpected field " + H.S(t1) + " for " + H.S(this.className_9) + ".");
      ++this.box_0.emittedArgumentCount_0;
    },
    $isFunction: true
  },
  ConstantLiteralEmitter_maybeAddTypeArguments_closure: {
    "^": "Closure:123;rti_0",
    call$1: function(type) {
      return this.rti_0.getTypeRepresentationWithHashes$2(type, new Z.ConstantLiteralEmitter_maybeAddTypeArguments__closure());
    },
    $isFunction: true
  },
  ConstantLiteralEmitter_maybeAddTypeArguments__closure: {
    "^": "Closure:13;",
    call$1: function(_) {
    },
    $isFunction: true
  },
  JavaScriptConstantTask: {
    "^": "ConstantCompilerTask;dartConstantCompiler,jsConstantCompiler,compiler,watch,profilerTag",
    get$name: function(_) {
      return "ConstantHandler";
    },
    getConstantForVariable$1: function(element) {
      return this.dartConstantCompiler.initialVariableValues.$index(0, element.get$declaration());
    },
    compileConstant$1: function(element) {
      return this.measure$1(new Z.JavaScriptConstantTask_compileConstant_closure(this, element));
    },
    compileVariable$1: function(element) {
      this.measure$1(new Z.JavaScriptConstantTask_compileVariable_closure(this, element));
    },
    compileNode$2: function(node, elements) {
      return this.measure$1(new Z.JavaScriptConstantTask_compileNode_closure(this, node, elements));
    },
    compileMetadata$3: function(metadata, node, elements) {
      return this.measure$1(new Z.JavaScriptConstantTask_compileMetadata_closure(this, metadata, node, elements));
    }
  },
  JavaScriptConstantTask_compileConstant_closure: {
    "^": "Closure:23;this_0,element_1",
    call$0: function() {
      var t1, t2, result;
      t1 = this.this_0;
      t2 = this.element_1;
      result = t1.dartConstantCompiler.compileVariable$2$isConst(t2, true);
      t1.jsConstantCompiler.compileVariable$2$isConst(t2, true);
      return result;
    },
    $isFunction: true
  },
  JavaScriptConstantTask_compileVariable_closure: {
    "^": "Closure:23;this_0,element_1",
    call$0: function() {
      this.this_0.jsConstantCompiler.compileVariable$1(this.element_1);
    },
    $isFunction: true
  },
  JavaScriptConstantTask_compileNode_closure: {
    "^": "Closure:23;this_0,node_1,elements_2",
    call$0: function() {
      var t1, t2, t3, result;
      t1 = this.this_0;
      t2 = this.node_1;
      t3 = this.elements_2;
      result = t1.dartConstantCompiler.compileNodeWithDefinitions$2(t2, t3);
      t1.jsConstantCompiler.compileNodeWithDefinitions$2(t2, t3);
      return result;
    },
    $isFunction: true
  },
  JavaScriptConstantTask_compileMetadata_closure: {
    "^": "Closure:23;this_0,metadata_1,node_2,elements_3",
    call$0: function() {
      var t1, t2, t3, constant, t4;
      t1 = this.this_0;
      t2 = this.node_2;
      t3 = this.elements_3;
      constant = t1.dartConstantCompiler.compileNodeWithDefinitions$2(t2, t3);
      t1 = t1.jsConstantCompiler;
      t4 = this.metadata_1;
      t1.metadataConstantMap.$indexSet(0, t4, K.ConstantCompilerBase.prototype.compileMetadata$3.call(t1, t4, t2, t3));
      return constant;
    },
    $isFunction: true
  },
  JavaScriptConstantCompiler: {
    "^": "ConstantCompilerBase;compiledConstants,lazyStatics,nodeConstantMap,metadataConstantMap,compiler,constantSystem,initialVariableValues,pendingVariables",
    compileVariableWithDefinitions$3$isConst: function(element, definitions, isConst) {
      var t1, value;
      t1 = !isConst;
      if (t1 && this.lazyStatics.contains$1(0, element))
        return;
      value = K.ConstantCompilerBase.prototype.compileVariableWithDefinitions$3$isConst.call(this, element, definitions, isConst);
      if (t1 && value == null)
        this.lazyStatics.add$1(0, element);
      return value;
    },
    getStaticNonFinalFieldsForEmission$0: function() {
      var t1 = this.initialVariableValues;
      t1 = H.setRuntimeTypeInfo(new P.LinkedHashMapKeyIterable(t1), [H.getTypeArgumentByIndex(t1, 0)]);
      return H.setRuntimeTypeInfo(new H.WhereIterable(t1, new Z.JavaScriptConstantCompiler_getStaticNonFinalFieldsForEmission_closure()), [H.getRuntimeTypeArgument(t1, "IterableBase", 0)]);
    },
    getConstantsForEmission$1: function(preSortCompare) {
      var seenConstants, result, sorted;
      seenConstants = P.LinkedHashSet_LinkedHashSet(null, null, null, K.Constant);
      result = H.setRuntimeTypeInfo([], [K.Constant]);
      sorted = this.compiledConstants.toList$0(0);
      if (preSortCompare != null)
        H.IterableMixinWorkaround_sortList(sorted, preSortCompare);
      H.IterableMixinWorkaround_forEach(sorted, new Z.JavaScriptConstantCompiler_getConstantsForEmission_addConstant(this, seenConstants, result));
      return result;
    },
    getConstantsForEmission$0: function() {
      return this.getConstantsForEmission$1(null);
    },
    compileNodeWithDefinitions$3$isConst: function(node, definitions, isConst) {
      var t1, constant;
      t1 = this.nodeConstantMap;
      constant = t1.$index(0, node);
      if (constant != null)
        return constant;
      constant = K.ConstantCompilerBase.prototype.compileNodeWithDefinitions$3$isConst.call(this, node, definitions, isConst);
      if (constant != null)
        t1.$indexSet(0, node, constant);
      return constant;
    },
    compileNodeWithDefinitions$2: function(node, definitions) {
      return this.compileNodeWithDefinitions$3$isConst(node, definitions, true);
    },
    getConstantForNode$2: function(node, definitions) {
      var constant, t1;
      constant = this.nodeConstantMap.$index(0, node);
      if (constant != null)
        return constant;
      t1 = definitions._constants;
      return t1 != null ? t1.$index(0, node) : null;
    },
    getConstantForMetadata$1: function(metadata) {
      return this.metadataConstantMap.$index(0, metadata);
    }
  },
  JavaScriptConstantCompiler_getStaticNonFinalFieldsForEmission_closure: {
    "^": "Closure:13;",
    call$1: function(element) {
      return J.$eq(J.get$kind$x(element), C.ElementKind_field_1) && !element.get$isInstanceMember() && (element.get$modifiers().flags & 4) === 0 && (element.get$modifiers().flags & 16) === 0;
    },
    $isFunction: true
  },
  JavaScriptConstantCompiler_getConstantsForEmission_addConstant: {
    "^": "Closure:167;this_0,seenConstants_1,result_2",
    call$1: function(constant) {
      var t1 = this.seenConstants_1;
      if (!t1.contains$1(0, constant)) {
        H.IterableMixinWorkaround_forEach(constant.getDependencies$0(), this);
        this.result_2.push(constant);
        t1.add$1(0, constant);
      }
    },
    $isFunction: true
  },
  JavaScriptBitNotOperation: {
    "^": "BitNotOperation;name",
    fold$1: function(_, constant) {
      if (constant.get$isInt() || constant.get$isMinusZero()) {
        if (constant.get$isMinusZero())
          constant = K.IntConstant_IntConstant(0);
        return K.IntConstant_IntConstant((J.$not$i(constant.get$value(constant)) & C.JavaScriptConstantSystem_2Vk.BITS32) >>> 0);
      }
      return;
    }
  },
  JavaScriptBinaryBitOperation: {
    "^": "Object;dartBitOperation",
    get$name: function(_) {
      var t1 = this.dartBitOperation;
      return t1.get$name(t1);
    },
    fold$2: function(_, left, right) {
      var result, t1;
      if (left.get$isMinusZero())
        left = K.IntConstant_IntConstant(0);
      if (right.get$isMinusZero())
        right = K.IntConstant_IntConstant(0);
      result = this.dartBitOperation.fold$2(0, left, right);
      if (result != null) {
        t1 = result.value;
        if (typeof t1 !== "number")
          return t1.$and();
        return K.IntConstant_IntConstant((t1 & C.JavaScriptConstantSystem_2Vk.BITS32) >>> 0);
      }
      return result;
    },
    apply$2: function(left, right) {
      return this.dartBitOperation.apply$2(left, right);
    }
  },
  JavaScriptShiftRightOperation: {
    "^": "JavaScriptBinaryBitOperation;dartBitOperation",
    fold$2: function(_, left, right) {
      var value, truncatedValue;
      if (left.get$isInt()) {
        value = left.get$value(left);
        if (typeof value !== "number")
          return value.$and();
        truncatedValue = (value & C.JavaScriptConstantSystem_2Vk.BITS32) >>> 0;
        if (value < 0)
          truncatedValue -= 2 * ((truncatedValue & 2147483648) >>> 0);
        if (value !== truncatedValue)
          left = K.IntConstant_IntConstant(truncatedValue);
      }
      return Z.JavaScriptBinaryBitOperation.prototype.fold$2.call(this, this, left, right);
    }
  },
  JavaScriptNegateOperation: {
    "^": "Object;dartNegateOperation",
    get$name: function(_) {
      return this.dartNegateOperation.name;
    },
    fold$1: function(_, constant) {
      if (constant.get$isInt())
        if (constant.get$value(constant) === 0)
          return C.JavaScriptConstantSystem_2Vk.convertToJavaScriptConstant$1(K.DoubleConstant_DoubleConstant(-0.0));
      return this.dartNegateOperation.fold$1(0, constant);
    }
  },
  JavaScriptBinaryArithmeticOperation: {
    "^": "Object;dartArithmeticOperation",
    get$name: function(_) {
      var t1 = this.dartArithmeticOperation;
      return t1.get$name(t1);
    },
    fold$2: function(_, left, right) {
      var result = this.dartArithmeticOperation.fold$2(0, left, right);
      if (result == null)
        return result;
      return C.JavaScriptConstantSystem_2Vk.convertToJavaScriptConstant$1(result);
    },
    apply$2: function(left, right) {
      return this.dartArithmeticOperation.apply$2(left, right);
    }
  },
  JavaScriptIdentityOperation: {
    "^": "Object;dartIdentityOperation",
    get$name: function(_) {
      return this.dartIdentityOperation.name;
    },
    fold$2: function(_, left, right) {
      var result = this.dartIdentityOperation.fold$2(0, left, right);
      if (result == null || result.get$value(result))
        return result;
      if (left.get$isNum() && right.get$isNum())
        return J.toDouble$0$n(left.get$value(left)) === J.toDouble$0$n(right.get$value(right)) ? C.TrueConstant_true : C.FalseConstant_false;
      return result;
    },
    apply$2: function(left, right) {
      return left == null ? right == null : left === right;
    }
  },
  JavaScriptConstantSystem: {
    "^": "ConstantSystem;BITS31,BITS32,add>,bitAnd<,bitNot<,bitOr<,bitXor<,booleanAnd<,booleanOr<,divide<,equal<,greaterEqual<,greater<,identity<,lessEqual<,less<,modulo<,multiply<,negate<,not<,shiftLeft<,shiftRight<,subtract<,truncatingDivide<",
    add$1: function($receiver, arg0) {
      return this.add.call$1(arg0);
    },
    convertToJavaScriptConstant$1: function(constant) {
      var intValue, doubleValue, floorValue;
      if (constant.get$isInt()) {
        intValue = constant.get$value(constant);
        doubleValue = J.getInterceptor$n(intValue).toDouble$0(intValue);
        if (isNaN(doubleValue) || doubleValue == Infinity || doubleValue == -Infinity)
          return K.DoubleConstant_DoubleConstant(C.JSNumber_methods.toDouble$0(intValue));
        floorValue = C.JSInt_methods.toInt$0(C.JSNumber_methods.toInt$0(Math.floor(C.JSNumber_methods.toDouble$0(intValue))));
        if (floorValue !== intValue)
          return K.IntConstant_IntConstant(floorValue);
      } else if (constant.get$isDouble()) {
        doubleValue = constant.get$value(constant);
        if (!(doubleValue == Infinity || doubleValue == -Infinity) && !isNaN(doubleValue) && !constant.get$isMinusZero()) {
          intValue = J.toInt$0$n(doubleValue);
          if (intValue === doubleValue)
            return K.IntConstant_IntConstant(intValue);
        }
      }
      return constant;
    },
    createInt$1: function(i) {
      return this.convertToJavaScriptConstant$1(K.IntConstant_IntConstant(i));
    },
    createDouble$1: function(d) {
      return this.convertToJavaScriptConstant$1(K.DoubleConstant_DoubleConstant(d));
    },
    createString$1: function(string) {
      return new K.StringConstant(string, J.get$hashCode$(string.slowToString$0()));
    },
    createBool$1: function(value) {
      return value ? C.TrueConstant_true : C.FalseConstant_false;
    },
    createNull$0: function() {
      return C.C_NullConstant;
    },
    isInt$1: function(constant) {
      return constant.get$isInt() || constant.get$isMinusZero();
    },
    isString$1: [function(constant) {
      return constant.get$isString();
    }, "call$1", "get$isString", 2, 0, 83],
    isBool$1: [function(constant) {
      return constant.get$isBool();
    }, "call$1", "get$isBool", 2, 0, 83],
    isNull$1: [function(constant) {
      return constant.get$isNull();
    }, "call$1", "get$isNull", 2, 0, 83],
    isSubtype$3: [function(compiler, s, t) {
      var t1, t2;
      t1 = s.get$element();
      t2 = compiler.get$intClass();
      if (t1 == null ? t2 == null : t1 === t2) {
        t1 = t.get$element();
        t2 = compiler.doubleClass;
        t2 = t1 == null ? t2 == null : t1 === t2;
        t1 = t2;
      } else
        t1 = false;
      if (t1)
        return true;
      t1 = compiler.types.subtypeVisitor;
      return s.get$treatAsDynamic() || t1.isMoreSpecific$2(s, t) === true;
    }, "call$3", "get$isSubtype", 6, 0, 84],
    createMap$4: function(compiler, sourceType, keys, values) {
      var backend, onlyStringKeys, protoValue, i, key, keysType, $arguments, t1, className, classElement, typeArgument, type;
      backend = compiler.backend;
      protoValue = null;
      i = 0;
      while (true) {
        if (!(i < keys.length)) {
          onlyStringKeys = true;
          break;
        }
        key = keys[i];
        if (key.get$isString() === true) {
          if (J.$eq(key.get$value(key), C.LiteralDartString___proto__)) {
            if (i >= values.length)
              return H.ioore(values, i);
            protoValue = values[i];
          }
        } else {
          onlyStringKeys = false;
          protoValue = null;
          break;
        }
        ++i;
      }
      if (sourceType.get$treatAsRaw())
        keysType = compiler.listClass.get$rawType();
      else {
        $arguments = H.setRuntimeTypeInfo([C.JSArray_methods.get$first(sourceType.typeArguments)], [V.DartType]);
        t1 = compiler.listClass;
        keysType = new V.InterfaceType(t1, $arguments);
        keysType.GenericType$3$checkTypeArgumentCount(t1, $arguments, true);
      }
      t1 = K.ListConstant__computeHash(keysType, keys);
      if (onlyStringKeys)
        className = protoValue != null ? "ConstantProtoMap" : "ConstantStringMap";
      else
        className = "GeneralConstantMap";
      classElement = backend.get$jsHelperLibrary().find$1(0, className);
      classElement.ensureResolved$1(compiler);
      typeArgument = sourceType.typeArguments;
      if (sourceType.get$treatAsRaw())
        type = classElement.get$rawType();
      else {
        type = new V.InterfaceType(classElement, typeArgument);
        type.GenericType$3$checkTypeArgumentCount(classElement, typeArgument, true);
      }
      t1 = new Z.JavaScriptMapConstant(new K.ListConstant(keys, t1, keysType), protoValue, onlyStringKeys, keys, values, K.MapConstant_computeHash(type, keys, values), type);
      t1.MapConstant$3(type, keys, values);
      return t1;
    }
  },
  JavaScriptMapConstant: {
    "^": "MapConstant;keyList<,protoValue,onlyStringKeys,keys,values,hashCode,type",
    get$isMap: function(_) {
      return true;
    },
    computeMask$1: function(compiler) {
      return compiler.typesTask.get$constMapType();
    },
    getDependencies$0: function() {
      var result = H.setRuntimeTypeInfo([], [K.Constant]);
      if (this.onlyStringKeys)
        result.push(this.keyList);
      else
        C.JSArray_methods.addAll$1(result, this.keys);
      C.JSArray_methods.addAll$1(result, this.values);
      return result;
    },
    static: {"^": "JavaScriptMapConstant_PROTO_PROPERTY,JavaScriptMapConstant_DART_CLASS,JavaScriptMapConstant_DART_STRING_CLASS,JavaScriptMapConstant_DART_PROTO_CLASS,JavaScriptMapConstant_DART_GENERAL_CLASS,JavaScriptMapConstant_LENGTH_NAME,JavaScriptMapConstant_JS_OBJECT_NAME,JavaScriptMapConstant_KEYS_NAME,JavaScriptMapConstant_PROTO_VALUE,JavaScriptMapConstant_JS_DATA_NAME"}
  },
  CustomElementsAnalysis: {
    "^": "Object;backend<,compiler<,resolutionJoin,codegenJoin,fetchedTableAccessorMethod,tableAccessorMethod",
    registerInstantiatedClass$2: function(classElement, enqueuer) {
      if (classElement.resolutionState === 0)
        this.compiler.resolver.resolveClass$1(classElement);
      if (!O.Elements_isNativeOrExtendsNative(classElement))
        return;
      if (classElement.get$isMixinApplication())
        return;
      (enqueuer.get$isResolutionQueue() ? this.resolutionJoin : this.codegenJoin).instantiatedClasses.add$1(0, classElement);
    },
    registerTypeLiteral$2: function(type, registry) {
      if (type.get$kind(type) === C.TypeKind_interface)
        this.resolutionJoin.selectedClasses.add$1(0, type.get$element());
      else if (type.get$kind(type) === C.TypeKind_kuk)
        this.resolutionJoin.allClassesSelected = true;
    },
    constructors$1: [function(classElement) {
      return this.codegenJoin.computeEscapingConstructors$1(classElement);
    }, "call$1", "get$constructors", 2, 0, 207],
    CustomElementsAnalysis$1: function(backend) {
      this.resolutionJoin.allClassesSelected = true;
      this.codegenJoin.allClassesSelected = true;
    }
  },
  CustomElementsAnalysisJoin: {
    "^": "Object;backend<,instantiatedClasses,selectedClasses,allClassesSelected,demanded,activeClasses",
    get$compiler: function() {
      return this.backend.compiler;
    },
    flush$1: function(enqueuer) {
      var newActiveClasses, t1, t2, t3, classElement, isNative, isExtension, t4, escapingConstructors, t5, constant;
      if (!this.demanded)
        return;
      newActiveClasses = P.LinkedHashSet_LinkedHashSet(null, null, null, O.ClassElement);
      for (t1 = this.instantiatedClasses, t2 = H.setRuntimeTypeInfo(new P.LinkedHashSetIterator(t1, t1._modifications, null, null), [null]), t2._cell = t2._set._first, t3 = this.selectedClasses; t2.moveNext$0();) {
        classElement = t2._collection$_current;
        isNative = classElement.get$isNative();
        isExtension = !isNative && O.Elements_isNativeOrExtendsNative(classElement);
        if (!(isNative && t3.contains$1(0, classElement)))
          if (isExtension)
            t4 = this.allClassesSelected || t3.contains$1(0, classElement);
          else
            t4 = false;
        else
          t4 = true;
        if (t4) {
          newActiveClasses.add$1(0, classElement);
          escapingConstructors = this.computeEscapingConstructors$1(classElement);
          H.IterableMixinWorkaround_forEach(escapingConstructors, enqueuer.get$registerStaticUse());
          t4 = this.backend;
          t5 = t4.compiler;
          H.IterableMixinWorkaround_forEach(escapingConstructors, t5.globalDependencies.get$registerDependency());
          constant = new K.TypeConstant(classElement.get$rawType(), t4.typeLiteralClass.get$rawType());
          t4.registerCompileTimeConstant$2(constant, t5.globalDependencies);
          t4.constantCompilerTask.jsConstantCompiler.compiledConstants.add$1(0, constant);
        }
      }
      this.activeClasses.addAll$1(0, newActiveClasses);
      t1.removeAll$1(newActiveClasses);
    },
    computeEscapingConstructors$1: function(classElement) {
      var result = [];
      result.$builtinTypeInfo = [O.Element];
      if (classElement.get$isNative())
        return result;
      classElement.forEachMember$3$includeBackendMembers$includeSuperAndInjectedMembers(new Z.CustomElementsAnalysisJoin_computeEscapingConstructors_selectGenerativeConstructors(result), false, false);
      return result;
    }
  },
  CustomElementsAnalysisJoin_computeEscapingConstructors_selectGenerativeConstructors: {
    "^": "Closure:74;result_0",
    call$2: function(enclosing, member) {
      if (J.get$kind$x(member) === C.ElementKind_generative_constructor_16)
        if (member.get$functionSignature().get$requiredParameterCount() === 0)
          this.result_0.push(member);
    },
    $isFunction: true
  },
  MinifyNamer: {
    "^": "Namer;getterPrefix:js_backend$MinifyNamer$getterPrefix<,setterPrefix:js_backend$MinifyNamer$setterPrefix<,callPrefix:js_backend$MinifyNamer$callPrefix<,_jsReserved,_jsVariableReserved,currentIsolate,getterPrefix,setterPrefix,metadataField,callPrefix,callCatchAllName,reflectableField,defaultValuesField,methodsWithOptionalArgumentsField,classDescriptorProperty,nativeSpecProperty,compiler,globals,shortPrivateNameOwners,usedGlobalNames,usedInstanceNames,globalNameMap,suggestedGlobalNames,instanceNameMap,suggestedInstanceNames,operatorNameMap,popularNameCounters,constantNames,constantLongNames,constantHasher,functionTypeNameMap,functionTypeNamer",
    get$isolateName: function() {
      return "I";
    },
    get$isolatePropertiesName: function() {
      return "p";
    },
    getFreshName$4$ensureSafe: function(proposedName, usedNames, suggestedNames, ensureSafe) {
      var suggestion, freshName;
      suggestion = suggestedNames.$index(0, proposedName);
      freshName = suggestion != null && !usedNames.contains$1(0, suggestion) ? suggestion : this._getUnusedName$2(proposedName, usedNames);
      usedNames.add$1(0, freshName);
      return freshName;
    },
    getClosureVariableName$2: function($name, id) {
      if (id < 52)
        return P.String_String$fromCharCodes([this._letterNumber$1(id)]);
      return H.S(this.getMappedInstanceName$1("closure")) + "_" + id;
    },
    reserveBackendNames$0: function() {
      var t1, t2, t3, $name, t4, t5, code;
      for (t1 = H.setRuntimeTypeInfo(new H.ListIterator(C.List_aWd, 180, 0, null), [H.getTypeArgumentByIndex(C.List_aWd, 0)]), t2 = this.usedInstanceNames, t3 = this.instanceNameMap; t1.moveNext$0();) {
        $name = t1.__internal$_current;
        t4 = J.getInterceptor$asx($name);
        t5 = t4.get$length($name);
        if (typeof t5 !== "number")
          return t5.$lt();
        if (t5 < 2)
          t3.$indexSet(0, $name, $name);
        t2.add$1(0, $name);
        code = t4.codeUnitAt$1($name, 0);
        if (code === 103 || code === 115)
          t2.add$1(0, C.JSString_methods.substring$1($name, 1));
      }
      this._populateSuggestedNames$3(this.suggestedInstanceNames, t2, C.List_U2X);
      this._populateSuggestedNames$3(this.suggestedGlobalNames, this.usedGlobalNames, C.List_IEE);
    },
    _populateSuggestedNames$3: function(suggestionMap, used, suggestions) {
      var t1, c, $name, letter;
      for (t1 = H.setRuntimeTypeInfo(new H.ListIterator(suggestions, suggestions.length, 0, null), [H.getTypeArgumentByIndex(suggestions, 0)]), c = 96; t1.moveNext$0();) {
        $name = t1.__internal$_current;
        do {
          c = c === 122 ? 65 : c + 1;
          letter = H.Primitives_stringFromCharCodes([c]);
        } while (used.contains$1(0, letter));
        suggestionMap.$indexSet(0, $name, letter);
      }
    },
    _getUnusedName$2: function(proposedName, usedNames) {
      var hash, n, h, codes, h2, i, candidate, code, t1, startLetter;
      hash = this._calculateHash$1(proposedName);
      if (hash < 1000)
        hash *= 314159;
      for (n = 2; n <= 3; ++n)
        for (h = hash; h > 10;) {
          codes = [this._letterNumber$1(h)];
          codes.$builtinTypeInfo = [P.$int];
          h2 = C.JSInt_methods._tdivFast$1(h, 52);
          for (i = 1; i < n; ++i) {
            codes.push(this._alphaNumericNumber$1(h2));
            h2 = C.JSInt_methods._tdivFast$1(h2, 62);
          }
          candidate = H.Primitives_stringFromCharCodes(codes);
          if (!usedNames.contains$1(0, candidate))
            if (!this.get$jsReserved().contains$1(0, candidate)) {
              code = C.JSString_methods.codeUnitAt$1(candidate, 0);
              t1 = !(code === 103 || code === 115);
            } else
              t1 = false;
          else
            t1 = false;
          if (t1)
            return candidate;
          h = C.JSInt_methods._tdivFast$1(h, 7);
        }
      startLetter = P.String_String$fromCharCodes([this._letterNumber$1(hash)]);
      for (i = 0; usedNames.contains$1(0, startLetter + i);)
        ++i;
      return startLetter + i;
    },
    _calculateHash$1: function($name) {
      var t1, h, i;
      for (t1 = $name.length, h = 0, i = 0; i < t1; ++i) {
        h = (h + C.JSString_methods.codeUnitAt$1($name, i) & 4294967295) >>> 0;
        h = h + (h << 10 >>> 0) & 4294967295;
        h = ((h ^ h >>> 6) & 4294967295) >>> 0;
      }
      return h;
    },
    _letterNumber$1: function(x) {
      if (x >= 52)
        x = C.JSInt_methods.$mod(x, 52);
      if (x < 26)
        return 97 + x;
      return 65 + x - 26;
    },
    _alphaNumericNumber$1: function(x) {
      if (x >= 62)
        x = C.JSInt_methods.$mod(x, 62);
      if (x < 26)
        return 97 + x;
      if (x < 52)
        return 65 + x - 26;
      return 48 + x - 52;
    },
    static: {"^": "MinifyNamer_ALPHABET_CHARACTERS,MinifyNamer_ALPHANUMERIC_CHARACTERS"}
  },
  Namer: {
    "^": "Object;_jsReserved,_jsVariableReserved,currentIsolate,getterPrefix<,setterPrefix<,metadataField,callPrefix<,callCatchAllName,reflectableField,defaultValuesField,methodsWithOptionalArgumentsField,classDescriptorProperty,nativeSpecProperty,compiler<,globals,shortPrivateNameOwners,usedGlobalNames,usedInstanceNames,globalNameMap,suggestedGlobalNames,instanceNameMap,suggestedInstanceNames,operatorNameMap,popularNameCounters,constantNames,constantLongNames,constantHasher,functionTypeNameMap,functionTypeNamer",
    get$jsReserved: function() {
      if (this._jsReserved == null) {
        var t1 = P.LinkedHashSet_LinkedHashSet(null, null, null, P.String);
        this._jsReserved = t1;
        t1.addAll$1(0, C.List_Odk);
        this._jsReserved.addAll$1(0, C.List_O5a);
      }
      return this._jsReserved;
    },
    get$jsVariableReserved: function() {
      if (this._jsVariableReserved == null) {
        var t1 = P.LinkedHashSet_LinkedHashSet(null, null, null, P.String);
        this._jsVariableReserved = t1;
        t1.addAll$1(0, C.List_Odk);
        this._jsVariableReserved.addAll$1(0, C.List_O5a);
        this._jsVariableReserved.addAll$1(0, C.List_3CK);
        this._jsVariableReserved.addAll$1(0, C.List_69t);
        this._jsVariableReserved.addAll$1(0, C.List_init_Isolate);
      }
      return this._jsVariableReserved;
    },
    get$backend: function() {
      return this.compiler.backend;
    },
    get$isolateName: function() {
      return "Isolate";
    },
    get$isolatePropertiesName: function() {
      return "$isolateProperties";
    },
    getNameForJsGetName$2: function(node, $name) {
      switch ($name) {
        case "GETTER_PREFIX":
          return this.get$getterPrefix();
        case "SETTER_PREFIX":
          return this.get$setterPrefix();
        case "CALL_PREFIX":
          return this.get$callPrefix();
        case "CALL_CATCH_ALL":
          return this.callCatchAllName;
        case "REFLECTABLE":
          return this.reflectableField;
        case "CLASS_DESCRIPTOR_PROPERTY":
          return this.classDescriptorProperty;
        default:
          this.compiler.reportDiagnosticInternal$4(node, C.MessageKind_wwi, P.LinkedHashMap_LinkedHashMap$_literal(["text", "Error: Namer has no name for \"" + H.S($name) + "\"."], null, null), C.Diagnostic_1_error);
          return "BROKEN";
      }
    },
    constantName$1: function(constant) {
      var t1, result;
      t1 = this.constantNames;
      result = t1.$index(0, constant);
      if (result == null) {
        result = this.getFreshName$4$ensureSafe(this.constantLongName$1(constant), this.usedGlobalNames, this.suggestedGlobalNames, true);
        t1.$indexSet(0, constant, result);
      }
      return result;
    },
    constantLongName$1: function(constant) {
      var t1, longName;
      t1 = this.constantLongNames;
      longName = t1.$index(0, constant);
      if (longName == null) {
        longName = new Z.ConstantNamingVisitor(this.compiler, this.constantHasher, null, false, H.setRuntimeTypeInfo([], [P.String]), 0).getName$1(constant);
        t1.$indexSet(0, constant, longName);
      }
      return longName;
    },
    privateName$2: function(library, $name) {
      var t1 = J.getInterceptor$asx($name);
      if (!(!t1.get$isEmpty($name) && t1.codeUnitAt$1($name, 0) === 95))
        return $name;
      if (J.$eq(this.shortPrivateNameOwners.putIfAbsent$2($name, new Z.Namer_privateName_closure(library)), library) && !t1.contains$1($name, "$"))
        return $name;
      else
        return "_" + H.S(this.getNameX$1(library)) + "$" + H.S($name);
    },
    instanceMethodName$1: function(element) {
      var elementName, $name, library, signature, t1, methodName, t2, buffer;
      elementName = element.name;
      $name = this.operatorNameToIdentifier$1(elementName);
      if ($name == null ? elementName != null : $name !== elementName)
        return this.getMappedOperatorName$1($name);
      library = element.get$enclosingElement().get$library();
      if (element.kind === C.ElementKind_generative_constructor_body_0)
        $name = O.Elements_reconstructConstructorNameSourceString(element);
      signature = element.get$functionSignature();
      t1 = $name === "call";
      methodName = t1 ? this.get$callPrefix() + "$" + signature.get$parameterCount() : H.S(this.privateName$2(library, $name)) + "$" + signature.get$parameterCount();
      if (signature.get$optionalParametersAreNamed()) {
        t2 = signature.optionalParameters;
        t2 = !t2.get$isEmpty(t2);
      } else
        t2 = false;
      if (t2) {
        buffer = P.StringBuffer$("");
        H.IterableMixinWorkaround_forEach(signature.orderedOptionalParameters, new Z.Namer_instanceMethodName_closure(this, buffer));
        methodName += buffer._contents;
      }
      if (t1)
        return methodName;
      return this.getMappedInstanceName$1(methodName);
    },
    publicInstanceMethodNameByArity$2: function($name, arity) {
      var newName = this.operatorNameToIdentifier$1($name);
      if (newName !== $name)
        return this.getMappedOperatorName$1(newName);
      if ($name === "call")
        return this.get$callPrefix() + "$" + arity;
      return this.getMappedInstanceName$1($name + "$" + arity);
    },
    invocationName$1: function(selector) {
      var t1, proposedName, $name, buffer, argumentName, t2, suffix;
      t1 = selector.kind;
      if (t1 === C.SelectorKind_getter_0) {
        proposedName = this.privateName$2(selector.library, selector.name);
        return this.get$getterPrefix() + H.S(this.getMappedInstanceName$1(proposedName));
      } else if (t1 === C.SelectorKind_setter_1) {
        proposedName = this.privateName$2(selector.library, selector.name);
        return this.get$setterPrefix() + H.S(this.getMappedInstanceName$1(proposedName));
      } else {
        $name = selector.name;
        if (t1 === C.SelectorKind_operator_3 || t1 === C.SelectorKind_index_4)
          return this.getMappedOperatorName$1(this.operatorNameToIdentifier$1($name));
        buffer = P.StringBuffer$("");
        for (t1 = selector.getOrderedNamedArguments$0(), t1 = H.setRuntimeTypeInfo(new H.ListIterator(t1, t1.length, 0, null), [H.getTypeArgumentByIndex(t1, 0)]); t1.moveNext$0();) {
          argumentName = t1.__internal$_current;
          t2 = "$" + H.S(this.get$jsReserved().contains$1(0, argumentName) || J.startsWith$1$s(argumentName, "$") ? "$" + H.S(argumentName) : argumentName);
          buffer._contents += t2;
        }
        suffix = "$" + selector.argumentCount + H.S(buffer);
        if (selector.get$isClosureCall())
          return this.get$callPrefix() + suffix;
        else
          return this.getMappedInstanceName$1(H.S(this.privateName$2(selector.library, $name)) + suffix);
      }
    },
    instanceFieldAccessorName$1: function(element) {
      return this.getMappedInstanceName$1(this.privateName$2(element.get$enclosingElement().get$library(), element.name));
    },
    instanceFieldPropertyName$1: function(element) {
      var libraryName, className, instanceName;
      if (element.get$hasFixedBackendName())
        return element._fixedBackendName;
      if (this.compiler.world.isUsedAsMixin$1(element.get$enclosingClass()) || element.get$enclosingClass().hasFieldShadowedBy$1(element)) {
        libraryName = this.getNameX$1(element.get$library());
        className = this.getNameX$1(element.get$enclosingClass());
        instanceName = this.privateName$2(element.get$library(), element.name);
        return this.getMappedInstanceName$1(H.S(libraryName) + "$" + H.S(className) + "$" + H.S(instanceName));
      }
      return this.getMappedInstanceName$1(this.privateName$2(element.get$library(), element.name));
    },
    setterName$1: function(element) {
      var $name = this.getMappedInstanceName$1(this.privateName$2(element.get$library(), element.name));
      return this.get$setterPrefix() + H.S($name);
    },
    getterName$1: function(element) {
      var $name = this.getMappedInstanceName$1(this.privateName$2(element.get$library(), element.name));
      return this.get$getterPrefix() + H.S($name);
    },
    getMappedGlobalName$2$ensureSafe: function(proposedName, ensureSafe) {
      var t1, newName;
      t1 = this.globalNameMap;
      newName = t1.$index(0, proposedName);
      if (newName == null) {
        newName = this.getFreshName$4$ensureSafe(proposedName, this.usedGlobalNames, this.suggestedGlobalNames, ensureSafe);
        t1.$indexSet(0, proposedName, newName);
      }
      return newName;
    },
    getMappedGlobalName$1: function(proposedName) {
      return this.getMappedGlobalName$2$ensureSafe(proposedName, true);
    },
    getMappedInstanceName$1: function(proposedName) {
      var t1, newName;
      t1 = this.instanceNameMap;
      newName = t1.$index(0, proposedName);
      if (newName == null) {
        newName = this.getFreshName$4$ensureSafe(proposedName, this.usedInstanceNames, this.suggestedInstanceNames, true);
        t1.$indexSet(0, proposedName, newName);
      }
      return newName;
    },
    getMappedOperatorName$1: function(proposedName) {
      var t1, newName;
      t1 = this.operatorNameMap;
      newName = t1.$index(0, proposedName);
      if (newName == null) {
        newName = this.getFreshName$4$ensureSafe(proposedName, this.usedInstanceNames, this.suggestedInstanceNames, false);
        t1.$indexSet(0, proposedName, newName);
      }
      return newName;
    },
    getFreshName$4$ensureSafe: function(proposedName, usedNames, suggestedNames, ensureSafe) {
      var candidate, t1, counter, i;
      if (ensureSafe)
        proposedName = this._safeName$2(proposedName, this.get$jsReserved());
      if (!usedNames.contains$1(0, proposedName))
        candidate = proposedName;
      else {
        t1 = this.popularNameCounters;
        counter = t1.$index(0, proposedName);
        i = counter == null ? 0 : counter;
        for (; usedNames.contains$1(0, H.S(proposedName) + H.S(i));)
          i = J.$add$ns(i, 1);
        t1.$indexSet(0, proposedName, J.$add$ns(i, 1));
        candidate = H.S(proposedName) + H.S(i);
      }
      usedNames.add$1(0, candidate);
      return candidate;
    },
    getClosureVariableName$2: function($name, id) {
      return H.S($name) + "_" + id;
    },
    _computeGuess$1: function(element) {
      var t1, $name, t2, enclosingClass;
      if (element.get$isGenerativeConstructor()) {
        t1 = element.get$enclosingClass();
        $name = H.S(t1.get$name(t1)) + "$" + H.S(element.name);
      } else if ((element.get$modifiers().flags & 32) !== 0) {
        t1 = element.get$enclosingClass();
        $name = H.S(t1.get$name(t1)) + "_" + H.S(O.Elements_reconstructConstructorName(element));
      } else if (O.Elements_isStaticOrTopLevel(element)) {
        t1 = element.get$isClassMember();
        t2 = element.name;
        if (t1) {
          enclosingClass = element.get$enclosingClass();
          $name = H.S(enclosingClass.get$name(enclosingClass)) + "_" + H.S(t2);
        } else
          $name = J.replaceAll$2$s(t2, "+", "_");
      } else if (element.kind === C.ElementKind_library_0) {
        $name = element.getLibraryOrScriptName$0();
        if (C.JSString_methods.contains$1($name, "."))
          $name = element.libraryTag != null ? C.JSString_methods.substring$1($name, C.JSString_methods.lastIndexOf$1($name, ".") + 1) : C.JSString_methods.substring$2($name, 0, C.JSString_methods.indexOf$1($name, "."));
        t1 = $.get$Namer_IDENTIFIER()._nativeRegExp;
        if (!t1.test($name)) {
          $name = H.stringReplaceAllFuncUnchecked($name, $.get$Namer_NON_IDENTIFIER_CHAR(), new Z.Namer__computeGuess_closure(), null);
          if (!t1.test($name))
            $name = "lib_" + $name;
        }
      } else
        $name = element.name;
      return $name;
    },
    getInterceptorSuffix$1: function(classes) {
      var t1, names;
      t1 = classes.where$1(0, new Z.Namer_getInterceptorSuffix_closure());
      t1 = H.MappedIterable_MappedIterable(t1, new Z.Namer_getInterceptorSuffix_abbreviate(this), H.getRuntimeTypeArgument(t1, "IterableBase", 0), null);
      names = P.List_List$from(t1, true, H.getRuntimeTypeArgument(t1, "IterableBase", 0));
      if (classes.any$1(0, new Z.Namer_getInterceptorSuffix_closure0()))
        names.push("x");
      H.IterableMixinWorkaround_sortList(names, null);
      return C.JSArray_methods.join$0(names);
    },
    getInterceptorName$2: function(element, classes) {
      var suffix;
      if (classes.contains$1(0, this.compiler.backend.get$jsInterceptorClass()) === true)
        return this.getNameX$1(element);
      suffix = this.getInterceptorSuffix$1(classes);
      return this.getMappedGlobalName$1(H.S(element.get$name(element)) + "$" + suffix);
    },
    getOneShotInterceptorName$2: function(selector, classes) {
      var root, t1, suffix;
      root = this.invocationName$1(selector);
      if (classes.contains$1(0, this.compiler.backend.get$jsInterceptorClass()) === true) {
        t1 = selector.kind;
        return this.getMappedGlobalName$2$ensureSafe(t1 === C.SelectorKind_getter_0 || t1 === C.SelectorKind_setter_1 ? H.S(root) + "$" : root, false);
      } else {
        suffix = this.getInterceptorSuffix$1(classes);
        return this.getMappedGlobalName$2$ensureSafe(H.S(root) + "$" + suffix, false);
      }
    },
    getRuntimeTypeName$1: function(element) {
      if (element == null)
        return "dynamic";
      return this.getNameX$1(element);
    },
    getNameX$1: function(element) {
      var t1, t2, cached, guess, kind, result;
      if (element.get$isInstanceMember()) {
        t1 = element.kind;
        if (t1 === C.ElementKind_generative_constructor_body_0 || t1 === C.ElementKind_function_2)
          return this.instanceMethodName$1(element);
        else if (t1 === C.ElementKind_getter_0)
          return this.getterName$1(element);
        else if (t1 === C.ElementKind_setter_0)
          return this.setterName$1(element);
        else {
          t2 = this.compiler;
          if (t1 === C.ElementKind_field_1)
            t2.internalError$2(element, "Use instanceFieldPropertyName or instanceFieldAccessorName.");
          else
            t2.internalError$2(element, "getName for bad kind: " + J.toString$0(t1) + ".");
        }
      } else {
        element = element.get$declaration();
        t1 = this.globals;
        cached = t1.$index(0, element);
        if (cached != null)
          return cached;
        guess = this._computeGuess$1(element);
        kind = element.get$kind(element);
        if (kind === C.ElementKind_variable_1 || kind === C.ElementKind_parameter_1)
          return this._safeName$2(guess, this.get$jsReserved());
        if (kind === C.ElementKind_generative_constructor_16 || kind === C.ElementKind_function_2 || kind === C.ElementKind_class_4 || kind === C.ElementKind_field_1 || kind === C.ElementKind_getter_0 || kind === C.ElementKind_setter_0 || kind === C.ElementKind_typedef_32 || kind === C.ElementKind_library_0) {
          result = O.Elements_isInstanceField(element) && element.get$hasFixedBackendName() ? guess : this.getFreshName$4$ensureSafe(guess, this.usedGlobalNames, this.suggestedGlobalNames, true);
          t1.$indexSet(0, element, result);
          return result;
        }
        this.compiler.internalError$2(element, "getName for unknown kind: " + J.toString$0(element.kind) + ".");
      }
    },
    getNameOfClass$1: [function(cls) {
      return this.getNameX$1(cls);
    }, "call$1", "get$getNameOfClass", 2, 0, 208],
    globalObjectFor$1: function(element) {
      var t1, library, t2;
      if (!(element.get$isGetter() || element.get$kind(element) === C.ElementKind_setter_0))
        if (element.get$kind(element) !== C.ElementKind_class_4) {
          t1 = element.kind;
          t1 = !(t1 === C.ElementKind_generative_constructor_16 || element.get$isFactoryConstructor()) && !element.get$isFunction() && t1 !== C.ElementKind_library_0;
        } else
          t1 = false;
      else
        t1 = false;
      if (t1)
        return this.currentIsolate;
      library = element.get$library();
      t1 = this.compiler.backend.get$interceptorsLibrary();
      if (library == null ? t1 == null : library === t1)
        return "J";
      t1 = library.canonicalUri;
      t2 = t1.scheme === "dart";
      if (t2 && C.JSString_methods.startsWith$1(t1._path, "_"))
        return "H";
      if (t2) {
        if (t1.toString$0(0) === "dart:html")
          return "W";
        return "P";
      }
      t1 = $.get$Namer_userGlobalObjects();
      return t1[C.JSInt_methods.$mod(C.JSString_methods.get$hashCode(library.getLibraryOrScriptName$0()), t1.length)];
    },
    elementAccess$1: function(element) {
      var $name = this.getNameX$1(element);
      return new Q.PropertyAccess(new Q.VariableUse(this.globalObjectFor$1(element), null, null), new Q.LiteralString0("\"" + H.S($name) + "\"", null, null), null, null);
    },
    getLazyInitializerName$1: function(element) {
      return this.getMappedGlobalName$1(this.get$getterPrefix() + H.S(this.getNameX$1(element)));
    },
    getStaticClosureName$1: function(element) {
      return this.getMappedGlobalName$1(H.S(this.getNameX$1(element)) + "$closure");
    },
    getFunctionTypeName$1: function(functionType) {
      return this.functionTypeNameMap.putIfAbsent$2(functionType, new Z.Namer_getFunctionTypeName_closure(this, functionType));
    },
    operatorIsType$1: function(type) {
      if (type.get$kind(type) === C.TypeKind_function)
        return "$is_" + H.S(this.getFunctionTypeName$1(type));
      return "$is" + H.S(this.getRuntimeTypeName$1(type.get$element()));
    },
    _safeName$2: function($name, reserved) {
      return reserved.contains$1(0, $name) || J.startsWith$1$s($name, "$") ? "$" + H.S($name) : $name;
    },
    operatorNameToIdentifier$1: function($name) {
      if ($name == null)
        return;
      if ($name === "==")
        return "$eq";
      else if ($name === "~")
        return "$not";
      else if ($name === "[]")
        return "$index";
      else if ($name === "[]=")
        return "$indexSet";
      else if ($name === "*")
        return "$mul";
      else if ($name === "/")
        return "$div";
      else if ($name === "%")
        return "$mod";
      else if ($name === "~/")
        return "$tdiv";
      else if ($name === "+")
        return "$add";
      else if ($name === "<<")
        return "$shl";
      else if ($name === ">>")
        return "$shr";
      else if ($name === ">=")
        return "$ge";
      else if ($name === ">")
        return "$gt";
      else if ($name === "<=")
        return "$le";
      else if ($name === "<")
        return "$lt";
      else if ($name === "&")
        return "$and";
      else if ($name === "^")
        return "$xor";
      else if ($name === "|")
        return "$or";
      else if ($name === "-")
        return "$sub";
      else if ($name === "unary-")
        return "$negate";
      else
        return $name;
    },
    static: {"^": "Namer_javaScriptKeywords,Namer_reservedPropertySymbols,Namer_reservedGlobalSymbols,Namer_reservedGlobalObjectNames,Namer_reservedGlobalHelperFunctions,Namer_userGlobalObjects,Namer_IDENTIFIER,Namer_NON_IDENTIFIER_CHAR", Namer$: function(compiler) {
        var t1, t2, t3, t4, t5, t6, t7;
        t1 = P.LinkedHashMap_LinkedHashMap(null, null, null, V.FunctionType, P.String);
        t2 = P.LinkedHashMap_LinkedHashMap(null, null, null, O.Element, P.String);
        t3 = P.LinkedHashMap_LinkedHashMap(null, null, null, P.String, O.LibraryElement);
        t4 = P.LinkedHashSet_LinkedHashSet(null, null, null, P.String);
        t5 = P.LinkedHashSet_LinkedHashSet(null, null, null, P.String);
        t6 = P.LinkedHashMap_LinkedHashMap(null, null, null, P.String, P.String);
        t7 = P.LinkedHashMap_LinkedHashMap(null, null, null, P.String, P.String);
        return new Z.Namer(null, null, "$", "get$", "set$", "@", "call", "call$catchAll", "$reflectable", "$defaultValues", "$methodsWithOptionalArguments", "^", "%", compiler, t2, t3, t4, t5, P.LinkedHashMap_LinkedHashMap(null, null, null, P.String, P.String), P.LinkedHashMap_LinkedHashMap(null, null, null, P.String, P.String), t6, P.LinkedHashMap_LinkedHashMap(null, null, null, P.String, P.String), t7, P.LinkedHashMap_LinkedHashMap(null, null, null, P.String, P.$int), P.LinkedHashMap_LinkedHashMap(null, null, null, K.Constant, P.String), P.LinkedHashMap_LinkedHashMap(null, null, null, K.Constant, P.String), new Z.ConstantCanonicalHasher(compiler, P.LinkedHashMap_LinkedHashMap(null, null, null, K.Constant, P.$int)), t1, new Z.FunctionTypeNamer(compiler, null));
      }}
  },
  Namer_privateName_closure: {
    "^": "Closure:23;library_0",
    call$0: function() {
      return this.library_0;
    },
    $isFunction: true
  },
  Namer_instanceMethodName_closure: {
    "^": "Closure:77;this_0,buffer_1",
    call$1: function(element) {
      var t1 = this.this_0;
      this.buffer_1.write$1("$" + H.S(t1._safeName$2(J.get$name$x(element), t1.get$jsReserved())));
    },
    $isFunction: true
  },
  Namer__computeGuess_closure: {
    "^": "Closure:13;",
    call$1: function(match) {
      return C.JSInt_methods.toRadixString$1(J.codeUnitAt$1$s(match.$index(0, 0), 0), 16);
    },
    $isFunction: true
  },
  Namer_getInterceptorSuffix_abbreviate: {
    "^": "Closure:208;this_0",
    call$1: function(cls) {
      var t1, t2;
      t1 = this.this_0.compiler;
      t2 = J.getInterceptor(cls);
      if (t2.$eq(cls, t1.objectClass))
        return "o";
      if (t2.$eq(cls, t1.backend.get$jsStringClass()))
        return "s";
      if (t2.$eq(cls, t1.backend.get$jsArrayClass()))
        return "a";
      if (t2.$eq(cls, t1.backend.get$jsDoubleClass()))
        return "d";
      if (t2.$eq(cls, t1.backend.get$jsIntClass()))
        return "i";
      if (t2.$eq(cls, t1.backend.get$jsNumberClass()))
        return "n";
      if (t2.$eq(cls, t1.backend.get$jsNullClass()))
        return "u";
      if (t2.$eq(cls, t1.backend.get$jsBoolClass()))
        return "b";
      if (t2.$eq(cls, t1.backend.get$jsInterceptorClass()))
        return "I";
      return t2.get$name(cls);
    },
    $isFunction: true
  },
  Namer_getInterceptorSuffix_closure: {
    "^": "Closure:13;",
    call$1: function(cls) {
      return !O.Elements_isNativeOrExtendsNative(cls);
    },
    $isFunction: true
  },
  Namer_getInterceptorSuffix_closure0: {
    "^": "Closure:13;",
    call$1: function(cls) {
      return O.Elements_isNativeOrExtendsNative(cls);
    },
    $isFunction: true
  },
  Namer_getFunctionTypeName_closure: {
    "^": "Closure:23;this_0,functionType_1",
    call$0: function() {
      var t1, t2;
      t1 = this.this_0;
      t2 = t1.functionTypeNamer;
      t2.sb = P.StringBuffer$("");
      this.functionType_1.accept$2(0, t2, null);
      return t1.getFreshName$4$ensureSafe(J.toString$0(t2.sb), t1.usedInstanceNames, t1.suggestedInstanceNames, true);
    },
    $isFunction: true
  },
  ConstantNamingVisitor: {
    "^": "Object;compiler<,hasher,root<,failed,fragments,length*",
    getName$1: function(constant) {
      var t1, t2;
      constant.accept$1(0, this);
      t1 = this.root;
      if (t1 == null)
        return "CONSTANT";
      if (this.failed)
        return H.S(t1) + "_" + this.hashWord$2(this.hasher._visit$1(constant), 3);
      t2 = this.fragments;
      if (t2.length === 1)
        return "C_" + H.S(t1);
      return C.JSArray_methods.join$1(t2, "_");
    },
    hashWord$2: function(hash, $length) {
      var sb, i, t1;
      hash &= 536870911;
      sb = P.StringBuffer$("");
      for (i = 0; i < $length; ++i) {
        t1 = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"[C.JSInt_methods.$mod(hash, 62)];
        sb._contents += t1;
        hash = C.JSInt_methods._tdivFast$1(hash, 62);
        if (hash === 0)
          break;
      }
      return sb._contents;
    },
    addRoot$1: function(fragment) {
      if (this.root == null && this.fragments.length === 0)
        this.root = fragment;
      this.add$1(0, fragment);
    },
    add$1: function(_, fragment) {
      var t1, t2;
      t1 = this.fragments;
      t1.push(fragment);
      t2 = this.length + J.get$length$asx(fragment);
      this.length = t2;
      if (t1.length > 5)
        this.failed = true;
      t1 = this.root;
      if (t1 != null && t2 > t1.length + 1 + 30)
        this.failed = true;
    },
    addIdentifier$1: function(fragment) {
      var t1;
      if (fragment.length <= 30) {
        t1 = $.get$ConstantNamingVisitor_IDENTIFIER()._nativeRegExp;
        if (typeof fragment !== "string")
          H.throwExpression(P.ArgumentError$(fragment));
        t1 = t1.test(fragment);
      } else
        t1 = false;
      if (t1)
        this.add$1(0, fragment);
      else
        this.failed = true;
    },
    visitFunction$1: function(constant) {
      var t1 = constant.element;
      this.add$1(0, t1.get$name(t1));
    },
    visitNull$1: function(constant) {
      this.add$1(0, "null");
    },
    visitInt$1: function(constant) {
      var t1 = constant.value;
      if (typeof t1 !== "number")
        return t1.$lt();
      if (t1 < 0)
        this.add$1(0, "m" + -t1);
      else
        this.add$1(0, "" + t1);
    },
    visitDouble$1: function(constant) {
      this.failed = true;
    },
    visitTrue$1: function(constant) {
      this.add$1(0, "true");
    },
    visitFalse$1: function(constant) {
      this.add$1(0, "false");
    },
    visitString$1: function(constant) {
      this.addIdentifier$1(constant.value.slowToString$0());
    },
    visitList$1: function(constant) {
      var t1, $length, i;
      this.addRoot$1("List");
      t1 = constant.entries;
      $length = t1.length;
      if ($length === 0)
        this.add$1(0, "empty");
      else if ($length >= 5)
        this.failed = true;
      else
        for (i = 0; i < $length; ++i) {
          if (i >= t1.length)
            return H.ioore(t1, i);
          J.accept$1$x(t1[i], this);
          if (this.failed)
            break;
        }
    },
    visitMap$1: function(constant) {
      var t1;
      this.addRoot$1("Map");
      if (constant.keys.length === 0)
        this.add$1(0, "empty");
      else {
        t1 = this.hasher;
        this.add$1(0, this.hashWord$2(t1._visit$1(constant.get$keyList()), 2) + this.hashWord$2(t1._visit$1(constant), 3));
      }
    },
    visitConstructed$1: function(constant) {
      var t1, i;
      this.addRoot$1(constant.type.get$element().name);
      for (t1 = constant.fields, i = 0; i < t1.length; ++i) {
        J.accept$1$x(t1[i], this);
        if (this.failed)
          return;
      }
    },
    visitType$1: function(constant) {
      this.addRoot$1("Type");
      this.addIdentifier$1(this.compiler.backend.get$rti().getTypeRepresentationForTypeConstant$1(constant.representedType));
    },
    visitInterceptor$1: function(constant) {
      this.addRoot$1(constant.get$dispatchedType().get$element().name);
      this.add$1(0, "methods");
    },
    visitDummy$1: function(constant) {
      this.add$1(0, "dummy_receiver");
    },
    visitDeferred$1: function(constant) {
      this.addRoot$1("Deferred");
    },
    static: {"^": "ConstantNamingVisitor_IDENTIFIER,ConstantNamingVisitor_MAX_FRAGMENTS,ConstantNamingVisitor_MAX_EXTRA_LENGTH,ConstantNamingVisitor_DEFAULT_TAG_LENGTH"}
  },
  ConstantCanonicalHasher: {
    "^": "Object;compiler<,hashes",
    _visit$1: function(constant) {
      var t1, hash, t2;
      t1 = this.hashes;
      hash = t1.$index(0, constant);
      if (hash == null) {
        t2 = J.accept$1$x(constant, this);
        if (typeof t2 !== "number")
          return H.iae(t2);
        hash = 536870911 & t2 + ((67108863 & t2) << 3 >>> 0);
        hash &= hash >>> 11;
        hash = 536870911 & hash + ((16383 & hash) << 15 >>> 0);
        t1.$indexSet(0, constant, hash);
      }
      return hash;
    },
    visitNull$1: function(constant) {
      return 1;
    },
    visitTrue$1: function(constant) {
      return 2;
    },
    visitFalse$1: function(constant) {
      return 3;
    },
    visitFunction$1: function(constant) {
      var t1 = constant.element;
      return this._hashString$2(1, t1.get$name(t1));
    },
    visitInt$1: function(constant) {
      return Z.ConstantCanonicalHasher__hashInt(constant.value);
    },
    visitDouble$1: function(constant) {
      return Z.ConstantCanonicalHasher__hashDouble(constant.value);
    },
    visitString$1: function(constant) {
      return this._hashString$2(2, constant.value.slowToString$0());
    },
    visitList$1: function(constant) {
      var t1 = constant.entries;
      return this._hashList$2(t1.length, t1);
    },
    visitMap$1: function(constant) {
      var t1 = constant.keys;
      return this._hashList$2(this._hashList$2(t1.length, t1), constant.values);
    },
    visitConstructed$1: function(constant) {
      var hash, t1, i;
      hash = this._hashString$2(3, constant.type.get$element().name);
      for (t1 = constant.fields, i = 0; i < t1.length; ++i)
        hash = Z.ConstantCanonicalHasher__combine(hash, this._visit$1(t1[i]));
      return hash;
    },
    visitType$1: function(constant) {
      return this._hashString$2(4, this.compiler.backend.get$rti().getTypeRepresentationForTypeConstant$1(constant.representedType));
    },
    visitInterceptor$1: function(constant) {
      return this._hashString$2(5, constant.get$dispatchedType().get$element().name);
    },
    visitDummy$1: function(constant) {
      this.compiler.internalError$2(C._SpannableSentinel_fBD, "DummyReceiverConstant should never be named and never be subconstant");
    },
    visitDeferred$1: function(constant) {
      return Z.ConstantCanonicalHasher__combine(constant.prefix.hashCode, constant.referenced.accept$1(0, this));
    },
    _hashString$2: function(hash, s) {
      var $length, t1, i;
      $length = s.length;
      hash = Z.ConstantCanonicalHasher__combine(hash, $length);
      for (t1 = J.getInterceptor$s(s), i = 0; i < $length; i += 1 + (i >>> 2))
        hash = Z.ConstantCanonicalHasher__combine(hash, t1.codeUnitAt$1(s, i));
      return hash;
    },
    _hashList$2: function(hash, constants) {
      var t1;
      for (t1 = H.setRuntimeTypeInfo(new H.ListIterator(constants, constants.length, 0, null), [H.getTypeArgumentByIndex(constants, 0)]); t1.moveNext$0();)
        hash = Z.ConstantCanonicalHasher__combine(hash, this._visit$1(t1.__internal$_current));
      return hash;
    },
    static: {"^": "ConstantCanonicalHasher__MASK,ConstantCanonicalHasher__UINT32_LIMIT", ConstantCanonicalHasher__hashInt: function(value) {
        if (J.abs$0$n(value) < 4294967296)
          return 536870911 & value;
        return Z.ConstantCanonicalHasher__hashDouble(value);
      }, ConstantCanonicalHasher__hashDouble: function(value) {
        var magnitude, sign, intValue, hash;
        magnitude = Math.abs(value);
        sign = value < 0 ? 1 : 0;
        if (magnitude < 4294967296) {
          intValue = C.JSNumber_methods.toInt$0(value);
          hash = Z.ConstantCanonicalHasher__hashInt(intValue);
          if (value === intValue)
            return hash;
          return Z.ConstantCanonicalHasher__combine(Z.ConstantCanonicalHasher__combine(hash, sign), C.JSNumber_methods.toInt$0((magnitude - Math.abs(intValue)) * 536870912));
        } else if (value == Infinity || value == -Infinity)
          return Z.ConstantCanonicalHasher__combine(6, sign);
        else if (isNaN(value))
          return 7;
        else {
          for (hash = 0; magnitude >= 4294967296;) {
            magnitude /= 4294967296;
            ++hash;
          }
          return Z.ConstantCanonicalHasher__combine(Z.ConstantCanonicalHasher__combine(hash, sign), Z.ConstantCanonicalHasher__hashDouble(magnitude));
        }
      }, ConstantCanonicalHasher__combine: function(hash, value) {
        if (typeof value !== "number")
          return H.iae(value);
        hash = 536870911 & hash + value;
        hash = 536870911 & hash + ((524287 & hash) << 10 >>> 0);
        return hash ^ hash >>> 6;
      }}
  },
  FunctionTypeNamer: {
    "^": "DartTypeVisitor;compiler<,sb",
    get$backend: function() {
      return this.compiler.backend;
    },
    visitType$2: function(type, _) {
      this.sb.write$1(type.get$name(type));
    },
    visitFunctionType$2: function(type, _) {
      var t1, parameter, t2, first;
      if (this.compiler.backend.get$rti().isSimpleFunctionType$1(type)) {
        this.sb.write$1("args" + type.parameterTypes.length);
        return;
      }
      type.returnType.accept$2(0, this, null);
      this.sb.write$1("_");
      for (t1 = type.parameterTypes, t1 = H.setRuntimeTypeInfo(new H.ListIterator(t1, t1.length, 0, null), [H.getTypeArgumentByIndex(t1, 0)]); t1.moveNext$0();) {
        parameter = t1.__internal$_current;
        t2 = this.sb;
        t2.toString;
        t2._contents += "_";
        J.accept$2$x(parameter, this, null);
      }
      for (t1 = type.optionalParameterTypes, t1 = H.setRuntimeTypeInfo(new H.ListIterator(t1, t1.length, 0, null), [H.getTypeArgumentByIndex(t1, 0)]), first = false; t1.moveNext$0(); first = true) {
        parameter = t1.__internal$_current;
        if (!first) {
          t2 = this.sb;
          t2.toString;
          t2._contents += "_";
        }
        t2 = this.sb;
        t2.toString;
        t2._contents += "_";
        J.accept$2$x(parameter, this, null);
      }
      t1 = type.namedParameterTypes;
      t2 = t1.length;
      if (t2 !== 0)
        for (t1 = H.setRuntimeTypeInfo(new H.ListIterator(t1, t2, 0, null), [H.getTypeArgumentByIndex(t1, 0)]), first = false; t1.moveNext$0(); first = true) {
          parameter = t1.__internal$_current;
          if (!first) {
            t2 = this.sb;
            t2.toString;
            t2._contents += "_";
          }
          t2 = this.sb;
          t2.toString;
          t2._contents += "_";
          J.accept$2$x(parameter, this, null);
        }
    },
    $asDartTypeVisitor: function() {
      return [null, null];
    }
  },
  NativeEmitter: {
    "^": "Object;cachedBuilders,emitter,nativeBuffer,nativeClasses,subtypes,directSubtypes,nativeMethods,handleNoSuchMethod",
    get$compiler: function() {
      return this.emitter.compiler;
    },
    get$backend: function() {
      return this.emitter.compiler.backend;
    },
    generateNativeClasses$3: function(classes, mainBuffer, additionalProperties) {
      var preOrder, seen, t1, t2, builders, t3, classElement, neededClasses, nonleafClasses, extensionPoints, neededByConstant, modifiedClasses, builder, needed, quotedName, t4, leafTags, nonleafTags, nativeTags, sufficingInterceptor;
      preOrder = H.setRuntimeTypeInfo([], [O.ClassElement]);
      seen = P.LinkedHashSet_LinkedHashSet(null, null, null, O.ClassElement);
      t1 = this.emitter;
      t2 = t1.compiler;
      seen.add$1(0, t2.objectClass);
      seen.add$1(0, t2.backend.get$jsInterceptorClass());
      H.IterableMixinWorkaround_forEach(classes, new Z.NativeEmitter_generateNativeClasses_walk(preOrder, seen));
      builders = P.LinkedHashMap_LinkedHashMap(null, null, null, O.ClassElement, K.ClassBuilder);
      for (t3 = H.setRuntimeTypeInfo(new H.ListIterator(classes, classes.length, 0, null), [H.getTypeArgumentByIndex(classes, 0)]); t3.moveNext$0();) {
        classElement = t3.__internal$_current;
        if (classElement.get$isNative())
          builders.$indexSet(0, classElement, this.generateNativeClass$1(classElement));
      }
      neededClasses = P.LinkedHashSet_LinkedHashSet(null, null, null, O.ClassElement);
      nonleafClasses = P.LinkedHashSet_LinkedHashSet(null, null, null, O.ClassElement);
      extensionPoints = this.computeExtensionPoints$1(preOrder);
      neededClasses.add$1(0, t2.objectClass);
      neededByConstant = t1.interceptorEmitter.interceptorsReferencedFromConstants$0();
      modifiedClasses = t1.typeTestEmitter.classesModifiedByEmitRuntimeTypeSupport$0();
      for (t3 = H.setRuntimeTypeInfo(new H.ReversedListIterable(preOrder), [H.getTypeArgumentByIndex(H.setRuntimeTypeInfo(new H.IterableMixinWorkaround(), [H.getTypeArgumentByIndex(preOrder, 0)]), 0)]), t3 = H.setRuntimeTypeInfo(new H.ListIterator(t3, t3.get$length(t3), 0, null), [H.getRuntimeTypeArgument(t3, "ListIterable", 0)]); t3.moveNext$0();) {
        classElement = t3.__internal$_current;
        builder = builders.$index(0, classElement);
        if (builder == null)
          needed = true;
        else if (!builder.get$isTrivial())
          needed = true;
        else if (neededByConstant.contains$1(0, classElement))
          needed = true;
        else if (modifiedClasses.contains$1(0, classElement))
          needed = true;
        else
          needed = extensionPoints.containsKey$1(classElement) && true;
        if (classElement.get$isNative()) {
          quotedName = classElement.get$nativeTagInfo();
          t4 = C.JSArray_methods.contains$1(J.substring$2$s(quotedName, 1, quotedName.length - 1).split(","), "!nonleaf");
        } else
          t4 = false;
        if (t4) {
          nonleafClasses.add$1(0, classElement);
          needed = true;
        }
        if (needed || neededClasses.contains$1(0, classElement)) {
          neededClasses.add$1(0, classElement);
          neededClasses.add$1(0, classElement.get$superclass());
          t4 = classElement.supertype;
          nonleafClasses.add$1(0, t4 == null ? null : t4.get$element());
        }
      }
      leafTags = P.LinkedHashMap_LinkedHashMap(null, null, null, O.ClassElement, [P.Set, P.String]);
      nonleafTags = P.LinkedHashMap_LinkedHashMap(null, null, null, O.ClassElement, [P.Set, P.String]);
      for (t3 = H.setRuntimeTypeInfo(new H.ListIterator(classes, classes.length, 0, null), [H.getTypeArgumentByIndex(classes, 0)]); t3.moveNext$0();) {
        classElement = t3.__internal$_current;
        if (!classElement.get$isNative())
          continue;
        nativeTags = L.nativeTagsOfClass(classElement);
        if (nonleafClasses.contains$1(0, classElement) || extensionPoints.containsKey$1(classElement))
          J.addAll$1$ax(nonleafTags.putIfAbsent$2(classElement, new Z.NativeEmitter_generateNativeClasses_closure()), nativeTags);
        else {
          for (sufficingInterceptor = classElement; !neededClasses.contains$1(0, sufficingInterceptor);)
            sufficingInterceptor = sufficingInterceptor.get$superclass();
          t4 = t2.objectClass;
          if (sufficingInterceptor == null ? t4 == null : sufficingInterceptor === t4)
            sufficingInterceptor = t2.backend.get$jsInterceptorClass();
          J.addAll$1$ax(leafTags.putIfAbsent$2(sufficingInterceptor, new Z.NativeEmitter_generateNativeClasses_closure0()), nativeTags);
        }
      }
      if (t2.enqueuer.codegen.nativeEnqueuer.hasInstantiatedNativeClasses$0()) {
        t3 = new Z.NativeEmitter_generateNativeClasses_generateClassInfo(this, additionalProperties, builders, extensionPoints, leafTags, nonleafTags);
        t3.call$1(t2.backend.get$jsInterceptorClass());
        for (t4 = H.setRuntimeTypeInfo(new H.ListIterator(classes, classes.length, 0, null), [H.getTypeArgumentByIndex(classes, 0)]); t4.moveNext$0();)
          t3.call$1(t4.__internal$_current);
      }
      for (t3 = H.setRuntimeTypeInfo(new H.ListIterator(classes, classes.length, 0, null), [H.getTypeArgumentByIndex(classes, 0)]), t4 = t1.classEmitter; t3.moveNext$0();) {
        classElement = t3.__internal$_current;
        if (!classElement.get$isNative())
          continue;
        if (neededClasses.contains$1(0, classElement)) {
          t4.emitClassBuilderWithReflectionData$4(t2.backend.get$namer().getNameX$1(classElement), classElement, builders.$index(0, classElement), t1.getElementDescriptor$1(classElement));
          t1.needsDefineClass = true;
        }
      }
    },
    computeExtensionPoints$1: function(classes) {
      var t1, map, t2, classElement, nativeAncestor;
      t1 = new Z.NativeEmitter_computeExtensionPoints_nativeAncestorOf(new Z.NativeEmitter_computeExtensionPoints_nativeSuperclassOf());
      map = P.LinkedHashMap_LinkedHashMap(null, null, null, O.ClassElement, [P.List, O.ClassElement]);
      for (t2 = H.setRuntimeTypeInfo(new H.ListIterator(classes, classes.length, 0, null), [H.getTypeArgumentByIndex(classes, 0)]); t2.moveNext$0();) {
        classElement = t2.__internal$_current;
        if (classElement.get$isNative())
          continue;
        nativeAncestor = t1.call$1(classElement);
        if (nativeAncestor != null)
          J.add$1$ax(map.putIfAbsent$2(nativeAncestor, new Z.NativeEmitter_computeExtensionPoints_closure()), classElement);
      }
      return map;
    },
    generateNativeClass$1: function(classElement) {
      var t1, t2, t3, builder, t4, t5, t6, superclass, superName, hasFields, propertyCount;
      t1 = this.emitter;
      t2 = t1.compiler;
      if (t2.hasIncrementalSupport) {
        t3 = this.cachedBuilders;
        builder = t3.$index(0, classElement);
        if (builder != null)
          return builder;
        t4 = t2.backend.get$namer();
        t5 = [];
        t5.$builtinTypeInfo = [Q.Property];
        t6 = [];
        t6.$builtinTypeInfo = [P.String];
        builder = new K.ClassBuilder(t5, t6, null, null, null, classElement, t4, false);
        t3.$indexSet(0, classElement, builder);
      } else {
        t3 = t2.backend.get$namer();
        t4 = [];
        t4.$builtinTypeInfo = [Q.Property];
        t5 = [];
        t5.$builtinTypeInfo = [P.String];
        builder = new K.ClassBuilder(t4, t5, null, null, null, classElement, t3, false);
      }
      this.nativeClasses.add$1(0, classElement);
      superclass = classElement.get$superclass();
      t3 = t2.objectClass;
      if (superclass == null ? t3 == null : superclass === t3)
        superclass = t2.backend.get$jsInterceptorClass();
      superName = t2.backend.get$namer().getNameX$1(superclass);
      t2 = t1.classEmitter;
      t2.emitClassConstructor$2(classElement, builder);
      hasFields = t2.emitFields$4$classIsNative(classElement, builder, superName, true);
      t3 = builder.properties;
      propertyCount = t3.length;
      t2.emitClassGettersSetters$2(classElement, builder);
      t2.emitInstanceMembers$2(classElement, builder);
      t1.typeTestEmitter.emitIsTests$2(classElement, builder);
      if (!hasFields && t3.length === propertyCount && !J.getInterceptor(superclass).$isMixinApplicationElement)
        builder.isTrivial = true;
      return builder;
    },
    potentiallyConvertDartClosuresToJs$3: function(statements, member, stubParameters) {
      var parameters, t1, t2, converter;
      parameters = member.get$functionSignature();
      t1 = this.emitter.compiler;
      t2 = t1.backend;
      converter = t2.find$2(0, t2.get$jsHelperLibrary(), "convertDartClosureToJS");
      parameters.forEachParameter$1(new Z.NativeEmitter_potentiallyConvertDartClosuresToJs_closure(this, statements, stubParameters, t1.backend.get$namer().elementAccess$1(converter)));
    },
    isSupertypeOfNativeClass$1: function(element) {
      var t1, t2;
      t1 = element.kind;
      if (t1 === C.ElementKind_type_variable_128)
        this.emitter.compiler.internalError$2(element, "Is check for type variable.");
      t2 = this.emitter.compiler;
      if (!!J.getInterceptor(element.computeType$1(t2).unalias$1(t2)).$isFunctionType)
        return false;
      if (t1 !== C.ElementKind_class_4)
        t2.internalError$2(element, "Is check does not handle element.");
      if (t2.backend.get$classesMixedIntoInterceptedClasses().contains$1(0, element))
        return true;
      return this.subtypes.$index(0, element) != null;
    },
    requiresNativeIsCheck$1: function(element) {
      if (element == null || element.kind !== C.ElementKind_class_4)
        return false;
      if (O.Elements_isNativeOrExtendsNative(element))
        return true;
      return this.isSupertypeOfNativeClass$1(element);
    },
    assembleCode$1: function(targetBuffer) {
      var objectProperties, t1, t2, element, $init;
      objectProperties = H.setRuntimeTypeInfo([], [Q.Property]);
      if (this.nativeClasses._collection$_length !== 0)
        if (this.handleNoSuchMethod)
          this.emitter.nsmEmitter.emitNoSuchMethodHandlers$1(new Z.NativeEmitter_assembleCode_addProperty(objectProperties));
      if (objectProperties.length !== 0) {
        t1 = this.emitter.compiler;
        t2 = t1.backend;
        element = t2.find$2(0, t2.get$jsHelperLibrary(), "defineProperty");
        $init = C.C_JsBuilder.call$2("          (function(table) {\n            for(var key in table)\n              #(Object.prototype, key, table[key]);\n           })(#)", [t1.backend.get$namer().elementAccess$1(element), new Q.ObjectInitializer(objectProperties, true, null, null)]);
        if (t1.enableMinification)
          targetBuffer.write$1(";");
        targetBuffer.write$1(Q.prettyPrint(new Q.ExpressionStatement($init, null, null), t1, true, null));
        targetBuffer.write$1("\n");
      }
      targetBuffer.write$1(this.nativeBuffer);
      targetBuffer.write$1("\n");
    }
  },
  NativeEmitter_generateNativeClasses_walk: {
    "^": "Closure:45;preOrder_0,seen_1",
    call$1: function(element) {
      var t1 = this.seen_1;
      if (t1.contains$1(0, element))
        return;
      t1.add$1(0, element);
      this.call$1(element.get$superclass());
      this.preOrder_0.push(element);
    },
    $isFunction: true
  },
  NativeEmitter_generateNativeClasses_closure: {
    "^": "Closure:23;",
    call$0: function() {
      return P.LinkedHashSet_LinkedHashSet(null, null, null, P.String);
    },
    $isFunction: true
  },
  NativeEmitter_generateNativeClasses_closure0: {
    "^": "Closure:23;",
    call$0: function() {
      return P.LinkedHashSet_LinkedHashSet(null, null, null, P.String);
    },
    $isFunction: true
  },
  NativeEmitter_generateNativeClasses_generateClassInfo: {
    "^": "Closure:45;this_2,additionalProperties_3,builders_4,extensionPoints_5,leafTags_6,nonleafTags_7",
    call$1: function(classElement) {
      var t1, extensions, leafStr, nonleafStr, sb, encoding, builder;
      t1 = new Z.NativeEmitter_generateNativeClasses_generateClassInfo_formatTags();
      extensions = this.extensionPoints_5.$index(0, classElement);
      leafStr = t1.call$1(this.leafTags_6.$index(0, classElement));
      nonleafStr = t1.call$1(this.nonleafTags_7.$index(0, classElement));
      sb = P.StringBuffer$(leafStr);
      if (!J.$eq(nonleafStr, "")) {
        sb.write$1(";");
        sb.write$1(nonleafStr);
      }
      if (extensions != null) {
        sb.write$1(";");
        sb.writeAll$2(J.map$1$ax(extensions, this.this_2.emitter.compiler.backend.get$namer().get$getNameOfClass()), "|");
      }
      encoding = sb._contents;
      builder = this.builders_4.$index(0, classElement);
      if (builder == null) {
        if (encoding !== "")
          J.$indexSet$ax(this.additionalProperties_3.putIfAbsent$2(classElement, new Z.NativeEmitter_generateNativeClasses_generateClassInfo_closure()), this.this_2.emitter.compiler.backend.get$namer().nativeSpecProperty, new Q.LiteralString0("\"" + encoding + "\"", null, null));
      } else
        builder.addProperty$2(this.this_2.emitter.compiler.backend.get$namer().nativeSpecProperty, new Q.LiteralString0("\"" + encoding + "\"", null, null));
    },
    $isFunction: true
  },
  NativeEmitter_generateNativeClasses_generateClassInfo_formatTags: {
    "^": "Closure:209;",
    call$1: function(tags) {
      var t1;
      if (tags == null)
        return "";
      t1 = J.toList$0$ax(tags);
      H.IterableMixinWorkaround_sortList(t1, null);
      return J.join$1$ax(t1, "|");
    },
    $isFunction: true
  },
  NativeEmitter_generateNativeClasses_generateClassInfo_closure: {
    "^": "Closure:23;",
    call$0: function() {
      return P.LinkedHashMap_LinkedHashMap(null, null, null, P.String, Q.Expression);
    },
    $isFunction: true
  },
  NativeEmitter_computeExtensionPoints_nativeSuperclassOf: {
    "^": "Closure:210;",
    call$1: function(element) {
      if (element == null)
        return;
      if (element.get$isNative())
        return element;
      return this.call$1(element.get$superclass());
    },
    $isFunction: true
  },
  NativeEmitter_computeExtensionPoints_nativeAncestorOf: {
    "^": "Closure:210;nativeSuperclassOf_0",
    call$1: function(element) {
      return this.nativeSuperclassOf_0.call$1(element.get$superclass());
    },
    $isFunction: true
  },
  NativeEmitter_computeExtensionPoints_closure: {
    "^": "Closure:23;",
    call$0: function() {
      return H.setRuntimeTypeInfo([], [O.ClassElement]);
    },
    $isFunction: true
  },
  NativeEmitter_potentiallyConvertDartClosuresToJs_closure: {
    "^": "Closure:50;this_0,statements_1,stubParameters_2,closureConverter_3",
    call$1: function(parameter) {
      var t1, $name, t2, t3, t4, type;
      t1 = J.getInterceptor$x(parameter);
      $name = t1.get$name(parameter);
      for (t2 = this.stubParameters_2, t2 = H.setRuntimeTypeInfo(new H.ListIterator(t2, t2.length, 0, null), [H.getTypeArgumentByIndex(t2, 0)]), t3 = this.this_0.emitter.compiler; t2.moveNext$0();) {
        t4 = J.get$name$x(t2.__internal$_current);
        if (t4 == null ? $name == null : t4 === $name) {
          type = t1.get$type(parameter).unalias$1(t3);
          if (!!J.getInterceptor(type).$isFunctionType) {
            this.statements_1.push(C.C_JsBuilder.statement$2("# = #(#, " + type.computeArity$0() + ")", [$name, this.closureConverter_3, $name]));
            break;
          }
        }
      }
    },
    $isFunction: true
  },
  NativeEmitter_assembleCode_addProperty: {
    "^": "Closure:105;objectProperties_0",
    call$2: function($name, value) {
      var prop = new Q.Property(new Q.LiteralString0("\"" + H.S($name) + "\"", null, null), value, null, null);
      this.objectProperties_0.push(prop);
      return prop;
    },
    $isFunction: true
  },
  RuntimeTypes: {
    "^": "Object;compiler<,representationGenerator,rtiDependencies,classesNeedingRti,methodsNeedingRti,classesUsingTypeVariableExpression,checkedTypeArguments,checkedBounds,directlyInstantiatedArguments,allInstantiatedArguments,checkedArguments,usingFactoryWithTypeArguments,cachedRequiredChecks",
    get$backend: function() {
      return this.compiler.backend;
    },
    registerRtiDependency$2: function(element, dependency) {
      if (element.get$kind(element) !== C.ElementKind_class_4 || dependency.get$kind(dependency) !== C.ElementKind_class_4)
        return;
      J.add$1$ax(this.rtiDependencies.putIfAbsent$2(element, new Z.RuntimeTypes_registerRtiDependency_closure()), dependency);
    },
    addImplicitChecks$2: function(universe, classesUsingChecks) {
      var t1, instantiatedTypes, t2, t3, type, $interface, t4, t5, cls, current, instance, t6, t7;
      t1 = J.getInterceptor$asx(classesUsingChecks);
      if (t1.get$isEmpty(classesUsingChecks))
        return;
      instantiatedTypes = universe.instantiatedTypes;
      if (universe.usingFactoryWithTypeArguments)
        for (t1 = H.setRuntimeTypeInfo(new P.LinkedHashSetIterator(instantiatedTypes, instantiatedTypes._modifications, null, null), [null]), t1._cell = t1._set._first, t2 = this.compiler, t3 = universe.isChecks; t1.moveNext$0();) {
          type = t1._collection$_current;
          if (J.get$kind$x(type) !== C.TypeKind_interface)
            continue;
          $interface = type;
          do {
            t4 = $interface.get$typeArguments();
            t5 = new H.ListIterator(t4, t4.length, 0, null);
            t5.$builtinTypeInfo = [H.getTypeArgumentByIndex(t4, 0)];
            for (; t5.moveNext$0();)
              t3.add$1(0, t5.__internal$_current.unalias$1(t2));
            $interface = $interface.get$element().get$supertype();
          } while ($interface != null && !instantiatedTypes.contains$1(0, $interface));
        }
      else
        for (t2 = H.setRuntimeTypeInfo(new P.LinkedHashSetIterator(instantiatedTypes, instantiatedTypes._modifications, null, null), [null]), t2._cell = t2._set._first, t3 = this.compiler, t4 = universe.isChecks; t2.moveNext$0();) {
          type = t2._collection$_current;
          if (J.get$kind$x(type) !== C.TypeKind_interface)
            continue;
          for (t5 = t1.get$iterator(classesUsingChecks); t5.moveNext$0();) {
            cls = t5.get$current();
            current = type;
            do {
              instance = current.asInstanceOf$1(cls);
              if (instance == null)
                break;
              t6 = instance.typeArguments;
              t7 = new H.ListIterator(t6, t6.length, 0, null);
              t7.$builtinTypeInfo = [H.getTypeArgumentByIndex(t6, 0)];
              for (; t7.moveNext$0();)
                t4.add$1(0, t7.__internal$_current.unalias$1(t3));
              current = current.element.get$supertype();
            } while (current != null && !instantiatedTypes.contains$1(0, current));
          }
        }
    },
    computeClassesNeedingRti$0: function() {
      var t1, classesUsingTypeVariableTests, t2, t3;
      t1 = new Z.RuntimeTypes_computeClassesNeedingRti_potentiallyAddForRti(this);
      classesUsingTypeVariableTests = P.LinkedHashSet_LinkedHashSet(null, null, null, O.ClassElement);
      t2 = this.compiler;
      t2.enqueuer.resolution.universe.isChecks.forEach$1(0, new Z.RuntimeTypes_computeClassesNeedingRti_closure(classesUsingTypeVariableTests));
      this.addImplicitChecks$2(t2.enqueuer.resolution.universe, classesUsingTypeVariableTests);
      if (t2.backend.get$jsArrayClass() != null)
        this.registerRtiDependency$2(t2.backend.get$jsArrayClass(), t2.listClass);
      t2.enqueuer.resolution.universe.isChecks.forEach$1(0, new Z.RuntimeTypes_computeClassesNeedingRti_closure0(this, t1));
      if (t2.enableTypeAssertions) {
        t3 = new Z.RuntimeTypes_computeClassesNeedingRti_analyzeMethod(this, t1);
        t2.enqueuer.resolution.universe.genericClosures.forEach$1(0, t3);
        t2.enqueuer.resolution.universe.genericCallMethods.forEach$1(0, t3);
      }
      this.classesUsingTypeVariableExpression.forEach$1(0, t1);
    },
    get$requiredChecks: function() {
      if (this.cachedRequiredChecks == null)
        this.computeRequiredChecks$0();
      return this.cachedRequiredChecks;
    },
    computeChecks$2: function(instantiated, checked) {
      var result, t1, element, t2, t3, superelement;
      result = new Z.TypeCheckMapping(P.LinkedHashMap_LinkedHashMap(null, null, null, O.ClassElement, [P.Set, Z.TypeCheck]));
      for (t1 = H.setRuntimeTypeInfo(new P.LinkedHashSetIterator(instantiated, instantiated._modifications, null, null), [null]), t1._cell = t1._set._first; t1.moveNext$0();) {
        element = t1._collection$_current;
        if (checked.contains$1(0, element))
          result.add$3(0, element, element, null);
        t2 = element.get$allSupertypes();
        t2.toString;
        t3 = new E.LinkIterator(null, t2);
        t3.$builtinTypeInfo = [H.getTypeArgumentByIndex(t2, 0)];
        for (; t3.moveNext$0();) {
          superelement = t3._util_implementation$_current.get$element();
          if (checked.contains$1(0, superelement))
            result.add$3(0, element, superelement, this.computeSubstitution$2(element, superelement));
        }
      }
      return result;
    },
    computeRequiredChecks$0: function() {
      var t1, isChecks, hasFunctionTypeCheck, instantiatedTypesAndClosures;
      t1 = this.compiler;
      isChecks = t1.enqueuer.codegen.universe.isChecks;
      hasFunctionTypeCheck = isChecks.any$1(0, new Z.RuntimeTypes_computeRequiredChecks_closure());
      t1 = t1.enqueuer;
      instantiatedTypesAndClosures = hasFunctionTypeCheck ? this.computeInstantiatedTypesAndClosures$1(t1.codegen.universe) : t1.codegen.universe.instantiatedTypes;
      this.computeInstantiatedArguments$2(instantiatedTypesAndClosures, isChecks);
      this.computeCheckedArguments$2(instantiatedTypesAndClosures, isChecks);
      this.cachedRequiredChecks = this.computeChecks$2(this.allInstantiatedArguments, this.checkedArguments);
    },
    computeInstantiatedTypesAndClosures$1: function(universe) {
      var t1, instantiatedTypes, instantiatedType, type, callType;
      t1 = universe.instantiatedTypes;
      instantiatedTypes = P.LinkedHashSet_LinkedHashSet(null, null, null, V.DartType);
      instantiatedTypes.addAll$1(0, t1);
      for (t1 = H.setRuntimeTypeInfo(new P.LinkedHashSetIterator(t1, t1._modifications, null, null), [null]), t1._cell = t1._set._first; t1.moveNext$0();) {
        instantiatedType = t1._collection$_current;
        if (J.get$kind$x(instantiatedType) === C.TypeKind_interface) {
          type = instantiatedType.element.get$callType();
          callType = type != null && instantiatedType.get$typeArguments().length !== 0 ? type.subst$2(instantiatedType.get$typeArguments(), instantiatedType.get$element().get$typeVariables()) : type;
          if (callType != null)
            instantiatedTypes.add$1(0, callType);
        }
      }
      for (t1 = universe.staticFunctionsNeedingGetter, t1 = H.setRuntimeTypeInfo(new P.LinkedHashSetIterator(t1, t1._modifications, null, null), [null]), t1._cell = t1._set._first; t1.moveNext$0();)
        instantiatedTypes.add$1(0, J.get$type$x(t1._collection$_current));
      for (t1 = this.compiler.enqueuer.resolution.universe.closurizedMembers, t1 = H.setRuntimeTypeInfo(new P.LinkedHashSetIterator(t1, t1._modifications, null, null), [null]), t1._cell = t1._set._first; t1.moveNext$0();)
        instantiatedTypes.add$1(0, J.get$type$x(t1._collection$_current));
      return instantiatedTypes;
    },
    computeInstantiatedArguments$2: function(instantiatedTypes, isChecks) {
      var t1, t2, t3, superCollector, directCollector, functionArgumentCollector, t4;
      t1 = this.compiler;
      t2 = t1.backend;
      t3 = P.LinkedHashSet_LinkedHashSet(null, null, null, O.ClassElement);
      superCollector = new Z.ArgumentCollector(t2, t3);
      directCollector = new Z.ArgumentCollector(t1.backend, P.LinkedHashSet_LinkedHashSet(null, null, null, O.ClassElement));
      functionArgumentCollector = new Z.FunctionArgumentCollector(t1.backend, P.LinkedHashSet_LinkedHashSet(null, null, null, O.ClassElement));
      t1 = new Z.RuntimeTypes_computeInstantiatedArguments_collectFunctionTypeArguments(functionArgumentCollector);
      t1.call$1(isChecks);
      t1.call$1(this.checkedBounds);
      t1 = new Z.RuntimeTypes_computeInstantiatedArguments_collectTypeArguments(superCollector, directCollector);
      t1.call$1(instantiatedTypes);
      t1.call$2$isTypeArgument(this.checkedTypeArguments, true);
      for (t1 = t3.toList$0(0), t1 = H.setRuntimeTypeInfo(new H.ListIterator(t1, t1.length, 0, null), [H.getTypeArgumentByIndex(t1, 0)]); t1.moveNext$0();) {
        t2 = t1.__internal$_current.get$allSupertypes();
        t2.toString;
        t4 = new E.LinkIterator(null, t2);
        t4.$builtinTypeInfo = [H.getTypeArgumentByIndex(t2, 0)];
        for (; t4.moveNext$0();)
          J.accept$2$x(t4._util_implementation$_current, superCollector, false);
      }
      t1 = directCollector.classes;
      t1.addAll$1(0, functionArgumentCollector.classes);
      this.directlyInstantiatedArguments = t1;
      t3.addAll$1(0, t1);
      this.allInstantiatedArguments = t3;
    },
    computeCheckedArguments$2: function(instantiatedTypes, isChecks) {
      var t1, t2, t3, t4;
      t1 = this.compiler;
      t2 = t1.backend;
      t3 = P.LinkedHashSet_LinkedHashSet(null, null, null, O.ClassElement);
      t1 = t1.backend;
      t4 = P.LinkedHashSet_LinkedHashSet(null, null, null, O.ClassElement);
      t1 = new Z.RuntimeTypes_computeCheckedArguments_collectFunctionTypeArguments(new Z.FunctionArgumentCollector(t1, t4));
      t1.call$1(instantiatedTypes);
      t1.call$1(this.checkedTypeArguments);
      t2 = new Z.RuntimeTypes_computeCheckedArguments_collectTypeArguments(new Z.ArgumentCollector(t2, t3));
      t2.call$1(isChecks);
      t2.call$2$isTypeArgument(this.checkedBounds, true);
      t3.addAll$1(0, t4);
      this.checkedArguments = t3;
    },
    getClassesUsedInSubstitutions$2: function(backend, checks) {
      var instantiated, collector, t1, t2, t3, target, result, substitution;
      instantiated = P.LinkedHashSet_LinkedHashSet(null, null, null, O.ClassElement);
      collector = new Z.ArgumentCollector(backend, P.LinkedHashSet_LinkedHashSet(null, null, null, O.ClassElement));
      for (t1 = checks.map, t2 = H.setRuntimeTypeInfo(new P.LinkedHashMapKeyIterable(t1), [H.getTypeArgumentByIndex(t1, 0)]), t3 = t2._map, t2 = H.setRuntimeTypeInfo(new P.LinkedHashMapKeyIterator(t3, t3._modifications, null, null), [H.getTypeArgumentByIndex(t2, 0)]), t2._cell = t2._map._first; t2.moveNext$0();) {
        target = t2._collection$_current;
        instantiated.add$1(0, target);
        result = t1.$index(0, target);
        t3 = J.get$iterator$ax(result != null ? result : C.List_empty6);
        for (; t3.moveNext$0();) {
          substitution = t3.get$current().get$substitution();
          if (substitution != null)
            collector.collectAll$1(substitution.arguments);
        }
      }
      instantiated.addAll$1(0, collector.classes);
      return instantiated;
    },
    getTypeRepresentationForTypeConstant$1: function(type) {
      var namer, t1, $name, $arguments;
      namer = this.compiler.backend.get$namer();
      if (type.get$kind(type) === C.TypeKind_dynamic)
        return namer.getRuntimeTypeName$1(null);
      t1 = type.get$element();
      $name = H.S(namer.globalObjectFor$1(t1)) + "." + H.S(namer.getNameX$1(t1));
      if (type.get$element().kind !== C.ElementKind_class_4)
        return $name;
      t1 = type.get$element().get$typeVariables().length;
      if (t1 === 0)
        return $name;
      $arguments = C.JSArray_methods.join$1(P.List_List$filled(t1, "dynamic", null), ", ");
      return $name + "<" + $arguments + ">";
    },
    isTrivialSubstitution$2: function(cls, check) {
      var type, variables, $arguments, index, t1, t2;
      if (cls.get$isClosure())
        return true;
      if (check.get$typeVariables().length === 0 || cls === check)
        return true;
      type = cls.get$thisType().asInstanceOf$1(check);
      if (type == null)
        return true;
      variables = cls.get$typeVariables();
      $arguments = type.typeArguments;
      if (variables.length !== $arguments.length)
        return false;
      for (index = 0; index < variables.length; ++index) {
        t1 = variables[index].get$element();
        if (index >= $arguments.length)
          return H.ioore($arguments, index);
        t2 = $arguments[index].get$element();
        if (t1 == null ? t2 != null : t1 !== t2)
          return false;
      }
      return true;
    },
    getSupertypeSubstitution$3$alwaysGenerateFunction: function(cls, check, alwaysGenerateFunction) {
      var substitution = this.getSubstitution$2(cls, check);
      if (substitution != null)
        return substitution.getCode$2(this, alwaysGenerateFunction);
      else
        return;
    },
    getSubstitution$2: function(cls, other) {
      var t1, check;
      for (t1 = J.get$iterator$ax(this.cachedRequiredChecks.$index(0, cls)); t1.moveNext$0();) {
        check = t1.get$current();
        if (check.get$cls() === other)
          return check.get$substitution();
      }
      return this.computeSubstitution$2(cls, other);
    },
    computeSubstitution$3$alwaysGenerateFunction: function(cls, check, alwaysGenerateFunction) {
      var target, typeVariables;
      if (this.isTrivialSubstitution$2(cls, check))
        return;
      target = cls.get$thisType().asInstanceOf$1(check);
      typeVariables = cls.get$typeVariables();
      if (typeVariables.length === 0 && !alwaysGenerateFunction)
        return new Z.Substitution(false, target.typeArguments, C.List_empty3);
      else
        return new Z.Substitution(true, target.typeArguments, typeVariables);
    },
    computeSubstitution$2: function(cls, check) {
      return this.computeSubstitution$3$alwaysGenerateFunction(cls, check, false);
    },
    getSubstitutionRepresentation$2: function(types, onVariable) {
      var elements, t1, t2, t3, index, type, representation, index0;
      elements = H.setRuntimeTypeInfo([], [Q.ArrayElement]);
      for (t1 = H.setRuntimeTypeInfo(new H.ListIterator(types, types.length, 0, null), [H.getTypeArgumentByIndex(types, 0)]), t2 = this.representationGenerator, t3 = t2.compiler, index = 0; t1.moveNext$0(); index = index0) {
        type = t1.__internal$_current;
        t2.onVariable = onVariable;
        representation = type.unalias$1(t3).accept$2(0, t2, null);
        t2.onVariable = null;
        index0 = index + 1;
        elements.push(new Q.ArrayElement(index, representation, null, null));
      }
      return new Q.ArrayInitializer(index, elements, null, null);
    },
    getTypeEncoding$2$alwaysGenerateFunction: function(type, alwaysGenerateFunction) {
      var contextClass, encoding, t1;
      contextClass = V.Types_getClassContext(type);
      encoding = this.representationGenerator.getTypeRepresentation$2(type, new Z.RuntimeTypes_getTypeEncoding_onVariable());
      t1 = contextClass == null;
      if (t1 && !alwaysGenerateFunction)
        return encoding;
      else
        return C.C_JsBuilder.call$2("function(#) { return # }", [!t1 ? H.setRuntimeTypeInfo(new H.MappedListIterable(contextClass.get$typeVariables(), new Z.RuntimeTypes_getTypeEncoding_closure()), [null, null]).toList$0(0) : C.List_empty0, encoding]);
    },
    getSignatureEncoding$2: function(type, this_) {
      var contextClass, encoding, backend, contextName;
      contextClass = V.Types_getClassContext(type);
      encoding = this.getTypeEncoding$2$alwaysGenerateFunction(type, true);
      if (contextClass != null) {
        backend = this.compiler.backend;
        contextName = backend.get$namer().getNameX$1(contextClass);
        return C.C_JsBuilder.call$2("function () { return #(#, #, #); }", [backend.namer.elementAccess$1(backend.find$2(0, backend.jsHelperLibrary, "computeSignature")), encoding, this_, new Q.LiteralString0("\"" + H.S(contextName) + "\"", null, null)]);
      } else
        return encoding;
    },
    getTypeRepresentationWithHashes$2: function(type, onVariable) {
      return Q.prettyPrint(this.representationGenerator.getTypeRepresentation$2(type, new Z.RuntimeTypes_getTypeRepresentationWithHashes_closure(onVariable)), this.compiler, true, null).buffer._contents;
    },
    isSimpleFunctionType$1: function(type) {
      var t1 = type.returnType;
      if (t1.get$kind(t1) !== C.TypeKind_dynamic)
        return false;
      if (type.optionalParameterTypes.length !== 0)
        return false;
      if (type.namedParameterTypes.length !== 0)
        return false;
      for (t1 = type.parameterTypes, t1 = H.setRuntimeTypeInfo(new H.ListIterator(t1, t1.length, 0, null), [H.getTypeArgumentByIndex(t1, 0)]); t1.moveNext$0();)
        if (J.get$kind$x(t1.__internal$_current) !== C.TypeKind_dynamic)
          return false;
      return true;
    },
    static: {RuntimeTypes_hasTypeArguments: function(type) {
        if (!!type.$isInterfaceType)
          return !type.get$treatAsRaw();
        return false;
      }, RuntimeTypes_getTypeVariableIndex: function(variable) {
        var variables, index;
        variables = variable.get$enclosingClass().get$typeVariables();
        for (index = 0; index < variables.length; ++index)
          if (variables[index].get$element() === variable)
            return index;
        throw H.wrapException(K.invariant(variable, false, "Couldn't find type-variable index"));
      }}
  },
  RuntimeTypes_registerRtiDependency_closure: {
    "^": "Closure:23;",
    call$0: function() {
      return P.LinkedHashSet_LinkedHashSet(null, null, null, O.ClassElement);
    },
    $isFunction: true
  },
  RuntimeTypes_computeClassesNeedingRti_potentiallyAddForRti: {
    "^": "Closure:45;this_0",
    call$1: function(cls) {
      var t1, t2, classes, dependencies;
      if (cls.get$typeVariables().length === 0)
        return;
      t1 = this.this_0;
      t2 = t1.classesNeedingRti;
      if (t2.contains$1(0, cls))
        return;
      t2.add$1(0, cls);
      classes = t1.compiler.world._subtypes.$index(0, cls.get$declaration());
      if (classes != null)
        J.forEach$1$ax(classes, new Z.RuntimeTypes_computeClassesNeedingRti_potentiallyAddForRti_closure(this));
      dependencies = t1.rtiDependencies.$index(0, cls);
      if (dependencies != null)
        J.forEach$1$ax(dependencies, new Z.RuntimeTypes_computeClassesNeedingRti_potentiallyAddForRti_closure0(this));
    },
    $isFunction: true
  },
  RuntimeTypes_computeClassesNeedingRti_potentiallyAddForRti_closure: {
    "^": "Closure:87;potentiallyAddForRti_1",
    call$1: function(sub) {
      this.potentiallyAddForRti_1.call$1(sub);
    },
    $isFunction: true
  },
  RuntimeTypes_computeClassesNeedingRti_potentiallyAddForRti_closure0: {
    "^": "Closure:87;potentiallyAddForRti_2",
    call$1: function(other) {
      this.potentiallyAddForRti_2.call$1(other);
    },
    $isFunction: true
  },
  RuntimeTypes_computeClassesNeedingRti_closure: {
    "^": "Closure:123;classesUsingTypeVariableTests_3",
    call$1: function(type) {
      if (J.get$kind$x(type) === C.TypeKind_kuk)
        this.classesUsingTypeVariableTests_3.add$1(0, type.get$element().get$enclosingElement());
    },
    $isFunction: true
  },
  RuntimeTypes_computeClassesNeedingRti_closure0: {
    "^": "Closure:123;this_4,potentiallyAddForRti_5",
    call$1: function(type) {
      var t1, contextClass, t2;
      t1 = J.getInterceptor$x(type);
      if (t1.get$kind(type) === C.TypeKind_interface) {
        if (!type.get$treatAsRaw())
          this.potentiallyAddForRti_5.call$1(type.get$element());
      } else {
        contextClass = V.Types_getClassContext(type);
        if (contextClass != null)
          this.potentiallyAddForRti_5.call$1(contextClass);
        if (t1.get$kind(type) === C.TypeKind_function) {
          t1 = this.this_4;
          t2 = new Z.RuntimeTypes_computeClassesNeedingRti__analyzeMethod(t1, this.potentiallyAddForRti_5, type);
          t1 = t1.compiler;
          t1.enqueuer.resolution.universe.genericClosures.forEach$1(0, t2);
          t1.enqueuer.resolution.universe.genericCallMethods.forEach$1(0, t2);
        }
      }
    },
    $isFunction: true
  },
  RuntimeTypes_computeClassesNeedingRti__analyzeMethod: {
    "^": "Closure:211;this_6,potentiallyAddForRti_7,type_8",
    call$1: function(method) {
      var memberType, contextClass;
      memberType = J.get$type$x(method);
      contextClass = V.Types_getClassContext(memberType);
      if (contextClass != null && this.this_6.compiler.types.potentialSubtypeVisitor.isSubtype$2(memberType, this.type_8)) {
        this.potentiallyAddForRti_7.call$1(contextClass);
        this.this_6.methodsNeedingRti.add$1(0, method);
      }
    },
    $isFunction: true
  },
  RuntimeTypes_computeClassesNeedingRti_analyzeMethod: {
    "^": "Closure:211;this_9,potentiallyAddForRti_10",
    call$1: function(method) {
      var contextClass = V.Types_getClassContext(J.get$type$x(method));
      if (contextClass != null) {
        this.potentiallyAddForRti_10.call$1(contextClass);
        this.this_9.methodsNeedingRti.add$1(0, method);
      }
    },
    $isFunction: true
  },
  RuntimeTypes_computeRequiredChecks_closure: {
    "^": "Closure:13;",
    call$1: function(type) {
      return J.get$kind$x(type) === C.TypeKind_function;
    },
    $isFunction: true
  },
  RuntimeTypes_computeInstantiatedArguments_collectFunctionTypeArguments: {
    "^": "Closure:212;functionArgumentCollector_0",
    call$1: function(types) {
      var t1, t2;
      for (t1 = H.setRuntimeTypeInfo(new P.LinkedHashSetIterator(types, types._modifications, null, null), [null]), t1._cell = t1._set._first, t2 = this.functionArgumentCollector_0; t1.moveNext$0();)
        J.accept$2$x(t1._collection$_current, t2, false);
    },
    $isFunction: true
  },
  RuntimeTypes_computeInstantiatedArguments_collectTypeArguments: {
    "^": "Closure:213;superCollector_1,directCollector_2",
    call$2$isTypeArgument: function(types, isTypeArgument) {
      var t1, t2, t3, type, t4, t5;
      for (t1 = H.setRuntimeTypeInfo(new P.LinkedHashSetIterator(types, types._modifications, null, null), [null]), t1._cell = t1._set._first, t2 = this.directCollector_2, t3 = this.superCollector_1; t1.moveNext$0();) {
        type = t1._collection$_current;
        t4 = J.getInterceptor$x(type);
        t4.accept$2(type, t2, isTypeArgument);
        if (t4.get$kind(type) === C.TypeKind_interface) {
          t4 = type.get$element().get$allSupertypes();
          t4.toString;
          t5 = new E.LinkIterator(null, t4);
          t5.$builtinTypeInfo = [H.getTypeArgumentByIndex(t4, 0)];
          for (; t5.moveNext$0();)
            J.accept$2$x(t5._util_implementation$_current, t3, isTypeArgument);
        }
      }
    },
    call$1: function(types) {
      return this.call$2$isTypeArgument(types, false);
    },
    $isFunction: true
  },
  RuntimeTypes_computeCheckedArguments_collectFunctionTypeArguments: {
    "^": "Closure:212;functionArgumentCollector_0",
    call$1: function(types) {
      var t1, t2;
      for (t1 = H.setRuntimeTypeInfo(new P.LinkedHashSetIterator(types, types._modifications, null, null), [null]), t1._cell = t1._set._first, t2 = this.functionArgumentCollector_0; t1.moveNext$0();)
        J.accept$2$x(t1._collection$_current, t2, false);
    },
    $isFunction: true
  },
  RuntimeTypes_computeCheckedArguments_collectTypeArguments: {
    "^": "Closure:213;collector_1",
    call$2$isTypeArgument: function(types, isTypeArgument) {
      var t1, t2;
      for (t1 = H.setRuntimeTypeInfo(new P.LinkedHashSetIterator(types, types._modifications, null, null), [null]), t1._cell = t1._set._first, t2 = this.collector_1; t1.moveNext$0();)
        J.accept$2$x(t1._collection$_current, t2, isTypeArgument);
    },
    call$1: function(types) {
      return this.call$2$isTypeArgument(types, false);
    },
    $isFunction: true
  },
  RuntimeTypes_getTypeEncoding_onVariable: {
    "^": "Closure:214;",
    call$1: function(v) {
      return new Q.VariableUse(v.get$element().name, null, null);
    },
    $isFunction: true
  },
  RuntimeTypes_getTypeEncoding_closure: {
    "^": "Closure:13;",
    call$1: function(type) {
      return J.toString$0(type);
    },
    $isFunction: true
  },
  RuntimeTypes_getTypeRepresentationWithHashes_closure: {
    "^": "Closure:13;onVariable_0",
    call$1: function(variable) {
      this.onVariable_0.call$1(variable);
      return new Q.LiteralString0("#", null, null);
    },
    $isFunction: true
  },
  TypeRepresentationGenerator: {
    "^": "DartTypeVisitor;compiler<,onVariable",
    onVariable$1: function(arg0) {
      return this.onVariable.call$1(arg0);
    },
    get$backend: function() {
      return this.compiler.backend;
    },
    getTypeRepresentation$2: function(type, onVariable) {
      var representation;
      this.onVariable = onVariable;
      representation = type.unalias$1(this.compiler).accept$2(0, this, null);
      this.onVariable = null;
      return representation;
    },
    visitTypeVariableType$2: function(type, _) {
      return this.onVariable$1(type);
    },
    visitDynamicType$2: function(type, _) {
      return C.C_JsBuilder.call$1("null");
    },
    visitInterfaceType$2: function(type, _) {
      var t1, $name;
      t1 = type.element;
      $name = this.compiler.backend.get$namer().elementAccess$1(t1);
      return type.get$treatAsRaw() ? $name : this.visitList$2$head(type.typeArguments, $name);
    },
    visitList$2$head: function(types, head) {
      var elements, index, t1, t2, index0;
      elements = H.setRuntimeTypeInfo([], [Q.ArrayElement]);
      if (head != null) {
        elements.push(new Q.ArrayElement(0, head, null, null));
        index = 1;
      } else
        index = 0;
      for (t1 = H.setRuntimeTypeInfo(new H.ListIterator(types, types.length, 0, null), [H.getTypeArgumentByIndex(types, 0)]), t2 = this.compiler; t1.moveNext$0(); index = index0) {
        index0 = index + 1;
        elements.push(new Q.ArrayElement(index, t1.__internal$_current.unalias$1(t2).accept$2(0, this, null), null, null));
      }
      return new Q.ArrayInitializer(elements.length, elements, null, null);
    },
    visitList$1: function(types) {
      return this.visitList$2$head(types, null);
    },
    visitFunctionType$2: function(type, _) {
      var properties, t1, t2, t3, namedArguments, names, index, t4;
      properties = H.setRuntimeTypeInfo([], [Q.Property]);
      t1 = new Z.TypeRepresentationGenerator_visitFunctionType_addProperty(properties);
      t2 = this.compiler;
      t3 = "\"" + H.S(t2.backend.get$namer().getFunctionTypeName$1(type)) + "\"";
      t2.backend.get$namer();
      t1.call$2("func", new Q.LiteralString0(t3, null, null));
      t3 = type.returnType;
      if (t3.get$kind(t3) === C.TypeKind_void) {
        t2.backend.get$namer();
        t1.call$2("void", C.C_JsBuilder.call$1("true"));
      } else if (!t3.get$treatAsDynamic()) {
        t2.backend.get$namer();
        t1.call$2("ret", t3.unalias$1(t2).accept$2(0, this, null));
      }
      t3 = type.parameterTypes;
      if (t3.length !== 0) {
        t2.backend.get$namer();
        t1.call$2("args", this.visitList$1(t3));
      }
      t3 = type.optionalParameterTypes;
      if (t3.length !== 0) {
        t2.backend.get$namer();
        t1.call$2("opt", this.visitList$1(t3));
      }
      t3 = type.namedParameterTypes;
      if (t3.length !== 0) {
        namedArguments = H.setRuntimeTypeInfo([], [Q.Property]);
        names = type.namedParameters;
        for (index = 0; index < t3.length; ++index) {
          if (index >= names.length)
            return H.ioore(names, index);
          t4 = "\"" + H.S(names[index]) + "\"";
          if (index >= t3.length)
            return H.ioore(t3, index);
          namedArguments.push(new Q.Property(new Q.LiteralString0(t4, null, null), t3[index].unalias$1(t2).accept$2(0, this, null), null, null));
        }
        t2.backend.get$namer();
        t1.call$2("named", new Q.ObjectInitializer(namedArguments, true, null, null));
      }
      return new Q.ObjectInitializer(properties, true, null, null);
    },
    visitMalformedType$2: function(type, _) {
      return C.C_JsBuilder.call$1("null");
    },
    visitVoidType$2: function(type, _) {
      return C.C_JsBuilder.call$1("null");
    },
    visitType$2: function(type, _) {
      this.compiler.internalError$2(C._SpannableSentinel_fBD, "Unexpected type: " + type.toString$0(0) + " (" + type.get$kind(type).id + ").");
    },
    $asDartTypeVisitor: function() {
      return [null, null];
    }
  },
  TypeRepresentationGenerator_visitFunctionType_addProperty: {
    "^": "Closure:215;properties_0",
    call$2: function($name, value) {
      this.properties_0.push(new Q.Property(new Q.LiteralString0("\"" + $name + "\"", null, null), value, null, null));
    },
    $isFunction: true
  },
  TypeCheckMapping: {
    "^": "Object;map",
    map$1: function($receiver, arg0) {
      return this.map.call$1(arg0);
    },
    $index: function(_, element) {
      var result = this.map.$index(0, element);
      return result != null ? result : C.List_empty6;
    },
    add$3: function(_, cls, check, substitution) {
      var t1, t2;
      t1 = this.map;
      t1.putIfAbsent$2(cls, new Z.TypeCheckMapping_add_closure());
      t1 = t1.$index(0, cls);
      t2 = $.TypeCheck_nextHash;
      $.TypeCheck_nextHash = t2 + 1;
      J.add$1$ax(t1, new Z.TypeCheck(check, substitution, t2 & 1073741823));
    },
    get$iterator: function(_) {
      var t1, t2;
      t1 = this.map;
      t1 = H.setRuntimeTypeInfo(new P.LinkedHashMapKeyIterable(t1), [H.getTypeArgumentByIndex(t1, 0)]);
      t2 = t1._map;
      t1 = H.setRuntimeTypeInfo(new P.LinkedHashMapKeyIterator(t2, t2._modifications, null, null), [H.getTypeArgumentByIndex(t1, 0)]);
      t1._cell = t1._map._first;
      return t1;
    },
    toString$0: function(_) {
      var sb, t1, t2, holder, t3, check, t4;
      sb = P.StringBuffer$("");
      for (t1 = this.map, t1 = H.setRuntimeTypeInfo(new P.LinkedHashMapKeyIterable(t1), [H.getTypeArgumentByIndex(t1, 0)]), t2 = t1._map, t1 = H.setRuntimeTypeInfo(new P.LinkedHashMapKeyIterator(t2, t2._modifications, null, null), [H.getTypeArgumentByIndex(t1, 0)]), t1._cell = t1._map._first; t1.moveNext$0();) {
        holder = t1._collection$_current;
        t2 = [holder];
        t3 = new H.ListIterator(t2, 1, 0, null);
        t3.$builtinTypeInfo = [H.getTypeArgumentByIndex(t2, 0)];
        t2 = J.getInterceptor$x(holder);
        for (; t3.moveNext$0();) {
          check = t3.__internal$_current;
          t4 = H.S(t2.get$name(holder)) + "." + H.S(J.get$name$x(check)) + ", ";
          sb._contents += t4;
        }
      }
      return "[" + H.S(sb) + "]";
    }
  },
  TypeCheckMapping_add_closure: {
    "^": "Closure:23;",
    call$0: function() {
      return P.LinkedHashSet_LinkedHashSet(null, null, null, Z.TypeCheck);
    },
    $isFunction: true
  },
  ArgumentCollector: {
    "^": "DartTypeVisitor;backend<,classes",
    collectAll$1: function(types) {
      var t1;
      for (t1 = H.setRuntimeTypeInfo(new H.ListIterator(types, types.length, 0, null), [H.getTypeArgumentByIndex(types, 0)]); t1.moveNext$0();)
        J.accept$2$x(t1.__internal$_current, this, true);
    },
    visitType$2: function(type, _) {
    },
    visitDynamicType$2: function(type, _) {
    },
    visitTypedefType$2: function(type, isTypeArgument) {
      type.unalias$1(this.backend.compiler).accept$2(0, this, isTypeArgument);
    },
    visitInterfaceType$2: function(type, isTypeArgument) {
      if (isTypeArgument === true)
        this.classes.add$1(0, type.element);
      V.DartType_visitList(type.typeArguments, this, true);
    },
    visitFunctionType$2: function(type, _) {
      type.visitChildren$2(this, true);
    },
    $asDartTypeVisitor: function() {
      return [null, null];
    }
  },
  FunctionArgumentCollector: {
    "^": "DartTypeVisitor;backend<,classes",
    visitType$2: function(type, _) {
    },
    visitDynamicType$2: function(type, _) {
    },
    visitTypedefType$2: function(type, inFunctionType) {
      type.unalias$1(this.backend.compiler).accept$2(0, this, inFunctionType);
    },
    visitInterfaceType$2: function(type, inFunctionType) {
      if (inFunctionType === true)
        this.classes.add$1(0, type.element);
      V.DartType_visitList(type.typeArguments, this, inFunctionType);
    },
    visitFunctionType$2: function(type, _) {
      type.visitChildren$2(this, true);
    },
    $asDartTypeVisitor: function() {
      return [null, null];
    }
  },
  Substitution: {
    "^": "Object;isFunction<,arguments<,parameters<",
    getCode$2: function(rti, ensureIsFunction) {
      var value = rti.getSubstitutionRepresentation$2(this.arguments, new Z.Substitution_getCode_use(rti));
      if (this.isFunction)
        return C.C_JsBuilder.call$2("function(#) { return # }", [H.setRuntimeTypeInfo(new H.MappedListIterable(this.parameters, new Z.Substitution_getCode_declaration(rti)), [null, null]), value]);
      else if (ensureIsFunction)
        return C.C_JsBuilder.call$2("function() { return # }", value);
      else
        return value;
    }
  },
  Substitution_getCode_declaration: {
    "^": "Closure:214;rti_0",
    call$1: function(variable) {
      var t1 = this.rti_0.compiler.backend.get$namer();
      return new Q.Parameter(t1._safeName$2(variable.get$element().name, t1.get$jsVariableReserved()), null, null);
    },
    $isFunction: true
  },
  Substitution_getCode_use: {
    "^": "Closure:214;rti_1",
    call$1: function(variable) {
      var t1 = this.rti_1.compiler.backend.get$namer();
      return new Q.VariableUse(t1._safeName$2(variable.get$element().name, t1.get$jsVariableReserved()), null, null);
    },
    $isFunction: true
  },
  TypeCheck: {
    "^": "Object;cls<,substitution<,hashCode>",
    static: {"^": "TypeCheck_nextHash"}
  },
  TypeVariableHandler: {
    "^": "Object;backend<,typeVariableConstructor,evaluator,typeVariableClasses,typeVariables<,typeVariableConstants",
    get$compiler: function() {
      return this.backend.compiler;
    },
    processTypeVariablesOf$1: function(cls) {
      var typeVariableType, constants, t1, t2, currentTypeVariable, t3, c, t4, printer, $name, index;
      if (!this.backend.referencedFromMirrorSystem$1(cls) && new Z.TypeVariableHandler_processTypeVariablesOf_hasMemberNeededForReflection(this).call$1(cls) !== true)
        return;
      typeVariableType = this.backend.typeVariableClass.get$thisType();
      constants = H.setRuntimeTypeInfo([], [P.$int]);
      for (t1 = cls.get$typeVariables(), t1 = H.setRuntimeTypeInfo(new H.ListIterator(t1, t1.length, 0, null), [H.getTypeArgumentByIndex(t1, 0)]), t2 = this.typeVariableConstants; t1.moveNext$0();) {
        currentTypeVariable = t1.__internal$_current;
        t3 = this.backend;
        c = K.CompileTimeConstantEvaluator_makeConstructedConstant(t3.compiler, t3.constantCompilerTask.jsConstantCompiler, currentTypeVariable.get$element(), typeVariableType, this.typeVariableConstructor, new Z.TypeVariableHandler_processTypeVariablesOf_createArguments(this, cls, currentTypeVariable), false);
        t3 = this.backend;
        t3.registerCompileTimeConstant$2(c, t3.compiler.globalDependencies);
        this.backend.constantCompilerTask.jsConstantCompiler.compiledConstants.add$1(0, c);
        t3 = currentTypeVariable.get$element();
        t4 = this.backend.emitter.constantEmitter._referenceEmitter;
        t4.toString;
        t4 = c.accept$1(0, t4);
        printer = Q.Printer$(this.backend.compiler, null, true);
        printer.visit$1(t4);
        $name = printer.outBuffer.buffer._contents;
        if (t2.containsKey$1(t3)) {
          index = t2.$index(0, t3);
          t3 = this.backend.emitter.metadataEmitter.globalMetadata;
          if (index >>> 0 !== index || index >= t3.length)
            return H.ioore(t3, index);
          t3[index] = $name;
        } else {
          index = this.backend.emitter.metadataEmitter.addGlobalMetadata$1($name);
          t2.$indexSet(0, t3, index);
        }
        constants.push(index);
      }
      this.typeVariables.$indexSet(0, cls, constants);
    },
    onTreeShakingDisabled$1: function(enqueuer) {
      var t1, constructors, t2;
      if (enqueuer.get$isResolutionQueue()) {
        t1 = this.backend;
        t1.enqueueClass$3(enqueuer, t1.typeVariableClass, t1.compiler.globalDependencies);
        t1 = this.backend;
        t1.typeVariableClass.ensureResolved$1(t1.compiler);
        constructors = this.backend.typeVariableClass.get$constructors();
        if (constructors.get$isEmpty(constructors)) {
          t1 = constructors.get$tail();
          t1 = t1.get$isEmpty(t1);
        } else
          t1 = false;
        if (t1) {
          t1 = this.backend;
          t2 = t1.typeVariableClass;
          t1.compiler.internalError$2(t2, "Class '" + J.toString$0(t2) + "' should only have one constructor");
        }
        t1 = this.backend.typeVariableClass.get$constructors();
        t1 = t1.get$head(t1);
        this.typeVariableConstructor = t1;
        t2 = this.backend;
        t2.enqueueInResolution$2(t1, t2.compiler.globalDependencies);
        enqueuer.registerInstantiatedType$2(this.backend.typeVariableClass.get$rawType(), this.backend.compiler.globalDependencies);
        t2 = this.backend;
        enqueuer.registerStaticUse$1(t2.find$2(0, t2.jsHelperLibrary, "createRuntimeType"));
      } else {
        t1 = this.typeVariableClasses;
        if (t1 != null) {
          this.typeVariableClasses = null;
          t1.toString;
          H.IterableMixinWorkaround_forEach(t1, new Z.TypeVariableHandler_onTreeShakingDisabled_closure(this));
        }
      }
    },
    reifyTypeVariable$1: function(variable) {
      var t1, t2;
      t1 = this.typeVariableConstants;
      if (t1.containsKey$1(variable))
        return t1.$index(0, variable);
      this.backend.emitter.metadataEmitter.globalMetadata.push("\"Placeholder for " + J.toString$0(variable) + "\"");
      t2 = this.backend.emitter.metadataEmitter.globalMetadata.length - 1;
      t1.$indexSet(0, variable, t2);
      return t2;
    }
  },
  TypeVariableHandler_processTypeVariablesOf_hasMemberNeededForReflection: {
    "^": "Closure:216;this_1",
    call$1: function(cls) {
      var t1 = {};
      t1.result_0 = false;
      cls.get$implementation(cls).forEachMember$1(new Z.TypeVariableHandler_processTypeVariablesOf_hasMemberNeededForReflection_closure(t1, this.this_1));
      return t1.result_0;
    },
    $isFunction: true
  },
  TypeVariableHandler_processTypeVariablesOf_hasMemberNeededForReflection_closure: {
    "^": "Closure:74;box_0,this_2",
    call$2: function(cls, member) {
      var t1 = this.box_0;
      t1.result_0 = t1.result_0 || this.this_2.backend.referencedFromMirrorSystem$1(member);
    },
    $isFunction: true
  },
  TypeVariableHandler_processTypeVariablesOf_createArguments: {
    "^": "Closure:73;this_3,cls_4,currentTypeVariable_5",
    call$1: function($constructor) {
      var t1, t2, t3, $name, bound;
      t1 = this.this_3;
      t2 = t1.typeVariableConstructor;
      if ($constructor == null ? t2 != null : $constructor !== t2)
        t1.backend.compiler.internalError$2(this.currentTypeVariable_5.element, "Unexpected constructor " + J.toString$0($constructor));
      t2 = t1.backend.constantCompilerTask.jsConstantCompiler;
      t3 = this.currentTypeVariable_5.element;
      $name = t2.constantSystem.createString$1(new Y.LiteralDartString(t3.name));
      t2 = t1.backend;
      bound = t2.constantCompilerTask.jsConstantCompiler.constantSystem.createInt$1(t2.emitter.metadataEmitter.reifyType$1(t3.get$bound()));
      t1 = t1.backend.constantCompilerTask.jsConstantCompiler.compiler;
      return [new K.TypeConstant(this.cls_4.get$rawType(), t1.backend.get$typeImplementation().computeType$1(t1)), $name, bound];
    },
    $isFunction: true
  },
  TypeVariableHandler_onTreeShakingDisabled_closure: {
    "^": "Closure:13;this_0",
    call$1: function(cls) {
      return this.this_0.processTypeVariablesOf$1(cls);
    },
    $isFunction: true
  }
}],
["leg_apiimpl", "package:compiler/implementation/apiimpl.dart", , S, {
  "^": "",
  Compiler: {
    "^": "Compiler0;provider,handler,libraryRoot,packageRoot,options,environment<,mockableLibraryUsed,allowedLibraryCategories,totalCompileTime,nextFreeClassId,world,assembledCode,types,cacheStrategy,commentMap,globalDependencies,mirrorDependencies,enableMinification,enableTypeAssertions,enableUserAssertions,trustTypeAnnotations,enableConcreteTypeInference,disableTypeInferenceFlag,dumpInfo,useContentSecurityPolicy,maxConcreteTypeSize,analyzeAllFlag,analyzeOnly,analyzeMain,analyzeSignaturesOnly,enableNativeLiveTypeAnalysis,stopAfterTypeInference,preserveComments,verbose,sourceMapUri,outputUri,terseDiagnostics,showPackageWarnings,lastDiagnosticWasFiltered,suppressedWarnings,suppressWarnings,hasIncrementalSupport,outputProvider,disableInlining,compilerWasCancelled,librariesToAnalyzeWhenRun,tracer,measuredTask,_currentElement,coreLibrary,mainApp,mainFunction,mirrorsLibrary,typedDataLibrary,objectClass,boolClass,numClass,intClass,doubleClass,stringClass,functionClass,nullClass,listClass,typeClass,mapClass,symbolClass,stackTraceClass,typedDataClass,proxyConstant,patchConstant,nativeAnnotationClass,symbolConstructor,mirrorSystemClass,mirrorsUsedClass,mirrorSystemGetNameFunction,symbolImplementationClass,symbolValidatedConstructor,mirrorsUsedConstructor,deferredLibraryClass,documentClass,identicalFunction,loadLibraryFunction,functionApplyMethod,intEnvironment,boolEnvironment,stringEnvironment,tasks,scanner,dietParser,parser,patchParser,libraryLoader,validator,resolver,closureToClassMapper,checker,irBuilder,typesTask,backend,constants,enqueuer,deferredLoadTask,mirrorUsageAnalyzerTask,dumpInfoTask,buildId,enqueuerFilter,iteratorSelector,currentSelector,moveNextSelector,noSuchMethodSelector,symbolValidatedConstructorSelector,fromEnvironmentSelector,enabledNoSuchMethod,enabledRuntimeType,enabledFunctionApply,enabledInvokeOn,hasIsolateSupport,progress,phase,compilationFailed,hasCrashed,disableTypeInferenceForMirrors,_unnamedListConstructor,_filledListConstructor",
    provider$1: function(arg0) {
      return this.provider.call$1(arg0);
    },
    handler$5: function(arg0, arg1, arg2, arg3, arg4) {
      return this.handler.call$5(arg0, arg1, arg2, arg3, arg4);
    },
    lookupLibraryPath$1: function(dartLibraryName) {
      var info, path;
      info = C.Map_or8xz.$index(0, dartLibraryName);
      if (info == null)
        return;
      if ((info.platforms & 1) === 0)
        return;
      if (!this.allowedLibraryCategories.contains$1(0, info.category))
        return;
      path = info.dart2jsPath;
      return "lib/" + H.S(path == null ? info.path : path);
    },
    lookupPatchPath$1: function(dartLibraryName) {
      var info, path;
      info = C.Map_or8xz.$index(0, dartLibraryName);
      if (info == null)
        return;
      if ((info.platforms & 1) === 0)
        return;
      path = info.dart2jsPatchPath;
      if (path == null)
        return;
      return "lib/" + path;
    },
    log$1: [function(message) {
      this.handler$5(null, null, null, message, C.Diagnostic_kiE);
    }, "call$1", "get$log", 2, 0, 8],
    translateResolvedUri$3: function(importingLibrary, resolvedUri, node) {
      if (resolvedUri.scheme === "dart")
        return this.translateDartUri$3(importingLibrary, resolvedUri, node);
      return resolvedUri;
    },
    readScript$2: function(node, readableUri) {
      var t1, t2, resourceUri;
      t1 = {};
      t1.node_0 = node;
      if (readableUri.scheme !== "") {
        t2 = readableUri._fragment;
        t2 = (t2 == null ? "" : t2) === "";
      } else
        t2 = false;
      if (!t2) {
        if (node == null) {
          t1.node_0 = C._SpannableSentinel_fBD;
          t2 = C._SpannableSentinel_fBD;
        } else
          t2 = node;
        this.internalError$2(t2, "Relative uri " + readableUri.toString$0(0) + " provided to readScript(Uri).");
      }
      t2 = new S.Compiler_readScript_reportReadError(t1, this, readableUri, this._currentElement);
      resourceUri = this.translateUri$2(t1.node_0, readableUri);
      return P.Future_Future$sync(new S.Compiler_readScript_closure(this, resourceUri), null).then$1(new S.Compiler_readScript_closure0(readableUri, t2, resourceUri)).catchError$1(new S.Compiler_readScript_closure1(t2));
    },
    translateUri$2: function(node, readableUri) {
      switch (readableUri.scheme) {
        case "package":
          return this.packageRoot.resolveUri$1(P.Uri_parse(readableUri._path));
        default:
          return readableUri;
      }
    },
    translateDartUri$3: function(importingLibrary, resolvedUri, node) {
      var t1, libraryInfo, path, t2, t3, allowInternalLibraryAccess;
      t1 = resolvedUri._path;
      libraryInfo = C.Map_or8xz.$index(0, t1);
      path = this.lookupLibraryPath$1(t1);
      if (libraryInfo != null && libraryInfo.category === "Internal") {
        t2 = importingLibrary != null;
        if (t2) {
          t3 = importingLibrary.canonicalUri;
          if (t3.scheme === "dart" || importingLibrary.get$isPatch())
            allowInternalLibraryAccess = true;
          else
            allowInternalLibraryAccess = C.JSString_methods.contains$1(t3._path, "dart/tests/compiler/dart2js_native") && true;
        } else
          allowInternalLibraryAccess = false;
        if (!allowInternalLibraryAccess)
          if (t2)
            this.reportDiagnosticInternal$4(node, C.MessageKind_ocl, P.LinkedHashMap_LinkedHashMap$_literal(["resolvedUri", resolvedUri, "importingUri", importingLibrary.canonicalUri], null, null), C.Diagnostic_1_error);
          else
            this.reportDiagnosticInternal$4(node, C.MessageKind_mJ10, P.LinkedHashMap_LinkedHashMap$_literal(["resolvedUri", resolvedUri], null, null), C.Diagnostic_1_error);
      }
      if (path == null) {
        this.reportDiagnosticInternal$4(node, C.MessageKind_yFk, P.LinkedHashMap_LinkedHashMap$_literal(["resolvedUri", resolvedUri], null, null), C.Diagnostic_1_error);
        return;
      }
      if (t1 === "html" || t1 === "io")
        this.mockableLibraryUsed = true;
      return this.libraryRoot.resolveUri$1(P.Uri_parse(path));
    },
    resolvePatchUri$1: function(dartLibraryPath) {
      var patchPath = this.lookupPatchPath$1(dartLibraryPath);
      if (patchPath == null)
        return;
      return this.libraryRoot.resolveUri$1(P.Uri_parse(patchPath));
    },
    run$1: function(uri) {
      this.handler$5(null, null, null, "Allowed library categories: " + P.IterableBase_iterableToFullString(this.allowedLibraryCategories, "{", "}"), C.Diagnostic_kiE);
      return K.Compiler0.prototype.run$1.call(this, uri).then$1(new S.Compiler_run_closure(this));
    },
    reportDiagnostic$3: function(node, message, kind) {
      var span = this.spanFromSpannable$1(node);
      if (kind === C.Diagnostic_1_error || kind === C.Diagnostic_32_crash)
        this.compilationFailed = true;
      if (span == null || span.uri == null)
        this.callUserHandler$5(null, null, null, message.computeMessage$0(), kind);
      else
        this.callUserHandler$5(this.translateUri$2(null, span.uri), span.begin, span.end, message.computeMessage$0(), kind);
    },
    get$isMockCompilation: function() {
      return this.mockableLibraryUsed && J.indexOf$1$asx(this.options, "--allow-mock-compilation") !== -1;
    },
    callUserHandler$5: function(uri, begin, end, message, kind) {
      var ex, s, exception, t1;
      try {
        this.handler$5(uri, begin, end, message, kind);
      } catch (exception) {
        t1 = H.unwrapException(exception);
        ex = t1;
        s = new H._StackTrace(exception, null);
        this.diagnoseCrashInUserCode$3("Uncaught exception in diagnostic handler", ex, s);
        throw exception;
      }

    },
    callUserProvider$1: function(uri) {
      var ex, s, t1, exception;
      try {
        t1 = this.provider$1(uri);
        return t1;
      } catch (exception) {
        t1 = H.unwrapException(exception);
        ex = t1;
        s = new H._StackTrace(exception, null);
        this.diagnoseCrashInUserCode$3("Uncaught exception in input provider", ex, s);
        throw exception;
      }

    },
    diagnoseCrashInUserCode$3: function(message, exception, stackTrace) {
      this.hasCrashed = true;
      P.print(message + ": " + H.S(this.tryToString$1(exception)));
      P.print(this.tryToString$1(stackTrace));
    },
    fromEnvironment$1: function($name) {
      return this.environment.$index(0, $name);
    },
    Compiler$7: function(provider, outputProvider, handler, libraryRoot, packageRoot, options, environment) {
      if (!C.JSString_methods.endsWith$1(this.libraryRoot._path, "/"))
        throw H.wrapException(P.ArgumentError$("libraryRoot must end with a /"));
      if (!C.JSString_methods.endsWith$1(this.packageRoot._path, "/"))
        throw H.wrapException(P.ArgumentError$("packageRoot must end with a /"));
    },
    static: {Compiler_extractStringOption: function(options, prefix, defaultValue) {
        var t1, option;
        for (t1 = J.get$iterator$ax(options); t1.moveNext$0();) {
          option = t1.get$current();
          if (J.getInterceptor$s(option).startsWith$1(option, prefix))
            return C.JSString_methods.substring$1(option, prefix.length);
        }
        return defaultValue;
      }, Compiler_extractUriOption: function(options, prefix) {
        var option = S.Compiler_extractStringOption(options, prefix, null);
        return option == null ? null : P.Uri_parse(option);
      }, Compiler_extractCsvOption: function(options, prefix) {
        var t1, option;
        for (t1 = J.get$iterator$ax(options); t1.moveNext$0();) {
          option = t1.get$current();
          if (J.getInterceptor$s(option).startsWith$1(option, prefix))
            return C.JSString_methods.substring$1(option, prefix.length).split(",");
        }
        return C.List_empty0;
      }}
  },
  Compiler_readScript_reportReadError: {
    "^": "Closure:8;box_0,this_1,readableUri_2,element_3",
    call$1: function(exception) {
      var t1 = this.this_1;
      t1.withCurrentElement$2(this.element_3, new S.Compiler_readScript_reportReadError_closure(this.box_0, t1, this.readableUri_2, exception));
    },
    $isFunction: true
  },
  Compiler_readScript_reportReadError_closure: {
    "^": "Closure:23;box_0,this_4,readableUri_5,exception_6",
    call$0: function() {
      this.this_4.reportDiagnosticInternal$4(this.box_0.node_0, C.MessageKind_brT, P.LinkedHashMap_LinkedHashMap$_literal(["uri", this.readableUri_5, "exception", this.exception_6], null, null), C.Diagnostic_1_error);
    },
    $isFunction: true
  },
  Compiler_readScript_closure: {
    "^": "Closure:23;this_7,resourceUri_8",
    call$0: function() {
      return this.this_7.callUserProvider$1(this.resourceUri_8);
    },
    $isFunction: true
  },
  Compiler_readScript_closure0: {
    "^": "Closure:13;readableUri_9,reportReadError_10,resourceUri_11",
    call$1: function(data) {
      var t1, resourceUriString, t2, sourceFile;
      t1 = this.resourceUri_11;
      resourceUriString = t1.toString$0(0);
      t2 = H.checkSubtype(data, "$isList", [P.$int], "$asList");
      if (t2)
        sourceFile = new A.Utf8BytesSourceFile(data, -1, resourceUriString, null);
      else if (typeof data === "string")
        sourceFile = new A.StringSourceFile(data, resourceUriString, null);
      else {
        this.reportReadError_10.call$1("Expected a 'String' or a 'List<int>' from the input provider, but got: " + H.S(P.Error_safeToString(data)) + ".");
        sourceFile = null;
      }
      return new K.Script(sourceFile, this.readableUri_9, t1);
    },
    $isFunction: true
  },
  Compiler_readScript_closure1: {
    "^": "Closure:13;reportReadError_12",
    call$1: function(error) {
      this.reportReadError_12.call$1(error);
      return;
    },
    $isFunction: true
  },
  Compiler_run_closure: {
    "^": "Closure:54;this_0",
    call$1: function(success) {
      var t1, t2, cumulated, task, t3, t4, t5, total;
      for (t1 = this.this_0, t2 = t1.tasks, t2 = H.setRuntimeTypeInfo(new H.ListIterator(t2, t2.length, 0, null), [H.getTypeArgumentByIndex(t2, 0)]), cumulated = 0; t2.moveNext$0();) {
        task = t2.__internal$_current;
        cumulated += task.get$timing();
        t3 = task.get$name(task) + " took ";
        t4 = task.watch;
        if (t4 != null) {
          t4 = t4.get$elapsedTicks();
          t5 = $.Stopwatch__frequency;
          if (typeof t5 !== "number")
            return H.iae(t5);
          t5 = C.JSInt_methods.$tdiv(t4 * 1000, t5);
          t4 = t5;
        } else
          t4 = 0;
        t1.handler$5(null, null, null, t3 + t4 + "msec", C.Diagnostic_kiE);
      }
      t2 = t1.totalCompileTime.get$elapsedTicks();
      t3 = $.Stopwatch__frequency;
      if (typeof t3 !== "number")
        return H.iae(t3);
      total = C.JSInt_methods.$tdiv(t2 * 1000, t3);
      t1.handler$5(null, null, null, "Total compile-time " + total + "msec; unaccounted " + (total - cumulated) + "msec", C.Diagnostic_kiE);
      return success;
    },
    $isFunction: true
  }
}],
["libraries", "package:libraries.dart", , D, {
  "^": "",
  LibraryInfo: {
    "^": "Object;path,category,dart2jsPath,dart2jsPatchPath,documented,platforms,implementation>,maturity"
  },
  Maturity: {
    "^": "Object;level,name>,description",
    toString$0: function(_) {
      return this.name + ": " + this.level + "\n" + this.description + "\n";
    },
    static: {"^": "Maturity_DEPRECATED,Maturity_EXPERIMENTAL,Maturity_UNSTABLE,Maturity_WEB_STABLE,Maturity_STABLE,Maturity_LOCKED,Maturity_UNSPECIFIED"}
  }
}],
["logical_rewriter", "package:compiler/implementation/dart_backend/logical_rewriter.dart", , A, {
  "^": "",
  LogicalRewriter: {
    "^": "Visitor0;fallthrough",
    visitLabeledStatement$1: function(node) {
      var savedFallthrough = this.fallthrough;
      this.fallthrough = node.next;
      node.body = node.body.accept$1(0, this);
      this.fallthrough = savedFallthrough;
      node.next = node.next.accept$1(0, this);
      return node;
    },
    visitAssign$1: function(node) {
      node.definition = node.definition.accept$1(0, this);
      node.next = node.next.accept$1(0, this);
      return node;
    },
    visitReturn$1: function(node) {
      node.value = node.get$value(node).accept$1(0, this);
      return node;
    },
    visitBreak$1: function(node) {
      return node;
    },
    visitContinue$1: function(node) {
      return node;
    },
    isFallthroughBreak$1: function(node) {
      var t1, t2;
      if (!!J.getInterceptor(node).$isBreak1) {
        t1 = node.target.binding.get$next();
        t2 = this.fallthrough;
        t2 = t1 == null ? t2 == null : t1 === t2;
        t1 = t2;
      } else
        t1 = false;
      return t1;
    },
    visitIf$1: function(node) {
      var tmp, t1, t2;
      if (this.isFallthroughBreak$1(node.get$thenStatement())) {
        node.condition = new M.Not(node.condition, false);
        tmp = node.thenStatement;
        node.thenStatement = node.elseStatement;
        node.elseStatement = tmp;
      }
      t1 = !this.isFallthroughBreak$1(node.elseStatement);
      node.condition = this.makeCondition$3$liftNots(node.condition, true, t1);
      node.thenStatement = node.thenStatement.accept$1(0, this);
      t2 = node.elseStatement.accept$1(0, this);
      node.elseStatement = t2;
      if (t1 && !!J.getInterceptor(node.condition).$isNot) {
        node.condition = H.interceptedTypeCast(node.condition, "$isNot").operand;
        tmp = node.thenStatement;
        node.thenStatement = t2;
        node.elseStatement = tmp;
      }
      return node;
    },
    visitWhileTrue$1: function(node) {
      node.body = node.body.accept$1(0, this);
      return node;
    },
    visitWhileCondition$1: function(node) {
      node.condition = this.makeCondition$3$liftNots(node.condition, true, false);
      node.body = node.body.accept$1(0, this);
      node.next = node.next.accept$1(0, this);
      return node;
    },
    visitExpressionStatement$1: function(node) {
      node.expression = node.expression.accept$1(0, this);
      node.next = node.next.accept$1(0, this);
      return node;
    },
    visitVariable$1: function(node) {
      return node;
    },
    visitInvokeStatic$1: function(node) {
      this._rewriteList$1(node.get$arguments());
      return node;
    },
    visitInvokeMethod$1: function(node) {
      node.receiver = node.receiver.accept$1(0, this);
      this._rewriteList$1(node.arguments);
      return node;
    },
    visitInvokeSuperMethod$1: function(node) {
      this._rewriteList$1(node.arguments);
      return node;
    },
    visitInvokeConstructor$1: function(node) {
      this._rewriteList$1(node.arguments);
      return node;
    },
    visitConcatenateStrings$1: function(node) {
      this._rewriteList$1(node.arguments);
      return node;
    },
    visitLiteralList$1: function(node) {
      this._rewriteList$1(node.get$values(node));
      return node;
    },
    visitLiteralMap$1: function(node) {
      this._rewriteList$1(node.keys);
      this._rewriteList$1(node.values);
      return node;
    },
    visitTypeOperator$1: function(node) {
      node.receiver = node.receiver.accept$1(0, this);
      return node;
    },
    visitConstant$1: function(node) {
      return node;
    },
    visitThis$1: function(node) {
      return node;
    },
    visitReifyTypeVar$1: function(node) {
      return node;
    },
    visitFunctionExpression$1: function(node) {
      var t1 = node.definition;
      t1.body = t1.body.accept$1(0, new A.LogicalRewriter(null));
      return node;
    },
    visitFunctionDeclaration$1: function(node) {
      var t1 = node.definition;
      t1.body = t1.body.accept$1(0, new A.LogicalRewriter(null));
      node.next = node.next.accept$1(0, this);
      return node;
    },
    visitNot$1: function(node) {
      return this.toBoolean$1(this.makeCondition$3$liftNots(node.get$operand(), false, false));
    },
    visitConditional$1: function(node) {
      var t1, tmp;
      node.thenExpression = node.thenExpression.accept$1(0, this);
      node.elseExpression = node.elseExpression.accept$1(0, this);
      if (this.isTrue$1(node.thenExpression) && this.isFalse$1(node.elseExpression))
        return this.toBoolean$1(this.makeCondition$3$liftNots(node.condition, true, false));
      if (this.isFalse$1(node.thenExpression) && this.isTrue$1(node.elseExpression))
        return this.toBoolean$1(this.makeCondition$3$liftNots(node.condition, false, false));
      if (this.isBooleanValued$1(node.thenExpression) && this.isFalse$1(node.elseExpression))
        return new M.LogicalOperator(this.makeCondition$3$liftNots(node.condition, true, false), true, this.putInBooleanContext$1(node.thenExpression), false);
      if (this.isBooleanValued$1(node.thenExpression) && this.isTrue$1(node.elseExpression))
        return new M.LogicalOperator(this.makeCondition$3$liftNots(node.condition, false, false), false, this.putInBooleanContext$1(node.thenExpression), false);
      if (this.isBooleanValued$1(node.elseExpression) && this.isTrue$1(node.thenExpression))
        return new M.LogicalOperator(this.makeCondition$3$liftNots(node.condition, true, false), false, this.putInBooleanContext$1(node.elseExpression), false);
      if (this.isBooleanValued$1(node.elseExpression) && this.isFalse$1(node.thenExpression))
        return new M.LogicalOperator(this.makeCondition$3$liftNots(node.condition, false, false), true, this.putInBooleanContext$1(node.elseExpression), false);
      t1 = this.makeCondition$2(node.condition, true);
      node.condition = t1;
      if (!!J.getInterceptor(t1).$isNot) {
        node.condition = H.interceptedTypeCast(t1, "$isNot").operand;
        tmp = node.thenExpression;
        node.thenExpression = node.elseExpression;
        node.elseExpression = tmp;
      }
      return node;
    },
    visitLogicalOperator$1: function(node) {
      node.left = this.makeCondition$2(node.left, true);
      node.right = this.makeCondition$2(node.right, true);
      return node;
    },
    isBooleanValued$1: function(e) {
      var t1;
      if (!this.isTrue$1(e))
        if (!this.isFalse$1(e)) {
          t1 = J.getInterceptor(e);
          t1 = !!t1.$isNot || !!t1.$isLogicalOperator;
        } else
          t1 = true;
      else
        t1 = true;
      return t1;
    },
    putInBooleanContext$1: function(e) {
      if (!!J.getInterceptor(e).$isNot && !!J.getInterceptor(e.operand).$isNot)
        return H.interceptedTypeCast(e.get$operand(), "$isNot").operand;
      else
        return e;
    },
    toBoolean$1: function(e) {
      if (this.isBooleanValued$1(e))
        return e;
      else
        return new M.Not(new M.Not(e, false), false);
    },
    makeCondition$3$liftNots: function(e, polarity, liftNots) {
      var t1, t2, tmp;
      t1 = J.getInterceptor(e);
      if (!!t1.$isNot)
        return this.makeCondition$3$liftNots(e.operand, !polarity, liftNots);
      if (!!t1.$isLogicalOperator) {
        e.left = this.makeCondition$2(e.left, polarity);
        t1 = this.makeCondition$2(e.right, polarity);
        e.right = t1;
        if (!polarity)
          e.isAnd = !e.isAnd;
        t2 = e.left;
        if (!!J.getInterceptor(t2).$isNot && !!J.getInterceptor(t1).$isNot && liftNots) {
          e.left = H.interceptedTypeCast(t2, "$isNot").operand;
          e.right = H.interceptedTypeCast(t1, "$isNot").operand;
          e.isAnd = !e.isAnd;
          return new M.Not(e, false);
        }
        return e;
      }
      if (!!t1.$isConditional2) {
        e.thenExpression = this.makeCondition$2(e.thenExpression, polarity);
        e.elseExpression = this.makeCondition$2(e.elseExpression, polarity);
        if (this.isTrue$1(e.thenExpression) && this.isFalse$1(e.elseExpression))
          return this.makeCondition$3$liftNots(e.condition, true, liftNots);
        if (this.isFalse$1(e.thenExpression) && this.isTrue$1(e.elseExpression))
          return this.makeCondition$3$liftNots(e.condition, false, liftNots);
        if (this.isTrue$1(e.thenExpression))
          return this.makeOr$3$liftNots(this.makeCondition$2(e.condition, true), e.elseExpression, liftNots);
        if (this.isFalse$1(e.thenExpression))
          return this.makeAnd$3$liftNots(this.makeCondition$2(e.condition, false), e.elseExpression, liftNots);
        if (this.isTrue$1(e.elseExpression))
          return this.makeOr$3$liftNots(this.makeCondition$2(e.condition, false), e.thenExpression, liftNots);
        if (this.isFalse$1(e.elseExpression))
          return this.makeAnd$3$liftNots(this.makeCondition$2(e.condition, true), e.thenExpression, liftNots);
        t1 = this.makeCondition$2(e.condition, true);
        e.condition = t1;
        if (!!J.getInterceptor(t1).$isNot) {
          e.condition = H.interceptedTypeCast(t1, "$isNot").operand;
          tmp = e.thenExpression;
          e.thenExpression = e.elseExpression;
          e.elseExpression = tmp;
        }
        t1 = e.thenExpression;
        if (!!J.getInterceptor(t1).$isNot && !!J.getInterceptor(e.elseExpression).$isNot && liftNots) {
          e.thenExpression = H.interceptedTypeCast(t1, "$isNot").operand;
          e.elseExpression = H.interceptedTypeCast(e.elseExpression, "$isNot").operand;
          return new M.Not(e, false);
        }
        return e;
      }
      if (!!t1.$isConstant0 && !!J.getInterceptor(e.value).$isBoolConstant) {
        if (!polarity) {
          t1 = t1.get$value(e).negate$0();
          return new M.Constant0(new M.PrimitiveConstExp(t1), t1, false);
        }
        return e;
      }
      e = t1.accept$1(e, this);
      return polarity ? e : new M.Not(e, false);
    },
    makeCondition$2: function(e, polarity) {
      return this.makeCondition$3$liftNots(e, polarity, true);
    },
    isTrue$1: function(e) {
      return !!J.getInterceptor(e).$isConstant0 && !!J.getInterceptor(e.value).$isTrueConstant;
    },
    isFalse$1: function(e) {
      return !!J.getInterceptor(e).$isConstant0 && !!J.getInterceptor(e.value).$isFalseConstant;
    },
    makeAnd$3$liftNots: function(e1, e2, liftNots) {
      if (!!J.getInterceptor(e1).$isNot && !!J.getInterceptor(e2).$isNot && liftNots)
        return new M.Not(new M.LogicalOperator(e1.get$operand(), false, e2.get$operand(), false), false);
      else
        return new M.LogicalOperator(e1, true, e2, false);
    },
    makeOr$3$liftNots: function(e1, e2, liftNots) {
      if (!!J.getInterceptor(e1).$isNot && !!J.getInterceptor(e2).$isNot && liftNots)
        return new M.Not(new M.LogicalOperator(e1.get$operand(), true, e2.get$operand(), false), false);
      else
        return new M.LogicalOperator(e1, false, e2, false);
    },
    _rewriteList$1: function(l) {
      var i, t1;
      for (i = 0; i < l.length; ++i) {
        t1 = J.accept$1$x(l[i], this);
        if (i >= l.length)
          return H.ioore(l, i);
        l[i] = t1;
      }
    },
    $asVisitor0: function() {
      return [M.Statement0, M.Expression0];
    }
  }
}],
["loop_rewriter", "package:compiler/implementation/dart_backend/loop_rewriter.dart", , R, {
  "^": "",
  LoopRewriter: {
    "^": "RecursiveVisitor;usedContinueLabels",
    visitLabeledStatement$1: function(node) {
      node.body = node.body.accept$1(0, this);
      node.next = node.next.accept$1(0, this);
      return node;
    },
    visitAssign$1: function(node) {
      var t1, t2;
      t1 = node.variable;
      t2 = node.definition;
      if (t1 == null ? t2 == null : t1 === t2) {
        --t1.readCount;
        --t1.writeCount;
        return node.next.accept$1(0, this);
      }
      t2.accept$1(0, this);
      node.next = node.next.accept$1(0, this);
      return node;
    },
    visitReturn$1: function(node) {
      node.get$value(node).accept$1(0, this);
      return node;
    },
    visitBreak$1: function(node) {
      return node;
    },
    visitContinue$1: function(node) {
      this.usedContinueLabels.add$1(0, node.get$target(node));
      return node;
    },
    visitIf$1: function(node) {
      node.get$condition().accept$1(0, this);
      node.thenStatement = node.get$thenStatement().accept$1(0, this);
      node.elseStatement = node.elseStatement.accept$1(0, this);
      return node;
    },
    visitWhileTrue$1: function(node) {
      var t1, t2, t3, t4, thenHasContinue, elseHasContinue;
      t1 = node.body;
      t2 = J.getInterceptor(t1);
      t3 = node.label;
      t4 = this.usedContinueLabels;
      if (!!t2.$isIf2) {
        t1.thenStatement = t1.get$thenStatement().accept$1(0, this);
        thenHasContinue = t4.remove$1(0, t3);
        t1.elseStatement = t1.elseStatement.accept$1(0, this);
        elseHasContinue = t4.remove$1(0, t3);
        if (thenHasContinue && !elseHasContinue) {
          t3.binding = null;
          t1 = new M.WhileCondition(t3, t1.condition, t1.thenStatement, t1.elseStatement);
          t3.binding = t1;
          return t1;
        } else if (!thenHasContinue && elseHasContinue) {
          t3.binding = null;
          t1 = new M.WhileCondition(t3, new M.Not(t1.condition, false), t1.elseStatement, t1.thenStatement);
          t3.binding = t1;
          return t1;
        }
      } else {
        node.body = t2.accept$1(t1, this);
        t4.remove$1(0, t3);
      }
      return node;
    },
    visitWhileCondition$1: function(node) {
      node.condition.accept$1(0, this);
      node.body = node.body.accept$1(0, this);
      node.next = node.next.accept$1(0, this);
      return node;
    },
    visitExpressionStatement$1: function(node) {
      node.expression.accept$1(0, this);
      node.next = node.next.accept$1(0, this);
      return node;
    },
    visitFunctionDeclaration$1: function(node) {
      var t1, t2;
      t1 = P.LinkedHashSet_LinkedHashSet(null, null, null, M.Label0);
      t2 = node.definition;
      t2.body = t2.body.accept$1(0, new R.LoopRewriter(t1));
      node.next = node.next.accept$1(0, this);
      return node;
    },
    visitFunctionExpression$1: function(node) {
      var t1, t2;
      t1 = P.LinkedHashSet_LinkedHashSet(null, null, null, M.Label0);
      t2 = node.definition;
      t2.body = t2.body.accept$1(0, new R.LoopRewriter(t1));
    }
  }
}],
["mirror_renamer", "package:compiler/implementation/mirror_renamer/mirror_renamer.dart", , V, {
  "^": "",
  MirrorRenamer: {
    "^": "Object;symbols,mirrorSystemGetNameNodes,mirrorHelperGetNameFunctionNode,mirrorHelperSymbolsMapNode,compiler<,backend<",
    addRenames$3: function(renames, topLevelNodes, placeholderCollector) {
      var t1, t2, sampleNode, symbolsMapIdentifier, sb, t3, first, mangledName, str;
      t1 = this.mirrorSystemGetNameNodes;
      if (t1.length === 0)
        return;
      this.symbols = P.LinkedHashMap_LinkedHashMap(null, null, null, P.String, P.String);
      for (t2 = placeholderCollector.memberPlaceholders, t2 = t2.get$values(t2), t2 = H.setRuntimeTypeInfo(new H.MappedIterator(null, J.get$iterator$ax(t2._iterable), t2._f), [H.getTypeArgumentByIndex(t2, 0), H.getTypeArgumentByIndex(t2, 1)]); t2.moveNext$0();) {
        sampleNode = J.get$first$ax(t2.__internal$_current);
        this.symbols.putIfAbsent$2(renames.$index(0, sampleNode), new V.MirrorRenamer_addRenames_closure(sampleNode));
      }
      t2 = this.mirrorHelperSymbolsMapNode.get$definitions().nodes;
      symbolsMapIdentifier = t2.get$head(t2).asSend$0().selector;
      C.JSArray_methods.remove$1(topLevelNodes, this.mirrorHelperSymbolsMapNode);
      sb = P.StringBuffer$("const " + H.S(renames.$index(0, symbolsMapIdentifier)) + " = const<String,String>{");
      for (t2 = this.symbols, t2 = H.setRuntimeTypeInfo(new P.LinkedHashMapKeyIterable(t2), [H.getTypeArgumentByIndex(t2, 0)]), t3 = t2._map, t2 = H.setRuntimeTypeInfo(new P.LinkedHashMapKeyIterator(t3, t3._modifications, null, null), [H.getTypeArgumentByIndex(t2, 0)]), t2._cell = t2._map._first, first = true; t2.moveNext$0();) {
        mangledName = t2._collection$_current;
        if (!first)
          sb._contents += ",";
        else
          first = false;
        t3 = "'" + H.S(mangledName) + "' : '";
        sb._contents += t3;
        str = this.symbols.$index(0, mangledName);
        t3 = sb._contents += typeof str === "string" ? str : H.S(str);
        sb._contents = t3 + "'";
      }
      sb.write$1("};");
      sb.write$1(H.Primitives_stringFromCharCode(0));
      topLevelNodes.push(new V.MirrorRenamer_addRenames_parse(this).call$1(sb._contents));
      H.IterableMixinWorkaround_forEach(t1, new V.MirrorRenamer_addRenames_closure0(this, renames));
    },
    static: {"^": "MirrorRenamer_MIRROR_HELPER_GET_NAME_FUNCTION,MirrorRenamer_DART_MIRROR_HELPER,MirrorRenamer_MIRROR_HELPER_SYMBOLS_MAP_NAME"}
  },
  MirrorRenamer_addRenames_parse: {
    "^": "Closure:217;this_0",
    call$1: function(text) {
      var t1, tokens;
      t1 = this.this_0;
      tokens = t1.compiler.scanner.tokenize$1(text);
      return t1.compiler.parser.parseCompilationUnit$1(tokens);
    },
    $isFunction: true
  },
  MirrorRenamer_addRenames_closure: {
    "^": "Closure:23;sampleNode_1",
    call$0: function() {
      var t1 = this.sampleNode_1.token;
      return t1.get$value(t1);
    },
    $isFunction: true
  },
  MirrorRenamer_addRenames_closure0: {
    "^": "Closure:13;this_2,renames_3",
    call$1: function(node) {
      var t1, t2, t3;
      t1 = this.renames_3;
      t2 = node.get$selector();
      t3 = this.this_2.mirrorHelperGetNameFunctionNode;
      t1.$indexSet(0, t2, t1.$index(0, t3.get$name(t3)));
      t1.$indexSet(0, node.get$receiver(), "");
    },
    $isFunction: true
  }
}],
["native", "package:compiler/implementation/native_handler.dart", , L, {
  "^": "",
  checkAllowedLibrary: function(listener, token) {
    if (!listener.compilationUnitElement.get$library().canUseNative)
      listener.reportFatalError$2(token, "Unexpected token");
  },
  nativeTagsOfClass: function(cls) {
    var quotedName, t1, t2;
    quotedName = cls.get$nativeTagInfo();
    t1 = J.substring$2$s(quotedName, 1, quotedName.length - 1).split(",");
    t2 = new H.IterableMixinWorkaround();
    t2.$builtinTypeInfo = [H.getTypeArgumentByIndex(t1, 0)];
    t1 = new H.WhereIterable(t1, new L.nativeTagsOfClass_closure());
    t1.$builtinTypeInfo = [H.getTypeArgumentByIndex(t2, 0)];
    return P.List_List$from(t1, true, H.getRuntimeTypeArgument(t1, "IterableBase", 0));
  },
  handleSsaNative: function(builder, nativeBody) {
    var compiler, element, backend, nativeMethodName, str, t1, hasBody, parameters, $arguments, inputs, receiver, foreignParameters, nativeMethodCall, t2, t3, t4, t5;
    compiler = builder.compiler;
    element = builder.work.element;
    backend = builder.backend;
    nativeMethodName = element.get$fixedBackendName();
    if (nativeBody != null) {
      str = nativeBody.asLiteralString$0().dartString.slowToString$0();
      t1 = $.get$nativeRedirectionRegExp()._nativeRegExp;
      if (typeof str !== "string")
        H.throwExpression(P.ArgumentError$(str));
      if (t1.test(str))
        compiler.internalError$2(nativeBody, "Deprecated syntax, use @JSName('name') instead.");
      hasBody = true;
    } else
      hasBody = false;
    t1 = !hasBody;
    if (t1)
      builder.nativeEmitter.nativeMethods.add$1(0, element);
    parameters = element.get$functionSignature();
    if (t1) {
      $arguments = H.setRuntimeTypeInfo([], [P.String]);
      inputs = H.setRuntimeTypeInfo([], [B.HInstruction]);
      if (element.get$isInstanceMember()) {
        inputs.push(builder.localsHandler.readThis$0());
        receiver = "#.";
      } else
        receiver = "";
      parameters.forEachParameter$1(new L.handleSsaNative_closure(builder, compiler, new L.handleSsaNative_convertDartClosure(builder, nativeBody, compiler, backend), $arguments, inputs));
      foreignParameters = C.JSArray_methods.join$1($arguments, ",");
      t1 = element.kind;
      if (t1 === C.ElementKind_function_2)
        nativeMethodCall = receiver + H.S(nativeMethodName) + "(" + foreignParameters + ")";
      else if (t1 === C.ElementKind_getter_0)
        nativeMethodCall = receiver + H.S(nativeMethodName);
      else if (t1 === C.ElementKind_setter_0)
        nativeMethodCall = receiver + H.S(nativeMethodName) + " = " + foreignParameters;
      else {
        compiler.internalError$2(element, "Unexpected kind: \"" + J.toString$0(t1) + "\".");
        nativeMethodCall = null;
      }
      t1 = C.C_JsBuilder.uncachedExpressionTemplate$1(nativeMethodCall);
      t2 = backend.compiler.typesTask.get$dynamicType();
      t3 = new Z.SideEffects(0);
      t3.flags = 7;
      t3.setDependsOnSomething$0();
      t3 = B.HForeign$(t1, t2, inputs, false, t3, false, null);
      builder._ssa$_current.add$1(0, t3);
      builder.stack.push(t3);
      t3 = builder.stack;
      if (0 >= t3.length)
        return H.ioore(t3, 0);
      t3 = H.setRuntimeTypeInfo([t3.pop()], [B.HInstruction]);
      t2 = $.HInstruction_idCounter;
      if (typeof t2 !== "number")
        return t2.$add();
      $.HInstruction_idCounter = t2 + 1;
      t2 = new B.HReturn(null, null, t2, t3, H.setRuntimeTypeInfo([], [B.HInstruction]), null, null, null, new Z.SideEffects(0), false, C.FlatTypeMask_null_0);
      t2.HInstruction$2(t3, C.FlatTypeMask_null_0);
      builder.close$1(0, t2).addSuccessor$1(builder.graph.exit);
    } else {
      if (parameters.get$parameterCount() !== 0)
        compiler.internalError$2(nativeBody, "native \"...\" syntax is restricted to functions with zero parameters.");
      t1 = Q.Template$withStatementResult(new Q.LiteralStatement(nativeBody.asLiteralString$0().dartString.slowToString$0(), null, null));
      t2 = H.setRuntimeTypeInfo([], [B.HInstruction]);
      t3 = new Z.SideEffects(0);
      t3.flags = 7;
      t3.setDependsOnSomething$0();
      t4 = backend.compiler.typesTask.get$dynamicType();
      t5 = $.HInstruction_idCounter;
      if (typeof t5 !== "number")
        return t5.$add();
      $.HInstruction_idCounter = t5 + 1;
      t5 = new B.HForeign(t1, true, false, null, null, null, t5, t2, H.setRuntimeTypeInfo([], [B.HInstruction]), null, null, null, new Z.SideEffects(0), false, t4);
      t5.HInstruction$2(t2, t4);
      t5.HForeign$7$canThrow$effects$isStatement$nativeBehavior(t1, t4, t2, false, t3, true, null);
      builder._ssa$_current.add$1(0, t5);
      builder.stack.push(t5);
    }
  },
  SpecialType: {
    "^": "Object;name>",
    get$hashCode: function(_) {
      return C.JSString_methods.get$hashCode(this.name);
    },
    $isSpecialType: true,
    static: {"^": "SpecialType_JsObject"}
  },
  NativeEnqueuer: {
    "^": "Object;",
    processNativeClasses$1: function(libraries) {
    },
    registerElement$1: function(_, element) {
    },
    handleFieldAnnotations$1: function(field) {
    },
    registerFieldLoad$1: function(field) {
    },
    registerFieldStore$1: function(field) {
    },
    getNativeBehaviorOf$1: function(node) {
      return $.get$NativeBehavior_NONE();
    },
    hasInstantiatedNativeClasses$0: function() {
      return false;
    },
    registerJsCall$2: function(node, resolver) {
    },
    logSummary$1: function(log) {
    },
    get$annotationCreatesClass: function() {
      return;
    },
    get$annotationReturnsClass: function() {
      return;
    }
  },
  NativeEnqueuerBase: {
    "^": "Object;registeredClasses<,compiler<",
    hasInstantiatedNativeClasses$0: function() {
      return this.registeredClasses._collection$_length !== 0;
    },
    get$backend: function() {
      return this.compiler.backend;
    },
    processNativeClasses$1: function(libraries) {
      var t1, t2;
      t1 = this.compiler;
      if (t1.hasIncrementalSupport) {
        t2 = this.processedLibraries;
        libraries = H.setRuntimeTypeInfo(new H.WhereIterable(libraries, t2.get$add(t2)), [H.getRuntimeTypeArgument(libraries, "IterableBase", 0)]);
      }
      libraries.forEach$1(0, this.get$processNativeClassesInLibrary());
      if (t1.backend.get$isolateHelperLibrary() != null)
        this.processNativeClassesInLibrary$1(t1.backend.get$isolateHelperLibrary());
      this.processSubclassesOfNativeClasses$1(libraries);
      if (!this.enableLiveTypeAnalysis) {
        this.nativeClasses.forEach$1(0, new L.NativeEnqueuerBase_processNativeClasses_closure(this));
        this.flushQueue$0();
      }
    },
    processNativeClassesInLibrary$1: [function(library) {
      J.get$implementation$x(library).forEachLocalMember$1(new L.NativeEnqueuerBase_processNativeClassesInLibrary_closure(this));
    }, "call$1", "get$processNativeClassesInLibrary", 2, 0, 129],
    processNativeClass$1: function(classElement) {
      this.nativeClasses.add$1(0, classElement);
      this.unusedClasses.add$1(0, classElement);
      classElement.ensureResolved$1(this.compiler);
    },
    processSubclassesOfNativeClasses$1: function(libraries) {
      var potentialExtends, t1, t2;
      potentialExtends = P.LinkedHashMap_LinkedHashMap(null, null, null, P.String, [P.Set, O.ClassElement]);
      libraries.forEach$1(0, new L.NativeEnqueuerBase_processSubclassesOfNativeClasses_closure(this, potentialExtends));
      t1 = this.nativeClasses;
      t1.forEach$1(0, new L.NativeEnqueuerBase_processSubclassesOfNativeClasses_walkPotentialSubclasses(this, potentialExtends, new L.NativeEnqueuerBase_processSubclassesOfNativeClasses_nativeSuperclassOf()));
      t2 = this.nativeClassesAndSubclasses;
      t1.addAll$1(0, t2);
      this.unusedClasses.addAll$1(0, t2);
    },
    findExtendsNameOfClass$1: function(classElement) {
      return this.compiler.withCurrentElement$2(classElement, new L.NativeEnqueuerBase_findExtendsNameOfClass_closure(classElement, new L.NativeEnqueuerBase_findExtendsNameOfClass_scanForExtendsName(new L.NativeEnqueuerBase_findExtendsNameOfClass_skipTypeParameters())));
    },
    get$annotationCreatesClass: function() {
      this.findAnnotationClasses$0();
      return this._annotationCreatesClass;
    },
    get$annotationReturnsClass: function() {
      this.findAnnotationClasses$0();
      return this._annotationReturnsClass;
    },
    findAnnotationClasses$0: function() {
      if (this._annotationCreatesClass != null)
        return;
      var t1 = new L.NativeEnqueuerBase_findAnnotationClasses_find(this);
      this._annotationCreatesClass = t1.call$1("Creates");
      this._annotationReturnsClass = t1.call$1("Returns");
      this._annotationJsNameClass = t1.call$1("JSName");
    },
    findJsNameFromAnnotation$1: function(element) {
      var annotationClass, link, t1, $name, annotation, value, t2, fields, specString;
      this.findAnnotationClasses$0();
      annotationClass = this._annotationJsNameClass;
      for (link = element.get$metadata(), t1 = this.compiler, $name = null; !link.get$isEmpty(link); link = link.get$tail()) {
        annotation = link.get$head(link).ensureResolved$1(t1);
        value = annotation.value;
        if (!J.getInterceptor(value).$isConstructedConstant)
          continue;
        t2 = value.type;
        if (!J.getInterceptor(t2).$isInterfaceType)
          continue;
        t2 = t2.get$element();
        if (t2 == null ? annotationClass != null : t2 !== annotationClass)
          continue;
        fields = value.fields;
        t2 = fields.length;
        if (t2 === 1) {
          if (0 >= t2)
            return H.ioore(fields, 0);
          t2 = !J.getInterceptor(fields[0]).$isStringConstant;
        } else
          t2 = true;
        if (t2)
          t1.internalError$2(annotation, "Annotations needs one string: " + J.toString$0(annotation.parseNode$1(t1)));
        if (0 >= fields.length)
          return H.ioore(fields, 0);
        specString = fields[0].toDartString$0().slowToString$0();
        if ($name == null)
          $name = specString;
        else
          t1.internalError$2(annotation, "Too many JSName annotations: " + J.toString$0(annotation.parseNode$1(t1)));
      }
      return $name;
    },
    enqueueClass$2: function(classElement, cause) {
      this.unusedClasses.remove$1(0, classElement);
      this.pendingClasses.add$1(0, classElement);
      this.queue._add$1(new L.NativeEnqueuerBase_enqueueClass_closure(this, classElement, cause));
    },
    flushQueue$0: function() {
      if (this.flushing)
        return;
      this.flushing = true;
      for (var t1 = this.queue; t1._head !== t1._tail;)
        t1.removeFirst$0().call$0();
      this.flushing = false;
    },
    processClass$2: function(classElement, cause) {
      var t1, t2, t3, t4;
      t1 = this.registeredClasses;
      t2 = t1._collection$_length;
      this.pendingClasses.remove$1(0, classElement);
      t1.add$1(0, classElement);
      t1 = this.world;
      t3 = this.compiler;
      t4 = t3.globalDependencies;
      classElement.ensureResolved$1(t1.compiler);
      t1.registerInstantiatedType$3$mirrorUsage(classElement.get$rawType(), t4, false);
      classElement.parseNode$1(t3);
      if (t2 === 0)
        this.queue._add$1(this.get$onFirstNativeClass());
    },
    registerElement$1: function(_, element) {
      this.compiler.withCurrentElement$2(element, new L.NativeEnqueuerBase_registerElement_closure(this, element));
    },
    handleFieldAnnotations$1: function(element) {
      if (element.get$enclosingElement().get$isNative())
        if (element.get$isInstanceMember())
          this.setNativeName$1(element);
    },
    setNativeName$1: function(element) {
      var $name = this.findJsNameFromAnnotation$1(element);
      element.setNative$1($name == null ? element.get$name(element) : $name);
    },
    isNativeMethod$1: function(element) {
      if (!element.get$enclosingElement().get$library().canUseNative)
        return false;
      return this.compiler.withCurrentElement$2(element, new L.NativeEnqueuerBase_isNativeMethod_closure(this, element));
    },
    registerFieldLoad$1: function(field) {
      this.processNativeBehavior$2(L.NativeBehavior_ofFieldLoad(field, this.compiler), field);
      this.flushQueue$0();
    },
    registerFieldStore$1: function(field) {
      this.processNativeBehavior$2(L.NativeBehavior_ofFieldStore(field, this.compiler), field);
      this.flushQueue$0();
    },
    registerJsCall$2: function(node, resolver) {
      var behavior = L.NativeBehavior_ofJsCall(node, this.compiler, resolver);
      this.processNativeBehavior$2(behavior, node);
      this.nativeBehaviors.$indexSet(0, node, behavior);
      this.flushQueue$0();
    },
    getNativeBehaviorOf$1: function(node) {
      return this.nativeBehaviors.$index(0, node);
    },
    processNativeBehavior$2: function(behavior, cause) {
      var t1, registry, t2, t3, t4, t5, t6, t7, type, t8, t9;
      t1 = this.compiler;
      registry = t1.globalDependencies;
      t2 = this.unusedClasses;
      t3 = t2._collection$_length;
      for (t4 = behavior.typesInstantiated, t4 = H.setRuntimeTypeInfo(new H.ListIterator(t4, t4.length, 0, null), [H.getTypeArgumentByIndex(t4, 0)]), t5 = this.matchedTypeConstraints, t6 = this.world, t7 = t6.compiler; t4.moveNext$0();) {
        type = t4.__internal$_current;
        if (t5.contains$1(0, type))
          continue;
        t5.add$1(0, type);
        t8 = J.getInterceptor(type);
        if (!!t8.$isSpecialType) {
          if (type === C.SpecialType_MYA) {
            t8 = t1.objectClass;
            t8.ensureResolved$1(t7);
            t6.registerInstantiatedType$3$mirrorUsage(t8.get$rawType(), registry, false);
          }
          continue;
        }
        if (!!t8.$isInterfaceType) {
          t8 = type.get$element();
          t9 = t1.intClass;
          if (t8 == null ? t9 == null : t8 === t9) {
            t9.ensureResolved$1(t7);
            t6.registerInstantiatedType$3$mirrorUsage(t9.get$rawType(), registry, false);
          } else {
            t8 = type.get$element();
            t9 = t1.doubleClass;
            if (t8 == null ? t9 == null : t8 === t9) {
              t9.ensureResolved$1(t7);
              t6.registerInstantiatedType$3$mirrorUsage(t9.get$rawType(), registry, false);
            } else {
              t8 = type.get$element();
              t9 = t1.numClass;
              if (t8 == null ? t9 == null : t8 === t9) {
                t8 = t1.doubleClass;
                t8.ensureResolved$1(t7);
                t6.registerInstantiatedType$3$mirrorUsage(t8.get$rawType(), registry, false);
                t8 = t1.intClass;
                t8.ensureResolved$1(t7);
                t6.registerInstantiatedType$3$mirrorUsage(t8.get$rawType(), registry, false);
              } else {
                t8 = type.get$element();
                t9 = t1.stringClass;
                if (t8 == null ? t9 == null : t8 === t9) {
                  t9.ensureResolved$1(t7);
                  t6.registerInstantiatedType$3$mirrorUsage(t9.get$rawType(), registry, false);
                } else {
                  t8 = type.get$element();
                  t9 = t1.nullClass;
                  if (t8 == null ? t9 == null : t8 === t9) {
                    t9.ensureResolved$1(t7);
                    t6.registerInstantiatedType$3$mirrorUsage(t9.get$rawType(), registry, false);
                  } else {
                    t8 = type.get$element();
                    t9 = t1.boolClass;
                    if (t8 == null ? t9 == null : t8 === t9) {
                      t9.ensureResolved$1(t7);
                      t6.registerInstantiatedType$3$mirrorUsage(t9.get$rawType(), registry, false);
                    } else {
                      t8 = t1.types;
                      t9 = t1.backend.get$jsArrayClass().get$rawType();
                      t8 = t8.subtypeVisitor;
                      if (type.get$treatAsDynamic() || t8.isMoreSpecific$2(type, t9) === true) {
                        t8 = type.get$element();
                        t8.ensureResolved$1(t7);
                        t6.registerInstantiatedType$3$mirrorUsage(t8.get$rawType(), registry, false);
                      }
                    }
                  }
                }
              }
            }
          }
        }
        this.enqueueUnusedClassesMatching$3(new L.NativeEnqueuerBase_processNativeBehavior_closure(this, type), cause, "subtypeof(" + H.S(type) + ")");
      }
      if (t2._collection$_length === 0 && t3 !== 0)
        t1.log$1("All native types marked as used due to " + H.S(cause) + ".");
    },
    enqueueUnusedClassesMatching$3: function(predicate, cause, reason) {
      var t1, matches;
      t1 = this.unusedClasses;
      matches = new H.WhereIterable(t1, predicate);
      matches.$builtinTypeInfo = [H.getTypeArgumentByIndex(t1, 0)];
      H.IterableMixinWorkaround_forEach(P.List_List$from(matches, true, H.getRuntimeTypeArgument(matches, "IterableBase", 0)), new L.NativeEnqueuerBase_enqueueUnusedClassesMatching_closure(this, cause));
    },
    enqueueUnusedClassesMatching$2: function(predicate, cause) {
      return this.enqueueUnusedClassesMatching$3(predicate, cause, null);
    },
    onFirstNativeClass$0: [function() {
      var t1 = new L.NativeEnqueuerBase_onFirstNativeClass_staticUse(this);
      t1.call$1("defineProperty");
      t1.call$1("toStringForNativeObject");
      t1.call$1("hashCodeForNativeObject");
      t1.call$1("convertDartClosureToJS");
      this.addNativeExceptions$0();
    }, "call$0", "get$onFirstNativeClass", 0, 0, 23],
    addNativeExceptions$0: function() {
      this.enqueueUnusedClassesMatching$2(new L.NativeEnqueuerBase_addNativeExceptions_closure(), "native exception");
    }
  },
  NativeEnqueuerBase_processNativeClasses_closure: {
    "^": "Closure:13;this_0",
    call$1: function(c) {
      return this.this_0.enqueueClass$2(c, "forced");
    },
    $isFunction: true
  },
  NativeEnqueuerBase_processNativeClassesInLibrary_closure: {
    "^": "Closure:77;this_0",
    call$1: function(element) {
      if (J.get$kind$x(element) === C.ElementKind_class_4 && element.get$isNative())
        this.this_0.processNativeClass$1(element);
    },
    $isFunction: true
  },
  NativeEnqueuerBase_processSubclassesOfNativeClasses_closure: {
    "^": "Closure:13;this_0,potentialExtends_1",
    call$1: function(library) {
      J.get$implementation$x(library).forEachLocalMember$1(new L.NativeEnqueuerBase_processSubclassesOfNativeClasses__closure(this.this_0, this.potentialExtends_1));
    },
    $isFunction: true
  },
  NativeEnqueuerBase_processSubclassesOfNativeClasses__closure: {
    "^": "Closure:13;this_2,potentialExtends_3",
    call$1: function(element) {
      var extendsName;
      if (element.get$isClass() === true) {
        element.get$name(element);
        extendsName = this.this_2.findExtendsNameOfClass$1(element);
        if (extendsName != null)
          J.add$1$ax(this.potentialExtends_3.putIfAbsent$2(extendsName, new L.NativeEnqueuerBase_processSubclassesOfNativeClasses___closure()), element);
      }
    },
    $isFunction: true
  },
  NativeEnqueuerBase_processSubclassesOfNativeClasses___closure: {
    "^": "Closure:23;",
    call$0: function() {
      return P.LinkedHashSet_LinkedHashSet(null, null, null, O.ClassElement);
    },
    $isFunction: true
  },
  NativeEnqueuerBase_processSubclassesOfNativeClasses_nativeSuperclassOf: {
    "^": "Closure:210;",
    call$1: function(classElement) {
      if (classElement.get$isNative())
        return classElement;
      if (classElement.get$superclass() == null)
        return;
      return this.call$1(classElement.get$superclass());
    },
    $isFunction: true
  },
  NativeEnqueuerBase_processSubclassesOfNativeClasses_walkPotentialSubclasses: {
    "^": "Closure:45;this_4,potentialExtends_5,nativeSuperclassOf_6",
    call$1: function(element) {
      var t1, t2, nativeSuperclass, potentialSubclasses;
      t1 = this.this_4;
      t2 = t1.nativeClassesAndSubclasses;
      if (t2.contains$1(0, element))
        return;
      element.ensureResolved$1(t1.compiler);
      nativeSuperclass = this.nativeSuperclassOf_6.call$1(element);
      if (nativeSuperclass != null) {
        t2.add$1(0, element);
        if (element.get$nativeTagInfo() == null)
          J.add$1$ax(t1.nonNativeSubclasses.putIfAbsent$2(nativeSuperclass, new L.NativeEnqueuerBase_processSubclassesOfNativeClasses_walkPotentialSubclasses_closure()), element);
        potentialSubclasses = this.potentialExtends_5.$index(0, element.name);
        if (potentialSubclasses != null)
          J.forEach$1$ax(potentialSubclasses, this);
      }
    },
    $isFunction: true
  },
  NativeEnqueuerBase_processSubclassesOfNativeClasses_walkPotentialSubclasses_closure: {
    "^": "Closure:23;",
    call$0: function() {
      return P.LinkedHashSet_LinkedHashSet(null, null, null, O.ClassElement);
    },
    $isFunction: true
  },
  NativeEnqueuerBase_findExtendsNameOfClass_skipTypeParameters: {
    "^": "Closure:218;",
    call$1: function(token) {
      return token.get$endGroup().next;
    },
    $isFunction: true
  },
  NativeEnqueuerBase_findExtendsNameOfClass_scanForExtendsName: {
    "^": "Closure:219;skipTypeParameters_0",
    call$1: function(token) {
      var id;
      if (token.get$stringValue() === "abstract")
        token = token.next;
      if (token.get$stringValue() !== "class")
        return;
      token = token.next;
      if (!token.isIdentifier$0())
        return;
      token = token.next;
      if (token.get$stringValue() === "<")
        token = this.skipTypeParameters_0.call$1(token);
      if (token.get$stringValue() !== "extends")
        return;
      token = token.next;
      for (id = token; token.get$info().kind !== 0; id = token) {
        token = token.next;
        if (token.get$stringValue() !== ".")
          break;
        token = token.next;
        if (!token.isIdentifier$0())
          return;
      }
      return id.get$value(id);
    },
    $isFunction: true
  },
  NativeEnqueuerBase_findExtendsNameOfClass_closure: {
    "^": "Closure:23;classElement_1,scanForExtendsName_2",
    call$0: function() {
      var t1 = this.classElement_1;
      return this.scanForExtendsName_2.call$1(t1.get$position(t1));
    },
    $isFunction: true
  },
  NativeEnqueuerBase_findAnnotationClasses_find: {
    "^": "Closure:220;this_0",
    call$1: function($name) {
      var t1, t2, e;
      t1 = this.this_0.compiler;
      t2 = t1.backend;
      e = t2.find$2(0, t2.get$jsHelperLibrary(), $name);
      if (e == null || !e.$isClassElement)
        t1.internalError$2(C._SpannableSentinel_fBD, "Could not find implementation class '" + $name + "'.");
      return e;
    },
    $isFunction: true
  },
  NativeEnqueuerBase_enqueueClass_closure: {
    "^": "Closure:23;this_0,classElement_1,cause_2",
    call$0: function() {
      this.this_0.processClass$2(this.classElement_1, this.cause_2);
    },
    $isFunction: true
  },
  NativeEnqueuerBase_registerElement_closure: {
    "^": "Closure:23;this_0,element_1",
    call$0: function() {
      var t1, t2, t3;
      t1 = this.element_1;
      if (t1.get$isFunction() || t1.get$isGetter() || t1.get$kind(t1) === C.ElementKind_setter_0) {
        t2 = this.this_0;
        if (t2.isNativeMethod$1(t1) === true)
          t2.setNativeName$1(t1);
        if (t1.get$isNative()) {
          t2.processNativeBehavior$2(L.NativeBehavior_ofMethod(t1, t2.compiler), t1);
          t2.flushQueue$0();
        }
      } else if (t1.get$kind(t1) === C.ElementKind_field_1) {
        t2 = this.this_0;
        t2.handleFieldAnnotations$1(t1);
        if (t1.get$isNative()) {
          t3 = t2.compiler;
          t2.processNativeBehavior$2(L.NativeBehavior_ofFieldLoad(t1, t3), t1);
          t2.flushQueue$0();
          t2.processNativeBehavior$2(L.NativeBehavior_ofFieldStore(t1, t3), t1);
          t2.flushQueue$0();
        }
      }
    },
    $isFunction: true
  },
  NativeEnqueuerBase_isNativeMethod_closure: {
    "^": "Closure:23;this_0,element_1",
    call$0: function() {
      var node, t1;
      node = this.element_1.parseNode$1(this.this_0.compiler);
      t1 = J.getInterceptor(node);
      if (!t1.$isFunctionExpression)
        return false;
      if (t1.get$body(node).getBeginToken$0().get$stringValue() === "native")
        return true;
      return false;
    },
    $isFunction: true
  },
  NativeEnqueuerBase_processNativeBehavior_closure: {
    "^": "Closure:13;this_0,type_1",
    call$1: function(nativeClass) {
      var t1, t2;
      t1 = this.this_0.compiler.types;
      t2 = nativeClass.get$thisType();
      t1 = t1.subtypeVisitor;
      return t2.get$treatAsDynamic() || t1.isMoreSpecific$2(t2, this.type_1) === true;
    },
    $isFunction: true
  },
  NativeEnqueuerBase_enqueueUnusedClassesMatching_closure: {
    "^": "Closure:13;this_0,cause_1",
    call$1: function(c) {
      return this.this_0.enqueueClass$2(c, this.cause_1);
    },
    $isFunction: true
  },
  NativeEnqueuerBase_onFirstNativeClass_staticUse: {
    "^": "Closure:13;this_0",
    call$1: function($name) {
      var t1, t2, t3;
      t1 = this.this_0;
      t2 = t1.compiler;
      t3 = t2.backend;
      t3.enqueue$3(t1.world, t3.find$2(0, t3.get$jsHelperLibrary(), $name), t2.globalDependencies);
    },
    $isFunction: true
  },
  NativeEnqueuerBase_addNativeExceptions_closure: {
    "^": "Closure:13;",
    call$1: function(classElement) {
      var $name, t1;
      $name = J.get$name$x(classElement);
      t1 = J.getInterceptor$asx($name);
      if (t1.contains$1($name, "Exception"))
        return true;
      if (t1.contains$1($name, "Error"))
        return true;
      return false;
    },
    $isFunction: true
  },
  NativeResolutionEnqueuer: {
    "^": "NativeEnqueuerBase;tagOwner,nativeClasses,registeredClasses,pendingClasses,unusedClasses,processedLibraries,nativeClassesAndSubclasses,nonNativeSubclasses,matchedTypeConstraints,queue,flushing,nativeBehaviors,world,compiler,enableLiveTypeAnalysis,_annotationCreatesClass,_annotationReturnsClass,_annotationJsNameClass",
    processNativeClass$1: function(classElement) {
      var t1, t2, t3, tag, owner;
      L.NativeEnqueuerBase.prototype.processNativeClass$1.call(this, classElement);
      for (t1 = L.nativeTagsOfClass(classElement), t1 = H.setRuntimeTypeInfo(new H.ListIterator(t1, t1.length, 0, null), [H.getTypeArgumentByIndex(t1, 0)]), t2 = this.tagOwner, t3 = this.compiler; t1.moveNext$0();) {
        tag = t1.__internal$_current;
        owner = t2.$index(0, tag);
        if (owner != null) {
          if (owner !== classElement)
            t3.internalError$2(classElement, "Tag '" + H.S(tag) + "' already in use by '" + H.S(J.get$name$x(owner)) + "'");
        } else
          t2.$indexSet(0, tag, classElement);
      }
    },
    logSummary$1: function(log) {
      log.call$1("Resolved " + this.registeredClasses._collection$_length + " native elements used, " + this.unusedClasses._collection$_length + " native elements dead.");
    }
  },
  NativeCodegenEnqueuer: {
    "^": "NativeEnqueuerBase;emitter,doneAddSubtypes,nativeClasses,registeredClasses,pendingClasses,unusedClasses,processedLibraries,nativeClassesAndSubclasses,nonNativeSubclasses,matchedTypeConstraints,queue,flushing,nativeBehaviors,world,compiler,enableLiveTypeAnalysis,_annotationCreatesClass,_annotationReturnsClass,_annotationJsNameClass",
    processNativeClasses$1: function(libraries) {
      var t1, t2, classElement;
      L.NativeEnqueuerBase.prototype.processNativeClasses$1.call(this, libraries);
      for (t1 = this.compiler.enqueuer.resolution.nativeEnqueuer.get$registeredClasses(), t1 = H.setRuntimeTypeInfo(new P.LinkedHashSetIterator(t1, t1._modifications, null, null), [null]), t1._cell = t1._set._first, t2 = this.unusedClasses; t1.moveNext$0();) {
        classElement = t1._collection$_current;
        if (t2.contains$1(0, classElement))
          this.enqueueClass$2(classElement, "was resolved");
      }
      this.flushQueue$0();
    },
    processClass$2: function(classElement, cause) {
      L.NativeEnqueuerBase.prototype.processClass$2.call(this, classElement, cause);
      this.addSubtypes$2(classElement, this.emitter.nativeEmitter);
    },
    addSubtypes$2: function(cls, emitter) {
      var t1, type, superclass;
      if (!cls.get$isNative())
        return;
      t1 = this.doneAddSubtypes;
      if (t1.contains$1(0, cls))
        return;
      t1.add$1(0, cls);
      this.addSubtypes$2(cls.get$superclass(), emitter);
      for (t1 = cls.allSupertypesAndSelf._supertypes, t1.toString, t1 = H.setRuntimeTypeInfo(new E.LinkIterator(null, t1), [H.getTypeArgumentByIndex(t1, 0)]); t1.moveNext$0();) {
        type = t1._util_implementation$_current;
        J.add$1$ax(emitter.subtypes.putIfAbsent$2(type.get$element(), new L.NativeCodegenEnqueuer_addSubtypes_closure()), cls);
      }
      superclass = cls.get$superclass();
      while (true) {
        if (!(superclass != null && superclass.get$isMixinApplication()))
          break;
        superclass = superclass.get$superclass();
      }
      J.add$1$ax(emitter.directSubtypes.putIfAbsent$2(superclass, new L.NativeCodegenEnqueuer_addSubtypes_closure0()), cls);
    },
    logSummary$1: function(log) {
      log.call$1("Compiled " + this.registeredClasses._collection$_length + " native classes, " + this.unusedClasses._collection$_length + " native classes omitted.");
    }
  },
  NativeCodegenEnqueuer_addSubtypes_closure: {
    "^": "Closure:23;",
    call$0: function() {
      return H.setRuntimeTypeInfo([], [O.ClassElement]);
    },
    $isFunction: true
  },
  NativeCodegenEnqueuer_addSubtypes_closure0: {
    "^": "Closure:23;",
    call$0: function() {
      return H.setRuntimeTypeInfo([], [O.ClassElement]);
    },
    $isFunction: true
  },
  SideEffectsVisitor: {
    "^": "BaseVisitor;sideEffects<",
    visitLiteralExpression$1: function(node) {
      var t1 = this.sideEffects;
      t1.flags = (t1.flags | 7) >>> 0;
      t1.setDependsOnSomething$0();
      node.visitChildren$1(this);
    },
    visitLiteralStatement$1: function(node) {
      var t1 = this.sideEffects;
      t1.flags = (t1.flags | 7) >>> 0;
      t1.setDependsOnSomething$0();
    },
    visitAssignment$1: function(node) {
      var t1, t2;
      t1 = this.sideEffects;
      t2 = (t1.flags | 4) >>> 0;
      t1.flags = t2;
      t2 = (t2 | 2) >>> 0;
      t1.flags = t2;
      t1.flags = (t2 | 1) >>> 0;
      node.visitChildren$1(this);
    },
    visitVariableInitialization$1: function(node) {
      node.visitChildren$1(this);
    },
    visitCall$1: function(node) {
      var t1 = this.sideEffects;
      t1.flags = (t1.flags | 7) >>> 0;
      t1.setDependsOnSomething$0();
      node.visitChildren$1(this);
    },
    visitBinary$1: function(node) {
      node.left.accept$1(0, this);
      node.right.accept$1(0, this);
    },
    visitThrow$1: function(node) {
      var t1 = this.sideEffects;
      t1.flags = (t1.flags | 7) >>> 0;
    },
    visitNew$1: function(node) {
      var t1 = this.sideEffects;
      t1.flags = (t1.flags | 7) >>> 0;
      t1.setDependsOnSomething$0();
      node.visitChildren$1(this);
    },
    visitPrefix$1: function(node) {
      var t1, t2;
      if (node.op === "delete") {
        t1 = this.sideEffects;
        t2 = (t1.flags | 4) >>> 0;
        t1.flags = t2;
        t2 = (t2 | 2) >>> 0;
        t1.flags = t2;
        t1.flags = (t2 | 1) >>> 0;
      }
      node.argument.accept$1(0, this);
    },
    visitVariableUse$1: function(node) {
      var t1 = this.sideEffects;
      t1.flags = (t1.flags | 32) >>> 0;
    },
    visitPostfix$1: function(node) {
      node.argument.accept$1(0, this);
    },
    visitAccess$1: function(node) {
      var t1, t2;
      t1 = this.sideEffects;
      t2 = (t1.flags | 8) >>> 0;
      t1.flags = t2;
      t2 = (t2 | 16) >>> 0;
      t1.flags = t2;
      t1.flags = (t2 | 32) >>> 0;
      node.receiver.accept$1(0, this);
      node.selector.accept$1(0, this);
    },
    $asBaseVisitor: function() {
      return [null];
    }
  },
  NativeBehavior: {
    "^": "Object;typesReturned,typesInstantiated,codeTemplate,sideEffects<",
    _overrideWithAnnotations$2: function(element, compiler) {
      var t1, enqueuer, creates, returns;
      t1 = element.get$metadata();
      if (t1.get$isEmpty(t1))
        return;
      t1 = new L.NativeBehavior__overrideWithAnnotations_lookup(element, compiler);
      enqueuer = compiler.enqueuer.resolution.nativeEnqueuer;
      creates = L.NativeBehavior__collect(element, compiler, enqueuer.get$annotationCreatesClass(), t1);
      returns = L.NativeBehavior__collect(element, compiler, enqueuer.get$annotationReturnsClass(), t1);
      if (creates != null) {
        t1 = this.typesInstantiated;
        C.JSArray_methods.set$length(t1, 0);
        C.JSArray_methods.addAll$1(t1, creates);
      }
      if (returns != null) {
        t1 = this.typesReturned;
        C.JSArray_methods.set$length(t1, 0);
        C.JSArray_methods.addAll$1(t1, returns);
      }
    },
    _escape$2: function(type, compiler) {
      var t1, t2;
      type = type.unalias$1(compiler);
      if (!!J.getInterceptor(type).$isFunctionType) {
        this._escape$2(type.returnType, compiler);
        t1 = type.parameterTypes;
        t2 = new H.ListIterator(t1, t1.length, 0, null);
        t2.$builtinTypeInfo = [H.getTypeArgumentByIndex(t1, 0)];
        for (; t2.moveNext$0();)
          this._capture$2(t2.__internal$_current, compiler);
      }
    },
    _capture$2: function(type, compiler) {
      var t1, t2;
      type = type.unalias$1(compiler);
      if (!!J.getInterceptor(type).$isFunctionType) {
        this._capture$2(type.returnType, compiler);
        t1 = type.parameterTypes;
        t2 = new H.ListIterator(t1, t1.length, 0, null);
        t2.$builtinTypeInfo = [H.getTypeArgumentByIndex(t1, 0)];
        for (; t2.moveNext$0();)
          this._escape$2(t2.__internal$_current, compiler);
      } else
        this.typesInstantiated.push(type);
    },
    static: {"^": "NativeBehavior_NONE", NativeBehavior_processSpecString: function(listener, spannable, specString, nullType, objectType, resolveType, typesInstantiated, typesReturned) {
        var t1, t2, t3, returns, creates;
        t1 = {};
        t1.specString_0 = specString;
        t2 = new L.NativeBehavior_processSpecString_resolveTypesString(resolveType);
        if (J.contains$1$asx(specString, ":")) {
          t3 = new L.NativeBehavior_processSpecString_getTypesString(t1);
          returns = t3.call$1("returns");
          if (returns != null)
            t2.call$3$onType$onVar(returns, new L.NativeBehavior_processSpecString_closure(typesReturned), new L.NativeBehavior_processSpecString_closure0(typesReturned, objectType, nullType));
          creates = t3.call$1("creates");
          if (creates != null)
            t2.call$4$onType$onVar$onVoid(creates, new L.NativeBehavior_processSpecString_closure1(typesInstantiated), new L.NativeBehavior_processSpecString_closure2(listener, spannable, creates), new L.NativeBehavior_processSpecString_closure3(listener, spannable, creates));
          if (!J.get$isEmpty$asx(t1.specString_0))
            listener.internalError$2(spannable, "Invalid JS type string.");
        } else
          t2.call$3$onType$onVar(t1.specString_0, new L.NativeBehavior_processSpecString_closure4(typesReturned, typesInstantiated), new L.NativeBehavior_processSpecString_closure5(typesReturned, objectType, nullType));
      }, NativeBehavior_ofJsCall: function(jsCall, compiler, resolver) {
        var argNodes, t1, code, specLiteral, t2, t3, behavior, t4, specString;
        argNodes = jsCall.argumentsNode.nodes;
        if (argNodes.get$isEmpty(argNodes))
          compiler.internalError$2(jsCall, "JS expression has no type.");
        t1 = argNodes.get$tail();
        code = t1.get$head(t1);
        if (!J.getInterceptor(code).$isStringNode || code.get$isInterpolation() === true)
          compiler.internalError$2(code, "JS code must be a string literal.");
        specLiteral = argNodes.get$head(argNodes).asLiteralString$0();
        if (specLiteral == null)
          compiler.internalError$2(argNodes.get$head(argNodes), "Unexpected JS first argument.");
        t1 = [];
        t2 = [];
        t3 = new Z.SideEffects(0);
        behavior = new L.NativeBehavior(t1, t2, null, t3);
        t4 = C.C_JsBuilder.parseForeignJS$1(code.get$dartString().slowToString$0());
        behavior.codeTemplate = t4;
        t4.ast.accept$1(0, new L.SideEffectsVisitor(t3));
        specString = specLiteral.dartString.slowToString$0();
        t3 = compiler.objectClass.computeType$1(compiler);
        L.NativeBehavior_processSpecString(compiler, jsCall, specString, compiler.nullClass.computeType$1(compiler), t3, new L.NativeBehavior_ofJsCall_resolveType(jsCall, compiler, resolver, specLiteral), t2, t1);
        return behavior;
      }, NativeBehavior_ofMethod: function(method, compiler) {
        var type, t1, behavior, t2;
        type = method.computeType$1(compiler);
        t1 = [];
        behavior = new L.NativeBehavior(t1, [], null, new Z.SideEffects(0));
        t2 = type.returnType;
        t1.push(t2);
        if (t2.get$kind(t2) !== C.TypeKind_void)
          t1.push(compiler.nullClass.computeType$1(compiler));
        behavior._capture$2(type, compiler);
        method.get$functionSignature().forEachOptionalParameter$1(new L.NativeBehavior_ofMethod_closure(compiler, behavior));
        behavior._overrideWithAnnotations$2(method, compiler);
        return behavior;
      }, NativeBehavior_ofFieldLoad: function(field, compiler) {
        var type, t1, behavior;
        type = field.computeType$1(compiler);
        t1 = [];
        behavior = new L.NativeBehavior(t1, [], null, new Z.SideEffects(0));
        t1.push(type);
        t1.push(compiler.nullClass.computeType$1(compiler));
        behavior._capture$2(type, compiler);
        behavior._overrideWithAnnotations$2(field, compiler);
        return behavior;
      }, NativeBehavior_ofFieldStore: function(field, compiler) {
        var behavior = new L.NativeBehavior([], [], null, new Z.SideEffects(0));
        behavior._escape$2(field.computeType$1(compiler), compiler);
        return behavior;
      }, NativeBehavior__collect: function(element, compiler, annotationClass, lookup) {
        var link, types, annotation, value, t1, fields, t2, type;
        for (link = element.get$metadata(), types = null; !link.get$isEmpty(link); link = link.get$tail()) {
          annotation = link.get$head(link).ensureResolved$1(compiler);
          value = annotation.value;
          if (!J.getInterceptor(value).$isConstructedConstant)
            continue;
          t1 = value.type;
          if (!J.getInterceptor(t1).$isInterfaceType)
            continue;
          t1 = t1.get$element();
          if (t1 == null ? annotationClass != null : t1 !== annotationClass)
            continue;
          fields = value.fields;
          t1 = fields.length;
          if (t1 === 1) {
            if (0 >= t1)
              return H.ioore(fields, 0);
            t1 = !J.getInterceptor(fields[0]).$isStringConstant;
          } else
            t1 = true;
          if (t1)
            compiler.internalError$2(annotation, "Annotations needs one string: " + J.toString$0(annotation.parseNode$1(compiler)));
          if (0 >= fields.length)
            return H.ioore(fields, 0);
          t1 = fields[0].toDartString$0().slowToString$0().split("|");
          t2 = new H.ListIterator(t1, t1.length, 0, null);
          t2.$builtinTypeInfo = [H.getTypeArgumentByIndex(t1, 0)];
          for (; t2.moveNext$0();) {
            type = L.NativeBehavior__parseType(t2.__internal$_current, compiler, lookup, annotation);
            if (types == null)
              types = [];
            types.push(type);
          }
        }
        return types;
      }, NativeBehavior__parseType: function(typeString, compiler, lookup, locationNodeOrElement) {
        var t1, type, index;
        t1 = J.getInterceptor(typeString);
        if (t1.$eq(typeString, "=Object"))
          return C.SpecialType_MYA;
        if (t1.$eq(typeString, "dynamic"))
          return C.C_DynamicType;
        type = lookup.call$1(typeString);
        if (type != null)
          return type;
        index = t1.indexOf$1(typeString, "<");
        if (index < 1)
          compiler.internalError$2(L.NativeBehavior__errorNode(locationNodeOrElement, compiler), "Type '" + H.S(typeString) + "' not found.");
        type = lookup.call$1(t1.substring$2(typeString, 0, index));
        if (type != null)
          return type;
        compiler.internalError$2(L.NativeBehavior__errorNode(locationNodeOrElement, compiler), "Type '" + typeString + "' not found.");
      }, NativeBehavior__errorNode: function(locationNodeOrElement, compiler) {
        if (!!locationNodeOrElement.$isNode)
          return locationNodeOrElement;
        return locationNodeOrElement.parseNode$1(compiler);
      }}
  },
  NativeBehavior_processSpecString_resolveTypesString: {
    "^": "Closure:221;resolveType_1",
    call$4$onType$onVar$onVoid: function(typesString, onType, onVar, onVoid) {
      var t1, t2;
      if (typesString === "void") {
        if (onVoid != null)
          onVoid.call$0();
        return;
      }
      if (typesString === "" || typesString === "var") {
        onVar.call$0();
        return;
      }
      for (t1 = typesString.split("|"), t1 = H.setRuntimeTypeInfo(new H.ListIterator(t1, t1.length, 0, null), [H.getTypeArgumentByIndex(t1, 0)]), t2 = this.resolveType_1; t1.moveNext$0();)
        onType.call$1(t2.call$1(t1.__internal$_current));
    },
    call$1: function(typesString) {
      return this.call$4$onType$onVar$onVoid(typesString, null, null, null);
    },
    call$3$onType$onVar: function(typesString, onType, onVar) {
      return this.call$4$onType$onVar$onVoid(typesString, onType, onVar, null);
    },
    $isFunction: true
  },
  NativeBehavior_processSpecString_getTypesString: {
    "^": "Closure:3;box_0",
    call$1: function(tag) {
      var marker, t1, startPos, endPos, typeString;
      marker = tag + ":";
      t1 = this.box_0;
      startPos = J.indexOf$1$asx(t1.specString_0, marker);
      if (startPos === -1)
        return;
      endPos = J.indexOf$2$asx(t1.specString_0, ";", startPos);
      if (endPos === -1)
        return;
      typeString = J.substring$2$s(t1.specString_0, startPos + marker.length, endPos);
      t1.specString_0 = C.JSString_methods.trim$0(J.substring$2$s(t1.specString_0, 0, startPos) + J.substring$1$s(t1.specString_0, endPos + 1));
      return typeString;
    },
    $isFunction: true
  },
  NativeBehavior_processSpecString_closure0: {
    "^": "Closure:23;typesReturned_2,objectType_3,nullType_4",
    call$0: function() {
      var t1 = this.typesReturned_2;
      t1.push(this.objectType_3);
      t1.push(this.nullType_4);
    },
    $isFunction: true
  },
  NativeBehavior_processSpecString_closure: {
    "^": "Closure:13;typesReturned_5",
    call$1: function(type) {
      this.typesReturned_5.push(type);
    },
    $isFunction: true
  },
  NativeBehavior_processSpecString_closure3: {
    "^": "Closure:23;listener_6,spannable_7,creates_8",
    call$0: function() {
      this.listener_6.internalError$2(this.spannable_7, "Invalid type string 'creates:" + this.creates_8 + "'");
    },
    $isFunction: true
  },
  NativeBehavior_processSpecString_closure2: {
    "^": "Closure:23;listener_9,spannable_10,creates_11",
    call$0: function() {
      this.listener_9.internalError$2(this.spannable_10, "Invalid type string 'creates:" + this.creates_11 + "'");
    },
    $isFunction: true
  },
  NativeBehavior_processSpecString_closure1: {
    "^": "Closure:13;typesInstantiated_12",
    call$1: function(type) {
      this.typesInstantiated_12.push(type);
    },
    $isFunction: true
  },
  NativeBehavior_processSpecString_closure5: {
    "^": "Closure:23;typesReturned_13,objectType_14,nullType_15",
    call$0: function() {
      var t1 = this.typesReturned_13;
      t1.push(this.objectType_14);
      t1.push(this.nullType_15);
    },
    $isFunction: true
  },
  NativeBehavior_processSpecString_closure4: {
    "^": "Closure:13;typesReturned_16,typesInstantiated_17",
    call$1: function(type) {
      this.typesInstantiated_17.push(type);
      this.typesReturned_16.push(type);
    },
    $isFunction: true
  },
  NativeBehavior_ofJsCall_resolveType: {
    "^": "Closure:0;jsCall_0,compiler_1,resolver_2,specLiteral_3",
    call$1: function(typeString) {
      return L.NativeBehavior__parseType(typeString, this.compiler_1, new L.NativeBehavior_ofJsCall_resolveType_closure(this.resolver_2, this.specLiteral_3), this.jsCall_0);
    },
    $isFunction: true
  },
  NativeBehavior_ofJsCall_resolveType_closure: {
    "^": "Closure:13;resolver_4,specLiteral_5",
    call$1: function($name) {
      return this.resolver_4.resolveTypeFromString$2(this.specLiteral_5, $name);
    },
    $isFunction: true
  },
  NativeBehavior_ofMethod_closure: {
    "^": "Closure:50;compiler_0,behavior_1",
    call$1: function(parameter) {
      this.behavior_1._escape$2(J.get$type$x(parameter), this.compiler_0);
    },
    $isFunction: true
  },
  NativeBehavior__overrideWithAnnotations_lookup: {
    "^": "Closure:222;element_0,compiler_1",
    call$1: function($name) {
      var e = this.element_0.buildScope$0().lookup$1($name);
      if (e == null)
        return;
      if (!e.$isClassElement)
        return;
      e.ensureResolved$1(this.compiler_1);
      return e.get$thisType();
    },
    $isFunction: true
  },
  nativeTagsOfClass_closure: {
    "^": "Closure:13;",
    call$1: function(s) {
      return !J.startsWith$1$s(s, "!");
    },
    $isFunction: true
  },
  handleSsaNative_convertDartClosure: {
    "^": "Closure:223;builder_0,nativeBody_1,compiler_2,backend_3",
    call$2: function(parameter, type) {
      var t1, local, arity, t2;
      t1 = this.builder_0;
      local = t1.localsHandler.readLocal$1(parameter);
      arity = t1.graph.addConstant$2(t1.constantSystem.createInt$1(type.computeArity$0()), this.compiler_2);
      t2 = this.backend_3;
      t1.pushInvokeStatic$3(this.nativeBody_1, t2.find$2(0, t2.jsHelperLibrary, "convertDartClosureToJS"), [local, arity]);
      t1 = t1.stack;
      if (0 >= t1.length)
        return H.ioore(t1, 0);
      return t1.pop();
    },
    $isFunction: true
  },
  handleSsaNative_closure: {
    "^": "Closure:50;builder_4,compiler_5,convertDartClosure_6,arguments_7,inputs_8",
    call$1: function(parameter) {
      var type, input;
      type = J.get$type$x(parameter).unalias$1(this.compiler_5);
      input = this.builder_4.localsHandler.readLocal$1(parameter);
      if (!!J.getInterceptor(type).$isFunctionType)
        input = this.convertDartClosure_6.call$2(parameter, type);
      this.inputs_8.push(input);
      this.arguments_7.push("#");
    },
    $isFunction: true
  }
}],
["ordered_typeset", "package:compiler/implementation/ordered_typeset.dart", , Y, {
  "^": "",
  OrderedTypeSet: {
    "^": "Object;_levels,types<,_supertypes",
    extendClass$1: function(type) {
      var t1, extendedTypes, t2, t3, list, t4, i, t5;
      t1 = this.types;
      extendedTypes = E.LinkEntry$(type, t1, V.DartType);
      t2 = this._levels;
      t3 = t2.length;
      list = H.setRuntimeTypeInfo(Array(t3 + 1), [[O.Link, V.DartType]]);
      for (t4 = list.length, i = 0; i < t3; ++i) {
        t5 = t2[i];
        if (i >= t4)
          return H.ioore(list, i);
        list[i] = t5;
      }
      if (t3 >= t4)
        return H.ioore(list, t3);
      list[t3] = extendedTypes;
      return new Y.OrderedTypeSet(list, extendedTypes, this._supertypes.prepend$1(t1.get$head(t1)));
    },
    $index: function(_, index) {
      var t1, t2;
      t1 = this._levels;
      t2 = t1.length;
      if (J.$lt$n(index, t2)) {
        if (index >>> 0 !== index || index >= t2)
          return H.ioore(t1, index);
        return t1[index];
      }
      return C.C_Link0;
    },
    forEach$2: function(_, level, f) {
      var t1, t2, pointer;
      t1 = this._levels;
      t2 = t1.length;
      if (level < t2) {
        if (level < 0)
          return H.ioore(t1, level);
        pointer = t1[level];
        for (; pointer == null ? (level > 0 ? t1[level - 1] : C.C_Link0) != null : pointer !== (level > 0 ? t1[level - 1] : C.C_Link0);) {
          f.call$1(pointer.get$head(pointer));
          pointer = pointer.get$tail();
        }
      }
    },
    asInstanceOf$1: function(cls) {
      var level, t1, t2, pointer;
      level = cls.get$hierarchyDepth();
      t1 = this._levels;
      t2 = t1.length;
      if (level < t2) {
        if (level < 0)
          return H.ioore(t1, level);
        pointer = t1[level];
        for (; pointer == null ? (level > 0 ? t1[level - 1] : C.C_Link0) != null : pointer !== (level > 0 ? t1[level - 1] : C.C_Link0);) {
          if (cls === pointer.get$head(pointer).get$element())
            return pointer.get$head(pointer);
          pointer = pointer.get$tail();
        }
      }
      return;
    },
    toString$0: function(_) {
      return J.toString$0(this.types);
    }
  },
  OrderedTypeSetBuilder: {
    "^": "Object;map,allSupertypes<,maxDepth,cls<",
    map$1: function($receiver, arg0) {
      return this.map.call$1(arg0);
    },
    add$2: function(_, compiler, type) {
      var t1, t2;
      if (type.get$element() === this.cls) {
        t1 = type.get$element();
        t2 = compiler.objectClass;
        if (t1 == null ? t2 != null : t1 !== t2)
          this.allSupertypes.addLast$1(t2.get$rawType());
        this._addAtDepth$3(compiler, type, this.maxDepth + 1);
      } else {
        t1 = type.get$element();
        t2 = compiler.objectClass;
        if (t1 == null ? t2 != null : t1 !== t2)
          this.allSupertypes.addLast$1(type);
        this._addAtDepth$3(compiler, type, type.get$element().get$hierarchyDepth());
      }
    },
    _addAtDepth$3: function(compiler, type, depth) {
      var t1, link, prev, existingType, t2, t3, link0, next;
      t1 = this.map;
      link = t1.$index(0, depth);
      for (prev = null; link != null; prev = link, link = link0) {
        existingType = J.get$head$x(link);
        if (J.$eq(existingType, type))
          return;
        t2 = existingType.get$element();
        t3 = type.get$element();
        if (t2 == null ? t3 == null : t2 === t3) {
          t1 = this.cls;
          compiler.reportDiagnosticInternal$4(t1, C.MessageKind_Jsm, P.LinkedHashMap_LinkedHashMap$_literal(["thisType", t1.get$thisType(), "firstType", existingType, "secondType", type], null, null), C.Diagnostic_1_error);
          return;
        }
        link0 = link.get$tail();
      }
      next = E.LinkEntry$(type, null, V.DartType);
      next.tail = null;
      if (prev == null)
        t1.$indexSet(0, depth, next);
      else
        prev.set$tail(next);
      if (depth > this.maxDepth)
        this.maxDepth = depth;
    },
    toTypeSet$0: function() {
      var levels, t1, t2, next, depth, first, last;
      levels = H.setRuntimeTypeInfo(Array(this.maxDepth + 1), [[O.Link, V.DartType]]);
      if (this.maxDepth < 0)
        return new Y.OrderedTypeSet(levels, C.C_Link0, C.C_Link0);
      for (t1 = levels.length, t2 = this.map, next = C.C_Link0, depth = 0; depth <= this.maxDepth; ++depth) {
        first = t2.$index(0, depth);
        if (first == null) {
          if (depth >= t1)
            return H.ioore(levels, depth);
          levels[depth] = next;
        } else {
          if (depth >= t1)
            return H.ioore(levels, depth);
          levels[depth] = first;
          for (last = first; last.get$tail() != null;)
            last = last.get$tail();
          last.set$tail(next);
          next = first;
        }
      }
      return new Y.OrderedTypeSet(levels, C.JSArray_methods.get$last(levels), this.allSupertypes.toLink$0());
    },
    toString$0: function(_) {
      var sb, t1, depth, t2, first;
      sb = P.StringBuffer$("");
      for (t1 = this.map, depth = 0; depth <= this.maxDepth; ++depth) {
        t2 = "" + depth + ": ";
        sb._contents += t2;
        first = t1.$index(0, depth);
        if (first != null) {
          t2 = H.S(J.get$head$x(first));
          sb._contents += t2;
          for (; first.get$tail() != null;) {
            t2 = first.get$tail();
            t2 = ", " + H.S(t2.get$head(t2));
            sb._contents += t2;
            first = first.get$tail();
          }
        }
        sb._contents += "\n";
      }
      return sb._contents;
    }
  }
}],
["patchparser", "package:compiler/implementation/patch_parser.dart", , S, {
  "^": "",
  patchElement: function(compiler, origin, patch) {
    var t1;
    if (origin == null) {
      compiler.reportDiagnosticInternal$4(patch, C.MessageKind_dIz, P.LinkedHashMap_LinkedHashMap$_literal(["name", patch.get$name(patch)], null, null), C.Diagnostic_1_error);
      return;
    }
    if (origin.get$kind(origin) !== C.ElementKind_class_4) {
      t1 = origin.kind;
      t1 = t1 === C.ElementKind_generative_constructor_16 || origin.get$isFactoryConstructor() || origin.get$isFunction() || t1 === C.ElementKind_abstract_field_1;
    } else
      t1 = true;
    if (!t1) {
      compiler.reportDiagnosticInternal$4(origin, C.MessageKind_yDL0, C.Map_empty, C.Diagnostic_1_error);
      return;
    }
    if (patch.get$kind(patch) === C.ElementKind_class_4)
      S.tryPatchClass(compiler, origin, patch);
    else if (patch.get$isGetter())
      S.tryPatchGetter(compiler, origin, patch);
    else {
      t1 = patch.kind;
      if (t1 === C.ElementKind_setter_0)
        S.tryPatchSetter(compiler, origin, patch);
      else if (t1 === C.ElementKind_generative_constructor_16 || patch.get$isFactoryConstructor())
        S.tryPatchConstructor(compiler, origin, patch);
      else if (patch.get$isFunction())
        S.tryPatchFunction(compiler, origin, patch);
      else
        compiler.reportDiagnosticInternal$4(patch, C.MessageKind_yDL0, C.Map_empty, C.Diagnostic_1_error);
    }
  },
  tryPatchClass: function(compiler, origin, patch) {
    if (origin.get$kind(origin) !== C.ElementKind_class_4) {
      compiler.reportDiagnosticInternal$4(origin, C.MessageKind_MYA, P.LinkedHashMap_LinkedHashMap$_literal(["className", patch.get$name(patch)], null, null), C.Diagnostic_1_error);
      compiler.reportDiagnosticInternal$4(patch, C.MessageKind_cgH, P.LinkedHashMap_LinkedHashMap$_literal(["className", patch.name], null, null), C.Diagnostic_8_info);
      return;
    }
    if (origin.get$isPatched())
      compiler.internalError$2(origin, "Patching the same class more than once.");
    origin.applyPatch$1(patch);
    S.EagerAnnotationHandler_checkAnnotation(compiler, patch, C.C_NativeAnnotationHandler);
  },
  EagerAnnotationHandler_checkAnnotation: function(compiler, element, handler) {
    var link, annotation, t1;
    for (link = element.get$metadata(); !link.get$isEmpty(link); link = link.get$tail()) {
      annotation = link.get$head(link);
      if (handler.apply$3(compiler, element, annotation)) {
        t1 = compiler.enqueuer.resolution;
        if (t1.queueIsClosed)
          H.throwExpression(O.SpannableAssertionFailure$(element, "Resolution work list is closed. Trying to add deferred action for " + H.S(element)));
        t1.deferredTaskQueue._add$1(new K.DeferredTask(element, new S.EagerAnnotationHandler_checkAnnotation_closure(compiler, element, handler, annotation)));
        return true;
      }
    }
    return false;
  },
  tryPatchGetter: function(listener, origin, patch) {
    if (origin.get$kind(origin) !== C.ElementKind_abstract_field_1) {
      listener.reportDiagnosticInternal$4(origin, C.MessageKind_q9Q0, P.LinkedHashMap_LinkedHashMap$_literal(["name", origin.name], null, null), C.Diagnostic_1_error);
      listener.reportDiagnosticInternal$4(patch, C.MessageKind_2Rm0, P.LinkedHashMap_LinkedHashMap$_literal(["getterName", patch.get$name(patch)], null, null), C.Diagnostic_8_info);
      return;
    }
    if (origin.get$getter() == null) {
      listener.reportDiagnosticInternal$4(origin, C.MessageKind_IFE, P.LinkedHashMap_LinkedHashMap$_literal(["getterName", patch.get$name(patch)], null, null), C.Diagnostic_1_error);
      listener.reportDiagnosticInternal$4(patch, C.MessageKind_2Rm0, P.LinkedHashMap_LinkedHashMap$_literal(["getterName", patch.name], null, null), C.Diagnostic_8_info);
      return;
    }
    S.patchFunction(listener, origin.getter, patch);
  },
  tryPatchSetter: function(listener, origin, patch) {
    if (origin.get$kind(origin) !== C.ElementKind_abstract_field_1) {
      listener.reportDiagnosticInternal$4(origin, C.MessageKind_q9Q, P.LinkedHashMap_LinkedHashMap$_literal(["name", origin.name], null, null), C.Diagnostic_1_error);
      listener.reportDiagnosticInternal$4(patch, C.MessageKind_2Rm, P.LinkedHashMap_LinkedHashMap$_literal(["setterName", patch.get$name(patch)], null, null), C.Diagnostic_8_info);
      return;
    }
    if (origin.get$setter() == null) {
      listener.reportDiagnosticInternal$4(origin, C.MessageKind_C1h, P.LinkedHashMap_LinkedHashMap$_literal(["setterName", patch.get$name(patch)], null, null), C.Diagnostic_1_error);
      listener.reportDiagnosticInternal$4(patch, C.MessageKind_2Rm, P.LinkedHashMap_LinkedHashMap$_literal(["setterName", patch.name], null, null), C.Diagnostic_8_info);
      return;
    }
    S.patchFunction(listener, origin.setter, patch);
  },
  tryPatchConstructor: function(listener, origin, patch) {
    if (!(origin.get$kind(origin) === C.ElementKind_generative_constructor_16 || origin.get$isFactoryConstructor())) {
      listener.reportDiagnosticInternal$4(origin, C.MessageKind_6hp, P.LinkedHashMap_LinkedHashMap$_literal(["constructorName", patch.get$name(patch)], null, null), C.Diagnostic_1_error);
      listener.reportDiagnosticInternal$4(patch, C.MessageKind_yzJ, P.LinkedHashMap_LinkedHashMap$_literal(["constructorName", patch.name], null, null), C.Diagnostic_8_info);
      return;
    }
    S.patchFunction(listener, origin, patch);
  },
  tryPatchFunction: function(listener, origin, patch) {
    if (!origin.get$isFunction()) {
      listener.reportDiagnosticInternal$4(origin, C.MessageKind_Wfv0, P.LinkedHashMap_LinkedHashMap$_literal(["functionName", patch.get$name(patch)], null, null), C.Diagnostic_1_error);
      listener.reportDiagnosticInternal$4(patch, C.MessageKind_qhc, P.LinkedHashMap_LinkedHashMap$_literal(["functionName", patch.name], null, null), C.Diagnostic_8_info);
      return;
    }
    S.patchFunction(listener, origin, patch);
  },
  patchFunction: function(listener, origin, patch) {
    if ((origin.get$modifiers().flags & 64) === 0) {
      listener.reportDiagnosticInternal$4(origin, C.MessageKind_csC0, C.Map_empty, C.Diagnostic_1_error);
      listener.reportDiagnosticInternal$4(patch, C.MessageKind_qhc, P.LinkedHashMap_LinkedHashMap$_literal(["functionName", patch.get$name(patch)], null, null), C.Diagnostic_8_info);
      return;
    }
    if (origin.get$isPatched())
      listener.internalError$2(origin, "Trying to patch a function more than once.");
    origin.applyPatch$1(patch);
  },
  PatchParserTask: {
    "^": "CompilerTask;name>,compiler,watch,profilerTag",
    patchLibrary$3: function(loader, patchUri, originLibrary) {
      return this.compiler.readScript$2(originLibrary, patchUri).then$1(new S.PatchParserTask_patchLibrary_closure(this, loader, originLibrary));
    },
    scanLibraryElements$1: function(compilationUnit) {
      this.measure$1(new S.PatchParserTask_scanLibraryElements_closure(this, compilationUnit));
    },
    parsePatchClassNode$1: function(element) {
      if (element.get$cachedNode() != null)
        return;
      this.measure$1(new S.PatchParserTask_parsePatchClassNode_closure(this, element));
    },
    applyContainerPatch$2: function(originClass, patches) {
      var t1, t2, patch;
      for (patches.toString, t1 = H.setRuntimeTypeInfo(new E.LinkIterator(null, patches), [H.getTypeArgumentByIndex(patches, 0)]), t2 = this.compiler; t1.moveNext$0();) {
        patch = t1._util_implementation$_current;
        if (!S.EagerAnnotationHandler_checkAnnotation(t2, patch, C.C_PatchAnnotationHandler))
          continue;
        S.patchElement(t2, originClass.localLookup$1(J.get$name$x(patch)), patch);
      }
    }
  },
  PatchParserTask_patchLibrary_closure: {
    "^": "Closure:132;this_0,loader_1,originLibrary_2",
    call$1: function(script) {
      var patchLibrary, t1;
      patchLibrary = U.LibraryElementX$(script, null, this.originLibrary_2);
      t1 = this.this_0;
      return t1.compiler.withCurrentElement$2(patchLibrary, new S.PatchParserTask_patchLibrary__closure(t1, this.loader_1, patchLibrary));
    },
    $isFunction: true
  },
  PatchParserTask_patchLibrary__closure: {
    "^": "Closure:23;this_3,loader_4,patchLibrary_5",
    call$0: function() {
      var t1, t2, t3;
      t1 = this.loader_4;
      t2 = this.patchLibrary_5;
      t1.registerNewLibrary$1(t2);
      t3 = this.this_3;
      t3.compiler.withCurrentElement$2(t2.entryCompilationUnit, new S.PatchParserTask_patchLibrary___closure(t3, t2));
      return t1.task.processLibraryTags$2(t1, t2);
    },
    $isFunction: true
  },
  PatchParserTask_patchLibrary___closure: {
    "^": "Closure:23;this_6,patchLibrary_7",
    call$0: function() {
      this.this_6.scanLibraryElements$1(this.patchLibrary_7.entryCompilationUnit);
    },
    $isFunction: true
  },
  PatchParserTask_scanLibraryElements_closure: {
    "^": "Closure:23;this_0,compilationUnit_1",
    call$0: function() {
      var t1, tokens, t2;
      t1 = this.compilationUnit_1;
      tokens = Y.Scanner_Scanner(t1.script.file, false).tokenize$0();
      t2 = this.this_0.compiler;
      new Y.PartialParser(new S.PatchElementListener(t2, t2.get$getNextFreeClassId(), t2, t1, new B.StringValidator(t2), C.C_Link6, C.C_Link3, C.C_Link2, C.C_Link7, false), true).parseUnit$1(tokens);
    },
    $isFunction: true
  },
  PatchParserTask_parsePatchClassNode_closure: {
    "^": "Closure:23;this_0,element_1",
    call$0: function() {
      var t1, t2;
      t1 = this.this_0;
      t2 = this.element_1;
      return t1.compiler.withCurrentElement$2(t2, new S.PatchParserTask_parsePatchClassNode__closure(t1, t2));
    },
    $isFunction: true
  },
  PatchParserTask_parsePatchClassNode__closure: {
    "^": "Closure:23;this_2,element_3",
    call$0: function() {
      var t1, t2, t3, listener, patches;
      t1 = this.this_2;
      t2 = t1.compiler;
      t3 = this.element_3;
      listener = new Y.MemberListener(t3, false, null, t2, t3.get$compilationUnit(), new B.StringValidator(t2), C.C_Link6, C.C_Link3, C.C_Link2, C.C_Link7, false);
      new S.PatchClassElementParser(listener, true).parseTopLevelDeclaration$1(t3.beginToken);
      t3.cachedNode = listener.popNode$0();
      patches = t3.get$localMembers();
      t1.applyContainerPatch$2(t3.modelx$PatchMixin$origin, patches);
    },
    $isFunction: true
  },
  PatchClassElementParser: {
    "^": "PartialParser;listener,mayParseFunctionExpressions",
    parseClassBody$1: function(token) {
      return Y.Parser.prototype.parseClassBody$1.call(this, token);
    }
  },
  PatchElementListener: {
    "^": "ElementListener;compiler<,idGenerator,listener,compilationUnitElement,stringValidator,interpolationScope,nodes,metadata,memberErrors,suppressParseErrors",
    pushElement$1: function(patch) {
      Y.ElementListener.prototype.pushElement$1.call(this, patch);
      if (S.EagerAnnotationHandler_checkAnnotation(this.compiler, patch, C.C_PatchAnnotationHandler))
        S.patchElement(this.listener, this.compilationUnitElement.get$library().localLookup$1(patch.get$name(patch)), patch);
    }
  },
  EagerAnnotationHandler_checkAnnotation_closure: {
    "^": "Closure:23;compiler_0,element_1,handler_2,annotation_3",
    call$0: function() {
      var t1, t2;
      t1 = this.annotation_3;
      t2 = this.compiler_0;
      t1.ensureResolved$1(t2);
      this.handler_2.validate$4(t2, this.element_1, t1, t1.value);
    },
    $isFunction: true
  },
  NativeAnnotationHandler: {
    "^": "Object;",
    getNativeAnnotation$1: function(annotation) {
      var t1, argument;
      if (annotation.get$beginToken() != null) {
        t1 = annotation.get$beginToken().next;
        t1 = t1.get$value(t1) === "Native";
      } else
        t1 = false;
      if (t1) {
        argument = annotation.get$beginToken().next.next.next;
        t1 = J.getInterceptor(argument);
        if (!!t1.$isStringToken)
          return t1.get$value(argument);
      }
      return;
    },
    apply$3: function(compiler, element, annotation) {
      var $native;
      if (element.get$kind(element) === C.ElementKind_class_4) {
        $native = this.getNativeAnnotation$1(annotation);
        if ($native != null) {
          element.get$declaration().setNative$1($native);
          return true;
        }
      }
      return false;
    },
    validate$4: function(compiler, element, annotation, constant) {
      var t1, t2;
      t1 = constant.computeType$1(compiler).get$element();
      t2 = compiler.nativeAnnotationClass;
      if (t1 == null ? t2 != null : t1 !== t2)
        compiler.internalError$2(annotation, "Invalid @Native(...) annotation.");
    }
  },
  PatchAnnotationHandler: {
    "^": "Object;",
    apply$3: function(compiler, element, annotation) {
      var t1;
      if (annotation.get$beginToken() != null) {
        t1 = annotation.get$beginToken().next;
        t1 = t1.get$value(t1) === "patch";
      } else
        t1 = false;
      return t1;
    },
    validate$4: function(compiler, element, annotation, constant) {
      if (!J.$eq(constant, compiler.patchConstant))
        compiler.internalError$2(annotation, "Invalid patch annotation.");
    }
  }
}],
["resolution", "package:compiler/implementation/resolution/resolution.dart", , A, {
  "^": "",
  _ensureTreeElements: function(element) {
    var t1;
    if (element.get$_treeElements() == null) {
      t1 = $.TreeElementMapping__hashCodeCounter + 1;
      $.TreeElementMapping__hashCodeCounter = t1;
      element.resolution$AnalyzableElementX$_treeElements = new A.TreeElementMapping(element, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, t1);
    }
    return element.resolution$AnalyzableElementX$_treeElements;
  },
  Scope_buildEnclosingScope: function(element) {
    return element.get$enclosingElement() != null ? element.get$enclosingElement().buildScope$0() : element.buildScope$0();
  },
  TreeElementMapping: {
    "^": "Object;analyzedElement<,_selectors,_types,_superUses,_otherDependencies,_constants,_potentiallyMutated,_potentiallyMutatedIn,_potentiallyMutatedInClosure,_accessedByClosureIn,_resolution$_elements,_asserts,_definedTargets,_usedTargets,_definedLabels,_targetLabels,hashCode>",
    $indexSet: function(_, node, element) {
      var t1 = this._resolution$_elements;
      if (t1 == null) {
        t1 = H.setRuntimeTypeInfo(new N.Setlet(C.C__SetletMarker, null), [O.Element]);
        this._resolution$_elements = t1;
      }
      t1.add$1(0, element);
      node.set$_secret_tree_element$_element(element);
    },
    $index: function(_, node) {
      return node.get$_secret_tree_element$_element();
    },
    setType$2: function(node, type) {
      var t1 = this._types;
      if (t1 == null) {
        t1 = H.setRuntimeTypeInfo(new M.Maplet(C.C__MapletMarker, null, null), [Y.Node, V.DartType]);
        this._types = t1;
      }
      t1.$indexSet(0, node, type);
    },
    getType$1: function(node) {
      var t1 = this._types;
      return t1 != null ? t1.$index(0, node) : null;
    },
    _setSelector$2: function(node, selector) {
      var t1 = this._selectors;
      if (t1 == null) {
        t1 = H.setRuntimeTypeInfo(new M.Maplet(C.C__MapletMarker, null, null), [O.Spannable, Z.Selector]);
        this._selectors = t1;
      }
      t1.$indexSet(0, node, selector);
    },
    getSelector$1: function(node) {
      var t1 = this._selectors;
      return t1 != null ? t1.$index(0, node) : null;
    },
    getTypeLiteralType$1: function(node) {
      var t1 = this._types;
      return t1 != null ? t1.$index(0, node) : null;
    },
    registerDependency$1: function(element) {
      var t1;
      if (element == null)
        return;
      t1 = this._otherDependencies;
      if (t1 == null) {
        t1 = H.setRuntimeTypeInfo(new N.Setlet(C.C__SetletMarker, null), [O.Element]);
        this._otherDependencies = t1;
      }
      t1.add$1(0, element.get$implementation(element));
    },
    getPotentialMutations$1: function(element) {
      var t1, mutations;
      t1 = this._potentiallyMutated;
      if (t1 == null)
        return C.List_empty1;
      mutations = t1.$index(0, element);
      if (mutations == null)
        return C.List_empty1;
      return mutations;
    },
    registerPotentialMutation$2: function(element, mutationNode) {
      var t1 = this._potentiallyMutated;
      if (t1 == null) {
        t1 = H.setRuntimeTypeInfo(new M.Maplet(C.C__MapletMarker, null, null), [O.VariableElement, [P.List, Y.Node]]);
        this._potentiallyMutated = t1;
      }
      J.add$1$ax(t1.putIfAbsent$2(element, new A.TreeElementMapping_registerPotentialMutation_closure()), mutationNode);
    },
    getPotentialMutationsIn$2: function(node, element) {
      var t1, mutationsIn, mutations;
      t1 = this._potentiallyMutatedIn;
      if (t1 == null)
        return C.List_empty1;
      mutationsIn = t1.$index(0, node);
      if (mutationsIn == null)
        return C.List_empty1;
      mutations = J.$index$asx(mutationsIn, element);
      if (mutations == null)
        return C.List_empty1;
      return mutations;
    },
    registerPotentialMutationIn$3: function(contextNode, element, mutationNode) {
      var t1 = this._potentiallyMutatedIn;
      if (t1 == null) {
        t1 = H.setRuntimeTypeInfo(new M.Maplet(C.C__MapletMarker, null, null), [Y.Node, [P.Map, O.VariableElement, [P.List, Y.Node]]]);
        this._potentiallyMutatedIn = t1;
      }
      J.add$1$ax(t1.putIfAbsent$2(contextNode, new A.TreeElementMapping_registerPotentialMutationIn_closure()).putIfAbsent$2(element, new A.TreeElementMapping_registerPotentialMutationIn_closure0()), mutationNode);
    },
    getPotentialMutationsInClosure$1: function(element) {
      var t1, mutations;
      t1 = this._potentiallyMutatedInClosure;
      if (t1 == null)
        return C.List_empty1;
      mutations = t1.$index(0, element);
      if (mutations == null)
        return C.List_empty1;
      return mutations;
    },
    registerPotentialMutationInClosure$2: function(element, mutationNode) {
      var t1 = this._potentiallyMutatedInClosure;
      if (t1 == null) {
        t1 = H.setRuntimeTypeInfo(new M.Maplet(C.C__MapletMarker, null, null), [O.VariableElement, [P.List, Y.Node]]);
        this._potentiallyMutatedInClosure = t1;
      }
      J.add$1$ax(t1.putIfAbsent$2(element, new A.TreeElementMapping_registerPotentialMutationInClosure_closure()), mutationNode);
    },
    getAccessesByClosureIn$2: function(node, element) {
      var t1, accessesIn, accesses;
      t1 = this._accessedByClosureIn;
      if (t1 == null)
        return C.List_empty1;
      accessesIn = t1.$index(0, node);
      if (accessesIn == null)
        return C.List_empty1;
      accesses = J.$index$asx(accessesIn, element);
      if (accesses == null)
        return C.List_empty1;
      return accesses;
    },
    setAccessedByClosureIn$3: function(contextNode, element, accessNode) {
      var t1 = this._accessedByClosureIn;
      if (t1 == null) {
        t1 = P.LinkedHashMap_LinkedHashMap(null, null, null, Y.Node, [P.Map, O.VariableElement, [P.List, Y.Node]]);
        this._accessedByClosureIn = t1;
      }
      J.add$1$ax(t1.putIfAbsent$2(contextNode, new A.TreeElementMapping_setAccessedByClosureIn_closure()).putIfAbsent$2(element, new A.TreeElementMapping_setAccessedByClosureIn_closure0()), accessNode);
    },
    toString$0: function(_) {
      return "TreeElementMapping(" + H.S(this.analyzedElement) + ")";
    },
    registerTargetOf$2: function(node, target) {
      var t1 = this._usedTargets;
      if (t1 == null) {
        t1 = H.setRuntimeTypeInfo(new M.Maplet(C.C__MapletMarker, null, null), [Y.GotoStatement, O.JumpTarget]);
        this._usedTargets = t1;
      }
      t1.$indexSet(0, node, target);
    },
    defineLabel$2: function(label, target) {
      var t1 = this._definedLabels;
      if (t1 == null) {
        t1 = H.setRuntimeTypeInfo(new M.Maplet(C.C__MapletMarker, null, null), [Y.Label, O.LabelDefinition]);
        this._definedLabels = t1;
      }
      t1.$indexSet(0, label, target);
    },
    registerTargetLabel$2: function(node, label) {
      var t1 = this._targetLabels;
      if (t1 == null) {
        t1 = H.setRuntimeTypeInfo(new M.Maplet(C.C__MapletMarker, null, null), [Y.GotoStatement, O.LabelDefinition]);
        this._targetLabels = t1;
      }
      t1.$indexSet(0, node, label);
    },
    getTargetLabel$1: function(node) {
      var t1 = this._targetLabels;
      return t1 != null ? t1.$index(0, node) : null;
    },
    static: {"^": "TreeElementMapping__hashCodeCounter"}
  },
  TreeElementMapping_registerPotentialMutation_closure: {
    "^": "Closure:23;",
    call$0: function() {
      return H.setRuntimeTypeInfo([], [Y.Node]);
    },
    $isFunction: true
  },
  TreeElementMapping_registerPotentialMutationIn_closure: {
    "^": "Closure:23;",
    call$0: function() {
      return H.setRuntimeTypeInfo(new M.Maplet(C.C__MapletMarker, null, null), [O.VariableElement, [P.List, Y.Node]]);
    },
    $isFunction: true
  },
  TreeElementMapping_registerPotentialMutationIn_closure0: {
    "^": "Closure:23;",
    call$0: function() {
      return H.setRuntimeTypeInfo([], [Y.Node]);
    },
    $isFunction: true
  },
  TreeElementMapping_registerPotentialMutationInClosure_closure: {
    "^": "Closure:23;",
    call$0: function() {
      return H.setRuntimeTypeInfo([], [Y.Node]);
    },
    $isFunction: true
  },
  TreeElementMapping_setAccessedByClosureIn_closure: {
    "^": "Closure:23;",
    call$0: function() {
      return H.setRuntimeTypeInfo(new M.Maplet(C.C__MapletMarker, null, null), [O.VariableElement, [P.List, Y.Node]]);
    },
    $isFunction: true
  },
  TreeElementMapping_setAccessedByClosureIn_closure0: {
    "^": "Closure:23;",
    call$0: function() {
      return H.setRuntimeTypeInfo([], [Y.Node]);
    },
    $isFunction: true
  },
  ResolverTask: {
    "^": "CompilerTask;constantCompiler,currentlyResolvedTypeDeclaration,pendingClassesToBeResolved,pendingClassesToBePostProcessed,compiler,watch,profilerTag",
    get$name: function(_) {
      return "Resolver";
    },
    resolve$1: function(element) {
      return this.measure$1(new A.ResolverTask_resolve_closure(this, element));
    },
    resolveRedirectingConstructor$4: function(resolver, node, $constructor, redirection) {
      var seen, t1, t2;
      seen = H.setRuntimeTypeInfo(new N.Setlet(C.C__SetletMarker, null), [O.FunctionElement]);
      seen.add$1(0, $constructor);
      for (t1 = resolver.visitor, t2 = t1.compiler; redirection != null;) {
        redirection = redirection.get$implementation(redirection);
        if (seen.contains$1(0, redirection) === true)
          t2.reportFatalError$3(node, C.MessageKind_5iV, C.Map_empty);
        seen.add$1(0, redirection);
        redirection = t1.resolveConstructorRedirection$1(redirection);
      }
    },
    checkMatchingPatchParameters$3: function(origin, originParameters, patchParameters) {
      var t1, t2, originParameter, patchParameter, originParameterType, patchParameterType, originParameterText, patchParameterText;
      for (t1 = this.compiler, t2 = origin.name; !originParameters.get$isEmpty(originParameters);) {
        originParameter = originParameters.get$head(originParameters);
        patchParameter = patchParameters.get$head(patchParameters);
        if (!originParameter.get$isPatched())
          originParameter.applyPatch$1(patchParameter);
        originParameterType = originParameter.computeType$1(t1);
        patchParameterType = patchParameter.computeType$1(t1);
        if (!J.$eq(originParameterType, patchParameterType)) {
          t1.reportDiagnosticInternal$4(originParameter.parseNode$1(t1), C.MessageKind_63w, P.LinkedHashMap_LinkedHashMap$_literal(["methodName", t2, "parameterName", originParameter.name, "originParameterType", originParameterType, "patchParameterType", patchParameterType], null, null), C.Diagnostic_1_error);
          t1.reportDiagnosticInternal$4(patchParameter, C.MessageKind_jzZ, P.LinkedHashMap_LinkedHashMap$_literal(["parameterName", J.get$name$x(patchParameter)], null, null), C.Diagnostic_8_info);
        } else {
          originParameterText = J.toString$0(originParameter.parseNode$1(t1));
          patchParameterText = J.toString$0(patchParameter.parseNode$1(t1));
          if (originParameterText !== patchParameterText && origin !== t1.get$unnamedListConstructor()) {
            t1.reportDiagnosticInternal$4(originParameter.parseNode$1(t1), C.MessageKind_wco, P.LinkedHashMap_LinkedHashMap$_literal(["methodName", t2, "originParameter", originParameterText, "patchParameter", patchParameterText], null, null), C.Diagnostic_1_error);
            t1.reportDiagnosticInternal$4(patchParameter, C.MessageKind_jzZ, P.LinkedHashMap_LinkedHashMap$_literal(["parameterName", patchParameter.get$name(patchParameter)], null, null), C.Diagnostic_8_info);
          }
        }
        originParameters = originParameters.get$tail();
        patchParameters = patchParameters.get$tail();
      }
    },
    checkMatchingPatchSignatures$2: function(origin, patch) {
      var originSignature, patchTree, patchSignature, t1;
      origin.get$node();
      originSignature = origin.get$functionSignature();
      patchTree = patch.get$node();
      patchSignature = patch.get$functionSignature();
      if (!J.$eq(originSignature.get$type(originSignature).returnType, patchSignature.get$type(patchSignature).returnType))
        this.compiler.withCurrentElement$2(patch, new A.ResolverTask_checkMatchingPatchSignatures_closure(this, origin, originSignature, patchTree, patchSignature));
      if (originSignature.requiredParameterCount !== patchSignature.requiredParameterCount)
        this.compiler.withCurrentElement$2(patch, new A.ResolverTask_checkMatchingPatchSignatures_closure0(this, origin, originSignature, patchTree, patchSignature));
      else
        this.checkMatchingPatchParameters$3(origin, originSignature.requiredParameters, patchSignature.requiredParameters);
      t1 = originSignature.optionalParameterCount;
      if (t1 !== 0 && patchSignature.optionalParameterCount !== 0)
        if (originSignature.optionalParametersAreNamed !== patchSignature.optionalParametersAreNamed)
          this.compiler.withCurrentElement$2(patch, new A.ResolverTask_checkMatchingPatchSignatures_closure1(this, origin, patchTree));
      if (t1 !== patchSignature.optionalParameterCount)
        this.compiler.withCurrentElement$2(patch, new A.ResolverTask_checkMatchingPatchSignatures_closure2(this, origin, originSignature, patchTree, patchSignature));
      else
        this.checkMatchingPatchParameters$3(origin, originSignature.optionalParameters, patchSignature.optionalParameters);
    },
    resolveMethodElement$1: function(element) {
      var t1 = {};
      t1.element_0 = element;
      return this.compiler.withCurrentElement$2(element, new A.ResolverTask_resolveMethodElement_closure(t1, this));
    },
    resolveField$1: function(element) {
      var t1, tree, t2, visitor, registry, t3, t4, initializer, modifiers, t5;
      t1 = this.compiler;
      tree = element.parseNode$1(t1);
      if ((element.get$variables().modifiers.flags & 1) !== 0) {
        t2 = element.enclosingElement;
        t2 = t2 != null && t2.get$kind(t2) === C.ElementKind_compilation_unit_0;
      } else
        t2 = false;
      if (t2)
        t1.reportFatalError$3(element.variables.modifiers.findModifier$1("static"), C.MessageKind_S4x, C.Map_empty);
      visitor = A.ResolverVisitor$(t1, element, new A.ResolutionRegistry(t1, A._ensureTreeElements(element)), false);
      registry = visitor.registry;
      t2 = tree.get$definitions().nodes;
      t3 = registry.mapping;
      t3.$indexSet(0, t2.get$head(t2), element);
      t2 = tree.get$type(tree);
      t4 = element.variables;
      if (t2 != null)
        t4.type = visitor.resolveTypeAnnotation$1(tree.get$type(tree));
      else
        t4.type = C.C_DynamicType;
      initializer = element.get$initializer();
      modifiers = t4.modifiers;
      t2 = initializer != null;
      if (t2)
        initializer.accept$1(0, visitor);
      else {
        t4 = modifiers.flags;
        if ((t4 & 16) !== 0)
          t1.reportDiagnosticInternal$4(element, C.MessageKind_UQk, C.Map_empty, C.Diagnostic_1_error);
        else {
          if ((t4 & 4) !== 0) {
            t4 = element.enclosingElement;
            t5 = !(t4 != null && t4.get$kind(t4) === C.ElementKind_class_4 && (element.get$modifiers().flags & 1) === 0);
            t4 = t5;
          } else
            t4 = false;
          if (t4)
            t1.reportDiagnosticInternal$4(element, C.MessageKind_ACG, C.Map_empty, C.Diagnostic_1_error);
          else {
            t4 = t1.nullClass;
            t5 = registry.compiler.enqueuer.resolution;
            t4.ensureResolved$1(t5.compiler);
            t5.registerInstantiatedType$3$mirrorUsage(t4.get$rawType(), registry, false);
          }
        }
      }
      if (O.Elements_isStaticOrTopLevelField(element)) {
        t4 = visitor.compiler.enqueuer.resolution;
        if (t4.queueIsClosed)
          H.throwExpression(O.SpannableAssertionFailure$(element, "Resolution work list is closed. Trying to add deferred action for " + element.toString$0(0)));
        t4.deferredTaskQueue._add$1(new K.DeferredTask(element, new A.ResolverTask_resolveField_closure(this, element)));
        if (t2)
          if ((modifiers.flags & 16) === 0)
            registry.compiler.backend.get$resolutionCallbacks().onLazyField$1(registry);
      }
      element.computeType$1(t1);
      return t3;
    },
    resolveReturnType$2: function(element, annotation) {
      var t1, result;
      if (annotation == null)
        return C.C_DynamicType;
      t1 = this.compiler;
      result = A.ResolverVisitor$(t1, element, new A.ResolutionRegistry(t1, A._ensureTreeElements(element)), false).resolveTypeAnnotation$1(annotation);
      if (result == null)
        return C.C_DynamicType;
      return result;
    },
    resolveRedirectionChain$2: function($constructor, node) {
      var seen, targetType, t1, target, nextTarget, t2, factory, treeElements, functionNode, redirectionNode, factoryType;
      seen = H.setRuntimeTypeInfo([], [O.Element]);
      t1 = this.compiler;
      target = $constructor;
      while (true) {
        if (!(target.get$immediateRedirectionTarget() != null)) {
          targetType = null;
          break;
        }
        if (target.get$internalEffectiveTarget() != null) {
          targetType = target.effectiveTargetType;
          target = target.internalEffectiveTarget;
          break;
        }
        nextTarget = target.immediateRedirectionTarget;
        if (C.JSArray_methods.contains$1(seen, nextTarget))
          t1.reportFatalError$3(node, C.MessageKind_aPa, C.Map_empty);
        seen.push(target);
        target = nextTarget;
      }
      if (targetType == null)
        targetType = target.get$enclosingClass().get$thisType();
      for (; t2 = seen.length, t2 !== 0;) {
        if (0 >= t2)
          return H.ioore(seen, 0);
        factory = seen.pop();
        treeElements = factory.get$treeElements();
        functionNode = factory.parseNode$1(t1);
        redirectionNode = functionNode.get$body(functionNode);
        t2 = treeElements._types;
        factoryType = t2 != null ? t2.$index(0, redirectionNode) : null;
        targetType.toString;
        targetType = targetType.subst$2(factoryType.get$typeArguments(), factoryType.get$element().get$typeVariables());
        factory.internalEffectiveTarget = target;
        factory.effectiveTargetType = targetType;
      }
    },
    loadSupertypes$2: function(cls, from) {
      this.compiler.withCurrentElement$2(cls, new A.ResolverTask_loadSupertypes_closure(this, cls, from));
    },
    _resolveTypeDeclaration$2: function(element, resolveTypeDeclaration) {
      return this.compiler.withCurrentElement$2(element, new A.ResolverTask__resolveTypeDeclaration_closure(this, element, resolveTypeDeclaration));
    },
    resolveClass$1: function(element) {
      return this._resolveTypeDeclaration$2(element, new A.ResolverTask_resolveClass_closure(this, element));
    },
    resolveClassInternal$2: function(element, registry) {
      var t1 = this.compiler;
      if (!element.get$isPatch()) {
        t1.withCurrentElement$2(element, new A.ResolverTask_resolveClassInternal_closure(this, element, registry));
        if (element.get$isPatched())
          element.get$patch().ensureResolved$1(t1);
      } else {
        element.set$resolutionState(1);
        element.get$origin(element).ensureResolved$1(t1);
        element.computeType$1(t1);
        element.supertype = element.get$origin(element).get$supertype();
        element.interfaces = element.get$origin(element).get$interfaces();
        element.allSupertypesAndSelf = element.get$origin(element).get$allSupertypesAndSelf();
        element.set$supertypeLoadState(1);
        element.set$supertypeLoadState(2);
        element.set$resolutionState(2);
      }
    },
    _postProcessClassElement$1: function(element) {
      var t1, t2, metadata;
      t1 = element.get$metadata();
      t1.toString;
      t2 = new E.LinkIterator(null, t1);
      t2.$builtinTypeInfo = [H.getTypeArgumentByIndex(t1, 0)];
      t1 = this.compiler;
      for (; t2.moveNext$0();) {
        metadata = t2._util_implementation$_current;
        metadata.ensureResolved$1(t1);
        if (!element.get$isProxy() && J.$eq(metadata.get$value(metadata), t1.proxyConstant))
          element.isProxy = true;
      }
      element.forEachMember$1(new A.ResolverTask__postProcessClassElement_closure(this));
      A.MembersCreator_computeClassMembersByName(t1, element, "call");
    },
    checkMixinApplication$1: function(mixinApplication) {
      var modifiers, illegalFlags, t1, mixin;
      modifiers = mixinApplication.get$modifiers();
      illegalFlags = (modifiers.flags & 4294967293) >>> 0;
      if (illegalFlags !== 0) {
        t1 = $.Node__HASH_COUNTER + 1;
        $.Node__HASH_COUNTER = t1;
        this.compiler.reportDiagnosticInternal$4(modifiers, C.MessageKind_axq, P.LinkedHashMap_LinkedHashMap$_literal(["modifiers", new Y.Modifiers(null, illegalFlags, t1)], null, null), C.Diagnostic_1_error);
      }
      mixin = mixinApplication.get$mixinType() != null ? mixinApplication.mixinType.get$element() : null;
      if (mixin == null)
        return;
      if (mixin.get$superclass() == null) {
        this.compiler.reportDiagnosticInternal$4(mixinApplication, C.MessageKind_yDL, C.Map_empty, C.Diagnostic_1_error);
        return;
      }
      t1 = this.compiler;
      if (!mixin.get$superclass().isObject$1(t1))
        t1.reportDiagnosticInternal$4(mixin, C.MessageKind_woc, C.Map_empty, C.Diagnostic_1_error);
      mixin.forEachLocalMember$1(new A.ResolverTask_checkMixinApplication_closure(this, mixinApplication, mixin));
    },
    checkMixinSuperUses$3: function(resolutionTree, mixinApplication, mixin) {
      var superUses, t1, t2;
      if (resolutionTree == null)
        return;
      superUses = resolutionTree._superUses;
      superUses = superUses != null ? superUses : C.List_empty1;
      t1 = J.getInterceptor$asx(superUses);
      if (t1.get$isEmpty(superUses))
        return;
      t2 = this.compiler;
      t2.reportDiagnosticInternal$4(mixinApplication, C.MessageKind_5UV, P.LinkedHashMap_LinkedHashMap$_literal(["className", mixin.get$name(mixin)], null, null), C.Diagnostic_1_error);
      for (t1 = t1.get$iterator(superUses); t1.moveNext$0();)
        t2.reportDiagnosticInternal$4(t1.get$current(), C.MessageKind_t1T, C.Map_empty, C.Diagnostic_8_info);
    },
    checkClassMembers$1: function(cls) {
      var t1, t2, t3, constConstructors, nonFinalInstanceFields, span;
      t1 = this.compiler;
      t2 = cls.get$declaration();
      t3 = t1.objectClass;
      if (t2 == null ? t3 == null : t2 === t3)
        return;
      constConstructors = H.setRuntimeTypeInfo([], [O.Element]);
      nonFinalInstanceFields = H.setRuntimeTypeInfo([], [O.Element]);
      cls.forEachMember$1(new A.ResolverTask_checkClassMembers_closure(this, constConstructors, nonFinalInstanceFields));
      t2 = constConstructors.length;
      if (t2 !== 0 && nonFinalInstanceFields.length !== 0) {
        span = t2 > 1 ? cls : constConstructors[0];
        t1.reportDiagnosticInternal$4(span, C.MessageKind_QpY, P.LinkedHashMap_LinkedHashMap$_literal(["className", cls.name], null, null), C.Diagnostic_1_error);
        t2 = constConstructors.length;
        if (t2 > 1)
          for (t2 = H.setRuntimeTypeInfo(new H.ListIterator(constConstructors, t2, 0, null), [H.getTypeArgumentByIndex(constConstructors, 0)]); t2.moveNext$0();)
            t1.reportDiagnosticInternal$4(t2.__internal$_current, C.MessageKind_IAi, C.Map_empty, C.Diagnostic_8_info);
        for (t2 = H.setRuntimeTypeInfo(new H.ListIterator(nonFinalInstanceFields, nonFinalInstanceFields.length, 0, null), [H.getTypeArgumentByIndex(nonFinalInstanceFields, 0)]); t2.moveNext$0();)
          t1.reportDiagnosticInternal$4(t2.__internal$_current, C.MessageKind_eRS, C.Map_empty, C.Diagnostic_8_info);
      }
    },
    checkAbstractField$1: function(member) {
      var lookupElement, getter, setter, getterFlags, setterFlags, t1, mismatchedFlags;
      if (!member.get$isGetter())
        return;
      lookupElement = member.get$enclosingClass().lookupLocalMember$1(member.name);
      if (lookupElement == null)
        this.compiler.internalError$2(member, "No abstract field for accessor");
      else if (lookupElement.get$kind(lookupElement) !== C.ElementKind_abstract_field_1)
        this.compiler.internalError$2(member, "Inaccessible abstract field for accessor");
      getter = lookupElement.get$getter();
      if (getter == null)
        return;
      setter = lookupElement.setter;
      if (setter == null)
        return;
      getterFlags = (getter.get$modifiers().flags | 2) >>> 0;
      setterFlags = (setter.get$modifiers().flags | 2) >>> 0;
      if (getterFlags !== setterFlags) {
        t1 = $.Node__HASH_COUNTER + 1;
        $.Node__HASH_COUNTER = t1;
        mismatchedFlags = new Y.Modifiers(null, (getterFlags ^ setterFlags) >>> 0, t1);
        t1 = this.compiler;
        t1.reportDiagnosticInternal$4(lookupElement.getter, C.MessageKind_oyn, P.LinkedHashMap_LinkedHashMap$_literal(["modifiers", mismatchedFlags], null, null), C.Diagnostic_1_error);
        t1.reportDiagnosticInternal$4(lookupElement.setter, C.MessageKind_r9o, P.LinkedHashMap_LinkedHashMap$_literal(["modifiers", mismatchedFlags], null, null), C.Diagnostic_1_error);
      }
    },
    checkUserDefinableOperator$1: function(member) {
      var $function, value, isMinus, requiredParameterCount, messageKind, node, signature, t1, errorNode, t2, t3;
      $function = member.asFunctionElement$0();
      if ($function == null)
        return;
      value = member.name;
      if (value == null)
        return;
      if (!(Y.isUserDefinableOperator(value) || value === "unary-"))
        return;
      if (value === "unary-") {
        isMinus = true;
        requiredParameterCount = 0;
        messageKind = C.MessageKind_aVa;
      } else if (value === "-") {
        isMinus = true;
        requiredParameterCount = 1;
        messageKind = C.MessageKind_aVa;
      } else {
        if (value === "~") {
          requiredParameterCount = 0;
          messageKind = C.MessageKind_46y;
        } else if (Y.isBinaryOperator(value)) {
          if (value === "==")
            this.checkOverrideHashCode$1(member);
          requiredParameterCount = 1;
          messageKind = C.MessageKind_xES;
        } else if (value === "[]=") {
          requiredParameterCount = 2;
          messageKind = C.MessageKind_nTW;
        } else {
          this.compiler.internalError$2($function, "Unexpected user defined operator " + value);
          requiredParameterCount = null;
          messageKind = null;
        }
        isMinus = false;
      }
      node = $function.get$node();
      signature = $function.get$functionSignature();
      if (signature.get$requiredParameterCount() !== requiredParameterCount) {
        if (node.get$parameters() != null) {
          if (!isMinus) {
            t1 = signature.requiredParameterCount;
            if (typeof requiredParameterCount !== "number")
              return H.iae(requiredParameterCount);
            t1 = t1 < requiredParameterCount;
          } else
            t1 = true;
          if (t1)
            errorNode = node.get$parameters();
          else {
            t1 = node.get$parameters().nodes.skip$1(0, requiredParameterCount);
            errorNode = t1.get$head(t1);
          }
        } else
          errorNode = node;
        this.compiler.reportDiagnosticInternal$4(errorNode, messageKind, P.LinkedHashMap_LinkedHashMap$_literal(["operatorName", $function.name], null, null), C.Diagnostic_1_error);
      }
      if (signature.optionalParameterCount !== 0) {
        t1 = node.get$parameters().nodes.skip$1(0, signature.requiredParameterCount);
        errorNode = t1.get$head(t1);
        t1 = signature.optionalParametersAreNamed;
        t2 = $function.name;
        t3 = this.compiler;
        if (t1)
          t3.reportDiagnosticInternal$4(errorNode, C.MessageKind_wC3, P.LinkedHashMap_LinkedHashMap$_literal(["operatorName", t2], null, null), C.Diagnostic_1_error);
        else
          t3.reportDiagnosticInternal$4(errorNode, C.MessageKind_5Jd, P.LinkedHashMap_LinkedHashMap$_literal(["operatorName", t2], null, null), C.Diagnostic_1_error);
      }
    },
    checkOverrideHashCode$1: function(operatorEquals) {
      var cls;
      if (operatorEquals.get$isAbstract())
        return;
      cls = operatorEquals.get$enclosingClass();
      if (cls.lookupLocalMember$1("hashCode") != null)
        return;
      this.compiler.reportDiagnosticInternal$4(operatorEquals, C.MessageKind_6xV, P.LinkedHashMap_LinkedHashMap$_literal(["class", cls.name], null, null), C.Diagnostic_4_hint);
    },
    resolveSignature$1: function(element) {
      var t1 = {};
      t1.defaultValuesError_0 = null;
      if ((element.modifiers.flags & 32) !== 0)
        if (element.parseNode$1(this.compiler).get$isRedirectingFactory())
          t1.defaultValuesError_0 = C.MessageKind_qfd;
      return this.compiler.withCurrentElement$2(element, new A.ResolverTask_resolveSignature_closure(t1, this, element));
    },
    resolveTypedef$1: function(element) {
      if (element.get$isResolved())
        return element.get$treeElements();
      this.compiler.world.allTypedefs.add$1(0, element);
      return this._resolveTypeDeclaration$2(element, new A.ResolverTask_resolveTypedef_closure(this, element));
    },
    resolveMetadataAnnotation$1: function(annotation) {
      this.compiler.withCurrentElement$2(annotation.annotatedElement, new A.ResolverTask_resolveMetadataAnnotation_closure(this, annotation));
    },
    error$3: [function(_, node, kind, $arguments) {
      this.compiler.reportFatalError$3(node, kind, $arguments);
    }, function($receiver, node, kind) {
      return this.error$3($receiver, node, kind, C.Map_empty);
    }, "error$2", "call$3", "call$2", "get$error", 4, 2, 224, 225],
    resolveMetadata$2: function(element, node) {
      var metadata, t1, t2, metadataAnnotation;
      metadata = H.setRuntimeTypeInfo(new E.LinkBuilderImplementation(null, null, 0), [null]);
      for (t1 = node.metadata.nodes, t1.toString, t1 = H.setRuntimeTypeInfo(new E.LinkIterator(null, t1), [H.getTypeArgumentByIndex(t1, 0)]), t2 = this.compiler; t1.moveNext$0();) {
        metadataAnnotation = new U.ParameterMetadataAnnotation(t1._util_implementation$_current, null, null, 0);
        metadataAnnotation.annotatedElement = element;
        t2.resolver.resolveMetadataAnnotation$1(metadataAnnotation);
        metadata.addLast$1(metadataAnnotation);
      }
      return metadata.toLink$0();
    }
  },
  ResolverTask_resolve_closure: {
    "^": "Closure:23;this_0,element_1",
    call$0: function() {
      var t1, t2, t3, kind;
      t1 = this.element_1;
      if (t1 != null && t1.get$isErroneous())
        return;
      t2 = this.this_0;
      t3 = new A.ResolverTask_resolve__processMetadata(t2, t1);
      kind = t1.get$kind(t1);
      if (kind === C.ElementKind_generative_constructor_16 || kind === C.ElementKind_function_2 || kind === C.ElementKind_getter_0 || kind === C.ElementKind_setter_0)
        return t3.call$1(t2.resolveMethodElement$1(t1));
      if (kind === C.ElementKind_field_1)
        return t3.call$1(t2.resolveField$1(t1));
      if (t1.get$isClass()) {
        t1.ensureResolved$1(t2.compiler);
        return t3.call$0();
      } else if (t1.get$isTypedef())
        return t3.call$1(t2.resolveTypedef$1(t1));
      t2.compiler.internalError$2(t1, "resolve(" + t1.toString$0(0) + ") not implemented.");
    },
    $isFunction: true
  },
  ResolverTask_resolve__processMetadata: {
    "^": "Closure:226;this_2,element_3",
    call$1: function(result) {
      var t1, t2;
      for (t1 = this.element_3.get$metadata(), t1.toString, t1 = H.setRuntimeTypeInfo(new E.LinkIterator(null, t1), [H.getTypeArgumentByIndex(t1, 0)]), t2 = this.this_2.compiler; t1.moveNext$0();)
        t1._util_implementation$_current.ensureResolved$1(t2);
      return result;
    },
    call$0: function() {
      return this.call$1(null);
    },
    $isFunction: true
  },
  ResolverTask_checkMatchingPatchSignatures_closure: {
    "^": "Closure:23;this_0,origin_1,originSignature_2,patchTree_3,patchSignature_4",
    call$0: function() {
      var errorNode, t1, t2;
      errorNode = this.patchTree_3;
      if (errorNode.get$returnType() != null)
        errorNode = errorNode.get$returnType();
      t1 = this.originSignature_2;
      t2 = this.patchSignature_4;
      this.this_0.compiler.reportFatalError$3(errorNode, C.MessageKind_2No, P.LinkedHashMap_LinkedHashMap$_literal(["methodName", this.origin_1.name, "originReturnType", t1.get$type(t1).returnType, "patchReturnType", t2.get$type(t2).returnType], null, null));
    },
    $isFunction: true
  },
  ResolverTask_checkMatchingPatchSignatures_closure0: {
    "^": "Closure:23;this_5,origin_6,originSignature_7,patchTree_8,patchSignature_9",
    call$0: function() {
      this.this_5.compiler.reportFatalError$3(this.patchTree_8, C.MessageKind_csC, P.LinkedHashMap_LinkedHashMap$_literal(["methodName", this.origin_6.name, "originParameterCount", this.originSignature_7.get$requiredParameterCount(), "patchParameterCount", this.patchSignature_9.get$requiredParameterCount()], null, null));
    },
    $isFunction: true
  },
  ResolverTask_checkMatchingPatchSignatures_closure1: {
    "^": "Closure:23;this_10,origin_11,patchTree_12",
    call$0: function() {
      this.this_10.compiler.reportFatalError$3(this.patchTree_12, C.MessageKind_cg9, P.LinkedHashMap_LinkedHashMap$_literal(["methodName", this.origin_11.name], null, null));
    },
    $isFunction: true
  },
  ResolverTask_checkMatchingPatchSignatures_closure2: {
    "^": "Closure:23;this_13,origin_14,originSignature_15,patchTree_16,patchSignature_17",
    call$0: function() {
      this.this_13.compiler.reportFatalError$3(this.patchTree_16, C.MessageKind_O92, P.LinkedHashMap_LinkedHashMap$_literal(["methodName", this.origin_14.name, "originParameterCount", this.originSignature_15.get$optionalParameterCount(), "patchParameterCount", this.patchSignature_17.get$optionalParameterCount()], null, null));
    },
    $isFunction: true
  },
  ResolverTask_resolveMethodElement_closure: {
    "^": "Closure:23;box_0,this_1",
    call$0: function() {
      var t1, t2, isConstructor, t3, t4, target, patch;
      t1 = this.box_0;
      t2 = t1.element_0;
      isConstructor = t2.kind === C.ElementKind_generative_constructor_16;
      t3 = this.this_1;
      t4 = t3.compiler;
      if (t4.enqueuer.resolution.resolvedElements.contains$1(0, t2.get$analyzableElement().get$declaration()))
        return t1.element_0.get$resolvedAst().elements;
      if (t1.element_0.get$isSynthesized()) {
        t2 = t1.element_0;
        if (isConstructor) {
          t2 = A._ensureTreeElements(t2);
          target = t1.element_0.asFunctionElement$0().get$definingConstructor();
          t1.element_0.computeSignature$1(t4);
          if (!target.get$isErroneous()) {
            t4.enqueuer.resolution.registerStaticUse$1(target);
            t4.world.toString;
            t2.registerDependency$1(target);
          }
          return t2;
        } else
          return A._ensureTreeElements(t2);
      }
      t1.element_0.parseNode$1(t4);
      t1.element_0.computeType$1(t4);
      if (t1.element_0.get$isPatched()) {
        patch = t1.element_0.get$patch();
        t4.withCurrentElement$2(patch, new A.ResolverTask_resolveMethodElement__closure(t3, patch));
        t3.checkMatchingPatchSignatures$2(t1.element_0, patch);
        t1.element_0 = patch;
      }
      return t4.withCurrentElement$2(t1.element_0, new A.ResolverTask_resolveMethodElement__closure0(t1, t3, isConstructor));
    },
    $isFunction: true
  },
  ResolverTask_resolveMethodElement__closure: {
    "^": "Closure:23;this_2,patch_3",
    call$0: function() {
      var t1, t2;
      t1 = this.patch_3;
      t2 = this.this_2.compiler;
      t1.parseNode$1(t2);
      t1.computeType$1(t2);
    },
    $isFunction: true
  },
  ResolverTask_resolveMethodElement__closure0: {
    "^": "Closure:23;box_0,this_4,isConstructor_5",
    call$0: function() {
      var t1, tree, t2, t3, t4, t5, visitor, registry, resolver, redirection, resolutionTree, enclosingClass, mixinUses;
      t1 = this.box_0;
      tree = t1.element_0.get$node();
      if ((tree.get$modifiers().flags & 64) !== 0)
        this.this_4.compiler.reportFatalError$3(tree, C.MessageKind_ek3, C.Map_empty);
      t2 = this.isConstructor_5;
      if (t2 || (t1.element_0.get$modifiers().flags & 32) !== 0) {
        if (tree.get$returnType() != null)
          this.this_4.compiler.reportFatalError$3(tree, C.MessageKind_6qD, C.Map_empty);
        if ((t1.element_0.get$modifiers().flags & 16) !== 0 && tree.hasBody$0() && !tree.get$isRedirectingFactory())
          this.this_4.compiler.reportDiagnosticInternal$4(tree, C.MessageKind_4CA, C.Map_empty, C.Diagnostic_1_error);
      }
      t3 = this.this_4;
      t4 = t1.element_0;
      t5 = t3.compiler;
      visitor = A.ResolverVisitor$(t5, t4, new A.ResolutionRegistry(t5, A._ensureTreeElements(t4)), false);
      registry = visitor.registry;
      registry.defineFunction$2(tree, t1.element_0);
      visitor.setupFunction$2(tree, t1.element_0);
      if (t2) {
        t1.element_0.toString;
        t2 = true;
      } else
        t2 = false;
      if (t2) {
        resolver = new A.InitializerResolver(visitor, P.LinkedHashMap_LinkedHashMap(null, null, null, O.Element, Y.Node), null, false);
        redirection = resolver.resolveInitializers$2(t1.element_0, tree);
        if (redirection != null)
          t3.resolveRedirectingConstructor$4(resolver, tree, t1.element_0, redirection);
      } else {
        t1.element_0.toString;
        if (tree.get$initializers() != null)
          t5.reportFatalError$3(tree, C.MessageKind_6aU, C.Map_empty);
      }
      if (!t5.analyzeSignaturesOnly || tree.get$isRedirectingFactory()) {
        t2 = tree.get$body(tree);
        if (t2 == null)
          ;
        else
          t2.accept$1(0, visitor);
      }
      resolutionTree = registry.mapping;
      enclosingClass = t1.element_0.get$enclosingClass();
      if (enclosingClass != null) {
        mixinUses = t5.world.mixinUses.$index(0, enclosingClass);
        if (mixinUses != null)
          for (t1 = J.get$iterator$ax(mixinUses); t1.moveNext$0();)
            t3.checkMixinSuperUses$3(resolutionTree, t1.get$current(), enclosingClass);
      }
      return resolutionTree;
    },
    $isFunction: true
  },
  ResolverTask_resolveField_closure: {
    "^": "Closure:23;this_0,element_1",
    call$0: function() {
      var t1, t2;
      t1 = this.element_1;
      t2 = this.this_0;
      if ((t1.variables.modifiers.flags & 16) !== 0)
        t2.constantCompiler.compileConstant$1(t1);
      else
        t2.constantCompiler.compileVariable$1(t1);
    },
    $isFunction: true
  },
  ResolverTask_loadSupertypes_closure: {
    "^": "Closure:23;this_0,cls_1,from_2",
    call$0: function() {
      var t1 = this.this_0;
      return t1.measure$1(new A.ResolverTask_loadSupertypes__closure(t1, this.cls_1, this.from_2));
    },
    $isFunction: true
  },
  ResolverTask_loadSupertypes__closure: {
    "^": "Closure:23;this_3,cls_4,from_5",
    call$0: function() {
      var t1, t2;
      t1 = this.cls_4;
      t2 = t1.supertypeLoadState;
      if (t2 === 2)
        return;
      if (t2 === 1) {
        t2 = this.this_3.compiler;
        t2.reportDiagnosticInternal$4(this.from_5, C.MessageKind_MQy, P.LinkedHashMap_LinkedHashMap$_literal(["className", t1.name], null, null), C.Diagnostic_1_error);
        t1.set$supertypeLoadState(2);
        t1.hasIncompleteHierarchy = true;
        t2 = t2.objectClass.get$allSupertypesAndSelf().extendClass$1(t1.computeType$1(t2));
        t1.allSupertypesAndSelf = t2;
        t2 = t2._supertypes;
        t1.supertype = t2.get$head(t2);
        t1.interfaces = C.C_Link0;
        return;
      }
      t1.set$supertypeLoadState(1);
      t2 = this.this_3;
      t2.compiler.withCurrentElement$2(t1, new A.ResolverTask_loadSupertypes___closure(t2, t1));
    },
    $isFunction: true
  },
  ResolverTask_loadSupertypes___closure: {
    "^": "Closure:23;this_6,cls_7",
    call$0: function() {
      var t1, t2;
      t1 = this.cls_7;
      t2 = this.this_6.compiler;
      t1.parseNode$1(t2).accept$1(0, new A.ClassSupertypeResolver(A.Scope_buildEnclosingScope(t1), t1, t2));
      if (t1.supertypeLoadState !== 2)
        t1.set$supertypeLoadState(2);
    },
    $isFunction: true
  },
  ResolverTask__resolveTypeDeclaration_closure: {
    "^": "Closure:23;this_0,element_1,resolveTypeDeclaration_2",
    call$0: function() {
      var t1 = this.this_0;
      return t1.measure$1(new A.ResolverTask__resolveTypeDeclaration__closure(t1, this.element_1, this.resolveTypeDeclaration_2));
    },
    $isFunction: true
  },
  ResolverTask__resolveTypeDeclaration__closure: {
    "^": "Closure:23;this_3,element_4,resolveTypeDeclaration_5",
    call$0: function() {
      var t1, previousResolvedTypeDeclaration, result, t2, t3, t4;
      t1 = this.this_3;
      previousResolvedTypeDeclaration = t1.currentlyResolvedTypeDeclaration;
      t1.currentlyResolvedTypeDeclaration = this.element_4;
      result = this.resolveTypeDeclaration_5.call$0();
      if (previousResolvedTypeDeclaration == null) {
        t2 = t1.pendingClassesToBeResolved;
        t3 = t1.pendingClassesToBePostProcessed;
        t4 = t1.compiler;
        do {
          for (; t2._head !== t2._tail;)
            t2.removeFirst$0().ensureResolved$1(t4);
          for (; t3._head !== t3._tail;)
            t1._postProcessClassElement$1(t3.removeFirst$0());
        } while (t2._head !== t2._tail);
      }
      t1.currentlyResolvedTypeDeclaration = previousResolvedTypeDeclaration;
      return result;
    },
    $isFunction: true
  },
  ResolverTask_resolveClass_closure: {
    "^": "Closure:23;this_0,element_1",
    call$0: function() {
      var t1, t2;
      t1 = this.this_0;
      t2 = this.element_1;
      t1.resolveClassInternal$2(t2, new A.ResolutionRegistry(t1.compiler, A._ensureTreeElements(t2)));
      return t2.get$treeElements();
    },
    $isFunction: true
  },
  ResolverTask_resolveClassInternal_closure: {
    "^": "Closure:23;this_0,element_1,registry_2",
    call$0: function() {
      var t1 = this.this_0;
      return t1.measure$1(new A.ResolverTask_resolveClassInternal__closure(t1, this.element_1, this.registry_2));
    },
    $isFunction: true
  },
  ResolverTask_resolveClassInternal__closure: {
    "^": "Closure:23;this_3,element_4,registry_5",
    call$0: function() {
      var t1, t2, t3, tree, t4;
      t1 = this.element_4;
      t1.set$resolutionState(1);
      t2 = this.this_3;
      t3 = t2.compiler;
      tree = t1.parseNode$1(t3);
      t2.loadSupertypes$2(t1, tree);
      t4 = A.Scope_buildEnclosingScope(t1);
      if (tree == null)
        ;
      else
        tree.accept$1(0, new A.ClassResolverVisitor(t4, t1, this.registry_5, new A.TypeResolver(t3), t3));
      t1.set$resolutionState(2);
      if (t3.mirrorSystemClass === t1)
        t3.mirrorSystemGetNameFunction = t1.lookupLocalMember$1("getName");
      else if (t3.symbolClass === t1) {
        t4 = t1.get$constructors();
        t3.symbolConstructor = t4.get$head(t4);
      } else {
        t4 = t3.symbolImplementationClass;
        if (t4 === t1)
          t3.symbolValidatedConstructor = t4.lookupConstructor$1(t3.symbolValidatedConstructorSelector);
        else if (t3.mirrorsUsedClass === t1) {
          t4 = t1.get$constructors();
          t3.mirrorsUsedConstructor = t4.get$head(t4);
        } else {
          t4 = t3.intClass;
          if (t4 === t1)
            t3.intEnvironment = t4.lookupConstructor$1(t3.fromEnvironmentSelector);
          else {
            t4 = t3.stringClass;
            if (t4 === t1)
              t3.stringEnvironment = t4.lookupConstructor$1(t3.fromEnvironmentSelector);
            else {
              t4 = t3.boolClass;
              if (t4 === t1)
                t3.boolEnvironment = t4.lookupConstructor$1(t3.fromEnvironmentSelector);
            }
          }
        }
      }
      t2.pendingClassesToBePostProcessed._add$1(t1);
    },
    $isFunction: true
  },
  ResolverTask__postProcessClassElement_closure: {
    "^": "Closure:48;this_0",
    call$2: function(_, member) {
      var t1;
      if (!member.get$isInstanceMember()) {
        t1 = this.this_0;
        t1.compiler.withCurrentElement$2(member, new A.ResolverTask__postProcessClassElement__closure(t1, member));
      }
    },
    $isFunction: true
  },
  ResolverTask__postProcessClassElement__closure: {
    "^": "Closure:23;this_1,member_2",
    call$0: function() {
      var t1, t2;
      for (t1 = this.member_2.get$metadata(), t1.toString, t1 = H.setRuntimeTypeInfo(new E.LinkIterator(null, t1), [H.getTypeArgumentByIndex(t1, 0)]), t2 = this.this_1.compiler; t1.moveNext$0();)
        t1._util_implementation$_current.ensureResolved$1(t2);
    },
    $isFunction: true
  },
  ResolverTask_checkMixinApplication_closure: {
    "^": "Closure:95;this_0,mixinApplication_1,mixin_2",
    call$1: function(member) {
      var t1;
      if (J.get$kind$x(member) === C.ElementKind_generative_constructor_16 && !member.get$isSynthesized())
        this.this_0.compiler.reportDiagnosticInternal$4(member, C.MessageKind_EkK, C.Map_empty, C.Diagnostic_1_error);
      else {
        t1 = this.this_0;
        if (t1.compiler.enqueuer.resolution.resolvedElements.contains$1(0, member.get$analyzableElement().get$declaration()))
          t1.checkMixinSuperUses$3(member.get$resolvedAst().elements, this.mixinApplication_1, this.mixin_2);
      }
    },
    $isFunction: true
  },
  ResolverTask_checkClassMembers_closure: {
    "^": "Closure:19;this_0,constConstructors_1,nonFinalInstanceFields_2",
    call$2: function(holder, member) {
      var t1 = this.this_0;
      t1.compiler.withCurrentElement$2(member, new A.ResolverTask_checkClassMembers__closure(t1, this.constConstructors_1, this.nonFinalInstanceFields_2, member));
    },
    $isFunction: true
  },
  ResolverTask_checkClassMembers__closure: {
    "^": "Closure:23;this_3,constConstructors_4,nonFinalInstanceFields_5,member_6",
    call$0: function() {
      var t1, t2, t3, mismatchedFlagsBits, t4;
      t1 = this.member_6;
      t2 = this.this_3;
      t3 = t2.compiler;
      t1.computeType$1(t3);
      if (t1.get$isFunction() && (t1.get$modifiers().flags & 4) !== 0)
        t3.reportDiagnosticInternal$4(t1, C.MessageKind_u61, C.Map_empty, C.Diagnostic_1_error);
      if (t1.get$isConstructor()) {
        mismatchedFlagsBits = t1.get$modifiers().flags & 3;
        if (mismatchedFlagsBits !== 0) {
          t4 = $.Node__HASH_COUNTER + 1;
          $.Node__HASH_COUNTER = t4;
          t3.reportDiagnosticInternal$4(t1, C.MessageKind_cAH, P.LinkedHashMap_LinkedHashMap$_literal(["modifiers", new Y.Modifiers(null, mismatchedFlagsBits, t4)], null, null), C.Diagnostic_1_error);
        }
        if ((t1.get$modifiers().flags & 16) !== 0)
          this.constConstructors_4.push(t1);
      }
      if (t1.get$kind(t1) === C.ElementKind_field_1) {
        if ((t1.get$modifiers().flags & 16) !== 0 && (t1.get$modifiers().flags & 1) === 0)
          t3.reportDiagnosticInternal$4(t1, C.MessageKind_Mkc, C.Map_empty, C.Diagnostic_1_error);
        if ((t1.get$modifiers().flags & 1) === 0 && (t1.get$modifiers().flags & 4) === 0)
          this.nonFinalInstanceFields_5.push(t1);
      }
      t2.checkAbstractField$1(t1);
      t2.checkUserDefinableOperator$1(t1);
    },
    $isFunction: true
  },
  ResolverTask_resolveSignature_closure: {
    "^": "Closure:23;box_0,this_1,element_2",
    call$0: function() {
      var t1, t2;
      t1 = this.this_1;
      t2 = this.element_2;
      return t1.measure$1(new A.ResolverTask_resolveSignature__closure(this.box_0, t1, t2, t1.compiler.parser.measure$1(new A.ResolverTask_resolveSignature__closure0(t1, t2))));
    },
    $isFunction: true
  },
  ResolverTask_resolveSignature__closure0: {
    "^": "Closure:23;this_3,element_4",
    call$0: function() {
      return this.element_4.parseNode$1(this.this_3.compiler);
    },
    $isFunction: true
  },
  ResolverTask_resolveSignature__closure: {
    "^": "Closure:23;box_0,this_5,element_6,node_7",
    call$0: function() {
      var t1, t2, t3;
      t1 = this.this_5.compiler;
      t2 = this.node_7;
      t3 = this.element_6;
      return A.SignatureResolver_analyze(t1, t2.get$parameters(), t2.get$returnType(), t3, new A.ResolutionRegistry(t1, A._ensureTreeElements(t3)), true, this.box_0.defaultValuesError_0);
    },
    $isFunction: true
  },
  ResolverTask_resolveTypedef_closure: {
    "^": "Closure:23;this_0,element_1",
    call$0: function() {
      var t1, t2, t3;
      t1 = this.this_0;
      t2 = t1.compiler;
      t3 = this.element_1;
      return t2.withCurrentElement$2(t3, new A.ResolverTask_resolveTypedef__closure(t1, t3, new A.ResolutionRegistry(t2, A._ensureTreeElements(t3))));
    },
    $isFunction: true
  },
  ResolverTask_resolveTypedef__closure: {
    "^": "Closure:23;this_2,element_3,registry_4",
    call$0: function() {
      var t1 = this.this_2;
      return t1.measure$1(new A.ResolverTask_resolveTypedef___closure(t1, this.element_3, this.registry_4));
    },
    $isFunction: true
  },
  ResolverTask_resolveTypedef___closure: {
    "^": "Closure:23;this_5,element_6,registry_7",
    call$0: function() {
      var t1, t2, t3, node, t4;
      t1 = this.element_6;
      t1.resolutionState = 1;
      t2 = this.this_5;
      t3 = t2.compiler;
      node = t3.parser.measure$1(new A.ResolverTask_resolveTypedef____closure(t2, t1));
      t2 = this.registry_7;
      t4 = A.Scope_buildEnclosingScope(t1);
      if (node == null)
        ;
      else
        J.accept$1$x(node, new A.TypedefResolverVisitor(t4, t1, t2, new A.TypeResolver(t3), t3));
      t1.resolutionState = 2;
      return t2.mapping;
    },
    $isFunction: true
  },
  ResolverTask_resolveTypedef____closure: {
    "^": "Closure:23;this_8,element_9",
    call$0: function() {
      return this.element_9.parseNode$1(this.this_8.compiler);
    },
    $isFunction: true
  },
  ResolverTask_resolveMetadataAnnotation_closure: {
    "^": "Closure:23;this_0,annotation_1",
    call$0: function() {
      var t1 = this.this_0;
      return t1.measure$1(new A.ResolverTask_resolveMetadataAnnotation__closure(t1, this.annotation_1));
    },
    $isFunction: true
  },
  ResolverTask_resolveMetadataAnnotation__closure: {
    "^": "Closure:23;this_2,annotation_3",
    call$0: function() {
      var t1, t2, t3, node, annotatedElement, context, classElement, visitor, registry;
      t1 = this.annotation_3;
      t1.resolutionState = 1;
      t2 = this.this_2;
      t3 = t2.compiler;
      node = t1.parseNode$1(t3);
      annotatedElement = t1.annotatedElement;
      context = annotatedElement.get$analyzableElement();
      classElement = annotatedElement.get$enclosingClass();
      if (classElement != null)
        classElement.ensureResolved$1(t3);
      visitor = A.ResolverVisitor$(t3, context, new A.ResolutionRegistry(t3, A._ensureTreeElements(context)), true);
      registry = visitor.registry;
      node.accept$1(0, visitor);
      t2 = t2.constantCompiler.compileMetadata$3(t1, node, registry.mapping);
      t1.value = t2;
      registry.compiler.backend.registerMetadataConstant$3(t2, annotatedElement, registry);
      t1.resolutionState = 2;
    },
    $isFunction: true
  },
  InitializerResolver: {
    "^": "Object;visitor,initialized,initializers,hasSuper",
    error$3: [function(_, node, kind, $arguments) {
      this.visitor.compiler.reportFatalError$3(node, kind, $arguments);
    }, function($receiver, node, kind) {
      return this.error$3($receiver, node, kind, C.Map_empty);
    }, "error$2", "call$3", "call$2", "get$error", 4, 2, 227, 225],
    isFieldInitializer$1: function(node) {
      var t1;
      if (node.selector.asIdentifier$0() == null)
        return false;
      t1 = node.receiver;
      if (t1 == null)
        return true;
      if (t1.asIdentifier$0() == null)
        return false;
      t1 = t1.asIdentifier$0().token;
      return t1.get$value(t1) === "this";
    },
    reportDuplicateInitializerError$3: function(field, $init, existing) {
      var t1, t2;
      t1 = this.visitor.compiler;
      t2 = field.name;
      t1.reportDiagnosticInternal$4($init, C.MessageKind_44i, P.LinkedHashMap_LinkedHashMap$_literal(["fieldName", t2], null, null), C.Diagnostic_1_error);
      t1.reportDiagnosticInternal$4(existing, C.MessageKind_bkG, P.LinkedHashMap_LinkedHashMap$_literal(["fieldName", t2], null, null), C.Diagnostic_8_info);
    },
    checkForDuplicateInitializers$2: function(field, $init) {
      var t1, initializer;
      if (field == null)
        return;
      field.get$name(field);
      t1 = this.initialized;
      if (t1.containsKey$1(field))
        this.reportDuplicateInitializerError$3(field, $init, t1.$index(0, field));
      else if ((field.get$modifiers().flags & 4) !== 0) {
        field.parseNode$1(this.visitor.compiler);
        initializer = field.get$initializer();
        if (initializer != null)
          this.reportDuplicateInitializerError$3(field, $init, initializer);
      }
      t1.$indexSet(0, field, $init);
    },
    getSuperOrThisLookupTarget$3: function($constructor, isSuperCall, diagnosticNode) {
      var lookupTarget, t1, t2;
      lookupTarget = $constructor.get$enclosingClass();
      if (isSuperCall) {
        t1 = this.visitor.compiler;
        t2 = t1.objectClass;
        if (lookupTarget == null ? t2 == null : lookupTarget === t2)
          t1.reportFatalError$3(diagnosticNode, C.MessageKind_Q4d, C.Map_empty);
        else
          return lookupTarget.get$supertype().get$element();
      }
      return lookupTarget;
    },
    resolveSuperOrThisForSend$3: function($constructor, functionNode, $call) {
      var t1, wasInstanceContext, t2, t3, selector, lookupTarget, constructorSelector, calledConstructor;
      t1 = this.visitor;
      wasInstanceContext = t1.inInstanceContext;
      t1.inInstanceContext = false;
      new A.InitializerResolver_resolveSuperOrThisForSend_closure(this, $call).call$0();
      t1.inInstanceContext = wasInstanceContext;
      t2 = t1.registry;
      t3 = t2.mapping._selectors;
      selector = t3 != null ? t3.$index(0, $call) : null;
      lookupTarget = this.getSuperOrThisLookupTarget$3($constructor, Y.Initializers_isSuperConstructorCall($call), $call);
      constructorSelector = t1.getRedirectingThisOrSuperConstructorSelector$1($call);
      calledConstructor = lookupTarget.lookupConstructor$1(constructorSelector);
      this.verifyThatConstructorMatchesCall$7($constructor, calledConstructor, selector, false, $call, lookupTarget.name, constructorSelector);
      t2.useElement$2($call, calledConstructor);
      t2.compiler.enqueuer.resolution.registerStaticUse$1(calledConstructor);
      return calledConstructor;
    },
    verifyThatConstructorMatchesCall$7: function(caller, lookedupConstructor, $call, isImplicitSuperCall, diagnosticNode, className, constructorSelector) {
      var fullConstructorName, kind, t1;
      if (lookedupConstructor == null || lookedupConstructor.get$kind(lookedupConstructor) !== C.ElementKind_generative_constructor_16) {
        fullConstructorName = O.Elements_constructorNameForDiagnostics(className, constructorSelector.name);
        kind = isImplicitSuperCall ? C.MessageKind_Wv6 : C.MessageKind_d2A;
        this.visitor.compiler.reportDiagnosticInternal$4(diagnosticNode, kind, P.LinkedHashMap_LinkedHashMap$_literal(["constructorName", fullConstructorName], null, null), C.Diagnostic_1_error);
      } else {
        t1 = this.visitor.compiler;
        if (!$call.applies$2(lookedupConstructor, t1))
          t1.reportDiagnosticInternal$4(diagnosticNode, isImplicitSuperCall ? C.MessageKind_8xB : C.MessageKind_iqP, C.Map_empty, C.Diagnostic_1_error);
        else if ((caller.get$modifiers().flags & 16) !== 0 && !lookedupConstructor.get$isConst())
          t1.reportDiagnosticInternal$4(diagnosticNode, C.MessageKind_eT2, C.Map_empty, C.Diagnostic_1_error);
      }
    },
    resolveInitializers$2: function($constructor, functionNode) {
      var link, t1, t2, resolvedSuper, $init, selector, t3, $name, target, $call, classElement, callToMatch, lookupTarget, constructorSelector, calledConstructor;
      $constructor.get$functionSignature().forEachParameter$1(new A.InitializerResolver_resolveInitializers_closure(this));
      if (functionNode.get$initializers() == null) {
        this.initializers = C.C_Link3;
        link = C.C_Link3;
      } else {
        t1 = functionNode.get$initializers().nodes;
        this.initializers = t1;
        link = t1;
      }
      for (t1 = this.visitor, t2 = t1.compiler, resolvedSuper = false; !link.get$isEmpty(link); link = link.get$tail())
        if (link.get$head(link).asSendSet$0() != null) {
          $init = link.get$head(link).asSendSet$0();
          selector = $init.selector;
          t3 = selector.asIdentifier$0().token;
          $name = t3.get$value(t3);
          if (this.isFieldInitializer$1($init)) {
            target = $constructor.get$enclosingClass().lookupLocalMember$1($name);
            if (target == null)
              t2.reportFatalError$3(selector, C.MessageKind_SFN, P.LinkedHashMap_LinkedHashMap$_literal(["name", $name], null, null));
            else if (target.get$kind(target) !== C.ElementKind_field_1)
              t2.reportFatalError$3(selector, C.MessageKind_rYI, P.LinkedHashMap_LinkedHashMap$_literal(["fieldName", $name], null, null));
            else if (!target.get$isInstanceMember())
              t2.reportFatalError$3(selector, C.MessageKind_avx, P.LinkedHashMap_LinkedHashMap$_literal(["fieldName", $name], null, null));
          } else {
            t2.reportFatalError$3($init, C.MessageKind_EyN0, C.Map_empty);
            target = null;
          }
          t3 = t1.registry;
          t3.useElement$2($init, target);
          t3.compiler.enqueuer.resolution.registerStaticUse$1(target);
          this.checkForDuplicateInitializers$2(target, $init);
          t3 = $init.argumentsNode.nodes;
          t1.visitInStaticContext$1(t3.get$head(t3));
        } else if (link.get$head(link).asSend$0() != null) {
          $call = link.get$head(link).asSend$0();
          if ($call.argumentsNode == null)
            t2.reportFatalError$3(link.get$head(link), C.MessageKind_M2I, C.Map_empty);
          if (Y.Initializers_isSuperConstructorCall($call)) {
            if (resolvedSuper)
              t2.reportFatalError$3($call, C.MessageKind_ivD, C.Map_empty);
            this.resolveSuperOrThisForSend$3($constructor, functionNode, $call);
            resolvedSuper = true;
          } else if (Y.Initializers_isConstructorRedirect($call)) {
            if (functionNode.hasBody$0() && ($constructor.get$modifiers().flags & 16) === 0)
              t2.reportFatalError$3(functionNode, C.MessageKind_5NE, C.Map_empty);
            t1 = this.initializers.get$tail();
            if (!t1.get$isEmpty(t1))
              t2.reportFatalError$3($call, C.MessageKind_pSV, C.Map_empty);
            $constructor.functionSignatureCache.forEachParameter$1(new A.InitializerResolver_resolveInitializers_closure0(this));
            return this.resolveSuperOrThisForSend$3($constructor, functionNode, $call);
          } else
            t2.reportFatalError$3($call, C.MessageKind_x49, C.Map_empty);
        } else
          t2.reportFatalError$3(link.get$head(link), C.MessageKind_M2I, C.Map_empty);
      if (!resolvedSuper) {
        classElement = $constructor.get$enclosingClass();
        classElement.get$superclass();
        if (classElement !== t2.objectClass) {
          callToMatch = Z.Selector_Selector(C.SelectorKind_call_2, "", classElement.get$enclosingElement().get$library(), 0, null);
          lookupTarget = this.getSuperOrThisLookupTarget$3($constructor, true, functionNode);
          constructorSelector = Z.Selector_Selector(C.SelectorKind_call_2, "", t1.enclosingElement.get$library(), 0, null);
          calledConstructor = lookupTarget.lookupConstructor$1(constructorSelector);
          this.verifyThatConstructorMatchesCall$7($constructor, calledConstructor, callToMatch, true, functionNode, lookupTarget.name, constructorSelector);
          t1 = t1.registry;
          t2 = t1.compiler;
          t2.world.toString;
          t1.mapping.registerDependency$1(calledConstructor);
          t2.enqueuer.resolution.registerStaticUse$1(calledConstructor);
        }
      }
      return;
    }
  },
  InitializerResolver_resolveSuperOrThisForSend_closure: {
    "^": "Closure:23;this_0,call_1",
    call$0: function() {
      var t1, t2;
      t1 = this.this_0.visitor;
      t2 = this.call_1;
      t1.resolveSelector$2(t2, null);
      t1.resolveArguments$1(t2.argumentsNode);
    },
    $isFunction: true
  },
  InitializerResolver_resolveInitializers_closure: {
    "^": "Closure:50;this_0",
    call$1: function(element) {
      if (J.get$kind$x(element) === C.ElementKind_initializing_formal_1)
        this.this_0.checkForDuplicateInitializers$2(element.get$fieldElement(), element.initializer);
    },
    $isFunction: true
  },
  InitializerResolver_resolveInitializers_closure0: {
    "^": "Closure:50;this_1",
    call$1: function(parameter) {
      if (J.get$kind$x(parameter) === C.ElementKind_initializing_formal_1)
        this.this_1.visitor.compiler.reportFatalError$3(parameter.get$node(), C.MessageKind_Mny, C.Map_empty);
    },
    $isFunction: true
  },
  CommonResolverVisitor: {
    "^": "Visitor;compiler<",
    visitNode$1: function(node) {
      this.compiler.internalError$2(node, "internal error: Unhandled node: " + P.Object.prototype.toString$0.call(node, node));
    },
    visitEmptyStatement$1: function(node) {
      return;
    },
    error$3: [function(_, node, kind, $arguments) {
      this.compiler.reportFatalError$3(node, kind, $arguments);
    }, function($receiver, node, kind) {
      return this.error$3($receiver, node, kind, C.Map_empty);
    }, "error$2", "call$3", "call$2", "get$error", 4, 2, 228, 225]
  },
  LabeledStatementLabelScope: {
    "^": "Object;outer<,labels",
    lookup$1: function(labelName) {
      var label = this.labels.$index(0, labelName);
      if (label != null)
        return label;
      return this.outer.lookup$1(labelName);
    }
  },
  SwitchLabelScope: {
    "^": "Object;outer<,caseLabels",
    lookup$1: function(labelName) {
      var result = this.caseLabels.$index(0, labelName);
      if (result != null)
        return result;
      return this.outer.lookup$1(labelName);
    }
  },
  EmptyLabelScope: {
    "^": "Object;",
    lookup$1: function(label) {
      return;
    },
    get$outer: function() {
      throw H.wrapException("internal error: empty label scope has no outer");
    }
  },
  StatementScope: {
    "^": "Object;labels,breakTargetStack,continueTargetStack,nestingLevel<",
    static: {StatementScope$: function() {
        return new A.StatementScope(C.C_EmptyLabelScope, C.C_Link5, C.C_Link5, 0);
      }}
  },
  TypeResolver: {
    "^": "Object;compiler<",
    resolveTypeAnnotation$4$deferredIsMalformed$malformedIsError: function(visitor, node, deferredIsMalformed, malformedIsError) {
      var t1, registry, t2, send, prefixName, typeName, t3, t4, t5, t6, wrappedElement, element, element0, $arguments, type, addTypeVariableBoundsCheck, outer, isInFactoryConstructor;
      t1 = {};
      registry = visitor.registry;
      t1.typeName_0 = null;
      t1.type_1 = null;
      t2 = new A.TypeResolver_resolveTypeAnnotation_checkNoTypeArguments(t1, this, visitor, node);
      send = node.get$typeName().asSend$0();
      if (send != null) {
        prefixName = send.receiver.asIdentifier$0();
        t1.typeName_0 = send.selector.asIdentifier$0();
      } else {
        typeName = node.typeName.asIdentifier$0();
        t1.typeName_0 = typeName;
        t3 = typeName.token;
        if (t3.get$value(t3) === "void") {
          t1.type_1 = C.C_VoidType;
          t2.call$1(C.C_VoidType);
          t2 = t1.type_1;
          if (t2 != null) {
            t3 = registry.mapping;
            t4 = t3._types;
            if (t4 == null) {
              t4 = new M.Maplet(C.C__MapletMarker, null, null);
              t4.$builtinTypeInfo = [Y.Node, V.DartType];
              t3._types = t4;
              t3 = t4;
            } else
              t3 = t4;
            t3.$indexSet(0, node, t2);
          }
          return t1.type_1;
        } else {
          t3 = t1.typeName_0.token;
          if (t3.get$value(t3) === "dynamic") {
            t1.type_1 = C.C_DynamicType;
            t2.call$1(C.C_DynamicType);
            t2 = t1.type_1;
            if (t2 != null) {
              t3 = registry.mapping;
              t4 = t3._types;
              if (t4 == null) {
                t4 = new M.Maplet(C.C__MapletMarker, null, null);
                t4.$builtinTypeInfo = [Y.Node, V.DartType];
                t3._types = t4;
                t3 = t4;
              } else
                t3 = t4;
              t3.$indexSet(0, node, t2);
            }
            return t1.type_1;
          }
        }
        prefixName = null;
      }
      t3 = t1.typeName_0;
      t4 = visitor.get$scope();
      t5 = this.compiler;
      if (prefixName != null) {
        t6 = prefixName.token;
        wrappedElement = t4.lookup$1(t6.get$value(t6));
        element = wrappedElement != null && wrappedElement.get$kind(wrappedElement) === C.ElementKind_warn_on_use_0 ? wrappedElement.unwrap$2(t5, prefixName) : wrappedElement;
        if (element != null && element.get$kind(element) === C.ElementKind_prefix_8) {
          t4 = t3.token;
          element0 = element.lookupLocalMember$1(t4.get$value(t4));
          if (element0 != null && element.get$_deferredImport() != null && deferredIsMalformed && !J.getInterceptor(t5.backend).$isDartBackend) {
            t3 = P.LinkedHashMap_LinkedHashMap$_literal(["node", t3], null, null);
            t4 = element0.get$name(element0);
            t6 = $.ElementX_elementHashCode + 1;
            $.ElementX_elementHashCode = t6;
            element = new U.ErroneousElementX(C.MessageKind_wiD, t3, null, t4, C.ElementKind_error_0, element0, t6, C.C_Link2, null, false);
          } else
            element = element0;
        } else
          element = null;
      } else {
        t6 = t3.token;
        t6.get$value(t6);
        wrappedElement = t4.lookup$1(t6.get$value(t6));
        element = wrappedElement != null && wrappedElement.get$kind(wrappedElement) === C.ElementKind_warn_on_use_0 ? wrappedElement.unwrap$2(t5, t3) : wrappedElement;
      }
      t3 = new A.TypeResolver_resolveTypeAnnotation_reportFailureAndCreateType(t1, this, visitor, node, malformedIsError, registry);
      if (element == null)
        t1.type_1 = t3.call$2(C.MessageKind_VyX, P.LinkedHashMap_LinkedHashMap$_literal(["typeName", node.typeName], null, null));
      else if (element.get$kind(element) === C.ElementKind_ambiguous_0) {
        t1.type_1 = t3.call$2(element.get$messageKind(), element.get$messageArguments());
        element.diagnose$2(registry.mapping.analyzedElement, t5);
      } else if (element.get$isErroneous())
        t1.type_1 = t3.call$3$erroneousElement(element.get$messageKind(), element.get$messageArguments(), element);
      else if (!element.get$impliesType())
        t1.type_1 = t3.call$2(C.MessageKind_4QU, P.LinkedHashMap_LinkedHashMap$_literal(["node", node.typeName], null, null));
      else {
        t4 = element.kind;
        if (t4 === C.ElementKind_class_4) {
          t2 = t5.resolver;
          if (t2.currentlyResolvedTypeDeclaration == null)
            element.ensureResolved$1(t2.compiler);
          else
            t2.pendingClassesToBeResolved._add$1(element);
          element.computeType$1(t5);
          $arguments = [];
          $arguments.$builtinTypeInfo = [V.DartType];
          if (this.resolveTypeArguments$4(visitor, node, element.get$typeVariables(), $arguments)) {
            t2 = element.get$declaration();
            t3 = element.get$declaration();
            t4 = new V.InterfaceType(t3, $arguments);
            t4.GenericType$3$checkTypeArgumentCount(t3, $arguments, false);
            t3 = t2.get$rawType().typeArguments;
            type = new V.BadInterfaceType(t4, t2, t3);
            type.GenericType$3$checkTypeArgumentCount(t2, t3, true);
            t1.type_1 = type;
            addTypeVariableBoundsCheck = false;
          } else if ($arguments.length === 0) {
            t1.type_1 = element.get$rawType();
            addTypeVariableBoundsCheck = false;
          } else {
            t2 = element.get$declaration();
            t3 = C.JSArray_methods.toList$1$growable($arguments, false);
            type = new V.InterfaceType(t2, t3);
            type.GenericType$3$checkTypeArgumentCount(t2, t3, true);
            t1.type_1 = type;
            addTypeVariableBoundsCheck = true;
          }
        } else if (t4 === C.ElementKind_typedef_32) {
          if (element.get$resolutionState() === 0)
            t5.resolver.resolve$1(element);
          element.computeType$1(t5);
          $arguments = [];
          $arguments.$builtinTypeInfo = [V.DartType];
          if (this.resolveTypeArguments$4(visitor, node, element.get$typeVariables(), $arguments)) {
            t2 = new V.TypedefType(element, $arguments);
            t2.GenericType$3$checkTypeArgumentCount(element, $arguments, false);
            t3 = element.get$rawType().typeArguments;
            type = new V.BadTypedefType(t2, element, t3);
            type.GenericType$3$checkTypeArgumentCount(element, t3, true);
            t1.type_1 = type;
            addTypeVariableBoundsCheck = false;
          } else if ($arguments.length === 0) {
            t1.type_1 = element.get$rawType();
            addTypeVariableBoundsCheck = false;
          } else {
            t2 = C.JSArray_methods.toList$1$growable($arguments, false);
            type = new V.TypedefType(element, t2);
            type.GenericType$3$checkTypeArgumentCount(element, t2, true);
            t1.type_1 = type;
            addTypeVariableBoundsCheck = true;
          }
        } else {
          if (t4 === C.ElementKind_type_variable_128) {
            outer = visitor.get$enclosingElement().get$outermostEnclosingMemberOrTopLevel();
            isInFactoryConstructor = outer != null && (outer.get$modifiers().flags & 32) !== 0;
            t4 = outer.kind;
            if (t4 !== C.ElementKind_class_4 && t4 !== C.ElementKind_typedef_32 && !isInFactoryConstructor && O.Elements_isInStaticContext(visitor.get$enclosingElement())) {
              registry.compiler.backend.get$resolutionCallbacks().onThrowRuntimeError$1(registry);
              type = t3.call$3$userProvidedBadType(C.MessageKind_G79, P.LinkedHashMap_LinkedHashMap$_literal(["typeVariableName", node], null, null), element.computeType$1(t5));
              t1.type_1 = type;
              t3 = type;
            } else {
              type = element.computeType$1(t5);
              t1.type_1 = type;
              t3 = type;
            }
            t1.type_1 = t2.call$1(t3);
          } else
            t5.internalError$2(node, "Unexpected element kind " + J.toString$0(t4) + ".");
          addTypeVariableBoundsCheck = false;
        }
        if (addTypeVariableBoundsCheck) {
          registry.compiler.backend.get$resolutionCallbacks().onTypeVariableBoundCheck$1(registry);
          t2 = visitor.get$enclosingElement();
          t3 = visitor.compiler.enqueuer.resolution;
          if (t3.queueIsClosed)
            H.throwExpression(O.SpannableAssertionFailure$(t2, "Resolution work list is closed. Trying to add deferred action for " + J.toString$0(t2)));
          t3.deferredTaskQueue._add$1(new K.DeferredTask(t2, new A.TypeResolver_resolveTypeAnnotation_closure(t1, this, node)));
        }
      }
      t2 = t1.type_1;
      if (t2 != null) {
        t3 = registry.mapping;
        t4 = t3._types;
        if (t4 == null) {
          t4 = new M.Maplet(C.C__MapletMarker, null, null);
          t4.$builtinTypeInfo = [Y.Node, V.DartType];
          t3._types = t4;
          t3 = t4;
        } else
          t3 = t4;
        t3.$indexSet(0, node, t2);
      }
      return t1.type_1;
    },
    resolveTypeAnnotation$2: function(visitor, node) {
      return this.resolveTypeAnnotation$4$deferredIsMalformed$malformedIsError(visitor, node, true, false);
    },
    checkTypeVariableBounds$2: function(node, type) {
      this.compiler.types.checkTypeVariableBounds$2(type, new A.TypeResolver_checkTypeVariableBounds_checkTypeVariableBound(this, node, type));
    },
    resolveTypeArguments$4: function(visitor, node, typeVariables, $arguments) {
      var t1, expectedVariables, typeArguments, t2, t3, index, typeArgumentCountMismatch;
      t1 = node.typeArguments;
      if (t1 == null)
        return false;
      expectedVariables = typeVariables.length;
      for (typeArguments = t1.nodes, t2 = expectedVariables - 1, t3 = visitor.compiler, index = 0, typeArgumentCountMismatch = false; !typeArguments.get$isEmpty(typeArguments); typeArguments = typeArguments.get$tail(), ++index) {
        if (index > t2) {
          t3.reportDiagnosticInternal$4(typeArguments.get$head(typeArguments), C.MessageKind_EWB, C.Map_empty, C.Diagnostic_2_warning);
          typeArgumentCountMismatch = true;
        }
        $arguments.push(this.resolveTypeAnnotation$2(visitor, typeArguments.get$head(typeArguments)));
      }
      if (index < expectedVariables) {
        t3.reportDiagnosticInternal$4(t1, C.MessageKind_AYZ, C.Map_empty, C.Diagnostic_2_warning);
        typeArgumentCountMismatch = true;
      }
      return typeArgumentCountMismatch;
    }
  },
  TypeResolver_resolveTypeAnnotation_checkNoTypeArguments: {
    "^": "Closure:88;box_0,this_1,visitor_2,node_3",
    call$1: function(type) {
      var $arguments, t1, t2, t3, t4, t5;
      $arguments = H.setRuntimeTypeInfo([], [V.DartType]);
      t1 = this.visitor_2;
      t2 = this.node_3;
      if (this.this_1.resolveTypeArguments$4(t1, t2, C.List_empty3, $arguments)) {
        t2 = P.LinkedHashMap_LinkedHashMap$_literal(["type", t2], null, null);
        t3 = this.box_0.typeName_0.token;
        t3 = t3.get$value(t3);
        t1 = t1.get$enclosingElement();
        t4 = $.ElementX_elementHashCode + 1;
        $.ElementX_elementHashCode = t4;
        t5 = $.MalformedType_nextHash;
        $.MalformedType_nextHash = t5 + 1;
        return new V.MalformedType(new U.ErroneousElementX(C.MessageKind_0, t2, null, t3, C.ElementKind_error_0, t1, t4, C.C_Link2, null, false), type, $arguments, t5 & 1073741823);
      }
      return type;
    },
    $isFunction: true
  },
  TypeResolver_resolveTypeAnnotation_reportFailureAndCreateType: {
    "^": "Closure:229;box_0,this_4,visitor_5,node_6,malformedIsError_7,registry_8",
    call$4$erroneousElement$userProvidedBadType: function(messageKind, messageArguments, erroneousElement, userProvidedBadType) {
      var t1, t2, t3, t4, t5, $arguments;
      t1 = this.visitor_5;
      t2 = this.node_6;
      if (this.malformedIsError_7)
        t1.compiler.reportFatalError$3(t2, messageKind, messageArguments);
      else {
        t3 = this.registry_8;
        t3.compiler.backend.get$resolutionCallbacks().onThrowRuntimeError$1(t3);
        t1.compiler.reportDiagnosticInternal$4(t2, messageKind, messageArguments, C.Diagnostic_2_warning);
      }
      if (erroneousElement == null) {
        t3 = this.box_0.typeName_0.token;
        t3 = t3.get$value(t3);
        t4 = t1.get$enclosingElement();
        t5 = $.ElementX_elementHashCode + 1;
        $.ElementX_elementHashCode = t5;
        erroneousElement = new U.ErroneousElementX(messageKind, messageArguments, null, t3, C.ElementKind_error_0, t4, t5, C.C_Link2, null, false);
      }
      $arguments = H.setRuntimeTypeInfo([], [V.DartType]);
      this.this_4.resolveTypeArguments$4(t1, t2, C.List_empty3, $arguments);
      t1 = $.MalformedType_nextHash;
      $.MalformedType_nextHash = t1 + 1;
      return new V.MalformedType(erroneousElement, userProvidedBadType, $arguments, t1 & 1073741823);
    },
    call$2: function(messageKind, messageArguments) {
      return this.call$4$erroneousElement$userProvidedBadType(messageKind, messageArguments, null, null);
    },
    call$3$erroneousElement: function(messageKind, messageArguments, erroneousElement) {
      return this.call$4$erroneousElement$userProvidedBadType(messageKind, messageArguments, erroneousElement, null);
    },
    call$3$userProvidedBadType: function(messageKind, messageArguments, userProvidedBadType) {
      return this.call$4$erroneousElement$userProvidedBadType(messageKind, messageArguments, null, userProvidedBadType);
    },
    $isFunction: true
  },
  TypeResolver_resolveTypeAnnotation_closure: {
    "^": "Closure:23;box_0,this_9,node_10",
    call$0: function() {
      return this.this_9.checkTypeVariableBounds$2(this.node_10, this.box_0.type_1);
    },
    $isFunction: true
  },
  TypeResolver_checkTypeVariableBounds_checkTypeVariableBound: {
    "^": "Closure:230;this_0,node_1,type_2",
    call$4: function(_, typeArgument, typeVariable, bound) {
      var t1, t2;
      t1 = this.this_0.compiler;
      t2 = t1.types.subtypeVisitor;
      if (!(typeArgument.get$treatAsDynamic() || t2.isMoreSpecific$2(typeArgument, bound) === true))
        t1.reportDiagnosticInternal$4(this.node_1, C.MessageKind_uz8, P.LinkedHashMap_LinkedHashMap$_literal(["typeVariable", typeVariable, "bound", bound, "typeArgument", typeArgument, "thisType", this.type_2.get$element().get$thisType()], null, null), C.Diagnostic_2_warning);
    },
    $isFunction: true
  },
  MappingVisitor: {
    "^": "CommonResolverVisitor;",
    addToScope$1: [function(element) {
      var existing = this.get$scope().add$1(0, element);
      if (existing == null ? element != null : existing !== element)
        this.reportDuplicateDefinition$3(J.get$name$x(element), element, existing);
    }, "call$1", "get$addToScope", 2, 0, 47],
    reportDuplicateDefinition$3: function($name, definition, existing) {
      var t1 = this.compiler;
      t1.reportDiagnosticInternal$4(definition, C.MessageKind_c0h, P.LinkedHashMap_LinkedHashMap$_literal(["name", $name], null, null), C.Diagnostic_1_error);
      t1.reportDiagnosticInternal$4(existing, C.MessageKind_3bx, P.LinkedHashMap_LinkedHashMap$_literal(["name", $name], null, null), C.Diagnostic_8_info);
    }
  },
  ResolverVisitor: {
    "^": "MappingVisitor;enclosingElement<,inInstanceContext,inCheckContext,inCatchBlock,scope<,currentClass,currentExpressionStatement,sendIsMemberAccess,statementScope,allowedCategory,argumentsToJsInterceptorConstant,allowFinalWithoutInitializer,promotionScope,registry,typeResolver,compiler",
    isPotentiallyMutableTarget$1: function(target) {
      var t1;
      if (target == null)
        return false;
      t1 = J.getInterceptor$x(target);
      if (t1.get$kind(target) === C.ElementKind_variable_1 || t1.get$kind(target) === C.ElementKind_parameter_1)
        t1 = !(target.get$isFinal() === true || (target.get$modifiers().flags & 16) !== 0);
      else
        t1 = false;
      return t1;
    },
    reportLookupErrorIfAny$3: function(result, node, $name) {
      var t1, t2, t3, t4;
      if (!(result == null || result.get$isErroneous()))
        if (!this.inInstanceContext && result.get$isInstanceMember()) {
          this.compiler.reportDiagnosticInternal$4(node, C.MessageKind_yP5, P.LinkedHashMap_LinkedHashMap$_literal(["name", $name], null, null), C.Diagnostic_1_error);
          t1 = P.LinkedHashMap_LinkedHashMap$_literal(["name", $name], null, null);
          t2 = this.enclosingElement;
          t3 = $.ElementX_elementHashCode + 1;
          $.ElementX_elementHashCode = t3;
          return new U.ErroneousElementX(C.MessageKind_yP5, t1, null, $name, C.ElementKind_error_0, t2, t3, C.C_Link2, null, false);
        } else if (result.get$kind(result) === C.ElementKind_ambiguous_0) {
          t1 = this.compiler;
          t1.reportDiagnosticInternal$4(node, result.get$messageKind(), result.get$messageArguments(), C.Diagnostic_1_error);
          result.diagnose$2(this.enclosingElement, t1);
          t1 = result.get$messageKind();
          t2 = result.get$messageArguments();
          t3 = this.enclosingElement;
          t4 = $.ElementX_elementHashCode + 1;
          $.ElementX_elementHashCode = t4;
          return new U.ErroneousElementX(t1, t2, null, $name, C.ElementKind_error_0, t3, t4, C.C_Link2, null, false);
        }
      return result;
    },
    getOrDefineTarget$1: function(statement) {
      var t1, t2, element;
      t1 = this.registry.mapping;
      t2 = t1._definedTargets;
      element = t2 != null ? t2.$index(0, statement) : null;
      if (element == null) {
        t2 = this.statementScope.nestingLevel;
        element = new U.JumpTargetX(this.enclosingElement, statement, t2, C.C_Link4, false, false);
        t2 = t1._definedTargets;
        if (t2 == null) {
          t2 = new M.Maplet(C.C__MapletMarker, null, null);
          t2.$builtinTypeInfo = [Y.Node, O.JumpTarget];
          t1._definedTargets = t2;
          t1 = t2;
        } else
          t1 = t2;
        t1.$indexSet(0, statement, element);
      }
      return element;
    },
    inStaticContext$1: function(action) {
      var wasInstanceContext, result;
      wasInstanceContext = this.inInstanceContext;
      this.inInstanceContext = false;
      result = action.call$0();
      this.inInstanceContext = wasInstanceContext;
      return result;
    },
    doInPromotionScope$2: function(node, action) {
      var result;
      this.promotionScope = this.promotionScope.prepend$1(node);
      result = action.call$0();
      this.promotionScope = this.promotionScope.get$tail();
      return result;
    },
    visitInStaticContext$1: function(node) {
      this.inStaticContext$1(new A.ResolverVisitor_visitInStaticContext_closure(this, node));
    },
    visitIdentifier$1: function(node) {
      var t1, $name, t2, element, t3, t4, t5;
      t1 = node.token;
      if (t1.get$value(t1) === "this") {
        if (!this.inInstanceContext)
          this.compiler.reportFatalError$3(node, C.MessageKind_yP5, P.LinkedHashMap_LinkedHashMap$_literal(["name", node], null, null));
        return;
      } else if (t1.get$value(t1) === "super") {
        if (!this.inInstanceContext)
          this.compiler.reportFatalError$3(node, C.MessageKind_2rf, C.Map_empty);
        if ((64 & this.allowedCategory) === 0)
          this.compiler.reportFatalError$3(node, C.MessageKind_6dL, C.Map_empty);
        return;
      } else {
        $name = t1.get$value(t1);
        t2 = this.compiler;
        element = O.Elements_unwrap(this.scope.lookup$1($name), t2, node);
        if ((element == null || element.get$isErroneous()) && $name === "dynamic") {
          element = t2.typeClass;
          this.registry.mapping.setType$2(node, C.C_DynamicType);
        }
        element = this.reportLookupErrorIfAny$3(element, node, t1.get$value(t1));
        if (element == null) {
          if (!this.inInstanceContext) {
            t1 = t1.get$value(t1);
            t3 = P.LinkedHashMap_LinkedHashMap$_literal(["name", node], null, null);
            t2.reportDiagnosticInternal$4(node, C.MessageKind_SFN, t3, C.Diagnostic_2_warning);
            t4 = this.enclosingElement;
            t5 = $.ElementX_elementHashCode + 1;
            $.ElementX_elementHashCode = t5;
            element = new U.ErroneousElementX(C.MessageKind_SFN, t3, null, t1, C.ElementKind_error_0, t4, t5, C.C_Link2, null, false);
            t5 = this.registry;
            t5.compiler.backend.get$resolutionCallbacks().onThrowNoSuchMethod$1(t5);
          }
        } else if (element.get$isErroneous())
          ;
        else if ((element.get$kind(element).category & this.allowedCategory) === 0)
          t2.reportFatalError$3(node, C.MessageKind_wwi, P.LinkedHashMap_LinkedHashMap$_literal(["text", "is not an expression " + element.toString$0(0)], null, null));
        if (!(element == null || element.get$isErroneous()) && element.get$kind(element) === C.ElementKind_class_4)
          element.ensureResolved$1(t2);
        t1 = this.registry.useElement$2(node, element);
        return t1 != null ? new A.ElementResult(t1) : null;
      }
    },
    visitTypeAnnotation$1: function(node) {
      var type, t1, t2;
      type = this.resolveTypeAnnotation$1(node);
      if (this.inCheckContext) {
        t1 = this.registry;
        t2 = t1.compiler;
        t2.enqueuer.resolution.registerIsCheck$2(type, t1);
        t2.backend.get$resolutionCallbacks().onIsCheck$2(type, t1);
      }
      return new A.TypeResult(type);
    },
    getRedirectingThisOrSuperConstructorSelector$1: function(node) {
      var t1;
      if (node.get$receiver() != null) {
        t1 = node.get$selector().asIdentifier$0().token;
        return Z.Selector_Selector(C.SelectorKind_call_2, t1.get$value(t1), this.enclosingElement.get$library(), 0, null);
      } else
        return Z.Selector_Selector(C.SelectorKind_call_2, "", this.enclosingElement.get$library(), 0, null);
    },
    resolveConstructorRedirection$1: function($constructor) {
      var node, initializers, selector;
      node = $constructor.parseNode$1(this.compiler);
      if (node == null)
        return;
      if (node.get$initializers() == null)
        return;
      initializers = node.get$initializers().nodes;
      if (!initializers.get$isEmpty(initializers) && Y.Initializers_isConstructorRedirect(initializers.get$head(initializers))) {
        selector = this.getRedirectingThisOrSuperConstructorSelector$1(initializers.get$head(initializers));
        return $constructor.get$enclosingClass().lookupConstructor$1(selector);
      }
      return;
    },
    setupFunction$2: function(node, $function) {
      var t1, enclosingElement, t2, t3, functionParameters;
      t1 = {};
      enclosingElement = $function.enclosingElement;
      if ((node.get$modifiers().flags & 1) !== 0 && enclosingElement.get$kind(enclosingElement) !== C.ElementKind_class_4)
        this.compiler.reportDiagnosticInternal$4(node, C.MessageKind_ftt, C.Map_empty, C.Diagnostic_1_error);
      t2 = this.scope;
      t3 = new A.MethodScope($function, P.LinkedHashMap_LinkedHashMap(null, null, null, P.String, O.Element), t2);
      t3.MutableScope$1(t2);
      this.scope = t3;
      functionParameters = $function.get$functionSignature();
      t1.parameterNodes_0 = node.get$parameters() == null ? C.C_Link3 : node.get$parameters().nodes;
      functionParameters.forEachParameter$1(new A.ResolverVisitor_setupFunction_closure(t1, this, functionParameters));
      t1 = this.compiler.enqueuer.resolution;
      if (t1.queueIsClosed)
        H.throwExpression(O.SpannableAssertionFailure$(enclosingElement, "Resolution work list is closed. Trying to add deferred action for " + J.toString$0(enclosingElement)));
      t1.deferredTaskQueue._add$1(new K.DeferredTask(enclosingElement, new A.ResolverVisitor_setupFunction_closure0(this, functionParameters)));
      if (this.inCheckContext)
        functionParameters.forEachParameter$1(new A.ResolverVisitor_setupFunction_closure1(this));
    },
    visitCascade$1: function(node) {
      var t1 = node.expression;
      if (t1 == null)
        ;
      else
        t1.accept$1(0, this);
    },
    visitCascadeReceiver$1: function(node) {
      var t1 = node.expression;
      if (t1 == null)
        ;
      else
        t1.accept$1(0, this);
    },
    visitClassNode$1: function(node) {
      this.compiler.internalError$2(node, "shouldn't be called");
    },
    visitIn$2: function(node, nestedScope) {
      var oldScope, result;
      oldScope = this.scope;
      this.scope = nestedScope;
      result = node == null ? null : J.accept$1$x(node, this);
      this.scope = oldScope;
      return result;
    },
    visitLoopBodyIn$3: function(loop, body, bodyScope) {
      var element, t1;
      element = this.getOrDefineTarget$1(loop);
      t1 = this.statementScope;
      t1.breakTargetStack = t1.breakTargetStack.prepend$1(element);
      t1.continueTargetStack = t1.continueTargetStack.prepend$1(element);
      ++t1.nestingLevel;
      this.visitIn$2(body, bodyScope);
      t1 = this.statementScope;
      --t1.nestingLevel;
      t1.breakTargetStack = t1.breakTargetStack.get$tail();
      t1.continueTargetStack = t1.continueTargetStack.get$tail();
      if (!element.get$isTarget())
        this.registry.undefineTarget$1(loop);
    },
    visitBlock$1: function(node) {
      var t1, t2;
      t1 = this.scope;
      t2 = new A.BlockScope(P.LinkedHashMap_LinkedHashMap(null, null, null, P.String, O.Element), t1);
      t2.MutableScope$1(t1);
      this.visitIn$2(node.statements, t2);
    },
    visitDoWhile$1: function(node) {
      var t1, t2;
      t1 = this.scope;
      t2 = new A.BlockScope(P.LinkedHashMap_LinkedHashMap(null, null, null, P.String, O.Element), t1);
      t2.MutableScope$1(t1);
      this.visitLoopBodyIn$3(node, node.body, t2);
      t2 = node.condition;
      if (t2 == null)
        ;
      else
        t2.accept$1(0, this);
    },
    visitEmptyStatement$1: function(node) {
    },
    visitExpressionStatement$1: function(node) {
      var oldExpressionStatement, t1;
      oldExpressionStatement = this.currentExpressionStatement;
      this.currentExpressionStatement = node;
      t1 = node.expression;
      if (t1 == null)
        ;
      else
        t1.accept$1(0, this);
      this.currentExpressionStatement = oldExpressionStatement;
    },
    visitFor$1: function(node) {
      var t1, blockScope;
      t1 = this.scope;
      blockScope = new A.BlockScope(P.LinkedHashMap_LinkedHashMap(null, null, null, P.String, O.Element), t1);
      blockScope.MutableScope$1(t1);
      this.visitIn$2(node.initializer, blockScope);
      this.visitIn$2(node.get$condition(), blockScope);
      this.visitIn$2(node.update, blockScope);
      this.visitLoopBodyIn$3(node, node.body, blockScope);
    },
    visitFunctionDeclaration$1: function(node) {
      this.visitFunctionExpression$2$inFunctionDeclaration(node.$function, true);
    },
    visitFunctionExpression$2$inFunctionDeclaration: function(node, inFunctionDeclaration) {
      var t1, $name, t2, t3, t4, $function, oldScope, previousEnclosingElement, oldStatementScope;
      if (!inFunctionDeclaration && node.get$name(node) != null)
        this.compiler.reportDiagnosticInternal$4(node.get$name(node), C.MessageKind_wwi0, P.LinkedHashMap_LinkedHashMap$_literal(["name", node.get$name(node)], null, null), C.Diagnostic_1_error);
      t1 = node.get$returnType();
      if (t1 == null)
        ;
      else
        t1.accept$1(0, this);
      if (node.get$name(node) == null)
        $name = "";
      else {
        t1 = node.get$name(node).asIdentifier$0().token;
        $name = t1.get$value(t1);
      }
      t1 = $.get$Modifiers_EMPTY();
      t2 = this.enclosingElement;
      t3 = H.setRuntimeTypeInfo([], [O.FunctionElement]);
      t4 = $.ElementX_elementHashCode + 1;
      $.ElementX_elementHashCode = t4;
      $function = new U.LocalFunctionElementX(node, null, t1, t3, null, false, null, null, null, $name, C.ElementKind_function_2, t2, t4, C.C_Link2, null, false);
      t4 = this.compiler;
      t2 = this.registry;
      $function.functionSignatureCache = A.SignatureResolver_analyze(t4, node.get$parameters(), node.get$returnType(), $function, t2, true, null);
      t2.defineFunction$2(node, $function);
      if (inFunctionDeclaration)
        this.addToScope$1($function);
      oldScope = this.scope;
      this.setupFunction$2(node, $function);
      previousEnclosingElement = this.enclosingElement;
      this.enclosingElement = $function;
      oldStatementScope = this.statementScope;
      this.statementScope = A.StatementScope$();
      t1 = node.get$body(node);
      if (t1 == null)
        ;
      else
        t1.accept$1(0, this);
      this.statementScope = oldStatementScope;
      this.scope = oldScope;
      this.enclosingElement = previousEnclosingElement;
      t1 = t2.compiler;
      t3 = t1.enqueuer.resolution;
      t3.universe.allClosures.add$1(0, $function);
      t3.registerIfGeneric$2($function, t2);
      t4 = t4.functionClass;
      t1 = t1.enqueuer.resolution;
      t4.ensureResolved$1(t1.compiler);
      t1.registerInstantiatedType$3$mirrorUsage(t4.get$rawType(), t2, false);
    },
    visitFunctionExpression$1: function(node) {
      return this.visitFunctionExpression$2$inFunctionDeclaration(node, false);
    },
    visitIf$1: function(node) {
      var t1, t2;
      this.doInPromotionScope$2(node.get$condition().expression, new A.ResolverVisitor_visitIf_closure(this, node));
      this.doInPromotionScope$2(node.get$thenPart(), new A.ResolverVisitor_visitIf_closure0(this, node));
      t1 = this.scope;
      t2 = new A.BlockScope(P.LinkedHashMap_LinkedHashMap(null, null, null, P.String, O.Element), t1);
      t2.MutableScope$1(t1);
      this.visitIn$2(node.elsePart, t2);
    },
    resolveSend$1: function(node) {
      var selector, t1, t2, t3, t4, oldCategory, resolvedReceiver, $name, target, receiverClass, kind, prefix, t5;
      selector = this.resolveSelector$2(node, null);
      t1 = node.receiver;
      t2 = t1 == null;
      if (!t2 && t1.isSuper$0()) {
        t3 = this.registry.mapping;
        t4 = t3._superUses;
        if (t4 == null) {
          t4 = H.setRuntimeTypeInfo(new N.Setlet(C.C__SetletMarker, null), [Y.Node]);
          t3._superUses = t4;
          t3 = t4;
        } else
          t3 = t4;
        t3.add$1(0, node);
      }
      if (t2) {
        if (selector.kind === C.SelectorKind_call_2 && selector.name === "assert") {
          t1 = selector.argumentCount;
          if (t1 !== 1)
            this.compiler.reportFatalError$3(node.selector, C.MessageKind_RsV, P.LinkedHashMap_LinkedHashMap$_literal(["argumentCount", t1], null, null));
          else {
            t1 = selector.namedArguments.length;
            if (t1 !== 0)
              this.compiler.reportFatalError$3(node.selector, C.MessageKind_UyX, P.LinkedHashMap_LinkedHashMap$_literal(["argumentCount", t1], null, null));
          }
          t1 = this.registry;
          t2 = t1.mapping;
          t3 = t2._asserts;
          if (t3 == null) {
            t3 = H.setRuntimeTypeInfo(new N.Setlet(C.C__SetletMarker, null), [Y.Send]);
            t2._asserts = t3;
            t2 = t3;
          } else
            t2 = t3;
          t2.add$1(0, node);
          t1.compiler.backend.get$resolutionCallbacks().onAssert$2(node, t1);
          return C.C_AssertResult;
        }
        return node.selector.accept$1(0, this);
      }
      oldCategory = this.allowedCategory;
      this.allowedCategory = (oldCategory | 72) >>> 0;
      resolvedReceiver = t1.accept$1(0, this);
      this.allowedCategory = oldCategory;
      t2 = node.selector;
      t3 = t2.asIdentifier$0().token;
      $name = t3.get$value(t3);
      if ($name === "this") {
        this.compiler.reportFatalError$3(t2, C.MessageKind_wwi, P.LinkedHashMap_LinkedHashMap$_literal(["text", "expected an identifier"], null, null));
        target = null;
      } else if (t1.isSuper$0()) {
        if (!!t2.$isOperator)
          if (Y.isUserDefinableOperator($name))
            $name = selector.name;
          else
            this.compiler.reportFatalError$3(t2, C.MessageKind_Yqn, P.LinkedHashMap_LinkedHashMap$_literal(["name", $name], null, null));
        if (!this.inInstanceContext)
          this.compiler.reportFatalError$3(t1, C.MessageKind_yP5, P.LinkedHashMap_LinkedHashMap$_literal(["name", $name], null, null));
        t2 = this.currentClass;
        if (t2.get$supertype() == null)
          this.compiler.reportFatalError$3(t1, C.MessageKind_wwi, P.LinkedHashMap_LinkedHashMap$_literal(["text", "Object has no superclass"], null, null));
        t1 = this.compiler;
        target = t2.lookupSuperSelector$2(selector, t1);
        if (target == null) {
          t2 = P.LinkedHashMap_LinkedHashMap$_literal(["className", t2, "memberName", $name], null, null);
          t1.reportDiagnosticInternal$4(node, C.MessageKind_IGI, t2, C.Diagnostic_2_warning);
          t1 = this.enclosingElement;
          t3 = $.ElementX_elementHashCode + 1;
          $.ElementX_elementHashCode = t3;
          target = new U.ErroneousElementX(C.MessageKind_IGI, t2, null, $name, C.ElementKind_error_0, t1, t3, C.C_Link2, null, false);
          t3 = this.registry;
          t1 = t3.compiler;
          t1.enqueuer.resolution.registerInvocation$1(selector);
          t1.backend.get$resolutionCallbacks().onSuperNoSuchMethod$1(t3);
        }
      } else {
        if (resolvedReceiver != null) {
          t1 = resolvedReceiver.get$element();
          t1 = t1 == null || t1.get$isErroneous();
        } else
          t1 = true;
        if (t1)
          return;
        else {
          t1 = resolvedReceiver.get$element();
          if (t1.get$kind(t1) === C.ElementKind_class_4) {
            receiverClass = resolvedReceiver.get$element();
            t1 = this.compiler;
            receiverClass.ensureResolved$1(t1);
            if (!!t2.$isOperator)
              return;
            A.MembersCreator_computeClassMembersByName(t1, receiverClass.get$declaration(), $name);
            target = receiverClass.lookupLocalMember$1($name);
            t2 = target == null;
            if (t2 || target.get$isInstanceMember()) {
              t3 = this.registry;
              t3.compiler.backend.get$resolutionCallbacks().onThrowNoSuchMethod$1(t3);
              kind = t2 ? C.MessageKind_PTQ : C.MessageKind_4CA0;
              t2 = P.LinkedHashMap_LinkedHashMap$_literal(["className", receiverClass.name, "memberName", $name], null, null);
              t1.reportDiagnosticInternal$4(node, kind, t2, C.Diagnostic_2_warning);
              t1 = this.enclosingElement;
              t3 = $.ElementX_elementHashCode + 1;
              $.ElementX_elementHashCode = t3;
              return new A.ElementResult(new U.ErroneousElementX(kind, t2, null, $name, C.ElementKind_error_0, t1, t3, C.C_Link2, null, false));
            } else {
              if (!J.getInterceptor$asx($name).get$isEmpty($name) && C.JSString_methods.codeUnitAt$1($name, 0) === 95) {
                t2 = target.get$library();
                t3 = this.enclosingElement.get$library();
                t3 = t2 == null ? t3 != null : t2 !== t3;
                t2 = t3;
              } else
                t2 = false;
              if (t2) {
                t2 = this.registry;
                t2.compiler.backend.get$resolutionCallbacks().onThrowNoSuchMethod$1(t2);
                t2 = P.LinkedHashMap_LinkedHashMap$_literal(["libraryName", target.get$library().getLibraryOrScriptName$0(), "name", $name], null, null);
                t1.reportDiagnosticInternal$4(node, C.MessageKind_jV0, t2, C.Diagnostic_2_warning);
                t1 = this.enclosingElement;
                t3 = $.ElementX_elementHashCode + 1;
                $.ElementX_elementHashCode = t3;
                return new A.ElementResult(new U.ErroneousElementX(C.MessageKind_jV0, t2, null, $name, C.ElementKind_error_0, t1, t3, C.C_Link2, null, false));
              }
            }
          } else {
            t1 = resolvedReceiver.get$element();
            if (t1.get$kind(t1) === C.ElementKind_prefix_8) {
              prefix = resolvedReceiver.get$element();
              target = prefix.lookupLocalMember$1($name);
              if (target == null || target.get$isErroneous()) {
                t1 = this.registry;
                t1.compiler.backend.get$resolutionCallbacks().onThrowNoSuchMethod$1(t1);
                t1 = P.LinkedHashMap_LinkedHashMap$_literal(["libraryName", prefix.name, "memberName", $name], null, null);
                this.compiler.reportDiagnosticInternal$4(node, C.MessageKind_QnN, t1, C.Diagnostic_2_warning);
                t2 = this.enclosingElement;
                t3 = $.ElementX_elementHashCode + 1;
                $.ElementX_elementHashCode = t3;
                return new A.ElementResult(new U.ErroneousElementX(C.MessageKind_QnN, t1, null, $name, C.ElementKind_error_0, t2, t3, C.C_Link2, null, false));
              } else if (target.get$kind(target) === C.ElementKind_ambiguous_0) {
                t1 = this.registry;
                t1.compiler.backend.get$resolutionCallbacks().onThrowNoSuchMethod$1(t1);
                t1 = target.get$messageKind();
                t2 = target.get$messageArguments();
                t3 = this.compiler;
                t3.reportDiagnosticInternal$4(node, t1, t2, C.Diagnostic_2_warning);
                t4 = this.enclosingElement;
                t5 = $.ElementX_elementHashCode + 1;
                $.ElementX_elementHashCode = t5;
                target.diagnose$2(t4, t3);
                return new A.ElementResult(new U.ErroneousElementX(t1, t2, null, $name, C.ElementKind_error_0, t4, t5, C.C_Link2, null, false));
              } else if (target.kind === C.ElementKind_class_4)
                target.ensureResolved$1(this.compiler);
            } else
              target = null;
          }
        }
      }
      return target != null ? new A.ElementResult(target) : null;
    },
    resolveSelector$2: function(node, element) {
      var selector = A.ResolverVisitor_computeSendSelector(node, this.enclosingElement.get$library(), element);
      if (selector != null)
        this.registry.mapping._setSelector$2(node, selector);
      return selector;
    },
    resolveArguments$1: function(list) {
      var oldSendIsMemberAccess, seenNamedArguments, link, t1, argument, namedArgument, t2, source;
      if (list == null)
        return;
      oldSendIsMemberAccess = this.sendIsMemberAccess;
      this.sendIsMemberAccess = false;
      seenNamedArguments = P.LinkedHashMap_LinkedHashMap(null, null, null, P.String, Y.Node);
      for (link = list.nodes, t1 = this.compiler; !link.get$isEmpty(link); link = link.get$tail()) {
        argument = link.get$head(link);
        if (argument == null)
          ;
        else
          J.accept$1$x(argument, this);
        namedArgument = argument.asNamedArgument$0();
        if (namedArgument != null) {
          t2 = namedArgument.name.token;
          source = t2.get$value(t2);
          if (seenNamedArguments.containsKey$1(source)) {
            t2 = seenNamedArguments.$index(0, source);
            t1.reportDiagnosticInternal$4(argument, C.MessageKind_c0h, P.LinkedHashMap_LinkedHashMap$_literal(["name", source], null, null), C.Diagnostic_1_error);
            t1.reportDiagnosticInternal$4(t2, C.MessageKind_3bx, P.LinkedHashMap_LinkedHashMap$_literal(["name", source], null, null), C.Diagnostic_8_info);
          } else
            seenNamedArguments.$indexSet(0, source, namedArgument);
        } else if (seenNamedArguments._collection$_length !== 0)
          t1.reportFatalError$3(argument, C.MessageKind_JAi, C.Map_empty);
      }
      this.sendIsMemberAccess = oldSendIsMemberAccess;
    },
    visitSend$1: function(node) {
      var oldSendIsMemberAccess, t1, t2, t3, t4, t5, t6, result, target, t7, t8, t9, target0, cls, type, operatorString, resolvedArguments, selector, $call, argument;
      oldSendIsMemberAccess = this.sendIsMemberAccess;
      t1 = node.argumentsNode;
      t2 = t1 == null;
      t3 = !t2;
      if (t3)
        t4 = !J.getInterceptor(node.selector).$isOperator && t3;
      else
        t4 = true;
      this.sendIsMemberAccess = t4;
      t4 = node.selector;
      t5 = !!J.getInterceptor(t4).$isOperator;
      if (t5) {
        t6 = t4.asOperator$0().token;
        t6 = t6.get$value(t6) === "&&";
      } else
        t6 = false;
      result = t6 ? this.doInPromotionScope$2(node.receiver, new A.ResolverVisitor_visitSend_closure(this, node)) : this.resolveSend$1(node);
      this.sendIsMemberAccess = oldSendIsMemberAccess;
      target = result != null ? result.get$element() : null;
      t6 = target != null;
      if (t6) {
        t7 = this.compiler;
        t7 = target === t7.mirrorSystemGetNameFunction && !t7.mirrorUsageAnalyzerTask.hasMirrorUsage$1(this.enclosingElement);
      } else
        t7 = false;
      if (t7) {
        t7 = this.compiler;
        t8 = t7.mirrorSystemClass;
        t8 = t8.get$name(t8);
        t9 = t7.mirrorSystemGetNameFunction;
        t7.reportDiagnosticInternal$4(t4, C.MessageKind_soG, P.LinkedHashMap_LinkedHashMap$_literal(["class", t8, "name", t9.get$name(t9)], null, null), C.Diagnostic_4_hint);
      }
      if (!(!t6 || target.get$isErroneous())) {
        if (target.get$kind(target) === C.ElementKind_abstract_field_1) {
          target0 = target.get$getter();
          if (target0 == null && !this.inInstanceContext) {
            t6 = this.registry;
            t6.compiler.backend.get$resolutionCallbacks().onThrowNoSuchMethod$1(t6);
            t6 = target.name;
            this.compiler.reportDiagnosticInternal$4(t4, C.MessageKind_pi10, C.Map_empty, C.Diagnostic_2_warning);
            t7 = this.enclosingElement;
            t8 = $.ElementX_elementHashCode + 1;
            $.ElementX_elementHashCode = t8;
            target = new U.ErroneousElementX(C.MessageKind_pi10, C.Map_empty, null, t6, C.ElementKind_error_0, t7, t8, C.C_Link2, null, false);
          } else
            target = target0;
        } else if (target.kind === C.ElementKind_type_variable_128) {
          cls = target.get$enclosingClass();
          t6 = this.registry;
          t7 = t6.compiler;
          t7.backend.registerClassUsingVariableExpression$1(cls);
          t7.backend.get$resolutionCallbacks().onTypeVariableExpression$1(t6);
          t6.registerTypeLiteral$2(node, target.computeType$1(this.compiler));
        } else {
          if (target.get$impliesType())
            if (this.sendIsMemberAccess)
              t6 = !t5 && t3;
            else
              t6 = true;
          else
            t6 = false;
          if (t6) {
            t6 = this.compiler;
            if (target === t6.typeClass && node.receiver == null) {
              t7 = this.registry.mapping._types;
              type = t7 != null ? t7.$index(0, t4) : null;
            } else
              type = null;
            if (type == null)
              type = target.computeType$1(t6);
            this.registry.registerTypeLiteral$2(node, type);
            if (!(!t5 && t3))
              this.analyzeConstant$1(node);
            else
              this.analyzeConstant$1(t4);
          }
        }
        if (this.isPotentiallyMutableTarget$1(target)) {
          t6 = this.enclosingElement;
          t7 = target.get$enclosingElement();
          if (t6 == null ? t7 != null : t6 !== t7)
            for (t6 = this.promotionScope, t6.toString, t6 = H.setRuntimeTypeInfo(new E.LinkIterator(null, t6), [H.getTypeArgumentByIndex(t6, 0)]), t7 = this.registry.mapping; t6.moveNext$0();)
              t7.setAccessedByClosureIn$3(t6._util_implementation$_current, target, node);
        }
      }
      if (t5) {
        t4 = t4.asOperator$0().token;
        operatorString = t4.get$value(t4);
        if (operatorString === "is") {
          type = this.resolveTypeAnnotation$1(node.get$typeAnnotationFromIsCheckOrCast());
          if (type != null) {
            t4 = this.registry;
            t6 = t4.compiler;
            t6.enqueuer.resolution.registerIsCheck$2(type, t4);
            t6.backend.get$resolutionCallbacks().onIsCheck$2(type, t4);
          }
          resolvedArguments = true;
        } else if (operatorString === "as") {
          t4 = t1.nodes;
          type = this.resolveTypeAnnotation$1(t4.get$head(t4));
          if (type != null) {
            t4 = this.registry;
            t6 = t4.compiler;
            t6.enqueuer.resolution.registerIsCheck$2(type, t4);
            t6.backend.get$resolutionCallbacks().onIsCheck$2(type, t4);
            t6.backend.get$resolutionCallbacks().onAsCheck$2(type, t4);
          }
          resolvedArguments = true;
        } else if (operatorString === "&&") {
          t4 = t1.nodes;
          this.doInPromotionScope$2(t4.get$head(t4), new A.ResolverVisitor_visitSend_closure0(this, node));
          resolvedArguments = true;
        } else
          resolvedArguments = false;
      } else
        resolvedArguments = false;
      if (!resolvedArguments)
        this.resolveArguments$1(t1);
      t4 = this.registry;
      t6 = t4.mapping._selectors;
      selector = t6 != null ? t6.$index(0, node) : null;
      if (selector == null)
        return;
      if (!t5 && t3) {
        t3 = target != null;
        if (!t3 || target.get$isErroneous() || target.get$isGetter() || target.get$kind(target) === C.ElementKind_field_1 || O.Elements_isClosureSend(node, target)) {
          $call = Z.Selector_Selector(C.SelectorKind_call_2, "call", null, selector.get$argumentCount(), selector.get$namedArguments());
          t4.compiler.enqueuer.resolution.registerInvocation$1($call);
        } else if (target.get$impliesType())
          ;
        else if (!selector.applies$2(target, this.compiler)) {
          t5 = t4.compiler;
          t5.backend.get$resolutionCallbacks().onThrowNoSuchMethod$1(t4);
          t6 = node.receiver;
          if (t6 != null && t6.isSuper$0()) {
            t5.enqueuer.resolution.registerInvocation$1(selector);
            t5.backend.get$resolutionCallbacks().onSuperNoSuchMethod$1(t4);
          }
        }
        if (t3 && target.isForeign$1(this.compiler)) {
          t3 = J.getInterceptor$x(selector);
          if (t3.get$name(selector) === "JS")
            t4.compiler.enqueuer.resolution.nativeEnqueuer.registerJsCall$2(node, this);
          else if (t3.get$name(selector) === "JS_INTERCEPTOR_CONSTANT") {
            t1 = t1.nodes;
            if (!t1.get$isEmpty(t1)) {
              argument = t1.get$head(t1);
              t1 = this.argumentsToJsInterceptorConstant;
              if (t1 == null) {
                t1 = P.LinkedHashSet_LinkedHashSet(null, null, null, Y.Node);
                this.argumentsToJsInterceptorConstant = t1;
              }
              t1.add$1(0, argument);
            }
          }
        }
      }
      t4.useElement$2(node, target);
      this.registerSend$2(selector, target);
      if (t2 && O.Elements_isStaticOrTopLevelFunction(target)) {
        t1 = target.get$declaration();
        t4.compiler.enqueuer.resolution.registerGetOfStaticFunction$1(t1);
      }
      return t2 ? target != null ? new A.ElementResult(target) : null : null;
    },
    resolveTypeFromString$2: function(node, typeName) {
      var t1, element;
      t1 = this.compiler;
      element = O.Elements_unwrap(this.scope.lookup$1(typeName), t1, node);
      if (element == null)
        return;
      if (!element.$isClassElement)
        return;
      element.ensureResolved$1(t1);
      return element.computeType$1(t1);
    },
    visitSendSet$1: function(node) {
      var oldSendIsMemberAccess, t1, t2, result, target, operatorName, isComplex, setter, getter, t3, t4, t5, selector, getterSelector, userOperator;
      oldSendIsMemberAccess = this.sendIsMemberAccess;
      t1 = node.argumentsNode;
      t2 = t1 != null;
      if (t2)
        t2 = !J.getInterceptor(node.selector).$isOperator && t2;
      else
        t2 = true;
      this.sendIsMemberAccess = t2;
      result = this.resolveSend$1(node);
      this.sendIsMemberAccess = oldSendIsMemberAccess;
      target = result != null ? result.get$element() : null;
      t2 = node.assignmentOperator.token;
      operatorName = t2.get$value(t2);
      isComplex = operatorName !== "=";
      if (!(!!J.getInterceptor(result).$isAssertResult || target == null || target.get$isErroneous())) {
        if (target.get$kind(target) === C.ElementKind_abstract_field_1) {
          setter = target.get$setter();
          getter = target.getter;
          if (setter == null && !this.inInstanceContext) {
            t2 = target.name;
            this.compiler.reportDiagnosticInternal$4(node.selector, C.MessageKind_pi11, C.Map_empty, C.Diagnostic_2_warning);
            t3 = this.enclosingElement;
            t4 = $.ElementX_elementHashCode + 1;
            $.ElementX_elementHashCode = t4;
            setter = new U.ErroneousElementX(C.MessageKind_pi11, C.Map_empty, null, t2, C.ElementKind_error_0, t3, t4, C.C_Link2, null, false);
            t4 = this.registry;
            t4.compiler.backend.get$resolutionCallbacks().onThrowNoSuchMethod$1(t4);
          }
          if (isComplex && getter == null && !this.inInstanceContext) {
            t2 = target.name;
            this.compiler.reportDiagnosticInternal$4(node.selector, C.MessageKind_pi10, C.Map_empty, C.Diagnostic_2_warning);
            t3 = this.enclosingElement;
            t4 = $.ElementX_elementHashCode + 1;
            $.ElementX_elementHashCode = t4;
            getter = new U.ErroneousElementX(C.MessageKind_pi10, C.Map_empty, null, t2, C.ElementKind_error_0, t3, t4, C.C_Link2, null, false);
            t4 = this.registry;
            t4.compiler.backend.get$resolutionCallbacks().onThrowNoSuchMethod$1(t4);
          }
        } else {
          if (target.get$impliesType()) {
            t2 = target.name;
            this.compiler.reportDiagnosticInternal$4(node.selector, C.MessageKind_fHw, C.Map_empty, C.Diagnostic_2_warning);
            t3 = this.enclosingElement;
            t4 = $.ElementX_elementHashCode + 1;
            $.ElementX_elementHashCode = t4;
            setter = new U.ErroneousElementX(C.MessageKind_fHw, C.Map_empty, null, t2, C.ElementKind_error_0, t3, t4, C.C_Link2, null, false);
            t4 = this.registry;
            t4.compiler.backend.get$resolutionCallbacks().onThrowNoSuchMethod$1(t4);
          } else {
            if ((target.get$modifiers().flags & 4) === 0)
              if ((target.get$modifiers().flags & 16) === 0)
                t2 = target.get$isFunction() && O.Elements_isStaticOrTopLevelFunction(target) && target.kind !== C.ElementKind_setter_0;
              else
                t2 = true;
            else
              t2 = true;
            if (t2) {
              t2 = target.get$isFunction();
              t3 = node.selector;
              t4 = this.compiler;
              t5 = target.name;
              if (t2) {
                t4.reportDiagnosticInternal$4(t3, C.MessageKind_46y0, C.Map_empty, C.Diagnostic_2_warning);
                t2 = this.enclosingElement;
                t3 = $.ElementX_elementHashCode + 1;
                $.ElementX_elementHashCode = t3;
                setter = new U.ErroneousElementX(C.MessageKind_46y0, C.Map_empty, null, t5, C.ElementKind_error_0, t2, t3, C.C_Link2, null, false);
              } else {
                t4.reportDiagnosticInternal$4(t3, C.MessageKind_pi11, C.Map_empty, C.Diagnostic_2_warning);
                t2 = this.enclosingElement;
                t3 = $.ElementX_elementHashCode + 1;
                $.ElementX_elementHashCode = t3;
                setter = new U.ErroneousElementX(C.MessageKind_pi11, C.Map_empty, null, t5, C.ElementKind_error_0, t2, t3, C.C_Link2, null, false);
              }
              t2 = this.registry;
              t2.compiler.backend.get$resolutionCallbacks().onThrowNoSuchMethod$1(t2);
            } else
              setter = target;
          }
          getter = target;
        }
        if (this.isPotentiallyMutableTarget$1(target)) {
          t2 = this.registry.mapping;
          t2.registerPotentialMutation$2(target, node);
          t3 = this.enclosingElement;
          t4 = target.get$enclosingElement();
          if (t3 == null ? t4 != null : t3 !== t4)
            t2.registerPotentialMutationInClosure$2(target, node);
          for (t3 = this.promotionScope, t3.toString, t3 = H.setRuntimeTypeInfo(new E.LinkIterator(null, t3), [H.getTypeArgumentByIndex(t3, 0)]); t3.moveNext$0();)
            t2.registerPotentialMutationIn$3(t3._util_implementation$_current, target, node);
        }
      } else {
        getter = target;
        setter = getter;
      }
      this.resolveArguments$1(t1);
      t1 = this.registry;
      t2 = t1.mapping;
      t3 = t2._selectors;
      selector = t3 != null ? t3.$index(0, node) : null;
      if (isComplex) {
        t3 = J.getInterceptor$x(selector);
        getterSelector = t3.get$kind(selector) === C.SelectorKind_setter_1 ? Z.Selector_Selector(C.SelectorKind_getter_0, t3.get$name(selector), selector.get$library(), 0, null) : Z.Selector_Selector(C.SelectorKind_index_4, O.Elements_constructOperatorName("[]", false), null, 1, null);
        this.registerSend$2(getterSelector, getter);
        t4 = node.selector;
        t2._setSelector$2(t4, getterSelector);
        t2 = node.receiver;
        if (t2 != null && t2.isSuper$0()) {
          t2 = this.currentClass;
          t5 = this.compiler;
          getter = t2.lookupSuperSelector$2(getterSelector, t5);
          if (getter == null) {
            t3.get$name(selector);
            t5.reportDiagnosticInternal$4(node, C.MessageKind_IGI, P.LinkedHashMap_LinkedHashMap$_literal(["className", t2, "memberName", t3.get$name(selector)], null, null), C.Diagnostic_2_warning);
            $.ElementX_elementHashCode = $.ElementX_elementHashCode + 1;
            t1.compiler.backend.get$resolutionCallbacks().onSuperNoSuchMethod$1(t1);
          }
        }
        t1.useElement$2(t4, getter);
        t2 = new A.ResolverVisitor_visitSendSet_registerBinaryOperator(this, node);
        if (operatorName === "++") {
          t2.call$1("+");
          t2 = this.compiler.intClass;
          t3 = t1.compiler.enqueuer.resolution;
          t2.ensureResolved$1(t3.compiler);
          t3.registerInstantiatedType$3$mirrorUsage(t2.get$rawType(), t1, false);
        } else if (operatorName === "--") {
          t2.call$1("-");
          t2 = this.compiler.intClass;
          t3 = t1.compiler.enqueuer.resolution;
          t2.ensureResolved$1(t3.compiler);
          t3.registerInstantiatedType$3$mirrorUsage(t2.get$rawType(), t1, false);
        } else if (J.endsWith$1$s(operatorName, "=")) {
          userOperator = O.Elements_mapToUserOperatorOrNull(operatorName);
          if (userOperator == null) {
            H.throwExpression("Unhandled operator: " + operatorName);
            result = null;
          } else
            result = userOperator;
          t2.call$1(result);
        }
      }
      this.registerSend$2(selector, setter);
      t1 = t1.useElement$2(node, setter);
      return t1 != null ? new A.ElementResult(t1) : null;
    },
    registerSend$2: function(selector, target) {
      var t1, t2;
      if (target == null || target.get$isInstanceMember()) {
        t1 = selector.kind;
        if (t1 === C.SelectorKind_getter_0)
          this.registry.compiler.enqueuer.resolution.registerInvokedGetter$1(selector);
        else {
          t2 = this.registry;
          if (t1 === C.SelectorKind_setter_1)
            t2.compiler.enqueuer.resolution.registerInvokedSetter$1(selector);
          else
            t2.compiler.enqueuer.resolution.registerInvocation$1(selector);
        }
      } else if (O.Elements_isStaticOrTopLevel(target))
        if (target.get$kind(target) !== C.ElementKind_type_variable_128) {
          t1 = target.get$declaration();
          this.registry.compiler.enqueuer.resolution.registerStaticUse$1(t1);
        }
    },
    visitLiteralInt$1: function(node) {
      var t1, t2, t3;
      t1 = this.registry;
      t2 = this.compiler.intClass;
      t3 = t1.compiler.enqueuer.resolution;
      t2.ensureResolved$1(t3.compiler);
      t3.registerInstantiatedType$3$mirrorUsage(t2.get$rawType(), t1, false);
    },
    visitLiteralDouble$1: function(node) {
      var t1, t2, t3;
      t1 = this.registry;
      t2 = this.compiler.doubleClass;
      t3 = t1.compiler.enqueuer.resolution;
      t2.ensureResolved$1(t3.compiler);
      t3.registerInstantiatedType$3$mirrorUsage(t2.get$rawType(), t1, false);
    },
    visitLiteralBool$1: function(node) {
      var t1, t2, t3;
      t1 = this.registry;
      t2 = this.compiler.boolClass;
      t3 = t1.compiler.enqueuer.resolution;
      t2.ensureResolved$1(t3.compiler);
      t3.registerInstantiatedType$3$mirrorUsage(t2.get$rawType(), t1, false);
    },
    visitLiteralString$1: function(node) {
      var t1, t2, t3;
      t1 = this.registry;
      t2 = this.compiler.stringClass;
      t3 = t1.compiler.enqueuer.resolution;
      t2.ensureResolved$1(t3.compiler);
      t3.registerInstantiatedType$3$mirrorUsage(t2.get$rawType(), t1, false);
    },
    visitLiteralNull$1: function(node) {
      var t1, t2, t3;
      t1 = this.registry;
      t2 = this.compiler.nullClass;
      t3 = t1.compiler.enqueuer.resolution;
      t2.ensureResolved$1(t3.compiler);
      t3.registerInstantiatedType$3$mirrorUsage(t2.get$rawType(), t1, false);
    },
    visitLiteralSymbol$1: function(node) {
      var t1, t2, t3, t4, t5;
      t1 = this.registry;
      t2 = this.compiler;
      t3 = t2.symbolClass;
      t4 = t1.compiler;
      t5 = t4.enqueuer.resolution;
      t3.ensureResolved$1(t5.compiler);
      t5.registerInstantiatedType$3$mirrorUsage(t3.get$rawType(), t1, false);
      t3 = t2.symbolConstructor.get$declaration();
      t4.enqueuer.resolution.registerStaticUse$1(t3);
      t3 = node.get$slowNameString();
      t4.backend.registerConstSymbol$2(t3, t1);
      if (!this.validateSymbol$3$reportError(node, node.get$slowNameString(), false))
        t2.reportDiagnosticInternal$4(node, C.MessageKind_zVP, P.LinkedHashMap_LinkedHashMap$_literal(["value", node.get$slowNameString()], null, null), C.Diagnostic_1_error);
      this.analyzeConstant$1(node);
    },
    visitStringJuxtaposition$1: function(node) {
      var t1, t2, t3;
      t1 = this.registry;
      t2 = this.compiler.stringClass;
      t3 = t1.compiler.enqueuer.resolution;
      t2.ensureResolved$1(t3.compiler);
      t3.registerInstantiatedType$3$mirrorUsage(t2.get$rawType(), t1, false);
      node.first.accept$1(0, this);
      node.second.accept$1(0, this);
    },
    visitNodeList$1: function(node) {
      var link, t1;
      for (link = node.nodes; !link.get$isEmpty(link); link = link.get$tail()) {
        t1 = link.get$head(link);
        if (t1 == null)
          ;
        else
          J.accept$1$x(t1, this);
      }
    },
    visitOperator$1: function(node) {
      this.compiler.internalError$2(node, "operator");
    },
    visitRethrow$1: function(node) {
      if (!this.inCatchBlock)
        this.compiler.reportFatalError$3(node, C.MessageKind_z3C, C.Map_empty);
    },
    visitReturn$1: function(node) {
      var expression, t1;
      expression = node.get$expression();
      if (expression != null) {
        t1 = this.enclosingElement;
        t1 = t1.get$kind(t1) === C.ElementKind_generative_constructor_16;
      } else
        t1 = false;
      if (t1)
        this.compiler.reportDiagnosticInternal$4(expression, C.MessageKind_aBG, C.Map_empty, C.Diagnostic_1_error);
      t1 = node.expression;
      if (t1 == null)
        ;
      else
        t1.accept$1(0, this);
    },
    visitRedirectingFactoryBody$1: function(node) {
      var t1, t2, t3, $constructor, isConstConstructor, redirectionTarget, t4, targetClass, t5, type, targetType, constructorType, t6;
      t1 = this.enclosingElement;
      t2 = this.compiler;
      t3 = t2.symbolConstructor;
      if (!t1.get$isFactoryConstructor()) {
        t2.reportDiagnosticInternal$4(node, C.MessageKind_y1j, C.Map_empty, C.Diagnostic_1_error);
        t2.reportDiagnosticInternal$4(this.enclosingElement, C.MessageKind_LJp, C.Map_empty, C.Diagnostic_4_hint);
      }
      $constructor = this.enclosingElement;
      isConstConstructor = ($constructor.get$modifiers().flags & 16) !== 0;
      redirectionTarget = node.accept$1(0, new A.ConstructorResolver(this, isConstConstructor, null, t2));
      $constructor.set$immediateRedirectionTarget(redirectionTarget);
      t4 = this.registry;
      t4.useElement$2(node, redirectionTarget);
      if (redirectionTarget == null || redirectionTarget.get$isErroneous()) {
        t4.compiler.backend.get$resolutionCallbacks().onThrowNoSuchMethod$1(t4);
        return;
      } else {
        if (isConstConstructor && !redirectionTarget.get$isConst())
          t2.reportDiagnosticInternal$4(node, C.MessageKind_6QF, C.Map_empty, C.Diagnostic_1_error);
        if (J.$eq(redirectionTarget, $constructor)) {
          t2.reportDiagnosticInternal$4(node, C.MessageKind_aPa, C.Map_empty, C.Diagnostic_1_error);
          return;
        }
      }
      targetClass = redirectionTarget.get$enclosingClass();
      t5 = t4.mapping._types;
      type = t5 != null ? t5.$index(0, node) : null;
      targetType = redirectionTarget.computeType$1(t2).subst$2(type.get$typeArguments(), targetClass.get$typeVariables());
      constructorType = $constructor.computeType$1(t2);
      t5 = t2.types.subtypeVisitor;
      if (!(targetType.get$treatAsDynamic() || t5.isMoreSpecific$2(targetType, constructorType) === true))
        t2.reportDiagnosticInternal$4(node, C.MessageKind_Yeh, P.LinkedHashMap_LinkedHashMap$_literal(["fromType", targetType, "toType", constructorType], null, null), C.Diagnostic_2_warning);
      if (!redirectionTarget.computeSignature$1(t2).isCompatibleWith$1($constructor.computeSignature$1(t2)))
        t4.compiler.backend.get$resolutionCallbacks().onThrowNoSuchMethod$1(t4);
      t2 = t2.enqueuer.resolution;
      if (t2.queueIsClosed)
        H.throwExpression(O.SpannableAssertionFailure$($constructor, "Resolution work list is closed. Trying to add deferred action for " + $constructor.toString$0(0)));
      t2.deferredTaskQueue._add$1(new K.DeferredTask($constructor, new A.ResolverVisitor_visitRedirectingFactoryBody_closure(this, node, $constructor)));
      t2 = t4.compiler;
      t2.enqueuer.resolution.registerStaticUse$1(redirectionTarget);
      t5 = redirectionTarget.get$enclosingClass().get$declaration();
      t6 = t2.enqueuer.resolution;
      t5.ensureResolved$1(t6.compiler);
      t6.registerInstantiatedType$3$mirrorUsage(t5.get$rawType(), t4, false);
      if (t1 == null ? t3 == null : t1 === t3)
        t2.backend.get$resolutionCallbacks().onSymbolConstructor$1(t4);
    },
    visitThrow$1: function(node) {
      var t1 = this.registry;
      t1.compiler.backend.get$resolutionCallbacks().onThrowExpression$1(t1);
      t1 = node.get$expression();
      if (t1 == null)
        ;
      else
        t1.accept$1(0, this);
    },
    visitVariableDefinitions$1: function(node) {
      var t1, t2, type, variables, t3, t4, t5;
      t1 = node.type;
      t2 = t1 != null;
      type = t2 ? this.resolveTypeAnnotation$1(t1) : C.C_DynamicType;
      t1 = node.modifiers;
      variables = new U.VariableList(node, type, t1, C.C_Link2);
      variables.VariableList$node$2(node, type);
      t3 = this.compiler;
      t4 = new A.ResolverVisitor_visitVariableDefinitions_reportExtraModifier(this, t1);
      t1 = t1.flags;
      if ((t1 & 4) !== 0)
        t5 = (t1 & 16) !== 0 || (t1 & 8) !== 0;
      else
        t5 = false;
      if (t5)
        t4.call$1("final");
      if ((t1 & 8) !== 0)
        t2 = (t1 & 16) !== 0 || t2;
      else
        t2 = false;
      if (t2)
        t4.call$1("var");
      if (this.enclosingElement.get$isFunction()) {
        if ((t1 & 2) !== 0)
          t4.call$1("abstract");
        if ((t1 & 1) !== 0)
          t4.call$1("static");
      }
      if (node.metadata != null)
        variables.metadata = t3.resolver.resolveMetadata$2(this.enclosingElement, node);
      node.definitions.accept$1(0, new A.VariableDefinitionsVisitor(node, this, variables, t3));
    },
    visitWhile$1: function(node) {
      var t1, t2;
      t1 = node.condition;
      if (t1 == null)
        ;
      else
        t1.accept$1(0, this);
      t1 = this.scope;
      t2 = new A.BlockScope(P.LinkedHashMap_LinkedHashMap(null, null, null, P.String, O.Element), t1);
      t2.MutableScope$1(t1);
      this.visitLoopBodyIn$3(node, node.body, t2);
    },
    visitParenthesizedExpression$1: function(node) {
      var oldSendIsMemberAccess, t1;
      oldSendIsMemberAccess = this.sendIsMemberAccess;
      this.sendIsMemberAccess = false;
      t1 = node.expression;
      if (t1 == null)
        ;
      else
        t1.accept$1(0, this);
      this.sendIsMemberAccess = oldSendIsMemberAccess;
    },
    visitNewExpression$1: function(node) {
      var t1, $constructor, t2, t3, isMirrorsUsedConstant, callSelector, t4, t5, t6, t7, cls, t8, type, argumentNode, $name, nameString;
      t1 = this.compiler;
      $constructor = new A.ConstructorResolver(this, false, null, t1).visitNewExpression$1(node);
      t2 = t1.symbolConstructor;
      if (node.get$isConst()) {
        t3 = t1.mirrorsUsedConstructor;
        isMirrorsUsedConstant = $constructor == null ? t3 == null : $constructor === t3;
      } else
        isMirrorsUsedConstant = false;
      t3 = node.send;
      callSelector = this.resolveSelector$2(t3, $constructor);
      t4 = t3.argumentsNode;
      this.resolveArguments$1(t4);
      t5 = this.registry;
      t5.useElement$2(t3, $constructor);
      t6 = $constructor != null;
      if (!t6 || $constructor.get$isErroneous())
        return t6 ? new A.ElementResult($constructor) : null;
      if (!callSelector.applies$2($constructor, t1))
        t5.compiler.backend.get$resolutionCallbacks().onThrowNoSuchMethod$1(t5);
      t6 = $constructor.get$declaration();
      t7 = t5.compiler;
      t7.enqueuer.resolution.registerStaticUse$1(t6);
      cls = $constructor.get$enclosingClass();
      t6 = t5.mapping;
      t8 = t6._types;
      type = t8 != null ? t8.$index(0, node) : null;
      if (node.get$isConst() && type.get$typeVariableOccurrence() != null)
        t1.reportDiagnosticInternal$4(t3.selector, C.MessageKind_Kz0, C.Map_empty, C.Diagnostic_1_error);
      t7.enqueuer.resolution.registerInstantiatedType$2(type, t5);
      if (($constructor.get$modifiers().flags & 32) !== 0 && type.get$typeArguments().length !== 0)
        t7.enqueuer.resolution.universe.usingFactoryWithTypeArguments = true;
      if ($constructor.kind === C.ElementKind_generative_constructor_16 && cls.get$isAbstract()) {
        t1.reportDiagnosticInternal$4(node, C.MessageKind_5ib, C.Map_empty, C.Diagnostic_2_warning);
        t7.backend.get$resolutionCallbacks().onAbstractClassInstantiation$1(t5);
      }
      if ($constructor == null ? t2 == null : $constructor === t2)
        if (node.get$isConst()) {
          t2 = t4.nodes;
          argumentNode = t2.get$head(t2);
          $name = t1.resolver.constantCompiler.compileNode$2(argumentNode, t6);
          if (!$name.get$isString())
            t1.reportDiagnosticInternal$4(argumentNode, C.MessageKind_yPB, P.LinkedHashMap_LinkedHashMap$_literal(["type", $name.computeType$1(t1)], null, null), C.Diagnostic_1_error);
          else {
            nameString = $name.get$value($name).slowToString$0();
            if (this.validateSymbol$2(argumentNode, nameString))
              t7.backend.registerConstSymbol$2(nameString, t5);
          }
        } else {
          if (!t1.mirrorUsageAnalyzerTask.hasMirrorUsage$1(this.enclosingElement)) {
            t2 = t1.symbolClass;
            t1.reportDiagnosticInternal$4(node.newToken, C.MessageKind_Ewx, P.LinkedHashMap_LinkedHashMap$_literal(["name", t2.get$name(t2)], null, null), C.Diagnostic_4_hint);
          }
          t7.backend.registerNewSymbol$1(t5);
        }
      else if (isMirrorsUsedConstant)
        t1.mirrorUsageAnalyzerTask.validate$2(node, t6);
      if (node.get$isConst())
        this.analyzeConstant$1(node);
      return;
    },
    checkConstMapKeysDontOverrideEquals$2: function(spannable, map) {
      var t1, t2, key, keyType, cls, t3, t4;
      for (t1 = map.get$keys(), t1 = H.setRuntimeTypeInfo(new H.ListIterator(t1, t1.length, 0, null), [H.getTypeArgumentByIndex(t1, 0)]), t2 = this.compiler; t1.moveNext$0();) {
        key = t1.__internal$_current;
        if (!key.get$isObject())
          continue;
        keyType = key.get$type(key);
        cls = keyType.get$element();
        t3 = t2.stringClass;
        if (cls == null ? t3 == null : cls === t3)
          continue;
        t3 = cls.lookupMember$1("==").get$enclosingClass();
        t4 = t2.objectClass;
        if (t3 == null ? t4 != null : t3 !== t4)
          t2.reportDiagnosticInternal$4(spannable, C.MessageKind_4AN, P.LinkedHashMap_LinkedHashMap$_literal(["type", keyType], null, null), C.Diagnostic_1_error);
      }
    },
    analyzeConstant$1: function(node) {
      var t1, t2;
      t1 = this.enclosingElement;
      t2 = this.compiler.enqueuer.resolution;
      if (t2.queueIsClosed)
        H.throwExpression(O.SpannableAssertionFailure$(t1, "Resolution work list is closed. Trying to add deferred action for " + J.toString$0(t1)));
      t2.deferredTaskQueue._add$1(new K.DeferredTask(t1, new A.ResolverVisitor_analyzeConstant_closure(this, node)));
    },
    validateSymbol$3$reportError: function(node, $name, reportError) {
      var t1;
      if (J.getInterceptor$asx($name).get$isEmpty($name))
        return true;
      if (C.JSString_methods.startsWith$1($name, "_")) {
        if (reportError)
          this.compiler.reportDiagnosticInternal$4(node, C.MessageKind_Wfv, P.LinkedHashMap_LinkedHashMap$_literal(["value", $name], null, null), C.Diagnostic_1_error);
        return false;
      }
      t1 = $.get$ResolverVisitor_symbolValidationPattern()._nativeRegExp;
      if (!t1.test($name)) {
        if (reportError)
          this.compiler.reportDiagnosticInternal$4(node, C.MessageKind_01, P.LinkedHashMap_LinkedHashMap$_literal(["value", $name], null, null), C.Diagnostic_1_error);
        return false;
      }
      return true;
    },
    validateSymbol$2: function(node, name) {
      return this.validateSymbol$3$reportError(node, name, true);
    },
    resolveTypeAnnotation$3$deferredIsMalformed$malformedIsError: function(node, deferredIsMalformed, malformedIsError) {
      var type, t1, t2, t3;
      type = this.typeResolver.resolveTypeAnnotation$4$deferredIsMalformed$malformedIsError(this, node, deferredIsMalformed, malformedIsError);
      if (this.inCheckContext) {
        t1 = this.registry;
        t2 = t1.compiler;
        t3 = t2.enqueuer.resolution;
        t3.universe.isChecks.add$1(0, type.unalias$1(t3.compiler));
        t2.backend.get$resolutionCallbacks().onIsCheck$2(type, t1);
        t1 = this.enclosingElement;
        t2.backend.registerRequiredType$2(type, t1);
      }
      return type;
    },
    resolveTypeAnnotation$1: function(node) {
      return this.resolveTypeAnnotation$3$deferredIsMalformed$malformedIsError(node, true, false);
    },
    visitModifiers$1: function(node) {
      this.compiler.internalError$2(node, "modifiers");
    },
    visitLiteralList$1: function(node) {
      var $arguments, nodes, typeArgument, t1, t2, t3, t4, type, t5, listType;
      this.sendIsMemberAccess = false;
      $arguments = node.get$typeArguments();
      if ($arguments != null) {
        nodes = $arguments.nodes;
        if (nodes.get$isEmpty(nodes)) {
          this.compiler.reportFatalError$3($arguments, C.MessageKind_AYZ, C.Map_empty);
          typeArgument = null;
        } else {
          typeArgument = this.resolveTypeAnnotation$1(nodes.get$head(nodes));
          for (nodes = nodes.get$tail(), t1 = this.compiler, t2 = this.typeResolver, t3 = this.registry, t4 = t3.compiler; !nodes.get$isEmpty(nodes); nodes = nodes.get$tail()) {
            t1.reportDiagnosticInternal$4(nodes.get$head(nodes), C.MessageKind_EWB, C.Map_empty, C.Diagnostic_2_warning);
            type = t2.resolveTypeAnnotation$4$deferredIsMalformed$malformedIsError(this, nodes.get$head(nodes), true, false);
            if (this.inCheckContext) {
              t5 = t4.enqueuer.resolution;
              t5.universe.isChecks.add$1(0, type.unalias$1(t5.compiler));
              t4.backend.get$resolutionCallbacks().onIsCheck$2(type, t3);
              t5 = this.enclosingElement;
              t4.backend.registerRequiredType$2(type, t5);
            }
          }
        }
      } else
        typeArgument = null;
      if (typeArgument != null) {
        if (node.constKeyword != null && typeArgument.get$typeVariableOccurrence() != null) {
          t1 = $arguments.nodes;
          this.compiler.reportDiagnosticInternal$4(t1.get$head(t1), C.MessageKind_Kz0, C.Map_empty, C.Diagnostic_1_error);
        }
        t1 = this.compiler.listClass;
        t2 = [typeArgument];
        listType = new V.InterfaceType(t1, t2);
        listType.GenericType$3$checkTypeArgumentCount(t1, t2, true);
      } else {
        t1 = this.compiler;
        t1.listClass.computeType$1(t1);
        listType = t1.listClass.get$rawType();
      }
      t1 = this.registry;
      t1.mapping.setType$2(node, listType);
      t2 = t1.compiler;
      t2.enqueuer.resolution.registerInstantiatedType$2(listType, t1);
      t1 = this.enclosingElement;
      t2.backend.registerRequiredType$2(listType, t1);
      node.elements.accept$1(0, this);
      if (node.constKeyword != null)
        this.analyzeConstant$1(node);
      this.sendIsMemberAccess = false;
    },
    visitConditional$1: function(node) {
      var t1;
      this.doInPromotionScope$2(node.condition, new A.ResolverVisitor_visitConditional_closure(this, node));
      this.doInPromotionScope$2(node.thenExpression, new A.ResolverVisitor_visitConditional_closure0(this, node));
      t1 = node.elseExpression;
      if (t1 == null)
        ;
      else
        t1.accept$1(0, this);
    },
    visitStringInterpolation$1: function(node) {
      var t1, t2, t3, t4;
      t1 = this.registry;
      t2 = this.compiler.stringClass;
      t3 = t1.compiler;
      t4 = t3.enqueuer.resolution;
      t2.ensureResolved$1(t4.compiler);
      t4.registerInstantiatedType$3$mirrorUsage(t2.get$rawType(), t1, false);
      t3.backend.get$resolutionCallbacks().onStringInterpolation$1(t1);
      this.visitLiteralString$1(node.string);
      this.visitNodeList$1(node.parts);
    },
    visitStringInterpolationPart$1: function(node) {
      var selector = Z.Selector_Selector(C.SelectorKind_call_2, "toString", null, 0, null);
      this.registry.compiler.enqueuer.resolution.registerInvocation$1(selector);
      node.expression.accept$1(0, this);
      this.visitLiteralString$1(node.string);
    },
    visitBreakStatement$1: function(node) {
      var t1, t2, target, labelName, label;
      t1 = node.target;
      if (t1 == null) {
        t1 = this.statementScope;
        t2 = t1.breakTargetStack;
        if (t2.get$isEmpty(t2))
          target = null;
        else {
          t1 = t1.breakTargetStack;
          target = t1.get$head(t1);
        }
        if (target == null)
          this.compiler.reportFatalError$3(node, C.MessageKind_Tj8, C.Map_empty);
        target.set$isBreakTarget(true);
      } else {
        t2 = t1.token;
        labelName = t2.get$value(t2);
        label = this.statementScope.labels.lookup$1(labelName);
        if (label == null)
          this.compiler.reportFatalError$3(t1, C.MessageKind_4MG, P.LinkedHashMap_LinkedHashMap$_literal(["labelName", labelName], null, null));
        target = label.target;
        if (!target.statement.isValidBreakTarget$0())
          this.compiler.reportFatalError$3(t1, C.MessageKind_Agx, C.Map_empty);
        label.isBreakTarget = true;
        target.isBreakTarget = true;
        this.registry.mapping.registerTargetLabel$2(node, label);
      }
      this.registry.mapping.registerTargetOf$2(node, target);
    },
    visitContinueStatement$1: function(node) {
      var t1, t2, target, labelName, label;
      t1 = node.target;
      if (t1 == null) {
        t1 = this.statementScope;
        t2 = t1.continueTargetStack;
        if (t2.get$isEmpty(t2))
          target = null;
        else {
          t1 = t1.continueTargetStack;
          target = t1.get$head(t1);
        }
        if (target == null)
          this.compiler.reportFatalError$3(node, C.MessageKind_AIG, C.Map_empty);
        target.set$isContinueTarget(true);
      } else {
        t2 = t1.token;
        labelName = t2.get$value(t2);
        label = this.statementScope.labels.lookup$1(labelName);
        if (label == null)
          this.compiler.reportFatalError$3(t1, C.MessageKind_4MG, P.LinkedHashMap_LinkedHashMap$_literal(["labelName", labelName], null, null));
        target = label.target;
        if (!target.statement.isValidContinueTarget$0())
          this.compiler.reportFatalError$3(t1, C.MessageKind_uJO, C.Map_empty);
        label.isContinueTarget = true;
        target.isContinueTarget = true;
        this.registry.mapping.registerTargetLabel$2(node, label);
      }
      this.registry.mapping.registerTargetOf$2(node, target);
    },
    visitForIn$1: function(node) {
      var library, t1, t2, t3, t4, blockScope, declaration, oldAllowFinalWithoutInitializer, send, variableDefinitions, loopVariable, identifier, loopVariableSelector, nodes, first;
      library = this.enclosingElement.get$library();
      t1 = this.registry;
      t2 = this.compiler;
      t3 = t2.iteratorSelector;
      t4 = t1.mapping;
      t4._setSelector$2(node, t3);
      t1 = t1.compiler;
      t1.enqueuer.resolution.registerInvokedGetter$1(t3);
      t3 = t2.currentSelector;
      t4._setSelector$2(node.inToken, t3);
      t1.enqueuer.resolution.registerInvokedGetter$1(t3);
      t3 = t2.moveNextSelector;
      t4._setSelector$2(node.forToken, t3);
      t1.enqueuer.resolution.registerInvocation$1(t3);
      t3 = node.expression;
      if (t3 == null)
        ;
      else
        t3.accept$1(0, this);
      t1 = this.scope;
      blockScope = new A.BlockScope(P.LinkedHashMap_LinkedHashMap(null, null, null, P.String, O.Element), t1);
      blockScope.MutableScope$1(t1);
      declaration = node.declaredIdentifier;
      oldAllowFinalWithoutInitializer = this.allowFinalWithoutInitializer;
      this.allowFinalWithoutInitializer = true;
      this.visitIn$2(declaration, blockScope);
      this.allowFinalWithoutInitializer = oldAllowFinalWithoutInitializer;
      send = declaration.asSend$0();
      variableDefinitions = declaration.asVariableDefinitions$0();
      if (send != null) {
        loopVariable = send.get$_secret_tree_element$_element();
        t1 = send.selector;
        identifier = t1.asIdentifier$0();
        if (identifier == null) {
          t2.reportDiagnosticInternal$4(t1, C.MessageKind_VUC, C.Map_empty, C.Diagnostic_1_error);
          loopVariableSelector = null;
        } else {
          t1 = identifier.token;
          loopVariableSelector = Z.Selector_Selector(C.SelectorKind_setter_1, t1.get$value(t1), library, 1, null);
        }
        t1 = send.receiver;
        if (t1 != null)
          t2.reportDiagnosticInternal$4(t1, C.MessageKind_VUC, C.Map_empty, C.Diagnostic_1_error);
      } else if (variableDefinitions != null) {
        nodes = variableDefinitions.definitions.nodes;
        t1 = nodes.get$tail();
        if (!t1.get$isEmpty(t1)) {
          t1 = nodes.get$tail();
          t2.reportDiagnosticInternal$4(t1.get$head(t1), C.MessageKind_VUC, C.Map_empty, C.Diagnostic_1_error);
        }
        first = nodes.get$head(nodes);
        identifier = first.asIdentifier$0();
        if (identifier == null) {
          t2.reportDiagnosticInternal$4(first, C.MessageKind_VUC, C.Map_empty, C.Diagnostic_1_error);
          loopVariable = null;
          loopVariableSelector = null;
        } else {
          t1 = identifier.token;
          loopVariableSelector = Z.Selector_Selector(C.SelectorKind_setter_1, t1.get$value(t1), library, 1, null);
          loopVariable = identifier.get$_secret_tree_element$_element();
        }
      } else {
        t2.reportDiagnosticInternal$4(declaration, C.MessageKind_VUC, C.Map_empty, C.Diagnostic_1_error);
        loopVariable = null;
        loopVariableSelector = null;
      }
      if (loopVariableSelector != null) {
        t4._setSelector$2(declaration, loopVariableSelector);
        this.registerSend$2(loopVariableSelector, loopVariable);
      }
      if (loopVariable != null)
        t4.$indexSet(0, node, loopVariable);
      this.visitLoopBodyIn$3(node, node.body, blockScope);
    },
    visitLabel$1: function(node) {
    },
    visitLabeledStatement$1: function(node) {
      var body, targetElement, labelElements, t1, label, t2, labelName;
      body = node.statement;
      targetElement = this.getOrDefineTarget$1(body);
      labelElements = P.LinkedHashMap_LinkedHashMap$_empty(P.String, O.LabelDefinition);
      for (t1 = node.labels.nodes, t1.toString, t1 = H.setRuntimeTypeInfo(new E.LinkIterator(null, t1), [H.getTypeArgumentByIndex(t1, 0)]); t1.moveNext$0();) {
        label = t1._util_implementation$_current;
        t2 = label.get$identifier().token;
        labelName = t2.get$value(t2);
        if (labelElements.containsKey$1(labelName))
          continue;
        labelElements.$indexSet(0, labelName, targetElement.addLabel$2(label, labelName));
      }
      t1 = this.statementScope;
      t1.labels = new A.LabeledStatementLabelScope(t1.labels, labelElements);
      ++t1.nestingLevel;
      if (body == null)
        ;
      else
        body.accept$1(0, this);
      t1 = this.statementScope;
      --t1.nestingLevel;
      t1.labels = t1.labels.get$outer();
      labelElements.forEach$1(0, new A.ResolverVisitor_visitLabeledStatement_closure(this));
      if (!targetElement.get$isTarget())
        this.registry.undefineTarget$1(body);
    },
    visitLiteralMap$1: function(node) {
      var $arguments, nodes, keyTypeArgument, valueTypeArgument, t1, t2, t3, t4, type, t5, mapType;
      this.sendIsMemberAccess = false;
      $arguments = node.typeArguments;
      if ($arguments != null) {
        nodes = $arguments.nodes;
        if (nodes.get$isEmpty(nodes)) {
          this.compiler.reportFatalError$3($arguments, C.MessageKind_AYZ, C.Map_empty);
          keyTypeArgument = null;
          valueTypeArgument = null;
        } else {
          keyTypeArgument = this.resolveTypeAnnotation$1(nodes.get$head(nodes));
          nodes = nodes.get$tail();
          if (nodes.get$isEmpty(nodes)) {
            this.compiler.reportDiagnosticInternal$4($arguments, C.MessageKind_AYZ, C.Map_empty, C.Diagnostic_2_warning);
            valueTypeArgument = null;
          } else {
            valueTypeArgument = this.resolveTypeAnnotation$1(nodes.get$head(nodes));
            for (nodes = nodes.get$tail(), t1 = this.compiler, t2 = this.typeResolver, t3 = this.registry, t4 = t3.compiler; !nodes.get$isEmpty(nodes); nodes = nodes.get$tail()) {
              t1.reportDiagnosticInternal$4(nodes.get$head(nodes), C.MessageKind_EWB, C.Map_empty, C.Diagnostic_2_warning);
              type = t2.resolveTypeAnnotation$4$deferredIsMalformed$malformedIsError(this, nodes.get$head(nodes), true, false);
              if (this.inCheckContext) {
                t5 = t4.enqueuer.resolution;
                t5.universe.isChecks.add$1(0, type.unalias$1(t5.compiler));
                t4.backend.get$resolutionCallbacks().onIsCheck$2(type, t3);
                t5 = this.enclosingElement;
                t4.backend.registerRequiredType$2(type, t5);
              }
            }
          }
        }
      } else {
        keyTypeArgument = null;
        valueTypeArgument = null;
      }
      t1 = this.compiler;
      if (valueTypeArgument != null) {
        t2 = t1.mapClass;
        t3 = [keyTypeArgument, valueTypeArgument];
        mapType = new V.InterfaceType(t2, t3);
        mapType.GenericType$3$checkTypeArgumentCount(t2, t3, true);
      } else {
        t1.mapClass.computeType$1(t1);
        mapType = t1.mapClass.get$rawType();
      }
      t2 = node.constKeyword != null;
      if (t2 && mapType.get$typeVariableOccurrence() != null)
        t1.reportDiagnosticInternal$4($arguments, C.MessageKind_Kz0, C.Map_empty, C.Diagnostic_1_error);
      t1 = this.registry;
      t1.mapping.setType$2(node, mapType);
      t3 = t1.compiler;
      t3.enqueuer.resolution.registerInstantiatedType$2(mapType, t1);
      if (t2)
        t3.backend.get$resolutionCallbacks().onConstantMap$1(t1);
      t1 = this.enclosingElement;
      t3.backend.registerRequiredType$2(mapType, t1);
      node.visitChildren$1(this);
      if (t2)
        this.analyzeConstant$1(node);
      this.sendIsMemberAccess = false;
    },
    visitLiteralMapEntry$1: function(node) {
      node.key.accept$1(0, this);
      node.value.accept$1(0, this);
    },
    visitNamedArgument$1: function(node) {
      var t1 = node.expression;
      if (t1 == null)
        ;
      else
        t1.accept$1(0, this);
    },
    typeOfConstant$1: function(constant) {
      if (constant.get$isInt())
        return this.compiler.intClass.get$rawType();
      if (constant.get$isBool())
        return this.compiler.boolClass.get$rawType();
      if (constant.get$isDouble())
        return this.compiler.doubleClass.get$rawType();
      if (constant.get$isString())
        return this.compiler.stringClass.get$rawType();
      if (constant.get$isNull())
        return this.compiler.nullClass.get$rawType();
      if (constant.get$isFunction())
        return this.compiler.functionClass.get$rawType();
      return constant.get$type(constant);
    },
    checkCaseExpressions$1: function(node) {
      var cases, t1, t2, firstCase, firstCaseType, hasReportedProblem, t3, t4, caseMatch, t5, constant, caseType, t6;
      this.getOrDefineTarget$1(node);
      P.LinkedHashMap_LinkedHashMap$_empty(P.String, O.LabelDefinition);
      cases = node.cases.nodes;
      cases.get$head(cases);
      for (t1 = this.registry.mapping, t2 = this.compiler, firstCase = null, firstCaseType = null, hasReportedProblem = false; !cases.get$isEmpty(cases); cases = cases.get$tail()) {
        t3 = cases.get$head(cases).get$labelsAndCases().nodes;
        t3.toString;
        t4 = new E.LinkIterator(null, t3);
        t4.$builtinTypeInfo = [H.getTypeArgumentByIndex(t3, 0)];
        for (; t4.moveNext$0();) {
          caseMatch = t4._util_implementation$_current.asCaseMatch$0();
          if (caseMatch == null)
            continue;
          t3 = caseMatch.expression;
          t5 = t1._constants;
          constant = t5 != null ? t5.$index(0, t3) : null;
          caseType = this.typeOfConstant$1(constant);
          if (firstCaseType == null) {
            t5 = caseType.get$element();
            t6 = t2.doubleClass;
            if (t5 == null ? t6 == null : t5 === t6)
              t2.reportDiagnosticInternal$4(node, C.MessageKind_RoN, P.LinkedHashMap_LinkedHashMap$_literal(["type", "double"], null, null), C.Diagnostic_1_error);
            else {
              t5 = caseType.get$element();
              t6 = t2.functionClass;
              if (t5 == null ? t6 == null : t5 === t6)
                t2.reportDiagnosticInternal$4(node, C.MessageKind_AHc, P.LinkedHashMap_LinkedHashMap$_literal(["type", "Function"], null, null), C.Diagnostic_1_error);
              else {
                if (constant.get$isObject()) {
                  t5 = caseType.get$element().lookupMember$1("==").get$enclosingClass();
                  t6 = t2.objectClass;
                  t6 = t5 == null ? t6 != null : t5 !== t6;
                  t5 = t6;
                } else
                  t5 = false;
                if (t5)
                  t2.reportDiagnosticInternal$4(t3, C.MessageKind_RoN, P.LinkedHashMap_LinkedHashMap$_literal(["type", caseType], null, null), C.Diagnostic_1_error);
              }
            }
            firstCaseType = caseType;
            firstCase = caseMatch;
          } else if (!J.$eq(caseType, firstCaseType)) {
            if (!hasReportedProblem) {
              t2.reportDiagnosticInternal$4(node, C.MessageKind_e5Z, P.LinkedHashMap_LinkedHashMap$_literal(["type", firstCaseType], null, null), C.Diagnostic_1_error);
              t2.reportDiagnosticInternal$4(firstCase.expression, C.MessageKind_8hf, P.LinkedHashMap_LinkedHashMap$_literal(["type", firstCaseType], null, null), C.Diagnostic_8_info);
              hasReportedProblem = true;
            }
            t2.reportDiagnosticInternal$4(t3, C.MessageKind_8hf, P.LinkedHashMap_LinkedHashMap$_literal(["type", caseType], null, null), C.Diagnostic_8_info);
          }
        }
      }
    },
    visitSwitchStatement$1: function(node) {
      var breakElement, continueLabels, t1, cases, t2, t3, t4, switchCase, t5, t6, labelOrCase, caseMatch, labelName, existingElement, labelElement;
      node.parenthesizedExpression.expression.accept$1(0, this);
      breakElement = this.getOrDefineTarget$1(node);
      continueLabels = P.LinkedHashMap_LinkedHashMap$_empty(P.String, O.LabelDefinition);
      t1 = node.cases;
      cases = t1.nodes;
      for (t2 = this.registry, t3 = t2.mapping, t4 = this.compiler; !cases.get$isEmpty(cases);) {
        switchCase = cases.get$head(cases);
        t5 = switchCase.get$labelsAndCases().nodes;
        t5.toString;
        t6 = new E.LinkIterator(null, t5);
        t6.$builtinTypeInfo = [H.getTypeArgumentByIndex(t5, 0)];
        for (; t6.moveNext$0();) {
          labelOrCase = t6._util_implementation$_current;
          caseMatch = labelOrCase.asCaseMatch$0();
          if (caseMatch != null) {
            this.analyzeConstant$1(caseMatch.expression);
            continue;
          }
          t5 = labelOrCase.get$identifier().token;
          labelName = t5.get$value(t5);
          existingElement = continueLabels.$index(0, labelName);
          if (existingElement != null) {
            t4.reportDiagnosticInternal$4(labelOrCase, C.MessageKind_sQK, P.LinkedHashMap_LinkedHashMap$_literal(["labelName", labelName], null, null), C.Diagnostic_1_error);
            t4.reportDiagnosticInternal$4(existingElement.label, C.MessageKind_EUF, P.LinkedHashMap_LinkedHashMap$_literal(["labelName", labelName], null, null), C.Diagnostic_8_info);
          } else {
            existingElement = this.statementScope.labels.lookup$1(labelName);
            if (existingElement != null) {
              t4.reportDiagnosticInternal$4(labelOrCase, C.MessageKind_sQK, P.LinkedHashMap_LinkedHashMap$_literal(["labelName", labelName], null, null), C.Diagnostic_2_warning);
              t4.reportDiagnosticInternal$4(existingElement.label, C.MessageKind_EUF, P.LinkedHashMap_LinkedHashMap$_literal(["labelName", labelName], null, null), C.Diagnostic_8_info);
            }
          }
          labelElement = this.getOrDefineTarget$1(switchCase).addLabel$2(labelOrCase, labelName);
          t5 = t3._definedLabels;
          if (t5 == null) {
            t5 = new M.Maplet(C.C__MapletMarker, null, null);
            t5.$builtinTypeInfo = [Y.Label, O.LabelDefinition];
            t3._definedLabels = t5;
          }
          t5.$indexSet(0, labelOrCase, labelElement);
          continueLabels.$indexSet(0, labelName, labelElement);
        }
        cases = cases.get$tail();
        if (switchCase.defaultKeyword != null && !cases.get$isEmpty(cases))
          t4.reportFatalError$3(switchCase, C.MessageKind_GnF, C.Map_empty);
      }
      t3 = this.enclosingElement;
      t4 = t4.enqueuer.resolution;
      if (t4.queueIsClosed)
        H.throwExpression(O.SpannableAssertionFailure$(t3, "Resolution work list is closed. Trying to add deferred action for " + J.toString$0(t3)));
      t4.deferredTaskQueue._add$1(new K.DeferredTask(t3, new A.ResolverVisitor_visitSwitchStatement_closure(this, node)));
      t3 = this.statementScope;
      t3.breakTargetStack = t3.breakTargetStack.prepend$1(breakElement);
      t3.labels = new A.SwitchLabelScope(t3.labels, continueLabels);
      ++t3.nestingLevel;
      t1.toString;
      this.visitNodeList$1(t1);
      t1 = this.statementScope;
      --t1.nestingLevel;
      t1.breakTargetStack = t1.breakTargetStack.get$tail();
      t1.labels = t1.labels.get$outer();
      continueLabels.forEach$1(0, new A.ResolverVisitor_visitSwitchStatement_closure0(this));
      t2.compiler.backend.get$resolutionCallbacks().onFallThroughError$1(t2);
    },
    visitSwitchCase$1: function(node) {
      var t1, t2;
      this.visitNodeList$1(node.labelsAndCases);
      t1 = this.scope;
      t2 = new A.BlockScope(P.LinkedHashMap_LinkedHashMap(null, null, null, P.String, O.Element), t1);
      t2.MutableScope$1(t1);
      this.visitIn$2(node.statements, t2);
    },
    visitCaseMatch$1: function(node) {
      var t1 = node.expression;
      if (t1 == null)
        ;
      else
        t1.accept$1(0, this);
    },
    visitTryStatement$1: function(node) {
      var t1, t2;
      t1 = node.tryBlock;
      if (t1 == null)
        ;
      else
        t1.accept$1(0, this);
      t1 = node.catchBlocks;
      t2 = t1.nodes;
      if (t2.get$isEmpty(t2) && node.finallyBlock == null)
        this.compiler.reportFatalError$3(node.getEndToken$0().next, C.MessageKind_Jik, C.Map_empty);
      t1.accept$1(0, this);
      t1 = node.finallyBlock;
      if (t1 == null)
        ;
      else
        t1.accept$1(0, this);
    },
    visitCatchBlock$1: function(node) {
      var t1, t2, t3, formalsToProcess, exceptionDefinition, stackTraceDefinition, formalsToProcess0, t4, t5, link, nodeList, declaration, t6, type, blockScope, wasInCheckContext, oldInCatchBlock, exceptionType, exceptionVariable, stackTraceVariable, stackTraceElement;
      t1 = this.registry;
      t2 = t1.compiler;
      t2.backend.get$resolutionCallbacks().onCatchStatement$1(t1);
      t3 = node.formals;
      if (t3 != null) {
        formalsToProcess = t3.nodes;
        if (formalsToProcess.get$isEmpty(formalsToProcess)) {
          this.compiler.reportFatalError$3(node, C.MessageKind_iqV, C.Map_empty);
          exceptionDefinition = null;
          stackTraceDefinition = null;
        } else {
          exceptionDefinition = formalsToProcess.get$head(formalsToProcess).asVariableDefinitions$0();
          formalsToProcess0 = formalsToProcess.get$tail();
          if (!formalsToProcess0.get$isEmpty(formalsToProcess0)) {
            stackTraceDefinition = formalsToProcess0.get$head(formalsToProcess0).asVariableDefinitions$0();
            formalsToProcess0 = formalsToProcess0.get$tail();
            if (!formalsToProcess0.get$isEmpty(formalsToProcess0))
              for (t4 = H.setRuntimeTypeInfo(new E.LinkIterator(null, formalsToProcess0), [H.getTypeArgumentByIndex(formalsToProcess0, 0)]), t5 = this.compiler; t4.moveNext$0();)
                t5.reportFatalError$3(t4._util_implementation$_current, C.MessageKind_CFL, C.Map_empty);
            t2.backend.get$resolutionCallbacks().onStackTraceInCatch$1(t1);
          } else
            stackTraceDefinition = null;
        }
        for (t4 = this.compiler, link = formalsToProcess; !link.get$isEmpty(link); link = link.get$tail()) {
          nodeList = link.get$head(link).asNodeList$0();
          if (nodeList != null)
            t4.reportFatalError$3(nodeList, C.MessageKind_4lO, C.Map_empty);
          else {
            declaration = link.get$head(link);
            t5 = declaration.get$modifiers().nodes.nodes;
            t5.toString;
            t6 = new E.LinkIterator(null, t5);
            t6.$builtinTypeInfo = [H.getTypeArgumentByIndex(t5, 0)];
            for (; t6.moveNext$0();)
              t4.reportFatalError$3(t6._util_implementation$_current, C.MessageKind_cOu, C.Map_empty);
            type = J.get$type$x(declaration);
            if (type != null)
              t4.reportFatalError$3(type, C.MessageKind_lUo, C.Map_empty);
          }
        }
      } else {
        exceptionDefinition = null;
        stackTraceDefinition = null;
      }
      t4 = this.scope;
      blockScope = new A.BlockScope(P.LinkedHashMap_LinkedHashMap(null, null, null, P.String, O.Element), t4);
      blockScope.MutableScope$1(t4);
      wasInCheckContext = this.inCheckContext;
      this.inCheckContext = true;
      new A.ResolverVisitor_visitCatchBlock_closure(this, node, blockScope).call$0();
      this.inCheckContext = wasInCheckContext;
      this.visitIn$2(t3, blockScope);
      oldInCatchBlock = this.inCatchBlock;
      this.inCatchBlock = true;
      this.visitIn$2(node.block, blockScope);
      this.inCatchBlock = oldInCatchBlock;
      t3 = node.type;
      if (t3 != null && exceptionDefinition != null) {
        t4 = t1.mapping;
        t5 = t4._types;
        exceptionType = t5 != null ? t5.$index(0, t3) : null;
        t3 = exceptionDefinition.definitions.nodes;
        exceptionVariable = t3.get$head(t3);
        t4.toString;
        exceptionVariable.get$_secret_tree_element$_element().get$variables().type = exceptionType;
      }
      if (stackTraceDefinition != null) {
        t3 = stackTraceDefinition.definitions.nodes;
        stackTraceVariable = t3.get$head(t3);
        t1.mapping.toString;
        stackTraceElement = stackTraceVariable.get$_secret_tree_element$_element();
        t3 = this.compiler;
        t4 = t3.stackTraceClass;
        t2 = t2.enqueuer.resolution;
        t4.ensureResolved$1(t2.compiler);
        t2.registerInstantiatedType$3$mirrorUsage(t4.get$rawType(), t1, false);
        stackTraceElement.get$variables().type = t3.stackTraceClass.get$rawType();
      }
    },
    visitTypedef$1: function(node) {
      this.compiler.internalError$2(node, "typedef");
    },
    $asMappingVisitor: function() {
      return [A.ResolutionResult];
    },
    $asCommonResolverVisitor: function() {
      return [A.ResolutionResult];
    },
    $asVisitor: function() {
      return [A.ResolutionResult];
    },
    static: {"^": "ResolverVisitor_symbolValidationPattern", ResolverVisitor$: function(compiler, element, registry, useEnclosingScope) {
        var t1, t2, t3, t4, t5;
        t1 = element.get$isInstanceMember() && !element.get$isField() || element.get$isGenerativeConstructor();
        t2 = element.get$isClassMember() ? element.get$enclosingClass() : null;
        t3 = A.StatementScope$();
        t4 = useEnclosingScope ? A.Scope_buildEnclosingScope(element) : element.buildScope$0();
        if (compiler.enableTypeAssertions) {
          t5 = element.kind;
          if (t5 !== C.ElementKind_library_0)
            if (t5 !== C.ElementKind_typedef_32) {
              t5 = element.get$enclosingElement();
              t5 = t5.get$kind(t5) !== C.ElementKind_typedef_32;
            } else
              t5 = false;
          else
            t5 = false;
        } else
          t5 = false;
        return new A.ResolverVisitor(element, t1, t5, false, t4, t2, null, false, t3, 167, null, false, C.C_Link3, registry, new A.TypeResolver(compiler), compiler);
      }, ResolverVisitor_computeSendSelector: function(node, library, element) {
        var isSet, t1, t2, t3, source, op, identifier, named, link, arity, namedArgument;
        isSet = node.asSendSet$0() != null;
        t1 = node.selector;
        t2 = !!J.getInterceptor(t1).$isOperator;
        if (t2) {
          t3 = t1.asOperator$0().token;
          t3 = t3.get$value(t3) === "[]";
        } else
          t3 = false;
        if (t3)
          return isSet ? Z.Selector_Selector(C.SelectorKind_index_4, O.Elements_constructOperatorName("[]=", false), null, 2, null) : Z.Selector_Selector(C.SelectorKind_index_4, O.Elements_constructOperatorName("[]", false), null, 1, null);
        if (t2) {
          t1 = t1.asOperator$0().token;
          source = t1.get$value(t1);
          if (source === "!" || source === "&&" || source === "||" || source === "is" || source === "as" || source === "?" || source === ">>>")
            return;
          op = !Y.isUserDefinableOperator(source) ? O.Elements_mapToUserOperatorOrNull(source) : source;
          if (op == null)
            return Z.Selector_Selector(C.SelectorKind_call_2, source, library, node.argumentsNode.slowLength$0(), []);
          t1 = node.argumentsNode.nodes;
          return t1.get$isEmpty(t1) ? Z.Selector_Selector(C.SelectorKind_operator_3, O.Elements_constructOperatorName(op, true), null, 0, null) : Z.Selector_Selector(C.SelectorKind_operator_3, O.Elements_constructOperatorName(op, false), null, 1, null);
        }
        identifier = t1.asIdentifier$0();
        t1 = node.argumentsNode;
        if (t1 == null) {
          t1 = identifier.token;
          return Z.Selector_Selector(C.SelectorKind_getter_0, t1.get$value(t1), library, 0, null);
        } else if (isSet) {
          t1 = identifier.token;
          return Z.Selector_Selector(C.SelectorKind_setter_1, t1.get$value(t1), library, 1, null);
        }
        named = H.setRuntimeTypeInfo([], [P.String]);
        for (link = t1.nodes, arity = 0; !link.get$isEmpty(link); link = link.get$tail()) {
          namedArgument = link.get$head(link).asNamedArgument$0();
          if (namedArgument != null) {
            t1 = namedArgument.name.token;
            named.push(t1.get$value(t1));
          }
          ++arity;
        }
        if (element != null)
          t1 = element.get$kind(element) === C.ElementKind_generative_constructor_16 || element.get$isFactoryConstructor();
        else
          t1 = false;
        if (t1)
          return Z.Selector_Selector(C.SelectorKind_call_2, element.get$name(element), library, arity, named);
        if (identifier == null)
          t1 = Z.Selector_Selector(C.SelectorKind_call_2, "call", null, arity, named);
        else {
          t1 = identifier.token;
          t1 = Z.Selector_Selector(C.SelectorKind_call_2, t1.get$value(t1), library, arity, named);
        }
        return t1;
      }}
  },
  ResolverVisitor_visitInStaticContext_closure: {
    "^": "Closure:23;this_0,node_1",
    call$0: function() {
      var t1 = this.node_1;
      return t1 == null ? null : t1.accept$1(0, this.this_0);
    },
    $isFunction: true
  },
  ResolverVisitor_setupFunction_closure: {
    "^": "Closure:50;box_0,this_1,functionParameters_2",
    call$1: function(element) {
      var t1, t2, t3, t4, parameterNode;
      t1 = this.functionParameters_2.get$optionalParameters();
      t2 = J.getInterceptor(element);
      if (t2.$eq(element, t1.get$head(t1))) {
        t1 = this.box_0;
        t3 = t1.parameterNodes_0;
        t1.parameterNodes_0 = J.get$nodes$x(t3.get$head(t3));
      }
      t1 = this.this_1;
      t3 = element.get$initializer();
      if (t3 == null)
        ;
      else
        t3.accept$1(0, t1);
      t3 = this.box_0;
      t4 = t3.parameterNodes_0;
      t4 = t4.get$head(t4).get$definitions().nodes;
      parameterNode = t4.get$head(t4);
      t4 = t1.registry;
      if (t2.get$kind(element) === C.ElementKind_initializing_formal_1)
        t4.useElement$2(parameterNode, element);
      else {
        K.invariant(parameterNode, true, null);
        t4.mapping.$indexSet(0, parameterNode, element);
        t1.addToScope$1(element);
      }
      t3.parameterNodes_0 = t3.parameterNodes_0.get$tail();
    },
    $isFunction: true
  },
  ResolverVisitor_setupFunction_closure0: {
    "^": "Closure:23;this_3,functionParameters_4",
    call$0: function() {
      this.functionParameters_4.forEachOptionalParameter$1(new A.ResolverVisitor_setupFunction__closure(this.this_3));
    },
    $isFunction: true
  },
  ResolverVisitor_setupFunction__closure: {
    "^": "Closure:77;this_5",
    call$1: function(parameter) {
      this.this_5.compiler.resolver.constantCompiler.compileConstant$1(parameter);
    },
    $isFunction: true
  },
  ResolverVisitor_setupFunction_closure1: {
    "^": "Closure:50;this_6",
    call$1: function(element) {
      var t1, t2, t3;
      t1 = this.this_6.registry;
      t2 = J.get$type$x(element);
      t3 = t1.compiler;
      t3.enqueuer.resolution.registerIsCheck$2(t2, t1);
      t3.backend.get$resolutionCallbacks().onIsCheck$2(t2, t1);
    },
    $isFunction: true
  },
  ResolverVisitor_visitIf_closure: {
    "^": "Closure:23;this_0,node_1",
    call$0: function() {
      var t1 = this.node_1.condition;
      return t1 == null ? null : t1.accept$1(0, this.this_0);
    },
    $isFunction: true
  },
  ResolverVisitor_visitIf_closure0: {
    "^": "Closure:23;this_2,node_3",
    call$0: function() {
      var t1, t2, t3;
      t1 = this.this_2;
      t2 = t1.scope;
      t3 = new A.BlockScope(P.LinkedHashMap_LinkedHashMap(null, null, null, P.String, O.Element), t2);
      t3.MutableScope$1(t2);
      return t1.visitIn$2(this.node_3.thenPart, t3);
    },
    $isFunction: true
  },
  ResolverVisitor_visitSend_closure: {
    "^": "Closure:23;this_0,node_1",
    call$0: function() {
      return this.this_0.resolveSend$1(this.node_1);
    },
    $isFunction: true
  },
  ResolverVisitor_visitSend_closure0: {
    "^": "Closure:23;this_2,node_3",
    call$0: function() {
      return this.this_2.resolveArguments$1(this.node_3.argumentsNode);
    },
    $isFunction: true
  },
  ResolverVisitor_visitSendSet_registerBinaryOperator: {
    "^": "Closure:66;this_0,node_1",
    call$1: function($name) {
      var binop, t1;
      binop = Z.Selector_Selector(C.SelectorKind_operator_3, O.Elements_constructOperatorName($name, false), null, 1, null);
      t1 = this.this_0.registry;
      t1.compiler.enqueuer.resolution.registerInvocation$1(binop);
      t1.mapping._setSelector$2(this.node_1.assignmentOperator, binop);
    },
    $isFunction: true
  },
  ResolverVisitor_visitRedirectingFactoryBody_closure: {
    "^": "Closure:23;this_0,node_1,constructor_2",
    call$0: function() {
      this.this_0.compiler.resolver.resolveRedirectionChain$2(this.constructor_2, this.node_1);
    },
    $isFunction: true
  },
  ResolverVisitor_visitVariableDefinitions_reportExtraModifier: {
    "^": "Closure:66;this_0,modifiers_1",
    call$1: function(modifier) {
      var modifierNode, nodes, t1;
      nodes = this.modifiers_1.nodes.nodes;
      while (true) {
        if (!!nodes.get$isEmpty(nodes)) {
          modifierNode = null;
          break;
        }
        t1 = nodes.get$head(nodes).asIdentifier$0().token;
        if (modifier === t1.get$value(t1)) {
          modifierNode = nodes.get$head(nodes);
          break;
        }
        nodes = nodes.get$tail();
      }
      this.this_0.compiler.reportDiagnosticInternal$4(modifierNode, C.MessageKind_KQp, P.LinkedHashMap_LinkedHashMap$_literal(["modifier", modifier], null, null), C.Diagnostic_1_error);
    },
    $isFunction: true
  },
  ResolverVisitor_analyzeConstant_closure: {
    "^": "Closure:23;this_0,node_1",
    call$0: function() {
      var t1, t2, t3, t4, constant;
      t1 = this.this_0;
      t2 = t1.compiler;
      t3 = this.node_1;
      t4 = t1.registry;
      constant = t2.resolver.constantCompiler.compileNode$2(t3, t4.mapping);
      if (constant.get$isMap(constant))
        t1.checkConstMapKeysDontOverrideEquals$2(t3, constant);
      t1 = t1.argumentsToJsInterceptorConstant;
      if (t1 != null && t1.contains$1(0, t3))
        if (constant.get$isType())
          if (!!J.getInterceptor(constant.get$representedType()).$isInterfaceType) {
            t1 = constant.representedType;
            t4.compiler.enqueuer.resolution.registerInstantiatedType$2(t1, t4);
          } else
            t2.reportDiagnosticInternal$4(t3, C.MessageKind_wU7, C.Map_empty, C.Diagnostic_1_error);
        else
          t2.reportDiagnosticInternal$4(t3, C.MessageKind_wU7, C.Map_empty, C.Diagnostic_1_error);
    },
    $isFunction: true
  },
  ResolverVisitor_visitConditional_closure: {
    "^": "Closure:23;this_0,node_1",
    call$0: function() {
      var t1 = this.node_1.condition;
      return t1 == null ? null : t1.accept$1(0, this.this_0);
    },
    $isFunction: true
  },
  ResolverVisitor_visitConditional_closure0: {
    "^": "Closure:23;this_2,node_3",
    call$0: function() {
      var t1 = this.node_3.thenExpression;
      return t1 == null ? null : t1.accept$1(0, this.this_2);
    },
    $isFunction: true
  },
  ResolverVisitor_visitLabeledStatement_closure: {
    "^": "Closure:231;this_0",
    call$2: function(labelName, element) {
      var t1 = this.this_0;
      if (element.get$isTarget())
        t1.registry.mapping.defineLabel$2(element.get$label(element), element);
      else
        t1.compiler.reportDiagnosticInternal$4(element.get$label(element), C.MessageKind_oEw, P.LinkedHashMap_LinkedHashMap$_literal(["labelName", labelName], null, null), C.Diagnostic_2_warning);
    },
    $isFunction: true
  },
  ResolverVisitor_visitSwitchStatement_closure: {
    "^": "Closure:23;this_0,node_1",
    call$0: function() {
      this.this_0.checkCaseExpressions$1(this.node_1);
    },
    $isFunction: true
  },
  ResolverVisitor_visitSwitchStatement_closure0: {
    "^": "Closure:231;this_2",
    call$2: function(key, label) {
      var t1, t2, t3;
      if (!label.get$isContinueTarget()) {
        t1 = this.this_2.registry;
        t1.undefineTarget$1(label.get$target(label).statement);
        t2 = label.label;
        t1 = t1.mapping;
        t3 = t1._definedLabels;
        if (t3 != null) {
          t3.remove$1(0, t2);
          t2 = t1._definedLabels;
          if (t2.get$isEmpty(t2))
            t1._definedLabels = null;
        }
      }
    },
    $isFunction: true
  },
  ResolverVisitor_visitCatchBlock_closure: {
    "^": "Closure:23;this_0,node_1,blockScope_2",
    call$0: function() {
      return this.this_0.visitIn$2(this.node_1.type, this.blockScope_2);
    },
    $isFunction: true
  },
  TypeDefinitionVisitor: {
    "^": "MappingVisitor;scope<,enclosingElement<",
    get$element: function() {
      return this.enclosingElement;
    },
    resolveTypeVariableBounds$1: function(node) {
      var nameSet, t1, types, nodeLink, t2, t3, typeVariable, typeName, typeNode, t4, variableElement, boundType, t5;
      if (node == null)
        return;
      nameSet = H.setRuntimeTypeInfo(new N.Setlet(C.C__SetletMarker, null), [P.String]);
      t1 = this.get$element().get$typeVariables();
      types = H.setRuntimeTypeInfo(new H.ListIterator(t1, t1.length, 0, null), [H.getTypeArgumentByIndex(t1, 0)]);
      nodeLink = node.nodes;
      for (t1 = this.compiler, t2 = this.registry.mapping, t3 = this.typeResolver; !nodeLink.get$isEmpty(nodeLink);) {
        types.moveNext$0();
        typeVariable = types.__internal$_current;
        typeName = typeVariable.get$element().name;
        typeNode = nodeLink.get$head(nodeLink);
        t4 = t2._types;
        if (t4 == null) {
          t4 = new M.Maplet(C.C__MapletMarker, null, null);
          t4.$builtinTypeInfo = [Y.Node, V.DartType];
          t2._types = t4;
        }
        t4.$indexSet(0, typeNode, typeVariable);
        if (nameSet.contains$1(0, typeName) === true)
          t1.reportFatalError$3(typeNode, C.MessageKind_OPN, P.LinkedHashMap_LinkedHashMap$_literal(["typeVariableName", typeName], null, null));
        nameSet.add$1(0, typeName);
        variableElement = typeVariable.get$element();
        if (typeNode.get$bound() != null) {
          boundType = t3.resolveTypeAnnotation$2(this, typeNode.get$bound());
          variableElement.boundCache = boundType;
          t4 = this.get$element();
          t5 = t1.enqueuer.resolution;
          if (t5.queueIsClosed)
            H.throwExpression(O.SpannableAssertionFailure$(t4, "Resolution work list is closed. Trying to add deferred action for " + t4.toString$0(0)));
          t5.deferredTaskQueue._add$1(new K.DeferredTask(t4, new A.TypeDefinitionVisitor_resolveTypeVariableBounds_checkTypeVariableBound(this, typeNode, variableElement, boundType)));
        } else
          variableElement.boundCache = t1.objectClass.get$rawType();
        nodeLink = nodeLink.get$tail();
      }
    },
    $asMappingVisitor: function() {
      return [V.DartType];
    },
    $asCommonResolverVisitor: function() {
      return [V.DartType];
    },
    $asVisitor: function() {
      return [V.DartType];
    }
  },
  TypeDefinitionVisitor_resolveTypeVariableBounds_checkTypeVariableBound: {
    "^": "Closure:7;this_0,typeNode_1,variableElement_2,boundType_3",
    call$0: function() {
      var t1, seenTypeVariables, bound, element, seenTypeVariables0;
      t1 = this.variableElement_2;
      seenTypeVariables = E.LinkEntry$(t1, C.C_Link8, H.getTypeArgumentByIndex(C.C_Link8, 0));
      bound = this.boundType_3;
      for (; bound.get$kind(bound) === C.TypeKind_kuk; seenTypeVariables = seenTypeVariables0) {
        element = bound.get$element();
        if (seenTypeVariables.contains$1(0, element)) {
          if (element === t1)
            this.this_0.compiler.reportDiagnosticInternal$4(this.typeNode_1.name, C.MessageKind_WR81, P.LinkedHashMap_LinkedHashMap$_literal(["typeVariableName", t1.name], null, null), C.Diagnostic_2_warning);
          break;
        }
        seenTypeVariables0 = new E.LinkEntry(element, seenTypeVariables);
        seenTypeVariables0.$builtinTypeInfo = [H.getTypeArgumentByIndex(seenTypeVariables, 0)];
        bound = element.get$boundCache();
      }
    },
    $isFunction: true
  },
  TypedefResolverVisitor: {
    "^": "TypeDefinitionVisitor;scope,enclosingElement,registry,typeResolver,compiler",
    get$element: function() {
      return this.enclosingElement;
    },
    visitTypedef$1: function(node) {
      var t1, t2, signature, t3, t4;
      t1 = this.enclosingElement;
      t2 = this.compiler;
      t1.computeType$1(t2);
      this.scope = new A.TypeDeclarationScope(t1, this.scope);
      this.resolveTypeVariableBounds$1(node.typeParameters);
      signature = A.SignatureResolver_analyze(t2, node.formals, node.returnType, t1, this.registry, false, C.MessageKind_4u1);
      t1.set$functionSignature(signature);
      t3 = this.scope;
      t4 = new A.MethodScope(t1, P.LinkedHashMap_LinkedHashMap(null, null, null, P.String, O.Element), t3);
      t4.MutableScope$1(t3);
      this.scope = t4;
      t4 = this.get$addToScope();
      signature.forEachRequiredParameter$1(t4);
      signature.forEachOptionalParameter$1(t4);
      t1.alias = signature.type;
      t2 = t2.enqueuer.resolution;
      if (t2.queueIsClosed)
        H.throwExpression(O.SpannableAssertionFailure$(t1, "Resolution work list is closed. Trying to add deferred action for " + t1.toString$0(0)));
      t2.deferredTaskQueue._add$1(new K.DeferredTask(t1, new A.TypedefResolverVisitor_visitTypedef_checkCyclicReference(this)));
    }
  },
  TypedefResolverVisitor_visitTypedef_checkCyclicReference: {
    "^": "Closure:7;this_0",
    call$0: function() {
      var t1 = this.this_0;
      t1.enclosingElement.checkCyclicReference$1(t1.compiler);
    },
    $isFunction: true
  },
  TypedefCyclicVisitor: {
    "^": "DartTypeVisitor;compiler<,element<,hasCyclicReference,seenTypedefs,seenTypedefsCount,seenTypeVariables",
    visitType$2: function(type, _) {
    },
    visitTypedefType$2: function(type, _) {
      var typedefElement, t1, t2, t3, t4, cycle, t5, t6;
      typedefElement = type.element;
      if (this.seenTypedefs.contains$1(0, typedefElement)) {
        if (!this.hasCyclicReference && this.element === typedefElement) {
          this.hasCyclicReference = true;
          t1 = this.seenTypedefsCount;
          if (t1 === 1) {
            t1 = this.element;
            this.compiler.reportDiagnosticInternal$4(t1, C.MessageKind_Olq, P.LinkedHashMap_LinkedHashMap$_literal(["typedefName", t1.name], null, null), C.Diagnostic_1_error);
          } else if (t1 === 2) {
            t1 = this.element;
            t2 = this.seenTypedefs;
            this.compiler.reportDiagnosticInternal$4(t1, C.MessageKind_xw80, P.LinkedHashMap_LinkedHashMap$_literal(["typedefName", t1.name, "otherTypedefName", J.get$name$x(t2.get$head(t2))], null, null), C.Diagnostic_1_error);
          } else
            for (t1 = this.seenTypedefs, t1.toString, t1 = H.setRuntimeTypeInfo(new E.LinkIterator(null, t1), [H.getTypeArgumentByIndex(t1, 0)]), t2 = this.compiler, t3 = this.element, t4 = t3.name; t1.moveNext$0();) {
              cycle = t1._util_implementation$_current;
              if (typedefElement == null ? cycle != null : typedefElement !== cycle)
                t2.reportDiagnosticInternal$4(t3, C.MessageKind_xw80, P.LinkedHashMap_LinkedHashMap$_literal(["typedefName", t4, "otherTypedefName", J.get$name$x(cycle)], null, null), C.Diagnostic_1_error);
            }
          t1 = this.element;
          t2 = t1.name;
          t3 = P.LinkedHashMap_LinkedHashMap$_literal(["typedefName", t2], null, null);
          t4 = $.ElementX_elementHashCode + 1;
          $.ElementX_elementHashCode = t4;
          t5 = typedefElement.get$alias();
          t6 = $.MalformedType_nextHash;
          $.MalformedType_nextHash = t6 + 1;
          t1.alias = new V.MalformedType(new U.ErroneousElementX(C.MessageKind_Olq, t3, null, t2, C.ElementKind_error_0, t1, t4, C.C_Link2, null, false), t5, null, t6 & 1073741823);
          t1.hasBeenCheckedForCycles = true;
        }
      } else {
        this.seenTypedefs = this.seenTypedefs.prepend$1(typedefElement);
        ++this.seenTypedefsCount;
        V.DartType_visitList(type.typeArguments, this, null);
        typedefElement.get$alias().accept$2(0, this, null);
        this.seenTypedefs = this.seenTypedefs.get$tail();
        --this.seenTypedefsCount;
      }
    },
    visitFunctionType$2: function(type, _) {
      type.visitChildren$2(this, null);
    },
    visitInterfaceType$2: function(type, _) {
      V.DartType_visitList(type.typeArguments, this, null);
    },
    visitTypeVariableType$2: function(type, _) {
      var typeVariableElement = type.element;
      if (this.seenTypeVariables.contains$1(0, typeVariableElement))
        return;
      this.seenTypeVariables = this.seenTypeVariables.prepend$1(typeVariableElement);
      typeVariableElement.get$bound().accept$2(0, this, null);
      this.seenTypeVariables = this.seenTypeVariables.get$tail();
    },
    $asDartTypeVisitor: function() {
      return [null, null];
    }
  },
  ClassResolverVisitor: {
    "^": "TypeDefinitionVisitor;scope,enclosingElement,registry,typeResolver,compiler",
    get$element: function() {
      return this.enclosingElement;
    },
    visitClassNode$1: function(node) {
      var t1, t2, t3, superMixin, supertype, link, superElement, superMember, $arguments, t4, t5;
      K.invariant(node, true, null);
      t1 = this.enclosingElement;
      K.invariant(t1, t1.get$resolutionState() === 1, new A.ClassResolverVisitor_visitClassNode_closure(this));
      t2 = this.compiler;
      t1.computeType$1(t2);
      this.scope = new A.TypeDeclarationScope(t1, this.scope);
      this.resolveTypeVariableBounds$1(node.typeParameters);
      if (t1.get$supertype() == null && node.superclass != null) {
        t3 = node.superclass;
        superMixin = t3.asMixinApplication$0();
        if (superMixin != null) {
          supertype = this.resolveSupertype$2(t1, superMixin.get$superclass());
          link = superMixin.get$mixins().nodes;
          for (; !link.get$isEmpty(link);) {
            supertype = this.applyMixin$3(supertype, this.checkMixinType$1(link.get$head(link)), link.get$head(link));
            link = link.get$tail();
          }
          t1.supertype = supertype;
        } else
          t1.supertype = this.resolveSupertype$2(t1, t3);
      }
      if (t1.supertype == null) {
        superElement = this.registry.compiler.backend.defaultSuperclass$1(t1);
        if (t1 !== superElement) {
          if (superElement == null)
            t2.internalError$2(node, "Cannot resolve default superclass for " + t1.toString$0(0) + ".");
          else
            superElement.ensureResolved$1(t2);
          t1.supertype = superElement.computeType$1(t2);
        }
      }
      if (t1.interfaces == null)
        t1.interfaces = this.resolveInterfaces$2(node.interfaces, node.superclass);
      this.calculateAllSupertypes$1(t1);
      if (!t1.get$hasConstructor()) {
        superMember = t1.get$superclass().localLookup$1("");
        if (superMember == null || superMember.get$kind(superMember) !== C.ElementKind_generative_constructor_16) {
          $arguments = P.LinkedHashMap_LinkedHashMap$_literal(["constructorName", ""], null, null);
          t2.reportDiagnosticInternal$4(node, C.MessageKind_ku2, $arguments, C.Diagnostic_1_error);
          t3 = $.ElementX_elementHashCode + 1;
          $.ElementX_elementHashCode = t3;
          superMember = new U.ErroneousElementX(C.MessageKind_ku2, $arguments, null, "", C.ElementKind_error_0, t1, t3, C.C_Link2, null, false);
          t3 = this.registry;
          t3.compiler.backend.get$resolutionCallbacks().onThrowNoSuchMethod$1(t3);
        } else if (!Z.Selector_Selector(C.SelectorKind_call_2, "", t1.get$enclosingElement().get$library(), 0, null).applies$2(superMember, t2)) {
          t2.reportDiagnosticInternal$4(node, C.MessageKind_8xB, C.Map_empty, C.Diagnostic_1_error);
          t3 = P.LinkedHashMap_LinkedHashMap$_empty(null, null);
          t4 = $.ElementX_elementHashCode + 1;
          $.ElementX_elementHashCode = t4;
          superMember = new U.ErroneousElementX(C.MessageKind_8xB, t3, null, "", C.ElementKind_error_0, t1, t4, C.C_Link2, null, false);
        }
        t3 = $.get$Modifiers_EMPTY();
        t4 = H.setRuntimeTypeInfo([], [O.FunctionElement]);
        t5 = $.ElementX_elementHashCode + 1;
        $.ElementX_elementHashCode = t5;
        t1.setDefaultConstructor$2(new U.SynthesizedConstructorElementX(superMember, true, null, null, null, null, null, t3, t4, null, false, null, null, null, "", C.ElementKind_generative_constructor_16, t1, t5, C.C_Link2, null, false), t2);
      }
      return t1.computeType$1(t2);
    },
    checkMixinType$1: function(mixinNode) {
      var mixinType = this.typeResolver.resolveTypeAnnotation$2(this, mixinNode);
      if (this.isBlackListed$1(mixinType))
        this.compiler.reportDiagnosticInternal$4(mixinNode, C.MessageKind_M2b, P.LinkedHashMap_LinkedHashMap$_literal(["type", mixinType], null, null), C.Diagnostic_1_error);
      else if (mixinType.get$kind(mixinType) === C.TypeKind_kuk)
        this.compiler.reportDiagnosticInternal$4(mixinNode, C.MessageKind_qxw, C.Map_empty, C.Diagnostic_1_error);
      else if (mixinType.get$kind(mixinType) === C.TypeKind_malformed)
        this.compiler.reportDiagnosticInternal$4(mixinNode, C.MessageKind_NcA, P.LinkedHashMap_LinkedHashMap$_literal(["className", this.enclosingElement.name, "malformedType", mixinType], null, null), C.Diagnostic_1_error);
      return mixinType;
    },
    visitNamedMixinApplication$1: function(node) {
      var t1, t2, t3, supertype, link;
      K.invariant(node, true, null);
      t1 = this.enclosingElement;
      K.invariant(t1, t1.get$resolutionState() === 1, new A.ClassResolverVisitor_visitNamedMixinApplication_closure(this));
      t2 = node.classKeyword;
      if (t2.get$stringValue() === "typedef")
        this.compiler.reportDiagnosticInternal$4(t2, C.MessageKind_4AN0, C.Map_empty, C.Diagnostic_2_warning);
      t2 = this.compiler;
      t1.computeType$1(t2);
      this.scope = new A.TypeDeclarationScope(t1, this.scope);
      this.resolveTypeVariableBounds$1(node.typeParameters);
      t3 = node.mixinApplication;
      supertype = this.resolveSupertype$2(t1, t3.get$superclass());
      link = t3.get$mixins().nodes;
      for (; t3 = link.get$tail(), !t3.get$isEmpty(t3);) {
        supertype = this.applyMixin$3(supertype, this.checkMixinType$1(link.get$head(link)), link.get$head(link));
        link = link.get$tail();
      }
      this.doApplyMixinTo$3(t1, supertype, this.checkMixinType$1(link.get$head(link)));
      return t1.computeType$1(t2);
    },
    applyMixin$3: function(supertype, mixinType, node) {
      var t1, superName, mixinName, t2, t3, t4, t5, t6, t7, t8, t9, t10, mixinApplication, typeVariables, mixinThisType;
      t1 = {};
      superName = supertype.get$name(supertype);
      mixinName = mixinType.get$name(mixinType);
      t2 = H.S(superName) + "+" + H.S(mixinName);
      t3 = this.enclosingElement;
      t4 = t3.get$compilationUnit();
      t5 = this.compiler;
      t6 = t5.nextFreeClassId++;
      t7 = $.Node__HASH_COUNTER + 1;
      $.Node__HASH_COUNTER = t7;
      t8 = t7 + 1;
      $.Node__HASH_COUNTER = t8;
      t9 = new O.Link();
      t9.$builtinTypeInfo = [O.FunctionElement];
      t10 = $.ElementX_elementHashCode + 1;
      $.ElementX_elementHashCode = t10;
      mixinApplication = new U.MixinApplicationElementX(node, new Y.Modifiers(new Y.NodeList(C.C_Link3, null, null, null, t7), 2, t8), t9, null, t6, null, null, null, 0, 0, false, false, C.C_Link, null, null, true, null, null, null, null, null, null, null, t2, C.ElementKind_class_4, t4, t10, C.C_Link2, null, false);
      typeVariables = [];
      typeVariables.$builtinTypeInfo = [V.DartType];
      H.IterableMixinWorkaround_forEach(t3.get$typeVariables(), new A.ClassResolverVisitor_applyMixin_closure(mixinApplication, typeVariables));
      t1.index_0 = 0;
      H.IterableMixinWorkaround_forEach(t3.get$typeVariables(), new A.ClassResolverVisitor_applyMixin_closure0(t1, this, typeVariables));
      mixinApplication.computeThisAndRawType$2(t5, typeVariables);
      this.doApplyMixinTo$3(mixinApplication, supertype.subst$2(typeVariables, t3.get$typeVariables()), mixinType.subst$2(typeVariables, t3.get$typeVariables()));
      mixinApplication.resolutionState = 2;
      mixinApplication.supertypeLoadState = 2;
      if (mixinApplication.get$thisTypeCache() == null)
        mixinApplication.computeThisAndRawType$2(t5, mixinApplication.computeTypeParameters$1(t5));
      mixinThisType = mixinApplication.get$thisTypeCache();
      return mixinThisType.subst$2(t3.get$typeVariables(), mixinThisType.typeArguments);
    },
    doApplyMixinTo$3: function(mixinApplication, supertype, mixinType) {
      var node, supertype0, namedMixinApplication, interfaces, superclass;
      node = mixinApplication.get$node();
      supertype0 = mixinApplication.supertype;
      if (supertype0 != null)
        supertype = supertype0;
      else
        mixinApplication.supertype = supertype;
      namedMixinApplication = node.asNamedMixinApplication$0();
      interfaces = namedMixinApplication != null ? this.resolveInterfaces$2(namedMixinApplication.interfaces, namedMixinApplication.mixinApplication.get$superclass()) : C.C_Link0;
      if (mixinApplication.interfaces == null)
        mixinApplication.interfaces = mixinType.get$kind(mixinType) === C.TypeKind_interface ? interfaces.prepend$1(mixinType) : interfaces;
      superclass = supertype.get$element();
      if (mixinType.get$kind(mixinType) !== C.TypeKind_interface) {
        mixinApplication.hasIncompleteHierarchy = true;
        mixinApplication.allSupertypesAndSelf = superclass.get$allSupertypesAndSelf();
        return;
      }
      mixinApplication.set$mixinType(this.resolveMixinFor$2(mixinApplication, mixinType));
      superclass.forEachLocalMember$1(new A.ClassResolverVisitor_doApplyMixinTo_closure(this, mixinApplication, superclass));
      this.calculateAllSupertypes$1(mixinApplication);
    },
    resolveMixinFor$2: function(mixinApplication, mixinType) {
      var mixin, t1, current, previous, current0;
      mixin = mixinType.get$element();
      t1 = this.compiler;
      mixin.ensureResolved$1(t1);
      current = mixin;
      previous = mixinApplication;
      while (true) {
        if (!(current != null && current.get$isMixinApplication()))
          break;
        if (current === mixinApplication) {
          t1.reportDiagnosticInternal$4(mixinApplication, C.MessageKind_43h0, P.LinkedHashMap_LinkedHashMap$_literal(["mixinName1", current.name, "mixinName2", previous.name], null, null), C.Diagnostic_1_error);
          return;
        }
        current0 = current.get$mixinType() != null ? current.mixinType.get$element() : null;
        previous = current;
        current = current0;
      }
      this.registry.compiler.world.registerMixinUse$2(mixinApplication, mixin);
      return mixinType;
    },
    resolveSupertype$2: function(cls, superclass) {
      var supertype, t1;
      supertype = this.typeResolver.resolveTypeAnnotation$2(this, superclass);
      if (supertype != null)
        if (supertype.get$kind(supertype) === C.TypeKind_malformed) {
          t1 = this.compiler;
          t1.reportDiagnosticInternal$4(superclass, C.MessageKind_EqP, P.LinkedHashMap_LinkedHashMap$_literal(["className", this.enclosingElement.name, "malformedType", supertype], null, null), C.Diagnostic_1_error);
          return t1.objectClass.get$rawType();
        } else if (supertype.get$kind(supertype) !== C.TypeKind_interface) {
          t1 = this.compiler;
          t1.reportDiagnosticInternal$4(superclass.get$typeName(), C.MessageKind_qxw, C.Map_empty, C.Diagnostic_1_error);
          return t1.objectClass.get$rawType();
        } else if (this.isBlackListed$1(supertype)) {
          t1 = this.compiler;
          t1.reportDiagnosticInternal$4(superclass, C.MessageKind_R1M, P.LinkedHashMap_LinkedHashMap$_literal(["type", supertype], null, null), C.Diagnostic_1_error);
          return t1.objectClass.get$rawType();
        }
      return supertype;
    },
    resolveInterfaces$2: function(interfaces, superclass) {
      var link, t1, t2, t3, t4, result, interfaceType;
      if (interfaces == null)
        return C.C_Link0;
      for (link = interfaces.nodes, t1 = this.typeResolver, t2 = this.enclosingElement, t3 = this.compiler, t4 = t2.name, result = C.C_Link0; !link.get$isEmpty(link); link = link.get$tail()) {
        interfaceType = t1.resolveTypeAnnotation$2(this, link.get$head(link));
        if (interfaceType != null)
          if (interfaceType.get$kind(interfaceType) === C.TypeKind_malformed)
            t3.reportDiagnosticInternal$4(superclass, C.MessageKind_Eba, P.LinkedHashMap_LinkedHashMap$_literal(["className", t4, "malformedType", interfaceType], null, null), C.Diagnostic_1_error);
          else if (interfaceType.get$kind(interfaceType) !== C.TypeKind_interface)
            t3.reportFatalError$3(link.get$head(link).get$typeName(), C.MessageKind_qxw, C.Map_empty);
          else {
            if (interfaceType.$eq(0, t2.get$supertype())) {
              t3.reportDiagnosticInternal$4(superclass, C.MessageKind_4YV, P.LinkedHashMap_LinkedHashMap$_literal(["type", interfaceType], null, null), C.Diagnostic_1_error);
              t3.reportDiagnosticInternal$4(link.get$head(link), C.MessageKind_4YV, P.LinkedHashMap_LinkedHashMap$_literal(["type", interfaceType], null, null), C.Diagnostic_1_error);
            }
            if (result.contains$1(0, interfaceType))
              t3.reportDiagnosticInternal$4(link.get$head(link), C.MessageKind_iZu, P.LinkedHashMap_LinkedHashMap$_literal(["type", interfaceType], null, null), C.Diagnostic_1_error);
            result = result.prepend$1(interfaceType);
            if (this.isBlackListed$1(interfaceType))
              t3.reportFatalError$3(link.get$head(link), C.MessageKind_o2c, P.LinkedHashMap_LinkedHashMap$_literal(["type", interfaceType], null, null));
          }
      }
      return result;
    },
    calculateAllSupertypes$1: function(cls) {
      var supertype, t1, allSupertypes, interfaces, types, list;
      if (cls.allSupertypesAndSelf != null)
        return;
      supertype = cls.supertype;
      t1 = this.compiler;
      if (supertype != null) {
        allSupertypes = new Y.OrderedTypeSetBuilder(P.LinkedHashMap_LinkedHashMap(null, null, null, P.$int, [E.LinkEntry, V.DartType]), H.setRuntimeTypeInfo(new E.LinkBuilderImplementation(null, null, 0), [null]), -1, cls);
        allSupertypes.add$2(0, t1, supertype);
        for (interfaces = cls.interfaces; !interfaces.get$isEmpty(interfaces); interfaces = interfaces.get$tail())
          allSupertypes.add$2(0, t1, interfaces.get$head(interfaces));
        this.addAllSupertypes$2(allSupertypes, supertype);
        for (interfaces = cls.interfaces; !interfaces.get$isEmpty(interfaces); interfaces = interfaces.get$tail())
          this.addAllSupertypes$2(allSupertypes, interfaces.get$head(interfaces));
        allSupertypes.add$2(0, t1, cls.computeType$1(t1));
        cls.allSupertypesAndSelf = allSupertypes.toTypeSet$0();
      } else {
        types = E.LinkEntry$(cls.computeType$1(t1), C.C_Link0, V.DartType);
        list = H.setRuntimeTypeInfo(Array(1), [[O.Link, V.DartType]]);
        list[0] = types;
        cls.allSupertypesAndSelf = new Y.OrderedTypeSet(list, types, C.C_Link0);
      }
    },
    addAllSupertypes$2: function(allSupertypes, type) {
      var supertypes, t1, supertype;
      supertypes = type.get$element().get$allSupertypesAndSelf()._supertypes;
      for (t1 = this.compiler; !supertypes.get$isEmpty(supertypes);) {
        supertype = supertypes.get$head(supertypes);
        supertype.toString;
        allSupertypes.add$2(0, t1, supertype.subst$2(type.get$typeArguments(), type.get$element().get$typeVariables()));
        supertypes = supertypes.get$tail();
      }
    },
    isBlackListed$1: function(type) {
      var lib, t1, t2, t3;
      lib = this.enclosingElement.get$enclosingElement().get$library();
      t1 = this.compiler;
      t2 = t1.coreLibrary;
      if (lib == null ? t2 != null : lib !== t2)
        if (!t1.backend.isBackendLibrary$1(lib))
          if (type.get$kind(type) !== C.TypeKind_dynamic) {
            t2 = type.get$element();
            t3 = t1.boolClass;
            if (t2 == null ? t3 != null : t2 !== t3) {
              t2 = type.get$element();
              t3 = t1.numClass;
              if (t2 == null ? t3 != null : t2 !== t3) {
                t2 = type.get$element();
                t3 = t1.intClass;
                if (t2 == null ? t3 != null : t2 !== t3) {
                  t2 = type.get$element();
                  t3 = t1.doubleClass;
                  if (t2 == null ? t3 != null : t2 !== t3) {
                    t2 = type.get$element();
                    t3 = t1.stringClass;
                    if (t2 == null ? t3 != null : t2 !== t3) {
                      t2 = type.get$element();
                      t1 = t1.nullClass;
                      t1 = t2 == null ? t1 == null : t2 === t1;
                    } else
                      t1 = true;
                  } else
                    t1 = true;
                } else
                  t1 = true;
              } else
                t1 = true;
            } else
              t1 = true;
          } else
            t1 = true;
        else
          t1 = false;
      else
        t1 = false;
      return t1;
    }
  },
  ClassResolverVisitor_visitClassNode_closure: {
    "^": "Closure:23;this_0",
    call$0: function() {
      return "cyclic resolution of class " + this.this_0.enclosingElement.toString$0(0);
    },
    $isFunction: true
  },
  ClassResolverVisitor_visitNamedMixinApplication_closure: {
    "^": "Closure:23;this_0",
    call$0: function() {
      return "cyclic resolution of class " + this.this_0.enclosingElement.toString$0(0);
    },
    $isFunction: true
  },
  ClassResolverVisitor_applyMixin_closure: {
    "^": "Closure:37;mixinApplication_1,typeVariables_2",
    call$1: function(type) {
      var t1, t2, t3;
      t1 = type.get$element().name;
      t2 = type.get$element().node;
      t3 = $.ElementX_elementHashCode + 1;
      $.ElementX_elementHashCode = t3;
      this.typeVariables_2.push(new V.TypeVariableType(new U.TypeVariableElementX(t2, null, null, t1, C.ElementKind_type_variable_128, this.mixinApplication_1, t3, C.C_Link2, null, false)));
    },
    $isFunction: true
  },
  ClassResolverVisitor_applyMixin_closure0: {
    "^": "Closure:37;box_0,this_3,typeVariables_4",
    call$1: function(type) {
      var t1, t2, typeVariable, typeVariableElement;
      t1 = this.typeVariables_4;
      t2 = this.box_0.index_0++;
      if (t2 >= t1.length)
        return H.ioore(t1, t2);
      typeVariable = t1[t2];
      typeVariableElement = typeVariable.get$element();
      typeVariableElement.typeCache = typeVariable;
      typeVariableElement.boundCache = type.get$element().get$bound().subst$2(t1, this.this_3.enclosingElement.get$typeVariables());
    },
    $isFunction: true
  },
  ClassResolverVisitor_doApplyMixinTo_closure: {
    "^": "Closure:77;this_0,mixinApplication_1,superclass_2",
    call$1: function(member) {
      var t1, t2, t3, t4, t5, t6, t7;
      t1 = J.getInterceptor$x(member);
      if (t1.get$kind(member) !== C.ElementKind_generative_constructor_16)
        return;
      t2 = this.mixinApplication_1;
      t3 = t1.get$name(member);
      t4 = $.get$Modifiers_EMPTY();
      t5 = H.setRuntimeTypeInfo([], [O.FunctionElement]);
      t6 = $.ElementX_elementHashCode + 1;
      $.ElementX_elementHashCode = t6;
      t1 = t1.get$name(member);
      t7 = J.getInterceptor$asx(t1);
      if (!t7.get$isEmpty(t1) && t7.codeUnitAt$1(t1, 0) === 95) {
        t1 = t2.enclosingElement.get$library();
        t7 = this.superclass_2.get$enclosingElement().get$library();
        t7 = t1 == null ? t7 != null : t1 !== t7;
        t1 = t7;
      } else
        t1 = false;
      if (t1)
        return;
      t2.constructors = t2.constructors.prepend$1(new U.SynthesizedConstructorElementX(member, false, null, null, null, null, null, t4, t5, null, false, null, null, null, t3, C.ElementKind_generative_constructor_16, t2, t6, C.C_Link2, null, false));
    },
    $isFunction: true
  },
  ClassSupertypeResolver: {
    "^": "CommonResolverVisitor;context,classElement,compiler",
    visitNodeList$1: function(node) {
      var link;
      if (node != null)
        for (link = node.nodes; !link.get$isEmpty(link); link = link.get$tail())
          J.accept$1$x(link.get$head(link), this);
    },
    visitClassNode$1: function(node) {
      var t1, t2;
      t1 = node.superclass;
      if (t1 == null) {
        t1 = this.compiler;
        t2 = t1.objectClass;
        if (this.classElement !== t2) {
          t1.resolver.loadSupertypes$2(t2, node);
          t2.ensureResolved$1(t1);
        }
      } else
        t1.accept$1(0, this);
      this.visitNodeList$1(node.interfaces);
    },
    visitMixinApplication$1: function(node) {
      var t1 = node.get$superclass();
      t1.toString;
      this.visitTypeAnnotation$1(t1);
      this.visitNodeList$1(node.get$mixins());
    },
    visitNamedMixinApplication$1: function(node) {
      var t1, t2;
      t1 = node.mixinApplication;
      t2 = t1.get$superclass();
      t2.toString;
      this.visitTypeAnnotation$1(t2);
      this.visitNodeList$1(t1.get$mixins());
      this.visitNodeList$1(node.interfaces);
    },
    visitTypeAnnotation$1: function(node) {
      node.typeName.accept$1(0, this);
    },
    visitIdentifier$1: function(node) {
      var t1, t2, element;
      t1 = this.compiler;
      t2 = node.token;
      element = O.Elements_unwrap(this.context.lookup$1(t2.get$value(t2)), t1, node);
      if (element != null && element.get$kind(element) === C.ElementKind_class_4) {
        t1.resolver.loadSupertypes$2(element, node);
        element.ensureResolved$1(t1);
      }
    },
    visitSend$1: function(node) {
      var t1, prefix, t2, t3, t4, element, e;
      t1 = node.receiver;
      prefix = t1.asIdentifier$0();
      if (prefix == null)
        this.compiler.reportFatalError$3(t1, C.MessageKind_kr3, P.LinkedHashMap_LinkedHashMap$_literal(["node", t1], null, null));
      t2 = this.compiler;
      t3 = this.context;
      t4 = prefix.token;
      element = O.Elements_unwrap(t3.lookup$1(t4.get$value(t4)), t2, prefix);
      if (element == null || element.get$kind(element) !== C.ElementKind_prefix_8)
        t2.reportFatalError$3(t1, C.MessageKind_kr3, P.LinkedHashMap_LinkedHashMap$_literal(["node", t1], null, null));
      t1 = node.selector;
      t3 = t1.asIdentifier$0().token;
      e = element.lookupLocalMember$1(t3.get$value(t3));
      if (e == null || !e.get$impliesType())
        t2.reportFatalError$3(t1, C.MessageKind_VyX, P.LinkedHashMap_LinkedHashMap$_literal(["typeName", t1], null, null));
      t2.resolver.loadSupertypes$2(e, node);
      e.ensureResolved$1(t2);
    },
    $asCommonResolverVisitor: function() {
      return [null];
    },
    $asVisitor: function() {
      return [null];
    }
  },
  VariableDefinitionsVisitor: {
    "^": "CommonResolverVisitor;definitions<,resolver,variables,compiler",
    visitSendSet$1: function(node) {
      var identifier, t1, $name, scope, t2;
      identifier = node.selector;
      t1 = identifier.get$token();
      $name = t1.get$value(t1);
      t1 = this.resolver;
      scope = new A.VariableDefinitionScope($name, false, t1.scope);
      t2 = node.argumentsNode.nodes;
      t1.visitIn$2(t2.get$head(t2), scope);
      if (scope.variableReferencedInInitializer)
        this.compiler.reportDiagnosticInternal$4(identifier, C.MessageKind_hbB, P.LinkedHashMap_LinkedHashMap$_literal(["variableName", $name], null, null), C.Diagnostic_1_error);
      return identifier;
    },
    visitIdentifier$1: function(node) {
      var t1, t2, t3, t4;
      t1 = this.resolver.registry;
      t2 = this.compiler;
      t3 = t2.nullClass;
      t4 = t1.compiler.enqueuer.resolution;
      t3.ensureResolved$1(t4.compiler);
      t4.registerInstantiatedType$3$mirrorUsage(t3.get$rawType(), t1, false);
      if ((this.definitions.modifiers.flags & 16) !== 0)
        t2.reportDiagnosticInternal$4(node, C.MessageKind_UQk, C.Map_empty, C.Diagnostic_1_error);
      if ((this.definitions.modifiers.flags & 4) !== 0 && !this.resolver.allowFinalWithoutInitializer)
        t2.reportDiagnosticInternal$4(node, C.MessageKind_ACG, C.Map_empty, C.Diagnostic_1_error);
      return node;
    },
    visitNodeList$1: function(node) {
      var link, t1, t2, $name, t3, t4, t5, t6, element, existing;
      for (link = node.nodes, t1 = this.compiler; !link.get$isEmpty(link); link = link.get$tail()) {
        t2 = link.get$head(link);
        $name = t2 == null ? null : J.accept$1$x(t2, this);
        t2 = $name.get$token();
        t2 = t2.get$value(t2);
        t3 = this.resolver.enclosingElement;
        t4 = this.variables;
        t5 = $name.get$token();
        t6 = $.ElementX_elementHashCode + 1;
        $.ElementX_elementHashCode = t6;
        element = new U.LocalVariableElementX(t5, t4, null, null, t2, C.ElementKind_variable_1, t3, t6, C.C_Link2, null, false);
        element.createDefinitions$1(t4.definitions);
        t4 = this.resolver;
        t6 = link.get$head(link);
        K.invariant(t6, true, null);
        t4.registry.mapping.$indexSet(0, t6, element);
        t6 = this.resolver;
        existing = t6.scope.add$1(0, element);
        if (existing !== element) {
          t3 = t6.compiler;
          t3.reportDiagnosticInternal$4(element, C.MessageKind_c0h, P.LinkedHashMap_LinkedHashMap$_literal(["name", t2], null, null), C.Diagnostic_1_error);
          t3.reportDiagnosticInternal$4(existing, C.MessageKind_3bx, P.LinkedHashMap_LinkedHashMap$_literal(["name", t2], null, null), C.Diagnostic_8_info);
        }
        if ((this.definitions.modifiers.flags & 16) !== 0) {
          t2 = t1.enqueuer.resolution;
          if (t2.queueIsClosed)
            H.throwExpression(O.SpannableAssertionFailure$(element, "Resolution work list is closed. Trying to add deferred action for " + element.toString$0(0)));
          t2.deferredTaskQueue._add$1(new K.DeferredTask(element, new A.VariableDefinitionsVisitor_visitNodeList_closure(this, element)));
        }
      }
    },
    $asCommonResolverVisitor: function() {
      return [Y.Identifier];
    },
    $asVisitor: function() {
      return [Y.Identifier];
    }
  },
  VariableDefinitionsVisitor_visitNodeList_closure: {
    "^": "Closure:23;this_0,element_1",
    call$0: function() {
      this.this_0.compiler.resolver.constantCompiler.compileConstant$1(this.element_1);
    },
    $isFunction: true
  },
  ConstructorResolver: {
    "^": "CommonResolverVisitor;resolver,inConstContext,type>,compiler",
    visitNode$1: function(node) {
      throw H.wrapException("not supported");
    },
    failOrReturnErroneousElement$5: function(enclosing, diagnosticNode, targetName, kind, $arguments) {
      var t1 = this.resolver;
      if (kind === C.MessageKind_ku2) {
        t1 = t1.registry;
        t1.compiler.backend.get$resolutionCallbacks().onThrowNoSuchMethod$1(t1);
      } else {
        t1 = t1.registry;
        t1.compiler.backend.get$resolutionCallbacks().onThrowRuntimeError$1(t1);
      }
      t1 = this.compiler;
      if (this.inConstContext)
        t1.reportDiagnosticInternal$4(diagnosticNode, kind, $arguments, C.Diagnostic_1_error);
      else
        t1.reportDiagnosticInternal$4(diagnosticNode, kind, $arguments, C.Diagnostic_2_warning);
      t1 = $.ElementX_elementHashCode + 1;
      $.ElementX_elementHashCode = t1;
      return new U.ErroneousElementX(kind, $arguments, null, targetName, C.ElementKind_error_0, enclosing, t1, C.C_Link2, null, false);
    },
    resolveConstructor$3: function(cls, diagnosticNode, constructorName) {
      var t1, t2, result, fullConstructorName;
      t1 = this.compiler;
      if (cls.resolutionState === 0)
        t1.resolver.resolveClass$1(cls);
      t2 = this.resolver;
      result = cls.lookupConstructor$1(constructorName === "" ? Z.Selector_Selector(C.SelectorKind_call_2, "", t2.enclosingElement.get$library(), 0, null) : Z.Selector_Selector(C.SelectorKind_call_2, constructorName, t2.enclosingElement.get$library(), 0, null));
      if (result == null) {
        fullConstructorName = O.Elements_constructorNameForDiagnostics(cls.name, constructorName);
        return this.failOrReturnErroneousElement$5(cls, diagnosticNode, fullConstructorName, C.MessageKind_ku2, P.LinkedHashMap_LinkedHashMap$_literal(["constructorName", fullConstructorName], null, null));
      } else if (this.inConstContext && !result.get$isConst())
        t1.reportFatalError$3(diagnosticNode, C.MessageKind_6QF, C.Map_empty);
      return result;
    },
    visitNewExpression$1: function(node) {
      var selector;
      this.inConstContext = node.get$isConst();
      selector = node.send.selector;
      return this.finishConstructorReference$3(selector == null ? null : selector.accept$1(0, this), selector, node);
    },
    finishConstructorReference$3: function(element, diagnosticNode, expression) {
      var t1;
      if (!(element == null || element.get$isErroneous()))
        t1 = !(J.get$kind$x(element) === C.ElementKind_generative_constructor_16 || element.get$isFactoryConstructor());
      else
        t1 = false;
      if (t1) {
        t1 = J.getInterceptor$x(element);
        if (t1.get$kind(element) === C.ElementKind_class_4) {
          element.ensureResolved$1(this.compiler);
          element = this.resolveConstructor$3(element, diagnosticNode, "");
        } else
          element = this.failOrReturnErroneousElement$5(element, diagnosticNode, t1.get$name(element), C.MessageKind_4QU, P.LinkedHashMap_LinkedHashMap$_literal(["node", diagnosticNode], null, null));
      }
      t1 = this.type;
      if (t1 == null)
        if (element == null || element.get$isErroneous()) {
          this.type = C.C_DynamicType;
          t1 = C.C_DynamicType;
        } else {
          t1 = element.get$enclosingClass().get$rawType();
          this.type = t1;
        }
      this.resolver.registry.mapping.setType$2(expression, t1);
      return element;
    },
    visitTypeAnnotation$1: function(node) {
      var t1, t2, t3;
      t1 = this.resolver;
      t2 = t1.resolveTypeAnnotation$3$deferredIsMalformed$malformedIsError(node, false, this.inConstContext);
      this.type = t2;
      t3 = t1.enclosingElement;
      t1.registry.compiler.backend.registerRequiredType$2(t2, t3);
      return this.type.get$element();
    },
    visitSend$1: function(node) {
      var t1, element, t2, $name, t3;
      t1 = node.receiver;
      element = t1 == null ? null : t1.accept$1(0, this);
      if (element == null || element.get$isErroneous())
        return element;
      t2 = node.selector;
      $name = t2.asIdentifier$0();
      if ($name == null)
        this.compiler.internalError$2(t2, "unexpected node");
      t2 = J.getInterceptor$x(element);
      if (t2.get$kind(element) === C.ElementKind_class_4) {
        element.ensureResolved$1(this.compiler);
        t1 = $name.token;
        return this.resolveConstructor$3(element, $name, t1.get$value(t1));
      } else {
        t3 = this.compiler;
        if (t2.get$kind(element) === C.ElementKind_prefix_8) {
          t1 = $name.token;
          element = O.Elements_unwrap(element.lookupLocalMember$1(t1.get$value(t1)), t3, node);
          if (element == null)
            return this.failOrReturnErroneousElement$5(this.resolver.enclosingElement, $name, t1.get$value(t1), C.MessageKind_SFN, P.LinkedHashMap_LinkedHashMap$_literal(["name", $name], null, null));
          else if (element.get$kind(element) !== C.ElementKind_class_4)
            t3.reportFatalError$3(node, C.MessageKind_4QU, P.LinkedHashMap_LinkedHashMap$_literal(["node", $name], null, null));
        } else
          t3.internalError$2(t1, "unexpected element " + H.S(element));
      }
      return element;
    },
    visitIdentifier$1: function(node) {
      var t1, $name, t2, element;
      t1 = node.token;
      $name = t1.get$value(t1);
      t1 = this.resolver;
      t2 = this.compiler;
      element = t1.reportLookupErrorIfAny$3(O.Elements_unwrap(t1.scope.lookup$1($name), t2, node), node, $name);
      t1.registry.useElement$2(node, element);
      if (element == null)
        return this.failOrReturnErroneousElement$5(t1.enclosingElement, node, $name, C.MessageKind_SFN, P.LinkedHashMap_LinkedHashMap$_literal(["name", $name], null, null));
      else if (element.get$isErroneous())
        return element;
      else if (element.get$kind(element) === C.ElementKind_typedef_32)
        t2.reportFatalError$3(node, C.MessageKind_mJ1, P.LinkedHashMap_LinkedHashMap$_literal(["typedefName", $name], null, null));
      else {
        t1 = element.kind;
        if (t1 === C.ElementKind_type_variable_128)
          t2.reportFatalError$3(node, C.MessageKind_pi1, P.LinkedHashMap_LinkedHashMap$_literal(["typeVariableName", $name], null, null));
        else if (t1 !== C.ElementKind_class_4 && t1 !== C.ElementKind_prefix_8)
          t2.reportFatalError$3(node, C.MessageKind_4QU, P.LinkedHashMap_LinkedHashMap$_literal(["node", $name], null, null));
      }
      return element;
    },
    visitRedirectingFactoryBody$1: function(node) {
      var constructorReference = node.constructorReference;
      return this.finishConstructorReference$3(constructorReference == null ? null : constructorReference.accept$1(0, this), constructorReference, node);
    },
    $asCommonResolverVisitor: function() {
      return [O.Element];
    },
    $asVisitor: function() {
      return [O.Element];
    }
  },
  AnalyzableElementX: {
    "^": "Object;_treeElements:resolution$AnalyzableElementX$_treeElements<",
    get$hasTreeElements: function() {
      return this.resolution$AnalyzableElementX$_treeElements != null;
    },
    get$treeElements: function() {
      return this.resolution$AnalyzableElementX$_treeElements;
    },
    $isAnalyzableElementX: true,
    $isElement: true
  },
  ResolutionResult: {
    "^": "Object;"
  },
  ElementResult: {
    "^": "Object;element<",
    toString$0: function(_) {
      return "ElementResult(" + this.element.toString$0(0) + ")";
    }
  },
  TypeResult: {
    "^": "Object;type>",
    get$element: function() {
      return this.type.get$element();
    },
    toString$0: function(_) {
      return "TypeResult(" + J.toString$0(this.type) + ")";
    }
  },
  AssertResult: {
    "^": "Object;",
    get$element: function() {
      return;
    },
    toString$0: function(_) {
      return "AssertResult()";
    },
    $isAssertResult: true
  },
  ResolutionRegistry: {
    "^": "Registry;compiler<,mapping",
    get$backend: function() {
      return this.compiler.backend;
    },
    defineFunction$2: function(node, element) {
      if (node.get$name(node) != null)
        this.mapping.$indexSet(0, node.get$name(node), element);
      this.mapping.$indexSet(0, node, element);
    },
    useElement$2: function(node, element) {
      if (element == null)
        return;
      this.mapping.$indexSet(0, node, element);
      return element;
    },
    undefineTarget$1: function(node) {
      var t1, t2;
      t1 = this.mapping;
      t2 = t1._definedTargets;
      if (t2 != null) {
        t2.remove$1(0, node);
        t2 = t1._definedTargets;
        if (t2.get$isEmpty(t2))
          t1._definedTargets = null;
      }
    },
    registerTypeLiteral$2: function(node, type) {
      var t1, t2;
      this.mapping.setType$2(node, type);
      t1 = this.compiler;
      t1.backend.get$resolutionCallbacks().onTypeLiteral$2(type, this);
      t2 = t1.enqueuer.resolution;
      t1 = t1.typeClass;
      t1.ensureResolved$1(t2.compiler);
      t2.registerInstantiatedType$3$mirrorUsage(t1.get$rawType(), this, false);
    },
    registerGetOfStaticFunction$1: function(element) {
      this.compiler.enqueuer.resolution.registerGetOfStaticFunction$1(element);
    },
    registerDependency$1: function(element) {
      this.mapping.registerDependency$1(element);
    },
    registerStaticInvocation$1: function(element) {
      if (element == null)
        return;
      this.compiler.enqueuer.resolution.internalAddToWorkList$1(element);
      this.mapping.registerDependency$1(element);
    },
    registerInstantiation$1: function(type) {
      this.compiler.enqueuer.resolution.registerInstantiatedType$2(type, this);
    }
  },
  Scope: {
    "^": "Object;"
  },
  NestedScope: {
    "^": "Scope;parent>",
    lookup$1: function($name) {
      var result = this.localLookup$1($name);
      if (result != null)
        return result;
      return this.parent.lookup$1($name);
    }
  },
  VariableDefinitionScope: {
    "^": "NestedScope;variableName,variableReferencedInInitializer,parent",
    localLookup$1: function($name) {
      var t1 = this.variableName;
      if ($name == null ? t1 == null : $name === t1)
        this.variableReferencedInInitializer = true;
      return;
    },
    add$1: function(_, newElement) {
      throw H.wrapException("Cannot add element to VariableDefinitionScope");
    }
  },
  TypeDeclarationScope: {
    "^": "NestedScope;element<,parent",
    add$1: function(_, newElement) {
      throw H.wrapException("Cannot add element to TypeDeclarationScope");
    },
    lookupTypeVariable$1: function($name) {
      var typeVariables, t1, type, t2;
      typeVariables = this.get$element().get$typeVariables();
      for (t1 = H.setRuntimeTypeInfo(new H.ListIterator(typeVariables, typeVariables.length, 0, null), [H.getTypeArgumentByIndex(typeVariables, 0)]); t1.moveNext$0();) {
        type = t1.__internal$_current;
        t2 = type.get$element().name;
        if (t2 == null ? $name == null : t2 === $name)
          return type.get$element();
      }
      return;
    },
    localLookup$1: function($name) {
      return this.lookupTypeVariable$1($name);
    },
    toString$0: function(_) {
      return "TypeDeclarationScope(" + this.get$element().toString$0(0) + ")";
    }
  },
  MutableScope: {
    "^": "NestedScope;elements>",
    add$1: function(_, newElement) {
      var t1, t2;
      t1 = this.elements;
      t2 = J.getInterceptor$x(newElement);
      if (t1.containsKey$1(t2.get$name(newElement)))
        return t1.$index(0, t2.get$name(newElement));
      t1.$indexSet(0, t2.get$name(newElement), newElement);
      return newElement;
    },
    localLookup$1: function($name) {
      return this.elements.$index(0, $name);
    },
    MutableScope$1: function($parent) {
    }
  },
  MethodScope: {
    "^": "MutableScope;element<,elements,parent",
    toString$0: function(_) {
      var t1, t2;
      t1 = "MethodScope(" + this.element.toString$0(0);
      t2 = this.elements;
      t2 = H.setRuntimeTypeInfo(new P.LinkedHashMapKeyIterable(t2), [H.getTypeArgumentByIndex(t2, 0)]);
      return t1 + H.S(P.List_List$from(t2, true, H.getRuntimeTypeArgument(t2, "IterableBase", 0))) + ")";
    }
  },
  BlockScope: {
    "^": "MutableScope;elements,parent",
    toString$0: function(_) {
      var t1 = this.elements;
      t1 = H.setRuntimeTypeInfo(new P.LinkedHashMapKeyIterable(t1), [H.getTypeArgumentByIndex(t1, 0)]);
      return "BlockScope(" + H.S(P.List_List$from(t1, true, H.getRuntimeTypeArgument(t1, "IterableBase", 0))) + ")";
    }
  },
  ClassScope: {
    "^": "TypeDeclarationScope;element,parent",
    get$element: function() {
      return this.element;
    },
    localLookup$1: function($name) {
      var result = this.element.lookupLocalMember$1($name);
      if (result != null)
        return result;
      return A.TypeDeclarationScope.prototype.localLookup$1.call(this, $name);
    },
    lookup$1: function($name) {
      var result, t1;
      result = this.localLookup$1($name);
      if (result != null)
        return result;
      result = this.parent.lookup$1($name);
      if (result != null)
        return result;
      t1 = this.element;
      return t1.lookupSuperMemberInLibrary$2($name, t1.get$enclosingElement().get$library());
    },
    add$1: function(_, newElement) {
      throw H.wrapException("Cannot add an element in a class scope");
    },
    toString$0: function(_) {
      return "ClassScope(" + this.element.toString$0(0) + ")";
    }
  },
  LibraryScope: {
    "^": "Object;library<",
    lookup$1: function($name) {
      return this.library.find$1(0, $name);
    },
    add$1: function(_, newElement) {
      throw H.wrapException("Cannot add an element to a library scope");
    },
    toString$0: function(_) {
      return "LibraryScope(" + this.library.toString$0(0) + ")";
    }
  },
  SignatureResolver: {
    "^": "MappingVisitor;resolver,enclosingElement<,scope<,defaultValuesError,createRealParameters,optionalParameters,optionalParameterCount,isOptionalParameter,optionalParametersAreNamed,currentDefinitions,registry,typeResolver,compiler",
    visitNodeList$1: function(node) {
      var value, elements;
      value = node.beginToken.get$stringValue();
      if (value !== "[" && value !== "{")
        this.compiler.internalError$2(node, "expected optional parameters");
      this.optionalParametersAreNamed = value === "{";
      this.isOptionalParameter = true;
      elements = this.analyzeNodes$1(node.nodes);
      this.optionalParameterCount = elements.length;
      this.optionalParameters = elements.toLink$0();
    },
    visitVariableDefinitions$1: function(node) {
      var definitions, t1, definition, t2, element;
      definitions = node.definitions.nodes;
      if (definitions.get$isEmpty(definitions))
        this.compiler.internalError$2(node, "no parameter definition");
      t1 = definitions.get$tail();
      if (!t1.get$isEmpty(t1)) {
        t1 = definitions.get$tail();
        this.compiler.internalError$2(t1.get$head(t1), "extra definition");
      }
      definition = definitions.get$head(definitions);
      t1 = J.getInterceptor(definition);
      if (!!t1.$isNodeList)
        this.compiler.internalError$2(node, "optional parameters are not implemented");
      t2 = node.modifiers.flags;
      if ((t2 & 16) !== 0)
        this.compiler.reportDiagnosticInternal$4(node, C.MessageKind_FGJ, C.Map_empty, C.Diagnostic_1_error);
      if ((t2 & 1) !== 0)
        this.compiler.reportDiagnosticInternal$4(node, C.MessageKind_aTW, C.Map_empty, C.Diagnostic_1_error);
      if (this.currentDefinitions != null)
        this.compiler.internalError$2(node, "function type parameters not supported");
      this.currentDefinitions = node;
      element = t1.accept$1(definition, this);
      if (this.currentDefinitions.metadata != null)
        element.set$metadata(this.compiler.resolver.resolveMetadata$2(element, node));
      this.currentDefinitions = null;
      return element;
    },
    validateName$1: function(node) {
      var t1 = node.token;
      t1.get$value(t1);
      if (this.isOptionalParameter)
        if (this.optionalParametersAreNamed) {
          t1 = t1.get$value(t1);
          t1 = !J.getInterceptor$asx(t1).get$isEmpty(t1) && C.JSString_methods.codeUnitAt$1(t1, 0) === 95;
        } else
          t1 = false;
      else
        t1 = false;
      if (t1)
        this.compiler.reportDiagnosticInternal$4(node, C.MessageKind_knt, C.Map_empty, C.Diagnostic_1_error);
    },
    computeParameterType$2: function(element, fieldElement) {
      var t1, t2, t3, type, link;
      t1 = new A.SignatureResolver_computeParameterType_computeFunctionType(this, element);
      t2 = this.currentDefinitions;
      t3 = t2.type;
      if (t3 != null) {
        type = this.resolveReturnType$1(t3);
        if (type.get$kind(type) === C.TypeKind_void)
          this.compiler.reportDiagnosticInternal$4(t3, C.MessageKind_4lY, C.Map_empty, C.Diagnostic_1_error);
        element.typeCache = type;
      } else {
        link = t2.definitions.nodes;
        if (link.get$head(link).asFunctionExpression$0() != null)
          t1.call$1(link.get$head(link));
        else if (link.get$head(link).asSend$0() != null && link.get$head(link).asSend$0().selector.asFunctionExpression$0() != null)
          t1.call$1(link.get$head(link).asSend$0().selector.asFunctionExpression$0());
        else if (fieldElement != null)
          element.typeCache = fieldElement.computeType$1(this.compiler);
        else
          element.typeCache = C.C_DynamicType;
      }
    },
    computeParameterType$1: function(element) {
      return this.computeParameterType$2(element, null);
    },
    visitIdentifier$1: function(node) {
      return this.createParameter$2(node, null);
    },
    getParameterName$1: function(node) {
      var t1, identifier, functionExpression;
      t1 = node.selector;
      identifier = t1.asIdentifier$0();
      if (identifier != null)
        return identifier;
      else {
        functionExpression = t1.asFunctionExpression$0();
        if (functionExpression != null && functionExpression.name.asIdentifier$0() != null)
          return functionExpression.name.asIdentifier$0();
        else
          this.compiler.internalError$2(node, "internal error: unimplemented receiver on parameter send");
      }
    },
    visitSend$1: function(node) {
      return this.createFieldParameter$2(node, null);
    },
    createParameter$2: function($name, initializer) {
      var t1, t2, t3, t4, parameter;
      this.validateName$1($name);
      t1 = this.enclosingElement;
      t2 = this.currentDefinitions;
      if (this.createRealParameters) {
        t3 = $name.get$token();
        t3 = t3.get$value(t3);
        t4 = $.ElementX_elementHashCode + 1;
        $.ElementX_elementHashCode = t4;
        parameter = new U.LocalParameterElementX(initializer, null, null, t2, $name, null, null, t3, C.ElementKind_parameter_1, t1, t4, C.C_Link2, null, false);
      } else {
        t3 = $name.get$token();
        t3 = t3.get$value(t3);
        t4 = $.ElementX_elementHashCode + 1;
        $.ElementX_elementHashCode = t4;
        parameter = new U.FormalElementX(t2, $name, null, null, t3, C.ElementKind_parameter_1, t1, t4, C.C_Link2, null, false);
      }
      this.computeParameterType$1(parameter);
      return parameter;
    },
    createFieldParameter$2: function(node, initializer) {
      var t1, element, $name, t2, t3, fieldElement, t4;
      t1 = node.receiver;
      if (t1.asIdentifier$0() != null) {
        t1 = t1.asIdentifier$0().token;
        t1 = t1.get$value(t1) !== "this";
      } else
        t1 = true;
      if (t1) {
        this.compiler.reportFatalError$3(node, C.MessageKind_qxi, C.Map_empty);
        element = null;
      } else {
        t1 = this.enclosingElement;
        if (t1.kind !== C.ElementKind_generative_constructor_16) {
          this.compiler.reportFatalError$3(node, C.MessageKind_Mny, C.Map_empty);
          element = null;
        } else {
          $name = this.getParameterName$1(node);
          this.validateName$1($name);
          t2 = t1.get$enclosingClass();
          t3 = $name.token;
          fieldElement = t2.lookupLocalMember$1(t3.get$value(t3));
          if (fieldElement == null || fieldElement.get$kind(fieldElement) !== C.ElementKind_field_1)
            this.compiler.reportFatalError$3(node, C.MessageKind_rYI, P.LinkedHashMap_LinkedHashMap$_literal(["fieldName", $name], null, null));
          else if (!fieldElement.get$isInstanceMember())
            this.compiler.reportFatalError$3(node, C.MessageKind_LQb, P.LinkedHashMap_LinkedHashMap$_literal(["fieldName", $name], null, null));
          t2 = this.currentDefinitions;
          t3 = t3.get$value(t3);
          t4 = $.ElementX_elementHashCode + 1;
          $.ElementX_elementHashCode = t4;
          element = new U.InitializingFormalElementX(fieldElement, initializer, null, null, t2, $name, null, null, t3, C.ElementKind_initializing_formal_1, t1, t4, C.C_Link2, null, false);
          this.computeParameterType$2(element, fieldElement);
        }
      }
      return element;
    },
    visitSendSet$1: function(node) {
      var t1, element, t2, defaultValue;
      if (node.receiver != null) {
        t1 = node.argumentsNode.nodes;
        if (t1.get$isEmpty(t1))
          H.throwExpression(P.StateError$("No elements"));
        element = this.createFieldParameter$2(node, t1.get$head(t1));
      } else {
        t1 = node.selector;
        if (t1.asIdentifier$0() != null || t1.asFunctionExpression$0() != null) {
          t1 = this.getParameterName$1(node);
          t2 = node.argumentsNode.nodes;
          if (t2.get$isEmpty(t2))
            H.throwExpression(P.StateError$("No elements"));
          element = this.createParameter$2(t1, t2.get$head(t2));
        } else
          element = null;
      }
      t1 = node.argumentsNode.nodes;
      defaultValue = t1.get$head(t1);
      t1 = this.defaultValuesError;
      if (t1 != null)
        this.compiler.reportDiagnosticInternal$4(defaultValue, t1, C.Map_empty, C.Diagnostic_1_error);
      return element;
    },
    visitFunctionExpression$1: function(node) {
      var modifiers, t1;
      modifiers = this.currentDefinitions.modifiers;
      t1 = modifiers.flags;
      if ((t1 & 4) !== 0)
        this.compiler.reportDiagnosticInternal$4(modifiers, C.MessageKind_hOe, C.Map_empty, C.Diagnostic_1_error);
      if ((t1 & 8) !== 0)
        this.compiler.reportDiagnosticInternal$4(modifiers, C.MessageKind_NYu, C.Map_empty, C.Diagnostic_1_error);
      return this.createParameter$2(node.name, null);
    },
    analyzeNodes$1: function(link) {
      var elements, t1, element, t2;
      elements = H.setRuntimeTypeInfo(new E.LinkBuilderImplementation(null, null, 0), [null]);
      for (t1 = this.compiler; !link.get$isEmpty(link); link = link.get$tail()) {
        element = J.accept$1$x(link.get$head(link), this);
        if (element != null)
          elements.addLast$1(element);
        else {
          t2 = link.get$tail();
          if (!t2.get$isEmpty(t2) || !J.getInterceptor(link.get$head(link)).$isNodeList)
            t1.internalError$2(link.get$head(link), "expected optional parameters");
        }
      }
      return elements;
    },
    resolveReturnType$1: function(annotation) {
      var result;
      if (annotation == null)
        return C.C_DynamicType;
      result = this.resolver.resolveTypeAnnotation$1(annotation);
      if (result == null)
        return C.C_DynamicType;
      return result;
    },
    $asMappingVisitor: function() {
      return [U.FormalElementX];
    },
    $asCommonResolverVisitor: function() {
      return [U.FormalElementX];
    },
    $asVisitor: function() {
      return [U.FormalElementX];
    },
    static: {SignatureResolver_analyze: function(compiler, formalParameters, returnNode, element, registry, createRealParameters, defaultValuesError) {
        var t1, visitor, parameters, requiredParameterCount, parametersBuilder, returnType, t2, parameterTypes, orderedOptionalParameters, namedParametersBuilder, namedParameterTypesBuilder, parameter, namedParameters, namedParameterTypes, optionalParameterTypes, optionalParameterTypesBuilder, type;
        t1 = element.buildScope$0();
        visitor = new A.SignatureResolver(A.ResolverVisitor$(compiler, element, registry, false), element, t1, defaultValuesError, createRealParameters, C.C_Link, 0, false, false, null, registry, new A.TypeResolver(compiler), compiler);
        t1 = formalParameters == null;
        if (t1) {
          if (!element.get$isGetter())
            if (element.get$isErroneous())
              ;
            else
              compiler.reportDiagnosticInternal$4(element, C.MessageKind_43h, C.Map_empty, C.Diagnostic_1_error);
          parameters = C.C_Link;
          requiredParameterCount = 0;
        } else {
          if (element.get$isGetter())
            if (formalParameters.endToken.next.get$stringValue() !== "native")
              compiler.reportDiagnosticInternal$4(formalParameters, C.MessageKind_iim, C.Map_empty, C.Diagnostic_1_error);
          parametersBuilder = visitor.analyzeNodes$1(formalParameters.nodes);
          requiredParameterCount = parametersBuilder.length;
          parameters = parametersBuilder.toLink$0();
        }
        if ((element.get$modifiers().flags & 32) !== 0) {
          returnType = element.get$enclosingClass().get$thisType();
          if (compiler.enableTypeAssertions) {
            t2 = registry.compiler;
            t2.enqueuer.resolution.registerIsCheck$2(returnType, registry);
            t2.backend.get$resolutionCallbacks().onIsCheck$2(returnType, registry);
          }
        } else
          returnType = visitor.resolveReturnType$1(returnNode);
        if (element.kind === C.ElementKind_setter_0)
          t2 = requiredParameterCount !== 1 || visitor.optionalParameterCount !== 0;
        else
          t2 = false;
        if (t2)
          if (!t1)
            compiler.reportDiagnosticInternal$4(formalParameters, C.MessageKind_EOZ, C.Map_empty, C.Diagnostic_1_error);
        parameterTypes = H.setRuntimeTypeInfo(new E.LinkBuilderImplementation(null, null, 0), [null]);
        for (parameters.toString, t1 = H.setRuntimeTypeInfo(new E.LinkIterator(null, parameters), [H.getTypeArgumentByIndex(parameters, 0)]); t1.moveNext$0();)
          parameterTypes.addLast$1(J.get$type$x(t1._util_implementation$_current));
        orderedOptionalParameters = visitor.optionalParameters.toList$0(0);
        if (visitor.optionalParametersAreNamed) {
          H.IterableMixinWorkaround_sortList(orderedOptionalParameters, new A.SignatureResolver_analyze_closure());
          namedParametersBuilder = H.setRuntimeTypeInfo(new E.LinkBuilderImplementation(null, null, 0), [null]);
          namedParameterTypesBuilder = H.setRuntimeTypeInfo(new E.LinkBuilderImplementation(null, null, 0), [null]);
          for (t1 = H.setRuntimeTypeInfo(new H.ListIterator(orderedOptionalParameters, orderedOptionalParameters.length, 0, null), [H.getTypeArgumentByIndex(orderedOptionalParameters, 0)]); t1.moveNext$0();) {
            parameter = t1.__internal$_current;
            t2 = J.getInterceptor$x(parameter);
            namedParametersBuilder.addLast$1(t2.get$name(parameter));
            namedParameterTypesBuilder.addLast$1(t2.get$type(parameter));
          }
          namedParameters = namedParametersBuilder.toLink$0().toList$1$growable(0, false);
          namedParameterTypes = namedParameterTypesBuilder.toLink$0().toList$1$growable(0, false);
          optionalParameterTypes = C.List_empty3;
        } else {
          optionalParameterTypesBuilder = H.setRuntimeTypeInfo(new E.LinkBuilderImplementation(null, null, 0), [null]);
          for (t1 = visitor.optionalParameters, t1.toString, t1 = H.setRuntimeTypeInfo(new E.LinkIterator(null, t1), [H.getTypeArgumentByIndex(t1, 0)]); t1.moveNext$0();)
            optionalParameterTypesBuilder.addLast$1(J.get$type$x(t1._util_implementation$_current));
          optionalParameterTypes = optionalParameterTypesBuilder.toLink$0().toList$1$growable(0, false);
          namedParameters = C.List_empty0;
          namedParameterTypes = C.List_empty3;
        }
        type = V.FunctionType_FunctionType(element.get$declaration(), returnType, parameterTypes.toLink$0().toList$1$growable(0, false), optionalParameterTypes, namedParameters, namedParameterTypes);
        return new U.FunctionSignatureX(parameters, visitor.optionalParameters, requiredParameterCount, visitor.optionalParameterCount, visitor.optionalParametersAreNamed, orderedOptionalParameters, type);
      }}
  },
  SignatureResolver_computeParameterType_computeFunctionType: {
    "^": "Closure:232;this_0,element_1",
    call$1: function(functionExpression) {
      var t1, t2, functionSignature;
      t1 = this.this_0;
      t2 = this.element_1;
      functionSignature = A.SignatureResolver_analyze(t1.compiler, functionExpression.get$parameters(), functionExpression.get$returnType(), t2, t1.registry, false, C.MessageKind_8eb);
      t2.functionSignatureCache = functionSignature;
      t2.typeCache = functionSignature.type;
    },
    $isFunction: true
  },
  SignatureResolver_analyze_closure: {
    "^": "Closure:233;",
    call$2: function(a, b) {
      return J.compareTo$1$ns(J.get$name$x(a), J.get$name$x(b));
    },
    $isFunction: true
  }
}],
["resolution.compute_members", "package:compiler/implementation/resolution/class_members.dart", , A, {
  "^": "",
  MembersCreator_computeClassMembersByName: function(compiler, cls, $name) {
    var library, t1;
    if (cls.isMemberComputed$1($name))
      return;
    library = cls.get$enclosingElement().get$library();
    t1 = H.setRuntimeTypeInfo(new N.Setlet(C.C__SetletMarker, null), [O.Name]);
    t1.add$1(0, O.Name_Name($name, library, false));
    t1.add$1(0, O.Name_Name($name, library, true));
    cls.computeClassMember$3(compiler, $name, t1);
  },
  MembersCreator: {
    "^": "Object;cls<,compiler<",
    reportMessage$3: function(marker, kind, report) {
      if (J.add$1$ax(this.reportedMessages.putIfAbsent$2(marker, new A.MembersCreator_reportMessage_closure()), kind) === true)
        report.call$0();
    },
    computeSuperClassMembers$2: function($name, names) {
      var supertype, superclass, t1, t2;
      supertype = this.cls.get$supertype();
      if (supertype == null)
        return;
      superclass = supertype.get$element();
      t1 = new A.MembersCreator_computeSuperClassMembers_inheritClassMember(this, supertype);
      t2 = this.compiler;
      if (names != null) {
        superclass.computeClassMember$3(t2, $name, names);
        for (t2 = names.get$iterator(names); t2.moveNext$0();)
          t1.call$1(superclass.lookupClassMember$1(t2.get$current()));
      } else {
        superclass.computeAllClassMembers$1(t2);
        superclass.forEachClassMember$1(t1);
      }
    },
    computeClassMembers$2: function(nameText, names) {
      var declaredMembers, t1, t2, t3, t4, memberName;
      declaredMembers = P.LinkedHashMap_LinkedHashMap(null, null, null, O.Name, O.Member);
      t1 = this.cls;
      if (t1.get$isMixinApplication()) {
        if ((t1.get$mixinType() != null ? t1.mixinType.get$element() : null) != null) {
          t2 = new A.MembersCreator_computeClassMembers_inheritMixinMember(this, t1);
          t3 = this.compiler;
          if (names != null) {
            t4 = t1.mixinType;
            (t4 != null ? t4.get$element() : null).computeClassMember$3(t3, nameText, names);
            for (t3 = names.get$iterator(names); t3.moveNext$0();) {
              memberName = t3.get$current();
              t4 = t1.mixinType;
              t2.call$1((t4 != null ? t4.get$element() : null).lookupClassMember$1(memberName));
            }
          } else {
            t4 = t1.mixinType;
            (t4 != null ? t4.get$element() : null).computeAllClassMembers$1(t3);
            t1 = t1.mixinType;
            (t1 != null ? t1.get$element() : null).forEachClassMember$1(t2);
          }
        }
      } else {
        t2 = new A.MembersCreator_computeClassMembers_createMember(this, nameText, declaredMembers, t1.get$library(), t1.get$thisType());
        t1.forEachLocalMember$1(t2);
        if (t1.get$isPatched())
          t1.get$implementation(t1).forEachLocalMember$1(new A.MembersCreator_computeClassMembers_closure(t2));
      }
      return declaredMembers;
    },
    checkInterfaceMember$3: function($name, interfaceMember, classMember) {
      var t1 = {};
      if (classMember != null)
        return;
      if (!!J.getInterceptor(interfaceMember).$isDeclaredMember && interfaceMember.get$declarer().get$element() === this.cls) {
        t1.kind_0 = C.MessageKind_QgR;
        if (interfaceMember.get$isSetter())
          t1.kind_0 = C.MessageKind_lLu;
        else if (interfaceMember.get$isGetter())
          t1.kind_0 = C.MessageKind_dWH;
        this.reportMessage$3(interfaceMember.get$element(), C.MessageKind_QgR, new A.MembersCreator_checkInterfaceMember_closure(t1, this, $name, interfaceMember));
      } else {
        t1 = new A.MembersCreator_checkInterfaceMember_reportWarning(this, $name, interfaceMember);
        if (interfaceMember.get$isSetter())
          t1.call$4(C.MessageKind_oUC, C.MessageKind_ad7, C.MessageKind_AQu, C.MessageKind_qlM);
        else if (interfaceMember.get$isGetter())
          t1.call$4(C.MessageKind_8Gl, C.MessageKind_I6V, C.MessageKind_8aB, C.MessageKind_C3e);
        else if (interfaceMember.get$isMethod())
          t1.call$3(C.MessageKind_xw81, C.MessageKind_IzL, C.MessageKind_omH);
      }
    },
    checkImplementsFunctionWithCall$0: function() {
      var t1, t2;
      t1 = this.cls;
      t2 = this.compiler;
      if (t1.asInstanceOf$1(t2.functionClass) == null)
        return;
      if (t1.lookupMember$1("call") != null)
        return;
      if (t2.backend.isBackendLibrary$1(t1.get$library()))
        return;
      this.reportMessage$3(t2.functionClass, C.MessageKind_IzL, new A.MembersCreator_checkImplementsFunctionWithCall_closure(this));
    },
    checkValidOverride$2: function(declared, superMember) {
      var t1, superclass, t2, inherited, declaredType, t3, inheritedType;
      t1 = {};
      if (superMember == null) {
        if (!declared.get$isStatic()) {
          superclass = this.cls.get$superclass();
          t1.superclass_0 = superclass;
          for (t2 = superclass; t2 != null; t2 = superclass) {
            superMember = t2.lookupClassMember$1(declared.get$name(declared));
            if (superMember != null && superMember.get$isStatic()) {
              this.reportMessage$3(superMember, C.MessageKind_MyU, new A.MembersCreator_checkValidOverride_closure(t1, this, declared, superMember));
              break;
            }
            superclass = t1.superclass_0.get$superclass();
            t1.superclass_0 = superclass;
          }
        }
      } else {
        if (declared.get$isStatic()) {
          t1 = superMember.get$declarations();
          t2 = new H.ListIterator(t1, 1, 0, null);
          t2.$builtinTypeInfo = [H.getTypeArgumentByIndex(t1, 0)];
          for (; t2.moveNext$0();) {
            inherited = t2.__internal$_current;
            this.reportMessage$3(inherited.get$element(), C.MessageKind_dTZ, new A.MembersCreator_checkValidOverride_closure0(this, declared, inherited));
          }
        }
        declaredType = declared.get$functionType();
        t1 = superMember.get$declarations();
        t2 = new H.ListIterator(t1, 1, 0, null);
        t2.$builtinTypeInfo = [H.getTypeArgumentByIndex(t1, 0)];
        t1 = this.compiler;
        for (; t2.moveNext$0();) {
          inherited = t2.__internal$_current;
          t3 = new A.MembersCreator_checkValidOverride_reportError(this, declared, inherited);
          if (declared.get$isDeclaredByField() && inherited.get$isMethod())
            t3.call$2(C.MessageKind_uez, C.MessageKind_OOv);
          else if (declared.get$isMethod() && inherited.get$isDeclaredByField())
            t3.call$2(C.MessageKind_woc0, C.MessageKind_E4y);
          else if (declared.get$isGetter() && inherited.get$isMethod())
            t3.call$2(C.MessageKind_7Re0, C.MessageKind_ieL);
          else if (declared.get$isMethod() && inherited.get$isGetter())
            t3.call$2(C.MessageKind_gg9, C.MessageKind_ieL0);
          else {
            inheritedType = inherited.get$functionType();
            t3 = t1.types.subtypeVisitor;
            if (!(declaredType.get$treatAsDynamic() || t3.isMoreSpecific$2(declaredType, inheritedType) === true)) {
              t3 = new A.MembersCreator_checkValidOverride_reportWarning(this, declared, inherited);
              if (declared.get$isDeclaredByField()) {
                if (inherited.get$isDeclaredByField())
                  t3.call$3(inherited.get$element(), C.MessageKind_CnH, C.MessageKind_CRg);
                else if (inherited.get$isGetter())
                  t3.call$3(inherited, C.MessageKind_x0h, C.MessageKind_YAz);
                else if (inherited.get$isSetter())
                  t3.call$3(inherited, C.MessageKind_x0h0, C.MessageKind_sBE);
              } else if (declared.get$isGetter())
                if (inherited.get$isDeclaredByField())
                  t3.call$3(inherited, C.MessageKind_u8x, C.MessageKind_CRg);
                else
                  t3.call$3(inherited, C.MessageKind_QtW, C.MessageKind_YAz);
              else if (declared.get$isSetter())
                if (inherited.get$isDeclaredByField())
                  t3.call$3(inherited, C.MessageKind_u8x0, C.MessageKind_CRg);
                else
                  t3.call$3(inherited, C.MessageKind_QtW0, C.MessageKind_sBE);
              else
                t3.call$3(inherited, C.MessageKind_gkc, C.MessageKind_B8J);
            }
          }
        }
      }
    }
  },
  MembersCreator_reportMessage_closure: {
    "^": "Closure:23;",
    call$0: function() {
      return P.LinkedHashSet_LinkedHashSet(null, null, null, K.MessageKind);
    },
    $isFunction: true
  },
  MembersCreator_computeSuperClassMembers_inheritClassMember: {
    "^": "Closure:234;this_0,supertype_1",
    call$1: function(member) {
      var t1, t2, t3, inherited;
      t1 = this.this_0;
      if (member != null) {
        t2 = J.get$name$x(member).text;
        t3 = t1.computedMemberNames;
        t2 = t3 != null && J.contains$1$asx(t3, t2) === true;
      } else
        t2 = true;
      if (t2)
        return;
      if (!member.get$isStatic()) {
        inherited = member.inheritFrom$1(this.supertype_1);
        t1.classMembers.$indexSet(0, member.get$name(member), inherited);
      }
    },
    $isFunction: true
  },
  MembersCreator_computeClassMembers_inheritMixinMember: {
    "^": "Closure:234;this_0,mixinApplication_1",
    call$1: function(member) {
      var t1, t2, t3, $name, mixedInMember, inherited;
      t1 = this.this_0;
      if (member != null) {
        t2 = J.get$name$x(member).text;
        t3 = t1.computedMemberNames;
        t2 = t3 != null && J.contains$1$asx(t3, t2) === true;
      } else
        t2 = true;
      if (t2)
        return;
      $name = J.get$name$x(member);
      if (!member.get$isAbstract() && !member.get$isStatic()) {
        mixedInMember = member.inheritFrom$1(this.mixinApplication_1.mixinType);
        t2 = t1.classMembers;
        inherited = t2.$index(0, $name);
        t2.$indexSet(0, $name, mixedInMember);
        t1.checkValidOverride$2(mixedInMember, inherited);
      }
    },
    $isFunction: true
  },
  MembersCreator_computeClassMembers_createMember: {
    "^": "Closure:47;this_2,nameText_3,declaredMembers_4,library_5,thisType_6",
    call$1: function(element) {
      var t1, elementName, t2, t3, $name, type, functionType;
      t1 = J.getInterceptor$x(element);
      if (t1.get$kind(element) === C.ElementKind_generative_constructor_16 || element.get$isFactoryConstructor())
        return;
      elementName = t1.get$name(element);
      t2 = this.this_2;
      t3 = t2.computedMemberNames;
      if (t3 != null && J.contains$1$asx(t3, elementName) === true)
        return;
      t3 = this.nameText_3;
      if (t3 != null && (elementName == null ? t3 != null : elementName !== t3))
        return;
      t3 = new A.MembersCreator_computeClassMembers_createMember_addDeclaredMember(t2, this.declaredMembers_4, this.thisType_6, element);
      $name = O.Name_Name(t1.get$name(element), this.library_5, false);
      if (t1.get$kind(element) === C.ElementKind_field_1) {
        type = element.computeType$1(t2.compiler);
        t3.call$3($name, type, V.FunctionType$internal(null, type, C.List_empty3, C.List_empty3, C.List_empty0, C.List_empty3));
        if (!element.get$isConst() && !element.get$isFinal())
          t3.call$3($name.get$setter(), type, V.FunctionType$internal(null, C.C_VoidType, H.setRuntimeTypeInfo([type], [V.DartType]), C.List_empty3, C.List_empty0, C.List_empty3));
      } else if (element.get$isGetter()) {
        functionType = element.computeType$1(t2.compiler);
        t3.call$3($name, functionType.get$returnType(), functionType);
      } else {
        t2 = t2.compiler;
        if (t1.get$kind(element) === C.ElementKind_setter_0) {
          functionType = element.computeType$1(t2);
          type = functionType.get$parameterTypes().length !== 0 ? J.get$first$ax(functionType.get$parameterTypes()) : C.C_DynamicType;
          t3.call$3($name.get$setter(), type, functionType);
        } else {
          type = element.computeType$1(t2);
          t3.call$3($name, type, type);
        }
      }
    },
    $isFunction: true
  },
  MembersCreator_computeClassMembers_createMember_addDeclaredMember: {
    "^": "Closure:235;this_7,declaredMembers_8,thisType_9,element_10",
    call$3: function($name, type, functionType) {
      var t1, t2, inherited, t3, t4, declared;
      t1 = this.this_7;
      t2 = t1.classMembers;
      inherited = t2.$index(0, $name);
      t3 = this.element_10;
      t4 = this.thisType_9;
      declared = t3.get$isAbstract() ? new A.DeclaredAbstractMember(inherited, $name, t3, t4, type, functionType) : new A.DeclaredMember($name, t3, t4, type, functionType);
      this.declaredMembers_8.$indexSet(0, $name, declared);
      t2.$indexSet(0, $name, declared);
      t1.checkValidOverride$2(declared, inherited);
    },
    $isFunction: true
  },
  MembersCreator_computeClassMembers_closure: {
    "^": "Closure:77;createMember_11",
    call$1: function(element) {
      if (element.get$isDeclaration())
        this.createMember_11.call$1(element);
    },
    $isFunction: true
  },
  MembersCreator_checkInterfaceMember_closure: {
    "^": "Closure:23;box_0,this_1,name_2,interfaceMember_3",
    call$0: function() {
      var t1, t2;
      t1 = this.this_1;
      t2 = t1.cls;
      t1.compiler.reportDiagnosticInternal$4(this.interfaceMember_3.get$element(), this.box_0.kind_0, P.LinkedHashMap_LinkedHashMap$_literal(["class", t2.get$name(t2), "name", this.name_2.text], null, null), C.Diagnostic_2_warning);
    },
    $isFunction: true
  },
  MembersCreator_checkInterfaceMember_reportWarning: {
    "^": "Closure:236;this_4,name_5,interfaceMember_6",
    call$4: function(singleKind, multipleKind, explicitlyDeclaredKind, implicitlyDeclaredKind) {
      var t1, t2;
      t1 = this.interfaceMember_6;
      t2 = this.this_4;
      t2.reportMessage$3(t1, C.MessageKind_IzL, new A.MembersCreator_checkInterfaceMember_reportWarning_closure(t2, this.name_5, t1, singleKind, multipleKind, explicitlyDeclaredKind, implicitlyDeclaredKind, J.get$first$ax(t1.get$declarations())));
    },
    call$3: function(singleKind, multipleKind, explicitlyDeclaredKind) {
      return this.call$4(singleKind, multipleKind, explicitlyDeclaredKind, null);
    },
    $isFunction: true
  },
  MembersCreator_checkInterfaceMember_reportWarning_closure: {
    "^": "Closure:23;this_7,name_8,interfaceMember_9,singleKind_10,multipleKind_11,explicitlyDeclaredKind_12,implicitlyDeclaredKind_13,inherited_14",
    call$0: function() {
      var t1, t2, t3, t4, t5, inherited, t6, t7, t8;
      t1 = this.this_7;
      t2 = t1.compiler;
      t1 = t1.cls;
      t3 = this.interfaceMember_9;
      t4 = J.get$length$asx(t3.get$declarations()) === 1 ? this.singleKind_10 : this.multipleKind_11;
      t5 = this.name_8.text;
      t2.reportDiagnosticInternal$4(t1, t4, P.LinkedHashMap_LinkedHashMap$_literal(["class", t1.get$name(t1), "name", t5, "method", t3, "declarer", this.inherited_14.get$declarer()], null, null), C.Diagnostic_2_warning);
      for (t1 = J.get$iterator$ax(t3.get$declarations()), t3 = this.explicitlyDeclaredKind_12, t4 = this.implicitlyDeclaredKind_13; t1.moveNext$0();) {
        inherited = t1.get$current();
        t6 = inherited.get$element();
        t7 = inherited.get$isDeclaredByField() ? t4 : t3;
        t8 = inherited.get$declarer();
        t8.toString;
        t2.reportDiagnosticInternal$4(t6, t7, P.LinkedHashMap_LinkedHashMap$_literal(["class", t8.element.name, "name", t5], null, null), C.Diagnostic_8_info);
      }
    },
    $isFunction: true
  },
  MembersCreator_checkImplementsFunctionWithCall_closure: {
    "^": "Closure:23;this_0",
    call$0: function() {
      var t1, t2, t3, t4;
      t1 = this.this_0;
      t2 = t1.compiler;
      t1 = t1.cls;
      t3 = t1.get$name(t1);
      t4 = t2.functionClass;
      t2.reportDiagnosticInternal$4(t1, C.MessageKind_xw81, P.LinkedHashMap_LinkedHashMap$_literal(["class", t3, "name", "call", "method", "call", "declarer", t4.get$name(t4)], null, null), C.Diagnostic_2_warning);
    },
    $isFunction: true
  },
  MembersCreator_checkValidOverride_closure: {
    "^": "Closure:23;box_0,this_1,declared_2,superMember_3",
    call$0: function() {
      var t1, t2;
      t1 = this.this_1.compiler;
      t2 = this.declared_2;
      t1.reportDiagnosticInternal$4(t2.get$element(), C.MessageKind_MyU, P.LinkedHashMap_LinkedHashMap$_literal(["memberName", t2.get$name(t2), "className", this.box_0.superclass_0.name], null, null), C.Diagnostic_2_warning);
      t1.reportDiagnosticInternal$4(this.superMember_3.get$element(), C.MessageKind_p6D, C.Map_empty, C.Diagnostic_8_info);
    },
    $isFunction: true
  },
  MembersCreator_checkValidOverride_closure0: {
    "^": "Closure:23;this_4,declared_5,inherited_6",
    call$0: function() {
      var t1, t2, t3, t4;
      t1 = this.declared_5.get$element();
      t2 = this.inherited_6.get$element();
      t3 = this.this_4.compiler;
      t4 = t2.get$enclosingClass();
      t3.reportDiagnosticInternal$4(t1, C.MessageKind_dTZ, P.LinkedHashMap_LinkedHashMap$_literal(["memberName", t2.name, "className", t4.get$name(t4)], null, null), C.Diagnostic_1_error);
      t3.reportDiagnosticInternal$4(t2, C.MessageKind_W7h, C.Map_empty, C.Diagnostic_8_info);
    },
    $isFunction: true
  },
  MembersCreator_checkValidOverride_reportError: {
    "^": "Closure:237;this_7,declared_8,inherited_9",
    call$2: function(errorKind, infoKind) {
      var t1, t2;
      t1 = this.this_7;
      t2 = this.inherited_9;
      t1.reportMessage$3(t2.get$element(), C.MessageKind_gkc, new A.MembersCreator_checkValidOverride_reportError_closure(t1, this.declared_8, t2, errorKind, infoKind));
    },
    $isFunction: true
  },
  MembersCreator_checkValidOverride_reportError_closure: {
    "^": "Closure:23;this_10,declared_11,inherited_12,errorKind_13,infoKind_14",
    call$0: function() {
      var t1, t2, t3, t4;
      t1 = this.this_10;
      t2 = t1.compiler;
      t3 = this.declared_11;
      t4 = this.inherited_12;
      t2.reportDiagnosticInternal$4(t3.get$element(), this.errorKind_13, P.LinkedHashMap_LinkedHashMap$_literal(["name", t3.get$name(t3).text, "class", t1.cls.get$thisType(), "inheritedClass", t4.get$declarer()], null, null), C.Diagnostic_1_error);
      t2.reportDiagnosticInternal$4(t4.get$element(), this.infoKind_14, P.LinkedHashMap_LinkedHashMap$_literal(["name", t3.get$name(t3).text, "class", t4.get$declarer()], null, null), C.Diagnostic_8_info);
    },
    $isFunction: true
  },
  MembersCreator_checkValidOverride_reportWarning: {
    "^": "Closure:238;this_15,declared_16,inherited_17",
    call$3: function(marker, warningKind, infoKind) {
      var t1 = this.this_15;
      t1.reportMessage$3(marker, C.MessageKind_gkc, new A.MembersCreator_checkValidOverride_reportWarning_closure(t1, this.declared_16, this.inherited_17, warningKind, infoKind));
    },
    $isFunction: true
  },
  MembersCreator_checkValidOverride_reportWarning_closure: {
    "^": "Closure:23;this_18,declared_19,inherited_20,warningKind_21,infoKind_22",
    call$0: function() {
      var t1, t2, t3, t4;
      t1 = this.this_18;
      t2 = t1.compiler;
      t3 = this.declared_19;
      t4 = this.inherited_20;
      t2.reportDiagnosticInternal$4(t3.get$element(), this.warningKind_21, P.LinkedHashMap_LinkedHashMap$_literal(["declaredType", t3.get$type(t3), "name", t3.get$name(t3).text, "class", t1.cls.get$thisType(), "inheritedType", t4.get$type(t4), "inheritedClass", t4.get$declarer()], null, null), C.Diagnostic_2_warning);
      t2.reportDiagnosticInternal$4(t4.get$element(), this.infoKind_22, P.LinkedHashMap_LinkedHashMap$_literal(["name", t3.get$name(t3).text, "class", t4.get$declarer()], null, null), C.Diagnostic_8_info);
    },
    $isFunction: true
  },
  ClassMembersCreator: {
    "^": "MembersCreator;cls,compiler,computedMemberNames,classMembers,reportedMessages",
    computeMembers$2: function($name, names) {
      this.computeSuperClassMembers$2($name, names);
      return this.computeClassMembers$2($name, names);
    },
    checkInterfaceImplementation$0: function() {
      this.classMembers.forEach$1(0, new A.ClassMembersCreator_checkInterfaceImplementation_closure(this, this.cls.get$library()));
    }
  },
  ClassMembersCreator_checkInterfaceImplementation_closure: {
    "^": "Closure:239;this_0,library_1",
    call$2: function($name, classMember) {
      if (!$name.isAccessibleFrom$1(this.library_1))
        return;
      this.this_0.checkInterfaceMember$3($name, classMember, J.get$implementation$x(classMember));
    },
    $isFunction: true
  },
  InterfaceMembersCreator: {
    "^": "MembersCreator;interfaceMembers,cls,compiler,computedMemberNames,classMembers,reportedMessages",
    computeMembers$2: function($name, names) {
      var inheritedInterfaceMembers, declaredMembers;
      this.computeSuperClassMembers$2($name, names);
      inheritedInterfaceMembers = this.computeSuperInterfaceMembers$2($name, names);
      declaredMembers = this.computeClassMembers$2($name, names);
      this.computeInterfaceMembers$2(inheritedInterfaceMembers, declaredMembers);
      return declaredMembers;
    },
    computeSuperInterfaceMembers$2: function($name, names) {
      var t1, supertype, superclass, inheritedInterfaceMembers, t2, t3, t4, link, superinterface, memberName;
      t1 = this.cls;
      supertype = t1.get$supertype();
      superclass = supertype.get$element();
      inheritedInterfaceMembers = P.LinkedHashMap_LinkedHashMap(null, null, null, O.Name, [N.Setlet, O.Member]);
      t2 = new A.InterfaceMembersCreator_computeSuperInterfaceMembers_inheritInterfaceMember(this, inheritedInterfaceMembers);
      t3 = new A.InterfaceMembersCreator_computeSuperInterfaceMembers_inheritInterfaceMembers(t2);
      if (names != null)
        for (t4 = names.get$iterator(names); t4.moveNext$0();)
          t2.call$2(supertype, superclass.lookupInterfaceMember$1(t4.get$current()));
      else
        t3.call$1(supertype);
      for (link = t1.interfaces, t1 = this.compiler; !link.get$isEmpty(link); link = link.get$tail()) {
        superinterface = link.get$head(link);
        if (names != null) {
          superinterface.get$element().computeClassMember$3(t1, $name, names);
          for (t4 = names.get$iterator(names); t4.moveNext$0();) {
            memberName = t4.get$current();
            t2.call$2(superinterface, superinterface.get$element().lookupInterfaceMember$1(memberName));
          }
        } else {
          superinterface.get$element().computeAllClassMembers$1(t1);
          t3.call$1(superinterface);
        }
      }
      return inheritedInterfaceMembers;
    },
    checkInterfaceImplementation$0: function() {
      var library = this.cls.get$library();
      this.checkImplementsFunctionWithCall$0();
      this.interfaceMembers.forEach$1(0, new A.InterfaceMembersCreator_checkInterfaceImplementation_closure(this, library));
    },
    computeInterfaceMembers$2: function(inheritedInterfaceMembers, declaredMembers) {
      inheritedInterfaceMembers.forEach$1(0, new A.InterfaceMembersCreator_computeInterfaceMembers_closure(this, declaredMembers, this.cls.get$thisType()));
      declaredMembers.forEach$1(0, new A.InterfaceMembersCreator_computeInterfaceMembers_closure0(this));
    },
    _inheritedSynthesizedMember$2: function($name, inheritedMembers) {
      var names, t1, minRequiredParameters, maxPositionalParameters, member, requiredParameters, t2, type, optionalParameters, positionalParameters, requiredParameterTypes, optionalParameterTypes, namedParameters, memberType;
      names = P.LinkedHashSet_LinkedHashSet(null, null, null, P.String);
      for (t1 = inheritedMembers.get$iterator(inheritedMembers), minRequiredParameters = null, maxPositionalParameters = null; t1.moveNext$0();) {
        member = t1.get$current();
        requiredParameters = member.get$isSetter() ? 1 : 0;
        t2 = J.getInterceptor$x(member);
        if (J.get$kind$x(t2.get$type(member)) === C.TypeKind_function) {
          type = t2.get$type(member);
          H.IterableMixinWorkaround_forEach(type.get$namedParameters(), new A.InterfaceMembersCreator__inheritedSynthesizedMember_closure(names));
          requiredParameters = type.get$parameterTypes().length;
          optionalParameters = type.get$optionalParameterTypes().length;
        } else
          optionalParameters = 0;
        positionalParameters = requiredParameters + optionalParameters;
        if (minRequiredParameters == null || minRequiredParameters > requiredParameters)
          minRequiredParameters = requiredParameters;
        if (maxPositionalParameters == null || maxPositionalParameters < positionalParameters)
          maxPositionalParameters = positionalParameters;
      }
      if (typeof maxPositionalParameters !== "number")
        return maxPositionalParameters.$sub();
      if (typeof minRequiredParameters !== "number")
        return H.iae(minRequiredParameters);
      optionalParameters = maxPositionalParameters - minRequiredParameters;
      if (optionalParameters === 0 || names._collection$_length === 0) {
        requiredParameterTypes = P.List_List$filled(minRequiredParameters, C.C_DynamicType, null);
        optionalParameterTypes = P.List_List$filled(optionalParameters, C.C_DynamicType, null);
        namedParameters = names.toList$0(0);
        H.IterableMixinWorkaround_sortList(namedParameters, new A.InterfaceMembersCreator__inheritedSynthesizedMember_closure0());
        memberType = V.FunctionType$internal(null, C.C_DynamicType, requiredParameterTypes, optionalParameterTypes, namedParameters, P.List_List$filled(namedParameters.length, C.C_DynamicType, null));
        type = inheritedMembers.get$first(inheritedMembers).get$isGetter() || inheritedMembers.get$first(inheritedMembers).get$isSetter() ? C.C_DynamicType : memberType;
        this.interfaceMembers.$indexSet(0, $name, new A.SyntheticMember(type, memberType, inheritedMembers));
      }
    }
  },
  InterfaceMembersCreator_computeSuperInterfaceMembers_inheritInterfaceMember: {
    "^": "Closure:240;this_0,inheritedInterfaceMembers_1",
    call$2: function(supertype, member) {
      var t1, t2, members;
      if (member != null) {
        t1 = member.get$name(member);
        t2 = this.this_0.computedMemberNames;
        t1 = t2 != null && J.contains$1$asx(t2, t1.text) === true;
      } else
        t1 = true;
      if (t1)
        return;
      members = this.inheritedInterfaceMembers_1.putIfAbsent$2(member.get$name(member), new A.InterfaceMembersCreator_computeSuperInterfaceMembers_inheritInterfaceMember_closure());
      for (t1 = J.get$iterator$ax(member.get$declarations()), t2 = J.getInterceptor$ax(members); t1.moveNext$0();)
        t2.add$1(members, t1.get$current().inheritFrom$1(supertype));
    },
    $isFunction: true
  },
  InterfaceMembersCreator_computeSuperInterfaceMembers_inheritInterfaceMember_closure: {
    "^": "Closure:23;",
    call$0: function() {
      return H.setRuntimeTypeInfo(new N.Setlet(C.C__SetletMarker, null), [O.Member]);
    },
    $isFunction: true
  },
  InterfaceMembersCreator_computeSuperInterfaceMembers_inheritInterfaceMembers: {
    "^": "Closure:241;inheritInterfaceMember_2",
    call$1: function(supertype) {
      supertype.get$element().forEachInterfaceMember$1(new A.InterfaceMembersCreator_computeSuperInterfaceMembers_inheritInterfaceMembers_closure(this.inheritInterfaceMember_2, supertype));
    },
    $isFunction: true
  },
  InterfaceMembersCreator_computeSuperInterfaceMembers_inheritInterfaceMembers_closure: {
    "^": "Closure:242;inheritInterfaceMember_3,supertype_4",
    call$1: function(member) {
      this.inheritInterfaceMember_3.call$2(this.supertype_4, member);
    },
    $isFunction: true
  },
  InterfaceMembersCreator_checkInterfaceImplementation_closure: {
    "^": "Closure:243;this_0,library_1",
    call$2: function($name, interfaceMember) {
      var t1, classMember;
      if (!$name.isAccessibleFrom$1(this.library_1))
        return;
      t1 = this.this_0;
      classMember = t1.classMembers.$index(0, $name);
      t1.checkInterfaceMember$3($name, interfaceMember, classMember != null ? J.get$implementation$x(classMember) : classMember);
    },
    $isFunction: true
  },
  InterfaceMembersCreator_computeInterfaceMembers_closure: {
    "^": "Closure:244;this_0,declaredMembers_1,thisType_2",
    call$2: function($name, inheritedMembers) {
      var declared, t1, t2, subtypesOfAllInherited, t3, t4, someAreGetters, allAreGetters, inherited, t5, other, t6, t7, t8, kind, members;
      declared = this.declaredMembers_1.$index(0, $name);
      if (declared != null) {
        for (t1 = J.get$iterator$ax(inheritedMembers), t2 = this.this_0; t1.moveNext$0();)
          t2.checkValidOverride$2(declared, t1.get$current());
        if (!declared.get$isStatic())
          t2.interfaceMembers.$indexSet(0, $name, declared);
      } else {
        t1 = J.getInterceptor$asx(inheritedMembers);
        if (t1.get$length(inheritedMembers) === 1)
          this.this_0.interfaceMembers.$indexSet(0, $name, t1.get$single(inheritedMembers));
        else {
          subtypesOfAllInherited = P.LinkedHashMap_LinkedHashMap(null, null, null, V.DartType, [N.Setlet, O.Member]);
          $outer$0:
            for (t2 = t1.get$iterator(inheritedMembers), t3 = this.this_0, t4 = t3.compiler, someAreGetters = false, allAreGetters = true; t2.moveNext$0();) {
              inherited = t2.get$current();
              if (inherited.get$isGetter()) {
                if (!allAreGetters) {
                  someAreGetters = true;
                  break $outer$0;
                }
                someAreGetters = true;
              } else {
                if (someAreGetters) {
                  allAreGetters = false;
                  break $outer$0;
                }
                allAreGetters = false;
              }
              for (t5 = t1.get$iterator(inheritedMembers); t5.moveNext$0();) {
                other = t5.get$current();
                t6 = t4.types;
                t7 = inherited.get$functionType();
                t8 = other.get$functionType();
                t6 = t6.subtypeVisitor;
                if (!(t7.get$treatAsDynamic() || t6.isMoreSpecific$2(t7, t8) === true))
                  continue $outer$0;
              }
              J.add$1$ax(subtypesOfAllInherited.putIfAbsent$2(inherited.get$functionType(), new A.InterfaceMembersCreator_computeInterfaceMembers__closure0()), inherited);
            }
          if (someAreGetters && !allAreGetters) {
            t2 = J.getInterceptor$x($name);
            t4.reportDiagnosticInternal$4(t3.cls, C.MessageKind_9U7, P.LinkedHashMap_LinkedHashMap$_literal(["class", this.thisType_2, "name", t2.get$text($name)], null, null), C.Diagnostic_2_warning);
            for (t1 = t1.get$iterator(inheritedMembers); t1.moveNext$0();) {
              inherited = t1.get$current();
              if (inherited.get$isMethod())
                kind = C.MessageKind_U8J;
              else
                kind = inherited.get$isDeclaredByField() ? C.MessageKind_JAZ : C.MessageKind_ynF;
              t4.reportDiagnosticInternal$4(inherited.get$element(), kind, P.LinkedHashMap_LinkedHashMap$_literal(["class", inherited.get$declarer(), "name", t2.get$text($name)], null, null), C.Diagnostic_8_info);
            }
            t3.interfaceMembers.$indexSet(0, $name, new A.ErroneousMember(inheritedMembers));
          } else if (subtypesOfAllInherited._collection$_length === 1) {
            t1 = subtypesOfAllInherited.get$values(subtypesOfAllInherited);
            members = t1._f$1(J.get$first$ax(t1._iterable));
            t1 = J.getInterceptor$ax(members);
            inherited = t1.get$first(members);
            if (t1.get$length(members) !== 1)
              inherited = new A.SyntheticMember(J.get$type$x(inherited), inherited.get$functionType(), members);
            t3.interfaceMembers.$indexSet(0, $name, inherited);
          } else
            t3._inheritedSynthesizedMember$2($name, inheritedMembers);
        }
      }
    },
    $isFunction: true
  },
  InterfaceMembersCreator_computeInterfaceMembers__closure0: {
    "^": "Closure:23;",
    call$0: function() {
      return H.setRuntimeTypeInfo(new N.Setlet(C.C__SetletMarker, null), [O.Member]);
    },
    $isFunction: true
  },
  InterfaceMembersCreator_computeInterfaceMembers_closure0: {
    "^": "Closure:239;this_3",
    call$2: function($name, member) {
      if (!member.get$isStatic())
        this.this_3.interfaceMembers.putIfAbsent$2($name, new A.InterfaceMembersCreator_computeInterfaceMembers__closure(member));
    },
    $isFunction: true
  },
  InterfaceMembersCreator_computeInterfaceMembers__closure: {
    "^": "Closure:23;member_4",
    call$0: function() {
      return this.member_4;
    },
    $isFunction: true
  },
  InterfaceMembersCreator__inheritedSynthesizedMember_closure: {
    "^": "Closure:0;names_0",
    call$1: function($name) {
      return this.names_0.add$1(0, $name);
    },
    $isFunction: true
  },
  InterfaceMembersCreator__inheritedSynthesizedMember_closure0: {
    "^": "Closure:19;",
    call$2: function(a, b) {
      return J.compareTo$1$ns(a, b);
    },
    $isFunction: true
  },
  ClassMemberMixin: {
    "^": "Object;interfaceMembersAreClassMembers:compute_members$ClassMemberMixin$interfaceMembersAreClassMembers<",
    _prepareCreator$1: function(compiler) {
      var superclass, t1, t2, t3;
      if (this.compute_members$ClassMemberMixin$classMembers == null) {
        this.compute_members$ClassMemberMixin$classMembers = P.LinkedHashMap_LinkedHashMap(null, null, null, O.Name, O.Member);
        if (this.compute_members$ClassMemberMixin$interfaceMembersAreClassMembers) {
          superclass = this.get$superclass();
          if (superclass != null)
            t1 = !superclass.get$interfaceMembersAreClassMembers() || superclass.get$isMixinApplication();
          else
            t1 = false;
          if (!t1) {
            t1 = this.interfaces;
            t1 = !t1.get$isEmpty(t1);
          } else
            t1 = true;
          if (t1)
            this.compute_members$ClassMemberMixin$interfaceMembersAreClassMembers = false;
        }
        if (!this.compute_members$ClassMemberMixin$interfaceMembersAreClassMembers)
          this.compute_members$ClassMemberMixin$interfaceMembers = P.LinkedHashMap_LinkedHashMap(null, null, null, O.Name, O.MemberSignature);
      }
      t1 = this.compute_members$ClassMemberMixin$interfaceMembersAreClassMembers;
      t2 = this.compute_members$ClassMemberMixin$computedMemberNames;
      t3 = this.compute_members$ClassMemberMixin$classMembers;
      return t1 ? new A.ClassMembersCreator(this, compiler, t2, t3, P.LinkedHashMap_LinkedHashMap(null, null, null, null, [P.Set, K.MessageKind])) : new A.InterfaceMembersCreator(this.compute_members$ClassMemberMixin$interfaceMembers, this, compiler, t2, t3, P.LinkedHashMap_LinkedHashMap(null, null, null, null, [P.Set, K.MessageKind]));
    },
    computeClassMember$3: function(compiler, $name, names) {
      var t1, set;
      if (this.isMemberComputed$1($name))
        return;
      if (!J.getInterceptor$asx($name).get$isEmpty($name) && C.JSString_methods.codeUnitAt$1($name, 0) === 95) {
        names.add$1(0, O.Name_Name($name, this.get$library(), false));
        names.add$1(0, O.Name_Name($name, this.get$library(), true));
      }
      this._prepareCreator$1(compiler).computeMembers$2($name, names);
      t1 = this.compute_members$ClassMemberMixin$computedMemberNames;
      if (t1 == null) {
        t1 = $.ClassMemberMixin__EMPTY_MEMBERS_NAMES;
        this.compute_members$ClassMemberMixin$computedMemberNames = t1;
        set = t1;
      } else
        set = t1;
      if ($name !== "call") {
        if (set === $.ClassMemberMixin__EMPTY_MEMBERS_NAMES) {
          set = H.setRuntimeTypeInfo(new N.Setlet(C.C__SetletMarker, null), [P.String]);
          this.compute_members$ClassMemberMixin$computedMemberNames = set;
        }
        J.add$1$ax(set, $name);
      }
    },
    computeAllClassMembers$1: function(compiler) {
      var creator, declaredMembers;
      if (this.compute_members$ClassMemberMixin$computedMemberNames == null && this.compute_members$ClassMemberMixin$classMembers != null)
        return;
      creator = this._prepareCreator$1(compiler);
      declaredMembers = creator.computeMembers$2(null, null);
      if (!creator.cls.get$isAbstract() && !declaredMembers.containsKey$1(C.PublicName_noSuchMethod_false))
        creator.checkInterfaceImplementation$0();
      this.compute_members$ClassMemberMixin$computedMemberNames = null;
    },
    isMemberComputed$1: function($name) {
      var t1 = this.compute_members$ClassMemberMixin$computedMemberNames;
      if (t1 == null)
        return this.compute_members$ClassMemberMixin$classMembers != null;
      else
        return $name === "call" || J.contains$1$asx(t1, $name) === true;
    },
    lookupClassMember$1: function($name) {
      return this.compute_members$ClassMemberMixin$classMembers.$index(0, $name);
    },
    forEachClassMember$1: function(f) {
      this.compute_members$ClassMemberMixin$classMembers.forEach$1(0, new A.ClassMemberMixin_forEachClassMember_closure(f));
    },
    lookupInterfaceMember$1: function($name) {
      var member;
      if (this.compute_members$ClassMemberMixin$interfaceMembersAreClassMembers) {
        member = this.compute_members$ClassMemberMixin$classMembers.$index(0, $name);
        if (member != null && member.get$isStatic())
          return;
        return member;
      }
      return this.compute_members$ClassMemberMixin$interfaceMembers.$index(0, $name);
    },
    forEachInterfaceMember$1: function(f) {
      if (this.compute_members$ClassMemberMixin$interfaceMembersAreClassMembers)
        this.compute_members$ClassMemberMixin$classMembers.forEach$1(0, new A.ClassMemberMixin_forEachInterfaceMember_closure(f));
      else
        this.compute_members$ClassMemberMixin$interfaceMembers.forEach$1(0, new A.ClassMemberMixin_forEachInterfaceMember_closure0(f));
    },
    $isClassElement: true,
    $isScopeContainerElement: true,
    $isElement: true,
    $isAstElement: true
  },
  ClassMemberMixin_forEachClassMember_closure: {
    "^": "Closure:19;f_0",
    call$2: function(_, member) {
      return this.f_0.call$1(member);
    },
    $isFunction: true
  },
  ClassMemberMixin_forEachInterfaceMember_closure: {
    "^": "Closure:19;f_0",
    call$2: function(_, member) {
      if (!member.get$isStatic())
        this.f_0.call$1(member);
    },
    $isFunction: true
  },
  ClassMemberMixin_forEachInterfaceMember_closure0: {
    "^": "Closure:19;f_1",
    call$2: function(_, member) {
      return this.f_1.call$1(member);
    },
    $isFunction: true
  },
  DeclaredMember: {
    "^": "Object;name>,element<,declarer<,type>,functionType<",
    get$isStatic: function() {
      return !this.element.get$isInstanceMember();
    },
    get$isGetter: function() {
      var t1 = this.element;
      if (!t1.get$isGetter())
        t1 = !this.name.isSetter && t1.kind === C.ElementKind_field_1;
      else
        t1 = true;
      return t1;
    },
    get$isSetter: function() {
      return this.name.isSetter;
    },
    get$isMethod: function() {
      return this.element.get$isFunction();
    },
    get$isDeclaredByField: function() {
      return this.element.kind === C.ElementKind_field_1;
    },
    get$isAbstract: function() {
      return false;
    },
    get$implementation: function(_) {
      return this;
    },
    inheritFrom$1: function(instance) {
      if (this.declarer.typeArguments.length === 0)
        return this;
      return this._newInheritedMember$1(instance);
    },
    _newInheritedMember$1: function(instance) {
      return new A.InheritedMember(this, instance);
    },
    get$declarations: function() {
      return H.setRuntimeTypeInfo([this], [O.Member]);
    },
    get$hashCode: function(_) {
      var t1, t2;
      t1 = this.element;
      t1 = t1.get$hashCode(t1);
      t2 = C.JSBool_methods.get$hashCode(this.name.isSetter);
      if (typeof t1 !== "number")
        return t1.$add();
      return t1 + 13 * t2;
    },
    $eq: function(_, other) {
      if (other == null)
        return false;
      if (!J.getInterceptor(other).$isMember)
        return false;
      return this.element === other.get$element() && this.name.isSetter === other.get$isSetter();
    },
    toString$0: function(_) {
      var sb = P.StringBuffer$("");
      this.printOn$2(sb, this.type);
      return sb._contents;
    },
    printOn$2: function(sb, type) {
      var t1;
      if (!this.element.get$isInstanceMember())
        sb.write$1("static ");
      if (this.get$isAbstract())
        sb.write$1("abstract ");
      if (this.get$isGetter()) {
        sb.write$1(type);
        sb.write$1(" get ");
        sb.write$1(this.name);
      } else {
        t1 = this.name;
        if (t1.isSetter) {
          sb.write$1("void set ");
          sb.write$1(t1.get$getter());
          sb.write$1("(");
          sb.write$1(type);
          sb.write$1(" _)");
        } else {
          t1 = t1.toString$0(0);
          type.toString;
          sb.write$1(new V.TypeDeclarationFormatter(null, null).format$2(0, type, t1));
        }
      }
    },
    $isDeclaredMember: true,
    $isMember: true
  },
  DeclaredAbstractMember: {
    "^": "DeclaredMember;implementation>,name,element,declarer,type,functionType",
    get$isAbstract: function() {
      return true;
    },
    _newInheritedMember$1: function(instance) {
      var t1 = this.implementation;
      t1 = t1 != null ? t1.inheritFrom$1(instance) : null;
      return new A.InheritedAbstractMember(t1, this, instance);
    }
  },
  InheritedMember: {
    "^": "Object;declaration<,instance",
    get$element: function() {
      return this.declaration.element;
    },
    get$name: function(_) {
      return this.declaration.name;
    },
    get$declarer: function() {
      return this.instance;
    },
    get$isStatic: function() {
      return false;
    },
    get$isSetter: function() {
      return this.declaration.name.isSetter;
    },
    get$isGetter: function() {
      return this.declaration.get$isGetter();
    },
    get$isMethod: function() {
      return this.declaration.element.get$isFunction();
    },
    get$isDeclaredByField: function() {
      return this.declaration.element.kind === C.ElementKind_field_1;
    },
    get$isAbstract: function() {
      return false;
    },
    get$implementation: function(_) {
      return this;
    },
    get$type: function(_) {
      var t1, t2;
      t1 = this.declaration.type;
      t2 = this.instance;
      t1.toString;
      return t1.subst$2(t2.typeArguments, t2.get$element().get$typeVariables());
    },
    get$functionType: function() {
      var t1, t2;
      t1 = this.declaration.functionType;
      t2 = this.instance;
      t1.toString;
      return t1.subst$2(t2.typeArguments, t2.get$element().get$typeVariables());
    },
    inheritFrom$1: function(newInstance) {
      return this._newInheritedMember$1(newInstance);
    },
    _newInheritedMember$1: function(newInstance) {
      var t1 = this.instance;
      t1.toString;
      return new A.InheritedMember(this.declaration, t1.subst$2(newInstance.typeArguments, newInstance.get$element().get$typeVariables()));
    },
    get$declarations: function() {
      return H.setRuntimeTypeInfo([this], [O.Member]);
    },
    get$hashCode: function(_) {
      var t1, t2, t3;
      t1 = this.declaration;
      t2 = t1.element;
      t2 = t2.get$hashCode(t2);
      t1 = C.JSBool_methods.get$hashCode(t1.name.isSetter);
      if (typeof t2 !== "number")
        return t2.$add();
      t3 = J.get$hashCode$(this.instance);
      if (typeof t3 !== "number")
        return H.iae(t3);
      return t2 + 13 * t1 + 17 * t3;
    },
    $eq: function(_, other) {
      if (other == null)
        return false;
      if (!J.getInterceptor(other).$isInheritedMember)
        return false;
      return this.declaration.$eq(0, other.declaration) && J.$eq(this.instance, other.instance);
    },
    toString$0: function(_) {
      var sb, t1;
      sb = P.StringBuffer$("");
      t1 = this.instance;
      this.declaration.printOn$2(sb, t1);
      sb.write$1(" inherited from " + J.toString$0(t1));
      return sb._contents;
    },
    $isInheritedMember: true,
    $isDeclaredMember: true,
    $isMember: true
  },
  InheritedAbstractMember: {
    "^": "InheritedMember;implementation>,declaration,instance",
    get$isAbstract: function() {
      return true;
    },
    _newInheritedMember$1: function(newInstance) {
      var t1, t2;
      t1 = this.instance;
      t1.toString;
      t1 = t1.subst$2(newInstance.typeArguments, newInstance.get$element().get$typeVariables());
      t2 = this.implementation;
      t2 = t2 != null ? t2.inheritFrom$1(newInstance) : null;
      return new A.InheritedAbstractMember(t2, this.declaration, t1);
    }
  },
  AbstractSyntheticMember: {
    "^": "Object;",
    get$declarations: function() {
      return this.inheritedMembers;
    },
    get$name: function(_) {
      var t1 = this.inheritedMembers;
      return J.get$name$x(t1.get$first(t1));
    }
  },
  SyntheticMember: {
    "^": "AbstractSyntheticMember;type>,functionType<,inheritedMembers",
    get$isSetter: function() {
      var t1 = this.inheritedMembers;
      return t1.get$first(t1).get$isSetter();
    },
    get$isGetter: function() {
      var t1 = this.inheritedMembers;
      return t1.get$first(t1).get$isGetter();
    },
    get$isMethod: function() {
      var t1 = this.inheritedMembers;
      return t1.get$first(t1).get$isMethod();
    },
    get$isErroneous: function() {
      return false;
    },
    toString$0: function(_) {
      var t1, t2, t3;
      t1 = this.type;
      t2 = this.inheritedMembers;
      t3 = J.toString$0(J.get$name$x(t2.get$first(t2)));
      t1.toString;
      return new V.TypeDeclarationFormatter(null, null).format$2(0, t1, t3) + " synthesized from " + P.IterableBase_iterableToShortString(t2, "(", ")");
    }
  },
  ErroneousMember: {
    "^": "AbstractSyntheticMember;inheritedMembers",
    get$type: function(_) {
      return this.get$functionType();
    },
    get$functionType: function() {
      throw H.wrapException(P.UnsupportedError$("Erroneous members have no type."));
    },
    get$isSetter: function() {
      return false;
    },
    get$isGetter: function() {
      return false;
    },
    get$isMethod: function() {
      return false;
    },
    get$isErroneous: function() {
      return true;
    },
    toString$0: function(_) {
      var t1 = this.inheritedMembers;
      return "erroneous member '" + J.toString$0(J.get$name$x(t1.get$first(t1))) + "' synthesized from " + P.IterableBase_iterableToShortString(t1, "(", ")");
    }
  }
}],
["scanner", "package:compiler/implementation/scanner/scannerlib.dart", , Y, {
  "^": "",
  KeywordState_KEYWORD_STATE: function() {
    var t1, strings, i, t2;
    t1 = $.KeywordState__KEYWORD_STATE;
    if (t1 == null) {
      strings = H.setRuntimeTypeInfo(Array(54), [P.String]);
      for (t1 = strings.length, i = 0; i < 54; ++i) {
        t2 = C.List_0[i];
        if (i >= t1)
          return H.ioore(strings, i);
        strings[i] = t2.syntax;
      }
      H.IterableMixinWorkaround_sortList(strings, new Y.KeywordState_KEYWORD_STATE_closure());
      t1 = Y.KeywordState_computeKeywordStateTable(0, strings, 0, t1);
      $.KeywordState__KEYWORD_STATE = t1;
    }
    return t1;
  },
  KeywordState_computeKeywordStateTable: function(start, strings, offset, $length) {
    var result, t1, t2, t3, i, chunk, chunkStart, isLeaf, t4, t5, c;
    result = Array(26);
    result.$builtinTypeInfo = [Y.KeywordState];
    for (t1 = offset + $length, t2 = strings.length, t3 = start + 1, i = offset, chunk = 0, chunkStart = -1, isLeaf = false; i < t1; ++i) {
      if (i < 0 || i >= t2)
        return H.ioore(strings, i);
      t4 = strings[i];
      t5 = t4.length;
      if (t5 === start)
        isLeaf = true;
      if (t5 > start) {
        t4.toString;
        if (start >= t5)
          H.throwExpression(P.RangeError$value(start));
        c = t4.charCodeAt(start);
        if (chunk !== c) {
          if (chunkStart !== -1) {
            t4 = chunk - 97;
            t5 = Y.KeywordState_computeKeywordStateTable(t3, strings, chunkStart, i - chunkStart);
            if (t4 < 0 || t4 >= 26)
              return H.ioore(result, t4);
            result[t4] = t5;
          }
          chunkStart = i;
          chunk = c;
        }
      }
    }
    if (chunkStart !== -1) {
      t4 = chunk - 97;
      t1 = Y.KeywordState_computeKeywordStateTable(t3, strings, chunkStart, t1 - chunkStart);
      if (t4 < 0 || t4 >= 26)
        return H.ioore(result, t4);
      result[t4] = t1;
    } else {
      if (offset < 0 || offset >= t2)
        return H.ioore(strings, offset);
      t1 = strings[offset];
      t2 = $.Keyword__keywords;
      if (t2 == null) {
        t2 = Y.Keyword_computeKeywordMap();
        $.Keyword__keywords = t2;
      }
      return new Y.LeafKeywordState(t2.$index(0, t1));
    }
    if (isLeaf) {
      if (offset < 0 || offset >= t2)
        return H.ioore(strings, offset);
      t1 = strings[offset];
      if (t1 == null)
        t1 = null;
      else {
        t2 = $.Keyword__keywords;
        if (t2 == null) {
          t2 = Y.Keyword_computeKeywordMap();
          $.Keyword__keywords = t2;
        }
        t1 = t2.$index(0, t1);
      }
      return new Y.ArrayKeywordState(result, t1);
    } else
      return new Y.ArrayKeywordState(result, null);
  },
  closeBraceFor: function(openBrace) {
    return C.Map_4u8XL.$index(0, openBrace);
  },
  parse: function(diagnosticListener, element, doParse) {
    var listener, e, exception, t1, t2, t3, $name, t4, t5;
    listener = new Y.NodeListener(true, null, diagnosticListener, element.get$compilationUnit(), new B.StringValidator(diagnosticListener), C.C_Link6, C.C_Link3, C.C_Link2, C.C_Link7, false);
    listener.set$memberErrors(listener.get$memberErrors().prepend$1(false));
    try {
      doParse.call$1(new Y.Parser(listener, true));
    } catch (exception) {
      t1 = H.unwrapException(exception);
      if (!!J.getInterceptor(t1).$isParserError) {
        e = t1;
        if (!!J.getInterceptor(element).$isPartialElement)
          element.set$hasParseError(true);
        t1 = J.get$position$x(element);
        t2 = J.get$reason$x(e);
        t3 = $.Node__HASH_COUNTER + 1;
        $.Node__HASH_COUNTER = t3;
        $name = new Y.Identifier(t1, null, t3);
        t4 = E.LinkEntry$($name, C.C_Link3, H.getTypeArgumentByIndex(C.C_Link3, 0));
        ++t3;
        $.Node__HASH_COUNTER = t3;
        t5 = t3 + 1;
        $.Node__HASH_COUNTER = t5;
        return new Y.ErrorNode(t1, t2, $name, new Y.NodeList(t4, null, null, null, t3), t5);
      } else
        throw exception;
    }

    return listener.popNode$0();
  },
  Scanner_Scanner: function(file, includeComments) {
    var t1, t2;
    if (!!J.getInterceptor(file).$isUtf8BytesSourceFile) {
      t1 = new Y.SymbolToken(C.PrecedenceInfo_EOF_0_0, -1, null);
      t2 = new Y.Utf8BytesScanner(file.content, -1, 0, -1, 0, -1, -1, C.C_Link13, includeComments, -1, t1, null, file, H.setRuntimeTypeInfo([0], [P.$int]));
      t2.tail = t1;
      t2.Utf8BytesScanner$2$includeComments(file, includeComments);
      return t2;
    } else {
      t1 = new Y.SymbolToken(C.PrecedenceInfo_EOF_0_0, -1, null);
      t2 = new Y.StringScanner(file.slowText$0(), -1, C.C_Link13, includeComments, -1, t1, null, file, H.setRuntimeTypeInfo([0], [P.$int]));
      t2.tail = t1;
      t2.ensureZeroTermination$0();
      return t2;
    }
  },
  LazySubstring_LazySubstring: function(data, start, $length, b) {
    var fields;
    if (start < 1048576 && $length < 512) {
      fields = (start << 9 | $length) << 1 >>> 0;
      if (b)
        fields = (fields | 1) >>> 0;
      return new Y.CompactLazySubstring(data, fields);
    } else
      return new Y.FullLazySubstring(data, start, $length, b);
  },
  isUserDefinableOperator: function(value) {
    return Y.isBinaryOperator(value) || value === "-" || value === "[]=" || value === "~";
  },
  isBinaryOperator: function(value) {
    return value === "==" || value === "[]" || value === "*" || value === "/" || value === "%" || value === "~/" || value === "+" || value === "<<" || value === ">>" || value === ">=" || value === ">" || value === "<=" || value === "<" || value === "&" || value === "^" || value === "|";
  },
  ArrayBasedScanner: {
    "^": "AbstractScanner;",
    appendPrecedenceToken$1: function(info) {
      var t1, t2;
      t1 = this.tail;
      t2 = new Y.SymbolToken(info, this.tokenStart, null);
      t1.next = t2;
      this.tail = t2;
    },
    select$3: function(_, choice, yes, no) {
      var next = this.advance$0();
      if (next === choice) {
        this.appendPrecedenceToken$1(yes);
        return this.advance$0();
      } else {
        this.appendPrecedenceToken$1(no);
        return next;
      }
    },
    appendKeywordToken$1: function(keyword) {
      var syntax, t1, t2;
      syntax = keyword.syntax;
      if (syntax === "this" || syntax === "super")
        this.discardOpenLt$0();
      t1 = this.tail;
      t2 = new Y.KeywordToken(keyword, this.tokenStart, null);
      t1.next = t2;
      this.tail = t2;
    },
    appendEofToken$0: function() {
      var t1, t2;
      this.tokenStart = this.get$stringOffset();
      this.discardOpenLt$0();
      for (; t1 = this.groupingStack, !t1.get$isEmpty(t1);) {
        t1 = this.groupingStack;
        this.unmatchedBeginGroup$1(t1.get$head(t1));
        this.groupingStack = this.groupingStack.get$tail();
      }
      t1 = this.tail;
      t2 = new Y.SymbolToken(C.PrecedenceInfo_EOF_0_0, this.tokenStart, null);
      t1.next = t2;
      this.tail = t2;
      t2.next = t2;
    },
    appendWhiteSpace$1: function(next) {
      if (next === 10 && this.file != null)
        this.lineStarts.push(this.get$stringOffset() + 1);
    },
    lineFeedInMultiline$0: function() {
      if (this.file != null)
        this.lineStarts.push(this.get$stringOffset() + 1);
    },
    appendBeginGroup$1: function(info) {
      var token = new Y.BeginGroupToken(null, info, this.tokenStart, null);
      this.tail.next = token;
      this.tail = token;
      if (info.kind !== 60)
        this.discardOpenLt$0();
      this.groupingStack = this.groupingStack.prepend$1(token);
    },
    appendEndGroup$2: function(info, openKind) {
      var $close, t1, begin;
      this.discardBeginGroupUntil$1(openKind);
      this.appendPrecedenceToken$1(info);
      $close = this.tail;
      t1 = this.groupingStack;
      if (t1.get$isEmpty(t1))
        return this.advance$0();
      t1 = this.groupingStack;
      begin = t1.get$head(t1);
      if (begin.get$info().kind !== openKind) {
        begin.set$endGroup($close);
        this.groupingStack = this.groupingStack.get$tail();
        return 2;
      }
      begin.set$endGroup($close);
      this.groupingStack = this.groupingStack.get$tail();
      return this.advance$0();
    },
    discardBeginGroupUntil$1: function(openKind) {
      var t1, t2, begin;
      for (t1 = openKind === 123; t2 = this.groupingStack, !t2.get$isEmpty(t2);) {
        this.discardOpenLt$0();
        t2 = this.groupingStack;
        if (t2.get$isEmpty(t2))
          return;
        t2 = this.groupingStack;
        begin = t2.get$head(t2);
        if (openKind === begin.get$info().kind)
          return;
        if (t1 && begin.get$info().kind === 128)
          return;
        this.unmatchedBeginGroup$1(begin);
        this.groupingStack = this.groupingStack.get$tail();
      }
    },
    appendGt$1: function(info) {
      var t1;
      this.appendPrecedenceToken$1(info);
      t1 = this.groupingStack;
      if (t1.get$isEmpty(t1))
        return;
      t1 = this.groupingStack;
      if (J.get$kind$x(t1.get$head(t1)) === 60) {
        t1 = this.groupingStack;
        t1.get$head(t1).set$endGroup(this.tail);
        this.groupingStack = this.groupingStack.get$tail();
      }
    },
    appendGtGt$1: function(info) {
      var t1;
      this.appendPrecedenceToken$1(info);
      t1 = this.groupingStack;
      if (t1.get$isEmpty(t1))
        return;
      t1 = this.groupingStack;
      if (J.get$kind$x(t1.get$head(t1)) === 60)
        this.groupingStack = this.groupingStack.get$tail();
      t1 = this.groupingStack;
      if (t1.get$isEmpty(t1))
        return;
      t1 = this.groupingStack;
      if (J.get$kind$x(t1.get$head(t1)) === 60) {
        t1 = this.groupingStack;
        t1.get$head(t1).set$endGroup(this.tail);
        this.groupingStack = this.groupingStack.get$tail();
      }
    },
    appendComment$2: function(start, asciiOnly) {
      if (!this.includeComments)
        return;
      this.appendSubstringToken$3(C.PrecedenceInfo_comment_0_158, start, asciiOnly);
    },
    appendErrorToken$1: function(token) {
      this.tail.next = token;
      this.tail = token;
    },
    discardOpenLt$0: function() {
      while (true) {
        var t1 = this.groupingStack;
        if (!t1.get$isEmpty(t1)) {
          t1 = this.groupingStack;
          t1 = J.get$kind$x(t1.get$head(t1)) === 60;
        } else
          t1 = false;
        if (!t1)
          break;
        this.groupingStack = this.groupingStack.get$tail();
      }
    }
  },
  ClassElementParser: {
    "^": "PartialParser;listener,mayParseFunctionExpressions",
    parseClassBody$1: function(token) {
      return Y.Parser.prototype.parseClassBody$1.call(this, token);
    }
  },
  PartialClassElement: {
    "^": "ClassElementX;beginToken<,endToken,cachedNode<,localMembersReversed,localScope,localMembersCache,id,supertype,interfaces,nativeTagInfo,supertypeLoadState,resolutionState,isProxy,hasIncompleteHierarchy,backendMembers,allSupertypesAndSelf,compute_members$ClassMemberMixin$computedMemberNames,compute_members$ClassMemberMixin$interfaceMembersAreClassMembers,compute_members$ClassMemberMixin$classMembers,compute_members$ClassMemberMixin$interfaceMembers,modelx$PatchMixin$patch,modelx$PatchMixin$origin,modelx$TypeDeclarationElementX$thisTypeCache,modelx$TypeDeclarationElementX$rawTypeCache,resolution$AnalyzableElementX$_treeElements,name,kind,enclosingElement,hashCode,metadata,_fixedBackendName,_isNative",
    set$supertypeLoadState: function(state) {
      this.supertypeLoadState = state;
    },
    set$resolutionState: function(state) {
      this.resolutionState = state;
    },
    get$node: function() {
      return this.cachedNode;
    },
    parseNode$1: function(compiler) {
      var t1 = this.cachedNode;
      if (t1 != null)
        return t1;
      compiler.withCurrentElement$2(this, new Y.PartialClassElement_parseNode_closure(this, compiler));
      return this.cachedNode;
    },
    get$position: function(_) {
      return this.beginToken;
    },
    get$modifiers: function() {
      var t1 = this.cachedNode;
      return t1 != null ? t1.modifiers : $.get$Modifiers_EMPTY();
    },
    accept$1: function(_, visitor) {
      return visitor.visitClassElement$1(this);
    }
  },
  PartialClassElement_parseNode_closure: {
    "^": "Closure:23;this_0,compiler_1",
    call$0: function() {
      var t1, t2;
      t1 = this.compiler_1;
      t2 = this.this_0;
      t1.parser.measure$1(new Y.PartialClassElement_parseNode__closure(t2, t1));
      t1.patchParser.measure$1(new Y.PartialClassElement_parseNode__closure0(t2, t1));
    },
    $isFunction: true
  },
  PartialClassElement_parseNode__closure: {
    "^": "Closure:23;this_2,compiler_3",
    call$0: function() {
      var t1, t2, listener;
      t1 = this.compiler_3;
      t2 = this.this_2;
      listener = new Y.MemberListener(t2, false, null, t1, t2.get$compilationUnit(), new B.StringValidator(t1), C.C_Link6, C.C_Link3, C.C_Link2, C.C_Link7, false);
      new Y.ClassElementParser(listener, true).parseTopLevelDeclaration$1(t2.beginToken);
      t2.cachedNode = listener.popNode$0();
    },
    $isFunction: true
  },
  PartialClassElement_parseNode__closure0: {
    "^": "Closure:23;this_4,compiler_5",
    call$0: function() {
      var t1 = this.this_4;
      if (t1.get$isPatched())
        this.compiler_5.patchParser.parsePatchClassNode$1(t1.modelx$PatchMixin$patch);
    },
    $isFunction: true
  },
  MemberListener: {
    "^": "NodeListener;enclosingElement<,throwOnFatalError,idGenerator,listener,compilationUnitElement,stringValidator,interpolationScope,nodes,metadata,memberErrors,suppressParseErrors",
    isConstructorName$1: function(nameNode) {
      var t1, $name;
      if (this.enclosingElement.kind !== C.ElementKind_class_4)
        return false;
      if (nameNode.asIdentifier$0() != null) {
        t1 = nameNode.asIdentifier$0().token;
        $name = t1.get$value(t1);
      } else {
        t1 = nameNode.asSend$0().receiver.asIdentifier$0().token;
        $name = t1.get$value(t1);
      }
      t1 = this.enclosingElement.name;
      return t1 == null ? $name == null : t1 === $name;
    },
    getMethodNameHack$1: function(methodName) {
      var send, t1, receiver, selector, operator, t2, t3;
      send = methodName.asSend$0();
      if (send == null) {
        if (this.isConstructorName$1(methodName))
          return "";
        t1 = methodName.asIdentifier$0().token;
        return t1.get$value(t1);
      }
      t1 = send.receiver;
      receiver = t1.asIdentifier$0();
      selector = send.selector.asIdentifier$0();
      operator = selector.asOperator$0();
      if (operator != null) {
        t1 = operator.token;
        t2 = t1.next.next.get$stringValue();
        return O.Elements_constructOperatorName(t1.get$value(t1), t2 === ")");
      } else {
        if (receiver != null) {
          t2 = receiver.token;
          t2 = t2.get$value(t2);
          t3 = this.enclosingElement.name;
          t3 = t2 == null ? t3 != null : t2 !== t3;
          t2 = t3;
        } else
          t2 = true;
        if (t2)
          this.listener.reportDiagnosticInternal$4(t1, C.MessageKind_AHF, P.LinkedHashMap_LinkedHashMap$_literal(["name", this.enclosingElement.name], null, null), C.Diagnostic_1_error);
        t1 = selector.token;
        return t1.get$value(t1);
      }
    },
    endMethod$3: function(getOrSet, beginToken, endToken) {
      var method, isConstructor, $name, t1, t2, t3, memberElement, kind, t4;
      Y.NodeListener.prototype.endMethod$3.call(this, getOrSet, beginToken, endToken);
      method = this.popNode$0();
      this.pushNode$1(null);
      isConstructor = this.isConstructorName$1(method.get$name(method));
      $name = this.getMethodNameHack$1(method.get$name(method));
      if (isConstructor) {
        if (getOrSet != null)
          this.reportFatalError$2(getOrSet, "illegal modifier");
        t1 = method.get$modifiers();
        t2 = H.setRuntimeTypeInfo([], [O.FunctionElement]);
        t3 = $.ElementX_elementHashCode + 1;
        $.ElementX_elementHashCode = t3;
        memberElement = new Y.PartialConstructorElement(null, null, null, null, null, false, null, null, null, null, null, t1, t2, null, false, null, null, null, $name, C.ElementKind_generative_constructor_16, this.enclosingElement, t3, C.C_Link2, null, false);
        memberElement.init$3(beginToken, null, endToken);
      } else {
        if (getOrSet != null)
          kind = getOrSet.get$stringValue() === "get" ? C.ElementKind_getter_0 : C.ElementKind_setter_0;
        else
          kind = C.ElementKind_function_2;
        t1 = method.get$modifiers();
        t2 = method.hasBody$0();
        t3 = H.setRuntimeTypeInfo([], [O.FunctionElement]);
        t4 = $.ElementX_elementHashCode + 1;
        $.ElementX_elementHashCode = t4;
        memberElement = new Y.PartialFunctionElement(null, null, null, null, null, false, null, null, t1, t3, null, !t2, null, null, null, $name, kind, this.enclosingElement, t4, C.C_Link2, null, false);
        memberElement.init$3(beginToken, getOrSet, endToken);
      }
      this.addMember$1(memberElement);
    },
    endFactoryMethod$2: function(beginToken, endToken) {
      var method, $name, singleIdentifierName, t1, t2, t3, memberElement;
      Y.NodeListener.prototype.endFactoryMethod$2.call(this, beginToken, endToken);
      method = this.popNode$0();
      this.pushNode$1(null);
      $name = this.getMethodNameHack$1(method.get$name(method));
      singleIdentifierName = method.get$name(method).asIdentifier$0();
      if (singleIdentifierName != null) {
        t1 = singleIdentifierName.token;
        t1 = t1.get$value(t1);
        t1 = t1 == null ? $name == null : t1 === $name;
      } else
        t1 = false;
      if (t1) {
        t1 = this.enclosingElement.name;
        if ($name == null ? t1 != null : $name !== t1)
          this.listener.reportDiagnosticInternal$4(singleIdentifierName, C.MessageKind_wAS, P.LinkedHashMap_LinkedHashMap$_literal(["name", t1], null, null), C.Diagnostic_1_error);
      }
      t1 = method.get$modifiers();
      t2 = H.setRuntimeTypeInfo([], [O.FunctionElement]);
      t3 = $.ElementX_elementHashCode + 1;
      $.ElementX_elementHashCode = t3;
      memberElement = new Y.PartialConstructorElement(null, null, null, null, null, false, null, null, null, null, null, t1, t2, null, false, null, null, null, $name, C.ElementKind_function_2, this.enclosingElement, t3, C.C_Link2, null, false);
      memberElement.init$3(beginToken, null, endToken);
      this.addMember$1(memberElement);
    },
    endFields$3: function(count, beginToken, endToken) {
      var t1, hasParseError, variableDefinitions, modifiers;
      t1 = this.memberErrors;
      hasParseError = t1.get$head(t1);
      Y.NodeListener.prototype.endFields$3.call(this, count, beginToken, endToken);
      variableDefinitions = this.popNode$0();
      modifiers = variableDefinitions.get$modifiers();
      this.pushNode$1(null);
      this.buildFieldElements$7(modifiers, variableDefinitions.get$definitions(), this.enclosingElement, new Y.MemberListener_endFields_buildFieldElement(this), beginToken, endToken, hasParseError);
    },
    endInitializer$1: function(assignmentOperator) {
      this.pushNode$1(null);
      Y.NodeListener.prototype.endInitializer$1.call(this, assignmentOperator);
    },
    endInitializers$3: function(count, beginToken, endToken) {
      this.pushNode$1(null);
    },
    addMember$1: function(memberElement) {
      var link, t1;
      for (link = this.metadata; !link.get$isEmpty(link); link = link.get$tail()) {
        t1 = link.get$head(link);
        t1.set$annotatedElement(memberElement);
        memberElement.addMetadataInternal$1(t1);
      }
      this.metadata = C.C_Link2;
      this.enclosingElement.addMember$2(memberElement, this.listener);
    },
    endMetadata$3: function(beginToken, periodBeforeName, endToken) {
      this.popNode$0();
      if (periodBeforeName != null)
        this.popNode$0();
      this.popNode$0();
      this.metadata = this.metadata.prepend$1(new Y.PartialMetadataAnnotation(beginToken, endToken, null, null, null, 0));
    }
  },
  MemberListener_endFields_buildFieldElement: {
    "^": "Closure:245;this_0",
    call$2: function($name, fields) {
      var t1, t2, t3, t4, t5;
      t1 = this.this_0;
      t2 = H.setRuntimeTypeInfo([], [O.FunctionElement]);
      t3 = $name.token;
      t4 = t3.get$value(t3);
      t5 = $.ElementX_elementHashCode + 1;
      $.ElementX_elementHashCode = t5;
      t1.addMember$1(new U.FieldElementX(t2, null, t3, fields, null, null, t4, C.ElementKind_field_1, t1.enclosingElement, t5, C.C_Link2, null, false));
    },
    $isFunction: true
  },
  Keyword: {
    "^": "Object;syntax<,isPseudo,isBuiltIn,info<",
    toString$0: function(_) {
      return this.syntax;
    },
    static: {"^": "Keyword_values<,Keyword__keywords", Keyword_keywords: function() {
        var t1 = $.Keyword__keywords;
        if (t1 == null) {
          t1 = Y.Keyword_computeKeywordMap();
          $.Keyword__keywords = t1;
        }
        return t1;
      }, Keyword_computeKeywordMap: function() {
        var result, t1, keyword;
        result = P.LinkedHashMap_LinkedHashMap(null, null, null, P.String, Y.Keyword);
        for (t1 = H.setRuntimeTypeInfo(new H.ListIterator(C.List_0, 54, 0, null), [H.getTypeArgumentByIndex(C.List_0, 0)]); t1.moveNext$0();) {
          keyword = t1.__internal$_current;
          result.$indexSet(0, keyword.get$syntax(), keyword);
        }
        return result;
      }}
  },
  KeywordState: {
    "^": "Object;"
  },
  KeywordState_KEYWORD_STATE_closure: {
    "^": "Closure:19;",
    call$2: function(a, b) {
      return J.compareTo$1$ns(a, b);
    },
    $isFunction: true
  },
  ArrayKeywordState: {
    "^": "KeywordState;table,keyword",
    next$1: [function(c) {
      var t1, t2;
      t1 = this.table;
      if (typeof c !== "number")
        return c.$sub();
      t2 = c - 97;
      if (t2 < 0 || t2 >= 26)
        return H.ioore(t1, t2);
      return t1[t2];
    }, "call$1", "get$next", 2, 0, 246],
    toString$0: function(_) {
      var sb, t1, foo, i;
      sb = P.StringBuffer$("");
      sb.write$1("[");
      t1 = this.keyword;
      if (t1 != null) {
        sb.write$1("*");
        sb.write$1(t1);
        sb.write$1(" ");
      }
      foo = this.table;
      for (i = 0; i < 26; ++i)
        if (foo[i] != null) {
          t1 = H.Primitives_stringFromCharCodes([i + 97]) + ": " + J.toString$0(foo[i]) + "; ";
          sb._contents += t1;
        }
      sb.write$1("]");
      return sb._contents;
    }
  },
  LeafKeywordState: {
    "^": "KeywordState;keyword",
    next$1: [function(c) {
      return;
    }, "call$1", "get$next", 2, 0, 246],
    toString$0: function(_) {
      return this.keyword.syntax;
    }
  },
  Listener: {
    "^": "Object;",
    endArguments$3: function(count, beginToken, endToken) {
    },
    endBlock$3: function(count, beginToken, endToken) {
    },
    beginCascade$1: function(token) {
    },
    endCascade$0: function() {
    },
    endClassBody$3: function(memberCount, beginToken, endToken) {
    },
    endCompilationUnit$2: function(count, token) {
    },
    endConstructorReference$3: function(start, periodBeforeName, endToken) {
    },
    endDoWhileStatement$3: function(doKeyword, whileKeyword, endToken) {
    },
    endExpressionStatement$1: function(token) {
    },
    endFormalParameter$1: function(thisKeyword) {
    },
    handleNoFormalParameters$1: function(token) {
    },
    endFormalParameters$3: function(count, beginToken, endToken) {
    },
    endForStatement$3: function(updateExpressionCount, beginToken, endToken) {
    },
    endForIn$3: function(beginToken, inKeyword, endToken) {
    },
    endFunction$2: function(getOrSet, endToken) {
    },
    endFunctionDeclaration$1: function(token) {
    },
    endFunctionBody$3: function(count, beginToken, endToken) {
    },
    handleNoFunctionBody$1: function(token) {
    },
    skippedFunctionBody$1: function(token) {
    },
    endIfStatement$2: function(ifToken, elseToken) {
    },
    endInitializer$1: function(assignmentOperator) {
    },
    endInitializers$3: function(count, beginToken, endToken) {
    },
    handleNoInitializers$0: function() {
    },
    handleLabel$1: function(token) {
    },
    endLabeledStatement$1: function(labelCount) {
    },
    endLiteralMapEntry$2: function(colon, endToken) {
    },
    endMetadataStar$2: function(count, forParameter) {
    },
    endOptionalFormalParameters$3: function(count, beginToken, endToken) {
    },
    endRedirectingFactoryBody$2: function(beginToken, endToken) {
    },
    endReturnStatement$3: function(hasExpression, beginToken, endToken) {
    },
    endSend$1: function(token) {
    },
    endSwitchStatement$2: function(switchKeyword, endToken) {
    },
    endSwitchBlock$3: function(caseCount, beginToken, endToken) {
    },
    endLiteralSymbol$2: function(hashToken, identifierCount) {
    },
    endThrowExpression$2: function(throwToken, endToken) {
    },
    endRethrowStatement$2: function(throwToken, endToken) {
    },
    handleCaseMatch$2: function(caseKeyword, colon) {
    },
    handleCatchBlock$2: function(onKeyword, catchKeyword) {
    },
    endTryStatement$3: function(catchCount, tryKeyword, finallyKeyword) {
    },
    endUnamedFunction$1: function(token) {
    },
    endVariablesDeclaration$2: function(count, endToken) {
    },
    endWhileStatement$2: function(whileKeyword, endToken) {
    },
    handleAsOperator$2: function(operathor, endToken) {
    },
    handleAssignmentExpression$1: function(token) {
    },
    handleBinaryExpression$1: function(token) {
    },
    handleConditionalExpression$2: function(question, colon) {
    },
    handleConstExpression$1: function(token) {
    },
    handleFunctionTypedFormalParameter$1: function(token) {
    },
    handleIndexedExpression$2: function(openCurlyBracket, closeCurlyBracket) {
    },
    handleIsOperator$3: function(operathor, not, endToken) {
    },
    handleLiteralBool$1: function(token) {
    },
    handleBreakStatement$3: function(hasTarget, breakKeyword, endToken) {
    },
    handleContinueStatement$3: function(hasTarget, continueKeyword, endToken) {
    },
    handleEmptyStatement$1: function(token) {
    },
    handleAssertStatement$2: function(assertKeyword, semicolonToken) {
    },
    handleLiteralDouble$1: function(token) {
    },
    handleLiteralInt$1: function(token) {
    },
    handleLiteralList$4: function(count, beginToken, constKeyword, endToken) {
    },
    handleLiteralMap$4: function(count, beginToken, constKeyword, endToken) {
    },
    handleLiteralNull$1: function(token) {
    },
    handleNamedArgument$1: function(colon) {
    },
    handleNewExpression$1: function(token) {
    },
    handleNoArguments$1: function(token) {
    },
    handleNoExpression$1: function(token) {
    },
    handleOperator$1: function(token) {
    },
    handleOperatorName$2: function(operatorKeyword, token) {
    },
    handleSuperExpression$1: function(token) {
    },
    handleSwitchCase$6: function(labelCount, expressionCount, defaultKeyword, statementCount, firstToken, endToken) {
    },
    handleThisExpression$1: function(token) {
    },
    handleUnaryPostfixAssignmentExpression$1: function(token) {
    },
    handleUnaryPrefixExpression$1: function(token) {
    },
    handleUnaryPrefixAssignmentExpression$1: function(token) {
    },
    handleValuedFormalParameter$2: function(equals, token) {
    },
    synthesizeIdentifier$1: function(token) {
      var synthesizedToken = new Y.StringToken(Y.StringToken_canonicalizedString("?", false), C.PrecedenceInfo_identifier_0_97, token.charOffset, null);
      synthesizedToken.next = token.next;
      return synthesizedToken;
    },
    skipToEof$1: function(token) {
      for (; token.get$info() !== C.PrecedenceInfo_EOF_0_0;)
        token = token.next;
      return token;
    },
    recoverableError$2: function(token, message) {
      this.error$2(0, message, token);
    },
    error$2: [function(_, message, token) {
      throw H.wrapException(Y.ParserError$(H.S(message) + " @ " + token.charOffset));
    }, "call$2", "get$error", 4, 0, 247],
    reportError$3: function(spannable, messageKind, $arguments) {
      var message = K.Message$(messageKind, $arguments, true).computeMessage$0();
      this.recoverableError$2(spannable, message);
    },
    reportErrorToken$1: function(token) {
      var hex, t1, start, kind, $arguments, begin;
      if (!!token.$isBadInputToken) {
        hex = J.toRadixString$1$n(token.character, 16);
        t1 = hex.length;
        this.reportError$3(token, C.MessageKind_EDB, P.LinkedHashMap_LinkedHashMap$_literal(["characterHex", t1 < 4 ? C.JSString_methods.substring$1("0000", t1) + hex : hex], null, null));
      } else if (!!token.$isUnterminatedToken) {
        start = token.start;
        switch (start) {
          case "1e":
            kind = C.MessageKind_gsm;
            $arguments = C.Map_empty;
            break;
          case "\"":
          case "'":
          case "\"\"\"":
          case "'''":
          case "r\"":
          case "r'":
          case "r\"\"\"":
          case "r'''":
            $arguments = P.LinkedHashMap_LinkedHashMap$_literal(["quote", start], null, null);
            kind = C.MessageKind_IqA;
            break;
          case "0x":
            kind = C.MessageKind_e3S;
            $arguments = C.Map_empty;
            break;
          case "$":
            kind = C.MessageKind_IMh;
            $arguments = C.Map_empty;
            break;
          case "/*":
            kind = C.MessageKind_4DV;
            $arguments = C.Map_empty;
            break;
          default:
            kind = C.MessageKind_Qcp;
            $arguments = C.Map_empty;
            break;
        }
        this.reportError$3(token, kind, $arguments);
      } else if (!!token.$isUnmatchedToken) {
        begin = token.begin.info.value;
        this.reportError$3(token, C.MessageKind_V4w, P.LinkedHashMap_LinkedHashMap$_literal(["begin", begin, "end", Y.closeBraceFor(begin)], null, null));
      } else
        throw H.wrapException(O.SpannableAssertionFailure$(token, token.get$assertionMessage()));
    }
  },
  ParserError: {
    "^": "Object;reason>",
    toString$0: function(_) {
      return this.reason;
    },
    $isParserError: true,
    static: {ParserError$: function(reason) {
        return new Y.ParserError(reason);
      }}
  },
  ElementListener: {
    "^": "Listener;idGenerator,listener,compilationUnitElement,stringValidator,interpolationScope,nodes>,metadata@,memberErrors@,suppressParseErrors",
    idGenerator$0: function() {
      return this.idGenerator.call$0();
    },
    popLiteralString$0: function() {
      var node = this.popNode$0();
      if (node.get$isInterpolation() === true)
        this.listener.internalError$2(node, "String interpolation not supported in library tags.");
      return node;
    },
    addPartOfTag$1: function(tag) {
      this.compilationUnitElement.setPartOf$2(tag, this.listener);
    },
    endMetadata$3: function(beginToken, periodBeforeName, endToken) {
      if (periodBeforeName != null)
        this.popNode$0();
      this.popNode$0();
      this.metadata = this.metadata.prepend$1(new Y.PartialMetadataAnnotation(beginToken, endToken, null, null, null, 0));
    },
    endClassDeclaration$5: function(interfacesCount, beginToken, extendsKeyword, implementsKeyword, endToken) {
      var $name, id, t1, t2, t3;
      this.makeNodeList$4(interfacesCount, implementsKeyword, null, ",");
      this.popNode$0();
      this.popNode$0();
      $name = this.popNode$0();
      id = this.idGenerator$0();
      t1 = $name.get$token();
      t1 = t1.get$value(t1);
      t2 = P.LinkedHashMap_LinkedHashMap(null, null, null, P.String, O.Element);
      t3 = $.ElementX_elementHashCode + 1;
      $.ElementX_elementHashCode = t3;
      this.pushElement$1(new Y.PartialClassElement(beginToken, endToken, null, C.C_Link, new U.ScopeX(t2), null, id, null, null, null, 0, 0, false, false, C.C_Link, null, null, true, null, null, null, null, null, null, null, t1, C.ElementKind_class_4, this.compilationUnitElement, t3, C.C_Link2, null, false));
      this.rejectBuiltInIdentifier$1($name);
    },
    rejectBuiltInIdentifier$1: function($name) {
      var t1, keyword;
      t1 = $name.token;
      if (!!J.getInterceptor(t1).$isKeywordToken) {
        keyword = H.interceptedTypeCast(t1, "$isKeywordToken").keyword;
        if (!keyword.isPseudo)
          this.reportFatalError$2($name, "Illegal name '" + keyword.syntax + "'.");
      }
    },
    endFunctionTypeAlias$2: function(typedefKeyword, endToken) {
      var $name, t1, t2;
      this.popNode$0();
      $name = this.popNode$0();
      this.popNode$0();
      t1 = $name.get$token();
      t1 = t1.get$value(t1);
      t2 = $.ElementX_elementHashCode + 1;
      $.ElementX_elementHashCode = t2;
      this.pushElement$1(new Y.PartialTypedefElement(typedefKeyword, null, null, false, 0, null, null, null, null, t1, C.ElementKind_typedef_32, this.compilationUnitElement, t2, C.C_Link2, null, false));
      this.rejectBuiltInIdentifier$1($name);
    },
    endNamedMixinApplication$3: function(classKeyword, implementsKeyword, endToken) {
      var interfaces, mixinApplication, modifiers, typeParameters, $name, t1, id, t2, t3, t4;
      interfaces = implementsKeyword != null ? this.popNode$0() : null;
      mixinApplication = this.popNode$0();
      modifiers = this.popNode$0();
      typeParameters = this.popNode$0();
      $name = this.popNode$0();
      t1 = $.Node__HASH_COUNTER + 1;
      $.Node__HASH_COUNTER = t1;
      id = this.idGenerator$0();
      t2 = $name.get$token();
      t2 = t2.get$value(t2);
      t3 = H.setRuntimeTypeInfo(new O.Link(), [O.FunctionElement]);
      t4 = $.ElementX_elementHashCode + 1;
      $.ElementX_elementHashCode = t4;
      this.pushElement$1(new U.MixinApplicationElementX(new Y.NamedMixinApplication($name, typeParameters, modifiers, mixinApplication, interfaces, classKeyword, endToken, t1), modifiers, t3, null, id, null, null, null, 0, 0, false, false, C.C_Link, null, null, true, null, null, null, null, null, null, null, t2, C.ElementKind_class_4, this.compilationUnitElement, t4, C.C_Link2, null, false));
      this.rejectBuiltInIdentifier$1($name);
    },
    endTopLevelMethod$3: function(beginToken, getOrSet, endToken) {
      var t1, hasParseError, $name, modifiers, kind, t2, t3, element;
      t1 = this.memberErrors;
      if (!t1.get$isEmpty(t1)) {
        t1 = this.memberErrors;
        hasParseError = t1.get$head(t1) === true;
      } else
        hasParseError = false;
      this.memberErrors = this.memberErrors.get$tail();
      $name = this.popNode$0();
      this.popNode$0();
      modifiers = this.popNode$0();
      if (getOrSet == null)
        kind = C.ElementKind_function_2;
      else if (getOrSet.get$stringValue() === "get")
        kind = C.ElementKind_getter_0;
      else
        kind = getOrSet.get$stringValue() === "set" ? C.ElementKind_setter_0 : null;
      t1 = $name.get$token();
      t1 = t1.get$value(t1);
      t2 = H.setRuntimeTypeInfo([], [O.FunctionElement]);
      t3 = $.ElementX_elementHashCode + 1;
      $.ElementX_elementHashCode = t3;
      element = new Y.PartialFunctionElement(null, null, null, null, null, false, null, null, modifiers, t2, null, false, null, null, null, t1, kind, this.compilationUnitElement, t3, C.C_Link2, null, false);
      element.init$3(beginToken, getOrSet, endToken);
      element.set$hasParseError(hasParseError);
      this.pushElement$1(element);
    },
    endTopLevelFields$3: function(count, beginToken, endToken) {
      var t1, hasParseError, variables;
      t1 = this.memberErrors;
      if (!t1.get$isEmpty(t1)) {
        t1 = this.memberErrors;
        hasParseError = t1.get$head(t1) === true;
      } else
        hasParseError = false;
      this.memberErrors = this.memberErrors.get$tail();
      variables = this.makeNodeList$4(count, null, null, ",");
      this.popNode$0();
      this.buildFieldElements$7(this.popNode$0(), variables, this.compilationUnitElement, new Y.ElementListener_endTopLevelFields_buildFieldElement(this), beginToken, endToken, hasParseError);
    },
    buildFieldElements$7: function(modifiers, variables, enclosingElement, buildFieldElement, beginToken, endToken, hasParseError) {
      var fields, variableNodes, initializedIdentifier, identifier;
      fields = new Y.PartialFieldList(beginToken, endToken, hasParseError, null, null, modifiers, C.C_Link2);
      for (variableNodes = variables.nodes; !variableNodes.get$isEmpty(variableNodes); variableNodes = variableNodes.get$tail()) {
        initializedIdentifier = variableNodes.get$head(variableNodes);
        identifier = initializedIdentifier.asIdentifier$0();
        buildFieldElement.call$2(identifier == null ? initializedIdentifier.asSendSet$0().selector.asIdentifier$0() : identifier, fields);
      }
    },
    handleModifiers$1: function(count) {
      var modifierNodes, t1, t2;
      if (count === 0)
        this.pushNode$1($.get$Modifiers_EMPTY());
      else {
        modifierNodes = this.makeNodeList$4(count, null, null, " ");
        t1 = Y.Modifiers_computeFlags(modifierNodes.nodes);
        t2 = $.Node__HASH_COUNTER + 1;
        $.Node__HASH_COUNTER = t2;
        this.pushNode$1(new Y.Modifiers(modifierNodes, t1, t2));
      }
    },
    expected$2: function(string, token) {
      var preceding;
      if (!!J.getInterceptor(token).$isErrorToken)
        this.reportErrorToken$1(token);
      else if (";" === string) {
        preceding = this.findPrecedingToken$1(token);
        if (preceding == null ? token == null : preceding === token)
          this.reportError$3(token, C.MessageKind_Whe, P.LinkedHashMap_LinkedHashMap$_literal(["token", string], null, null));
        else
          this.reportError$3(preceding, C.MessageKind_kSE, P.LinkedHashMap_LinkedHashMap$_literal(["token", string], null, null));
        return token;
      } else
        this.reportFatalError$2(token, K.Message$(C.MessageKind_Whe, P.LinkedHashMap_LinkedHashMap$_literal(["token", string], null, null), true).computeMessage$0());
      return this.skipToEof$1(token);
    },
    findPrecedingToken$1: function(token) {
      var t1, current;
      t1 = this.nodes;
      if (!t1.get$isEmpty(t1)) {
        t1 = this.nodes;
        t1 = t1.get$head(t1) != null;
      } else
        t1 = false;
      if (t1) {
        t1 = this.nodes;
        current = t1.get$head(t1).getBeginToken$0();
        while (true) {
          if (current.get$info().kind !== 0) {
            t1 = current.next;
            t1 = t1 == null ? token != null : t1 !== token;
          } else
            t1 = false;
          if (!t1)
            break;
          current = current.next;
        }
        if (current.get$info().kind !== 0)
          return current;
      }
      return token;
    },
    expectedIdentifier$1: function(token) {
      if (!!token.$isKeywordToken)
        this.reportError$3(token, C.MessageKind_rBh, P.LinkedHashMap_LinkedHashMap$_literal(["keyword", token.keyword.syntax], null, null));
      else if (!!token.$isErrorToken) {
        this.reportErrorToken$1(token);
        return this.synthesizeIdentifier$1(token);
      } else
        this.reportFatalError$2(token, "Expected identifier, but got '" + H.S(token.get$value(token)) + "'.");
      return token;
    },
    expectedType$1: function(token) {
      var t1;
      this.pushNode$1(null);
      t1 = J.getInterceptor(token);
      if (!!t1.$isErrorToken) {
        this.reportErrorToken$1(token);
        return this.synthesizeIdentifier$1(token);
      } else {
        this.reportFatalError$2(token, "Expected a type, but got '" + H.S(t1.get$value(token)) + "'.");
        return this.skipToEof$1(token);
      }
    },
    expectedExpression$1: function(token) {
      var t1;
      if (!!token.$isErrorToken) {
        this.reportErrorToken$1(token);
        t1 = $.Node__HASH_COUNTER + 1;
        $.Node__HASH_COUNTER = t1;
        this.pushNode$1(new Y.ErrorExpression(token, null, t1));
        return token.next;
      } else {
        this.reportFatalError$2(token, "Expected an expression, but got '" + H.S(token.get$value(token)) + "'.");
        this.pushNode$1(null);
        return this.skipToEof$1(token);
      }
    },
    unexpected$1: function(token) {
      var t1, message;
      t1 = J.getInterceptor(token);
      if (!!t1.$isErrorToken)
        this.reportErrorToken$1(token);
      else {
        message = "Unexpected token '" + H.S(t1.get$value(token)) + "'.";
        this.reportFatalError$2(token, token.get$info() === C.PrecedenceInfo_mJ8 ? t1.get$value(token) : message);
      }
      return this.skipToEof$1(token);
    },
    expectedBlockToSkip$1: function(token) {
      if (token.get$stringValue() === "native") {
        L.checkAllowedLibrary(this, token);
        token = token.next;
        if (token.get$info().kind === 39)
          token = token.next;
        return token.get$stringValue() === "{" ? token.get$endGroup() : token;
      } else
        return this.unexpected$1(token);
    },
    expectedFunctionBody$1: function(token) {
      var t1 = J.getInterceptor(token);
      if (!!t1.$isErrorToken)
        this.reportErrorToken$1(token);
      else
        this.reportFatalError$2(token, "Expected a function body, but got '" + H.S(t1.get$value(token)) + "'.");
      return this.skipToEof$1(token);
    },
    expectedClassBody$1: function(token) {
      var t1 = J.getInterceptor(token);
      if (!!t1.$isErrorToken)
        this.reportErrorToken$1(token);
      else
        this.reportFatalError$2(token, "Expected a class body, but got '" + H.S(t1.get$value(token)) + "'.");
      return this.skipToEof$1(token);
    },
    unmatched$1: function(token) {
      var begin, next;
      begin = token.info.value;
      this.reportError$3(token, C.MessageKind_V4w, P.LinkedHashMap_LinkedHashMap$_literal(["begin", begin, "end", Y.closeBraceFor(begin)], null, null));
      next = token.next;
      for (; !!J.getInterceptor(next).$isErrorToken;)
        next = next.next;
      return next;
    },
    recoverableError$2: function(node, message) {
      this.reportFatalError$2(node, message);
    },
    pushElement$1: function(element) {
      this.popMetadata$1(element);
      this.compilationUnitElement.addMember$2(element, this.listener);
    },
    popMetadata$1: function(element) {
      var link, result;
      for (link = this.metadata, result = C.C_Link2; !link.get$isEmpty(link); link = link.get$tail()) {
        element.addMetadata$1(link.get$head(link));
        result = result.prepend$1(link.get$head(link));
      }
      this.metadata = C.C_Link2;
      return result;
    },
    addLibraryTag$1: function(tag) {
      var t1, library;
      t1 = this.compilationUnitElement;
      library = t1.get$implementationLibrary();
      if (!(!t1.get$hasMembers() && library.get$entryCompilationUnit() === t1))
        this.reportFatalError$2(tag, "Library tags not allowed here.");
      t1.get$implementationLibrary().addTag$2(tag, this.listener);
    },
    pushNode$1: function(node) {
      this.nodes = this.nodes.prepend$1(node);
    },
    popNode$0: function() {
      var t1, node;
      t1 = this.nodes;
      node = t1.get$head(t1);
      this.nodes = this.nodes.get$tail();
      return node;
    },
    makeNodeList$4: function(count, beginToken, endToken, delimiter) {
      var poppedNodes, t1;
      for (poppedNodes = C.C_Link3; count > 0; --count)
        poppedNodes = poppedNodes.prepend$1(this.popNode$0());
      t1 = $.Node__HASH_COUNTER + 1;
      $.Node__HASH_COUNTER = t1;
      return new Y.NodeList(poppedNodes, beginToken, endToken, delimiter, t1);
    },
    beginLiteralString$1: function(token) {
      var quoting, t1;
      quoting = B.StringValidator_quotingFromString(token.get$value(token));
      this.interpolationScope = this.interpolationScope.prepend$1(quoting);
      t1 = $.Node__HASH_COUNTER + 1;
      $.Node__HASH_COUNTER = t1;
      this.pushNode$1(new Y.LiteralString(token, null, t1));
    },
    endLiteralString$1: function(count) {
      var t1, result, parts, isLast, i, string, validation, t2, t3, expression, t4;
      t1 = this.interpolationScope;
      result = t1.get$head(t1);
      this.interpolationScope = this.interpolationScope.get$tail();
      for (t1 = this.stringValidator, parts = C.C_Link9, isLast = true, i = 0; i < count; ++i, isLast = false) {
        string = this.popNode$0();
        validation = t1.validateInterpolationPart$4$isFirst$isLast(string.get$token(), result, false, isLast);
        t2 = string.get$token();
        t3 = $.Node__HASH_COUNTER + 1;
        $.Node__HASH_COUNTER = t3;
        expression = this.popNode$0();
        t4 = $.Node__HASH_COUNTER + 1;
        $.Node__HASH_COUNTER = t4;
        parts = parts.prepend$1(new Y.StringInterpolationPart(expression, new Y.LiteralString(t2, validation, t3), t4));
      }
      string = this.popNode$0();
      validation = t1.validateInterpolationPart$4$isFirst$isLast(string.get$token(), result, true, isLast);
      t1 = string.get$token();
      t2 = $.Node__HASH_COUNTER + 1;
      $.Node__HASH_COUNTER = t2;
      string = new Y.LiteralString(t1, validation, t2);
      if (isLast)
        this.pushNode$1(string);
      else {
        t1 = t2 + 1;
        $.Node__HASH_COUNTER = t1;
        t2 = t1 + 1;
        $.Node__HASH_COUNTER = t2;
        this.pushNode$1(new Y.StringInterpolation(string, new Y.NodeList(parts, null, null, "", t1), t2));
      }
    },
    handleStringJuxtaposition$1: function(stringCount) {
      var accumulator, expression, t1;
      accumulator = this.popNode$0();
      --stringCount;
      for (; stringCount > 0;) {
        expression = this.popNode$0();
        t1 = $.Node__HASH_COUNTER + 1;
        $.Node__HASH_COUNTER = t1;
        accumulator = new Y.StringJuxtaposition(expression, accumulator, null, null, t1);
        --stringCount;
      }
      this.pushNode$1(accumulator);
    },
    endFields$3: function(fieldCount, start, token) {
      this.memberErrors = this.memberErrors.get$tail();
    },
    endMethod$3: function(getOrSet, start, token) {
      this.memberErrors = this.memberErrors.get$tail();
    },
    endFactoryMethod$2: function(beginToken, endToken) {
      this.memberErrors = this.memberErrors.get$tail();
    },
    reportFatalError$2: function(spannable, message) {
      this.listener.reportFatalError$3(spannable, C.MessageKind_wwi, P.LinkedHashMap_LinkedHashMap$_literal(["text", message], null, null));
    },
    reportError$3: function(spannable, errorCode, $arguments) {
      var t1 = this.memberErrors;
      if (!t1.get$isEmpty(t1)) {
        t1 = this.memberErrors;
        t1 = t1.get$head(t1) === true;
      } else
        t1 = false;
      if (t1)
        return;
      if (this.suppressParseErrors)
        return;
      t1 = this.memberErrors;
      if (!t1.get$isEmpty(t1))
        this.memberErrors = this.memberErrors.get$tail().prepend$1(true);
      this.listener.reportDiagnosticInternal$4(spannable, errorCode, $arguments, C.Diagnostic_1_error);
    },
    reportError$2: function(spannable, errorCode) {
      return this.reportError$3(spannable, errorCode, C.Map_empty);
    },
    static: {ElementListener$: function(listener, compilationUnitElement, idGenerator) {
        return new Y.ElementListener(idGenerator, listener, compilationUnitElement, new B.StringValidator(listener), C.C_Link6, C.C_Link3, C.C_Link2, C.C_Link7, false);
      }}
  },
  ElementListener_endTopLevelFields_buildFieldElement: {
    "^": "Closure:245;this_0",
    call$2: function($name, fields) {
      var t1, t2, t3, t4, t5;
      t1 = this.this_0;
      t2 = H.setRuntimeTypeInfo([], [O.FunctionElement]);
      t3 = $name.token;
      t4 = t3.get$value(t3);
      t5 = $.ElementX_elementHashCode + 1;
      $.ElementX_elementHashCode = t5;
      t1.pushElement$1(new U.FieldElementX(t2, null, t3, fields, null, null, t4, C.ElementKind_field_1, t1.compilationUnitElement, t5, C.C_Link2, null, false));
    },
    $isFunction: true
  },
  NodeListener: {
    "^": "ElementListener;throwOnFatalError,idGenerator,listener,compilationUnitElement,stringValidator,interpolationScope,nodes,metadata,memberErrors,suppressParseErrors",
    reportFatalError$2: function(spannable, message) {
      var t1;
      if (this.throwOnFatalError) {
        t1 = this.memberErrors;
        if (!t1.get$isEmpty(t1)) {
          t1 = this.memberErrors;
          t1 = t1.get$head(t1) === true;
        } else
          t1 = false;
        if (!t1 && !this.suppressParseErrors)
          this.reportError$3(spannable, C.MessageKind_wwi, P.LinkedHashMap_LinkedHashMap$_literal(["text", message], null, null));
        throw H.wrapException(Y.ParserError$(message));
      } else
        Y.ElementListener.prototype.reportFatalError$2.call(this, spannable, message);
    },
    addLibraryTag$1: function(tag) {
      this.pushNode$1(tag);
    },
    addPartOfTag$1: function(tag) {
      this.pushNode$1(tag);
    },
    endClassDeclaration$5: function(interfacesCount, beginToken, extendsKeyword, implementsKeyword, endToken) {
      var body, interfaces, supertype, typeParameters, $name, modifiers, t1;
      body = this.popNode$0();
      interfaces = this.makeNodeList$4(interfacesCount, implementsKeyword, null, ",");
      supertype = this.popNode$0();
      typeParameters = this.popNode$0();
      $name = this.popNode$0();
      modifiers = this.popNode$0();
      t1 = $.Node__HASH_COUNTER + 1;
      $.Node__HASH_COUNTER = t1;
      this.pushNode$1(new Y.ClassNode(modifiers, $name, supertype, interfaces, typeParameters, body, beginToken, extendsKeyword, endToken, t1));
    },
    endCompilationUnit$2: function(count, token) {
      this.pushNode$1(this.makeNodeList$4(count, null, null, "\n"));
    },
    endFunctionTypeAlias$2: function(typedefKeyword, endToken) {
      var formals, typeParameters, $name, returnType, t1;
      formals = this.popNode$0();
      typeParameters = this.popNode$0();
      $name = this.popNode$0();
      returnType = this.popNode$0();
      t1 = $.Node__HASH_COUNTER + 1;
      $.Node__HASH_COUNTER = t1;
      this.pushNode$1(new Y.Typedef(returnType, $name, typeParameters, formals, typedefKeyword, endToken, t1));
    },
    endNamedMixinApplication$3: function(classKeyword, implementsKeyword, endToken) {
      var interfaces, mixinApplication, modifiers, typeParameters, $name, t1;
      interfaces = implementsKeyword != null ? this.popNode$0() : null;
      mixinApplication = this.popNode$0();
      modifiers = this.popNode$0();
      typeParameters = this.popNode$0();
      $name = this.popNode$0();
      t1 = $.Node__HASH_COUNTER + 1;
      $.Node__HASH_COUNTER = t1;
      this.pushNode$1(new Y.NamedMixinApplication($name, typeParameters, modifiers, mixinApplication, interfaces, classKeyword, endToken, t1));
    },
    endClassBody$3: function(memberCount, beginToken, endToken) {
      this.pushNode$1(this.makeNodeList$4(memberCount, beginToken, endToken, null));
    },
    endTopLevelFields$3: function(count, beginToken, endToken) {
      var variables, type, modifiers, t1;
      variables = this.makeNodeList$4(count, null, endToken, ",");
      type = this.popNode$0();
      modifiers = this.popNode$0();
      t1 = $.Node__HASH_COUNTER + 1;
      $.Node__HASH_COUNTER = t1;
      this.pushNode$1(new Y.VariableDefinitions(null, type, modifiers, variables, t1));
    },
    endTopLevelMethod$3: function(beginToken, getOrSet, endToken) {
      var $name, modifiers, kind, t1, t2, t3, t4;
      this.popNode$0();
      this.popNode$0();
      $name = this.popNode$0();
      this.popNode$0();
      modifiers = this.popNode$0();
      if (getOrSet == null)
        kind = C.ElementKind_function_2;
      else if (getOrSet.get$stringValue() === "get")
        kind = C.ElementKind_getter_0;
      else
        kind = getOrSet.get$stringValue() === "set" ? C.ElementKind_setter_0 : null;
      t1 = $name.get$token();
      t1 = t1.get$value(t1);
      t2 = this.compilationUnitElement;
      t3 = H.setRuntimeTypeInfo([], [O.FunctionElement]);
      t4 = $.ElementX_elementHashCode + 1;
      $.ElementX_elementHashCode = t4;
      t4 = new Y.PartialFunctionElement(null, null, null, null, null, false, null, null, modifiers, t3, null, false, null, null, null, t1, kind, t2, t4, C.C_Link2, null, false);
      t4.init$3(beginToken, getOrSet, endToken);
      this.popMetadata$1(t4);
      t2.addMember$2(t4, this.listener);
    },
    endFormalParameter$1: function(thisKeyword) {
      var $name, t1, thisIdentifier, type, modifiers, metadata, t2, t3;
      $name = this.popNode$0();
      if (thisKeyword != null) {
        t1 = $.Node__HASH_COUNTER + 1;
        $.Node__HASH_COUNTER = t1;
        thisIdentifier = new Y.Identifier(thisKeyword, null, t1);
        if ($name.asSend$0() == null) {
          t1 = $.Node__HASH_COUNTER + 1;
          $.Node__HASH_COUNTER = t1;
          $name = new Y.Send(thisIdentifier, $name, null, null, t1);
        } else
          $name = $name.asSend$0().copyWithReceiver$1(thisIdentifier);
      }
      type = this.popNode$0();
      modifiers = this.popNode$0();
      metadata = this.popNode$0();
      t1 = E.LinkEntry$($name, C.C_Link3, H.getTypeArgumentByIndex(C.C_Link3, 0));
      t2 = $.Node__HASH_COUNTER + 1;
      $.Node__HASH_COUNTER = t2;
      t3 = t2 + 1;
      $.Node__HASH_COUNTER = t3;
      this.pushNode$1(new Y.VariableDefinitions(metadata, type, modifiers, new Y.NodeList(t1, null, null, null, t2), t3));
    },
    endFormalParameters$3: function(count, beginToken, endToken) {
      this.pushNode$1(this.makeNodeList$4(count, beginToken, endToken, ","));
    },
    handleNoFormalParameters$1: function(token) {
      this.pushNode$1(null);
    },
    endArguments$3: function(count, beginToken, endToken) {
      this.pushNode$1(this.makeNodeList$4(count, beginToken, endToken, ","));
    },
    handleNoArguments$1: function(token) {
      this.pushNode$1(null);
    },
    endConstructorReference$3: function(start, periodBeforeName, endToken) {
      var $name, typeArguments, classReference, t1, identifier, send, $constructor;
      $name = periodBeforeName != null ? this.popNode$0() : null;
      typeArguments = this.popNode$0();
      classReference = this.popNode$0();
      if (typeArguments != null) {
        t1 = $.Node__HASH_COUNTER + 1;
        $.Node__HASH_COUNTER = t1;
        classReference = new Y.TypeAnnotation(classReference, typeArguments, t1);
      } else {
        identifier = classReference.asIdentifier$0();
        send = classReference.asSend$0();
        if (identifier != null)
          classReference = identifier;
        else if (send != null)
          classReference = send;
        else
          this.internalError$1$node(classReference);
      }
      if ($name != null) {
        t1 = $.Node__HASH_COUNTER + 1;
        $.Node__HASH_COUNTER = t1;
        $constructor = new Y.Send(classReference, $name, null, null, t1);
      } else
        $constructor = classReference;
      this.pushNode$1($constructor);
    },
    endRedirectingFactoryBody$2: function(beginToken, endToken) {
      var t1, t2;
      t1 = this.popNode$0();
      t2 = $.Node__HASH_COUNTER + 1;
      $.Node__HASH_COUNTER = t2;
      this.pushNode$1(new Y.RedirectingFactoryBody(t1, beginToken, endToken, null, t2));
    },
    endReturnStatement$3: function(hasExpression, beginToken, endToken) {
      var expression, t1;
      expression = hasExpression ? this.popNode$0() : null;
      t1 = $.Node__HASH_COUNTER + 1;
      $.Node__HASH_COUNTER = t1;
      this.pushNode$1(new Y.Return0(expression, beginToken, endToken, t1));
    },
    endExpressionStatement$1: function(token) {
      var t1, t2;
      t1 = this.popNode$0();
      t2 = $.Node__HASH_COUNTER + 1;
      $.Node__HASH_COUNTER = t2;
      this.pushNode$1(new Y.ExpressionStatement0(t1, token, t2));
    },
    expectedFunctionBody$1: function(token) {
      var token0, hasExpression;
      if (token.get$stringValue() === "native") {
        L.checkAllowedLibrary(this, token);
        token0 = token.next;
        if (token0.get$info().kind === 39) {
          this.beginLiteralString$1(token0);
          this.endLiteralString$1(0);
          token0 = token0.next;
          hasExpression = true;
        } else
          hasExpression = false;
        this.endReturnStatement$3(hasExpression, token, token0);
        return token0.next;
      } else if (!!token.$isErrorToken) {
        this.pushNode$1(null);
        this.reportErrorToken$1(token);
      } else
        this.reportFatalError$2(token, "Expected a function body, but got '" + H.S(token.get$value(token)) + "'.");
      return this.skipToEof$1(token);
    },
    expectedClassBody$1: function(token) {
      var t1 = J.getInterceptor(token);
      if (!!t1.$isErrorToken)
        this.reportErrorToken$1(token);
      else {
        this.reportFatalError$2(token, "Expected a class body, but got '" + H.S(t1.get$value(token)) + "'.");
        return this.skipToEof$1(token);
      }
    },
    handleLiteralInt$1: function(token) {
      var t1 = $.Node__HASH_COUNTER + 1;
      $.Node__HASH_COUNTER = t1;
      this.pushNode$1(new Y.LiteralInt(token, new Y.NodeListener_handleLiteralInt_closure(this), t1));
    },
    handleLiteralDouble$1: function(token) {
      var t1 = $.Node__HASH_COUNTER + 1;
      $.Node__HASH_COUNTER = t1;
      this.pushNode$1(new Y.LiteralDouble(token, new Y.NodeListener_handleLiteralDouble_closure(this), t1));
    },
    handleLiteralBool$1: function(token) {
      var t1 = $.Node__HASH_COUNTER + 1;
      $.Node__HASH_COUNTER = t1;
      this.pushNode$1(new Y.LiteralBool0(token, new Y.NodeListener_handleLiteralBool_closure(this), t1));
    },
    handleLiteralNull$1: function(token) {
      var t1 = $.Node__HASH_COUNTER + 1;
      $.Node__HASH_COUNTER = t1;
      this.pushNode$1(new Y.LiteralNull0(token, null, t1));
    },
    endLiteralSymbol$2: function(hashToken, identifierCount) {
      var identifiers, t1;
      identifiers = this.makeNodeList$4(identifierCount, null, null, ".");
      t1 = $.Node__HASH_COUNTER + 1;
      $.Node__HASH_COUNTER = t1;
      this.pushNode$1(new Y.LiteralSymbol(hashToken, identifiers, t1));
    },
    handleBinaryExpression$1: function(token) {
      var argument, receiver, tokenString, argumentSend, t1, t2, t3, t4;
      argument = this.popNode$0();
      receiver = this.popNode$0();
      tokenString = token.get$stringValue();
      if (tokenString === "." || tokenString === "..") {
        argumentSend = argument.asSend$0();
        if (argumentSend == null)
          this.reportFatalError$2(argument, "Expected an identifier.");
        if (argumentSend.receiver != null)
          this.internalError$1$node(argument);
        if (!!argument.$isSendSet)
          this.internalError$1$node(argument);
        this.pushNode$1(argument.asSend$0().copyWithReceiver$1(receiver));
      } else {
        t1 = E.LinkEntry$(argument, C.C_Link3, H.getTypeArgumentByIndex(C.C_Link3, 0));
        t2 = $.Node__HASH_COUNTER + 1;
        $.Node__HASH_COUNTER = t2;
        t3 = t2 + 1;
        $.Node__HASH_COUNTER = t3;
        t4 = t3 + 1;
        $.Node__HASH_COUNTER = t4;
        this.pushNode$1(new Y.Send(receiver, new Y.Operator(token, null, t3), new Y.NodeList(t1, null, null, null, t2), null, t4));
      }
      if (tokenString === "===")
        this.listener.reportDiagnosticInternal$4(token, C.MessageKind_3KU, P.LinkedHashMap_LinkedHashMap$_literal(["lhs", receiver, "rhs", argument], null, null), C.Diagnostic_1_error);
      if (tokenString === "!==")
        this.listener.reportDiagnosticInternal$4(token, C.MessageKind_EKW, P.LinkedHashMap_LinkedHashMap$_literal(["lhs", receiver, "rhs", argument], null, null), C.Diagnostic_1_error);
    },
    beginCascade$1: function(token) {
      var t1, t2;
      t1 = this.popNode$0();
      t2 = $.Node__HASH_COUNTER + 1;
      $.Node__HASH_COUNTER = t2;
      this.pushNode$1(new Y.CascadeReceiver(t1, token, t2));
    },
    endCascade$0: function() {
      var t1, t2;
      t1 = this.popNode$0();
      t2 = $.Node__HASH_COUNTER + 1;
      $.Node__HASH_COUNTER = t2;
      this.pushNode$1(new Y.Cascade(t1, t2));
    },
    handleAsOperator$2: function(operathor, endToken) {
      var type, expression, t1, t2, t3, t4;
      type = this.popNode$0();
      expression = this.popNode$0();
      t1 = E.LinkEntry$(type, C.C_Link3, H.getTypeArgumentByIndex(C.C_Link3, 0));
      t2 = $.Node__HASH_COUNTER + 1;
      $.Node__HASH_COUNTER = t2;
      t3 = t2 + 1;
      $.Node__HASH_COUNTER = t3;
      t4 = t3 + 1;
      $.Node__HASH_COUNTER = t4;
      this.pushNode$1(new Y.Send(expression, new Y.Operator(operathor, null, t3), new Y.NodeList(t1, null, null, null, t2), null, t4));
    },
    handleAssignmentExpression$1: function(token) {
      var arg, node, send, t1, t2, link, $arguments, t3, t4;
      arg = this.popNode$0();
      node = this.popNode$0();
      send = node.asSend$0();
      if (send != null) {
        if (send.argumentsNode != null) {
          t1 = send.selector;
          if (!!J.getInterceptor(t1).$isOperator) {
            t1 = t1.asOperator$0().token;
            t1 = t1.get$value(t1) === "[]";
          } else
            t1 = false;
        } else
          t1 = true;
        t1 = !t1;
      } else
        t1 = true;
      if (t1)
        this.reportFatalError$2(node, "Not assignable.");
      if (send.asSendSet$0() != null)
        this.internalError$1$node(send);
      t1 = send.selector;
      if (!!J.getInterceptor(t1).$isOperator) {
        t2 = t1.asOperator$0().token;
        t2 = t2.get$value(t2) === "[]";
      } else
        t2 = false;
      if (t2) {
        link = E.LinkEntry$(arg, C.C_Link3, H.getTypeArgumentByIndex(C.C_Link3, 0));
        t2 = send.argumentsNode.nodes;
        link = E.LinkEntry$(t2.get$head(t2), link, H.getTypeArgumentByIndex(link, 0));
        t2 = $.Node__HASH_COUNTER + 1;
        $.Node__HASH_COUNTER = t2;
        $arguments = new Y.NodeList(link, null, null, null, t2);
      } else {
        t2 = E.LinkEntry$(arg, C.C_Link3, H.getTypeArgumentByIndex(C.C_Link3, 0));
        t3 = $.Node__HASH_COUNTER + 1;
        $.Node__HASH_COUNTER = t3;
        $arguments = new Y.NodeList(t2, null, null, null, t3);
        t2 = t3;
      }
      ++t2;
      $.Node__HASH_COUNTER = t2;
      t3 = send.receiver;
      t4 = t2 + 1;
      $.Node__HASH_COUNTER = t4;
      this.pushNode$1(new Y.SendSet(new Y.Operator(token, null, t2), t3, t1, $arguments, null, t4));
    },
    handleConditionalExpression$2: function(question, colon) {
      var elseExpression, thenExpression, condition, t1;
      elseExpression = this.popNode$0();
      thenExpression = this.popNode$0();
      condition = this.popNode$0();
      t1 = $.Node__HASH_COUNTER + 1;
      $.Node__HASH_COUNTER = t1;
      this.pushNode$1(new Y.Conditional0(condition, thenExpression, elseExpression, question, colon, t1));
    },
    endSend$1: function(token) {
      var $arguments, selector, t1;
      $arguments = this.popNode$0();
      selector = this.popNode$0();
      t1 = $.Node__HASH_COUNTER + 1;
      $.Node__HASH_COUNTER = t1;
      this.pushNode$1(new Y.Send(null, selector, $arguments, null, t1));
    },
    endFunctionBody$3: function(count, beginToken, endToken) {
      var t1, t2;
      if (count === 0 && beginToken == null) {
        t1 = $.Node__HASH_COUNTER + 1;
        $.Node__HASH_COUNTER = t1;
        this.pushNode$1(new Y.EmptyStatement0(endToken, t1));
      } else {
        t1 = this.makeNodeList$4(count, beginToken, endToken, null);
        t2 = $.Node__HASH_COUNTER + 1;
        $.Node__HASH_COUNTER = t2;
        this.pushNode$1(new Y.Block0(t1, t2));
      }
    },
    skippedFunctionBody$1: function(token) {
      var t1, t2;
      t1 = $.Node__HASH_COUNTER + 1;
      $.Node__HASH_COUNTER = t1;
      t2 = t1 + 1;
      $.Node__HASH_COUNTER = t2;
      this.pushNode$1(new Y.Block0(new Y.NodeList(C.C_Link3, null, null, null, t1), t2));
    },
    handleNoFunctionBody$1: function(token) {
      var t1 = $.Node__HASH_COUNTER + 1;
      $.Node__HASH_COUNTER = t1;
      this.pushNode$1(new Y.EmptyStatement0(token, t1));
    },
    endFunction$2: function(getOrSet, endToken) {
      var body, initializers, formals, $name, type, modifiers, t1;
      body = this.popNode$0();
      initializers = this.popNode$0();
      formals = this.popNode$0();
      $name = this.popNode$0();
      type = this.popNode$0();
      modifiers = this.popNode$0();
      t1 = $.Node__HASH_COUNTER + 1;
      $.Node__HASH_COUNTER = t1;
      this.pushNode$1(new Y.FunctionExpression($name, formals, body, type, modifiers, initializers, getOrSet, null, t1));
    },
    endFunctionDeclaration$1: function(endToken) {
      var t1, t2;
      t1 = this.popNode$0();
      t2 = $.Node__HASH_COUNTER + 1;
      $.Node__HASH_COUNTER = t2;
      this.pushNode$1(new Y.FunctionDeclaration0(t1, t2));
    },
    endVariablesDeclaration$2: function(count, endToken) {
      var variables, type, modifiers, t1;
      variables = this.makeNodeList$4(count, null, endToken, ",");
      type = this.popNode$0();
      modifiers = this.popNode$0();
      t1 = $.Node__HASH_COUNTER + 1;
      $.Node__HASH_COUNTER = t1;
      this.pushNode$1(new Y.VariableDefinitions(null, type, modifiers, variables, t1));
    },
    endInitializer$1: function(assignmentOperator) {
      var initializer, $arguments, t1, t2, $name;
      initializer = this.popNode$0();
      if (initializer == null)
        $arguments = null;
      else {
        t1 = E.LinkEntry$(initializer, C.C_Link3, H.getTypeArgumentByIndex(C.C_Link3, 0));
        t2 = $.Node__HASH_COUNTER + 1;
        $.Node__HASH_COUNTER = t2;
        $arguments = new Y.NodeList(t1, null, null, null, t2);
      }
      $name = this.popNode$0();
      t1 = $.Node__HASH_COUNTER + 1;
      $.Node__HASH_COUNTER = t1;
      t2 = t1 + 1;
      $.Node__HASH_COUNTER = t2;
      this.pushNode$1(new Y.SendSet(new Y.Operator(assignmentOperator, null, t1), null, $name, $arguments, null, t2));
    },
    endIfStatement$2: function(ifToken, elseToken) {
      var elsePart, thenPart, condition, t1;
      elsePart = elseToken == null ? null : this.popNode$0();
      thenPart = this.popNode$0();
      condition = this.popNode$0();
      t1 = $.Node__HASH_COUNTER + 1;
      $.Node__HASH_COUNTER = t1;
      this.pushNode$1(new Y.If0(condition, thenPart, elsePart, ifToken, elseToken, t1));
    },
    endForStatement$3: function(updateExpressionCount, beginToken, endToken) {
      var body, updates, condition, initializer, t1;
      body = this.popNode$0();
      updates = this.makeNodeList$4(updateExpressionCount, null, null, ",");
      condition = this.popNode$0();
      initializer = this.popNode$0();
      t1 = $.Node__HASH_COUNTER + 1;
      $.Node__HASH_COUNTER = t1;
      this.pushNode$1(new Y.For0(initializer, condition, updates, beginToken, body, t1));
    },
    handleNoExpression$1: function(token) {
      this.pushNode$1(null);
    },
    endDoWhileStatement$3: function(doKeyword, whileKeyword, endToken) {
      var condition, body, t1;
      condition = this.popNode$0();
      body = this.popNode$0();
      t1 = $.Node__HASH_COUNTER + 1;
      $.Node__HASH_COUNTER = t1;
      this.pushNode$1(new Y.DoWhile(doKeyword, whileKeyword, endToken, condition, body, t1));
    },
    endWhileStatement$2: function(whileKeyword, endToken) {
      var body, condition, t1;
      body = this.popNode$0();
      condition = this.popNode$0();
      t1 = $.Node__HASH_COUNTER + 1;
      $.Node__HASH_COUNTER = t1;
      this.pushNode$1(new Y.While(whileKeyword, condition, body, t1));
    },
    endBlock$3: function(count, beginToken, endToken) {
      var t1, t2;
      t1 = this.makeNodeList$4(count, beginToken, endToken, null);
      t2 = $.Node__HASH_COUNTER + 1;
      $.Node__HASH_COUNTER = t2;
      this.pushNode$1(new Y.Block0(t1, t2));
    },
    endThrowExpression$2: function(throwToken, endToken) {
      var expression, t1;
      expression = this.popNode$0();
      t1 = $.Node__HASH_COUNTER + 1;
      $.Node__HASH_COUNTER = t1;
      this.pushNode$1(new Y.Throw0(expression, throwToken, endToken, t1));
    },
    endRethrowStatement$2: function(throwToken, endToken) {
      var t1 = $.Node__HASH_COUNTER + 1;
      $.Node__HASH_COUNTER = t1;
      this.pushNode$1(new Y.Rethrow(throwToken, endToken, t1));
      if (throwToken.get$stringValue() === "throw")
        this.listener.reportDiagnosticInternal$4(throwToken, C.MessageKind_69x, C.Map_empty, C.Diagnostic_1_error);
    },
    handleUnaryPrefixExpression$1: function(token) {
      var t1, t2, t3, t4, t0;
      t1 = this.popNode$0();
      t2 = $.Node__HASH_COUNTER + 1;
      $.Node__HASH_COUNTER = t2;
      t3 = t2 + 1;
      $.Node__HASH_COUNTER = t3;
      t4 = new Y.Prefix0(C.C_Link3, null, null, null, t3);
      t0 = t4;
      t4 = t3;
      t3 = t0;
      ++t4;
      $.Node__HASH_COUNTER = t4;
      this.pushNode$1(new Y.Send(t1, new Y.Operator(token, null, t2), t3, null, t4));
    },
    handleSuperExpression$1: function(token) {
      var t1 = $.Node__HASH_COUNTER + 1;
      $.Node__HASH_COUNTER = t1;
      this.pushNode$1(new Y.Identifier(token, null, t1));
    },
    handleThisExpression$1: function(token) {
      var t1 = $.Node__HASH_COUNTER + 1;
      $.Node__HASH_COUNTER = t1;
      this.pushNode$1(new Y.Identifier(token, null, t1));
    },
    handleUnaryAssignmentExpression$2: function(token, isPrefix) {
      var node, send, t1, t2, t3, argument, op, t4, t0;
      node = this.popNode$0();
      send = node.asSend$0();
      if (send == null)
        this.reportFatalError$2(node, "Not assignable.");
      t1 = send.argumentsNode;
      if (t1 != null) {
        t2 = send.selector;
        if (!!J.getInterceptor(t2).$isOperator) {
          t2 = t2.asOperator$0().token;
          t2 = t2.get$value(t2) === "[]";
        } else
          t2 = false;
      } else
        t2 = true;
      if (!t2)
        this.reportFatalError$2(node, "Not assignable.");
      if (send.asSendSet$0() != null)
        this.internalError$1$node(send);
      t2 = send.selector;
      if (!!J.getInterceptor(t2).$isOperator) {
        t3 = t2.asOperator$0().token;
        t3 = t3.get$value(t3) === "[]";
      } else
        t3 = false;
      if (t3) {
        t1 = t1.nodes;
        argument = t1.get$head(t1);
      } else
        argument = null;
      t1 = $.Node__HASH_COUNTER + 1;
      $.Node__HASH_COUNTER = t1;
      op = new Y.Operator(token, null, t1);
      t3 = send.receiver;
      if (isPrefix) {
        if (argument == null) {
          ++t1;
          $.Node__HASH_COUNTER = t1;
          t4 = new Y.Prefix0(C.C_Link3, null, null, null, t1);
          t0 = t4;
          t4 = t1;
          t1 = t0;
        } else {
          t4 = E.LinkEntry$(argument, C.C_Link3, H.getTypeArgumentByIndex(C.C_Link3, 0));
          ++t1;
          $.Node__HASH_COUNTER = t1;
          t4 = new Y.Prefix0(t4, null, null, null, t1);
          t0 = t4;
          t4 = t1;
          t1 = t0;
        }
        ++t4;
        $.Node__HASH_COUNTER = t4;
        this.pushNode$1(new Y.SendSet(op, t3, t2, t1, null, t4));
      } else {
        if (argument == null) {
          ++t1;
          $.Node__HASH_COUNTER = t1;
          t4 = new Y.Postfix0(C.C_Link3, null, null, null, t1);
          t0 = t4;
          t4 = t1;
          t1 = t0;
        } else {
          t4 = E.LinkEntry$(argument, C.C_Link3, H.getTypeArgumentByIndex(C.C_Link3, 0));
          ++t1;
          $.Node__HASH_COUNTER = t1;
          t4 = new Y.Postfix0(t4, null, null, null, t1);
          t0 = t4;
          t4 = t1;
          t1 = t0;
        }
        ++t4;
        $.Node__HASH_COUNTER = t4;
        this.pushNode$1(new Y.SendSet(op, t3, t2, t1, null, t4));
      }
    },
    handleUnaryPostfixAssignmentExpression$1: function(token) {
      this.handleUnaryAssignmentExpression$2(token, false);
    },
    handleUnaryPrefixAssignmentExpression$1: function(token) {
      this.handleUnaryAssignmentExpression$2(token, true);
    },
    endInitializers$3: function(count, beginToken, endToken) {
      this.pushNode$1(this.makeNodeList$4(count, beginToken, null, ","));
    },
    handleNoInitializers$0: function() {
      this.pushNode$1(null);
    },
    endFields$3: function(count, beginToken, endToken) {
      var variables, type, modifiers, t1;
      variables = this.makeNodeList$4(count, null, endToken, ",");
      type = this.popNode$0();
      modifiers = this.popNode$0();
      t1 = $.Node__HASH_COUNTER + 1;
      $.Node__HASH_COUNTER = t1;
      this.pushNode$1(new Y.VariableDefinitions(null, type, modifiers, variables, t1));
    },
    endMethod$3: function(getOrSet, beginToken, endToken) {
      var body, initializers, formalParameters, $name, returnType, modifiers, t1;
      body = this.popNode$0();
      initializers = this.popNode$0();
      formalParameters = this.popNode$0();
      $name = this.popNode$0();
      returnType = this.popNode$0();
      modifiers = this.popNode$0();
      t1 = $.Node__HASH_COUNTER + 1;
      $.Node__HASH_COUNTER = t1;
      this.pushNode$1(new Y.FunctionExpression($name, formalParameters, body, returnType, modifiers, initializers, getOrSet, null, t1));
    },
    handleLiteralMap$4: function(count, beginToken, constKeyword, endToken) {
      var entries, typeArguments, t1;
      entries = this.makeNodeList$4(count, beginToken, endToken, ",");
      typeArguments = this.popNode$0();
      t1 = $.Node__HASH_COUNTER + 1;
      $.Node__HASH_COUNTER = t1;
      this.pushNode$1(new Y.LiteralMap(typeArguments, entries, constKeyword, t1));
    },
    endLiteralMapEntry$2: function(colon, endToken) {
      var value, key, t1;
      value = this.popNode$0();
      key = this.popNode$0();
      t1 = $.Node__HASH_COUNTER + 1;
      $.Node__HASH_COUNTER = t1;
      this.pushNode$1(new Y.LiteralMapEntry(key, value, colon, t1));
    },
    handleLiteralList$4: function(count, beginToken, constKeyword, endToken) {
      var elements, t1, t2;
      elements = this.makeNodeList$4(count, beginToken, endToken, ",");
      t1 = this.popNode$0();
      t2 = $.Node__HASH_COUNTER + 1;
      $.Node__HASH_COUNTER = t2;
      this.pushNode$1(new Y.LiteralList(t1, elements, constKeyword, t2));
    },
    handleIndexedExpression$2: function(openSquareBracket, closeSquareBracket) {
      var $arguments, receiver, t1, t2, t3, t4;
      $arguments = this.makeNodeList$4(1, openSquareBracket, closeSquareBracket, null);
      receiver = this.popNode$0();
      t1 = openSquareBracket.charOffset;
      t2 = Y.StringToken_canonicalizedString("[]", false);
      t3 = $.Node__HASH_COUNTER + 1;
      $.Node__HASH_COUNTER = t3;
      t4 = t3 + 1;
      $.Node__HASH_COUNTER = t4;
      this.pushNode$1(new Y.Send(receiver, new Y.Operator(new Y.StringToken(t2, C.PrecedenceInfo_CRA, t1, null), null, t3), $arguments, null, t4));
    },
    handleNewExpression$1: function(token) {
      var $arguments, $name, t1, t2;
      $arguments = this.popNode$0();
      $name = this.popNode$0();
      t1 = $.Node__HASH_COUNTER + 1;
      $.Node__HASH_COUNTER = t1;
      t2 = t1 + 1;
      $.Node__HASH_COUNTER = t2;
      this.pushNode$1(new Y.NewExpression(token, new Y.Send(null, $name, $arguments, null, t1), t2));
    },
    handleConstExpression$1: function(token) {
      this.handleNewExpression$1(token);
    },
    handleOperator$1: function(token) {
      var t1 = $.Node__HASH_COUNTER + 1;
      $.Node__HASH_COUNTER = t1;
      this.pushNode$1(new Y.Operator(token, null, t1));
    },
    handleOperatorName$2: function(operatorKeyword, token) {
      var t1, t2, t3;
      t1 = $.Node__HASH_COUNTER + 1;
      $.Node__HASH_COUNTER = t1;
      t2 = t1 + 1;
      $.Node__HASH_COUNTER = t2;
      t3 = t2 + 1;
      $.Node__HASH_COUNTER = t3;
      this.pushNode$1(new Y.Send(new Y.Identifier(operatorKeyword, null, t2), new Y.Operator(token, null, t1), null, null, t3));
    },
    handleNamedArgument$1: function(colon) {
      var expression, $name, t1;
      expression = this.popNode$0();
      $name = this.popNode$0();
      t1 = $.Node__HASH_COUNTER + 1;
      $.Node__HASH_COUNTER = t1;
      this.pushNode$1(new Y.NamedArgument($name, expression, colon, t1));
    },
    endOptionalFormalParameters$3: function(count, beginToken, endToken) {
      this.pushNode$1(this.makeNodeList$4(count, beginToken, endToken, ","));
    },
    handleFunctionTypedFormalParameter$1: function(endToken) {
      var formals, $name, returnType, t1, t2;
      formals = this.popNode$0();
      $name = this.popNode$0();
      returnType = this.popNode$0();
      this.pushNode$1(null);
      t1 = $.get$Modifiers_EMPTY();
      t2 = $.Node__HASH_COUNTER + 1;
      $.Node__HASH_COUNTER = t2;
      this.pushNode$1(new Y.FunctionExpression($name, formals, null, returnType, t1, null, null, null, t2));
    },
    handleValuedFormalParameter$2: function(equals, token) {
      var defaultValue, parameterName, t1, t2, t3, t4;
      defaultValue = this.popNode$0();
      parameterName = this.popNode$0();
      t1 = $.Node__HASH_COUNTER + 1;
      $.Node__HASH_COUNTER = t1;
      t2 = E.LinkEntry$(defaultValue, C.C_Link3, H.getTypeArgumentByIndex(C.C_Link3, 0));
      t3 = t1 + 1;
      $.Node__HASH_COUNTER = t3;
      t4 = t3 + 1;
      $.Node__HASH_COUNTER = t4;
      this.pushNode$1(new Y.SendSet(new Y.Operator(equals, null, t1), null, parameterName, new Y.NodeList(t2, null, null, null, t3), null, t4));
    },
    endTryStatement$3: function(catchCount, tryKeyword, finallyKeyword) {
      var finallyBlock, catchBlocks, tryBlock, t1;
      finallyBlock = finallyKeyword != null ? this.popNode$0() : null;
      catchBlocks = this.makeNodeList$4(catchCount, null, null, null);
      tryBlock = this.popNode$0();
      t1 = $.Node__HASH_COUNTER + 1;
      $.Node__HASH_COUNTER = t1;
      this.pushNode$1(new Y.TryStatement(tryBlock, catchBlocks, finallyBlock, tryKeyword, finallyKeyword, t1));
    },
    handleCaseMatch$2: function(caseKeyword, colon) {
      var t1, t2;
      t1 = this.popNode$0();
      t2 = $.Node__HASH_COUNTER + 1;
      $.Node__HASH_COUNTER = t2;
      this.pushNode$1(new Y.CaseMatch(caseKeyword, t1, colon, t2));
    },
    handleCatchBlock$2: function(onKeyword, catchKeyword) {
      var block, formals, type, t1;
      block = this.popNode$0();
      formals = catchKeyword != null ? this.popNode$0() : null;
      type = onKeyword != null ? this.popNode$0() : null;
      t1 = $.Node__HASH_COUNTER + 1;
      $.Node__HASH_COUNTER = t1;
      this.pushNode$1(new Y.CatchBlock(type, formals, block, onKeyword, catchKeyword, t1));
    },
    endSwitchStatement$2: function(switchKeyword, endToken) {
      var cases, expression, t1;
      cases = this.popNode$0();
      expression = this.popNode$0();
      t1 = $.Node__HASH_COUNTER + 1;
      $.Node__HASH_COUNTER = t1;
      this.pushNode$1(new Y.SwitchStatement(expression, cases, switchKeyword, t1));
    },
    endSwitchBlock$3: function(caseCount, beginToken, endToken) {
      var caseNodes, t1;
      for (caseNodes = C.C_Link3; caseCount > 0;) {
        caseNodes = caseNodes.prepend$1(this.popNode$0());
        --caseCount;
      }
      t1 = $.Node__HASH_COUNTER + 1;
      $.Node__HASH_COUNTER = t1;
      this.pushNode$1(new Y.NodeList(caseNodes, beginToken, endToken, null, t1));
    },
    handleSwitchCase$6: function(labelCount, caseCount, defaultKeyword, statementCount, firstToken, endToken) {
      var statements, labelsAndCases, t1;
      statements = this.makeNodeList$4(statementCount, null, null, null);
      labelsAndCases = this.makeNodeList$4(labelCount + caseCount, null, null, null);
      t1 = $.Node__HASH_COUNTER + 1;
      $.Node__HASH_COUNTER = t1;
      this.pushNode$1(new Y.SwitchCase(labelsAndCases, defaultKeyword, statements, firstToken, t1));
    },
    handleBreakStatement$3: function(hasTarget, breakKeyword, endToken) {
      var target, t1;
      target = hasTarget ? this.popNode$0() : null;
      t1 = $.Node__HASH_COUNTER + 1;
      $.Node__HASH_COUNTER = t1;
      this.pushNode$1(new Y.BreakStatement(target, breakKeyword, endToken, t1));
    },
    handleContinueStatement$3: function(hasTarget, continueKeyword, endToken) {
      var target, t1;
      target = hasTarget ? this.popNode$0() : null;
      t1 = $.Node__HASH_COUNTER + 1;
      $.Node__HASH_COUNTER = t1;
      this.pushNode$1(new Y.ContinueStatement(target, continueKeyword, endToken, t1));
    },
    handleEmptyStatement$1: function(token) {
      var t1 = $.Node__HASH_COUNTER + 1;
      $.Node__HASH_COUNTER = t1;
      this.pushNode$1(new Y.EmptyStatement0(token, t1));
    },
    endFactoryMethod$2: function(beginToken, endToken) {
      var body, formals, $name, t1, modifier, modifierCount, modifiers;
      Y.ElementListener.prototype.endFactoryMethod$2.call(this, beginToken, endToken);
      body = this.popNode$0();
      formals = this.popNode$0();
      $name = this.popNode$0();
      if (beginToken.get$stringValue() === "external") {
        t1 = $.Node__HASH_COUNTER + 1;
        $.Node__HASH_COUNTER = t1;
        this.pushNode$1(new Y.Identifier(beginToken, null, t1));
        modifier = beginToken.next;
        modifierCount = 1;
      } else {
        modifier = beginToken;
        modifierCount = 0;
      }
      if (modifier.get$stringValue() === "const") {
        t1 = $.Node__HASH_COUNTER + 1;
        $.Node__HASH_COUNTER = t1;
        this.pushNode$1(new Y.Identifier(modifier, null, t1));
        ++modifierCount;
        modifier = modifier.next;
      }
      t1 = $.Node__HASH_COUNTER + 1;
      $.Node__HASH_COUNTER = t1;
      this.pushNode$1(new Y.Identifier(modifier, null, t1));
      this.handleModifiers$1(modifierCount + 1);
      modifiers = this.popNode$0();
      t1 = $.Node__HASH_COUNTER + 1;
      $.Node__HASH_COUNTER = t1;
      this.pushNode$1(new Y.FunctionExpression($name, formals, body, null, modifiers, null, null, null, t1));
    },
    endForIn$3: function(beginToken, inKeyword, endToken) {
      var body, expression, declaredIdentifier, t1;
      body = this.popNode$0();
      expression = this.popNode$0();
      declaredIdentifier = this.popNode$0();
      t1 = $.Node__HASH_COUNTER + 1;
      $.Node__HASH_COUNTER = t1;
      this.pushNode$1(new Y.ForIn0(declaredIdentifier, expression, beginToken, inKeyword, null, body, t1));
    },
    endMetadataStar$2: function(count, forParameter) {
      if (forParameter)
        if (0 === count)
          this.pushNode$1(null);
        else
          this.pushNode$1(this.makeNodeList$4(count, null, null, " "));
    },
    endMetadata$3: function(beginToken, periodBeforeName, endToken) {
      var $arguments, $name, typeArguments, receiver, t1, identifier, send, $constructor, t2, t3;
      $arguments = this.popNode$0();
      if ($arguments == null) {
        $name = periodBeforeName != null ? this.popNode$0() : null;
        typeArguments = this.popNode$0();
        receiver = this.popNode$0();
        if (typeArguments != null) {
          t1 = $.Node__HASH_COUNTER + 1;
          $.Node__HASH_COUNTER = t1;
          receiver = new Y.TypeAnnotation(receiver, typeArguments, t1);
          this.reportFatalError$2(typeArguments, "Type arguments are not allowed here.");
        } else {
          identifier = receiver.asIdentifier$0();
          send = receiver.asSend$0();
          if (identifier != null) {
            t1 = $.Node__HASH_COUNTER + 1;
            $.Node__HASH_COUNTER = t1;
            receiver = new Y.Send(null, identifier, null, null, t1);
          } else if (send == null)
            this.internalError$1$node(receiver);
        }
        if ($name != null) {
          t1 = $.Node__HASH_COUNTER + 1;
          $.Node__HASH_COUNTER = t1;
          send = new Y.Send(receiver, $name, null, null, t1);
        } else
          send = receiver;
        t1 = $.Node__HASH_COUNTER + 1;
        $.Node__HASH_COUNTER = t1;
        this.pushNode$1(new Y.Metadata(beginToken, send, t1));
      } else {
        this.endConstructorReference$3(beginToken, periodBeforeName, endToken);
        $constructor = this.popNode$0();
        t1 = $.Node__HASH_COUNTER + 1;
        $.Node__HASH_COUNTER = t1;
        t2 = t1 + 1;
        $.Node__HASH_COUNTER = t2;
        t3 = t2 + 1;
        $.Node__HASH_COUNTER = t3;
        this.pushNode$1(new Y.Metadata(beginToken, new Y.NewExpression(null, new Y.Send(null, $constructor, $arguments, null, t1), t2), t3));
      }
    },
    handleAssertStatement$2: function(assertKeyword, semicolonToken) {
      var $arguments, t1, t2, t3;
      $arguments = this.popNode$0();
      t1 = $.Node__HASH_COUNTER + 1;
      $.Node__HASH_COUNTER = t1;
      t2 = t1 + 1;
      $.Node__HASH_COUNTER = t2;
      t3 = t2 + 1;
      $.Node__HASH_COUNTER = t3;
      this.pushNode$1(new Y.ExpressionStatement0(new Y.Send(null, new Y.Identifier(assertKeyword, null, t1), $arguments, null, t2), semicolonToken, t3));
    },
    endUnamedFunction$1: function(token) {
      var body, formals, t1, t2;
      body = this.popNode$0();
      formals = this.popNode$0();
      t1 = $.get$Modifiers_EMPTY();
      t2 = $.Node__HASH_COUNTER + 1;
      $.Node__HASH_COUNTER = t2;
      this.pushNode$1(new Y.FunctionExpression(null, formals, body, null, t1, null, null, null, t2));
    },
    handleIsOperator$3: function(operathor, not, endToken) {
      var type, expression, t1, t2, t3, t0, argument, t4;
      type = this.popNode$0();
      expression = this.popNode$0();
      if (not != null) {
        t1 = $.Node__HASH_COUNTER + 1;
        $.Node__HASH_COUNTER = t1;
        t2 = t1 + 1;
        $.Node__HASH_COUNTER = t2;
        t3 = new Y.Prefix0(C.C_Link3, null, null, null, t2);
        t0 = t3;
        t3 = t2;
        t2 = t0;
        ++t3;
        $.Node__HASH_COUNTER = t3;
        argument = new Y.Send(type, new Y.Operator(not, null, t1), t2, null, t3);
      } else
        argument = type;
      t1 = E.LinkEntry$(argument, C.C_Link3, H.getTypeArgumentByIndex(C.C_Link3, 0));
      t2 = $.Node__HASH_COUNTER + 1;
      $.Node__HASH_COUNTER = t2;
      t3 = t2 + 1;
      $.Node__HASH_COUNTER = t3;
      t4 = t3 + 1;
      $.Node__HASH_COUNTER = t4;
      this.pushNode$1(new Y.Send(expression, new Y.Operator(operathor, null, t3), new Y.NodeList(t1, null, null, null, t2), null, t4));
    },
    handleLabel$1: function(colon) {
      var $name, t1;
      $name = this.popNode$0();
      t1 = $.Node__HASH_COUNTER + 1;
      $.Node__HASH_COUNTER = t1;
      this.pushNode$1(new Y.Label($name, colon, t1));
    },
    endLabeledStatement$1: function(labelCount) {
      var statement, labels, t1;
      statement = this.popNode$0();
      labels = this.makeNodeList$4(labelCount, null, null, null);
      t1 = $.Node__HASH_COUNTER + 1;
      $.Node__HASH_COUNTER = t1;
      this.pushNode$1(new Y.LabeledStatement(labels, statement, t1));
    },
    internalError$2$node$token: function(node, token) {
      throw H.wrapException(O.SpannableAssertionFailure$(node, "Internal error in parser."));
    },
    internalError$1$node: function(node) {
      return this.internalError$2$node$token(node, null);
    }
  },
  NodeListener_handleLiteralInt_closure: {
    "^": "Closure:19;this_0",
    call$2: function(t, e) {
      this.this_0.listener.internalError$2(t, "'" + H.S(t.get$value(t)) + "': " + H.S(e));
      return;
    },
    $isFunction: true
  },
  NodeListener_handleLiteralDouble_closure: {
    "^": "Closure:19;this_0",
    call$2: function(t, e) {
      this.this_0.listener.internalError$2(t, "'" + H.S(t.get$value(t)) + "': " + H.S(e));
      return;
    },
    $isFunction: true
  },
  NodeListener_handleLiteralBool_closure: {
    "^": "Closure:19;this_0",
    call$2: function(t, e) {
      this.this_0.listener.internalError$2(t, "'" + H.S(t.get$value(t)) + "': " + H.S(e));
      return;
    },
    $isFunction: true
  },
  PartialElement: {
    "^": "Object;hasParseError:scanner$PartialElement$hasParseError?",
    get$isErroneous: function() {
      return this.scanner$PartialElement$hasParseError;
    },
    $isPartialElement: true,
    $isElement: true
  },
  PartialFunctionMixin: {
    "^": "Object;beginToken:scanner$PartialFunctionMixin$beginToken<",
    init$3: function(beginToken, getOrSet, endToken) {
      var t1, t2;
      this.scanner$PartialFunctionMixin$beginToken = beginToken;
      this.scanner$PartialFunctionMixin$getOrSet = getOrSet;
      this.scanner$PartialFunctionMixin$endToken = endToken;
      t1 = (this.get$modifiers().flags & 32) !== 0 || this.kind === C.ElementKind_generative_constructor_16;
      t2 = this.enclosingElement;
      this.scanner$PartialFunctionMixin$_scanner$_position = U.ElementX_findNameToken(beginToken, t1, this.name, t2.get$name(t2));
    },
    get$node: function() {
      return this.scanner$PartialFunctionMixin$cachedNode;
    },
    parseNode$1: function(listener) {
      var t1 = this.scanner$PartialFunctionMixin$cachedNode;
      if (t1 != null)
        return t1;
      t1 = Y.parse(listener, this, new Y.PartialFunctionMixin_parseNode_parseFunction(this));
      this.scanner$PartialFunctionMixin$cachedNode = t1;
      return t1;
    },
    get$position: function(_) {
      return this.scanner$PartialFunctionMixin$_scanner$_position;
    },
    $isFunctionElement: true,
    $isAstElement: true,
    $isElement: true
  },
  PartialFunctionMixin_parseNode_parseFunction: {
    "^": "Closure:248;this_0",
    call$1: function(p) {
      var t1, t2, t3;
      t1 = this.this_0;
      t2 = t1.get$isClassMember() && (t1.modifiers.flags & 32) !== 0;
      t3 = t1.scanner$PartialFunctionMixin$beginToken;
      if (t2)
        p.parseFactoryMethod$1(t3);
      else
        p.parseFunction$2(t3, t1.scanner$PartialFunctionMixin$getOrSet);
    },
    $isFunction: true
  },
  PartialFunctionElement: {
    "^": "FunctionElementX_PartialElement_PartialFunctionMixin;scanner$PartialFunctionMixin$cachedNode,scanner$PartialFunctionMixin$beginToken,scanner$PartialFunctionMixin$getOrSet,scanner$PartialFunctionMixin$endToken,scanner$PartialFunctionMixin$_scanner$_position,scanner$PartialElement$hasParseError,resolution$AnalyzableElementX$_treeElements,typeCache,modifiers,nestedClosures,functionSignatureCache,_hasNoBody,abstractField,modelx$PatchMixin$patch,modelx$PatchMixin$origin,name,kind,enclosingElement,hashCode,metadata,_fixedBackendName,_isNative"
  },
  FunctionElementX_PartialElement: {
    "^": "FunctionElementX+PartialElement;hasParseError:scanner$PartialElement$hasParseError?",
    $isPartialElement: true,
    $isElement: true
  },
  FunctionElementX_PartialElement_PartialFunctionMixin: {
    "^": "FunctionElementX_PartialElement+PartialFunctionMixin;beginToken:scanner$PartialFunctionMixin$beginToken<",
    $isFunctionElement: true,
    $isAstElement: true,
    $isElement: true
  },
  PartialConstructorElement: {
    "^": "ConstructorElementX_PartialElement_PartialFunctionMixin;scanner$PartialFunctionMixin$cachedNode,scanner$PartialFunctionMixin$beginToken,scanner$PartialFunctionMixin$getOrSet,scanner$PartialFunctionMixin$endToken,scanner$PartialFunctionMixin$_scanner$_position,scanner$PartialElement$hasParseError,immediateRedirectionTarget,internalEffectiveTarget,effectiveTargetType,resolution$AnalyzableElementX$_treeElements,typeCache,modifiers,nestedClosures,functionSignatureCache,_hasNoBody,abstractField,modelx$PatchMixin$patch,modelx$PatchMixin$origin,name,kind,enclosingElement,hashCode,metadata,_fixedBackendName,_isNative"
  },
  ConstructorElementX_PartialElement: {
    "^": "ConstructorElementX+PartialElement;hasParseError:scanner$PartialElement$hasParseError?",
    $isPartialElement: true,
    $isElement: true
  },
  ConstructorElementX_PartialElement_PartialFunctionMixin: {
    "^": "ConstructorElementX_PartialElement+PartialFunctionMixin;beginToken:scanner$PartialFunctionMixin$beginToken<",
    $isFunctionElement: true,
    $isAstElement: true,
    $isElement: true
  },
  PartialFieldList: {
    "^": "VariableList;beginToken<,endToken,hasParseError,definitions,type,modifiers,metadata",
    parseNode$2: function(element, listener) {
      var t1 = this.definitions;
      if (t1 != null)
        return t1;
      listener.withCurrentElement$2(element, new Y.PartialFieldList_parseNode_closure(this, element, listener));
      return this.definitions;
    },
    computeType$2: function(element, compiler) {
      var t1 = this.type;
      if (t1 != null)
        return t1;
      compiler.withCurrentElement$2(element, new Y.PartialFieldList_computeType_closure(this, element, compiler));
      return this.type;
    }
  },
  PartialFieldList_parseNode_closure: {
    "^": "Closure:23;this_0,element_1,listener_2",
    call$0: function() {
      var t1, t2, t3;
      t1 = this.this_0;
      t2 = this.listener_2;
      t3 = Y.parse(t2, this.element_1, new Y.PartialFieldList_parseNode__closure(t1));
      t1.definitions = t3;
      if (t1.hasParseError !== true)
        if ((t3.get$modifiers().flags & 8) === 0)
          if ((t1.definitions.get$modifiers().flags & 4) === 0)
            if ((t1.definitions.get$modifiers().flags & 16) === 0) {
              t3 = t1.definitions;
              t3 = t3.get$type(t3) == null && !t1.definitions.get$isErroneous();
            } else
              t3 = false;
          else
            t3 = false;
        else
          t3 = false;
      else
        t3 = false;
      if (t3)
        t2.reportDiagnosticInternal$4(t1.definitions, C.MessageKind_wwi, P.LinkedHashMap_LinkedHashMap$_literal(["text", "A field declaration must start with var, final, const, or a type annotation."], null, null), C.Diagnostic_1_error);
    },
    $isFunction: true
  },
  PartialFieldList_parseNode__closure: {
    "^": "Closure:248;this_3",
    call$1: function(parser) {
      var t1 = this.this_3;
      if (t1.hasParseError === true)
        parser.listener.suppressParseErrors = true;
      return parser.parseMember$1(t1.beginToken);
    },
    $isFunction: true
  },
  PartialFieldList_computeType_closure: {
    "^": "Closure:23;this_0,element_1,compiler_2",
    call$0: function() {
      var t1, t2, t3, node, t4, type;
      t1 = this.this_0;
      t2 = this.element_1;
      t3 = this.compiler_2;
      node = t1.parseNode$2(t2, t3);
      if (node.get$type(node) != null) {
        t3 = t3.resolver;
        t4 = node.get$type(node);
        type = t3.resolveReturnType$2(t2, t4);
        if (type.get$kind(type) === C.TypeKind_void)
          t3.compiler.reportFatalError$3(t4, C.MessageKind_4lY, C.Map_empty);
        t1.type = type;
      } else
        t1.type = C.C_DynamicType;
    },
    $isFunction: true
  },
  PartialTypedefElement: {
    "^": "TypedefElementX;token<,cachedNode,alias,hasBeenCheckedForCycles,resolutionState,functionSignature,modelx$TypeDeclarationElementX$thisTypeCache,modelx$TypeDeclarationElementX$rawTypeCache,resolution$AnalyzableElementX$_treeElements,name,kind,enclosingElement,hashCode,metadata,_fixedBackendName,_isNative",
    parseNode$1: function(listener) {
      var t1 = this.cachedNode;
      if (t1 != null)
        return t1;
      t1 = Y.parse(listener, this, new Y.PartialTypedefElement_parseNode_closure(this));
      this.cachedNode = t1;
      return t1;
    },
    get$position: function(_) {
      var t1, t2;
      t1 = this.kind === C.ElementKind_generative_constructor_16 || this.get$isFactoryConstructor();
      t2 = this.enclosingElement;
      return U.ElementX_findNameToken(this.token, t1, this.name, t2.get$name(t2));
    }
  },
  PartialTypedefElement_parseNode_closure: {
    "^": "Closure:13;this_0",
    call$1: function(p) {
      return p.parseTopLevelDeclaration$1(this.this_0.token);
    },
    $isFunction: true
  },
  PartialMetadataAnnotation: {
    "^": "MetadataAnnotationX;beginToken<,tokenAfterEndToken,cachedNode,value,annotatedElement,resolutionState",
    get$endToken: function() {
      var token, t1, token0;
      token = this.beginToken;
      for (t1 = this.tokenAfterEndToken; token.get$info().kind !== 0; token = token0) {
        token0 = token.next;
        if (token0 == null ? t1 == null : token0 === t1)
          break;
      }
      return token;
    },
    parseNode$1: function(listener) {
      var t1 = this.cachedNode;
      if (t1 != null)
        return t1;
      t1 = Y.parse(listener, this.annotatedElement, new Y.PartialMetadataAnnotation_parseNode_closure(this)).get$expression();
      this.cachedNode = t1;
      return t1;
    }
  },
  PartialMetadataAnnotation_parseNode_closure: {
    "^": "Closure:13;this_0",
    call$1: function(p) {
      return p.parseMetadata$1(this.this_0.beginToken);
    },
    $isFunction: true
  },
  FormalParameterType: {
    "^": "Object;type>",
    static: {"^": "FormalParameterType_REQUIRED,FormalParameterType_POSITIONAL,FormalParameterType_NAMED"}
  },
  Parser: {
    "^": "Object;listener,mayParseFunctionExpressions",
    parseUnit$1: function(token) {
      var t1, count, t2;
      for (t1 = this.listener, count = 0; token.get$info().kind !== 0;) {
        token = this.parseTopLevelDeclaration$1(token);
        t2 = t1.metadata;
        if (!t2.get$isEmpty(t2)) {
          t2 = t1.metadata;
          t1.reportFatalError$2(t2.get$head(t2).get$beginToken(), "Metadata not supported here.");
          t1.metadata = C.C_Link2;
        }
        ++count;
      }
      t1.endCompilationUnit$2(count, token);
      return token;
    },
    parseTopLevelDeclaration$1: function(token) {
      var value, t1, token0, t2, token1, implementsKeyword, $name, t3, deferredKeyword, asKeyword, combinators, prefix, uri;
      token = this.parseMetadataStar$1(token);
      value = token.get$stringValue();
      if (value === "abstract" && "class" === token.next.get$stringValue() || value === "class")
        return this.parseClassOrNamedMixinApplication$1(token);
      else if (value === "typedef") {
        t1 = this.peekAfterType$1(token.next).get$stringValue();
        token0 = token.next;
        if ("=" === t1) {
          if (!token0.isIdentifier$0())
            token0 = this.listener.expectedIdentifier$1(token0);
          t1 = this.listener;
          t2 = $.Node__HASH_COUNTER + 1;
          $.Node__HASH_COUNTER = t2;
          t1.nodes = t1.nodes.prepend$1(new Y.Identifier(token0, null, t2));
          token0 = this.parseMixinApplication$1(this.parseModifiers$1(this.expect$2("=", this.parseTypeVariablesOpt$1(token0.next))));
          if ("implements" === token0.get$stringValue()) {
            token1 = this.parseTypeList$1(token0.next);
            implementsKeyword = token0;
            token0 = token1;
          } else
            implementsKeyword = null;
          t1.endNamedMixinApplication$3(token, implementsKeyword, token0);
          token = token0;
        } else {
          token0 = this.parseReturnTypeOpt$1(token0);
          if (!token0.isIdentifier$0())
            token0 = this.listener.expectedIdentifier$1(token0);
          t1 = this.listener;
          t2 = $.Node__HASH_COUNTER + 1;
          $.Node__HASH_COUNTER = t2;
          t1.nodes = t1.nodes.prepend$1(new Y.Identifier(token0, null, t2));
          token0 = this.parseFormalParameters$1(this.parseTypeVariablesOpt$1(token0.next));
          t1.endFunctionTypeAlias$2(token, token0);
          token = token0;
        }
        return this.expect$2(";", token);
      } else if (value === "library") {
        token0 = this.expect$2(";", this.parseQualified$1(token.next));
        t1 = this.listener;
        $name = t1.popNode$0();
        t2 = t1.popMetadata$1(t1.compilationUnitElement);
        t3 = $.Node__HASH_COUNTER + 1;
        $.Node__HASH_COUNTER = t3;
        t1.addLibraryTag$1(new Y.LibraryName($name, token, t2, t3));
        return token0;
      } else if (value === "import") {
        token0 = this.parseLiteralStringOrRecoverExpression$1(token.next);
        if ("deferred" === token0.get$stringValue()) {
          token1 = token0.next;
          deferredKeyword = token0;
          token0 = token1;
        } else
          deferredKeyword = null;
        if ("as" === token0.get$stringValue()) {
          token1 = token0.next;
          if (!token1.isIdentifier$0())
            token1 = this.listener.expectedIdentifier$1(token1);
          t1 = this.listener;
          t2 = $.Node__HASH_COUNTER + 1;
          $.Node__HASH_COUNTER = t2;
          t1.nodes = t1.nodes.prepend$1(new Y.Identifier(token1, null, t2));
          token1 = token1.next;
          asKeyword = token0;
          token0 = token1;
        } else
          asKeyword = null;
        token0 = this.expect$2(";", this.parseCombinators$1(token0));
        t1 = this.listener;
        combinators = t1.popNode$0();
        prefix = asKeyword != null ? t1.popNode$0() : null;
        uri = t1.popLiteralString$0();
        t2 = t1.popMetadata$1(t1.compilationUnitElement);
        t3 = $.Node__HASH_COUNTER + 1;
        $.Node__HASH_COUNTER = t3;
        t1.addLibraryTag$1(new Y.Import(prefix, token, deferredKeyword != null, uri, combinators, t2, t3));
        return token0;
      } else if (value === "export") {
        token0 = this.expect$2(";", this.parseCombinators$1(this.parseLiteralStringOrRecoverExpression$1(token.next)));
        t1 = this.listener;
        combinators = t1.popNode$0();
        uri = t1.popNode$0();
        t2 = t1.popMetadata$1(t1.compilationUnitElement);
        t3 = $.Node__HASH_COUNTER + 1;
        $.Node__HASH_COUNTER = t3;
        t1.addLibraryTag$1(new Y.Export(token, uri, combinators, t2, t3));
        return token0;
      } else if (value === "part")
        return this.parsePartOrPartOf$1(token);
      else
        return this.parseTopLevelMember$1(token);
    },
    parseCombinators$1: function(token) {
      var t1, count, value, token0, identifiers, t2;
      for (t1 = this.listener, count = 0; true;) {
        value = token.get$stringValue();
        if ("hide" === value) {
          token0 = this.parseIdentifierList$1(token.next);
          identifiers = t1.popNode$0();
          t2 = $.Node__HASH_COUNTER + 1;
          $.Node__HASH_COUNTER = t2;
          t1.nodes = t1.nodes.prepend$1(new Y.Combinator(identifiers, token, t2));
          token = token0;
        } else {
          if ("show" === value) {
            token0 = this.parseIdentifierList$1(token.next);
            identifiers = t1.popNode$0();
            t2 = $.Node__HASH_COUNTER + 1;
            $.Node__HASH_COUNTER = t2;
            t1.nodes = t1.nodes.prepend$1(new Y.Combinator(identifiers, token, t2));
          } else {
            if (0 === count)
              t1.nodes = t1.nodes.prepend$1(null);
            else {
              t2 = t1.makeNodeList$4(count, null, null, " ");
              t1.nodes = t1.nodes.prepend$1(t2);
            }
            break;
          }
          token = token0;
        }
        ++count;
      }
      return token;
    },
    parseIdentifierList$1: function(token) {
      var t1, count, t2;
      token = this.parseIdentifier$1(token);
      for (t1 = this.listener, count = 1; "," === token.get$stringValue();) {
        token = token.next;
        if (!token.isIdentifier$0())
          token = t1.expectedIdentifier$1(token);
        t2 = $.Node__HASH_COUNTER + 1;
        $.Node__HASH_COUNTER = t2;
        t1.nodes = t1.nodes.prepend$1(new Y.Identifier(token, null, t2));
        token = token.next;
        ++count;
      }
      t1.pushNode$1(t1.makeNodeList$4(count, null, null, ","));
      return token;
    },
    parseTypeList$1: function(token) {
      var count, t1;
      token = this.parseType$1(token);
      for (count = 1; "," === token.get$stringValue();) {
        token = this.parseType$1(token.next);
        ++count;
      }
      t1 = this.listener;
      t1.pushNode$1(t1.makeNodeList$4(count, null, null, ","));
      return token;
    },
    parsePartOrPartOf$1: function(token) {
      var t1, t2, t3, token0, $name, uri;
      t1 = token.next.get$stringValue();
      t2 = token.next;
      t3 = this.listener;
      if ("of" === t1) {
        token0 = this.expect$2(";", this.parseQualified$1(t2.next));
        $name = t3.popNode$0();
        t1 = t3.popMetadata$1(t3.compilationUnitElement);
        t2 = $.Node__HASH_COUNTER + 1;
        $.Node__HASH_COUNTER = t2;
        t3.addPartOfTag$1(new Y.PartOf($name, token, t1, t2));
        return token0;
      } else {
        token0 = this.expect$2(";", this.parseLiteralStringOrRecoverExpression$1(t2));
        uri = t3.popLiteralString$0();
        t1 = t3.popMetadata$1(t3.compilationUnitElement);
        t2 = $.Node__HASH_COUNTER + 1;
        $.Node__HASH_COUNTER = t2;
        t3.addLibraryTag$1(new Y.Part(uri, token, t1, t2));
        return token0;
      }
    },
    parseMetadataStar$2$forParameter: function(token, forParameter) {
      var count;
      for (count = 0; "@" === token.get$stringValue();) {
        token = this.parseMetadata$1(token);
        ++count;
      }
      this.listener.endMetadataStar$2(count, forParameter);
      return token;
    },
    parseMetadataStar$1: function(token) {
      return this.parseMetadataStar$2$forParameter(token, false);
    },
    parseMetadata$1: function(token) {
      var token0, t1, t2, token1, period;
      token0 = token.next;
      if (!token0.isIdentifier$0())
        token0 = this.listener.expectedIdentifier$1(token0);
      t1 = this.listener;
      t2 = $.Node__HASH_COUNTER + 1;
      $.Node__HASH_COUNTER = t2;
      t1.nodes = t1.nodes.prepend$1(new Y.Identifier(token0, null, t2));
      token0 = this.parseTypeArgumentsOpt$1(this.parseQualifiedRestOpt$1(token0.next));
      if ("." === token0.get$stringValue()) {
        token1 = token0.next;
        if (!token1.isIdentifier$0())
          token1 = t1.expectedIdentifier$1(token1);
        t2 = $.Node__HASH_COUNTER + 1;
        $.Node__HASH_COUNTER = t2;
        t1.nodes = t1.nodes.prepend$1(new Y.Identifier(token1, null, t2));
        token1 = token1.next;
        period = token0;
        token0 = token1;
      } else
        period = null;
      token0 = this.parseArgumentsOpt$1(token0);
      t1.endMetadata$3(token, period, token0);
      return token0;
    },
    parseMixinApplication$1: function(token) {
      var t1, mixins, superclass, t2;
      token = this.parseTypeList$1(this.expect$2("with", this.parseType$1(token)));
      t1 = this.listener;
      mixins = t1.popNode$0();
      superclass = t1.popNode$0();
      t2 = $.Node__HASH_COUNTER + 1;
      $.Node__HASH_COUNTER = t2;
      t1.pushNode$1(new Y.MixinApplication(superclass, mixins, t2));
      return token;
    },
    parseReturnTypeOpt$1: function(token) {
      var t1, t2;
      if (token.get$stringValue() === "void") {
        t1 = $.Node__HASH_COUNTER + 1;
        $.Node__HASH_COUNTER = t1;
        t2 = t1 + 1;
        $.Node__HASH_COUNTER = t2;
        this.listener.pushNode$1(new Y.TypeAnnotation(new Y.Identifier(token, null, t1), null, t2));
        return token.next;
      } else
        return this.parseTypeOpt$1(token);
    },
    parseFormalParametersOpt$1: function(token) {
      if ("(" === token.get$stringValue())
        return this.parseFormalParameters$1(token);
      else {
        this.listener.handleNoFormalParameters$1(token);
        return token;
      }
    },
    parseFormalParameters$1: function(token) {
      var token0, parameterCount, value;
      this.expect$2("(", token);
      if (")" === token.next.get$stringValue()) {
        this.listener.endFormalParameters$3(0, token, token.next);
        return token.next.next;
      }
      token0 = token;
      parameterCount = 0;
      do {
        ++parameterCount;
        token0 = token0.next;
        value = token0.get$stringValue();
        if (value === "[") {
          token0 = this.parseOptionalFormalParameters$2(token0, false);
          break;
        } else if (value === "{") {
          token0 = this.parseOptionalFormalParameters$2(token0, true);
          break;
        }
        token0 = this.parseFormalParameter$2(token0, C.FormalParameterType_required);
      } while ("," === token0.get$stringValue());
      this.listener.endFormalParameters$3(parameterCount, token, token0);
      return this.expect$2(")", token0);
    },
    parseFormalParameter$2: function(token, type) {
      var token0, thisKeyword, t1, t2, value;
      token = this.parseReturnTypeOpt$1(this.parseModifiers$1(this.parseMetadataStar$2$forParameter(token, true)));
      if ("this" === token.get$stringValue()) {
        token0 = this.expect$2(".", token.next);
        thisKeyword = token;
        token = token0;
      } else
        thisKeyword = null;
      if (!token.isIdentifier$0())
        token = this.listener.expectedIdentifier$1(token);
      t1 = this.listener;
      t2 = $.Node__HASH_COUNTER + 1;
      $.Node__HASH_COUNTER = t2;
      t1.nodes = t1.nodes.prepend$1(new Y.Identifier(token, null, t2));
      token = token.next;
      if ("(" === token.get$stringValue()) {
        token = this.parseFormalParameters$1(token);
        t1.handleFunctionTypedFormalParameter$1(token);
      }
      value = token.get$stringValue();
      t2 = "=" === value;
      if (t2 || ":" === value) {
        token0 = this.parseExpression$1(token.next);
        t1.handleValuedFormalParameter$2(token, token0);
        if (type === C.FormalParameterType_required)
          t1.reportError$2(token, C.MessageKind_XSe);
        else if (type === C.FormalParameterType_named && t2)
          t1.reportError$2(token, C.MessageKind_ZaR);
        else if (type === C.FormalParameterType_positional && ":" === value)
          t1.reportError$2(token, C.MessageKind_oqh);
        token = token0;
      }
      t1.endFormalParameter$1(thisKeyword);
      return token;
    },
    parseOptionalFormalParameters$2: function(token, isNamed) {
      var token0, parameterCount;
      token0 = token;
      parameterCount = 0;
      do {
        token0 = token0.next;
        token0 = this.parseFormalParameter$2(token0, isNamed ? C.FormalParameterType_named : C.FormalParameterType_positional);
        ++parameterCount;
      } while ("," === token0.get$stringValue());
      this.listener.endOptionalFormalParameters$3(parameterCount, token, token0);
      if (isNamed)
        return this.expect$2("}", token0);
      else
        return this.expect$2("]", token0);
    },
    parseTypeOpt$1: function(token) {
      var peek, t1;
      token.get$stringValue();
      peek = this.peekAfterIfType$1(token);
      if (peek != null)
        t1 = peek.isIdentifier$0() || "this" === peek.get$stringValue();
      else
        t1 = false;
      if (t1)
        return this.parseType$1(token);
      this.listener.pushNode$1(null);
      return token;
    },
    isValidTypeReference$1: function(token) {
      var kind, keyword, value;
      kind = token.get$info().kind;
      if (kind === 97)
        return true;
      if (kind === 107) {
        keyword = H.interceptedTypeCast(token, "$isKeywordToken").keyword;
        value = keyword.syntax;
        return keyword.isPseudo || value === "dynamic" || value === "void";
      }
      return false;
    },
    parseQualified$1: function(token) {
      var t1, t2, last, first;
      token = this.parseIdentifier$1(token);
      for (t1 = this.listener; "." === token.get$stringValue();) {
        token = token.next;
        if (!token.isIdentifier$0())
          token = t1.expectedIdentifier$1(token);
        t2 = $.Node__HASH_COUNTER + 1;
        $.Node__HASH_COUNTER = t2;
        t1.nodes = t1.nodes.prepend$1(new Y.Identifier(token, null, t2));
        token = token.next;
        last = t1.popNode$0();
        first = t1.popNode$0();
        t2 = $.Node__HASH_COUNTER + 1;
        $.Node__HASH_COUNTER = t2;
        t1.nodes = t1.nodes.prepend$1(new Y.Send(first, last, null, null, t2));
      }
      return token;
    },
    parseQualifiedRestOpt$1: function(token) {
      if ("." === token.get$stringValue())
        return this.parseQualifiedRest$1(token);
      else
        return token;
    },
    parseQualifiedRest$1: function(token) {
      var t1, t2, last, first;
      token = token.next;
      if (!token.isIdentifier$0())
        token = this.listener.expectedIdentifier$1(token);
      t1 = this.listener;
      t2 = $.Node__HASH_COUNTER + 1;
      $.Node__HASH_COUNTER = t2;
      t1.nodes = t1.nodes.prepend$1(new Y.Identifier(token, null, t2));
      token = token.next;
      last = t1.popNode$0();
      first = t1.popNode$0();
      t2 = $.Node__HASH_COUNTER + 1;
      $.Node__HASH_COUNTER = t2;
      t1.nodes = t1.nodes.prepend$1(new Y.Send(first, last, null, null, t2));
      return token;
    },
    skipBlock$1: function(token) {
      var endGroup;
      if ("{" !== token.get$stringValue())
        return this.listener.expectedBlockToSkip$1(token);
      endGroup = token.get$endGroup();
      if (endGroup == null)
        return this.listener.unmatched$1(token);
      else if (endGroup.get$info().kind !== 125)
        return this.listener.unmatched$1(token);
      return token.endGroup;
    },
    parseClassOrNamedMixinApplication$1: function(token) {
      var token0, abstractKeyword, isMixinApplication, token1, modifierCount, t1, implementsKeyword;
      if ("abstract" === token.get$stringValue()) {
        token0 = token.next;
        abstractKeyword = token;
      } else {
        token0 = token;
        abstractKeyword = null;
      }
      isMixinApplication = "=" === this.peekAfterType$1(token0.next).get$stringValue();
      token1 = isMixinApplication ? this.expect$2("=", this.parseTypeVariablesOpt$1(this.parseIdentifier$1(token0.next))) : token0;
      if (abstractKeyword != null) {
        this.parseModifier$1(abstractKeyword);
        modifierCount = 1;
      } else
        modifierCount = 0;
      t1 = this.listener;
      t1.handleModifiers$1(modifierCount);
      if (isMixinApplication) {
        token = this.parseMixinApplication$1(token1);
        if ("implements" === token.get$stringValue()) {
          token1 = this.parseTypeList$1(token.next);
          implementsKeyword = token;
          token = token1;
        } else
          implementsKeyword = null;
        t1.endNamedMixinApplication$3(token0, implementsKeyword, token);
        return this.expect$2(";", token);
      } else
        return this.parseClass$2(token, token0);
    },
    parseClass$2: function(begin, classKeyword) {
      var token, t1, t2, token0, extendsKeyword, interfacesCount, implementsKeyword;
      token = this.parseTypeVariablesOpt$1(this.parseIdentifier$1(classKeyword.next));
      if ("extends" === token.get$stringValue()) {
        t1 = this.peekAfterType$1(token.next).get$stringValue();
        t2 = token.next;
        token0 = "with" === t1 ? this.parseMixinApplication$1(t2) : this.parseType$1(t2);
        extendsKeyword = token;
        token = token0;
      } else {
        this.listener.pushNode$1(null);
        extendsKeyword = null;
      }
      if ("implements" === token.get$stringValue()) {
        token0 = token;
        interfacesCount = 0;
        do {
          token0 = this.parseType$1(token0.next);
          ++interfacesCount;
        } while ("," === token0.get$stringValue());
        implementsKeyword = token;
        token = token0;
      } else {
        implementsKeyword = null;
        interfacesCount = 0;
      }
      token = this.parseClassBody$1(token);
      this.listener.endClassDeclaration$5(interfacesCount, begin, extendsKeyword, implementsKeyword, token);
      return token.next;
    },
    parseStringPart$1: function(token) {
      var t1, t2;
      t1 = this.listener;
      if (token.get$info().kind === 39) {
        t2 = $.Node__HASH_COUNTER + 1;
        $.Node__HASH_COUNTER = t2;
        t1.nodes = t1.nodes.prepend$1(new Y.LiteralString(token, null, t2));
        return token.next;
      } else
        return t1.expected$2("string", token);
    },
    parseIdentifier$1: function(token) {
      var t1, t2;
      if (!token.isIdentifier$0())
        token = this.listener.expectedIdentifier$1(token);
      t1 = this.listener;
      t2 = $.Node__HASH_COUNTER + 1;
      $.Node__HASH_COUNTER = t2;
      t1.nodes = t1.nodes.prepend$1(new Y.Identifier(token, null, t2));
      return token.next;
    },
    expect$2: function(string, token) {
      if (string !== token.get$stringValue())
        return this.listener.expected$2(string, token);
      return token.next;
    },
    parseType$1: function(token) {
      var t1, t2, typeArguments, typeName;
      if (this.isValidTypeReference$1(token)) {
        if (!token.isIdentifier$0())
          token = this.listener.expectedIdentifier$1(token);
        t1 = this.listener;
        t2 = $.Node__HASH_COUNTER + 1;
        $.Node__HASH_COUNTER = t2;
        t1.nodes = t1.nodes.prepend$1(new Y.Identifier(token, null, t2));
        token = this.parseQualifiedRestOpt$1(token.next);
      } else {
        t1 = this.listener;
        token = t1.expectedType$1(token);
      }
      token = this.parseTypeArgumentsOpt$1(token);
      typeArguments = t1.popNode$0();
      typeName = t1.popNode$0();
      t2 = $.Node__HASH_COUNTER + 1;
      $.Node__HASH_COUNTER = t2;
      t1.nodes = t1.nodes.prepend$1(new Y.TypeAnnotation(typeName, typeArguments, t2));
      return token;
    },
    parseTypeArgumentsOpt$1: function(token) {
      return this.parseStuff$5(token, new Y.Parser_parseTypeArgumentsOpt_closure(this), new Y.Parser_parseTypeArgumentsOpt_closure0(this), new Y.Parser_parseTypeArgumentsOpt_closure1(this), new Y.Parser_parseTypeArgumentsOpt_closure2(this));
    },
    parseTypeVariablesOpt$1: function(token) {
      return this.parseStuff$5(token, new Y.Parser_parseTypeVariablesOpt_closure(this), new Y.Parser_parseTypeVariablesOpt_closure0(this), new Y.Parser_parseTypeVariablesOpt_closure1(this), new Y.Parser_parseTypeVariablesOpt_closure2(this));
    },
    parseStuff$5: function(token, beginStuff, stuffParser, endStuff, handleNoStuff) {
      var token0, count, next, t1;
      if ("<" === token.get$stringValue()) {
        beginStuff.call$1(token);
        token0 = token;
        count = 0;
        do {
          token0 = stuffParser.call$1(token0.get$next());
          ++count;
        } while ("," === token0.get$stringValue());
        next = token0.next;
        if (token0.get$stringValue() === ">>") {
          t1 = token0.charOffset;
          token0 = new Y.SymbolToken(C.PrecedenceInfo_TG0, t1, null);
          t1 = new Y.SymbolToken(C.PrecedenceInfo_TG0, t1 + 1, null);
          token0.next = t1;
          t1.next = next;
        } else if (token0.get$stringValue() === ">>>") {
          t1 = token0.charOffset;
          token0 = new Y.SymbolToken(C.PrecedenceInfo_TG0, t1, null);
          t1 = new Y.SymbolToken(C.PrecedenceInfo_A0t, t1 + 1, null);
          token0.next = t1;
          t1.next = next;
        }
        endStuff.call$3(count, token, token0);
        return this.expect$2(">", token0);
      }
      handleNoStuff.call$1(token);
      return token;
    },
    parseTopLevelMember$1: function(token) {
      var t1, identifiers, $name, value, getOrSet, type, token0, isField, modifiers;
      t1 = this.listener;
      t1.memberErrors = t1.memberErrors.prepend$1(false);
      identifiers = this.findMemberName$1(token);
      if (identifiers.get$isEmpty(identifiers))
        return t1.unexpected$1(token);
      $name = identifiers.get$head(identifiers);
      identifiers = identifiers.get$tail();
      if (!identifiers.get$isEmpty(identifiers)) {
        value = identifiers.get$head(identifiers).get$stringValue();
        if (value === "get" || value === "set") {
          getOrSet = identifiers.get$head(identifiers);
          identifiers = identifiers.get$tail();
        } else
          getOrSet = null;
      } else
        getOrSet = null;
      if (!identifiers.get$isEmpty(identifiers))
        if (this.isValidTypeReference$1(identifiers.get$head(identifiers))) {
          type = identifiers.get$head(identifiers);
          identifiers = identifiers.get$tail();
        } else
          type = null;
      else
        type = null;
      token0 = $name.get$next();
      while (true) {
        if (!true) {
          isField = null;
          break;
        }
        value = token0.get$stringValue();
        if (value === "(" || value === "{" || value === "=>") {
          isField = false;
          break;
        } else if (value === "=" || value === ",") {
          isField = true;
          break;
        } else if (value === ";") {
          isField = getOrSet == null || getOrSet.get$stringValue() !== "get";
          break;
        } else {
          token0 = t1.unexpected$1(token0);
          if (token0.get$info().kind === 0)
            return token0;
        }
      }
      modifiers = identifiers.reverse$0();
      return isField === true ? this.parseFields$6(token, modifiers, type, getOrSet, $name, true) : this.parseTopLevelMethod$5(token, modifiers, type, getOrSet, $name);
    },
    isVarFinalOrConst$1: [function(token) {
      var value = token.get$stringValue();
      return "var" === value || "final" === value || "const" === value;
    }, "call$1", "get$isVarFinalOrConst", 2, 0, 249],
    expectVarFinalOrConst$3: function(modifiers, hasType, allowStatic) {
      var staticModifier, modifierCount, t1, modifier, modifierList, varFinalOrConst, hasTypeOrModifier, kind, t2;
      if (allowStatic && !modifiers.get$isEmpty(modifiers) && "static" === modifiers.get$head(modifiers).get$stringValue()) {
        staticModifier = modifiers.get$head(modifiers);
        this.parseModifier$1(staticModifier);
        modifiers = modifiers.get$tail();
        modifierCount = 1;
      } else {
        modifierCount = 0;
        staticModifier = null;
      }
      if (modifiers.get$isEmpty(modifiers)) {
        this.listener.handleModifiers$1(modifierCount);
        return;
      }
      t1 = modifiers.get$tail();
      if (t1.get$isEmpty(t1)) {
        modifier = modifiers.get$head(modifiers);
        if (this.isVarFinalOrConst$1(modifier)) {
          this.parseModifier$1(modifier);
          this.listener.handleModifiers$1(modifierCount + 1);
          return modifier;
        }
      }
      modifierList = modifiers.toList$0(0);
      varFinalOrConst = H.IterableMixinWorkaround_firstWhere(modifierList, this.get$isVarFinalOrConst(), new Y.Parser_expectVarFinalOrConst_closure());
      if (allowStatic && staticModifier == null) {
        staticModifier = H.IterableMixinWorkaround_firstWhere(modifierList, new Y.Parser_expectVarFinalOrConst_closure0(this), new Y.Parser_expectVarFinalOrConst_closure1());
        if (staticModifier != null) {
          ++modifierCount;
          this.parseModifier$1(staticModifier);
          C.JSArray_methods.remove$1(modifierList, staticModifier);
        }
      }
      if (varFinalOrConst != null) {
        this.parseModifier$1(varFinalOrConst);
        ++modifierCount;
        C.JSArray_methods.remove$1(modifierList, varFinalOrConst);
        hasTypeOrModifier = true;
      } else
        hasTypeOrModifier = hasType;
      t1 = this.listener;
      t1.handleModifiers$1(modifierCount);
      kind = hasTypeOrModifier ? C.MessageKind_KQp : C.MessageKind_o53;
      for (t2 = H.setRuntimeTypeInfo(new H.ListIterator(modifierList, modifierList.length, 0, null), [H.getTypeArgumentByIndex(modifierList, 0)]); t2.moveNext$0();) {
        modifier = t2.__internal$_current;
        t1.reportError$3(modifier, kind, P.LinkedHashMap_LinkedHashMap$_literal(["modifier", modifier], null, null));
      }
      return;
    },
    parseFields$6: function(start, modifiers, type, getOrSet, $name, isTopLevel) {
      var t1, hasType, varFinalOrConst, isVar, hasModifier, kind, token, fieldCount, t2, token0;
      t1 = type == null;
      hasType = !t1;
      varFinalOrConst = this.expectVarFinalOrConst$3(modifiers, hasType, !isTopLevel);
      if (varFinalOrConst != null) {
        isVar = "var" === varFinalOrConst.get$stringValue();
        hasModifier = true;
      } else {
        isVar = false;
        hasModifier = false;
      }
      if (getOrSet != null) {
        kind = hasModifier || hasType ? C.MessageKind_KQp : C.MessageKind_o53;
        this.listener.reportError$3(getOrSet, kind, P.LinkedHashMap_LinkedHashMap$_literal(["modifier", getOrSet], null, null));
      }
      if (t1)
        this.listener.pushNode$1(null);
      else if ("void" === type.get$stringValue()) {
        t1 = this.listener;
        t1.pushNode$1(null);
        t1.reportError$2(type, C.MessageKind_4lY);
      } else {
        this.parseType$1(type);
        if (isVar)
          this.listener.reportError$3(modifiers.get$head(modifiers), C.MessageKind_KQp, P.LinkedHashMap_LinkedHashMap$_literal(["modifier", modifiers.get$head(modifiers)], null, null));
      }
      token = this.parseVariableInitializerOpt$1(this.parseIdentifier$1($name));
      for (t1 = this.listener, fieldCount = 1; "," === token.get$stringValue();) {
        token = token.next;
        if (!token.isIdentifier$0())
          token = t1.expectedIdentifier$1(token);
        t2 = $.Node__HASH_COUNTER + 1;
        $.Node__HASH_COUNTER = t2;
        t1.nodes = t1.nodes.prepend$1(new Y.Identifier(token, null, t2));
        token = this.parseVariableInitializerOpt$1(token.next);
        ++fieldCount;
      }
      token0 = this.expect$2(";", token);
      if (isTopLevel)
        t1.endTopLevelFields$3(fieldCount, start, token);
      else
        t1.endFields$3(fieldCount, start, token);
      return token0;
    },
    parseTopLevelMethod$5: function(start, modifiers, type, getOrSet, $name) {
      var t1, t2, externalModifier, modifier, token;
      for (t1 = H.setRuntimeTypeInfo(new E.LinkIterator(null, modifiers), [H.getTypeArgumentByIndex(modifiers, 0)]), t2 = this.listener, externalModifier = null; t1.moveNext$0();) {
        modifier = t1._util_implementation$_current;
        if (externalModifier == null && "external" === modifier.get$stringValue())
          externalModifier = modifier;
        else
          t2.reportError$3(modifier, C.MessageKind_KQp, P.LinkedHashMap_LinkedHashMap$_literal(["modifier", modifier], null, null));
      }
      t1 = externalModifier != null;
      if (t1) {
        this.parseModifier$1(externalModifier);
        t2.handleModifiers$1(1);
      } else
        t2.handleModifiers$1(0);
      if (type == null)
        t2.pushNode$1(null);
      else
        this.parseReturnTypeOpt$1(type);
      token = this.parseFunctionBody$3(this.parseFormalParametersOpt$1(this.parseIdentifier$1($name)), false, t1);
      t2.endTopLevelMethod$3(start, getOrSet, token);
      return token.next;
    },
    findMemberName$1: function(token) {
      var t1, token0, identifiers, value, t2;
      for (t1 = this.listener, token0 = token, identifiers = C.C_Link11; token0.get$info().kind !== 0;) {
        value = token0.get$stringValue();
        if (value === "(" || value === "{" || value === "=>")
          return identifiers;
        else if (value === "=" || value === ";" || value === ",")
          return identifiers;
        identifiers = identifiers.prepend$1(token0);
        if (this.isValidTypeReference$1(token0)) {
          if ("." === token0.next.get$stringValue())
            token0 = token0.next.next.isIdentifier$0() ? token0.next.next : token0;
          if ("<" === token0.next.get$stringValue()) {
            t2 = token0.next;
            if (!!J.getInterceptor(t2).$isBeginGroupToken) {
              if (t2.get$endGroup() == null)
                t1.unmatched$1(t2);
              token0 = t2.endGroup;
            }
          }
        }
        token0 = token0.next;
      }
      if (!!token.$isErrorToken)
        t1.reportErrorToken$1(token);
      else
        t1.reportFatalError$2(token, "Expected a declaration, but got '" + H.S(token.get$value(token)) + "'.");
      return C.C_Link11;
    },
    parseVariableInitializerOpt$1: function(token) {
      var token0;
      if ("=" === token.get$stringValue()) {
        token0 = this.parseExpression$1(token.next);
        this.listener.endInitializer$1(token);
        token = token0;
      }
      return token;
    },
    parseInitializersOpt$1: function(token) {
      if (":" === token.get$stringValue())
        return this.parseInitializers$1(token);
      else {
        this.listener.handleNoInitializers$0();
        return token;
      }
    },
    parseInitializers$1: function(token) {
      var old, token0, count;
      this.expect$2(":", token);
      old = this.mayParseFunctionExpressions;
      this.mayParseFunctionExpressions = false;
      token0 = token;
      count = 0;
      do {
        token0 = this.parseExpression$1(token0.next);
        ++count;
      } while ("," === token0.get$stringValue());
      this.mayParseFunctionExpressions = old;
      this.listener.endInitializers$3(count, token, token0);
      return token0;
    },
    parseLiteralStringOrRecoverExpression$1: function(token) {
      if (token.get$info().kind === 39)
        return this.parseLiteralString$1(token);
      else {
        this.listener.reportFatalError$2(token, "unexpected");
        return this.parseExpression$1(token);
      }
    },
    isModifier$1: function(token) {
      var value = token.get$stringValue();
      return "final" === value || "var" === value || "const" === value || "abstract" === value || "static" === value || "external" === value;
    },
    parseModifier$1: function(token) {
      var t1, t2;
      t1 = this.listener;
      t2 = $.Node__HASH_COUNTER + 1;
      $.Node__HASH_COUNTER = t2;
      t1.nodes = t1.nodes.prepend$1(new Y.Identifier(token, null, t2));
      return token.next;
    },
    parseModifierList$1: function(tokens) {
      var t1, count, token, t2;
      for (t1 = this.listener, count = 0; !tokens.get$isEmpty(tokens); tokens = tokens.get$tail()) {
        token = tokens.get$head(tokens);
        if (this.isModifier$1(token)) {
          t2 = $.Node__HASH_COUNTER + 1;
          $.Node__HASH_COUNTER = t2;
          t1.nodes = t1.nodes.prepend$1(new Y.Identifier(token, null, t2));
          token.get$next();
        } else
          t1.unexpected$1(token);
        ++count;
      }
      t1.handleModifiers$1(count);
    },
    parseModifiers$1: function(token) {
      var t1, count, t2;
      for (t1 = this.listener, count = 0; token.get$info().kind === 107;) {
        if (!this.isModifier$1(token))
          break;
        t2 = $.Node__HASH_COUNTER + 1;
        $.Node__HASH_COUNTER = t2;
        t1.nodes = t1.nodes.prepend$1(new Y.Identifier(token, null, t2));
        token = token.next;
        ++count;
      }
      t1.handleModifiers$1(count);
      return token;
    },
    peekAfterType$1: function(token) {
      var peek, gtToken;
      peek = token.next;
      if (peek.get$info().kind === 46)
        peek = peek.next.isIdentifier$0() ? peek.next.next : peek;
      if (peek.get$info().kind === 60) {
        gtToken = peek.get$endGroup();
        if (gtToken != null)
          return gtToken.next;
      }
      return peek;
    },
    peekAfterIfType$1: function(token) {
      if ("void" !== token.get$stringValue() && !token.isIdentifier$0())
        return;
      return this.peekAfterType$1(token);
    },
    parseClassBody$1: function(token) {
      var token0, count;
      token0 = ("{" !== token.get$stringValue() ? this.listener.expectedClassBody$1(token) : token).next;
      count = 0;
      while (true) {
        if (!(token0.get$info().kind !== 0 && "}" !== token0.get$stringValue()))
          break;
        token0 = this.parseMember$1(token0);
        ++count;
      }
      this.expect$2("}", token0);
      this.listener.endClassBody$3(count, token, token0);
      return token0;
    },
    parseMember$1: function(token) {
      var token0, t1, identifiers, $name, afterName, value, getOrSet, type, isField, modifiers;
      token = this.parseMetadataStar$1(token);
      token.get$stringValue();
      token0 = "external" === token.get$stringValue() ? token.next : token;
      if ("factory" === ("const" === token0.get$stringValue() ? token0.next : token0).get$stringValue())
        return this.parseFactoryMethod$1(token);
      t1 = this.listener;
      t1.memberErrors = t1.memberErrors.prepend$1(false);
      identifiers = this.findMemberName$1(token);
      if (identifiers.get$isEmpty(identifiers))
        return t1.unexpected$1(token);
      $name = identifiers.get$head(identifiers);
      afterName = $name.get$next();
      identifiers = identifiers.get$tail();
      if (!identifiers.get$isEmpty(identifiers))
        if ("operator" === identifiers.get$head(identifiers).get$stringValue()) {
          $name = identifiers.get$head(identifiers);
          identifiers = identifiers.get$tail();
        }
      if (!identifiers.get$isEmpty(identifiers)) {
        value = identifiers.get$head(identifiers).get$stringValue();
        if (value === "get" || value === "set") {
          getOrSet = identifiers.get$head(identifiers);
          identifiers = identifiers.get$tail();
        } else
          getOrSet = null;
      } else
        getOrSet = null;
      if (!identifiers.get$isEmpty(identifiers))
        if (this.isValidTypeReference$1(identifiers.get$head(identifiers))) {
          type = identifiers.get$head(identifiers);
          identifiers = identifiers.get$tail();
        } else
          type = null;
      else
        type = null;
      token0 = afterName;
      while (true) {
        if (!true) {
          isField = null;
          break;
        }
        value = token0.get$stringValue();
        if (value === "(" || value === "." || value === "{" || value === "=>") {
          isField = false;
          break;
        } else if (value === ";") {
          isField = getOrSet == null || getOrSet.get$stringValue() !== "get";
          break;
        } else if (value === "=" || value === ",") {
          isField = true;
          break;
        } else {
          token0 = t1.unexpected$1(token0);
          if (token0.get$info().kind === 0) {
            t1.endFields$3(1, token, token0);
            return token0;
          }
        }
      }
      modifiers = identifiers.reverse$0();
      return isField === true ? this.parseFields$6(token, modifiers, type, getOrSet, $name, false) : this.parseMethod$5(token, modifiers, type, getOrSet, $name);
    },
    parseMethod$5: function(start, modifiers, type, getOrSet, $name) {
      var t1, t2, externalModifier, staticModifier, constModifier, modifierCount, allowedModifierCount, modifier, token;
      for (t1 = H.setRuntimeTypeInfo(new E.LinkIterator(null, modifiers), [H.getTypeArgumentByIndex(modifiers, 0)]), t2 = this.listener, externalModifier = null, staticModifier = null, constModifier = null, modifierCount = 0, allowedModifierCount = 1; t1.moveNext$0();) {
        modifier = t1._util_implementation$_current;
        if (externalModifier == null && "external" === modifier.get$stringValue()) {
          ++modifierCount;
          if (modifierCount !== allowedModifierCount)
            t2.reportError$3(modifier, C.MessageKind_KQp, P.LinkedHashMap_LinkedHashMap$_literal(["modifier", modifier], null, null));
          ++allowedModifierCount;
          externalModifier = modifier;
        } else if (staticModifier == null && "static" === modifier.get$stringValue()) {
          ++modifierCount;
          if (modifierCount !== allowedModifierCount)
            t2.reportError$3(modifier, C.MessageKind_KQp, P.LinkedHashMap_LinkedHashMap$_literal(["modifier", modifier], null, null));
          staticModifier = modifier;
        } else if (constModifier == null && "const" === modifier.get$stringValue()) {
          ++modifierCount;
          if (modifierCount !== allowedModifierCount)
            t2.reportError$3(modifier, C.MessageKind_KQp, P.LinkedHashMap_LinkedHashMap$_literal(["modifier", modifier], null, null));
          constModifier = modifier;
        } else
          t2.reportError$3(modifier, C.MessageKind_KQp, P.LinkedHashMap_LinkedHashMap$_literal(["modifier", modifier], null, null));
      }
      this.parseModifierList$1(modifiers);
      if (type == null)
        t2.pushNode$1(null);
      else
        this.parseReturnTypeOpt$1(type);
      if ("operator" === $name.get$stringValue()) {
        token = this.parseOperatorName$1($name);
        if (staticModifier != null)
          t2.reportError$3(staticModifier, C.MessageKind_KQp, P.LinkedHashMap_LinkedHashMap$_literal(["modifier", staticModifier], null, null));
      } else
        token = this.parseIdentifier$1($name);
      token = this.parseInitializersOpt$1(this.parseFormalParametersOpt$1(this.parseQualifiedRestOpt$1(token)));
      if ("=" === token.get$stringValue())
        token = this.parseRedirectingFactoryBody$1(token);
      else
        token = this.parseFunctionBody$3(token, false, staticModifier == null || externalModifier != null);
      t2.endMethod$3(getOrSet, start, token);
      return token.next;
    },
    parseFactoryMethod$1: function(token) {
      var token0, externalModifier, t1;
      if (token.get$stringValue() === "external") {
        token0 = token.next;
        externalModifier = token;
      } else {
        token0 = token;
        externalModifier = null;
      }
      if ("const" === token0.get$stringValue())
        token0 = token0.next;
      t1 = this.listener;
      t1.memberErrors = t1.memberErrors.prepend$1(false);
      token0 = this.parseFormalParameters$1(this.parseConstructorReference$1(token0.next));
      token0 = "=" === token0.get$stringValue() ? this.parseRedirectingFactoryBody$1(token0) : this.parseFunctionBody$3(token0, false, externalModifier != null);
      t1.endFactoryMethod$2(token, token0);
      return token0.next;
    },
    parseOperatorName$1: function(token) {
      var token0;
      if (Y.isUserDefinableOperator(token.next.get$stringValue())) {
        token0 = token.next;
        this.listener.handleOperatorName$2(token, token0);
        return token0.next;
      } else
        return this.parseIdentifier$1(token);
    },
    parseFunction$2: function(token, getOrSet) {
      token = this.parseModifiers$1(token);
      if (getOrSet == null ? token == null : getOrSet === token)
        token = token.next;
      if ("operator" === token.get$stringValue()) {
        this.listener.pushNode$1(null);
        token = this.parseOperatorName$1(token);
      } else {
        token = this.parseReturnTypeOpt$1(token);
        if (getOrSet == null ? token == null : getOrSet === token)
          token = token.next;
        token = "operator" === token.get$stringValue() ? this.parseOperatorName$1(token) : this.parseIdentifier$1(token);
      }
      token = this.parseInitializersOpt$1(this.parseFormalParametersOpt$1(this.parseQualifiedRestOpt$1(token)));
      token = "=" === token.get$stringValue() ? this.parseRedirectingFactoryBody$1(token) : this.parseFunctionBody$3(token, false, true);
      this.listener.endFunction$2(getOrSet, token);
      return token.next;
    },
    parseFunctionDeclaration$1: function(token) {
      token = this.parseFunction$2(token, null);
      this.listener.endFunctionDeclaration$1(token);
      return token;
    },
    parseFunctionExpression$1: function(token) {
      var t1, t2;
      t1 = this.listener;
      t1.handleModifiers$1(0);
      token = this.parseFormalParameters$1(this.parseIdentifier$1(this.parseReturnTypeOpt$1(token)));
      t1.handleNoInitializers$0();
      t2 = token.get$stringValue();
      token = this.parseFunctionBody$3(token, true, false);
      t1.endFunction$2(null, token);
      return "{" === t2 ? token.next : token;
    },
    parseConstructorReference$1: function(token) {
      var token0, token1, period;
      token0 = this.parseTypeArgumentsOpt$1(this.parseQualifiedRestOpt$1(this.parseIdentifier$1(token)));
      if ("." === token0.get$stringValue()) {
        token1 = this.parseIdentifier$1(token0.next);
        period = token0;
        token0 = token1;
      } else
        period = null;
      this.listener.endConstructorReference$3(token, period, token0);
      return token0;
    },
    parseRedirectingFactoryBody$1: function(token) {
      var token0 = this.parseConstructorReference$1(token.next);
      this.expect$2(";", token0);
      this.listener.endRedirectingFactoryBody$2(token, token0);
      return token0;
    },
    parseFunctionBody$3: function(token, isExpression, allowAbstract) {
      var token0, t1, statementCount;
      if (";" === token.get$stringValue()) {
        if (!allowAbstract)
          this.listener.reportError$2(token, C.MessageKind_ouf);
        this.listener.endFunctionBody$3(0, null, token);
        return token;
      } else if ("=>" === token.get$stringValue()) {
        token0 = this.parseExpression$1(token.next);
        t1 = this.listener;
        if (!isExpression) {
          this.expect$2(";", token0);
          t1.endReturnStatement$3(true, token, token0);
        } else
          t1.endReturnStatement$3(true, token, null);
        return token0;
      }
      if ("{" !== token.get$stringValue())
        return this.listener.expectedFunctionBody$1(token);
      token0 = token.next;
      statementCount = 0;
      while (true) {
        if (!(token0.get$info().kind !== 0 && "}" !== token0.get$stringValue()))
          break;
        token0 = this.parseStatement$1(token0);
        ++statementCount;
      }
      this.listener.endFunctionBody$3(statementCount, token, token0);
      this.expect$2("}", token0);
      return token0;
    },
    parseStatement$1: function(token) {
      var value, token0, t1, token1, elseToken, t2, hasTarget;
      value = token.get$stringValue();
      if (token.get$info().kind === 97)
        return this.parseExpressionStatementOrDeclaration$1(token);
      else if (value === "{")
        return this.parseBlock$1(token);
      else if (value === "return") {
        token0 = token.next;
        t1 = this.listener;
        if (";" === token0.get$stringValue()) {
          t1.endReturnStatement$3(false, token, token0);
          token = token0;
        } else {
          token0 = this.parseExpression$1(token0);
          t1.endReturnStatement$3(true, token, token0);
          token = token0;
        }
        return this.expect$2(";", token);
      } else if (value === "var" || value === "final")
        return this.parseVariablesDeclarationMaybeSemicolon$2(token, true);
      else if (value === "if") {
        token0 = this.parseStatement$1(this.parseParenthesizedExpression$1(this.expect$2("if", token)));
        if ("else" === token0.get$stringValue()) {
          token1 = this.parseStatement$1(token0.next);
          elseToken = token0;
          token0 = token1;
        } else
          elseToken = null;
        this.listener.endIfStatement$2(token, elseToken);
        return token0;
      } else if (value === "for")
        return this.parseForStatement$1(token);
      else if (value === "rethrow")
        return this.parseRethrowStatement$1(token);
      else if (value === "throw" && ";" === token.next.get$stringValue())
        return this.parseRethrowStatement$1(token);
      else if (value === "void")
        return this.parseExpressionStatementOrDeclaration$1(token);
      else if (value === "while") {
        token0 = this.parseStatement$1(this.parseParenthesizedExpression$1(this.expect$2("while", token)));
        this.listener.endWhileStatement$2(token, token0);
        return token0;
      } else if (value === "do") {
        token0 = this.parseStatement$1(this.expect$2("do", token));
        token1 = this.parseParenthesizedExpression$1(this.expect$2("while", token0));
        this.listener.endDoWhileStatement$3(token, token0, token1);
        return this.expect$2(";", token1);
      } else if (value === "try")
        return this.parseTryStatement$1(token);
      else if (value === "switch") {
        token0 = this.parseSwitchBlock$1(this.parseParenthesizedExpression$1(token.next));
        this.listener.endSwitchStatement$2(token, token0);
        return token0.next;
      } else if (value === "break") {
        token0 = token.next;
        if (token0.isIdentifier$0()) {
          if (!token0.isIdentifier$0())
            token0 = this.listener.expectedIdentifier$1(token0);
          t1 = this.listener;
          t2 = $.Node__HASH_COUNTER + 1;
          $.Node__HASH_COUNTER = t2;
          t1.nodes = t1.nodes.prepend$1(new Y.Identifier(token0, null, t2));
          token0 = token0.next;
          hasTarget = true;
        } else
          hasTarget = false;
        this.listener.handleBreakStatement$3(hasTarget, token, token0);
        return this.expect$2(";", token0);
      } else if (value === "continue") {
        token0 = token.next;
        if (token0.isIdentifier$0()) {
          if (!token0.isIdentifier$0())
            token0 = this.listener.expectedIdentifier$1(token0);
          t1 = this.listener;
          t2 = $.Node__HASH_COUNTER + 1;
          $.Node__HASH_COUNTER = t2;
          t1.nodes = t1.nodes.prepend$1(new Y.Identifier(token0, null, t2));
          token0 = token0.next;
          hasTarget = true;
        } else
          hasTarget = false;
        this.listener.handleContinueStatement$3(hasTarget, token, token0);
        return this.expect$2(";", token0);
      } else if (value === "assert") {
        token0 = this.expect$2("assert", token);
        this.expect$2("(", token0);
        token0 = this.parseArguments$1(token0);
        this.listener.handleAssertStatement$2(token, token0);
        return this.expect$2(";", token0);
      } else if (value === ";") {
        this.listener.handleEmptyStatement$1(token);
        return this.expect$2(";", token);
      } else if (value === "const")
        return this.parseExpressionStatementOrConstDeclaration$1(token);
      else if (token.isIdentifier$0())
        return this.parseExpressionStatementOrDeclaration$1(token);
      else {
        token = this.parseExpression$1(token);
        this.listener.endExpressionStatement$1(token);
        return this.expect$2(";", token);
      }
    },
    peekIdentifierAfterType$1: function(token) {
      var peek = this.peekAfterType$1(token);
      if (peek != null && peek.isIdentifier$0())
        return peek;
      else
        return;
    },
    peekIdentifierAfterOptionalType$1: function(token) {
      var peek = this.peekIdentifierAfterType$1(token);
      if (peek != null)
        return peek;
      else if (token.isIdentifier$0())
        return token;
      else
        return;
    },
    parseExpressionStatementOrDeclaration$1: function(token) {
      var identifier, afterId, afterIdKind, afterParens;
      identifier = this.peekIdentifierAfterType$1(token);
      if (identifier != null) {
        afterId = identifier.next;
        afterIdKind = afterId.get$info().kind;
        if (afterIdKind === 61 || afterIdKind === 59 || afterIdKind === 44)
          return this.parseVariablesDeclarationMaybeSemicolon$2(token, true);
        else if (afterIdKind === 40) {
          afterParens = afterId.get$endGroup().next;
          if ("{" === afterParens.get$stringValue() || "=>" === afterParens.get$stringValue())
            return this.parseFunctionDeclaration$1(token);
        }
      } else if (":" === token.next.get$stringValue())
        return this.parseLabeledStatement$1(token);
      else if ("(" === token.next.get$stringValue()) {
        afterParens = token.next.get$endGroup().next.get$stringValue();
        if (afterParens === "{" || afterParens === "=>")
          return this.parseFunctionDeclaration$1(token);
      }
      return this.parseExpressionStatement$1(token);
    },
    parseExpressionStatementOrConstDeclaration$1: function(token) {
      var identifier, afterIdKind;
      if (this.isModifier$1(token.next))
        return this.parseVariablesDeclarationMaybeSemicolon$2(token, true);
      identifier = this.peekIdentifierAfterOptionalType$1(token.next);
      if (identifier != null) {
        afterIdKind = identifier.next.get$info().kind;
        if (afterIdKind === 61 || afterIdKind === 59 || afterIdKind === 44)
          return this.parseVariablesDeclarationMaybeSemicolon$2(token, true);
      }
      return this.parseExpressionStatement$1(token);
    },
    parseLabeledStatement$1: function(token) {
      var t1, labelCount, t2, token0;
      t1 = this.listener;
      labelCount = 0;
      do {
        if (!token.isIdentifier$0())
          token = t1.expectedIdentifier$1(token);
        t2 = $.Node__HASH_COUNTER + 1;
        $.Node__HASH_COUNTER = t2;
        t1.nodes = t1.nodes.prepend$1(new Y.Identifier(token, null, t2));
        token = token.next;
        token0 = this.expect$2(":", token);
        t1.handleLabel$1(token);
        ++labelCount;
        if (token0.isIdentifier$0() && ":" === token0.next.get$stringValue()) {
          token = token0;
          continue;
        } else
          break;
      } while (true);
      token = this.parseStatement$1(token0);
      t1.endLabeledStatement$1(labelCount);
      return token;
    },
    parseExpressionStatement$1: function(token) {
      token = this.parseExpression$1(token);
      this.listener.endExpressionStatement$1(token);
      return this.expect$2(";", token);
    },
    parseExpression$1: function(token) {
      return "throw" === token.get$stringValue() ? this.parseThrowExpression$2(token, true) : this.parsePrecedenceExpression$3(token, 1, true);
    },
    parseExpressionWithoutCascade$1: function(token) {
      return "throw" === token.get$stringValue() ? this.parseThrowExpression$2(token, false) : this.parsePrecedenceExpression$3(token, 1, false);
    },
    parsePrecedenceExpression$3: function(token, precedence, allowCascades) {
      var info, tokenLevel, t1, t2, level, t3, t4, t5, token0, not, value, t6, token1;
      token = this.parseUnaryExpression$2(token, allowCascades);
      info = token.get$info();
      tokenLevel = info.precedence;
      for (t1 = this.listener, t2 = !allowCascades, level = tokenLevel; level >= precedence; --level)
        for (t3 = level !== 6, t4 = level + 1, t5 = level === 7; tokenLevel === level;) {
          if (tokenLevel === 2) {
            if (t2)
              return token;
            token = this.parseCascadeExpression$1(token);
          } else if (tokenLevel === 1) {
            token0 = this.parsePrecedenceExpression$3(token.next, level, allowCascades);
            t1.handleAssignmentExpression$1(token);
            token = token0;
          } else if (tokenLevel === 14)
            if (info === C.PrecedenceInfo_Axo) {
              token0 = this.parseUnaryExpression$2(token.next, allowCascades);
              t1.handleBinaryExpression$1(token);
              token = token0;
            } else if (info === C.PrecedenceInfo_wYn || info === C.PrecedenceInfo_atn)
              token = this.parseArgumentOrIndexStar$1(token);
            else if (info === C.PrecedenceInfo_ivD || info === C.PrecedenceInfo_ifx) {
              t1.handleUnaryPostfixAssignmentExpression$1(token);
              token = token.next;
            } else
              token = t1.unexpected$1(token);
          else if (info === C.PrecedenceInfo_is_7_107) {
            if ("!" === token.next.get$stringValue()) {
              token0 = token.next;
              not = token0;
            } else {
              token0 = token;
              not = null;
            }
            token0 = this.parseType$1(token0.next);
            t1.handleIsOperator$3(token, not, token0);
            value = token0.get$stringValue();
            if (value === "is" || value === "as")
              t1.unexpected$1(token0);
            token = token0;
          } else if (info === C.PrecedenceInfo_as_7_107) {
            token0 = this.parseType$1(token.next);
            t1.handleAsOperator$2(token, token0);
            value = token0.get$stringValue();
            if (value === "is" || value === "as")
              t1.unexpected$1(token0);
            token = token0;
          } else if (info === C.PrecedenceInfo_3u5) {
            t6 = token.next;
            token0 = "throw" === t6.get$stringValue() ? this.parseThrowExpression$2(t6, false) : this.parsePrecedenceExpression$3(t6, 1, false);
            token1 = this.expect$2(":", token0);
            token1 = "throw" === token1.get$stringValue() ? this.parseThrowExpression$2(token1, false) : this.parsePrecedenceExpression$3(token1, 1, false);
            t1.handleConditionalExpression$2(token, token0);
            token = token1;
          } else {
            token0 = this.parsePrecedenceExpression$3(token.next, t4, allowCascades);
            t1.handleBinaryExpression$1(token);
            token = token0;
          }
          info = token.get$info();
          tokenLevel = info.precedence;
          if (!t3 || t5)
            break;
        }
      return token;
    },
    parseCascadeExpression$1: function(token) {
      var t1, token0, t2;
      t1 = this.listener;
      t1.beginCascade$1(token);
      token0 = token.next;
      if ("[" === token0.get$stringValue())
        token = this.parseArgumentOrIndexStar$1(token0);
      else {
        if (token0.isIdentifier$0()) {
          if (!token0.isIdentifier$0())
            token0 = t1.expectedIdentifier$1(token0);
          t2 = $.Node__HASH_COUNTER + 1;
          $.Node__HASH_COUNTER = t2;
          t1.nodes = t1.nodes.prepend$1(new Y.Identifier(token0, null, t2));
          token0 = this.parseArgumentsOpt$1(token0.next);
          t1.endSend$1(token0);
          t1.handleBinaryExpression$1(token);
        } else
          return t1.unexpected$1(token0);
        token = token0;
      }
      do {
        if ("." === token.get$stringValue()) {
          token0 = token.next;
          if (!token0.isIdentifier$0())
            token0 = t1.expectedIdentifier$1(token0);
          t2 = $.Node__HASH_COUNTER + 1;
          $.Node__HASH_COUNTER = t2;
          t1.nodes = t1.nodes.prepend$1(new Y.Identifier(token0, null, t2));
          token0 = this.parseArgumentsOpt$1(token0.next);
          t1.endSend$1(token0);
          t1.handleBinaryExpression$1(token);
        } else
          token0 = token;
        token0 = this.parseArgumentOrIndexStar$1(token0);
        if (token !== token0) {
          token = token0;
          continue;
        } else
          break;
      } while (true);
      if (token0.get$info().precedence === 1) {
        t2 = token0.next;
        token = "throw" === t2.get$stringValue() ? this.parseThrowExpression$2(t2, false) : this.parsePrecedenceExpression$3(t2, 1, false);
        t1.handleAssignmentExpression$1(token0);
      } else
        token = token0;
      t1.endCascade$0();
      return token;
    },
    parseUnaryExpression$2: function(token, allowCascades) {
      var value, token0;
      value = token.get$stringValue();
      if (value === "+") {
        this.listener.reportError$2(token, C.MessageKind_fWv);
        return this.parseUnaryExpression$2(token.next, allowCascades);
      } else if (value === "!" || value === "-" || value === "~") {
        token0 = this.parsePrecedenceExpression$3(token.next, 14, allowCascades);
        this.listener.handleUnaryPrefixExpression$1(token);
        token = token0;
      } else if (value === "++" || value === "--") {
        token0 = this.parsePrecedenceExpression$3(token.next, 14, allowCascades);
        this.listener.handleUnaryPrefixAssignmentExpression$1(token);
        token = token0;
      } else
        token = this.parsePrimary$1(token);
      return token;
    },
    parseArgumentOrIndexStar$1: function(token) {
      var t1, old, token0;
      for (t1 = this.listener; true;)
        if ("[" === token.get$stringValue()) {
          old = this.mayParseFunctionExpressions;
          this.mayParseFunctionExpressions = true;
          token0 = this.parseExpression$1(token.next);
          this.mayParseFunctionExpressions = old;
          t1.handleIndexedExpression$2(token, token0);
          token = this.expect$2("]", token0);
        } else if ("(" === token.get$stringValue()) {
          token = this.parseArguments$1(token);
          t1.endSend$1(token);
        } else
          break;
      return token;
    },
    parsePrimary$1: function(token) {
      var kind, value, t1, token0;
      kind = token.get$info().kind;
      if (kind === 97)
        return this.parseSendOrFunctionLiteral$1(token);
      else if (kind === 105 || kind === 120) {
        this.listener.handleLiteralInt$1(token);
        return token.next;
      } else if (kind === 100) {
        this.listener.handleLiteralDouble$1(token);
        return token.next;
      } else if (kind === 39)
        return this.parseLiteralString$1(token);
      else if (kind === 35)
        return this.parseLiteralSymbol$1(token);
      else if (kind === 107) {
        value = token.get$stringValue();
        if (value === "true" || value === "false") {
          this.listener.handleLiteralBool$1(token);
          return token.next;
        } else if (value === "null") {
          this.listener.handleLiteralNull$1(token);
          return token.next;
        } else if (value === "this") {
          t1 = this.listener;
          t1.handleThisExpression$1(token);
          token = token.next;
          if ("(" === token.get$stringValue()) {
            token = this.parseArguments$1(token);
            t1.endSend$1(token);
          }
          return token;
        } else if (value === "super") {
          t1 = this.listener;
          t1.handleSuperExpression$1(token);
          token = token.next;
          if ("(" === token.get$stringValue()) {
            token = this.parseArguments$1(token);
            t1.endSend$1(token);
          }
          return token;
        } else if (value === "new") {
          token0 = this.parseRequiredArguments$1(this.parseConstructorReference$1(this.expect$2("new", token)));
          this.listener.handleNewExpression$1(token);
          return token0;
        } else if (value === "const")
          return this.parseConstExpression$1(token);
        else if (value === "void")
          return this.parseFunctionExpression$1(token);
        else if (token.isIdentifier$0())
          return this.parseSendOrFunctionLiteral$1(token);
        else
          return this.listener.expectedExpression$1(token);
      } else if (kind === 40)
        return this.parseParenthesizedExpressionOrFunctionLiteral$1(token);
      else if (kind === 60 || kind === 91 || kind === 123 || token.get$stringValue() === "[]")
        return this.parseLiteralListOrMap$1(token);
      else
        return this.listener.expectedExpression$1(token);
    },
    parseParenthesizedExpressionOrFunctionLiteral$1: function(token) {
      var kind, t1, t2;
      kind = token.get$endGroup().next.get$info().kind;
      t1 = this.mayParseFunctionExpressions;
      if (t1)
        t2 = kind === 130 || kind === 123;
      else
        t2 = false;
      if (t2) {
        token = this.parseFormalParameters$1(token);
        t1 = token.get$stringValue();
        token = this.parseFunctionBody$3(token, true, false);
        this.listener.endUnamedFunction$1(token);
        return "{" === t1 ? token.next : token;
      } else {
        this.mayParseFunctionExpressions = true;
        token = this.parseParenthesizedExpression$1(token);
        this.mayParseFunctionExpressions = t1;
        return token;
      }
    },
    parseParenthesizedExpression$1: function(token) {
      var token0, t1, expression, t2;
      token0 = this.parseExpression$1(this.expect$2("(", token));
      t1 = token.get$endGroup();
      if (t1 == null ? token0 != null : t1 !== token0) {
        this.listener.unexpected$1(token0);
        token0 = token.endGroup;
      }
      t1 = this.listener;
      expression = t1.popNode$0();
      t2 = $.Node__HASH_COUNTER + 1;
      $.Node__HASH_COUNTER = t2;
      t1.pushNode$1(new Y.ParenthesizedExpression(expression, token, t2));
      return this.expect$2(")", token0);
    },
    parseLiteralListOrMap$1: function(token) {
      var token0, constKeyword, old, t1, count, token1;
      if ("const" === token.get$stringValue()) {
        token0 = token.next;
        constKeyword = token;
        token = token0;
      } else
        constKeyword = null;
      token = this.parseTypeArgumentsOpt$1(token);
      if ("{" === token.get$stringValue()) {
        old = this.mayParseFunctionExpressions;
        this.mayParseFunctionExpressions = true;
        t1 = this.listener;
        token0 = token;
        count = 0;
        do {
          if ("}" === token0.next.get$stringValue()) {
            token0 = token0.next;
            break;
          }
          token0 = this.parseExpression$1(token0.next);
          token1 = this.parseExpression$1(this.expect$2(":", token0));
          t1.endLiteralMapEntry$2(token0, token1);
          ++count;
          if ("," === token1.get$stringValue()) {
            token0 = token1;
            continue;
          } else {
            token0 = token1;
            break;
          }
        } while (true);
        this.mayParseFunctionExpressions = old;
        t1.handleLiteralMap$4(count, token, constKeyword, token0);
        return this.expect$2("}", token0);
      } else if ("[" === token.get$stringValue()) {
        old = this.mayParseFunctionExpressions;
        this.mayParseFunctionExpressions = true;
        token0 = token;
        count = 0;
        do {
          if ("]" === token0.next.get$stringValue()) {
            token0 = token0.next;
            break;
          }
          token0 = this.parseExpression$1(token0.next);
          ++count;
        } while ("," === token0.get$stringValue());
        this.mayParseFunctionExpressions = old;
        this.listener.handleLiteralList$4(count, token, constKeyword, token0);
        return this.expect$2("]", token0);
      } else {
        t1 = this.listener;
        if ("[]" === token.get$stringValue()) {
          t1.handleLiteralList$4(0, token, constKeyword, token);
          return token.next;
        } else {
          t1.unexpected$1(token);
          return;
        }
      }
    },
    parseSendOrFunctionLiteral$1: function(token) {
      var peek;
      if (!this.mayParseFunctionExpressions)
        return this.parseSend$1(token);
      peek = this.peekAfterIfType$1(token);
      if (peek != null && peek.get$info().kind === 97 && this.isFunctionDeclaration$1(peek.next))
        return this.parseFunctionExpression$1(token);
      else if (this.isFunctionDeclaration$1(token.next))
        return this.parseFunctionExpression$1(token);
      else
        return this.parseSend$1(token);
    },
    isFunctionDeclaration$1: function(token) {
      var afterParens;
      if ("(" === token.get$stringValue()) {
        afterParens = token.get$endGroup().next.get$stringValue();
        if (afterParens === "{" || afterParens === "=>")
          return true;
      }
      return false;
    },
    parseRequiredArguments$1: function(token) {
      var t1;
      if ("(" === token.get$stringValue())
        token = this.parseArguments$1(token);
      else {
        t1 = this.listener;
        t1.handleNoArguments$1(token);
        token = t1.unexpected$1(token);
      }
      return token;
    },
    parseConstExpression$1: function(token) {
      var token0, value;
      token0 = this.expect$2("const", token);
      value = token0.get$stringValue();
      if (value === "<" || value === "[" || value === "[]" || value === "{")
        return this.parseLiteralListOrMap$1(token);
      token0 = this.parseRequiredArguments$1(this.parseConstructorReference$1(token0));
      this.listener.handleConstExpression$1(token);
      return token0;
    },
    parseLiteralString$1: function(token) {
      var old, count;
      old = this.mayParseFunctionExpressions;
      this.mayParseFunctionExpressions = true;
      token = this.parseSingleLiteralString$1(token);
      for (count = 1; token.get$info().kind === 39;) {
        token = this.parseSingleLiteralString$1(token);
        ++count;
      }
      if (count > 1)
        this.listener.handleStringJuxtaposition$1(count);
      this.mayParseFunctionExpressions = old;
      return token;
    },
    parseLiteralSymbol$1: function(token) {
      var token0, t1, count, t2;
      token0 = token.next;
      if (Y.isUserDefinableOperator(token0.get$stringValue())) {
        t1 = this.listener;
        t1.handleOperator$1(token0);
        t1.endLiteralSymbol$2(token, 1);
        return token0.next;
      } else {
        token0 = this.parseIdentifier$1(token0);
        for (t1 = this.listener, count = 1; token0.get$stringValue() === ".";) {
          ++count;
          token0 = token0.next;
          if (!token0.isIdentifier$0())
            token0 = t1.expectedIdentifier$1(token0);
          t2 = $.Node__HASH_COUNTER + 1;
          $.Node__HASH_COUNTER = t2;
          t1.nodes = t1.nodes.prepend$1(new Y.Identifier(token0, null, t2));
          token0 = token0.next;
        }
        t1.endLiteralSymbol$2(token, count);
        return token0;
      }
    },
    parseSingleLiteralString$1: function(token) {
      var t1, quoting, t2, kind, interpolationCount;
      t1 = this.listener;
      quoting = B.StringValidator_quotingFromString(token.get$value(token));
      t1.interpolationScope = t1.interpolationScope.prepend$1(quoting);
      t2 = $.Node__HASH_COUNTER + 1;
      $.Node__HASH_COUNTER = t2;
      t1.nodes = t1.nodes.prepend$1(new Y.LiteralString(token, null, t2));
      token = token.next;
      kind = token.get$info().kind;
      for (interpolationCount = 0; kind !== 0;) {
        if (kind === 128)
          token = this.expect$2("}", this.parseExpression$1(token.next));
        else if (kind === 159)
          token = this.parseExpression$1(token.next);
        else
          break;
        ++interpolationCount;
        token = this.parseStringPart$1(token);
        kind = token.get$info().kind;
      }
      t1.endLiteralString$1(interpolationCount);
      return token;
    },
    parseSend$1: function(token) {
      var t1, t2;
      if (!token.isIdentifier$0())
        token = this.listener.expectedIdentifier$1(token);
      t1 = this.listener;
      t2 = $.Node__HASH_COUNTER + 1;
      $.Node__HASH_COUNTER = t2;
      t1.nodes = t1.nodes.prepend$1(new Y.Identifier(token, null, t2));
      token = this.parseArgumentsOpt$1(token.next);
      t1.endSend$1(token);
      return token;
    },
    parseArgumentsOpt$1: function(token) {
      if ("(" !== token.get$stringValue()) {
        this.listener.handleNoArguments$1(token);
        return token;
      } else
        return this.parseArguments$1(token);
    },
    parseArguments$1: function(token) {
      var old, t1, token0, argumentCount, t2, colon;
      if (")" === token.next.get$stringValue()) {
        this.listener.endArguments$3(0, token, token.next);
        return token.next.next;
      }
      old = this.mayParseFunctionExpressions;
      this.mayParseFunctionExpressions = true;
      t1 = this.listener;
      token0 = token;
      argumentCount = 0;
      do {
        if (":" === token0.next.next.get$stringValue()) {
          token0 = token0.next;
          if (!token0.isIdentifier$0())
            token0 = t1.expectedIdentifier$1(token0);
          t2 = $.Node__HASH_COUNTER + 1;
          $.Node__HASH_COUNTER = t2;
          t1.nodes = t1.nodes.prepend$1(new Y.Identifier(token0, null, t2));
          token0 = token0.next;
          colon = token0;
        } else
          colon = null;
        token0 = this.parseExpression$1(token0.next);
        if (colon != null)
          t1.handleNamedArgument$1(colon);
        ++argumentCount;
      } while ("," === token0.get$stringValue());
      this.mayParseFunctionExpressions = old;
      t1.endArguments$3(argumentCount, token, token0);
      return this.expect$2(")", token0);
    },
    parseVariablesDeclarationMaybeSemicolon$2: function(token, endWithSemicolon) {
      var t1, count, t2, token0;
      token = this.parseOptionallyInitializedIdentifier$1(this.parseTypeOpt$1(this.parseModifiers$1(token)));
      for (t1 = this.listener, count = 1; "," === token.get$stringValue();) {
        token = token.next;
        if (!token.isIdentifier$0())
          token = t1.expectedIdentifier$1(token);
        t2 = $.Node__HASH_COUNTER + 1;
        $.Node__HASH_COUNTER = t2;
        t1.nodes = t1.nodes.prepend$1(new Y.Identifier(token, null, t2));
        token = this.parseVariableInitializerOpt$1(token.next);
        ++count;
      }
      if (endWithSemicolon) {
        token0 = this.expect$2(";", token);
        t1.endVariablesDeclaration$2(count, token);
        return token0;
      } else {
        t1.endVariablesDeclaration$2(count, null);
        return token;
      }
    },
    parseOptionallyInitializedIdentifier$1: function(token) {
      var t1, t2;
      if (!token.isIdentifier$0())
        token = this.listener.expectedIdentifier$1(token);
      t1 = this.listener;
      t2 = $.Node__HASH_COUNTER + 1;
      $.Node__HASH_COUNTER = t2;
      t1.nodes = t1.nodes.prepend$1(new Y.Identifier(token, null, t2));
      return this.parseVariableInitializerOpt$1(token.next);
    },
    parseForStatement$1: function(token) {
      var token0, token1;
      token0 = this.parseVariablesDeclarationOrExpressionOpt$1(this.expect$2("(", this.expect$2("for", token)));
      if ("in" === token0.get$stringValue()) {
        token1 = this.parseStatement$1(this.expect$2(")", this.parseExpression$1(token0.next)));
        this.listener.endForIn$3(token, token0, token1);
        return token1;
      } else
        return this.parseForRest$2(token, token0);
    },
    parseVariablesDeclarationOrExpressionOpt$1: function(token) {
      var value, identifier, stringValue;
      value = token.get$stringValue();
      if (value === ";") {
        this.listener.handleNoExpression$1(token);
        return token;
      } else if (value === "var" || value === "final")
        return this.parseVariablesDeclarationMaybeSemicolon$2(token, false);
      identifier = this.peekIdentifierAfterType$1(token);
      if (identifier != null) {
        stringValue = identifier.next.get$stringValue();
        if ("=" === stringValue || ";" === stringValue || "," === stringValue || "in" === stringValue)
          return this.parseVariablesDeclarationMaybeSemicolon$2(token, false);
      }
      return this.parseExpression$1(token);
    },
    parseForRest$2: function(forToken, token) {
      var expressionCount;
      token = this.expect$2(";", token);
      if (";" === token.get$stringValue()) {
        this.listener.handleEmptyStatement$1(token);
        token = this.expect$2(";", token);
      } else
        token = this.parseExpressionStatement$1(token);
      for (expressionCount = 0; true;) {
        if (")" === token.get$stringValue())
          break;
        token = this.parseExpression$1(token);
        ++expressionCount;
        if ("," === token.get$stringValue())
          token = token.next;
        else
          break;
      }
      token = this.parseStatement$1(this.expect$2(")", token));
      this.listener.endForStatement$3(expressionCount, forToken, token);
      return token;
    },
    parseBlock$1: function(token) {
      var token0, statementCount;
      token0 = this.expect$2("{", token);
      statementCount = 0;
      while (true) {
        if (!(token0.get$info().kind !== 0 && "}" !== token0.get$stringValue()))
          break;
        token0 = this.parseStatement$1(token0);
        ++statementCount;
      }
      this.listener.endBlock$3(statementCount, token, token0);
      return this.expect$2("}", token0);
    },
    parseThrowExpression$2: function(token, allowCascades) {
      var token0 = this.expect$2("throw", token);
      token0 = allowCascades ? this.parseExpression$1(token0) : this.parseExpressionWithoutCascade$1(token0);
      this.listener.endThrowExpression$2(token, token0);
      return token0;
    },
    parseRethrowStatement$1: function(token) {
      var token0 = token.get$stringValue() === "throw" ? this.expect$2("throw", token) : this.expect$2("rethrow", token);
      this.listener.endRethrowStatement$2(token, token0);
      return this.expect$2(";", token0);
    },
    parseTryStatement$1: function(token) {
      var token0, value, t1, catchCount, token1, onKeyword, catchKeyword, finallyKeyword;
      token0 = this.parseBlock$1(token.next);
      value = token0.get$stringValue();
      t1 = this.listener;
      catchCount = 0;
      while (true) {
        if (!(value === "catch" || value === "on"))
          break;
        if (value === "on") {
          token1 = this.parseType$1(token0.next);
          value = token1.get$stringValue();
          onKeyword = token0;
          token0 = token1;
        } else
          onKeyword = null;
        if (value === "catch") {
          token1 = this.parseFormalParameters$1(token0.next);
          catchKeyword = token0;
          token0 = token1;
        } else
          catchKeyword = null;
        token0 = this.parseBlock$1(token0);
        ++catchCount;
        t1.handleCatchBlock$2(onKeyword, catchKeyword);
        value = token0.get$stringValue();
      }
      if ("finally" === token0.get$stringValue()) {
        token1 = this.parseBlock$1(token0.next);
        finallyKeyword = token0;
        token0 = token1;
      } else
        finallyKeyword = null;
      t1.endTryStatement$3(catchCount, token, finallyKeyword);
      return token0;
    },
    parseSwitchBlock$1: function(token) {
      var token0, caseCount;
      token0 = this.expect$2("{", token);
      for (caseCount = 0; token0.get$info().kind !== 0;) {
        if ("}" === token0.get$stringValue())
          break;
        token0 = this.parseSwitchCase$1(token0);
        ++caseCount;
      }
      this.listener.endSwitchBlock$3(caseCount, token, token0);
      this.expect$2("}", token0);
      return token0;
    },
    peekPastLabels$1: function(token) {
      while (true) {
        if (!(token.isIdentifier$0() && ":" === token.next.get$stringValue()))
          break;
        token = token.next.next;
      }
      return token;
    },
    parseSwitchCase$1: function(token) {
      var peek, defaultKeyword, t1, token0, expressionCount, labelCount, value, t2, token1, token2, statementCount;
      peek = this.peekPastLabels$1(token);
      t1 = this.listener;
      token0 = token;
      expressionCount = 0;
      labelCount = 0;
      while (true) {
        if (!true) {
          defaultKeyword = null;
          break;
        }
        value = peek.get$stringValue();
        if (value === "default") {
          for (; token0 !== peek; token0 = token1) {
            if (!token0.isIdentifier$0())
              token0 = t1.expectedIdentifier$1(token0);
            t2 = $.Node__HASH_COUNTER + 1;
            $.Node__HASH_COUNTER = t2;
            t1.nodes = t1.nodes.prepend$1(new Y.Identifier(token0, null, t2));
            token0 = token0.next;
            token1 = this.expect$2(":", token0);
            t1.handleLabel$1(token0);
            ++labelCount;
          }
          token1 = this.expect$2(":", token0.next);
          peek = token1;
          defaultKeyword = token0;
          token0 = peek;
          break;
        } else if (value === "case") {
          for (; token0 !== peek; token0 = token1) {
            if (!token0.isIdentifier$0())
              token0 = t1.expectedIdentifier$1(token0);
            t2 = $.Node__HASH_COUNTER + 1;
            $.Node__HASH_COUNTER = t2;
            t1.nodes = t1.nodes.prepend$1(new Y.Identifier(token0, null, t2));
            token0 = token0.next;
            token1 = this.expect$2(":", token0);
            t1.handleLabel$1(token0);
            ++labelCount;
          }
          token1 = this.parseExpression$1(token0.next);
          token2 = this.expect$2(":", token1);
          t1.handleCaseMatch$2(token0, token1);
          ++expressionCount;
          peek = this.peekPastLabels$1(token2);
        } else {
          if (expressionCount === 0)
            t1.expected$2("case", token0);
          defaultKeyword = null;
          break;
        }
        token0 = token2;
      }
      for (statementCount = 0; token0.get$info().kind !== 0;) {
        value = peek.get$stringValue();
        if (value !== "case")
          if (value !== "default")
            t2 = value === "}" && token0 === peek;
          else
            t2 = true;
        else
          t2 = true;
        if (t2)
          break;
        else
          token0 = this.parseStatement$1(token0);
        ++statementCount;
        peek = this.peekPastLabels$1(token0);
      }
      t1.handleSwitchCase$6(labelCount, expressionCount, defaultKeyword, statementCount, token, token0);
      return token0;
    }
  },
  Parser_parseTypeArgumentsOpt_closure: {
    "^": "Closure:13;this_0",
    call$1: function(t) {
      return;
    },
    $isFunction: true
  },
  Parser_parseTypeArgumentsOpt_closure0: {
    "^": "Closure:13;this_1",
    call$1: function(t) {
      return this.this_1.parseType$1(t);
    },
    $isFunction: true
  },
  Parser_parseTypeArgumentsOpt_closure1: {
    "^": "Closure:250;this_2",
    call$3: function(c, bt, et) {
      var t1 = this.this_2.listener;
      t1.pushNode$1(t1.makeNodeList$4(c, bt, et, ","));
      return;
    },
    $isFunction: true
  },
  Parser_parseTypeArgumentsOpt_closure2: {
    "^": "Closure:13;this_3",
    call$1: function(t) {
      this.this_3.listener.pushNode$1(null);
      return;
    },
    $isFunction: true
  },
  Parser_parseTypeVariablesOpt_closure: {
    "^": "Closure:13;this_0",
    call$1: function(t) {
      return;
    },
    $isFunction: true
  },
  Parser_parseTypeVariablesOpt_closure0: {
    "^": "Closure:13;this_1",
    call$1: function(t) {
      var t1, token, bound, $name, t2;
      t1 = this.this_1;
      token = t1.parseIdentifier$1(t);
      if ("extends" === token.get$stringValue())
        token = t1.parseType$1(token.next);
      else
        t1.listener.pushNode$1(null);
      t1 = t1.listener;
      bound = t1.popNode$0();
      $name = t1.popNode$0();
      t2 = $.Node__HASH_COUNTER + 1;
      $.Node__HASH_COUNTER = t2;
      t1.pushNode$1(new Y.TypeVariable($name, bound, t2));
      t1.rejectBuiltInIdentifier$1($name);
      return token;
    },
    $isFunction: true
  },
  Parser_parseTypeVariablesOpt_closure1: {
    "^": "Closure:250;this_2",
    call$3: function(c, bt, et) {
      var t1 = this.this_2.listener;
      t1.pushNode$1(t1.makeNodeList$4(c, bt, et, ","));
      return;
    },
    $isFunction: true
  },
  Parser_parseTypeVariablesOpt_closure2: {
    "^": "Closure:13;this_3",
    call$1: function(t) {
      this.this_3.listener.pushNode$1(null);
      return;
    },
    $isFunction: true
  },
  Parser_expectVarFinalOrConst_closure: {
    "^": "Closure:23;",
    call$0: function() {
      return;
    },
    $isFunction: true
  },
  Parser_expectVarFinalOrConst_closure0: {
    "^": "Closure:13;this_0",
    call$1: function(modifier) {
      return "static" === modifier.get$stringValue();
    },
    $isFunction: true
  },
  Parser_expectVarFinalOrConst_closure1: {
    "^": "Closure:23;",
    call$0: function() {
      return;
    },
    $isFunction: true
  },
  ParserTask: {
    "^": "CompilerTask;compiler,watch,profilerTag",
    get$name: function(_) {
      return "Parser";
    },
    parse$1: function(element) {
      return this.measure$1(new Y.ParserTask_parse_closure(this, element));
    },
    parseCompilationUnit$1: function(token) {
      return this.measure$1(new Y.ParserTask_parseCompilationUnit_closure(this, token));
    }
  },
  ParserTask_parse_closure: {
    "^": "Closure:23;this_0,element_1",
    call$0: function() {
      return this.element_1.parseNode$1(this.this_0.compiler);
    },
    $isFunction: true
  },
  ParserTask_parseCompilationUnit_closure: {
    "^": "Closure:23;this_0,token_1",
    call$0: function() {
      var t1, listener;
      t1 = this.this_0.compiler;
      listener = new Y.NodeListener(false, null, t1, null, new B.StringValidator(t1), C.C_Link6, C.C_Link3, C.C_Link2, C.C_Link7, false);
      new Y.Parser(listener, true).parseUnit$1(this.token_1);
      return listener.popNode$0();
    },
    $isFunction: true
  },
  PartialParser: {
    "^": "Parser;listener,mayParseFunctionExpressions",
    parseClassBody$1: function(token) {
      return this.skipClassBody$1(token);
    },
    parseExpression$1: function(token) {
      return this.skipExpression$1(token);
    },
    parseArgumentsOpt$1: function(token) {
      if ("(" === token.get$stringValue())
        return token.get$endGroup().next;
      else
        return token;
    },
    skipExpression$1: function(token) {
      var t1, kind, value, nextValue, begin, t2, token0;
      for (t1 = this.listener; true;) {
        kind = token.get$info().kind;
        value = token.get$stringValue();
        if (kind === 0 || value === ";" || value === "," || value === "}" || value === ")" || value === "]")
          break;
        if (value === "=" || value === "?" || value === ":") {
          nextValue = token.next.get$stringValue();
          if (nextValue === "const") {
            token = token.next;
            nextValue = token.next.get$stringValue();
          }
          if (nextValue === "{") {
            begin = token.next;
            token = (begin.get$endGroup() != null ? begin.endGroup : token).next;
            continue;
          }
          if (nextValue === "<") {
            begin = token.next;
            token = (begin.get$endGroup() != null ? begin.endGroup : token).next;
            if (token.get$stringValue() === "{")
              token = (token.get$endGroup() != null ? token.endGroup : token).next;
            continue;
          }
        }
        if (!this.mayParseFunctionExpressions && value === "{")
          break;
        t2 = J.getInterceptor(token);
        if (!!t2.$isBeginGroupToken) {
          token0 = token.endGroup;
          if (token0 != null)
            token = token0;
        } else if (!!t2.$isErrorToken)
          t1.reportErrorToken$1(token);
        token = token.next;
      }
      return token;
    },
    skipClassBody$1: function(token) {
      var endGroup;
      if ("{" !== token.get$stringValue())
        return this.listener.unexpected$1(token);
      endGroup = token.get$endGroup();
      if (endGroup == null)
        return this.listener.unmatched$1(token);
      else if (endGroup.get$info().kind !== 125)
        return this.listener.unmatched$1(token);
      return endGroup;
    },
    parseFunctionBody$3: function(token, isExpression, allowAbstract) {
      var value = token.get$stringValue();
      if (value === ";") {
        if (!allowAbstract)
          this.listener.reportError$2(token, C.MessageKind_ouf);
        this.listener.handleNoFunctionBody$1(token);
      } else {
        if (value === "=>") {
          token = this.skipExpression$1(token.next);
          this.expect$2(";", token);
        } else if (value === "=") {
          token = this.parseRedirectingFactoryBody$1(token);
          this.expect$2(";", token);
        } else
          token = this.skipBlock$1(token);
        this.listener.skippedFunctionBody$1(token);
      }
      return token;
    },
    parseFormalParameters$1: function(token) {
      return this.skipFormals$1(token);
    },
    skipFormals$1: function(token) {
      var endToken;
      if ("(" !== token.get$stringValue()) {
        if (";" === token.get$stringValue()) {
          this.listener.reportFatalError$2(token, "expected '('");
          return token;
        }
        return this.listener.unexpected$1(token);
      }
      endToken = token.get$endGroup();
      this.listener.endFormalParameters$3(0, token, endToken);
      return endToken.next;
    }
  },
  AbstractScanner: {
    "^": "Object;tail@",
    beginToken$0: [function() {
      this.tokenStart = this.get$stringOffset();
    }, "call$0", "get$beginToken", 0, 0, 7],
    tokenize$0: function() {
      var next, t1, t2;
      for (; !this.atEndOfFile$0();) {
        next = this.advance$0();
        for (; next !== 0;)
          next = this.bigSwitch$1(next);
        if (this.atEndOfFile$0())
          this.appendEofToken$0();
        else {
          this.appendErrorToken$1(new Y.BadInputToken(0, this.tokenStart, null));
          this.advanceAfterError$1(true);
        }
      }
      t1 = this.file;
      if (t1 != null) {
        t1.set$length(0, this.get$stringOffset());
        t2 = this.lineStarts;
        t2.push(this.get$stringOffset() + 1);
        t1.lineStartsCache = t2;
      }
      return this.firstToken$0();
    },
    bigSwitch$1: function(next) {
      var t1 = this.get$stringOffset();
      this.tokenStart = t1;
      if (next === 32 || next === 9 || next === 10 || next === 13) {
        this.appendWhiteSpace$1(next);
        next = this.advance$0();
        for (; next === 32;)
          next = this.advance$0();
        return next;
      }
      if (typeof next !== "number")
        return H.iae(next);
      if (97 <= next && next <= 122) {
        if (114 === next)
          return this.tokenizeRawStringKeywordOrIdentifier$1(next);
        return this.tokenizeKeywordOrIdentifier$2(next, true);
      }
      if (65 <= next && next <= 90 || next === 95 || next === 36)
        return this.tokenizeIdentifier$3(next, this.get$scanOffset(), true);
      if (next === 60)
        return this.tokenizeLessThan$1(next);
      if (next === 62)
        return this.tokenizeGreaterThan$1(next);
      if (next === 61)
        return this.tokenizeEquals$1(next);
      if (next === 33)
        return this.tokenizeExclamation$1(next);
      if (next === 43)
        return this.tokenizePlus$1(next);
      if (next === 45)
        return this.tokenizeMinus$1(next);
      if (next === 42)
        return this.select$3(0, 61, C.PrecedenceInfo_WZn, C.PrecedenceInfo_sUe);
      if (next === 37)
        return this.select$3(0, 61, C.PrecedenceInfo_k6K, C.PrecedenceInfo_4AN);
      if (next === 38)
        return this.tokenizeAmpersand$1(next);
      if (next === 124)
        return this.tokenizeBar$1(next);
      if (next === 94)
        return this.select$3(0, 61, C.PrecedenceInfo_OJ0, C.PrecedenceInfo_Nm5);
      if (next === 91)
        return this.tokenizeOpenSquareBracket$1(next);
      if (next === 126)
        return this.tokenizeTilde$1(next);
      if (next === 92) {
        this.appendPrecedenceToken$1(C.PrecedenceInfo_woc);
        return this.advance$0();
      }
      if (next === 35)
        return this.tokenizeTag$1(next);
      if (next === 40) {
        this.appendBeginGroup$1(C.PrecedenceInfo_wYn);
        return this.advance$0();
      }
      if (next === 41)
        return this.appendEndGroup$2(C.PrecedenceInfo_MIj, 40);
      if (next === 44) {
        this.appendPrecedenceToken$1(C.PrecedenceInfo_Odk);
        return this.advance$0();
      }
      if (next === 58) {
        this.appendPrecedenceToken$1(C.PrecedenceInfo_pmZ);
        return this.advance$0();
      }
      if (next === 59) {
        this.appendPrecedenceToken$1(C.PrecedenceInfo_kuc);
        this.discardOpenLt$0();
        return this.advance$0();
      }
      if (next === 63) {
        this.appendPrecedenceToken$1(C.PrecedenceInfo_3u5);
        return this.advance$0();
      }
      if (next === 93)
        return this.appendEndGroup$2(C.PrecedenceInfo_6L0, 91);
      if (next === 96) {
        this.appendPrecedenceToken$1(C.PrecedenceInfo_10U);
        return this.advance$0();
      }
      if (next === 123) {
        this.appendBeginGroup$1(C.PrecedenceInfo_qJU);
        return this.advance$0();
      }
      if (next === 125)
        return this.appendEndGroup$2(C.PrecedenceInfo_atK, 123);
      if (next === 47)
        return this.tokenizeSlashOrComment$1(next);
      if (next === 64) {
        this.appendPrecedenceToken$1(C.PrecedenceInfo_CJR);
        return this.advance$0();
      }
      if (next === 34 || next === 39)
        return this.tokenizeString$3(next, this.get$scanOffset(), false);
      if (next === 46)
        return this.tokenizeDotsOrNumber$1(next);
      if (next === 48)
        return this.tokenizeHexOrNumber$1(next);
      if (next === 49 || next === 50 || next === 51 || next === 52 || next === 53 || next === 54 || next === 55 || next === 56 || next === 57)
        return this.tokenizeNumber$1(next);
      if (next === 0)
        return 0;
      if (next < 31) {
        this.appendErrorToken$1(new Y.BadInputToken(next, t1, null));
        return this.advanceAfterError$1(true);
      }
      next = this.currentAsUnicode$1(next);
      if (next === 160) {
        this.appendWhiteSpace$1(next);
        return this.advance$0();
      }
      this.appendErrorToken$1(new Y.BadInputToken(next, this.tokenStart, null));
      return this.advanceAfterError$1(true);
    },
    tokenizeTag$1: function(next) {
      var t1, asciiOnly;
      if (this.get$scanOffset() === 0)
        if (this.peek$0() === 33) {
          t1 = this.get$scanOffset();
          asciiOnly = true;
          do {
            next = this.advance$0();
            if (typeof next !== "number")
              return next.$gt();
            if (next > 127)
              asciiOnly = false;
          } while (next !== 10 && next !== 13 && next !== 0);
          if (!asciiOnly)
            this.handleUnicode$1(t1 + 1);
          return next;
        }
      this.appendPrecedenceToken$1(C.PrecedenceInfo_YfA);
      return this.advance$0();
    },
    tokenizeTilde$1: function(next) {
      next = this.advance$0();
      if (next === 47)
        return this.select$3(0, 61, C.PrecedenceInfo_DqM, C.PrecedenceInfo_8cP);
      else {
        this.appendPrecedenceToken$1(C.PrecedenceInfo_FeL);
        return next;
      }
    },
    tokenizeOpenSquareBracket$1: function(next) {
      var token, t1;
      next = this.advance$0();
      if (next === 93) {
        token = this.previousToken$0();
        t1 = J.getInterceptor(token);
        if (!(!!t1.$isKeywordToken && token.keyword.syntax === "operator"))
          t1 = !!t1.$isSymbolToken && token.info === C.PrecedenceInfo_YfA;
        else
          t1 = true;
        if (t1)
          return this.select$3(0, 61, C.PrecedenceInfo_I7d, C.PrecedenceInfo_CRA);
      }
      this.appendBeginGroup$1(C.PrecedenceInfo_atn);
      return next;
    },
    tokenizeBar$1: function(next) {
      next = this.advance$0();
      if (next === 124) {
        this.appendPrecedenceToken$1(C.PrecedenceInfo_Ogk);
        return this.advance$0();
      } else if (next === 61) {
        this.appendPrecedenceToken$1(C.PrecedenceInfo_YwG);
        return this.advance$0();
      } else {
        this.appendPrecedenceToken$1(C.PrecedenceInfo_P1e);
        return next;
      }
    },
    tokenizeAmpersand$1: function(next) {
      next = this.advance$0();
      if (next === 38) {
        this.appendPrecedenceToken$1(C.PrecedenceInfo_v9T);
        return this.advance$0();
      } else if (next === 61) {
        this.appendPrecedenceToken$1(C.PrecedenceInfo_sxw);
        return this.advance$0();
      } else {
        this.appendPrecedenceToken$1(C.PrecedenceInfo_1nr);
        return next;
      }
    },
    tokenizeMinus$1: function(next) {
      next = this.advance$0();
      if (next === 45) {
        this.appendPrecedenceToken$1(C.PrecedenceInfo_ifx);
        return this.advance$0();
      } else if (next === 61) {
        this.appendPrecedenceToken$1(C.PrecedenceInfo_ij7);
        return this.advance$0();
      } else {
        this.appendPrecedenceToken$1(C.PrecedenceInfo_06W);
        return next;
      }
    },
    tokenizePlus$1: function(next) {
      next = this.advance$0();
      if (43 === next) {
        this.appendPrecedenceToken$1(C.PrecedenceInfo_ivD);
        return this.advance$0();
      } else if (61 === next) {
        this.appendPrecedenceToken$1(C.PrecedenceInfo_iHe);
        return this.advance$0();
      } else {
        this.appendPrecedenceToken$1(C.PrecedenceInfo_W2j);
        return next;
      }
    },
    tokenizeExclamation$1: function(next) {
      next = this.advance$0();
      if (next === 61)
        return this.select$3(0, 61, C.PrecedenceInfo_EsG, C.PrecedenceInfo_zPV);
      this.appendPrecedenceToken$1(C.PrecedenceInfo_Mr4);
      return next;
    },
    tokenizeEquals$1: function(next) {
      this.discardOpenLt$0();
      next = this.advance$0();
      if (next === 61)
        return this.select$3(0, 61, C.PrecedenceInfo_4QZ, C.PrecedenceInfo_43h);
      else if (next === 62) {
        this.appendPrecedenceToken$1(C.PrecedenceInfo_U48);
        return this.advance$0();
      }
      this.appendPrecedenceToken$1(C.PrecedenceInfo_xw8);
      return next;
    },
    tokenizeGreaterThan$1: function(next) {
      next = this.advance$0();
      if (61 === next) {
        this.appendPrecedenceToken$1(C.PrecedenceInfo_qBT);
        return this.advance$0();
      } else if (62 === next) {
        next = this.advance$0();
        if (61 === next) {
          this.appendPrecedenceToken$1(C.PrecedenceInfo_TVl);
          return this.advance$0();
        } else {
          this.appendGtGt$1(C.PrecedenceInfo_A0t);
          return next;
        }
      } else {
        this.appendGt$1(C.PrecedenceInfo_TG0);
        return next;
      }
    },
    tokenizeLessThan$1: function(next) {
      next = this.advance$0();
      if (61 === next) {
        this.appendPrecedenceToken$1(C.PrecedenceInfo_1Vp);
        return this.advance$0();
      } else if (60 === next)
        return this.select$3(0, 61, C.PrecedenceInfo_TLM, C.PrecedenceInfo_cD9);
      else {
        this.appendBeginGroup$1(C.PrecedenceInfo_S9I);
        return next;
      }
    },
    tokenizeNumber$1: function(next) {
      var start, nextnext;
      start = this.get$scanOffset();
      for (; true;) {
        next = this.advance$0();
        if (typeof next !== "number")
          return H.iae(next);
        if (48 <= next && next <= 57)
          continue;
        else if (next === 101 || next === 69)
          return this.tokenizeFractionPart$2(next, start);
        else {
          if (next === 46) {
            nextnext = this.peek$0();
            if (typeof nextnext !== "number")
              return H.iae(nextnext);
            if (48 <= nextnext && nextnext <= 57)
              return this.tokenizeFractionPart$2(this.advance$0(), start);
          }
          this.appendSubstringToken$3(C.PrecedenceInfo_int_0_105, start, true);
          return next;
        }
      }
      return;
    },
    tokenizeHexOrNumber$1: function(next) {
      var x = this.peek$0();
      if (x === 120 || x === 88)
        return this.tokenizeHex$1(next);
      return this.tokenizeNumber$1(next);
    },
    tokenizeHex$1: function(next) {
      var start, hasDigits, t1;
      start = this.get$scanOffset();
      this.advance$0();
      for (hasDigits = false; true; hasDigits = true) {
        next = this.advance$0();
        if (typeof next !== "number")
          return H.iae(next);
        if (!(48 <= next && next <= 57))
          if (!(65 <= next && next <= 70))
            t1 = 97 <= next && next <= 102;
          else
            t1 = true;
        else
          t1 = true;
        if (t1)
          ;
        else {
          if (!hasDigits) {
            t1 = this.tokenStart;
            this.appendErrorToken$1(new Y.UnterminatedToken("0x", this.get$stringOffset(), t1, null));
            return this.advanceAfterError$1(true);
          }
          this.appendSubstringToken$3(C.PrecedenceInfo_hexadecimal_0_120, start, true);
          return next;
        }
      }
      return;
    },
    tokenizeDotsOrNumber$1: function(next) {
      var start = this.get$scanOffset();
      next = this.advance$0();
      if (typeof next !== "number")
        return H.iae(next);
      if (48 <= next && next <= 57)
        return this.tokenizeFractionPart$2(next, start);
      else if (46 === next)
        return this.select$3(0, 46, C.PrecedenceInfo_6el, C.PrecedenceInfo_ouN);
      else {
        this.appendPrecedenceToken$1(C.PrecedenceInfo_Axo);
        return next;
      }
    },
    tokenizeFractionPart$2: function(next, start) {
      var done, hasDigit, hasExponentDigits, t1;
      $LOOP$0:
        for (done = false, hasDigit = false; !done;) {
          if (typeof next !== "number")
            return H.iae(next);
          if (48 <= next && next <= 57)
            ;
          else if (101 === next || 69 === next) {
            next = this.advance$0();
            if (next === 43 || next === 45)
              next = this.advance$0();
            for (hasExponentDigits = false; true; hasExponentDigits = true) {
              if (typeof next !== "number")
                return H.iae(next);
              if (48 <= next && next <= 57)
                ;
              else {
                if (!hasExponentDigits) {
                  t1 = this.tokenStart;
                  this.appendErrorToken$1(new Y.UnterminatedToken("1e", this.get$stringOffset(), t1, null));
                  this.advanceAfterError$1(false);
                  return next;
                }
                break;
              }
              next = this.advance$0();
            }
            done = true;
            hasDigit = true;
            continue $LOOP$0;
          } else {
            done = true;
            continue $LOOP$0;
          }
          next = this.advance$0();
          hasDigit = true;
        }
      if (!hasDigit) {
        this.appendSubstringToken$4(C.PrecedenceInfo_int_0_105, start, true, -1);
        if (46 === next)
          return this.select$3(0, 46, C.PrecedenceInfo_6el, C.PrecedenceInfo_ouN);
        this.appendPrecedenceToken$1(C.PrecedenceInfo_Axo);
        return next;
      }
      this.appendSubstringToken$3(C.PrecedenceInfo_double_0_100, start, true);
      return next;
    },
    tokenizeSlashOrComment$1: function(next) {
      var start = this.get$scanOffset();
      next = this.advance$0();
      if (42 === next)
        return this.tokenizeMultiLineComment$2(next, start);
      else if (47 === next)
        return this.tokenizeSingleLineComment$2(next, start);
      else if (61 === next) {
        this.appendPrecedenceToken$1(C.PrecedenceInfo_kCU);
        return this.advance$0();
      } else {
        this.appendPrecedenceToken$1(C.PrecedenceInfo_9Uv);
        return next;
      }
    },
    tokenizeSingleLineComment$2: function(next, start) {
      var asciiOnly;
      for (asciiOnly = true; true;) {
        next = this.advance$0();
        if (typeof next !== "number")
          return next.$gt();
        if (next > 127)
          asciiOnly = false;
        if (10 === next || 13 === next || 0 === next) {
          if (!asciiOnly)
            this.handleUnicode$1(start);
          this.appendComment$2(start, asciiOnly);
          return next;
        }
      }
      return;
    },
    tokenizeMultiLineComment$2: function(next, start) {
      var unicodeStart, asciiOnlyComment, asciiOnlyLines, nesting, t1;
      next = this.advance$0();
      for (unicodeStart = start, asciiOnlyComment = true, asciiOnlyLines = true, nesting = 1; true;)
        if (0 === next) {
          if (!asciiOnlyLines)
            this.handleUnicode$1(unicodeStart);
          t1 = this.tokenStart;
          this.appendErrorToken$1(new Y.UnterminatedToken("/*", this.get$stringOffset(), t1, null));
          this.advanceAfterError$1(true);
          break;
        } else if (42 === next) {
          next = this.advance$0();
          if (47 === next) {
            --nesting;
            if (0 === nesting) {
              if (!asciiOnlyLines)
                this.handleUnicode$1(unicodeStart);
              next = this.advance$0();
              this.appendComment$2(start, asciiOnlyComment);
              break;
            } else
              next = this.advance$0();
          }
        } else if (47 === next) {
          next = this.advance$0();
          if (42 === next) {
            next = this.advance$0();
            ++nesting;
          }
        } else if (next === 10) {
          if (!asciiOnlyLines) {
            this.handleUnicode$1(unicodeStart);
            unicodeStart = this.get$scanOffset();
            asciiOnlyLines = true;
          }
          this.lineFeedInMultiline$0();
          next = this.advance$0();
        } else {
          if (typeof next !== "number")
            return next.$gt();
          if (next > 127) {
            asciiOnlyComment = false;
            asciiOnlyLines = false;
          }
          next = this.advance$0();
        }
      return next;
    },
    tokenizeRawStringKeywordOrIdentifier$1: function(next) {
      var nextnext, start;
      nextnext = this.peek$0();
      if (nextnext === 34 || nextnext === 39) {
        start = this.get$scanOffset();
        return this.tokenizeString$3(this.advance$0(), start, true);
      }
      return this.tokenizeKeywordOrIdentifier$2(next, true);
    },
    tokenizeKeywordOrIdentifier$2: function(next, allowDollar) {
      var state, start, t1, t2;
      state = Y.KeywordState_KEYWORD_STATE();
      start = this.get$scanOffset();
      while (true) {
        t1 = state != null;
        if (t1) {
          if (typeof next !== "number")
            return H.iae(next);
          t2 = 97 <= next && next <= 122;
        } else
          t2 = false;
        if (!t2)
          break;
        state = state.next$1(next);
        next = this.advance$0();
      }
      if (!t1 || state.keyword == null)
        return this.tokenizeIdentifier$3(next, start, allowDollar);
      if (typeof next !== "number")
        return H.iae(next);
      if (!(65 <= next && next <= 90))
        t1 = 48 <= next && next <= 57 || next === 95 || next === 36;
      else
        t1 = true;
      if (t1)
        return this.tokenizeIdentifier$3(next, start, allowDollar);
      else {
        this.appendKeywordToken$1(state.keyword);
        return next;
      }
    },
    tokenizeIdentifier$3: function(next, start, allowDollar) {
      var t1;
      for (; true;) {
        if (typeof next !== "number")
          return H.iae(next);
        if (!(97 <= next && next <= 122))
          if (!(65 <= next && next <= 90))
            if (!(48 <= next && next <= 57))
              if (next !== 95)
                t1 = next === 36 && allowDollar;
              else
                t1 = true;
            else
              t1 = true;
          else
            t1 = true;
        else
          t1 = true;
        if (t1)
          next = this.advance$0();
        else {
          if (start === this.get$scanOffset()) {
            this.appendErrorToken$1(new Y.BadInputToken(next, this.tokenStart, null));
            return this.advanceAfterError$1(true);
          } else
            this.appendSubstringToken$3(C.PrecedenceInfo_identifier_0_97, start, true);
          break;
        }
      }
      return next;
    },
    tokenizeString$3: function(next, start, raw) {
      var next0 = this.advance$0();
      if (next == null ? next0 == null : next === next0) {
        next0 = this.advance$0();
        if (next == null ? next0 == null : next === next0)
          return this.tokenizeMultiLineString$3(next, start, raw);
        else {
          this.appendSubstringToken$3(C.PrecedenceInfo_string_0_39, start, true);
          return next0;
        }
      }
      if (raw)
        return this.tokenizeSingleLineRawString$3(next0, next, start);
      else
        return this.tokenizeSingleLineString$3(next0, next, start);
    },
    tokenizeSingleLineString$3: function(next, quoteChar, start) {
      var asciiOnly, t1, t2;
      for (asciiOnly = true; next == null ? quoteChar != null : next !== quoteChar;) {
        if (next === 92)
          next = this.advance$0();
        else if (next === 36) {
          if (!asciiOnly)
            this.handleUnicode$1(start);
          next = this.tokenizeStringInterpolation$2(start, asciiOnly);
          start = this.get$scanOffset();
          asciiOnly = true;
          continue;
        }
        if (typeof next !== "number")
          return next.$le();
        if (next <= 13)
          t1 = next === 10 || next === 13 || next === 0;
        else
          t1 = false;
        if (t1) {
          if (!asciiOnly)
            this.handleUnicode$1(start);
          t1 = H.Primitives_stringFromCharCodes([quoteChar]);
          t2 = this.tokenStart;
          this.appendErrorToken$1(new Y.UnterminatedToken(t1, this.get$stringOffset(), t2, null));
          return this.advanceAfterError$1(true);
        }
        if (next > 127)
          asciiOnly = false;
        next = this.advance$0();
      }
      if (!asciiOnly)
        this.handleUnicode$1(start);
      next = this.advance$0();
      this.appendSubstringToken$3(C.PrecedenceInfo_string_0_39, start, asciiOnly);
      return next;
    },
    tokenizeStringInterpolation$2: function(start, asciiOnly) {
      var next, t1;
      this.appendSubstringToken$3(C.PrecedenceInfo_string_0_39, start, asciiOnly);
      this.tokenStart = this.get$stringOffset();
      next = this.advance$0();
      if (next === 123)
        return this.tokenizeInterpolatedExpression$1(next);
      else {
        this.appendPrecedenceToken$1(C.PrecedenceInfo_$_0_159);
        if (typeof next !== "number")
          return H.iae(next);
        if (97 <= next && next <= 122) {
          this.tokenStart = this.get$stringOffset();
          next = this.tokenizeKeywordOrIdentifier$2(next, false);
        } else if (65 <= next && next <= 90 || next === 95) {
          this.tokenStart = this.get$stringOffset();
          next = this.tokenizeIdentifier$3(next, this.get$scanOffset(), false);
        } else {
          t1 = this.tokenStart;
          this.appendErrorToken$1(new Y.UnterminatedToken("$", this.get$stringOffset(), t1, null));
          this.advanceAfterError$1(false);
        }
        this.tokenStart = this.get$stringOffset();
        return next;
      }
    },
    tokenizeInterpolatedExpression$1: function(next) {
      var t1;
      this.appendBeginGroup$1(C.PrecedenceInfo_DYf);
      this.tokenStart = this.get$stringOffset();
      next = this.advance$0();
      while (true) {
        t1 = next === 0;
        if (!(!t1 && next !== 2))
          break;
        next = this.bigSwitch$1(next);
      }
      if (t1)
        return next;
      next = this.advance$0();
      this.tokenStart = this.get$stringOffset();
      return next;
    },
    tokenizeSingleLineRawString$3: function(next, quoteChar, start) {
      var asciiOnly, t1, t2;
      next = this.advance$0();
      for (asciiOnly = true; next !== 0;) {
        if (next == null ? quoteChar == null : next === quoteChar) {
          if (!asciiOnly)
            this.handleUnicode$1(start);
          next = this.advance$0();
          this.appendSubstringToken$3(C.PrecedenceInfo_string_0_39, start, asciiOnly);
          return next;
        } else if (next === 10 || next === 13) {
          if (!asciiOnly)
            this.handleUnicode$1(start);
          t1 = "r" + H.Primitives_stringFromCharCodes([quoteChar]);
          t2 = this.tokenStart;
          this.appendErrorToken$1(new Y.UnterminatedToken(t1, this.get$stringOffset(), t2, null));
          return this.advanceAfterError$1(true);
        } else {
          if (typeof next !== "number")
            return next.$gt();
          if (next > 127)
            asciiOnly = false;
        }
        next = this.advance$0();
      }
      if (!asciiOnly)
        this.handleUnicode$1(start);
      t1 = "r" + P.String_String$fromCharCodes([quoteChar]);
      t2 = this.tokenStart;
      this.appendErrorToken$1(new Y.UnterminatedToken(t1, this.get$stringOffset(), t2, null));
      return this.advanceAfterError$1(true);
    },
    tokenizeMultiLineRawString$2: function(quoteChar, start) {
      var next, unicodeStart, asciiOnlyString, asciiOnlyLine, t1, t2;
      next = this.advance$0();
      $outer$0:
        for (unicodeStart = start, asciiOnlyString = true, asciiOnlyLine = true; next !== 0;) {
          for (; next == null ? quoteChar != null : next !== quoteChar;) {
            if (next === 10) {
              if (!asciiOnlyLine) {
                this.handleUnicode$1(unicodeStart);
                unicodeStart = this.get$scanOffset();
                asciiOnlyLine = true;
              }
              this.lineFeedInMultiline$0();
            } else {
              if (typeof next !== "number")
                return next.$gt();
              if (next > 127) {
                asciiOnlyString = false;
                asciiOnlyLine = false;
              }
            }
            next = this.advance$0();
            if (next === 0)
              break $outer$0;
          }
          next = this.advance$0();
          if (next == null ? quoteChar == null : next === quoteChar) {
            next = this.advance$0();
            if (next == null ? quoteChar == null : next === quoteChar) {
              if (!asciiOnlyLine)
                this.handleUnicode$1(unicodeStart);
              next = this.advance$0();
              this.appendSubstringToken$3(C.PrecedenceInfo_string_0_39, start, asciiOnlyString);
              return next;
            }
          }
        }
      if (!asciiOnlyLine)
        this.handleUnicode$1(unicodeStart);
      t1 = "r" + P.String_String$fromCharCodes([quoteChar, quoteChar, quoteChar]);
      t2 = this.tokenStart;
      this.appendErrorToken$1(new Y.UnterminatedToken(t1, this.get$stringOffset(), t2, null));
      return this.advanceAfterError$1(true);
    },
    tokenizeMultiLineString$3: function(quoteChar, start, raw) {
      var next, unicodeStart, asciiOnlyString, asciiOnlyLine, t1, t2;
      if (raw)
        return this.tokenizeMultiLineRawString$2(quoteChar, start);
      next = this.advance$0();
      for (unicodeStart = start, asciiOnlyString = true, asciiOnlyLine = true; next !== 0;) {
        if (next === 36) {
          if (!asciiOnlyLine)
            this.handleUnicode$1(unicodeStart);
          next = this.tokenizeStringInterpolation$2(start, asciiOnlyString);
          start = this.get$scanOffset();
          unicodeStart = start;
          asciiOnlyString = true;
          asciiOnlyLine = true;
          continue;
        }
        if (next == null ? quoteChar == null : next === quoteChar) {
          next = this.advance$0();
          if (next == null ? quoteChar == null : next === quoteChar) {
            next = this.advance$0();
            if (next == null ? quoteChar == null : next === quoteChar) {
              if (!asciiOnlyLine)
                this.handleUnicode$1(unicodeStart);
              next = this.advance$0();
              this.appendSubstringToken$3(C.PrecedenceInfo_string_0_39, start, asciiOnlyString);
              return next;
            }
          }
          continue;
        }
        if (next === 92) {
          next = this.advance$0();
          if (next === 0)
            break;
        }
        if (next === 10) {
          if (!asciiOnlyLine) {
            this.handleUnicode$1(unicodeStart);
            unicodeStart = this.get$scanOffset();
            asciiOnlyLine = true;
          }
          this.lineFeedInMultiline$0();
        } else {
          if (typeof next !== "number")
            return next.$gt();
          if (next > 127) {
            asciiOnlyString = false;
            asciiOnlyLine = false;
          }
        }
        next = this.advance$0();
      }
      if (!asciiOnlyLine)
        this.handleUnicode$1(unicodeStart);
      t1 = P.String_String$fromCharCodes([quoteChar, quoteChar, quoteChar]);
      t2 = this.tokenStart;
      this.appendErrorToken$1(new Y.UnterminatedToken(t1, this.get$stringOffset(), t2, null));
      return this.advanceAfterError$1(true);
    },
    advanceAfterError$1: function(shouldAdvance) {
      if (this.atEndOfFile$0())
        return 0;
      if (shouldAdvance)
        return this.advance$0();
      else
        return -1;
    },
    unmatchedBeginGroup$1: function(begin) {
      var synthetic, next;
      synthetic = new Y.SymbolToken(C.Map_4uNPy.$index(0, begin.get$info().value), begin.get$charOffset(), null);
      next = new Y.UnmatchedToken(begin, begin.charOffset, null);
      begin.set$endGroup(synthetic);
      synthetic.next = next;
      this.appendErrorToken$1(next);
    }
  },
  ScannerTask: {
    "^": "CompilerTask;compiler,watch,profilerTag",
    get$name: function(_) {
      return "Scanner";
    },
    scan$1: function(compilationUnit) {
      this.measure$1(new Y.ScannerTask_scan_closure(this, compilationUnit));
    },
    tokenize$1: function(source) {
      return this.measure$1(new Y.ScannerTask_tokenize_closure(source));
    }
  },
  ScannerTask_scan_closure: {
    "^": "Closure:23;this_0,compilationUnit_1",
    call$0: function() {
      var t1, t2, t3, tokens;
      t1 = this.compilationUnit_1;
      t2 = this.this_0.compiler;
      t3 = t2.preserveComments;
      tokens = Y.Scanner_Scanner(t1.script.file, t3).tokenize$0();
      if (t3)
        tokens = t2.processAndStripComments$1(tokens);
      t2.dietParser.dietParse$2(t1, tokens);
    },
    $isFunction: true
  },
  ScannerTask_tokenize_closure: {
    "^": "Closure:23;source_0",
    call$0: function() {
      var t1, t2;
      t1 = new Y.SymbolToken(C.PrecedenceInfo_EOF_0_0, -1, null);
      t2 = new Y.StringScanner(this.source_0, -1, C.C_Link13, false, -1, t1, null, null, H.setRuntimeTypeInfo([0], [P.$int]));
      t2.tail = t1;
      t2.ensureZeroTermination$0();
      return t2.tokenize$0();
    },
    $isFunction: true
  },
  DietParserTask: {
    "^": "CompilerTask;name>,compiler,watch,profilerTag",
    dietParse$2: function(compilationUnit, tokens) {
      this.measure$1(new Y.DietParserTask_dietParse_closure(this, compilationUnit, tokens));
    }
  },
  DietParserTask_dietParse_closure: {
    "^": "Closure:23;this_0,compilationUnit_1,tokens_2",
    call$0: function() {
      var t1 = this.this_0.compiler;
      new Y.PartialParser(Y.ElementListener$(t1, this.compilationUnit_1, t1.get$getNextFreeClassId()), true).parseUnit$1(this.tokens_2);
    },
    $isFunction: true
  },
  StringScanner: {
    "^": "ArrayBasedScanner;string<,scanOffset<,groupingStack,includeComments,tokenStart,tokens,tail,file,lineStarts",
    ensureZeroTermination$0: function() {
      if (!C.JSString_methods.get$isEmpty(this.string)) {
        var t1 = this.string;
        t1 = C.JSString_methods.codeUnitAt$1(t1, t1.length - 1) !== 0;
      } else
        t1 = true;
      if (t1)
        this.string += "\u0000";
    },
    advance$0: function() {
      return C.JSString_methods.codeUnitAt$1(this.string, ++this.scanOffset);
    },
    peek$0: function() {
      return C.JSString_methods.codeUnitAt$1(this.string, this.scanOffset + 1);
    },
    get$stringOffset: function() {
      return this.scanOffset;
    },
    currentAsUnicode$1: function(next) {
      return next;
    },
    handleUnicode$1: function(startScanOffset) {
    },
    firstToken$0: function() {
      return this.tokens.next;
    },
    previousToken$0: function() {
      return this.tail;
    },
    appendSubstringToken$4: function(info, start, asciiOnly, extraOffset) {
      var t1, t2, t3, t4, t5;
      t1 = this.tail;
      t2 = this.string;
      t3 = this.scanOffset;
      t4 = this.tokenStart;
      t5 = new Y.StringToken(null, info, t4, null);
      t5.StringToken$fromSubstring$6$canonicalize(info, t2, start, t3 + extraOffset, t4, true);
      t1.next = t5;
      this.tail = this.tail.next;
    },
    appendSubstringToken$3: function(info, start, asciiOnly) {
      return this.appendSubstringToken$4(info, start, asciiOnly, 0);
    },
    atEndOfFile$0: function() {
      return this.scanOffset >= this.string.length - 1;
    }
  },
  Token: {
    "^": "Object;charOffset<,next<",
    get$kind: function(_) {
      return this.get$info().kind;
    },
    get$charCount: function() {
      if (this.get$info() === C.PrecedenceInfo_mJ8)
        return 1;
      else
        return this.get$value(this).length;
    },
    get$hashCode: function(_) {
      return O.computeHashCode(this.charOffset, this.get$info(), this.get$value(this), null, null);
    },
    $isToken: true
  },
  SymbolToken: {
    "^": "Token;info<,charOffset,next",
    get$value: function(_) {
      return this.info.value;
    },
    get$stringValue: function() {
      return this.info.value;
    },
    isIdentifier$0: function() {
      return false;
    },
    toString$0: function(_) {
      return "SymbolToken(" + this.info.value + ")";
    },
    $isSymbolToken: true
  },
  BeginGroupToken: {
    "^": "SymbolToken;endGroup@,info,charOffset,next",
    $isBeginGroupToken: true
  },
  KeywordToken: {
    "^": "Token;keyword,charOffset,next",
    get$info: function() {
      return this.keyword.info;
    },
    get$value: function(_) {
      return this.keyword.syntax;
    },
    get$stringValue: function() {
      return this.keyword.syntax;
    },
    isIdentifier$0: function() {
      var t1 = this.keyword;
      return t1.isPseudo || t1.isBuiltIn;
    },
    toString$0: function(_) {
      return "KeywordToken(" + this.keyword.syntax + ")";
    },
    $isKeywordToken: true
  },
  ErrorToken: {
    "^": "Token;",
    get$info: function() {
      return C.PrecedenceInfo_mJ8;
    },
    get$value: function(_) {
      throw H.wrapException(O.SpannableAssertionFailure$(this, this.get$assertionMessage()));
    },
    get$stringValue: function() {
      return;
    },
    isIdentifier$0: function() {
      return false;
    },
    $isErrorToken: true
  },
  BadInputToken: {
    "^": "ErrorToken;character,charOffset,next",
    toString$0: function(_) {
      return "BadInputToken(" + H.S(this.character) + ")";
    },
    get$assertionMessage: function() {
      return "Character U+" + J.toRadixString$1$n(this.character, 16) + " not allowed here.";
    },
    $isBadInputToken: true
  },
  UnterminatedToken: {
    "^": "ErrorToken;start>,endOffset,charOffset,next",
    toString$0: function(_) {
      return "UnterminatedToken(" + this.start + ")";
    },
    get$assertionMessage: function() {
      return "'" + this.start + "' isn't terminated.";
    },
    get$charCount: function() {
      return this.endOffset - this.charOffset;
    },
    $isUnterminatedToken: true
  },
  UnmatchedToken: {
    "^": "ErrorToken;begin,charOffset,next",
    toString$0: function(_) {
      return "UnmatchedToken(" + this.begin.info.value + ")";
    },
    get$assertionMessage: function() {
      return "'" + ("SymbolToken(" + this.begin.info.value + ")") + "' isn't closed.";
    },
    $isUnmatchedToken: true
  },
  StringToken: {
    "^": "Token;valueOrLazySubstring,info<,charOffset,next",
    get$value: function(_) {
      var t1, data, start, end;
      t1 = this.valueOrLazySubstring;
      if (typeof t1 === "string")
        return t1;
      else {
        data = J.get$data$x(t1);
        start = J.get$start$x(this.valueOrLazySubstring);
        end = start + J.get$length$asx(this.valueOrLazySubstring);
        if (typeof data === "string") {
          t1 = Y.StringToken_canonicalizedString(C.JSString_methods.substring$2(data, start, end), this.valueOrLazySubstring.get$boolValue());
          this.valueOrLazySubstring = t1;
        } else {
          t1 = Y.StringToken_decodeUtf8(data, start, end, this.valueOrLazySubstring.get$boolValue());
          this.valueOrLazySubstring = t1;
        }
        return t1;
      }
    },
    get$stringValue: function() {
      return;
    },
    isIdentifier$0: function() {
      return this.info.kind === 97;
    },
    toString$0: function(_) {
      return "StringToken(" + H.S(this.get$value(this)) + ")";
    },
    StringToken$fromUtf8Bytes$6: function(info, data, start, end, asciiOnly, charOffset) {
      var $length = end - start;
      if ($length <= 4)
        this.valueOrLazySubstring = Y.StringToken_decodeUtf8(data, start, end, asciiOnly);
      else
        this.valueOrLazySubstring = Y.LazySubstring_LazySubstring(data, start, $length, asciiOnly);
    },
    StringToken$fromSubstring$6$canonicalize: function(info, data, start, end, charOffset, canonicalize) {
      var $length = end - start;
      if ($length <= 4)
        this.valueOrLazySubstring = Y.StringToken_canonicalizedString(C.JSString_methods.substring$2(data, start, end), canonicalize);
      else
        this.valueOrLazySubstring = Y.LazySubstring_LazySubstring(data, start, $length, canonicalize);
    },
    $isStringToken: true,
    static: {"^": "StringToken_LAZY_THRESHOLD,StringToken_canonicalizedSubstrings", StringToken_canonicalizedString: function(s, canonicalize) {
        var t1, result;
        if (!canonicalize)
          return s;
        t1 = $.get$StringToken_canonicalizedSubstrings();
        result = t1.lookup$1(s);
        if (result != null)
          return result;
        t1.add$1(0, s);
        return s;
      }, StringToken_decodeUtf8: function(data, start, end, asciiOnly) {
        var t1 = J.getInterceptor$ax(data);
        return Y.StringToken_canonicalizedString(asciiOnly ? P.String_String$fromCharCodes(t1.getRange$2(data, start, end)) : C.Utf8Codec_false.decode$1(t1.sublist$2(data, start, end)), true);
      }}
  },
  LazySubstring: {
    "^": "Object;"
  },
  CompactLazySubstring: {
    "^": "LazySubstring;data>,fields<",
    get$start: function(_) {
      return this.fields >>> 10;
    },
    get$length: function(_) {
      return this.fields >>> 1 & 511;
    },
    get$boolValue: function() {
      return (this.fields & 1) === 1;
    }
  },
  FullLazySubstring: {
    "^": "LazySubstring;data>,start>,length>,boolValue<"
  },
  PrecedenceInfo: {
    "^": "Object;value>,precedence,kind>",
    toString$0: function(_) {
      return "PrecedenceInfo(" + this.value + ", " + this.precedence + ", " + this.kind + ")";
    },
    get$hashCode: function(_) {
      return O.computeHashCode(this.value, this.precedence, this.kind, null, null);
    }
  },
  Utf8BytesScanner: {
    "^": "ArrayBasedScanner;bytes,byteOffset,scanSlack,scanSlackOffset,utf8Slack,lastUnicodeOffset,stringOffsetSlackOffset,groupingStack,includeComments,tokenStart,tokens,tail,file,lineStarts",
    get$scanOffset: function() {
      var t1 = this.byteOffset;
      if (t1 === this.scanSlackOffset)
        return t1 - this.scanSlack;
      else
        return t1;
    },
    ensureZeroTermination$0: function() {
      var t1, t2, newBytes, i;
      if (!J.get$isEmpty$asx(this.bytes)) {
        t1 = this.bytes;
        t2 = J.getInterceptor$asx(t1);
        t1 = !J.$eq(t2.$index(t1, t2.get$length(t1) - 1), 0);
      } else
        t1 = true;
      if (t1) {
        t1 = J.get$length$asx(this.bytes) + 1;
        newBytes = new Uint8Array(t1);
        for (i = 0; i < J.get$length$asx(this.bytes); ++i) {
          t2 = J.$index$asx(this.bytes, i);
          if (i >= t1)
            return H.ioore(newBytes, i);
          newBytes[i] = t2;
        }
        t2 = J.get$length$asx(this.bytes);
        if (t2 < 0 || t2 >= t1)
          return H.ioore(newBytes, t2);
        newBytes[t2] = 0;
        this.bytes = newBytes;
      }
    },
    advance$0: function() {
      return J.$index$asx(this.bytes, ++this.byteOffset);
    },
    peek$0: function() {
      return J.$index$asx(this.bytes, this.byteOffset + 1);
    },
    nextCodePoint$3: function(startOffset, nextByte, advance) {
      var numBytes, bit, end, codePoint, t1;
      for (numBytes = 2, bit = 32; (nextByte & bit) !== 0;) {
        ++numBytes;
        bit = bit >>> 1;
      }
      end = startOffset + numBytes;
      if (advance)
        this.byteOffset = end - 1;
      codePoint = C.Utf8Codec_false.decode$1(J.sublist$2$ax(this.bytes, startOffset, end));
      if (codePoint.length === 0)
        codePoint = H.Primitives_stringFromCharCode(65279);
      t1 = codePoint.length;
      if (t1 === 1) {
        if (advance) {
          t1 = numBytes - 1;
          this.utf8Slack = this.utf8Slack + t1;
          this.scanSlack = t1;
          this.scanSlackOffset = this.byteOffset;
        }
        return C.JSString_methods.codeUnitAt$1(codePoint, 0);
      } else if (t1 === 2) {
        if (advance) {
          this.utf8Slack = this.utf8Slack + (numBytes - 2);
          this.scanSlack = numBytes - 1;
          t1 = this.byteOffset;
          this.scanSlackOffset = t1;
          this.stringOffsetSlackOffset = t1;
        }
        t1 = new P.Runes(codePoint);
        return t1.get$single(t1);
      } else
        throw H.wrapException("Invalid UTF-8 byte sequence: " + H.S(J.sublist$2$ax(this.bytes, startOffset, end)));
    },
    currentAsUnicode$1: function(next) {
      var t1, res;
      if (next < 128)
        return next;
      t1 = this.byteOffset;
      if (t1 === this.lastUnicodeOffset)
        return next;
      res = this.nextCodePoint$3(t1, next, true);
      this.lastUnicodeOffset = this.byteOffset;
      return res;
    },
    handleUnicode$1: function(startScanOffset) {
      var end, t1, allowMalformed, s;
      end = this.byteOffset;
      t1 = J.sublist$2$ax(this.bytes, startScanOffset, end);
      allowMalformed = C.Utf8Codec_false._allowMalformed;
      s = new P.Utf8Decoder(allowMalformed).convert$1(t1);
      this.utf8Slack = this.utf8Slack + (end - startScanOffset - s.length);
    },
    get$stringOffset: function() {
      var t1, t2, t3;
      t1 = this.stringOffsetSlackOffset;
      t2 = this.byteOffset;
      t3 = this.utf8Slack;
      if (t1 === t2)
        return t2 - t3 - 1;
      else
        return t2 - t3;
    },
    firstToken$0: function() {
      return this.tokens.next;
    },
    previousToken$0: function() {
      return this.tail;
    },
    appendSubstringToken$4: function(info, start, asciiOnly, extraOffset) {
      var t1, t2, t3, t4, t5;
      t1 = this.tail;
      t2 = this.bytes;
      t3 = this.byteOffset;
      t4 = this.tokenStart;
      t5 = new Y.StringToken(null, info, t4, null);
      t5.StringToken$fromUtf8Bytes$6(info, t2, start, t3 + extraOffset, asciiOnly, t4);
      t1.next = t5;
      this.tail = this.tail.next;
    },
    appendSubstringToken$3: function(info, start, asciiOnly) {
      return this.appendSubstringToken$4(info, start, asciiOnly, 0);
    },
    atEndOfFile$0: function() {
      return this.byteOffset >= J.get$length$asx(this.bytes) - 1;
    },
    Utf8BytesScanner$2$includeComments: function(file, includeComments) {
      this.ensureZeroTermination$0();
      if (3 < J.get$length$asx(this.bytes) && J.$eq(J.$index$asx(this.bytes, 0), 239) && J.$eq(J.$index$asx(this.bytes, 1), 187) && J.$eq(J.$index$asx(this.bytes, 2), 191))
        this.byteOffset += 3;
    }
  }
}],
["secret_tree_element", "package:compiler/implementation/resolution/secret_tree_element.dart", , G, {
  "^": "",
  NullTreeElementMixin: {
    "^": "Object;",
    get$_secret_tree_element$_element: function() {
      return;
    },
    set$_secret_tree_element$_element: function(_) {
    }
  },
  StoredTreeElementMixin: {
    "^": "Object;_secret_tree_element$_element:secret_tree_element$StoredTreeElementMixin$_secret_tree_element$_element@"
  }
}],
["simple_types_inferrer", "package:compiler/implementation/inferrer/simple_types_inferrer.dart", , Q, {
  "^": "",
  TypeMaskSystem: {
    "^": "Object;compiler<",
    narrowType$3$isNullable: function(type, annotation, isNullable) {
      var t1, t2, t3, otherType;
      if (annotation.get$treatAsDynamic())
        return type;
      t1 = annotation.get$element();
      t2 = this.compiler;
      t3 = t2.objectClass;
      if (t1 == null ? t3 == null : t1 === t3)
        return type;
      if (annotation.get$kind(annotation) === C.TypeKind_typedef || annotation.get$kind(annotation) === C.TypeKind_function)
        otherType = t2.typesTask.get$functionType();
      else if (annotation.get$kind(annotation) === C.TypeKind_kuk)
        return type;
      else
        otherType = annotation.get$kind(annotation) === C.TypeKind_void ? t2.typesTask.get$nullType() : new B.FlatTypeMask(annotation.get$element(), 6);
      if (isNullable)
        otherType = otherType.nullable$0();
      if (type == null)
        return otherType;
      return type.intersection$2(0, otherType, t2);
    },
    narrowType$2: function(type, annotation) {
      return this.narrowType$3$isNullable(type, annotation, true);
    },
    get$functionType: function() {
      return this.compiler.typesTask.get$functionType();
    },
    isNull$1: [function(mask) {
      mask.get$isEmpty(mask);
      return false;
    }, "call$1", "get$isNull", 2, 0, 251]
  },
  InferrerEngine: {
    "^": "Object;compiler<,types<",
    forEachElementMatching$2: function(selector, f) {
      var t1;
      for (t1 = J.get$iterator$ax(this.compiler.world.allFunctions.query$1(0, selector).functions); t1.moveNext$0();)
        if (f.call$1(J.get$implementation$x(t1.get$current())) !== true)
          return;
    },
    updateSideEffects$3: function(sideEffects, selector, callee) {
      var t1, t2;
      if (J.get$kind$x(callee) === C.ElementKind_field_1)
        if (callee.get$isInstanceMember()) {
          t1 = selector.kind;
          if (t1 === C.SelectorKind_setter_1)
            sideEffects.flags = (sideEffects.flags | 2) >>> 0;
          else {
            t2 = sideEffects.flags;
            if (t1 === C.SelectorKind_getter_0)
              sideEffects.flags = (t2 | 16) >>> 0;
            else {
              sideEffects.flags = (t2 | 7) >>> 0;
              sideEffects.setDependsOnSomething$0();
            }
          }
        } else {
          t1 = selector.kind;
          if (t1 === C.SelectorKind_setter_1)
            sideEffects.flags = (sideEffects.flags | 4) >>> 0;
          else {
            t2 = sideEffects.flags;
            if (t1 === C.SelectorKind_getter_0)
              sideEffects.flags = (t2 | 32) >>> 0;
            else {
              sideEffects.flags = (t2 | 7) >>> 0;
              sideEffects.setDependsOnSomething$0();
            }
          }
        }
      else if (callee.get$isGetter() && selector.kind !== C.SelectorKind_getter_0) {
        sideEffects.flags = (sideEffects.flags | 7) >>> 0;
        sideEffects.setDependsOnSomething$0();
      } else {
        t1 = this.compiler.world.getSideEffectsOfElement$1(callee);
        sideEffects.flags = (sideEffects.flags | t1.flags) >>> 0;
      }
    },
    typeOfNativeBehavior$1: function(nativeBehavior) {
      var typesReturned, t1, t2, returnType, type, mappedType, t3, t4, classes, element, subtypes, subclasses;
      typesReturned = nativeBehavior.typesReturned;
      t1 = typesReturned.length;
      if (t1 === 0)
        return this.get$types().get$dynamicType();
      for (t1 = H.setRuntimeTypeInfo(new H.ListIterator(typesReturned, t1, 0, null), [H.getTypeArgumentByIndex(typesReturned, 0)]), t2 = this.compiler, returnType = null; t1.moveNext$0();) {
        type = t1.__internal$_current;
        if (J.$eq(type, C.SpecialType_MYA))
          mappedType = this.get$types().nonNullExact$1(t2.objectClass);
        else {
          t3 = type.get$element();
          t4 = t2.stringClass;
          if (t3 == null ? t4 == null : t3 === t4)
            mappedType = this.get$types().get$stringType();
          else {
            t3 = type.get$element();
            t4 = t2.intClass;
            if (t3 == null ? t4 == null : t3 === t4)
              mappedType = this.get$types().get$intType();
            else {
              t3 = type.get$element();
              t4 = t2.doubleClass;
              if (t3 == null ? t4 == null : t3 === t4)
                mappedType = this.get$types().get$doubleType();
              else {
                t3 = type.get$element();
                t4 = t2.numClass;
                if (t3 == null ? t4 == null : t3 === t4)
                  mappedType = this.get$types().get$numType();
                else {
                  t3 = type.get$element();
                  t4 = t2.boolClass;
                  if (t3 == null ? t4 == null : t3 === t4)
                    mappedType = this.get$types().get$boolType();
                  else {
                    t3 = type.get$element();
                    t4 = t2.nullClass;
                    if (t3 == null ? t4 == null : t3 === t4)
                      mappedType = this.get$types().get$nullType();
                    else if (type.get$isVoid())
                      mappedType = this.get$types().get$nullType();
                    else if (type.get$isDynamic())
                      return this.get$types().get$dynamicType();
                    else {
                      t3 = t2.world;
                      t4 = type.get$element();
                      classes = t3._subtypes.$index(0, t4.get$declaration());
                      if (!(classes != null && !J.get$isEmpty$asx(classes)))
                        mappedType = this.get$types().nonNullExact$1(type.get$element());
                      else {
                        element = type.get$element();
                        subtypes = t2.world._subtypes.$index(0, element.get$declaration());
                        subclasses = t2.world._subclasses.$index(0, element.get$declaration());
                        if (subclasses != null) {
                          t3 = J.get$length$asx(subtypes);
                          t4 = J.get$length$asx(subclasses);
                          t4 = t3 == null ? t4 == null : t3 === t4;
                          t3 = t4;
                        } else
                          t3 = false;
                        mappedType = t3 ? this.get$types().nonNullSubclass$1(element) : this.get$types().nonNullSubtype$1(element);
                      }
                    }
                  }
                }
              }
            }
          }
        }
        returnType = this.get$types().computeLUB$2(returnType, mappedType);
        if (J.$eq(returnType, this.get$types().get$dynamicType()))
          break;
      }
      return returnType;
    },
    updateSelectorInTree$3: function(owner, node, selector) {
      var elements, t1, t2;
      elements = owner.get$resolvedAst().elements;
      if (node.asSendSet$0() != null) {
        t1 = selector.kind;
        if (t1 !== C.SelectorKind_setter_1)
          t2 = t1 === C.SelectorKind_index_4 && selector.argumentCount === 2;
        else
          t2 = true;
        if (t2)
          elements._setSelector$2(node, selector);
        else {
          if (t1 !== C.SelectorKind_getter_0)
            t1 = t1 === C.SelectorKind_index_4 && selector.argumentCount === 1;
          else
            t1 = true;
          if (t1) {
            elements.toString;
            elements._setSelector$2(node.get$selector(), selector);
          } else {
            elements.toString;
            elements._setSelector$2(node.get$assignmentOperator(), selector);
          }
        }
      } else if (node.asSend$0() != null)
        elements._setSelector$2(node, selector);
      else {
        t1 = this.compiler;
        if (selector.get$asUntyped() === t1.iteratorSelector)
          elements._setSelector$2(node, selector);
        else if (selector.get$asUntyped() === t1.currentSelector) {
          elements.toString;
          elements._setSelector$2(node.get$inToken(), selector);
        } else {
          elements.toString;
          elements._setSelector$2(node.get$forToken(), selector);
        }
      }
    },
    isNativeElement$1: function(element) {
      if (element.get$isNative())
        return true;
      return element.get$isClassMember() && element.get$enclosingClass().get$isNative() && element.kind === C.ElementKind_field_1;
    }
  },
  SimpleTypeInferrerVisitor: {
    "^": "InferrerVisitor;returnType<,visitingInitializers,isConstructorRedirect,seenSuperConstructorCall,sideEffects<,outermostElement<,inferrer:simple_types_inferrer$SimpleTypeInferrerVisitor$inferrer<,capturedVariables,analyzedElement,types,inferrer,breaksFor,continuesFor,locals,cascadeReceiverStack,accumulateIsChecks,conditionIsSimple,isChecks,loopLevel,_thisType,_superType,compiler,elements",
    analyzeSuperConstructorCall$2: function(target, $arguments) {
      var t1, t2;
      this.get$inferrer().analyze$2(target, $arguments);
      t1 = this.analyzedElement;
      t2 = t1.get$kind(t1) !== C.ElementKind_generative_constructor_16 || this.locals.fieldScope.isThisExposed || this.get$inferrer().generativeConstructorsExposingThis.contains$1(0, target.get$implementation(target));
      if (t1.kind === C.ElementKind_generative_constructor_16)
        this.locals.fieldScope.isThisExposed = t2;
    },
    run$0: function() {
      var t1, t2, initializer, t3, closureData, signature, t4, cls, selector, target, t5, element;
      t1 = {};
      t2 = this.analyzedElement;
      t1.node_0 = t2.get$node();
      if (t2.get$kind(t2) === C.ElementKind_field_1) {
        initializer = t2.get$initializer();
        if (initializer == null)
          return this.types.get$nullType();
      } else
        initializer = null;
      t3 = this.compiler;
      closureData = t3.closureToClassMapper.computeClosureToClassMapping$3(t2, t1.node_0, this.elements);
      closureData.forEachCapturedVariable$1(new Q.SimpleTypeInferrerVisitor_run_closure(this));
      closureData.forEachBoxedVariable$1(new Q.SimpleTypeInferrerVisitor_run_closure0(this));
      if (t2.kind === C.ElementKind_field_1)
        return initializer == null ? null : initializer.accept$1(0, this);
      signature = t2.get$functionSignature();
      signature.forEachOptionalParameter$1(new Q.SimpleTypeInferrerVisitor_run_closure1(this));
      if (t2.get$isNative())
        return this.types.get$dynamicType();
      if (t2.kind === C.ElementKind_generative_constructor_16) {
        if (t2.kind === C.ElementKind_generative_constructor_16)
          this.locals.fieldScope.isThisExposed = false;
        t4 = new Q.SimpleTypeInferrerVisitor_run_closure2(t1, this);
        signature.forEachRequiredParameter$1(t4);
        signature.forEachOptionalParameter$1(t4);
        cls = t2.get$enclosingClass();
        if (t2.get$isSynthesized()) {
          t1.node_0 = t2;
          this.synthesizeForwardingCall$2(t2, t2.get$definingConstructor());
        } else {
          this.visitingInitializers = true;
          t4 = t1.node_0.get$initializers();
          if (t4 == null)
            ;
          else
            t4.accept$1(0, this);
          this.visitingInitializers = false;
          if (!this.isConstructorRedirect && !this.seenSuperConstructorCall && !cls.isObject$1(t3)) {
            selector = Z.Selector_Selector(C.SelectorKind_call_2, "", t2.get$library(), 0, null);
            target = cls.get$superclass().lookupConstructor$1(selector);
            this.analyzeSuperConstructorCall$2(target, X.ArgumentsTypes$([], P.LinkedHashMap_LinkedHashMap$_empty(null, null), null));
            this.synthesizeForwardingCall$2(t2, target);
          }
          t4 = t1.node_0;
          t4 = t4.get$body(t4);
          if (t4 == null)
            ;
          else
            t4.accept$1(0, this);
          t4 = this.get$inferrer();
          t5 = t2.kind !== C.ElementKind_generative_constructor_16 || this.locals.fieldScope.isThisExposed;
          element = t2.get$implementation(t2);
          if (t5)
            t4.generativeConstructorsExposingThis.add$1(0, element);
        }
        if (!this.isConstructorRedirect)
          cls.forEachInstanceField$1(new Q.SimpleTypeInferrerVisitor_run_closure3(t1, this));
        this.returnType = this.types.nonNullExact$1(cls);
      } else {
        t4 = new Q.SimpleTypeInferrerVisitor_run_closure4(t1, this);
        signature.forEachRequiredParameter$1(t4);
        signature.forEachOptionalParameter$1(t4);
        t1 = t1.node_0;
        t1 = t1.get$body(t1);
        if (t1 == null)
          ;
        else
          t1.accept$1(0, this);
        if (this.returnType == null) {
          t1 = this.types;
          this.returnType = this.locals.seenReturnOrThrow ? t1.nonNullEmpty$0() : t1.get$nullType();
        } else if (!this.locals.seenReturnOrThrow)
          this.returnType = this.get$inferrer().addReturnTypeFor$3(t2, this.returnType, this.types.get$nullType());
      }
      t3.world.registerSideEffects$2(t2, this.sideEffects);
      return this.returnType;
    },
    visitFunctionExpression$1: function(node) {
      var element, closureLocals, t1, t2, t3, t4, t5, t6, visitor, nestedClosureData;
      this.elements.toString;
      element = node.get$_secret_tree_element$_element();
      closureLocals = X.LocalsHandler$from(this.locals, node, false, H.getRuntimeTypeArgument(this, "SimpleTypeInferrerVisitor", 0));
      t1 = this.compiler;
      t2 = this.get$inferrer();
      t3 = H.getRuntimeTypeArgument(this, "SimpleTypeInferrerVisitor", 0);
      t4 = H.setRuntimeTypeInfo(new N.Setlet(C.C__SetletMarker, null), [O.Element]);
      t5 = element.get$outermostEnclosingMemberOrTopLevel();
      t5 = t5.get$implementation(t5);
      t6 = t2.get$types();
      visitor = H.setRuntimeTypeInfo(new Q.SimpleTypeInferrerVisitor(null, false, false, false, new Z.SideEffects(0), t5, t2, t4, element, t6, t2, P.LinkedHashMap_LinkedHashMap(null, null, null, O.JumpTarget, [P.List, [X.LocalsHandler, t3]]), P.LinkedHashMap_LinkedHashMap(null, null, null, O.JumpTarget, [P.List, [X.LocalsHandler, t3]]), closureLocals, H.setRuntimeTypeInfo([], [t3]), false, false, null, 0, null, null, t1, element.get$resolvedAst().elements), [t3]);
      visitor.InferrerVisitor$5(element, t2, t6, t1, closureLocals, t3, [Q.InferrerEngine, t3, [X.TypeSystem, t3]]);
      visitor.SimpleTypeInferrerVisitor$internal$5(element, t5, t2, t1, closureLocals, t3);
      visitor.run$0();
      this.get$inferrer().recordReturnType$2(element, visitor.returnType);
      nestedClosureData = t1.closureToClassMapper.getMappingForNestedFunction$1(node);
      nestedClosureData.forEachCapturedVariable$1(new Q.SimpleTypeInferrerVisitor_visitFunctionExpression_closure(this, nestedClosureData));
      return this.get$inferrer().concreteTypes.putIfAbsent$2(node, new Q.SimpleTypeInferrerVisitor_visitFunctionExpression_closure0(this, node, element));
    },
    visitFunctionDeclaration$1: function(node) {
      var t1, element, type;
      t1 = node.$function;
      this.elements.toString;
      element = t1.get$_secret_tree_element$_element();
      type = this.get$inferrer().concreteTypes.putIfAbsent$2(t1, new Q.SimpleTypeInferrerVisitor_visitFunctionDeclaration_closure(this, node, element));
      this.locals.update$3(element, type, node);
      t1.accept$1(0, this);
      return type;
    },
    visitStringInterpolation$1: function(node) {
      var t1 = this.sideEffects;
      t1.flags = (t1.flags | 7) >>> 0;
      return X.InferrerVisitor.prototype.visitStringInterpolation$1.call(this, node);
    },
    visitLiteralList$1: function(node) {
      return this.get$inferrer().concreteTypes.putIfAbsent$2(node, new Q.SimpleTypeInferrerVisitor_visitLiteralList_closure(this, node));
    },
    visitLiteralMap$1: function(node) {
      return this.get$inferrer().concreteTypes.putIfAbsent$2(node, new Q.SimpleTypeInferrerVisitor_visitLiteralMap_closure(this, node));
    },
    checkIfExposesThis$1: function(selector) {
      var t1 = this.analyzedElement;
      if (t1.get$kind(t1) !== C.ElementKind_generative_constructor_16 || this.locals.fieldScope.isThisExposed)
        return;
      this.get$inferrer().forEachElementMatching$2(selector, new Q.SimpleTypeInferrerVisitor_checkIfExposesThis_closure(this, selector));
    },
    treatAsInstanceMember$1: function(element) {
      var t1, t2;
      t1 = element != null;
      if (!t1 || element.get$isErroneous()) {
        t2 = this.outermostElement;
        t2 = t2.get$isInstanceMember() && !t2.get$isField() || t2.get$isGenerativeConstructor();
      } else
        t2 = false;
      if (!t2)
        t1 = t1 && element.get$isInstanceMember();
      else
        t1 = true;
      return t1;
    },
    visitSendSet$1: function(node) {
      var element, t1, t2, t3, getterSelector, t4, operatorSelector, setterSelector, op, isIncrementOrDecrement, receiverType, isCallOnThis, rhsType, indexType, node0, getterType, returnType, operatorArguments, newType;
      this.elements.toString;
      element = node.get$_secret_tree_element$_element();
      t1 = element != null;
      if (!(!t1 || element.get$isErroneous()) && element.get$impliesType()) {
        node.visitChildren$1(this);
        return this.types.get$dynamicType();
      }
      t2 = node.selector;
      t3 = this.elements._selectors;
      getterSelector = t3 != null ? t3.$index(0, t2) : null;
      t3 = node.assignmentOperator;
      t4 = this.elements._selectors;
      operatorSelector = t4 != null ? t4.$index(0, t3) : null;
      t4 = this.elements._selectors;
      setterSelector = t4 != null ? t4.$index(0, node) : null;
      t3 = t3.token;
      op = t3.get$value(t3);
      isIncrementOrDecrement = op === "++" || op === "--";
      t3 = node.receiver;
      if (t3 == null)
        if (this.treatAsInstanceMember$1(element)) {
          receiverType = this.get$thisType();
          isCallOnThis = true;
        } else {
          receiverType = null;
          isCallOnThis = false;
        }
      else {
        receiverType = t3.accept$1(0, this);
        isCallOnThis = t3.isThis$0() || t3.isSuper$0();
      }
      if (isIncrementOrDecrement) {
        rhsType = this.types.get$uint31Type();
        if (!!J.getInterceptor(t2).$isOperator) {
          t3 = t2.asOperator$0().token;
          t3 = t3.get$value(t3) === "[]";
        } else
          t3 = false;
        if (t3) {
          t3 = node.argumentsNode.nodes;
          t3 = t3.get$head(t3);
          indexType = t3 == null ? null : J.accept$1$x(t3, this);
        } else
          indexType = null;
      } else {
        if (!!J.getInterceptor(t2).$isOperator) {
          t3 = t2.asOperator$0().token;
          t3 = t3.get$value(t3) === "[]";
        } else
          t3 = false;
        t4 = node.argumentsNode;
        if (t3) {
          t3 = t4.nodes;
          t4 = t3.get$head(t3);
          indexType = t4 == null ? null : J.accept$1$x(t4, this);
          t3 = t3.get$tail();
          t3 = t3.get$head(t3);
          rhsType = t3 == null ? null : J.accept$1$x(t3, this);
        } else {
          t3 = t4.nodes;
          t3 = t3.get$head(t3);
          rhsType = t3 == null ? null : J.accept$1$x(t3, this);
          indexType = null;
        }
      }
      if (!this.visitingInitializers) {
        t3 = this.analyzedElement;
        t4 = !(t3.get$kind(t3) !== C.ElementKind_generative_constructor_16 || this.locals.fieldScope.isThisExposed);
        t3 = t4;
      } else
        t3 = false;
      if (t3) {
        for (t3 = node.argumentsNode.nodes, t3.toString, t3 = H.setRuntimeTypeInfo(new E.LinkIterator(null, t3), [H.getTypeArgumentByIndex(t3, 0)]); t3.moveNext$0();) {
          node0 = t3._util_implementation$_current;
          if (node0.isThis$0() || node0.isSuper$0()) {
            t3 = this.analyzedElement;
            if (t3.get$kind(t3) === C.ElementKind_generative_constructor_16)
              this.locals.fieldScope.isThisExposed = true;
            break;
          }
        }
        t3 = this.analyzedElement;
        if (!(t3.get$kind(t3) !== C.ElementKind_generative_constructor_16 || this.locals.fieldScope.isThisExposed) && isCallOnThis) {
          t3 = this.types;
          this.checkIfExposesThis$1(t3.newTypedSelector$2(receiverType, setterSelector));
          if (getterSelector != null)
            this.checkIfExposesThis$1(t3.newTypedSelector$2(receiverType, getterSelector));
        }
      }
      if (!!J.getInterceptor(t2).$isOperator) {
        t3 = t2.asOperator$0().token;
        t3 = t3.get$value(t3) === "[]";
      } else
        t3 = false;
      if (t3)
        if (op === "=") {
          this.handleDynamicSend$4(node, setterSelector, receiverType, X.ArgumentsTypes$([indexType, rhsType], null, H.getRuntimeTypeArgument(this, "SimpleTypeInferrerVisitor", 0)));
          return rhsType;
        } else {
          getterType = this.handleDynamicSend$4(node, getterSelector, receiverType, X.ArgumentsTypes$([indexType], null, H.getRuntimeTypeArgument(this, "SimpleTypeInferrerVisitor", 0)));
          returnType = this.handleDynamicSend$4(node, operatorSelector, getterType, X.ArgumentsTypes$([rhsType], null, H.getRuntimeTypeArgument(this, "SimpleTypeInferrerVisitor", 0)));
          this.handleDynamicSend$4(node, setterSelector, receiverType, X.ArgumentsTypes$([indexType, returnType], null, H.getRuntimeTypeArgument(this, "SimpleTypeInferrerVisitor", 0)));
          if (!!J.getInterceptor(node.argumentsNode).$isPostfix0)
            return getterType;
          else
            return returnType;
        }
      else if (op === "=") {
        t1 = node.argumentsNode.nodes;
        return this.handlePlainAssignment$6(node, element, setterSelector, receiverType, rhsType, t1.get$head(t1));
      } else {
        operatorArguments = X.ArgumentsTypes$([rhsType], null, H.getRuntimeTypeArgument(this, "SimpleTypeInferrerVisitor", 0));
        if (t1 && element.get$isErroneous()) {
          t1 = this.types;
          getterType = t1.get$dynamicType();
          newType = t1.get$dynamicType();
        } else if (O.Elements_isStaticOrTopLevelField(element)) {
          this.elements.toString;
          getterType = this.handleStaticSend$4(node, getterSelector, t2.get$_secret_tree_element$_element(), null);
          newType = this.handleDynamicSend$4(node, operatorSelector, getterType, operatorArguments);
          this.handleStaticSend$4(node, setterSelector, element, X.ArgumentsTypes$([newType], null, H.getRuntimeTypeArgument(this, "SimpleTypeInferrerVisitor", 0)));
        } else if (!t1 || element.get$isErroneous() || element.get$kind(element) === C.ElementKind_setter_0 || element.kind === C.ElementKind_field_1) {
          getterType = this.handleDynamicSend$4(node, getterSelector, receiverType, null);
          newType = this.handleDynamicSend$4(node, operatorSelector, getterType, operatorArguments);
          this.handleDynamicSend$4(node, setterSelector, receiverType, X.ArgumentsTypes$([newType], null, H.getRuntimeTypeArgument(this, "SimpleTypeInferrerVisitor", 0)));
        } else if (O.Elements_isLocal(element)) {
          getterType = this.locals.use$1(element);
          newType = this.handleDynamicSend$4(node, operatorSelector, getterType, operatorArguments);
          this.locals.update$3(element, newType, node);
        } else {
          getterType = this.types.get$dynamicType();
          newType = this.handleDynamicSend$4(node, operatorSelector, getterType, operatorArguments);
        }
        if (!!J.getInterceptor(node.argumentsNode).$isPostfix0)
          return getterType;
        else
          return newType;
      }
    },
    handlePlainAssignment$6: function(node, element, setterSelector, receiverType, rhsType, rhs) {
      var $arguments, t1, targets, single;
      $arguments = X.ArgumentsTypes$([rhsType], null, H.getRuntimeTypeArgument(this, "SimpleTypeInferrerVisitor", 0));
      t1 = element != null;
      if (t1 && element.get$isErroneous())
        ;
      else if (O.Elements_isStaticOrTopLevelField(element))
        this.handleStaticSend$4(node, setterSelector, element, $arguments);
      else if (!t1 || element.get$isErroneous() || element.get$kind(element) === C.ElementKind_setter_0) {
        t1 = this.analyzedElement;
        if (t1.get$kind(t1) === C.ElementKind_generative_constructor_16 && node.asSendSet$0() != null && node.asSendSet$0().receiver != null && node.asSendSet$0().receiver.isThis$0()) {
          targets = this.compiler.world.allFunctions.query$1(0, this.types.newTypedSelector$2(this.get$thisType(), setterSelector)).functions;
          t1 = J.getInterceptor$asx(targets);
          if (t1.get$length(targets) === 1) {
            single = t1.get$first(targets);
            if (J.get$kind$x(single) === C.ElementKind_field_1)
              this.locals.fieldScope.updateField$2(single, rhsType);
          }
        }
        this.handleDynamicSend$4(node, setterSelector, receiverType, $arguments);
      } else if (element.get$kind(element) === C.ElementKind_field_1)
        if (element.get$isFinal())
          this.get$inferrer().recordTypeOfFinalField$4(node, this.outermostElement, element, rhsType);
        else {
          t1 = this.analyzedElement;
          if (t1.get$kind(t1) === C.ElementKind_generative_constructor_16)
            this.locals.fieldScope.updateField$2(element, rhsType);
          if (this.visitingInitializers)
            this.get$inferrer().recordTypeOfNonFinalField$3(node, element, rhsType);
          else
            this.handleDynamicSend$4(node, setterSelector, receiverType, $arguments);
        }
      else if (O.Elements_isLocal(element))
        this.locals.update$3(element, rhsType, node);
      return rhsType;
    },
    visitSuperSend$1: function(node) {
      var element, t1, t2, $arguments, selector;
      this.elements.toString;
      element = node.get$_secret_tree_element$_element();
      t1 = node.argumentsNode;
      t2 = t1 == null;
      $arguments = t2 ? null : this.analyzeArguments$1(t1.nodes);
      if (this.visitingInitializers) {
        this.seenSuperConstructorCall = true;
        this.analyzeSuperConstructorCall$2(element, $arguments);
      }
      t1 = this.elements._selectors;
      selector = t1 != null ? t1.$index(0, node) : null;
      t1 = this.analyzedElement;
      if (t1.get$kind(t1) === C.ElementKind_generative_constructor_16)
        this.locals.fieldScope.isThisExposed = true;
      if (element == null || element.get$isErroneous() || !selector.applies$2(element, this.compiler))
        return this.handleDynamicSend$4(node, selector, this.get$superType(), $arguments);
      else if (t2 || element.get$isFunction() || element.get$kind(element) === C.ElementKind_generative_constructor_16)
        return this.handleStaticSend$4(node, selector, element, $arguments);
      else
        return this.get$inferrer().registerCalledClosure$7(node, selector, this.get$inferrer().typeOfElement$1(element), this.outermostElement, $arguments, this.sideEffects, this.loopLevel > 0);
    },
    findLength$1: function(node) {
      var t1, firstArgument, element, $length, constant;
      t1 = node.argumentsNode.nodes;
      firstArgument = t1.get$head(t1);
      this.elements.toString;
      element = firstArgument.get$_secret_tree_element$_element();
      $length = firstArgument.asLiteralInt$0();
      if ($length != null)
        return $length.get$value($length);
      else if (element != null && element.get$kind(element) === C.ElementKind_field_1 && O.Elements_isStaticOrTopLevelField(element) && this.compiler.world.fieldNeverChanges$1(element)) {
        constant = this.compiler.backend.get$constants().getConstantForVariable$1(element);
        if (constant != null && constant.get$isInt())
          return constant.get$value(constant);
      }
      return;
    },
    visitStaticSend$1: function(node) {
      var t1, element, t2, t3, $arguments, t4, t5, selector, returnType, $length, elementType, $constructor;
      t1 = {};
      this.elements.toString;
      element = node.get$_secret_tree_element$_element();
      t2 = this.elements._asserts;
      if (t2 != null && t2.contains$1(0, node) === true)
        element = this.compiler.backend.get$assertMethod();
      t2 = node.argumentsNode;
      t3 = t2.nodes;
      $arguments = this.analyzeArguments$1(t3);
      if (this.visitingInitializers)
        if (Y.Initializers_isConstructorRedirect(node))
          this.isConstructorRedirect = true;
        else if (Y.Initializers_isSuperConstructorCall(node)) {
          this.seenSuperConstructorCall = true;
          this.analyzeSuperConstructorCall$2(element, $arguments);
        }
      t4 = this.compiler;
      if (element.isForeign$1(t4))
        return this.handleForeignSend$1(node);
      t5 = this.elements._selectors;
      selector = t5 != null ? t5.$index(0, node) : null;
      if (!selector.applies$2(element, t4))
        return this.types.get$dynamicType();
      returnType = this.handleStaticSend$4(node, selector, element, $arguments);
      if (element === t4.get$unnamedListConstructor())
        t2 = !J.getInterceptor(node.selector).$isOperator && t2 != null && t3.get$isEmpty(t3);
      else
        t2 = false;
      if (t2)
        return this.get$inferrer().concreteTypes.putIfAbsent$2(node, new Q.SimpleTypeInferrerVisitor_visitStaticSend_closure(this, node));
      else if (O.Elements_isFixedListConstructorCall(element, node, t4) || O.Elements_isFilledListConstructorCall(element, node, t4)) {
        $length = this.findLength$1(node);
        if (O.Elements_isFixedListConstructorCall(element, node, t4))
          elementType = this.types.get$nullType();
        else {
          t1 = $arguments.positional;
          if (1 >= t1.length)
            return H.ioore(t1, 1);
          elementType = t1[1];
        }
        return this.get$inferrer().concreteTypes.putIfAbsent$2(node, new Q.SimpleTypeInferrerVisitor_visitStaticSend_closure0(this, node, $length, elementType));
      } else if (O.Elements_isConstructorOfTypedArraySubclass(element, t4)) {
        $length = this.findLength$1(node);
        $constructor = element.get$implementation(element);
        t1.constructor_0 = $constructor;
        t1.constructor_0 = $constructor.get$effectiveTarget();
        elementType = this.get$inferrer().returnTypeOfElement$1(t1.constructor_0.get$enclosingClass().lookupMember$1("[]"));
        return this.get$inferrer().concreteTypes.putIfAbsent$2(node, new Q.SimpleTypeInferrerVisitor_visitStaticSend_closure1(t1, this, node, $length, elementType));
      } else if (element.get$isFunction() || element.kind === C.ElementKind_generative_constructor_16 || element.get$isFactoryConstructor())
        return returnType;
      else
        return this.get$inferrer().registerCalledClosure$7(node, selector, this.get$inferrer().typeOfElement$1(element), this.outermostElement, $arguments, this.sideEffects, this.loopLevel > 0);
    },
    handleForeignSend$1: function(node) {
      var $arguments, t1, selector, $name, nativeBehavior, t2;
      $arguments = this.analyzeArguments$1(node.argumentsNode.nodes);
      t1 = this.elements._selectors;
      selector = t1 != null ? t1.$index(0, node) : null;
      $name = J.get$name$x(selector);
      this.elements.toString;
      this.handleStaticSend$4(node, selector, node.get$_secret_tree_element$_element(), $arguments);
      if ($name === "JS") {
        nativeBehavior = this.compiler.enqueuer.resolution.nativeEnqueuer.getNativeBehaviorOf$1(node);
        t1 = this.sideEffects;
        t2 = nativeBehavior.sideEffects;
        t1.flags = (t1.flags | t2.flags) >>> 0;
        return this.get$inferrer().typeOfNativeBehavior$1(nativeBehavior);
      } else {
        t1 = $name === "JS_GET_NAME" || $name === "JS_NULL_CLASS_NAME" || $name === "JS_OBJECT_CLASS_NAME" || $name === "JS_OPERATOR_IS_PREFIX" || $name === "JS_OPERATOR_AS_PREFIX" || $name === "JS_STRING_CONCAT";
        t2 = this.types;
        if (t1)
          return t2.get$stringType();
        else {
          t1 = this.sideEffects;
          t1.flags = (t1.flags | 7) >>> 0;
          return t2.get$dynamicType();
        }
      }
    },
    analyzeArguments$1: function($arguments) {
      var positional, t1, t2, named, argument, namedArgument, t3;
      positional = [];
      for ($arguments.toString, t1 = H.setRuntimeTypeInfo(new E.LinkIterator(null, $arguments), [H.getTypeArgumentByIndex($arguments, 0)]), t2 = this.analyzedElement, named = null; t1.moveNext$0();) {
        argument = t1._util_implementation$_current;
        namedArgument = argument.asNamedArgument$0();
        if (namedArgument != null) {
          argument = namedArgument.expression;
          if (named == null)
            named = P.LinkedHashMap_LinkedHashMap(null, null, null, P.String, H.getRuntimeTypeArgument(this, "SimpleTypeInferrerVisitor", 0));
          t3 = namedArgument.name.token;
          named.$indexSet(0, t3.get$value(t3), argument.accept$1(0, this));
        } else
          positional.push(argument.accept$1(0, this));
        t3 = t2.get$kind(t2) !== C.ElementKind_generative_constructor_16 || this.locals.fieldScope.isThisExposed || argument.isThis$0();
        if (t2.kind === C.ElementKind_generative_constructor_16)
          this.locals.fieldScope.isThisExposed = t3;
      }
      return X.ArgumentsTypes$(positional, named, H.getRuntimeTypeArgument(this, "SimpleTypeInferrerVisitor", 0));
    },
    visitGetterSend$1: function(node) {
      var element, t1, selector;
      this.elements.toString;
      element = node.get$_secret_tree_element$_element();
      t1 = this.elements._selectors;
      selector = t1 != null ? t1.$index(0, node) : null;
      if (O.Elements_isStaticOrTopLevelField(element))
        return this.handleStaticSend$4(node, selector, element, null);
      else if (O.Elements_isInstanceSend(node, this.elements))
        return this.visitDynamicSend$1(node);
      else if (O.Elements_isStaticOrTopLevelFunction(element))
        return this.handleStaticSend$4(node, selector, element, null);
      else if (element != null && element.get$isErroneous())
        return this.types.get$dynamicType();
      else if (O.Elements_isLocal(element))
        return this.locals.use$1(element);
      else
        return;
    },
    visitClosureSend$1: function(node) {
      var closure, $arguments, element, t1, selector, t2;
      closure = node.selector.accept$1(0, this);
      $arguments = this.analyzeArguments$1(node.argumentsNode.nodes);
      this.elements.toString;
      element = node.get$_secret_tree_element$_element();
      t1 = this.elements._selectors;
      selector = t1 != null ? t1.$index(0, node) : null;
      t1 = element != null && element.get$isFunction();
      t2 = this.outermostElement;
      if (t1)
        return this.get$inferrer().registerCalledElement$7(node, selector, t2, element, $arguments, this.sideEffects, this.loopLevel > 0);
      else
        return this.get$inferrer().registerCalledClosure$7(node, selector, closure, t2, $arguments, this.sideEffects, this.loopLevel > 0);
    },
    handleStaticSend$4: function(node, selector, element, $arguments) {
      if (element == null || element.get$isErroneous())
        return this.types.get$dynamicType();
      return this.get$inferrer().registerCalledElement$7(node, selector, this.outermostElement, element, $arguments, this.sideEffects, this.loopLevel > 0);
    },
    handleDynamicSend$4: function(node, selector, receiverType, $arguments) {
      var t1, receiver, element, refinedType;
      if (!J.$eq(selector.get$mask(), receiverType)) {
        t1 = this.types;
        selector = J.$eq(receiverType, t1.get$dynamicType()) ? selector.get$asUntyped() : t1.newTypedSelector$2(receiverType, selector);
        this.get$inferrer().updateSelectorInTree$3(this.analyzedElement, node, selector);
      }
      if (node.asSend$0() != null) {
        receiver = node.asSend$0().receiver;
        if (receiver != null) {
          this.elements.toString;
          element = receiver.get$_secret_tree_element$_element();
          if (O.Elements_isLocal(element) && this.capturedVariables.contains$1(0, element) !== true) {
            refinedType = this.types.refineReceiver$2(selector, receiverType);
            this.locals.update$3(element, refinedType, node);
          }
        }
      }
      return this.get$inferrer().registerCalledSelector$7(node, selector, receiverType, this.outermostElement, $arguments, this.sideEffects, this.loopLevel > 0);
    },
    visitDynamicSend$1: function(node) {
      var element, t1, receiverType, isCallOnThis, t2, selector, $arguments, t3;
      this.elements.toString;
      element = node.get$_secret_tree_element$_element();
      t1 = node.receiver;
      if (t1 == null)
        if (this.treatAsInstanceMember$1(element)) {
          receiverType = this.get$thisType();
          isCallOnThis = true;
        } else {
          receiverType = null;
          isCallOnThis = false;
        }
      else {
        isCallOnThis = t1.isThis$0() || t1.isSuper$0();
        receiverType = t1.accept$1(0, this);
      }
      t2 = this.elements._selectors;
      selector = t2 != null ? t2.$index(0, node) : null;
      t2 = this.analyzedElement;
      if (!(t2.get$kind(t2) !== C.ElementKind_generative_constructor_16 || this.locals.fieldScope.isThisExposed) && isCallOnThis)
        this.checkIfExposesThis$1(this.types.newTypedSelector$2(receiverType, selector));
      t2 = node.argumentsNode;
      $arguments = t2 == null ? null : this.analyzeArguments$1(t2.nodes);
      t3 = J.getInterceptor$x(selector);
      if (t3.get$name(selector) === "==" || t3.get$name(selector) === "!=") {
        t3 = this.types;
        if (t3.isNull$1(receiverType)) {
          t1 = t2.nodes;
          this.potentiallyAddNullCheck$2(node, t1.get$head(t1));
          return t3.get$boolType();
        } else {
          t2 = $arguments.positional;
          if (0 >= t2.length)
            return H.ioore(t2, 0);
          if (t3.isNull$1(t2[0])) {
            this.potentiallyAddNullCheck$2(node, t1);
            return t3.get$boolType();
          }
        }
      }
      return this.handleDynamicSend$4(node, selector, receiverType, $arguments);
    },
    synthesizeForwardingCall$2: function(node, element) {
      var t1, signature, unnamed, $arguments;
      t1 = {};
      element = element.get$implementation(element);
      signature = this.analyzedElement.get$functionSignature();
      if (!element.get$functionSignature().isCompatibleWith$1(signature))
        return this.types.nonNullEmpty$0();
      unnamed = H.setRuntimeTypeInfo([], [H.getRuntimeTypeArgument(this, "SimpleTypeInferrerVisitor", 0)]);
      signature.forEachRequiredParameter$1(new Q.SimpleTypeInferrerVisitor_synthesizeForwardingCall_closure(this, unnamed));
      t1.named_0 = null;
      if (signature.optionalParametersAreNamed) {
        t1.named_0 = P.LinkedHashMap_LinkedHashMap(null, null, null, P.String, H.getRuntimeTypeArgument(this, "SimpleTypeInferrerVisitor", 0));
        signature.forEachOptionalParameter$1(new Q.SimpleTypeInferrerVisitor_synthesizeForwardingCall_closure0(t1, this));
      } else
        signature.forEachOptionalParameter$1(new Q.SimpleTypeInferrerVisitor_synthesizeForwardingCall_closure1(this, unnamed));
      $arguments = X.ArgumentsTypes$(unnamed, t1.named_0, H.getRuntimeTypeArgument(this, "SimpleTypeInferrerVisitor", 0));
      return this.get$inferrer().registerCalledElement$7(node, null, this.outermostElement, element, $arguments, this.sideEffects, this.loopLevel > 0);
    },
    visitRedirectingFactoryBody$1: function(node) {
      var element, t1, t2, mask;
      this.elements.toString;
      element = node.get$_secret_tree_element$_element();
      t1 = element != null && element.get$isErroneous();
      t2 = this.analyzedElement;
      if (t1) {
        t1 = this.types.get$dynamicType();
        this.returnType = this.get$inferrer().addReturnTypeFor$3(t2, this.returnType, t1);
      } else {
        mask = this.synthesizeForwardingCall$2(node.constructorReference, element);
        this.returnType = this.get$inferrer().addReturnTypeFor$3(t2, this.returnType, mask);
      }
      this.locals.seenReturnOrThrow = true;
      return;
    },
    visitReturn$1: function(node) {
      var expression, t1;
      expression = node.get$expression();
      t1 = expression == null ? this.types.get$nullType() : expression.accept$1(0, this);
      this.returnType = this.get$inferrer().addReturnTypeFor$3(this.analyzedElement, this.returnType, t1);
      this.locals.seenReturnOrThrow = true;
      return;
    },
    visitForIn$1: function(node) {
      var t1, expressionType, t2, iteratorSelector, currentSelector, moveNextSelector, iteratorType, currentType, identifier, element, selector;
      t1 = node.expression;
      expressionType = t1 == null ? null : t1.accept$1(0, this);
      t2 = this.elements._selectors;
      iteratorSelector = t2 != null ? t2.$index(0, node) : null;
      t2 = this.elements._selectors;
      currentSelector = t2 != null ? t2.$index(0, node.inToken) : null;
      t2 = this.elements._selectors;
      moveNextSelector = t2 != null ? t2.$index(0, node.forToken) : null;
      iteratorType = this.handleDynamicSend$4(node, iteratorSelector, expressionType, null);
      this.handleDynamicSend$4(node, moveNextSelector, iteratorType, X.ArgumentsTypes$([], null, H.getRuntimeTypeArgument(this, "SimpleTypeInferrerVisitor", 0)));
      currentType = this.handleDynamicSend$4(node, currentSelector, iteratorType, null);
      if (t1.isThis$0()) {
        t2 = this.analyzedElement;
        if (t2.get$kind(t2) === C.ElementKind_generative_constructor_16)
          this.locals.fieldScope.isThisExposed = true;
      }
      identifier = node.declaredIdentifier;
      this.elements.toString;
      element = node.get$_secret_tree_element$_element();
      t2 = this.elements._selectors;
      selector = t2 != null ? t2.$index(0, identifier) : null;
      this.handlePlainAssignment$6(identifier, element, selector, element != null && element.get$isInstanceMember() ? this.get$thisType() : this.types.get$dynamicType(), currentType, t1);
      return this.handleLoop$2(node, new Q.SimpleTypeInferrerVisitor_visitForIn_closure(this, node));
    },
    SimpleTypeInferrerVisitor$internal$5: function(analyzedElement, outermostElement, inferrer, compiler, locals, $T) {
    },
    $asInferrerVisitor: function($T) {
      return [$T, [Q.InferrerEngine, $T, [X.TypeSystem, $T]]];
    },
    $asResolvedVisitor: null,
    $asVisitor: null
  },
  SimpleTypeInferrerVisitor_run_closure: {
    "^": "Closure:19;this_1",
    call$2: function(variable, field) {
      this.this_1.locals.captured.$indexSet(0, variable, field);
    },
    $isFunction: true
  },
  SimpleTypeInferrerVisitor_run_closure0: {
    "^": "Closure:19;this_2",
    call$2: function(variable, field) {
      this.this_2.locals.capturedAndBoxed.$indexSet(0, variable, field);
    },
    $isFunction: true
  },
  SimpleTypeInferrerVisitor_run_closure1: {
    "^": "Closure:50;this_3",
    call$1: function(element) {
      var defaultValue, t1, type;
      defaultValue = element.get$initializer();
      t1 = this.this_3;
      if (defaultValue == null)
        type = t1.types.get$nullType();
      else
        type = defaultValue.accept$1(0, t1);
      t1.get$inferrer().setDefaultTypeOfParameter$2(element, type);
    },
    $isFunction: true
  },
  SimpleTypeInferrerVisitor_run_closure2: {
    "^": "Closure:50;box_0,this_4",
    call$1: function(element) {
      var t1, parameterType, t2, t3;
      t1 = this.this_4;
      parameterType = t1.get$inferrer().typeOfElement$1(element);
      if (J.get$kind$x(element) === C.ElementKind_initializing_formal_1) {
        t2 = element.get$fieldElement().get$isFinal();
        t3 = element.fieldElement;
        if (t2)
          t1.get$inferrer().recordTypeOfFinalField$4(this.box_0.node_0, t1.analyzedElement, t3, parameterType);
        else {
          t1.locals.fieldScope.updateField$2(t3, parameterType);
          t1.get$inferrer().recordTypeOfNonFinalField$3(element.definitions, t3, parameterType);
        }
      }
      t1.locals.update$3(element, parameterType, this.box_0.node_0);
    },
    $isFunction: true
  },
  SimpleTypeInferrerVisitor_run_closure3: {
    "^": "Closure:252;box_0,this_5",
    call$2: function(_, field) {
      var t1, t2;
      if ((field.get$modifiers().flags & 4) !== 0)
        return;
      t1 = this.this_5;
      t2 = t1.locals.fieldScope.fields;
      if ((t2 == null ? null : t2.$index(0, field)) == null && field.get$initializer() == null)
        t1.get$inferrer().recordTypeOfNonFinalField$3(this.box_0.node_0, field, t1.types.get$nullType());
    },
    $isFunction: true
  },
  SimpleTypeInferrerVisitor_run_closure4: {
    "^": "Closure:13;box_0,this_6",
    call$1: function(element) {
      var t1 = this.this_6;
      t1.locals.update$3(element, t1.get$inferrer().typeOfElement$1(element), this.box_0.node_0);
    },
    $isFunction: true
  },
  SimpleTypeInferrerVisitor_visitFunctionExpression_closure: {
    "^": "Closure:19;this_0,nestedClosureData_1",
    call$2: function(variable, field) {
      var t1 = this.nestedClosureData_1;
      if (!t1.isVariableBoxed$1(variable)) {
        if (J.$eq(variable, t1.thisLocal)) {
          t1 = this.this_0;
          t1.get$inferrer().recordType$2(field, t1.get$thisType());
        }
        t1 = this.this_0;
        if (t1.locals.locals.$index(0, variable) == null)
          return;
        t1.get$inferrer().recordType$2(field, t1.locals.locals.$index(0, variable));
      }
      this.this_0.capturedVariables.add$1(0, variable);
    },
    $isFunction: true
  },
  SimpleTypeInferrerVisitor_visitFunctionExpression_closure0: {
    "^": "Closure:23;this_2,node_3,element_4",
    call$0: function() {
      return this.this_2.types.allocateClosure$2(this.node_3, this.element_4);
    },
    $isFunction: true
  },
  SimpleTypeInferrerVisitor_visitFunctionDeclaration_closure: {
    "^": "Closure:23;this_0,node_1,element_2",
    call$0: function() {
      return this.this_0.types.allocateClosure$2(this.node_1.$function, this.element_2);
    },
    $isFunction: true
  },
  SimpleTypeInferrerVisitor_visitLiteralList_closure: {
    "^": "Closure:23;this_0,node_1",
    call$0: function() {
      var t1, t2, t3, t4, elementType, $length, element, type, containerType;
      for (t1 = this.node_1, t2 = t1.elements.nodes, t2.toString, t2 = H.setRuntimeTypeInfo(new E.LinkIterator(null, t2), [H.getTypeArgumentByIndex(t2, 0)]), t3 = this.this_0, t4 = t3.types, elementType = null, $length = 0; t2.moveNext$0();) {
        element = t2._util_implementation$_current;
        type = element == null ? null : J.accept$1$x(element, t3);
        elementType = elementType == null ? t4.allocatePhi$3(null, null, type) : t4.addPhiInput$3(null, elementType, type);
        ++$length;
      }
      elementType = elementType == null ? t4.nonNullEmpty$0() : t4.simplifyPhi$3(null, null, elementType);
      containerType = t1.constKeyword != null ? t4.get$constListType() : t4.get$growableListType();
      return t4.allocateList$5(containerType, t1, t3.outermostElement, elementType, $length);
    },
    $isFunction: true
  },
  SimpleTypeInferrerVisitor_visitLiteralMap_closure: {
    "^": "Closure:23;this_0,node_1",
    call$0: function() {
      var t1, keyTypes, valueTypes, t2, t3, entry, t4, t5, type;
      t1 = this.node_1;
      keyTypes = [];
      valueTypes = [];
      for (t2 = t1.entries.nodes, t2.toString, t2 = H.setRuntimeTypeInfo(new E.LinkIterator(null, t2), [H.getTypeArgumentByIndex(t2, 0)]), t3 = this.this_0; t2.moveNext$0();) {
        entry = t2._util_implementation$_current;
        t4 = J.getInterceptor$x(entry);
        t5 = t4.get$key(entry);
        keyTypes.push(t5 == null ? null : t5.accept$1(0, t3));
        t4 = t4.get$value(entry);
        valueTypes.push(t4 == null ? null : t4.accept$1(0, t3));
      }
      t2 = t3.types;
      type = t1.constKeyword != null ? t2.get$constMapType() : t2.get$mapType();
      return t2.allocateMap$5(type, t1, t3.outermostElement, keyTypes, valueTypes);
    },
    $isFunction: true
  },
  SimpleTypeInferrerVisitor_checkIfExposesThis_closure: {
    "^": "Closure:13;this_0,selector_1",
    call$1: function(element) {
      var t1, cls, enclosing, subclasses, t2;
      if (element.get$isField()) {
        if (this.selector_1.kind !== C.SelectorKind_setter_1) {
          t1 = this.this_0;
          cls = t1.outermostElement.get$enclosingClass();
          enclosing = element.get$enclosingClass();
          if (enclosing == null ? cls != null : enclosing !== cls) {
            subclasses = t1.compiler.world._subclasses.$index(0, cls.get$declaration());
            t2 = subclasses != null && J.contains$1$asx(subclasses, enclosing.get$declaration()) === true;
          } else
            t2 = true;
          if (t2)
            if ((element.get$modifiers().flags & 4) === 0) {
              t1 = t1.locals.fieldScope.fields;
              t1 = (t1 == null ? null : t1.$index(0, element)) == null && element.get$initializer() == null;
            } else
              t1 = false;
          else
            t1 = false;
        } else
          t1 = false;
        if (t1) {
          t1 = this.this_0;
          t1.get$inferrer().recordTypeOfNonFinalField$3(t1.analyzedElement.get$node(), element, t1.types.get$nullType());
        }
        return true;
      }
      t1 = this.this_0;
      t2 = t1.analyzedElement;
      if (t2.get$kind(t2) === C.ElementKind_generative_constructor_16)
        t1.locals.fieldScope.isThisExposed = true;
      return false;
    },
    $isFunction: true
  },
  SimpleTypeInferrerVisitor_visitStaticSend_closure: {
    "^": "Closure:23;this_1,node_2",
    call$0: function() {
      var t1, t2;
      t1 = this.this_1;
      t2 = t1.types;
      return t2.allocateList$5(t2.get$growableListType(), this.node_2, t1.outermostElement, t2.nonNullEmpty$0(), 0);
    },
    $isFunction: true
  },
  SimpleTypeInferrerVisitor_visitStaticSend_closure0: {
    "^": "Closure:23;this_3,node_4,length_5,elementType_6",
    call$0: function() {
      var t1, t2;
      t1 = this.this_3;
      t2 = t1.types;
      return t2.allocateList$5(t2.get$fixedListType(), this.node_4, t1.outermostElement, this.elementType_6, this.length_5);
    },
    $isFunction: true
  },
  SimpleTypeInferrerVisitor_visitStaticSend_closure1: {
    "^": "Closure:23;box_0,this_7,node_8,length_9,elementType_10",
    call$0: function() {
      var t1, t2;
      t1 = this.this_7;
      t2 = t1.types;
      return t2.allocateList$5(t2.nonNullExact$1(this.box_0.constructor_0.get$enclosingClass()), this.node_8, t1.outermostElement, this.elementType_10, this.length_9);
    },
    $isFunction: true
  },
  SimpleTypeInferrerVisitor_synthesizeForwardingCall_closure: {
    "^": "Closure:50;this_1,unnamed_2",
    call$1: function(element) {
      this.unnamed_2.push(this.this_1.locals.use$1(element));
    },
    $isFunction: true
  },
  SimpleTypeInferrerVisitor_synthesizeForwardingCall_closure0: {
    "^": "Closure:50;box_0,this_3",
    call$1: function(element) {
      this.box_0.named_0.$indexSet(0, J.get$name$x(element), this.this_3.locals.use$1(element));
    },
    $isFunction: true
  },
  SimpleTypeInferrerVisitor_synthesizeForwardingCall_closure1: {
    "^": "Closure:50;this_4,unnamed_5",
    call$1: function(element) {
      this.unnamed_5.push(this.this_4.locals.use$1(element));
    },
    $isFunction: true
  },
  SimpleTypeInferrerVisitor_visitForIn_closure: {
    "^": "Closure:23;this_0,node_1",
    call$0: function() {
      var t1 = this.node_1.body;
      if (t1 == null)
        ;
      else
        t1.accept$1(0, this.this_0);
    },
    $isFunction: true
  }
}],
["source_file", "package:compiler/implementation/source_file.dart", , A, {
  "^": "",
  SourceFile: {
    "^": "Object;",
    get$lineStarts: function() {
      var t1 = this.lineStartsCache;
      if (t1 == null) {
        t1 = this.lineStartsFromString$1(this.slowText$0());
        this.lineStartsCache = t1;
      }
      return t1;
    },
    lineStartsFromString$1: function(text) {
      var starts, t1, index;
      starts = [0];
      for (t1 = text.length, index = 0; index < t1;) {
        index = C.JSString_methods.indexOf$2(text, "\n", index) + 1;
        if (index <= 0)
          break;
        starts.push(index);
      }
      starts.push(t1 + 1);
      return starts;
    },
    getLine$1: function(position) {
      var starts, count, count0, first, step, middle;
      starts = this.get$lineStarts();
      if (position < 0 || J.get$last$ax(starts) <= position)
        throw H.wrapException("bad position #" + position + " in file " + H.S(this.filename) + " with length " + this.get$length(this) + ".");
      count = starts.length;
      for (count0 = count, first = 0; count0 > 1;) {
        step = C.JSInt_methods._tdivFast$1(count0, 2);
        middle = first + step;
        if (middle < 0 || middle >= count)
          return H.ioore(starts, middle);
        if (position < starts[middle])
          count0 = step;
        else {
          count0 -= step;
          first = middle;
        }
      }
      return first;
    }
  },
  Utf8BytesSourceFile: {
    "^": "SourceFile;content,lengthCache,filename,lineStartsCache",
    slowText$0: function() {
      return C.Utf8Codec_false.decode$1(this.content);
    },
    get$length: function(_) {
      var t1 = this.lengthCache;
      if (t1 === -1) {
        t1 = C.Utf8Codec_false.decode$1(this.content).length;
        this.lengthCache = t1;
      }
      return t1;
    },
    set$length: function(_, v) {
      this.lengthCache = v;
      return v;
    },
    $isUtf8BytesSourceFile: true
  },
  StringSourceFile: {
    "^": "SourceFile;text>,filename,lineStartsCache",
    get$length: function(_) {
      return this.text.length;
    },
    set$length: function(_, v) {
    },
    slowText$0: function() {
      return this.text;
    }
  }
}],
["source_map_builder", "package:compiler/implementation/source_map_builder.dart", , T, {
  "^": "",
  SourceMapBuilder: {
    "^": "Object;uri<,fileUri,targetFile,entries,sourceUrlMap,sourceUrlList,sourceNameMap,sourceNameList,previousTargetLine,previousTargetColumn,previousSourceUrlIndex,previousSourceLine,previousSourceColumn,previousSourceNameIndex,firstEntryInLine",
    updatePreviousSourceLocation$1: function(sourceLocation) {
      var t1, t2, t3, t4, sourceUrl, sourceName;
      this.previousSourceLine = sourceLocation.getLine$0();
      t1 = sourceLocation.sourceFile;
      t2 = sourceLocation.getLine$0();
      t3 = sourceLocation.get$offset(sourceLocation);
      t4 = t1.get$lineStarts();
      if (t2 >>> 0 !== t2 || t2 >= t4.length)
        return H.ioore(t4, t2);
      this.previousSourceColumn = t3 - t4[t2];
      sourceUrl = t1.filename;
      this.previousSourceUrlIndex = this.indexOf$3(0, this.sourceUrlList, sourceUrl, this.sourceUrlMap);
      sourceName = sourceLocation.name;
      if (sourceName != null)
        this.previousSourceNameIndex = this.indexOf$3(0, this.sourceNameList, sourceName, this.sourceNameMap);
    },
    sameAsPreviousLocation$1: function(sourceLocation) {
      var t1, t2, sourceUrlIndex, t3;
      if (sourceLocation == null)
        return true;
      t1 = this.sourceUrlList;
      t2 = sourceLocation.sourceFile;
      sourceUrlIndex = this.indexOf$3(0, t1, t2.filename, this.sourceUrlMap);
      t1 = this.previousSourceUrlIndex;
      if (sourceUrlIndex == null ? t1 == null : sourceUrlIndex === t1) {
        t1 = sourceLocation.getLine$0();
        t3 = this.previousSourceLine;
        if (t1 == null ? t3 == null : t1 === t3) {
          t1 = sourceLocation.getLine$0();
          t3 = sourceLocation.get$offset(sourceLocation);
          t2 = t2.get$lineStarts();
          if (t1 >>> 0 !== t1 || t1 >= t2.length)
            return H.ioore(t2, t1);
          t1 = t3 - t2[t1] === this.previousSourceColumn;
        } else
          t1 = false;
      } else
        t1 = false;
      return t1;
    },
    addMapping$2: [function(targetOffset, sourceLocation) {
      var t1 = this.entries;
      if (t1.length !== 0 && new T.SourceMapBuilder_addMapping_sameLine(this).call$2(targetOffset, C.JSArray_methods.get$last(t1).targetOffset) === true)
        if (this.sameAsPreviousLocation$1(sourceLocation))
          return;
      if (sourceLocation != null)
        this.updatePreviousSourceLocation$1(sourceLocation);
      this.entries.push(new T.SourceMapEntry(sourceLocation, targetOffset));
    }, "call$2", "get$addMapping", 4, 0, 253],
    printStringListOn$2: function(strings, buffer) {
      var t1, first, string;
      buffer.write$1("[");
      for (t1 = H.setRuntimeTypeInfo(new H.ListIterator(strings, strings.length, 0, null), [H.getTypeArgumentByIndex(strings, 0)]), first = true; t1.moveNext$0(); first = false) {
        string = t1.__internal$_current;
        if (!first)
          buffer._contents += ",";
        buffer._contents += "\"";
        O.writeJsonEscapedCharsOn(string, buffer);
        buffer._contents += "\"";
      }
      buffer.write$1("]");
    },
    build$0: function() {
      var mappingsBuffer, buffer, t1, t2;
      this.previousSourceUrlIndex = 0;
      this.previousSourceLine = 0;
      this.previousSourceColumn = 0;
      this.previousSourceNameIndex = 0;
      mappingsBuffer = P.StringBuffer$("");
      H.IterableMixinWorkaround_forEach(this.entries, new T.SourceMapBuilder_build_closure(this, mappingsBuffer));
      buffer = P.StringBuffer$("");
      buffer.write$1("{\n");
      buffer.write$1("  \"version\": 3,\n");
      t1 = this.uri;
      t2 = t1 != null;
      if (t2 && this.fileUri != null)
        buffer.write$1("  \"file\": \"" + X.relativize(t1, this.fileUri, false) + "\",\n");
      buffer.write$1("  \"sourceRoot\": \"\",\n");
      buffer.write$1("  \"sources\": ");
      if (t2)
        this.sourceUrlList = H.setRuntimeTypeInfo(new H.MappedListIterable(this.sourceUrlList, new T.SourceMapBuilder_build_closure0(this)), [null, null]).toList$0(0);
      this.printStringListOn$2(this.sourceUrlList, buffer);
      buffer.write$1(",\n");
      buffer.write$1("  \"names\": ");
      this.printStringListOn$2(this.sourceNameList, buffer);
      buffer.write$1(",\n");
      buffer.write$1("  \"mappings\": \"");
      buffer.write$1(mappingsBuffer);
      buffer.write$1("\"\n}\n");
      return buffer._contents;
    },
    writeEntry$3: function(entry, targetFile, output) {
      var t1, targetLine, t2, targetColumn, i, sourceUrl, sourceLine, t3, t4, sourceName, sourceUrlIndex, sourceNameIndex;
      t1 = entry.targetOffset;
      targetLine = targetFile.getLine$1(t1);
      t2 = targetFile.get$lineStarts();
      if (targetLine < 0 || targetLine >= t2.length)
        return H.ioore(t2, targetLine);
      targetColumn = t1 - t2[targetLine];
      i = this.previousTargetLine;
      if (targetLine > i) {
        for (; i < targetLine; ++i)
          output._contents += ";";
        this.previousTargetLine = targetLine;
        this.previousTargetColumn = 0;
        this.firstEntryInLine = true;
      }
      if (!this.firstEntryInLine)
        output.write$1(",");
      this.firstEntryInLine = false;
      T.SourceMapBuilder_encodeVLQ(output, targetColumn - this.previousTargetColumn);
      this.previousTargetColumn = targetColumn;
      t1 = entry.sourceLocation;
      if (t1 == null)
        return;
      t2 = t1.sourceFile;
      sourceUrl = t2.filename;
      sourceLine = t1.getLine$0();
      t3 = t1.getLine$0();
      t4 = t1.get$offset(t1);
      t2 = t2.get$lineStarts();
      if (t3 >>> 0 !== t3 || t3 >= t2.length)
        return H.ioore(t2, t3);
      t3 = t2[t3];
      sourceName = t1.name;
      sourceUrlIndex = this.indexOf$3(0, this.sourceUrlList, sourceUrl, this.sourceUrlMap);
      t2 = this.previousSourceUrlIndex;
      if (typeof sourceUrlIndex !== "number")
        return sourceUrlIndex.$sub();
      if (typeof t2 !== "number")
        return H.iae(t2);
      T.SourceMapBuilder_encodeVLQ(output, sourceUrlIndex - t2);
      t2 = this.previousSourceLine;
      if (typeof sourceLine !== "number")
        return sourceLine.$sub();
      if (typeof t2 !== "number")
        return H.iae(t2);
      T.SourceMapBuilder_encodeVLQ(output, sourceLine - t2);
      T.SourceMapBuilder_encodeVLQ(output, t4 - t3 - this.previousSourceColumn);
      if (sourceName != null) {
        sourceNameIndex = this.indexOf$3(0, this.sourceNameList, sourceName, this.sourceNameMap);
        t2 = this.previousSourceNameIndex;
        if (typeof sourceNameIndex !== "number")
          return sourceNameIndex.$sub();
        if (typeof t2 !== "number")
          return H.iae(t2);
        T.SourceMapBuilder_encodeVLQ(output, sourceNameIndex - t2);
      }
      this.updatePreviousSourceLocation$1(t1);
    },
    indexOf$3: function(_, list, value, map) {
      return map.putIfAbsent$2(value, new T.SourceMapBuilder_indexOf_closure(list, value));
    },
    SourceMapBuilder$3: function(uri, fileUri, targetFile) {
      this.entries = H.setRuntimeTypeInfo([], [T.SourceMapEntry]);
      this.sourceUrlMap = P.LinkedHashMap_LinkedHashMap(null, null, null, P.String, P.$int);
      this.sourceUrlList = H.setRuntimeTypeInfo([], [P.String]);
      this.sourceNameMap = P.LinkedHashMap_LinkedHashMap(null, null, null, P.String, P.$int);
      this.sourceNameList = H.setRuntimeTypeInfo([], [P.String]);
      this.previousTargetLine = 0;
      this.previousTargetColumn = 0;
      this.previousSourceUrlIndex = 0;
      this.previousSourceLine = 0;
      this.previousSourceColumn = 0;
      this.previousSourceNameIndex = 0;
      this.firstEntryInLine = true;
    },
    static: {"^": "SourceMapBuilder_VLQ_BASE_SHIFT,SourceMapBuilder_VLQ_BASE_MASK,SourceMapBuilder_VLQ_CONTINUATION_BIT,SourceMapBuilder_VLQ_CONTINUATION_MASK,SourceMapBuilder_BASE64_DIGITS", SourceMapBuilder_encodeVLQ: function(output, value) {
        var signBit, digit, t1, t2;
        if (value < 0) {
          value = -value;
          signBit = 1;
        } else
          signBit = 0;
        value = value << 1 | signBit;
        do {
          digit = value & 31;
          value = value >>> 5;
          t1 = value > 0;
          if (t1)
            digit = (digit | 32) >>> 0;
          if (digit >= 64)
            return H.ioore("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", digit);
          t2 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"[digit];
          output._contents += t2;
        } while (t1);
      }}
  },
  SourceMapBuilder_addMapping_sameLine: {
    "^": "Closure:254;this_0",
    call$2: function(position, otherPosition) {
      var t1 = this.this_0.targetFile;
      return t1.getLine$1(position) === t1.getLine$1(otherPosition);
    },
    $isFunction: true
  },
  SourceMapBuilder_build_closure: {
    "^": "Closure:255;this_0,mappingsBuffer_1",
    call$1: function(entry) {
      var t1 = this.this_0;
      return t1.writeEntry$3(entry, t1.targetFile, this.mappingsBuffer_1);
    },
    $isFunction: true
  },
  SourceMapBuilder_build_closure0: {
    "^": "Closure:13;this_2",
    call$1: function(url) {
      return X.relativize(this.this_2.uri, P.Uri_parse(url), false);
    },
    $isFunction: true
  },
  SourceMapBuilder_indexOf_closure: {
    "^": "Closure:23;list_0,value_1",
    call$0: function() {
      var t1, index;
      t1 = this.list_0;
      index = t1.length;
      C.JSArray_methods.add$1(t1, this.value_1);
      return index;
    },
    $isFunction: true
  },
  SourceMapEntry: {
    "^": "Object;sourceLocation,targetOffset"
  },
  SourceFileLocation: {
    "^": "Object;",
    getLine$0: function() {
      var t1 = this.line;
      if (t1 == null) {
        t1 = this.sourceFile.getLine$1(this.get$offset(this));
        this.line = t1;
      }
      return t1;
    }
  },
  TokenSourceFileLocation: {
    "^": "SourceFileLocation;token<,name>,sourceFile,line",
    get$offset: function(_) {
      return this.token.charOffset;
    }
  }
}],
["ssa", "package:compiler/implementation/ssa/ssa.dart", , B, {
  "^": "",
  isFixedLength: function(mask, compiler) {
    var backend, t1, t2;
    backend = compiler.backend;
    if (mask.get$isContainer() && mask.get$length(mask) != null)
      return true;
    else {
      if (!mask.containsOnly$1(backend.get$jsFixedArrayClass()))
        if (!mask.containsOnlyString$1(compiler)) {
          t1 = backend.compiler;
          t2 = t1.typedDataClass;
          t1 = t2 != null && mask.satisfies$2(t2, t1) && mask.satisfies$2(backend.jsIndexingBehaviorInterface, t1);
        } else
          t1 = true;
      else
        t1 = true;
      if (t1)
        return true;
    }
    return false;
  },
  TypeMaskFactory_fromInferredType: function(mask, compiler) {
    var backend = compiler.backend;
    if (mask == null)
      return backend.compiler.typesTask.get$dynamicType();
    return mask;
  },
  TypeMaskFactory_fromNativeBehavior: function(nativeBehavior, compiler) {
    var backend, t1;
    backend = compiler.backend;
    t1 = nativeBehavior.typesReturned;
    if (t1.length === 0)
      return backend.compiler.typesTask.get$dynamicType();
    return H.setRuntimeTypeInfo(new H.MappedListIterable(t1, new B.TypeMaskFactory_fromNativeBehavior_closure(compiler)), [null, null]).reduce$1(0, new B.TypeMaskFactory_fromNativeBehavior_closure0(compiler));
  },
  TypeMaskFactory_fromNativeType: function(type, compiler) {
    var backend, t1, t2;
    backend = compiler.backend;
    if (J.$eq(type, C.SpecialType_MYA))
      return new B.FlatTypeMask(compiler.objectClass, 2);
    else if (type.get$isVoid())
      return backend.compiler.typesTask.get$nullType();
    else {
      t1 = type.get$element();
      t2 = compiler.nullClass;
      if (t1 == null ? t2 == null : t1 === t2)
        return backend.compiler.typesTask.get$nullType();
      else if (type.get$treatAsDynamic())
        return backend.compiler.typesTask.get$dynamicType();
      else if (compiler.world.hasAnySubtype$1(type.get$element()))
        return new B.FlatTypeMask(type.get$element(), 6);
      else if (compiler.world.hasAnySubclass$1(type.get$element()))
        return new B.FlatTypeMask(type.get$element(), 4);
      else
        return new B.FlatTypeMask(type.get$element(), 2);
    }
  },
  SyntheticLocal: {
    "^": "Local;name>,executableContext<"
  },
  SsaBuilderTask: {
    "^": "CompilerTask;emitter,backend<,compiler,watch,profilerTag",
    get$name: function(_) {
      return "SSA builder";
    },
    build$1: function(work) {
      return this.measure$1(new B.SsaBuilderTask_build_closure(this, work));
    }
  },
  SsaBuilderTask_build_closure: {
    "^": "Closure:23;this_0,work_1",
    call$0: function() {
      var t1, t2, element;
      t1 = this.work_1;
      t2 = t1.element;
      element = t2.get$implementation(t2);
      t2 = this.this_0;
      return t2.compiler.withCurrentElement$2(element, new B.SsaBuilderTask_build__closure(t2, t1, element));
    },
    $isFunction: true
  },
  SsaBuilderTask_build__closure: {
    "^": "Closure:23;this_2,work_3,element_4",
    call$0: function() {
      var t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, builder, kind, graph, thisInstruction, parameter, className, memberName, $name;
      $.HInstruction_idCounter = 0;
      t1 = this.this_2;
      t2 = t1.backend;
      t3 = this.work_3;
      t4 = t1.emitter.nativeEmitter;
      t5 = new B.HGraph(null, null, null, null, false, false, H.setRuntimeTypeInfo([], [B.HBasicBlock]), P.LinkedHashMap_LinkedHashMap(null, null, null, K.Constant, B.HConstant));
      t5.HGraph$0();
      t6 = H.setRuntimeTypeInfo([], [O.Element]);
      t7 = P.LinkedHashMap_LinkedHashMap$_empty(O.ParameterElement, B.HInstruction);
      t8 = P.LinkedHashMap_LinkedHashMap$_empty(O.JumpTarget, B.JumpHandler);
      t9 = P.LinkedHashMap_LinkedHashMap$_empty(O.Local, B.HLocalValue);
      t10 = H.setRuntimeTypeInfo([], [B.HInstruction]);
      t11 = H.setRuntimeTypeInfo([], [V.DartType]);
      t12 = H.setRuntimeTypeInfo([], [B.AstInliningState]);
      t13 = P.LinkedHashMap_LinkedHashMap(null, null, null, O.Element, B.TypeMask);
      t14 = t2.compiler;
      builder = new B.SsaBuilder(t2, t2.constantCompilerTask.jsConstantCompiler.constantSystem, t3, t2.rti, t4, t5, null, null, true, false, 0, t6, null, null, null, t7, t8, t9, t10, t11, t12, null, null, false, null, t13, t14, t3.resolutionTree);
      builder.SsaBuilder$3(t2, t3, t4);
      t4 = this.element_4;
      kind = t4.get$kind(t4);
      if (kind === C.ElementKind_generative_constructor_16)
        graph = builder.buildFactory$1(t3.element);
      else if (kind === C.ElementKind_generative_constructor_body_0 || kind === C.ElementKind_function_2 || kind === C.ElementKind_getter_0 || kind === C.ElementKind_setter_0)
        graph = builder.buildMethod$1(t4);
      else if (kind === C.ElementKind_field_1)
        if (t4.get$isInstanceMember()) {
          builder.openFunction$2(t4, t4.get$node());
          thisInstruction = builder.localsHandler.readThis$0();
          t2 = t14.typesTask.get$dynamicType();
          t6 = H.setRuntimeTypeInfo([], [B.HInstruction]);
          t7 = $.HInstruction_idCounter;
          if (typeof t7 !== "number")
            return t7.$add();
          $.HInstruction_idCounter = t7 + 1;
          parameter = new B.HParameterValue(null, null, t7, t6, H.setRuntimeTypeInfo([], [B.HInstruction]), null, null, null, new Z.SideEffects(0), false, t2);
          parameter.HInstruction$2(t6, t2);
          parameter.sourceElement = t4;
          t5 = t5.entry;
          t5.addBefore$2(t5.last, parameter);
          t5 = B.HFieldSet$(t4, thisInstruction, builder.potentiallyCheckType$2(parameter, t4.get$type(t4)));
          builder._ssa$_current.add$1(0, t5);
          graph = builder.closeFunction$0();
        } else {
          builder.openFunction$2(t4, t4.get$node());
          t2 = t4.get$initializer();
          if (t2 != null)
            t2.accept$1(0, builder);
          t2 = builder.stack;
          if (0 >= t2.length)
            return H.ioore(t2, 0);
          t2 = H.setRuntimeTypeInfo([builder.potentiallyCheckType$2(t2.pop(), t4.get$type(t4))], [B.HInstruction]);
          t5 = $.HInstruction_idCounter;
          if (typeof t5 !== "number")
            return t5.$add();
          $.HInstruction_idCounter = t5 + 1;
          t5 = new B.HReturn(null, null, t5, t2, H.setRuntimeTypeInfo([], [B.HInstruction]), null, null, null, new Z.SideEffects(0), false, C.FlatTypeMask_null_0);
          t5.HInstruction$2(t2, C.FlatTypeMask_null_0);
          builder.closeAndGotoExit$1(t5);
          graph = builder.closeFunction$0();
        }
      else {
        t1.compiler.internalError$2(t4, "Unexpected element kind " + J.toString$0(kind) + ".");
        graph = null;
      }
      if (kind !== C.ElementKind_field_1)
        t4.get$functionSignature().forEachOptionalParameter$1(new B.SsaBuilderTask_build___closure(t1, t3));
      t1 = t1.compiler;
      if (t1.tracer.isEnabled) {
        if (t4.get$isClassMember()) {
          t2 = t4.get$enclosingClass();
          className = t2.get$name(t2);
          memberName = t4.name;
          $name = H.S(className) + "." + H.S(memberName);
          if (t4.kind === C.ElementKind_generative_constructor_body_0)
            $name += " (body)";
        } else
          $name = H.S(t4.name);
        t1.tracer.traceCompilation$3($name, t3.compilationContext, t1);
        t1.tracer.traceGraph$2("builder", graph);
      }
      return graph;
    },
    $isFunction: true
  },
  SsaBuilderTask_build___closure: {
    "^": "Closure:50;this_5,work_6",
    call$1: function(parameter) {
      var constant, registry, t1;
      constant = this.this_5.backend.constantCompilerTask.jsConstantCompiler.initialVariableValues.$index(0, parameter.get$declaration());
      registry = this.work_6.registry;
      t1 = registry.compiler;
      t1.backend.registerCompileTimeConstant$2(constant, registry);
      t1.backend.get$constantCompilerTask().jsConstantCompiler.compiledConstants.add$1(0, constant);
    },
    $isFunction: true
  },
  LocalsHandler0: {
    "^": "Object;directLocals<,redirectionMapping,builder,closureData,typeVariableLocals,executableContext",
    substInContext$1: function(type) {
      var t1, typeContext;
      t1 = this.executableContext;
      if (t1.get$contextClass() != null) {
        typeContext = V.Types_getClassContext(type);
        if (typeContext != null) {
          t1 = t1.get$contextClass().asInstanceOf$1(typeContext);
          type.toString;
          type = type.subst$2(t1.typeArguments, t1.get$element().get$typeVariables());
        }
      }
      return type;
    },
    redirectElement$2: function(from, to) {
      this.redirectionMapping.$indexSet(0, from, to);
    },
    createBox$0: function() {
      var t1, box;
      t1 = this.builder;
      box = B.HForeign$(C.C_JsBuilder.parseForeignJS$1("{}"), t1.backend.nonNullType, H.setRuntimeTypeInfo([], [B.HInstruction]), false, null, false, null);
      this.builder._ssa$_current.add$1(0, box);
      return box;
    },
    enterScope$2: function(node, element) {
      var scopeData, t1, box;
      scopeData = this.closureData.capturingScopes.$index(0, node);
      if (scopeData == null)
        return;
      if (element != null && element.get$kind(element) === C.ElementKind_generative_constructor_body_0) {
        t1 = this.builder;
        box = t1.addParameter$2(scopeData.get$boxElement(), t1.backend.nonNullType);
      } else
        box = this.createBox$0();
      this.directLocals.$indexSet(0, scopeData.get$boxElement(), box);
      scopeData._capturedVariableMapping.forEach$1(0, new B.LocalsHandler_enterScope_closure(this, element));
    },
    updateCaptureBox$2: function(boxElement, toBeCopiedElements) {
      var oldBox, newBox, t1, boxedVariable, oldValue;
      oldBox = this.readLocal$1(boxElement);
      newBox = this.createBox$0();
      for (t1 = H.setRuntimeTypeInfo(new H.ListIterator(toBeCopiedElements, toBeCopiedElements.length, 0, null), [H.getTypeArgumentByIndex(toBeCopiedElements, 0)]); t1.moveNext$0();) {
        boxedVariable = t1.__internal$_current;
        this.updateLocal$2(boxElement, oldBox);
        oldValue = this.readLocal$1(boxedVariable);
        this.updateLocal$2(boxElement, newBox);
        this.updateLocal$2(boxedVariable, oldValue);
      }
      this.updateLocal$2(boxElement, newBox);
    },
    startFunction$2: function(element, node) {
      var t1, compiler, backend, t2, t3, t4, thisInstruction, cls, isNativeUpgradeFactory, isInterceptorClass, $name, value;
      t1 = this.builder;
      compiler = t1.compiler;
      this.closureData = compiler.closureToClassMapper.computeClosureToClassMapping$3(element, node, t1.elements);
      if (!!element.$isFunctionElement)
        element.get$functionSignature().orderedForEachParameter$1(new B.LocalsHandler_startFunction_closure(this, element, compiler, this.closureData.capturingScopes.$index(0, node)));
      this.enterScope$2(node, element);
      this.closureData._freeVariableMapping.forEach$1(0, new B.LocalsHandler_startFunction_closure0(this));
      backend = compiler.backend;
      t1 = this.closureData;
      if (t1.closureElement != null) {
        t1 = t1.thisLocal;
        t2 = backend.get$nonNullType();
        t3 = H.setRuntimeTypeInfo([], [B.HInstruction]);
        t4 = $.HInstruction_idCounter;
        if (typeof t4 !== "number")
          return t4.$add();
        $.HInstruction_idCounter = t4 + 1;
        thisInstruction = new B.HThis(null, null, t4, t3, H.setRuntimeTypeInfo([], [B.HInstruction]), null, null, null, new Z.SideEffects(0), false, t2);
        thisInstruction.HInstruction$2(t3, t2);
        thisInstruction.sourceElement = t1;
        t1 = this.builder.graph;
        t1.thisInstruction = thisInstruction;
        t1.entry.addAtEntry$1(thisInstruction);
        this.updateLocal$2(this.closureData.closureElement, thisInstruction);
      } else if (element.get$isInstanceMember()) {
        t1 = this.closureData.thisLocal;
        t2 = this.builder.getTypeOfThis$0();
        t3 = H.setRuntimeTypeInfo([], [B.HInstruction]);
        t4 = $.HInstruction_idCounter;
        if (typeof t4 !== "number")
          return t4.$add();
        $.HInstruction_idCounter = t4 + 1;
        thisInstruction = new B.HThis(null, null, t4, t3, H.setRuntimeTypeInfo([], [B.HInstruction]), null, null, null, new Z.SideEffects(0), false, t2);
        thisInstruction.HInstruction$2(t3, t2);
        thisInstruction.sourceElement = t1;
        t1 = this.builder.graph;
        t1.thisInstruction = thisInstruction;
        t1.entry.addAtEntry$1(thisInstruction);
        this.directLocals.$indexSet(0, this.closureData.thisLocal, thisInstruction);
      }
      cls = element.get$enclosingClass();
      isNativeUpgradeFactory = element.get$kind(element) === C.ElementKind_generative_constructor_16 && O.Elements_isNativeOrExtendsNative(cls);
      if (backend.isInterceptedMethod$1(element)) {
        isInterceptorClass = backend.isInterceptorClass$1(cls.get$declaration());
        $name = isInterceptorClass ? "receiver" : "_";
        t1 = this.builder.getTypeOfThis$0();
        t2 = H.setRuntimeTypeInfo([], [B.HInstruction]);
        t3 = $.HInstruction_idCounter;
        if (typeof t3 !== "number")
          return t3.$add();
        $.HInstruction_idCounter = t3 + 1;
        value = new B.HParameterValue(null, null, t3, t2, H.setRuntimeTypeInfo([], [B.HInstruction]), null, null, null, new Z.SideEffects(0), false, t1);
        value.HInstruction$2(t2, t1);
        value.sourceElement = new B.SyntheticLocal($name, this.executableContext);
        t1 = this.builder.graph;
        t1.explicitReceiverParameter = value;
        t1.entry.addAfter$2(this.directLocals.$index(0, this.closureData.thisLocal), value);
        if (isInterceptorClass)
          this.directLocals.$indexSet(0, this.closureData.thisLocal, value);
      } else if (isNativeUpgradeFactory) {
        t1 = new B.FlatTypeMask(cls, 3);
        t2 = H.setRuntimeTypeInfo([], [B.HInstruction]);
        t3 = $.HInstruction_idCounter;
        if (typeof t3 !== "number")
          return t3.$add();
        $.HInstruction_idCounter = t3 + 1;
        value = new B.HParameterValue(null, null, t3, t2, H.setRuntimeTypeInfo([], [B.HInstruction]), null, null, null, new Z.SideEffects(0), false, t1);
        value.HInstruction$2(t2, t1);
        value.sourceElement = new B.SyntheticLocal("receiver", this.executableContext);
        t1 = this.builder.graph;
        t1.explicitReceiverParameter = value;
        t1.entry.addAtEntry$1(value);
      }
    },
    isAccessedDirectly$1: function(local) {
      return !this.redirectionMapping.containsKey$1(local) && !this.closureData.usedVariablesInTry.contains$1(0, local);
    },
    isStoredInClosureField$1: function(local) {
      var redirectTarget;
      if (this.isAccessedDirectly$1(local))
        return false;
      redirectTarget = this.redirectionMapping.$index(0, local);
      if (redirectTarget == null)
        return false;
      return !!J.getInterceptor(redirectTarget).$isClosureFieldElement;
    },
    isBoxed$1: function(local) {
      if (this.isAccessedDirectly$1(local))
        return false;
      if (this.isStoredInClosureField$1(local))
        return false;
      return this.redirectionMapping.containsKey$1(local);
    },
    readLocal$1: function(local) {
      var t1, redirect, receiver, fieldGet, lookup, localValue, t2, t3, t4, instruction;
      t1 = this.redirectionMapping;
      if (!t1.containsKey$1(local) && !this.closureData.usedVariablesInTry.contains$1(0, local)) {
        if (this.directLocals.$index(0, local) == null)
          this.builder.compiler.internalError$2(local, "Cannot find value " + J.toString$0(local) + ".");
        return this.directLocals.$index(0, local);
      } else if (this.isStoredInClosureField$1(local)) {
        redirect = t1.$index(0, local);
        receiver = this.readLocal$1(this.closureData.closureElement);
        t1 = this.builder;
        fieldGet = B.HFieldGet$(redirect, receiver, !!J.getInterceptor(local).$isBoxLocal ? t1.backend.nonNullType : t1.getTypeOfCapturedVariable$1(redirect), null);
        t1 = this.builder._ssa$_current;
        t1.internalAddAfter$2(t1.last, fieldGet);
        fieldGet.notifyAddedToBlock$1(t1);
        return fieldGet;
      } else if (this.isBoxed$1(local)) {
        redirect = t1.$index(0, local);
        lookup = B.HFieldGet$(redirect, this.readLocal$1(redirect.get$box()), this.builder.getTypeOfCapturedVariable$1(redirect), null);
        t1 = this.builder._ssa$_current;
        t1.internalAddAfter$2(t1.last, lookup);
        lookup.notifyAddedToBlock$1(t1);
        return lookup;
      } else {
        localValue = this.getLocal$1(local);
        t1 = this.builder.backend.compiler.typesTask;
        t2 = t1.dynamicTypeCache;
        if (t2 == null) {
          t2 = new B.FlatTypeMask(t1.compiler.objectClass, 5);
          t1.dynamicTypeCache = t2;
          t1 = t2;
        } else
          t1 = t2;
        t2 = [localValue];
        t2.$builtinTypeInfo = [B.HInstruction];
        t3 = $.HInstruction_idCounter;
        if (typeof t3 !== "number")
          return t3.$add();
        $.HInstruction_idCounter = t3 + 1;
        t4 = [];
        t4.$builtinTypeInfo = [B.HInstruction];
        instruction = new B.HLocalGet(local, null, null, t3, t2, t4, null, null, null, new Z.SideEffects(0), false, t1);
        instruction.HInstruction$2(t2, t1);
        t1 = this.builder._ssa$_current;
        t1.internalAddAfter$2(t1.last, instruction);
        instruction.notifyAddedToBlock$1(t1);
        return instruction;
      }
    },
    readThis$0: function() {
      var res = this.readLocal$1(this.closureData.thisLocal);
      if (res.instructionType == null)
        res.set$instructionType(this.builder.getTypeOfThis$0());
      return res;
    },
    getLocal$1: function(local) {
      if (!!J.getInterceptor(local).$isParameterElement)
        return this.builder.parameters.$index(0, local);
      return this.builder.activationVariables.putIfAbsent$2(local, new B.LocalsHandler_getLocal_closure(this, local));
    },
    getTypeVariableAsLocal$1: function(type) {
      return this.typeVariableLocals.putIfAbsent$2(type, new B.LocalsHandler_getTypeVariableAsLocal_closure(this, type));
    },
    updateLocal$2: function(local, value) {
      var t1, redirect, box, t2, t3, t4, localValue;
      t1 = this.redirectionMapping;
      if (!t1.containsKey$1(local) && !this.closureData.usedVariablesInTry.contains$1(0, local))
        this.directLocals.$indexSet(0, local, value);
      else if (this.isBoxed$1(local)) {
        redirect = t1.$index(0, local);
        box = this.readLocal$1(redirect.get$box());
        t1 = this.builder;
        t2 = [box, value];
        t2.$builtinTypeInfo = [B.HInstruction];
        t3 = $.HInstruction_idCounter;
        if (typeof t3 !== "number")
          return t3.$add();
        $.HInstruction_idCounter = t3 + 1;
        t4 = [];
        t4.$builtinTypeInfo = [B.HInstruction];
        t3 = new B.HFieldSet(redirect, null, null, t3, t2, t4, null, null, null, new Z.SideEffects(0), false, C.FlatTypeMask_null_0);
        t3.HInstruction$2(t2, C.FlatTypeMask_null_0);
        t2 = t3.sideEffects;
        t4 = (t2.flags & 4294967288) >>> 0;
        t2.flags = t4;
        t4 = (t4 & 4294967239) >>> 0;
        t2.flags = t4;
        t2.flags = (t4 | 2) >>> 0;
        t1 = t1._ssa$_current;
        t1.internalAddAfter$2(t1.last, t3);
        t3.notifyAddedToBlock$1(t1);
      } else {
        localValue = this.getLocal$1(local);
        t1 = this.builder;
        t2 = [localValue, value];
        t2.$builtinTypeInfo = [B.HInstruction];
        t3 = $.HInstruction_idCounter;
        if (typeof t3 !== "number")
          return t3.$add();
        $.HInstruction_idCounter = t3 + 1;
        t4 = [];
        t4.$builtinTypeInfo = [B.HInstruction];
        t3 = new B.HLocalSet(local, null, null, t3, t2, t4, null, null, null, new Z.SideEffects(0), false, C.FlatTypeMask_null_0);
        t3.HInstruction$2(t2, C.FlatTypeMask_null_0);
        t1 = t1._ssa$_current;
        t1.internalAddAfter$2(t1.last, t3);
        t3.notifyAddedToBlock$1(t1);
      }
    },
    startLoop$1: function(node) {
      var scopeData = this.closureData.capturingScopes.$index(0, node);
      if (scopeData == null)
        return;
      if (scopeData.get$boxedLoopVariables().length !== 0)
        this.enterScope$2(node, null);
    },
    beginLoopHeader$1: function(loopEntry) {
      var t1, savedDirectLocals;
      t1 = this.directLocals;
      savedDirectLocals = P.LinkedHashMap_LinkedHashMap(null, null, null, O.Local, B.HInstruction);
      savedDirectLocals.addAll$1(0, t1);
      savedDirectLocals.forEach$1(0, new B.LocalsHandler_beginLoopHeader_closure(this, loopEntry, this.builder.backend));
    },
    enterLoopBody$1: function(node) {
      var scopeData = this.closureData.capturingScopes.$index(0, node);
      if (scopeData == null)
        return;
      if (scopeData.get$boxedLoopVariables().length === 0)
        this.enterScope$2(node, null);
    },
    enterLoopUpdates$1: function(node) {
      var scopeData = this.closureData.capturingScopes.$index(0, node);
      if (scopeData == null)
        return;
      if (scopeData.get$boxedLoopVariables().length !== 0)
        this.updateCaptureBox$2(scopeData.boxElement, scopeData.boxedLoopVariables);
    },
    endLoop$1: function(loopEntry) {
      if (loopEntry.predecessors.length === 1)
        return;
      loopEntry.forEachPhi$1(new B.LocalsHandler_endLoop_closure0(this));
    },
    mergeWith$2: function(otherLocals, joinBlock) {
      var joinedLocals, t1;
      joinedLocals = P.LinkedHashMap_LinkedHashMap(null, null, null, O.Local, B.HInstruction);
      t1 = this.builder;
      otherLocals.directLocals.forEach$1(0, new B.LocalsHandler_mergeWith_closure(this, joinBlock, joinedLocals, t1.backend));
      this.directLocals = joinedLocals;
    },
    mergeMultiple$2: function(localsHandlers, joinBlock) {
      var t1, t2, joinedLocals;
      t1 = {};
      t2 = localsHandlers.length;
      if (t2 === 1) {
        if (0 >= t2)
          return H.ioore(localsHandlers, 0);
        return localsHandlers[0];
      }
      joinedLocals = P.LinkedHashMap_LinkedHashMap(null, null, null, O.Local, B.HInstruction);
      t1.thisValue_0 = null;
      t2 = this.builder;
      this.directLocals.forEach$1(0, new B.LocalsHandler_mergeMultiple_closure(t1, this, joinBlock, joinedLocals, t2.backend));
      for (t2 = H.setRuntimeTypeInfo(new H.ListIterator(localsHandlers, localsHandlers.length, 0, null), [H.getTypeArgumentByIndex(localsHandlers, 0)]); t2.moveNext$0();)
        t2.__internal$_current.get$directLocals().forEach$1(0, new B.LocalsHandler_mergeMultiple_closure0(joinedLocals));
      t1 = t1.thisValue_0;
      if (t1 != null)
        joinedLocals.$indexSet(0, this.closureData.thisLocal, t1);
      this.directLocals = P.LinkedHashMap_LinkedHashMap(null, null, null, O.Local, B.HInstruction);
      joinedLocals.forEach$1(0, new B.LocalsHandler_mergeMultiple_closure1(this, localsHandlers, joinBlock));
      return this;
    },
    static: {LocalsHandler$from0: function(other) {
        var t1, t2, t3, t4;
        P.LinkedHashMap_LinkedHashMap(null, null, null, O.Local, B.HInstruction);
        P.LinkedHashMap_LinkedHashMap(null, null, null, O.Local, Q.CapturedVariable);
        t1 = P.LinkedHashMap_LinkedHashMap(null, null, null, V.TypeVariableType, Q.TypeVariableLocal);
        t2 = other.directLocals;
        t3 = P.LinkedHashMap_LinkedHashMap(null, null, null, O.Local, B.HInstruction);
        t3.addAll$1(0, t2);
        t2 = other.redirectionMapping;
        t4 = other.executableContext;
        return new B.LocalsHandler0(t3, t2, other.builder, other.closureData, t1, t4);
      }}
  },
  LocalsHandler_enterScope_closure: {
    "^": "Closure:256;this_0,element_1",
    call$2: function(from, to) {
      var t1, t2, instruction;
      if (J.get$kind$x(from) === C.ElementKind_parameter_1) {
        t1 = this.element_1;
        t1 = t1.get$kind(t1) !== C.ElementKind_generative_constructor_body_0;
      } else
        t1 = false;
      t2 = this.this_0;
      if (t1) {
        instruction = t2.readLocal$1(from);
        t2.redirectElement$2(from, to);
        t2.updateLocal$2(from, instruction);
      } else
        t2.redirectElement$2(from, to);
    },
    $isFunction: true
  },
  LocalsHandler_startFunction_closure: {
    "^": "Closure:50;this_0,element_1,compiler_2,scopeData_3",
    call$1: function(parameterElement) {
      var t1, t2, parameter;
      t1 = this.element_1;
      if (t1.get$kind(t1) === C.ElementKind_generative_constructor_body_0) {
        t1 = this.scopeData_3;
        if (t1 != null && t1._capturedVariableMapping.containsKey$1(parameterElement))
          return;
      }
      t1 = this.this_0;
      t2 = this.compiler_2;
      parameter = t1.builder.addParameter$2(parameterElement, B.TypeMaskFactory_fromInferredType(t2.typesTask.getGuaranteedTypeOfElement$1(parameterElement), t2));
      t1.builder.parameters.$indexSet(0, parameterElement, parameter);
      t1.directLocals.$indexSet(0, parameterElement, parameter);
    },
    $isFunction: true
  },
  LocalsHandler_startFunction_closure0: {
    "^": "Closure:257;this_4",
    call$2: function(from, to) {
      this.this_4.redirectElement$2(from, to);
    },
    $isFunction: true
  },
  LocalsHandler_getLocal_closure: {
    "^": "Closure:23;this_0,local_1",
    call$0: function() {
      var t1, t2, t3, t4, localValue;
      t1 = this.this_0;
      t2 = t1.builder.backend.nonNullType;
      t3 = H.setRuntimeTypeInfo([], [B.HInstruction]);
      t4 = $.HInstruction_idCounter;
      if (typeof t4 !== "number")
        return t4.$add();
      $.HInstruction_idCounter = t4 + 1;
      localValue = new B.HLocalValue(null, null, t4, t3, H.setRuntimeTypeInfo([], [B.HInstruction]), null, null, null, new Z.SideEffects(0), false, t2);
      localValue.HInstruction$2(t3, t2);
      localValue.sourceElement = this.local_1;
      t1.builder.graph.entry.addAtExit$1(localValue);
      return localValue;
    },
    $isFunction: true
  },
  LocalsHandler_getTypeVariableAsLocal_closure: {
    "^": "Closure:23;this_0,type_1",
    call$0: function() {
      return new Q.TypeVariableLocal(this.type_1, this.this_0.executableContext);
    },
    $isFunction: true
  },
  LocalsHandler_beginLoopHeader_closure: {
    "^": "Closure:258;this_0,loopEntry_1,backend_2",
    call$2: function(local, instruction) {
      var t1, t2, t3, t4, phi;
      t1 = this.this_0;
      if (t1.isAccessedDirectly$1(local))
        if (!J.$eq(local, t1.closureData.thisLocal)) {
          t2 = this.backend_2.compiler.typesTask.get$dynamicType();
          t3 = H.setRuntimeTypeInfo([instruction], [B.HInstruction]);
          t4 = $.HInstruction_idCounter;
          if (typeof t4 !== "number")
            return t4.$add();
          $.HInstruction_idCounter = t4 + 1;
          phi = new B.HPhi(0, null, null, t4, t3, H.setRuntimeTypeInfo([], [B.HInstruction]), null, null, null, new Z.SideEffects(0), false, t2);
          phi.HInstruction$2(t3, t2);
          phi.sourceElement = local;
          this.loopEntry_1.addPhi$1(phi);
          t1.directLocals.$indexSet(0, local, phi);
        } else
          t1.directLocals.$indexSet(0, local, instruction);
    },
    $isFunction: true
  },
  LocalsHandler_endLoop_closure0: {
    "^": "Closure:259;this_0",
    call$1: function(phi) {
      var element = phi.sourceElement;
      phi.addInput$1(this.this_0.directLocals.$index(0, element));
    },
    $isFunction: true
  },
  LocalsHandler_mergeWith_closure: {
    "^": "Closure:258;this_0,joinBlock_1,joinedLocals_2,backend_3",
    call$2: function(local, instruction) {
      var t1, mine, t2, t3, t4, phi;
      t1 = this.this_0;
      if (J.$eq(local, t1.closureData.thisLocal))
        this.joinedLocals_2.$indexSet(0, local, instruction);
      else {
        mine = t1.directLocals.$index(0, local);
        if (mine == null)
          return;
        t1 = this.joinedLocals_2;
        if (instruction === mine)
          t1.$indexSet(0, local, instruction);
        else {
          t2 = H.setRuntimeTypeInfo([mine, instruction], [B.HInstruction]);
          t3 = this.backend_3.compiler.typesTask.get$dynamicType();
          t4 = $.HInstruction_idCounter;
          if (typeof t4 !== "number")
            return t4.$add();
          $.HInstruction_idCounter = t4 + 1;
          phi = new B.HPhi(0, null, null, t4, t2, H.setRuntimeTypeInfo([], [B.HInstruction]), null, null, null, new Z.SideEffects(0), false, t3);
          phi.HInstruction$2(t2, t3);
          phi.sourceElement = local;
          this.joinBlock_1.addPhi$1(phi);
          t1.$indexSet(0, local, phi);
        }
      }
    },
    $isFunction: true
  },
  LocalsHandler_mergeMultiple_closure: {
    "^": "Closure:258;box_0,this_1,joinBlock_2,joinedLocals_3,backend_4",
    call$2: function(local, instruction) {
      var t1, t2, t3, phi;
      if (!J.$eq(local, this.this_1.closureData.thisLocal)) {
        t1 = this.backend_4.compiler.typesTask.get$dynamicType();
        t2 = H.setRuntimeTypeInfo([], [B.HInstruction]);
        t3 = $.HInstruction_idCounter;
        if (typeof t3 !== "number")
          return t3.$add();
        $.HInstruction_idCounter = t3 + 1;
        phi = new B.HPhi(0, null, null, t3, t2, H.setRuntimeTypeInfo([], [B.HInstruction]), null, null, null, new Z.SideEffects(0), false, t1);
        phi.HInstruction$2(t2, t1);
        phi.sourceElement = local;
        this.joinedLocals_3.$indexSet(0, local, phi);
        this.joinBlock_2.addPhi$1(phi);
      } else
        this.box_0.thisValue_0 = instruction;
    },
    $isFunction: true
  },
  LocalsHandler_mergeMultiple_closure0: {
    "^": "Closure:258;joinedLocals_5",
    call$2: function(local, instruction) {
      var phi = this.joinedLocals_5.$index(0, local);
      if (phi != null)
        phi.addInput$1(instruction);
    },
    $isFunction: true
  },
  LocalsHandler_mergeMultiple_closure1: {
    "^": "Closure:258;this_6,localsHandlers_7,joinBlock_8",
    call$2: function(local, instruction) {
      var t1 = this.this_6;
      if (!J.$eq(local, t1.closureData.thisLocal) && instruction.get$inputs().length !== this.localsHandlers_7.length)
        this.joinBlock_8.removePhi$1(instruction);
      else
        t1.directLocals.$indexSet(0, local, instruction);
    },
    $isFunction: true
  },
  JumpHandlerEntry: {
    "^": "Object;jumpInstruction<,locals<"
  },
  JumpHandler: {
    "^": "Object;"
  },
  NullJumpHandler: {
    "^": "Object;compiler<",
    generateBreak$1: function(label) {
      this.compiler.internalError$2(C._SpannableSentinel_0, "NullJumpHandler.generateBreak should not be called.");
    },
    generateBreak$0: function() {
      return this.generateBreak$1(null);
    },
    forEachBreak$1: function(ignored) {
    },
    forEachContinue$1: function(ignored) {
    },
    close$0: function(_) {
    },
    hasAnyContinue$0: function() {
      return false;
    },
    hasAnyBreak$0: function() {
      return false;
    },
    labels$0: function(_) {
      return C.List_empty14;
    },
    get$target: function(_) {
      return;
    }
  },
  TargetJumpHandler: {
    "^": "Object;builder,target>,jumps",
    generateBreak$1: function(label) {
      var t1, breakInstruction, t2, locals;
      if (label == null) {
        t1 = $.HInstruction_idCounter;
        if (typeof t1 !== "number")
          return t1.$add();
        $.HInstruction_idCounter = t1 + 1;
        breakInstruction = new B.HBreak(false, this.target, null, null, null, t1, C.List_empty12, H.setRuntimeTypeInfo([], [B.HInstruction]), null, null, null, new Z.SideEffects(0), false, C.FlatTypeMask_null_0);
        breakInstruction.HInstruction$2(C.List_empty12, C.FlatTypeMask_null_0);
      } else {
        t1 = label.get$target(label);
        t2 = $.HInstruction_idCounter;
        if (typeof t2 !== "number")
          return t2.$add();
        $.HInstruction_idCounter = t2 + 1;
        breakInstruction = new B.HBreak(false, t1, label, null, null, t2, C.List_empty12, H.setRuntimeTypeInfo([], [B.HInstruction]), null, null, null, new Z.SideEffects(0), false, C.FlatTypeMask_null_0);
        breakInstruction.HInstruction$2(C.List_empty12, C.FlatTypeMask_null_0);
      }
      t1 = this.builder;
      locals = B.LocalsHandler$from0(t1.localsHandler);
      t1.close$1(0, breakInstruction);
      this.jumps.push(new B.JumpHandlerEntry(breakInstruction, locals));
    },
    generateBreak$0: function() {
      return this.generateBreak$1(null);
    },
    generateContinue$1: function(label) {
      var t1, continueInstruction, t2, locals;
      if (label == null) {
        t1 = $.HInstruction_idCounter;
        if (typeof t1 !== "number")
          return t1.$add();
        $.HInstruction_idCounter = t1 + 1;
        continueInstruction = new B.HContinue(this.target, null, null, null, t1, C.List_empty12, H.setRuntimeTypeInfo([], [B.HInstruction]), null, null, null, new Z.SideEffects(0), false, C.FlatTypeMask_null_0);
        continueInstruction.HInstruction$2(C.List_empty12, C.FlatTypeMask_null_0);
      } else {
        t1 = label.get$target(label);
        t2 = $.HInstruction_idCounter;
        if (typeof t2 !== "number")
          return t2.$add();
        $.HInstruction_idCounter = t2 + 1;
        continueInstruction = new B.HContinue(t1, label, null, null, t2, C.List_empty12, H.setRuntimeTypeInfo([], [B.HInstruction]), null, null, null, new Z.SideEffects(0), false, C.FlatTypeMask_null_0);
        continueInstruction.HInstruction$2(C.List_empty12, C.FlatTypeMask_null_0);
      }
      t1 = this.builder;
      locals = B.LocalsHandler$from0(t1.localsHandler);
      t1.close$1(0, continueInstruction);
      this.jumps.push(new B.JumpHandlerEntry(continueInstruction, locals));
    },
    generateContinue$0: function() {
      return this.generateContinue$1(null);
    },
    forEachBreak$1: function(action) {
      var t1, entry;
      for (t1 = this.jumps, t1 = H.setRuntimeTypeInfo(new H.ListIterator(t1, t1.length, 0, null), [H.getTypeArgumentByIndex(t1, 0)]); t1.moveNext$0();) {
        entry = t1.__internal$_current;
        if (!!entry.get$jumpInstruction().$isHBreak)
          action.call$2(entry.jumpInstruction, entry.locals);
      }
    },
    forEachContinue$1: function(action) {
      var t1, entry;
      for (t1 = this.jumps, t1 = H.setRuntimeTypeInfo(new H.ListIterator(t1, t1.length, 0, null), [H.getTypeArgumentByIndex(t1, 0)]); t1.moveNext$0();) {
        entry = t1.__internal$_current;
        if (!!entry.get$jumpInstruction().$isHContinue)
          action.call$2(entry.jumpInstruction, entry.locals);
      }
    },
    hasAnyContinue$0: function() {
      for (var t1 = this.jumps, t1 = H.setRuntimeTypeInfo(new H.ListIterator(t1, t1.length, 0, null), [H.getTypeArgumentByIndex(t1, 0)]); t1.moveNext$0();)
        if (!!t1.__internal$_current.get$jumpInstruction().$isHContinue)
          return true;
      return false;
    },
    hasAnyBreak$0: function() {
      for (var t1 = this.jumps, t1 = H.setRuntimeTypeInfo(new H.ListIterator(t1, t1.length, 0, null), [H.getTypeArgumentByIndex(t1, 0)]); t1.moveNext$0();)
        if (!!t1.__internal$_current.get$jumpInstruction().$isHBreak)
          return true;
      return false;
    },
    close$0: function(_) {
      this.builder.jumpTargets.remove$1(0, this.target);
    },
    labels$0: function(_) {
      var t1, result, element;
      for (t1 = this.target, t1 = t1.get$labels(t1), t1 = H.setRuntimeTypeInfo(new E.LinkIterator(null, t1), [H.getTypeArgumentByIndex(t1, 0)]), result = null; t1.moveNext$0();) {
        element = t1._util_implementation$_current;
        if (result == null) {
          result = [];
          result.$builtinTypeInfo = [O.LabelDefinition];
        }
        result.push(element);
      }
      return result == null ? C.List_empty14 : result;
    },
    TargetJumpHandler$2: function(builder, target) {
      builder.jumpTargets.$indexSet(0, this.target, this);
    },
    static: {TargetJumpHandler$: function(builder, target) {
        var t1 = new B.TargetJumpHandler(builder, target, H.setRuntimeTypeInfo([], [B.JumpHandlerEntry]));
        t1.TargetJumpHandler$2(builder, target);
        return t1;
      }}
  },
  SwitchCaseJumpHandler: {
    "^": "TargetJumpHandler;targetIndexMap,builder,target,jumps",
    generateBreak$1: function(label) {
      var t1, breakInstruction, locals;
      if (label == null) {
        t1 = $.HInstruction_idCounter;
        if (typeof t1 !== "number")
          return t1.$add();
        $.HInstruction_idCounter = t1 + 1;
        breakInstruction = new B.HBreak(true, this.target, null, null, null, t1, C.List_empty12, H.setRuntimeTypeInfo([], [B.HInstruction]), null, null, null, new Z.SideEffects(0), false, C.FlatTypeMask_null_0);
        breakInstruction.HInstruction$2(C.List_empty12, C.FlatTypeMask_null_0);
        t1 = this.builder;
        locals = B.LocalsHandler$from0(t1.localsHandler);
        t1.close$1(0, breakInstruction);
        this.jumps.push(new B.JumpHandlerEntry(breakInstruction, locals));
      } else
        B.TargetJumpHandler.prototype.generateBreak$1.call(this, label);
    },
    generateBreak$0: function() {
      return this.generateBreak$1(null);
    },
    generateContinue$1: function(label) {
      var t1, t2, t3, value, continueInstruction, locals;
      if (label != null && this.targetIndexMap.containsKey$1(label.get$target(label))) {
        t1 = this.builder;
        t2 = this.targetIndexMap.$index(0, label.get$target(label));
        t3 = t1.compiler;
        value = t1.graph.addConstant$2(t3.backend.get$constantSystem().createInt$1(t2), t3);
        t3 = this.target;
        t1.localsHandler.updateLocal$2(t3, value);
        t2 = $.HInstruction_idCounter;
        if (typeof t2 !== "number")
          return t2.$add();
        $.HInstruction_idCounter = t2 + 1;
        continueInstruction = new B.HContinue(t3, null, null, null, t2, C.List_empty12, H.setRuntimeTypeInfo([], [B.HInstruction]), null, null, null, new Z.SideEffects(0), false, C.FlatTypeMask_null_0);
        continueInstruction.HInstruction$2(C.List_empty12, C.FlatTypeMask_null_0);
        locals = B.LocalsHandler$from0(t1.localsHandler);
        t1.close$1(0, continueInstruction);
        this.jumps.push(new B.JumpHandlerEntry(continueInstruction, locals));
      } else
        B.TargetJumpHandler.prototype.generateContinue$1.call(this, label);
    },
    generateContinue$0: function() {
      return this.generateContinue$1(null);
    },
    close$0: function(_) {
      var t1, t2;
      for (t1 = this.targetIndexMap, t1 = H.setRuntimeTypeInfo(new P.LinkedHashMapKeyIterable(t1), [H.getTypeArgumentByIndex(t1, 0)]), t2 = t1._map, t1 = H.setRuntimeTypeInfo(new P.LinkedHashMapKeyIterator(t2, t2._modifications, null, null), [H.getTypeArgumentByIndex(t1, 0)]), t1._cell = t1._map._first, t2 = this.builder.jumpTargets; t1.moveNext$0();)
        t2.remove$1(0, t1._collection$_current);
      B.TargetJumpHandler.prototype.close$0.call(this, this);
    },
    SwitchCaseJumpHandler$3: function(builder, target, node) {
      var t1, t2, t3, switchIndex, t4, t5, label, labelElement, continueTarget;
      for (t1 = node.cases.nodes, t1.toString, t1 = H.setRuntimeTypeInfo(new E.LinkIterator(null, t1), [H.getTypeArgumentByIndex(t1, 0)]), t2 = this.targetIndexMap, t3 = builder.jumpTargets, switchIndex = 1; t1.moveNext$0();) {
        t4 = t1._util_implementation$_current.get$labelsAndCases().nodes;
        t4.toString;
        t5 = new E.LinkIterator(null, t4);
        t5.$builtinTypeInfo = [H.getTypeArgumentByIndex(t4, 0)];
        for (; t5.moveNext$0();) {
          label = t5._util_implementation$_current.asLabel$0();
          if (label != null) {
            t4 = builder.elements._definedLabels;
            labelElement = t4 != null ? t4.$index(0, label) : null;
            if (labelElement != null && labelElement.get$isContinueTarget()) {
              continueTarget = J.get$target$x(labelElement);
              t2.$indexSet(0, continueTarget, switchIndex);
              t3.$indexSet(0, continueTarget, this);
            }
          }
        }
        ++switchIndex;
      }
    },
    static: {SwitchCaseJumpHandler$: function(builder, target, node) {
        var t1 = new B.SwitchCaseJumpHandler(P.LinkedHashMap_LinkedHashMap(null, null, null, O.JumpTarget, P.$int), builder, target, H.setRuntimeTypeInfo([], [B.JumpHandlerEntry]));
        t1.TargetJumpHandler$2(builder, target);
        t1.SwitchCaseJumpHandler$3(builder, target, node);
        return t1;
      }}
  },
  SsaBuilder: {
    "^": "ResolvedVisitor;backend<,constantSystem,work,rti,nativeEmitter,graph,_ssa$_current<,lastOpenedBlock,isReachable,inExpressionOfThrow,loopNesting,sourceElementStack<,localsHandler,rethrowableException,lastAddedParameter,parameters<,jumpTargets,activationVariables,stack<,currentInlinedInstantiations,inliningStack,returnLocal,returnType<,inTryStatement,cachedTypeOfThis,cachedTypesOfCapturedVariables,compiler,elements",
    get$current: function() {
      return this._ssa$_current;
    },
    get$sourceElement: function() {
      return J.get$last$ax(this.sourceElementStack);
    },
    close$1: function(_, end) {
      var result = this._ssa$_current;
      result.close$1(0, end);
      this.isReachable = false;
      this._ssa$_current = null;
      return result;
    },
    closeAndGotoExit$1: function(end) {
      var result, t1, t2;
      result = this._ssa$_current;
      result.addAfter$2(result.last, end);
      result.status = 2;
      this.isReachable = false;
      this._ssa$_current = null;
      t1 = this.graph.exit;
      t2 = result.successors;
      if (t2.length === 0)
        result.successors = [t1];
      else
        C.JSArray_methods.add$1(t2, t1);
      t1.predecessors.push(result);
      return result;
    },
    openNewBlock$0: function() {
      var block, t1, t2;
      block = this.graph.addNewBlock$0();
      t1 = this._ssa$_current;
      if (t1 != null) {
        t2 = $.HInstruction_idCounter;
        if (typeof t2 !== "number")
          return t2.$add();
        $.HInstruction_idCounter = t2 + 1;
        t2 = new B.HGoto(null, null, t2, C.List_empty12, H.setRuntimeTypeInfo([], [B.HInstruction]), null, null, null, new Z.SideEffects(0), false, C.FlatTypeMask_null_0);
        t2.HInstruction$2(C.List_empty12, C.FlatTypeMask_null_0);
        t1.close$1(0, t2);
        t1.addSuccessor$1(block);
      }
      block.status = 1;
      this.isReachable = true;
      this._ssa$_current = block;
      this.lastOpenedBlock = block;
      return block;
    },
    add$1: function(_, instruction) {
      var t1 = this._ssa$_current;
      t1.internalAddAfter$2(t1.last, instruction);
      instruction.notifyAddedToBlock$1(t1);
    },
    completeSendArgumentsList$4: function($function, selector, providedArguments, currentNode) {
      if (!$function.get$isInstanceMember() || currentNode == null || currentNode.asForIn$0() != null || $function.kind === C.ElementKind_generative_constructor_body_0 || selector.kind === C.SelectorKind_getter_0)
        return providedArguments;
      else
        return this.completeDynamicSendArgumentsList$3(selector, $function, providedArguments);
    },
    completeDynamicSendArgumentsList$3: function(selector, $function, providedArguments) {
      var t1, signature, compiledArguments, t2, t3, t4, t5, index, t6, selectorArgumentNames, firstProvidedNamedArgument;
      t1 = {};
      signature = $function.get$functionSignature();
      compiledArguments = H.setRuntimeTypeInfo(Array(signature.get$parameterCount() + 1), [B.HInstruction]);
      t2 = providedArguments.length;
      if (0 >= t2)
        return H.ioore(providedArguments, 0);
      t3 = providedArguments[0];
      t4 = compiledArguments.length;
      if (0 >= t4)
        return H.ioore(compiledArguments, 0);
      compiledArguments[0] = t3;
      t1.index_0 = 1;
      for (t3 = signature.requiredParameterCount, t5 = 1; t5 <= t3; index = t5 + 1, t1.index_0 = index, t5 = index) {
        if (t5 >= t2)
          return H.ioore(providedArguments, t5);
        t6 = providedArguments[t5];
        if (t5 >= t4)
          return H.ioore(compiledArguments, t5);
        compiledArguments[t5] = t6;
      }
      if (!signature.optionalParametersAreNamed)
        signature.forEachOptionalParameter$1(new B.SsaBuilder_completeDynamicSendArgumentsList_closure(t1, this, providedArguments, compiledArguments));
      else {
        selectorArgumentNames = selector.getOrderedNamedArguments$0();
        t1.namedArgumentIndex_1 = 0;
        firstProvidedNamedArgument = t1.index_0;
        H.IterableMixinWorkaround_forEach(signature.orderedOptionalParameters, new B.SsaBuilder_completeDynamicSendArgumentsList_closure0(t1, this, providedArguments, compiledArguments, selectorArgumentNames, firstProvidedNamedArgument));
      }
      return compiledArguments;
    },
    tryInlineMethod$4: function(element, selector, providedArguments, currentNode) {
      var t1, t2, t3, insideLoop, cachedCanBeInlined;
      t1 = {};
      t1.element_0 = element;
      t2 = this.backend;
      t2.registerStaticUse$2(element, this.compiler.enqueuer.codegen);
      t3 = t1.element_0;
      element = t3.get$implementation(t3);
      t1.element_0 = element;
      insideLoop = this.loopNesting > 0 || this.graph.calledInLoop;
      t2 = t2.inlineCache;
      cachedCanBeInlined = insideLoop ? t2.canBeInlinedInsideLoop.$index(0, element) : t2.canBeInlined.$index(0, element);
      if (J.$eq(cachedCanBeInlined, false))
        return false;
      if (new B.SsaBuilder_tryInlineMethod_meetsHardConstraints(t1, this, selector, providedArguments, element).call$0() === true && new B.SsaBuilder_tryInlineMethod_heuristicSayGoodToGo(t1, this, element, insideLoop, cachedCanBeInlined).call$0() === true) {
        new B.SsaBuilder_tryInlineMethod_doInlining(t1, this, selector, providedArguments, currentNode, element).call$0();
        return true;
      }
      return false;
    },
    inlinedFrom$2: function(element, f) {
      return this.compiler.withCurrentElement$2(element, new B.SsaBuilder_inlinedFrom_closure(this, element, f));
    },
    handleConstantForOptionalParameter$1: [function(parameter) {
      return this.graph.addConstant$2(this.backend.constantCompilerTask.jsConstantCompiler.initialVariableValues.$index(0, parameter.get$declaration()), this.compiler);
    }, "call$1", "get$handleConstantForOptionalParameter", 2, 0, 260],
    get$currentNonClosureClass: function() {
      var cls = J.get$last$ax(this.sourceElementStack).get$enclosingClass();
      if (cls != null && cls.get$isClosure())
        return cls.get$methodElement().get$enclosingClass();
      else
        return cls;
    },
    getConstantForNode$1: function(node) {
      return this.backend.constantCompilerTask.jsConstantCompiler.getConstantForNode$2(node, this.elements);
    },
    getTypeOfThis$0: function() {
      var result, cls;
      result = this.cachedTypeOfThis;
      if (result == null) {
        cls = this.localsHandler.closureData.thisLocal.executableContext.get$enclosingClass();
        result = this.compiler.world.isUsedAsMixin$1(cls) ? new B.FlatTypeMask(cls.get$declaration(), 6) : new B.FlatTypeMask(cls.get$declaration(), 4);
        this.cachedTypeOfThis = result;
      }
      return result;
    },
    getTypeOfCapturedVariable$1: function(element) {
      return this.cachedTypesOfCapturedVariables.putIfAbsent$2(element, new B.SsaBuilder_getTypeOfCapturedVariable_closure(this, element));
    },
    buildMethod$1: function(functionElement) {
      var $function;
      this.graph.calledInLoop = this.compiler.world.functionsCalledInLoop.contains$1(0, functionElement.get$declaration());
      $function = functionElement.get$node();
      this.openFunction$2(functionElement, $function);
      if (functionElement.name === "==")
        if (!this.backend.specialOperatorEqClasses.contains$1(0, functionElement.get$enclosingClass()))
          new B.SsaBranchBuilder(this, $function).handleIf$3(new B.SsaBuilder_buildMethod_closure(this), new B.SsaBuilder_buildMethod_closure0(this), null);
      $function.get$body($function).accept$1(0, this);
      return this.closeFunction$0();
    },
    getConstructorBody$1: function($constructor) {
      var t1, node, classElement, t2, t3, t4, t5, t6, bodyElement, patch, t7, origin;
      t1 = {};
      if ($constructor.get$isSynthesized())
        return;
      node = $constructor.get$node();
      if (!node.hasBody$0())
        return;
      if (node.hasEmptyBody$0())
        return;
      classElement = $constructor.get$enclosingClass();
      t1.bodyElement_0 = null;
      classElement.forEachBackendMember$1(new B.SsaBuilder_getConstructorBody_closure(t1, $constructor));
      if (t1.bodyElement_0 == null) {
        t2 = $constructor.name;
        t3 = $.get$Modifiers_EMPTY();
        t4 = $constructor.get$enclosingElement();
        t5 = [];
        t5.$builtinTypeInfo = [O.FunctionElement];
        t6 = $.ElementX_elementHashCode + 1;
        $.ElementX_elementHashCode = t6;
        bodyElement = new U.ConstructorBodyElementX($constructor, null, t3, t5, null, false, null, null, null, t2, C.ElementKind_generative_constructor_body_0, t4, t6, C.C_Link2, null, false);
        bodyElement.functionSignatureCache = $constructor.get$functionSignature();
        t1.bodyElement_0 = bodyElement;
        classElement.backendMembers = classElement.backendMembers.prepend$1(bodyElement);
        if ($constructor.get$isPatch()) {
          patch = t1.bodyElement_0;
          t2 = $constructor.get$origin($constructor);
          t4 = t2.get$name(t2);
          t5 = t2.get$enclosingElement();
          t6 = [];
          t6.$builtinTypeInfo = [O.FunctionElement];
          t7 = $.ElementX_elementHashCode + 1;
          $.ElementX_elementHashCode = t7;
          origin = new U.ConstructorBodyElementX(t2, null, t3, t6, null, false, null, null, null, t4, C.ElementKind_generative_constructor_body_0, t5, t7, C.C_Link2, null, false);
          origin.functionSignatureCache = t2.get$functionSignature();
          origin.applyPatch$1(patch);
          t2 = classElement.get$origin(classElement);
          t7 = t1.bodyElement_0;
          t2.addBackendMember$1(t7.get$origin(t7));
        }
      }
      return t1.bodyElement_0;
    },
    addParameter$2: function(parameter, type) {
      var t1, t2, result;
      t1 = H.setRuntimeTypeInfo([], [B.HInstruction]);
      t2 = $.HInstruction_idCounter;
      if (typeof t2 !== "number")
        return t2.$add();
      $.HInstruction_idCounter = t2 + 1;
      result = new B.HParameterValue(null, null, t2, t1, H.setRuntimeTypeInfo([], [B.HInstruction]), null, null, null, new Z.SideEffects(0), false, type);
      result.HInstruction$2(t1, type);
      result.sourceElement = parameter;
      t1 = this.lastAddedParameter;
      t2 = this.graph;
      if (t1 == null) {
        t1 = t2.entry;
        t1.addBefore$2(t1.first, result);
      } else
        t2.entry.addAfter$2(t1, result);
      this.lastAddedParameter = result;
      return result;
    },
    setupStateForInlining$2: function($function, compiledArguments) {
      var t1, t2, t3, t4, signature, enclosing;
      t1 = {};
      t2 = new B.LocalsHandler0(P.LinkedHashMap_LinkedHashMap(null, null, null, O.Local, B.HInstruction), P.LinkedHashMap_LinkedHashMap(null, null, null, O.Local, Q.CapturedVariable), this, null, P.LinkedHashMap_LinkedHashMap(null, null, null, V.TypeVariableType, Q.TypeVariableLocal), $function);
      this.localsHandler = t2;
      t3 = this.compiler;
      t2.closureData = t3.closureToClassMapper.computeClosureToClassMapping$3($function, $function.get$node(), this.elements);
      t2 = new B.SyntheticLocal("result", $function);
      this.returnLocal = t2;
      this.localsHandler.updateLocal$2(t2, this.graph.addConstant$2(t3.backend.get$constantSystem().createNull$0(), t3));
      this.inTryStatement = false;
      t1.argumentIndex_0 = 0;
      if ($function.get$isInstanceMember()) {
        t2 = this.localsHandler;
        t3 = t2.closureData.thisLocal;
        t4 = t1.argumentIndex_0++;
        if (t4 >= compiledArguments.length)
          return H.ioore(compiledArguments, t4);
        t2.updateLocal$2(t3, compiledArguments[t4]);
      }
      signature = $function.get$functionSignature();
      signature.orderedForEachParameter$1(new B.SsaBuilder_setupStateForInlining_closure(t1, this, compiledArguments));
      enclosing = $function.get$enclosingClass();
      t2 = $function.kind;
      if (t2 === C.ElementKind_generative_constructor_16 || $function.get$isFactoryConstructor() || t2 === C.ElementKind_generative_constructor_body_0) {
        t2 = this.backend;
        t2 = t2.rti.classesNeedingRti.contains$1(0, enclosing.get$declaration()) || t2.compiler.enabledRuntimeType;
      } else
        t2 = false;
      if (t2)
        H.IterableMixinWorkaround_forEach(enclosing.get$typeVariables(), new B.SsaBuilder_setupStateForInlining_closure0(t1, this, compiledArguments));
      this.elements = $function.get$resolvedAst().elements;
      this.returnType = signature.type.returnType;
      this.stack = H.setRuntimeTypeInfo([], [B.HInstruction]);
      this.insertTraceCall$1($function);
    },
    potentiallyCheckInlinedParameterTypes$1: function($function) {
      if (!this.compiler.enableTypeAssertions)
        return;
      $function.get$functionSignature().orderedForEachParameter$1(new B.SsaBuilder_potentiallyCheckInlinedParameterTypes_closure(this));
    },
    inlineSuperOrRedirect$5: function(callee, compiledArguments, constructors, fieldValues, caller) {
      var t1 = {};
      t1.callee_1 = callee;
      callee = callee.get$implementation(callee);
      t1.callee_1 = callee;
      this.compiler.withCurrentElement$2(callee, new B.SsaBuilder_inlineSuperOrRedirect_closure(t1, this, compiledArguments, constructors, fieldValues, caller));
    },
    buildInitializers$3: function($constructor, constructors, fieldValues) {
      var $arguments, t1, target, functionNode, initializers, link, foundSuperOrRedirect, $call, selector, compiledArguments, $init, t2, enclosingClass, superClass, t3;
      if ($constructor.get$isSynthesized()) {
        $arguments = H.setRuntimeTypeInfo([], [B.HInstruction]);
        t1 = $constructor.get$definingConstructor();
        target = t1.get$implementation(t1);
        t1 = this.compiler;
        if (!Z.Selector_addForwardingElementArgumentsToList($constructor, $arguments, target, new B.SsaBuilder_buildInitializers_compileArgument(this), this.get$handleConstantForOptionalParameter(), t1))
          t1.internalError$2($constructor, "forwarding constructor call does not match");
        this.inlineSuperOrRedirect$5(target, $arguments, constructors, fieldValues, $constructor);
        return;
      }
      functionNode = $constructor.get$node();
      if (functionNode.get$initializers() != null) {
        initializers = functionNode.get$initializers().nodes;
        for (link = initializers, foundSuperOrRedirect = false; !link.get$isEmpty(link); link = link.get$tail())
          if (!J.getInterceptor(link.get$head(link)).$isSendSet) {
            $call = link.get$head(link);
            this.elements.toString;
            t1 = $call.get$_secret_tree_element$_element();
            target = t1.get$implementation(t1);
            t1 = this.elements._selectors;
            selector = t1 != null ? t1.$index(0, $call) : null;
            $arguments = $call.get$argumentsNode().nodes;
            compiledArguments = [];
            compiledArguments.$builtinTypeInfo = [B.HInstruction];
            this.inlinedFrom$2($constructor, new B.SsaBuilder_buildInitializers_closure(this, target, selector, $arguments, compiledArguments));
            this.inlineSuperOrRedirect$5(target, compiledArguments, constructors, fieldValues, $constructor);
            foundSuperOrRedirect = true;
          } else {
            $init = link.get$head(link);
            this.inlinedFrom$2($constructor, new B.SsaBuilder_buildInitializers_closure0(this, $init.get$argumentsNode().nodes));
            this.elements.toString;
            t1 = $init.get$_secret_tree_element$_element();
            t2 = this.stack;
            if (0 >= t2.length)
              return H.ioore(t2, 0);
            fieldValues.$indexSet(0, t1, t2.pop());
          }
      } else
        foundSuperOrRedirect = false;
      if (!foundSuperOrRedirect) {
        enclosingClass = $constructor.get$enclosingClass();
        superClass = enclosingClass.get$superclass();
        t1 = this.compiler;
        t2 = enclosingClass.get$declaration();
        t3 = t1.objectClass;
        if (t2 == null ? t3 != null : t2 !== t3) {
          selector = Z.Selector_Selector(C.SelectorKind_call_2, "", enclosingClass.get$enclosingElement().get$library(), 0, null);
          target = superClass.lookupConstructor$1(selector);
          if (target == null)
            t1.internalError$2(superClass, "No default constructor available.");
          $arguments = H.setRuntimeTypeInfo([], [B.HInstruction]);
          selector.addArgumentsToList$6(C.C_Link3, $arguments, target.get$implementation(target), null, this.get$handleConstantForOptionalParameter(), t1);
          this.inlineSuperOrRedirect$5(target, $arguments, constructors, fieldValues, $constructor);
        }
      }
    },
    buildFieldInitializers$2: function(classElement, fieldValues) {
      classElement.forEachInstanceField$1(new B.SsaBuilder_buildFieldInitializers_closure(this, classElement, fieldValues));
    },
    buildFactory$1: function(functionElement) {
      var t1, t2, classElement, isNativeUpgradeFactory, $function, fieldValues, constructors, constructorArguments, fields, type, ssaType, t3, t4, instantiatedTypes, t5, newObject, i, t6, t7, t8, typeArguments, index, interceptor, $constructor, body, bodyCallInputs, node, parameterClosureData, currentClass, scopeData, t9, t10, t11, invoke;
      t1 = {};
      functionElement = J.get$implementation$x(functionElement);
      t2 = functionElement.get$enclosingClass();
      classElement = t2.get$implementation(t2);
      isNativeUpgradeFactory = O.Elements_isNativeOrExtendsNative(classElement);
      $function = functionElement.get$node();
      t2 = this.inliningStack;
      if (t2.length === 0)
        this.openFunction$2(functionElement, $function);
      fieldValues = P.LinkedHashMap_LinkedHashMap(null, null, null, O.Element, B.HInstruction);
      this.buildFieldInitializers$2(classElement, fieldValues);
      functionElement.get$functionSignature().orderedForEachParameter$1(new B.SsaBuilder_buildFactory_closure(this, fieldValues));
      constructors = H.setRuntimeTypeInfo([functionElement], [O.FunctionElement]);
      this.buildInitializers$3(functionElement, constructors, fieldValues);
      constructorArguments = H.setRuntimeTypeInfo([], [B.HInstruction]);
      fields = H.setRuntimeTypeInfo([], [O.Element]);
      classElement.forEachInstanceField$2$includeSuperAndInjectedMembers(new B.SsaBuilder_buildFactory_closure0(this, isNativeUpgradeFactory, fieldValues, constructorArguments, fields), true);
      type = classElement.get$thisType();
      ssaType = new B.FlatTypeMask(classElement.get$declaration(), 2);
      t3 = type != null;
      if (t3)
        this.currentInlinedInstantiations.push(type);
      t4 = this.currentInlinedInstantiations;
      instantiatedTypes = t4.length !== 0 ? P.List_List$from(t4, true, V.DartType) : null;
      if (!isNativeUpgradeFactory) {
        t5 = $.HInstruction_idCounter;
        if (typeof t5 !== "number")
          return t5.$add();
        $.HInstruction_idCounter = t5 + 1;
        newObject = new B.HForeignNew(classElement, instantiatedTypes, null, false, false, null, null, null, t5, constructorArguments, H.setRuntimeTypeInfo([], [B.HInstruction]), null, null, null, new Z.SideEffects(0), false, ssaType);
        newObject.HInstruction$2(constructorArguments, ssaType);
        newObject.HForeign$7$canThrow$effects$isStatement$nativeBehavior(null, ssaType, constructorArguments, false, null, false, null);
        this._ssa$_current.add$1(0, newObject);
      } else {
        newObject = this.graph.explicitReceiverParameter;
        t5 = B.HFieldGet$(null, newObject, this.backend.compiler.typesTask.get$dynamicType(), false);
        this._ssa$_current.add$1(0, t5);
        for (i = 0; i < fields.length; ++i) {
          t5 = fields[i];
          if (i >= constructorArguments.length)
            return H.ioore(constructorArguments, i);
          t6 = [newObject, constructorArguments[i]];
          t6.$builtinTypeInfo = [B.HInstruction];
          t7 = $.HInstruction_idCounter;
          if (typeof t7 !== "number")
            return t7.$add();
          $.HInstruction_idCounter = t7 + 1;
          t8 = [];
          t8.$builtinTypeInfo = [B.HInstruction];
          t5 = new B.HFieldSet(t5, null, null, t7, t6, t8, null, null, null, new Z.SideEffects(0), false, C.FlatTypeMask_null_0);
          t5.HInstruction$2(t6, C.FlatTypeMask_null_0);
          t6 = t5.sideEffects;
          t7 = (t6.flags & 4294967288) >>> 0;
          t6.flags = t7;
          t7 = (t7 & 4294967239) >>> 0;
          t6.flags = t7;
          t6.flags = (t7 | 2) >>> 0;
          t7 = this._ssa$_current;
          t7.internalAddAfter$2(t7.last, t5);
          t5.notifyAddedToBlock$1(t7);
        }
        isNativeUpgradeFactory = true;
      }
      if (t3) {
        if (0 >= t4.length)
          return H.ioore(t4, 0);
        t4.pop();
      }
      t3 = this.backend;
      t4 = t3.rti.classesNeedingRti;
      if (t4.contains$1(0, classElement.get$declaration()) || t3.compiler.enabledRuntimeType) {
        t1.source_0 = null;
        t1.allIndexed_1 = true;
        t1.expectedIndex_2 = 0;
        t1.contextClass_3 = null;
        t1.remainingTypeVariables_4 = null;
        typeArguments = H.setRuntimeTypeInfo([], [B.HInstruction]);
        H.IterableMixinWorkaround_forEach(classElement.get$typeVariables(), new B.SsaBuilder_buildFactory_closure1(t1, this, new B.SsaBuilder_buildFactory_isIndexedTypeArgumentGet(t1, this), typeArguments));
        t5 = t1.source_0;
        if (t5 != null && t1.allIndexed_1 && t1.remainingTypeVariables_4 === 0) {
          this.pushInvokeStatic$3(null, t3.find$2(0, t3.jsHelperLibrary, "copyTypeArguments"), [t5, newObject]);
          t1 = this.stack;
          if (0 >= t1.length)
            return H.ioore(t1, 0);
          t1.pop();
        } else
          newObject = this.callSetRuntimeTypeInfo$3(classElement, typeArguments, newObject);
      }
      for (index = constructors.length - 1, t1 = this.compiler, t5 = !isNativeUpgradeFactory, t6 = this.graph, t7 = t3.compiler, interceptor = null; index >= 0; --index) {
        if (index >= constructors.length)
          return H.ioore(constructors, index);
        $constructor = constructors[index];
        body = this.getConstructorBody$1($constructor);
        if (body == null)
          continue;
        bodyCallInputs = [];
        bodyCallInputs.$builtinTypeInfo = [B.HInstruction];
        if (isNativeUpgradeFactory) {
          if (interceptor == null)
            interceptor = t6.addConstant$2(new K.InterceptorConstant(classElement.get$thisType()), t1);
          bodyCallInputs.push(interceptor);
        }
        bodyCallInputs.push(newObject);
        node = $constructor.get$resolvedAst().node;
        parameterClosureData = t1.closureToClassMapper.getMappingForNestedFunction$1(node);
        body.get$functionSignature().orderedForEachParameter$1(new B.SsaBuilder_buildFactory_closure2(this, bodyCallInputs));
        currentClass = $constructor.get$enclosingClass();
        if (t4.contains$1(0, currentClass.get$declaration()) || t7.enabledRuntimeType)
          H.IterableMixinWorkaround_forEach(currentClass.get$typeVariables(), new B.SsaBuilder_buildFactory_closure3(this, bodyCallInputs));
        scopeData = parameterClosureData.capturingScopes.$index(0, node);
        if (scopeData != null)
          bodyCallInputs.push(this.localsHandler.readLocal$1(scopeData.get$boxElement()));
        if (t5 && this.tryInlineMethod$4(body, null, bodyCallInputs, $function)) {
          t8 = this.stack;
          if (0 >= t8.length)
            return H.ioore(t8, 0);
          t8.pop();
        } else {
          t8 = body.get$declaration();
          t9 = t3.nonNullType;
          t10 = $.HInstruction_idCounter;
          if (typeof t10 !== "number")
            return t10.$add();
          $.HInstruction_idCounter = t10 + 1;
          t11 = [];
          t11.$builtinTypeInfo = [B.HInstruction];
          invoke = new B.HInvokeConstructorBody(t8, true, null, null, null, t10, bodyCallInputs, t11, null, null, null, new Z.SideEffects(0), false, t9);
          invoke.HInstruction$2(bodyCallInputs, t9);
          t8 = invoke.sideEffects;
          t9 = (t8.flags | 7) >>> 0;
          t8.flags = t9;
          t8.flags = (t9 | 56) >>> 0;
          invoke.sideEffects = t1.world.getSideEffectsOfElement$1($constructor);
          t9 = this._ssa$_current;
          t9.internalAddAfter$2(t9.last, invoke);
          invoke.notifyAddedToBlock$1(t9);
        }
      }
      if (t2.length === 0) {
        t1 = H.setRuntimeTypeInfo([newObject], [B.HInstruction]);
        t2 = $.HInstruction_idCounter;
        if (typeof t2 !== "number")
          return t2.$add();
        $.HInstruction_idCounter = t2 + 1;
        t2 = new B.HReturn(null, null, t2, t1, H.setRuntimeTypeInfo([], [B.HInstruction]), null, null, null, new Z.SideEffects(0), false, C.FlatTypeMask_null_0);
        t2.HInstruction$2(t1, C.FlatTypeMask_null_0);
        this.closeAndGotoExit$1(t2);
        return this.closeFunction$0();
      } else {
        this.localsHandler.updateLocal$2(this.returnLocal, newObject);
        return;
      }
    },
    openFunction$2: function(element, node) {
      var t1, block, enclosing, signature;
      t1 = this.graph;
      block = t1.addNewBlock$0();
      t1 = t1.entry;
      t1.status = 1;
      this.isReachable = t1 != null;
      this._ssa$_current = t1;
      this.lastOpenedBlock = t1;
      this.localsHandler.startFunction$2(element, node);
      t1 = $.HInstruction_idCounter;
      if (typeof t1 !== "number")
        return t1.$add();
      $.HInstruction_idCounter = t1 + 1;
      t1 = new B.HGoto(null, null, t1, C.List_empty12, H.setRuntimeTypeInfo([], [B.HInstruction]), null, null, null, new Z.SideEffects(0), false, C.FlatTypeMask_null_0);
      t1.HInstruction$2(C.List_empty12, C.FlatTypeMask_null_0);
      this.close$1(0, t1).addSuccessor$1(block);
      block.status = 1;
      this.isReachable = true;
      this._ssa$_current = block;
      this.lastOpenedBlock = block;
      enclosing = element.get$enclosingElement();
      if (element.get$kind(element) === C.ElementKind_generative_constructor_16 || element.get$isFactoryConstructor() || element.get$kind(element) === C.ElementKind_generative_constructor_body_0) {
        t1 = this.backend;
        t1 = t1.rti.classesNeedingRti.contains$1(0, enclosing.get$declaration()) || t1.compiler.enabledRuntimeType;
      } else
        t1 = false;
      if (t1)
        H.IterableMixinWorkaround_forEach(enclosing.get$typeVariables(), new B.SsaBuilder_openFunction_closure(this));
      if (!!element.$isFunctionElement) {
        signature = element.get$functionSignature();
        signature.orderedForEachParameter$1(new B.SsaBuilder_openFunction_closure0(this, element, this.localsHandler.closureData.capturingScopes.$index(0, node)));
        this.returnType = signature.type.returnType;
      }
      this.insertTraceCall$1(element);
    },
    insertTraceCall$1: function(element) {
    },
    buildTypeConversion$3: function(original, type, kind) {
      var t1, representations, $name, t2;
      if (type == null)
        return original;
      t1 = this.compiler;
      type = type.unalias$1(t1);
      if (type.get$kind(type) === C.TypeKind_interface && !type.get$treatAsRaw()) {
        t1 = type.get$element();
        representations = this.buildTypeArgumentRepresentations$1(type);
        this._ssa$_current.add$1(0, representations);
        return B.HTypeConversion$withTypeRepresentation(type, kind, new B.FlatTypeMask(t1, 7), original, representations);
      } else if (type.get$kind(type) === C.TypeKind_kuk)
        return B.HTypeConversion$withTypeRepresentation(type, kind, original.instructionType, original, this.addTypeVariableReference$1(type));
      else if (type.get$kind(type) === C.TypeKind_function) {
        $name = kind === 2 ? "_asCheck" : "_assertCheck";
        new B.TypeBuilder().visitFunctionType$2(type, this);
        t1 = this.stack;
        if (0 >= t1.length)
          return H.ioore(t1, 0);
        t1 = t1.pop();
        this.pushInvokeDynamic$3(null, Z.Selector_Selector(C.SelectorKind_call_2, $name, this.backend.jsHelperLibrary, 1, null), [t1, original]);
        t1 = original.instructionType;
        t2 = this.stack;
        if (0 >= t2.length)
          return H.ioore(t2, 0);
        return B.HTypeConversion$(type, kind, t1, t2.pop(), null);
      } else
        return original.convertType$3(t1, type, kind);
    },
    potentiallyCheckType$3$kind: function(original, type, kind) {
      var other, t1, t2;
      if (!this.compiler.enableTypeAssertions)
        return original;
      type = this.localsHandler.substInContext$1(type);
      other = this.buildTypeConversion$3(original, type, kind);
      if (other == null ? original != null : other !== original)
        this._ssa$_current.add$1(0, other);
      t1 = this.work.registry;
      t2 = t1.compiler;
      t2.enqueuer.codegen.registerIsCheck$2(type, t1);
      t2.backend.registerIsCheckForCodegen$3(type, t2.enqueuer.codegen, t1);
      return other;
    },
    potentiallyCheckType$2: function(original, type) {
      return this.potentiallyCheckType$3$kind(original, type, 0);
    },
    closeFunction$0: function() {
      var t1, t2, t3;
      if (this._ssa$_current != null) {
        t1 = $.HInstruction_idCounter;
        if (typeof t1 !== "number")
          return t1.$add();
        $.HInstruction_idCounter = t1 + 1;
        t1 = new B.HGoto(null, null, t1, C.List_empty12, H.setRuntimeTypeInfo([], [B.HInstruction]), null, null, null, new Z.SideEffects(0), false, C.FlatTypeMask_null_0);
        t1.HInstruction$2(C.List_empty12, C.FlatTypeMask_null_0);
        this.closeAndGotoExit$1(t1);
      }
      t1 = this.graph;
      t1.addBlock$1(t1.exit);
      t2 = t1.exit;
      t2.status = 1;
      t3 = $.HInstruction_idCounter;
      if (typeof t3 !== "number")
        return t3.$add();
      $.HInstruction_idCounter = t3 + 1;
      t3 = new B.HExit(null, null, t3, C.List_empty12, H.setRuntimeTypeInfo([], [B.HInstruction]), null, null, null, new Z.SideEffects(0), false, C.FlatTypeMask_null_0);
      t3.HInstruction$2(C.List_empty12, C.FlatTypeMask_null_0);
      t2.close$1(0, t3);
      t1.assignDominators$0();
      return t1;
    },
    popBoolified$0: function() {
      var t1, value, t2, t3, result;
      t1 = this.stack;
      if (0 >= t1.length)
        return H.ioore(t1, 0);
      value = t1.pop();
      t1 = this.compiler;
      if (t1.enableTypeAssertions)
        return this.potentiallyCheckType$3$kind(value, t1.boolClass.get$rawType(), 3);
      t1 = this.backend.compiler.typesTask.get$boolType();
      t2 = H.setRuntimeTypeInfo([value], [B.HInstruction]);
      t3 = $.HInstruction_idCounter;
      if (typeof t3 !== "number")
        return t3.$add();
      $.HInstruction_idCounter = t3 + 1;
      result = new B.HBoolify(null, null, t3, t2, H.setRuntimeTypeInfo([], [B.HInstruction]), null, null, null, new Z.SideEffects(0), false, t1);
      result.HInstruction$2(t2, t1);
      result._useGvn = true;
      this._ssa$_current.add$1(0, result);
      return result;
    },
    attachPosition$2: function(target, node) {
      if (node != null)
        target.sourcePosition = this.sourceFileLocationForToken$2(node, node.getBeginToken$0());
      return target;
    },
    sourceFileLocationForToken$2: function(node, token) {
      var t1, t2, sourceFile, $location;
      t1 = this.sourceElementStack;
      t2 = J.getInterceptor$ax(t1);
      sourceFile = J.get$implementation$x(t2.get$last(t1)).get$compilationUnit().get$script().file;
      $location = new T.TokenSourceFileLocation(token, J.get$name$x(t2.get$last(t1)), sourceFile, null);
      t1 = token.charOffset;
      if ($location.get$offset($location) >= sourceFile.get$length(sourceFile))
        H.throwExpression(C.MessageKind_tMf.message$1(0, P.LinkedHashMap_LinkedHashMap$_literal(["offset", t1, "fileName", sourceFile.filename, "length", sourceFile.get$length(sourceFile)], null, null)));
      return $location;
    },
    visitBlock$1: function(node) {
      var link, t1;
      if (!this.isReachable)
        return;
      for (link = node.statements.nodes; !link.get$isEmpty(link); link = link.get$tail()) {
        t1 = link.get$head(link);
        if (t1 != null)
          J.accept$1$x(t1, this);
        if (!this.isReachable) {
          if (this.stack.length !== 0)
            this.compiler.internalError$2(node, "Non-empty instruction stack.");
          return;
        }
      }
      if (this.stack.length !== 0)
        this.compiler.internalError$2(node, "Non-empty instruction stack.");
    },
    visitClassNode$1: function(node) {
      this.compiler.internalError$2(node, "SsaBuilder.visitClassNode should not be called.");
    },
    visitThrowExpression$1: function(expression) {
      var old, t1;
      old = this.inExpressionOfThrow;
      try {
        this.inExpressionOfThrow = true;
        t1 = expression;
        if (t1 != null)
          J.accept$1$x(t1, this);
      } finally {
        this.inExpressionOfThrow = old;
      }
    },
    visitExpressionStatement$1: function(node) {
      var t1, throwExpression, t2;
      if (!this.isReachable)
        return;
      t1 = node.expression;
      throwExpression = t1.asThrow$0();
      if (throwExpression != null && this.inliningStack.length === 0) {
        this.visitThrowExpression$1(throwExpression.expression);
        this.handleInTryStatement$0();
        t1 = this.stack;
        if (0 >= t1.length)
          return H.ioore(t1, 0);
        t1 = H.setRuntimeTypeInfo([t1.pop()], [B.HInstruction]);
        t2 = $.HInstruction_idCounter;
        if (typeof t2 !== "number")
          return t2.$add();
        $.HInstruction_idCounter = t2 + 1;
        t2 = new B.HThrow(false, null, null, t2, t1, H.setRuntimeTypeInfo([], [B.HInstruction]), null, null, null, new Z.SideEffects(0), false, C.FlatTypeMask_null_0);
        t2.HInstruction$2(t1, C.FlatTypeMask_null_0);
        this.closeAndGotoExit$1(t2);
      } else {
        t1.accept$1(0, this);
        t1 = this.stack;
        if (0 >= t1.length)
          return H.ioore(t1, 0);
        t1.pop();
      }
    },
    beginLoopHeader$1: function(node) {
      var t1, previousBlock, jumpHandler, t2, result;
      t1 = $.HInstruction_idCounter;
      if (typeof t1 !== "number")
        return t1.$add();
      $.HInstruction_idCounter = t1 + 1;
      t1 = new B.HGoto(null, null, t1, C.List_empty12, H.setRuntimeTypeInfo([], [B.HInstruction]), null, null, null, new Z.SideEffects(0), false, C.FlatTypeMask_null_0);
      t1.HInstruction$2(C.List_empty12, C.FlatTypeMask_null_0);
      previousBlock = this.close$1(0, t1);
      jumpHandler = this.createJumpHandler$2$isLoopJump(node, true);
      t1 = jumpHandler.get$target(jumpHandler);
      t2 = jumpHandler.labels$0(0);
      result = this.graph.addNewBlock$0();
      result.loopInformation = new B.HLoopInformation(result, H.setRuntimeTypeInfo([], [B.HBasicBlock]), H.setRuntimeTypeInfo([], [B.HBasicBlock]), t2, t1, null);
      previousBlock.addSuccessor$1(result);
      result.status = 1;
      this.isReachable = true;
      this._ssa$_current = result;
      this.lastOpenedBlock = result;
      this.localsHandler.beginLoopHeader$1(result);
      return jumpHandler;
    },
    endLoop$4: function(loopEntry, branchExitBlock, jumpHandler, savedLocals) {
      var block, breakHandlers, t1;
      block = this.graph.addNewBlock$0();
      breakHandlers = H.setRuntimeTypeInfo([], [B.LocalsHandler0]);
      jumpHandler.forEachBreak$1(new B.SsaBuilder_endLoop_closure(block, breakHandlers));
      t1 = branchExitBlock != null;
      if (t1)
        branchExitBlock.addSuccessor$1(block);
      this.localsHandler.endLoop$1(loopEntry);
      block.status = 1;
      this.isReachable = true;
      this._ssa$_current = block;
      this.lastOpenedBlock = block;
      if (breakHandlers.length !== 0) {
        if (t1)
          breakHandlers.push(savedLocals);
        this.localsHandler = savedLocals.mergeMultiple$2(breakHandlers, block);
      } else
        this.localsHandler = savedLocals;
    },
    wrapStatementGraph$1: function(statements) {
      if (statements == null)
        return;
      return new B.HSubGraphBlockInformation(statements);
    },
    wrapExpressionGraph$1: function(expression) {
      if (expression == null)
        return;
      return new B.HSubExpressionBlockInformation(expression);
    },
    handleLoop$5: function(loop, initialize, condition, update, body) {
      var initializerBlock, initializerGraph, startBlock, jumpHandler, t1, loopInfo, t2, t3, conditionEndBlock, conditionExpression, savedLocals, block, bodyGraph, bodyBlock, loopIsDegenerate, t4, block0, continueHandlers, labels, target, updateEndBlock, t5, t6, info, label;
      this.localsHandler.startLoop$1(loop);
      initializerBlock = this.openNewBlock$0();
      initialize.call$0();
      initializerGraph = new B.SubExpression(initializerBlock, this._ssa$_current);
      startBlock = initializerBlock;
      ++this.loopNesting;
      jumpHandler = this.beginLoopHeader$1(loop);
      t1 = this._ssa$_current;
      loopInfo = t1.loopInformation;
      t2 = H.setRuntimeTypeInfo([condition.call$0()], [B.HInstruction]);
      t3 = $.HInstruction_idCounter;
      if (typeof t3 !== "number")
        return t3.$add();
      $.HInstruction_idCounter = t3 + 1;
      t3 = new B.HLoopBranch(0, null, null, t3, t2, H.setRuntimeTypeInfo([], [B.HInstruction]), null, null, null, new Z.SideEffects(0), false, C.FlatTypeMask_null_0);
      t3.HInstruction$2(t2, C.FlatTypeMask_null_0);
      conditionEndBlock = this.close$1(0, t3);
      conditionExpression = new B.SubExpression(t1, conditionEndBlock);
      savedLocals = B.LocalsHandler$from0(this.localsHandler);
      t3 = this.graph;
      block = t3.addNewBlock$0();
      conditionEndBlock.addSuccessor$1(block);
      block.status = 1;
      this.isReachable = true;
      this._ssa$_current = block;
      this.lastOpenedBlock = block;
      this.localsHandler.enterLoopBody$1(loop);
      body.call$0();
      bodyGraph = new B.SubGraph(block, this.lastOpenedBlock);
      bodyBlock = this._ssa$_current;
      loopIsDegenerate = bodyBlock == null;
      t2 = !loopIsDegenerate;
      if (t2) {
        t4 = $.HInstruction_idCounter;
        if (typeof t4 !== "number")
          return t4.$add();
        $.HInstruction_idCounter = t4 + 1;
        t4 = new B.HGoto(null, null, t4, C.List_empty12, H.setRuntimeTypeInfo([], [B.HInstruction]), null, null, null, new Z.SideEffects(0), false, C.FlatTypeMask_null_0);
        t4.HInstruction$2(C.List_empty12, C.FlatTypeMask_null_0);
        this.close$1(0, t4);
      }
      if (!(!jumpHandler.hasAnyContinue$0() && loopIsDegenerate)) {
        block0 = t3.addNewBlock$0();
        continueHandlers = H.setRuntimeTypeInfo([], [B.LocalsHandler0]);
        jumpHandler.forEachContinue$1(new B.SsaBuilder_handleLoop_closure(block0, continueHandlers));
        if (t2) {
          continueHandlers.push(this.localsHandler);
          bodyBlock.addSuccessor$1(block0);
        }
        block0.status = 1;
        this.isReachable = true;
        this._ssa$_current = block0;
        this.lastOpenedBlock = block0;
        if (0 >= continueHandlers.length)
          return H.ioore(continueHandlers, 0);
        this.localsHandler = continueHandlers[0].mergeMultiple$2(continueHandlers, block0);
        labels = jumpHandler.labels$0(0);
        t2 = this.elements._definedTargets;
        target = t2 != null ? t2.$index(0, loop) : null;
        if (labels.length !== 0) {
          t2 = jumpHandler.labels$0(0);
          if (0 >= t2.length)
            return H.ioore(t2, 0);
          block.blockFlow = new B.HBlockFlow(new B.HLabeledBlockInformation(new B.HSubGraphBlockInformation(bodyGraph), t2, J.get$target$x(t2[0]), true), block0);
        } else if (target != null && target.get$isContinueTarget())
          block.blockFlow = new B.HBlockFlow(new B.HLabeledBlockInformation(new B.HSubGraphBlockInformation(bodyGraph), C.List_empty14, target, true), block0);
        this.localsHandler.enterLoopUpdates$1(loop);
        update.call$0();
        t2 = $.HInstruction_idCounter;
        if (typeof t2 !== "number")
          return t2.$add();
        $.HInstruction_idCounter = t2 + 1;
        t2 = new B.HGoto(null, null, t2, C.List_empty12, H.setRuntimeTypeInfo([], [B.HInstruction]), null, null, null, new Z.SideEffects(0), false, C.FlatTypeMask_null_0);
        t2.HInstruction$2(C.List_empty12, C.FlatTypeMask_null_0);
        updateEndBlock = this.close$1(0, t2);
        updateEndBlock.addSuccessor$1(t1);
        block = t3.addNewBlock$0();
        block.status = 1;
        this.isReachable = true;
        this._ssa$_current = block;
        this.lastOpenedBlock = block;
        t3 = $.HInstruction_idCounter;
        if (typeof t3 !== "number")
          return t3.$add();
        $.HInstruction_idCounter = t3 + 1;
        t3 = new B.HGoto(null, null, t3, C.List_empty12, H.setRuntimeTypeInfo([], [B.HInstruction]), null, null, null, new Z.SideEffects(0), false, C.FlatTypeMask_null_0);
        t3.HInstruction$2(C.List_empty12, C.FlatTypeMask_null_0);
        this.close$1(0, t3);
        conditionEndBlock.addSuccessor$1(block);
        this.endLoop$4(t1, block, jumpHandler, savedLocals);
        t1.postProcessLoopHeader$0();
        t3 = loop.accept$1(0, C.C_LoopTypeVisitor);
        t2 = this.wrapExpressionGraph$1(initializerGraph);
        t4 = this.wrapExpressionGraph$1(conditionExpression);
        t5 = this.wrapStatementGraph$1(bodyGraph);
        t6 = this.wrapExpressionGraph$1(new B.SubExpression(block0, updateEndBlock));
        t1 = t1.loopInformation;
        info = new B.HLoopBlockInformation(t3, t2, t4, t5, t6, t1.target, t1.labels, this.sourceFileLocationForToken$2(loop, loop.getBeginToken$0()), this.sourceFileLocationForToken$2(loop, loop.getEndToken$0()));
        startBlock.blockFlow = new B.HBlockFlow(info, this._ssa$_current);
        loopInfo.loopBlockInformation = info;
      } else {
        block = t3.addNewBlock$0();
        block.status = 1;
        this.isReachable = true;
        this._ssa$_current = block;
        this.lastOpenedBlock = block;
        t2 = $.HInstruction_idCounter;
        if (typeof t2 !== "number")
          return t2.$add();
        $.HInstruction_idCounter = t2 + 1;
        t2 = new B.HGoto(null, null, t2, C.List_empty12, H.setRuntimeTypeInfo([], [B.HInstruction]), null, null, null, new Z.SideEffects(0), false, C.FlatTypeMask_null_0);
        t2.HInstruction$2(C.List_empty12, C.FlatTypeMask_null_0);
        this.close$1(0, t2);
        this.endLoop$4(t1, block, jumpHandler, savedLocals);
        t1.loopInformation = null;
        t2 = conditionEndBlock.last.inputs;
        if (0 >= t2.length)
          return H.ioore(t2, 0);
        t2 = H.setRuntimeTypeInfo([t2[0]], [B.HInstruction]);
        t3 = $.HInstruction_idCounter;
        if (typeof t3 !== "number")
          return t3.$add();
        $.HInstruction_idCounter = t3 + 1;
        t3 = new B.HIf(null, null, null, t3, t2, H.setRuntimeTypeInfo([], [B.HInstruction]), null, null, null, new Z.SideEffects(0), false, C.FlatTypeMask_null_0);
        t3.HInstruction$2(t2, C.FlatTypeMask_null_0);
        conditionEndBlock.addAtExit$1(t3);
        conditionEndBlock.addSuccessor$1(block);
        conditionEndBlock.remove$1(0, conditionEndBlock.last);
        t3 = new B.HBlockFlow(new B.HIfBlockInformation(this.wrapExpressionGraph$1(conditionExpression), this.wrapStatementGraph$1(bodyGraph), this.wrapStatementGraph$1(new B.SubGraph(block, block))), this._ssa$_current);
        conditionEndBlock.blockFlow = t3;
        conditionEndBlock.last.set$blockInformation(t3);
        if (jumpHandler.hasAnyBreak$0()) {
          t2 = this.elements._definedTargets;
          label = (t2 != null ? t2.$index(0, loop) : null).addLabel$2(null, "loop");
          label.isBreakTarget = true;
          label.target.isBreakTarget = true;
          t2 = this._ssa$_current;
          t3 = H.setRuntimeTypeInfo([label], [O.LabelDefinition]);
          t1.blockFlow = new B.HBlockFlow(new B.HLabeledBlockInformation(new B.HSubGraphBlockInformation(new B.SubGraph(t1, t2)), t3, t3[0].target, false), this._ssa$_current);
          jumpHandler.forEachBreak$1(new B.SsaBuilder_handleLoop_closure0(label));
        }
      }
      jumpHandler.close$0(0);
      --this.loopNesting;
    },
    visitFor$1: function(node) {
      this.handleLoop$5(node, new B.SsaBuilder_visitFor_buildInitializer(this, node), new B.SsaBuilder_visitFor_buildCondition(this, node), new B.SsaBuilder_visitFor_buildUpdate(this, node), new B.SsaBuilder_visitFor_buildBody(this, node));
    },
    visitWhile$1: function(node) {
      this.handleLoop$5(node, new B.SsaBuilder_visitWhile_closure(), new B.SsaBuilder_visitWhile_buildCondition(this, node), new B.SsaBuilder_visitWhile_closure0(), new B.SsaBuilder_visitWhile_closure1(this, node));
    },
    visitDoWhile$1: function(node) {
      var savedLocals, jumpHandler, bodyEntryBlock, loopInfo, t1, target, hasContinues, bodyEntryBlock0, bodyExitBlock, isAbortingBody, block, continueHandlers, t2, labels, bodyInfo, info, t3, conditionEndBlock, block0, loopBlockInfo, label;
      savedLocals = B.LocalsHandler$from0(this.localsHandler);
      this.localsHandler.startLoop$1(node);
      ++this.loopNesting;
      jumpHandler = this.beginLoopHeader$1(node);
      bodyEntryBlock = this._ssa$_current;
      loopInfo = bodyEntryBlock.loopInformation;
      t1 = this.elements._definedTargets;
      target = t1 != null ? t1.$index(0, node) : null;
      hasContinues = target != null && target.get$isContinueTarget();
      bodyEntryBlock0 = hasContinues ? this.openNewBlock$0() : bodyEntryBlock;
      this.localsHandler.enterLoopBody$1(node);
      t1 = node.body;
      if (t1 != null)
        t1.accept$1(0, this);
      if (this._ssa$_current != null) {
        t1 = $.HInstruction_idCounter;
        if (typeof t1 !== "number")
          return t1.$add();
        $.HInstruction_idCounter = t1 + 1;
        t1 = new B.HGoto(null, null, t1, C.List_empty12, H.setRuntimeTypeInfo([], [B.HInstruction]), null, null, null, new Z.SideEffects(0), false, C.FlatTypeMask_null_0);
        t1.HInstruction$2(C.List_empty12, C.FlatTypeMask_null_0);
        bodyExitBlock = this.close$1(0, t1);
        isAbortingBody = false;
      } else {
        bodyExitBlock = this.lastOpenedBlock;
        isAbortingBody = true;
      }
      if (!(isAbortingBody && !hasContinues)) {
        t1 = this.graph;
        block = t1.addNewBlock$0();
        continueHandlers = H.setRuntimeTypeInfo([], [B.LocalsHandler0]);
        jumpHandler.forEachContinue$1(new B.SsaBuilder_visitDoWhile_closure(block, continueHandlers));
        t2 = !isAbortingBody;
        if (t2)
          bodyExitBlock.addSuccessor$1(block);
        if (continueHandlers.length !== 0) {
          if (t2)
            continueHandlers.push(this.localsHandler);
          this.localsHandler = savedLocals.mergeMultiple$2(continueHandlers, block);
          labels = jumpHandler.labels$0(0);
          bodyInfo = new B.HSubGraphBlockInformation(new B.SubGraph(bodyEntryBlock0, bodyExitBlock));
          t2 = labels.length;
          if (t2 !== 0) {
            if (0 >= t2)
              return H.ioore(labels, 0);
            info = new B.HLabeledBlockInformation(bodyInfo, labels, J.get$target$x(labels[0]), true);
          } else
            info = new B.HLabeledBlockInformation(bodyInfo, C.List_empty14, target, true);
          bodyEntryBlock0.blockFlow = new B.HBlockFlow(info, block);
        }
        block.status = 1;
        this.isReachable = true;
        this._ssa$_current = block;
        this.lastOpenedBlock = block;
        t2 = node.condition;
        if (t2 != null)
          t2.accept$1(0, this);
        t2 = H.setRuntimeTypeInfo([this.popBoolified$0()], [B.HInstruction]);
        t3 = $.HInstruction_idCounter;
        if (typeof t3 !== "number")
          return t3.$add();
        $.HInstruction_idCounter = t3 + 1;
        t3 = new B.HLoopBranch(1, null, null, t3, t2, H.setRuntimeTypeInfo([], [B.HInstruction]), null, null, null, new Z.SideEffects(0), false, C.FlatTypeMask_null_0);
        t3.HInstruction$2(t2, C.FlatTypeMask_null_0);
        conditionEndBlock = this.close$1(0, t3);
        block0 = t1.addNewBlock$0();
        conditionEndBlock.addSuccessor$1(block0);
        block0.status = 1;
        this.isReachable = true;
        this._ssa$_current = block0;
        this.lastOpenedBlock = block0;
        t3 = $.HInstruction_idCounter;
        if (typeof t3 !== "number")
          return t3.$add();
        $.HInstruction_idCounter = t3 + 1;
        t3 = new B.HGoto(null, null, t3, C.List_empty12, H.setRuntimeTypeInfo([], [B.HInstruction]), null, null, null, new Z.SideEffects(0), false, C.FlatTypeMask_null_0);
        t3.HInstruction$2(C.List_empty12, C.FlatTypeMask_null_0);
        this.close$1(0, t3);
        block0.addSuccessor$1(bodyEntryBlock);
        block0 = t1.addNewBlock$0();
        block0.status = 1;
        this.isReachable = true;
        this._ssa$_current = block0;
        this.lastOpenedBlock = block0;
        t1 = $.HInstruction_idCounter;
        if (typeof t1 !== "number")
          return t1.$add();
        $.HInstruction_idCounter = t1 + 1;
        t1 = new B.HGoto(null, null, t1, C.List_empty12, H.setRuntimeTypeInfo([], [B.HInstruction]), null, null, null, new Z.SideEffects(0), false, C.FlatTypeMask_null_0);
        t1.HInstruction$2(C.List_empty12, C.FlatTypeMask_null_0);
        this.close$1(0, t1);
        conditionEndBlock.addSuccessor$1(block0);
        this.endLoop$4(bodyEntryBlock, block0, jumpHandler, this.localsHandler);
        bodyEntryBlock.postProcessLoopHeader$0();
        t1 = this.wrapExpressionGraph$1(new B.SubExpression(block, conditionEndBlock));
        t3 = this.wrapStatementGraph$1(new B.SubGraph(bodyEntryBlock, bodyExitBlock));
        t2 = bodyEntryBlock.loopInformation;
        loopBlockInfo = new B.HLoopBlockInformation(2, null, t1, t3, null, t2.target, t2.labels, this.sourceFileLocationForToken$2(node, node.getBeginToken$0()), this.sourceFileLocationForToken$2(node, node.getEndToken$0()));
        bodyEntryBlock.blockFlow = new B.HBlockFlow(loopBlockInfo, this._ssa$_current);
        loopInfo.loopBlockInformation = loopBlockInfo;
      } else {
        bodyEntryBlock.loopInformation = null;
        if (jumpHandler.hasAnyBreak$0()) {
          this.endLoop$4(bodyEntryBlock, null, jumpHandler, this.localsHandler);
          t1 = this.elements._definedTargets;
          label = (t1 != null ? t1.$index(0, node) : null).addLabel$2(null, "loop");
          label.isBreakTarget = true;
          label.target.isBreakTarget = true;
          t1 = H.setRuntimeTypeInfo([label], [O.LabelDefinition]);
          bodyEntryBlock.blockFlow = new B.HBlockFlow(new B.HLabeledBlockInformation(new B.HSubGraphBlockInformation(new B.SubGraph(bodyEntryBlock0, bodyExitBlock)), t1, t1[0].target, false), this._ssa$_current);
          jumpHandler.forEachBreak$1(new B.SsaBuilder_visitDoWhile_closure0(label));
        }
      }
      jumpHandler.close$0(0);
      --this.loopNesting;
    },
    visitFunctionExpression$1: function(node) {
      var t1, nestedClosureData, closureClassElement, callElement, t2, t3, t4, capturedVariables, type, methodElement;
      t1 = this.compiler;
      nestedClosureData = t1.closureToClassMapper.getMappingForNestedFunction$1(node);
      closureClassElement = nestedClosureData.closureClassElement;
      callElement = nestedClosureData.callElement;
      t2 = this.work;
      t2.registry.compiler.enqueuer.codegen.registerStaticUse$1(callElement);
      t3 = t2.registry;
      t4 = t3.compiler.enqueuer.codegen;
      closureClassElement.ensureResolved$1(t4.compiler);
      t4.registerInstantiatedType$3$mirrorUsage(closureClassElement.rawType, t3, false);
      capturedVariables = H.setRuntimeTypeInfo([], [B.HInstruction]);
      H.IterableMixinWorkaround_forEach(closureClassElement._closureFields, new B.SsaBuilder_visitFunctionExpression_closure(this, nestedClosureData, capturedVariables));
      type = new B.FlatTypeMask(t1.functionClass, 2);
      t3 = $.HInstruction_idCounter;
      if (typeof t3 !== "number")
        return t3.$add();
      $.HInstruction_idCounter = t3 + 1;
      t3 = new B.HForeignNew(closureClassElement, null, null, false, false, null, null, null, t3, capturedVariables, H.setRuntimeTypeInfo([], [B.HInstruction]), null, null, null, new Z.SideEffects(0), false, type);
      t3.HInstruction$2(capturedVariables, type);
      t3.HForeign$7$canThrow$effects$isStatement$nativeBehavior(null, type, capturedVariables, false, null, false, null);
      this._ssa$_current.add$1(0, t3);
      this.stack.push(t3);
      methodElement = nestedClosureData.closureElement;
      if (t1.backend.methodNeedsRti$1(methodElement)) {
        t1 = t2.registry;
        t2 = t1.compiler;
        t3 = t2.backend;
        t2 = t2.enqueuer.codegen;
        t3.toString;
        if (t2.get$isResolutionQueue() || t3.get$rti().methodsNeedingRti.contains$1(0, methodElement) || t3.compiler.enabledRuntimeType)
          t3.registerComputeSignature$2(t2, t1);
      }
    },
    visitFunctionDeclaration$1: function(node) {
      var t1, localFunction, t2;
      t1 = node.$function;
      if (t1 != null)
        t1.accept$1(0, this);
      this.elements.toString;
      localFunction = t1.get$_secret_tree_element$_element();
      t1 = this.localsHandler;
      t2 = this.stack;
      if (0 >= t2.length)
        return H.ioore(t2, 0);
      t1.updateLocal$2(localFunction, t2.pop());
    },
    visitIdentifier$1: function(node) {
      var t1 = node.token;
      if (t1.get$value(t1) === "this")
        this.stack.push(this.localsHandler.readThis$0());
      else
        this.compiler.internalError$2(node, "SsaFromAstMixin.visitIdentifier on non-this.");
    },
    visitIf$1: function(node) {
      var t1 = node.get$elsePart() != null ? new B.SsaBuilder_visitIf_closure(this, node) : null;
      new B.SsaBranchBuilder(this, node).handleIf$3(new B.SsaBuilder_visitIf_closure0(this, node), new B.SsaBuilder_visitIf_closure1(this, node), t1);
    },
    visitLogicalAndOr$2: function(node, op) {
      var t1 = op.token;
      new B.SsaBranchBuilder(this, node).handleLogicalAndOrWithLeftNode$3$isAnd(node.receiver, new B.SsaBuilder_visitLogicalAndOr_closure(this, node), "&&" === t1.get$value(t1));
    },
    visitUnary$2: function(node, op) {
      var t1, operand, folded;
      t1 = node.receiver;
      if (t1 != null)
        t1.accept$1(0, this);
      t1 = this.stack;
      if (0 >= t1.length)
        return H.ioore(t1, 0);
      operand = t1.pop();
      if (!!J.getInterceptor(operand).$isHConstant) {
        t1 = op.token;
        folded = this.constantSystem.lookupUnary$1(t1.get$value(t1)).fold$1(0, operand.constant);
        if (folded != null) {
          this.stack.push(this.graph.addConstant$2(folded, this.compiler));
          return;
        }
      }
      t1 = this.elements._selectors;
      t1 = t1 != null ? t1.$index(0, node) : null;
      this.pushInvokeDynamic$3(node, t1, [operand]);
    },
    visitBinary$5: function(left, op, right, selector, send) {
      var t1, t2, t3, t4, eq;
      t1 = op.token;
      switch (t1.get$value(t1)) {
        case "===":
          t1 = this.backend.compiler.typesTask.get$boolType();
          t2 = H.setRuntimeTypeInfo([left, right], [B.HInstruction]);
          t3 = $.HInstruction_idCounter;
          if (typeof t3 !== "number")
            return t3.$add();
          $.HInstruction_idCounter = t3 + 1;
          t3 = new B.HIdentity(null, false, null, null, null, t3, t2, H.setRuntimeTypeInfo([], [B.HInstruction]), null, null, null, new Z.SideEffects(0), false, t1);
          t3.HInstruction$2(t2, t1);
          t3.HInvokeBinary$4(left, right, null, t1);
          t3 = this.attachPosition$2(t3, op);
          this._ssa$_current.add$1(0, t3);
          this.stack.push(t3);
          return;
        case "!==":
          t1 = this.backend.compiler;
          t2 = t1.typesTask.get$boolType();
          t3 = H.setRuntimeTypeInfo([left, right], [B.HInstruction]);
          t4 = $.HInstruction_idCounter;
          if (typeof t4 !== "number")
            return t4.$add();
          $.HInstruction_idCounter = t4 + 1;
          eq = new B.HIdentity(null, false, null, null, null, t4, t3, H.setRuntimeTypeInfo([], [B.HInstruction]), null, null, null, new Z.SideEffects(0), false, t2);
          eq.HInstruction$2(t3, t2);
          eq.HInvokeBinary$4(left, right, null, t2);
          this._ssa$_current.add$1(0, eq);
          t1 = t1.typesTask.get$boolType();
          t2 = H.setRuntimeTypeInfo([eq], [B.HInstruction]);
          t3 = $.HInstruction_idCounter;
          if (typeof t3 !== "number")
            return t3.$add();
          $.HInstruction_idCounter = t3 + 1;
          t3 = new B.HNot(null, null, t3, t2, H.setRuntimeTypeInfo([], [B.HInstruction]), null, null, null, new Z.SideEffects(0), false, t1);
          t3.HInstruction$2(t2, t1);
          t3._useGvn = true;
          t3 = this.attachPosition$2(t3, op);
          this._ssa$_current.add$1(0, t3);
          this.stack.push(t3);
          return;
      }
      this.pushInvokeDynamic$4$location(send, selector, [left, right], op);
      if (t1.get$value(t1) === "!=") {
        t1 = this.popBoolified$0();
        t2 = this.backend.compiler.typesTask.get$boolType();
        t1 = H.setRuntimeTypeInfo([t1], [B.HInstruction]);
        t3 = $.HInstruction_idCounter;
        if (typeof t3 !== "number")
          return t3.$add();
        $.HInstruction_idCounter = t3 + 1;
        t3 = new B.HNot(null, null, t3, t1, H.setRuntimeTypeInfo([], [B.HInstruction]), null, null, null, new Z.SideEffects(0), false, t2);
        t3.HInstruction$2(t1, t2);
        t3._useGvn = true;
        t3 = this.attachPosition$2(t3, op);
        this._ssa$_current.add$1(0, t3);
        this.stack.push(t3);
      }
    },
    generateInstanceSendReceiver$1: function(send) {
      var t1;
      if (send.get$receiver() == null)
        return this.localsHandler.readThis$0();
      t1 = send.receiver;
      if (t1 != null)
        t1.accept$1(0, this);
      t1 = this.stack;
      if (0 >= t1.length)
        return H.ioore(t1, 0);
      return t1.pop();
    },
    noSuchMethodTargetSymbolString$2: function(error, prefix) {
      var result = error.get$name(error);
      if (prefix === "set")
        return H.S(result) + "=";
      return result;
    },
    noSuchMethodTargetSymbolString$1: function(error) {
      return this.noSuchMethodTargetSymbolString$2(error, null);
    },
    generateInstanceGetterWithCompiledReceiver$3: function(send, selector, receiver) {
      this.pushInvokeDynamic$3(send, selector, [receiver]);
    },
    generateIsDeferredLoadedCheckIfNeeded$1: function(node) {
      var deferredTask, prefixElement, loadIdConstant, uriConstant, t1;
      deferredTask = this.compiler.deferredLoadTask;
      prefixElement = deferredTask.deferredPrefixElement$2(node, this.elements);
      if (prefixElement != null) {
        loadIdConstant = this.addConstantString$1(deferredTask.importDeferName.$index(0, prefixElement._deferredImport));
        uriConstant = this.addConstantString$1(prefixElement._deferredImport.uri.get$dartString().slowToString$0());
        t1 = this.backend;
        this.pushInvokeStatic$3(node, t1.find$2(0, t1.jsHelperLibrary, "checkDeferredIsLoaded"), [loadIdConstant, uriConstant]);
        t1 = this.stack;
        if (0 >= t1.length)
          return H.ioore(t1, 0);
        t1.pop();
      }
    },
    generateGetter$2: function(send, element) {
      var t1, loadFunction, prefixElement, loadId, inputs, t2, value, prefix, wrapper, t3, t4, instruction, type, receiver;
      t1 = element != null;
      if (t1 && element.isForeign$1(this.compiler)) {
        this.elements.toString;
        element = send.get$_secret_tree_element$_element();
        K.invariant(send, element.get$isDeferredLoaderGetter(), null);
        t1 = this.compiler;
        loadFunction = t1.loadLibraryFunction;
        prefixElement = element.get$enclosingElement();
        loadId = t1.deferredLoadTask.importDeferName.$index(0, prefixElement.get$deferredImport());
        inputs = [this.graph.addConstant$2(t1.backend.get$constantSystem().createString$1(new Y.LiteralDartString(loadId)), t1)];
        t1 = this.backend.nonNullType;
        t2 = $.HInstruction_idCounter;
        if (typeof t2 !== "number")
          return t2.$add();
        $.HInstruction_idCounter = t2 + 1;
        t2 = new B.HInvokeStatic(loadFunction, false, null, null, null, t2, inputs, H.setRuntimeTypeInfo([], [B.HInstruction]), null, null, null, new Z.SideEffects(0), false, t1);
        t2.HInstruction$2(inputs, t1);
        t1 = t2.sideEffects;
        t1.flags = (t1.flags | 7) >>> 0;
        t1.setDependsOnSomething$0();
        this._ssa$_current.add$1(0, t2);
        this.stack.push(t2);
      } else if (O.Elements_isStaticOrTopLevelField(element)) {
        value = element.get$kind(element) === C.ElementKind_field_1 && !element.get$isAssignable() ? this.backend.constantCompilerTask.jsConstantCompiler.initialVariableValues.$index(0, element.get$declaration()) : null;
        if (value != null) {
          t1 = this.compiler;
          prefix = t1.deferredLoadTask.deferredPrefixElement$2(send, this.elements);
          t2 = this.graph;
          if (prefix != null) {
            wrapper = new K.DeferredConstant(value, prefix);
            t3 = t1.deferredLoadTask;
            t3.toString;
            t4 = H.setRuntimeTypeInfo(new N.Setlet(C.C__SetletMarker, null), [Y.Import]);
            t4.add$1(0, prefix._deferredImport);
            t3._constantToOutputUnit.$indexSet(0, wrapper, new B.OutputUnit(t4, null));
            instruction = t2.addConstant$2(wrapper, t1);
          } else
            instruction = t2.addConstant$2(value, t1);
          this.stack.push(instruction);
          type = B.TypeMaskFactory_fromInferredType(t1.typesTask.getGuaranteedTypeOfElement$1(element), t1);
          if (!type.containsAll$1(t1) && !instruction.constant.get$isNull())
            instruction.set$instructionType(type.nonNullable$0());
        } else if (element.kind === C.ElementKind_field_1 && this.backend.constantCompilerTask.jsConstantCompiler.initialVariableValues.$index(0, element.get$declaration()) == null) {
          t1 = this.compiler;
          t1 = B.TypeMaskFactory_fromInferredType(t1.typesTask.getGuaranteedTypeOfElement$1(element), t1);
          t2 = H.setRuntimeTypeInfo([], [B.HInstruction]);
          t3 = $.HInstruction_idCounter;
          if (typeof t3 !== "number")
            return t3.$add();
          $.HInstruction_idCounter = t3 + 1;
          instruction = new B.HLazyStatic(element, null, null, t3, t2, H.setRuntimeTypeInfo([], [B.HInstruction]), null, null, null, new Z.SideEffects(0), false, t1);
          instruction.HInstruction$2(t2, t1);
          t1 = instruction.sideEffects;
          t1.flags = (t1.flags | 7) >>> 0;
          t1.setDependsOnSomething$0();
          this._ssa$_current.add$1(0, instruction);
          this.stack.push(instruction);
        } else if (element.get$isGetter())
          this.pushInvokeStatic$3(send, element, H.setRuntimeTypeInfo([], [B.HInstruction]));
        else {
          t1 = this.compiler;
          instruction = B.HStatic$(element.get$declaration(), B.TypeMaskFactory_fromInferredType(t1.typesTask.getGuaranteedTypeOfElement$1(element), t1));
          this._ssa$_current.add$1(0, instruction);
          this.stack.push(instruction);
        }
      } else if (O.Elements_isInstanceSend(send, this.elements)) {
        receiver = this.generateInstanceSendReceiver$1(send);
        t1 = this.elements._selectors;
        this.generateInstanceGetterWithCompiledReceiver$3(send, t1 != null ? t1.$index(0, send) : null, receiver);
      } else if (O.Elements_isStaticOrTopLevelFunction(element)) {
        t1 = B.HStatic$(element.get$declaration(), this.backend.nonNullType);
        this._ssa$_current.add$1(0, t1);
        this.stack.push(t1);
        t1 = this.work.registry;
        t2 = element.get$declaration();
        t1.compiler.enqueuer.codegen.registerGetOfStaticFunction$1(t2);
      } else if (t1 && element.get$isErroneous())
        this.generateThrowNoSuchMethod$3$argumentNodes(send, this.noSuchMethodTargetSymbolString$2(element, "get"), C.C_Link3);
      else
        this.stack.push(this.localsHandler.readLocal$1(element));
    },
    generateInstanceSetterWithCompiledReceiver$5$location$selector: function(send, receiver, value, $location, selector) {
      var t1;
      if (selector == null) {
        t1 = this.elements._selectors;
        selector = t1 != null ? t1.$index(0, send) : null;
      }
      if ($location == null)
        $location = send;
      this.pushInvokeDynamic$3($location, selector, [receiver, value]);
      t1 = this.stack;
      if (0 >= t1.length)
        return H.ioore(t1, 0);
      t1.pop();
      this.stack.push(value);
    },
    generateInstanceSetterWithCompiledReceiver$3: function(send, receiver, value) {
      return this.generateInstanceSetterWithCompiledReceiver$5$location$selector(send, receiver, value, null, null);
    },
    generateNonInstanceSetter$4$location: function(send, element, value, $location) {
      var t1, t2, $arguments, checked;
      if ($location == null)
        $location = send;
      if (O.Elements_isStaticOrTopLevelField(element)) {
        if (element.get$kind(element) === C.ElementKind_setter_0) {
          this.pushInvokeStatic$3($location, element, H.setRuntimeTypeInfo([value], [B.HInstruction]));
          t1 = this.stack;
          if (0 >= t1.length)
            return H.ioore(t1, 0);
          t1.pop();
        } else {
          value = this.potentiallyCheckType$2(value, element.get$type(element));
          t1 = H.setRuntimeTypeInfo([value], [B.HInstruction]);
          t2 = $.HInstruction_idCounter;
          if (typeof t2 !== "number")
            return t2.$add();
          $.HInstruction_idCounter = t2 + 1;
          t2 = new B.HStaticStore(element, null, null, t2, t1, H.setRuntimeTypeInfo([], [B.HInstruction]), null, null, null, new Z.SideEffects(0), false, C.FlatTypeMask_null_0);
          t2.HInstruction$2(t1, C.FlatTypeMask_null_0);
          t2.HStaticStore$2(element, value);
          t2 = this.attachPosition$2(t2, $location);
          this._ssa$_current.add$1(0, t2);
        }
        this.stack.push(value);
      } else if (element != null && element.get$isErroneous()) {
        $arguments = send == null ? C.List_empty12 : H.setRuntimeTypeInfo([value], [B.HInstruction]);
        this.generateThrowNoSuchMethod$3$argumentValues($location, this.noSuchMethodTargetSymbolString$2(element, "set"), $arguments);
      } else {
        this.stack.push(value);
        if (value.get$sourceElement() == null)
          value.sourceElement = element;
        checked = this.potentiallyCheckType$2(value, element.get$type(element));
        if (checked !== value) {
          t1 = this.stack;
          if (0 >= t1.length)
            return H.ioore(t1, 0);
          t1.pop();
          this.stack.push(checked);
        }
        this.localsHandler.updateLocal$2(element, checked);
      }
    },
    generateNonInstanceSetter$3: function(send, element, value) {
      return this.generateNonInstanceSetter$4$location(send, element, value, null);
    },
    invokeInterceptor$1: function(receiver) {
      var t1, t2, t3, interceptor;
      t1 = this.backend.nonNullType;
      t2 = H.setRuntimeTypeInfo([receiver], [B.HInstruction]);
      t3 = $.HInstruction_idCounter;
      if (typeof t3 !== "number")
        return t3.$add();
      $.HInstruction_idCounter = t3 + 1;
      interceptor = new B.HInterceptor(null, null, null, t3, t2, H.setRuntimeTypeInfo([], [B.HInstruction]), null, null, null, new Z.SideEffects(0), false, t1);
      interceptor.HInstruction$2(t2, t1);
      interceptor.HInterceptor$2(receiver, t1);
      this._ssa$_current.add$1(0, interceptor);
      return interceptor;
    },
    buildTypeArgumentRepresentations$1: function(type) {
      var t1, t2, t3, inputs, templates;
      if (type.get$kind(type) === C.TypeKind_kuk) {
        t1 = H.setRuntimeTypeInfo([this.addTypeVariableReference$1(type)], [B.HInstruction]);
        t2 = this.backend.extendableArrayType;
        t3 = $.HInstruction_idCounter;
        if (typeof t3 !== "number")
          return t3.$add();
        $.HInstruction_idCounter = t3 + 1;
        t3 = new B.HLiteralList(null, null, t3, t1, H.setRuntimeTypeInfo([], [B.HInstruction]), null, null, null, new Z.SideEffects(0), false, t2);
        t3.HInstruction$2(t1, t2);
        return t3;
      } else {
        inputs = H.setRuntimeTypeInfo([], [B.HInstruction]);
        templates = H.setRuntimeTypeInfo([], [P.String]);
        for (t1 = type.get$typeArguments(), t1 = H.setRuntimeTypeInfo(new H.ListIterator(t1, t1.length, 0, null), [H.getTypeArgumentByIndex(t1, 0)]), t2 = this.rti; t1.moveNext$0();)
          templates.push(t2.getTypeRepresentationWithHashes$2(t1.__internal$_current, new B.SsaBuilder_buildTypeArgumentRepresentations_closure(this, inputs)));
        return B.HForeign$(C.C_JsBuilder.uncachedExpressionTemplate$1("[" + C.JSArray_methods.join$1(templates, ", ") + "]"), this.backend.readableArrayType, inputs, false, null, false, null);
      }
    },
    visitOperatorSend$1: function(node) {
      var op, t1, t2, t3, not, expression, isNot, instruction, t4, type, element, converted, right, left;
      op = node.selector;
      t1 = op.get$token();
      if ("[]" === t1.get$value(t1))
        this.visitDynamicSend$1(node);
      else {
        t1 = op.get$token();
        if ("&&" !== t1.get$value(t1)) {
          t1 = op.get$token();
          t1 = "||" === t1.get$value(t1);
        } else
          t1 = true;
        if (t1)
          this.visitLogicalAndOr$2(node, op);
        else {
          t1 = op.get$token();
          if ("!" === t1.get$value(t1)) {
            t1 = node.receiver;
            if (t1 != null)
              t1.accept$1(0, this);
            t1 = this.popBoolified$0();
            t2 = this.backend.compiler.typesTask.get$boolType();
            t1 = H.setRuntimeTypeInfo([t1], [B.HInstruction]);
            t3 = $.HInstruction_idCounter;
            if (typeof t3 !== "number")
              return t3.$add();
            $.HInstruction_idCounter = t3 + 1;
            not = new B.HNot(null, null, t3, t1, H.setRuntimeTypeInfo([], [B.HInstruction]), null, null, null, new Z.SideEffects(0), false, t2);
            not.HInstruction$2(t1, t2);
            not._useGvn = true;
            t2 = this.attachPosition$2(not, node);
            this._ssa$_current.add$1(0, t2);
            this.stack.push(t2);
          } else {
            t1 = node.argumentsNode;
            t2 = J.getInterceptor(t1);
            if (!!t2.$isPrefix0)
              this.visitUnary$2(node, op);
            else {
              t3 = op.get$token();
              if ("is" === t3.get$value(t3)) {
                t2 = node.receiver;
                if (t2 != null)
                  t2.accept$1(0, this);
                t2 = this.stack;
                if (0 >= t2.length)
                  return H.ioore(t2, 0);
                expression = t2.pop();
                if (!!op.$isOperator) {
                  t2 = op.asOperator$0().token;
                  t2 = t2.get$value(t2) === "is";
                } else
                  t2 = false;
                if (t2) {
                  t1 = t1.nodes;
                  isNot = t1.get$head(t1).asSend$0() != null;
                } else
                  isNot = false;
                t1 = this.elements;
                t2 = node.get$typeAnnotationFromIsCheckOrCast();
                t1 = t1._types;
                instruction = this.buildIsNode$3(node, t1 != null ? t1.$index(0, t2) : null, expression);
                if (isNot) {
                  this._ssa$_current.add$1(0, instruction);
                  t1 = this.backend.compiler.typesTask.get$boolType();
                  t2 = H.setRuntimeTypeInfo([instruction], [B.HInstruction]);
                  t3 = $.HInstruction_idCounter;
                  if (typeof t3 !== "number")
                    return t3.$add();
                  $.HInstruction_idCounter = t3 + 1;
                  instruction = new B.HNot(null, null, t3, t2, H.setRuntimeTypeInfo([], [B.HInstruction]), null, null, null, new Z.SideEffects(0), false, t1);
                  instruction.HInstruction$2(t2, t1);
                  instruction._useGvn = true;
                }
                this._ssa$_current.add$1(0, instruction);
                this.stack.push(instruction);
              } else {
                t3 = op.get$token();
                t4 = node.receiver;
                if ("as" === t3.get$value(t3)) {
                  if (t4 != null)
                    t4.accept$1(0, this);
                  t1 = this.stack;
                  if (0 >= t1.length)
                    return H.ioore(t1, 0);
                  expression = t1.pop();
                  t1 = this.elements;
                  t2 = node.get$typeAnnotationFromIsCheckOrCast();
                  t1 = t1._types;
                  type = t1 != null ? t1.$index(0, t2) : null;
                  if (J.get$kind$x(type) === C.TypeKind_malformed) {
                    element = type.get$element();
                    t1 = K.Message$(element.get$messageKind(), element.get$messageArguments(), false).computeMessage$0();
                    t2 = this.backend;
                    this.pushInvokeStatic$3(node, t2.find$2(0, t2.jsHelperLibrary, "throwTypeError"), [this.addConstantString$1(t1)]);
                  } else {
                    converted = this.buildTypeConversion$3(expression, this.localsHandler.substInContext$1(type), 2);
                    if (converted == null ? expression != null : converted !== expression)
                      this._ssa$_current.add$1(0, converted);
                    this.stack.push(converted);
                  }
                } else {
                  if (t4 != null)
                    t4.accept$1(0, this);
                  if (t1 != null)
                    t2.accept$1(t1, this);
                  t1 = this.stack;
                  if (0 >= t1.length)
                    return H.ioore(t1, 0);
                  right = t1.pop();
                  t1 = this.stack;
                  if (0 >= t1.length)
                    return H.ioore(t1, 0);
                  left = t1.pop();
                  t1 = this.elements._selectors;
                  this.visitBinary$5(left, op, right, t1 != null ? t1.$index(0, node) : null, node);
                }
              }
            }
          }
        }
      }
    },
    buildIsNode$3: function(node, type, expression) {
      var t1, t2, t3, runtimeType, $call, element, helper, representations, isFieldName;
      t1 = this.compiler;
      type = this.localsHandler.substInContext$1(type).unalias$1(t1);
      if (type.get$kind(type) === C.TypeKind_function) {
        new B.TypeBuilder().visitFunctionType$2(type, this);
        t1 = this.stack;
        if (0 >= t1.length)
          return H.ioore(t1, 0);
        t1 = t1.pop();
        t2 = this.backend;
        this.pushInvokeDynamic$3(node, Z.Selector_Selector(C.SelectorKind_call_2, "_isTest", t2.jsHelperLibrary, 1, null), [t1, expression]);
        t1 = this.stack;
        if (0 >= t1.length)
          return H.ioore(t1, 0);
        t1 = t1.pop();
        t2 = t2.compiler.typesTask.get$boolType();
        t1 = [expression, t1];
        t3 = $.HInstruction_idCounter;
        if (typeof t3 !== "number")
          return t3.$add();
        $.HInstruction_idCounter = t3 + 1;
        t3 = new B.HIs(type, 1, null, null, t3, t1, H.setRuntimeTypeInfo([], [B.HInstruction]), null, null, null, new Z.SideEffects(0), false, t2);
        t3.HInstruction$2(t1, t2);
        t3.HIs$internal$4(type, t1, 1, t2);
        return t3;
      } else if (type.get$kind(type) === C.TypeKind_kuk) {
        runtimeType = this.addTypeVariableReference$1(type);
        t1 = this.backend;
        t2 = t1.compiler;
        this.pushInvokeStatic$4(null, t1.find$2(0, t1.jsHelperLibrary, "checkSubtypeOfRuntimeType"), H.setRuntimeTypeInfo([expression, runtimeType], [B.HInstruction]), t2.typesTask.get$boolType());
        t1 = this.stack;
        if (0 >= t1.length)
          return H.ioore(t1, 0);
        $call = t1.pop();
        t2 = t2.typesTask.get$boolType();
        t1 = [expression, $call];
        t3 = $.HInstruction_idCounter;
        if (typeof t3 !== "number")
          return t3.$add();
        $.HInstruction_idCounter = t3 + 1;
        t3 = new B.HIs(type, 2, null, null, t3, t1, H.setRuntimeTypeInfo([], [B.HInstruction]), null, null, null, new Z.SideEffects(0), false, t2);
        t3.HInstruction$2(t1, t2);
        t3.HIs$internal$4(type, t1, 2, t2);
        return t3;
      } else if (Z.RuntimeTypes_hasTypeArguments(type)) {
        element = type.get$element();
        t2 = this.backend;
        helper = t2.find$2(0, t2.jsHelperLibrary, "checkSubtype");
        representations = this.buildTypeArgumentRepresentations$1(type);
        this._ssa$_current.add$1(0, representations);
        t3 = t2.namer;
        isFieldName = this.addConstantString$1("$is" + H.S(t3.getRuntimeTypeName$1(element)));
        t2 = t2.compiler;
        this.pushInvokeStatic$4(node, helper, H.setRuntimeTypeInfo([expression, isFieldName, representations, t1.world.hasAnySubtype$1(element) ? this.addConstantString$1("$as" + H.S(t3.getNameX$1(element))) : this.graph.addConstant$2(t1.backend.get$constantSystem().createNull$0(), t1)], [B.HInstruction]), t2.typesTask.get$boolType());
        t1 = this.stack;
        if (0 >= t1.length)
          return H.ioore(t1, 0);
        $call = t1.pop();
        t2 = t2.typesTask.get$boolType();
        t1 = [expression, $call];
        t3 = $.HInstruction_idCounter;
        if (typeof t3 !== "number")
          return t3.$add();
        $.HInstruction_idCounter = t3 + 1;
        t3 = new B.HIs(type, 1, null, null, t3, t1, H.setRuntimeTypeInfo([], [B.HInstruction]), null, null, null, new Z.SideEffects(0), false, t2);
        t3.HInstruction$2(t1, t2);
        t3.HIs$internal$4(type, t1, 1, t2);
        return t3;
      } else if (type.get$kind(type) === C.TypeKind_malformed) {
        element = type.get$element();
        t1 = K.Message$(element.get$messageKind(), element.get$messageArguments(), false).computeMessage$0();
        t2 = this.backend;
        this.pushInvokeStatic$3(node, t2.find$2(0, t2.jsHelperLibrary, "throwTypeError"), [this.addConstantString$1(t1)]);
        t1 = this.stack;
        if (0 >= t1.length)
          return H.ioore(t1, 0);
        $call = t1.pop();
        t2 = t2.compiler.typesTask.get$boolType();
        t1 = [expression, $call];
        t3 = $.HInstruction_idCounter;
        if (typeof t3 !== "number")
          return t3.$add();
        $.HInstruction_idCounter = t3 + 1;
        t3 = new B.HIs(type, 1, null, null, t3, t1, H.setRuntimeTypeInfo([], [B.HInstruction]), null, null, null, new Z.SideEffects(0), false, t2);
        t3.HInstruction$2(t1, t2);
        t3.HIs$internal$4(type, t1, 1, t2);
        return t3;
      } else {
        t1 = this.backend;
        element = type.get$element();
        t2 = t1.compiler;
        t3 = t2.stringClass;
        if (element == null ? t3 != null : element !== t3) {
          t3 = t2.boolClass;
          if (element == null ? t3 != null : element !== t3) {
            t3 = t2.numClass;
            if (element == null ? t3 != null : element !== t3) {
              t3 = t2.intClass;
              if (element == null ? t3 != null : element !== t3) {
                t3 = t2.doubleClass;
                if (element == null ? t3 != null : element !== t3) {
                  t3 = t1.jsArrayClass;
                  if (element == null ? t3 != null : element !== t3) {
                    t3 = t1.jsMutableArrayClass;
                    if (element == null ? t3 != null : element !== t3) {
                      t3 = t1.jsExtendableArrayClass;
                      if (element == null ? t3 != null : element !== t3) {
                        t1 = t1.jsFixedArrayClass;
                        t1 = element == null ? t1 == null : element === t1;
                      } else
                        t1 = true;
                    } else
                      t1 = true;
                  } else
                    t1 = true;
                } else
                  t1 = true;
              } else
                t1 = true;
            } else
              t1 = true;
          } else
            t1 = true;
        } else
          t1 = true;
        if (t1) {
          t1 = t2.typesTask.get$boolType();
          t2 = [expression];
          t3 = $.HInstruction_idCounter;
          if (typeof t3 !== "number")
            return t3.$add();
          $.HInstruction_idCounter = t3 + 1;
          t3 = new B.HIs(type, 0, null, null, t3, t2, H.setRuntimeTypeInfo([], [B.HInstruction]), null, null, null, new Z.SideEffects(0), false, t1);
          t3.HInstruction$2(t2, t1);
          t3.HIs$internal$4(type, t2, 0, t1);
          return t3;
        }
        t1 = this.invokeInterceptor$1(expression);
        t2 = t2.typesTask.get$boolType();
        t1 = [expression, t1];
        t3 = $.HInstruction_idCounter;
        if (typeof t3 !== "number")
          return t3.$add();
        $.HInstruction_idCounter = t3 + 1;
        t3 = new B.HIs(type, 0, null, null, t3, t1, H.setRuntimeTypeInfo([], [B.HInstruction]), null, null, null, new Z.SideEffects(0), false, t2);
        t3.HInstruction$2(t1, t2);
        t3.HIs$internal$4(type, t1, 0, t2);
        return t3;
      }
    },
    addDynamicSendArgumentsToList$2: function(node, list) {
      var t1, selector, $arguments, t2, positionalArgumentCount, i, instructions, nameIndex, nameIndex0, t3, orderedNames;
      t1 = this.elements._selectors;
      selector = t1 != null ? t1.$index(0, node) : null;
      t1 = node.argumentsNode;
      if (selector.get$namedArguments().length === 0)
        this.addGenericSendArgumentsToList$2(t1.nodes, list);
      else {
        $arguments = t1.nodes;
        t1 = selector.argumentCount;
        t2 = selector.namedArguments;
        positionalArgumentCount = t1 - t2.length;
        for (i = 0; i < positionalArgumentCount; $arguments = $arguments.get$tail(), ++i) {
          t1 = $arguments.get$head($arguments);
          if (t1 != null)
            J.accept$1$x(t1, this);
          t1 = this.stack;
          if (0 >= t1.length)
            return H.ioore(t1, 0);
          list.push(t1.pop());
        }
        instructions = P.LinkedHashMap_LinkedHashMap(null, null, null, P.String, B.HInstruction);
        for (nameIndex = 0; !$arguments.get$isEmpty($arguments); $arguments = $arguments.get$tail(), nameIndex = nameIndex0) {
          t1 = $arguments.get$head($arguments);
          if (t1 != null)
            J.accept$1$x(t1, this);
          nameIndex0 = nameIndex + 1;
          if (nameIndex >= t2.length)
            return H.ioore(t2, nameIndex);
          t1 = t2[nameIndex];
          t3 = this.stack;
          if (0 >= t3.length)
            return H.ioore(t3, 0);
          instructions.$indexSet(0, t1, t3.pop());
        }
        orderedNames = selector.getOrderedNamedArguments$0();
        for (t1 = H.setRuntimeTypeInfo(new H.ListIterator(orderedNames, orderedNames.length, 0, null), [H.getTypeArgumentByIndex(orderedNames, 0)]); t1.moveNext$0();)
          list.push(instructions.$index(0, t1.__internal$_current));
      }
    },
    addStaticSendArgumentsToList$4: function(selector, $arguments, element, list) {
      return selector.addArgumentsToList$6($arguments, list, element, new B.SsaBuilder_addStaticSendArgumentsToList_compileArgument(this), this.get$handleConstantForOptionalParameter(), this.compiler);
    },
    addGenericSendArgumentsToList$2: function(link, list) {
      var t1;
      for (; !link.get$isEmpty(link); link = link.get$tail()) {
        t1 = link.get$head(link);
        if (t1 != null)
          J.accept$1$x(t1, this);
        t1 = this.stack;
        if (0 >= t1.length)
          return H.ioore(t1, 0);
        list.push(t1.pop());
      }
    },
    visitDynamicSend$1: function(node) {
      var t1, selector, inputs;
      t1 = this.elements._selectors;
      selector = t1 != null ? t1.$index(0, node) : null;
      inputs = H.setRuntimeTypeInfo([], [B.HInstruction]);
      inputs.push(this.generateInstanceSendReceiver$1(node));
      this.addDynamicSendArgumentsToList$2(node, inputs);
      this.pushInvokeDynamic$3(node, selector, inputs);
      t1 = J.getInterceptor$x(selector);
      if (t1.get$kind(selector) !== C.SelectorKind_setter_1)
        t1 = t1.get$kind(selector) === C.SelectorKind_index_4 && selector.get$argumentCount() === 2;
      else
        t1 = true;
      if (t1) {
        t1 = this.stack;
        if (0 >= t1.length)
          return H.ioore(t1, 0);
        t1.pop();
        this.stack.push(C.JSArray_methods.get$last(inputs));
      }
    },
    visitClosureSend$1: function(node) {
      var t1, selector, element, closureTarget, inputs, closureSelector, t2, t3;
      t1 = this.elements._selectors;
      selector = t1 != null ? t1.$index(0, node) : null;
      this.elements.toString;
      element = node.get$_secret_tree_element$_element();
      if (element == null) {
        t1 = node.selector;
        if (t1 != null)
          t1.accept$1(0, this);
        t1 = this.stack;
        if (0 >= t1.length)
          return H.ioore(t1, 0);
        closureTarget = t1.pop();
      } else
        closureTarget = this.localsHandler.readLocal$1(element);
      inputs = H.setRuntimeTypeInfo([], [B.HInstruction]);
      inputs.push(closureTarget);
      this.addDynamicSendArgumentsToList$2(node, inputs);
      closureSelector = Z.Selector_Selector(C.SelectorKind_call_2, "call", null, selector.get$argumentCount(), selector.get$namedArguments());
      t1 = this.backend.compiler.typesTask.get$dynamicType();
      t2 = $.HInstruction_idCounter;
      if (typeof t2 !== "number")
        return t2.$add();
      $.HInstruction_idCounter = t2 + 1;
      t3 = H.setRuntimeTypeInfo([], [B.HInstruction]);
      t2 = new B.HInvokeClosure(C.C_InvokeDynamicSpecializer, closureSelector, null, null, null, t2, inputs, t3, null, null, null, new Z.SideEffects(0), false, t1);
      t2.HInstruction$2(inputs, t1);
      t1 = t2.sideEffects;
      t1.flags = (t1.flags | 7) >>> 0;
      t1.setDependsOnSomething$0();
      t2 = this.attachPosition$2(t2, node);
      this._ssa$_current.add$1(0, t2);
      this.stack.push(t2);
    },
    handleForeingJsGetFlag$1: function(node) {
      var $arguments, t1, argument, i, string, $name, value;
      $arguments = node.argumentsNode.nodes.toList$0(0);
      t1 = $arguments.length;
      switch (t1) {
        case 0:
          this.compiler.reportDiagnosticInternal$4(node, C.MessageKind_wwi, P.LinkedHashMap_LinkedHashMap$_literal(["text", "Error: Expected one argument to JS_GET_FLAG."], null, null), C.Diagnostic_1_error);
          return;
        case 1:
          if (0 >= t1)
            return H.ioore($arguments, 0);
          argument = $arguments[0];
          break;
        default:
          for (t1 = this.compiler, i = 1; i < $arguments.length; ++i)
            t1.reportDiagnosticInternal$4($arguments[i], C.MessageKind_wwi, P.LinkedHashMap_LinkedHashMap$_literal(["text", "Error: Extra argument to JS_GET_FLAG."], null, null), C.Diagnostic_1_error);
          return;
      }
      string = argument.asLiteralString$0();
      if (string == null)
        this.compiler.reportDiagnosticInternal$4(argument, C.MessageKind_wwi, P.LinkedHashMap_LinkedHashMap$_literal(["text", "Error: Expected a literal string."], null, null), C.Diagnostic_1_error);
      $name = string.dartString.slowToString$0();
      if ($name === "MUST_RETAIN_METADATA")
        value = this.backend.mustRetainMetadata;
      else {
        this.compiler.reportDiagnosticInternal$4(node, C.MessageKind_wwi, P.LinkedHashMap_LinkedHashMap$_literal(["text", "Error: Unknown internal flag \"" + H.S($name) + "\"."], null, null), C.Diagnostic_1_error);
        value = false;
      }
      t1 = this.compiler;
      this.stack.push(this.graph.addConstant$2(t1.backend.get$constantSystem().createBool$1(value), t1));
    },
    handleForeignJsGetName$1: function(node) {
      var $arguments, t1, argument, i, string;
      $arguments = node.argumentsNode.nodes.toList$0(0);
      t1 = $arguments.length;
      switch (t1) {
        case 0:
          this.compiler.reportDiagnosticInternal$4(node, C.MessageKind_wwi, P.LinkedHashMap_LinkedHashMap$_literal(["text", "Error: Expected one argument to JS_GET_NAME."], null, null), C.Diagnostic_1_error);
          return;
        case 1:
          if (0 >= t1)
            return H.ioore($arguments, 0);
          argument = $arguments[0];
          break;
        default:
          for (t1 = this.compiler, i = 1; i < $arguments.length; ++i)
            t1.reportDiagnosticInternal$4($arguments[i], C.MessageKind_wwi, P.LinkedHashMap_LinkedHashMap$_literal(["text", "Error: Extra argument to JS_GET_NAME."], null, null), C.Diagnostic_1_error);
          return;
      }
      string = argument.asLiteralString$0();
      if (string == null)
        this.compiler.reportDiagnosticInternal$4(argument, C.MessageKind_wwi, P.LinkedHashMap_LinkedHashMap$_literal(["text", "Error: Expected a literal string."], null, null), C.Diagnostic_1_error);
      this.stack.push(this.addConstantString$1(this.backend.namer.getNameForJsGetName$2(argument, string.dartString.slowToString$0())));
    },
    handleJsInterceptorConstant$1: function(node) {
      var t1, t2, argument, argumentInstruction, argumentConstant, instruction;
      t1 = node.argumentsNode.nodes;
      if (!t1.get$isEmpty(t1)) {
        t2 = t1.get$tail();
        t2 = t2.get$isEmpty(t2);
      } else
        t2 = false;
      if (t2) {
        argument = t1.get$head(t1);
        if (argument != null)
          J.accept$1$x(argument, this);
        t1 = this.stack;
        if (0 >= t1.length)
          return H.ioore(t1, 0);
        argumentInstruction = t1.pop();
        if (!!J.getInterceptor(argumentInstruction).$isHConstant) {
          argumentConstant = argumentInstruction.constant;
          if (!!argumentConstant.$isTypeConstant) {
            instruction = this.graph.addConstant$2(new K.InterceptorConstant(argumentConstant.representedType), this.compiler);
            this.stack.push(instruction);
            return;
          }
        }
      }
      t1 = this.compiler;
      t1.reportDiagnosticInternal$4(node, C.MessageKind_wU7, C.Map_empty, C.Diagnostic_1_error);
      this.stack.push(this.graph.addConstant$2(t1.backend.get$constantSystem().createNull$0(), t1));
    },
    handleForeignRawFunctionRef$2: function(node, $name) {
      var t1, t2, t3, closure, element, params;
      t1 = node.argumentsNode;
      t2 = t1.nodes;
      if (!t2.get$isEmpty(t2)) {
        t3 = t2.get$tail();
        t3 = !t3.get$isEmpty(t3);
      } else
        t3 = true;
      if (t3)
        this.compiler.internalError$2(t1, "\"" + $name + "\" requires exactly one argument.");
      closure = t2.get$head(t2);
      this.elements.toString;
      element = closure.get$_secret_tree_element$_element();
      if (!O.Elements_isStaticOrTopLevelFunction(element))
        this.compiler.internalError$2(closure, "\"" + $name + "\" requires a static or top-level method.");
      params = element.get$implementation(element).get$functionSignature();
      if (params.get$optionalParameterCount() !== 0)
        this.compiler.internalError$2(closure, "\"" + $name + "\" does not handle closure with optional parameters.");
      this.work.registry.compiler.enqueuer.codegen.registerStaticUse$1(element);
      t1 = this.backend;
      t1 = B.HForeign$(Q.Template$withExpressionResult(t1.namer.elementAccess$1(element)), t1.compiler.typesTask.get$dynamicType(), H.setRuntimeTypeInfo([], [B.HInstruction]), false, null, false, null);
      this._ssa$_current.add$1(0, t1);
      this.stack.push(t1);
      return params;
    },
    generateSuperNoSuchMethodSend$3: function(node, selector, $arguments) {
      var $name, element, t1, t2, t3, publicName, nameConstant, internalNameConstant, createInvocationMirror, t4, t5, argumentsInstruction, argumentNames, t6, argumentNamesInstruction, kindConstant;
      $name = selector.name;
      element = this.get$currentNonClosureClass().lookupSuperMember$1("noSuchMethod");
      t1 = this.compiler;
      if (t1.enabledInvokeOn) {
        t2 = element.get$enclosingElement().get$declaration();
        t3 = t1.objectClass;
        t3 = t2 == null ? t3 != null : t2 !== t3;
        t2 = t3;
      } else
        t2 = false;
      if (t2) {
        t2 = this.work.registry;
        t3 = selector.get$asUntyped();
        t2.compiler.enqueuer.codegen.registerSelectorUse$1(t3);
      }
      if (selector.kind === C.SelectorKind_setter_1) {
        if (typeof $name !== "string")
          return $name.$add();
        publicName = $name + "=";
      } else
        publicName = $name;
      t2 = this.constantSystem;
      nameConstant = t2.createString$1(new Y.LiteralDartString(publicName));
      t3 = this.backend;
      internalNameConstant = t2.createString$1(new Y.LiteralDartString(t3.namer.invocationName$1(selector)));
      createInvocationMirror = t3.find$2(0, t3.jsHelperLibrary, "createInvocationMirror");
      t4 = t3.extendableArrayType;
      t5 = $.HInstruction_idCounter;
      if (typeof t5 !== "number")
        return t5.$add();
      $.HInstruction_idCounter = t5 + 1;
      argumentsInstruction = new B.HLiteralList(null, null, t5, $arguments, H.setRuntimeTypeInfo([], [B.HInstruction]), null, null, null, new Z.SideEffects(0), false, t4);
      argumentsInstruction.HInstruction$2($arguments, t4);
      this._ssa$_current.add$1(0, argumentsInstruction);
      argumentNames = H.setRuntimeTypeInfo([], [B.HInstruction]);
      for (t4 = selector.namedArguments, t4 = H.setRuntimeTypeInfo(new H.ListIterator(t4, t4.length, 0, null), [H.getTypeArgumentByIndex(t4, 0)]), t5 = this.graph; t4.moveNext$0();)
        argumentNames.push(t5.addConstant$2(t2.createString$1(new Y.LiteralDartString(t4.__internal$_current)), t1));
      t4 = t3.extendableArrayType;
      t6 = $.HInstruction_idCounter;
      if (typeof t6 !== "number")
        return t6.$add();
      $.HInstruction_idCounter = t6 + 1;
      argumentNamesInstruction = new B.HLiteralList(null, null, t6, argumentNames, H.setRuntimeTypeInfo([], [B.HInstruction]), null, null, null, new Z.SideEffects(0), false, t4);
      argumentNamesInstruction.HInstruction$2(argumentNames, t4);
      this._ssa$_current.add$1(0, argumentNamesInstruction);
      kindConstant = t2.createInt$1(selector.get$invocationMirrorKind());
      this.pushInvokeStatic$4(null, createInvocationMirror, [t5.addConstant$2(nameConstant, t1), t5.addConstant$2(internalNameConstant, t1), t5.addConstant$2(kindConstant, t1), argumentsInstruction, argumentNamesInstruction], t3.compiler.typesTask.get$dynamicType());
      t3 = this.stack;
      if (0 >= t3.length)
        return H.ioore(t3, 0);
      t3 = this.buildInvokeSuper$3(t1.noSuchMethodSelector, element, H.setRuntimeTypeInfo([t3.pop()], [B.HInstruction]));
      this._ssa$_current.add$1(0, t3);
      this.stack.push(t3);
    },
    visitSuperSend$1: function(node) {
      var t1, selector, element, $arguments, inputs, $function, target, closureSelector, t2, t3;
      t1 = this.elements._selectors;
      selector = t1 != null ? t1.$index(0, node) : null;
      this.elements.toString;
      element = node.get$_secret_tree_element$_element();
      if (element == null || element.get$isErroneous()) {
        $arguments = H.setRuntimeTypeInfo([], [B.HInstruction]);
        t1 = node.argumentsNode;
        if (t1 != null)
          this.addGenericSendArgumentsToList$2(t1.nodes, $arguments);
        return this.generateSuperNoSuchMethodSend$3(node, selector, $arguments);
      }
      inputs = H.setRuntimeTypeInfo([], [B.HInstruction]);
      t1 = node.argumentsNode;
      if (t1 == null) {
        t1 = this.buildInvokeSuper$3(selector, element, inputs);
        this._ssa$_current.add$1(0, t1);
        this.stack.push(t1);
      } else if (element.get$isFunction() || element.get$kind(element) === C.ElementKind_generative_constructor_16)
        if (selector.applies$2(element, this.compiler)) {
          $function = element.get$implementation(element);
          this.addStaticSendArgumentsToList$4(selector, t1.nodes, $function, inputs);
          t1 = this.buildInvokeSuper$3(selector, element, inputs);
          this._ssa$_current.add$1(0, t1);
          this.stack.push(t1);
        } else if (element.get$kind(element) === C.ElementKind_generative_constructor_16)
          this.generateWrongArgumentCountError$3(node, element, t1.nodes);
        else {
          this.addGenericSendArgumentsToList$2(t1.nodes, inputs);
          this.generateSuperNoSuchMethodSend$3(node, selector, inputs);
        }
      else {
        target = this.buildInvokeSuper$3(selector, element, inputs);
        this._ssa$_current.add$1(0, target);
        inputs = H.setRuntimeTypeInfo([target], [B.HInstruction]);
        this.addDynamicSendArgumentsToList$2(node, inputs);
        closureSelector = Z.Selector_Selector(C.SelectorKind_call_2, "call", null, selector.get$argumentCount(), selector.get$namedArguments());
        t1 = this.backend.compiler.typesTask.get$dynamicType();
        t2 = $.HInstruction_idCounter;
        if (typeof t2 !== "number")
          return t2.$add();
        $.HInstruction_idCounter = t2 + 1;
        t3 = H.setRuntimeTypeInfo([], [B.HInstruction]);
        t2 = new B.HInvokeClosure(C.C_InvokeDynamicSpecializer, closureSelector, null, null, null, t2, inputs, t3, null, null, null, new Z.SideEffects(0), false, t1);
        t2.HInstruction$2(inputs, t1);
        t1 = t2.sideEffects;
        t1.flags = (t1.flags | 7) >>> 0;
        t1.setDependsOnSomething$0();
        this._ssa$_current.add$1(0, t2);
        this.stack.push(t2);
      }
    },
    needsSubstitutionForTypeVariableAccess$1: function(cls) {
      var t1, subclasses;
      t1 = this.compiler;
      if (t1.world.isUsedAsMixin$1(cls))
        return true;
      subclasses = t1.world._subclasses.$index(0, cls.get$declaration());
      return subclasses != null && J.any$1$ax(subclasses, new B.SsaBuilder_needsSubstitutionForTypeVariableAccess_closure(this, cls));
    },
    readTypeVariable$2: function(cls, variable) {
      var target, t1, t2, t3, index, substitutionNameString, substitutionName;
      target = this.localsHandler.readThis$0();
      t1 = this.graph;
      t2 = Z.RuntimeTypes_getTypeVariableIndex(variable);
      t3 = this.compiler;
      index = t1.addConstant$2(t3.backend.get$constantSystem().createInt$1(t2), t3);
      t2 = this.backend;
      if (this.needsSubstitutionForTypeVariableAccess$1(cls)) {
        substitutionNameString = t2.namer.getNameX$1(cls);
        substitutionName = t1.addConstant$2(t3.backend.get$constantSystem().createString$1(new Y.LiteralDartString(substitutionNameString)), t3);
        this.pushInvokeStatic$4(null, t2.find$2(0, t2.jsHelperLibrary, "getRuntimeTypeArgument"), [target, substitutionName, index], t2.compiler.typesTask.get$dynamicType());
      } else
        this.pushInvokeStatic$4(null, t2.find$2(0, t2.jsHelperLibrary, "getTypeArgumentByIndex"), [target, index], t2.compiler.typesTask.get$dynamicType());
      t1 = this.stack;
      if (0 >= t1.length)
        return H.ioore(t1, 0);
      return t1.pop();
    },
    addTypeVariableReference$1: function(type) {
      var member, isClosure, t1, isInConstructorContext, typeVariableLocal;
      member = J.get$last$ax(this.sourceElementStack);
      isClosure = member.get$enclosingElement().get$isClosure();
      if (isClosure)
        member = member.get$enclosingElement().get$methodElement().get$outermostEnclosingMemberOrTopLevel();
      t1 = J.getInterceptor$x(member);
      isInConstructorContext = t1.get$kind(member) === C.ElementKind_generative_constructor_16 || member.get$isFactoryConstructor() || t1.get$kind(member) === C.ElementKind_generative_constructor_body_0;
      typeVariableLocal = this.localsHandler.getTypeVariableAsLocal$1(type);
      if (isClosure) {
        if (!member.get$isFactoryConstructor())
          if (isInConstructorContext)
            t1 = !this.localsHandler.isAccessedDirectly$1(typeVariableLocal) || this.localsHandler.directLocals.$index(0, typeVariableLocal) != null;
          else
            t1 = false;
        else
          t1 = true;
        if (t1)
          return this.localsHandler.readLocal$1(typeVariableLocal);
        else if (member.get$isFunction() || member.get$isGetter() || member.kind === C.ElementKind_setter_0 || isInConstructorContext)
          return this.readTypeVariable$2(member.get$enclosingClass(), type.get$element());
        else
          return this.localsHandler.readLocal$1(typeVariableLocal);
      } else {
        if (!isInConstructorContext)
          t1 = t1.get$kind(member) === C.ElementKind_field_1 && this.work.element !== member;
        else
          t1 = true;
        if (t1)
          return this.localsHandler.readLocal$1(typeVariableLocal);
        else if (member.get$isInstanceMember())
          return this.readTypeVariable$2(member.get$enclosingClass(), type.get$element());
        else
          this.compiler.internalError$2(type.get$element(), "Unimplemented unresolved type variable.");
      }
    },
    analyzeTypeArgument$1: function(argument) {
      var t1, inputs, template, parser, expression, code, t2, t3, result;
      if (argument.get$treatAsDynamic()) {
        t1 = this.compiler;
        return this.graph.addConstant$2(t1.backend.get$constantSystem().createNull$0(), t1);
      }
      if (argument.get$kind(argument) === C.TypeKind_kuk)
        return this.addTypeVariableReference$1(argument);
      inputs = [];
      inputs.$builtinTypeInfo = [B.HInstruction];
      template = this.rti.getTypeRepresentationWithHashes$2(argument, new B.SsaBuilder_analyzeTypeArgument_closure(this, inputs));
      t1 = [];
      t1.$builtinTypeInfo = [Q.InterpolatedNode];
      parser = new Q.MiniJsParser(-1, null, 0, 0, false, template, t1);
      parser.getToken$0();
      expression = parser.expression$0();
      code = new Q.Template(template, true, false, expression, null, -1);
      t1 = P.LinkedHashSet_LinkedHashSet(null, null, null, Q.Node0);
      t2 = [];
      t2.$builtinTypeInfo = [Q.InterpolatedNode];
      t1 = new Q.InterpolatedNodeAnalysis(t1, t2, 0);
      expression.accept$1(0, t1);
      code.instantiator = new Q.InstantiatorGeneratorVisitor(false, t1).visit$1(expression);
      code.positionalArgumentCount = t1.count;
      t1 = this.backend.compiler.typesTask;
      t2 = t1.stringTypeCache;
      if (t2 == null) {
        t2 = new B.FlatTypeMask(t1.compiler.backend.get$stringImplementation(), 2);
        t1.stringTypeCache = t2;
        t1 = t2;
      } else
        t1 = t2;
      t2 = $.HInstruction_idCounter;
      if (typeof t2 !== "number")
        return t2.$add();
      $.HInstruction_idCounter = t2 + 1;
      t3 = [];
      t3.$builtinTypeInfo = [B.HInstruction];
      result = new B.HForeign(code, false, false, null, null, null, t2, inputs, t3, null, null, null, new Z.SideEffects(0), false, t1);
      result.HInstruction$2(inputs, t1);
      t1 = this._ssa$_current;
      t1.internalAddAfter$2(t1.last, result);
      result.notifyAddedToBlock$1(t1);
      return result;
    },
    handleListConstructor$3: function(type, currentNode, newObject) {
      var t1, inputs;
      t1 = this.backend;
      if (!(t1.rti.classesNeedingRti.contains$1(0, type.get$element().get$declaration()) || t1.compiler.enabledRuntimeType) || type.get$treatAsRaw())
        return newObject;
      inputs = H.setRuntimeTypeInfo([], [B.HInstruction]);
      type = this.localsHandler.substInContext$1(type);
      H.IterableMixinWorkaround_forEach(type.get$typeArguments(), new B.SsaBuilder_handleListConstructor_closure(this, inputs));
      t1 = this.work.registry;
      t1.compiler.enqueuer.codegen.registerInstantiatedType$2(type, t1);
      return this.callSetRuntimeTypeInfo$3(type.get$element(), inputs, newObject);
    },
    callSetRuntimeTypeInfo$3: function(element, rtiInputs, newObject) {
      var t1, t2, t3, typeInfo;
      t1 = this.backend;
      if (!(t1.rti.classesNeedingRti.contains$1(0, element.get$declaration()) || t1.compiler.enabledRuntimeType) || element.get$typeVariables().length === 0)
        return newObject;
      t2 = t1.extendableArrayType;
      t3 = $.HInstruction_idCounter;
      if (typeof t3 !== "number")
        return t3.$add();
      $.HInstruction_idCounter = t3 + 1;
      typeInfo = new B.HLiteralList(null, null, t3, rtiInputs, H.setRuntimeTypeInfo([], [B.HInstruction]), null, null, null, new Z.SideEffects(0), false, t2);
      typeInfo.HInstruction$2(rtiInputs, t2);
      this._ssa$_current.add$1(0, typeInfo);
      this.pushInvokeStatic$4(null, t1.find$2(0, t1.jsHelperLibrary, "setRuntimeTypeInfo"), H.setRuntimeTypeInfo([newObject, typeInfo], [B.HInstruction]), t1.compiler.typesTask.get$dynamicType());
      C.JSArray_methods.get$last(this.stack).set$instructionType(newObject.instructionType);
      t1 = this.stack;
      if (0 >= t1.length)
        return H.ioore(t1, 0);
      return t1.pop();
    },
    handleNewSend$1: function(node) {
      var t1, send, t2, isFixedListConstructorCall, t3, t4, isGrowableListConstructorCall, $constructor, selector, constructor0, isJSArrayTypedConstructor, isRedirected, type, expectedType, inputs, elementType, conversion, code, t5, canThrow, foreign, t6, cls, newInstance, checked;
      t1 = {};
      send = node.send;
      this.generateIsDeferredLoadedCheckIfNeeded$1(send);
      t1.isFixedList_0 = false;
      this.elements.toString;
      t2 = this.compiler;
      isFixedListConstructorCall = O.Elements_isFixedListConstructorCall(send.get$_secret_tree_element$_element(), send, t2);
      this.elements.toString;
      t3 = send.get$_secret_tree_element$_element();
      t4 = t2.get$unnamedListConstructor();
      if (t3 == null ? t4 == null : t3 === t4)
        if (!J.getInterceptor(send.selector).$isOperator && send.argumentsNode != null) {
          t3 = send.argumentsNode.nodes;
          t3 = t3.get$isEmpty(t3);
          isGrowableListConstructorCall = t3;
        } else
          isGrowableListConstructorCall = false;
      else
        isGrowableListConstructorCall = false;
      this.elements.toString;
      $constructor = send.get$_secret_tree_element$_element();
      t3 = this.elements._selectors;
      selector = t3 != null ? t3.$index(0, send) : null;
      constructor0 = $constructor.get$implementation($constructor).get$effectiveTarget();
      t3 = t2.symbolConstructor;
      t4 = this.backend;
      isJSArrayTypedConstructor = $constructor === t4.jsArrayTypedConstructor;
      if ($constructor === t3) {
        constructor0 = t2.symbolValidatedConstructor;
        selector = t2.symbolValidatedConstructorSelector;
      }
      isRedirected = $constructor.get$isRedirectingFactory();
      t3 = this.elements._types;
      type = t3 != null ? t3.$index(0, node) : null;
      expectedType = $constructor.computeEffectiveTargetType$1(type);
      expectedType = this.localsHandler.substInContext$1(expectedType);
      if (this.checkTypeVariableBounds$2(node, type))
        return;
      inputs = H.setRuntimeTypeInfo([], [B.HInstruction]);
      if (constructor0.get$kind(constructor0) === C.ElementKind_generative_constructor_16 && O.Elements_isNativeOrExtendsNative(constructor0.get$enclosingClass()))
        inputs.push(this.graph.addConstant$2(t2.backend.get$constantSystem().createNull$0(), t2));
      t3 = send.argumentsNode.nodes;
      if (!this.addStaticSendArgumentsToList$4(selector, t3, constructor0.get$implementation(constructor0), inputs)) {
        this.generateWrongArgumentCountError$3(send, constructor0, t3);
        return;
      }
      if (constructor0.get$isFactoryConstructor() && expectedType.get$typeArguments().length !== 0)
        this.work.registry.compiler.enqueuer.codegen.universe.usingFactoryWithTypeArguments = true;
      elementType = new B.SsaBuilder_handleNewSend_computeType(t1, this, send, isFixedListConstructorCall, isGrowableListConstructorCall).call$1(constructor0);
      if (isFixedListConstructorCall) {
        if (0 >= inputs.length)
          return H.ioore(inputs, 0);
        if (!inputs[0].isNumber$1(t2)) {
          t3 = t4.compiler.typesTask.get$numType();
          if (0 >= inputs.length)
            return H.ioore(inputs, 0);
          conversion = B.HTypeConversion$(null, 1, t3, inputs[0], null);
          this._ssa$_current.add$1(0, conversion);
          if (0 >= inputs.length)
            return H.ioore(inputs, 0);
          inputs[0] = conversion;
        }
        code = C.C_JsBuilder.parseForeignJS$1("Array(#)");
        t3 = [];
        t3.push(expectedType);
        if (0 >= inputs.length)
          return H.ioore(inputs, 0);
        if (inputs[0].isInteger$1(t2)) {
          if (0 >= inputs.length)
            return H.ioore(inputs, 0);
          t5 = !!J.getInterceptor(inputs[0]).$isHConstant;
        } else
          t5 = false;
        if (t5) {
          if (0 >= inputs.length)
            return H.ioore(inputs, 0);
          t5 = inputs[0].get$constant();
          t5 = t5.get$value(t5);
          if (typeof t5 !== "number")
            return t5.$ge();
          canThrow = !(t5 >= 0) || false;
        } else
          canThrow = true;
        foreign = B.HForeign$(code, elementType, inputs, canThrow, null, false, new L.NativeBehavior(t3, [], null, new Z.SideEffects(0)));
        this._ssa$_current.add$1(0, foreign);
        this.stack.push(foreign);
        if (t2.typesTask.typesInferrer.isFixedArrayCheckedForGrowable$1(send)) {
          t3 = B.HForeign$(C.C_JsBuilder.parseForeignJS$1("#.fixed$length = init"), t4.compiler.typesTask.get$nullType(), [C.JSArray_methods.get$last(this.stack)], true, null, false, null);
          this._ssa$_current.add$1(0, t3);
        }
      } else if (isGrowableListConstructorCall) {
        t3 = H.setRuntimeTypeInfo([], [B.HInstruction]);
        t5 = t4.extendableArrayType;
        t6 = $.HInstruction_idCounter;
        if (typeof t6 !== "number")
          return t6.$add();
        $.HInstruction_idCounter = t6 + 1;
        t6 = new B.HLiteralList(null, null, t6, t3, H.setRuntimeTypeInfo([], [B.HInstruction]), null, null, null, new Z.SideEffects(0), false, t5);
        t6.HInstruction$2(t3, t5);
        this._ssa$_current.add$1(0, t6);
        this.stack.push(t6);
        C.JSArray_methods.get$last(this.stack).set$instructionType(elementType);
      } else {
        cls = constructor0.get$enclosingClass();
        if (cls.get$isAbstract() && constructor0.kind === C.ElementKind_generative_constructor_16) {
          t1 = cls.name;
          this.pushInvokeStatic$3(send, t4.find$2(0, t4.jsHelperLibrary, "throwAbstractClassInstantiationError"), [this.addConstantString$1(t1)]);
          return;
        }
        this.potentiallyAddTypeArguments$3(inputs, cls, expectedType);
        t3 = expectedType != null;
        if (t3)
          this.currentInlinedInstantiations.push(expectedType);
        this.pushInvokeStatic$4(node, constructor0, inputs, elementType);
        if (t3) {
          t3 = this.currentInlinedInstantiations;
          if (0 >= t3.length)
            return H.ioore(t3, 0);
          t3.pop();
        }
      }
      newInstance = C.JSArray_methods.get$last(this.stack);
      if (t1.isFixedList_0) {
        newInstance.set$instructionType(elementType);
        this.work.compilationContext.get$allocatedFixedLists().add$1(0, newInstance);
      }
      if (t4.rti.classesNeedingRti.contains$1(0, t2.listClass.get$declaration()) || t4.compiler.enabledRuntimeType)
        t1 = isFixedListConstructorCall || isGrowableListConstructorCall || isJSArrayTypedConstructor;
      else
        t1 = false;
      if (t1) {
        t1 = this.stack;
        if (0 >= t1.length)
          return H.ioore(t1, 0);
        newInstance = this.handleListConstructor$3(type, send, t1.pop());
        this.stack.push(newInstance);
      }
      if (isRedirected) {
        checked = this.potentiallyCheckType$2(newInstance, type);
        if (checked == null ? newInstance != null : checked !== newInstance) {
          t1 = this.stack;
          if (0 >= t1.length)
            return H.ioore(t1, 0);
          t1.pop();
          this.stack.push(checked);
        }
      }
    },
    potentiallyAddTypeArguments$3: function(inputs, cls, expectedType) {
      var t1 = this.backend;
      if (!(t1.rti.classesNeedingRti.contains$1(0, cls.get$declaration()) || t1.compiler.enabledRuntimeType))
        return;
      H.IterableMixinWorkaround_forEach(expectedType.typeArguments, new B.SsaBuilder_potentiallyAddTypeArguments_closure(this, inputs));
    },
    checkTypeVariableBounds$2: function(node, type) {
      var t1, t2, seenChecksMap, t3, t4, instance;
      t1 = {};
      t2 = this.compiler;
      if (!t2.enableTypeAssertions)
        return false;
      seenChecksMap = P.LinkedHashMap_LinkedHashMap(null, null, null, V.DartType, [P.Set, V.DartType]);
      t1.definitelyFails_0 = false;
      t3 = new B.SsaBuilder_checkTypeVariableBounds_addTypeVariableBoundCheck(t1, this, node, type, seenChecksMap);
      t2.types.checkTypeVariableBounds$2(type, t3);
      if (t1.definitelyFails_0)
        return true;
      for (t4 = type.get$element().get$allSupertypes(), t4.toString, t4 = H.setRuntimeTypeInfo(new E.LinkIterator(null, t4), [H.getTypeArgumentByIndex(t4, 0)]); t4.moveNext$0();) {
        instance = type.asInstanceOf$1(t4._util_implementation$_current.get$element());
        t2.types.checkTypeVariableBounds$2(instance, t3);
        if (t1.definitelyFails_0)
          return true;
      }
      return false;
    },
    visitAssert$1: function(node) {
      var t1 = this.compiler;
      if (!t1.enableUserAssertions) {
        this.stack.push(this.graph.addConstant$2(t1.backend.get$constantSystem().createNull$0(), t1));
        return;
      }
      this.visitStaticSend$1(node);
    },
    visitStaticSend$1: function(node) {
      var t1, selector, element, t2, $name, link, t3, nativeBehavior, inputs, ssaType, t4, sideEffects, t5, closureSelector;
      t1 = this.elements._selectors;
      selector = t1 != null ? t1.$index(0, node) : null;
      this.elements.toString;
      element = node.get$_secret_tree_element$_element();
      t1 = this.elements._asserts;
      if (t1 != null && t1.contains$1(0, node) === true)
        element = this.backend.assertMethod;
      t1 = this.compiler;
      if (element.isForeign$1(t1) && element.get$isFunction()) {
        t2 = this.elements._selectors;
        selector = t2 != null ? t2.$index(0, node) : null;
        $name = J.get$name$x(selector);
        if ($name === "JS") {
          t2 = node.argumentsNode;
          link = t2.nodes;
          if (!link.get$isEmpty(link)) {
            t3 = link.get$tail();
            t3 = t3.get$isEmpty(t3);
          } else
            t3 = true;
          if (t3)
            t1.internalError$2(t2, "At least two arguments expected.");
          nativeBehavior = t1.enqueuer.resolution.nativeEnqueuer.getNativeBehaviorOf$1(node);
          inputs = H.setRuntimeTypeInfo([], [B.HInstruction]);
          this.addGenericSendArgumentsToList$2(link.get$tail().get$tail(), inputs);
          ssaType = B.TypeMaskFactory_fromNativeBehavior(nativeBehavior, t1);
          t1 = nativeBehavior.codeTemplate;
          if (t1.isExpression) {
            t1 = B.HForeign$(t1, ssaType, inputs, false, nativeBehavior.sideEffects, false, nativeBehavior);
            this._ssa$_current.add$1(0, t1);
            this.stack.push(t1);
          } else {
            t1 = B.HForeign$(t1, ssaType, inputs, true, nativeBehavior.sideEffects, true, nativeBehavior);
            this._ssa$_current.add$1(0, t1);
            this.stack.push(t1);
          }
        } else if ($name === "JS_CURRENT_ISOLATE_CONTEXT") {
          t2 = node.argumentsNode.nodes;
          if (!t2.get$isEmpty(t2))
            t1.internalError$2(node, "Too many arguments to JS_CURRENT_ISOLATE_CONTEXT.");
          t2 = this.backend;
          if (!t1.hasIsolateSupport) {
            t1 = B.HForeign$(C.C_JsBuilder.parseForeignJS$1(t2.namer.currentIsolate), t2.compiler.typesTask.get$dynamicType(), H.setRuntimeTypeInfo([], [B.HInstruction]), false, null, false, null);
            this._ssa$_current.add$1(0, t1);
            this.stack.push(t1);
          } else {
            element = t2.isolateHelperLibrary.find$1(0, "_currentIsolate");
            if (element == null)
              t1.internalError$2(node, "Isolate library and compiler mismatch.");
            this.pushInvokeStatic$4(null, element, [], t2.compiler.typesTask.get$dynamicType());
          }
        } else if ($name === "JS_CALL_IN_ISOLATE") {
          link = node.argumentsNode.nodes;
          if (!t1.hasIsolateSupport) {
            t1 = link.get$tail();
            t1 = t1.get$head(t1);
            if (t1 != null)
              J.accept$1$x(t1, this);
            selector = Z.Selector_Selector(C.SelectorKind_call_2, "call", null, 0, null);
            t1 = this.stack;
            if (0 >= t1.length)
              return H.ioore(t1, 0);
            t1 = H.setRuntimeTypeInfo([t1.pop()], [B.HInstruction]);
            t2 = this.backend.compiler.typesTask.get$dynamicType();
            t3 = $.HInstruction_idCounter;
            if (typeof t3 !== "number")
              return t3.$add();
            $.HInstruction_idCounter = t3 + 1;
            t4 = H.setRuntimeTypeInfo([], [B.HInstruction]);
            t3 = new B.HInvokeClosure(C.C_InvokeDynamicSpecializer, selector, null, null, null, t3, t1, t4, null, null, null, new Z.SideEffects(0), false, t2);
            t3.HInstruction$2(t1, t2);
            t2 = t3.sideEffects;
            t2.flags = (t2.flags | 7) >>> 0;
            t2.setDependsOnSomething$0();
            this._ssa$_current.add$1(0, t3);
            this.stack.push(t3);
          } else {
            t2 = this.backend;
            element = t2.isolateHelperLibrary.find$1(0, "_callInIsolate");
            if (element == null)
              t1.internalError$2(node, "Isolate library and compiler mismatch.");
            inputs = H.setRuntimeTypeInfo([], [B.HInstruction]);
            this.addGenericSendArgumentsToList$2(link, inputs);
            this.pushInvokeStatic$4(node, element, inputs, t2.compiler.typesTask.get$dynamicType());
          }
        } else if ($name === "DART_CLOSURE_TO_JS")
          this.handleForeignRawFunctionRef$2(node, "DART_CLOSURE_TO_JS");
        else if ($name === "RAW_DART_FUNCTION_REF")
          this.handleForeignRawFunctionRef$2(node, "RAW_DART_FUNCTION_REF");
        else if ($name === "JS_SET_CURRENT_ISOLATE") {
          t2 = node.argumentsNode;
          t3 = t2.nodes;
          if (!t3.get$isEmpty(t3)) {
            t4 = t3.get$tail();
            t4 = !t4.get$isEmpty(t4);
          } else
            t4 = true;
          if (t4)
            t1.internalError$2(t2, "Exactly one argument required.");
          t1 = t3.get$head(t3);
          if (t1 != null)
            J.accept$1$x(t1, this);
          t1 = this.backend;
          sideEffects = new Z.SideEffects(0);
          sideEffects.flags = 7;
          t2 = C.C_JsBuilder.parseForeignJS$1(t1.namer.currentIsolate + " = #");
          t1 = t1.compiler.typesTask.get$dynamicType();
          t3 = this.stack;
          if (0 >= t3.length)
            return H.ioore(t3, 0);
          t3 = B.HForeign$(t2, t1, H.setRuntimeTypeInfo([t3.pop()], [B.HInstruction]), false, sideEffects, false, null);
          this._ssa$_current.add$1(0, t3);
          this.stack.push(t3);
        } else if ($name === "JS_CREATE_ISOLATE") {
          t2 = node.argumentsNode;
          t3 = t2.nodes;
          if (!t3.get$isEmpty(t3))
            t1.internalError$2(t2, "Too many arguments.");
          t1 = this.backend;
          t1 = B.HForeign$(C.C_JsBuilder.parseForeignJS$1("new " + t1.namer.get$isolateName() + "()"), t1.compiler.typesTask.get$dynamicType(), H.setRuntimeTypeInfo([], [B.HInstruction]), false, null, false, null);
          this._ssa$_current.add$1(0, t1);
          this.stack.push(t1);
        } else if ($name === "JS_OPERATOR_IS_PREFIX")
          this.stack.push(this.addConstantString$1("$is"));
        else if ($name === "JS_OBJECT_CLASS_NAME") {
          $name = this.backend.namer.getRuntimeTypeName$1(t1.objectClass);
          this.stack.push(this.addConstantString$1($name));
        } else if ($name === "JS_NULL_CLASS_NAME") {
          $name = this.backend.namer.getRuntimeTypeName$1(t1.nullClass);
          this.stack.push(this.addConstantString$1($name));
        } else if ($name === "JS_FUNCTION_CLASS_NAME") {
          $name = this.backend.namer.getRuntimeTypeName$1(t1.functionClass);
          this.stack.push(this.addConstantString$1($name));
        } else if ($name === "JS_OPERATOR_AS_PREFIX")
          this.stack.push(this.addConstantString$1("$as"));
        else if ($name === "JS_SIGNATURE_NAME")
          this.stack.push(this.addConstantString$1("$signature"));
        else if ($name === "JS_FUNCTION_TYPE_TAG")
          this.stack.push(this.addConstantString$1("func"));
        else if ($name === "JS_FUNCTION_TYPE_VOID_RETURN_TAG")
          this.stack.push(this.addConstantString$1("void"));
        else if ($name === "JS_FUNCTION_TYPE_RETURN_TYPE_TAG")
          this.stack.push(this.addConstantString$1("ret"));
        else if ($name === "JS_FUNCTION_TYPE_REQUIRED_PARAMETERS_TAG")
          this.stack.push(this.addConstantString$1("args"));
        else if ($name === "JS_FUNCTION_TYPE_OPTIONAL_PARAMETERS_TAG")
          this.stack.push(this.addConstantString$1("opt"));
        else if ($name === "JS_FUNCTION_TYPE_NAMED_PARAMETERS_TAG")
          this.stack.push(this.addConstantString$1("named"));
        else if ($name === "JS_DART_OBJECT_CONSTRUCTOR") {
          t2 = node.argumentsNode;
          t3 = t2.nodes;
          if (!t3.get$isEmpty(t3))
            t1.internalError$2(t2, "Too many arguments.");
          t2 = this.backend;
          t2 = B.HForeign$(Q.Template$withExpressionResult(t2.namer.elementAccess$1(t1.objectClass)), t2.compiler.typesTask.get$dynamicType(), H.setRuntimeTypeInfo([], [B.HInstruction]), false, null, false, null);
          this._ssa$_current.add$1(0, t2);
          this.stack.push(t2);
        } else if ($name === "JS_IS_INDEXABLE_FIELD_NAME") {
          t1 = this.backend;
          element = t1.find$2(0, t1.jsHelperLibrary, "JavaScriptIndexingBehavior");
          this.stack.push(this.addConstantString$1("$is" + H.S(t1.namer.getRuntimeTypeName$1(element))));
        } else if ($name === "JS_CURRENT_ISOLATE") {
          t2 = node.argumentsNode;
          t3 = t2.nodes;
          if (!t3.get$isEmpty(t3))
            t1.internalError$2(t2, "Too many arguments.");
          t1 = this.backend;
          t1 = B.HForeign$(C.C_JsBuilder.parseForeignJS$1(t1.namer.currentIsolate), t1.compiler.typesTask.get$dynamicType(), H.setRuntimeTypeInfo([], [B.HInstruction]), false, null, false, null);
          this._ssa$_current.add$1(0, t1);
          this.stack.push(t1);
        } else if ($name === "JS_GET_NAME")
          this.handleForeignJsGetName$1(node);
        else if ($name === "JS_GET_FLAG")
          this.handleForeingJsGetFlag$1(node);
        else if ($name === "JS_EFFECT")
          this.stack.push(this.graph.addConstant$2(t1.backend.get$constantSystem().createNull$0(), t1));
        else if ($name === "JS_INTERCEPTOR_CONSTANT")
          this.handleJsInterceptorConstant$1(node);
        else if ($name === "JS_STRING_CONCAT") {
          inputs = H.setRuntimeTypeInfo([], [B.HInstruction]);
          t2 = node.argumentsNode;
          this.addGenericSendArgumentsToList$2(t2.nodes, inputs);
          if (inputs.length !== 2)
            t1.internalError$2(t2, "Two arguments expected.");
          t1 = inputs.length;
          if (0 >= t1)
            return H.ioore(inputs, 0);
          t2 = inputs[0];
          if (1 >= t1)
            return H.ioore(inputs, 1);
          t1 = inputs[1];
          t3 = this.backend.compiler.typesTask.get$stringType();
          t1 = H.setRuntimeTypeInfo([t2, t1], [B.HInstruction]);
          t2 = $.HInstruction_idCounter;
          if (typeof t2 !== "number")
            return t2.$add();
          $.HInstruction_idCounter = t2 + 1;
          t2 = new B.HStringConcat(node, null, null, t2, t1, H.setRuntimeTypeInfo([], [B.HInstruction]), null, null, null, new Z.SideEffects(0), false, t3);
          t2.HInstruction$2(t1, t3);
          t2.sideEffects.setDependsOnSomething$0();
          this._ssa$_current.add$1(0, t2);
          this.stack.push(t2);
        } else
          H.throwExpression("Unknown foreign: " + H.S(selector));
        return;
      }
      if (element.get$isErroneous()) {
        this.generateThrowNoSuchMethod$3$argumentNodes(node, this.noSuchMethodTargetSymbolString$1(element), node.argumentsNode.nodes);
        return;
      }
      K.invariant(element, element.kind !== C.ElementKind_generative_constructor_16, null);
      this.generateIsDeferredLoadedCheckIfNeeded$1(node);
      if (element.get$isFunction()) {
        inputs = H.setRuntimeTypeInfo([], [B.HInstruction]);
        t2 = node.argumentsNode.nodes;
        if (!this.addStaticSendArgumentsToList$4(selector, t2, element.get$implementation(element), inputs)) {
          this.generateWrongArgumentCountError$3(node, element, t2);
          return;
        }
        if (element === t1.identicalFunction) {
          t1 = inputs.length;
          if (0 >= t1)
            return H.ioore(inputs, 0);
          t2 = inputs[0];
          if (1 >= t1)
            return H.ioore(inputs, 1);
          t1 = inputs[1];
          t3 = this.backend.compiler.typesTask.get$boolType();
          t4 = H.setRuntimeTypeInfo([t2, t1], [B.HInstruction]);
          t5 = $.HInstruction_idCounter;
          if (typeof t5 !== "number")
            return t5.$add();
          $.HInstruction_idCounter = t5 + 1;
          t5 = new B.HIdentity(null, false, null, null, null, t5, t4, H.setRuntimeTypeInfo([], [B.HInstruction]), null, null, null, new Z.SideEffects(0), false, t3);
          t5.HInstruction$2(t4, t3);
          t5.HInvokeBinary$4(t2, t1, null, t3);
          t5 = this.attachPosition$2(t5, node);
          this._ssa$_current.add$1(0, t5);
          this.stack.push(t5);
          return;
        }
        this.pushInvokeStatic$3(node, element, inputs);
      } else {
        this.generateGetter$2(node, element);
        t1 = this.stack;
        if (0 >= t1.length)
          return H.ioore(t1, 0);
        inputs = H.setRuntimeTypeInfo([t1.pop()], [B.HInstruction]);
        this.addDynamicSendArgumentsToList$2(node, inputs);
        closureSelector = Z.Selector_Selector(C.SelectorKind_call_2, "call", null, selector.get$argumentCount(), selector.get$namedArguments());
        t1 = this.backend.compiler.typesTask.get$dynamicType();
        t2 = $.HInstruction_idCounter;
        if (typeof t2 !== "number")
          return t2.$add();
        $.HInstruction_idCounter = t2 + 1;
        t3 = H.setRuntimeTypeInfo([], [B.HInstruction]);
        t2 = new B.HInvokeClosure(C.C_InvokeDynamicSpecializer, closureSelector, null, null, null, t2, inputs, t3, null, null, null, new Z.SideEffects(0), false, t1);
        t2.HInstruction$2(inputs, t1);
        t1 = t2.sideEffects;
        t1.flags = (t1.flags | 7) >>> 0;
        t1.setDependsOnSomething$0();
        t2 = this.attachPosition$2(t2, node);
        this._ssa$_current.add$1(0, t2);
        this.stack.push(t2);
      }
    },
    addConstantString$1: function(string) {
      return this.graph.addConstant$2(this.constantSystem.createString$1(new Y.LiteralDartString(string)), this.compiler);
    },
    visitTypePrefixSend$1: function(node) {
      this.compiler.internalError$2(node, "visitTypePrefixSend should not be called.");
    },
    visitTypeLiteralSend$1: function(node) {
      var t1, type, t2, t3, t4, value, target, selector, inputs, closureSelector;
      t1 = this.elements._types;
      type = t1 != null ? t1.$index(0, node) : null;
      t1 = J.getInterceptor$x(type);
      if (t1.get$kind(type) === C.TypeKind_interface || t1.get$kind(type) === C.TypeKind_typedef || t1.get$kind(type) === C.TypeKind_dynamic) {
        t1 = node.selector;
        t2 = !J.getInterceptor(t1).$isOperator && node.argumentsNode != null;
        t3 = this.stack;
        t4 = this.graph;
        if (t2)
          t3.push(t4.addConstant$2(this.getConstantForNode$1(t1), this.compiler));
        else
          t3.push(t4.addConstant$2(this.getConstantForNode$1(node), this.compiler));
      } else if (t1.get$kind(type) === C.TypeKind_kuk) {
        value = this.analyzeTypeArgument$1(this.localsHandler.substInContext$1(type));
        t1 = this.backend;
        this.pushInvokeStatic$4(node, t1.find$2(0, t1.jsHelperLibrary, "runtimeTypeToString"), [value], t1.compiler.typesTask.get$stringType());
        t1 = t1.find$2(0, t1.jsHelperLibrary, "createRuntimeType");
        t2 = this.stack;
        if (0 >= t2.length)
          return H.ioore(t2, 0);
        this.pushInvokeStatic$3(node, t1, [t2.pop()]);
      } else
        this.compiler.internalError$2(node, "unexpected type kind " + t1.get$kind(type).id);
      if (!J.getInterceptor(node.selector).$isOperator && node.argumentsNode != null) {
        t1 = this.stack;
        if (0 >= t1.length)
          return H.ioore(t1, 0);
        target = t1.pop();
        t1 = this.elements._selectors;
        selector = t1 != null ? t1.$index(0, node) : null;
        inputs = H.setRuntimeTypeInfo([target], [B.HInstruction]);
        this.addDynamicSendArgumentsToList$2(node, inputs);
        closureSelector = Z.Selector_Selector(C.SelectorKind_call_2, "call", null, selector.get$argumentCount(), selector.get$namedArguments());
        t1 = this.backend.compiler.typesTask.get$dynamicType();
        t2 = $.HInstruction_idCounter;
        if (typeof t2 !== "number")
          return t2.$add();
        $.HInstruction_idCounter = t2 + 1;
        t3 = H.setRuntimeTypeInfo([], [B.HInstruction]);
        t2 = new B.HInvokeClosure(C.C_InvokeDynamicSpecializer, closureSelector, null, null, null, t2, inputs, t3, null, null, null, new Z.SideEffects(0), false, t1);
        t2.HInstruction$2(inputs, t1);
        t1 = t2.sideEffects;
        t1.flags = (t1.flags | 7) >>> 0;
        t1.setDependsOnSomething$0();
        this._ssa$_current.add$1(0, t2);
        this.stack.push(t2);
      }
    },
    visitGetterSend$1: function(node) {
      this.generateIsDeferredLoadedCheckIfNeeded$1(node);
      this.elements.toString;
      this.generateGetter$2(node, node.get$_secret_tree_element$_element());
    },
    internalError$2$node: function(reason, node) {
      this.compiler.internalError$2(node, reason);
    },
    generateThrowNoSuchMethod$5$argumentNodes$argumentValues$existingArguments: function(diagnosticNode, methodName, argumentNodes, argumentValues, existingArguments) {
      var t1, t2, helper, t3, t4, t5, receiver, $name, t6, $arguments, existingNames, name0, existingNamesList;
      t1 = {};
      t1.argumentValues_0 = argumentValues;
      t2 = this.backend;
      helper = t2.find$2(0, t2.jsHelperLibrary, "throwNoSuchMethod");
      t3 = this.constantSystem;
      t4 = this.graph;
      t5 = this.compiler;
      receiver = t4.addConstant$2(t3.createString$1(C.LiteralDartString_IUt), t5);
      $name = t4.addConstant$2(t3.createString$1(new Y.LiteralDartString(methodName)), t5);
      if (t1.argumentValues_0 == null) {
        t1.argumentValues_0 = H.setRuntimeTypeInfo([], [B.HInstruction]);
        argumentNodes.forEach$1(0, new B.SsaBuilder_generateThrowNoSuchMethod_closure(t1, this));
      }
      t1 = t1.argumentValues_0;
      t3 = t2.extendableArrayType;
      t6 = $.HInstruction_idCounter;
      if (typeof t6 !== "number")
        return t6.$add();
      $.HInstruction_idCounter = t6 + 1;
      $arguments = new B.HLiteralList(null, null, t6, t1, H.setRuntimeTypeInfo([], [B.HInstruction]), null, null, null, new Z.SideEffects(0), false, t3);
      $arguments.HInstruction$2(t1, t3);
      this._ssa$_current.add$1(0, $arguments);
      if (existingArguments != null) {
        existingNames = H.setRuntimeTypeInfo([], [B.HInstruction]);
        for (t1 = H.setRuntimeTypeInfo(new H.ListIterator(existingArguments, existingArguments.length, 0, null), [H.getTypeArgumentByIndex(existingArguments, 0)]); t1.moveNext$0();) {
          name0 = t1.__internal$_current;
          existingNames.push(t4.addConstant$2(t5.backend.get$constantSystem().createString$1(new Y.LiteralDartString(name0)), t5));
        }
        t1 = t2.extendableArrayType;
        t2 = $.HInstruction_idCounter;
        if (typeof t2 !== "number")
          return t2.$add();
        $.HInstruction_idCounter = t2 + 1;
        existingNamesList = new B.HLiteralList(null, null, t2, existingNames, H.setRuntimeTypeInfo([], [B.HInstruction]), null, null, null, new Z.SideEffects(0), false, t1);
        existingNamesList.HInstruction$2(existingNames, t1);
        this._ssa$_current.add$1(0, existingNamesList);
      } else
        existingNamesList = t4.addConstant$2(t5.backend.get$constantSystem().createNull$0(), t5);
      this.pushInvokeStatic$3(diagnosticNode, helper, [receiver, $name, $arguments, existingNamesList]);
    },
    generateThrowNoSuchMethod$3$argumentValues: function(diagnosticNode, methodName, argumentValues) {
      return this.generateThrowNoSuchMethod$5$argumentNodes$argumentValues$existingArguments(diagnosticNode, methodName, null, argumentValues, null);
    },
    generateThrowNoSuchMethod$3$argumentNodes: function(diagnosticNode, methodName, argumentNodes) {
      return this.generateThrowNoSuchMethod$5$argumentNodes$argumentValues$existingArguments(diagnosticNode, methodName, argumentNodes, null, null);
    },
    generateThrowNoSuchMethod$4$argumentNodes$existingArguments: function(diagnosticNode, methodName, argumentNodes, existingArguments) {
      return this.generateThrowNoSuchMethod$5$argumentNodes$argumentValues$existingArguments(diagnosticNode, methodName, argumentNodes, null, existingArguments);
    },
    generateWrongArgumentCountError$3: function(diagnosticNode, $function, argumentNodes) {
      var existingArguments = H.setRuntimeTypeInfo([], [P.String]);
      $function.get$functionSignature().forEachParameter$1(new B.SsaBuilder_generateWrongArgumentCountError_closure(existingArguments));
      this.generateThrowNoSuchMethod$4$argumentNodes$existingArguments(diagnosticNode, $function.name, argumentNodes, existingArguments);
    },
    visitNewExpression$1: function(node) {
      var t1, element, t2, t3, element0, nameString;
      t1 = node.send;
      this.elements.toString;
      element = t1.get$_secret_tree_element$_element();
      t2 = this.compiler;
      t3 = t2.symbolConstructor;
      element0 = !(element != null && element.get$isErroneous()) ? element.get$effectiveTarget() : element;
      if (element0 != null && element0.get$isErroneous())
        if (element0.get$messageKind() === C.MessageKind_ku2)
          this.generateThrowNoSuchMethod$3$argumentNodes(t1, this.noSuchMethodTargetSymbolString$2(element0, "constructor"), t1.argumentsNode.nodes);
        else {
          t2 = K.Message$(element0.get$messageKind(), element0.get$messageArguments(), false).computeMessage$0();
          t3 = this.backend;
          this.pushInvokeStatic$3(t1, t3.find$2(0, t3.jsHelperLibrary, "throwRuntimeError"), [this.addConstantString$1(t2)]);
        }
      else if (node.get$isConst()) {
        this.stack.push(this.graph.addConstant$2(this.getConstantForNode$1(node), t2));
        if (element == null ? t3 == null : element === t3) {
          nameString = J.get$value$x(C.JSArray_methods.get$single(this.getConstantForNode$1(node).get$fields())).slowToString$0();
          t1 = this.work.registry;
          t1.compiler.backend.registerConstSymbol$2(nameString, t1);
        }
      } else
        this.handleNewSend$1(node);
    },
    pushInvokeDynamic$4$location: function(node, selector, $arguments, $location) {
      var t1, element, t2, receiver, inputs, isIntercepted, type, t3;
      if ($location == null)
        $location = node;
      t1 = this.compiler;
      element = t1.world.locateSingleElement$1(selector);
      if (element != null)
        if (element.kind !== C.ElementKind_field_1)
          if (!(element.get$isGetter() && selector.kind === C.SelectorKind_call_2))
            t2 = !(element.get$isFunction() && selector.kind === C.SelectorKind_getter_0) && new B.SsaBuilder_pushInvokeDynamic_isOptimizableOperation(this, new B.SsaBuilder_pushInvokeDynamic_isOptimizableOperationOnIndexable(this)).call$2(selector, element) !== true;
          else
            t2 = false;
        else
          t2 = false;
      else
        t2 = false;
      if (t2)
        if (this.tryInlineMethod$4(element, selector, $arguments, node))
          return;
      if (0 >= $arguments.length)
        return H.ioore($arguments, 0);
      receiver = $arguments[0];
      inputs = H.setRuntimeTypeInfo([], [B.HInstruction]);
      isIntercepted = this.backend.interceptedElements.$index(0, selector.name) != null;
      if (isIntercepted)
        inputs.push(this.invokeInterceptor$1(receiver));
      C.JSArray_methods.addAll$1(inputs, $arguments);
      type = B.TypeMaskFactory_fromInferredType(t1.typesTask.getGuaranteedTypeOfSelector$1(selector), t1);
      t1 = selector.kind;
      if (t1 === C.SelectorKind_getter_0) {
        t1 = $.HInstruction_idCounter;
        if (typeof t1 !== "number")
          return t1.$add();
        $.HInstruction_idCounter = t1 + 1;
        t2 = H.setRuntimeTypeInfo([], [B.HInstruction]);
        t1 = new B.HInvokeDynamicGetter(C.C_InvokeDynamicSpecializer, selector, null, null, null, t1, inputs, t2, null, null, null, new Z.SideEffects(0), false, type);
        t1.HInstruction$2(inputs, type);
        t2 = t1.sideEffects;
        t2.flags = (t2.flags | 7) >>> 0;
        t2.setDependsOnSomething$0();
        t1 = this.attachPosition$2(t1, $location);
        this._ssa$_current.add$1(0, t1);
        this.stack.push(t1);
      } else {
        t2 = $.HInstruction_idCounter;
        if (t1 === C.SelectorKind_setter_1) {
          if (typeof t2 !== "number")
            return t2.$add();
          $.HInstruction_idCounter = t2 + 1;
          t1 = H.setRuntimeTypeInfo([], [B.HInstruction]);
          t1 = new B.HInvokeDynamicSetter(C.C_InvokeDynamicSpecializer, selector, null, null, null, t2, inputs, t1, null, null, null, new Z.SideEffects(0), false, type);
          t1.HInstruction$2(inputs, type);
          t2 = t1.sideEffects;
          t2.flags = (t2.flags | 7) >>> 0;
          t2.setDependsOnSomething$0();
          t1 = this.attachPosition$2(t1, $location);
          this._ssa$_current.add$1(0, t1);
          this.stack.push(t1);
        } else {
          if (typeof t2 !== "number")
            return t2.$add();
          $.HInstruction_idCounter = t2 + 1;
          t1 = H.setRuntimeTypeInfo([], [B.HInstruction]);
          t3 = isIntercepted ? B.InvokeDynamicSpecializer_lookupSpecializer(selector) : C.C_InvokeDynamicSpecializer;
          t1 = new B.HInvokeDynamicMethod(t3, selector, null, null, null, t2, inputs, t1, null, null, null, new Z.SideEffects(0), false, type);
          t1.HInstruction$2(inputs, type);
          t2 = t1.sideEffects;
          t2.flags = (t2.flags | 7) >>> 0;
          t2.setDependsOnSomething$0();
          t1 = this.attachPosition$2(t1, $location);
          this._ssa$_current.add$1(0, t1);
          this.stack.push(t1);
        }
      }
    },
    pushInvokeDynamic$3: function(node, selector, arguments) {
      return this.pushInvokeDynamic$4$location(node, selector, arguments, null);
    },
    pushInvokeStatic$4: function($location, element, $arguments, type) {
      var t1, t2, t3, t4, t5, instruction, sourceFile;
      if (this.tryInlineMethod$4(element, null, $arguments, $location))
        return;
      if (type == null) {
        t1 = this.compiler;
        type = B.TypeMaskFactory_fromInferredType(t1.typesTask.getGuaranteedReturnTypeOfElement$1(element), t1);
      }
      t1 = this.compiler;
      t2 = t1.world.elementsThatCannotThrow.contains$1(0, element);
      t3 = element.get$declaration();
      t4 = $.HInstruction_idCounter;
      if (typeof t4 !== "number")
        return t4.$add();
      $.HInstruction_idCounter = t4 + 1;
      t5 = [];
      t5.$builtinTypeInfo = [B.HInstruction];
      instruction = new B.HInvokeStatic(t3, !t2, null, null, null, t4, $arguments, t5, null, null, null, new Z.SideEffects(0), false, type);
      instruction.HInstruction$2($arguments, type);
      t2 = instruction.sideEffects;
      t3 = (t2.flags | 7) >>> 0;
      t2.flags = t3;
      t2.flags = (t3 | 56) >>> 0;
      t2 = this.currentInlinedInstantiations;
      if (t2.length !== 0)
        instruction.instantiatedTypes = P.List_List$from(t2, true, V.DartType);
      instruction.sideEffects = t1.world.getSideEffectsOfElement$1(element);
      if ($location == null) {
        t1 = this._ssa$_current;
        t1.internalAddAfter$2(t1.last, instruction);
        instruction.notifyAddedToBlock$1(t1);
        this.stack.push(instruction);
      } else {
        t1 = $location.getBeginToken$0();
        t2 = this.sourceElementStack;
        t3 = J.getInterceptor$ax(t2);
        sourceFile = J.get$implementation$x(t3.get$last(t2)).get$compilationUnit().get$script().file;
        $location = new T.TokenSourceFileLocation(t1, J.get$name$x(t3.get$last(t2)), sourceFile, null);
        t1 = t1.charOffset;
        if ($location.get$offset($location) >= sourceFile.get$length(sourceFile))
          H.throwExpression(C.MessageKind_tMf.message$1(0, P.LinkedHashMap_LinkedHashMap$_literal(["offset", t1, "fileName", sourceFile.filename, "length", sourceFile.get$length(sourceFile)], null, null)));
        instruction.sourcePosition = $location;
        t1 = this._ssa$_current;
        t1.internalAddAfter$2(t1.last, instruction);
        instruction.notifyAddedToBlock$1(t1);
        this.stack.push(instruction);
      }
    },
    pushInvokeStatic$3: function(location, element, arguments) {
      return this.pushInvokeStatic$4(location, element, arguments, null);
    },
    buildInvokeSuper$3: function(selector, element, $arguments) {
      var receiver, inputs, t1, t2, type, t3, t4, instruction;
      receiver = this.localsHandler.readThis$0();
      inputs = H.setRuntimeTypeInfo([], [B.HInstruction]);
      if (this.backend.interceptedElements.$index(0, selector.name) != null && element.get$kind(element) !== C.ElementKind_field_1)
        inputs.push(this.invokeInterceptor$1(receiver));
      inputs.push(receiver);
      C.JSArray_methods.addAll$1(inputs, $arguments);
      t1 = !element.get$isGetter() && selector.kind === C.SelectorKind_getter_0;
      t2 = this.compiler;
      type = t1 ? B.TypeMaskFactory_fromInferredType(t2.typesTask.getGuaranteedTypeOfElement$1(element), t2) : B.TypeMaskFactory_fromInferredType(t2.typesTask.getGuaranteedReturnTypeOfElement$1(element), t2);
      t1 = this.get$currentNonClosureClass();
      t3 = selector.kind;
      if (t3 !== C.SelectorKind_setter_1)
        t3 = t3 === C.SelectorKind_index_4 && selector.argumentCount === 2;
      else
        t3 = true;
      t4 = $.HInstruction_idCounter;
      if (typeof t4 !== "number")
        return t4.$add();
      $.HInstruction_idCounter = t4 + 1;
      instruction = new B.HInvokeSuper(t1, t3, selector, element, true, null, null, null, t4, inputs, H.setRuntimeTypeInfo([], [B.HInstruction]), null, null, null, new Z.SideEffects(0), false, type);
      instruction.HInstruction$2(inputs, type);
      t4 = instruction.sideEffects;
      t4.flags = (t4.flags | 7) >>> 0;
      t4.setDependsOnSomething$0();
      instruction.sideEffects = t2.world.getSideEffectsOfSelector$1(selector);
      return instruction;
    },
    handleComplexOperatorSend$3: function(node, receiver, $arguments) {
      var t1, rhs, t2;
      t1 = J.getInterceptor(node.argumentsNode);
      if (!!t1.$isPrefix0 || !!t1.$isPostfix0) {
        t1 = this.compiler;
        rhs = this.graph.addConstant$2(t1.backend.get$constantSystem().createInt$1(1), t1);
      } else {
        t1 = $arguments.get$head($arguments);
        if (t1 != null)
          J.accept$1$x(t1, this);
        t1 = this.stack;
        if (0 >= t1.length)
          return H.ioore(t1, 0);
        rhs = t1.pop();
      }
      t1 = node.assignmentOperator;
      t2 = this.elements._selectors;
      this.visitBinary$5(receiver, t1, rhs, t2 != null ? t2.$index(0, t1) : null, node);
    },
    visitSendSet$1: function(node) {
      var element, t1, op, t2, t3, setterInputs, result, getter, getterInputs, $arguments, t4, index, getterSelector, getterInstruction, setterSelector, t5, receiver, value, link;
      this.generateIsDeferredLoadedCheckIfNeeded$1(node);
      this.elements.toString;
      element = node.get$_secret_tree_element$_element();
      t1 = element != null;
      if (!(!t1 || element.get$isErroneous()) && element.get$impliesType()) {
        t1 = node.get$selector().get$token();
        this.generateThrowNoSuchMethod$3$argumentNodes(node, t1.get$value(t1), node.argumentsNode.nodes);
        return;
      }
      op = node.get$assignmentOperator();
      t2 = node.receiver;
      t3 = t2 != null;
      if (t3 && t2.isSuper$0()) {
        setterInputs = [];
        setterInputs.$builtinTypeInfo = [B.HInstruction];
        t2 = node.assignmentOperator.token;
        if (t2.get$value(t2) === "=") {
          this.addDynamicSendArgumentsToList$2(node, setterInputs);
          result = C.JSArray_methods.get$last(setterInputs);
        } else {
          t2 = this.elements;
          t3 = node.selector;
          t2.toString;
          getter = t3.get$_secret_tree_element$_element();
          getterInputs = [];
          getterInputs.$builtinTypeInfo = [B.HInstruction];
          t2 = node.argumentsNode;
          $arguments = t2.nodes;
          if (!!t3.$isOperator) {
            t4 = t3.asOperator$0().token;
            t4 = t4.get$value(t4) === "[]";
          } else
            t4 = false;
          if (t4) {
            t4 = $arguments.get$head($arguments);
            if (t4 != null)
              J.accept$1$x(t4, this);
            $arguments = $arguments.get$tail();
            t4 = this.stack;
            if (0 >= t4.length)
              return H.ioore(t4, 0);
            index = t4.pop();
            getterInputs.push(index);
            setterInputs.push(index);
          }
          t4 = this.elements._selectors;
          getterSelector = t4 != null ? t4.$index(0, t3) : null;
          if (getter == null || getter.get$isErroneous()) {
            this.generateSuperNoSuchMethodSend$3(node, getterSelector, getterInputs);
            t3 = this.stack;
            if (0 >= t3.length)
              return H.ioore(t3, 0);
            getterInstruction = t3.pop();
          } else {
            getterInstruction = this.buildInvokeSuper$3(getterSelector, getter, getterInputs);
            t3 = this._ssa$_current;
            t3.internalAddAfter$2(t3.last, getterInstruction);
            getterInstruction.notifyAddedToBlock$1(t3);
          }
          this.handleComplexOperatorSend$3(node, getterInstruction, $arguments);
          t3 = this.stack;
          if (0 >= t3.length)
            return H.ioore(t3, 0);
          setterInputs.push(t3.pop());
          result = !!J.getInterceptor(t2).$isPostfix0 ? getterInstruction : C.JSArray_methods.get$last(setterInputs);
        }
        t2 = this.elements._selectors;
        setterSelector = t2 != null ? t2.$index(0, node) : null;
        if (!t1 || element.get$isErroneous() || !setterSelector.applies$2(element, this.compiler)) {
          this.generateSuperNoSuchMethodSend$3(node, setterSelector, setterInputs);
          t1 = this.stack;
          if (0 >= t1.length)
            return H.ioore(t1, 0);
          t1.pop();
        } else {
          t1 = this.buildInvokeSuper$3(setterSelector, element, setterInputs);
          t2 = this._ssa$_current;
          t2.internalAddAfter$2(t2.last, t1);
          t1.notifyAddedToBlock$1(t2);
        }
        this.stack.push(result);
      } else {
        t1 = node.selector;
        t4 = !!J.getInterceptor(t1).$isOperator;
        if (t4) {
          t5 = t1.asOperator$0().token;
          t5 = t5.get$value(t5) === "[]";
        } else
          t5 = false;
        if (t5) {
          t5 = op.token;
          if ("=" === t5.get$value(t5))
            this.visitDynamicSend$1(node);
          else {
            if (t3)
              t2.accept$1(0, this);
            t2 = this.stack;
            if (0 >= t2.length)
              return H.ioore(t2, 0);
            receiver = t2.pop();
            t2 = node.argumentsNode;
            $arguments = t2.nodes;
            if (t4) {
              t3 = t1.asOperator$0().token;
              t3 = t3.get$value(t3) === "[]";
            } else
              t3 = false;
            if (t3) {
              t3 = $arguments.get$head($arguments);
              if (t3 != null)
                J.accept$1$x(t3, this);
              $arguments = $arguments.get$tail();
              t3 = this.stack;
              if (0 >= t3.length)
                return H.ioore(t3, 0);
              index = t3.pop();
            } else
              index = null;
            t3 = this.elements._selectors;
            t1 = t3 != null ? t3.$index(0, t1) : null;
            this.pushInvokeDynamic$3(node, t1, [receiver, index]);
            t1 = this.stack;
            if (0 >= t1.length)
              return H.ioore(t1, 0);
            getterInstruction = t1.pop();
            this.handleComplexOperatorSend$3(node, getterInstruction, $arguments);
            t1 = this.stack;
            if (0 >= t1.length)
              return H.ioore(t1, 0);
            value = t1.pop();
            t1 = this.elements._selectors;
            t1 = t1 != null ? t1.$index(0, node) : null;
            this.pushInvokeDynamic$3(node, t1, [receiver, index, value]);
            t1 = this.stack;
            if (0 >= t1.length)
              return H.ioore(t1, 0);
            t1.pop();
            t1 = this.stack;
            if (!!J.getInterceptor(t2).$isPostfix0)
              t1.push(getterInstruction);
            else
              t1.push(value);
          }
        } else {
          t2 = op.token;
          if ("=" === t2.get$value(t2)) {
            link = node.argumentsNode.nodes;
            if (O.Elements_isInstanceSend(node, this.elements)) {
              receiver = this.generateInstanceSendReceiver$1(node);
              t1 = link.get$head(link);
              if (t1 != null)
                J.accept$1$x(t1, this);
              t1 = this.stack;
              if (0 >= t1.length)
                return H.ioore(t1, 0);
              this.generateInstanceSetterWithCompiledReceiver$3(node, receiver, t1.pop());
            } else {
              t1 = link.get$head(link);
              if (t1 != null)
                J.accept$1$x(t1, this);
              t1 = this.stack;
              if (0 >= t1.length)
                return H.ioore(t1, 0);
              this.generateNonInstanceSetter$3(node, element, t1.pop());
            }
          } else if (t2.get$value(t2) === "is")
            this.compiler.internalError$2(op, "is-operator as SendSet.");
          else {
            this.elements.toString;
            getter = t1.get$_secret_tree_element$_element();
            if (!(getter == null || getter.get$isErroneous()) && getter.get$impliesType()) {
              t1 = t1.get$token();
              this.generateThrowNoSuchMethod$3$argumentNodes(node, t1.get$value(t1), node.argumentsNode.nodes);
              return;
            } else if (O.Elements_isInstanceSend(node, this.elements)) {
              receiver = this.generateInstanceSendReceiver$1(node);
              t2 = this.elements._selectors;
              t1 = t2 != null ? t2.$index(0, t1) : null;
              this.pushInvokeDynamic$3(node, t1, [receiver]);
            } else {
              this.generateGetter$2(node, getter);
              receiver = null;
            }
            t1 = this.stack;
            if (0 >= t1.length)
              return H.ioore(t1, 0);
            getterInstruction = t1.pop();
            t1 = node.argumentsNode;
            this.handleComplexOperatorSend$3(node, getterInstruction, t1.nodes);
            t2 = this.stack;
            if (0 >= t2.length)
              return H.ioore(t2, 0);
            value = t2.pop();
            if (O.Elements_isInstanceSend(node, this.elements))
              this.generateInstanceSetterWithCompiledReceiver$3(node, receiver, value);
            else
              this.generateNonInstanceSetter$3(node, element, value);
            if (!!J.getInterceptor(t1).$isPostfix0) {
              t1 = this.stack;
              if (0 >= t1.length)
                return H.ioore(t1, 0);
              t1.pop();
              this.stack.push(getterInstruction);
            }
          }
        }
      }
    },
    visitLiteralInt$1: function(node) {
      var t1, t2, t3;
      t1 = this.stack;
      t2 = node.get$value(node);
      t3 = this.compiler;
      t1.push(this.graph.addConstant$2(t3.backend.get$constantSystem().createInt$1(t2), t3));
    },
    visitLiteralDouble$1: function(node) {
      var t1, t2, t3;
      t1 = this.stack;
      t2 = node.get$value(node);
      t3 = this.compiler;
      t1.push(this.graph.addConstant$2(t3.backend.get$constantSystem().createDouble$1(t2), t3));
    },
    visitLiteralBool$1: function(node) {
      var t1, t2, t3;
      t1 = this.stack;
      t2 = node.get$value(node);
      t3 = this.compiler;
      t1.push(this.graph.addConstant$2(t3.backend.get$constantSystem().createBool$1(t2), t3));
    },
    visitLiteralString$1: function(node) {
      var t1 = this.compiler;
      this.stack.push(this.graph.addConstant$2(t1.backend.get$constantSystem().createString$1(node.dartString), t1));
    },
    visitLiteralSymbol$1: function(node) {
      var t1, t2;
      this.stack.push(this.graph.addConstant$2(this.getConstantForNode$1(node), this.compiler));
      t1 = this.work.registry;
      t2 = node.get$slowNameString();
      t1.compiler.backend.registerConstSymbol$2(t2, t1);
    },
    visitStringJuxtaposition$1: function(node) {
      var t1, t2, t3, stringBuilder;
      if (node.get$isInterpolation() !== true) {
        t1 = this.stack;
        t2 = node.get$dartString();
        t3 = this.compiler;
        t1.push(this.graph.addConstant$2(t3.backend.get$constantSystem().createString$1(t2), t3));
        return;
      }
      stringBuilder = new B.StringBuilderVisitor(this, node, null);
      node.accept$1(0, stringBuilder);
      this.stack.push(stringBuilder.result);
    },
    visitLiteralNull$1: function(node) {
      var t1 = this.compiler;
      this.stack.push(this.graph.addConstant$2(t1.backend.get$constantSystem().createNull$0(), t1));
    },
    visitNodeList$1: function(node) {
      var link, t1, t2;
      for (link = node.nodes, t1 = this.compiler; !link.get$isEmpty(link); link = link.get$tail())
        if (this._ssa$_current == null)
          t1.reportDiagnosticInternal$4(link.get$head(link), C.MessageKind_wwi, P.LinkedHashMap_LinkedHashMap$_literal(["text", "dead code"], null, null), C.Diagnostic_2_warning);
        else {
          t2 = link.get$head(link);
          if (t2 != null)
            J.accept$1$x(t2, this);
        }
    },
    visitParenthesizedExpression$1: function(node) {
      var t1 = node.expression;
      if (t1 != null)
        t1.accept$1(0, this);
    },
    visitOperator$1: function(node) {
      this.compiler.internalError$2(node, "SsaBuilder.visitOperator should not be called.");
    },
    visitCascade$1: function(node) {
      var t1 = node.expression;
      if (t1 != null)
        t1.accept$1(0, this);
      t1 = this.stack;
      if (0 >= t1.length)
        return H.ioore(t1, 0);
      t1.pop();
    },
    visitCascadeReceiver$1: function(node) {
      var t1 = node.expression;
      if (t1 != null)
        t1.accept$1(0, this);
      t1 = this.stack;
      t1.push(C.JSArray_methods.get$last(t1));
    },
    handleInTryStatement$0: function() {
      var t1, block, newBlock;
      if (!this.inTryStatement)
        return;
      t1 = $.HInstruction_idCounter;
      if (typeof t1 !== "number")
        return t1.$add();
      $.HInstruction_idCounter = t1 + 1;
      t1 = new B.HExitTry(null, null, t1, C.List_empty12, H.setRuntimeTypeInfo([], [B.HInstruction]), null, null, null, new Z.SideEffects(0), false, C.FlatTypeMask_null_0);
      t1.HInstruction$2(C.List_empty12, C.FlatTypeMask_null_0);
      block = this.close$1(0, t1);
      newBlock = this.graph.addNewBlock$0();
      block.addSuccessor$1(newBlock);
      newBlock.status = 1;
      this.isReachable = true;
      this._ssa$_current = newBlock;
      this.lastOpenedBlock = newBlock;
    },
    visitRethrow$1: function(node) {
      var exception, t1, t2;
      exception = this.rethrowableException;
      if (exception == null) {
        t1 = this.compiler;
        exception = this.graph.addConstant$2(t1.backend.get$constantSystem().createNull$0(), t1);
        t1.internalError$2(node, "rethrowableException should not be null.");
      }
      this.handleInTryStatement$0();
      t1 = H.setRuntimeTypeInfo([exception], [B.HInstruction]);
      t2 = $.HInstruction_idCounter;
      if (typeof t2 !== "number")
        return t2.$add();
      $.HInstruction_idCounter = t2 + 1;
      t2 = new B.HThrow(true, null, null, t2, t1, H.setRuntimeTypeInfo([], [B.HInstruction]), null, null, null, new Z.SideEffects(0), false, C.FlatTypeMask_null_0);
      t2.HInstruction$2(t1, C.FlatTypeMask_null_0);
      this.closeAndGotoExit$1(t2);
    },
    visitRedirectingFactoryBody$1: function(node) {
      var t1, targetConstructor, redirectingConstructor, inputs, targetSignature, redirectingSignature, targetOptionals, redirectingOptionals, i, parameter, targetType;
      this.elements.toString;
      t1 = node.get$_secret_tree_element$_element();
      targetConstructor = t1.get$implementation(t1);
      redirectingConstructor = J.get$implementation$x(J.get$last$ax(this.sourceElementStack));
      inputs = H.setRuntimeTypeInfo([], [B.HInstruction]);
      targetSignature = targetConstructor.get$functionSignature();
      redirectingSignature = redirectingConstructor.get$functionSignature();
      redirectingSignature.forEachRequiredParameter$1(new B.SsaBuilder_visitRedirectingFactoryBody_closure(this, inputs));
      targetOptionals = targetSignature.get$orderedOptionalParameters();
      redirectingOptionals = redirectingSignature.orderedOptionalParameters;
      for (i = 0; i < redirectingOptionals.length; ++i) {
        parameter = redirectingOptionals[i];
        inputs.push(this.localsHandler.readLocal$1(parameter));
      }
      for (; i < targetOptionals.length; ++i)
        inputs.push(this.handleConstantForOptionalParameter$1(targetOptionals[i]));
      t1 = this.backend;
      if (t1.rti.classesNeedingRti.contains$1(0, targetConstructor.get$enclosingClass().get$declaration()) || t1.compiler.enabledRuntimeType) {
        targetType = redirectingConstructor.computeEffectiveTargetType$1(redirectingConstructor.get$enclosingClass().get$thisType());
        H.IterableMixinWorkaround_forEach(this.localsHandler.substInContext$1(targetType).get$typeArguments(), new B.SsaBuilder_visitRedirectingFactoryBody_closure0(this, inputs));
      }
      this.pushInvokeStatic$3(node, targetConstructor, inputs);
      t1 = this.stack;
      if (0 >= t1.length)
        return H.ioore(t1, 0);
      this.emitReturn$2(t1.pop(), node);
    },
    visitReturn$1: function(node) {
      var t1, value;
      if (node.get$beginToken().get$stringValue() === "native") {
        L.handleSsaNative(this, node.expression);
        return;
      }
      t1 = node.expression;
      if (t1 == null) {
        t1 = this.compiler;
        value = this.graph.addConstant$2(t1.backend.get$constantSystem().createNull$0(), t1);
      } else {
        t1.accept$1(0, this);
        t1 = this.stack;
        if (0 >= t1.length)
          return H.ioore(t1, 0);
        value = this.potentiallyCheckType$2(t1.pop(), this.returnType);
      }
      this.handleInTryStatement$0();
      this.emitReturn$2(value, node);
    },
    visitThrow$1: function(node) {
      var t1, t2;
      this.visitThrowExpression$1(node.get$expression());
      if (this.isReachable) {
        this.handleInTryStatement$0();
        t1 = this.stack;
        if (0 >= t1.length)
          return H.ioore(t1, 0);
        t1 = H.setRuntimeTypeInfo([t1.pop()], [B.HInstruction]);
        t2 = $.HInstruction_idCounter;
        if (typeof t2 !== "number")
          return t2.$add();
        $.HInstruction_idCounter = t2 + 1;
        t2 = new B.HThrowExpression(null, null, t2, t1, H.setRuntimeTypeInfo([], [B.HInstruction]), null, null, null, new Z.SideEffects(0), false, C.FlatTypeMask_null_0);
        t2.HInstruction$2(t1, C.FlatTypeMask_null_0);
        this._ssa$_current.add$1(0, t2);
        this.stack.push(t2);
        this.isReachable = false;
      }
    },
    visitTypeAnnotation$1: function(node) {
      this.compiler.internalError$2(node, "Visiting type annotation in SSA builder.");
    },
    visitVariableDefinitions$1: function(node) {
      var link, t1, t2, definition, initialValue, local, t3;
      for (link = node.definitions.nodes, t1 = this.graph, t2 = this.compiler; !link.get$isEmpty(link); link = link.get$tail()) {
        definition = link.get$head(link);
        if (!!J.getInterceptor(definition).$isIdentifier) {
          initialValue = t1.addConstant$2(t2.backend.get$constantSystem().createNull$0(), t2);
          this.elements.toString;
          local = definition.get$_secret_tree_element$_element();
          this.localsHandler.updateLocal$2(local, initialValue);
        } else {
          this.visitSendSet$1(definition);
          t3 = this.stack;
          if (0 >= t3.length)
            return H.ioore(t3, 0);
          t3.pop();
        }
      }
    },
    setRtiIfNeeded$2: function(object, node) {
      var t1, t2, type, $arguments;
      t1 = this.localsHandler;
      t2 = this.elements._types;
      type = t1.substInContext$1(t2 != null ? t2.$index(0, node) : null);
      t1 = this.backend;
      if (!(t1.rti.classesNeedingRti.contains$1(0, type.get$element().get$declaration()) || t1.compiler.enabledRuntimeType) || type.get$treatAsRaw())
        return object;
      $arguments = H.setRuntimeTypeInfo([], [B.HInstruction]);
      for (t1 = type.get$typeArguments(), t1 = H.setRuntimeTypeInfo(new H.ListIterator(t1, t1.length, 0, null), [H.getTypeArgumentByIndex(t1, 0)]); t1.moveNext$0();)
        $arguments.push(this.analyzeTypeArgument$1(t1.__internal$_current));
      t1 = this.work.registry;
      t1.compiler.enqueuer.codegen.registerInstantiatedType$2(type, t1);
      return this.callSetRuntimeTypeInfo$3(type.get$element(), $arguments, object);
    },
    visitLiteralList$1: function(node) {
      var instruction, inputs, link, t1, t2, type;
      if (node.get$constKeyword() != null)
        instruction = this.graph.addConstant$2(this.getConstantForNode$1(node), this.compiler);
      else {
        inputs = H.setRuntimeTypeInfo([], [B.HInstruction]);
        for (link = node.elements.nodes; !link.get$isEmpty(link); link = link.get$tail()) {
          t1 = link.get$head(link);
          if (t1 != null)
            J.accept$1$x(t1, this);
          t1 = this.stack;
          if (0 >= t1.length)
            return H.ioore(t1, 0);
          inputs.push(t1.pop());
        }
        t1 = this.backend.extendableArrayType;
        t2 = $.HInstruction_idCounter;
        if (typeof t2 !== "number")
          return t2.$add();
        $.HInstruction_idCounter = t2 + 1;
        instruction = new B.HLiteralList(null, null, t2, inputs, H.setRuntimeTypeInfo([], [B.HInstruction]), null, null, null, new Z.SideEffects(0), false, t1);
        instruction.HInstruction$2(inputs, t1);
        this._ssa$_current.add$1(0, instruction);
        instruction = this.setRtiIfNeeded$2(instruction, node);
      }
      t1 = J.get$last$ax(this.sourceElementStack);
      t2 = this.compiler;
      type = B.TypeMaskFactory_fromInferredType(t2.typesTask.getGuaranteedTypeOfNode$2(t1, node), t2);
      if (!type.containsAll$1(t2))
        instruction.set$instructionType(type);
      this.stack.push(instruction);
    },
    visitConditional$1: function(node) {
      new B.SsaBranchBuilder(this, node)._handleDiamondBranch$4(new B.SsaBuilder_visitConditional_closure(this, node), new B.SsaBuilder_visitConditional_closure0(this, node), new B.SsaBuilder_visitConditional_closure1(this, node), true);
    },
    visitStringInterpolation$1: function(node) {
      var stringBuilder = new B.StringBuilderVisitor(this, node, null);
      node.accept$1(0, stringBuilder);
      this.stack.push(stringBuilder.result);
    },
    visitStringInterpolationPart$1: function(node) {
      this.compiler.internalError$2(node, "SsaBuilder.visitStringInterpolation should not be called.");
    },
    visitEmptyStatement$1: function(node) {
    },
    visitModifiers$1: function(node) {
      this.compiler.internalError$2(node, "SsaFromAstMixin.visitModifiers. not implemented.");
    },
    visitBreakStatement$1: function(node) {
      var t1, target, handler;
      this.handleInTryStatement$0();
      t1 = this.elements._usedTargets;
      target = t1 != null ? t1.$index(0, node) : null;
      handler = this.jumpTargets.$index(0, target);
      if (node.target == null)
        handler.generateBreak$0();
      else
        handler.generateBreak$1(this.elements.getTargetLabel$1(node));
    },
    visitContinueStatement$1: function(node) {
      var t1, target, handler;
      this.handleInTryStatement$0();
      t1 = this.elements._usedTargets;
      target = t1 != null ? t1.$index(0, node) : null;
      handler = this.jumpTargets.$index(0, target);
      if (node.target == null)
        handler.generateContinue$0();
      else
        handler.generateContinue$1(this.elements.getTargetLabel$1(node));
    },
    createJumpHandler$2$isLoopJump: function(node, isLoopJump) {
      var t1, element;
      t1 = this.elements._definedTargets;
      element = t1 != null ? t1.$index(0, node) : null;
      if (element != null) {
        t1 = element.get$statement();
        t1 = t1 == null ? node != null : t1 !== node;
      } else
        t1 = true;
      if (t1)
        return new B.NullJumpHandler(this.compiler);
      if (isLoopJump && !!J.getInterceptor(node).$isSwitchStatement)
        return B.SwitchCaseJumpHandler$(this, element, node);
      return B.TargetJumpHandler$(this, element);
    },
    visitForIn$1: function(node) {
      var t1 = {};
      t1.iterator_0 = null;
      this.handleLoop$5(node, new B.SsaBuilder_visitForIn_buildInitializer(t1, this, node), new B.SsaBuilder_visitForIn_buildCondition(t1, this, node), new B.SsaBuilder_visitForIn_closure(), new B.SsaBuilder_visitForIn_buildBody(t1, this, node));
    },
    visitLabel$1: function(node) {
      this.compiler.internalError$2(node, "SsaFromAstMixin.visitLabel.");
    },
    visitLabeledStatement$1: function(node) {
      var body, t1, t2, targetElement, beforeLocals, handler, entryBlock, joinBlock, breakHandlers, t3, t4;
      body = node.statement;
      t1 = J.getInterceptor(body);
      if (!!t1.$isLoop || !!t1.$isSwitchStatement || O.Elements_isUnusedLabel(node, this.elements)) {
        if (body != null)
          t1.accept$1(body, this);
        return;
      }
      t2 = this.elements._definedTargets;
      targetElement = t2 != null ? t2.$index(0, body) : null;
      beforeLocals = B.LocalsHandler$from0(this.localsHandler);
      handler = B.TargetJumpHandler$(this, targetElement);
      entryBlock = this.openNewBlock$0();
      if (body != null)
        t1.accept$1(body, this);
      t1 = this.lastOpenedBlock;
      joinBlock = this.graph.addNewBlock$0();
      breakHandlers = H.setRuntimeTypeInfo([], [B.LocalsHandler0]);
      handler.forEachBreak$1(new B.SsaBuilder_visitLabeledStatement_closure(joinBlock, breakHandlers));
      t2 = breakHandlers.length;
      t3 = this._ssa$_current;
      if (t3 != null) {
        t4 = $.HInstruction_idCounter;
        if (typeof t4 !== "number")
          return t4.$add();
        $.HInstruction_idCounter = t4 + 1;
        t4 = new B.HGoto(null, null, t4, C.List_empty12, H.setRuntimeTypeInfo([], [B.HInstruction]), null, null, null, new Z.SideEffects(0), false, C.FlatTypeMask_null_0);
        t4.HInstruction$2(C.List_empty12, C.FlatTypeMask_null_0);
        t3.close$1(0, t4);
        t3.addSuccessor$1(joinBlock);
        breakHandlers.push(this.localsHandler);
      }
      joinBlock.status = 1;
      this.isReachable = true;
      this._ssa$_current = joinBlock;
      this.lastOpenedBlock = joinBlock;
      this.localsHandler = beforeLocals.mergeMultiple$2(breakHandlers, joinBlock);
      if (t2 > 0) {
        t2 = handler.labels$0(0);
        if (0 >= t2.length)
          return H.ioore(t2, 0);
        entryBlock.blockFlow = new B.HBlockFlow(new B.HLabeledBlockInformation(new B.HSubGraphBlockInformation(new B.SubGraph(entryBlock, t1)), t2, J.get$target$x(t2[0]), false), joinBlock);
      }
      handler.builder.jumpTargets.remove$1(0, handler.target);
    },
    visitLiteralMap$1: function(node) {
      var listInputs, link, t1, inputs, $constructor, t2, t3, keyValuePairs, constructor0, expectedType, cls, instructionType;
      if (node.constKeyword != null) {
        this.stack.push(this.graph.addConstant$2(this.getConstantForNode$1(node), this.compiler));
        return;
      }
      listInputs = H.setRuntimeTypeInfo([], [B.HInstruction]);
      for (link = node.entries.nodes; !link.get$isEmpty(link); link = link.get$tail()) {
        t1 = link.get$head(link);
        if (t1 != null)
          J.accept$1$x(t1, this);
        t1 = this.stack;
        if (0 >= t1.length)
          return H.ioore(t1, 0);
        listInputs.push(t1.pop());
        t1 = this.stack;
        if (0 >= t1.length)
          return H.ioore(t1, 0);
        listInputs.push(t1.pop());
      }
      inputs = H.setRuntimeTypeInfo([], [B.HInstruction]);
      t1 = this.backend;
      if (listInputs.length === 0)
        $constructor = t1.mapLiteralConstructorEmpty;
      else {
        $constructor = t1.mapLiteralConstructor;
        t2 = t1.extendableArrayType;
        t3 = $.HInstruction_idCounter;
        if (typeof t3 !== "number")
          return t3.$add();
        $.HInstruction_idCounter = t3 + 1;
        keyValuePairs = new B.HLiteralList(null, null, t3, listInputs, H.setRuntimeTypeInfo([], [B.HInstruction]), null, null, null, new Z.SideEffects(0), false, t2);
        keyValuePairs.HInstruction$2(listInputs, t2);
        this._ssa$_current.add$1(0, keyValuePairs);
        inputs.push(keyValuePairs);
      }
      constructor0 = $constructor.get$effectiveTarget();
      t2 = this.elements._types;
      expectedType = $constructor.computeEffectiveTargetType$1(t2 != null ? t2.$index(0, node) : null);
      expectedType = this.localsHandler.substInContext$1(expectedType);
      if (constructor0.get$isFactoryConstructor())
        this.work.registry.compiler.enqueuer.codegen.universe.usingFactoryWithTypeArguments = true;
      cls = constructor0.get$enclosingClass();
      if (t1.rti.classesNeedingRti.contains$1(0, cls.get$declaration()) || t1.compiler.enabledRuntimeType) {
        cls.get$typeVariables();
        H.IterableMixinWorkaround_forEach(expectedType.get$typeArguments(), new B.SsaBuilder_visitLiteralMap_closure(this, inputs));
      }
      t2 = this.compiler;
      instructionType = new B.FlatTypeMask(t1.mapLiteralClass, 6).intersection$2(0, B.TypeMaskFactory_fromInferredType(t2.typesTask.getGuaranteedReturnTypeOfElement$1(constructor0), t2), t2);
      t1 = expectedType != null;
      if (t1)
        this.currentInlinedInstantiations.push(expectedType);
      this.pushInvokeStatic$4(node, constructor0, inputs, instructionType);
      if (t1) {
        t1 = this.currentInlinedInstantiations;
        if (0 >= t1.length)
          return H.ioore(t1, 0);
        t1.pop();
      }
    },
    visitLiteralMapEntry$1: function(node) {
      var t1 = node.value;
      if (t1 != null)
        t1.accept$1(0, this);
      t1 = node.key;
      if (t1 != null)
        t1.accept$1(0, this);
    },
    visitNamedArgument$1: function(node) {
      var t1 = node.expression;
      if (t1 != null)
        t1.accept$1(0, this);
    },
    buildSwitchCaseConstants$1: function(node) {
      var constants, t1, t2, t3, labelOrCase;
      constants = P.LinkedHashMap_LinkedHashMap(null, null, null, Y.CaseMatch, K.Constant);
      for (t1 = node.cases.nodes, t1.toString, t1 = H.setRuntimeTypeInfo(new E.LinkIterator(null, t1), [H.getTypeArgumentByIndex(t1, 0)]); t1.moveNext$0();) {
        t2 = t1._util_implementation$_current.get$labelsAndCases().nodes;
        t2.toString;
        t3 = new E.LinkIterator(null, t2);
        t3.$builtinTypeInfo = [H.getTypeArgumentByIndex(t2, 0)];
        for (; t3.moveNext$0();) {
          labelOrCase = t3._util_implementation$_current;
          if (!!J.getInterceptor(labelOrCase).$isCaseMatch)
            constants.$indexSet(0, labelOrCase, this.getConstantForNode$1(labelOrCase.expression));
        }
      }
      return constants;
    },
    visitSwitchStatement$1: function(node) {
      var constants, caseIndex, t1, hasContinue, switchIndex, hasDefault, switchCase, t2, t3, label, labelElement;
      constants = this.buildSwitchCaseConstants$1(node);
      caseIndex = P.LinkedHashMap_LinkedHashMap(null, null, null, Y.SwitchCase, P.$int);
      for (t1 = node.cases.nodes, t1.toString, t1 = H.setRuntimeTypeInfo(new E.LinkIterator(null, t1), [H.getTypeArgumentByIndex(t1, 0)]), hasContinue = false, switchIndex = 1, hasDefault = false; t1.moveNext$0();) {
        switchCase = t1._util_implementation$_current;
        t2 = switchCase.get$labelsAndCases().nodes;
        t2.toString;
        t3 = new E.LinkIterator(null, t2);
        t3.$builtinTypeInfo = [H.getTypeArgumentByIndex(t2, 0)];
        for (; t3.moveNext$0();) {
          label = t3._util_implementation$_current.asLabel$0();
          if (label != null) {
            t2 = this.elements._definedLabels;
            labelElement = t2 != null ? t2.$index(0, label) : null;
            if (labelElement != null && labelElement.get$isContinueTarget())
              hasContinue = true;
          }
        }
        if (switchCase.defaultKeyword != null)
          hasDefault = true;
        caseIndex.$indexSet(0, switchCase, switchIndex);
        ++switchIndex;
      }
      if (!hasContinue)
        this.buildSimpleSwitchStatement$2(node, constants);
      else
        this.buildComplexSwitchStatement$4(node, constants, caseIndex, hasDefault);
    },
    buildSimpleSwitchStatement$2: function(node, constants) {
      var jumpHandler = this.createJumpHandler$2$isLoopJump(node, false);
      this.handleSwitch$7(node, jumpHandler, new B.SsaBuilder_buildSimpleSwitchStatement_buildExpression(this, node), node.cases, new B.SsaBuilder_buildSimpleSwitchStatement_getConstants(constants), new B.SsaBuilder_buildSimpleSwitchStatement_isDefaultCase(), new B.SsaBuilder_buildSimpleSwitchStatement_buildSwitchCase(this));
      jumpHandler.close$0(0);
    },
    buildComplexSwitchStatement$4: function(node, constants, caseIndex, hasDefault) {
      var t1, switchTarget, initialValue, jumpHandler, switchCases;
      t1 = this.elements._definedTargets;
      switchTarget = t1 != null ? t1.$index(0, node) : null;
      t1 = this.compiler;
      initialValue = this.graph.addConstant$2(t1.backend.get$constantSystem().createNull$0(), t1);
      this.localsHandler.updateLocal$2(switchTarget, initialValue);
      jumpHandler = this.createJumpHandler$2$isLoopJump(node, false);
      switchCases = node.cases;
      if (!hasDefault) {
        switchCases = switchCases.nodes.toList$0(0);
        C.JSArray_methods.add$1(switchCases, null);
      }
      this.handleSwitch$7(node, jumpHandler, new B.SsaBuilder_buildComplexSwitchStatement_buildExpression(this, node), switchCases, new B.SsaBuilder_buildComplexSwitchStatement_getConstants(constants), new B.SsaBuilder_buildComplexSwitchStatement_isDefaultCase(), new B.SsaBuilder_buildComplexSwitchStatement_buildSwitchCase(this, caseIndex, switchTarget));
      jumpHandler.close$0(0);
      t1 = new B.SsaBuilder_buildComplexSwitchStatement_buildLoop(this, node, new B.SsaBuilder_buildComplexSwitchStatement_buildCondition(this), new B.SsaBuilder_buildComplexSwitchStatement_buildSwitch(this, node, caseIndex, switchTarget));
      if (hasDefault)
        t1.call$0();
      else
        new B.SsaBranchBuilder(this, node).handleIf$3(new B.SsaBuilder_buildComplexSwitchStatement_buildCondition0(this, switchTarget), t1, new B.SsaBuilder_buildComplexSwitchStatement_closure());
    },
    handleSwitch$7: function(errorNode, jumpHandler, buildExpression, switchCases, getConstants, isDefaultCase, buildSwitchCase) {
      var t1, expressionStart, expression, t2, t3, t4, switchInstruction, expressionEnd, savedLocals, statements, getFallThroughErrorElement, caseIterator, t5, hasDefault, t6, result, t7, result0, hConstant, t8, caseHandlers, block;
      t1 = {};
      P.LinkedHashMap_LinkedHashMap(null, null, null, Y.CaseMatch, K.Constant);
      expressionStart = this.openNewBlock$0();
      expression = buildExpression.call$0();
      t2 = J.getInterceptor$asx(switchCases);
      if (t2.get$isEmpty(switchCases))
        return;
      t3 = H.setRuntimeTypeInfo([expression], [B.HInstruction]);
      t4 = $.HInstruction_idCounter;
      if (typeof t4 !== "number")
        return t4.$add();
      $.HInstruction_idCounter = t4 + 1;
      switchInstruction = new B.HSwitch(null, null, t4, t3, H.setRuntimeTypeInfo([], [B.HInstruction]), null, null, null, new Z.SideEffects(0), false, C.FlatTypeMask_null_0);
      switchInstruction.HInstruction$2(t3, C.FlatTypeMask_null_0);
      expressionEnd = this.close$1(0, switchInstruction);
      savedLocals = this.localsHandler;
      statements = H.setRuntimeTypeInfo([], [B.HStatementInformation]);
      t4 = this.backend;
      getFallThroughErrorElement = t4.find$2(0, t4.jsHelperLibrary, "getFallThroughError");
      caseIterator = H.setRuntimeTypeInfo(new P.HasNextIterator(t2.get$iterator(switchCases), 2), [Y.Node]);
      t2 = this.graph;
      t4 = this.compiler;
      t5 = caseIterator._collection$_iterator;
      hasDefault = false;
      while (true) {
        t6 = caseIterator._collection$_state;
        if (t6 === 2)
          if (t5.moveNext$0()) {
            caseIterator._collection$_state = 0;
            t6 = 0;
          } else {
            caseIterator._collection$_state = 1;
            t6 = 1;
          }
        if (!(t6 === 0))
          break;
        if (t6 === 2)
          if (t5.moveNext$0()) {
            caseIterator._collection$_state = 0;
            t6 = 0;
          } else {
            caseIterator._collection$_state = 1;
            t6 = 1;
          }
        if (t6 !== 0)
          H.throwExpression(P.StateError$("No more elements"));
        result = t5.get$current();
        if (t5.moveNext$0())
          caseIterator._collection$_state = 0;
        else
          caseIterator._collection$_state = 1;
        t6 = [];
        t6.$builtinTypeInfo = [B.HBasicBlock];
        t7 = [];
        t7.$builtinTypeInfo = [B.HBasicBlock];
        result0 = new B.HBasicBlock(null, 0, new B.HInstructionList(null, null), null, null, null, true, t6, C.List_empty13, null, t7, null, null, null);
        t7 = t2.blocks;
        result0.id = t7.length;
        t7.push(result0);
        for (t7 = J.get$iterator$ax(getConstants.call$1(result)); t7.moveNext$0();) {
          hConstant = t2.addConstant$2(t7.get$current(), t4);
          t3.push(hConstant);
          hConstant.usedBy.push(switchInstruction);
          t8 = expressionEnd.successors;
          if (t8.length === 0)
            expressionEnd.successors = [result0];
          else
            C.JSArray_methods.add$1(t8, result0);
          t6.push(expressionEnd);
        }
        if (isDefaultCase.call$1(result) === true) {
          t7 = expressionEnd.successors;
          if (t7.length === 0)
            expressionEnd.successors = [result0];
          else
            C.JSArray_methods.add$1(t7, result0);
          t6.push(expressionEnd);
          hasDefault = true;
        }
        result0.status = 1;
        this.isReachable = true;
        this._ssa$_current = result0;
        this.lastOpenedBlock = result0;
        this.localsHandler = B.LocalsHandler$from0(savedLocals);
        buildSwitchCase.call$1(result);
        if (this._ssa$_current != null) {
          t6 = caseIterator._collection$_state;
          if (t6 === 2)
            if (t5.moveNext$0()) {
              caseIterator._collection$_state = 0;
              t6 = 0;
            } else {
              caseIterator._collection$_state = 1;
              t6 = 1;
            }
          if (t6 === 0) {
            this.pushInvokeStatic$3(result, getFallThroughErrorElement, []);
            t6 = this.stack;
            if (0 >= t6.length)
              return H.ioore(t6, 0);
            t6 = [t6.pop()];
            t6.$builtinTypeInfo = [B.HInstruction];
            t7 = $.HInstruction_idCounter;
            if (typeof t7 !== "number")
              return t7.$add();
            $.HInstruction_idCounter = t7 + 1;
            t8 = [];
            t8.$builtinTypeInfo = [B.HInstruction];
            t7 = new B.HThrow(false, null, null, t7, t6, t8, null, null, null, new Z.SideEffects(0), false, C.FlatTypeMask_null_0);
            t7.HInstruction$2(t6, C.FlatTypeMask_null_0);
            result = this._ssa$_current;
            result.addAfter$2(result.last, t7);
            result.status = 2;
            this.isReachable = false;
            this._ssa$_current = null;
            t7 = t2.exit;
            t6 = result.successors;
            if (t6.length === 0)
              result.successors = [t7];
            else
              C.JSArray_methods.add$1(t6, t7);
            t7.predecessors.push(result);
          } else if (isDefaultCase.call$1(result) !== true)
            jumpHandler.generateBreak$0();
        }
        statements.push(new B.HSubGraphBlockInformation(new B.SubGraph(result0, this.lastOpenedBlock)));
      }
      t1.joinBlock_0 = new B.HBasicBlock(null, 0, new B.HInstructionList(null, null), null, null, null, true, H.setRuntimeTypeInfo([], [B.HBasicBlock]), C.List_empty13, null, H.setRuntimeTypeInfo([], [B.HBasicBlock]), null, null, null);
      caseHandlers = H.setRuntimeTypeInfo([], [B.LocalsHandler0]);
      jumpHandler.forEachBreak$1(new B.SsaBuilder_handleSwitch_closure(t1, caseHandlers));
      jumpHandler.forEachContinue$1(new B.SsaBuilder_handleSwitch_closure0(this, errorNode));
      t3 = this._ssa$_current;
      if (t3 != null) {
        t4 = $.HInstruction_idCounter;
        if (typeof t4 !== "number")
          return t4.$add();
        $.HInstruction_idCounter = t4 + 1;
        t4 = new B.HGoto(null, null, t4, C.List_empty12, H.setRuntimeTypeInfo([], [B.HInstruction]), null, null, null, new Z.SideEffects(0), false, C.FlatTypeMask_null_0);
        t4.HInstruction$2(C.List_empty12, C.FlatTypeMask_null_0);
        t3.close$1(0, t4);
        this.lastOpenedBlock.addSuccessor$1(t1.joinBlock_0);
        caseHandlers.push(this.localsHandler);
      }
      if (!hasDefault) {
        block = t2.addNewBlock$0();
        expressionEnd.addSuccessor$1(block);
        block.status = 1;
        this.isReachable = true;
        this._ssa$_current = block;
        this.lastOpenedBlock = block;
        t3 = $.HInstruction_idCounter;
        if (typeof t3 !== "number")
          return t3.$add();
        $.HInstruction_idCounter = t3 + 1;
        t3 = new B.HGoto(null, null, t3, C.List_empty12, H.setRuntimeTypeInfo([], [B.HInstruction]), null, null, null, new Z.SideEffects(0), false, C.FlatTypeMask_null_0);
        t3.HInstruction$2(C.List_empty12, C.FlatTypeMask_null_0);
        this.close$1(0, t3);
        block.addSuccessor$1(t1.joinBlock_0);
        caseHandlers.push(savedLocals);
        statements.push(new B.HSubGraphBlockInformation(new B.SubGraph(block, block)));
      }
      if (caseHandlers.length !== 0) {
        t2.addBlock$1(t1.joinBlock_0);
        t2 = t1.joinBlock_0;
        t2.status = 1;
        this.isReachable = t2 != null;
        this._ssa$_current = t2;
        this.lastOpenedBlock = t2;
        t3 = caseHandlers.length;
        if (t3 === 1) {
          if (0 >= t3)
            return H.ioore(caseHandlers, 0);
          this.localsHandler = caseHandlers[0];
        } else
          this.localsHandler = savedLocals.mergeMultiple$2(caseHandlers, t2);
      } else
        t1.joinBlock_0 = null;
      expressionStart.blockFlow = new B.HBlockFlow(new B.HSwitchBlockInformation(new B.HSubExpressionBlockInformation(new B.SubExpression(expressionStart, expressionEnd)), statements, jumpHandler.get$target(jumpHandler), jumpHandler.labels$0(0)), t1.joinBlock_0);
      jumpHandler.close$0(0);
    },
    visitSwitchCase$1: function(node) {
      this.compiler.internalError$2(node, "SsaFromAstMixin.visitSwitchCase.");
    },
    visitCaseMatch$1: function(node) {
      this.compiler.internalError$2(node, "SsaFromAstMixin.visitCaseMatch.");
    },
    visitTryStatement$1: function(node) {
      var t1, savedLocals, enterBlock, t2, tryInstruction, oldInTryStatement, startTryBlock, t3, endTryBlock, t4, t5, startCatchBlock, t6, t7, t8, t9, t10, exception, oldRethrowableException, unwrappedException, endCatchBlock, catchGraph, startFinallyBlock, endFinallyBlock, finallyGraph, exitBlock;
      t1 = {};
      savedLocals = B.LocalsHandler$from0(this.localsHandler);
      enterBlock = this.openNewBlock$0();
      t2 = $.HInstruction_idCounter;
      if (typeof t2 !== "number")
        return t2.$add();
      $.HInstruction_idCounter = t2 + 1;
      tryInstruction = new B.HTry(null, null, null, null, null, t2, C.List_empty12, H.setRuntimeTypeInfo([], [B.HInstruction]), null, null, null, new Z.SideEffects(0), false, C.FlatTypeMask_null_0);
      tryInstruction.HInstruction$2(C.List_empty12, C.FlatTypeMask_null_0);
      this.close$1(0, tryInstruction);
      oldInTryStatement = this.inTryStatement;
      this.inTryStatement = true;
      t1.startTryBlock_0 = null;
      t2 = this.graph;
      startTryBlock = t2.addNewBlock$0();
      t1.startTryBlock_0 = startTryBlock;
      startTryBlock.status = 1;
      this.isReachable = true;
      this._ssa$_current = startTryBlock;
      this.lastOpenedBlock = startTryBlock;
      t3 = node.tryBlock;
      if (t3 != null)
        t3.accept$1(0, this);
      if (this._ssa$_current != null) {
        t3 = $.HInstruction_idCounter;
        if (typeof t3 !== "number")
          return t3.$add();
        $.HInstruction_idCounter = t3 + 1;
        t3 = new B.HExitTry(null, null, t3, C.List_empty12, H.setRuntimeTypeInfo([], [B.HInstruction]), null, null, null, new Z.SideEffects(0), false, C.FlatTypeMask_null_0);
        t3.HInstruction$2(C.List_empty12, C.FlatTypeMask_null_0);
        endTryBlock = this.close$1(0, t3);
      } else
        endTryBlock = null;
      t3 = t1.startTryBlock_0;
      t4 = this.lastOpenedBlock;
      t1.exception_1 = null;
      t5 = node.catchBlocks.nodes;
      if (!t5.get$isEmpty(t5)) {
        this.localsHandler = B.LocalsHandler$from0(savedLocals);
        startCatchBlock = t2.addNewBlock$0();
        startCatchBlock.status = 1;
        this.isReachable = true;
        this._ssa$_current = startCatchBlock;
        this.lastOpenedBlock = startCatchBlock;
        t6 = this.localsHandler.executableContext;
        t7 = this.backend;
        t8 = t7.nonNullType;
        t9 = H.setRuntimeTypeInfo([], [B.HInstruction]);
        t10 = $.HInstruction_idCounter;
        if (typeof t10 !== "number")
          return t10.$add();
        $.HInstruction_idCounter = t10 + 1;
        exception = new B.HLocalValue(null, null, t10, t9, H.setRuntimeTypeInfo([], [B.HInstruction]), null, null, null, new Z.SideEffects(0), false, t8);
        exception.HInstruction$2(t9, t8);
        exception.sourceElement = new B.SyntheticLocal("exception", t6);
        t1.exception_1 = exception;
        this._ssa$_current.add$1(0, exception);
        oldRethrowableException = this.rethrowableException;
        this.rethrowableException = t1.exception_1;
        this.pushInvokeStatic$3(node, t7.find$2(0, t7.jsHelperLibrary, "unwrapException"), [t1.exception_1]);
        t7 = this.stack;
        if (0 >= t7.length)
          return H.ioore(t7, 0);
        unwrappedException = t7.pop();
        tryInstruction.exception = t1.exception_1;
        t1.link_2 = t5;
        t7 = new B.SsaBuilder_visitTryStatement_pushCondition(this, unwrappedException);
        t6 = new B.SsaBuilder_visitTryStatement_visitThen(t1, this, unwrappedException);
        new B.SsaBranchBuilder(this, node).handleIf$3(new B.SsaBuilder_visitTryStatement_closure(t7, t5.get$head(t5)), t6, new B.SsaBuilder_visitTryStatement_visitElse(t1, this, node, t7, t6));
        if (this._ssa$_current != null) {
          t5 = $.HInstruction_idCounter;
          if (typeof t5 !== "number")
            return t5.$add();
          $.HInstruction_idCounter = t5 + 1;
          t5 = new B.HGoto(null, null, t5, C.List_empty12, H.setRuntimeTypeInfo([], [B.HInstruction]), null, null, null, new Z.SideEffects(0), false, C.FlatTypeMask_null_0);
          t5.HInstruction$2(C.List_empty12, C.FlatTypeMask_null_0);
          endCatchBlock = this.close$1(0, t5);
        } else
          endCatchBlock = null;
        this.rethrowableException = oldRethrowableException;
        tryInstruction.catchBlock = startCatchBlock;
        catchGraph = new B.SubGraph(startCatchBlock, this.lastOpenedBlock);
      } else {
        startCatchBlock = null;
        endCatchBlock = null;
        catchGraph = null;
      }
      t5 = node.finallyBlock;
      t6 = t5 != null;
      if (t6) {
        this.localsHandler = B.LocalsHandler$from0(savedLocals);
        startFinallyBlock = t2.addNewBlock$0();
        startFinallyBlock.status = 1;
        this.isReachable = true;
        this._ssa$_current = startFinallyBlock;
        this.lastOpenedBlock = startFinallyBlock;
        if (t6)
          t5.accept$1(0, this);
        if (this._ssa$_current != null) {
          t5 = $.HInstruction_idCounter;
          if (typeof t5 !== "number")
            return t5.$add();
          $.HInstruction_idCounter = t5 + 1;
          t5 = new B.HGoto(null, null, t5, C.List_empty12, H.setRuntimeTypeInfo([], [B.HInstruction]), null, null, null, new Z.SideEffects(0), false, C.FlatTypeMask_null_0);
          t5.HInstruction$2(C.List_empty12, C.FlatTypeMask_null_0);
          endFinallyBlock = this.close$1(0, t5);
        } else
          endFinallyBlock = null;
        tryInstruction.finallyBlock = startFinallyBlock;
        finallyGraph = new B.SubGraph(startFinallyBlock, this.lastOpenedBlock);
      } else {
        startFinallyBlock = null;
        endFinallyBlock = null;
        finallyGraph = null;
      }
      exitBlock = t2.addNewBlock$0();
      t2 = new B.SsaBuilder_visitTryStatement_addOptionalSuccessor();
      t5 = new B.SsaBuilder_visitTryStatement_addExitTrySuccessor(t1, this);
      enterBlock.addSuccessor$1(t1.startTryBlock_0);
      t2.call$2(enterBlock, startCatchBlock);
      t2.call$2(enterBlock, startFinallyBlock);
      enterBlock.addSuccessor$1(exitBlock);
      if (endTryBlock != null) {
        endTryBlock.addSuccessor$1(startCatchBlock != null ? startCatchBlock : startFinallyBlock);
        endTryBlock.addSuccessor$1(exitBlock);
      }
      if (endCatchBlock != null)
        endCatchBlock.addSuccessor$1(startFinallyBlock != null ? startFinallyBlock : exitBlock);
      if (endFinallyBlock != null)
        endFinallyBlock.addSuccessor$1(exitBlock);
      t5.call$1(startCatchBlock);
      t5.call$1(startFinallyBlock);
      this.localsHandler = savedLocals;
      exitBlock.status = 1;
      this.isReachable = true;
      this._ssa$_current = exitBlock;
      this.lastOpenedBlock = exitBlock;
      enterBlock.blockFlow = new B.HBlockFlow(new B.HTryBlockInformation(this.wrapStatementGraph$1(new B.SubGraph(t3, t4)), t1.exception_1, this.wrapStatementGraph$1(catchGraph), this.wrapStatementGraph$1(finallyGraph)), exitBlock);
      this.inTryStatement = oldInTryStatement;
    },
    visitCatchBlock$1: function(node) {
      var t1 = node.block;
      if (t1 != null)
        t1.accept$1(0, this);
    },
    visitTypedef$1: function(node) {
      this.compiler.internalError$2(node, "SsaFromAstMixin.visitTypedef. not implemented.");
    },
    visitTypeVariable$1: function(node) {
      this.compiler.internalError$2(node, "SsaFromAstMixin.visitTypeVariable.");
    },
    emitReturn$2: function(value, node) {
      var t1, t2;
      if (this.inliningStack.length === 0) {
        t1 = H.setRuntimeTypeInfo([value], [B.HInstruction]);
        t2 = $.HInstruction_idCounter;
        if (typeof t2 !== "number")
          return t2.$add();
        $.HInstruction_idCounter = t2 + 1;
        t2 = new B.HReturn(null, null, t2, t1, H.setRuntimeTypeInfo([], [B.HInstruction]), null, null, null, new Z.SideEffects(0), false, C.FlatTypeMask_null_0);
        t2.HInstruction$2(t1, C.FlatTypeMask_null_0);
        this.closeAndGotoExit$1(this.attachPosition$2(t2, node));
      } else
        this.localsHandler.updateLocal$2(this.returnLocal, value);
    },
    SsaBuilder$3: function(backend, work, nativeEmitter) {
      var t1 = work.element;
      this.localsHandler = new B.LocalsHandler0(P.LinkedHashMap_LinkedHashMap(null, null, null, O.Local, B.HInstruction), P.LinkedHashMap_LinkedHashMap(null, null, null, O.Local, Q.CapturedVariable), this, null, P.LinkedHashMap_LinkedHashMap(null, null, null, V.TypeVariableType, Q.TypeVariableLocal), t1);
      J.add$1$ax(this.sourceElementStack, t1);
    },
    $asResolvedVisitor: function() {
      return [null];
    },
    $asVisitor: function() {
      return [null];
    }
  },
  SsaBuilder_completeDynamicSendArgumentsList_closure: {
    "^": "Closure:13;box_0,this_1,providedArguments_2,compiledArguments_3",
    call$1: function(element) {
      var t1, t2, t3, t4;
      t1 = this.box_0;
      t2 = t1.index_0;
      t3 = this.providedArguments_2;
      t4 = this.compiledArguments_3;
      if (t2 < t3.length) {
        t3 = t3[t2];
        if (t2 >= t4.length)
          return H.ioore(t4, t2);
        t4[t2] = t3;
      } else {
        t3 = this.this_1.handleConstantForOptionalParameter$1(element);
        if (t2 >= t4.length)
          return H.ioore(t4, t2);
        t4[t2] = t3;
      }
      ++t1.index_0;
    },
    $isFunction: true
  },
  SsaBuilder_completeDynamicSendArgumentsList_closure0: {
    "^": "Closure:13;box_0,this_4,providedArguments_5,compiledArguments_6,selectorArgumentNames_7,firstProvidedNamedArgument_8",
    call$1: function(element) {
      var t1, t2, t3, t4, t5;
      t1 = this.box_0;
      t2 = this.selectorArgumentNames_7;
      if (t1.namedArgumentIndex_1 < t2.length) {
        t3 = J.get$name$x(element);
        t4 = t1.namedArgumentIndex_1;
        if (t4 >= t2.length)
          return H.ioore(t2, t4);
        t4 = J.$eq(t3, t2[t4]);
        t2 = t4;
      } else
        t2 = false;
      t3 = t1.index_0;
      t4 = this.compiledArguments_6;
      if (t2) {
        t2 = this.providedArguments_5;
        t5 = this.firstProvidedNamedArgument_8 + t1.namedArgumentIndex_1++;
        if (t5 >= t2.length)
          return H.ioore(t2, t5);
        t5 = t2[t5];
        if (t3 >= t4.length)
          return H.ioore(t4, t3);
        t4[t3] = t5;
      } else {
        t2 = this.this_4.handleConstantForOptionalParameter$1(element);
        if (t3 >= t4.length)
          return H.ioore(t4, t3);
        t4[t3] = t2;
      }
      ++t1.index_0;
    },
    $isFunction: true
  },
  SsaBuilder_tryInlineMethod_meetsHardConstraints: {
    "^": "Closure:42;box_0,this_1,selector_2,providedArguments_3,function_4",
    call$0: function() {
      var t1, t2, t3, t4, t5, t6, returnType;
      t1 = this.this_1;
      t2 = t1.compiler;
      t3 = t2.deferredLoadTask;
      t4 = this.box_0;
      t5 = t4.element_0;
      t6 = t2._currentElement;
      if (!J.$eq(t3.outputUnitForElement$1(t5), t3.outputUnitForElement$1(t6)))
        return false;
      if (t2.disableInlining)
        return false;
      t3 = this.selector_2;
      if (t3 != null && !t3.applies$2(this.function_4, t2))
        return false;
      t3 = t4.element_0;
      if (t3.get$name(t3) === "==") {
        t3 = t4.element_0.get$enclosingClass();
        t5 = t2.objectClass;
        if (t3 == null ? t5 != null : t3 !== t5) {
          t3 = this.providedArguments_3;
          if (1 >= t3.length)
            return H.ioore(t3, 1);
          t3 = t3[1].canBeNull$0();
        } else
          t3 = false;
        if (t3)
          return false;
      }
      t3 = t4.element_0;
      if (t3.get$kind(t3) === C.ElementKind_generative_constructor_16 && O.Elements_isNativeOrExtendsNative(t4.element_0.get$enclosingClass()))
        return false;
      t3 = t4.element_0;
      if (t3.get$kind(t3) !== C.ElementKind_generative_constructor_body_0) {
        returnType = t2.typesTask.getGuaranteedReturnTypeOfElement$1(t4.element_0);
        if (returnType != null && returnType.get$isEmpty(returnType) && !returnType.get$isNullable()) {
          t1.isReachable = false;
          return false;
        }
      }
      return true;
    },
    $isFunction: true
  },
  SsaBuilder_tryInlineMethod_heuristicSayGoodToGo: {
    "^": "Closure:42;box_0,this_5,function_6,insideLoop_7,cachedCanBeInlined_8",
    call$0: function() {
      var t1, t2, t3, t4, t5, numParameters, maxInliningNodes, inferrer, useMaxInliningNodes, functionNode, weeder, canInline;
      t1 = this.this_5;
      t2 = t1.inliningStack;
      t3 = this.function_6;
      if (H.IterableMixinWorkaround_any(t2, new B.SsaBuilder_tryInlineMethod_heuristicSayGoodToGo_closure(t3)))
        return false;
      if (t1.inExpressionOfThrow)
        return false;
      t4 = this.box_0;
      if (t4.element_0.get$isSynthesized())
        return true;
      t5 = this.cachedCanBeInlined_8;
      if (t5 === true)
        return t5;
      numParameters = t3.get$functionSignature().get$parameterCount();
      t5 = this.insideLoop_7;
      maxInliningNodes = t5 ? 42 + 4 * numParameters : 18 + 3 * numParameters;
      inferrer = t1.compiler.typesTask.typesInferrer;
      useMaxInliningNodes = !(inferrer.isCalledOnce$1(t4.element_0) && H.IterableMixinWorkaround_every(t2, new B.SsaBuilder_tryInlineMethod_heuristicSayGoodToGo_closure0(inferrer))) || false;
      functionNode = t3.get$node();
      weeder = new B.InlineWeeder(false, false, 0, maxInliningNodes, useMaxInliningNodes);
      t2 = functionNode.get$initializers();
      if (t2 != null)
        t2.accept$1(0, weeder);
      t2 = functionNode.get$body(functionNode);
      if (t2 != null)
        t2.accept$1(0, weeder);
      canInline = !weeder.tooDifficult;
      t1 = t1.backend;
      t4 = t4.element_0;
      if (canInline) {
        t1 = t1.inlineCache;
        t2 = t1.canBeInlinedInsideLoop;
        if (t5)
          t2.$indexSet(0, t4, true);
        else {
          t1.canBeInlined.$indexSet(0, t4, true);
          t2.$indexSet(0, t4, true);
        }
      } else
        t1.inlineCache.markAsNonInlinable$2$insideLoop(t4, t5);
      return canInline;
    },
    $isFunction: true
  },
  SsaBuilder_tryInlineMethod_heuristicSayGoodToGo_closure: {
    "^": "Closure:13;function_9",
    call$1: function(entry) {
      return J.$eq(entry.get$$function(), this.function_9);
    },
    $isFunction: true
  },
  SsaBuilder_tryInlineMethod_heuristicSayGoodToGo_closure0: {
    "^": "Closure:13;inferrer_10",
    call$1: function(entry) {
      return this.inferrer_10.isCalledOnce$1(entry.get$$function());
    },
    $isFunction: true
  },
  SsaBuilder_tryInlineMethod_doInlining: {
    "^": "Closure:7;box_0,this_11,selector_12,providedArguments_13,currentNode_14,function_15",
    call$0: function() {
      var t1, t2, compiledArguments, t3, result, state;
      t1 = this.box_0;
      if (t1.element_0.get$isInstanceMember()) {
        t1 = t1.element_0;
        if (t1.get$kind(t1) !== C.ElementKind_generative_constructor_body_0) {
          t1 = this.selector_12;
          t1 = t1.get$mask() == null || t1.get$mask().get$isNullable();
        } else
          t1 = false;
      } else
        t1 = false;
      if (t1) {
        t1 = this.this_11;
        t2 = this.providedArguments_13;
        if (0 >= t2.length)
          return H.ioore(t2, 0);
        t2 = t1.attachPosition$2(B.HFieldGet$(null, t2[0], t1.backend.compiler.typesTask.get$dynamicType(), false), this.currentNode_14);
        t1._ssa$_current.add$1(0, t2);
      }
      t1 = this.this_11;
      t2 = this.function_15;
      compiledArguments = t1.completeSendArgumentsList$4(t2, this.selector_12, this.providedArguments_13, this.currentNode_14);
      t3 = t1.inliningStack;
      t3.push(new B.AstInliningState(t1.returnLocal, t1.returnType, t1.elements, t1.stack, t1.localsHandler, t1.inTryStatement, t2));
      t1.setupStateForInlining$2(t2, compiledArguments);
      t1.inlinedFrom$2(t2, new B.SsaBuilder_tryInlineMethod_doInlining_closure(t1, t2));
      result = t1.localsHandler.readLocal$1(t1.returnLocal);
      if (0 >= t3.length)
        return H.ioore(t3, 0);
      state = t3.pop();
      t1.localsHandler = state.oldLocalsHandler;
      t1.returnLocal = state.oldReturnLocal;
      t1.inTryStatement = state.inTryStatement;
      t1.elements = state.oldElements;
      t1.returnType = state.oldReturnType;
      t3 = state.oldStack;
      t1.stack = t3;
      t3.push(result);
    },
    $isFunction: true
  },
  SsaBuilder_tryInlineMethod_doInlining_closure: {
    "^": "Closure:23;this_16,function_17",
    call$0: function() {
      var t1, t2, functionNode;
      t1 = this.this_16;
      if (!t1.isReachable) {
        t2 = t1.compiler;
        t1.emitReturn$2(t1.graph.addConstant$2(t2.backend.get$constantSystem().createNull$0(), t2), null);
      } else {
        t2 = this.function_17;
        t1.potentiallyCheckInlinedParameterTypes$1(t2);
        if (t2.get$kind(t2) === C.ElementKind_generative_constructor_16)
          t1.buildFactory$1(t2);
        else {
          functionNode = t2.get$node();
          functionNode.get$body(functionNode).accept$1(0, t1);
        }
      }
    },
    $isFunction: true
  },
  SsaBuilder_inlinedFrom_closure: {
    "^": "Closure:23;this_0,element_1,f_2",
    call$0: function() {
      var t1, t2, result;
      t1 = this.this_0.sourceElementStack;
      t2 = J.getInterceptor$ax(t1);
      t2.add$1(t1, this.element_1.get$declaration());
      result = this.f_2.call$0();
      t2.removeLast$0(t1);
      return result;
    },
    $isFunction: true
  },
  SsaBuilder_getTypeOfCapturedVariable_closure: {
    "^": "Closure:23;this_0,element_1",
    call$0: function() {
      var t1 = this.this_0.compiler;
      return B.TypeMaskFactory_fromInferredType(t1.typesTask.getGuaranteedTypeOfElement$1(this.element_1), t1);
    },
    $isFunction: true
  },
  SsaBuilder_buildMethod_closure: {
    "^": "Closure:23;this_0",
    call$0: function() {
      var t1, t2, parameter, t3, t4, t5;
      t1 = this.this_0;
      t2 = t1.parameters;
      t2 = t2.get$values(t2);
      parameter = t2._f$1(J.get$first$ax(t2._iterable));
      t2 = t1.compiler;
      t2 = t1.graph.addConstant$2(t2.backend.get$constantSystem().createNull$0(), t2);
      t3 = t1.backend.compiler.typesTask.get$boolType();
      t4 = H.setRuntimeTypeInfo([parameter, t2], [B.HInstruction]);
      t5 = $.HInstruction_idCounter;
      if (typeof t5 !== "number")
        return t5.$add();
      $.HInstruction_idCounter = t5 + 1;
      t5 = new B.HIdentity(null, false, null, null, null, t5, t4, H.setRuntimeTypeInfo([], [B.HInstruction]), null, null, null, new Z.SideEffects(0), false, t3);
      t5.HInstruction$2(t4, t3);
      t5.HInvokeBinary$4(parameter, t2, null, t3);
      t1._ssa$_current.add$1(0, t5);
      t1.stack.push(t5);
    },
    $isFunction: true
  },
  SsaBuilder_buildMethod_closure0: {
    "^": "Closure:23;this_1",
    call$0: function() {
      var t1, t2, t3;
      t1 = this.this_1;
      t2 = t1.compiler;
      t2 = H.setRuntimeTypeInfo([t1.graph.addConstant$2(t2.backend.get$constantSystem().createBool$1(false), t2)], [B.HInstruction]);
      t3 = $.HInstruction_idCounter;
      if (typeof t3 !== "number")
        return t3.$add();
      $.HInstruction_idCounter = t3 + 1;
      t3 = new B.HReturn(null, null, t3, t2, H.setRuntimeTypeInfo([], [B.HInstruction]), null, null, null, new Z.SideEffects(0), false, C.FlatTypeMask_null_0);
      t3.HInstruction$2(t2, C.FlatTypeMask_null_0);
      t1.closeAndGotoExit$1(t3);
    },
    $isFunction: true
  },
  SsaBuilder_getConstructorBody_closure: {
    "^": "Closure:77;box_0,constructor_1",
    call$1: function(backendMember) {
      if (J.get$kind$x(backendMember) === C.ElementKind_generative_constructor_body_0)
        if (backendMember.get$$constructor() === this.constructor_1)
          this.box_0.bodyElement_0 = backendMember;
    },
    $isFunction: true
  },
  SsaBuilder_setupStateForInlining_closure: {
    "^": "Closure:50;box_0,this_1,compiledArguments_2",
    call$1: function(parameter) {
      var t1, t2, argument;
      t1 = this.compiledArguments_2;
      t2 = this.box_0.argumentIndex_0++;
      if (t2 >= t1.length)
        return H.ioore(t1, t2);
      argument = t1[t2];
      this.this_1.localsHandler.updateLocal$2(parameter, argument);
    },
    $isFunction: true
  },
  SsaBuilder_setupStateForInlining_closure0: {
    "^": "Closure:37;box_0,this_3,compiledArguments_4",
    call$1: function(typeVariable) {
      var t1, t2, argument;
      t1 = this.compiledArguments_4;
      t2 = this.box_0.argumentIndex_0++;
      if (t2 >= t1.length)
        return H.ioore(t1, t2);
      argument = t1[t2];
      t2 = this.this_3.localsHandler;
      t2.updateLocal$2(t2.getTypeVariableAsLocal$1(typeVariable), argument);
    },
    $isFunction: true
  },
  SsaBuilder_potentiallyCheckInlinedParameterTypes_closure: {
    "^": "Closure:50;this_0",
    call$1: function(parameter) {
      var t1 = this.this_0;
      t1.potentiallyCheckType$2(t1.localsHandler.readLocal$1(parameter), J.get$type$x(parameter));
    },
    $isFunction: true
  },
  SsaBuilder_inlineSuperOrRedirect_closure: {
    "^": "Closure:23;box_1,this_2,compiledArguments_3,constructors_4,fieldValues_5,caller_6",
    call$0: function() {
      var t1, t2, t3, enclosingClass, t4, t5, type, typeVariables, variables, t6, t7, variable, t8, oldElements, resolvedAst, oldClosureData, node, newClosureData;
      t1 = {};
      t2 = this.constructors_4;
      t3 = this.box_1;
      t2.push(t3.callee_1);
      enclosingClass = t3.callee_1.get$enclosingClass();
      t4 = this.this_2;
      t5 = t4.backend;
      if (t5.rti.classesNeedingRti.contains$1(0, enclosingClass.get$declaration()) || t5.compiler.enabledRuntimeType) {
        type = this.caller_6.get$enclosingClass().get$thisType().asInstanceOf$1(enclosingClass);
        type = t4.localsHandler.substInContext$1(type);
        type.get$typeArguments();
        typeVariables = enclosingClass.get$typeVariables();
        if (!type.get$isRaw()) {
          variables = H.setRuntimeTypeInfo(new H.ListIterator(typeVariables, typeVariables.length, 0, null), [H.getTypeArgumentByIndex(typeVariables, 0)]);
          H.IterableMixinWorkaround_forEach(type.get$typeArguments(), new B.SsaBuilder_inlineSuperOrRedirect__closure(t4, variables));
        } else
          for (t5 = H.setRuntimeTypeInfo(new H.ListIterator(typeVariables, typeVariables.length, 0, null), [H.getTypeArgumentByIndex(typeVariables, 0)]), t6 = t4.graph, t7 = t4.compiler; t5.moveNext$0();) {
            variable = t5.__internal$_current;
            t8 = t4.localsHandler;
            t8.updateLocal$2(t8.getTypeVariableAsLocal$1(variable), t6.addConstant$2(t7.backend.get$constantSystem().createNull$0(), t7));
          }
      }
      t5 = t3.callee_1.get$enclosingClass();
      t6 = this.caller_6.get$enclosingClass();
      if (t5 == null ? t6 != null : t5 !== t6)
        t4.inlinedFrom$2(t3.callee_1, new B.SsaBuilder_inlineSuperOrRedirect__closure0(t3, t4, this.fieldValues_5));
      t1.index_0 = 0;
      t5 = this.fieldValues_5;
      t3.callee_1.get$functionSignature().orderedForEachParameter$1(new B.SsaBuilder_inlineSuperOrRedirect__closure1(t1, t4, this.compiledArguments_3, t5));
      oldElements = t4.elements;
      resolvedAst = t3.callee_1.get$resolvedAst();
      t1 = resolvedAst.elements;
      t4.elements = t1;
      oldClosureData = t4.localsHandler.closureData;
      node = resolvedAst.node;
      newClosureData = t4.compiler.closureToClassMapper.computeClosureToClassMapping$3(t3.callee_1, node, t1);
      t1 = t4.localsHandler;
      t1.closureData = newClosureData;
      t1.enterScope$2(node, t3.callee_1);
      t4.buildInitializers$3(t3.callee_1, t2, t5);
      t4.localsHandler.closureData = oldClosureData;
      t4.elements = oldElements;
    },
    $isFunction: true
  },
  SsaBuilder_inlineSuperOrRedirect__closure: {
    "^": "Closure:123;this_7,variables_8",
    call$1: function(argument) {
      var t1, typeVariable, t2;
      t1 = this.variables_8;
      t1.moveNext$0();
      typeVariable = t1.__internal$_current;
      t1 = this.this_7;
      t2 = t1.localsHandler;
      t2.updateLocal$2(t2.getTypeVariableAsLocal$1(typeVariable), t1.analyzeTypeArgument$1(argument));
    },
    $isFunction: true
  },
  SsaBuilder_inlineSuperOrRedirect__closure0: {
    "^": "Closure:23;box_1,this_9,fieldValues_10",
    call$0: function() {
      var t1 = this.box_1.callee_1.get$enclosingElement();
      this.this_9.buildFieldInitializers$2(t1.get$implementation(t1), this.fieldValues_10);
    },
    $isFunction: true
  },
  SsaBuilder_inlineSuperOrRedirect__closure1: {
    "^": "Closure:50;box_0,this_11,compiledArguments_12,fieldValues_13",
    call$1: function(parameter) {
      var t1, t2, argument;
      t1 = this.compiledArguments_12;
      t2 = this.box_0.index_0++;
      if (t2 >= t1.length)
        return H.ioore(t1, t2);
      argument = t1[t2];
      t2 = this.this_11;
      t2.parameters.$indexSet(0, parameter, argument);
      t2.localsHandler.updateLocal$2(parameter, argument);
      if (J.get$kind$x(parameter) === C.ElementKind_initializing_formal_1)
        this.fieldValues_13.$indexSet(0, parameter.get$fieldElement(), argument);
    },
    $isFunction: true
  },
  SsaBuilder_buildInitializers_compileArgument: {
    "^": "Closure:261;this_0",
    call$1: function(parameter) {
      return this.this_0.localsHandler.readLocal$1(parameter);
    },
    $isFunction: true
  },
  SsaBuilder_buildInitializers_closure: {
    "^": "Closure:23;this_1,target_2,selector_3,arguments_4,compiledArguments_5",
    call$0: function() {
      this.this_1.addStaticSendArgumentsToList$4(this.selector_3, this.arguments_4, this.target_2, this.compiledArguments_5);
    },
    $isFunction: true
  },
  SsaBuilder_buildInitializers_closure0: {
    "^": "Closure:23;this_6,arguments_7",
    call$0: function() {
      var t1 = this.arguments_7;
      t1 = t1.get$head(t1);
      if (t1 != null)
        J.accept$1$x(t1, this.this_6);
    },
    $isFunction: true
  },
  SsaBuilder_buildFieldInitializers_closure: {
    "^": "Closure:262;this_0,classElement_1,fieldValues_2",
    call$2: function(enclosingClass, member) {
      var t1 = this.this_0;
      t1.compiler.withCurrentElement$2(member, new B.SsaBuilder_buildFieldInitializers__closure(t1, this.classElement_1, this.fieldValues_2, member));
    },
    $isFunction: true
  },
  SsaBuilder_buildFieldInitializers__closure: {
    "^": "Closure:23;this_3,classElement_4,fieldValues_5,member_6",
    call$0: function() {
      var t1, definitions, node, initializer, t2, t3, savedElements;
      t1 = this.member_6;
      definitions = t1.get$treeElements();
      node = t1.get$node();
      initializer = t1.get$initializer();
      if (initializer == null) {
        if (!O.Elements_isNativeOrExtendsNative(this.classElement_4)) {
          t2 = this.this_3;
          t3 = t2.compiler;
          this.fieldValues_5.$indexSet(0, t1, t2.graph.addConstant$2(t3.backend.get$constantSystem().createNull$0(), t3));
        }
      } else {
        t2 = this.this_3;
        savedElements = t2.elements;
        t2.elements = definitions;
        t2.compiler.closureToClassMapper.computeClosureToClassMapping$3(t1, node, definitions);
        t2.inlinedFrom$2(t1, new B.SsaBuilder_buildFieldInitializers___closure(t2, initializer));
        t2.elements = savedElements;
        t2 = t2.stack;
        if (0 >= t2.length)
          return H.ioore(t2, 0);
        this.fieldValues_5.$indexSet(0, t1, t2.pop());
      }
    },
    $isFunction: true
  },
  SsaBuilder_buildFieldInitializers___closure: {
    "^": "Closure:23;this_7,right_8",
    call$0: function() {
      return this.right_8.accept$1(0, this.this_7);
    },
    $isFunction: true
  },
  SsaBuilder_buildFactory_closure: {
    "^": "Closure:50;this_1,fieldValues_2",
    call$1: function(parameter) {
      var parameterValue;
      if (J.get$kind$x(parameter) === C.ElementKind_initializing_formal_1) {
        parameterValue = this.this_1.localsHandler.readLocal$1(parameter);
        this.fieldValues_2.$indexSet(0, parameter.get$fieldElement(), parameterValue);
      }
    },
    $isFunction: true
  },
  SsaBuilder_buildFactory_closure0: {
    "^": "Closure:262;this_3,isNativeUpgradeFactory_4,fieldValues_5,constructorArguments_6,fields_7",
    call$2: function(enclosingClass, member) {
      var value, t1;
      value = this.fieldValues_5.$index(0, member);
      if (value == null)
        ;
      else {
        this.fields_7.push(member);
        t1 = this.this_3;
        this.constructorArguments_6.push(t1.potentiallyCheckType$2(value, t1.localsHandler.substInContext$1(member.get$type(member))));
      }
    },
    $isFunction: true
  },
  SsaBuilder_buildFactory_isIndexedTypeArgumentGet: {
    "^": "Closure:263;box_0,this_8",
    call$1: function(instruction) {
      var t1, t2, index, newSource, contextClass, constant;
      if (!J.getInterceptor(instruction).$isHInvokeStatic)
        return false;
      t1 = instruction.element;
      t2 = this.this_8.backend;
      t2 = t2.find$2(0, t2.jsHelperLibrary, "getTypeArgumentByIndex");
      if (t1 == null ? t2 != null : t1 !== t2)
        return false;
      t1 = instruction.inputs;
      if (1 >= t1.length)
        return H.ioore(t1, 1);
      index = t1[1];
      newSource = t1[0];
      if (!J.getInterceptor(newSource).$isHThis)
        return false;
      t1 = this.box_0;
      if (t1.source_0 == null) {
        t1.source_0 = newSource;
        contextClass = newSource.sourceElement.get$executableContext().get$enclosingClass();
        t1.contextClass_3 = contextClass;
        t1.remainingTypeVariables_4 = contextClass.get$typeVariables().length;
      }
      t2 = t1.remainingTypeVariables_4;
      if (t2 === 0)
        return false;
      if (typeof t2 !== "number")
        return t2.$sub();
      t1.remainingTypeVariables_4 = t2 - 1;
      constant = index.get$constant();
      return constant.get$value(constant) === t1.expectedIndex_2++;
    },
    $isFunction: true
  },
  SsaBuilder_buildFactory_closure1: {
    "^": "Closure:37;box_0,this_9,isIndexedTypeArgumentGet_10,typeArguments_11",
    call$1: function(typeVariable) {
      var t1, argument;
      t1 = this.this_9.localsHandler;
      argument = t1.readLocal$1(t1.getTypeVariableAsLocal$1(typeVariable));
      t1 = this.box_0;
      if (t1.allIndexed_1 && this.isIndexedTypeArgumentGet_10.call$1(argument) !== true)
        t1.allIndexed_1 = false;
      this.typeArguments_11.push(argument);
    },
    $isFunction: true
  },
  SsaBuilder_buildFactory_closure2: {
    "^": "Closure:50;this_12,bodyCallInputs_13",
    call$1: function(parameter) {
      var t1 = this.this_12;
      if (!t1.localsHandler.isBoxed$1(parameter))
        this.bodyCallInputs_13.push(t1.localsHandler.readLocal$1(parameter));
    },
    $isFunction: true
  },
  SsaBuilder_buildFactory_closure3: {
    "^": "Closure:37;this_14,bodyCallInputs_15",
    call$1: function(argument) {
      var t1 = this.this_14.localsHandler;
      this.bodyCallInputs_15.push(t1.readLocal$1(t1.getTypeVariableAsLocal$1(argument)));
    },
    $isFunction: true
  },
  SsaBuilder_openFunction_closure: {
    "^": "Closure:37;this_0",
    call$1: function(typeVariable) {
      var t1, param;
      t1 = this.this_0;
      param = t1.addParameter$2(typeVariable.get$element(), t1.backend.nonNullType);
      t1 = t1.localsHandler;
      t1.directLocals.$indexSet(0, t1.getTypeVariableAsLocal$1(typeVariable), param);
    },
    $isFunction: true
  },
  SsaBuilder_openFunction_closure0: {
    "^": "Closure:50;this_1,element_2,scopeData_3",
    call$1: function(parameterElement) {
      var t1, t2, newParameter;
      t1 = this.element_2;
      if (t1.get$kind(t1) === C.ElementKind_generative_constructor_body_0) {
        t2 = this.scopeData_3;
        if (t2 != null && t2._capturedVariableMapping.containsKey$1(parameterElement))
          return;
      }
      t2 = this.this_1;
      newParameter = t2.localsHandler.directLocals.$index(0, parameterElement);
      if (!(t1.kind === C.ElementKind_generative_constructor_16 || t1.get$isFactoryConstructor()) || !H.interceptedTypeCast(t1, "$isConstructorElement").get$isRedirectingFactory())
        newParameter = t2.potentiallyCheckType$2(newParameter, J.get$type$x(parameterElement));
      t2.localsHandler.directLocals.$indexSet(0, parameterElement, newParameter);
    },
    $isFunction: true
  },
  SsaBuilder_insertTraceCall_n: {
    "^": "Closure:13;",
    call$1: function(e) {
      return e == null ? "" : e.get$name(e);
    },
    $isFunction: true
  },
  SsaBuilder_endLoop_closure: {
    "^": "Closure:264;loopExitBlock_0,breakHandlers_1",
    call$2: function(breakInstruction, locals) {
      breakInstruction.block.addSuccessor$1(this.loopExitBlock_0);
      this.breakHandlers_1.push(locals);
    },
    $isFunction: true
  },
  SsaBuilder_handleLoop_closure: {
    "^": "Closure:265;updateBlock_0,continueHandlers_1",
    call$2: function(instruction, locals) {
      instruction.block.addSuccessor$1(this.updateBlock_0);
      this.continueHandlers_1.push(locals);
    },
    $isFunction: true
  },
  SsaBuilder_handleLoop_closure0: {
    "^": "Closure:266;label_2",
    call$2: function(breakInstruction, _) {
      var block, t1, t2;
      block = breakInstruction.block;
      t1 = this.label_2;
      t2 = $.HInstruction_idCounter;
      if (typeof t2 !== "number")
        return t2.$add();
      $.HInstruction_idCounter = t2 + 1;
      t2 = new B.HBreak(false, t1.target, t1, null, null, t2, C.List_empty12, H.setRuntimeTypeInfo([], [B.HInstruction]), null, null, null, new Z.SideEffects(0), false, C.FlatTypeMask_null_0);
      t2.HInstruction$2(C.List_empty12, C.FlatTypeMask_null_0);
      block.addAtExit$1(t2);
      block.remove$1(0, breakInstruction);
    },
    $isFunction: true
  },
  SsaBuilder_visitFor_buildInitializer: {
    "^": "Closure:7;this_0,node_1",
    call$0: function() {
      var initializer, t1;
      initializer = this.node_1.initializer;
      if (initializer == null)
        return;
      t1 = this.this_0;
      initializer.accept$1(0, t1);
      if (initializer.asExpression$0() != null) {
        t1 = t1.stack;
        if (0 >= t1.length)
          return H.ioore(t1, 0);
        t1.pop();
      }
    },
    $isFunction: true
  },
  SsaBuilder_visitFor_buildCondition: {
    "^": "Closure:267;this_2,node_3",
    call$0: function() {
      var t1, t2;
      t1 = this.node_3;
      if (t1.get$condition() == null) {
        t1 = this.this_2;
        t2 = t1.compiler;
        return t1.graph.addConstant$2(t2.backend.get$constantSystem().createBool$1(true), t2);
      }
      t2 = this.this_2;
      t1 = t1.get$condition();
      if (t1 != null)
        t1.accept$1(0, t2);
      return t2.popBoolified$0();
    },
    $isFunction: true
  },
  SsaBuilder_visitFor_buildUpdate: {
    "^": "Closure:7;this_4,node_5",
    call$0: function() {
      var t1, t2, expression, t3;
      for (t1 = this.node_5.update.nodes, t1.toString, t1 = H.setRuntimeTypeInfo(new E.LinkIterator(null, t1), [H.getTypeArgumentByIndex(t1, 0)]), t2 = this.this_4; t1.moveNext$0();) {
        expression = t1._util_implementation$_current;
        if (expression != null)
          J.accept$1$x(expression, t2);
        t3 = t2.stack;
        if (0 >= t3.length)
          return H.ioore(t3, 0);
        t3.pop();
      }
    },
    $isFunction: true
  },
  SsaBuilder_visitFor_buildBody: {
    "^": "Closure:7;this_6,node_7",
    call$0: function() {
      var t1 = this.node_7.body;
      if (t1 != null)
        t1.accept$1(0, this.this_6);
    },
    $isFunction: true
  },
  SsaBuilder_visitWhile_buildCondition: {
    "^": "Closure:267;this_0,node_1",
    call$0: function() {
      var t1, t2;
      t1 = this.this_0;
      t2 = this.node_1.condition;
      if (t2 != null)
        t2.accept$1(0, t1);
      return t1.popBoolified$0();
    },
    $isFunction: true
  },
  SsaBuilder_visitWhile_closure: {
    "^": "Closure:23;",
    call$0: function() {
    },
    $isFunction: true
  },
  SsaBuilder_visitWhile_closure0: {
    "^": "Closure:23;",
    call$0: function() {
    },
    $isFunction: true
  },
  SsaBuilder_visitWhile_closure1: {
    "^": "Closure:23;this_2,node_3",
    call$0: function() {
      var t1 = this.node_3.body;
      if (t1 != null)
        t1.accept$1(0, this.this_2);
    },
    $isFunction: true
  },
  SsaBuilder_visitDoWhile_closure: {
    "^": "Closure:265;conditionBlock_0,continueHandlers_1",
    call$2: function(instruction, locals) {
      instruction.block.addSuccessor$1(this.conditionBlock_0);
      this.continueHandlers_1.push(locals);
    },
    $isFunction: true
  },
  SsaBuilder_visitDoWhile_closure0: {
    "^": "Closure:266;label_2",
    call$2: function(breakInstruction, _) {
      var block, t1, t2;
      block = breakInstruction.block;
      t1 = this.label_2;
      t2 = $.HInstruction_idCounter;
      if (typeof t2 !== "number")
        return t2.$add();
      $.HInstruction_idCounter = t2 + 1;
      t2 = new B.HBreak(false, t1.target, t1, null, null, t2, C.List_empty12, H.setRuntimeTypeInfo([], [B.HInstruction]), null, null, null, new Z.SideEffects(0), false, C.FlatTypeMask_null_0);
      t2.HInstruction$2(C.List_empty12, C.FlatTypeMask_null_0);
      block.addAtExit$1(t2);
      block.remove$1(0, breakInstruction);
    },
    $isFunction: true
  },
  SsaBuilder_visitFunctionExpression_closure: {
    "^": "Closure:268;this_0,nestedClosureData_1,capturedVariables_2",
    call$1: function(field) {
      var capturedLocal = this.nestedClosureData_1._closureFieldMapping.$index(0, field);
      this.capturedVariables_2.push(this.this_0.localsHandler.readLocal$1(capturedLocal));
    },
    $isFunction: true
  },
  SsaBuilder_visitIf_closure0: {
    "^": "Closure:23;this_0,node_1",
    call$0: function() {
      var t1 = this.node_1.condition;
      if (t1 != null)
        t1.accept$1(0, this.this_0);
      return;
    },
    $isFunction: true
  },
  SsaBuilder_visitIf_closure1: {
    "^": "Closure:23;this_2,node_3",
    call$0: function() {
      var t1 = this.node_3.thenPart;
      if (t1 != null)
        t1.accept$1(0, this.this_2);
      return;
    },
    $isFunction: true
  },
  SsaBuilder_visitIf_closure: {
    "^": "Closure:23;this_4,node_5",
    call$0: function() {
      var t1 = this.node_5.elsePart;
      if (t1 != null)
        t1.accept$1(0, this.this_4);
      return;
    },
    $isFunction: true
  },
  SsaBuilder_visitLogicalAndOr_closure: {
    "^": "Closure:23;this_0,node_1",
    call$0: function() {
      var t1 = this.node_1.argumentsNode;
      if (t1 != null)
        t1.accept$1(0, this.this_0);
    },
    $isFunction: true
  },
  SsaBuilder_buildTypeArgumentRepresentations_closure: {
    "^": "Closure:13;this_0,inputs_1",
    call$1: function(variable) {
      this.inputs_1.push(this.this_0.addTypeVariableReference$1(variable));
    },
    $isFunction: true
  },
  SsaBuilder_addStaticSendArgumentsToList_compileArgument: {
    "^": "Closure:269;this_0",
    call$1: function(argument) {
      var t1 = this.this_0;
      if (argument != null)
        J.accept$1$x(argument, t1);
      t1 = t1.stack;
      if (0 >= t1.length)
        return H.ioore(t1, 0);
      return t1.pop();
    },
    $isFunction: true
  },
  SsaBuilder_needsSubstitutionForTypeVariableAccess_closure: {
    "^": "Closure:87;this_0,cls_1",
    call$1: function(subclass) {
      return !this.this_0.rti.isTrivialSubstitution$2(subclass, this.cls_1);
    },
    $isFunction: true
  },
  SsaBuilder_analyzeTypeArgument_closure: {
    "^": "Closure:13;this_0,inputs_1",
    call$1: function(variable) {
      this.inputs_1.push(this.this_0.addTypeVariableReference$1(variable));
    },
    $isFunction: true
  },
  SsaBuilder_handleListConstructor_closure: {
    "^": "Closure:123;this_0,inputs_1",
    call$1: function(argument) {
      this.inputs_1.push(this.this_0.analyzeTypeArgument$1(argument));
    },
    $isFunction: true
  },
  SsaBuilder_handleNewSend_computeType: {
    "^": "Closure:270;box_0,this_1,send_2,isFixedListConstructorCall_3,isGrowableListConstructorCall_4",
    call$1: function(element) {
      var t1, t2, originalElement, t3, t4, inferred, cls;
      t1 = this.this_1;
      t2 = this.send_2;
      t1.elements.toString;
      originalElement = t2.get$_secret_tree_element$_element();
      if (this.isFixedListConstructorCall_3 || O.Elements_isFilledListConstructorCall(originalElement, t2, t1.compiler)) {
        this.box_0.isFixedList_0 = true;
        t3 = J.get$last$ax(t1.sourceElementStack);
        t4 = t1.compiler;
        inferred = B.TypeMaskFactory_fromInferredType(t4.typesTask.getGuaranteedTypeOfNode$2(t3, t2), t4);
        return inferred.containsAll$1(t4) ? t1.backend.fixedArrayType : inferred;
      } else if (this.isGrowableListConstructorCall_4) {
        t3 = J.get$last$ax(t1.sourceElementStack);
        t4 = t1.compiler;
        inferred = B.TypeMaskFactory_fromInferredType(t4.typesTask.getGuaranteedTypeOfNode$2(t3, t2), t4);
        return inferred.containsAll$1(t4) ? t1.backend.extendableArrayType : inferred;
      } else {
        t3 = t1.compiler;
        if (O.Elements_isConstructorOfTypedArraySubclass(originalElement, t3)) {
          this.box_0.isFixedList_0 = true;
          t1 = J.get$last$ax(t1.sourceElementStack);
          inferred = B.TypeMaskFactory_fromInferredType(t3.typesTask.getGuaranteedTypeOfNode$2(t1, t2), t3);
          cls = element.get$enclosingClass();
          return inferred.containsAll$1(t3) ? new B.FlatTypeMask(cls.get$thisType().get$element(), 2) : inferred;
        } else if (element.kind === C.ElementKind_generative_constructor_16)
          return new B.FlatTypeMask(element.get$enclosingClass().get$thisType().get$element(), 2);
        else
          return B.TypeMaskFactory_fromInferredType(t3.typesTask.getGuaranteedReturnTypeOfElement$1(originalElement), t3);
      }
    },
    $isFunction: true
  },
  SsaBuilder_potentiallyAddTypeArguments_closure: {
    "^": "Closure:123;this_0,inputs_1",
    call$1: function(argument) {
      this.inputs_1.push(this.this_0.analyzeTypeArgument$1(argument));
    },
    $isFunction: true
  },
  SsaBuilder_checkTypeVariableBounds_addTypeVariableBoundCheck: {
    "^": "Closure:271;box_0,this_1,node_2,type_3,seenChecksMap_4",
    call$4: function(instance, typeArgument, typeVariable, bound) {
      var t1, t2, t3, subtypeRelation, t4, t5, t6, message, seenChecks, subtypeInstruction, supertypeInstruction, messageInstruction, element, inputs, assertIsSubtype;
      t1 = this.box_0;
      if (t1.definitelyFails_0)
        return;
      t2 = this.this_1;
      t3 = t2.compiler;
      subtypeRelation = t3.types.computeSubtypeRelation$2(typeArgument, bound);
      if (subtypeRelation === 1)
        return;
      t4 = this.type_3;
      t5 = J.getInterceptor(t4);
      t6 = "Can't create an instance of malbounded type '" + t5.toString$0(t4) + "': '" + J.toString$0(typeArgument) + "' is not a subtype of bound '" + J.toString$0(bound) + "' for type variable '" + typeVariable.element.name + "' of type ";
      message = t6 + (t5.$eq(t4, instance) ? "'" + J.toString$0(t4.get$element().get$thisType()) + "'" : "'" + J.toString$0(instance.get$element().get$thisType()) + "' on the supertype '" + instance.toString$0(0) + "' of '" + t5.toString$0(t4) + "'") + ".";
      if (subtypeRelation === -1) {
        t3 = t2.backend;
        t2.pushInvokeStatic$3(this.node_2, t3.find$2(0, t3.jsHelperLibrary, "throwTypeError"), [t2.addConstantString$1(message)]);
        t1.definitelyFails_0 = true;
        return;
      } else if (subtypeRelation === 0) {
        seenChecks = this.seenChecksMap_4.putIfAbsent$2(typeArgument, new B.SsaBuilder_checkTypeVariableBounds_addTypeVariableBoundCheck_closure());
        t1 = J.getInterceptor$asx(seenChecks);
        if (t1.contains$1(seenChecks, bound) !== true) {
          t1.add$1(seenChecks, bound);
          subtypeInstruction = t2.analyzeTypeArgument$1(t2.localsHandler.substInContext$1(typeArgument));
          supertypeInstruction = t2.analyzeTypeArgument$1(t2.localsHandler.substInContext$1(bound));
          messageInstruction = t2.graph.addConstant$2(t3.backend.get$constantSystem().createString$1(new Y.LiteralDartString(message)), t3);
          t1 = t2.backend;
          element = t1.find$2(0, t1.jsHelperLibrary, "assertIsSubtype");
          inputs = H.setRuntimeTypeInfo([subtypeInstruction, supertypeInstruction, messageInstruction], [B.HInstruction]);
          t1 = subtypeInstruction.instructionType;
          t3 = $.HInstruction_idCounter;
          if (typeof t3 !== "number")
            return t3.$add();
          $.HInstruction_idCounter = t3 + 1;
          assertIsSubtype = new B.HInvokeStatic(element, true, null, null, null, t3, inputs, H.setRuntimeTypeInfo([], [B.HInstruction]), null, null, null, new Z.SideEffects(0), false, t1);
          assertIsSubtype.HInstruction$2(inputs, t1);
          t1 = assertIsSubtype.sideEffects;
          t1.flags = (t1.flags | 7) >>> 0;
          t1.setDependsOnSomething$0();
          t1 = t2.work.registry.compiler.backend.get$rti();
          t1.checkedTypeArguments.add$1(0, typeArgument);
          t1.checkedBounds.add$1(0, bound);
          t2._ssa$_current.add$1(0, assertIsSubtype);
        }
      }
    },
    $isFunction: true
  },
  SsaBuilder_checkTypeVariableBounds_addTypeVariableBoundCheck_closure: {
    "^": "Closure:23;",
    call$0: function() {
      return P.LinkedHashSet_LinkedHashSet(null, null, null, V.DartType);
    },
    $isFunction: true
  },
  SsaBuilder_generateThrowNoSuchMethod_closure: {
    "^": "Closure:13;box_0,this_1",
    call$1: function(argumentNode) {
      var t1, value;
      t1 = this.this_1;
      if (argumentNode != null)
        J.accept$1$x(argumentNode, t1);
      t1 = t1.stack;
      if (0 >= t1.length)
        return H.ioore(t1, 0);
      value = t1.pop();
      J.add$1$ax(this.box_0.argumentValues_0, value);
    },
    $isFunction: true
  },
  SsaBuilder_generateWrongArgumentCountError_closure: {
    "^": "Closure:77;existingArguments_0",
    call$1: function(parameter) {
      this.existingArguments_0.push(J.get$name$x(parameter));
    },
    $isFunction: true
  },
  SsaBuilder_pushInvokeDynamic_isOptimizableOperationOnIndexable: {
    "^": "Closure:272;this_0",
    call$2: function(selector, element) {
      var t1, t2;
      t1 = selector.kind;
      if (!(t1 === C.SelectorKind_getter_0 && selector.name === "length"))
        t2 = t1 === C.SelectorKind_index_4 && selector.argumentCount === 1;
      else
        t2 = true;
      if (t2) {
        t1 = this.this_0;
        return new B.FlatTypeMask(element.get$enclosingClass().get$declaration(), 2).satisfies$2(t1.backend.jsIndexableClass, t1.compiler);
      } else if (t1 === C.SelectorKind_index_4 && selector.argumentCount === 2) {
        t1 = this.this_0;
        return new B.FlatTypeMask(element.get$enclosingClass().get$declaration(), 2).satisfies$2(t1.backend.jsMutableIndexableClass, t1.compiler);
      } else
        return false;
    },
    $isFunction: true
  },
  SsaBuilder_pushInvokeDynamic_isOptimizableOperation: {
    "^": "Closure:272;this_1,isOptimizableOperationOnIndexable_2",
    call$2: function(selector, element) {
      var cls, t1, t2;
      cls = element.get$enclosingClass();
      if (this.isOptimizableOperationOnIndexable_2.call$2(selector, element) === true)
        return true;
      t1 = this.this_1.backend;
      if (!t1._interceptedClasses.contains$1(0, cls))
        return false;
      t2 = selector.kind;
      if (t2 === C.SelectorKind_operator_3)
        return true;
      if (t2 === C.SelectorKind_setter_1)
        return true;
      t2 = t2 === C.SelectorKind_index_4;
      if (t2 && selector.argumentCount === 1)
        return true;
      if (t2 && selector.argumentCount === 2)
        return true;
      if (element === t1.jsArrayAdd || element === t1.jsArrayRemoveLast || element === t1.jsStringSplit)
        return true;
      return false;
    },
    $isFunction: true
  },
  SsaBuilder_visitRedirectingFactoryBody_closure: {
    "^": "Closure:50;this_0,inputs_1",
    call$1: function(element) {
      this.inputs_1.push(this.this_0.localsHandler.readLocal$1(element));
    },
    $isFunction: true
  },
  SsaBuilder_visitRedirectingFactoryBody_closure0: {
    "^": "Closure:123;this_2,inputs_3",
    call$1: function(argument) {
      this.inputs_3.push(this.this_2.analyzeTypeArgument$1(argument));
    },
    $isFunction: true
  },
  SsaBuilder_visitConditional_closure: {
    "^": "Closure:23;this_0,node_1",
    call$0: function() {
      var t1 = this.node_1.condition;
      if (t1 != null)
        t1.accept$1(0, this.this_0);
      return;
    },
    $isFunction: true
  },
  SsaBuilder_visitConditional_closure0: {
    "^": "Closure:23;this_2,node_3",
    call$0: function() {
      var t1 = this.node_3.thenExpression;
      if (t1 != null)
        t1.accept$1(0, this.this_2);
      return;
    },
    $isFunction: true
  },
  SsaBuilder_visitConditional_closure1: {
    "^": "Closure:23;this_4,node_5",
    call$0: function() {
      var t1 = this.node_5.elseExpression;
      if (t1 != null)
        t1.accept$1(0, this.this_4);
      return;
    },
    $isFunction: true
  },
  SsaBuilder_visitForIn_buildInitializer: {
    "^": "Closure:7;box_0,this_1,node_2",
    call$0: function() {
      var t1, t2, t3, selector;
      t1 = this.this_1;
      t2 = this.node_2;
      t3 = t1.elements._selectors;
      selector = t3 != null ? t3.$index(0, t2) : null;
      t3 = t2.expression;
      if (t3 != null)
        t3.accept$1(0, t1);
      t3 = t1.stack;
      if (0 >= t3.length)
        return H.ioore(t3, 0);
      t1.pushInvokeDynamic$3(t2, selector, [t3.pop()]);
      t1 = t1.stack;
      if (0 >= t1.length)
        return H.ioore(t1, 0);
      this.box_0.iterator_0 = t1.pop();
    },
    $isFunction: true
  },
  SsaBuilder_visitForIn_buildCondition: {
    "^": "Closure:267;box_0,this_3,node_4",
    call$0: function() {
      var t1, t2, t3, selector;
      t1 = this.this_3;
      t2 = this.node_4;
      t3 = t1.elements._selectors;
      selector = t3 != null ? t3.$index(0, t2.forToken) : null;
      t1.pushInvokeDynamic$3(t2, selector, [this.box_0.iterator_0]);
      return t1.popBoolified$0();
    },
    $isFunction: true
  },
  SsaBuilder_visitForIn_buildBody: {
    "^": "Closure:7;box_0,this_5,node_6",
    call$0: function() {
      var t1, t2, t3, $call, identifier, variable, selector, value;
      t1 = this.this_5;
      t2 = this.node_6;
      t3 = t1.elements._selectors;
      $call = t3 != null ? t3.$index(0, t2.inToken) : null;
      t1.pushInvokeDynamic$3(t2, $call, [this.box_0.iterator_0]);
      identifier = t2.declaredIdentifier;
      t1.elements.toString;
      variable = t2.get$_secret_tree_element$_element();
      t3 = t1.elements._selectors;
      selector = t3 != null ? t3.$index(0, identifier) : null;
      t3 = t1.stack;
      if (0 >= t3.length)
        return H.ioore(t3, 0);
      value = t3.pop();
      if (identifier.asSend$0() != null && O.Elements_isInstanceSend(identifier, t1.elements))
        t1.generateInstanceSetterWithCompiledReceiver$5$location$selector(null, t1.generateInstanceSendReceiver$1(identifier), value, identifier, selector);
      else
        t1.generateNonInstanceSetter$4$location(null, variable, value, identifier);
      t3 = t1.stack;
      if (0 >= t3.length)
        return H.ioore(t3, 0);
      t3.pop();
      t2 = t2.body;
      if (t2 != null)
        t2.accept$1(0, t1);
    },
    $isFunction: true
  },
  SsaBuilder_visitForIn_closure: {
    "^": "Closure:23;",
    call$0: function() {
    },
    $isFunction: true
  },
  SsaBuilder_visitLabeledStatement_closure: {
    "^": "Closure:264;joinBlock_0,breakHandlers_1",
    call$2: function(breakInstruction, locals) {
      breakInstruction.block.addSuccessor$1(this.joinBlock_0);
      this.breakHandlers_1.push(locals);
    },
    $isFunction: true
  },
  SsaBuilder_visitLiteralMap_closure: {
    "^": "Closure:123;this_0,inputs_1",
    call$1: function(argument) {
      this.inputs_1.push(this.this_0.analyzeTypeArgument$1(argument));
    },
    $isFunction: true
  },
  SsaBuilder_buildSimpleSwitchStatement_buildExpression: {
    "^": "Closure:267;this_0,node_1",
    call$0: function() {
      var t1, t2;
      t1 = this.this_0;
      t2 = this.node_1.parenthesizedExpression.expression;
      if (t2 != null)
        t2.accept$1(0, t1);
      t1 = t1.stack;
      if (0 >= t1.length)
        return H.ioore(t1, 0);
      return t1.pop();
    },
    $isFunction: true
  },
  SsaBuilder_buildSimpleSwitchStatement_getConstants: {
    "^": "Closure:273;constants_2",
    call$1: function(switchCase) {
      var constantList, t1, t2, labelOrCase;
      constantList = H.setRuntimeTypeInfo([], [K.Constant]);
      for (t1 = switchCase.labelsAndCases.nodes, t1.toString, t1 = H.setRuntimeTypeInfo(new E.LinkIterator(null, t1), [H.getTypeArgumentByIndex(t1, 0)]), t2 = this.constants_2; t1.moveNext$0();) {
        labelOrCase = t1._util_implementation$_current;
        if (!!J.getInterceptor(labelOrCase).$isCaseMatch)
          constantList.push(t2.$index(0, labelOrCase));
      }
      return constantList;
    },
    $isFunction: true
  },
  SsaBuilder_buildSimpleSwitchStatement_isDefaultCase: {
    "^": "Closure:274;",
    call$1: function(switchCase) {
      return switchCase.defaultKeyword != null;
    },
    $isFunction: true
  },
  SsaBuilder_buildSimpleSwitchStatement_buildSwitchCase: {
    "^": "Closure:275;this_3",
    call$1: function(node) {
      var t1 = node.statements;
      t1.accept$1(0, this.this_3);
    },
    $isFunction: true
  },
  SsaBuilder_buildComplexSwitchStatement_buildExpression: {
    "^": "Closure:267;this_0,node_1",
    call$0: function() {
      var t1, t2;
      t1 = this.this_0;
      t2 = this.node_1.parenthesizedExpression.expression;
      if (t2 != null)
        t2.accept$1(0, t1);
      t1 = t1.stack;
      if (0 >= t1.length)
        return H.ioore(t1, 0);
      return t1.pop();
    },
    $isFunction: true
  },
  SsaBuilder_buildComplexSwitchStatement_getConstants: {
    "^": "Closure:273;constants_2",
    call$1: function(switchCase) {
      var constantList, t1, t2, labelOrCase;
      constantList = H.setRuntimeTypeInfo([], [K.Constant]);
      if (switchCase != null)
        for (t1 = switchCase.labelsAndCases.nodes, t1.toString, t1 = H.setRuntimeTypeInfo(new E.LinkIterator(null, t1), [H.getTypeArgumentByIndex(t1, 0)]), t2 = this.constants_2; t1.moveNext$0();) {
          labelOrCase = t1._util_implementation$_current;
          if (!!J.getInterceptor(labelOrCase).$isCaseMatch)
            constantList.push(t2.$index(0, labelOrCase));
        }
      return constantList;
    },
    $isFunction: true
  },
  SsaBuilder_buildComplexSwitchStatement_isDefaultCase: {
    "^": "Closure:274;",
    call$1: function(switchCase) {
      return switchCase == null || switchCase.defaultKeyword != null;
    },
    $isFunction: true
  },
  SsaBuilder_buildComplexSwitchStatement_buildSwitchCase: {
    "^": "Closure:275;this_3,caseIndex_4,switchTarget_5",
    call$1: function(switchCase) {
      var t1, t2, index, t3, value;
      t1 = this.this_3;
      t2 = this.switchTarget_5;
      if (switchCase != null) {
        index = this.caseIndex_4.$index(0, switchCase);
        t3 = t1.compiler;
        value = t1.graph.addConstant$2(t3.backend.get$constantSystem().createInt$1(index), t3);
        t1.localsHandler.updateLocal$2(t2, value);
      } else {
        t3 = t1.compiler;
        value = t1.graph.addConstant$2(t3.backend.get$constantSystem().createNull$0(), t3);
        t1.localsHandler.updateLocal$2(t2, value);
      }
      t1.jumpTargets.$index(0, t2).generateBreak$0();
    },
    $isFunction: true
  },
  SsaBuilder_buildComplexSwitchStatement_buildCondition: {
    "^": "Closure:267;this_6",
    call$0: function() {
      var t1, t2;
      t1 = this.this_6;
      t2 = t1.compiler;
      return t1.graph.addConstant$2(t2.backend.get$constantSystem().createBool$1(true), t2);
    },
    $isFunction: true
  },
  SsaBuilder_buildComplexSwitchStatement_buildSwitch: {
    "^": "Closure:7;this_7,node_8,caseIndex_9,switchTarget_10",
    call$0: function() {
      var t1, t2, t3;
      t1 = this.this_7;
      t2 = this.switchTarget_10;
      t3 = this.node_8;
      t1.handleSwitch$7(t3, new B.NullJumpHandler(t1.compiler), new B.SsaBuilder_buildComplexSwitchStatement_buildSwitch_buildExpression(t1, t2), t3.cases, new B.SsaBuilder_buildComplexSwitchStatement_buildSwitch_getConstants(t1, this.caseIndex_9), new B.SsaBuilder_buildComplexSwitchStatement_buildSwitch_closure(), new B.SsaBuilder_buildComplexSwitchStatement_buildSwitch_buildSwitchCase(t1, t2));
    },
    $isFunction: true
  },
  SsaBuilder_buildComplexSwitchStatement_buildSwitch_buildExpression: {
    "^": "Closure:267;this_11,switchTarget_12",
    call$0: function() {
      return this.this_11.localsHandler.readLocal$1(this.switchTarget_12);
    },
    $isFunction: true
  },
  SsaBuilder_buildComplexSwitchStatement_buildSwitch_getConstants: {
    "^": "Closure:273;this_13,caseIndex_14",
    call$1: function(switchCase) {
      return H.setRuntimeTypeInfo([this.this_13.constantSystem.createInt$1(this.caseIndex_14.$index(0, switchCase))], [K.Constant]);
    },
    $isFunction: true
  },
  SsaBuilder_buildComplexSwitchStatement_buildSwitch_buildSwitchCase: {
    "^": "Closure:275;this_15,switchTarget_16",
    call$1: function(switchCase) {
      var t1, t2;
      t1 = this.this_15;
      t2 = switchCase.statements;
      t2.accept$1(0, t1);
      if (t1._ssa$_current != null)
        t1.jumpTargets.$index(0, this.switchTarget_16).generateBreak$0();
    },
    $isFunction: true
  },
  SsaBuilder_buildComplexSwitchStatement_buildSwitch_closure: {
    "^": "Closure:13;",
    call$1: function(_) {
      return false;
    },
    $isFunction: true
  },
  SsaBuilder_buildComplexSwitchStatement_buildLoop: {
    "^": "Closure:7;this_17,node_18,buildCondition_19,buildSwitch_20",
    call$0: function() {
      this.this_17.handleLoop$5(this.node_18, new B.SsaBuilder_buildComplexSwitchStatement_buildLoop_closure(), this.buildCondition_19, new B.SsaBuilder_buildComplexSwitchStatement_buildLoop_closure0(), this.buildSwitch_20);
    },
    $isFunction: true
  },
  SsaBuilder_buildComplexSwitchStatement_buildLoop_closure: {
    "^": "Closure:23;",
    call$0: function() {
    },
    $isFunction: true
  },
  SsaBuilder_buildComplexSwitchStatement_buildLoop_closure0: {
    "^": "Closure:23;",
    call$0: function() {
    },
    $isFunction: true
  },
  SsaBuilder_buildComplexSwitchStatement_buildCondition0: {
    "^": "Closure:7;this_21,switchTarget_22",
    call$0: function() {
      var t1, t2;
      t1 = this.this_21;
      t2 = B.HForeign$(C.C_JsBuilder.parseForeignJS$1("#"), t1.backend.compiler.typesTask.get$boolType(), [t1.localsHandler.readLocal$1(this.switchTarget_22)], false, null, false, null);
      t1._ssa$_current.add$1(0, t2);
      t1.stack.push(t2);
    },
    $isFunction: true
  },
  SsaBuilder_buildComplexSwitchStatement_closure: {
    "^": "Closure:23;",
    call$0: function() {
      return P.LinkedHashMap_LinkedHashMap$_empty(null, null);
    },
    $isFunction: true
  },
  SsaBuilder_handleSwitch_closure: {
    "^": "Closure:264;box_0,caseHandlers_1",
    call$2: function(instruction, locals) {
      instruction.block.addSuccessor$1(this.box_0.joinBlock_0);
      this.caseHandlers_1.push(locals);
    },
    $isFunction: true
  },
  SsaBuilder_handleSwitch_closure0: {
    "^": "Closure:265;this_2,errorNode_3",
    call$2: function(instruction, locals) {
    },
    $isFunction: true
  },
  SsaBuilder_visitTryStatement_pushCondition: {
    "^": "Closure:276;this_1,unwrappedException_2",
    call$1: function(catchBlock) {
      var t1, t2, t3, type, condition, declaration, t4;
      if (catchBlock.onKeyword != null) {
        t1 = this.this_1;
        t2 = t1.elements;
        t3 = catchBlock.type;
        t2 = t2._types;
        type = t2 != null ? t2.$index(0, t3) : null;
        if (type == null)
          t1.compiler.internalError$2(t3, "On with no type.");
        condition = t1.buildIsNode$3(t3, type, this.unwrappedException_2);
        t1._ssa$_current.add$1(0, condition);
        t1.stack.push(condition);
      } else {
        t1 = catchBlock.formals.nodes;
        declaration = t1.get$head(t1);
        t1 = J.getInterceptor$x(declaration);
        t2 = this.this_1;
        if (t1.get$type(declaration) == null) {
          t1 = t2.compiler;
          condition = t2.graph.addConstant$2(t1.backend.get$constantSystem().createBool$1(true), t1);
          t2.stack.push(condition);
        } else {
          t3 = t2.elements;
          t4 = t1.get$type(declaration);
          t3 = t3._types;
          type = t3 != null ? t3.$index(0, t4) : null;
          if (type == null)
            t2.compiler.internalError$2(catchBlock, "Catch with unresolved type.");
          condition = t2.buildIsNode$3(t1.get$type(declaration), type, this.unwrappedException_2);
          t2._ssa$_current.add$1(0, condition);
          t2.stack.push(condition);
        }
      }
    },
    $isFunction: true
  },
  SsaBuilder_visitTryStatement_visitThen: {
    "^": "Closure:7;box_0,this_3,unwrappedException_4",
    call$0: function() {
      var t1, t2, catchBlock, t3, t4, exceptionVariable, trace, traceInstruction, traceVariable;
      t1 = this.box_0;
      t2 = t1.link_2;
      catchBlock = t2.get$head(t2);
      t1.link_2 = t1.link_2.get$tail();
      if (catchBlock.get$exception() != null) {
        t2 = this.this_3;
        t3 = t2.elements;
        t4 = catchBlock.get$exception();
        t3.toString;
        exceptionVariable = t4.get$_secret_tree_element$_element();
        t2.localsHandler.updateLocal$2(exceptionVariable, this.unwrappedException_4);
      }
      trace = catchBlock.get$trace();
      if (trace != null) {
        t2 = this.this_3;
        t3 = t2.backend;
        t2.pushInvokeStatic$3(trace, t3.find$2(0, t3.jsHelperLibrary, "getTraceFromException"), [t1.exception_1]);
        t1 = t2.stack;
        if (0 >= t1.length)
          return H.ioore(t1, 0);
        traceInstruction = t1.pop();
        t2.elements.toString;
        traceVariable = trace.get$_secret_tree_element$_element();
        t2.localsHandler.updateLocal$2(traceVariable, traceInstruction);
      }
      catchBlock.accept$1(0, this.this_3);
    },
    $isFunction: true
  },
  SsaBuilder_visitTryStatement_visitElse: {
    "^": "Closure:7;box_0,this_5,node_6,pushCondition_7,visitThen_8",
    call$0: function() {
      var t1, t2, t3;
      t1 = this.box_0;
      t2 = t1.link_2;
      t3 = this.this_5;
      if (t2.get$isEmpty(t2)) {
        t1 = H.setRuntimeTypeInfo([t1.exception_1], [B.HInstruction]);
        t2 = $.HInstruction_idCounter;
        if (typeof t2 !== "number")
          return t2.$add();
        $.HInstruction_idCounter = t2 + 1;
        t2 = new B.HThrow(true, null, null, t2, t1, H.setRuntimeTypeInfo([], [B.HInstruction]), null, null, null, new Z.SideEffects(0), false, C.FlatTypeMask_null_0);
        t2.HInstruction$2(t1, C.FlatTypeMask_null_0);
        t3.closeAndGotoExit$1(t2);
      } else {
        t1 = t1.link_2;
        new B.SsaBranchBuilder(t3, this.node_6).handleIf$3(new B.SsaBuilder_visitTryStatement_visitElse_closure(this.pushCondition_7, t1.get$head(t1)), this.visitThen_8, this);
      }
    },
    $isFunction: true
  },
  SsaBuilder_visitTryStatement_visitElse_closure: {
    "^": "Closure:23;pushCondition_9,newBlock_10",
    call$0: function() {
      this.pushCondition_9.call$1(this.newBlock_10);
    },
    $isFunction: true
  },
  SsaBuilder_visitTryStatement_closure: {
    "^": "Closure:23;pushCondition_11,firstBlock_12",
    call$0: function() {
      this.pushCondition_11.call$1(this.firstBlock_12);
    },
    $isFunction: true
  },
  SsaBuilder_visitTryStatement_addOptionalSuccessor: {
    "^": "Closure:19;",
    call$2: function(b1, b2) {
      if (b2 != null)
        b1.addSuccessor$1(b2);
    },
    $isFunction: true
  },
  SsaBuilder_visitTryStatement_addExitTrySuccessor: {
    "^": "Closure:13;box_0,this_13",
    call$1: function(successor) {
      var i, t1, t2, t3, block;
      if (successor == null)
        return;
      i = this.box_0.startTryBlock_0.id;
      t1 = this.this_13.graph.blocks;
      t2 = successor.predecessors;
      while (true) {
        t3 = successor.id;
        if (typeof i !== "number")
          return i.$lt();
        if (typeof t3 !== "number")
          return H.iae(t3);
        if (!(i < t3))
          break;
        if (i >= t1.length)
          return H.ioore(t1, i);
        block = t1[i];
        if (!!J.getInterceptor(J.get$last$ax(block)).$isHExitTry) {
          if (block.get$successors().length === 0)
            block.set$successors([successor]);
          else
            C.JSArray_methods.add$1(block.get$successors(), successor);
          t2.push(block);
        }
        ++i;
      }
    },
    $isFunction: true
  },
  StringBuilderVisitor: {
    "^": "Visitor;builder,diagnosticNode,result",
    get$compiler: function() {
      return this.builder.compiler;
    },
    visitNode$1: function(node) {
      this.builder.compiler.internalError$2(node, "Unexpected node.");
    },
    visitExpression$1: function(node) {
      var t1, t2, expression, selector;
      t1 = this.builder;
      node.accept$1(0, t1);
      t2 = t1.stack;
      if (0 >= t2.length)
        return H.ioore(t2, 0);
      expression = t2.pop();
      t2 = t1.compiler;
      if (expression.canBePrimitive$1(t2)) {
        this.append$1(0, this.stringify$2(node, expression));
        return;
      }
      selector = Z.TypedSelector_TypedSelector(expression.instructionType, Z.Selector_Selector(C.SelectorKind_call_2, "toString", null, 0, null), t2);
      if (B.TypeMaskFactory_fromInferredType(t2.typesTask.getGuaranteedTypeOfSelector$1(selector), t2).containsOnlyString$1(t2)) {
        t1.pushInvokeDynamic$3(node, selector, H.setRuntimeTypeInfo([expression], [B.HInstruction]));
        t1 = t1.stack;
        if (0 >= t1.length)
          return H.ioore(t1, 0);
        this.append$1(0, t1.pop());
        return;
      }
      this.append$1(0, this.stringify$2(node, expression));
    },
    visitStringInterpolation$1: function(node) {
      this.visitLiteralString$1(node.string);
      this.visitNodeList$1(node.parts);
    },
    visitStringInterpolationPart$1: function(node) {
      node.expression.accept$1(0, this);
      node.string.accept$1(0, this);
    },
    visitStringJuxtaposition$1: function(node) {
      node.first.accept$1(0, this);
      node.second.accept$1(0, this);
    },
    visitNodeList$1: function(node) {
      node.visitChildren$1(this);
    },
    append$1: function(_, expression) {
      var t1, t2, t3, t4, instruction;
      t1 = this.result;
      if (t1 == null)
        t1 = expression;
      else {
        t2 = this.builder;
        t3 = t2.backend.compiler.typesTask.get$stringType();
        t1 = H.setRuntimeTypeInfo([t1, expression], [B.HInstruction]);
        t4 = $.HInstruction_idCounter;
        if (typeof t4 !== "number")
          return t4.$add();
        $.HInstruction_idCounter = t4 + 1;
        instruction = new B.HStringConcat(this.diagnosticNode, null, null, t4, t1, H.setRuntimeTypeInfo([], [B.HInstruction]), null, null, null, new Z.SideEffects(0), false, t3);
        instruction.HInstruction$2(t1, t3);
        instruction.sideEffects.setDependsOnSomething$0();
        t2._ssa$_current.add$1(0, instruction);
        t1 = instruction;
      }
      this.result = t1;
    },
    stringify$2: function(node, expression) {
      var t1, t2, t3, t4, instruction;
      t1 = this.builder;
      t2 = t1.backend.compiler.typesTask.get$stringType();
      t3 = H.setRuntimeTypeInfo([expression], [B.HInstruction]);
      t4 = $.HInstruction_idCounter;
      if (typeof t4 !== "number")
        return t4.$add();
      $.HInstruction_idCounter = t4 + 1;
      instruction = new B.HStringify(node, null, null, t4, t3, H.setRuntimeTypeInfo([], [B.HInstruction]), null, null, null, new Z.SideEffects(0), false, t2);
      instruction.HInstruction$2(t3, t2);
      t2 = instruction.sideEffects;
      t2.flags = (t2.flags | 7) >>> 0;
      t2.setDependsOnSomething$0();
      t1._ssa$_current.add$1(0, instruction);
      return instruction;
    },
    $asVisitor: function() {
      return [null];
    }
  },
  InlineWeeder: {
    "^": "Visitor;seenReturn,tooDifficult,nodeCount,maxInliningNodes,useMaxInliningNodes",
    registerNode$0: function() {
      if (!this.useMaxInliningNodes)
        return true;
      if (this.nodeCount++ > this.maxInliningNodes) {
        this.tooDifficult = true;
        return false;
      } else
        return true;
    },
    visitNode$1: function(node) {
      if (!this.registerNode$0())
        return;
      if (this.seenReturn)
        this.tooDifficult = true;
      else
        node.visitChildren$1(this);
    },
    visitFunctionExpression$1: function(node) {
      if (!this.registerNode$0())
        return;
      this.tooDifficult = true;
    },
    visitFunctionDeclaration$1: function(node) {
      if (!this.registerNode$0())
        return;
      this.tooDifficult = true;
    },
    visitSend$1: function(node) {
      if (!this.registerNode$0())
        return;
      node.visitChildren$1(this);
    },
    visitLoop$1: function(node) {
      this.tooDifficult = true;
    },
    visitRedirectingFactoryBody$1: function(node) {
      if (!this.registerNode$0())
        return;
      this.tooDifficult = true;
    },
    visitRethrow$1: function(node) {
      if (!this.registerNode$0())
        return;
      this.tooDifficult = true;
    },
    visitReturn$1: function(node) {
      if (!this.registerNode$0())
        return;
      if (this.seenReturn || node.get$beginToken().get$stringValue() === "native") {
        this.tooDifficult = true;
        return;
      }
      if (node.get$expression() != null)
        node.expression.accept$1(0, this);
      this.seenReturn = true;
    },
    visitTryStatement$1: function(node) {
      if (!this.registerNode$0())
        return;
      this.tooDifficult = true;
    },
    visitThrow$1: function(node) {
      if (!this.registerNode$0())
        return;
      if (this.seenReturn)
        this.tooDifficult = true;
    },
    $asVisitor: function() {
      return [null];
    },
    static: {"^": "InlineWeeder_INLINING_NODES_OUTSIDE_LOOP,InlineWeeder_INLINING_NODES_OUTSIDE_LOOP_ARG_FACTOR,InlineWeeder_INLINING_NODES_INSIDE_LOOP,InlineWeeder_INLINING_NODES_INSIDE_LOOP_ARG_FACTOR"}
  },
  InliningState: {
    "^": "Object;$function<"
  },
  AstInliningState: {
    "^": "InliningState;oldReturnLocal,oldReturnType,oldElements,oldStack,oldLocalsHandler,inTryStatement,$function"
  },
  SsaBranch: {
    "^": "Object;branchBuilder,block<,startLocals,exitLocals,graph"
  },
  SsaBranchBuilder: {
    "^": "Object;builder,diagnosticNode",
    get$compiler: function() {
      return this.builder.compiler;
    },
    checkNotAborted$0: function() {
      var t1 = this.builder;
      if (t1._ssa$_current == null)
        t1.compiler.internalError$2(this.diagnosticNode, "aborted control flow not implemented.");
    },
    mergeLocals$3$mayReuseFromLocals: function(fromBranch, toBranch, mayReuseFromLocals) {
      var fromLocals, t1;
      fromLocals = fromBranch.exitLocals;
      t1 = toBranch.startLocals;
      if (t1 == null)
        if (mayReuseFromLocals) {
          toBranch.startLocals = fromLocals;
          return false;
        } else {
          toBranch.startLocals = B.LocalsHandler$from0(fromLocals);
          return true;
        }
      else {
        t1.mergeWith$2(fromLocals, toBranch.block);
        return true;
      }
    },
    startBranch$1: function(branch) {
      var t1, t2;
      t1 = this.builder;
      t2 = branch.block;
      t1.graph.addBlock$1(t2);
      t1.localsHandler = branch.startLocals;
      t2.status = 1;
      t1.isReachable = true;
      t1._ssa$_current = t2;
      t1.lastOpenedBlock = t2;
    },
    buildBranch$4: function(branch, visitBranch, joinBranch, isExpression) {
      var t1, t2, t3;
      this.startBranch$1(branch);
      visitBranch.call$0();
      t1 = this.builder;
      branch.graph = new B.SubGraph(branch.block, t1.lastOpenedBlock);
      branch.exitLocals = t1.localsHandler;
      t2 = t1._ssa$_current;
      if (t2 != null) {
        t3 = $.HInstruction_idCounter;
        if (typeof t3 !== "number")
          return t3.$add();
        $.HInstruction_idCounter = t3 + 1;
        t3 = new B.HGoto(null, null, t3, C.List_empty12, H.setRuntimeTypeInfo([], [B.HInstruction]), null, null, null, new Z.SideEffects(0), false, C.FlatTypeMask_null_0);
        t3.HInstruction$2(C.List_empty12, C.FlatTypeMask_null_0);
        t2.close$1(0, t3);
        t2.addSuccessor$1(joinBranch.block);
        this.mergeLocals$3$mayReuseFromLocals(branch, joinBranch, true);
      }
      if (isExpression) {
        this.checkNotAborted$0();
        t1 = t1.stack;
        if (0 >= t1.length)
          return H.ioore(t1, 0);
        return t1.pop();
      }
      return;
    },
    handleIf$3: function(visitCondition, visitThen, visitElse) {
      this._handleDiamondBranch$4(visitCondition, visitThen, visitElse == null ? new B.SsaBranchBuilder_handleIf_closure() : visitElse, false);
    },
    handleLogicalAndOr$3$isAnd: function(left, right, isAnd) {
      var t1, t2, t3, notIsAnd, t4, result;
      t1 = {};
      t1.boolifiedLeft_0 = null;
      t1.boolifiedRight_1 = null;
      this.handleIf$3(new B.SsaBranchBuilder_handleLogicalAndOr_visitCondition(t1, this, left, isAnd), new B.SsaBranchBuilder_handleLogicalAndOr_visitThen(t1, this, right), null);
      t2 = this.builder;
      t3 = t2.compiler;
      notIsAnd = t2.graph.addConstant$2(t3.backend.get$constantSystem().createBool$1(!isAnd), t3);
      t1 = H.setRuntimeTypeInfo([t1.boolifiedRight_1, notIsAnd], [B.HInstruction]);
      t3 = t2.backend.compiler.typesTask.get$dynamicType();
      t4 = $.HInstruction_idCounter;
      if (typeof t4 !== "number")
        return t4.$add();
      $.HInstruction_idCounter = t4 + 1;
      result = new B.HPhi(0, null, null, t4, t1, H.setRuntimeTypeInfo([], [B.HInstruction]), null, null, null, new Z.SideEffects(0), false, t3);
      result.HInstruction$2(t1, t3);
      result.sourceElement = null;
      t2._ssa$_current.addPhi$1(result);
      t2.stack.push(result);
    },
    handleLogicalAndOrWithLeftNode$3$isAnd: function(left, visitRight, isAnd) {
      var send, t1, newLeft, link;
      send = left.asSend$0();
      if (send != null)
        if (isAnd) {
          t1 = send.selector;
          if (!!J.getInterceptor(t1).$isOperator) {
            t1 = t1.asOperator$0().token;
            t1 = t1.get$value(t1) === "&&";
          } else
            t1 = false;
        } else {
          t1 = send.selector;
          if (!!J.getInterceptor(t1).$isOperator) {
            t1 = t1.asOperator$0().token;
            t1 = t1.get$value(t1) === "||";
          } else
            t1 = false;
        }
      else
        t1 = false;
      if (t1) {
        newLeft = send.receiver;
        link = send.argumentsNode.nodes;
        this.handleLogicalAndOrWithLeftNode$3$isAnd(newLeft, new B.SsaBranchBuilder_handleLogicalAndOrWithLeftNode_closure(this, visitRight, isAnd, link.get$head(link)), isAnd);
      } else
        this.handleLogicalAndOr$3$isAnd(new B.SsaBranchBuilder_handleLogicalAndOrWithLeftNode_closure0(this, left), visitRight, isAnd);
    },
    _handleDiamondBranch$4: function(visitCondition, visitThen, visitElse, isExpression) {
      var t1, conditionBranch, t2, thenBranch, t3, elseBranch, t4, joinBlock, joinBranch, t5, t6, t7, branch, conditionExitBlock, thenValue, elseValue, phi;
      t1 = new B.HBasicBlock(null, 0, new B.HInstructionList(null, null), null, null, null, true, H.setRuntimeTypeInfo([], [B.HBasicBlock]), C.List_empty13, null, H.setRuntimeTypeInfo([], [B.HBasicBlock]), null, null, null);
      conditionBranch = new B.SsaBranch(this, t1, null, null, null);
      t2 = new B.HBasicBlock(null, 0, new B.HInstructionList(null, null), null, null, null, true, H.setRuntimeTypeInfo([], [B.HBasicBlock]), C.List_empty13, null, H.setRuntimeTypeInfo([], [B.HBasicBlock]), null, null, null);
      thenBranch = new B.SsaBranch(this, t2, null, null, null);
      t3 = new B.HBasicBlock(null, 0, new B.HInstructionList(null, null), null, null, null, true, H.setRuntimeTypeInfo([], [B.HBasicBlock]), C.List_empty13, null, H.setRuntimeTypeInfo([], [B.HBasicBlock]), null, null, null);
      elseBranch = new B.SsaBranch(this, t3, null, null, null);
      t4 = H.setRuntimeTypeInfo([], [B.HBasicBlock]);
      joinBlock = new B.HBasicBlock(null, 0, new B.HInstructionList(null, null), null, null, null, true, t4, C.List_empty13, null, H.setRuntimeTypeInfo([], [B.HBasicBlock]), null, null, null);
      joinBranch = new B.SsaBranch(this, joinBlock, null, null, null);
      t5 = this.builder;
      conditionBranch.startLocals = t5.localsHandler;
      t6 = t5._ssa$_current;
      t7 = $.HInstruction_idCounter;
      if (typeof t7 !== "number")
        return t7.$add();
      $.HInstruction_idCounter = t7 + 1;
      t7 = new B.HGoto(null, null, t7, C.List_empty12, H.setRuntimeTypeInfo([], [B.HInstruction]), null, null, null, new Z.SideEffects(0), false, C.FlatTypeMask_null_0);
      t7.HInstruction$2(C.List_empty12, C.FlatTypeMask_null_0);
      t6.close$1(0, t7);
      t6.addSuccessor$1(t1);
      this.startBranch$1(conditionBranch);
      visitCondition.call$0();
      this.checkNotAborted$0();
      t6 = H.setRuntimeTypeInfo([t5.popBoolified$0()], [B.HInstruction]);
      t7 = $.HInstruction_idCounter;
      if (typeof t7 !== "number")
        return t7.$add();
      $.HInstruction_idCounter = t7 + 1;
      branch = new B.HIf(null, null, null, t7, t6, H.setRuntimeTypeInfo([], [B.HInstruction]), null, null, null, new Z.SideEffects(0), false, C.FlatTypeMask_null_0);
      branch.HInstruction$2(t6, C.FlatTypeMask_null_0);
      conditionExitBlock = t5._ssa$_current;
      t5.close$1(0, branch);
      conditionBranch.exitLocals = t5.localsHandler;
      conditionExitBlock.addSuccessor$1(t2);
      conditionExitBlock.addSuccessor$1(t3);
      this.mergeLocals$3$mayReuseFromLocals(conditionBranch, elseBranch, this.mergeLocals$3$mayReuseFromLocals(conditionBranch, thenBranch, true));
      conditionBranch.graph = new B.SubExpression(t1, conditionExitBlock);
      thenValue = this.buildBranch$4(thenBranch, visitThen, joinBranch, isExpression);
      elseValue = this.buildBranch$4(elseBranch, visitElse, joinBranch, isExpression);
      if (isExpression) {
        t2 = H.setRuntimeTypeInfo([thenValue, elseValue], [B.HInstruction]);
        t3 = t5.backend.compiler.typesTask.get$dynamicType();
        t6 = $.HInstruction_idCounter;
        if (typeof t6 !== "number")
          return t6.$add();
        $.HInstruction_idCounter = t6 + 1;
        phi = new B.HPhi(0, null, null, t6, t2, H.setRuntimeTypeInfo([], [B.HInstruction]), null, null, null, new Z.SideEffects(0), false, t3);
        phi.HInstruction$2(t2, t3);
        phi.sourceElement = null;
        joinBlock.addPhi$1(phi);
        t5.stack.push(phi);
      }
      if (t4.length !== 0)
        this.startBranch$1(joinBranch);
      else
        joinBlock = null;
      t2 = conditionBranch.graph;
      t3 = new B.HBlockFlow(new B.HIfBlockInformation(new B.HSubExpressionBlockInformation(t2), new B.HSubGraphBlockInformation(thenBranch.graph), new B.HSubGraphBlockInformation(elseBranch.graph)), joinBlock);
      t1.blockFlow = t3;
      t2.end.last.set$blockInformation(t3);
    }
  },
  SsaBranchBuilder_handleIf_closure: {
    "^": "Closure:23;",
    call$0: function() {
    },
    $isFunction: true
  },
  SsaBranchBuilder_handleLogicalAndOr_visitCondition: {
    "^": "Closure:7;box_0,this_1,left_2,isAnd_3",
    call$0: function() {
      var t1, boolifiedLeft, t2, t3, t4;
      this.left_2.call$0();
      t1 = this.this_1.builder;
      boolifiedLeft = t1.popBoolified$0();
      this.box_0.boolifiedLeft_0 = boolifiedLeft;
      t1.stack.push(boolifiedLeft);
      if (!this.isAnd_3) {
        t2 = t1.stack;
        if (0 >= t2.length)
          return H.ioore(t2, 0);
        t2 = t2.pop();
        t3 = t1.backend.compiler.typesTask.get$boolType();
        t2 = H.setRuntimeTypeInfo([t2], [B.HInstruction]);
        t4 = $.HInstruction_idCounter;
        if (typeof t4 !== "number")
          return t4.$add();
        $.HInstruction_idCounter = t4 + 1;
        t4 = new B.HNot(null, null, t4, t2, H.setRuntimeTypeInfo([], [B.HInstruction]), null, null, null, new Z.SideEffects(0), false, t3);
        t4.HInstruction$2(t2, t3);
        t4._useGvn = true;
        t1._ssa$_current.add$1(0, t4);
        t1.stack.push(t4);
      }
    },
    $isFunction: true
  },
  SsaBranchBuilder_handleLogicalAndOr_visitThen: {
    "^": "Closure:7;box_0,this_4,right_5",
    call$0: function() {
      this.right_5.call$0();
      this.box_0.boolifiedRight_1 = this.this_4.builder.popBoolified$0();
    },
    $isFunction: true
  },
  SsaBranchBuilder_handleLogicalAndOrWithLeftNode_closure: {
    "^": "Closure:23;this_0,visitRight_1,isAnd_2,middle_3",
    call$0: function() {
      return this.this_0.handleLogicalAndOrWithLeftNode$3$isAnd(this.middle_3, this.visitRight_1, this.isAnd_2);
    },
    $isFunction: true
  },
  SsaBranchBuilder_handleLogicalAndOrWithLeftNode_closure0: {
    "^": "Closure:23;this_4,left_5",
    call$0: function() {
      this.left_5.accept$1(0, this.this_4.builder);
      return;
    },
    $isFunction: true
  },
  TypeBuilder: {
    "^": "Object;",
    visitVoidType$2: function(type, builder) {
      var t1, t2;
      t1 = builder.get$backend();
      t1 = new B.FlatTypeMask(t1.find$2(0, t1.jsHelperLibrary, "VoidRuntimeType"), 3);
      t2 = $.HInstruction_idCounter;
      if (typeof t2 !== "number")
        return t2.$add();
      $.HInstruction_idCounter = t2 + 1;
      t2 = new B.HVoidType(type, null, null, t2, C.List_empty12, H.setRuntimeTypeInfo([], [B.HInstruction]), null, null, null, new Z.SideEffects(0), false, t1);
      t2.HInstruction$2(C.List_empty12, t1);
      t2._useGvn = true;
      builder.get$_ssa$_current().add$1(0, t2);
      builder.stack.push(t2);
    },
    visitTypeVariableType$2: function(type, builder) {
      var t1, instructionType, t2;
      t1 = builder.get$backend();
      instructionType = new B.FlatTypeMask(t1.find$2(0, t1.jsHelperLibrary, "RuntimeType"), 5);
      if (!J.get$last$ax(builder.get$sourceElementStack()).get$enclosingElement().get$isClosure() && J.get$last$ax(builder.sourceElementStack).get$isInstanceMember()) {
        t1 = H.setRuntimeTypeInfo([builder.localsHandler.readThis$0()], [B.HInstruction]);
        t2 = $.HInstruction_idCounter;
        if (typeof t2 !== "number")
          return t2.$add();
        $.HInstruction_idCounter = t2 + 1;
        t2 = new B.HReadTypeVariable(type, true, null, null, t2, t1, H.setRuntimeTypeInfo([], [B.HInstruction]), null, null, null, new Z.SideEffects(0), false, instructionType);
        t2.HInstruction$2(t1, instructionType);
        t2._useGvn = true;
        builder._ssa$_current.add$1(0, t2);
        builder.stack.push(t2);
      } else {
        t1 = H.setRuntimeTypeInfo([builder.addTypeVariableReference$1(type)], [B.HInstruction]);
        t2 = $.HInstruction_idCounter;
        if (typeof t2 !== "number")
          return t2.$add();
        $.HInstruction_idCounter = t2 + 1;
        t2 = new B.HReadTypeVariable(type, false, null, null, t2, t1, H.setRuntimeTypeInfo([], [B.HInstruction]), null, null, null, new Z.SideEffects(0), false, instructionType);
        t2.HInstruction$2(t1, instructionType);
        t2._useGvn = true;
        builder._ssa$_current.add$1(0, t2);
        builder.stack.push(t2);
      }
    },
    visitFunctionType$2: function(type, builder) {
      var t1, inputs, t2, namedParameterTypes, names, index, t3;
      type.returnType.accept$2(0, this, builder);
      t1 = builder.get$stack();
      if (0 >= t1.length)
        return H.ioore(t1, 0);
      inputs = H.setRuntimeTypeInfo([t1.pop()], [B.HInstruction]);
      for (t1 = type.parameterTypes, t1 = H.setRuntimeTypeInfo(new H.ListIterator(t1, t1.length, 0, null), [H.getTypeArgumentByIndex(t1, 0)]); t1.moveNext$0();) {
        J.accept$2$x(t1.__internal$_current, this, builder);
        t2 = builder.stack;
        if (0 >= t2.length)
          return H.ioore(t2, 0);
        inputs.push(t2.pop());
      }
      for (t1 = type.optionalParameterTypes, t1 = H.setRuntimeTypeInfo(new H.ListIterator(t1, t1.length, 0, null), [H.getTypeArgumentByIndex(t1, 0)]); t1.moveNext$0();) {
        J.accept$2$x(t1.__internal$_current, this, builder);
        t2 = builder.stack;
        if (0 >= t2.length)
          return H.ioore(t2, 0);
        inputs.push(t2.pop());
      }
      namedParameterTypes = type.namedParameterTypes;
      names = type.namedParameters;
      for (t1 = builder.graph, t2 = builder.compiler, index = 0; index < names.length; ++index) {
        t3 = names[index];
        inputs.push(t1.addConstant$2(t2.backend.get$constantSystem().createString$1(new Y.LiteralDartString(t3)), t2));
        if (index >= namedParameterTypes.length)
          return H.ioore(namedParameterTypes, index);
        J.accept$2$x(namedParameterTypes[index], this, builder);
        t3 = builder.stack;
        if (0 >= t3.length)
          return H.ioore(t3, 0);
        inputs.push(t3.pop());
      }
      t1 = builder.backend;
      t1 = new B.FlatTypeMask(t1.find$2(0, t1.jsHelperLibrary, "RuntimeFunctionType"), 3);
      t2 = $.HInstruction_idCounter;
      if (typeof t2 !== "number")
        return t2.$add();
      $.HInstruction_idCounter = t2 + 1;
      t2 = new B.HFunctionType(type, null, null, t2, inputs, H.setRuntimeTypeInfo([], [B.HInstruction]), null, null, null, new Z.SideEffects(0), false, t1);
      t2.HInstruction$2(inputs, t1);
      t2._useGvn = true;
      builder._ssa$_current.add$1(0, t2);
      builder.stack.push(t2);
    },
    visitMalformedType$2: function(type, builder) {
      this.visitDynamicType$2(C.C_DynamicType, builder);
    },
    visitStatementType$2: function(type, builder) {
      throw H.wrapException("not implemented visitStatementType(" + type.toString$0(0) + ")");
    },
    visitInterfaceType$2: function(type, builder) {
      var inputs, t1, t2, t3, cls;
      inputs = H.setRuntimeTypeInfo([], [B.HInstruction]);
      for (t1 = type.typeArguments, t2 = H.setRuntimeTypeInfo(new H.ListIterator(t1, t1.length, 0, null), [H.getTypeArgumentByIndex(t1, 0)]); t2.moveNext$0();) {
        J.accept$2$x(t2.__internal$_current, this, builder);
        t3 = builder.get$stack();
        if (0 >= t3.length)
          return H.ioore(t3, 0);
        inputs.push(t3.pop());
      }
      if (t1.length === 0) {
        t1 = builder.get$backend();
        cls = t1.find$2(0, t1.jsHelperLibrary, "RuntimeTypePlain");
      } else {
        t1 = builder.get$backend();
        cls = t1.find$2(0, t1.jsHelperLibrary, "RuntimeTypeGeneric");
      }
      t1 = new B.FlatTypeMask(cls, 3);
      t2 = $.HInstruction_idCounter;
      if (typeof t2 !== "number")
        return t2.$add();
      $.HInstruction_idCounter = t2 + 1;
      t2 = new B.HInterfaceType(type, null, null, t2, inputs, H.setRuntimeTypeInfo([], [B.HInstruction]), null, null, null, new Z.SideEffects(0), false, t1);
      t2.HInstruction$2(inputs, t1);
      t2._useGvn = true;
      builder.get$_ssa$_current().add$1(0, t2);
      builder.stack.push(t2);
    },
    visitTypedefType$2: function(type, builder) {
      var unaliased, t1;
      unaliased = type.unalias$1(builder.get$compiler());
      t1 = J.getInterceptor(unaliased);
      if (!!t1.$isTypedefType)
        throw H.wrapException("unable to unalias " + type.toString$0(0));
      t1.accept$2(unaliased, this, builder);
    },
    visitDynamicType$2: function(type, builder) {
      var backend, t1, t2;
      backend = builder.get$compiler().backend;
      t1 = new B.FlatTypeMask(backend.find$2(0, backend.get$jsHelperLibrary(), "DynamicRuntimeType"), 3);
      t2 = $.HInstruction_idCounter;
      if (typeof t2 !== "number")
        return t2.$add();
      $.HInstruction_idCounter = t2 + 1;
      t2 = new B.HDynamicType(type, null, null, t2, C.List_empty12, H.setRuntimeTypeInfo([], [B.HInstruction]), null, null, null, new Z.SideEffects(0), false, t1);
      t2.HInstruction$2(C.List_empty12, t1);
      t2._useGvn = true;
      builder.get$_ssa$_current().add$1(0, t2);
      builder.stack.push(t2);
    }
  },
  SsaCodeGeneratorTask: {
    "^": "CompilerTask;backend<,compiler,watch,profilerTag",
    get$name: function(_) {
      return "SSA code generator";
    },
    attachPosition$2: function(node, element) {
      var sourceFile, $name, expression, endToken, beginToken, sourcePosition;
      sourceFile = element.get$implementation(element).get$compilationUnit().get$script().file;
      $name = element.name;
      expression = element.get$implementation(element).get$node();
      if (expression == null) {
        endToken = element.get$position(element);
        beginToken = endToken;
      } else {
        beginToken = expression.getBeginToken$0();
        endToken = expression.getEndToken$0();
      }
      sourcePosition = beginToken.charOffset < sourceFile.get$length(sourceFile) ? new T.TokenSourceFileLocation(beginToken, $name, sourceFile, null) : null;
      return node.withPosition$2(sourcePosition, endToken.charOffset < sourceFile.get$length(sourceFile) ? new T.TokenSourceFileLocation(endToken, $name, sourceFile, null) : null);
    },
    generateCode$2: function(work, graph) {
      var t1 = work.element;
      if (t1.get$kind(t1) === C.ElementKind_field_1)
        return this.generateLazyInitializer$2(work, graph);
      else
        return this.generateMethod$2(work, graph);
    },
    generateLazyInitializer$2: function(work, graph) {
      return this.measure$1(new B.SsaCodeGeneratorTask_generateLazyInitializer_closure(this, work, graph));
    },
    generateMethod$2: function(work, graph) {
      return this.measure$1(new B.SsaCodeGeneratorTask_generateMethod_closure(this, work, graph));
    }
  },
  SsaCodeGeneratorTask_generateLazyInitializer_closure: {
    "^": "Closure:23;this_0,work_1,graph_2",
    call$0: function() {
      var t1, t2, t3, codegen;
      t1 = this.this_0;
      t2 = this.graph_2;
      t1.compiler.tracer.traceGraph$2("codegen", t2);
      t3 = this.work_1;
      codegen = B.SsaCodeGenerator$(t1.backend, t3);
      codegen.visitGraph$1(t2);
      return new Q.Fun(codegen.parameters, t1.attachPosition$2(codegen.currentContainer, t3.element), null, null);
    },
    $isFunction: true
  },
  SsaCodeGeneratorTask_generateMethod_closure: {
    "^": "Closure:23;this_0,work_1,graph_2",
    call$0: function() {
      var t1, t2, codegen, t3;
      t1 = this.this_0;
      t2 = this.work_1;
      codegen = B.SsaCodeGenerator$(t1.backend, t2);
      t3 = this.graph_2;
      codegen.visitGraph$1(t3);
      t1.compiler.tracer.traceGraph$2("codegen", t3);
      return t1.attachPosition$2(new Q.Fun(codegen.parameters, codegen.currentContainer, null, null), t2.element);
    },
    $isFunction: true
  },
  SsaCodeGenerator: {
    "^": "Object;isGeneratingExpression,backend<,work,generateAtUseSite,controlFlowOperators,breakAction,continueAction,parameters<,currentContainer,expressionStack,oldContainerStack,variableNames,shouldGroupVarDeclarations,collectedVariableDeclarations,declaredLocals,currentGraph,currentBlockInformation,subGraph",
    get$body: function(_) {
      return this.currentContainer;
    },
    get$compiler: function() {
      return this.backend.compiler;
    },
    hasNonBitOpUser$2: function(instruction, phiSet) {
      var t1, t2, user;
      t1 = instruction.usedBy;
      t2 = new H.ListIterator(t1, t1.length, 0, null);
      t2.$builtinTypeInfo = [H.getTypeArgumentByIndex(t1, 0)];
      for (; t2.moveNext$0();) {
        user = t2.__internal$_current;
        t1 = J.getInterceptor(user);
        if (!!t1.$isHPhi) {
          if (!phiSet.contains$1(0, user)) {
            phiSet.add$1(0, user);
            if (this.hasNonBitOpUser$2(user, phiSet))
              return true;
          }
        } else if (!t1.$isHBitNot && !t1.$isHBinaryBitOp)
          return true;
      }
      return false;
    },
    requiresUintConversion$1: function(instruction) {
      if (instruction.isUInt31$1(this.backend.compiler))
        return false;
      return this.hasNonBitOpUser$2(instruction, P.LinkedHashSet_LinkedHashSet(null, null, null, B.HPhi));
    },
    pushStatement$2: function(statement, instruction) {
      if (instruction != null)
        statement = statement.withPosition$2(instruction.get$sourcePosition(), statement._endSourcePosition);
      this.currentContainer.statements.push(statement);
    },
    pushStatement$1: function(statement) {
      return this.pushStatement$2(statement, null);
    },
    push$2: function(expression, instruction) {
      if (instruction != null)
        expression = expression.withPosition$2(instruction.sourcePosition, expression.get$_endSourcePosition());
      this.expressionStack.push(expression);
    },
    push$1: function(expression) {
      return this.push$2(expression, null);
    },
    attachLocationToLast$1: function(instruction) {
      var t1, t2, index;
      t1 = this.expressionStack;
      t2 = t1.length;
      index = t2 - 1;
      if (index < 0)
        return H.ioore(t1, index);
      t2 = t1[index];
      t2 = t2.withPosition$2(instruction.sourcePosition, t2._endSourcePosition);
      if (index >= t1.length)
        return H.ioore(t1, index);
      t1[index] = t2;
    },
    handleDelayedVariableDeclarations$0: function() {
      var t1, t2, $name, statement, assignment, variableReference, declarations;
      t1 = this.collectedVariableDeclarations;
      t2 = t1._collection$_length;
      if (t2 !== 0) {
        if (t2 === 1) {
          t2 = this.currentContainer.statements;
          t2 = t2.length >= 1 && !!J.getInterceptor(t2[0]).$isExpressionStatement;
        } else
          t2 = false;
        if (t2) {
          t2 = t1._first;
          if (t2 == null)
            H.throwExpression(P.StateError$("No elements"));
          $name = t2._element;
          t2 = this.currentContainer.statements;
          if (0 >= t2.length)
            return H.ioore(t2, 0);
          statement = t2[0];
          if (!!J.getInterceptor(statement.get$expression()).$isAssignment) {
            assignment = statement.get$expression();
            if (assignment.get$op() == null && !!J.getInterceptor(assignment.get$leftHandSide()).$isVariableReference) {
              variableReference = assignment.get$leftHandSide();
              t2 = variableReference.get$name(variableReference);
              if (t2 == null ? $name == null : t2 === $name) {
                t1 = assignment.value;
                t2 = this.currentContainer.statements;
                if (0 >= t2.length)
                  return H.ioore(t2, 0);
                t2[0] = new Q.ExpressionStatement(new Q.VariableDeclarationList([new Q.VariableInitialization(new Q.VariableDeclaration($name, null, null), null, t1, null, null)], null, null), null, null);
                return;
              }
            }
          }
        }
        declarations = H.setRuntimeTypeInfo([], [Q.VariableInitialization]);
        t1.forEach$1(0, new B.SsaCodeGenerator_handleDelayedVariableDeclarations_closure(declarations));
        C.JSArray_methods.insert$2(this.currentContainer.statements, 0, new Q.ExpressionStatement(new Q.VariableDeclarationList(declarations, null, null), null, null));
      }
    },
    visitGraph$1: function(graph) {
      var t1, t2, t3, t4, t5, t6, t7;
      t1 = this.backend.compiler;
      t2 = new B.SsaInstructionSelection(t1, null, null);
      t2.graph = graph;
      t2.visitDominatorTree$1(graph);
      new B.SsaTypeKnownRemover(null).visitDominatorTree$1(graph);
      t2 = this.generateAtUseSite;
      new B.SsaInstructionMerger(t1, null, null, t2, null).visitDominatorTree$1(graph);
      t3 = this.controlFlowOperators;
      new B.SsaConditionMerger(t2, t3).visitPostDominatorTree$1(graph);
      t4 = P.LinkedHashMap_LinkedHashMap(null, null, null, B.HBasicBlock, B.LiveEnvironment);
      t5 = P.LinkedHashMap_LinkedHashMap(null, null, null, B.HInstruction, B.LiveInterval);
      new B.SsaLiveIntervalBuilder(t1, t2, t3, 0, t4, t5, null).visitPostDominatorTree$1(graph);
      if (J.get$isEmpty$asx(t4.$index(0, graph.entry)) !== true)
        t1.internalError$2(C._SpannableSentinel_0, "LiveIntervalBuilder.");
      t3 = P.LinkedHashMap_LinkedHashMap(null, null, null, B.HInstruction, P.String);
      t6 = P.LinkedHashMap_LinkedHashMap(null, null, null, B.HBasicBlock, B.CopyHandler);
      t7 = P.LinkedHashSet_LinkedHashSet(null, null, null, P.String);
      t6 = new B.VariableNames(t3, t6, t7, "t0");
      new B.SsaVariableAllocator(t1, t4, t5, t2, t6, null).visitDominatorTree$1(graph);
      this.variableNames = t6;
      this.shouldGroupVarDeclarations = t7._collection$_length > 1;
      this.currentGraph = graph;
      t7 = graph.entry;
      this.subGraph = new B.SubGraph(t7, graph.exit);
      this.visitBasicBlock$1(t7);
      this.handleDelayedVariableDeclarations$0();
    },
    visitSubGraph$1: function(newSubGraph) {
      var oldSubGraph = this.subGraph;
      this.subGraph = newSubGraph;
      this.visitBasicBlock$1(newSubGraph.start);
      this.subGraph = oldSubGraph;
    },
    expressionType$1: function(info) {
      var limits, basicBlock, t1, result, t2, current, t3;
      limits = info.subExpression;
      basicBlock = limits.start;
      t1 = this.generateAtUseSite;
      result = 2;
      do {
        t2 = J.getInterceptor$ax(basicBlock);
        current = t2.get$first(basicBlock);
        for (; t3 = J.getInterceptor(current), !t3.$eq(current, t2.get$last(basicBlock));) {
          if (current.isControlFlow$0())
            return 0;
          if (current.usedBy.length === 0)
            result = 1;
          current = current.next;
        }
        if (!!t3.$isHGoto) {
          t2 = basicBlock.get$successors();
          if (0 >= t2.length)
            return H.ioore(t2, 0);
          basicBlock = t2[0];
        } else if (!!t3.$isHConditionalBranch)
          if (t1.contains$1(0, current)) {
            t2 = basicBlock.get$successors();
            if (0 >= t2.length)
              return H.ioore(t2, 0);
            basicBlock = t2[0];
          } else
            return basicBlock === limits.end ? result : 0;
        else
          return 0;
      } while (limits.contains$1(0, basicBlock));
      return result;
    },
    generateStatements$1: function(block) {
      var t1, oldSubGraph;
      if (!!J.getInterceptor(block).$isHStatementInformation)
        this.visitSubGraphInfo$1(block);
      else {
        t1 = block.get$subExpression();
        oldSubGraph = this.subGraph;
        this.subGraph = t1;
        this.visitBasicBlock$1(t1.start);
        this.subGraph = oldSubGraph;
      }
    },
    generateStatementsInNewBlock$1: function(block) {
      var result, oldContainer;
      result = new Q.Block(H.setRuntimeTypeInfo([], [Q.Statement]), null, null);
      oldContainer = this.currentContainer;
      this.currentContainer = result;
      this.generateStatements$1(block);
      this.currentContainer = oldContainer;
      return result;
    },
    unwrapStatement$1: function(block) {
      var t1, len, result;
      t1 = block.statements;
      len = t1.length;
      if (len === 0)
        return new Q.EmptyStatement(null, null);
      if (len === 1) {
        if (0 >= len)
          return H.ioore(t1, 0);
        result = t1[0];
        if (!!J.getInterceptor(result).$isBlock0)
          return this.unwrapStatement$1(result);
        return result;
      }
      return block;
    },
    generateExpression$1: function(expression) {
      var oldIsGeneratingExpression, oldExpressionStack, sequenceElements, t1, result;
      oldIsGeneratingExpression = this.isGeneratingExpression;
      this.isGeneratingExpression = true;
      oldExpressionStack = this.expressionStack;
      sequenceElements = H.setRuntimeTypeInfo([], [Q.Expression]);
      this.expressionStack = sequenceElements;
      this.visitSubGraph$1(expression.subExpression);
      this.expressionStack = oldExpressionStack;
      this.isGeneratingExpression = oldIsGeneratingExpression;
      t1 = sequenceElements.length;
      if (t1 === 0)
        return;
      else if (t1 === 1) {
        if (0 >= t1)
          return H.ioore(sequenceElements, 0);
        return sequenceElements[0];
      } else {
        if (0 >= t1)
          return H.ioore(sequenceElements, 0);
        result = sequenceElements.pop();
        for (; t1 = sequenceElements.length, t1 !== 0;) {
          if (0 >= t1)
            return H.ioore(sequenceElements, 0);
          result = new Q.Binary(",", sequenceElements.pop(), result, null, null);
        }
        return result;
      }
    },
    visitArguments$2$start: function(inputs, start) {
      var t1, result, i, t2, t3;
      t1 = Array(inputs.length - start);
      t1.fixed$length = init;
      result = H.setRuntimeTypeInfo(t1, [Q.Expression]);
      for (t1 = result.length, i = start; i < inputs.length; ++i) {
        this.use$1(inputs[i]);
        t2 = i - start;
        t3 = this.expressionStack;
        if (0 >= t3.length)
          return H.ioore(t3, 0);
        t3 = t3.pop();
        if (t2 < 0 || t2 >= t1)
          return H.ioore(result, t2);
        result[t2] = t3;
      }
      return result;
    },
    visitArguments$1: function(inputs) {
      return this.visitArguments$2$start(inputs, 1);
    },
    generateExpressionAssignment$2: function(variableName, value) {
      var op, t1, t2, t3, t4;
      if (!!J.getInterceptor(value).$isBinary) {
        op = value.op;
        t1 = op === "+";
        t2 = !t1;
        if (!t2 || op === "-" || op === "/" || op === "*" || op === "%" || op === "^" || op === "&" || op === "|") {
          t3 = value.left;
          if (!!J.getInterceptor(t3).$isVariableUse) {
            t4 = H.interceptedTypeCast(t3, "$isVariableUse").name;
            t4 = t4 == null ? variableName == null : t4 === variableName;
          } else
            t4 = false;
          if (t4) {
            if (!t2 || op === "-") {
              t2 = value.right;
              t2 = !!J.getInterceptor(t2).$isLiteralNumber && H.interceptedTypeCast(t2, "$isLiteralNumber").value === "1";
            } else
              t2 = false;
            if (t2) {
              t1 = t1 ? "++" : "--";
              return new Q.Prefix(t1, t3, null, null);
            }
            return new Q.Assignment(t3, op, value.right, null, null);
          }
        }
      }
      return new Q.Assignment(new Q.VariableUse(variableName, null, null), null, value, null, null);
    },
    assignVariable$2: function(variableName, value) {
      var t1;
      if (this.isGeneratingExpression) {
        if (!(this.declaredLocals.contains$1(0, variableName) || this.collectedVariableDeclarations.contains$1(0, variableName)))
          this.collectedVariableDeclarations.add$1(0, variableName);
        t1 = this.generateExpressionAssignment$2(variableName, value);
        this.expressionStack.push(t1);
      } else if (!this.shouldGroupVarDeclarations && !this.declaredLocals.contains$1(0, variableName)) {
        this.collectedVariableDeclarations.remove$1(0, variableName);
        this.declaredLocals.add$1(0, variableName);
        t1 = [new Q.VariableInitialization(new Q.VariableDeclaration(variableName, null, null), null, value, null, null)];
        t1.$builtinTypeInfo = [Q.VariableInitialization];
        this.currentContainer.statements.push(new Q.ExpressionStatement(new Q.VariableDeclarationList(t1, null, null), null, null));
      } else {
        if (!this.declaredLocals.contains$1(0, variableName))
          this.collectedVariableDeclarations.add$1(0, variableName);
        t1 = this.generateExpressionAssignment$2(variableName, value);
        this.currentContainer.statements.push(new Q.ExpressionStatement(t1, null, null));
      }
    },
    define$1: function(instruction) {
      var t1, t2, t3, inputName, needsAssignment, oldIsGeneratingExpression;
      t1 = J.getInterceptor(instruction);
      if (!!t1.$isHTypeConversion) {
        t2 = this.variableNames;
        t3 = instruction.inputs;
        if (0 >= t3.length)
          return H.ioore(t3, 0);
        t3 = t3[0];
        inputName = t2.ownName.$index(0, t3);
        needsAssignment = !J.$eq(this.variableNames.ownName.$index(0, instruction), inputName) || false;
      } else
        needsAssignment = true;
      if ((!!t1.$isHLocalValue ? false : needsAssignment) && !instruction.isControlFlow$0() && this.variableNames.ownName.containsKey$1(instruction)) {
        oldIsGeneratingExpression = this.isGeneratingExpression;
        this.isGeneratingExpression = true;
        t1.accept$1(instruction, this);
        this.isGeneratingExpression = oldIsGeneratingExpression;
        t1 = this.variableNames.ownName.$index(0, instruction);
        t2 = this.expressionStack;
        if (0 >= t2.length)
          return H.ioore(t2, 0);
        this.assignVariable$2(t1, t2.pop());
        return;
      }
      if (this.isGeneratingExpression) {
        this.isGeneratingExpression = true;
        t1.accept$1(instruction, this);
        this.isGeneratingExpression = true;
      } else {
        t1.accept$1(instruction, this);
        t1 = this.expressionStack;
        t2 = t1.length;
        if (t2 !== 0) {
          if (0 >= t2)
            return H.ioore(t1, 0);
          t1 = t1.pop();
          this.currentContainer.statements.push(new Q.ExpressionStatement(t1, null, null));
        }
      }
    },
    use$1: function(argument) {
      var oldIsGeneratingExpression, t1;
      if (this.generateAtUseSite.contains$1(0, argument)) {
        oldIsGeneratingExpression = this.isGeneratingExpression;
        this.isGeneratingExpression = true;
        J.accept$1$x(argument, this);
        this.isGeneratingExpression = oldIsGeneratingExpression;
      } else if (!!J.getInterceptor(argument).$isHCheck && !this.variableNames.ownName.containsKey$1(argument)) {
        t1 = argument.get$inputs();
        if (0 >= t1.length)
          return H.ioore(t1, 0);
        this.use$1(t1[0]);
      } else {
        t1 = this.variableNames.ownName.$index(0, argument);
        this.expressionStack.push(new Q.VariableUse(t1, null, null));
      }
    },
    continueAsBreak$1: [function(target) {
      var t1 = "c$" + H.S(target.get$labelName()) + "$" + target.get$target(target).nestingLevel;
      this.currentContainer.statements.push(new Q.Break(t1, null, null));
    }, "call$1", "get$continueAsBreak", 2, 0, 277],
    implicitContinueAsBreak$1: [function(target) {
      this.pushStatement$1(new Q.Break("c$" + target.get$nestingLevel(), null, null));
    }, "call$1", "get$implicitContinueAsBreak", 2, 0, 278],
    implicitBreakWithLabel$1: [function(target) {
      this.pushStatement$1(new Q.Break("$" + target.get$nestingLevel(), null, null));
    }, "call$1", "get$implicitBreakWithLabel", 2, 0, 278],
    wrapIntoLabels$2: function(result, labels) {
      var t1, label;
      for (t1 = H.setRuntimeTypeInfo(new H.ListIterator(labels, labels.length, 0, null), [H.getTypeArgumentByIndex(labels, 0)]); t1.moveNext$0();) {
        label = t1.__internal$_current;
        if (label.get$isTarget())
          result = new Q.LabeledStatement2("$" + H.S(label.get$labelName()) + "$" + label.target.nestingLevel, result, null, null);
      }
      return result;
    },
    visitIfInfo$1: function(info) {
      return false;
    },
    visitSwitchInfo$1: function(info) {
      var t1, t2, key, cases, switchInstruction, inputs, successors, oldContainer, inputIndex, statementIndex, successor, expression, oldSubGraph;
      t1 = info.expression;
      t2 = this.expressionType$1(t1) === 0;
      if (t2)
        this.generateStatements$1(t1);
      if (!t2)
        this.push$1(this.generateExpression$1(t1));
      else
        this.use$1(t1.subExpression.get$conditionExpression());
      t2 = this.expressionStack;
      if (0 >= t2.length)
        return H.ioore(t2, 0);
      key = t2.pop();
      cases = H.setRuntimeTypeInfo([], [Q.SwitchClause]);
      switchInstruction = t1.subExpression.end.last;
      inputs = switchInstruction.inputs;
      successors = switchInstruction.block.successors;
      oldContainer = this.currentContainer;
      for (t1 = info.statements, inputIndex = 1, statementIndex = 0; inputIndex < inputs.length; ++statementIndex) {
        t2 = inputIndex - 1;
        if (t2 < 0 || t2 >= successors.length)
          return H.ioore(successors, t2);
        successor = successors[t2];
        if (successor.get$isLive()) {
          do {
            if (inputIndex < 0 || inputIndex >= inputs.length)
              return H.ioore(inputs, inputIndex);
            J.accept$1$x(inputs[inputIndex], this);
            t2 = [];
            t2.$builtinTypeInfo = [Q.Statement];
            this.currentContainer = new Q.Block(t2, null, null);
            t2 = this.expressionStack;
            if (0 >= t2.length)
              return H.ioore(t2, 0);
            cases.push(new Q.Case(t2.pop(), this.currentContainer, null, null));
            ++inputIndex;
            t2 = inputIndex - 1;
            if (t2 >= successors.length)
              return H.ioore(successors, t2);
          } while (J.$eq(successors[t2], successor) && inputIndex < inputs.length);
          if (statementIndex >= t1.length)
            return H.ioore(t1, statementIndex);
          expression = t1[statementIndex];
          if (!!expression.$isHStatementInformation)
            this.visitSubGraphInfo$1(expression);
          else {
            t2 = expression.get$subExpression();
            oldSubGraph = this.subGraph;
            this.subGraph = t2;
            this.visitBasicBlock$1(t2.start);
            this.subGraph = oldSubGraph;
          }
        } else
          while (true) {
            t2 = inputIndex - 1;
            if (t2 < 0 || t2 >= successors.length)
              return H.ioore(successors, t2);
            if (!(J.$eq(successors[t2], successor) && inputIndex < inputs.length))
              break;
            ++inputIndex;
          }
      }
      t2 = C.JSArray_methods.get$last(t1);
      if (t2.get$start(t2).isLive) {
        this.currentContainer = new Q.Block(H.setRuntimeTypeInfo([], [Q.Statement]), null, null);
        this.generateStatements$1(C.JSArray_methods.get$last(t1));
        t1 = this.currentContainer;
        if (t1.statements.length !== 0)
          cases.push(new Q.Default(t1, null, null));
      }
      this.currentContainer = oldContainer;
      this.pushStatement$1(this.wrapIntoLabels$2(new Q.Switch(key, cases, null, null), info.labels));
      return true;
    },
    visitSubGraphInfo$1: function(info) {
      this.visitSubGraph$1(info.subGraph);
      return true;
    },
    visitSubExpressionInfo$1: function(info) {
      return false;
    },
    visitTryInfo$1: function(info) {
      var body, t1, t2, t3, catchPart, finallyPart;
      body = this.generateStatementsInNewBlock$1(info.body);
      t1 = info.catchBlock;
      if (t1 != null) {
        t2 = new B.SsaCodeGenerator_visitTryInfo_register(this);
        t3 = this.backend;
        t2.call$1(t3.jsPlainJavaScriptObjectClass);
        t2.call$1(t3.jsUnknownJavaScriptObjectClass);
        catchPart = new Q.Catch(new Q.VariableDeclaration(this.variableNames.ownName.$index(0, info.catchVariable), null, null), this.generateStatementsInNewBlock$1(t1), null, null);
      } else
        catchPart = null;
      t1 = info.finallyBlock;
      finallyPart = t1 != null ? this.generateStatementsInNewBlock$1(t1) : null;
      this.pushStatement$1(new Q.Try(body, catchPart, finallyPart, null, null));
      return true;
    },
    visitBodyIgnoreLabels$1: function(info) {
      var t1, t2, oldInfo;
      t1 = info.body;
      t2 = t1.subGraph.start.blockFlow;
      if (t2 != null && !!t2.body.$isHLabeledBlockInformation) {
        oldInfo = this.currentBlockInformation;
        this.currentBlockInformation = t2.body;
        this.generateStatements$1(t1);
        this.currentBlockInformation = oldInfo;
      } else
        this.generateStatements$1(t1);
    },
    visitLoopInfo$1: function(info) {
      var t1, condition, limits, isConditionExpression, t2, initialization, oldContainer, t3, avoidContainer, t4, t5, delayedVariablesCount, jsInitialization, inits, assignment, id, jsCondition, jsUpdates, body, loop, jsBreak, exitLoop, exitAvoidContainer, hasExitPhiUpdates, avoidEdge, updateBody, t6, result;
      t1 = {};
      condition = info.condition;
      limits = condition.subExpression;
      isConditionExpression = this.expressionType$1(condition) !== 0 && !!J.getInterceptor(limits.end.last).$isHConditionalBranch;
      t2 = info.kind;
      switch (t2) {
        case 1:
        case 0:
        case 3:
        case 4:
          initialization = info.initializer;
          if (initialization != null)
            if (this.expressionType$1(initialization) === 0) {
              this.generateStatements$1(initialization);
              initialization = null;
            }
          oldContainer = this.currentContainer;
          t3 = H.setRuntimeTypeInfo([], [Q.Statement]);
          avoidContainer = new Q.Block(t3, null, null);
          this.currentContainer = avoidContainer;
          this.assignPhisOfSuccessors$1(C.JSArray_methods.get$last(limits.end.successors));
          t4 = t3.length === 0;
          this.currentContainer = oldContainer;
          if (isConditionExpression)
            if (t4) {
              t5 = info.updates;
              t5 = t5 != null && this.expressionType$1(t5) !== 0;
            } else
              t5 = false;
          else
            t5 = false;
          if (t5) {
            if (initialization != null) {
              t3 = this.collectedVariableDeclarations;
              delayedVariablesCount = t3._collection$_length;
              jsInitialization = this.generateExpression$1(initialization);
              if (!this.shouldGroupVarDeclarations && delayedVariablesCount < t3._collection$_length) {
                t1.assignments_0 = null;
                if (new B.SsaCodeGenerator_visitLoopInfo_allSimpleAssignments(t1).call$1(jsInitialization) === true) {
                  inits = H.setRuntimeTypeInfo([], [Q.VariableInitialization]);
                  for (t1 = t1.assignments_0, t1 = H.setRuntimeTypeInfo(new H.ListIterator(t1, t1.length, 0, null), [H.getTypeArgumentByIndex(t1, 0)]), t4 = this.declaredLocals; t1.moveNext$0();) {
                    assignment = t1.__internal$_current;
                    id = H.interceptedTypeCast(assignment.get$leftHandSide(), "$isVariableUse").name;
                    inits.push(new Q.VariableInitialization(new Q.VariableDeclaration(id, null, null), null, assignment.get$value(assignment), null, null));
                    t3.remove$1(0, id);
                    t4.add$1(0, id);
                  }
                  jsInitialization = new Q.VariableDeclarationList(inits, null, null);
                }
              }
            } else
              jsInitialization = null;
            jsCondition = this.generateExpression$1(condition);
            jsUpdates = this.generateExpression$1(info.updates);
            oldContainer = this.currentContainer;
            body = new Q.Block(H.setRuntimeTypeInfo([], [Q.Statement]), null, null);
            this.currentContainer = body;
            this.visitBodyIgnoreLabels$1(info);
            this.currentContainer = oldContainer;
            loop = new Q.For(jsInitialization, jsCondition, jsUpdates, this.unwrapStatement$1(body), null, null);
          } else {
            if (initialization != null)
              this.generateStatements$1(initialization);
            oldContainer = this.currentContainer;
            body = new Q.Block(H.setRuntimeTypeInfo([], [Q.Statement]), null, null);
            if (isConditionExpression && t4) {
              jsCondition = this.generateExpression$1(condition);
              this.currentContainer = body;
            } else {
              jsCondition = this.newLiteralBool$1(true);
              this.currentContainer = body;
              this.generateStatements$1(condition);
              this.use$1(limits.get$conditionExpression());
              t1 = this.expressionStack;
              if (0 >= t1.length)
                return H.ioore(t1, 0);
              t1 = t1.pop();
              jsBreak = new Q.Break(null, null, null);
              if (t3.length === 0)
                exitLoop = jsBreak;
              else {
                t3.push(jsBreak);
                exitLoop = avoidContainer;
              }
              this.pushStatement$1(new Q.If(new Q.Prefix("!", t1, null, null), exitLoop, new Q.EmptyStatement(null, null), null, null));
            }
            t1 = info.updates;
            if (t1 != null) {
              this.wrapLoopBodyForContinue$1(info);
              this.generateStatements$1(t1);
            } else
              this.visitBodyIgnoreLabels$1(info);
            this.currentContainer = oldContainer;
            loop = new Q.While1(jsCondition, this.unwrapStatement$1(body), null, null);
          }
          break;
        case 2:
          t1 = info.initializer;
          if (t1 != null)
            this.generateStatements$1(t1);
          oldContainer = this.currentContainer;
          t1 = H.setRuntimeTypeInfo([], [Q.Statement]);
          exitAvoidContainer = new Q.Block(t1, null, null);
          this.currentContainer = exitAvoidContainer;
          this.assignPhisOfSuccessors$1(C.JSArray_methods.get$last(limits.end.successors));
          hasExitPhiUpdates = t1.length !== 0;
          this.currentContainer = oldContainer;
          t3 = H.setRuntimeTypeInfo([], [Q.Statement]);
          body = new Q.Block(t3, null, null);
          t4 = info.get$end().successors;
          if (0 >= t4.length)
            return H.ioore(t4, 0);
          avoidEdge = t4[0];
          t4 = H.setRuntimeTypeInfo([], [Q.Statement]);
          updateBody = new Q.Block(t4, null, null);
          this.currentContainer = updateBody;
          this.assignPhisOfSuccessors$1(avoidEdge);
          t5 = t4.length;
          this.currentContainer = body;
          this.visitBodyIgnoreLabels$1(info);
          t6 = info.updates;
          if (t6 != null)
            this.generateStatements$1(t6);
          if (isConditionExpression)
            this.push$1(this.generateExpression$1(condition));
          else {
            this.generateStatements$1(condition);
            this.use$1(limits.get$conditionExpression());
          }
          t6 = this.expressionStack;
          if (0 >= t6.length)
            return H.ioore(t6, 0);
          jsCondition = t6.pop();
          if (jsCondition == null)
            loop = new Q.While1(this.newLiteralBool$1(true), this.unwrapStatement$1(body), null, null);
          else {
            if (t5 !== 0 || hasExitPhiUpdates) {
              t4.push(new Q.Continue(null, null, null));
              jsBreak = new Q.Break(null, null, null);
              if (t1.length === 0)
                exitLoop = jsBreak;
              else {
                t1.push(jsBreak);
                exitLoop = exitAvoidContainer;
              }
              t3.push(new Q.If(jsCondition, updateBody, exitLoop, null, null));
              jsCondition = this.newLiteralBool$1(true);
            }
            loop = new Q.Do(jsCondition, this.unwrapStatement$1(body), null, null);
          }
          this.currentContainer = oldContainer;
          break;
        default:
          this.backend.compiler.internalError$2(limits.get$conditionExpression(), "Unexpected loop kind: " + H.S(t2) + ".");
          loop = null;
      }
      result = Q.Node0.prototype.withPosition$2.call(loop, info.sourcePosition, info.endSourcePosition);
      if (t2 === 4)
        result = new Q.LabeledStatement2("c$" + info.target.get$nestingLevel(), result, null, null);
      this.pushStatement$1(this.wrapIntoLabels$2(result, info.labels));
      return true;
    },
    visitLabeledBlockInfo$1: function(labeledBlockInfo) {
      var oldContainer, body, t1, t2, t3, result, continueOverrides, label, target;
      oldContainer = this.currentContainer;
      body = new Q.Block(H.setRuntimeTypeInfo([], [Q.Statement]), null, null);
      this.currentContainer = body;
      t1 = labeledBlockInfo.isContinue;
      if (t1) {
        for (t2 = labeledBlockInfo.labels, t2 = H.setRuntimeTypeInfo(new H.ListIterator(t2, t2.length, 0, null), [H.getTypeArgumentByIndex(t2, 0)]), t3 = this.continueAction, result = body, continueOverrides = C.C_Link17; t2.moveNext$0();) {
          label = t2.__internal$_current;
          if (label.get$isContinueTarget()) {
            result = new Q.LabeledStatement2("c$" + H.S(label.get$labelName()) + "$" + label.target.nestingLevel, result, null, null);
            t3.$indexSet(0, label, this.get$continueAsBreak());
            continueOverrides = continueOverrides.prepend$1(label);
          }
        }
        target = labeledBlockInfo.target;
        result = new Q.LabeledStatement2("c$" + target.get$nestingLevel(), result, null, null);
        t3.$indexSet(0, target, this.get$implicitContinueAsBreak());
        continueOverrides = continueOverrides.prepend$1(target);
      } else {
        for (t2 = labeledBlockInfo.labels, t2 = H.setRuntimeTypeInfo(new H.ListIterator(t2, t2.length, 0, null), [H.getTypeArgumentByIndex(t2, 0)]), result = body; t2.moveNext$0();) {
          label = t2.__internal$_current;
          if (label.get$isBreakTarget())
            result = new Q.LabeledStatement2("$" + H.S(label.get$labelName()) + "$" + label.target.nestingLevel, result, null, null);
        }
        continueOverrides = C.C_Link17;
      }
      target = labeledBlockInfo.target;
      if (target.get$isSwitch()) {
        result = new Q.LabeledStatement2("$" + target.nestingLevel, result, null, null);
        this.breakAction.$indexSet(0, target, this.get$implicitBreakWithLabel());
      }
      this.currentContainer = body;
      this.generateStatements$1(labeledBlockInfo.body);
      if (t1)
        for (t1 = this.continueAction; !continueOverrides.get$isEmpty(continueOverrides);) {
          t1.remove$1(0, continueOverrides.get$head(continueOverrides));
          continueOverrides = continueOverrides.get$tail();
        }
      else
        this.breakAction.remove$1(0, target);
      this.currentContainer = oldContainer;
      this.pushStatement$1(result);
      return true;
    },
    wrapLoopBodyForContinue$1: function(info) {
      var target, oldContainer, body, t1, t2, t3, result, label, labelName;
      target = info.target;
      if (target != null && target.get$isContinueTarget()) {
        oldContainer = this.currentContainer;
        body = new Q.Block(H.setRuntimeTypeInfo([], [Q.Statement]), null, null);
        this.currentContainer = body;
        for (t1 = info.labels, t2 = H.setRuntimeTypeInfo(new H.ListIterator(t1, t1.length, 0, null), [H.getTypeArgumentByIndex(t1, 0)]), t3 = this.continueAction, result = body; t2.moveNext$0();) {
          label = t2.__internal$_current;
          if (label.get$isContinueTarget()) {
            result = new Q.LabeledStatement2("c$" + H.S(label.get$labelName()) + "$" + label.target.nestingLevel, result, null, null);
            t3.$indexSet(0, label, this.get$continueAsBreak());
          }
        }
        labelName = "c$" + target.get$nestingLevel();
        t3.$indexSet(0, target, this.get$implicitContinueAsBreak());
        this.visitBodyIgnoreLabels$1(info);
        t3.remove$1(0, target);
        for (t1 = H.setRuntimeTypeInfo(new H.ListIterator(t1, t1.length, 0, null), [H.getTypeArgumentByIndex(t1, 0)]); t1.moveNext$0();) {
          label = t1.__internal$_current;
          if (label.get$isContinueTarget())
            t3.remove$1(0, label);
        }
        this.currentContainer = oldContainer;
        this.pushStatement$1(new Q.LabeledStatement2(labelName, result, null, null));
      } else
        this.generateStatements$1(info.body);
    },
    handleBlockFlow$1: function(block) {
      var info, t1, success, continuation;
      info = block.body;
      t1 = this.currentBlockInformation;
      if (info === t1)
        return false;
      this.currentBlockInformation = info;
      success = info.accept$1(0, this);
      this.currentBlockInformation = t1;
      if (success) {
        continuation = block.continuation;
        if (continuation != null)
          this.visitBasicBlock$1(continuation);
      }
      return success;
    },
    visitBasicBlock$1: function(node) {
      var t1;
      if (!node.isLive)
        return;
      if (!this.subGraph.contains$1(0, node))
        return;
      t1 = node.blockFlow;
      if (t1 != null && this.handleBlockFlow$1(t1))
        return;
      this.iterateBasicBlock$1(node);
    },
    emitAssignment$2: [function(destination, source) {
      this.assignVariable$2(destination, new Q.VariableUse(source, null, null));
    }, "call$2", "get$emitAssignment", 4, 0, 279],
    sequentializeCopies$3: function(copies, tempName, doAssignment) {
      var currentLocation, initialValue, worklist, ready, prunedCopies, t1, copy, t2, t3, destination, source, current;
      currentLocation = P.LinkedHashMap_LinkedHashMap(null, null, null, P.String, P.String);
      initialValue = P.LinkedHashMap_LinkedHashMap(null, null, null, P.String, P.String);
      worklist = H.setRuntimeTypeInfo([], [P.String]);
      ready = H.setRuntimeTypeInfo([], [P.String]);
      prunedCopies = H.setRuntimeTypeInfo([], [B.Copy]);
      for (t1 = H.setRuntimeTypeInfo(new H.ListIterator(copies, copies.get$length(copies), 0, null), [H.getRuntimeTypeArgument(copies, "ListIterable", 0)]); t1.moveNext$0();) {
        copy = t1.__internal$_current;
        t2 = J.get$source$x(copy);
        t3 = copy.get$destination();
        if (t2 == null ? t3 != null : t2 !== t3)
          prunedCopies.push(copy);
      }
      for (t1 = H.setRuntimeTypeInfo(new H.ListIterator(prunedCopies, prunedCopies.length, 0, null), [H.getTypeArgumentByIndex(prunedCopies, 0)]); t1.moveNext$0();) {
        copy = t1.__internal$_current;
        t2 = J.getInterceptor$x(copy);
        currentLocation.$indexSet(0, t2.get$source(copy), t2.get$source(copy));
        initialValue.$indexSet(0, copy.get$destination(), copy.source);
        worklist.push(copy.destination);
      }
      for (t1 = H.setRuntimeTypeInfo(new H.ListIterator(prunedCopies, prunedCopies.length, 0, null), [H.getTypeArgumentByIndex(prunedCopies, 0)]); t1.moveNext$0();) {
        copy = t1.__internal$_current;
        if (currentLocation.$index(0, copy.get$destination()) == null)
          ready.push(copy.destination);
      }
      for (; worklist.length !== 0;) {
        for (; t1 = ready.length, t1 !== 0;) {
          if (0 >= t1)
            return H.ioore(ready, 0);
          destination = ready.pop();
          source = initialValue.$index(0, destination);
          copy = currentLocation.$index(0, source);
          doAssignment.call$2(destination, copy);
          currentLocation.$indexSet(0, source, destination);
          if (J.$eq(source, copy) && initialValue.$index(0, source) != null)
            ready.push(source);
        }
        if (0 >= worklist.length)
          return H.ioore(worklist, 0);
        current = worklist.pop();
        if (currentLocation.$index(0, current) != null) {
          t1 = currentLocation.$index(0, initialValue.$index(0, current));
          t1 = current == null ? t1 != null : current !== t1;
        } else
          t1 = false;
        if (t1) {
          doAssignment.call$2(tempName, current);
          currentLocation.$indexSet(0, current, tempName);
          ready.push(current);
        }
      }
    },
    assignPhisOfSuccessors$1: function(node) {
      var handler, copies, t1, t2, copy, t3, $name;
      handler = this.variableNames.copyHandlers.$index(0, node);
      if (handler == null)
        return;
      copies = H.setRuntimeTypeInfo(new H.MappedListIterable(handler.get$copies(), new B.SsaCodeGenerator_assignPhisOfSuccessors_closure(this)), [null, null]);
      t1 = this.variableNames;
      t2 = t1.allUsedNames;
      t1 = t1.swapTemp;
      t2.add$1(0, t1);
      this.sequentializeCopies$3(copies, t1, this.get$emitAssignment());
      for (t1 = handler.assignments, t1 = H.setRuntimeTypeInfo(new H.ListIterator(t1, t1.length, 0, null), [H.getTypeArgumentByIndex(t1, 0)]); t1.moveNext$0();) {
        copy = t1.__internal$_current;
        t2 = this.variableNames;
        t3 = copy.get$destination();
        $name = t2.ownName.$index(0, t3);
        this.use$1(copy.source);
        t3 = this.expressionStack;
        if (0 >= t3.length)
          return H.ioore(t3, 0);
        this.assignVariable$2($name, t3.pop());
      }
    },
    iterateBasicBlock$1: function(node) {
      var instruction, t1, t2;
      instruction = node.first;
      for (t1 = this.generateAtUseSite; t2 = node.last, instruction == null ? t2 != null : instruction !== t2;) {
        if (!t1.contains$1(0, instruction))
          this.define$1(instruction);
        instruction = instruction.next;
      }
      this.assignPhisOfSuccessors$1(node);
      instruction.accept$1(0, this);
    },
    visitInvokeBinary$2: function(node, op) {
      var t1, t2, jsLeft;
      t1 = node.inputs;
      if (0 >= t1.length)
        return H.ioore(t1, 0);
      this.use$1(t1[0]);
      t2 = this.expressionStack;
      if (0 >= t2.length)
        return H.ioore(t2, 0);
      jsLeft = t2.pop();
      if (1 >= t1.length)
        return H.ioore(t1, 1);
      this.use$1(t1[1]);
      t1 = this.expressionStack;
      if (0 >= t1.length)
        return H.ioore(t1, 0);
      this.push$2(new Q.Binary(op, jsLeft, t1.pop(), null, null), node);
    },
    visitBitInvokeBinary$2: function(node, op) {
      var t1;
      this.visitInvokeBinary$2(node, op);
      if (op !== ">>>" && this.requiresUintConversion$1(node)) {
        t1 = this.expressionStack;
        if (0 >= t1.length)
          return H.ioore(t1, 0);
        this.push$2(new Q.Binary(">>>", t1.pop(), new Q.LiteralNumber("0", null, null), null, null), node);
      }
    },
    visitInvokeUnary$2: function(node, op) {
      var t1 = node.inputs;
      if (0 >= t1.length)
        return H.ioore(t1, 0);
      this.use$1(t1[0]);
      t1 = this.expressionStack;
      if (0 >= t1.length)
        return H.ioore(t1, 0);
      this.push$2(new Q.Prefix(op, t1.pop(), null, null), node);
    },
    emitIdentityComparison$2: function(instruction, inverse) {
      var op, t1, t2, left, right, jsLeft, t3, t4, t5, t6;
      op = instruction.singleComparisonOp;
      t1 = instruction.inputs;
      t2 = t1.length;
      if (0 >= t2)
        return H.ioore(t1, 0);
      left = t1[0];
      if (1 >= t2)
        return H.ioore(t1, 1);
      right = t1[1];
      if (op != null) {
        this.use$1(left);
        t1 = this.expressionStack;
        if (0 >= t1.length)
          return H.ioore(t1, 0);
        jsLeft = t1.pop();
        this.use$1(right);
        t1 = B.SsaCodeGenerator_mapRelationalOperator(op, inverse);
        t2 = this.expressionStack;
        if (0 >= t2.length)
          return H.ioore(t2, 0);
        this.push$1(new Q.Binary(t1, jsLeft, t2.pop(), null, null));
      } else {
        this.use$1(left);
        t1 = this.expressionStack;
        if (0 >= t1.length)
          return H.ioore(t1, 0);
        t1 = t1.pop();
        this.use$1(right);
        t2 = B.SsaCodeGenerator_mapRelationalOperator("==", inverse);
        t3 = this.expressionStack;
        if (0 >= t3.length)
          return H.ioore(t3, 0);
        t3 = t3.pop();
        this.use$1(right);
        this.use$1(left);
        t4 = B.SsaCodeGenerator_mapRelationalOperator("===", inverse);
        t5 = this.expressionStack;
        if (0 >= t5.length)
          return H.ioore(t5, 0);
        t5 = t5.pop();
        t6 = this.expressionStack;
        if (0 >= t6.length)
          return H.ioore(t6, 0);
        this.push$1(new Q.Conditional(new Q.Binary("==", t1, new Q.LiteralNull(null, null), null, null), new Q.Binary(t2, t3, new Q.LiteralNull(null, null), null, null), new Q.Binary(t4, t5, t6.pop(), null, null), null, null));
      }
    },
    visitIdentity$1: function(node) {
      this.emitIdentityComparison$2(node, false);
    },
    visitAdd$1: function(node) {
      return this.visitInvokeBinary$2(node, "+");
    },
    visitDivide$1: function(node) {
      return this.visitInvokeBinary$2(node, "/");
    },
    visitMultiply$1: function(node) {
      return this.visitInvokeBinary$2(node, "*");
    },
    visitSubtract$1: function(node) {
      return this.visitInvokeBinary$2(node, "-");
    },
    visitBitAnd$1: function(node) {
      return this.visitBitInvokeBinary$2(node, "&");
    },
    visitBitNot$1: function(node) {
      var t1;
      this.visitInvokeUnary$2(node, "~");
      if (this.requiresUintConversion$1(node)) {
        t1 = this.expressionStack;
        if (0 >= t1.length)
          return H.ioore(t1, 0);
        this.push$2(new Q.Binary(">>>", t1.pop(), new Q.LiteralNumber("0", null, null), null, null), node);
      }
      return;
    },
    visitBitOr$1: function(node) {
      return this.visitBitInvokeBinary$2(node, "|");
    },
    visitBitXor$1: function(node) {
      return this.visitBitInvokeBinary$2(node, "^");
    },
    visitShiftLeft$1: function(node) {
      return this.visitBitInvokeBinary$2(node, "<<");
    },
    visitShiftRight$1: function(node) {
      return this.visitBitInvokeBinary$2(node, ">>>");
    },
    visitTruncatingDivide$1: function(node) {
      var t1, t2, jsLeft;
      t1 = node.inputs;
      if (0 >= t1.length)
        return H.ioore(t1, 0);
      this.use$1(t1[0]);
      t2 = this.expressionStack;
      if (0 >= t2.length)
        return H.ioore(t2, 0);
      jsLeft = t2.pop();
      if (1 >= t1.length)
        return H.ioore(t1, 1);
      this.use$1(t1[1]);
      t1 = this.expressionStack;
      if (0 >= t1.length)
        return H.ioore(t1, 0);
      this.push$2(new Q.Binary("/", jsLeft, t1.pop(), null, null), node);
      t1 = this.expressionStack;
      if (0 >= t1.length)
        return H.ioore(t1, 0);
      this.push$2(new Q.Binary("|", t1.pop(), new Q.LiteralNumber("0", null, null), null, null), node);
    },
    visitNegate$1: function(node) {
      return this.visitInvokeUnary$2(node, "-");
    },
    visitLess$1: function(node) {
      return this.visitInvokeBinary$2(node, "<");
    },
    visitLessEqual$1: function(node) {
      return this.visitInvokeBinary$2(node, "<=");
    },
    visitGreater$1: function(node) {
      return this.visitInvokeBinary$2(node, ">");
    },
    visitGreaterEqual$1: function(node) {
      return this.visitInvokeBinary$2(node, ">=");
    },
    visitBoolify$1: function(node) {
      var t1 = node.inputs;
      if (0 >= t1.length)
        return H.ioore(t1, 0);
      this.use$1(t1[0]);
      t1 = this.expressionStack;
      if (0 >= t1.length)
        return H.ioore(t1, 0);
      this.push$2(new Q.Binary("===", t1.pop(), this.newLiteralBool$1(true), null, null), node);
    },
    visitExit$1: function(node) {
    },
    visitGoto$1: function(node) {
      var block, dominated, t1;
      block = node.block;
      dominated = block.dominatedBlocks;
      t1 = dominated.length;
      if (t1 === 0)
        return;
      if (t1 > 2)
        this.backend.compiler.internalError$2(node, "dominated.length = " + t1);
      if (dominated.length === 2) {
        t1 = this.currentGraph.entry;
        t1 = block == null ? t1 != null : block !== t1;
      } else
        t1 = false;
      if (t1)
        this.backend.compiler.internalError$2(node, "node.block != currentGraph.entry");
      if (0 >= dominated.length)
        return H.ioore(dominated, 0);
      this.visitBasicBlock$1(dominated[0]);
    },
    visitLoopBranch$1: function(node) {
      var t1;
      if (this.isGeneratingExpression) {
        t1 = node.inputs;
        if (0 >= t1.length)
          return H.ioore(t1, 0);
        this.use$1(t1[0]);
      }
    },
    tryCallAction$2: function(map, entity) {
      var action = map.$index(0, entity);
      if (action == null)
        return false;
      action.call$1(entity);
      return true;
    },
    visitBreak$1: function(node) {
      var t1, target;
      t1 = node.label;
      if (t1 != null) {
        if (!this.tryCallAction$2(this.breakAction, t1))
          this.pushStatement$2(new Q.Break("$" + H.S(t1.get$labelName()) + "$" + t1.target.nestingLevel, null, null), node);
      } else {
        target = node.target;
        if (!this.tryCallAction$2(this.breakAction, target))
          if (node.breakSwitchContinueLoop)
            this.pushStatement$2(new Q.Break("c$" + target.get$nestingLevel(), null, null), node);
          else
            this.pushStatement$2(new Q.Break(null, null, null), node);
      }
    },
    visitContinue$1: function(node) {
      var t1, target;
      t1 = node.label;
      if (t1 != null) {
        if (!this.tryCallAction$2(this.continueAction, t1))
          this.pushStatement$2(new Q.Continue("$" + H.S(t1.get$labelName()) + "$" + t1.target.nestingLevel, null, null), node);
      } else {
        target = node.target;
        if (!this.tryCallAction$2(this.continueAction, target))
          if (!!J.getInterceptor(target.get$statement()).$isSwitchStatement)
            this.pushStatement$2(new Q.Continue("c$" + target.nestingLevel, null, null), node);
          else
            this.pushStatement$2(new Q.Continue(null, null, null), node);
      }
    },
    visitExitTry$1: function(node) {
      var t1 = node.block.successors;
      if (0 >= t1.length)
        return H.ioore(t1, 0);
      this.visitBasicBlock$1(t1[0]);
    },
    visitTry$1: function(node) {
      this.backend.compiler.internalError$2(node, "visitTry should not be called.");
    },
    tryControlFlowOperation$1: function(node) {
      var phi, t1, t2, t3, t4;
      if (!this.controlFlowOperators.contains$1(0, node))
        return false;
      phi = node.blockInformation.continuation.phis.first;
      t1 = !this.generateAtUseSite.contains$1(0, phi);
      if (t1) {
        t2 = this.variableNames.ownName.$index(0, phi);
        t3 = this.variableNames;
        t4 = phi.inputs;
        if (1 >= t4.length)
          return H.ioore(t4, 1);
        t4 = t4[1];
        t4 = J.$eq(t2, t3.ownName.$index(0, t4));
        t2 = t4;
      } else
        t2 = false;
      if (t2)
        return false;
      if (t1)
        this.define$1(phi);
      this.visitBasicBlock$1(node.blockInformation.continuation);
      return true;
    },
    visitIf$1: function(node) {
      var t1, condition, info, joinBlock, t2, dominated, i;
      if (this.tryControlFlowOperation$1(node))
        return;
      t1 = node.inputs;
      if (0 >= t1.length)
        return H.ioore(t1, 0);
      condition = t1[0];
      info = node.blockInformation.body;
      if (condition.isConstant$0())
        if (condition.get$constant().get$isTrue())
          this.generateStatements$1(info.get$thenGraph());
        else
          this.generateStatements$1(info.get$elseGraph());
      else {
        if (0 >= t1.length)
          return H.ioore(t1, 0);
        this.use$1(t1[0]);
        t1 = this.expressionStack;
        if (0 >= t1.length)
          return H.ioore(t1, 0);
        this.pushStatement$2(new Q.If(t1.pop(), this.unwrapStatement$1(this.generateStatementsInNewBlock$1(info.get$thenGraph())), this.unwrapStatement$1(this.generateStatementsInNewBlock$1(info.elseGraph)), null, null), node);
      }
      joinBlock = node.blockInformation.continuation;
      if (joinBlock != null) {
        t1 = joinBlock.dominator;
        t2 = node.block;
        t2 = t1 == null ? t2 != null : t1 !== t2;
        t1 = t2;
      } else
        t1 = false;
      if (t1)
        this.visitBasicBlock$1(joinBlock);
      dominated = node.block.dominatedBlocks;
      for (i = 2; i < dominated.length; ++i)
        this.visitBasicBlock$1(dominated[i]);
    },
    visitInterceptor$1: function(node) {
      var t1, t2, t3, $name, $arguments;
      t1 = this.work;
      t2 = t1.registry;
      t3 = node.interceptedClasses;
      t2.compiler.backend.registerSpecializedGetInterceptor$1(t3);
      t3 = this.backend;
      t2 = t3.namer;
      $name = t2.getInterceptorName$2(t3.getInterceptorMethod, node.interceptedClasses);
      t3 = t2.globalObjectFor$1(t3.interceptorsLibrary);
      t2 = node.inputs;
      if (0 >= t2.length)
        return H.ioore(t2, 0);
      this.use$1(t2[0]);
      t2 = this.expressionStack;
      if (0 >= t2.length)
        return H.ioore(t2, 0);
      $arguments = H.setRuntimeTypeInfo([t2.pop()], [Q.Expression]);
      this.push$2(new Q.Call(new Q.PropertyAccess(new Q.VariableUse(t3, null, null), new Q.LiteralString0("\"" + H.S($name) + "\"", null, null), null, null), $arguments, null, null), node);
      t1 = t1.registry.compiler;
      t1.backend.registerUseInterceptor$1(t1.enqueuer.codegen);
    },
    visitInvokeDynamicMethod$1: function(node) {
      var t1, t2, object, $arguments, target, methodName, t3;
      t1 = node.inputs;
      if (0 >= t1.length)
        return H.ioore(t1, 0);
      this.use$1(t1[0]);
      t2 = this.expressionStack;
      if (0 >= t2.length)
        return H.ioore(t2, 0);
      object = t2.pop();
      node.selector.name;
      $arguments = this.visitArguments$1(t1);
      target = node.element;
      if (target != null && !node.get$isInterceptedCall()) {
        t1 = this.backend;
        t2 = t1.jsArrayAdd;
        if (target == null ? t2 == null : target === t2)
          methodName = "push";
        else {
          t2 = t1.jsArrayRemoveLast;
          if (target == null ? t2 == null : target === t2)
            methodName = "pop";
          else {
            t2 = t1.jsStringSplit;
            if (target == null ? t2 == null : target === t2) {
              t2 = this.work.registry;
              t1 = t1.compiler.listClass;
              t3 = t2.compiler.enqueuer.codegen;
              t1.ensureResolved$1(t3.compiler);
              t3.registerInstantiatedType$3$mirrorUsage(t1.get$rawType(), t2, false);
              methodName = "split";
            } else
              methodName = target.get$isNative() && target.get$isFunction() && !node.get$isInterceptedCall() ? target._fixedBackendName : null;
          }
        }
      } else
        methodName = null;
      if (methodName == null) {
        methodName = this.backend.namer.invocationName$1(node.selector);
        this.registerMethodInvoke$1(node);
      }
      this.push$2(new Q.Call(new Q.PropertyAccess(object, new Q.LiteralString0("\"" + H.S(methodName) + "\"", null, null), null, null), $arguments, null, null), node);
    },
    visitInvokeConstructorBody$1: function(node) {
      var t1, t2, object, methodName, $arguments;
      t1 = node.inputs;
      if (0 >= t1.length)
        return H.ioore(t1, 0);
      this.use$1(t1[0]);
      t2 = this.expressionStack;
      if (0 >= t2.length)
        return H.ioore(t2, 0);
      object = t2.pop();
      t2 = node.element;
      methodName = this.backend.namer.getNameX$1(t2);
      $arguments = this.visitArguments$1(t1);
      this.push$2(new Q.Call(new Q.PropertyAccess(object, new Q.LiteralString0("\"" + H.S(methodName) + "\"", null, null), null, null), $arguments, null, null), node);
      this.work.registry.compiler.enqueuer.codegen.registerStaticUse$1(t2);
    },
    visitOneShotInterceptor$1: function(node) {
      var $arguments, t1, t2, t3, selector, classes, $name;
      $arguments = this.visitArguments$1(node.inputs);
      t1 = this.backend;
      t2 = t1.namer;
      t3 = t2.globalObjectFor$1(t1.interceptorsLibrary);
      selector = this.getOptimizedSelectorFor$2(node, node.selector);
      classes = t1.getInterceptedClassesOn$1(selector.name);
      $name = t2.getOneShotInterceptorName$2(selector, classes);
      t2 = t1.oneShotInterceptors;
      if (!t2.containsKey$1($name)) {
        t1.registerSpecializedGetInterceptor$1(classes);
        t2.$indexSet(0, $name, selector);
      }
      this.push$2(new Q.Call(new Q.PropertyAccess(new Q.VariableUse(t3, null, null), new Q.LiteralString0("\"" + H.S($name) + "\"", null, null), null, null), $arguments, null, null), node);
      t1 = selector.kind;
      if (t1 === C.SelectorKind_getter_0)
        this.registerGetter$1(node);
      else if (t1 === C.SelectorKind_setter_1)
        this.registerSetter$1(node);
      else
        this.registerMethodInvoke$1(node);
      t1 = this.work.registry.compiler;
      t1.backend.registerUseInterceptor$1(t1.enqueuer.codegen);
    },
    getOptimizedSelectorFor$2: function(node, selector) {
      var t1 = node.element;
      if (t1 != null)
        return Z.TypedSelector_TypedSelector(new B.FlatTypeMask(t1.get$enclosingClass().get$declaration(), 2), selector, this.backend.compiler);
      return selector.extendIfReachesAll$1(this.backend.compiler);
    },
    registerMethodInvoke$1: function(node) {
      var selector, target, $call, t1, t2;
      selector = this.getOptimizedSelectorFor$2(node, node.selector);
      target = node.element;
      if (target == null || target.get$isGetter()) {
        $call = Z.Selector_Selector(C.SelectorKind_call_2, "call", null, selector.argumentCount, selector.namedArguments);
        t1 = this.work.registry;
        t2 = t1.compiler;
        t2.enqueuer.codegen.registerInvocation$1($call);
        t2.dumpInfoTask.elementUsesSelector$2(t1.treeElements.analyzedElement, $call);
      }
      t1 = this.work.registry;
      t2 = t1.compiler;
      t2.enqueuer.codegen.registerInvocation$1(selector);
      t2.dumpInfoTask.elementUsesSelector$2(t1.treeElements.analyzedElement, selector);
    },
    registerSetter$1: function(node) {
      var selector, t1, t2;
      selector = this.getOptimizedSelectorFor$2(node, node.selector);
      t1 = this.work.registry;
      t2 = t1.compiler;
      t2.enqueuer.codegen.registerInvokedSetter$1(selector);
      t2.dumpInfoTask.elementUsesSelector$2(t1.treeElements.analyzedElement, selector);
    },
    registerGetter$1: function(node) {
      var selector, t1, t2;
      selector = this.getOptimizedSelectorFor$2(node, node.selector);
      t1 = this.work.registry;
      t2 = t1.compiler;
      t2.enqueuer.codegen.registerInvokedGetter$1(selector);
      t2.dumpInfoTask.elementUsesSelector$2(t1.treeElements.analyzedElement, selector);
    },
    visitInvokeDynamicSetter$1: function(node) {
      var t1, $name, t2;
      t1 = node.inputs;
      if (0 >= t1.length)
        return H.ioore(t1, 0);
      this.use$1(t1[0]);
      $name = this.backend.namer.invocationName$1(node.selector);
      t2 = this.expressionStack;
      if (0 >= t2.length)
        return H.ioore(t2, 0);
      t2 = t2.pop();
      t1 = this.visitArguments$1(t1);
      this.push$2(new Q.Call(new Q.PropertyAccess(t2, new Q.LiteralString0("\"" + H.S($name) + "\"", null, null), null, null), t1, null, null), node);
      this.registerSetter$1(node);
    },
    visitInvokeDynamicGetter$1: function(node) {
      var t1, $name, t2;
      t1 = node.inputs;
      if (0 >= t1.length)
        return H.ioore(t1, 0);
      this.use$1(t1[0]);
      $name = this.backend.namer.invocationName$1(node.selector);
      t2 = this.expressionStack;
      if (0 >= t2.length)
        return H.ioore(t2, 0);
      t2 = t2.pop();
      t1 = this.visitArguments$1(t1);
      this.push$2(new Q.Call(new Q.PropertyAccess(t2, new Q.LiteralString0("\"" + H.S($name) + "\"", null, null), null, null), t1, null, null), node);
      this.registerGetter$1(node);
    },
    visitInvokeClosure$1: function(node) {
      var t1, $call, t2, t3;
      t1 = node.selector;
      $call = Z.Selector_Selector(C.SelectorKind_call_2, "call", null, t1.argumentCount, t1.namedArguments);
      t1 = node.inputs;
      if (0 >= t1.length)
        return H.ioore(t1, 0);
      this.use$1(t1[0]);
      t2 = this.expressionStack;
      if (0 >= t2.length)
        return H.ioore(t2, 0);
      t2 = t2.pop();
      t3 = this.backend.namer.invocationName$1($call);
      t1 = this.visitArguments$1(t1);
      this.push$2(new Q.Call(new Q.PropertyAccess(t2, new Q.LiteralString0("\"" + H.S(t3) + "\"", null, null), null, null), t1, null, null), node);
      t1 = this.work.registry;
      t3 = t1.compiler;
      t3.enqueuer.codegen.registerInvocation$1($call);
      t3.dumpInfoTask.elementUsesSelector$2(t1.treeElements.analyzedElement, $call);
    },
    visitInvokeStatic$1: function(node) {
      var element, instantiatedTypes, t1;
      element = node.element;
      element.get$enclosingClass();
      instantiatedTypes = node.instantiatedTypes;
      this.work.registry.compiler.enqueuer.codegen.registerStaticUse$1(element);
      if (instantiatedTypes != null && instantiatedTypes.length !== 0)
        H.IterableMixinWorkaround_forEach(instantiatedTypes, new B.SsaCodeGenerator_visitInvokeStatic_closure(this));
      this.push$1(this.backend.namer.elementAccess$1(element));
      t1 = this.expressionStack;
      if (0 >= t1.length)
        return H.ioore(t1, 0);
      this.push$2(new Q.Call(t1.pop(), this.visitArguments$2$start(node.inputs, 0), null, null), node);
    },
    visitInvokeSuper$1: function(node) {
      var superMethod, t1, superClass, fieldName, t2, access, selector, t3, t4, methodName;
      superMethod = node.element;
      t1 = this.work;
      t1.registry.compiler.enqueuer.codegen.registerStaticUse$1(superMethod);
      superClass = superMethod.get$enclosingClass();
      if (superMethod.kind === C.ElementKind_field_1) {
        fieldName = this.backend.namer.instanceFieldPropertyName$1(superMethod);
        t1 = node.inputs;
        if (0 >= t1.length)
          return H.ioore(t1, 0);
        this.use$1(t1[0]);
        t2 = this.expressionStack;
        if (0 >= t2.length)
          return H.ioore(t2, 0);
        access = new Q.PropertyAccess(t2.pop(), new Q.LiteralString0("\"" + H.S(fieldName) + "\"", null, null), null, null);
        if (node.isSetter) {
          this.use$1(J.get$last$ax(t1));
          t1 = this.expressionStack;
          if (0 >= t1.length)
            return H.ioore(t1, 0);
          this.push$2(new Q.Assignment(access, null, t1.pop(), null, null), node);
        } else
          this.push$2(access, node);
      } else {
        selector = node.selector;
        t2 = this.backend;
        if (selector.kind === C.SelectorKind_getter_0) {
          selector = Z.TypedSelector_TypedSelector(new B.FlatTypeMask(superClass, 2), selector, t2.compiler);
          t3 = t1.registry;
          t4 = t3.compiler;
          t4.enqueuer.codegen.registerInvokedGetter$1(selector);
          t4.dumpInfoTask.elementUsesSelector$2(t3.treeElements.analyzedElement, selector);
          t1.registry.compiler.enqueuer.codegen.universe.methodsNeedingSuperGetter.add$1(0, superMethod);
          t2 = t2.namer;
          methodName = t2.invocationName$1(selector);
          t1 = t2;
        } else {
          t1 = t2.namer;
          methodName = t1.getNameX$1(superMethod);
        }
        this.push$2(C.C_JsBuilder.call$2("#.prototype.#.call(#)", [t1.elementAccess$1(superClass), methodName, this.visitArguments$2$start(node.inputs, 0)]), node);
      }
    },
    visitFieldGet$1: function(node) {
      var t1, element, t2, $name;
      t1 = node.inputs;
      if (0 >= t1.length)
        return H.ioore(t1, 0);
      this.use$1(t1[0]);
      element = node.element;
      if (element == null) {
        t1 = this.expressionStack;
        if (0 >= t1.length)
          return H.ioore(t1, 0);
        this.push$2(new Q.PropertyAccess(t1.pop(), new Q.LiteralString0("\"toString\"", null, null), null, null), node);
      } else {
        t1 = this.backend;
        t2 = t1.jsIndexableLength;
        if (element == null ? t2 == null : element === t2) {
          t1 = this.expressionStack;
          if (0 >= t1.length)
            return H.ioore(t1, 0);
          this.push$2(new Q.PropertyAccess(t1.pop(), new Q.LiteralString0("\"length\"", null, null), null, null), node);
        } else {
          $name = t1.namer.instanceFieldPropertyName$1(element);
          t1 = this.expressionStack;
          if (0 >= t1.length)
            return H.ioore(t1, 0);
          this.push$2(new Q.PropertyAccess(t1.pop(), new Q.LiteralString0("\"" + H.S($name) + "\"", null, null), null, null), node);
          this.work.registry.compiler.enqueuer.codegen.universe.fieldGetters.add$1(0, element);
        }
      }
    },
    visitFieldSet$1: function(node) {
      var element, $name, t1, t2, receiver;
      element = node.element;
      this.work.registry.compiler.enqueuer.codegen.universe.fieldSetters.add$1(0, element);
      $name = this.backend.namer.instanceFieldPropertyName$1(element);
      t1 = node.inputs;
      if (0 >= t1.length)
        return H.ioore(t1, 0);
      this.use$1(t1[0]);
      t2 = this.expressionStack;
      if (0 >= t2.length)
        return H.ioore(t2, 0);
      receiver = t2.pop();
      if (1 >= t1.length)
        return H.ioore(t1, 1);
      this.use$1(t1[1]);
      t1 = "\"" + H.S($name) + "\"";
      t2 = this.expressionStack;
      if (0 >= t2.length)
        return H.ioore(t2, 0);
      this.push$2(new Q.Assignment(new Q.PropertyAccess(receiver, new Q.LiteralString0(t1, null, null), null, null), null, t2.pop(), null, null), node);
    },
    visitReadModifyWrite$1: function(node) {
      var element, $name, t1, t2, fieldReference, t3;
      element = node.element;
      this.work.registry.compiler.enqueuer.codegen.universe.fieldSetters.add$1(0, element);
      $name = this.backend.namer.instanceFieldPropertyName$1(element);
      t1 = node.inputs;
      if (0 >= t1.length)
        return H.ioore(t1, 0);
      this.use$1(t1[0]);
      t2 = this.expressionStack;
      if (0 >= t2.length)
        return H.ioore(t2, 0);
      fieldReference = new Q.PropertyAccess(t2.pop(), new Q.LiteralString0("\"" + H.S($name) + "\"", null, null), null, null);
      t2 = node.opKind;
      if (t2 === 1)
        this.push$2(new Q.Prefix(node.jsOp, fieldReference, null, null), node);
      else {
        t3 = node.jsOp;
        if (t2 === 2)
          this.push$2(new Q.Postfix(t3, fieldReference, null, null), node);
        else {
          if (1 >= t1.length)
            return H.ioore(t1, 1);
          this.use$1(t1[1]);
          t1 = this.expressionStack;
          if (0 >= t1.length)
            return H.ioore(t1, 0);
          this.push$2(new Q.Assignment(fieldReference, t3, t1.pop(), null, null), node);
        }
      }
    },
    visitLocalGet$1: function(node) {
      var t1 = node.inputs;
      if (0 >= t1.length)
        return H.ioore(t1, 0);
      this.use$1(t1[0]);
    },
    visitLocalSet$1: function(node) {
      var t1, t2;
      t1 = node.inputs;
      if (1 >= t1.length)
        return H.ioore(t1, 1);
      this.use$1(t1[1]);
      t2 = this.variableNames;
      if (0 >= t1.length)
        return H.ioore(t1, 0);
      t1 = t1[0];
      t1 = t2.ownName.$index(0, t1);
      t2 = this.expressionStack;
      if (0 >= t2.length)
        return H.ioore(t2, 0);
      this.assignVariable$2(t1, t2.pop());
    },
    registerForeignTypes$1: function(node) {
      var nativeBehavior = node.nativeBehavior;
      if (nativeBehavior == null)
        return;
      H.IterableMixinWorkaround_forEach(nativeBehavior.typesReturned, new B.SsaCodeGenerator_registerForeignTypes_closure(this));
    },
    visitForeign$1: function(node) {
      var inputs, interpolatedExpressions, i, t1;
      inputs = node.inputs;
      if (node.isStatement) {
        interpolatedExpressions = H.setRuntimeTypeInfo([], [Q.Expression]);
        for (i = 0; i < inputs.length; ++i) {
          this.use$1(inputs[i]);
          t1 = this.expressionStack;
          if (0 >= t1.length)
            return H.ioore(t1, 0);
          interpolatedExpressions.push(t1.pop());
        }
        this.pushStatement$1(node.codeTemplate.instantiate$1(interpolatedExpressions));
      } else {
        interpolatedExpressions = H.setRuntimeTypeInfo([], [Q.Expression]);
        for (i = 0; i < inputs.length; ++i) {
          this.use$1(inputs[i]);
          t1 = this.expressionStack;
          if (0 >= t1.length)
            return H.ioore(t1, 0);
          interpolatedExpressions.push(t1.pop());
        }
        this.push$1(node.codeTemplate.instantiate$1(interpolatedExpressions));
      }
      this.registerForeignTypes$1(node);
    },
    visitForeignNew$1: function(node) {
      var t1;
      this.push$2(new Q.New(this.backend.namer.elementAccess$1(node.element), this.visitArguments$2$start(node.inputs, 0), null, null), node);
      this.registerForeignTypes$1(node);
      t1 = node.instantiatedTypes;
      if (t1 == null)
        return;
      t1.toString;
      H.IterableMixinWorkaround_forEach(t1, new B.SsaCodeGenerator_visitForeignNew_closure(this));
    },
    newLiteralBool$1: function(value) {
      var t1;
      if (this.backend.compiler.enableMinification) {
        t1 = value ? "0" : "1";
        return new Q.Prefix("!", new Q.LiteralNumber(t1, null, null), null, null);
      } else
        return new Q.LiteralBool(value, null, null);
    },
    visitConstant$1: function(node) {
      var $function, t1, t2, element, t3;
      $function = node.constant;
      if ($function.get$isFunction()) {
        t1 = this.work.registry;
        t2 = $function.get$element();
        t1.compiler.enqueuer.codegen.registerStaticUse$1(t2);
      }
      if ($function.get$isType()) {
        element = $function.get$representedType().get$element();
        if (element != null && element.kind === C.ElementKind_class_4) {
          t1 = this.work.registry.compiler;
          t2 = t1.backend.get$customElementsAnalysis();
          t1.enqueuer.codegen;
          t2.codegenJoin.selectedClasses.add$1(0, element);
        }
      }
      t1 = this.backend;
      t2 = t1.emitter.constantEmitter._referenceEmitter;
      t2.toString;
      this.push$1($function.accept$1(0, t2));
      t2 = this.work.registry;
      t3 = t2.compiler;
      t3.backend.registerCompileTimeConstant$2($function, t2);
      t3.backend.get$constantCompilerTask().jsConstantCompiler.compiledConstants.add$1(0, $function);
      t1.constantCompilerTask.jsConstantCompiler.compiledConstants.add$1(0, $function);
    },
    visitNot$1: function(node) {
      var t1 = node.inputs;
      if (0 >= t1.length)
        return H.ioore(t1, 0);
      this.generateNot$1(t1[0]);
      this.attachLocationToLast$1(node);
    },
    generateNot$1: function(input) {
      var t1, handledBySpecialCase, operation;
      if (this.generateAtUseSite.contains$1(0, input)) {
        t1 = J.getInterceptor(input);
        if (!!t1.$isHIs) {
          this.emitIs$2(input, "!==");
          handledBySpecialCase = true;
        } else if (!!t1.$isHIsViaInterceptor) {
          t1 = input.inputs;
          if (0 >= t1.length)
            return H.ioore(t1, 0);
          this.checkTypeViaProperty$3(t1[0], input.typeExpression, true);
          this.attachLocationToLast$1(input);
          handledBySpecialCase = true;
        } else if (!!t1.$isHNot) {
          t1 = input.inputs;
          if (0 >= t1.length)
            return H.ioore(t1, 0);
          this.use$1(t1[0]);
          handledBySpecialCase = true;
        } else if (!!t1.$isHIdentity) {
          this.emitIdentityComparison$2(input, true);
          handledBySpecialCase = true;
        } else if (!!t1.$isHBoolify) {
          t1 = input.inputs;
          if (0 >= t1.length)
            return H.ioore(t1, 0);
          this.use$1(t1[0]);
          t1 = this.expressionStack;
          if (0 >= t1.length)
            return H.ioore(t1, 0);
          this.push$2(new Q.Binary("!==", t1.pop(), this.newLiteralBool$1(true), null, null), input);
          handledBySpecialCase = true;
        } else if (new B.SsaCodeGenerator_generateNot_canGenerateOptimizedComparison(this).call$1(input) === true) {
          operation = input.operation$1(this.backend.constantCompilerTask.jsConstantCompiler.constantSystem);
          this.visitInvokeBinary$2(input, B.SsaCodeGenerator_mapRelationalOperator(operation.get$name(operation), true));
          handledBySpecialCase = true;
        } else
          handledBySpecialCase = false;
      } else
        handledBySpecialCase = false;
      if (!handledBySpecialCase) {
        this.use$1(input);
        t1 = this.expressionStack;
        if (0 >= t1.length)
          return H.ioore(t1, 0);
        this.push$1(new Q.Prefix("!", t1.pop(), null, null));
      }
    },
    visitParameterValue$1: function(node) {
      var $name = this.variableNames.ownName.$index(0, node);
      this.parameters.push(new Q.Parameter($name, null, null));
      this.declaredLocals.add$1(0, $name);
    },
    visitLocalValue$1: function(node) {
      this.collectedVariableDeclarations.add$1(0, this.variableNames.ownName.$index(0, node));
    },
    visitPhi$1: function(node) {
      var t1, input, operation, t2, left, test, then;
      t1 = node.block.dominator.last.inputs;
      if (0 >= t1.length)
        return H.ioore(t1, 0);
      input = t1[0];
      if (input.isConstantFalse$0()) {
        t1 = node.inputs;
        if (1 >= t1.length)
          return H.ioore(t1, 1);
        this.use$1(t1[1]);
      } else if (input.isConstantTrue$0()) {
        t1 = node.inputs;
        if (0 >= t1.length)
          return H.ioore(t1, 0);
        this.use$1(t1[0]);
      } else {
        t1 = node.inputs;
        if (1 >= t1.length)
          return H.ioore(t1, 1);
        if (t1[1].isConstantBoolean$0()) {
          if (1 >= t1.length)
            return H.ioore(t1, 1);
          operation = t1[1].isConstantFalse$0() ? "&&" : "||";
          if (operation === "||")
            this.generateNot$1(input);
          else
            this.use$1(input);
          t2 = this.expressionStack;
          if (0 >= t2.length)
            return H.ioore(t2, 0);
          left = t2.pop();
          if (0 >= t1.length)
            return H.ioore(t1, 0);
          this.use$1(t1[0]);
          t1 = this.expressionStack;
          if (0 >= t1.length)
            return H.ioore(t1, 0);
          this.push$1(new Q.Binary(operation, left, t1.pop(), null, null));
        } else {
          this.use$1(input);
          t2 = this.expressionStack;
          if (0 >= t2.length)
            return H.ioore(t2, 0);
          test = t2.pop();
          if (0 >= t1.length)
            return H.ioore(t1, 0);
          this.use$1(t1[0]);
          t2 = this.expressionStack;
          if (0 >= t2.length)
            return H.ioore(t2, 0);
          then = t2.pop();
          if (1 >= t1.length)
            return H.ioore(t1, 1);
          this.use$1(t1[1]);
          t1 = this.expressionStack;
          if (0 >= t1.length)
            return H.ioore(t1, 0);
          this.push$1(new Q.Conditional(test, then, t1.pop(), null, null));
        }
      }
    },
    visitReturn$1: function(node) {
      var t1 = node.inputs;
      if (0 >= t1.length)
        return H.ioore(t1, 0);
      if (t1[0].isConstantNull$0())
        this.pushStatement$2(new Q.Return(null, null, null), node);
      else {
        if (0 >= t1.length)
          return H.ioore(t1, 0);
        this.use$1(t1[0]);
        t1 = this.expressionStack;
        if (0 >= t1.length)
          return H.ioore(t1, 0);
        this.pushStatement$2(new Q.Return(t1.pop(), null, null), node);
      }
    },
    visitThis$1: function(node) {
      this.push$1(new Q.This("this", null, null));
    },
    visitThrow$1: function(node) {
      var t1 = node.inputs;
      if (node.isRethrow) {
        if (0 >= t1.length)
          return H.ioore(t1, 0);
        this.use$1(t1[0]);
        t1 = this.expressionStack;
        if (0 >= t1.length)
          return H.ioore(t1, 0);
        this.pushStatement$2(new Q.Throw(t1.pop(), null, null), node);
      } else {
        if (0 >= t1.length)
          return H.ioore(t1, 0);
        this.generateThrowWithHelper$2("wrapException", t1[0]);
      }
    },
    visitRangeConversion$1: function(node) {
    },
    visitBoundsCheck$1: function(node) {
      var t1, t2, t3, under, jsIndex, over, underOver, thenBody, oldContainer;
      t1 = node.staticChecks;
      if (t1 !== 0) {
        if (t1 !== 2) {
          t1 = node.inputs;
          if (0 >= t1.length)
            return H.ioore(t1, 0);
          this.use$1(t1[0]);
          if (0 >= t1.length)
            return H.ioore(t1, 0);
          t2 = t1[0];
          t2 = t2.get$instructionType().containsOnlyInt$1(this.backend.compiler) && !t2.instructionType.get$isNullable();
          t3 = this.expressionStack;
          if (t2) {
            if (0 >= t3.length)
              return H.ioore(t3, 0);
            under = C.C_JsBuilder.call$2("# < 0", t3.pop());
          } else {
            if (0 >= t3.length)
              return H.ioore(t3, 0);
            jsIndex = t3.pop();
            under = C.C_JsBuilder.call$2("# >>> 0 !== #", [jsIndex, jsIndex]);
          }
        } else {
          t1 = node.inputs;
          if (0 >= t1.length)
            return H.ioore(t1, 0);
          t2 = t1[0];
          if (!(t2.get$instructionType().containsOnlyInt$1(this.backend.compiler) && !t2.instructionType.get$isNullable())) {
            if (0 >= t1.length)
              return H.ioore(t1, 0);
            this.checkInt$2(t1[0], "!==");
            t2 = this.expressionStack;
            if (0 >= t2.length)
              return H.ioore(t2, 0);
            under = t2.pop();
          } else
            under = null;
        }
        if (node.staticChecks !== 3) {
          if (0 >= t1.length)
            return H.ioore(t1, 0);
          this.use$1(t1[0]);
          t2 = this.expressionStack;
          if (0 >= t2.length)
            return H.ioore(t2, 0);
          jsIndex = t2.pop();
          if (1 >= t1.length)
            return H.ioore(t1, 1);
          this.use$1(t1[1]);
          t2 = this.expressionStack;
          if (0 >= t2.length)
            return H.ioore(t2, 0);
          over = new Q.Binary(">=", jsIndex, t2.pop(), null, null);
        } else
          over = null;
        if (under == null)
          underOver = over;
        else
          underOver = over == null ? under : new Q.Binary("||", under, over, null, null);
        thenBody = new Q.Block(H.setRuntimeTypeInfo([], [Q.Statement]), null, null);
        oldContainer = this.currentContainer;
        this.currentContainer = thenBody;
        if (2 >= t1.length)
          return H.ioore(t1, 2);
        this.generateThrowWithHelper$2("ioore", [t1[2], t1[0]]);
        this.currentContainer = oldContainer;
        this.pushStatement$2(new Q.If(underOver, this.unwrapStatement$1(thenBody), new Q.EmptyStatement(null, null), null, null), node);
      } else {
        t1 = node.inputs;
        if (2 >= t1.length)
          return H.ioore(t1, 2);
        this.generateThrowWithHelper$2("ioore", [t1[2], t1[0]]);
      }
    },
    generateThrowWithHelper$2: function(helperName, argument) {
      var t1, helper, jsHelper, $arguments, $location, value;
      t1 = this.backend;
      helper = t1.find$2(0, t1.jsHelperLibrary, helperName);
      this.work.registry.compiler.enqueuer.codegen.registerStaticUse$1(helper);
      jsHelper = t1.namer.elementAccess$1(helper);
      $arguments = [];
      t1 = J.getInterceptor(argument);
      if (!!t1.$isList) {
        $location = t1.$index(argument, 0);
        t1.forEach$1(argument, new B.SsaCodeGenerator_generateThrowWithHelper_closure(this, $arguments));
      } else {
        this.use$1(argument);
        t1 = this.expressionStack;
        if (0 >= t1.length)
          return H.ioore(t1, 0);
        $arguments.push(t1.pop());
        $location = argument;
      }
      value = new Q.Call(jsHelper, C.JSArray_methods.toList$1$growable($arguments, false), null, null).withPosition$2($location.get$sourcePosition(), null);
      if (helperName === "wrapException")
        this.pushStatement$1(new Q.Throw(value, null, null));
      else
        this.pushStatement$1(new Q.Return(value, null, null));
    },
    visitThrowExpression$1: function(node) {
      var t1, argument, helper, jsHelper;
      t1 = node.inputs;
      if (0 >= t1.length)
        return H.ioore(t1, 0);
      argument = t1[0];
      this.use$1(argument);
      t1 = this.backend;
      helper = t1.find$2(0, t1.jsHelperLibrary, "throwExpression");
      this.work.registry.compiler.enqueuer.codegen.registerStaticUse$1(helper);
      jsHelper = t1.namer.elementAccess$1(helper);
      t1 = this.expressionStack;
      if (0 >= t1.length)
        return H.ioore(t1, 0);
      this.push$2(new Q.Call(jsHelper, [t1.pop()], null, null).withPosition$2(argument.get$sourcePosition(), null), node);
    },
    visitSwitch$1: function(node) {
    },
    visitStatic$1: function(node) {
      var element, t1;
      element = node.element;
      t1 = this.backend;
      if (element.get$isFunction()) {
        t1 = t1.namer;
        this.push$1(C.C_JsBuilder.call$2("#.#()", [t1.globalObjectFor$1(element), t1.getStaticClosureName$1(element)]));
      } else
        this.push$1(t1.namer.elementAccess$1(element));
      this.work.registry.compiler.enqueuer.codegen.registerStaticUse$1(element);
    },
    visitLazyStatic$1: function(node) {
      var element, t1;
      element = node.element;
      this.work.registry.compiler.enqueuer.codegen.registerStaticUse$1(element);
      t1 = this.backend.namer;
      this.push$2(new Q.Call(C.C_JsBuilder.call$2("#.#", [t1.globalObjectFor$1(element), t1.getLazyInitializerName$1(element)]), H.setRuntimeTypeInfo([], [Q.Expression]), null, null), node);
    },
    visitStaticStore$1: function(node) {
      var t1, t2, variable;
      t1 = this.work.registry;
      t2 = node.element;
      t1.compiler.enqueuer.codegen.registerStaticUse$1(t2);
      variable = this.backend.namer.elementAccess$1(node.element);
      t2 = node.inputs;
      if (0 >= t2.length)
        return H.ioore(t2, 0);
      this.use$1(t2[0]);
      t2 = this.expressionStack;
      if (0 >= t2.length)
        return H.ioore(t2, 0);
      this.push$2(new Q.Assignment(variable, null, t2.pop(), null, null), node);
    },
    visitStringConcat$1: function(node) {
      var t1, t2, jsLeft;
      t1 = node.inputs;
      if (0 >= t1.length)
        return H.ioore(t1, 0);
      this.use$1(t1[0]);
      t2 = this.expressionStack;
      if (0 >= t2.length)
        return H.ioore(t2, 0);
      jsLeft = t2.pop();
      if (1 >= t1.length)
        return H.ioore(t1, 1);
      this.use$1(t1[1]);
      t1 = this.expressionStack;
      if (0 >= t1.length)
        return H.ioore(t1, 0);
      this.push$2(new Q.Binary("+", jsLeft, t1.pop(), null, null), node);
    },
    visitStringify$1: function(node) {
      var input, t1, t2, convertToString, jsHelper;
      input = J.get$first$ax(node.inputs);
      t1 = this.backend;
      t2 = t1.compiler;
      if (input.get$instructionType().containsOnlyString$1(t2) && !input.instructionType.get$isNullable())
        this.use$1(input);
      else {
        if (!(input.instructionType.containsOnlyInt$1(t2) && !input.instructionType.get$isNullable()))
          t2 = input.instructionType.containsOnlyBool$1(t2) && !input.instructionType.get$isNullable();
        else
          t2 = true;
        if (t2) {
          this.use$1(input);
          t1 = node.usedBy;
          t2 = t1.length;
          if (t2 === 1) {
            if (0 >= t2)
              return H.ioore(t1, 0);
            t1 = t1[0];
            if (!!J.getInterceptor(t1).$isHStringConcat) {
              t1 = t1.get$inputs();
              if (1 >= t1.length)
                return H.ioore(t1, 1);
              t1 = J.$eq(t1[1], node);
            } else
              t1 = false;
          } else
            t1 = false;
          if (t1)
            ;
          else {
            t1 = this.expressionStack;
            if (0 >= t1.length)
              return H.ioore(t1, 0);
            this.push$2(new Q.Binary("+", new Q.LiteralString0("\"\"", null, null), t1.pop(), null, null), node);
          }
        } else {
          convertToString = t1.find$2(0, t1.jsHelperLibrary, "S");
          this.work.registry.compiler.enqueuer.codegen.registerStaticUse$1(convertToString);
          jsHelper = t1.namer.elementAccess$1(convertToString);
          this.use$1(input);
          t1 = this.expressionStack;
          if (0 >= t1.length)
            return H.ioore(t1, 0);
          this.push$2(new Q.Call(jsHelper, H.setRuntimeTypeInfo([t1.pop()], [Q.Expression]), null, null), node);
        }
      }
    },
    visitLiteralList$1: function(node) {
      var t1, t2, t3;
      t1 = this.work.registry;
      t2 = this.backend.compiler.listClass;
      t3 = t1.compiler.enqueuer.codegen;
      t2.ensureResolved$1(t3.compiler);
      t3.registerInstantiatedType$3$mirrorUsage(t2.get$rawType(), t1, false);
      this.generateArrayLiteral$1(node);
    },
    generateArrayLiteral$1: function(node) {
      var t1, len, elements, i, t2;
      t1 = node.inputs;
      len = t1.length;
      elements = H.setRuntimeTypeInfo([], [Q.ArrayElement]);
      for (i = 0; i < len; ++i) {
        if (i >= t1.length)
          return H.ioore(t1, i);
        this.use$1(t1[i]);
        t2 = this.expressionStack;
        if (0 >= t2.length)
          return H.ioore(t2, 0);
        elements.push(new Q.ArrayElement(i, t2.pop(), null, null));
      }
      this.push$2(new Q.ArrayInitializer(len, elements, null, null), node);
    },
    visitIndex$1: function(node) {
      var t1, t2, receiver;
      t1 = node.inputs;
      if (0 >= t1.length)
        return H.ioore(t1, 0);
      this.use$1(t1[0]);
      t2 = this.expressionStack;
      if (0 >= t2.length)
        return H.ioore(t2, 0);
      receiver = t2.pop();
      if (1 >= t1.length)
        return H.ioore(t1, 1);
      this.use$1(t1[1]);
      t1 = this.expressionStack;
      if (0 >= t1.length)
        return H.ioore(t1, 0);
      this.push$2(new Q.PropertyAccess(receiver, t1.pop(), null, null), node);
    },
    visitIndexAssign$1: function(node) {
      var t1, t2, receiver, index;
      t1 = node.inputs;
      if (0 >= t1.length)
        return H.ioore(t1, 0);
      this.use$1(t1[0]);
      t2 = this.expressionStack;
      if (0 >= t2.length)
        return H.ioore(t2, 0);
      receiver = t2.pop();
      if (1 >= t1.length)
        return H.ioore(t1, 1);
      this.use$1(t1[1]);
      t2 = this.expressionStack;
      if (0 >= t2.length)
        return H.ioore(t2, 0);
      index = t2.pop();
      if (2 >= t1.length)
        return H.ioore(t1, 2);
      this.use$1(t1[2]);
      t1 = this.expressionStack;
      if (0 >= t1.length)
        return H.ioore(t1, 0);
      this.push$2(new Q.Assignment(new Q.PropertyAccess(receiver, index, null, null), null, t1.pop(), null, null), node);
    },
    checkInt$2: function(input, cmp) {
      var t1, left;
      this.use$1(input);
      t1 = this.expressionStack;
      if (0 >= t1.length)
        return H.ioore(t1, 0);
      left = t1.pop();
      this.use$1(input);
      t1 = this.expressionStack;
      if (0 >= t1.length)
        return H.ioore(t1, 0);
      this.push$1(new Q.Binary(cmp, left, new Q.Binary("|", t1.pop(), new Q.LiteralNumber("0", null, null), null, null), null, null));
    },
    checkTypeOf$3: function(input, cmp, typeName) {
      var t1;
      this.use$1(input);
      t1 = this.expressionStack;
      if (0 >= t1.length)
        return H.ioore(t1, 0);
      this.push$1(new Q.Binary(cmp, new Q.Prefix("typeof", t1.pop(), null, null), new Q.LiteralString0("\"" + typeName + "\"", null, null), null, null));
    },
    checkObject$2: function(input, cmp) {
      var t1, left;
      if (cmp === "===") {
        this.checkTypeOf$3(input, "===", "object");
        t1 = this.expressionStack;
        if (0 >= t1.length)
          return H.ioore(t1, 0);
        left = t1.pop();
        this.use$1(input);
        t1 = this.expressionStack;
        if (0 >= t1.length)
          return H.ioore(t1, 0);
        this.push$1(new Q.Binary("&&", left, new Q.Binary("!==", t1.pop(), new Q.LiteralNull(null, null), null, null), null, null));
      } else {
        this.checkTypeOf$3(input, "!==", "object");
        t1 = this.expressionStack;
        if (0 >= t1.length)
          return H.ioore(t1, 0);
        left = t1.pop();
        this.use$1(input);
        t1 = this.expressionStack;
        if (0 >= t1.length)
          return H.ioore(t1, 0);
        this.push$1(new Q.Binary("||", left, new Q.Binary("===", t1.pop(), new Q.LiteralNull(null, null), null, null), null, null));
      }
    },
    checkArray$2: function(input, cmp) {
      var t1;
      this.use$1(input);
      t1 = this.expressionStack;
      if (0 >= t1.length)
        return H.ioore(t1, 0);
      this.push$1(new Q.Binary(cmp, new Q.PropertyAccess(t1.pop(), new Q.LiteralString0("\"constructor\"", null, null), null, null), new Q.VariableUse("Array", null, null), null, null));
    },
    checkFieldExists$2: function(input, fieldName) {
      var t1;
      this.use$1(input);
      t1 = this.expressionStack;
      if (0 >= t1.length)
        return H.ioore(t1, 0);
      this.push$1(new Q.Prefix("!", new Q.Prefix("!", new Q.PropertyAccess(t1.pop(), new Q.LiteralString0("\"" + fieldName + "\"", null, null), null, null), null, null), null, null));
    },
    checkFieldDoesNotExist$2: function(input, fieldName) {
      var t1;
      this.use$1(input);
      t1 = this.expressionStack;
      if (0 >= t1.length)
        return H.ioore(t1, 0);
      this.push$1(new Q.Prefix("!", new Q.PropertyAccess(t1.pop(), new Q.LiteralString0("\"" + fieldName + "\"", null, null), null, null), null, null));
    },
    checkIndexingBehavior$2$negative: function(input, negative) {
      var t1, t2, object1;
      t1 = this.backend;
      if (!t1.compiler.enqueuer.resolution.seenClasses.contains$1(0, t1.jsIndexingBehaviorInterface))
        return false;
      this.use$1(input);
      t2 = this.expressionStack;
      if (0 >= t2.length)
        return H.ioore(t2, 0);
      object1 = t2.pop();
      this.use$1(input);
      t2 = this.expressionStack;
      if (0 >= t2.length)
        return H.ioore(t2, 0);
      this.push$1(t1.generateIsJsIndexableCall$2(object1, t2.pop()));
      if (negative) {
        t1 = this.expressionStack;
        if (0 >= t1.length)
          return H.ioore(t1, 0);
        this.push$1(new Q.Prefix("!", t1.pop(), null, null));
      }
      return true;
    },
    checkType$4$negative: function(input, interceptor, type, negative) {
      var element, t1, t2;
      element = type.get$element();
      t1 = this.backend;
      t2 = t1.jsArrayClass;
      if (element == null ? t2 == null : element === t2) {
        this.checkArray$2(input, negative ? "!==" : "===");
        return;
      } else {
        t2 = t1.jsMutableArrayClass;
        if (element == null ? t2 == null : element === t2) {
          if (negative)
            this.checkFieldExists$2(input, "immutable$list");
          else
            this.checkFieldDoesNotExist$2(input, "immutable$list");
          return;
        } else {
          t2 = t1.jsExtendableArrayClass;
          if (element == null ? t2 == null : element === t2) {
            if (negative)
              this.checkFieldExists$2(input, "fixed$length");
            else
              this.checkFieldDoesNotExist$2(input, "fixed$length");
            return;
          } else {
            t1 = t1.jsFixedArrayClass;
            if (element == null ? t1 == null : element === t1) {
              if (negative)
                this.checkFieldDoesNotExist$2(input, "fixed$length");
              else
                this.checkFieldExists$2(input, "fixed$length");
              return;
            }
          }
        }
      }
      if (interceptor != null)
        this.checkTypeViaProperty$3(interceptor, type, negative);
      else
        this.checkTypeViaProperty$3(input, type, negative);
    },
    checkTypeViaProperty$3: function(input, type, negative) {
      var t1, t2;
      t1 = this.work.registry;
      t2 = t1.compiler;
      t2.enqueuer.codegen.registerIsCheck$2(type, t1);
      t2.backend.registerIsCheckForCodegen$3(type, t2.enqueuer.codegen, t1);
      this.use$1(input);
      t1 = this.expressionStack;
      if (0 >= t1.length)
        return H.ioore(t1, 0);
      this.push$1(new Q.Prefix("!", new Q.PropertyAccess(t1.pop(), new Q.LiteralString0("\"" + this.backend.namer.operatorIsType$1(type) + "\"", null, null), null, null), null, null));
      if (!negative) {
        t1 = this.expressionStack;
        if (0 >= t1.length)
          return H.ioore(t1, 0);
        this.push$1(new Q.Prefix("!", t1.pop(), null, null));
      }
    },
    visitIs$1: function(node) {
      this.emitIs$2(node, "===");
    },
    visitIsViaInterceptor$1: function(node) {
      var t1 = node.inputs;
      if (0 >= t1.length)
        return H.ioore(t1, 0);
      this.checkTypeViaProperty$3(t1[0], node.typeExpression, false);
      this.attachLocationToLast$1(node);
    },
    emitIs$2: function(node, relation) {
      var type, t1, t2, input, negative, t3, interceptor, objectClass, element, numTest, left, right, numberTest, stringTest, objectTest, combiner, combiner2, arrayTest;
      type = node.typeExpression;
      t1 = this.work.registry;
      t2 = t1.compiler;
      t2.enqueuer.codegen.registerIsCheck$2(type, t1);
      t2.backend.registerIsCheckForCodegen$3(type, t2.enqueuer.codegen, t1);
      t1 = node.inputs;
      t2 = t1.length;
      if (0 >= t2)
        return H.ioore(t1, 0);
      input = t1[0];
      negative = relation === "!==";
      t3 = node.kind;
      if (t3 === 2 || t3 === 1) {
        if (1 >= t2)
          return H.ioore(t1, 1);
        this.use$1(t1[1]);
        if (negative) {
          t1 = this.expressionStack;
          if (0 >= t1.length)
            return H.ioore(t1, 0);
          this.push$1(new Q.Prefix("!", t1.pop(), null, null));
        }
      } else {
        interceptor = node.get$interceptor();
        t1 = this.backend.compiler;
        objectClass = t1.objectClass;
        element = type.get$element();
        t2 = t1.nullClass;
        if (element == null ? t2 == null : element === t2)
          if (negative) {
            this.use$1(input);
            t1 = this.expressionStack;
            if (0 >= t1.length)
              return H.ioore(t1, 0);
            this.push$1(new Q.Binary("!=", t1.pop(), new Q.LiteralNull(null, null), null, null));
          } else {
            this.use$1(input);
            t1 = this.expressionStack;
            if (0 >= t1.length)
              return H.ioore(t1, 0);
            this.push$1(new Q.Binary("==", t1.pop(), new Q.LiteralNull(null, null), null, null));
          }
        else if ((element == null ? objectClass == null : element === objectClass) || type.get$treatAsDynamic())
          this.push$2(this.newLiteralBool$1(!negative), node);
        else {
          t2 = t1.stringClass;
          if (element == null ? t2 == null : element === t2) {
            this.checkTypeOf$3(input, relation, "string");
            this.attachLocationToLast$1(node);
          } else {
            t2 = t1.doubleClass;
            if (element == null ? t2 == null : element === t2) {
              this.checkTypeOf$3(input, relation, "number");
              this.attachLocationToLast$1(node);
            } else {
              t2 = t1.numClass;
              if (element == null ? t2 == null : element === t2) {
                this.checkTypeOf$3(input, relation, "number");
                this.attachLocationToLast$1(node);
              } else {
                t2 = t1.boolClass;
                if (element == null ? t2 == null : element === t2) {
                  this.checkTypeOf$3(input, relation, "boolean");
                  this.attachLocationToLast$1(node);
                } else {
                  t2 = t1.intClass;
                  if (element == null ? t2 == null : element === t2) {
                    this.checkTypeOf$3(input, relation, "number");
                    t1 = this.expressionStack;
                    if (0 >= t1.length)
                      return H.ioore(t1, 0);
                    numTest = t1.pop();
                    this.use$1(input);
                    t1 = this.expressionStack;
                    if (0 >= t1.length)
                      return H.ioore(t1, 0);
                    left = t1.pop();
                    this.use$1(input);
                    t1 = this.expressionStack;
                    if (0 >= t1.length)
                      return H.ioore(t1, 0);
                    right = t1.pop();
                    this.push$1(C.C_JsBuilder.call$2("Math.floor(#) " + relation + " #", H.setRuntimeTypeInfo([left, right], [Q.Expression])));
                    t1 = negative ? "||" : "&&";
                    t2 = this.expressionStack;
                    if (0 >= t2.length)
                      return H.ioore(t2, 0);
                    this.push$2(new Q.Binary(t1, numTest, t2.pop(), null, null), node);
                  } else if (O.Elements_isNumberOrStringSupertype(element, t1)) {
                    relation = negative ? "!==" : "===";
                    this.checkTypeOf$3(input, relation, "number");
                    t1 = this.expressionStack;
                    if (0 >= t1.length)
                      return H.ioore(t1, 0);
                    numberTest = t1.pop();
                    this.checkTypeOf$3(input, relation, "string");
                    t1 = this.expressionStack;
                    if (0 >= t1.length)
                      return H.ioore(t1, 0);
                    stringTest = t1.pop();
                    this.checkObject$2(input, relation);
                    t1 = this.expressionStack;
                    if (0 >= t1.length)
                      return H.ioore(t1, 0);
                    objectTest = t1.pop();
                    this.checkType$4$negative(input, interceptor, type, negative);
                    combiner = negative ? "&&" : "||";
                    combiner2 = negative ? "||" : "&&";
                    t1 = this.expressionStack;
                    if (0 >= t1.length)
                      return H.ioore(t1, 0);
                    this.push$1(new Q.Binary(combiner, new Q.Binary(combiner, numberTest, stringTest, null, null), new Q.Binary(combiner2, objectTest, t1.pop(), null, null), null, null));
                    this.attachLocationToLast$1(node);
                  } else if (O.Elements_isStringOnlySupertype(element, t1)) {
                    relation = negative ? "!==" : "===";
                    this.checkTypeOf$3(input, relation, "string");
                    t1 = this.expressionStack;
                    if (0 >= t1.length)
                      return H.ioore(t1, 0);
                    stringTest = t1.pop();
                    this.checkObject$2(input, relation);
                    t1 = this.expressionStack;
                    if (0 >= t1.length)
                      return H.ioore(t1, 0);
                    objectTest = t1.pop();
                    this.checkType$4$negative(input, interceptor, type, negative);
                    combiner = negative ? "||" : "&&";
                    t1 = negative ? "&&" : "||";
                    t2 = this.expressionStack;
                    if (0 >= t2.length)
                      return H.ioore(t2, 0);
                    this.push$1(new Q.Binary(t1, stringTest, new Q.Binary(combiner, objectTest, t2.pop(), null, null), null, null));
                    this.attachLocationToLast$1(node);
                  } else {
                    t2 = t1.listClass;
                    if ((element == null ? t2 == null : element === t2) || O.Elements_isListSupertype(element, t1)) {
                      relation = negative ? "!==" : "===";
                      this.checkObject$2(input, relation);
                      t1 = this.expressionStack;
                      if (0 >= t1.length)
                        return H.ioore(t1, 0);
                      objectTest = t1.pop();
                      this.checkArray$2(input, relation);
                      t1 = this.expressionStack;
                      if (0 >= t1.length)
                        return H.ioore(t1, 0);
                      arrayTest = t1.pop();
                      this.checkType$4$negative(input, interceptor, type, negative);
                      combiner = negative ? "&&" : "||";
                      t1 = negative ? "||" : "&&";
                      t2 = this.expressionStack;
                      if (0 >= t2.length)
                        return H.ioore(t2, 0);
                      this.push$1(new Q.Binary(t1, objectTest, new Q.Binary(combiner, arrayTest, t2.pop(), null, null), null, null));
                      this.attachLocationToLast$1(node);
                    } else if (type.get$kind(type) === C.TypeKind_function) {
                      this.checkType$4$negative(input, interceptor, type, negative);
                      this.attachLocationToLast$1(node);
                    } else if (input.canBePrimitive$1(t1) && !input.canBePrimitiveArray$1(t1) || input.instructionType.get$isNullable()) {
                      this.checkObject$2(input, relation);
                      t1 = this.expressionStack;
                      if (0 >= t1.length)
                        return H.ioore(t1, 0);
                      objectTest = t1.pop();
                      this.checkType$4$negative(input, interceptor, type, negative);
                      t1 = negative ? "||" : "&&";
                      t2 = this.expressionStack;
                      if (0 >= t2.length)
                        return H.ioore(t2, 0);
                      this.push$2(new Q.Binary(t1, objectTest, t2.pop(), null, null), node);
                    } else {
                      this.checkType$4$negative(input, interceptor, type, negative);
                      this.attachLocationToLast$1(node);
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    visitTypeConversion$1: function(node) {
      var t1, t2, t3, t4, t5, receiver, t6, t7, turnIntoNumCheck, t8, t9, turnIntoNullCheck, test, objectTest, arrayTest, notArrayOrImmutable, notIndexing, stringTest, notIndexingTest, oldContainer, body, methodName, type, helper, backend, helperElement, $arguments;
      t1 = node.kind;
      t2 = t1 === 1;
      if (t2 || t1 === 4) {
        t3 = node.inputs;
        if (0 >= t3.length)
          return H.ioore(t3, 0);
        t4 = t3[0];
        t5 = node.checkedType;
        receiver = t4.get$instructionType();
        t6 = this.backend;
        t7 = t6.compiler;
        turnIntoNumCheck = t4.instructionType.containsOnlyInt$1(t7) && t5.containsOnlyInt$1(t7);
        t8 = !turnIntoNumCheck;
        if (t8)
          if (t5.nullable$0().$eq(0, receiver)) {
            t9 = t5.containsOnlyInt$1(t7) || t5.satisfies$2(t6.jsIndexableClass, t7);
            turnIntoNullCheck = t9;
          } else
            turnIntoNullCheck = false;
        else
          turnIntoNullCheck = false;
        if (turnIntoNullCheck) {
          this.use$1(t4);
          t4 = this.expressionStack;
          if (0 >= t4.length)
            return H.ioore(t4, 0);
          test = new Q.Binary("==", t4.pop(), new Q.LiteralNull(null, null), null, null);
        } else if (t5.containsOnlyInt$1(t7) && t8) {
          this.checkInt$2(t4, "!==");
          t4 = this.expressionStack;
          if (0 >= t4.length)
            return H.ioore(t4, 0);
          test = t4.pop();
        } else if (t5.containsOnlyNum$1(t7) || turnIntoNumCheck) {
          this.checkTypeOf$3(t4, "!==", "number");
          t4 = this.expressionStack;
          if (0 >= t4.length)
            return H.ioore(t4, 0);
          test = t4.pop();
        } else if (t5.containsOnlyBool$1(t7)) {
          this.checkTypeOf$3(t4, "!==", "boolean");
          t4 = this.expressionStack;
          if (0 >= t4.length)
            return H.ioore(t4, 0);
          test = t4.pop();
        } else if (t5.containsOnlyString$1(t7)) {
          this.checkTypeOf$3(t4, "!==", "string");
          t4 = this.expressionStack;
          if (0 >= t4.length)
            return H.ioore(t4, 0);
          test = t4.pop();
        } else if (t5.satisfies$2(t6.jsExtendableArrayClass, t7)) {
          this.checkObject$2(t4, "!==");
          t5 = this.expressionStack;
          if (0 >= t5.length)
            return H.ioore(t5, 0);
          objectTest = t5.pop();
          this.checkArray$2(t4, "!==");
          t5 = this.expressionStack;
          if (0 >= t5.length)
            return H.ioore(t5, 0);
          arrayTest = t5.pop();
          this.checkFieldExists$2(t4, "fixed$length");
          t4 = this.expressionStack;
          if (0 >= t4.length)
            return H.ioore(t4, 0);
          test = new Q.Binary("||", new Q.Binary("||", objectTest, arrayTest, null, null), t4.pop(), null, null);
        } else if (t5.satisfies$2(t6.jsMutableArrayClass, t7)) {
          this.checkObject$2(t4, "!==");
          t5 = this.expressionStack;
          if (0 >= t5.length)
            return H.ioore(t5, 0);
          objectTest = t5.pop();
          this.checkArray$2(t4, "!==");
          t5 = this.expressionStack;
          if (0 >= t5.length)
            return H.ioore(t5, 0);
          arrayTest = t5.pop();
          this.checkFieldExists$2(t4, "immutable$list");
          t5 = this.expressionStack;
          if (0 >= t5.length)
            return H.ioore(t5, 0);
          notArrayOrImmutable = new Q.Binary("||", arrayTest, t5.pop(), null, null);
          if (this.checkIndexingBehavior$2$negative(t4, true)) {
            t4 = this.expressionStack;
            if (0 >= t4.length)
              return H.ioore(t4, 0);
            notIndexing = new Q.Binary("&&", notArrayOrImmutable, t4.pop(), null, null);
          } else
            notIndexing = notArrayOrImmutable;
          test = new Q.Binary("||", objectTest, notIndexing, null, null);
        } else if (t5.satisfies$2(t6.jsArrayClass, t7)) {
          this.checkObject$2(t4, "!==");
          t5 = this.expressionStack;
          if (0 >= t5.length)
            return H.ioore(t5, 0);
          objectTest = t5.pop();
          this.checkArray$2(t4, "!==");
          t5 = this.expressionStack;
          if (0 >= t5.length)
            return H.ioore(t5, 0);
          arrayTest = t5.pop();
          if (this.checkIndexingBehavior$2$negative(t4, true)) {
            t4 = this.expressionStack;
            if (0 >= t4.length)
              return H.ioore(t4, 0);
            notIndexing = new Q.Binary("&&", arrayTest, t4.pop(), null, null);
          } else
            notIndexing = arrayTest;
          test = new Q.Binary("||", objectTest, notIndexing, null, null);
        } else if (t5.satisfies$2(t6.jsIndexableClass, t7)) {
          this.checkTypeOf$3(t4, "!==", "string");
          t5 = this.expressionStack;
          if (0 >= t5.length)
            return H.ioore(t5, 0);
          stringTest = t5.pop();
          this.checkObject$2(t4, "!==");
          t5 = this.expressionStack;
          if (0 >= t5.length)
            return H.ioore(t5, 0);
          objectTest = t5.pop();
          this.checkArray$2(t4, "!==");
          t5 = this.expressionStack;
          if (0 >= t5.length)
            return H.ioore(t5, 0);
          arrayTest = t5.pop();
          if (this.checkIndexingBehavior$2$negative(t4, true)) {
            t4 = this.expressionStack;
            if (0 >= t4.length)
              return H.ioore(t4, 0);
            notIndexingTest = new Q.Binary("&&", arrayTest, t4.pop(), null, null);
          } else
            notIndexingTest = arrayTest;
          test = new Q.Binary("&&", stringTest, new Q.Binary("||", objectTest, notIndexingTest, null, null), null, null);
        } else {
          t7.internalError$2(t4, "Unexpected check.");
          test = null;
        }
        oldContainer = this.currentContainer;
        body = new Q.Block(H.setRuntimeTypeInfo([], [Q.Statement]), null, null);
        this.currentContainer = body;
        if (t2) {
          if (0 >= t3.length)
            return H.ioore(t3, 0);
          this.generateThrowWithHelper$2("iae", t3[0]);
        } else if (t1 === 4) {
          if (0 >= t3.length)
            return H.ioore(t3, 0);
          this.use$1(t3[0]);
          methodName = t6.namer.invocationName$1(node.receiverTypeCheckSelector);
          t1 = this.expressionStack;
          if (0 >= t1.length)
            return H.ioore(t1, 0);
          this.pushStatement$1(new Q.Return(new Q.Call(new Q.PropertyAccess(t1.pop(), new Q.LiteralString0("\"" + H.S(methodName) + "\"", null, null), null, null), [], null, null), null, null));
        }
        this.currentContainer = oldContainer;
        this.pushStatement$2(new Q.If(test, this.unwrapStatement$1(body), new Q.EmptyStatement(null, null), null, null), node);
        return;
      }
      type = node.typeExpression;
      if (type.get$kind(type) === C.TypeKind_function) {
        t2 = this.work.registry;
        t3 = this.backend.compiler.functionClass.get$rawType();
        t4 = t2.compiler;
        t4.enqueuer.codegen.registerIsCheck$2(t3, t2);
        t4.backend.registerIsCheckForCodegen$3(t3, t4.enqueuer.codegen, t2);
      }
      t2 = this.work;
      t3 = t2.registry;
      t4 = t3.compiler;
      t4.enqueuer.codegen.registerIsCheck$2(type, t3);
      t4.backend.registerIsCheckForCodegen$3(type, t4.enqueuer.codegen, t3);
      helper = t1 === 3 ? C.CheckedModeHelper_boolConversionCheck : this.backend.getCheckedModeHelperInternal$3$nativeCheckOnly$typeCast(type, false, t1 === 2);
      t1 = node.inputs;
      if (helper == null) {
        if (0 >= t1.length)
          return H.ioore(t1, 0);
        this.use$1(t1[0]);
      } else {
        t3 = this.backend;
        backend = t3.compiler.backend;
        t4 = helper.name;
        helperElement = backend.find$2(0, backend.get$jsHelperLibrary(), t4);
        t2.registry.compiler.enqueuer.codegen.registerStaticUse$1(helperElement);
        $arguments = H.setRuntimeTypeInfo([], [Q.Expression]);
        if (0 >= t1.length)
          return H.ioore(t1, 0);
        this.use$1(t1[0]);
        t1 = this.expressionStack;
        if (0 >= t1.length)
          return H.ioore(t1, 0);
        $arguments.push(t1.pop());
        helper.generateAdditionalArguments$3(this, node, $arguments);
        this.push$1(new Q.Call(t3.namer.elementAccess$1(helperElement), $arguments, null, null));
      }
    },
    visitTypeKnown$1: function(node) {
    },
    visitFunctionType$1: function(node) {
      var type, t1, t2, returnType, parameterTypes, inputCount, inputCount0, t3, optionalParameterTypes, namedParameters, $name, $arguments;
      type = node.dartType;
      t1 = node.inputs;
      if (0 >= t1.length)
        return H.ioore(t1, 0);
      this.use$1(t1[0]);
      t2 = this.expressionStack;
      if (0 >= t2.length)
        return H.ioore(t2, 0);
      returnType = t2.pop();
      parameterTypes = H.setRuntimeTypeInfo([], [Q.Expression]);
      for (t2 = type.get$parameterTypes(), t2 = H.setRuntimeTypeInfo(new H.ListIterator(t2, t2.length, 0, null), [H.getTypeArgumentByIndex(t2, 0)]), inputCount = 1; t2.moveNext$0(); inputCount = inputCount0) {
        inputCount0 = inputCount + 1;
        if (inputCount >= t1.length)
          return H.ioore(t1, inputCount);
        this.use$1(t1[inputCount]);
        t3 = this.expressionStack;
        if (0 >= t3.length)
          return H.ioore(t3, 0);
        parameterTypes.push(t3.pop());
      }
      optionalParameterTypes = H.setRuntimeTypeInfo([], [Q.Expression]);
      for (t2 = type.get$optionalParameterTypes(), t2 = H.setRuntimeTypeInfo(new H.ListIterator(t2, t2.length, 0, null), [H.getTypeArgumentByIndex(t2, 0)]); t2.moveNext$0(); inputCount = inputCount0) {
        inputCount0 = inputCount + 1;
        if (inputCount >= t1.length)
          return H.ioore(t1, inputCount);
        this.use$1(t1[inputCount]);
        t3 = this.expressionStack;
        if (0 >= t3.length)
          return H.ioore(t3, 0);
        optionalParameterTypes.push(t3.pop());
      }
      namedParameters = H.setRuntimeTypeInfo([], [Q.Property]);
      for (t2 = type.get$namedParameters(), t2 = H.setRuntimeTypeInfo(new H.ListIterator(t2, t2.length, 0, null), [H.getTypeArgumentByIndex(t2, 0)]); t2.moveNext$0();) {
        inputCount0 = inputCount + 1;
        if (inputCount >= t1.length)
          return H.ioore(t1, inputCount);
        this.use$1(t1[inputCount]);
        t3 = this.expressionStack;
        if (0 >= t3.length)
          return H.ioore(t3, 0);
        $name = t3.pop();
        inputCount = inputCount0 + 1;
        if (inputCount0 >= t1.length)
          return H.ioore(t1, inputCount0);
        this.use$1(t1[inputCount0]);
        inputCount0 = this.expressionStack;
        if (0 >= inputCount0.length)
          return H.ioore(inputCount0, 0);
        namedParameters.push(new Q.Property($name, inputCount0.pop(), null, null));
      }
      if (namedParameters.length === 0) {
        $arguments = [returnType];
        t1 = parameterTypes.length;
        if (t1 !== 0 || optionalParameterTypes.length !== 0)
          $arguments.push(new Q.ArrayInitializer(t1, Q.ArrayInitializer__convert(parameterTypes), null, null));
        t1 = optionalParameterTypes.length;
        if (t1 !== 0)
          $arguments.push(new Q.ArrayInitializer(t1, Q.ArrayInitializer__convert(optionalParameterTypes), null, null));
        this.push$1(C.C_JsBuilder.call$2("#(#)", [this.accessHelper$1("buildFunctionType"), $arguments]));
      } else {
        t1 = parameterTypes.length;
        t2 = Q.ArrayInitializer__convert(parameterTypes);
        this.push$1(C.C_JsBuilder.call$2("#(#)", [this.accessHelper$1("buildNamedFunctionType"), [returnType, new Q.ArrayInitializer(t1, t2, null, null), new Q.ObjectInitializer(namedParameters, true, null, null)]]));
      }
    },
    visitReadTypeVariable$1: function(node) {
      var element, t1, helperElement, t2, index, receiver;
      element = node.dartType.element;
      t1 = this.backend;
      helperElement = t1.find$2(0, t1.jsHelperLibrary, "convertRtiToRuntimeType");
      this.work.registry.compiler.enqueuer.codegen.registerStaticUse$1(helperElement);
      t2 = node.inputs;
      if (0 >= t2.length)
        return H.ioore(t2, 0);
      this.use$1(t2[0]);
      if (node.hasReceiver) {
        t2 = t1.namer;
        if (t1.isInterceptorClass$1(element.get$enclosingClass())) {
          index = Z.RuntimeTypes_getTypeVariableIndex(element);
          t1 = this.expressionStack;
          if (0 >= t1.length)
            return H.ioore(t1, 0);
          receiver = t1.pop();
          this.push$1(C.C_JsBuilder.call$2("#(#.$builtinTypeInfo && #.$builtinTypeInfo[#])", [t2.elementAccess$1(helperElement), receiver, receiver, new Q.LiteralNumber("" + index, null, null)]));
        } else {
          t1.emitter.readTypeVariables.add$1(0, element);
          t1 = this.expressionStack;
          if (0 >= t1.length)
            return H.ioore(t1, 0);
          this.push$1(C.C_JsBuilder.call$2("#.#()", [t1.pop(), "$tv_" + H.S(t2.instanceFieldAccessorName$1(element))]));
        }
      } else {
        t1 = t1.namer.elementAccess$1(t1.find$2(0, t1.jsHelperLibrary, "convertRtiToRuntimeType"));
        t2 = this.expressionStack;
        if (0 >= t2.length)
          return H.ioore(t2, 0);
        this.push$1(C.C_JsBuilder.call$2("#(#)", [t1, t2.pop()]));
      }
    },
    visitInterfaceType$1: function(node) {
      var typeArguments, t1, t2, $arguments;
      typeArguments = H.setRuntimeTypeInfo([], [Q.Expression]);
      for (t1 = node.inputs, t1 = H.setRuntimeTypeInfo(new H.ListIterator(t1, t1.length, 0, null), [H.getTypeArgumentByIndex(t1, 0)]); t1.moveNext$0();) {
        this.use$1(t1.__internal$_current);
        t2 = this.expressionStack;
        if (0 >= t2.length)
          return H.ioore(t2, 0);
        typeArguments.push(t2.pop());
      }
      $arguments = [this.backend.namer.elementAccess$1(node.dartType.get$element())];
      t1 = typeArguments.length;
      if (t1 !== 0)
        $arguments.push(new Q.ArrayInitializer(t1, Q.ArrayInitializer__convert(typeArguments), null, null));
      this.push$1(C.C_JsBuilder.call$2("#(#)", [this.accessHelper$1("buildInterfaceType"), $arguments]));
    },
    visitVoidType$1: function(node) {
      this.push$1(C.C_JsBuilder.call$2("#()", this.accessHelper$1("getVoidRuntimeType")));
    },
    visitDynamicType$1: function(node) {
      this.push$1(C.C_JsBuilder.call$2("#()", this.accessHelper$1("getDynamicRuntimeType")));
    },
    accessHelper$1: function($name) {
      var t1, helper;
      t1 = this.backend;
      helper = t1.find$2(0, t1.jsHelperLibrary, $name);
      if (helper == null)
        return C.C_JsBuilder.call$1("(void 0)." + $name);
      this.work.registry.compiler.enqueuer.codegen.registerStaticUse$1(helper);
      return t1.namer.elementAccess$1(helper);
    },
    static: {"^": "SsaCodeGenerator_TYPE_STATEMENT,SsaCodeGenerator_TYPE_EXPRESSION,SsaCodeGenerator_TYPE_DECLARATION", SsaCodeGenerator$: function(backend, work) {
        var t1, t2, t3, t4, t5, t6;
        t1 = P.LinkedHashSet_LinkedHashSet(null, null, null, P.String);
        t2 = P.LinkedHashSet_LinkedHashSet(null, null, null, P.String);
        t3 = H.setRuntimeTypeInfo([], [Q.Statement]);
        t4 = H.setRuntimeTypeInfo([], [Q.Parameter]);
        t5 = H.setRuntimeTypeInfo([], [Q.Expression]);
        t6 = H.setRuntimeTypeInfo([], [Q.Block]);
        return new B.SsaCodeGenerator(false, backend, work, P.LinkedHashSet_LinkedHashSet(null, null, null, B.HInstruction), P.LinkedHashSet_LinkedHashSet(null, null, null, B.HInstruction), P.LinkedHashMap_LinkedHashMap(null, null, null, O.Entity, {func: "void__Entity", void: true, args: [O.Entity]}), P.LinkedHashMap_LinkedHashMap(null, null, null, O.Entity, {func: "void__Entity", void: true, args: [O.Entity]}), t4, new Q.Block(t3, null, null), t5, t6, null, false, t2, t1, null, null, null);
      }, SsaCodeGenerator_mapRelationalOperator: function(op, inverse) {
        return inverse ? C.Map_eoXV6.$index(0, op) : op;
      }}
  },
  SsaCodeGenerator_handleDelayedVariableDeclarations_closure: {
    "^": "Closure:0;declarations_0",
    call$1: function($name) {
      this.declarations_0.push(new Q.VariableInitialization(new Q.VariableDeclaration($name, null, null), null, null, null, null));
    },
    $isFunction: true
  },
  SsaCodeGenerator_visitTryInfo_register: {
    "^": "Closure:45;this_0",
    call$1: function(classElement) {
      var t1, t2;
      if (classElement != null) {
        t1 = this.this_0.work.registry;
        t2 = t1.compiler.enqueuer.codegen;
        classElement.ensureResolved$1(t2.compiler);
        t2.registerInstantiatedType$3$mirrorUsage(classElement.get$rawType(), t1, false);
      }
    },
    $isFunction: true
  },
  SsaCodeGenerator_visitLoopInfo_allSimpleAssignments: {
    "^": "Closure:280;box_0",
    call$1: function(expression) {
      var t1, t2, assignments;
      t1 = J.getInterceptor(expression);
      if (!!t1.$isAssignment) {
        if (!!J.getInterceptor(expression.leftHandSide).$isVariableUse && expression.op == null) {
          t1 = this.box_0;
          t2 = t1.assignments_0;
          if (t2 == null) {
            assignments = H.setRuntimeTypeInfo([], [Q.Assignment]);
            t1.assignments_0 = assignments;
            t1 = assignments;
          } else
            t1 = t2;
          t1.push(expression);
          return true;
        }
      } else if (expression.get$isCommaOperator())
        return this.call$1(t1.get$left(expression)) === true && this.call$1(expression.right) === true;
      return false;
    },
    $isFunction: true
  },
  SsaCodeGenerator_assignPhisOfSuccessors_closure: {
    "^": "Closure:281;this_0",
    call$1: function(copy) {
      var t1, t2, t3;
      t1 = this.this_0;
      t2 = t1.variableNames;
      t3 = J.get$source$x(copy);
      t3 = t2.ownName.$index(0, t3);
      t1 = t1.variableNames;
      t2 = copy.get$destination();
      return new B.Copy(t3, t1.ownName.$index(0, t2));
    },
    $isFunction: true
  },
  SsaCodeGenerator_visitInvokeStatic_closure: {
    "^": "Closure:13;this_0",
    call$1: function(type) {
      var t1 = this.this_0.work.registry;
      t1.compiler.enqueuer.codegen.registerInstantiatedType$2(type, t1);
    },
    $isFunction: true
  },
  SsaCodeGenerator_registerForeignTypes_closure: {
    "^": "Closure:13;this_0",
    call$1: function(type) {
      var t1;
      if (!!J.getInterceptor(type).$isInterfaceType) {
        t1 = this.this_0.work.registry;
        t1.compiler.enqueuer.codegen.registerInstantiatedType$2(type, t1);
      }
    },
    $isFunction: true
  },
  SsaCodeGenerator_visitForeignNew_closure: {
    "^": "Closure:13;this_0",
    call$1: function(type) {
      var t1 = this.this_0.work.registry;
      t1.compiler.enqueuer.codegen.registerInstantiatedType$2(type, t1);
    },
    $isFunction: true
  },
  SsaCodeGenerator_generateNot_canGenerateOptimizedComparison: {
    "^": "Closure:263;this_0",
    call$1: function(instruction) {
      var t1, t2, t3, left, right;
      if (!J.getInterceptor(instruction).$isHRelational)
        return false;
      t1 = this.this_0.backend;
      instruction.operation$1(t1.constantCompilerTask.jsConstantCompiler.constantSystem);
      t2 = instruction.inputs;
      t3 = t2.length;
      if (0 >= t3)
        return H.ioore(t2, 0);
      left = t2[0];
      if (1 >= t3)
        return H.ioore(t2, 1);
      right = t2[1];
      t1 = t1.compiler;
      if (left.get$instructionType().containsOnlyString$1(t1) && right.get$instructionType().containsOnlyString$1(t1))
        return true;
      return left.instructionType.containsOnlyInt$1(t1) && !left.instructionType.get$isNullable() && right.get$instructionType().containsOnlyInt$1(t1) && !right.instructionType.get$isNullable();
    },
    $isFunction: true
  },
  SsaCodeGenerator_generateThrowWithHelper_closure: {
    "^": "Closure:13;this_0,arguments_1",
    call$1: function(instruction) {
      var t1 = this.this_0;
      t1.use$1(instruction);
      t1 = t1.expressionStack;
      if (0 >= t1.length)
        return H.ioore(t1, 0);
      this.arguments_1.push(t1.pop());
    },
    $isFunction: true
  },
  SsaInstructionSelection: {
    "^": "HBaseVisitor;compiler<,graph,currentBlock",
    get$backend: function() {
      return this.compiler.backend;
    },
    visitGraph$1: function(graph) {
      this.graph = graph;
      this.visitDominatorTree$1(graph);
    },
    visitBasicBlock$1: function(block) {
      var instruction, next, replacement;
      instruction = block.first;
      for (; instruction != null; instruction = next) {
        next = instruction.next;
        replacement = instruction.accept$1(0, this);
        if (!J.$eq(replacement, instruction) && replacement != null) {
          block.rewrite$2(instruction, replacement);
          if (replacement.get$sourceElement() == null)
            replacement.set$sourceElement(instruction.get$sourceElement());
          if (replacement.get$sourcePosition() == null)
            replacement.sourcePosition = instruction.sourcePosition;
          if (replacement.block == null) {
            block.addAfter$2(instruction, replacement);
            next = replacement;
          }
          block.remove$1(0, instruction);
        }
      }
    },
    visitInstruction$1: function(node) {
      return node;
    },
    visitIs$1: function(node) {
      var interceptor, t1, t2, t3;
      if (node.kind === 0) {
        interceptor = node.get$interceptor();
        if (interceptor != null) {
          t1 = this.compiler.backend.compiler.typesTask.get$boolType();
          t2 = H.setRuntimeTypeInfo([interceptor], [B.HInstruction]);
          t3 = $.HInstruction_idCounter;
          if (typeof t3 !== "number")
            return t3.$add();
          $.HInstruction_idCounter = t3 + 1;
          t3 = new B.HIsViaInterceptor(node.typeExpression, null, null, t3, t2, H.setRuntimeTypeInfo([], [B.HInstruction]), null, null, null, new Z.SideEffects(0), false, t1);
          t3.HInstruction$2(t2, t1);
          t3._useGvn = true;
          return t3;
        }
      }
      return node;
    },
    visitIdentity$1: function(node) {
      var t1, t2, t3;
      t1 = node.inputs;
      t2 = t1.length;
      if (0 >= t2)
        return H.ioore(t1, 0);
      t3 = t1[0];
      if (1 >= t2)
        return H.ioore(t1, 1);
      node.singleComparisonOp = this.simpleOp$2(t3, t1[1]);
      return node;
    },
    simpleOp$2: function(left, right) {
      var leftType, rightType, t1;
      leftType = left.instructionType;
      rightType = right.instructionType;
      if (leftType.get$isNullable() && rightType.get$isNullable()) {
        if (!left.isConstantNull$0())
          if (!right.isConstantNull$0()) {
            if (!(left.isPrimitiveOrNull$1(this.compiler) && !left.instructionType.get$isNullable())) {
              t1 = left.instructionType;
              t1 = t1.get$isEmpty(t1) && left.instructionType.get$isNullable();
            } else
              t1 = true;
            t1 = t1 && leftType.$eq(0, rightType);
          } else
            t1 = true;
        else
          t1 = true;
        if (t1)
          return "==";
        return;
      }
      return "===";
    },
    visitInvokeDynamic$1: function(node) {
      var selector, t1, t2, t3, interceptor, receiverArgument, dummy;
      if (node.get$isInterceptedCall()) {
        selector = node.selector;
        t1 = this.compiler;
        if (t1.backend.get$interceptedElements().$index(0, selector.name) != null && !t1.backend.isInterceptedMixinSelector$1(selector)) {
          t2 = node.inputs;
          t3 = t2.length;
          if (0 >= t3)
            return H.ioore(t2, 0);
          interceptor = t2[0];
          if (1 >= t3)
            return H.ioore(t2, 1);
          receiverArgument = t2[1];
          if (interceptor.nonCheck$0() === receiverArgument.nonCheck$0())
            if (selector.kind !== C.SelectorKind_getter_0) {
              t3 = receiverArgument.instructionType;
              dummy = this.graph.addConstant$2(new K.DummyConstant(t3), t1);
              C.JSArray_methods.remove$1(receiverArgument.usedBy, node);
              J.$indexSet$ax(t2, 1, dummy);
              dummy.usedBy.push(node);
            }
        }
      }
      return node;
    },
    visitFieldSet$1: function(setter) {
      var block, t1, op, receiver, t2, t3, t4, t5, t6;
      block = setter.block;
      t1 = setter.inputs;
      if (1 >= t1.length)
        return H.ioore(t1, 1);
      op = t1[1];
      receiver = t1[0];
      t1 = new B.SsaInstructionSelection_visitFieldSet_isMatchingRead(setter, block, op);
      t2 = new B.SsaInstructionSelection_visitFieldSet_noMatchingRead();
      t3 = new B.SsaInstructionSelection_visitFieldSet_replaceOp(setter, block, op);
      t4 = new B.SsaInstructionSelection_visitFieldSet_plusOrMinus(setter, block, op, receiver, t1, t2, t3);
      t3 = new B.SsaInstructionSelection_visitFieldSet_simple(setter, op, receiver, t1, t2, t3);
      t1 = new B.SsaInstructionSelection_visitFieldSet_simpleBinary(op, t3);
      t5 = new B.SsaInstructionSelection_visitFieldSet_bitop(this, op, t2, t1);
      t6 = J.getInterceptor(op);
      if (!!t6.$isHAdd)
        return t4.call$2("+", "++");
      if (!!t6.$isHSubtract)
        return t4.call$2("-", "--");
      if (!!t6.$isHStringConcat) {
        t1 = op.inputs;
        t2 = t1.length;
        if (0 >= t2)
          return H.ioore(t1, 0);
        t4 = t1[0];
        if (1 >= t2)
          return H.ioore(t1, 1);
        return t3.call$3("+", t4, t1[1]);
      }
      if (!!t6.$isHMultiply)
        return t1.call$1("*");
      if (!!t6.$isHDivide)
        return t1.call$1("/");
      if (!!t6.$isHBitAnd)
        return t5.call$1("&");
      if (!!t6.$isHBitOr)
        return t5.call$1("|");
      if (!!t6.$isHBitXor)
        return t5.call$1("^");
      return t2.call$0();
    }
  },
  SsaInstructionSelection_visitFieldSet_isMatchingRead: {
    "^": "Closure:263;setter_0,block_1,op_2",
    call$1: function(candidate) {
      var t1, t2, t3, t4;
      if (!!J.getInterceptor(candidate).$isHFieldGet) {
        t1 = candidate.element;
        t2 = this.setter_0;
        t3 = t2.element;
        if (t1 == null ? t3 != null : t1 !== t3)
          return false;
        t1 = candidate.inputs;
        if (0 >= t1.length)
          return H.ioore(t1, 0);
        t1 = t1[0];
        t3 = t2.inputs;
        if (0 >= t3.length)
          return H.ioore(t3, 0);
        if (!J.$eq(t1, t3[0]))
          return false;
        t1 = this.op_2;
        t3 = t1.block;
        t4 = this.block_1;
        if (t3 == null ? t4 != null : t3 !== t4)
          return false;
        t3 = candidate.block;
        if (t3 == null ? t4 != null : t3 !== t4)
          return false;
        t2 = t2.previous;
        if (t2 == null ? t1 != null : t2 !== t1)
          return false;
        if (t1.previous !== candidate)
          return false;
        return true;
      }
      return false;
    },
    $isFunction: true
  },
  SsaInstructionSelection_visitFieldSet_noMatchingRead: {
    "^": "Closure:267;",
    call$0: function() {
      return;
    },
    $isFunction: true
  },
  SsaInstructionSelection_visitFieldSet_replaceOp: {
    "^": "Closure:282;setter_3,block_4,op_5",
    call$2: function(replacement, getter) {
      var t1, t2;
      t1 = this.block_4;
      t2 = this.setter_3;
      t1.addBefore$2(t2, replacement);
      t1.remove$1(0, t2);
      t2 = this.op_5;
      t1.rewrite$2(t2, replacement);
      t1.remove$1(0, t2);
      t1.remove$1(0, getter);
      return;
    },
    $isFunction: true
  },
  SsaInstructionSelection_visitFieldSet_plusOrMinus: {
    "^": "Closure:283;setter_6,block_7,op_8,receiver_9,isMatchingRead_10,noMatchingRead_11,replaceOp_12",
    call$2: function(assignOp, incrementOp) {
      var binary, t1, t2, left, right, t3, t4, t5, rmw;
      binary = this.op_8;
      t1 = binary.inputs;
      t2 = t1.length;
      if (0 >= t2)
        return H.ioore(t1, 0);
      left = t1[0];
      if (1 >= t2)
        return H.ioore(t1, 1);
      right = t1[1];
      if (this.isMatchingRead_10.call$1(left) === true)
        if (left.get$usedBy().length === 1) {
          t1 = !!J.getInterceptor(right).$isHConstant && right.constant.get$isOne();
          t2 = this.setter_6;
          t3 = this.receiver_9;
          t4 = this.replaceOp_12;
          if (t1) {
            t1 = binary.instructionType;
            t3 = H.setRuntimeTypeInfo([t3], [B.HInstruction]);
            t5 = $.HInstruction_idCounter;
            if (typeof t5 !== "number")
              return t5.$add();
            $.HInstruction_idCounter = t5 + 1;
            rmw = new B.HReadModifyWrite(t2.element, incrementOp, 1, null, null, t5, t3, H.setRuntimeTypeInfo([], [B.HInstruction]), null, null, null, new Z.SideEffects(0), false, t1);
            rmw.HInstruction$2(t3, t1);
            rmw.sideEffects.clearAllSideEffects$0();
            rmw.sideEffects.clearAllDependencies$0();
            t1 = rmw.sideEffects;
            t3 = (t1.flags | 2) >>> 0;
            t1.flags = t3;
            t1.flags = (t3 | 16) >>> 0;
            return t4.call$2(rmw, left);
          } else {
            t1 = binary.instructionType;
            t3 = H.setRuntimeTypeInfo([t3, right], [B.HInstruction]);
            t5 = $.HInstruction_idCounter;
            if (typeof t5 !== "number")
              return t5.$add();
            $.HInstruction_idCounter = t5 + 1;
            rmw = new B.HReadModifyWrite(t2.element, assignOp, 0, null, null, t5, t3, H.setRuntimeTypeInfo([], [B.HInstruction]), null, null, null, new Z.SideEffects(0), false, t1);
            rmw.HInstruction$2(t3, t1);
            rmw.sideEffects.clearAllSideEffects$0();
            rmw.sideEffects.clearAllDependencies$0();
            t1 = rmw.sideEffects;
            t3 = (t1.flags | 2) >>> 0;
            t1.flags = t3;
            t1.flags = (t3 | 16) >>> 0;
            return t4.call$2(rmw, left);
          }
        } else if (binary.usedBy.length === 1 && !!J.getInterceptor(right).$isHConstant && right.constant.get$isOne()) {
          t1 = this.setter_6;
          t2 = binary.instructionType;
          t3 = H.setRuntimeTypeInfo([this.receiver_9], [B.HInstruction]);
          t4 = $.HInstruction_idCounter;
          if (typeof t4 !== "number")
            return t4.$add();
          $.HInstruction_idCounter = t4 + 1;
          rmw = new B.HReadModifyWrite(t1.element, incrementOp, 2, null, null, t4, t3, H.setRuntimeTypeInfo([], [B.HInstruction]), null, null, null, new Z.SideEffects(0), false, t2);
          rmw.HInstruction$2(t3, t2);
          rmw.sideEffects.clearAllSideEffects$0();
          rmw.sideEffects.clearAllDependencies$0();
          t2 = rmw.sideEffects;
          t3 = (t2.flags | 2) >>> 0;
          t2.flags = t3;
          t2.flags = (t3 | 16) >>> 0;
          t3 = this.block_7;
          t3.addAfter$2(left, rmw);
          t3.remove$1(0, t1);
          t3.remove$1(0, binary);
          t3.rewrite$2(left, rmw);
          t3.remove$1(0, left);
          return;
        }
      return this.noMatchingRead_11.call$0();
    },
    $isFunction: true
  },
  SsaInstructionSelection_visitFieldSet_simple: {
    "^": "Closure:284;setter_13,op_14,receiver_15,isMatchingRead_16,noMatchingRead_17,replaceOp_18",
    call$3: function(assignOp, left, right) {
      var t1, t2, t3, rmw;
      if (this.isMatchingRead_16.call$1(left) === true)
        if (left.usedBy.length === 1) {
          t1 = this.op_14.instructionType;
          t2 = H.setRuntimeTypeInfo([this.receiver_15, right], [B.HInstruction]);
          t3 = $.HInstruction_idCounter;
          if (typeof t3 !== "number")
            return t3.$add();
          $.HInstruction_idCounter = t3 + 1;
          rmw = new B.HReadModifyWrite(this.setter_13.element, assignOp, 0, null, null, t3, t2, H.setRuntimeTypeInfo([], [B.HInstruction]), null, null, null, new Z.SideEffects(0), false, t1);
          rmw.HInstruction$2(t2, t1);
          rmw.sideEffects.clearAllSideEffects$0();
          rmw.sideEffects.clearAllDependencies$0();
          t1 = rmw.sideEffects;
          t2 = (t1.flags | 2) >>> 0;
          t1.flags = t2;
          t1.flags = (t2 | 16) >>> 0;
          return this.replaceOp_18.call$2(rmw, left);
        }
      return this.noMatchingRead_17.call$0();
    },
    $isFunction: true
  },
  SsaInstructionSelection_visitFieldSet_simpleBinary: {
    "^": "Closure:285;op_19,simple_20",
    call$1: function(assignOp) {
      var t1, t2, t3;
      t1 = this.op_19.inputs;
      t2 = t1.length;
      if (0 >= t2)
        return H.ioore(t1, 0);
      t3 = t1[0];
      if (1 >= t2)
        return H.ioore(t1, 1);
      return this.simple_20.call$3(assignOp, t3, t1[1]);
    },
    $isFunction: true
  },
  SsaInstructionSelection_visitFieldSet_bitop: {
    "^": "Closure:285;this_21,op_22,noMatchingRead_23,simpleBinary_24",
    call$1: function(assignOp) {
      if (this.op_22.isUInt31$1(this.this_21.compiler))
        return this.simpleBinary_24.call$1(assignOp);
      return this.noMatchingRead_23.call$0();
    },
    $isFunction: true
  },
  SsaTypeKnownRemover: {
    "^": "HBaseVisitor;currentBlock",
    visitGraph$1: function(graph) {
      this.visitDominatorTree$1(graph);
    },
    visitBasicBlock$1: function(block) {
      var instruction, next;
      instruction = block.first;
      for (; instruction != null; instruction = next) {
        next = instruction.next;
        instruction.accept$1(0, this);
      }
    },
    visitTypeKnown$1: function(instruction) {
      var t1, t2;
      t1 = instruction.block;
      t2 = instruction.inputs;
      if (0 >= t2.length)
        return H.ioore(t2, 0);
      t1.rewrite$2(instruction, t2[0]);
      instruction.block.remove$1(0, instruction);
    }
  },
  SsaInstructionMerger: {
    "^": "HBaseVisitor;compiler<,expectedInputs,pureInputs,generateAtUseSite,currentBlock",
    visitGraph$1: function(graph) {
      this.visitDominatorTree$1(graph);
    },
    analyzeInputs$2: function(user, start) {
      var inputs, t1, i, input, t2, t3;
      inputs = user.inputs;
      for (t1 = this.generateAtUseSite, i = start; i < inputs.length; ++i) {
        input = inputs[i];
        if (!t1.contains$1(0, input) && !input.isCodeMotionInvariant$0() && input.usedBy.length === 1 && !input.$isHPhi && !input.$isHLocalValue && !input.isJsStatement$0())
          if ((input.get$sideEffects().flags & 7) === 0 && (input.get$sideEffects().flags & 63) >>> 3 === 0 && !input.canThrow$0()) {
            t2 = user.block.get$enclosingLoopHeader();
            t3 = input.get$block().get$enclosingLoopHeader();
            if (t2 == null ? t3 == null : t2 === t3) {
              input.get$block().detach$1(input);
              user.block.internalAddBefore$2(user, input);
              input.set$block(user.block);
              this.pureInputs.add$1(0, input);
              t2 = input.inputs;
              t2.toString;
              H.IterableMixinWorkaround_forEach(t2, new B.SsaInstructionMerger_analyzeInputs_closure(this));
              input.accept$1(0, this);
            }
          } else
            this.expectedInputs.push(input);
      }
    },
    visitInstruction$1: function(instruction) {
      this.analyzeInputs$2(instruction, 0);
    },
    visitIs$1: function(instruction) {
    },
    visitBoundsCheck$1: function(instruction) {
      this.analyzeInputs$2(instruction, 1);
    },
    visitIdentity$1: function(instruction) {
      if (instruction.singleComparisonOp != null)
        B.HBaseVisitor.prototype.visitIdentity$1.call(this, instruction);
    },
    visitTypeConversion$1: function(instruction) {
      var t1 = instruction.kind;
      if (t1 !== 1 && t1 !== 4)
        this.analyzeInputs$2(instruction, 0);
    },
    visitTypeKnown$1: function(instruction) {
    },
    tryGenerateAtUseSite$1: function(instruction) {
      if (instruction.isControlFlow$0())
        return;
      this.generateAtUseSite.add$1(0, instruction);
    },
    isBlockSinglePredecessor$1: function(block) {
      var t1;
      if (block.get$successors().length === 1) {
        t1 = block.get$successors();
        if (0 >= t1.length)
          return H.ioore(t1, 0);
        t1 = t1[0].get$predecessors().length === 1;
      } else
        t1 = false;
      return t1;
    },
    visitBasicBlock$1: function(block) {
      if (this.isBlockSinglePredecessor$1(block))
        return;
      this.tryMergingExpressions$1(block);
    },
    tryMergingExpressions$1: function(block) {
      var t1, t2, instruction, t3, oldLength, newInputs, newCount;
      if (this.expectedInputs == null)
        this.expectedInputs = H.setRuntimeTypeInfo([], [B.HInstruction]);
      if (this.pureInputs == null)
        this.pureInputs = P.LinkedHashSet_LinkedHashSet(null, null, null, B.HInstruction);
      t1 = new B.SsaInstructionMerger_tryMergingExpressions_findInInputsAndPopNonMatching(this);
      t2 = J.getInterceptor$ax(block);
      J.accept$1$x(t2.get$last(block), this);
      for (instruction = t2.get$last(block).previous, t2 = this.generateAtUseSite; instruction != null; instruction = instruction.previous) {
        if (t2.contains$1(0, instruction))
          continue;
        if (instruction.isCodeMotionInvariant$0()) {
          t2.add$1(0, instruction);
          continue;
        }
        t3 = instruction.sideEffects.flags;
        if ((t3 & 7) === 0 && (t3 & 63) >>> 3 === 0 && !instruction.canThrow$0())
          if (this.pureInputs.contains$1(0, instruction))
            this.tryGenerateAtUseSite$1(instruction);
          else {
            oldLength = this.expectedInputs.length;
            instruction.accept$1(0, this);
            if (oldLength !== 0 && oldLength !== this.expectedInputs.length) {
              newInputs = J.sublist$1$ax(this.expectedInputs, oldLength);
              newCount = newInputs.length;
              t3 = this.expectedInputs;
              t3.toString;
              if (typeof t3 !== "object" || t3 === null || !!t3.immutable$list)
                H.throwExpression(P.UnsupportedError$("set range"));
              H.IterableMixinWorkaround_setRangeList(t3, newCount, newCount + oldLength, t3, 0);
              t3 = this.expectedInputs;
              t3.toString;
              if (typeof t3 !== "object" || t3 === null || !!t3.immutable$list)
                H.throwExpression(P.UnsupportedError$("set range"));
              H.IterableMixinWorkaround_setRangeList(t3, 0, newCount, newInputs, 0);
            }
          }
        else {
          if (t1.call$1(instruction) === true)
            this.tryGenerateAtUseSite$1(instruction);
          instruction.accept$1(0, this);
        }
      }
      if (block.get$predecessors().length === 1) {
        t1 = block.get$predecessors();
        if (0 >= t1.length)
          return H.ioore(t1, 0);
        t1 = this.isBlockSinglePredecessor$1(t1[0]);
      } else
        t1 = false;
      if (t1) {
        t1 = block.get$predecessors();
        if (0 >= t1.length)
          return H.ioore(t1, 0);
        this.tryMergingExpressions$1(t1[0]);
      } else {
        this.expectedInputs = null;
        this.pureInputs = null;
      }
    }
  },
  SsaInstructionMerger_analyzeInputs_closure: {
    "^": "Closure:13;this_0",
    call$1: function(instruction) {
      if (!instruction.isCodeMotionInvariant$0())
        this.this_0.generateAtUseSite.remove$1(0, instruction);
    },
    $isFunction: true
  },
  SsaInstructionMerger_tryMergingExpressions_findInInputsAndPopNonMatching: {
    "^": "Closure:263;this_0",
    call$1: function(instruction) {
      var t1, t2, t3;
      for (t1 = this.this_0; t2 = t1.expectedInputs, t3 = t2.length, t3 !== 0;) {
        if (0 >= t3)
          return H.ioore(t2, 0);
        if (t2.pop() === instruction)
          return true;
      }
      return false;
    },
    $isFunction: true
  },
  SsaConditionMerger: {
    "^": "HGraphVisitor;generateAtUseSite,controlFlowOperators",
    visitGraph$1: function(graph) {
      this.visitPostDominatorTree$1(graph);
    },
    hasAnyStatement$2: function(block, instruction) {
      var t1, t2, temp;
      t1 = instruction.block;
      if (t1 == null ? block != null : t1 !== block) {
        t1 = block.last;
        t2 = block.first;
        return t1 == null ? t2 != null : t1 !== t2;
      }
      t1 = block.last;
      if (instruction == null ? t1 != null : instruction !== t1) {
        t1 = t1.previous;
        t1 = instruction == null ? t1 != null : instruction !== t1;
      } else
        t1 = false;
      if (t1)
        return true;
      for (temp = block.first, t1 = this.generateAtUseSite; temp == null ? instruction != null : temp !== instruction; temp = temp.next)
        if (!t1.contains$1(0, temp))
          return true;
      return false;
    },
    isSafeToGenerateAtUseSite$2: function(user, input) {
      var t1 = J.getInterceptor(user);
      if (!!t1.$isHForeign)
        return false;
      if (!!t1.$isHCheck && user.isControlFlow$0())
        return false;
      if (!!t1.$isHIs)
        return false;
      return true;
    },
    visitBasicBlock$1: function(block) {
      var t1, end, t2, t3, t4, elseBlock, phi, thenInput, elseInput, thenBlock, otherIf, otherJoin, t5, nextInstruction;
      t1 = block.last;
      if (!J.getInterceptor(t1).$isHIf)
        return;
      end = t1.get$blockInformation().continuation;
      if (end == null)
        return;
      t2 = end.phis;
      t3 = t2.first;
      if (t3 == null)
        return;
      t4 = t2.last;
      if (t3 == null ? t4 != null : t3 !== t4)
        return;
      elseBlock = t1.get$elseBlock();
      t3 = end.predecessors;
      if (1 >= t3.length)
        return H.ioore(t3, 1);
      t4 = t3[1];
      if (t4 == null ? elseBlock != null : t4 !== elseBlock)
        return;
      phi = t2.first;
      t2 = phi.inputs;
      t4 = t2.length;
      if (0 >= t4)
        return H.ioore(t2, 0);
      thenInput = t2[0];
      if (1 >= t4)
        return H.ioore(t2, 1);
      elseInput = t2[1];
      if (thenInput.isJsStatement$0() || elseInput.isJsStatement$0())
        return;
      if (this.hasAnyStatement$2(elseBlock, elseInput))
        return;
      thenBlock = t1.get$thenBlock();
      while (true) {
        t2 = thenBlock.get$successors();
        if (0 >= t2.length)
          return H.ioore(t2, 0);
        if (!(!J.$eq(t2[0], end) && !!J.getInterceptor(thenBlock.get$first(thenBlock)).$isHGoto))
          break;
        t2 = thenBlock.get$successors();
        if (0 >= t2.length)
          return H.ioore(t2, 0);
        thenBlock = t2[0];
      }
      t2 = this.controlFlowOperators;
      if (t2.contains$1(0, thenBlock.get$last(thenBlock))) {
        otherIf = thenBlock.last;
        if (otherIf.get$blockInformation().continuation !== end) {
          otherJoin = otherIf.blockInformation.continuation;
          t4 = otherJoin.first;
          t5 = otherJoin.last;
          if (t4 == null ? t5 != null : t4 !== t5)
            return;
          t4 = otherJoin.successors;
          t5 = t4.length;
          if (t5 !== 1)
            return;
          if (0 >= t5)
            return H.ioore(t4, 0);
          if (!J.$eq(t4[0], end))
            return;
          t4 = otherJoin.phis;
          t5 = t4.first;
          if (t5 == null)
            return;
          t4 = t4.last;
          if (t5 == null ? t4 != null : t5 !== t4)
            return;
          if (thenInput !== t5)
            return;
          t4 = t5.inputs;
          if (1 >= t4.length)
            return H.ioore(t4, 1);
          if (!J.$eq(elseInput, t4[1]))
            return;
        }
        if (this.hasAnyStatement$2(thenBlock, otherIf))
          return;
      } else {
        if (0 >= t3.length)
          return H.ioore(t3, 0);
        if (t3[0] !== thenBlock)
          return;
        if (this.hasAnyStatement$2(thenBlock, thenInput))
          return;
      }
      t2.add$1(0, t1);
      nextInstruction = phi.block.first;
      for (; !!J.getInterceptor(nextInstruction).$isHGoto;) {
        t1 = nextInstruction.get$block().successors;
        if (0 >= t1.length)
          return H.ioore(t1, 0);
        nextInstruction = J.get$first$ax(t1[0]);
      }
      t1 = phi.usedBy;
      t2 = t1.length;
      if (t2 === 1) {
        if (0 >= t2)
          return H.ioore(t1, 0);
        if (J.$eq(t1[0], nextInstruction)) {
          if (0 >= t1.length)
            return H.ioore(t1, 0);
          t1 = this.isSafeToGenerateAtUseSite$2(t1[0], phi);
        } else
          t1 = false;
      } else
        t1 = false;
      if (t1)
        this.generateAtUseSite.add$1(0, phi);
      t1 = elseInput.get$block();
      if (t1 == null ? elseBlock == null : t1 === elseBlock)
        this.generateAtUseSite.add$1(0, elseInput);
      t1 = thenInput.block;
      if (0 >= t3.length)
        return H.ioore(t3, 0);
      t3 = t3[0];
      if (t1 == null ? t3 == null : t1 === t3)
        this.generateAtUseSite.add$1(0, thenInput);
    }
  },
  SsaSimplifyInterceptors: {
    "^": "HBaseVisitor;name>,constantSystem,compiler<,work,graph,currentBlock",
    visitGraph$1: function(graph) {
      this.graph = graph;
      this.visitDominatorTree$1(graph);
    },
    visitBasicBlock$1: function(node) {
      var instruction, shouldRemove, next;
      this.currentBlock = node;
      instruction = node.first;
      for (; instruction != null; instruction = next) {
        shouldRemove = instruction.accept$1(0, this);
        next = instruction.next;
        if (shouldRemove === true)
          instruction.block.remove$1(0, instruction);
      }
    },
    visitInstruction$1: function(instruction) {
      return false;
    },
    visitInvoke$1: function(invoke) {
      var t1, t2, interceptor, constant;
      if (!invoke.get$isInterceptedCall())
        return false;
      t1 = invoke.inputs;
      t2 = t1.length;
      if (0 >= t2)
        return H.ioore(t1, 0);
      interceptor = t1[0];
      if (!J.getInterceptor(interceptor).$isHInterceptor)
        return false;
      if (1 >= t2)
        return H.ioore(t1, 1);
      constant = this.tryComputeConstantInterceptor$2(t1[1], interceptor.interceptedClasses);
      if (constant != null)
        invoke.changeUse$2(interceptor, constant);
      return false;
    },
    canUseSelfForInterceptor$2: function(receiver, interceptedClasses) {
      var t1, backend;
      t1 = this.compiler;
      backend = t1.backend;
      if (receiver.canBePrimitive$1(t1))
        return false;
      if (receiver.instructionType.get$isNullable() && interceptedClasses.contains$1(0, backend.get$jsNullClass()) === true)
        return false;
      t1 = new B.FlatTypeMask(backend.get$jsInterceptorClass(), 4).intersection$2(0, receiver.instructionType, t1);
      return t1.get$isEmpty(t1);
    },
    tryComputeConstantInterceptor$2: function(input, interceptedClasses) {
      var t1, backend, t2, constantInterceptor, element;
      if (J.$eq(input, this.graph.explicitReceiverParameter))
        return this.graph.thisInstruction;
      t1 = this.compiler;
      backend = t1.backend;
      if (input.get$instructionType().get$isNullable()) {
        t2 = input.instructionType;
        constantInterceptor = t2.get$isEmpty(t2) && input.instructionType.get$isNullable() ? backend.get$jsNullClass() : null;
      } else if (input.instructionType.containsOnlyInt$1(t1) && !input.instructionType.get$isNullable())
        constantInterceptor = backend.get$jsIntClass();
      else if (input.instructionType.containsOnlyDouble$1(t1) && !input.instructionType.get$isNullable())
        constantInterceptor = backend.get$jsDoubleClass();
      else if (input.instructionType.containsOnlyBool$1(t1) && !input.instructionType.get$isNullable())
        constantInterceptor = backend.get$jsBoolClass();
      else if (input.instructionType.containsOnlyString$1(t1) && !input.instructionType.get$isNullable())
        constantInterceptor = backend.get$jsStringClass();
      else if (input.isReadableArray$1(t1))
        constantInterceptor = backend.get$jsArrayClass();
      else if (input.instructionType.containsOnlyNum$1(t1) && !input.instructionType.get$isNullable() && interceptedClasses.contains$1(0, backend.get$jsIntClass()) !== true && interceptedClasses.contains$1(0, backend.jsDoubleClass) !== true)
        constantInterceptor = backend.get$jsNumberClass();
      else {
        element = input.instructionType.singleClass$1(t1);
        constantInterceptor = element != null && element.get$isNative() ? element : null;
      }
      if (constantInterceptor == null)
        return;
      if (constantInterceptor === this.work.element.get$enclosingClass() && this.graph.thisInstruction != null)
        return this.graph.thisInstruction;
      t2 = constantInterceptor.get$thisType();
      return this.graph.addConstant$2(new K.InterceptorConstant(t2), t1);
    },
    findDominator$1: function(instructions) {
      var result, t1, candidate, t2, current;
      t1 = H.setRuntimeTypeInfo(new H.ListIterator(instructions, instructions.length, 0, null), [H.getTypeArgumentByIndex(instructions, 0)]);
      $L1$0:
        while (true) {
          if (!t1.moveNext$0()) {
            result = null;
            break;
          }
          c$0:
            c$L1$0: {
              candidate = t1.__internal$_current;
              t2 = new H.ListIterator(instructions, instructions.length, 0, null);
              t2.$builtinTypeInfo = [H.getTypeArgumentByIndex(instructions, 0)];
              for (; t2.moveNext$0();) {
                current = t2.__internal$_current;
                if (!J.$eq(current, candidate) && !candidate.dominates$1(current))
                  break c$L1$0;
              }
              result = candidate;
              break;
            }
        }
      return result;
    },
    visitInterceptor$1: function(node) {
      var t1, backend, t2, dominator, t3, interceptedClasses, user, intercepted, t4, receiver, constantInterceptor, nullConstant, inputs, t5, t6, t7, interceptor, block;
      t1 = this.compiler;
      backend = t1.backend;
      t2 = node.usedBy;
      dominator = this.findDominator$1(t2);
      if (!!J.getInterceptor(dominator).$isHInvokeDynamic)
        if (dominator.isCallOnInterceptor$1(t1)) {
          t3 = dominator.inputs;
          if (0 >= t3.length)
            return H.ioore(t3, 0);
          t3 = node === t3[0];
        } else
          t3 = false;
      else
        t3 = false;
      if (t3) {
        interceptedClasses = backend.getInterceptedClassesOn$1(dominator.get$selector().name);
        if (interceptedClasses.contains$1(0, backend.jsNumberClass) === true)
          t3 = !(interceptedClasses.contains$1(0, backend.jsDoubleClass) === true || interceptedClasses.contains$1(0, backend.jsIntClass) === true);
        else
          t3 = false;
        if (t3)
          for (t3 = H.setRuntimeTypeInfo(new H.ListIterator(t2, t2.length, 0, null), [H.getTypeArgumentByIndex(t2, 0)]); t3.moveNext$0();) {
            user = t3.__internal$_current;
            if (!J.getInterceptor(user).$isHInvoke)
              continue;
            intercepted = backend.getInterceptedClassesOn$1(user.get$selector().name);
            if (intercepted.contains$1(0, backend.jsIntClass) === true)
              interceptedClasses.add$1(0, backend.jsIntClass);
            if (intercepted.contains$1(0, backend.jsDoubleClass) === true)
              interceptedClasses.add$1(0, backend.jsDoubleClass);
          }
      } else {
        interceptedClasses = P.LinkedHashSet_LinkedHashSet(null, null, null, O.ClassElement);
        for (t3 = H.setRuntimeTypeInfo(new H.ListIterator(t2, t2.length, 0, null), [H.getTypeArgumentByIndex(t2, 0)]); t3.moveNext$0();) {
          user = t3.__internal$_current;
          if (!!J.getInterceptor(user).$isHInvokeDynamic)
            if (user.isCallOnInterceptor$1(t1)) {
              t4 = user.inputs;
              if (0 >= t4.length)
                return H.ioore(t4, 0);
              t4 = node === t4[0];
            } else
              t4 = false;
          else
            t4 = false;
          if (t4)
            interceptedClasses.addAll$1(0, backend.getInterceptedClassesOn$1(user.get$selector().name));
          else {
            interceptedClasses.addAll$1(0, backend.get$_interceptedClasses());
            break;
          }
        }
      }
      t3 = node.inputs;
      if (0 >= t3.length)
        return H.ioore(t3, 0);
      receiver = t3[0];
      if (this.canUseSelfForInterceptor$2(receiver, interceptedClasses))
        return this.rewriteToUseSelfAsInterceptor$2(node, receiver);
      constantInterceptor = this.tryComputeConstantInterceptor$2(receiver, interceptedClasses);
      if (constantInterceptor != null) {
        node.block.rewrite$2(node, constantInterceptor);
        return false;
      }
      node.interceptedClasses = interceptedClasses;
      t3 = t2.length;
      if (t3 !== 1)
        return false;
      if (0 >= t3)
        return H.ioore(t2, 0);
      t2 = t2[0];
      if (!J.getInterceptor(t2).$isHInvokeDynamic)
        return false;
      t3 = t2.get$block().get$enclosingLoopHeader();
      t4 = node.block.get$enclosingLoopHeader();
      if (t3 == null ? t4 != null : t3 !== t4)
        return false;
      t3 = this.graph;
      t3.toString;
      nullConstant = t3.addConstant$2(t1.backend.get$constantSystem().createNull$0(), t1);
      inputs = P.List_List$from(t2.get$inputs(), true, B.HInstruction);
      if (0 >= inputs.length)
        return H.ioore(inputs, 0);
      inputs[0] = nullConstant;
      t1 = t2.get$selector();
      t3 = t2.instructionType;
      t4 = node.interceptedClasses;
      t5 = $.HInstruction_idCounter;
      if (typeof t5 !== "number")
        return t5.$add();
      $.HInstruction_idCounter = t5 + 1;
      t6 = H.setRuntimeTypeInfo([], [B.HInstruction]);
      t7 = B.InvokeDynamicSpecializer_lookupSpecializer(t1);
      interceptor = new B.HOneShotInterceptor(t4, t7, t1, null, null, null, t5, inputs, t6, null, null, null, new Z.SideEffects(0), false, t3);
      interceptor.HInstruction$2(inputs, t3);
      t6 = interceptor.sideEffects;
      t6.flags = (t6.flags | 7) >>> 0;
      t6.setDependsOnSomething$0();
      interceptor.HOneShotInterceptor$4(t1, inputs, t3, t4);
      interceptor.sourcePosition = t2.sourcePosition;
      interceptor.sourceElement = t2.get$sourceElement();
      block = t2.block;
      block.addAfter$2(t2, interceptor);
      block.rewrite$2(t2, interceptor);
      block.remove$1(0, t2);
      return true;
    },
    rewriteToUseSelfAsInterceptor$2: function(node, receiver) {
      var t1, user, t2;
      for (t1 = C.JSArray_methods.toList$0(node.usedBy), t1 = H.setRuntimeTypeInfo(new H.ListIterator(t1, t1.length, 0, null), [H.getTypeArgumentByIndex(t1, 0)]); t1.moveNext$0();) {
        user = t1.__internal$_current;
        if (!!J.getInterceptor(user).$isHIs)
          user.changeUse$2(node, receiver);
        else {
          t2 = user.get$inputs();
          if (1 >= t2.length)
            return H.ioore(t2, 1);
          user.changeUse$2(node, t2[1]);
        }
      }
      return false;
    },
    visitOneShotInterceptor$1: function(node) {
      var t1, constant, selector, t2, t3, t4, t5, instruction, inputs, block;
      t1 = node.inputs;
      if (1 >= t1.length)
        return H.ioore(t1, 1);
      constant = this.tryComputeConstantInterceptor$2(t1[1], node.interceptedClasses);
      if (constant == null)
        return false;
      selector = node.selector;
      t2 = selector.kind;
      if (t2 === C.SelectorKind_getter_0) {
        t2 = node.element;
        if (1 >= t1.length)
          return H.ioore(t1, 1);
        t1 = H.setRuntimeTypeInfo([constant, t1[1]], [B.HInstruction]);
        t3 = node.instructionType;
        t4 = $.HInstruction_idCounter;
        if (typeof t4 !== "number")
          return t4.$add();
        $.HInstruction_idCounter = t4 + 1;
        t5 = H.setRuntimeTypeInfo([], [B.HInstruction]);
        instruction = new B.HInvokeDynamicGetter(C.C_InvokeDynamicSpecializer, selector, t2, null, null, t4, t1, t5, null, null, null, new Z.SideEffects(0), false, t3);
        instruction.HInstruction$2(t1, t3);
        t1 = instruction.sideEffects;
        t1.flags = (t1.flags | 7) >>> 0;
        t1.setDependsOnSomething$0();
      } else if (t2 === C.SelectorKind_setter_1) {
        t2 = node.element;
        t3 = t1.length;
        if (1 >= t3)
          return H.ioore(t1, 1);
        t4 = t1[1];
        if (2 >= t3)
          return H.ioore(t1, 2);
        t1 = H.setRuntimeTypeInfo([constant, t4, t1[2]], [B.HInstruction]);
        t4 = node.instructionType;
        t3 = $.HInstruction_idCounter;
        if (typeof t3 !== "number")
          return t3.$add();
        $.HInstruction_idCounter = t3 + 1;
        t5 = H.setRuntimeTypeInfo([], [B.HInstruction]);
        instruction = new B.HInvokeDynamicSetter(C.C_InvokeDynamicSpecializer, selector, t2, null, null, t3, t1, t5, null, null, null, new Z.SideEffects(0), false, t4);
        instruction.HInstruction$2(t1, t4);
        t1 = instruction.sideEffects;
        t1.flags = (t1.flags | 7) >>> 0;
        t1.setDependsOnSomething$0();
      } else {
        inputs = P.List_List$from(t1, true, B.HInstruction);
        if (0 >= inputs.length)
          return H.ioore(inputs, 0);
        inputs[0] = constant;
        t1 = node.instructionType;
        t2 = $.HInstruction_idCounter;
        if (typeof t2 !== "number")
          return t2.$add();
        $.HInstruction_idCounter = t2 + 1;
        t3 = H.setRuntimeTypeInfo([], [B.HInstruction]);
        t4 = B.InvokeDynamicSpecializer_lookupSpecializer(selector);
        instruction = new B.HInvokeDynamicMethod(t4, selector, null, null, null, t2, inputs, t3, null, null, null, new Z.SideEffects(0), false, t1);
        instruction.HInstruction$2(inputs, t1);
        t1 = instruction.sideEffects;
        t1.flags = (t1.flags | 7) >>> 0;
        t1.setDependsOnSomething$0();
      }
      block = node.block;
      block.addAfter$2(node, instruction);
      block.rewrite$2(node, instruction);
      return true;
    }
  },
  InvokeDynamicSpecializer: {
    "^": "Object;",
    computeTypeFromInputTypes$2: function(instruction, compiler) {
      var selector = instruction.get$selector();
      return B.TypeMaskFactory_fromInferredType(compiler.typesTask.getGuaranteedTypeOfSelector$1(selector), compiler);
    },
    tryConvertToBuiltin$2: function(instruction, compiler) {
      return;
    },
    operation$1: function(constantSystem) {
      return;
    },
    static: {InvokeDynamicSpecializer_lookupSpecializer: function(selector) {
        var t1 = selector.kind;
        if (t1 === C.SelectorKind_index_4)
          return selector.name === "[]" ? C.C_IndexSpecializer : C.C_IndexAssignSpecializer;
        else if (t1 === C.SelectorKind_operator_3) {
          t1 = selector.name;
          if (t1 === "unary-")
            return C.C_UnaryNegateSpecializer;
          else if (t1 === "~")
            return C.C_BitNotSpecializer;
          else if (t1 === "+")
            return C.C_AddSpecializer;
          else if (t1 === "-")
            return C.C_SubtractSpecializer;
          else if (t1 === "*")
            return C.C_MultiplySpecializer;
          else if (t1 === "/")
            return C.C_DivideSpecializer;
          else if (t1 === "~/")
            return C.C_TruncatingDivideSpecializer;
          else if (t1 === "%")
            return C.C_ModuloSpecializer;
          else if (t1 === ">>")
            return C.C_ShiftRightSpecializer;
          else if (t1 === "<<")
            return C.C_ShiftLeftSpecializer;
          else if (t1 === "&")
            return C.C_BitAndSpecializer;
          else if (t1 === "|")
            return C.C_BitOrSpecializer;
          else if (t1 === "^")
            return C.C_BitXorSpecializer;
          else if (t1 === "==")
            return C.C_EqualsSpecializer;
          else if (t1 === "<")
            return C.C_LessSpecializer;
          else if (t1 === "<=")
            return C.C_LessEqualSpecializer;
          else if (t1 === ">")
            return C.C_GreaterSpecializer;
          else if (t1 === ">=")
            return C.C_GreaterEqualSpecializer;
        }
        return C.C_InvokeDynamicSpecializer;
      }}
  },
  IndexAssignSpecializer: {
    "^": "InvokeDynamicSpecializer;",
    tryConvertToBuiltin$2: function(instruction, compiler) {
      var t1, t2, t3, t4, t5, t6;
      t1 = instruction.inputs;
      if (1 >= t1.length)
        return H.ioore(t1, 1);
      if (t1[1].isMutableIndexable$1(compiler)) {
        if (2 >= t1.length)
          return H.ioore(t1, 2);
        if (!t1[2].isInteger$1(compiler) && compiler.enableTypeAssertions)
          return;
        t2 = t1.length;
        if (1 >= t2)
          return H.ioore(t1, 1);
        t3 = t1[1];
        if (2 >= t2)
          return H.ioore(t1, 2);
        t4 = t1[2];
        if (3 >= t2)
          return H.ioore(t1, 3);
        t1 = t1[3];
        t2 = instruction.selector;
        t5 = H.setRuntimeTypeInfo([t3, t4, t1], [B.HInstruction]);
        t6 = $.HInstruction_idCounter;
        if (typeof t6 !== "number")
          return t6.$add();
        $.HInstruction_idCounter = t6 + 1;
        t6 = new B.HIndexAssign(t2, null, null, t6, t5, H.setRuntimeTypeInfo([], [B.HInstruction]), null, null, null, new Z.SideEffects(0), false, C.FlatTypeMask_null_0);
        t6.HInstruction$2(t5, C.FlatTypeMask_null_0);
        t6.HIndexAssign$4(t3, t4, t1, t2);
        return t6;
      }
      return;
    }
  },
  IndexSpecializer: {
    "^": "InvokeDynamicSpecializer;",
    tryConvertToBuiltin$2: function(instruction, compiler) {
      var t1, t2, refined, type, t3, t4, t5;
      t1 = instruction.inputs;
      if (1 >= t1.length)
        return H.ioore(t1, 1);
      if (!t1[1].isIndexablePrimitive$1(compiler))
        return;
      if (2 >= t1.length)
        return H.ioore(t1, 2);
      if (!t1[2].isInteger$1(compiler) && compiler.enableTypeAssertions)
        return;
      if (instruction.isCallOnInterceptor$1(compiler)) {
        if (1 >= t1.length)
          return H.ioore(t1, 1);
        t2 = t1[1];
      } else {
        if (0 >= t1.length)
          return H.ioore(t1, 0);
        t2 = t1[0];
      }
      refined = Z.TypedSelector_TypedSelector(t2.get$instructionType(), instruction.selector, compiler);
      type = B.TypeMaskFactory_fromInferredType(compiler.typesTask.getGuaranteedTypeOfSelector$1(refined), compiler);
      t2 = t1.length;
      if (1 >= t2)
        return H.ioore(t1, 1);
      t3 = t1[1];
      if (2 >= t2)
        return H.ioore(t1, 2);
      t1 = t1[2];
      t2 = instruction.selector;
      t4 = H.setRuntimeTypeInfo([t3, t1], [B.HInstruction]);
      t5 = $.HInstruction_idCounter;
      if (typeof t5 !== "number")
        return t5.$add();
      $.HInstruction_idCounter = t5 + 1;
      t5 = new B.HIndex(t2, null, null, t5, t4, H.setRuntimeTypeInfo([], [B.HInstruction]), null, null, null, new Z.SideEffects(0), false, type);
      t5.HInstruction$2(t4, type);
      t5.HIndex$4(t3, t1, t2, type);
      return t5;
    }
  },
  BitNotSpecializer: {
    "^": "InvokeDynamicSpecializer;",
    operation$1: function(constantSystem) {
      return constantSystem.get$bitNot();
    },
    computeTypeFromInputTypes$2: function(instruction, compiler) {
      var backend, t1;
      backend = compiler.backend;
      t1 = instruction.get$inputs();
      if (1 >= t1.length)
        return H.ioore(t1, 1);
      if (t1[1].isPrimitiveOrNull$1(compiler))
        return backend.compiler.typesTask.get$uint32Type();
      return B.InvokeDynamicSpecializer.prototype.computeTypeFromInputTypes$2.call(this, instruction, compiler);
    },
    tryConvertToBuiltin$2: function(instruction, compiler) {
      var t1, input, t2, t3, t4;
      t1 = instruction.inputs;
      if (1 >= t1.length)
        return H.ioore(t1, 1);
      input = t1[1];
      if (input.get$instructionType().containsOnlyNum$1(compiler) && !input.instructionType.get$isNullable()) {
        t1 = instruction.selector;
        t2 = this.computeTypeFromInputTypes$2(instruction, compiler);
        t3 = H.setRuntimeTypeInfo([input], [B.HInstruction]);
        t4 = $.HInstruction_idCounter;
        if (typeof t4 !== "number")
          return t4.$add();
        $.HInstruction_idCounter = t4 + 1;
        t4 = new B.HBitNot(t1, null, null, t4, t3, H.setRuntimeTypeInfo([], [B.HInstruction]), null, null, null, new Z.SideEffects(0), false, t2);
        t4.HInstruction$2(t3, t2);
        t4.HInvokeUnary$3(input, t1, t2);
        return t4;
      }
      return;
    }
  },
  UnaryNegateSpecializer: {
    "^": "InvokeDynamicSpecializer;",
    operation$1: function(constantSystem) {
      return constantSystem.get$negate();
    },
    computeTypeFromInputTypes$2: function(instruction, compiler) {
      var t1, operandType;
      t1 = instruction.get$inputs();
      if (1 >= t1.length)
        return H.ioore(t1, 1);
      operandType = t1[1].get$instructionType();
      t1 = instruction.get$inputs();
      if (1 >= t1.length)
        return H.ioore(t1, 1);
      if (t1[1].isNumberOrNull$1(compiler))
        return operandType;
      return B.InvokeDynamicSpecializer.prototype.computeTypeFromInputTypes$2.call(this, instruction, compiler);
    },
    tryConvertToBuiltin$2: function(instruction, compiler) {
      var t1, input, t2, t3, t4;
      t1 = instruction.inputs;
      if (1 >= t1.length)
        return H.ioore(t1, 1);
      input = t1[1];
      if (input.get$instructionType().containsOnlyNum$1(compiler) && !input.instructionType.get$isNullable()) {
        t1 = instruction.selector;
        t2 = input.instructionType;
        t3 = H.setRuntimeTypeInfo([input], [B.HInstruction]);
        t4 = $.HInstruction_idCounter;
        if (typeof t4 !== "number")
          return t4.$add();
        $.HInstruction_idCounter = t4 + 1;
        t4 = new B.HNegate(t1, null, null, t4, t3, H.setRuntimeTypeInfo([], [B.HInstruction]), null, null, null, new Z.SideEffects(0), false, t2);
        t4.HInstruction$2(t3, t2);
        t4.HInvokeUnary$3(input, t1, t2);
        return t4;
      }
      return;
    }
  },
  BinaryArithmeticSpecializer: {
    "^": "InvokeDynamicSpecializer;",
    computeTypeFromInputTypes$2: function(instruction, compiler) {
      var t1, left, right, backend;
      t1 = instruction.get$inputs();
      if (1 >= t1.length)
        return H.ioore(t1, 1);
      left = t1[1];
      t1 = instruction.get$inputs();
      if (2 >= t1.length)
        return H.ioore(t1, 2);
      right = t1[2];
      backend = compiler.backend;
      if (left.get$instructionType().containsOnlyInt$1(compiler) && right.get$instructionType().containsOnlyInt$1(compiler))
        return backend.compiler.typesTask.get$intType();
      if (left.instructionType.containsOnlyNum$1(compiler)) {
        if (left.instructionType.containsOnlyDouble$1(compiler) || right.get$instructionType().containsOnlyDouble$1(compiler))
          return backend.compiler.typesTask.get$doubleType();
        return backend.compiler.typesTask.get$numType();
      }
      return B.InvokeDynamicSpecializer.prototype.computeTypeFromInputTypes$2.call(this, instruction, compiler);
    },
    isBuiltin$2: function(instruction, compiler) {
      var t1 = instruction.inputs;
      if (1 >= t1.length)
        return H.ioore(t1, 1);
      if (t1[1].isNumber$1(compiler)) {
        if (2 >= t1.length)
          return H.ioore(t1, 2);
        t1 = t1[2].isNumber$1(compiler);
      } else
        t1 = false;
      return t1;
    },
    tryConvertToBuiltin$2: function(instruction, compiler) {
      var builtin;
      if (this.isBuiltin$2(instruction, compiler)) {
        builtin = this.newBuiltinVariant$2(instruction, compiler);
        if (builtin != null)
          return builtin;
        this.clearAllSideEffects$1(instruction);
      }
      return;
    },
    clearAllSideEffects$1: function(instruction) {
      instruction.sideEffects.clearAllSideEffects$0();
      instruction.sideEffects.clearAllDependencies$0();
      instruction._useGvn = true;
    },
    inputsArePositiveIntegers$2: function(instruction, compiler) {
      var t1, left, right;
      t1 = instruction.get$inputs();
      if (1 >= t1.length)
        return H.ioore(t1, 1);
      left = t1[1];
      t1 = instruction.get$inputs();
      if (2 >= t1.length)
        return H.ioore(t1, 2);
      right = t1[2];
      return left.isPositiveIntegerOrNull$1(compiler) && right.isPositiveIntegerOrNull$1(compiler);
    },
    renameToOptimizedSelector$3: function($name, selector, compiler) {
      var newSelector;
      if (selector.name === $name)
        return selector;
      newSelector = Z.Selector_Selector(C.SelectorKind_call_2, $name, compiler.backend.get$interceptorsLibrary(), selector.argumentCount, null);
      return selector.get$mask() == null ? newSelector : Z.TypedSelector_TypedSelector(selector.get$mask(), newSelector, compiler);
    }
  },
  AddSpecializer: {
    "^": "BinaryArithmeticSpecializer;",
    computeTypeFromInputTypes$2: function(instruction, compiler) {
      if (this.inputsArePositiveIntegers$2(instruction, compiler))
        return compiler.backend.compiler.typesTask.get$positiveIntType();
      return B.BinaryArithmeticSpecializer.prototype.computeTypeFromInputTypes$2.call(this, instruction, compiler);
    },
    operation$1: function(constantSystem) {
      return constantSystem.get$add(constantSystem);
    },
    newBuiltinVariant$2: function(instruction, compiler) {
      var t1, t2, t3, t4, t5, t6;
      t1 = instruction.inputs;
      t2 = t1.length;
      if (1 >= t2)
        return H.ioore(t1, 1);
      t3 = t1[1];
      if (2 >= t2)
        return H.ioore(t1, 2);
      t1 = t1[2];
      t2 = instruction.selector;
      t4 = this.computeTypeFromInputTypes$2(instruction, compiler);
      t5 = H.setRuntimeTypeInfo([t3, t1], [B.HInstruction]);
      t6 = $.HInstruction_idCounter;
      if (typeof t6 !== "number")
        return t6.$add();
      $.HInstruction_idCounter = t6 + 1;
      t6 = new B.HAdd(t2, null, null, t6, t5, H.setRuntimeTypeInfo([], [B.HInstruction]), null, null, null, new Z.SideEffects(0), false, t4);
      t6.HInstruction$2(t5, t4);
      t6.HInvokeBinary$4(t3, t1, t2, t4);
      return t6;
    }
  },
  DivideSpecializer: {
    "^": "BinaryArithmeticSpecializer;",
    operation$1: function(constantSystem) {
      return constantSystem.get$divide();
    },
    computeTypeFromInputTypes$2: function(instruction, compiler) {
      var t1, left, backend;
      t1 = instruction.get$inputs();
      if (1 >= t1.length)
        return H.ioore(t1, 1);
      left = t1[1];
      backend = compiler.backend;
      if (left.get$instructionType().containsOnlyNum$1(compiler))
        return backend.compiler.typesTask.get$doubleType();
      return B.BinaryArithmeticSpecializer.prototype.computeTypeFromInputTypes$2.call(this, instruction, compiler);
    },
    newBuiltinVariant$2: function(instruction, compiler) {
      var backend, t1, t2, t3, t4, t5, t6;
      backend = compiler.backend;
      t1 = instruction.inputs;
      t2 = t1.length;
      if (1 >= t2)
        return H.ioore(t1, 1);
      t3 = t1[1];
      if (2 >= t2)
        return H.ioore(t1, 2);
      t1 = t1[2];
      t2 = instruction.selector;
      t4 = backend.compiler.typesTask.get$doubleType();
      t5 = H.setRuntimeTypeInfo([t3, t1], [B.HInstruction]);
      t6 = $.HInstruction_idCounter;
      if (typeof t6 !== "number")
        return t6.$add();
      $.HInstruction_idCounter = t6 + 1;
      t6 = new B.HDivide(t2, null, null, t6, t5, H.setRuntimeTypeInfo([], [B.HInstruction]), null, null, null, new Z.SideEffects(0), false, t4);
      t6.HInstruction$2(t5, t4);
      t6.HInvokeBinary$4(t3, t1, t2, t4);
      return t6;
    }
  },
  ModuloSpecializer: {
    "^": "BinaryArithmeticSpecializer;",
    computeTypeFromInputTypes$2: function(instruction, compiler) {
      if (this.inputsArePositiveIntegers$2(instruction, compiler))
        return compiler.backend.compiler.typesTask.get$positiveIntType();
      return B.BinaryArithmeticSpecializer.prototype.computeTypeFromInputTypes$2.call(this, instruction, compiler);
    },
    operation$1: function(constantSystem) {
      return constantSystem.get$modulo();
    },
    newBuiltinVariant$2: function(instruction, compiler) {
      return;
    }
  },
  MultiplySpecializer: {
    "^": "BinaryArithmeticSpecializer;",
    operation$1: function(constantSystem) {
      return constantSystem.get$multiply();
    },
    computeTypeFromInputTypes$2: function(instruction, compiler) {
      if (this.inputsArePositiveIntegers$2(instruction, compiler))
        return compiler.backend.compiler.typesTask.get$positiveIntType();
      return B.BinaryArithmeticSpecializer.prototype.computeTypeFromInputTypes$2.call(this, instruction, compiler);
    },
    newBuiltinVariant$2: function(instruction, compiler) {
      var t1, t2, t3, t4, t5, t6;
      t1 = instruction.inputs;
      t2 = t1.length;
      if (1 >= t2)
        return H.ioore(t1, 1);
      t3 = t1[1];
      if (2 >= t2)
        return H.ioore(t1, 2);
      t1 = t1[2];
      t2 = instruction.selector;
      t4 = this.computeTypeFromInputTypes$2(instruction, compiler);
      t5 = H.setRuntimeTypeInfo([t3, t1], [B.HInstruction]);
      t6 = $.HInstruction_idCounter;
      if (typeof t6 !== "number")
        return t6.$add();
      $.HInstruction_idCounter = t6 + 1;
      t6 = new B.HMultiply(t2, null, null, t6, t5, H.setRuntimeTypeInfo([], [B.HInstruction]), null, null, null, new Z.SideEffects(0), false, t4);
      t6.HInstruction$2(t5, t4);
      t6.HInvokeBinary$4(t3, t1, t2, t4);
      return t6;
    }
  },
  SubtractSpecializer: {
    "^": "BinaryArithmeticSpecializer;",
    operation$1: function(constantSystem) {
      return constantSystem.get$subtract();
    },
    newBuiltinVariant$2: function(instruction, compiler) {
      var t1, t2, t3, t4, t5, t6;
      t1 = instruction.inputs;
      t2 = t1.length;
      if (1 >= t2)
        return H.ioore(t1, 1);
      t3 = t1[1];
      if (2 >= t2)
        return H.ioore(t1, 2);
      t1 = t1[2];
      t2 = instruction.selector;
      t4 = this.computeTypeFromInputTypes$2(instruction, compiler);
      t5 = H.setRuntimeTypeInfo([t3, t1], [B.HInstruction]);
      t6 = $.HInstruction_idCounter;
      if (typeof t6 !== "number")
        return t6.$add();
      $.HInstruction_idCounter = t6 + 1;
      t6 = new B.HSubtract(t2, null, null, t6, t5, H.setRuntimeTypeInfo([], [B.HInstruction]), null, null, null, new Z.SideEffects(0), false, t4);
      t6.HInstruction$2(t5, t4);
      t6.HInvokeBinary$4(t3, t1, t2, t4);
      return t6;
    }
  },
  TruncatingDivideSpecializer: {
    "^": "BinaryArithmeticSpecializer;",
    operation$1: function(constantSystem) {
      return constantSystem.get$truncatingDivide();
    },
    computeTypeFromInputTypes$2: function(instruction, compiler) {
      if (this.inputsArePositiveIntegers$2(instruction, compiler))
        return compiler.backend.compiler.typesTask.get$positiveIntType();
      return B.BinaryArithmeticSpecializer.prototype.computeTypeFromInputTypes$2.call(this, instruction, compiler);
    },
    isNotZero$2: function(instruction, compiler) {
      var intConstant;
      if (!instruction.isConstantInteger$0())
        return false;
      intConstant = instruction.get$constant();
      return intConstant.get$value(intConstant) !== 0;
    },
    tryConvertToBuiltin$2: function(instruction, compiler) {
      var t1, t2, left, right;
      t1 = instruction.inputs;
      t2 = t1.length;
      if (1 >= t2)
        return H.ioore(t1, 1);
      left = t1[1];
      if (2 >= t2)
        return H.ioore(t1, 2);
      right = t1[2];
      if (this.isBuiltin$2(instruction, compiler)) {
        if (right.isPositiveInteger$1(compiler) && this.isNotZero$2(right, compiler)) {
          if (left.isUInt31$1(compiler))
            return this.newBuiltinVariant$2(instruction, compiler);
          instruction.selector = this.renameToOptimizedSelector$3("_tdivFast", instruction.selector, compiler);
        }
        this.clearAllSideEffects$1(instruction);
      }
      return;
    },
    newBuiltinVariant$2: function(instruction, compiler) {
      var t1, t2, t3, t4, t5, t6;
      t1 = instruction.inputs;
      t2 = t1.length;
      if (1 >= t2)
        return H.ioore(t1, 1);
      t3 = t1[1];
      if (2 >= t2)
        return H.ioore(t1, 2);
      t1 = t1[2];
      t2 = instruction.selector;
      t4 = this.computeTypeFromInputTypes$2(instruction, compiler);
      t5 = H.setRuntimeTypeInfo([t3, t1], [B.HInstruction]);
      t6 = $.HInstruction_idCounter;
      if (typeof t6 !== "number")
        return t6.$add();
      $.HInstruction_idCounter = t6 + 1;
      t6 = new B.HTruncatingDivide(t2, null, null, t6, t5, H.setRuntimeTypeInfo([], [B.HInstruction]), null, null, null, new Z.SideEffects(0), false, t4);
      t6.HInstruction$2(t5, t4);
      t6.HInvokeBinary$4(t3, t1, t2, t4);
      return t6;
    }
  },
  BinaryBitOpSpecializer: {
    "^": "BinaryArithmeticSpecializer;",
    computeTypeFromInputTypes$2: function(instruction, compiler) {
      var t1, left, backend;
      t1 = instruction.get$inputs();
      if (1 >= t1.length)
        return H.ioore(t1, 1);
      left = t1[1];
      backend = compiler.backend;
      if (left.isPrimitiveOrNull$1(compiler))
        return backend.compiler.typesTask.get$uint32Type();
      return B.BinaryArithmeticSpecializer.prototype.computeTypeFromInputTypes$2.call(this, instruction, compiler);
    },
    argumentLessThan32$1: function(instruction) {
      var intConstant, count;
      if (!instruction.isConstantInteger$0())
        return false;
      intConstant = instruction.get$constant();
      count = intConstant.get$value(intConstant);
      if (typeof count !== "number")
        return count.$ge();
      return count >= 0 && count <= 31;
    },
    isPositive$2: [function(instruction, compiler) {
      return instruction.isPositiveInteger$1(compiler);
    }, "call$2", "get$isPositive", 4, 0, 286]
  },
  ShiftLeftSpecializer: {
    "^": "BinaryBitOpSpecializer;",
    operation$1: function(constantSystem) {
      return constantSystem.get$shiftLeft();
    },
    tryConvertToBuiltin$2: function(instruction, compiler) {
      var t1, t2, left, right;
      t1 = instruction.inputs;
      t2 = t1.length;
      if (1 >= t2)
        return H.ioore(t1, 1);
      left = t1[1];
      if (2 >= t2)
        return H.ioore(t1, 2);
      right = t1[2];
      if (left.get$instructionType().containsOnlyNum$1(compiler) && !left.instructionType.get$isNullable()) {
        if (this.argumentLessThan32$1(right))
          return this.newBuiltinVariant$2(instruction, compiler);
        this.clearAllSideEffects$1(instruction);
        if (right.isPositiveInteger$1(compiler))
          instruction.selector = this.renameToOptimizedSelector$3("_shlPositive", instruction.selector, compiler);
      }
      return;
    },
    newBuiltinVariant$2: function(instruction, compiler) {
      var t1, t2, t3, t4, t5, t6;
      t1 = instruction.inputs;
      t2 = t1.length;
      if (1 >= t2)
        return H.ioore(t1, 1);
      t3 = t1[1];
      if (2 >= t2)
        return H.ioore(t1, 2);
      t1 = t1[2];
      t2 = instruction.selector;
      t4 = this.computeTypeFromInputTypes$2(instruction, compiler);
      t5 = H.setRuntimeTypeInfo([t3, t1], [B.HInstruction]);
      t6 = $.HInstruction_idCounter;
      if (typeof t6 !== "number")
        return t6.$add();
      $.HInstruction_idCounter = t6 + 1;
      t6 = new B.HShiftLeft(t2, null, null, t6, t5, H.setRuntimeTypeInfo([], [B.HInstruction]), null, null, null, new Z.SideEffects(0), false, t4);
      t6.HInstruction$2(t5, t4);
      t6.HInvokeBinary$4(t3, t1, t2, t4);
      return t6;
    }
  },
  ShiftRightSpecializer: {
    "^": "BinaryBitOpSpecializer;",
    computeTypeFromInputTypes$2: function(instruction, compiler) {
      var t1, left, backend;
      t1 = instruction.get$inputs();
      if (1 >= t1.length)
        return H.ioore(t1, 1);
      left = t1[1];
      t1 = instruction.get$inputs();
      if (2 >= t1.length)
        return H.ioore(t1, 2);
      t1[2];
      backend = compiler.backend;
      if (!left.get$instructionType().get$isNullable() && left.instructionType.satisfies$2(backend.get$jsUInt32Class(), compiler))
        return left.instructionType;
      return B.BinaryBitOpSpecializer.prototype.computeTypeFromInputTypes$2.call(this, instruction, compiler);
    },
    tryConvertToBuiltin$2: function(instruction, compiler) {
      var t1, t2, left, right;
      t1 = instruction.inputs;
      t2 = t1.length;
      if (1 >= t2)
        return H.ioore(t1, 1);
      left = t1[1];
      if (2 >= t2)
        return H.ioore(t1, 2);
      right = t1[2];
      if (left.get$instructionType().containsOnlyNum$1(compiler) && !left.instructionType.get$isNullable()) {
        if (this.argumentLessThan32$1(right) && left.isPositiveInteger$1(compiler))
          return this.newBuiltinVariant$2(instruction, compiler);
        this.clearAllSideEffects$1(instruction);
        if (right.isPositiveInteger$1(compiler) && left.isPositiveInteger$1(compiler))
          instruction.selector = this.renameToOptimizedSelector$3("_shrBothPositive", instruction.selector, compiler);
        else if (left.isPositiveInteger$1(compiler) && right.instructionType.containsOnlyNum$1(compiler) && !right.instructionType.get$isNullable())
          instruction.selector = this.renameToOptimizedSelector$3("_shrReceiverPositive", instruction.selector, compiler);
        else if (right.isPositiveInteger$1(compiler))
          instruction.selector = this.renameToOptimizedSelector$3("_shrOtherPositive", instruction.selector, compiler);
      }
      return;
    },
    newBuiltinVariant$2: function(instruction, compiler) {
      var t1, t2, t3, t4, t5, t6;
      t1 = instruction.inputs;
      t2 = t1.length;
      if (1 >= t2)
        return H.ioore(t1, 1);
      t3 = t1[1];
      if (2 >= t2)
        return H.ioore(t1, 2);
      t1 = t1[2];
      t2 = instruction.selector;
      t4 = this.computeTypeFromInputTypes$2(instruction, compiler);
      t5 = H.setRuntimeTypeInfo([t3, t1], [B.HInstruction]);
      t6 = $.HInstruction_idCounter;
      if (typeof t6 !== "number")
        return t6.$add();
      $.HInstruction_idCounter = t6 + 1;
      t6 = new B.HShiftRight(t2, null, null, t6, t5, H.setRuntimeTypeInfo([], [B.HInstruction]), null, null, null, new Z.SideEffects(0), false, t4);
      t6.HInstruction$2(t5, t4);
      t6.HInvokeBinary$4(t3, t1, t2, t4);
      return t6;
    },
    operation$1: function(constantSystem) {
      return constantSystem.get$shiftRight();
    }
  },
  BitOrSpecializer: {
    "^": "BinaryBitOpSpecializer;",
    operation$1: function(constantSystem) {
      return constantSystem.get$bitOr();
    },
    computeTypeFromInputTypes$2: function(instruction, compiler) {
      var t1, left, right, backend;
      t1 = instruction.get$inputs();
      if (1 >= t1.length)
        return H.ioore(t1, 1);
      left = t1[1];
      t1 = instruction.get$inputs();
      if (2 >= t1.length)
        return H.ioore(t1, 2);
      right = t1[2];
      backend = compiler.backend;
      if (left.isUInt31$1(compiler) && right.isUInt31$1(compiler))
        return backend.compiler.typesTask.get$uint31Type();
      return B.BinaryBitOpSpecializer.prototype.computeTypeFromInputTypes$2.call(this, instruction, compiler);
    },
    newBuiltinVariant$2: function(instruction, compiler) {
      var t1, t2, t3, t4, t5, t6;
      t1 = instruction.inputs;
      t2 = t1.length;
      if (1 >= t2)
        return H.ioore(t1, 1);
      t3 = t1[1];
      if (2 >= t2)
        return H.ioore(t1, 2);
      t1 = t1[2];
      t2 = instruction.selector;
      t4 = this.computeTypeFromInputTypes$2(instruction, compiler);
      t5 = H.setRuntimeTypeInfo([t3, t1], [B.HInstruction]);
      t6 = $.HInstruction_idCounter;
      if (typeof t6 !== "number")
        return t6.$add();
      $.HInstruction_idCounter = t6 + 1;
      t6 = new B.HBitOr(t2, null, null, t6, t5, H.setRuntimeTypeInfo([], [B.HInstruction]), null, null, null, new Z.SideEffects(0), false, t4);
      t6.HInstruction$2(t5, t4);
      t6.HInvokeBinary$4(t3, t1, t2, t4);
      return t6;
    }
  },
  BitAndSpecializer: {
    "^": "BinaryBitOpSpecializer;",
    operation$1: function(constantSystem) {
      return constantSystem.get$bitAnd();
    },
    computeTypeFromInputTypes$2: function(instruction, compiler) {
      var t1, left, right, backend;
      t1 = instruction.get$inputs();
      if (1 >= t1.length)
        return H.ioore(t1, 1);
      left = t1[1];
      t1 = instruction.get$inputs();
      if (2 >= t1.length)
        return H.ioore(t1, 2);
      right = t1[2];
      backend = compiler.backend;
      if (left.isUInt31$1(compiler) || right.isUInt31$1(compiler))
        return backend.compiler.typesTask.get$uint31Type();
      return B.BinaryBitOpSpecializer.prototype.computeTypeFromInputTypes$2.call(this, instruction, compiler);
    },
    newBuiltinVariant$2: function(instruction, compiler) {
      var t1, t2, t3, t4, t5, t6;
      t1 = instruction.inputs;
      t2 = t1.length;
      if (1 >= t2)
        return H.ioore(t1, 1);
      t3 = t1[1];
      if (2 >= t2)
        return H.ioore(t1, 2);
      t1 = t1[2];
      t2 = instruction.selector;
      t4 = this.computeTypeFromInputTypes$2(instruction, compiler);
      t5 = H.setRuntimeTypeInfo([t3, t1], [B.HInstruction]);
      t6 = $.HInstruction_idCounter;
      if (typeof t6 !== "number")
        return t6.$add();
      $.HInstruction_idCounter = t6 + 1;
      t6 = new B.HBitAnd(t2, null, null, t6, t5, H.setRuntimeTypeInfo([], [B.HInstruction]), null, null, null, new Z.SideEffects(0), false, t4);
      t6.HInstruction$2(t5, t4);
      t6.HInvokeBinary$4(t3, t1, t2, t4);
      return t6;
    }
  },
  BitXorSpecializer: {
    "^": "BinaryBitOpSpecializer;",
    operation$1: function(constantSystem) {
      return constantSystem.get$bitXor();
    },
    computeTypeFromInputTypes$2: function(instruction, compiler) {
      var t1, left, right, backend;
      t1 = instruction.get$inputs();
      if (1 >= t1.length)
        return H.ioore(t1, 1);
      left = t1[1];
      t1 = instruction.get$inputs();
      if (2 >= t1.length)
        return H.ioore(t1, 2);
      right = t1[2];
      backend = compiler.backend;
      if (left.isUInt31$1(compiler) && right.isUInt31$1(compiler))
        return backend.compiler.typesTask.get$uint31Type();
      return B.BinaryBitOpSpecializer.prototype.computeTypeFromInputTypes$2.call(this, instruction, compiler);
    },
    newBuiltinVariant$2: function(instruction, compiler) {
      var t1, t2, t3, t4, t5, t6;
      t1 = instruction.inputs;
      t2 = t1.length;
      if (1 >= t2)
        return H.ioore(t1, 1);
      t3 = t1[1];
      if (2 >= t2)
        return H.ioore(t1, 2);
      t1 = t1[2];
      t2 = instruction.selector;
      t4 = this.computeTypeFromInputTypes$2(instruction, compiler);
      t5 = H.setRuntimeTypeInfo([t3, t1], [B.HInstruction]);
      t6 = $.HInstruction_idCounter;
      if (typeof t6 !== "number")
        return t6.$add();
      $.HInstruction_idCounter = t6 + 1;
      t6 = new B.HBitXor(t2, null, null, t6, t5, H.setRuntimeTypeInfo([], [B.HInstruction]), null, null, null, new Z.SideEffects(0), false, t4);
      t6.HInstruction$2(t5, t4);
      t6.HInvokeBinary$4(t3, t1, t2, t4);
      return t6;
    }
  },
  RelationalSpecializer: {
    "^": "InvokeDynamicSpecializer;",
    computeTypeFromInputTypes$2: function(instruction, compiler) {
      var backend, t1;
      backend = compiler.backend;
      t1 = instruction.get$inputs();
      if (1 >= t1.length)
        return H.ioore(t1, 1);
      if (t1[1].isPrimitiveOrNull$1(compiler))
        return backend.compiler.typesTask.get$boolType();
      return B.InvokeDynamicSpecializer.prototype.computeTypeFromInputTypes$2.call(this, instruction, compiler);
    },
    tryConvertToBuiltin$2: function(instruction, compiler) {
      var t1, t2, left, right;
      t1 = instruction.inputs;
      t2 = t1.length;
      if (1 >= t2)
        return H.ioore(t1, 1);
      left = t1[1];
      if (2 >= t2)
        return H.ioore(t1, 2);
      right = t1[2];
      if (left.get$instructionType().containsOnlyNum$1(compiler) && !left.instructionType.get$isNullable() && right.get$instructionType().containsOnlyNum$1(compiler) && !right.instructionType.get$isNullable())
        return this.newBuiltinVariant$2(instruction, compiler);
      return;
    }
  },
  EqualsSpecializer: {
    "^": "RelationalSpecializer;",
    tryConvertToBuiltin$2: function(instruction, compiler) {
      var t1, t2, left, right, instructionType, selector, world, backend;
      t1 = instruction.inputs;
      t2 = t1.length;
      if (1 >= t2)
        return H.ioore(t1, 1);
      left = t1[1];
      if (2 >= t2)
        return H.ioore(t1, 2);
      right = t1[2];
      instructionType = left.get$instructionType();
      if (right.isConstantNull$0() || left.isPrimitiveOrNull$1(compiler))
        return this.newBuiltinVariant$2(instruction, compiler);
      selector = Z.TypedSelector_TypedSelector(instructionType, instruction.selector, compiler);
      world = compiler.world;
      backend = compiler.backend;
      if (J.every$1$ax(world.allFunctions.query$1(0, selector).functions, backend.get$isDefaultEqualityImplementation()))
        return this.newBuiltinVariant$2(instruction, compiler);
      return;
    },
    operation$1: function(constantSystem) {
      return constantSystem.get$equal();
    },
    newBuiltinVariant$2: function(instruction, compiler) {
      var backend, t1, t2, t3, t4, t5, t6;
      backend = compiler.backend;
      t1 = instruction.inputs;
      t2 = t1.length;
      if (1 >= t2)
        return H.ioore(t1, 1);
      t3 = t1[1];
      if (2 >= t2)
        return H.ioore(t1, 2);
      t1 = t1[2];
      t2 = instruction.selector;
      t4 = backend.compiler.typesTask.get$boolType();
      t5 = H.setRuntimeTypeInfo([t3, t1], [B.HInstruction]);
      t6 = $.HInstruction_idCounter;
      if (typeof t6 !== "number")
        return t6.$add();
      $.HInstruction_idCounter = t6 + 1;
      t6 = new B.HIdentity(null, false, t2, null, null, t6, t5, H.setRuntimeTypeInfo([], [B.HInstruction]), null, null, null, new Z.SideEffects(0), false, t4);
      t6.HInstruction$2(t5, t4);
      t6.HInvokeBinary$4(t3, t1, t2, t4);
      return t6;
    }
  },
  LessSpecializer: {
    "^": "RelationalSpecializer;",
    operation$1: function(constantSystem) {
      return constantSystem.get$less();
    },
    newBuiltinVariant$2: function(instruction, compiler) {
      var backend, t1, t2, t3, t4, t5, t6;
      backend = compiler.backend;
      t1 = instruction.inputs;
      t2 = t1.length;
      if (1 >= t2)
        return H.ioore(t1, 1);
      t3 = t1[1];
      if (2 >= t2)
        return H.ioore(t1, 2);
      t1 = t1[2];
      t2 = instruction.selector;
      t4 = backend.compiler.typesTask.get$boolType();
      t5 = H.setRuntimeTypeInfo([t3, t1], [B.HInstruction]);
      t6 = $.HInstruction_idCounter;
      if (typeof t6 !== "number")
        return t6.$add();
      $.HInstruction_idCounter = t6 + 1;
      t6 = new B.HLess(false, t2, null, null, t6, t5, H.setRuntimeTypeInfo([], [B.HInstruction]), null, null, null, new Z.SideEffects(0), false, t4);
      t6.HInstruction$2(t5, t4);
      t6.HInvokeBinary$4(t3, t1, t2, t4);
      return t6;
    }
  },
  GreaterSpecializer: {
    "^": "RelationalSpecializer;",
    operation$1: function(constantSystem) {
      return constantSystem.get$greater();
    },
    newBuiltinVariant$2: function(instruction, compiler) {
      var backend, t1, t2, t3, t4, t5, t6;
      backend = compiler.backend;
      t1 = instruction.inputs;
      t2 = t1.length;
      if (1 >= t2)
        return H.ioore(t1, 1);
      t3 = t1[1];
      if (2 >= t2)
        return H.ioore(t1, 2);
      t1 = t1[2];
      t2 = instruction.selector;
      t4 = backend.compiler.typesTask.get$boolType();
      t5 = H.setRuntimeTypeInfo([t3, t1], [B.HInstruction]);
      t6 = $.HInstruction_idCounter;
      if (typeof t6 !== "number")
        return t6.$add();
      $.HInstruction_idCounter = t6 + 1;
      t6 = new B.HGreater(false, t2, null, null, t6, t5, H.setRuntimeTypeInfo([], [B.HInstruction]), null, null, null, new Z.SideEffects(0), false, t4);
      t6.HInstruction$2(t5, t4);
      t6.HInvokeBinary$4(t3, t1, t2, t4);
      return t6;
    }
  },
  GreaterEqualSpecializer: {
    "^": "RelationalSpecializer;",
    operation$1: function(constantSystem) {
      return constantSystem.get$greaterEqual();
    },
    newBuiltinVariant$2: function(instruction, compiler) {
      var backend, t1, t2, t3, t4, t5, t6;
      backend = compiler.backend;
      t1 = instruction.inputs;
      t2 = t1.length;
      if (1 >= t2)
        return H.ioore(t1, 1);
      t3 = t1[1];
      if (2 >= t2)
        return H.ioore(t1, 2);
      t1 = t1[2];
      t2 = instruction.selector;
      t4 = backend.compiler.typesTask.get$boolType();
      t5 = H.setRuntimeTypeInfo([t3, t1], [B.HInstruction]);
      t6 = $.HInstruction_idCounter;
      if (typeof t6 !== "number")
        return t6.$add();
      $.HInstruction_idCounter = t6 + 1;
      t6 = new B.HGreaterEqual(false, t2, null, null, t6, t5, H.setRuntimeTypeInfo([], [B.HInstruction]), null, null, null, new Z.SideEffects(0), false, t4);
      t6.HInstruction$2(t5, t4);
      t6.HInvokeBinary$4(t3, t1, t2, t4);
      return t6;
    }
  },
  LessEqualSpecializer: {
    "^": "RelationalSpecializer;",
    operation$1: function(constantSystem) {
      return constantSystem.get$lessEqual();
    },
    newBuiltinVariant$2: function(instruction, compiler) {
      var backend, t1, t2, t3, t4, t5, t6;
      backend = compiler.backend;
      t1 = instruction.inputs;
      t2 = t1.length;
      if (1 >= t2)
        return H.ioore(t1, 1);
      t3 = t1[1];
      if (2 >= t2)
        return H.ioore(t1, 2);
      t1 = t1[2];
      t2 = instruction.selector;
      t4 = backend.compiler.typesTask.get$boolType();
      t5 = H.setRuntimeTypeInfo([t3, t1], [B.HInstruction]);
      t6 = $.HInstruction_idCounter;
      if (typeof t6 !== "number")
        return t6.$add();
      $.HInstruction_idCounter = t6 + 1;
      t6 = new B.HLessEqual(false, t2, null, null, t6, t5, H.setRuntimeTypeInfo([], [B.HInstruction]), null, null, null, new Z.SideEffects(0), false, t4);
      t6.HInstruction$2(t5, t4);
      t6.HInvokeBinary$4(t3, t1, t2, t4);
      return t6;
    }
  },
  HGraphVisitor: {
    "^": "Object;",
    visitDominatorTree$1: function(graph) {
      new B.HGraphVisitor_visitDominatorTree_visitBasicBlockAndSuccessors(this).call$1(graph.entry);
    },
    visitPostDominatorTree$1: function(graph) {
      new B.HGraphVisitor_visitPostDominatorTree_visitBasicBlockAndSuccessors(this).call$1(graph.entry);
    }
  },
  HGraphVisitor_visitDominatorTree_visitBasicBlockAndSuccessors: {
    "^": "Closure:287;this_0",
    call$1: function(block) {
      var dominated, i;
      this.this_0.visitBasicBlock$1(block);
      dominated = block.dominatedBlocks;
      for (i = 0; i < dominated.length; ++i)
        this.call$1(dominated[i]);
    },
    $isFunction: true
  },
  HGraphVisitor_visitPostDominatorTree_visitBasicBlockAndSuccessors: {
    "^": "Closure:287;this_0",
    call$1: function(block) {
      var dominated, i;
      dominated = block.dominatedBlocks;
      for (i = dominated.length - 1; i >= 0; --i) {
        if (i >= dominated.length)
          return H.ioore(dominated, i);
        this.call$1(dominated[i]);
      }
      this.this_0.visitBasicBlock$1(block);
    },
    $isFunction: true
  },
  HGraph: {
    "^": "Object;entry,exit,thisInstruction,explicitReceiverParameter,isRecursiveMethod,calledInLoop,blocks,constants",
    addBlock$1: function(block) {
      var t1 = this.blocks;
      block.id = t1.length;
      t1.push(block);
    },
    addNewBlock$0: function() {
      var result = new B.HBasicBlock(null, 0, new B.HInstructionList(null, null), null, null, null, true, H.setRuntimeTypeInfo([], [B.HBasicBlock]), C.List_empty13, null, H.setRuntimeTypeInfo([], [B.HBasicBlock]), null, null, null);
      this.addBlock$1(result);
      return result;
    },
    addConstant$2: function(constant, compiler) {
      var result, type, t1, t2;
      result = this.constants.$index(0, constant);
      if (result == null) {
        type = constant.computeMask$1(compiler);
        t1 = H.setRuntimeTypeInfo([], [B.HInstruction]);
        t2 = $.HInstruction_idCounter;
        if (typeof t2 !== "number")
          return t2.$add();
        $.HInstruction_idCounter = t2 + 1;
        result = new B.HConstant(constant, null, null, t2, t1, H.setRuntimeTypeInfo([], [B.HInstruction]), null, null, null, new Z.SideEffects(0), false, type);
        result.HInstruction$2(t1, type);
        this.entry.addAtExit$1(result);
        this.constants.$indexSet(0, constant, result);
      } else if (result.get$block() == null)
        this.entry.addAtExit$1(result);
      return result;
    },
    assignDominators$0: function() {
      var t1, $length, i, block, predecessors, j;
      for (t1 = this.blocks, $length = t1.length, i = 0; i < $length; ++i) {
        if (i >= t1.length)
          return H.ioore(t1, i);
        block = t1[i];
        predecessors = block.get$predecessors();
        if (block.get$loopInformation() != null) {
          if (0 >= predecessors.length)
            return H.ioore(predecessors, 0);
          block.assignCommonDominator$1(predecessors[0]);
        } else
          for (j = predecessors.length - 1; j >= 0; --j) {
            if (j >= predecessors.length)
              return H.ioore(predecessors, j);
            block.assignCommonDominator$1(predecessors[j]);
          }
      }
    },
    HGraph$0: function() {
      this.entry = this.addNewBlock$0();
      this.exit = new B.HBasicBlock(null, 0, new B.HInstructionList(null, null), null, null, null, true, H.setRuntimeTypeInfo([], [B.HBasicBlock]), C.List_empty13, null, H.setRuntimeTypeInfo([], [B.HBasicBlock]), null, null, null);
    },
    $isHGraph: true
  },
  HBaseVisitor: {
    "^": "HGraphVisitor;",
    visitBasicBlock$1: function(node) {
      var instruction;
      this.currentBlock = node;
      instruction = node.first;
      for (; instruction != null;) {
        instruction.accept$1(0, this);
        instruction = instruction.next;
      }
    },
    visitInstruction$1: function(instruction) {
    },
    visitBinaryArithmetic$1: function(node) {
      return this.visitInvokeBinary$1(node);
    },
    visitInvoke$1: function(node) {
      return this.visitInstruction$1(node);
    },
    visitInvokeBinary$1: function(node) {
      return this.visitInstruction$1(node);
    },
    visitInvokeDynamic$1: function(node) {
      return this.visitInvoke$1(node);
    },
    visitInvokeUnary$1: function(node) {
      return this.visitInstruction$1(node);
    },
    visitConditionalBranch$1: function(node) {
      return this.visitControlFlow$1(node);
    },
    visitControlFlow$1: function(node) {
      return this.visitInstruction$1(node);
    },
    visitRelational$1: function(node) {
      return this.visitInvokeBinary$1(node);
    },
    visitAdd$1: function(node) {
      return this.visitBinaryArithmetic$1(node);
    },
    visitBitAnd$1: function(node) {
      return this.visitInvokeBinary$1(node);
    },
    visitBitNot$1: function(node) {
      return this.visitInvokeUnary$1(node);
    },
    visitBitOr$1: function(node) {
      return this.visitInvokeBinary$1(node);
    },
    visitBitXor$1: function(node) {
      return this.visitInvokeBinary$1(node);
    },
    visitBoolify$1: function(node) {
      return this.visitInstruction$1(node);
    },
    visitBoundsCheck$1: function(node) {
      return this.visitCheck$1(node);
    },
    visitBreak$1: function(node) {
      return this.visitControlFlow$1(node);
    },
    visitContinue$1: function(node) {
      return this.visitControlFlow$1(node);
    },
    visitCheck$1: function(node) {
      return this.visitInstruction$1(node);
    },
    visitConstant$1: function(node) {
      return this.visitInstruction$1(node);
    },
    visitDivide$1: function(node) {
      return this.visitBinaryArithmetic$1(node);
    },
    visitExit$1: function(node) {
      return this.visitControlFlow$1(node);
    },
    visitExitTry$1: function(node) {
      return this.visitControlFlow$1(node);
    },
    visitFieldGet$1: function(node) {
      return this.visitInstruction$1(node);
    },
    visitFieldSet$1: function(node) {
      return this.visitInstruction$1(node);
    },
    visitForeign$1: function(node) {
      return this.visitInstruction$1(node);
    },
    visitForeignNew$1: function(node) {
      return this.visitInstruction$1(node);
    },
    visitGoto$1: function(node) {
      return this.visitControlFlow$1(node);
    },
    visitGreater$1: function(node) {
      return this.visitRelational$1(node);
    },
    visitGreaterEqual$1: function(node) {
      return this.visitRelational$1(node);
    },
    visitIdentity$1: function(node) {
      return this.visitRelational$1(node);
    },
    visitIf$1: function(node) {
      return this.visitConditionalBranch$1(node);
    },
    visitIndex$1: function(node) {
      return this.visitInstruction$1(node);
    },
    visitIndexAssign$1: function(node) {
      return this.visitInstruction$1(node);
    },
    visitInterceptor$1: function(node) {
      return this.visitInstruction$1(node);
    },
    visitInvokeClosure$1: function(node) {
      return this.visitInvokeDynamic$1(node);
    },
    visitInvokeConstructorBody$1: function(node) {
      return this.visitInvoke$1(node);
    },
    visitInvokeDynamicMethod$1: function(node) {
      return this.visitInvokeDynamic$1(node);
    },
    visitInvokeDynamicGetter$1: function(node) {
      return this.visitInvokeDynamic$1(node);
    },
    visitInvokeDynamicSetter$1: function(node) {
      return this.visitInvokeDynamic$1(node);
    },
    visitInvokeStatic$1: function(node) {
      return this.visitInvoke$1(node);
    },
    visitInvokeSuper$1: function(node) {
      return this.visitInvoke$1(node);
    },
    visitLazyStatic$1: function(node) {
      return this.visitInstruction$1(node);
    },
    visitLess$1: function(node) {
      return this.visitRelational$1(node);
    },
    visitLessEqual$1: function(node) {
      return this.visitRelational$1(node);
    },
    visitLiteralList$1: function(node) {
      return this.visitInstruction$1(node);
    },
    visitLocalGet$1: function(node) {
      return this.visitInstruction$1(node);
    },
    visitLocalSet$1: function(node) {
      return this.visitInstruction$1(node);
    },
    visitLocalValue$1: function(node) {
      return this.visitInstruction$1(node);
    },
    visitLoopBranch$1: function(node) {
      return this.visitConditionalBranch$1(node);
    },
    visitNegate$1: function(node) {
      return this.visitInvokeUnary$1(node);
    },
    visitNot$1: function(node) {
      return this.visitInstruction$1(node);
    },
    visitOneShotInterceptor$1: function(node) {
      return this.visitInvokeDynamic$1(node);
    },
    visitPhi$1: function(node) {
      return this.visitInstruction$1(node);
    },
    visitMultiply$1: function(node) {
      return this.visitBinaryArithmetic$1(node);
    },
    visitParameterValue$1: function(node) {
      return this.visitInstruction$1(node);
    },
    visitRangeConversion$1: function(node) {
      return this.visitCheck$1(node);
    },
    visitReadModifyWrite$1: function(node) {
      return this.visitInstruction$1(node);
    },
    visitReturn$1: function(node) {
      return this.visitControlFlow$1(node);
    },
    visitShiftLeft$1: function(node) {
      return this.visitInvokeBinary$1(node);
    },
    visitShiftRight$1: function(node) {
      return this.visitInvokeBinary$1(node);
    },
    visitSubtract$1: function(node) {
      return this.visitBinaryArithmetic$1(node);
    },
    visitSwitch$1: function(node) {
      return this.visitControlFlow$1(node);
    },
    visitStatic$1: function(node) {
      return this.visitInstruction$1(node);
    },
    visitStaticStore$1: function(node) {
      return this.visitInstruction$1(node);
    },
    visitStringConcat$1: function(node) {
      return this.visitInstruction$1(node);
    },
    visitStringify$1: function(node) {
      return this.visitInstruction$1(node);
    },
    visitThis$1: function(node) {
      return this.visitInstruction$1(node);
    },
    visitThrow$1: function(node) {
      return this.visitControlFlow$1(node);
    },
    visitThrowExpression$1: function(node) {
      return this.visitInstruction$1(node);
    },
    visitTruncatingDivide$1: function(node) {
      return this.visitBinaryArithmetic$1(node);
    },
    visitTry$1: function(node) {
      return this.visitControlFlow$1(node);
    },
    visitIs$1: function(node) {
      return this.visitInstruction$1(node);
    },
    visitIsViaInterceptor$1: function(node) {
      return this.visitInstruction$1(node);
    },
    visitTypeConversion$1: function(node) {
      return this.visitCheck$1(node);
    },
    visitTypeKnown$1: function(node) {
      return this.visitCheck$1(node);
    },
    visitReadTypeVariable$1: function(node) {
      return this.visitInstruction$1(node);
    },
    visitFunctionType$1: function(node) {
      return this.visitInstruction$1(node);
    },
    visitVoidType$1: function(node) {
      return this.visitInstruction$1(node);
    },
    visitInterfaceType$1: function(node) {
      return this.visitInstruction$1(node);
    },
    visitDynamicType$1: function(node) {
      return this.visitInstruction$1(node);
    }
  },
  SubGraph: {
    "^": "Object;start>,end<",
    contains$1: function(_, block) {
      var t1, t2, t3;
      t1 = this.start.id;
      t2 = J.getInterceptor$x(block);
      t3 = t2.get$id(block);
      if (typeof t1 !== "number")
        return t1.$le();
      if (typeof t3 !== "number")
        return H.iae(t3);
      if (t1 <= t3) {
        t1 = t2.get$id(block);
        t2 = this.end.id;
        if (typeof t1 !== "number")
          return t1.$le();
        if (typeof t2 !== "number")
          return H.iae(t2);
        t2 = t1 <= t2;
        t1 = t2;
      } else
        t1 = false;
      return t1;
    }
  },
  SubExpression: {
    "^": "SubGraph;start,end",
    get$conditionExpression: function() {
      var last, t1;
      last = this.end.last;
      t1 = J.getInterceptor(last);
      if (!!t1.$isHConditionalBranch || !!t1.$isHSwitch) {
        t1 = last.inputs;
        if (0 >= t1.length)
          return H.ioore(t1, 0);
        return t1[0];
      }
      return;
    }
  },
  HInstructionList: {
    "^": "Object;first>,last>",
    get$isEmpty: function(_) {
      return this.first == null;
    },
    internalAddAfter$2: function(cursor, instruction) {
      var t1;
      if (cursor == null) {
        this.last = instruction;
        this.first = instruction;
      } else {
        t1 = this.last;
        if (cursor === t1) {
          t1.next = instruction;
          instruction.previous = t1;
          this.last = instruction;
        } else {
          instruction.previous = cursor;
          instruction.next = cursor.next;
          cursor.next.previous = instruction;
          cursor.next = instruction;
        }
      }
    },
    internalAddBefore$2: function(cursor, instruction) {
      var t1;
      if (cursor == null) {
        this.last = instruction;
        this.first = instruction;
      } else {
        t1 = this.first;
        if (cursor === t1) {
          t1.previous = instruction;
          instruction.next = t1;
          this.first = instruction;
        } else {
          instruction.next = cursor;
          instruction.previous = cursor.previous;
          cursor.previous.next = instruction;
          cursor.previous = instruction;
        }
      }
    },
    detach$1: function(instruction) {
      var t1, t2;
      t1 = instruction.previous;
      if (t1 == null)
        this.first = instruction.next;
      else
        t1.next = instruction.next;
      t2 = instruction.next;
      if (t2 == null)
        this.last = t1;
      else
        t2.previous = t1;
      instruction.previous = null;
      instruction.next = null;
    },
    remove$1: function(_, instruction) {
      this.detach$1(instruction);
    },
    contains$1: function(_, instruction) {
      var cursor = this.first;
      for (; cursor != null;) {
        if (cursor == null ? instruction == null : cursor === instruction)
          return true;
        cursor = cursor.next;
      }
      return false;
    }
  },
  HBasicBlock: {
    "^": "HInstructionList;id>,status,phis<,loopInformation<,blockFlow,parentLoopHeader,isLive<,predecessors<,successors@,dominator<,dominatedBlocks,dominatesCache,first,last",
    get$hashCode: function(_) {
      return this.id;
    },
    isLoopHeader$0: function() {
      return this.loopInformation != null;
    },
    get$enclosingLoopHeader: function() {
      if (this.loopInformation != null)
        return this;
      return this.parentLoopHeader;
    },
    close$1: function(_, end) {
      this.addAfter$2(this.last, end);
      this.status = 2;
    },
    addAtEntry$1: function(instruction) {
      this.internalAddBefore$2(this.first, instruction);
      instruction.notifyAddedToBlock$1(this);
    },
    addAtExit$1: function(instruction) {
      this.internalAddBefore$2(this.last, instruction);
      instruction.notifyAddedToBlock$1(this);
    },
    moveAtExit$1: function(instruction) {
      this.internalAddBefore$2(this.last, instruction);
      instruction.block = this;
    },
    add$1: function(_, instruction) {
      this.internalAddAfter$2(this.last, instruction);
      instruction.notifyAddedToBlock$1(this);
    },
    addPhi$1: function(phi) {
      var t1 = this.phis;
      t1.internalAddAfter$2(t1.last, phi);
      phi.notifyAddedToBlock$1(this);
    },
    removePhi$1: function(phi) {
      this.phis.detach$1(phi);
      phi.notifyRemovedFromBlock$0();
    },
    addAfter$2: function(cursor, instruction) {
      this.internalAddAfter$2(cursor, instruction);
      instruction.notifyAddedToBlock$1(this);
    },
    addBefore$2: function(cursor, instruction) {
      this.internalAddBefore$2(cursor, instruction);
      instruction.notifyAddedToBlock$1(this);
    },
    remove$1: function(_, instruction) {
      B.HInstructionList.prototype.remove$1.call(this, this, instruction);
      instruction.notifyRemovedFromBlock$0();
    },
    addSuccessor$1: function(block) {
      var t1 = this.successors;
      if (t1.length === 0)
        this.successors = [block];
      else
        C.JSArray_methods.add$1(t1, block);
      block.predecessors.push(this);
    },
    postProcessLoopHeader$0: function() {
      var t1, $length, i, t2;
      for (t1 = this.predecessors, $length = t1.length, i = 1; i < $length; ++i) {
        t2 = this.loopInformation;
        if (i >= t1.length)
          return H.ioore(t1, i);
        t2.addBackEdge$1(t1[i]);
      }
    },
    rewrite$2: function(from, to) {
      var t1, t2;
      for (t1 = from.usedBy, t2 = H.setRuntimeTypeInfo(new H.ListIterator(t1, t1.length, 0, null), [H.getTypeArgumentByIndex(t1, 0)]); t2.moveNext$0();)
        t2.__internal$_current.rewriteInput$2(from, to);
      C.JSArray_methods.addAll$1(to.get$usedBy(), t1);
      C.JSArray_methods.set$length(t1, 0);
    },
    rewriteWithBetterUser$2: function(from, to) {
      var t1, t2, better, user, t3, t4, check;
      for (t1 = to.usedBy, t2 = H.setRuntimeTypeInfo(new H.ListIterator(t1, t1.length, 0, null), [H.getTypeArgumentByIndex(t1, 0)]), better = C.C_Link16; t2.moveNext$0();) {
        user = t2.__internal$_current;
        t3 = J.getInterceptor(user);
        if (t3.$eq(user, from) || !t3.$isHCheck)
          continue;
        t3 = user.get$inputs();
        if (0 >= t3.length)
          return H.ioore(t3, 0);
        if (J.$eq(t3[0], to))
          better = better.prepend$1(user);
      }
      if (better.get$isEmpty(better))
        return this.rewrite$2(from, to);
      $L1$0:
        for (t2 = from.usedBy, t3 = H.setRuntimeTypeInfo(new H.ListIterator(t2, t2.length, 0, null), [H.getTypeArgumentByIndex(t2, 0)]); t3.moveNext$0();) {
          user = t3.__internal$_current;
          t4 = new E.LinkIterator(null, better);
          t4.$builtinTypeInfo = [H.getTypeArgumentByIndex(better, 0)];
          for (; t4.moveNext$0();) {
            check = t4._util_implementation$_current;
            if (check.dominates$1(user)) {
              user.rewriteInput$2(from, check);
              check.get$usedBy().push(user);
              continue $L1$0;
            }
          }
          user.rewriteInput$2(from, to);
          t1.push(user);
        }
      C.JSArray_methods.set$length(t2, 0);
    },
    addDominatedBlock$1: function(block) {
      var t1, index, t2, index0, t3;
      t1 = this.dominatedBlocks;
      index = t1.length;
      t2 = block.id;
      index0 = index;
      while (true) {
        if (index0 > 0) {
          t3 = t1[index0 - 1].id;
          if (typeof t3 !== "number")
            return t3.$gt();
          if (typeof t2 !== "number")
            return H.iae(t2);
          t3 = t3 > t2;
        } else
          t3 = false;
        if (!t3)
          break;
        --index0;
      }
      if (index0 === index)
        t1.push(block);
      else
        C.JSArray_methods.insert$2(t1, index0, block);
      block.dominator = this;
    },
    assignCommonDominator$1: function(predecessor) {
      var block0, block1, block00, t1, t2, index, t3;
      if (this.dominator == null)
        predecessor.addDominatedBlock$1(this);
      else if (predecessor.get$dominator() != null) {
        block0 = this.dominator;
        for (block1 = predecessor, block00 = block0; block00 == null ? block1 != null : block00 !== block1;) {
          t1 = block00.id;
          t2 = block1.id;
          if (typeof t1 !== "number")
            return t1.$gt();
          if (typeof t2 !== "number")
            return H.iae(t2);
          if (t1 > t2)
            block00 = block00.dominator;
          else
            block1 = block1.dominator;
        }
        if (block0 == null ? block00 != null : block0 !== block00) {
          t1 = block0.dominatedBlocks;
          index = H.Lists_indexOf(t1, this, 0, t1.length);
          t2 = t1.length;
          if (index === t2 - 1) {
            if (0 >= t2)
              return H.ioore(t1, 0);
            t1.pop();
          } else {
            t3 = index + 1;
            if (index < 0 || index > t2)
              H.throwExpression(P.RangeError$range(index, 0, t2));
            if (t3 > t2)
              H.throwExpression(P.RangeError$range(t3, index, t2));
            H.Lists_copy(t1, t3, t1, index, t2 - t3);
            C.JSArray_methods.set$length(t1, t2 - (t3 - index));
          }
          this.dominator = null;
          block00.addDominatedBlock$1(this);
        }
      }
    },
    forEachPhi$1: function(f) {
      var current, saved;
      current = this.phis.first;
      for (; current != null; current = saved) {
        saved = current.next;
        f.call$1(current);
      }
    },
    forEachInstruction$1: function(f) {
      var current, saved;
      current = this.first;
      for (; current != null; current = saved) {
        saved = current.next;
        f.call$1(current);
      }
    },
    dominates$1: function(other) {
      var t1, res, t2;
      t1 = this.dominatesCache;
      if (t1 == null)
        this.dominatesCache = P.LinkedHashMap_LinkedHashMap(null, null, null, B.HBasicBlock, P.bool);
      else {
        res = t1.$index(0, other);
        if (res != null)
          return res;
      }
      do {
        if (this === other) {
          this.dominatesCache.$indexSet(0, other, true);
          return true;
        }
        other = other.get$dominator();
        if (other != null) {
          t1 = other.id;
          t2 = this.id;
          if (typeof t1 !== "number")
            return t1.$ge();
          if (typeof t2 !== "number")
            return H.iae(t2);
          t2 = t1 >= t2;
          t1 = t2;
        } else
          t1 = false;
      } while (t1);
      this.dominatesCache.$indexSet(0, other, false);
      return false;
    },
    static: {"^": "HBasicBlock_STATUS_NEW,HBasicBlock_STATUS_OPEN,HBasicBlock_STATUS_CLOSED"}
  },
  HInstruction: {
    "^": "Object;sourceElement@,sourcePosition<,id>,inputs<,usedBy<,block@,next<,sideEffects<,instructionType@",
    get$hashCode: function(_) {
      return this.id;
    },
    get$isMovable: function() {
      return this._useGvn;
    },
    nonCheck$0: function() {
      return this;
    },
    canThrow$0: function() {
      return false;
    },
    isControlFlow$0: function() {
      return false;
    },
    isExact$0: [function() {
      if (!this.instructionType.get$isExact()) {
        var t1 = this.instructionType;
        t1 = t1.get$isEmpty(t1) && this.instructionType.get$isNullable();
      } else
        t1 = true;
      return t1;
    }, "call$0", "get$isExact", 0, 0, 42],
    canBeNull$0: function() {
      return this.instructionType.get$isNullable();
    },
    isNull$0: [function() {
      var t1 = this.instructionType;
      return t1.get$isEmpty(t1) && this.instructionType.get$isNullable();
    }, "call$0", "get$isNull", 0, 0, 42],
    canBePrimitive$1: function(compiler) {
      var backend, t1;
      if (!this.canBePrimitiveNumber$1(compiler))
        if (!this.canBePrimitiveArray$1(compiler)) {
          backend = compiler.backend;
          if (this.instructionType.contains$2(0, backend.get$jsBoolClass(), compiler) !== true) {
            backend = compiler.backend;
            if (this.instructionType.contains$2(0, backend.get$jsStringClass(), compiler) !== true) {
              t1 = this.instructionType;
              t1 = t1.get$isEmpty(t1) && this.instructionType.get$isNullable();
            } else
              t1 = true;
          } else
            t1 = true;
        } else
          t1 = true;
      else
        t1 = true;
      return t1;
    },
    canBePrimitiveNumber$1: function(compiler) {
      var backend = compiler.backend;
      return this.instructionType.contains$2(0, backend.get$jsNumberClass(), compiler) === true || this.instructionType.contains$2(0, backend.jsIntClass, compiler) === true || this.instructionType.contains$2(0, backend.jsPositiveIntClass, compiler) === true || this.instructionType.contains$2(0, backend.jsUInt32Class, compiler) === true || this.instructionType.contains$2(0, backend.jsUInt31Class, compiler) === true || this.instructionType.contains$2(0, backend.jsDoubleClass, compiler) === true;
    },
    canBePrimitiveArray$1: function(compiler) {
      var backend = compiler.backend;
      return this.instructionType.contains$2(0, backend.get$jsArrayClass(), compiler) === true || this.instructionType.contains$2(0, backend.jsFixedArrayClass, compiler) === true || this.instructionType.contains$2(0, backend.jsExtendableArrayClass, compiler) === true;
    },
    isIndexablePrimitive$1: function(compiler) {
      var backend = compiler.backend;
      return this.instructionType.containsOnlyString$1(compiler) || this.instructionType.satisfies$2(backend.get$jsIndexableClass(), compiler);
    },
    isExtendableArray$1: function(compiler) {
      var backend = compiler.backend;
      return this.instructionType.containsOnly$1(backend.get$jsExtendableArrayClass());
    },
    isReadableArray$1: function(compiler) {
      var backend = compiler.backend;
      return this.instructionType.satisfies$2(backend.get$jsArrayClass(), compiler);
    },
    isMutableIndexable$1: function(compiler) {
      var backend = compiler.backend;
      return this.instructionType.satisfies$2(backend.get$jsMutableIndexableClass(), compiler);
    },
    isInteger$1: function(compiler) {
      return this.instructionType.containsOnlyInt$1(compiler) && !this.instructionType.get$isNullable();
    },
    isUInt31$1: function(compiler) {
      var backend = compiler.backend;
      return !this.instructionType.get$isNullable() && this.instructionType.satisfies$2(backend.get$jsUInt31Class(), compiler);
    },
    isPositiveInteger$1: function(compiler) {
      var backend = compiler.backend;
      return !this.instructionType.get$isNullable() && this.instructionType.satisfies$2(backend.get$jsPositiveIntClass(), compiler);
    },
    isPositiveIntegerOrNull$1: function(compiler) {
      var backend = compiler.backend;
      return this.instructionType.satisfies$2(backend.get$jsPositiveIntClass(), compiler);
    },
    isNumber$1: function(compiler) {
      return this.instructionType.containsOnlyNum$1(compiler) && !this.instructionType.get$isNullable();
    },
    isNumberOrNull$1: function(compiler) {
      return this.instructionType.containsOnlyNum$1(compiler);
    },
    isString$1: [function(compiler) {
      return this.instructionType.containsOnlyString$1(compiler) && !this.instructionType.get$isNullable();
    }, "call$1", "get$isString", 2, 0, 177],
    isPrimitive$1: [function(compiler) {
      var t1;
      if (!(this.isPrimitiveOrNull$1(compiler) && !this.instructionType.get$isNullable())) {
        t1 = this.instructionType;
        t1 = t1.get$isEmpty(t1) && this.instructionType.get$isNullable();
      } else
        t1 = true;
      return t1;
    }, "call$1", "get$isPrimitive", 2, 0, 177],
    isPrimitiveOrNull$1: function(compiler) {
      var t1;
      if (!this.isIndexablePrimitive$1(compiler))
        if (!this.instructionType.containsOnlyNum$1(compiler))
          if (!this.instructionType.containsOnlyBool$1(compiler)) {
            t1 = this.instructionType;
            t1 = t1.get$isEmpty(t1) && this.instructionType.get$isNullable();
          } else
            t1 = true;
        else
          t1 = true;
      else
        t1 = true;
      return t1;
    },
    get$selector: function() {
      return;
    },
    getDartReceiver$1: function(compiler) {
      return;
    },
    onlyThrowsNSM$0: function() {
      return false;
    },
    gvnEquals$1: function(other) {
      var t1, inputsLength, otherInputs, i, t2;
      if (!this.typeEquals$1(other))
        return false;
      if (!J.$eq(this.sideEffects, other.sideEffects))
        return false;
      t1 = this.inputs;
      inputsLength = t1.length;
      otherInputs = other.inputs;
      if (inputsLength !== otherInputs.length)
        return false;
      for (i = 0; i < inputsLength; ++i) {
        if (i >= t1.length)
          return H.ioore(t1, i);
        t2 = t1[i].nonCheck$0();
        if (i >= otherInputs.length)
          return H.ioore(otherInputs, i);
        if (t2 !== otherInputs[i].nonCheck$0())
          return false;
      }
      return this.dataEquals$1(other);
    },
    gvnHashCode$0: function() {
      var result, t1, $length, i, t2;
      result = this.typeCode$0();
      t1 = this.inputs;
      $length = t1.length;
      for (i = 0; i < $length; ++i) {
        if (i >= t1.length)
          return H.ioore(t1, i);
        t2 = t1[i].nonCheck$0().id;
        if (typeof t2 !== "number")
          return H.iae(t2);
        result = result * 19 + t2 + C.JSInt_methods._shrOtherPositive$1(result, 7);
      }
      return result;
    },
    typeCode$0: function() {
      return -1;
    },
    typeEquals$1: function(other) {
      return false;
    },
    dataEquals$1: function(other) {
      return false;
    },
    notifyAddedToBlock$1: function(targetBlock) {
      var t1, i;
      for (t1 = this.inputs, i = 0; i < t1.length; ++i)
        t1[i].get$usedBy().push(this);
      this.block = targetBlock;
    },
    notifyRemovedFromBlock$0: function() {
      var t1, i;
      for (t1 = this.inputs, i = 0; i < t1.length; ++i)
        t1[i].removeUser$1(this);
      this.block = null;
    },
    rewriteInput$2: function(from, to) {
      var t1, t2, i;
      for (t1 = this.inputs, t2 = J.getInterceptor$ax(t1), i = 0; i < t1.length; ++i)
        if (t1[i] === from)
          t2.$indexSet(t1, i, to);
    },
    removeFromList$2: function(list, instruction) {
      var $length, i;
      $length = list.length;
      for (i = 0; i < $length;)
        if (instruction === list[i]) {
          --$length;
          list[i] = list[$length];
        } else
          ++i;
      C.JSArray_methods.set$length(list, $length);
    },
    removeUser$1: function(user) {
      this.removeFromList$2(this.usedBy, user);
    },
    changeUse$2: function(oldInput, newInput) {
      var t1, t2, i;
      for (t1 = this.inputs, t2 = J.getInterceptor$ax(t1), i = 0; i < t1.length; ++i)
        if (t1[i] === oldInput) {
          t2.$indexSet(t1, i, newInput);
          newInput.get$usedBy().push(this);
        }
      this.removeFromList$2(oldInput.usedBy, this);
    },
    dominatedUsers$1: function(other) {
      var users, otherBlock, t1, $length, usersInCurrentBlock, i, current, phi;
      users = H.setRuntimeTypeInfo(new N.Setlet(C.C__SetletMarker, null), [B.HInstruction]);
      otherBlock = other.block;
      for (t1 = this.usedBy, $length = t1.length, usersInCurrentBlock = 0, i = 0; i < $length; ++i) {
        if (i >= t1.length)
          return H.ioore(t1, i);
        current = t1[i];
        if (otherBlock.dominates$1(current.get$block())) {
          if (current.get$block() === otherBlock)
            ++usersInCurrentBlock;
          users.add$1(0, current);
        }
      }
      if (usersInCurrentBlock > 0)
        for (phi = otherBlock.phis.first; phi != null; phi = phi.next)
          if (users.contains$1(0, phi) === true) {
            users.remove$1(0, phi);
            --usersInCurrentBlock;
            if (usersInCurrentBlock === 0)
              break;
          }
      if (usersInCurrentBlock > 0) {
        current = otherBlock.first;
        for (; current == null ? other != null : current !== other;) {
          if (users.contains$1(0, current) === true) {
            users.remove$1(0, current);
            --usersInCurrentBlock;
            if (usersInCurrentBlock === 0)
              break;
          }
          current = current.next;
        }
      }
      return users;
    },
    replaceAllUsersDominatedBy$2: function(cursor, newInstruction) {
      var users, t1;
      users = this.dominatedUsers$1(cursor);
      for (t1 = users.get$iterator(users); t1.moveNext$0();)
        t1.get$current().changeUse$2(this, newInstruction);
    },
    isConstant$0: function() {
      return false;
    },
    isConstantBoolean$0: function() {
      return false;
    },
    isConstantNull$0: function() {
      return false;
    },
    isConstantInteger$0: function() {
      return false;
    },
    isConstantString$0: function() {
      return false;
    },
    isConstantList$0: function() {
      return false;
    },
    isConstantMap$0: function() {
      return false;
    },
    isConstantFalse$0: function() {
      return false;
    },
    isConstantTrue$0: function() {
      return false;
    },
    isInterceptor$1: [function(compiler) {
      return false;
    }, "call$1", "get$isInterceptor", 2, 0, 177],
    isCodeMotionInvariant$0: function() {
      return false;
    },
    isJsStatement$0: function() {
      return false;
    },
    dominates$1: function(other) {
      var t1, t2, current;
      if (this === other)
        return false;
      t1 = this.block;
      t2 = other.block;
      if (t1 == null ? t2 != null : t1 !== t2)
        return t1.dominates$1(t2);
      current = this.next;
      for (; current != null;) {
        if (current == null ? other == null : current === other)
          return true;
        current = current.next;
      }
      return false;
    },
    convertType$3: function(compiler, type, kind) {
      var element, t1, backend;
      type = type.unalias$1(compiler);
      if (type.get$kind(type) === C.TypeKind_dynamic)
        return this;
      element = type.get$element();
      t1 = compiler.objectClass;
      if (element == null ? t1 == null : element === t1)
        return this;
      backend = compiler.backend;
      if (type.get$kind(type) !== C.TypeKind_interface)
        return B.HTypeConversion$(type, kind, backend.compiler.typesTask.get$dynamicType(), this, null);
      else if (kind === 3)
        return B.HTypeConversion$(type, kind, backend.compiler.typesTask.get$boolType(), this, null);
      else if (kind === 0 && !type.get$treatAsRaw())
        throw H.wrapException("creating compound check to " + type.toString$0(0) + " (this = " + this.toString$0(0) + ")");
      else
        return B.HTypeConversion$(type, kind, new B.FlatTypeMask(element.get$declaration(), 7), this, null);
    },
    HInstruction$2: function(inputs, instructionType) {
    },
    $isHInstruction: true
  },
  HLateInstruction: {
    "^": "HInstruction;"
  },
  HBoolify: {
    "^": "HInstruction;sourceElement,sourcePosition,id,inputs,usedBy,block,previous,next,sideEffects,_useGvn,instructionType",
    accept$1: function(_, visitor) {
      return visitor.visitBoolify$1(this);
    },
    typeCode$0: function() {
      return 0;
    },
    typeEquals$1: function(other) {
      return !!other.$isHBoolify;
    },
    dataEquals$1: function(other) {
      return true;
    },
    $isHBoolify: true
  },
  HCheck: {
    "^": "HInstruction;",
    isJsStatement$0: function() {
      return true;
    },
    canThrow$0: function() {
      return true;
    },
    nonCheck$0: function() {
      var t1 = this.inputs;
      if (0 >= t1.length)
        return H.ioore(t1, 0);
      return t1[0].nonCheck$0();
    },
    $isHCheck: true
  },
  HBoundsCheck: {
    "^": "HCheck;staticChecks,sourceElement,sourcePosition,id,inputs,usedBy,block,previous,next,sideEffects,_useGvn,instructionType",
    get$length: function(_) {
      var t1 = this.inputs;
      if (1 >= t1.length)
        return H.ioore(t1, 1);
      return t1[1];
    },
    get$index: function(_) {
      var t1 = this.inputs;
      if (0 >= t1.length)
        return H.ioore(t1, 0);
      return t1[0];
    },
    isControlFlow$0: function() {
      return true;
    },
    accept$1: function(_, visitor) {
      return visitor.visitBoundsCheck$1(this);
    },
    typeCode$0: function() {
      return 2;
    },
    typeEquals$1: function(other) {
      return !!other.$isHBoundsCheck;
    },
    dataEquals$1: function(other) {
      return true;
    },
    $isHBoundsCheck: true,
    static: {"^": "HBoundsCheck_ALWAYS_FALSE,HBoundsCheck_FULL_CHECK,HBoundsCheck_ALWAYS_ABOVE_ZERO,HBoundsCheck_ALWAYS_BELOW_LENGTH,HBoundsCheck_ALWAYS_TRUE"}
  },
  HConditionalBranch: {
    "^": "HControlFlow;",
    get$condition: function() {
      var t1 = this.inputs;
      if (0 >= t1.length)
        return H.ioore(t1, 0);
      return t1[0];
    },
    $isHConditionalBranch: true
  },
  HControlFlow: {
    "^": "HInstruction;",
    isControlFlow$0: function() {
      return true;
    },
    isJsStatement$0: function() {
      return true;
    }
  },
  HInvoke: {
    "^": "HInstruction;",
    canThrow$0: function() {
      return true;
    },
    get$isInterceptedCall: function() {
      return this.get$selector() != null && this.inputs.length - 2 === this.get$selector().argumentCount;
    },
    $isHInvoke: true
  },
  HInvokeDynamic: {
    "^": "HInvoke;selector<,element<",
    toString$0: function(_) {
      return "invoke dynamic: " + J.toString$0(this.selector);
    },
    get$receiver: function() {
      var t1 = this.inputs;
      if (0 >= t1.length)
        return H.ioore(t1, 0);
      return t1[0];
    },
    getDartReceiver$1: function(compiler) {
      var t1 = this.inputs;
      if (this.isCallOnInterceptor$1(compiler)) {
        if (1 >= t1.length)
          return H.ioore(t1, 1);
        t1 = t1[1];
      } else {
        if (0 >= t1.length)
          return H.ioore(t1, 0);
        t1 = t1[0];
      }
      return t1;
    },
    isCallOnInterceptor$1: function(compiler) {
      var t1;
      if (this.get$isInterceptedCall()) {
        t1 = this.inputs;
        if (0 >= t1.length)
          return H.ioore(t1, 0);
        t1 = t1[0].isInterceptor$1(compiler);
      } else
        t1 = false;
      return t1;
    },
    typeCode$0: function() {
      return 29;
    },
    typeEquals$1: function(other) {
      return !!other.$isHInvokeDynamic;
    },
    dataEquals$1: function(other) {
      var t1, t2;
      t1 = this.selector.name;
      t2 = other.get$selector().name;
      return (t1 == null ? t2 == null : t1 === t2) && this.selector.kind === other.get$selector().kind;
    },
    $isHInvokeDynamic: true
  },
  HInvokeClosure: {
    "^": "HInvokeDynamic;specializer,selector,element,sourceElement,sourcePosition,id,inputs,usedBy,block,previous,next,sideEffects,_useGvn,instructionType",
    accept$1: function(_, visitor) {
      return visitor.visitInvokeClosure$1(this);
    }
  },
  HInvokeDynamicMethod: {
    "^": "HInvokeDynamic;specializer,selector,element,sourceElement,sourcePosition,id,inputs,usedBy,block,previous,next,sideEffects,_useGvn,instructionType",
    toString$0: function(_) {
      return "invoke dynamic method: " + J.toString$0(this.selector);
    },
    accept$1: function(_, visitor) {
      return visitor.visitInvokeDynamicMethod$1(this);
    }
  },
  HInvokeDynamicField: {
    "^": "HInvokeDynamic;",
    toString$0: function(_) {
      return "invoke dynamic field: " + J.toString$0(this.selector);
    }
  },
  HInvokeDynamicGetter: {
    "^": "HInvokeDynamicField;specializer,selector,element,sourceElement,sourcePosition,id,inputs,usedBy,block,previous,next,sideEffects,_useGvn,instructionType",
    toString$0: function(_) {
      return "invoke dynamic getter: " + J.toString$0(this.selector);
    },
    accept$1: function(_, visitor) {
      return visitor.visitInvokeDynamicGetter$1(this);
    }
  },
  HInvokeDynamicSetter: {
    "^": "HInvokeDynamicField;specializer,selector,element,sourceElement,sourcePosition,id,inputs,usedBy,block,previous,next,sideEffects,_useGvn,instructionType",
    toString$0: function(_) {
      return "invoke dynamic setter: " + J.toString$0(this.selector);
    },
    accept$1: function(_, visitor) {
      return visitor.visitInvokeDynamicSetter$1(this);
    }
  },
  HInvokeStatic: {
    "^": "HInvoke;element<,targetCanThrow,instantiatedTypes,sourceElement,sourcePosition,id,inputs,usedBy,block,previous,next,sideEffects,_useGvn,instructionType",
    canThrow$0: function() {
      return this.targetCanThrow;
    },
    toString$0: function(_) {
      return "invoke static: " + J.toString$0(this.element);
    },
    accept$1: function(_, visitor) {
      return visitor.visitInvokeStatic$1(this);
    },
    typeCode$0: function() {
      return 26;
    },
    $isHInvokeStatic: true
  },
  HInvokeSuper: {
    "^": "HInvokeStatic;caller,isSetter<,selector<,element,targetCanThrow,instantiatedTypes,sourceElement,sourcePosition,id,inputs,usedBy,block,previous,next,sideEffects,_useGvn,instructionType",
    toString$0: function(_) {
      var t1 = this.element;
      return "invoke super: " + H.S(t1.get$name(t1));
    },
    accept$1: function(_, visitor) {
      return visitor.visitInvokeSuper$1(this);
    },
    get$value: function(_) {
      return J.get$last$ax(this.inputs);
    }
  },
  HInvokeConstructorBody: {
    "^": "HInvokeStatic;element,targetCanThrow,instantiatedTypes,sourceElement,sourcePosition,id,inputs,usedBy,block,previous,next,sideEffects,_useGvn,instructionType",
    toString$0: function(_) {
      var t1 = this.element;
      return "invoke constructor body: " + H.S(t1.get$name(t1));
    },
    accept$1: function(_, visitor) {
      return visitor.visitInvokeConstructorBody$1(this);
    }
  },
  HFieldAccess: {
    "^": "HInstruction;element<",
    get$receiver: function() {
      var t1 = this.inputs;
      if (0 >= t1.length)
        return H.ioore(t1, 0);
      return t1[0];
    }
  },
  HFieldGet: {
    "^": "HFieldAccess;isAssignable<,element,sourceElement,sourcePosition,id,inputs,usedBy,block,previous,next,sideEffects,_useGvn,instructionType",
    isInterceptor$1: [function(compiler) {
      var t1, backend;
      t1 = this.sourceElement;
      if (t1 == null)
        return false;
      backend = compiler.backend;
      if (!!J.getInterceptor(t1).$isThisLocal)
        return backend.isInterceptorClass$1(t1.get$executableContext().get$enclosingClass());
      return false;
    }, "call$1", "get$isInterceptor", 2, 0, 177],
    canThrow$0: function() {
      var t1 = this.inputs;
      if (0 >= t1.length)
        return H.ioore(t1, 0);
      return t1[0].get$instructionType().get$isNullable();
    },
    getDartReceiver$1: function(compiler) {
      var t1 = this.inputs;
      if (0 >= t1.length)
        return H.ioore(t1, 0);
      return t1[0];
    },
    onlyThrowsNSM$0: function() {
      return true;
    },
    accept$1: function(_, visitor) {
      return visitor.visitFieldGet$1(this);
    },
    typeCode$0: function() {
      return 23;
    },
    typeEquals$1: function(other) {
      return !!other.$isHFieldGet;
    },
    dataEquals$1: function(other) {
      var t1, t2;
      t1 = this.element;
      t2 = other.get$element();
      return t1 == null ? t2 == null : t1 === t2;
    },
    toString$0: function(_) {
      return "FieldGet " + J.toString$0(this.element);
    },
    HFieldGet$4$isAssignable: function(element, receiver, type, isAssignable) {
      var t1;
      this.sideEffects.clearAllSideEffects$0();
      this.sideEffects.clearAllDependencies$0();
      this._useGvn = true;
      if (this.isAssignable) {
        t1 = this.sideEffects;
        t1.flags = (t1.flags | 16) >>> 0;
      }
    },
    $isHFieldGet: true,
    static: {HFieldGet$: function(element, receiver, type, isAssignable) {
        var t1, t2, t3;
        t1 = isAssignable != null ? isAssignable : element.get$isAssignable();
        t2 = H.setRuntimeTypeInfo([receiver], [B.HInstruction]);
        t3 = $.HInstruction_idCounter;
        if (typeof t3 !== "number")
          return t3.$add();
        $.HInstruction_idCounter = t3 + 1;
        t3 = new B.HFieldGet(t1, element, null, null, t3, t2, H.setRuntimeTypeInfo([], [B.HInstruction]), null, null, null, new Z.SideEffects(0), false, type);
        t3.HInstruction$2(t2, type);
        t3.HFieldGet$4$isAssignable(element, receiver, type, isAssignable);
        return t3;
      }}
  },
  HFieldSet: {
    "^": "HFieldAccess;element,sourceElement,sourcePosition,id,inputs,usedBy,block,previous,next,sideEffects,_useGvn,instructionType",
    canThrow$0: function() {
      var t1 = this.inputs;
      if (0 >= t1.length)
        return H.ioore(t1, 0);
      return t1[0].get$instructionType().get$isNullable();
    },
    getDartReceiver$1: function(compiler) {
      var t1 = this.inputs;
      if (0 >= t1.length)
        return H.ioore(t1, 0);
      return t1[0];
    },
    onlyThrowsNSM$0: function() {
      return true;
    },
    get$value: function(_) {
      var t1 = this.inputs;
      if (1 >= t1.length)
        return H.ioore(t1, 1);
      return t1[1];
    },
    accept$1: function(_, visitor) {
      return visitor.visitFieldSet$1(this);
    },
    isJsStatement$0: function() {
      return true;
    },
    toString$0: function(_) {
      return "FieldSet " + J.toString$0(this.element);
    },
    HFieldSet$3: function(element, receiver, value) {
      var t1;
      this.sideEffects.clearAllSideEffects$0();
      this.sideEffects.clearAllDependencies$0();
      t1 = this.sideEffects;
      t1.flags = (t1.flags | 2) >>> 0;
    },
    static: {HFieldSet$: function(element, receiver, value) {
        var t1, t2;
        t1 = H.setRuntimeTypeInfo([receiver, value], [B.HInstruction]);
        t2 = $.HInstruction_idCounter;
        if (typeof t2 !== "number")
          return t2.$add();
        $.HInstruction_idCounter = t2 + 1;
        t2 = new B.HFieldSet(element, null, null, t2, t1, H.setRuntimeTypeInfo([], [B.HInstruction]), null, null, null, new Z.SideEffects(0), false, C.FlatTypeMask_null_0);
        t2.HInstruction$2(t1, C.FlatTypeMask_null_0);
        t2.HFieldSet$3(element, receiver, value);
        return t2;
      }}
  },
  HReadModifyWrite: {
    "^": "HLateInstruction;element<,jsOp,opKind,sourceElement,sourcePosition,id,inputs,usedBy,block,previous,next,sideEffects,_useGvn,instructionType",
    get$receiver: function() {
      var t1 = this.inputs;
      if (0 >= t1.length)
        return H.ioore(t1, 0);
      return t1[0];
    },
    canThrow$0: function() {
      var t1 = this.inputs;
      if (0 >= t1.length)
        return H.ioore(t1, 0);
      return t1[0].get$instructionType().get$isNullable();
    },
    getDartReceiver$1: function(compiler) {
      var t1 = this.inputs;
      if (0 >= t1.length)
        return H.ioore(t1, 0);
      return t1[0];
    },
    onlyThrowsNSM$0: function() {
      return true;
    },
    get$value: function(_) {
      var t1 = this.inputs;
      if (1 >= t1.length)
        return H.ioore(t1, 1);
      return t1[1];
    },
    accept$1: function(_, visitor) {
      return visitor.visitReadModifyWrite$1(this);
    },
    isJsStatement$0: function() {
      return this.opKind === 0;
    },
    toString$0: function(_) {
      return "ReadModifyWrite " + this.jsOp + " " + this.opKind + " " + J.toString$0(this.element);
    },
    static: {"^": "HReadModifyWrite_ASSIGN_OP,HReadModifyWrite_PRE_OP,HReadModifyWrite_POST_OP"}
  },
  HLocalAccess: {
    "^": "HInstruction;variable<",
    get$receiver: function() {
      var t1 = this.inputs;
      if (0 >= t1.length)
        return H.ioore(t1, 0);
      return t1[0];
    }
  },
  HLocalGet: {
    "^": "HLocalAccess;variable,sourceElement,sourcePosition,id,inputs,usedBy,block,previous,next,sideEffects,_useGvn,instructionType",
    accept$1: function(_, visitor) {
      return visitor.visitLocalGet$1(this);
    }
  },
  HLocalSet: {
    "^": "HLocalAccess;variable,sourceElement,sourcePosition,id,inputs,usedBy,block,previous,next,sideEffects,_useGvn,instructionType",
    accept$1: function(_, visitor) {
      return visitor.visitLocalSet$1(this);
    },
    get$value: function(_) {
      var t1 = this.inputs;
      if (1 >= t1.length)
        return H.ioore(t1, 1);
      return t1[1];
    },
    isJsStatement$0: function() {
      return true;
    },
    $isHLocalSet: true
  },
  HForeign: {
    "^": "HInstruction;codeTemplate,isStatement,_canThrow,nativeBehavior,sourceElement,sourcePosition,id,inputs,usedBy,block,previous,next,sideEffects,_useGvn,instructionType",
    accept$1: function(_, visitor) {
      return visitor.visitForeign$1(this);
    },
    isJsStatement$0: function() {
      return this.isStatement;
    },
    canThrow$0: function() {
      if (!this._canThrow) {
        var t1 = this.sideEffects;
        t1 = (t1.flags & 7) !== 0 || t1.getDependsOnFlags$0() !== 0;
      } else
        t1 = true;
      return t1;
    },
    HForeign$7$canThrow$effects$isStatement$nativeBehavior: function(codeTemplate, type, inputs, canThrow, effects, isStatement, nativeBehavior) {
      var t1;
      if (effects == null && nativeBehavior != null)
        effects = nativeBehavior.sideEffects;
      if (effects != null) {
        t1 = this.sideEffects;
        t1.flags = (t1.flags | effects.flags) >>> 0;
      }
    },
    $isHForeign: true,
    static: {HForeign$: function(codeTemplate, type, inputs, canThrow, effects, isStatement, nativeBehavior) {
        var t1 = $.HInstruction_idCounter;
        if (typeof t1 !== "number")
          return t1.$add();
        $.HInstruction_idCounter = t1 + 1;
        t1 = new B.HForeign(codeTemplate, isStatement, canThrow, nativeBehavior, null, null, t1, inputs, H.setRuntimeTypeInfo([], [B.HInstruction]), null, null, null, new Z.SideEffects(0), false, type);
        t1.HInstruction$2(inputs, type);
        t1.HForeign$7$canThrow$effects$isStatement$nativeBehavior(codeTemplate, type, inputs, canThrow, effects, isStatement, nativeBehavior);
        return t1;
      }}
  },
  HForeignNew: {
    "^": "HForeign;element<,instantiatedTypes,codeTemplate,isStatement,_canThrow,nativeBehavior,sourceElement,sourcePosition,id,inputs,usedBy,block,previous,next,sideEffects,_useGvn,instructionType",
    accept$1: function(_, visitor) {
      return visitor.visitForeignNew$1(this);
    },
    $isHForeignNew: true
  },
  HInvokeBinary: {
    "^": "HInstruction;selector<",
    get$left: function(_) {
      var t1 = this.inputs;
      if (0 >= t1.length)
        return H.ioore(t1, 0);
      return t1[0];
    },
    get$right: function(_) {
      var t1 = this.inputs;
      if (1 >= t1.length)
        return H.ioore(t1, 1);
      return t1[1];
    },
    HInvokeBinary$4: function(left, right, selector, type) {
      this.sideEffects.clearAllSideEffects$0();
      this.sideEffects.clearAllDependencies$0();
      this._useGvn = true;
    }
  },
  HBinaryArithmetic: {
    "^": "HInvokeBinary;"
  },
  HAdd: {
    "^": "HBinaryArithmetic;selector,sourceElement,sourcePosition,id,inputs,usedBy,block,previous,next,sideEffects,_useGvn,instructionType",
    accept$1: function(_, visitor) {
      return visitor.visitAdd$1(this);
    },
    operation$1: function(constantSystem) {
      return constantSystem.get$add(constantSystem);
    },
    typeCode$0: function() {
      return 5;
    },
    typeEquals$1: function(other) {
      return !!other.$isHAdd;
    },
    dataEquals$1: function(other) {
      return true;
    },
    $isHAdd: true
  },
  HDivide: {
    "^": "HBinaryArithmetic;selector,sourceElement,sourcePosition,id,inputs,usedBy,block,previous,next,sideEffects,_useGvn,instructionType",
    accept$1: function(_, visitor) {
      return visitor.visitDivide$1(this);
    },
    operation$1: function(constantSystem) {
      return constantSystem.get$divide();
    },
    typeCode$0: function() {
      return 6;
    },
    typeEquals$1: function(other) {
      return !!other.$isHDivide;
    },
    dataEquals$1: function(other) {
      return true;
    },
    $isHDivide: true
  },
  HMultiply: {
    "^": "HBinaryArithmetic;selector,sourceElement,sourcePosition,id,inputs,usedBy,block,previous,next,sideEffects,_useGvn,instructionType",
    accept$1: function(_, visitor) {
      return visitor.visitMultiply$1(this);
    },
    operation$1: function(operations) {
      return operations.get$multiply();
    },
    typeCode$0: function() {
      return 7;
    },
    typeEquals$1: function(other) {
      return !!other.$isHMultiply;
    },
    dataEquals$1: function(other) {
      return true;
    },
    $isHMultiply: true
  },
  HSubtract: {
    "^": "HBinaryArithmetic;selector,sourceElement,sourcePosition,id,inputs,usedBy,block,previous,next,sideEffects,_useGvn,instructionType",
    accept$1: function(_, visitor) {
      return visitor.visitSubtract$1(this);
    },
    operation$1: function(constantSystem) {
      return constantSystem.get$subtract();
    },
    typeCode$0: function() {
      return 8;
    },
    typeEquals$1: function(other) {
      return !!other.$isHSubtract;
    },
    dataEquals$1: function(other) {
      return true;
    },
    $isHSubtract: true
  },
  HTruncatingDivide: {
    "^": "HBinaryArithmetic;selector,sourceElement,sourcePosition,id,inputs,usedBy,block,previous,next,sideEffects,_useGvn,instructionType",
    accept$1: function(_, visitor) {
      return visitor.visitTruncatingDivide$1(this);
    },
    operation$1: function(constantSystem) {
      return constantSystem.get$truncatingDivide();
    },
    typeCode$0: function() {
      return 36;
    },
    typeEquals$1: function(other) {
      return !!other.$isHTruncatingDivide;
    },
    dataEquals$1: function(other) {
      return true;
    },
    $isHTruncatingDivide: true
  },
  HSwitch: {
    "^": "HControlFlow;sourceElement,sourcePosition,id,inputs,usedBy,block,previous,next,sideEffects,_useGvn,instructionType",
    constant$1: [function(index) {
      var t1, t2;
      t1 = this.inputs;
      t2 = J.$add$ns(index, 1);
      if (t2 >>> 0 !== t2 || t2 >= t1.length)
        return H.ioore(t1, t2);
      return t1[t2];
    }, "call$1", "get$constant", 2, 0, 288],
    get$expression: function() {
      var t1 = this.inputs;
      if (0 >= t1.length)
        return H.ioore(t1, 0);
      return t1[0];
    },
    accept$1: function(_, visitor) {
      return visitor.visitSwitch$1(this);
    },
    toString$0: function(_) {
      return "HSwitch cases = " + H.S(this.inputs);
    },
    $isHSwitch: true
  },
  HBinaryBitOp: {
    "^": "HInvokeBinary;",
    $isHBinaryBitOp: true
  },
  HShiftLeft: {
    "^": "HBinaryBitOp;selector,sourceElement,sourcePosition,id,inputs,usedBy,block,previous,next,sideEffects,_useGvn,instructionType",
    accept$1: function(_, visitor) {
      return visitor.visitShiftLeft$1(this);
    },
    operation$1: function(constantSystem) {
      return constantSystem.get$shiftLeft();
    },
    typeCode$0: function() {
      return 9;
    },
    typeEquals$1: function(other) {
      return !!other.$isHShiftLeft;
    },
    dataEquals$1: function(other) {
      return true;
    },
    $isHShiftLeft: true
  },
  HShiftRight: {
    "^": "HBinaryBitOp;selector,sourceElement,sourcePosition,id,inputs,usedBy,block,previous,next,sideEffects,_useGvn,instructionType",
    accept$1: function(_, visitor) {
      return visitor.visitShiftRight$1(this);
    },
    operation$1: function(constantSystem) {
      return constantSystem.get$shiftRight();
    },
    typeCode$0: function() {
      return 30;
    },
    typeEquals$1: function(other) {
      return !!other.$isHShiftRight;
    },
    dataEquals$1: function(other) {
      return true;
    },
    $isHShiftRight: true
  },
  HBitOr: {
    "^": "HBinaryBitOp;selector,sourceElement,sourcePosition,id,inputs,usedBy,block,previous,next,sideEffects,_useGvn,instructionType",
    accept$1: function(_, visitor) {
      return visitor.visitBitOr$1(this);
    },
    operation$1: function(constantSystem) {
      return constantSystem.get$bitOr();
    },
    typeCode$0: function() {
      return 10;
    },
    typeEquals$1: function(other) {
      return !!other.$isHBitOr;
    },
    dataEquals$1: function(other) {
      return true;
    },
    $isHBitOr: true
  },
  HBitAnd: {
    "^": "HBinaryBitOp;selector,sourceElement,sourcePosition,id,inputs,usedBy,block,previous,next,sideEffects,_useGvn,instructionType",
    accept$1: function(_, visitor) {
      return visitor.visitBitAnd$1(this);
    },
    operation$1: function(constantSystem) {
      return constantSystem.get$bitAnd();
    },
    typeCode$0: function() {
      return 11;
    },
    typeEquals$1: function(other) {
      return !!other.$isHBitAnd;
    },
    dataEquals$1: function(other) {
      return true;
    },
    $isHBitAnd: true
  },
  HBitXor: {
    "^": "HBinaryBitOp;selector,sourceElement,sourcePosition,id,inputs,usedBy,block,previous,next,sideEffects,_useGvn,instructionType",
    accept$1: function(_, visitor) {
      return visitor.visitBitXor$1(this);
    },
    operation$1: function(constantSystem) {
      return constantSystem.get$bitXor();
    },
    typeCode$0: function() {
      return 12;
    },
    typeEquals$1: function(other) {
      return !!other.$isHBitXor;
    },
    dataEquals$1: function(other) {
      return true;
    },
    $isHBitXor: true
  },
  HInvokeUnary: {
    "^": "HInstruction;selector<",
    HInvokeUnary$3: function(input, selector, type) {
      this.sideEffects.clearAllSideEffects$0();
      this.sideEffects.clearAllDependencies$0();
      this._useGvn = true;
    }
  },
  HNegate: {
    "^": "HInvokeUnary;selector,sourceElement,sourcePosition,id,inputs,usedBy,block,previous,next,sideEffects,_useGvn,instructionType",
    accept$1: function(_, visitor) {
      return visitor.visitNegate$1(this);
    },
    operation$1: function(constantSystem) {
      return constantSystem.get$negate();
    },
    typeCode$0: function() {
      return 13;
    },
    typeEquals$1: function(other) {
      return !!other.$isHNegate;
    },
    dataEquals$1: function(other) {
      return true;
    },
    $isHNegate: true
  },
  HBitNot: {
    "^": "HInvokeUnary;selector,sourceElement,sourcePosition,id,inputs,usedBy,block,previous,next,sideEffects,_useGvn,instructionType",
    accept$1: function(_, visitor) {
      return visitor.visitBitNot$1(this);
    },
    operation$1: function(constantSystem) {
      return constantSystem.get$bitNot();
    },
    typeCode$0: function() {
      return 14;
    },
    typeEquals$1: function(other) {
      return !!other.$isHBitNot;
    },
    dataEquals$1: function(other) {
      return true;
    },
    $isHBitNot: true
  },
  HExit: {
    "^": "HControlFlow;sourceElement,sourcePosition,id,inputs,usedBy,block,previous,next,sideEffects,_useGvn,instructionType",
    toString$0: function(_) {
      return "exit";
    },
    accept$1: function(_, visitor) {
      return visitor.visitExit$1(this);
    }
  },
  HGoto: {
    "^": "HControlFlow;sourceElement,sourcePosition,id,inputs,usedBy,block,previous,next,sideEffects,_useGvn,instructionType",
    toString$0: function(_) {
      return "goto";
    },
    accept$1: function(_, visitor) {
      return visitor.visitGoto$1(this);
    },
    $isHGoto: true
  },
  HJump: {
    "^": "HControlFlow;target>"
  },
  HBreak: {
    "^": "HJump;breakSwitchContinueLoop,target,label,sourceElement,sourcePosition,id,inputs,usedBy,block,previous,next,sideEffects,_useGvn,instructionType",
    toString$0: function(_) {
      var t1 = this.label;
      return t1 != null ? "break " + H.S(t1.get$labelName()) : "break";
    },
    accept$1: function(_, visitor) {
      return visitor.visitBreak$1(this);
    },
    $isHBreak: true
  },
  HContinue: {
    "^": "HJump;target,label,sourceElement,sourcePosition,id,inputs,usedBy,block,previous,next,sideEffects,_useGvn,instructionType",
    toString$0: function(_) {
      var t1 = this.label;
      return t1 != null ? "continue " + H.S(t1.get$labelName()) : "continue";
    },
    accept$1: function(_, visitor) {
      return visitor.visitContinue$1(this);
    },
    $isHContinue: true
  },
  HTry: {
    "^": "HControlFlow;exception<,catchBlock,finallyBlock,sourceElement,sourcePosition,id,inputs,usedBy,block,previous,next,sideEffects,_useGvn,instructionType",
    toString$0: function(_) {
      return "try";
    },
    accept$1: function(_, visitor) {
      return visitor.visitTry$1(this);
    }
  },
  HExitTry: {
    "^": "HControlFlow;sourceElement,sourcePosition,id,inputs,usedBy,block,previous,next,sideEffects,_useGvn,instructionType",
    toString$0: function(_) {
      return "exit try";
    },
    accept$1: function(_, visitor) {
      return visitor.visitExitTry$1(this);
    },
    $isHExitTry: true
  },
  HIf: {
    "^": "HConditionalBranch;blockInformation@,sourceElement,sourcePosition,id,inputs,usedBy,block,previous,next,sideEffects,_useGvn,instructionType",
    toString$0: function(_) {
      return "if";
    },
    accept$1: function(_, visitor) {
      return visitor.visitIf$1(this);
    },
    get$thenBlock: function() {
      var t1 = this.block.successors;
      if (0 >= t1.length)
        return H.ioore(t1, 0);
      return t1[0];
    },
    get$elseBlock: function() {
      var t1 = this.block.successors;
      if (1 >= t1.length)
        return H.ioore(t1, 1);
      return t1[1];
    },
    $isHIf: true
  },
  HLoopBranch: {
    "^": "HConditionalBranch;kind>,sourceElement,sourcePosition,id,inputs,usedBy,block,previous,next,sideEffects,_useGvn,instructionType",
    toString$0: function(_) {
      return "loop-branch";
    },
    accept$1: function(_, visitor) {
      return visitor.visitLoopBranch$1(this);
    },
    static: {"^": "HLoopBranch_CONDITION_FIRST_LOOP,HLoopBranch_DO_WHILE_LOOP"}
  },
  HConstant: {
    "^": "HInstruction;constant<,sourceElement,sourcePosition,id,inputs,usedBy,block,previous,next,sideEffects,_useGvn,instructionType",
    toString$0: function(_) {
      return "literal: " + this.constant.toString$0(0);
    },
    accept$1: function(_, visitor) {
      return visitor.visitConstant$1(this);
    },
    isConstant$0: function() {
      return true;
    },
    isConstantBoolean$0: function() {
      return this.constant.get$isBool();
    },
    isConstantNull$0: function() {
      return this.constant.get$isNull();
    },
    isConstantInteger$0: function() {
      return this.constant.get$isInt();
    },
    isConstantString$0: function() {
      return this.constant.get$isString();
    },
    isConstantList$0: function() {
      return this.constant.get$isList();
    },
    isConstantMap$0: function() {
      var t1 = this.constant;
      return t1.get$isMap(t1);
    },
    isConstantFalse$0: function() {
      return this.constant.get$isFalse();
    },
    isConstantTrue$0: function() {
      return this.constant.get$isTrue();
    },
    isInterceptor$1: [function(compiler) {
      return this.constant.get$isInterceptor();
    }, "call$1", "get$isInterceptor", 2, 0, 177],
    isCodeMotionInvariant$0: function() {
      return true;
    },
    set$instructionType: function(type) {
      if (!this.constant.get$isList())
        return;
      this.instructionType = type;
    },
    $isHConstant: true
  },
  HNot: {
    "^": "HInstruction;sourceElement,sourcePosition,id,inputs,usedBy,block,previous,next,sideEffects,_useGvn,instructionType",
    accept$1: function(_, visitor) {
      return visitor.visitNot$1(this);
    },
    typeCode$0: function() {
      return 15;
    },
    typeEquals$1: function(other) {
      return !!other.$isHNot;
    },
    dataEquals$1: function(other) {
      return true;
    },
    $isHNot: true
  },
  HLocalValue: {
    "^": "HInstruction;sourceElement,sourcePosition,id,inputs,usedBy,block,previous,next,sideEffects,_useGvn,instructionType",
    toString$0: function(_) {
      var t1 = this.get$sourceElement();
      return "local " + H.S(t1.get$name(t1));
    },
    accept$1: function(_, visitor) {
      return visitor.visitLocalValue$1(this);
    },
    $isHLocalValue: true
  },
  HParameterValue: {
    "^": "HLocalValue;sourceElement,sourcePosition,id,inputs,usedBy,block,previous,next,sideEffects,_useGvn,instructionType",
    toString$0: function(_) {
      var t1 = this.get$sourceElement();
      return "parameter " + H.S(t1.get$name(t1));
    },
    accept$1: function(_, visitor) {
      return visitor.visitParameterValue$1(this);
    },
    $isHParameterValue: true
  },
  HThis: {
    "^": "HParameterValue;sourceElement,sourcePosition,id,inputs,usedBy,block,previous,next,sideEffects,_useGvn,instructionType",
    get$sourceElement: function() {
      return this.sourceElement;
    },
    accept$1: function(_, visitor) {
      return visitor.visitThis$1(this);
    },
    isCodeMotionInvariant$0: function() {
      return true;
    },
    isInterceptor$1: [function(compiler) {
      return compiler.backend.isInterceptorClass$1(this.sourceElement.get$executableContext().get$enclosingClass());
    }, "call$1", "get$isInterceptor", 2, 0, 177],
    toString$0: function(_) {
      return "this";
    },
    $isHThis: true
  },
  HPhi: {
    "^": "HInstruction;logicalOperatorType,sourceElement,sourcePosition,id,inputs,usedBy,block,previous,next,sideEffects,_useGvn,instructionType",
    addInput$1: function(input) {
      J.add$1$ax(this.inputs, input);
      input.usedBy.push(this);
    },
    toString$0: function(_) {
      return "phi";
    },
    accept$1: function(_, visitor) {
      return visitor.visitPhi$1(this);
    },
    $isHPhi: true,
    static: {"^": "HPhi_IS_NOT_LOGICAL_OPERATOR,HPhi_IS_AND,HPhi_IS_OR"}
  },
  HRelational: {
    "^": "HInvokeBinary;",
    $isHRelational: true
  },
  HIdentity: {
    "^": "HRelational;singleComparisonOp,usesBoolifiedInterceptor,selector,sourceElement,sourcePosition,id,inputs,usedBy,block,previous,next,sideEffects,_useGvn,instructionType",
    accept$1: function(_, visitor) {
      return visitor.visitIdentity$1(this);
    },
    operation$1: function(constantSystem) {
      return constantSystem.get$identity();
    },
    typeCode$0: function() {
      return 16;
    },
    typeEquals$1: function(other) {
      return !!other.$isHIdentity;
    },
    dataEquals$1: function(other) {
      return true;
    },
    $isHIdentity: true
  },
  HGreater: {
    "^": "HRelational;usesBoolifiedInterceptor,selector,sourceElement,sourcePosition,id,inputs,usedBy,block,previous,next,sideEffects,_useGvn,instructionType",
    accept$1: function(_, visitor) {
      return visitor.visitGreater$1(this);
    },
    operation$1: function(constantSystem) {
      return constantSystem.get$greater();
    },
    typeCode$0: function() {
      return 17;
    },
    typeEquals$1: function(other) {
      return !!other.$isHGreater;
    },
    dataEquals$1: function(other) {
      return true;
    },
    $isHGreater: true
  },
  HGreaterEqual: {
    "^": "HRelational;usesBoolifiedInterceptor,selector,sourceElement,sourcePosition,id,inputs,usedBy,block,previous,next,sideEffects,_useGvn,instructionType",
    accept$1: function(_, visitor) {
      return visitor.visitGreaterEqual$1(this);
    },
    operation$1: function(constantSystem) {
      return constantSystem.get$greaterEqual();
    },
    typeCode$0: function() {
      return 18;
    },
    typeEquals$1: function(other) {
      return !!other.$isHGreaterEqual;
    },
    dataEquals$1: function(other) {
      return true;
    },
    $isHGreaterEqual: true
  },
  HLess: {
    "^": "HRelational;usesBoolifiedInterceptor,selector,sourceElement,sourcePosition,id,inputs,usedBy,block,previous,next,sideEffects,_useGvn,instructionType",
    accept$1: function(_, visitor) {
      return visitor.visitLess$1(this);
    },
    operation$1: function(constantSystem) {
      return constantSystem.get$less();
    },
    typeCode$0: function() {
      return 19;
    },
    typeEquals$1: function(other) {
      return !!other.$isHLess;
    },
    dataEquals$1: function(other) {
      return true;
    },
    $isHLess: true
  },
  HLessEqual: {
    "^": "HRelational;usesBoolifiedInterceptor,selector,sourceElement,sourcePosition,id,inputs,usedBy,block,previous,next,sideEffects,_useGvn,instructionType",
    accept$1: function(_, visitor) {
      return visitor.visitLessEqual$1(this);
    },
    operation$1: function(constantSystem) {
      return constantSystem.get$lessEqual();
    },
    typeCode$0: function() {
      return 20;
    },
    typeEquals$1: function(other) {
      return !!other.$isHLessEqual;
    },
    dataEquals$1: function(other) {
      return true;
    },
    $isHLessEqual: true
  },
  HReturn: {
    "^": "HControlFlow;sourceElement,sourcePosition,id,inputs,usedBy,block,previous,next,sideEffects,_useGvn,instructionType",
    toString$0: function(_) {
      return "return";
    },
    accept$1: function(_, visitor) {
      return visitor.visitReturn$1(this);
    }
  },
  HThrowExpression: {
    "^": "HInstruction;sourceElement,sourcePosition,id,inputs,usedBy,block,previous,next,sideEffects,_useGvn,instructionType",
    toString$0: function(_) {
      return "throw expression";
    },
    accept$1: function(_, visitor) {
      return visitor.visitThrowExpression$1(this);
    },
    canThrow$0: function() {
      return true;
    }
  },
  HThrow: {
    "^": "HControlFlow;isRethrow,sourceElement,sourcePosition,id,inputs,usedBy,block,previous,next,sideEffects,_useGvn,instructionType",
    toString$0: function(_) {
      return "throw";
    },
    accept$1: function(_, visitor) {
      return visitor.visitThrow$1(this);
    }
  },
  HStatic: {
    "^": "HInstruction;element<,sourceElement,sourcePosition,id,inputs,usedBy,block,previous,next,sideEffects,_useGvn,instructionType",
    toString$0: function(_) {
      var t1 = this.element;
      return "static " + H.S(t1.get$name(t1));
    },
    accept$1: function(_, visitor) {
      return visitor.visitStatic$1(this);
    },
    gvnHashCode$0: function() {
      var t1, t2;
      t1 = B.HInstruction.prototype.gvnHashCode$0.call(this);
      t2 = J.get$hashCode$(this.element);
      if (typeof t2 !== "number")
        return H.iae(t2);
      return (t1 ^ t2) >>> 0;
    },
    typeCode$0: function() {
      return 21;
    },
    typeEquals$1: function(other) {
      return !!other.$isHStatic;
    },
    dataEquals$1: function(other) {
      var t1, t2;
      t1 = this.element;
      t2 = other.get$element();
      return t1 == null ? t2 == null : t1 === t2;
    },
    isCodeMotionInvariant$0: function() {
      return !this.element.get$isAssignable();
    },
    HStatic$2: function(element, type) {
      var t1;
      this.sideEffects.clearAllSideEffects$0();
      this.sideEffects.clearAllDependencies$0();
      if (this.element.get$isAssignable()) {
        t1 = this.sideEffects;
        t1.flags = (t1.flags | 32) >>> 0;
      }
      this._useGvn = true;
    },
    $isHStatic: true,
    static: {HStatic$: function(element, type) {
        var t1, t2;
        t1 = H.setRuntimeTypeInfo([], [B.HInstruction]);
        t2 = $.HInstruction_idCounter;
        if (typeof t2 !== "number")
          return t2.$add();
        $.HInstruction_idCounter = t2 + 1;
        t2 = new B.HStatic(element, null, null, t2, t1, H.setRuntimeTypeInfo([], [B.HInstruction]), null, null, null, new Z.SideEffects(0), false, type);
        t2.HInstruction$2(t1, type);
        t2.HStatic$2(element, type);
        return t2;
      }}
  },
  HInterceptor: {
    "^": "HInstruction;interceptedClasses<,sourceElement,sourcePosition,id,inputs,usedBy,block,previous,next,sideEffects,_useGvn,instructionType",
    toString$0: function(_) {
      return "interceptor on " + J.toString$0(this.interceptedClasses);
    },
    accept$1: function(_, visitor) {
      return visitor.visitInterceptor$1(this);
    },
    get$receiver: function() {
      var t1 = this.inputs;
      if (0 >= t1.length)
        return H.ioore(t1, 0);
      return t1[0];
    },
    isInterceptor$1: [function(compiler) {
      return true;
    }, "call$1", "get$isInterceptor", 2, 0, 177],
    typeCode$0: function() {
      return 4;
    },
    typeEquals$1: function(other) {
      return !!other.$isHInterceptor;
    },
    dataEquals$1: function(other) {
      var t1, t2;
      t1 = this.interceptedClasses;
      t2 = other.get$interceptedClasses();
      if (t1 == null ? t2 != null : t1 !== t2) {
        t1 = this.interceptedClasses;
        t1 = t1.get$length(t1);
        t2 = other.get$interceptedClasses();
        t2 = t2.get$length(t2);
        t1 = (t1 == null ? t2 == null : t1 === t2) && this.interceptedClasses.containsAll$1(other.get$interceptedClasses());
      } else
        t1 = true;
      return t1;
    },
    HInterceptor$2: function(receiver, type) {
      this.sideEffects.clearAllSideEffects$0();
      this.sideEffects.clearAllDependencies$0();
      this._useGvn = true;
    },
    $isHInterceptor: true
  },
  HOneShotInterceptor: {
    "^": "HInvokeDynamic;interceptedClasses<,specializer,selector,element,sourceElement,sourcePosition,id,inputs,usedBy,block,previous,next,sideEffects,_useGvn,instructionType",
    isCallOnInterceptor$1: function(compiler) {
      return true;
    },
    toString$0: function(_) {
      return "one shot interceptor on " + J.toString$0(this.selector);
    },
    accept$1: function(_, visitor) {
      return visitor.visitOneShotInterceptor$1(this);
    },
    HOneShotInterceptor$4: function(selector, inputs, type, interceptedClasses) {
    }
  },
  HLazyStatic: {
    "^": "HInstruction;element<,sourceElement,sourcePosition,id,inputs,usedBy,block,previous,next,sideEffects,_useGvn,instructionType",
    toString$0: function(_) {
      var t1 = this.element;
      return "lazy static " + H.S(t1.get$name(t1));
    },
    accept$1: function(_, visitor) {
      return visitor.visitLazyStatic$1(this);
    },
    typeCode$0: function() {
      return 30;
    },
    isCodeMotionInvariant$0: function() {
      return false;
    },
    canThrow$0: function() {
      return true;
    }
  },
  HStaticStore: {
    "^": "HInstruction;element<,sourceElement,sourcePosition,id,inputs,usedBy,block,previous,next,sideEffects,_useGvn,instructionType",
    toString$0: function(_) {
      var t1 = this.element;
      return "static store " + H.S(t1.get$name(t1));
    },
    accept$1: function(_, visitor) {
      return visitor.visitStaticStore$1(this);
    },
    typeCode$0: function() {
      return 22;
    },
    typeEquals$1: function(other) {
      return !!other.$isHStaticStore;
    },
    dataEquals$1: function(other) {
      return this.element === other.get$element();
    },
    isJsStatement$0: function() {
      return true;
    },
    HStaticStore$2: function(element, value) {
      var t1;
      this.sideEffects.clearAllSideEffects$0();
      this.sideEffects.clearAllDependencies$0();
      t1 = this.sideEffects;
      t1.flags = (t1.flags | 4) >>> 0;
    },
    $isHStaticStore: true
  },
  HLiteralList: {
    "^": "HInstruction;sourceElement,sourcePosition,id,inputs,usedBy,block,previous,next,sideEffects,_useGvn,instructionType",
    toString$0: function(_) {
      return "literal list";
    },
    accept$1: function(_, visitor) {
      return visitor.visitLiteralList$1(this);
    },
    $isHLiteralList: true
  },
  HIndex: {
    "^": "HInstruction;selector<,sourceElement,sourcePosition,id,inputs,usedBy,block,previous,next,sideEffects,_useGvn,instructionType",
    toString$0: function(_) {
      return "index operator";
    },
    accept$1: function(_, visitor) {
      return visitor.visitIndex$1(this);
    },
    get$receiver: function() {
      var t1 = this.inputs;
      if (0 >= t1.length)
        return H.ioore(t1, 0);
      return t1[0];
    },
    get$index: function(_) {
      var t1 = this.inputs;
      if (1 >= t1.length)
        return H.ioore(t1, 1);
      return t1[1];
    },
    getDartReceiver$1: function(compiler) {
      var t1 = this.inputs;
      if (0 >= t1.length)
        return H.ioore(t1, 0);
      return t1[0];
    },
    onlyThrowsNSM$0: function() {
      return true;
    },
    canThrow$0: function() {
      var t1 = this.inputs;
      if (0 >= t1.length)
        return H.ioore(t1, 0);
      return t1[0].get$instructionType().get$isNullable();
    },
    typeCode$0: function() {
      return 27;
    },
    typeEquals$1: function(other) {
      return !!other.$isHIndex;
    },
    dataEquals$1: function(other) {
      return true;
    },
    HIndex$4: function(receiver, index, selector, type) {
      var t1;
      this.sideEffects.clearAllSideEffects$0();
      this.sideEffects.clearAllDependencies$0();
      t1 = this.sideEffects;
      t1.flags = (t1.flags | 8) >>> 0;
      this._useGvn = true;
    },
    $isHIndex: true
  },
  HIndexAssign: {
    "^": "HInstruction;selector<,sourceElement,sourcePosition,id,inputs,usedBy,block,previous,next,sideEffects,_useGvn,instructionType",
    toString$0: function(_) {
      return "index assign operator";
    },
    accept$1: function(_, visitor) {
      return visitor.visitIndexAssign$1(this);
    },
    get$receiver: function() {
      var t1 = this.inputs;
      if (0 >= t1.length)
        return H.ioore(t1, 0);
      return t1[0];
    },
    get$index: function(_) {
      var t1 = this.inputs;
      if (1 >= t1.length)
        return H.ioore(t1, 1);
      return t1[1];
    },
    get$value: function(_) {
      var t1 = this.inputs;
      if (2 >= t1.length)
        return H.ioore(t1, 2);
      return t1[2];
    },
    getDartReceiver$1: function(compiler) {
      var t1 = this.inputs;
      if (0 >= t1.length)
        return H.ioore(t1, 0);
      return t1[0];
    },
    onlyThrowsNSM$0: function() {
      return true;
    },
    canThrow$0: function() {
      var t1 = this.inputs;
      if (0 >= t1.length)
        return H.ioore(t1, 0);
      return t1[0].get$instructionType().get$isNullable();
    },
    HIndexAssign$4: function(receiver, index, value, selector) {
      var t1;
      this.sideEffects.clearAllSideEffects$0();
      this.sideEffects.clearAllDependencies$0();
      t1 = this.sideEffects;
      t1.flags = (t1.flags | 1) >>> 0;
    }
  },
  HIs: {
    "^": "HInstruction;typeExpression<,kind>,sourceElement,sourcePosition,id,inputs,usedBy,block,previous,next,sideEffects,_useGvn,instructionType",
    get$expression: function() {
      var t1 = this.inputs;
      if (0 >= t1.length)
        return H.ioore(t1, 0);
      return t1[0];
    },
    get$interceptor: function() {
      var t1 = this.inputs;
      return t1.length > 1 ? t1[1] : null;
    },
    accept$1: function(_, visitor) {
      return visitor.visitIs$1(this);
    },
    toString$0: function(_) {
      var t1 = this.inputs;
      if (0 >= t1.length)
        return H.ioore(t1, 0);
      return H.S(t1[0]) + " is " + this.typeExpression.toString$0(0);
    },
    typeCode$0: function() {
      return 28;
    },
    typeEquals$1: function(other) {
      return !!other.$isHIs;
    },
    dataEquals$1: function(other) {
      return this.typeExpression.$eq(0, other.get$typeExpression()) && this.kind === other.get$kind(other);
    },
    HIs$internal$4: function(typeExpression, inputs, kind, type) {
      this._useGvn = true;
    },
    $isHIs: true,
    static: {"^": "HIs_RAW_CHECK,HIs_COMPOUND_CHECK,HIs_VARIABLE_CHECK"}
  },
  HIsViaInterceptor: {
    "^": "HLateInstruction;typeExpression<,sourceElement,sourcePosition,id,inputs,usedBy,block,previous,next,sideEffects,_useGvn,instructionType",
    accept$1: function(_, visitor) {
      return visitor.visitIsViaInterceptor$1(this);
    },
    toString$0: function(_) {
      var t1 = this.inputs;
      if (0 >= t1.length)
        return H.ioore(t1, 0);
      return H.S(t1[0]) + " is " + this.typeExpression.toString$0(0);
    },
    typeCode$0: function() {
      return 37;
    },
    typeEquals$1: function(other) {
      return !!other.$isHIsViaInterceptor;
    },
    dataEquals$1: function(other) {
      return this.typeExpression.$eq(0, other.get$typeExpression());
    },
    $isHIsViaInterceptor: true
  },
  HTypeConversion: {
    "^": "HCheck;typeExpression<,kind>,receiverTypeCheckSelector,contextIsTypeArguments,checkedType<,sourceElement,sourcePosition,id,inputs,usedBy,block,previous,next,sideEffects,_useGvn,instructionType",
    convertType$3: function(compiler, type, kind) {
      if (J.$eq(this.typeExpression, type))
        return this;
      return B.HInstruction.prototype.convertType$3.call(this, compiler, type, kind);
    },
    accept$1: function(_, visitor) {
      return visitor.visitTypeConversion$1(this);
    },
    isJsStatement$0: function() {
      var t1 = this.kind;
      return t1 === 1 || t1 === 4;
    },
    isControlFlow$0: function() {
      var t1 = this.kind;
      return t1 === 1 || t1 === 4;
    },
    typeCode$0: function() {
      return 24;
    },
    typeEquals$1: function(other) {
      return !!other.$isHTypeConversion;
    },
    isCodeMotionInvariant$0: function() {
      return false;
    },
    dataEquals$1: function(other) {
      var t1, t2;
      if (this.kind === other.get$kind(other))
        if (J.$eq(this.typeExpression, other.get$typeExpression()))
          if (J.$eq(this.checkedType, other.get$checkedType())) {
            t1 = this.receiverTypeCheckSelector;
            t2 = other.receiverTypeCheckSelector;
            t2 = t1 == null ? t2 == null : t1 === t2;
            t1 = t2;
          } else
            t1 = false;
        else
          t1 = false;
      else
        t1 = false;
      return t1;
    },
    HTypeConversion$withTypeRepresentation$5: function(typeExpression, kind, type, input, typeRepresentation) {
      this.sourceElement = input.get$sourceElement();
    },
    HTypeConversion$5: function(typeExpression, kind, type, input, receiverTypeCheckSelector) {
      this.sourceElement = input.get$sourceElement();
    },
    $isHTypeConversion: true,
    static: {"^": "HTypeConversion_CHECKED_MODE_CHECK,HTypeConversion_ARGUMENT_TYPE_CHECK,HTypeConversion_CAST_TYPE_CHECK,HTypeConversion_BOOLEAN_CONVERSION_CHECK,HTypeConversion_RECEIVER_TYPE_CHECK", HTypeConversion$: function(typeExpression, kind, type, input, receiverTypeCheckSelector) {
        var t1, t2;
        t1 = H.setRuntimeTypeInfo([input], [B.HInstruction]);
        t2 = $.HInstruction_idCounter;
        if (typeof t2 !== "number")
          return t2.$add();
        $.HInstruction_idCounter = t2 + 1;
        t2 = new B.HTypeConversion(typeExpression, kind, receiverTypeCheckSelector, false, type, null, null, t2, t1, H.setRuntimeTypeInfo([], [B.HInstruction]), null, null, null, new Z.SideEffects(0), false, type);
        t2.HInstruction$2(t1, type);
        t2._useGvn = true;
        t2.HTypeConversion$5(typeExpression, kind, type, input, receiverTypeCheckSelector);
        return t2;
      }, HTypeConversion$withTypeRepresentation: function(typeExpression, kind, type, input, typeRepresentation) {
        var t1, t2;
        t1 = H.setRuntimeTypeInfo([input, typeRepresentation], [B.HInstruction]);
        t2 = $.HInstruction_idCounter;
        if (typeof t2 !== "number")
          return t2.$add();
        $.HInstruction_idCounter = t2 + 1;
        t2 = new B.HTypeConversion(typeExpression, kind, null, false, type, null, null, t2, t1, H.setRuntimeTypeInfo([], [B.HInstruction]), null, null, null, new Z.SideEffects(0), false, type);
        t2.HInstruction$2(t1, type);
        t2._useGvn = true;
        t2.HTypeConversion$withTypeRepresentation$5(typeExpression, kind, type, input, typeRepresentation);
        return t2;
      }}
  },
  HTypeKnown: {
    "^": "HCheck;knownType@,_isMovable,sourceElement,sourcePosition,id,inputs,usedBy,block,previous,next,sideEffects,_useGvn,instructionType",
    toString$0: function(_) {
      return "TypeKnown " + J.toString$0(this.knownType);
    },
    accept$1: function(_, visitor) {
      return visitor.visitTypeKnown$1(this);
    },
    isJsStatement$0: function() {
      return false;
    },
    isControlFlow$0: function() {
      return false;
    },
    canThrow$0: function() {
      return false;
    },
    typeCode$0: function() {
      return 25;
    },
    typeEquals$1: function(other) {
      return !!other.$isHTypeKnown;
    },
    isCodeMotionInvariant$0: function() {
      return true;
    },
    get$isMovable: function() {
      return this._isMovable && this._useGvn;
    },
    dataEquals$1: function(other) {
      return J.$eq(this.knownType, other.get$knownType()) && J.$eq(this.instructionType, other.instructionType);
    },
    $isHTypeKnown: true
  },
  HRangeConversion: {
    "^": "HCheck;sourceElement,sourcePosition,id,inputs,usedBy,block,previous,next,sideEffects,_useGvn,instructionType",
    get$isMovable: function() {
      return false;
    },
    accept$1: function(_, visitor) {
      return visitor.visitRangeConversion$1(this);
    }
  },
  HStringConcat: {
    "^": "HInstruction;node<,sourceElement,sourcePosition,id,inputs,usedBy,block,previous,next,sideEffects,_useGvn,instructionType",
    get$left: function(_) {
      var t1 = this.inputs;
      if (0 >= t1.length)
        return H.ioore(t1, 0);
      return t1[0];
    },
    get$right: function(_) {
      var t1 = this.inputs;
      if (1 >= t1.length)
        return H.ioore(t1, 1);
      return t1[1];
    },
    accept$1: function(_, visitor) {
      return visitor.visitStringConcat$1(this);
    },
    toString$0: function(_) {
      return "string concat";
    },
    $isHStringConcat: true
  },
  HStringify: {
    "^": "HInstruction;node<,sourceElement,sourcePosition,id,inputs,usedBy,block,previous,next,sideEffects,_useGvn,instructionType",
    accept$1: function(_, visitor) {
      return visitor.visitStringify$1(this);
    },
    toString$0: function(_) {
      return "stringify";
    }
  },
  HLoopInformation: {
    "^": "Object;header,blocks,backEdges,labels,target>,loopBlockInformation",
    addBackEdge$1: function(predecessor) {
      var workQueue;
      this.backEdges.push(predecessor);
      workQueue = H.setRuntimeTypeInfo([predecessor], [B.HBasicBlock]);
      do {
        if (0 >= workQueue.length)
          return H.ioore(workQueue, 0);
        this.addBlock$2(workQueue.pop(), workQueue);
      } while (workQueue.length !== 0);
    },
    addBlock$2: function(block, workQueue) {
      var t1, parentHeader;
      t1 = this.header;
      if (block === t1)
        return;
      parentHeader = block.parentLoopHeader;
      if (parentHeader === t1)
        ;
      else if (parentHeader != null)
        workQueue.push(parentHeader);
      else {
        block.parentLoopHeader = t1;
        this.blocks.push(block);
        C.JSArray_methods.addAll$1(workQueue, block.predecessors);
      }
    }
  },
  HBlockFlow: {
    "^": "Object;body>,continuation<"
  },
  HBlockInformation: {
    "^": "Object;"
  },
  HStatementInformation: {
    "^": "HBlockInformation;",
    $isHStatementInformation: true
  },
  HSubGraphBlockInformation: {
    "^": "Object;subGraph",
    get$start: function(_) {
      return this.subGraph.start;
    },
    get$end: function() {
      return this.subGraph.end;
    },
    accept$1: function(_, visitor) {
      return visitor.visitSubGraphInfo$1(this);
    },
    $isHStatementInformation: true
  },
  HSubExpressionBlockInformation: {
    "^": "Object;subExpression<",
    get$start: function(_) {
      return this.subExpression.start;
    },
    get$end: function() {
      return this.subExpression.end;
    },
    accept$1: function(_, visitor) {
      return visitor.visitSubExpressionInfo$1(this);
    }
  },
  HLabeledBlockInformation: {
    "^": "Object;body>,labels,target>,isContinue",
    get$start: function(_) {
      return this.body.subGraph.start;
    },
    get$end: function() {
      return this.body.subGraph.end;
    },
    accept$1: function(_, visitor) {
      return visitor.visitLabeledBlockInfo$1(this);
    },
    $isHLabeledBlockInformation: true,
    $isHStatementInformation: true
  },
  LoopTypeVisitor: {
    "^": "Visitor;",
    visitNode$1: function(node) {
      return -1;
    },
    visitWhile$1: function(node) {
      return 0;
    },
    visitFor$1: function(node) {
      return 1;
    },
    visitDoWhile$1: function(node) {
      return 2;
    },
    visitForIn$1: function(node) {
      return 3;
    },
    visitSwitchStatement$1: function(node) {
      return 4;
    },
    $asVisitor: function() {
      return [null];
    }
  },
  HLoopBlockInformation: {
    "^": "Object;kind>,initializer<,condition,body>,updates,target>,labels,sourcePosition<,endSourcePosition",
    get$start: function(_) {
      var t1 = this.initializer;
      if (t1 != null)
        return t1.subExpression.start;
      if (this.kind === 2)
        return this.body.subGraph.start;
      return this.condition.subExpression.start;
    },
    get$end: function() {
      var t1 = this.updates;
      if (t1 != null)
        return t1.subExpression.end;
      if (this.kind === 2 && this.condition != null)
        return this.condition.subExpression.end;
      return this.body.subGraph.end;
    },
    accept$1: function(_, visitor) {
      return visitor.visitLoopInfo$1(this);
    },
    $isHStatementInformation: true,
    static: {"^": "HLoopBlockInformation_WHILE_LOOP,HLoopBlockInformation_FOR_LOOP,HLoopBlockInformation_DO_WHILE_LOOP,HLoopBlockInformation_FOR_IN_LOOP,HLoopBlockInformation_SWITCH_CONTINUE_LOOP,HLoopBlockInformation_NOT_A_LOOP"}
  },
  HIfBlockInformation: {
    "^": "Object;condition,thenGraph<,elseGraph<",
    get$start: function(_) {
      return this.condition.subExpression.start;
    },
    get$end: function() {
      var t1 = this.elseGraph;
      return t1 == null ? this.thenGraph.subGraph.end : t1.subGraph.end;
    },
    accept$1: function(_, visitor) {
      return visitor.visitIfInfo$1(this);
    },
    $isHStatementInformation: true
  },
  HTryBlockInformation: {
    "^": "Object;body>,catchVariable,catchBlock,finallyBlock",
    get$start: function(_) {
      return this.body.subGraph.start;
    },
    get$end: function() {
      var t1 = this.finallyBlock;
      return t1 == null ? this.catchBlock.subGraph.end : t1.subGraph.end;
    },
    accept$1: function(_, visitor) {
      return visitor.visitTryInfo$1(this);
    },
    $isHStatementInformation: true
  },
  HSwitchBlockInformation: {
    "^": "Object;expression<,statements,target>,labels",
    get$start: function(_) {
      return this.expression.subExpression.start;
    },
    get$end: function() {
      return C.JSArray_methods.get$last(this.statements).get$end();
    },
    accept$1: function(_, visitor) {
      return visitor.visitSwitchInfo$1(this);
    },
    $isHStatementInformation: true
  },
  HReadTypeVariable: {
    "^": "HInstruction;dartType<,hasReceiver<,sourceElement,sourcePosition,id,inputs,usedBy,block,previous,next,sideEffects,_useGvn,instructionType",
    accept$1: function(_, visitor) {
      return visitor.visitReadTypeVariable$1(this);
    },
    canThrow$0: function() {
      return false;
    },
    typeCode$0: function() {
      return 31;
    },
    typeEquals$1: function(other) {
      return !!other.$isHReadTypeVariable;
    },
    dataEquals$1: function(other) {
      return this.dartType.element === other.get$dartType().element && this.hasReceiver === other.get$hasReceiver();
    },
    $isHReadTypeVariable: true
  },
  HRuntimeType: {
    "^": "HInstruction;dartType<",
    canThrow$0: function() {
      return false;
    },
    typeCode$0: function() {
      throw H.wrapException("abstract method");
    },
    typeEquals$1: function(other) {
      throw H.wrapException("abstract method");
    },
    dataEquals$1: function(other) {
      return J.$eq(this.dartType, other.get$dartType());
    }
  },
  HFunctionType: {
    "^": "HRuntimeType;dartType,sourceElement,sourcePosition,id,inputs,usedBy,block,previous,next,sideEffects,_useGvn,instructionType",
    accept$1: function(_, visitor) {
      return visitor.visitFunctionType$1(this);
    },
    typeCode$0: function() {
      return 32;
    },
    typeEquals$1: function(other) {
      return !!other.$isHFunctionType;
    },
    $isHFunctionType: true
  },
  HVoidType: {
    "^": "HRuntimeType;dartType,sourceElement,sourcePosition,id,inputs,usedBy,block,previous,next,sideEffects,_useGvn,instructionType",
    accept$1: function(_, visitor) {
      return visitor.visitVoidType$1(this);
    },
    typeCode$0: function() {
      return 33;
    },
    typeEquals$1: function(other) {
      return !!other.$isHVoidType;
    },
    $isHVoidType: true
  },
  HInterfaceType: {
    "^": "HRuntimeType;dartType,sourceElement,sourcePosition,id,inputs,usedBy,block,previous,next,sideEffects,_useGvn,instructionType",
    accept$1: function(_, visitor) {
      return visitor.visitInterfaceType$1(this);
    },
    typeCode$0: function() {
      return 34;
    },
    typeEquals$1: function(other) {
      return !!other.$isHInterfaceType;
    },
    $isHInterfaceType: true
  },
  HDynamicType: {
    "^": "HRuntimeType;dartType,sourceElement,sourcePosition,id,inputs,usedBy,block,previous,next,sideEffects,_useGvn,instructionType",
    accept$1: function(_, visitor) {
      return visitor.visitDynamicType$1(this);
    },
    typeCode$0: function() {
      return 35;
    },
    typeEquals$1: function(other) {
      return !!other.$isHDynamicType;
    },
    $isHDynamicType: true
  },
  OptimizationPhase: {
    "^": "Object;"
  },
  SsaOptimizerTask: {
    "^": "CompilerTask;backend<,ranges<,compiler,watch,profilerTag",
    get$name: function(_) {
      return "SSA optimizer";
    },
    get$compiler: function() {
      return this.backend.compiler;
    },
    runPhases$2: function(graph, phases) {
      var t1, t2, phase;
      for (t1 = H.setRuntimeTypeInfo(new H.ListIterator(phases, phases.length, 0, null), [H.getTypeArgumentByIndex(phases, 0)]), t2 = this.backend.compiler; t1.moveNext$0();) {
        phase = t1.__internal$_current;
        phase.visitGraph$1(graph);
        t2.tracer.traceGraph$2(J.get$name$x(phase), graph);
      }
    },
    optimize$2: function(work, graph) {
      this.measure$1(new B.SsaOptimizerTask_optimize_closure(this, work, graph, this.backend.compiler.backend.get$constantSystem(), work.compilationContext));
    }
  },
  SsaOptimizerTask_optimize_closure: {
    "^": "Closure:23;this_0,work_1,graph_2,constantSystem_3,context_4",
    call$0: function() {
      var t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15, t16, t17, t18, t19, t20, t21, t22, dce, t23, phases;
      t1 = this.constantSystem_3;
      t2 = this.this_0;
      t3 = t2.backend;
      t4 = this.work_1;
      t5 = t3.compiler;
      t6 = P.LinkedHashMap_LinkedHashMap(null, null, null, P.$int, B.HInstruction);
      t7 = H.setRuntimeTypeInfo([], [P.$int]);
      t8 = P.LinkedHashMap_LinkedHashMap(null, null, null, B.HInstruction, P.Function);
      t9 = this.context_4.boundsChecked;
      t10 = P.LinkedHashMap_LinkedHashMap(null, null, null, P.$int, B.HInstruction);
      t11 = H.setRuntimeTypeInfo([], [P.$int]);
      t12 = P.LinkedHashMap_LinkedHashMap(null, null, null, B.HInstruction, P.Function);
      t13 = P.LinkedHashSet_LinkedHashSet(null, null, null, P.$int);
      t14 = P.LinkedHashMap_LinkedHashMap(null, null, null, P.$int, B.HInstruction);
      t15 = H.setRuntimeTypeInfo([], [P.$int]);
      t16 = P.LinkedHashMap_LinkedHashMap(null, null, null, B.HInstruction, P.Function);
      t17 = P.LinkedHashMap_LinkedHashMap(null, null, null, P.$int, B.HInstruction);
      t18 = H.setRuntimeTypeInfo([], [P.$int]);
      t19 = P.LinkedHashMap_LinkedHashMap(null, null, null, B.HInstruction, P.Function);
      t20 = H.setRuntimeTypeInfo([], [B.HRangeConversion]);
      t21 = P.LinkedHashMap_LinkedHashMap(null, null, null, B.HInstruction, B.Range);
      t22 = new B.ValueRangeInfo(t1, null, null);
      t22.intZero = new B.IntValue(0, t22);
      t22.intOne = new B.IntValue(1, t22);
      dce = new B.SsaDeadCodeEliminator("SsaDeadCodeEliminator", t5, null, false, null);
      t23 = this.graph_2;
      t2.runPhases$2(t23, H.setRuntimeTypeInfo([new B.SsaInstructionSimplifier("SsaInstructionSimplifier", t3, t4, t1, null, null), new B.SsaTypeConversionInserter("SsaTypeconversionInserter", t5, null), new B.SsaRedundantPhiEliminator("SsaRedundantPhiEliminator"), new B.SsaDeadPhiEliminator("SsaDeadPhiEliminator"), new B.SsaTypePropagator(t6, t7, t8, t5, null), new B.SsaInstructionSimplifier("SsaInstructionSimplifier", t3, t4, t1, null, null), new B.SsaCheckInserter(t9, t4, t3, "SsaCheckInserter", null, null), new B.SsaInstructionSimplifier("SsaInstructionSimplifier", t3, t4, t1, null, null), new B.SsaCheckInserter(t9, t4, t3, "SsaCheckInserter", null, null), new B.SsaTypePropagator(t10, t11, t12, t5, null), new B.SsaDeadCodeEliminator("SsaDeadCodeEliminator", t5, null, false, null), new B.SsaGlobalValueNumberer("SsaGlobalValueNumberer", t5, t13, null, null), new B.SsaTypePropagator(t14, t15, t16, t5, null), new B.SsaCodeMotion("SsaCodeMotion", null, null), new B.SsaLoadElimination(t5, "SsaLoadElimination", null, null, null), new B.SsaDeadPhiEliminator("SsaDeadPhiEliminator"), new B.SsaTypePropagator(t17, t18, t19, t5, null), new B.SsaValueRangeAnalyzer(t20, t21, t5, t1, t22, t4, null, null), new B.SsaInstructionSimplifier("SsaInstructionSimplifier", t3, t4, t1, null, null), new B.SsaCheckInserter(t9, t4, t3, "SsaCheckInserter", null, null), new B.SsaSimplifyInterceptors("SsaSimplifyInterceptors", t1, t5, t4, null, null), dce, new B.SsaTypePropagator(P.LinkedHashMap_LinkedHashMap(null, null, null, P.$int, B.HInstruction), H.setRuntimeTypeInfo([], [P.$int]), P.LinkedHashMap_LinkedHashMap(null, null, null, B.HInstruction, P.Function), t5, null)], [B.OptimizationPhase]));
      if (dce.eliminatedSideEffects) {
        t6 = P.LinkedHashSet_LinkedHashSet(null, null, null, P.$int);
        t7 = H.setRuntimeTypeInfo([], [B.HRangeConversion]);
        t8 = P.LinkedHashMap_LinkedHashMap(null, null, null, B.HInstruction, B.Range);
        t10 = new B.ValueRangeInfo(t1, null, null);
        t10.intZero = new B.IntValue(0, t10);
        t10.intOne = new B.IntValue(1, t10);
        phases = H.setRuntimeTypeInfo([new B.SsaGlobalValueNumberer("SsaGlobalValueNumberer", t5, t6, null, null), new B.SsaCodeMotion("SsaCodeMotion", null, null), new B.SsaValueRangeAnalyzer(t7, t8, t5, t1, t10, t4, null, null), new B.SsaInstructionSimplifier("SsaInstructionSimplifier", t3, t4, t1, null, null), new B.SsaCheckInserter(t9, t4, t3, "SsaCheckInserter", null, null), new B.SsaSimplifyInterceptors("SsaSimplifyInterceptors", t1, t5, t4, null, null), new B.SsaDeadCodeEliminator("SsaDeadCodeEliminator", t5, null, false, null)], [B.OptimizationPhase]);
      } else
        phases = H.setRuntimeTypeInfo([new B.SsaInstructionSimplifier("SsaInstructionSimplifier", t3, t4, t1, null, null)], [B.OptimizationPhase]);
      t2.runPhases$2(t23, phases);
    },
    $isFunction: true
  },
  SsaInstructionSimplifier: {
    "^": "HBaseVisitor;name>,backend<,work,constantSystem,graph,currentBlock",
    get$compiler: function() {
      return this.backend.compiler;
    },
    visitGraph$1: function(visitee) {
      this.graph = visitee;
      this.visitDominatorTree$1(visitee);
    },
    visitBasicBlock$1: function(block) {
      var instruction, t1, next, replacement;
      instruction = block.first;
      for (t1 = this.backend.compiler; instruction != null; instruction = next) {
        next = instruction.next;
        replacement = instruction.accept$1(0, this);
        if (!J.$eq(replacement, instruction)) {
          block.rewrite$2(instruction, replacement);
          if (!(replacement.get$instructionType().containsOnlyNum$1(t1) && instruction.instructionType.containsOnlyNum$1(t1)))
            replacement.set$instructionType(replacement.instructionType.intersection$2(0, instruction.instructionType, t1));
          if (replacement.get$sourceElement() == null)
            replacement.sourceElement = instruction.get$sourceElement();
          if (replacement.sourcePosition == null)
            replacement.sourcePosition = instruction.sourcePosition;
          if (replacement.block == null) {
            block.addAfter$2(instruction, replacement);
            next = replacement;
          }
          block.remove$1(0, instruction);
        }
      }
    },
    visitInstruction$1: function(node) {
      return node;
    },
    visitBoolify$1: function(node) {
      var inputs, input, t1, t2;
      inputs = node.inputs;
      if (0 >= inputs.length)
        return H.ioore(inputs, 0);
      input = inputs[0];
      t1 = this.backend;
      t2 = t1.compiler;
      if (input.get$instructionType().containsOnlyBool$1(t2) && !input.instructionType.get$isNullable())
        return input;
      if (input.instructionType.contains$2(0, t1.jsBoolClass, t2) !== true) {
        t1 = this.graph;
        t1.toString;
        return t1.addConstant$2(t2.backend.get$constantSystem().createBool$1(false), t2);
      }
      return node;
    },
    visitNot$1: function(node) {
      var inputs, input, t1, isTrue, t2;
      inputs = node.inputs;
      if (0 >= inputs.length)
        return H.ioore(inputs, 0);
      input = inputs[0];
      t1 = J.getInterceptor(input);
      if (!!t1.$isHConstant) {
        isTrue = input.constant.get$isTrue();
        t1 = this.graph;
        t2 = this.backend.compiler;
        t1.toString;
        return t1.addConstant$2(t2.backend.get$constantSystem().createBool$1(!isTrue), t2);
      } else if (!!t1.$isHNot) {
        t1 = input.inputs;
        if (0 >= t1.length)
          return H.ioore(t1, 0);
        return t1[0];
      }
      return node;
    },
    visitInvokeUnary$1: function(node) {
      var t1, t2, folded;
      t1 = node.operation$1(this.constantSystem);
      t2 = node.inputs;
      if (0 >= t2.length)
        return H.ioore(t2, 0);
      folded = this.foldUnary$2(t1, t2[0]);
      return folded != null ? folded : node;
    },
    foldUnary$2: function(operation, operand) {
      var folded;
      if (!!J.getInterceptor(operand).$isHConstant) {
        folded = J.fold$1$ax(operation, operand.constant);
        if (folded != null)
          return this.graph.addConstant$2(folded, this.backend.compiler);
      }
      return;
    },
    tryOptimizeLengthInterceptedGetter$1: function(node) {
      var t1, actualReceiver, t2, constant, t3, element, isFixed;
      t1 = node.inputs;
      if (1 >= t1.length)
        return H.ioore(t1, 1);
      actualReceiver = t1[1];
      t1 = this.backend;
      t2 = t1.compiler;
      if (actualReceiver.isIndexablePrimitive$1(t2)) {
        if (actualReceiver.isConstantString$0()) {
          constant = actualReceiver.get$constant();
          t1 = this.graph;
          t3 = J.get$length$asx(constant.get$value(constant));
          t1.toString;
          return t1.addConstant$2(t2.backend.get$constantSystem().createInt$1(t3), t2);
        } else if (actualReceiver.isConstantList$0()) {
          constant = actualReceiver.get$constant();
          t1 = this.graph;
          t3 = constant.get$entries(constant).length;
          t1.toString;
          return t1.addConstant$2(t2.backend.get$constantSystem().createInt$1(t3), t2);
        }
        element = t1.jsIndexableLength;
        isFixed = B.isFixedLength(actualReceiver.instructionType, t2);
        return B.HFieldGet$(element, actualReceiver, t2.typesTask.get$positiveIntType(), !isFixed);
      } else if (actualReceiver.isConstantMap$0()) {
        constant = actualReceiver.get$constant();
        t1 = this.graph;
        t3 = constant.get$keys().length;
        t1.toString;
        return t1.addConstant$2(t2.backend.get$constantSystem().createInt$1(t3), t2);
      }
      return;
    },
    handleInterceptedCall$1: function(node) {
      var t1, operation, t2, t3, instruction, t4, selector, input, target, argument, t5, result, optimized;
      t1 = node.specializer;
      operation = t1.operation$1(this.constantSystem);
      if (operation != null) {
        t2 = node.inputs;
        t3 = t2.length;
        if (t3 === 2) {
          if (1 >= t3)
            return H.ioore(t2, 1);
          instruction = this.foldUnary$2(operation, t2[1]);
        } else {
          if (1 >= t3)
            return H.ioore(t2, 1);
          t4 = t2[1];
          if (2 >= t3)
            return H.ioore(t2, 2);
          instruction = this.foldBinary$3(operation, t4, t2[2]);
        }
        if (instruction != null)
          return instruction;
      }
      t2 = this.backend;
      t3 = t2.compiler;
      instruction = t1.tryConvertToBuiltin$2(node, t3);
      if (instruction != null)
        return instruction;
      selector = node.selector;
      t1 = node.inputs;
      if (1 >= t1.length)
        return H.ioore(t1, 1);
      input = t1[1];
      t4 = selector.kind;
      if (t4 === C.SelectorKind_call_2 || t4 === C.SelectorKind_operator_3) {
        if (input.isExtendableArray$1(t3))
          if (selector.applies$2(t2.jsArrayRemoveLast, t3))
            target = t2.jsArrayRemoveLast;
          else
            target = selector.applies$2(t2.jsArrayAdd, t3) ? !t3.enableTypeAssertions ? t2.jsArrayAdd : null : null;
        else if (input.instructionType.containsOnlyString$1(t3))
          if (selector.applies$2(t2.jsStringSplit, t3)) {
            if (2 >= t1.length)
              return H.ioore(t1, 2);
            argument = t1[2];
            target = argument.get$instructionType().containsOnlyString$1(t3) && !argument.instructionType.get$isNullable() ? t2.jsStringSplit : null;
          } else {
            if (selector.applies$2(t2.jsStringOperatorAdd, t3)) {
              if (2 >= t1.length)
                return H.ioore(t1, 2);
              argument = t1[2];
              if (argument.get$instructionType().containsOnlyString$1(t3) && !argument.instructionType.get$isNullable() && !input.instructionType.get$isNullable()) {
                t1 = node.instructionType;
                t2 = H.setRuntimeTypeInfo([input, argument], [B.HInstruction]);
                t3 = $.HInstruction_idCounter;
                if (typeof t3 !== "number")
                  return t3.$add();
                $.HInstruction_idCounter = t3 + 1;
                t3 = new B.HStringConcat(null, null, null, t3, t2, H.setRuntimeTypeInfo([], [B.HInstruction]), null, null, null, new Z.SideEffects(0), false, t1);
                t3.HInstruction$2(t2, t1);
                t3.sideEffects.setDependsOnSomething$0();
                return t3;
              }
            } else if (selector.applies$2(t2.jsStringToString, t3) && !input.instructionType.get$isNullable())
              return input;
            target = null;
          }
        else
          target = null;
        if (target != null) {
          t2 = node.selector;
          t1 = J.sublist$1$ax(t1, 1);
          t3 = node.instructionType;
          t4 = $.HInstruction_idCounter;
          if (typeof t4 !== "number")
            return t4.$add();
          $.HInstruction_idCounter = t4 + 1;
          t5 = H.setRuntimeTypeInfo([], [B.HInstruction]);
          result = new B.HInvokeDynamicMethod(C.C_InvokeDynamicSpecializer, t2, null, null, null, t4, t1, t5, null, null, null, new Z.SideEffects(0), false, t3);
          result.HInstruction$2(t1, t3);
          t1 = result.sideEffects;
          t1.flags = (t1.flags | 7) >>> 0;
          t1.setDependsOnSomething$0();
          result.element = target;
          return result;
        }
      } else if (t4 === C.SelectorKind_getter_0)
        if (selector.get$asUntyped().applies$2(t2.jsIndexableLength, t3)) {
          optimized = this.tryOptimizeLengthInterceptedGetter$1(node);
          if (optimized != null)
            return optimized;
        }
      return node;
    },
    visitInvokeDynamicMethod$1: function(node) {
      var folded, t1, t2, selector, element, parameters;
      if (node.get$isInterceptedCall()) {
        folded = this.handleInterceptedCall$1(node);
        if (folded !== node)
          return folded;
      }
      t1 = this.backend.compiler;
      t2 = node.inputs;
      if (node.isCallOnInterceptor$1(t1)) {
        if (1 >= t2.length)
          return H.ioore(t2, 1);
        t2 = t2[1];
      } else {
        if (0 >= t2.length)
          return H.ioore(t2, 0);
        t2 = t2[0];
      }
      selector = Z.TypedSelector_TypedSelector(t2.get$instructionType(), node.selector, t1);
      element = t1.world.locateSingleElement$1(selector);
      if (element != null)
        if (element.get$isFunction()) {
          t1 = element.name;
          t2 = selector.name;
          t2 = t1 == null ? t2 == null : t1 === t2;
          t1 = t2;
        } else
          t1 = false;
      else
        t1 = false;
      if (t1)
        if (element._isNative) {
          folded = this.tryInlineNativeMethod$2(node, element);
          if (folded != null)
            return folded;
        } else {
          parameters = element.get$functionSignature();
          if (parameters.get$optionalParameterCount() === 0 || parameters.requiredParameterCount + parameters.optionalParameterCount === node.selector.argumentCount)
            node.element = element;
        }
      return node;
    },
    tryInlineNativeMethod$2: function(node, method) {
      var t1, signature, inputs, t2, returnType, t3, result;
      t1 = {};
      if (!node.get$isInterceptedCall())
        return;
      signature = method.get$functionSignature();
      if (signature.get$optionalParametersAreNamed())
        return;
      inputs = J.sublist$1$ax(node.inputs, 1);
      t1.inputPosition_0 = 1;
      t1.canInline_1 = true;
      t2 = new B.SsaInstructionSimplifier_tryInlineNativeMethod_closure(t1, this, inputs);
      signature.forEachRequiredParameter$1(t2);
      signature.forEachOptionalParameter$1(t2);
      if (!t1.canInline_1)
        return;
      t1 = this.backend.compiler;
      returnType = B.TypeMaskFactory_fromNativeBehavior(L.NativeBehavior_ofMethod(method, t1), t1);
      t1 = node.selector;
      t2 = $.HInstruction_idCounter;
      if (typeof t2 !== "number")
        return t2.$add();
      $.HInstruction_idCounter = t2 + 1;
      t3 = H.setRuntimeTypeInfo([], [B.HInstruction]);
      result = new B.HInvokeDynamicMethod(C.C_InvokeDynamicSpecializer, t1, null, null, null, t2, inputs, t3, null, null, null, new Z.SideEffects(0), false, returnType);
      result.HInstruction$2(inputs, returnType);
      t1 = result.sideEffects;
      t1.flags = (t1.flags | 7) >>> 0;
      t1.setDependsOnSomething$0();
      result.element = method;
      return result;
    },
    visitBoundsCheck$1: function(node) {
      var t1, index;
      t1 = node.inputs;
      if (0 >= t1.length)
        return H.ioore(t1, 0);
      index = t1[0];
      if (index.get$instructionType().containsOnlyInt$1(this.backend.compiler) && !index.instructionType.get$isNullable())
        return node;
      if (index.isConstant$0())
        if (!this.constantSystem.isInt$1(index.get$constant()))
          node.staticChecks = 0;
      return node;
    },
    foldBinary$3: function(operation, left, right) {
      var folded;
      if (!!J.getInterceptor(left).$isHConstant && !!J.getInterceptor(right).$isHConstant) {
        folded = operation.fold$2(0, left.get$constant(), right.get$constant());
        if (folded != null)
          return this.graph.addConstant$2(folded, this.backend.compiler);
      }
      return;
    },
    visitAdd$1: function(node) {
      var t1, t2, left, right;
      t1 = node.inputs;
      t2 = t1.length;
      if (0 >= t2)
        return H.ioore(t1, 0);
      left = t1[0];
      if (1 >= t2)
        return H.ioore(t1, 1);
      right = t1[1];
      t1 = this.backend.compiler;
      if (left.get$instructionType().containsOnlyInt$1(t1) && !left.instructionType.get$isNullable() && right.get$instructionType().containsOnlyInt$1(t1) && !right.instructionType.get$isNullable()) {
        if (!!left.$isHConstant && left.constant.get$isZero())
          return right;
        if (!!J.getInterceptor(right).$isHConstant && right.constant.get$isZero())
          return left;
      }
      return B.HBaseVisitor.prototype.visitAdd$1.call(this, node);
    },
    visitMultiply$1: function(node) {
      var t1, t2, left, right;
      t1 = node.inputs;
      t2 = t1.length;
      if (0 >= t2)
        return H.ioore(t1, 0);
      left = t1[0];
      if (1 >= t2)
        return H.ioore(t1, 1);
      right = t1[1];
      t1 = this.backend.compiler;
      if (left.get$instructionType().containsOnlyNum$1(t1) && !left.instructionType.get$isNullable() && right.get$instructionType().containsOnlyNum$1(t1) && !right.instructionType.get$isNullable()) {
        if (!!left.$isHConstant && left.constant.get$isOne())
          return right;
        if (!!J.getInterceptor(right).$isHConstant && right.constant.get$isOne())
          return left;
      }
      return B.HBaseVisitor.prototype.visitMultiply$1.call(this, node);
    },
    visitInvokeBinary$1: function(node) {
      var t1, t2, left, right, folded;
      t1 = node.inputs;
      t2 = t1.length;
      if (0 >= t2)
        return H.ioore(t1, 0);
      left = t1[0];
      if (1 >= t2)
        return H.ioore(t1, 1);
      right = t1[1];
      folded = this.foldBinary$3(node.operation$1(this.constantSystem), left, right);
      if (folded != null)
        return folded;
      return node;
    },
    allUsersAreBoolifies$1: function(instruction) {
      var users, $length, i;
      users = instruction.usedBy;
      $length = users.length;
      for (i = 0; i < $length; ++i)
        if (!J.getInterceptor(users[i]).$isHBoolify)
          return false;
      return true;
    },
    visitRelational$1: function(node) {
      if (this.allUsersAreBoolifies$1(node))
        ;
      return B.HBaseVisitor.prototype.visitRelational$1.call(this, node);
    },
    handleIdentityCheck$1: function(node) {
      var t1, t2, left, right, leftType, rightType, intersection, t3;
      t1 = node.inputs;
      t2 = t1.length;
      if (0 >= t2)
        return H.ioore(t1, 0);
      left = t1[0];
      if (1 >= t2)
        return H.ioore(t1, 1);
      right = t1[1];
      leftType = left.get$instructionType();
      rightType = right.get$instructionType();
      t1 = this.backend.compiler;
      if (!(left.instructionType.containsOnlyNum$1(t1) && right.instructionType.containsOnlyNum$1(t1))) {
        intersection = leftType.intersection$2(0, rightType, t1);
        if (intersection.get$isEmpty(intersection) && !intersection.get$isNullable()) {
          t2 = this.graph;
          t2.toString;
          return t2.addConstant$2(t1.backend.get$constantSystem().createBool$1(false), t1);
        }
      }
      t2 = left.instructionType;
      if (t2.get$isEmpty(t2) && left.instructionType.get$isNullable()) {
        t2 = right.instructionType;
        t2 = t2.get$isEmpty(t2) && right.instructionType.get$isNullable();
      } else
        t2 = false;
      if (t2) {
        t2 = this.graph;
        t2.toString;
        return t2.addConstant$2(t1.backend.get$constantSystem().createBool$1(true), t1);
      }
      if (left.isConstantBoolean$0() && right.instructionType.containsOnlyBool$1(t1) && !right.instructionType.get$isNullable())
        if (left.get$constant().get$isTrue())
          return right;
        else {
          t1 = t1.typesTask.get$boolType();
          t2 = H.setRuntimeTypeInfo([right], [B.HInstruction]);
          t3 = $.HInstruction_idCounter;
          if (typeof t3 !== "number")
            return t3.$add();
          $.HInstruction_idCounter = t3 + 1;
          t3 = new B.HNot(null, null, t3, t2, H.setRuntimeTypeInfo([], [B.HInstruction]), null, null, null, new Z.SideEffects(0), false, t1);
          t3.HInstruction$2(t2, t1);
          t3._useGvn = true;
          return t3;
        }
      if (right.isConstantBoolean$0() && left.instructionType.containsOnlyBool$1(t1) && !left.instructionType.get$isNullable())
        if (right.get$constant().get$isTrue())
          return left;
        else {
          t1 = t1.typesTask.get$boolType();
          t2 = H.setRuntimeTypeInfo([left], [B.HInstruction]);
          t3 = $.HInstruction_idCounter;
          if (typeof t3 !== "number")
            return t3.$add();
          $.HInstruction_idCounter = t3 + 1;
          t3 = new B.HNot(null, null, t3, t2, H.setRuntimeTypeInfo([], [B.HInstruction]), null, null, null, new Z.SideEffects(0), false, t1);
          t3.HInstruction$2(t2, t1);
          t3._useGvn = true;
          return t3;
        }
      return;
    },
    visitIdentity$1: function(node) {
      var newInstruction = this.handleIdentityCheck$1(node);
      return newInstruction == null ? B.HBaseVisitor.prototype.visitIdentity$1.call(this, node) : newInstruction;
    },
    simplifyCondition$3: function(block, condition, value) {
      condition.dominatedUsers$1(block.first).forEach$1(0, new B.SsaInstructionSimplifier_simplifyCondition_closure(this, condition, value));
    },
    visitIf$1: function(node) {
      var t1, condition, isNegated;
      t1 = node.inputs;
      if (0 >= t1.length)
        return H.ioore(t1, 0);
      condition = t1[0];
      if (condition.isConstant$0())
        return node;
      isNegated = !!condition.$isHNot;
      if (isNegated) {
        t1 = condition.inputs;
        if (0 >= t1.length)
          return H.ioore(t1, 0);
        condition = t1[0];
      } else {
        t1 = condition.usedBy;
        H.setRuntimeTypeInfo(new H.WhereIterable(t1, new B.SsaInstructionSimplifier_visitIf_closure(node)), [H.getTypeArgumentByIndex(H.setRuntimeTypeInfo(new H.IterableMixinWorkaround(), [H.getTypeArgumentByIndex(t1, 0)]), 0)]).forEach$1(0, new B.SsaInstructionSimplifier_visitIf_closure0(this, node));
      }
      this.simplifyCondition$3(node.get$thenBlock(), condition, !isNegated);
      this.simplifyCondition$3(node.get$elseBlock(), condition, isNegated);
      return node;
    },
    visitIs$1: function(node) {
      var type, element, t1, t2, expression, expressionMask, typeMask;
      type = node.typeExpression;
      element = type.get$element();
      if (node.kind !== 0)
        return node;
      else if (type.get$kind(type) === C.TypeKind_typedef)
        return node;
      else {
        t1 = this.backend.compiler;
        t2 = t1.functionClass;
        if (element == null ? t2 == null : element === t2)
          return node;
      }
      t2 = t1.objectClass;
      if ((element == null ? t2 == null : element === t2) || type.get$treatAsDynamic()) {
        t2 = this.graph;
        t2.toString;
        return t2.addConstant$2(t1.backend.get$constantSystem().createBool$1(true), t1);
      }
      t2 = node.inputs;
      if (0 >= t2.length)
        return H.ioore(t2, 0);
      expression = t2[0];
      if (expression.get$instructionType().containsOnlyInt$1(t1) && !expression.instructionType.get$isNullable()) {
        t2 = t1.intClass;
        if (element == null ? t2 != null : element !== t2) {
          t2 = t1.numClass;
          t2 = (element == null ? t2 == null : element === t2) || O.Elements_isNumberOrStringSupertype(element, t1);
        } else
          t2 = true;
        if (t2) {
          t2 = this.graph;
          t2.toString;
          return t2.addConstant$2(t1.backend.get$constantSystem().createBool$1(true), t1);
        } else {
          t2 = t1.doubleClass;
          if (element == null ? t2 == null : element === t2)
            return node;
          else {
            t2 = this.graph;
            t2.toString;
            return t2.addConstant$2(t1.backend.get$constantSystem().createBool$1(false), t1);
          }
        }
      } else if (expression.instructionType.containsOnlyDouble$1(t1) && !expression.instructionType.get$isNullable()) {
        t2 = t1.doubleClass;
        if (element == null ? t2 != null : element !== t2) {
          t2 = t1.numClass;
          t2 = (element == null ? t2 == null : element === t2) || O.Elements_isNumberOrStringSupertype(element, t1);
        } else
          t2 = true;
        if (t2) {
          t2 = this.graph;
          t2.toString;
          return t2.addConstant$2(t1.backend.get$constantSystem().createBool$1(true), t1);
        } else {
          t2 = t1.intClass;
          if (element == null ? t2 == null : element === t2)
            return node;
          else {
            t2 = this.graph;
            t2.toString;
            return t2.addConstant$2(t1.backend.get$constantSystem().createBool$1(false), t1);
          }
        }
      } else if (expression.instructionType.containsOnlyNum$1(t1) && !expression.instructionType.get$isNullable()) {
        t2 = t1.numClass;
        if (element == null ? t2 == null : element === t2) {
          t2 = this.graph;
          t2.toString;
          return t2.addConstant$2(t1.backend.get$constantSystem().createBool$1(true), t1);
        }
      } else {
        if (expression.canBePrimitiveNumber$1(t1)) {
          t2 = t1.intClass;
          t2 = element == null ? t2 == null : element === t2;
        } else
          t2 = false;
        if (t2)
          return node;
        else if (!Z.RuntimeTypes_hasTypeArguments(type)) {
          expressionMask = expression.instructionType;
          t2 = t1.nullClass;
          typeMask = (element == null ? t2 == null : element === t2) ? new B.FlatTypeMask(element, 7) : new B.FlatTypeMask(element, 6);
          if (J.$eq(expressionMask.union$2(typeMask, t1), typeMask)) {
            t2 = this.graph;
            t2.toString;
            return t2.addConstant$2(t1.backend.get$constantSystem().createBool$1(true), t1);
          } else {
            t2 = expressionMask.intersection$2(0, typeMask, t1);
            if (t2.get$isEmpty(t2)) {
              t2 = this.graph;
              t2.toString;
              return t2.addConstant$2(t1.backend.get$constantSystem().createBool$1(false), t1);
            }
          }
        }
      }
      return node;
    },
    visitTypeConversion$1: function(node) {
      var t1, type;
      t1 = node.inputs;
      if (0 >= t1.length)
        return H.ioore(t1, 0);
      t1[0];
      type = node.typeExpression;
      if (type != null) {
        if (type.get$kind(type) === C.TypeKind_malformed)
          return node;
        if (!type.get$treatAsRaw() || type.get$kind(type) === C.TypeKind_kuk)
          return node;
        if (type.get$kind(type) === C.TypeKind_function)
          return node;
      }
      return this.removeIfCheckAlwaysSucceeds$2(node, node.checkedType);
    },
    visitTypeKnown$1: function(node) {
      return this.removeIfCheckAlwaysSucceeds$2(node, node.knownType);
    },
    removeIfCheckAlwaysSucceeds$2: function(node, checkedType) {
      var t1, t2, input;
      t1 = this.backend.compiler;
      if (checkedType.containsAll$1(t1))
        return node;
      t2 = node.inputs;
      if (0 >= t2.length)
        return H.ioore(t2, 0);
      input = t2[0];
      return input.get$instructionType().isInMask$2(checkedType, t1) ? input : node;
    },
    findConcreteFieldForDynamicAccess$2: function(receiver, selector) {
      var receiverType, t1, result;
      receiverType = receiver.instructionType;
      t1 = this.backend.compiler;
      result = t1.world.locateSingleElement$1(Z.TypedSelector_TypedSelector(receiverType, selector, t1));
      return result != null && result.kind === C.ElementKind_field_1 ? result : null;
    },
    visitFieldGet$1: function(node) {
      var t1, receiver, t2, t3, type, constant;
      t1 = node.inputs;
      if (0 >= t1.length)
        return H.ioore(t1, 0);
      receiver = t1[0];
      t1 = node.element;
      t2 = this.backend;
      t3 = t2.jsIndexableLength;
      if (t1 == null ? t3 == null : t1 === t3)
        if (this.work.compilationContext.get$allocatedFixedLists().contains$1(0, receiver)) {
          t1 = receiver.get$inputs();
          if (0 >= t1.length)
            return H.ioore(t1, 0);
          if (t1[0].isInteger$1(t2.compiler)) {
            t1 = receiver.get$inputs();
            if (0 >= t1.length)
              return H.ioore(t1, 0);
            return t1[0];
          }
        } else if (receiver.isConstantList$0() || receiver.isConstantString$0()) {
          t1 = this.graph;
          t3 = receiver.get$constant();
          t3 = t3.get$length(t3);
          t2 = t2.compiler;
          t1.toString;
          return t1.addConstant$2(t2.backend.get$constantSystem().createInt$1(t3), t2);
        } else {
          type = receiver.instructionType;
          if (type.get$isContainer() && type.get$length(type) != null) {
            t1 = this.graph;
            t3 = type.get$length(type);
            t2 = t2.compiler;
            t1.toString;
            constant = t1.addConstant$2(t2.backend.get$constantSystem().createInt$1(t3), t2);
            if (type.get$isNullable()) {
              node.block.rewrite$2(node, constant);
              return node;
            } else
              return constant;
          }
        }
      return node;
    },
    visitIndex$1: function(node) {
      var t1, t2, entries, index;
      t1 = node.inputs;
      if (0 >= t1.length)
        return H.ioore(t1, 0);
      if (t1[0].isConstantList$0()) {
        if (1 >= t1.length)
          return H.ioore(t1, 1);
        t2 = t1[1].isConstantInteger$0();
      } else
        t2 = false;
      if (t2) {
        if (0 >= t1.length)
          return H.ioore(t1, 0);
        t2 = t1[0].get$constant();
        entries = t2.get$entries(t2);
        if (1 >= t1.length)
          return H.ioore(t1, 1);
        t1 = t1[1].get$constant();
        index = t1.get$value(t1);
        if (typeof index !== "number")
          return index.$ge();
        if (index >= 0 && index < entries.length) {
          t1 = this.graph;
          if (index >>> 0 !== index || index >= entries.length)
            return H.ioore(entries, index);
          return t1.addConstant$2(entries[index], this.backend.compiler);
        }
      }
      return node;
    },
    visitInvokeDynamicGetter$1: function(node) {
      var folded, t1, t2, receiver, field, type;
      if (node.get$isInterceptedCall()) {
        folded = this.handleInterceptedCall$1(node);
        if (folded !== node)
          return folded;
      }
      t1 = this.backend.compiler;
      t2 = node.inputs;
      if (node.isCallOnInterceptor$1(t1)) {
        if (1 >= t2.length)
          return H.ioore(t2, 1);
        receiver = t2[1];
      } else {
        if (0 >= t2.length)
          return H.ioore(t2, 0);
        receiver = t2[0];
      }
      field = this.findConcreteFieldForDynamicAccess$2(receiver, node.selector);
      if (field == null)
        return node;
      t2 = t1.world.fieldNeverChanges$1(field);
      type = field.get$enclosingClass().get$isNative() ? B.TypeMaskFactory_fromNativeBehavior(L.NativeBehavior_ofFieldLoad(field, t1), t1) : B.TypeMaskFactory_fromInferredType(t1.typesTask.getGuaranteedTypeOfElement$1(field), t1);
      return B.HFieldGet$(field, receiver, type, !t2);
    },
    visitInvokeDynamicSetter$1: function(node) {
      var folded, t1, t2, receiver, field, value, type, other;
      if (node.get$isInterceptedCall()) {
        folded = this.handleInterceptedCall$1(node);
        if (folded !== node)
          return folded;
      }
      t1 = this.backend.compiler;
      t2 = node.inputs;
      if (node.isCallOnInterceptor$1(t1)) {
        if (1 >= t2.length)
          return H.ioore(t2, 1);
        receiver = t2[1];
      } else {
        if (0 >= t2.length)
          return H.ioore(t2, 0);
        receiver = t2[0];
      }
      field = this.findConcreteFieldForDynamicAccess$2(receiver, node.selector);
      if (field == null || !field.get$isAssignable())
        return node;
      value = J.get$last$ax(t2);
      if (t1.enableTypeAssertions) {
        type = field.get$type(field);
        if (!type.get$treatAsRaw() || type.get$kind(type) === C.TypeKind_kuk)
          return node;
        other = value.convertType$3(t1, type, 0);
        if (other !== value) {
          node.block.addBefore$2(node, other);
          value = other;
        }
      }
      return B.HFieldSet$(field, receiver, value);
    },
    visitStringConcat$1: function(node) {
      var t1, t2, leftString, t3, rightString, t4, prefix, folded;
      t1 = new B.SsaInstructionSimplifier_visitStringConcat_getString();
      t2 = node.inputs;
      if (0 >= t2.length)
        return H.ioore(t2, 0);
      leftString = t1.call$1(t2[0]);
      t3 = leftString == null;
      if (!t3 && J.get$length$asx(J.get$value$x(leftString)) === 0) {
        if (1 >= t2.length)
          return H.ioore(t2, 1);
        return t2[1];
      }
      if (1 >= t2.length)
        return H.ioore(t2, 1);
      rightString = t1.call$1(t2[1]);
      if (rightString == null)
        return node;
      t4 = J.getInterceptor$x(rightString);
      if (J.get$length$asx(t4.get$value(rightString)) === 0) {
        if (0 >= t2.length)
          return H.ioore(t2, 0);
        return t2[0];
      }
      if (t3) {
        if (0 >= t2.length)
          return H.ioore(t2, 0);
        t2 = t2[0];
        if (!J.getInterceptor(t2).$isHStringConcat)
          return node;
        if (t2.get$usedBy().length !== 1)
          return node;
        t2 = t2.inputs;
        t3 = t2.length;
        if (0 >= t3)
          return H.ioore(t2, 0);
        prefix = t2[0];
        if (1 >= t3)
          return H.ioore(t2, 1);
        leftString = t1.call$1(t2[1]);
        if (leftString == null)
          return node;
      } else
        prefix = null;
      t1 = J.getInterceptor$x(leftString);
      if (J.get$length$asx(t1.get$value(leftString)) + J.get$length$asx(t4.get$value(rightString)) > 512)
        if (node.usedBy.length > 1)
          return node;
      t2 = this.backend.compiler;
      folded = this.graph.addConstant$2(this.constantSystem.createString$1(Y.DartString_DartString$concat(t1.get$value(leftString), t4.get$value(rightString))), t2);
      if (prefix == null)
        return folded;
      t1 = t2.typesTask.get$stringType();
      t2 = H.setRuntimeTypeInfo([prefix, folded], [B.HInstruction]);
      t3 = $.HInstruction_idCounter;
      if (typeof t3 !== "number")
        return t3.$add();
      $.HInstruction_idCounter = t3 + 1;
      t3 = new B.HStringConcat(node.node, null, null, t3, t2, H.setRuntimeTypeInfo([], [B.HInstruction]), null, null, null, new Z.SideEffects(0), false, t1);
      t3.HInstruction$2(t2, t1);
      t3.sideEffects.setDependsOnSomething$0();
      return t3;
    },
    visitStringify$1: function(node) {
      var t1, input, primitive;
      t1 = node.inputs;
      if (0 >= t1.length)
        return H.ioore(t1, 0);
      input = t1[0];
      t1 = this.backend.compiler;
      if (input.get$instructionType().containsOnlyString$1(t1) && !input.instructionType.get$isNullable())
        return input;
      if (input.isConstant$0()) {
        if (!input.get$constant().get$isPrimitive())
          return node;
        if (input.get$constant().get$isInt())
          if (!input.get$constant().isUInt32$0())
            return node;
        primitive = input.get$constant();
        return this.graph.addConstant$2(this.constantSystem.createString$1(primitive.toDartString$0()), t1);
      }
      return node;
    },
    visitOneShotInterceptor$1: function(node) {
      return this.handleInterceptedCall$1(node);
    },
    static: {"^": "SsaInstructionSimplifier_MAX_SHARED_CONSTANT_FOLDED_STRING_LENGTH"}
  },
  SsaInstructionSimplifier_tryInlineNativeMethod_closure: {
    "^": "Closure:50;box_0,this_1,inputs_2",
    call$1: function(element) {
      var t1, t2, t3, t4;
      t1 = this.box_0;
      t2 = t1.inputPosition_0;
      t3 = this.inputs_2;
      t4 = t3.length;
      if (t2 < t4 && t1.canInline_1) {
        t1.inputPosition_0 = t2 + 1;
        if (t2 >= t4)
          return H.ioore(t3, t2);
        t2 = this.this_1.backend.compiler;
        if (!!J.getInterceptor(J.get$type$x(element).unalias$1(t2)).$isFunctionType)
          t1.canInline_1 = false;
        if (t2.enableTypeAssertions)
          t1.canInline_1 = false;
      }
    },
    $isFunction: true
  },
  SsaInstructionSimplifier_simplifyCondition_closure: {
    "^": "Closure:13;this_0,condition_1,value_2",
    call$1: function(user) {
      var t1, t2;
      t1 = this.this_0;
      t2 = t1.graph;
      t1 = t1.backend.compiler;
      t2.toString;
      user.changeUse$2(this.condition_1, t2.addConstant$2(t1.backend.get$constantSystem().createBool$1(this.value_2), t1));
    },
    $isFunction: true
  },
  SsaInstructionSimplifier_visitIf_closure: {
    "^": "Closure:13;node_0",
    call$1: function(user) {
      return !!J.getInterceptor(user).$isHNot && user.dominates$1(this.node_0);
    },
    $isFunction: true
  },
  SsaInstructionSimplifier_visitIf_closure0: {
    "^": "Closure:13;this_1,node_2",
    call$1: function(hoisted) {
      var t1, t2;
      t1 = this.this_1;
      t2 = this.node_2;
      t1.simplifyCondition$3(t2.get$thenBlock(), hoisted, false);
      t1.simplifyCondition$3(t2.get$elseBlock(), hoisted, true);
    },
    $isFunction: true
  },
  SsaInstructionSimplifier_visitStringConcat_getString: {
    "^": "Closure:289;",
    call$1: function(instruction) {
      if (!instruction.isConstantString$0())
        return;
      return instruction.get$constant();
    },
    $isFunction: true
  },
  SsaCheckInserter: {
    "^": "HBaseVisitor;boundsChecked,work,backend<,name>,graph,currentBlock",
    visitGraph$1: function(graph) {
      this.graph = graph;
      this.visitDominatorTree$1(graph);
    },
    visitBasicBlock$1: function(block) {
      var instruction, next;
      instruction = block.first;
      for (; instruction != null; instruction = next) {
        next = instruction.next;
        instruction.accept$1(0, this);
      }
    },
    insertBoundsCheck$3: function(indexNode, array, indexArgument) {
      var t1, compiler, $length, type, t2, check;
      t1 = this.backend;
      compiler = t1.compiler;
      $length = B.HFieldGet$(t1.jsIndexableLength, array, compiler.typesTask.get$positiveIntType(), !B.isFixedLength(array.instructionType, compiler));
      indexNode.block.addBefore$2(indexNode, $length);
      type = indexArgument.isPositiveInteger$1(compiler) ? indexArgument.instructionType : compiler.typesTask.get$positiveIntType();
      t1 = H.setRuntimeTypeInfo([indexArgument, $length, array], [B.HInstruction]);
      t2 = $.HInstruction_idCounter;
      if (typeof t2 !== "number")
        return t2.$add();
      $.HInstruction_idCounter = t2 + 1;
      check = new B.HBoundsCheck(1, null, null, t2, t1, H.setRuntimeTypeInfo([], [B.HInstruction]), null, null, null, new Z.SideEffects(0), false, type);
      check.HInstruction$2(t1, type);
      check._useGvn = true;
      indexNode.block.addBefore$2(indexNode, check);
      if (!(indexArgument.instructionType.containsOnlyInt$1(compiler) && !indexArgument.instructionType.get$isNullable()))
        indexArgument.replaceAllUsersDominatedBy$2(indexNode, check);
      this.boundsChecked.add$1(0, indexNode);
      return check;
    },
    visitIndex$1: function(node) {
      var t1, index;
      if (this.boundsChecked.contains$1(0, node))
        return;
      t1 = node.inputs;
      if (1 >= t1.length)
        return H.ioore(t1, 1);
      index = t1[1];
      this.insertBoundsCheck$3(node, t1[0], index);
    },
    visitIndexAssign$1: function(node) {
      var t1, index;
      if (this.boundsChecked.contains$1(0, node))
        return;
      t1 = node.inputs;
      if (1 >= t1.length)
        return H.ioore(t1, 1);
      index = t1[1];
      this.insertBoundsCheck$3(node, t1[0], index);
    },
    visitInvokeDynamicMethod$1: function(node) {
      var element, t1, t2, t3;
      element = node.element;
      if (node.get$isInterceptedCall())
        return;
      t1 = this.backend;
      t2 = t1.jsArrayRemoveLast;
      if (element == null ? t2 != null : element !== t2)
        return;
      if (this.boundsChecked.contains$1(0, node))
        return;
      t2 = node.inputs;
      if (0 >= t2.length)
        return H.ioore(t2, 0);
      t2 = t2[0];
      t3 = this.graph;
      t1 = t1.compiler;
      t3.toString;
      this.insertBoundsCheck$3(node, t2, t3.addConstant$2(t1.backend.get$constantSystem().createInt$1(0), t1));
    }
  },
  SsaDeadCodeEliminator: {
    "^": "HGraphVisitor;name>,compiler<,analyzer,eliminatedSideEffects,zapInstructionCache",
    get$zapInstruction: function() {
      var t1 = this.zapInstructionCache;
      if (t1 == null) {
        t1 = this.analyzer.graph.addConstant$2(new K.DummyConstant(C.FlatTypeMask_null_0), this.compiler);
        this.zapInstructionCache = t1;
      }
      return t1;
    },
    hasFollowingThrowingNSM$1: function(instruction) {
      var t1, receiver, current, t2, current0;
      t1 = this.compiler;
      receiver = instruction.getDartReceiver$1(t1);
      current = instruction.next;
      do {
        t2 = current.getDartReceiver$1(t1);
        if ((t2 == null ? receiver == null : t2 === receiver) && current.canThrow$0())
          return true;
        if (current.canThrow$0() || (current.sideEffects.flags & 7) !== 0)
          return false;
        current0 = current.next;
        if (current0 == null && !!current.$isHGoto) {
          t2 = current.block.successors;
          if (0 >= t2.length)
            return H.ioore(t2, 0);
          current = J.get$first$ax(t2[0]);
        } else
          current = current0;
      } while (current != null);
      return false;
    },
    isDeadCode$1: function(instruction) {
      if (instruction.usedBy.length !== 0)
        return false;
      if ((instruction.sideEffects.flags & 7) !== 0)
        return false;
      if (instruction.canThrow$0() && instruction.onlyThrowsNSM$0() && this.hasFollowingThrowingNSM$1(instruction))
        return true;
      return !instruction.canThrow$0() && !instruction.$isHParameterValue && !instruction.$isHLocalSet;
    },
    visitGraph$1: function(graph) {
      var t1 = new B.SsaLiveBlockAnalyzer(graph, this.compiler, P.LinkedHashSet_LinkedHashSet(null, null, null, B.HBasicBlock), H.setRuntimeTypeInfo([], [B.HBasicBlock]), null);
      this.analyzer = t1;
      t1.analyze$0();
      this.visitPostDominatorTree$1(graph);
      this.cleanPhis$1(graph);
    },
    visitBasicBlock$1: function(block) {
      var t1, isDeadBlock, instruction, previous;
      t1 = this.analyzer.live.contains$1(0, block);
      isDeadBlock = !t1;
      block.isLive = t1;
      instruction = block.last.previous;
      for (; instruction != null; instruction = previous) {
        previous = instruction.previous;
        if (isDeadBlock) {
          this.eliminatedSideEffects = this.eliminatedSideEffects || (instruction.sideEffects.flags & 7) !== 0;
          this.removeUsers$1(instruction);
          block.remove$1(0, instruction);
        } else if (this.isDeadCode$1(instruction))
          block.remove$1(0, instruction);
      }
    },
    cleanPhis$1: function(graph) {
      var t1, t2, block, predecessors, i;
      $L$0:
        for (t1 = graph.blocks, t1 = H.setRuntimeTypeInfo(new H.ListIterator(t1, t1.length, 0, null), [H.getTypeArgumentByIndex(t1, 0)]); t1.moveNext$0();) {
          t2 = {};
          block = t1.__internal$_current;
          predecessors = block.get$predecessors();
          block.forEachPhi$1(new B.SsaDeadCodeEliminator_cleanPhis_closure(this, predecessors));
          if (predecessors.length < 2)
            continue $L$0;
          t2.indexOfLive_0 = -1;
          for (i = 0; i < predecessors.length; ++i)
            if (predecessors[i].get$isLive() === true) {
              if (t2.indexOfLive_0 >= 0)
                continue $L$0;
              t2.indexOfLive_0 = i;
            }
          block.forEachPhi$1(new B.SsaDeadCodeEliminator_cleanPhis_closure0(t2, this, block));
        }
    },
    removeUsers$1: function(instruction) {
      var t1 = instruction.usedBy;
      H.IterableMixinWorkaround_forEach(t1, new B.SsaDeadCodeEliminator_removeUsers_closure(this, instruction));
      C.JSArray_methods.set$length(t1, 0);
    },
    removeInput$2: function(user, input) {
      var inputs, $length, i;
      inputs = user.get$inputs();
      for ($length = inputs.length, i = 0; i < $length; ++i) {
        if (i >= inputs.length)
          return H.ioore(inputs, i);
        if (input === inputs[i]) {
          J.$indexSet$ax(user.get$inputs(), i, this.get$zapInstruction());
          this.get$zapInstruction().usedBy.push(user);
        }
      }
    }
  },
  SsaDeadCodeEliminator_cleanPhis_closure: {
    "^": "Closure:259;this_1,predecessors_2",
    call$1: function(phi) {
      var t1, t2, t3, t4, i, t5;
      for (t1 = phi.inputs, t2 = this.predecessors_2, t3 = this.this_1, t4 = J.getInterceptor$ax(t1), i = 0; i < t1.length; ++i) {
        if (i >= t2.length)
          return H.ioore(t2, i);
        if (t2[i].get$isLive() !== true) {
          if (i >= t1.length)
            return H.ioore(t1, i);
          t5 = !J.$eq(t1[i], t3.get$zapInstruction());
        } else
          t5 = false;
        if (t5) {
          t5 = t3.get$zapInstruction();
          if (i >= t1.length)
            return H.ioore(t1, i);
          C.JSArray_methods.remove$1(t1[i].get$usedBy(), phi);
          t4.$indexSet(t1, i, t5);
          t5.usedBy.push(phi);
        }
      }
    },
    $isFunction: true
  },
  SsaDeadCodeEliminator_cleanPhis_closure0: {
    "^": "Closure:259;box_0,this_3,block_4",
    call$1: function(phi) {
      var t1, t2, replacement;
      t1 = this.box_0.indexOfLive_0;
      if (t1 >= 0) {
        t2 = phi.inputs;
        if (t1 >= t2.length)
          return H.ioore(t2, t1);
        replacement = t2[t1];
      } else
        replacement = this.this_3.get$zapInstruction();
      if (replacement.dominates$1(phi)) {
        t1 = this.block_4;
        t1.rewrite$2(phi, replacement);
        t1.removePhi$1(phi);
      }
    },
    $isFunction: true
  },
  SsaDeadCodeEliminator_removeUsers_closure: {
    "^": "Closure:13;this_0,instruction_1",
    call$1: function(user) {
      this.this_0.removeInput$2(user, this.instruction_1);
    },
    $isFunction: true
  },
  SsaLiveBlockAnalyzer: {
    "^": "HBaseVisitor;graph,compiler<,live,worklist,currentBlock",
    get$backend: function() {
      return this.compiler.backend;
    },
    get$ranges: function() {
      return this.compiler.backend.get$optimizer().ranges;
    },
    analyze$0: function() {
      var t1, t2;
      this.markBlockLive$1(this.graph.entry);
      for (t1 = this.worklist; t2 = t1.length, t2 !== 0;) {
        if (0 >= t2)
          return H.ioore(t1, 0);
        t1.pop().last.accept$1(0, this);
      }
    },
    markBlockLive$1: [function(block) {
      var t1 = this.live;
      if (!t1.contains$1(0, block)) {
        this.worklist.push(block);
        t1.add$1(0, block);
      }
    }, "call$1", "get$markBlockLive", 2, 0, 287],
    visitControlFlow$1: function(instruction) {
      H.IterableMixinWorkaround_forEach(instruction.block.successors, this.get$markBlockLive());
    },
    visitIf$1: function(instruction) {
      var t1, condition;
      t1 = instruction.inputs;
      if (0 >= t1.length)
        return H.ioore(t1, 0);
      condition = t1[0];
      if (condition.isConstant$0())
        if (condition.isConstantTrue$0())
          this.markBlockLive$1(instruction.get$thenBlock());
        else
          this.markBlockLive$1(instruction.get$elseBlock());
      else
        H.IterableMixinWorkaround_forEach(instruction.block.successors, this.get$markBlockLive());
    },
    visitSwitch$1: function(node) {
      var t1, t2, t3, switchRange, lowerValue, upperValue, lower, upper, liveLabels, pos, input, constant, label, t4, t5;
      t1 = node.inputs;
      if (0 >= t1.length)
        return H.ioore(t1, 0);
      t2 = t1[0];
      t3 = this.compiler;
      if (t2.get$instructionType().containsOnlyInt$1(t3) && !t2.instructionType.get$isNullable()) {
        t2 = t3.backend.get$optimizer().ranges;
        if (0 >= t1.length)
          return H.ioore(t1, 0);
        switchRange = t2.$index(0, t1[0]);
        if (switchRange != null && !!J.getInterceptor(switchRange.get$lower()).$isIntValue && !!J.getInterceptor(switchRange.upper).$isIntValue) {
          lowerValue = switchRange.get$lower();
          upperValue = switchRange.upper;
          lower = lowerValue.get$value(lowerValue);
          upper = upperValue.get$value(upperValue);
          liveLabels = P.LinkedHashSet_LinkedHashSet(null, null, null, P.$int);
          for (t2 = this.live, t3 = this.worklist, pos = 1; pos < t1.length; ++pos) {
            input = t1[pos];
            if (!input.get$constant().get$isInt())
              continue;
            constant = input.get$constant();
            label = constant.get$value(constant);
            if (!liveLabels.contains$1(0, label)) {
              if (typeof label !== "number")
                return label.$le();
              if (typeof upper !== "number")
                return H.iae(upper);
              if (label <= upper) {
                if (typeof lower !== "number")
                  return H.iae(lower);
                t4 = label >= lower;
              } else
                t4 = false;
            } else
              t4 = false;
            if (t4) {
              t4 = node.block.successors;
              t5 = pos - 1;
              if (t5 >= t4.length)
                return H.ioore(t4, t5);
              t5 = t4[t5];
              if (!t2.contains$1(0, t5)) {
                t3.push(t5);
                t2.add$1(0, t5);
              }
              liveLabels.add$1(0, label);
            }
          }
          if (liveLabels._collection$_length !== J.$sub$n(upper, lower) + 1)
            this.markBlockLive$1(C.JSArray_methods.get$last(node.block.successors));
          return;
        }
      }
      H.IterableMixinWorkaround_forEach(node.block.successors, this.get$markBlockLive());
    }
  },
  SsaDeadPhiEliminator: {
    "^": "Object;name>",
    visitGraph$1: function(graph) {
      var worklist, livePhis, t1, t2, t3, input, i, block, current, next;
      worklist = H.setRuntimeTypeInfo([], [B.HPhi]);
      livePhis = P.LinkedHashSet_LinkedHashSet(null, null, null, B.HPhi);
      for (t1 = graph.blocks, t2 = H.setRuntimeTypeInfo(new H.ListIterator(t1, t1.length, 0, null), [H.getTypeArgumentByIndex(t1, 0)]); t2.moveNext$0();)
        t2.__internal$_current.forEachPhi$1(new B.SsaDeadPhiEliminator_visitGraph_closure(worklist, livePhis));
      for (; t2 = worklist.length, t2 !== 0;) {
        if (0 >= t2)
          return H.ioore(worklist, 0);
        t2 = worklist.pop().inputs;
        t3 = new H.ListIterator(t2, t2.length, 0, null);
        t3.$builtinTypeInfo = [H.getTypeArgumentByIndex(t2, 0)];
        for (; t3.moveNext$0();) {
          input = t3.__internal$_current;
          if (!!J.getInterceptor(input).$isHPhi && !livePhis.contains$1(0, input)) {
            worklist.push(input);
            livePhis.add$1(0, input);
          }
        }
      }
      for (i = t1.length - 1; i >= 0; --i) {
        if (i >= t1.length)
          return H.ioore(t1, i);
        block = t1[i];
        current = block.get$phis().first;
        for (t2 = block.phis; current != null; current = next) {
          next = current.next;
          if (!livePhis.contains$1(0, current) && current.usedBy.length === 0) {
            t2.detach$1(current);
            current.notifyRemovedFromBlock$0();
          }
        }
      }
    }
  },
  SsaDeadPhiEliminator_visitGraph_closure: {
    "^": "Closure:259;worklist_0,livePhis_1",
    call$1: function(phi) {
      var t1;
      for (t1 = phi.usedBy, t1 = H.setRuntimeTypeInfo(new H.ListIterator(t1, t1.length, 0, null), [H.getTypeArgumentByIndex(t1, 0)]); t1.moveNext$0();)
        if (!J.getInterceptor(t1.__internal$_current).$isHPhi) {
          this.worklist_0.push(phi);
          this.livePhis_1.add$1(0, phi);
          break;
        }
    },
    $isFunction: true
  },
  SsaRedundantPhiEliminator: {
    "^": "Object;name>",
    visitGraph$1: function(graph) {
      var worklist, t1, phi, t2, candidate, i, input, user;
      worklist = H.setRuntimeTypeInfo([], [B.HPhi]);
      for (t1 = graph.blocks, t1 = H.setRuntimeTypeInfo(new H.ListIterator(t1, t1.length, 0, null), [H.getTypeArgumentByIndex(t1, 0)]); t1.moveNext$0();)
        t1.__internal$_current.forEachPhi$1(new B.SsaRedundantPhiEliminator_visitGraph_closure(worklist));
      for (; t1 = worklist.length, t1 !== 0;) {
        if (0 >= t1)
          return H.ioore(worklist, 0);
        phi = worklist.pop();
        if (phi.block == null)
          continue;
        t1 = phi.inputs;
        t2 = t1.length;
        if (0 >= t2)
          return H.ioore(t1, 0);
        candidate = t1[0];
        for (i = 1; i < t2; ++i) {
          input = t1[i];
          if ((input == null ? candidate != null : input !== candidate) && input !== phi) {
            candidate = null;
            break;
          }
        }
        if (candidate == null)
          continue;
        t1 = phi.usedBy;
        t2 = new H.ListIterator(t1, t1.length, 0, null);
        t2.$builtinTypeInfo = [H.getTypeArgumentByIndex(t1, 0)];
        for (; t2.moveNext$0();) {
          user = t2.__internal$_current;
          if (!!J.getInterceptor(user).$isHPhi)
            worklist.push(user);
        }
        phi.block.rewrite$2(phi, candidate);
        phi.block.phis.detach$1(phi);
        phi.notifyRemovedFromBlock$0();
      }
    }
  },
  SsaRedundantPhiEliminator_visitGraph_closure: {
    "^": "Closure:259;worklist_0",
    call$1: function(phi) {
      return this.worklist_0.push(phi);
    },
    $isFunction: true
  },
  GvnWorkItem: {
    "^": "Object;block<,valueSet"
  },
  SsaGlobalValueNumberer: {
    "^": "Object;name>,compiler<,visited,blockChangesFlags,loopChangesFlags",
    visitGraph$1: function(graph) {
      var workQueue, item;
      this.computeChangesFlags$1(graph);
      this.moveLoopInvariantCode$1(graph);
      workQueue = H.setRuntimeTypeInfo([new B.GvnWorkItem(graph.entry, new B.ValueSet(0, H.setRuntimeTypeInfo(Array(8), [B.HInstruction]), null))], [B.GvnWorkItem]);
      do {
        if (0 >= workQueue.length)
          return H.ioore(workQueue, 0);
        item = workQueue.pop();
        this.visitBasicBlock$3(item.block, item.valueSet, workQueue);
      } while (workQueue.length !== 0);
    },
    moveLoopInvariantCode$1: function(graph) {
      var t1, i, block, t2, t3, changesFlags, info;
      for (t1 = graph.blocks, i = t1.length - 1; i >= 0; --i) {
        if (i >= t1.length)
          return H.ioore(t1, i);
        block = t1[i];
        if (block.get$loopInformation() != null) {
          t2 = this.loopChangesFlags;
          t3 = block.id;
          if (t3 >>> 0 !== t3 || t3 >= t2.length)
            return H.ioore(t2, t3);
          changesFlags = t2[t3];
          info = block.loopInformation;
          this.moveLoopInvariantCodeFromBlock$3(block, block, changesFlags);
          t2 = info.blocks;
          t3 = new H.ListIterator(t2, t2.length, 0, null);
          t3.$builtinTypeInfo = [H.getTypeArgumentByIndex(t2, 0)];
          for (; t3.moveNext$0();)
            this.moveLoopInvariantCodeFromBlock$3(t3.__internal$_current, block, changesFlags);
        }
      }
    },
    moveLoopInvariantCodeFromBlock$3: function(block, loopHeader, changesFlags) {
      var t1, preheader, dependsFlags, instruction, t2, firstInstructionInLoop, next, inputs, loopInvariantInputs, $length, i, t3, changesFlags0;
      t1 = loopHeader.predecessors;
      if (0 >= t1.length)
        return H.ioore(t1, 0);
      preheader = t1[0];
      if (typeof changesFlags !== "number")
        return changesFlags.$shl();
      dependsFlags = changesFlags << 3;
      instruction = block.first;
      if (block !== loopHeader) {
        t1 = this.blockChangesFlags;
        t2 = loopHeader.id;
        if (t2 >>> 0 !== t2 || t2 >= t1.length)
          return H.ioore(t1, t2);
        if (t1[t2] === 0) {
          if (new B.SsaGlobalValueNumberer_moveLoopInvariantCodeFromBlock_isLoopAlwaysTaken(this, loopHeader).call$0() === true) {
            t1 = loopHeader.successors;
            if (0 >= t1.length)
              return H.ioore(t1, 0);
            t1 = J.$eq(t1[0], block);
          } else
            t1 = false;
          firstInstructionInLoop = t1;
        } else
          firstInstructionInLoop = false;
      } else
        firstInstructionInLoop = true;
      for (t1 = J.getInterceptor$x(preheader); instruction != null; instruction = next, changesFlags = changesFlags0) {
        next = instruction.next;
        if (instruction._useGvn)
          if (instruction.get$isMovable())
            t2 = (!instruction.canThrow$0() || firstInstructionInLoop) && (instruction.sideEffects.flags & dependsFlags) >>> 0 === 0;
          else
            t2 = false;
        else
          t2 = false;
        if (t2) {
          inputs = instruction.inputs;
          $length = inputs.length;
          i = 0;
          while (true) {
            if (!(i < $length)) {
              loopInvariantInputs = true;
              break;
            }
            if (i >= inputs.length)
              return H.ioore(inputs, i);
            t2 = inputs[i].get$block().id;
            t3 = t1.get$id(preheader);
            if (typeof t2 !== "number")
              return t2.$gt();
            if (typeof t3 !== "number")
              return H.iae(t3);
            if (t2 > t3) {
              loopInvariantInputs = false;
              break;
            }
            ++i;
          }
          if (loopInvariantInputs) {
            block.detach$1(instruction);
            preheader.moveAtExit$1(instruction);
          } else
            firstInstructionInLoop = false;
        }
        changesFlags0 = (changesFlags | instruction.sideEffects.flags & 7) >>> 0;
        if (changesFlags !== changesFlags0)
          dependsFlags = changesFlags0 << 3;
      }
    },
    visitBasicBlock$3: function(block, values, workQueue) {
      var instruction, t1, t2, next, other, dominatedBlocks, $length, i, dominated, successorValues, t3, t4, workQueue0, changesFlags;
      instruction = block.first;
      if (block.loopInformation != null) {
        t1 = this.loopChangesFlags;
        t2 = block.id;
        if (t2 >>> 0 !== t2 || t2 >= t1.length)
          return H.ioore(t1, t2);
        values.kill$1(t1[t2]);
      }
      for (; instruction != null; instruction = next) {
        next = instruction.next;
        values.kill$1(instruction.sideEffects.flags & 7);
        if (instruction._useGvn) {
          other = values.lookup$1(instruction);
          if (other != null) {
            block.rewriteWithBetterUser$2(instruction, other);
            block.remove$1(0, instruction);
          } else
            values.add$1(0, instruction);
        }
      }
      dominatedBlocks = block.dominatedBlocks;
      for ($length = dominatedBlocks.length, t1 = $length - 1, t2 = this.visited, i = 0; i < $length; ++i) {
        if (i >= dominatedBlocks.length)
          return H.ioore(dominatedBlocks, i);
        dominated = dominatedBlocks[i];
        if (i === t1)
          successorValues = values;
        else {
          t3 = Array(8);
          t3.$builtinTypeInfo = [B.HInstruction];
          successorValues = B.ValueSet_copyTo(new B.ValueSet(0, t3, null), values.table, values.collisions);
        }
        if (J.get$size$x(successorValues) !== 0) {
          t3 = block.id;
          if (typeof t3 !== "number")
            return t3.$add();
          t4 = dominated.id;
          if (typeof t4 !== "number")
            return H.iae(t4);
          t4 = t3 + 1 < t4;
          t3 = t4;
        } else
          t3 = false;
        if (t3) {
          t2.clear$0(0);
          workQueue0 = [dominated];
          workQueue0.$builtinTypeInfo = [B.HBasicBlock];
          changesFlags = 0;
          do {
            if (0 >= workQueue0.length)
              return H.ioore(workQueue0, 0);
            changesFlags = (changesFlags | this.getChangesFlagsForDominatedBlock$3(block, workQueue0.pop(), workQueue0)) >>> 0;
          } while (workQueue0.length !== 0);
          successorValues.kill$1(changesFlags);
        }
        workQueue.push(new B.GvnWorkItem(dominated, successorValues));
      }
    },
    computeChangesFlags$1: function(graph) {
      var t1, $length, t2, i, block, id, instruction, changesFlags, t3, parentLoopHeader, t4, t5;
      t1 = graph.blocks;
      $length = t1.length;
      this.blockChangesFlags = H.setRuntimeTypeInfo(Array($length), [P.$int]);
      t2 = H.setRuntimeTypeInfo(Array($length), [P.$int]);
      this.loopChangesFlags = t2;
      for (i = 0; i < $length; ++i) {
        if (i >= t2.length)
          return H.ioore(t2, i);
        t2[i] = 0;
      }
      for (i = $length - 1; i >= 0; --i) {
        if (i >= t1.length)
          return H.ioore(t1, i);
        block = t1[i];
        t2 = J.getInterceptor$x(block);
        id = t2.get$id(block);
        instruction = t2.get$first(block);
        for (changesFlags = 0; instruction != null;) {
          changesFlags |= instruction.get$sideEffects().flags & 7;
          instruction = instruction.get$next();
        }
        t2 = this.blockChangesFlags;
        if (id >>> 0 !== id || id >= t2.length)
          return H.ioore(t2, id);
        t2[id] = changesFlags;
        if (block.get$loopInformation() != null) {
          t2 = this.loopChangesFlags;
          if (id >= t2.length)
            return H.ioore(t2, id);
          t3 = t2[id];
          if (typeof t3 !== "number")
            return t3.$or();
          t2[id] = (t3 | changesFlags) >>> 0;
        }
        parentLoopHeader = block.parentLoopHeader;
        if (parentLoopHeader != null) {
          t2 = this.loopChangesFlags;
          t3 = parentLoopHeader.id;
          t4 = t2.length;
          if (t3 >>> 0 !== t3 || t3 >= t4)
            return H.ioore(t2, t3);
          t5 = t2[t3];
          if (block.loopInformation != null) {
            if (id >= t4)
              return H.ioore(t2, id);
            t4 = t2[id];
          } else
            t4 = changesFlags;
          if (typeof t5 !== "number")
            return t5.$or();
          if (typeof t4 !== "number")
            return H.iae(t4);
          t2[t3] = (t5 | t4) >>> 0;
        }
      }
    },
    getChangesFlagsForDominatedBlock$3: function(dominator, dominated, workQueue) {
      var predecessors, $length, t1, changesFlags, i, block, id, t2, t3;
      predecessors = dominated.predecessors;
      for ($length = predecessors.length, t1 = this.visited, changesFlags = 0, i = 0; i < $length; ++i) {
        if (i >= predecessors.length)
          return H.ioore(predecessors, i);
        block = predecessors[i];
        id = J.get$id$x(block);
        t2 = dominator.id;
        if (typeof t2 !== "number")
          return t2.$lt();
        if (typeof id !== "number")
          return H.iae(id);
        if (t2 < id) {
          t2 = dominated.id;
          if (typeof t2 !== "number")
            return H.iae(t2);
          t2 = id < t2 && !t1.contains$1(0, id);
        } else
          t2 = false;
        if (t2) {
          t1.add$1(0, id);
          t2 = this.blockChangesFlags;
          if (id < 0 || id >= t2.length)
            return H.ioore(t2, id);
          t2 = t2[id];
          if (typeof t2 !== "number")
            return H.iae(t2);
          t3 = this.loopChangesFlags;
          if (id >= t3.length)
            return H.ioore(t3, id);
          t3 = t3[id];
          if (typeof t3 !== "number")
            return H.iae(t3);
          changesFlags = (changesFlags | t2 | t3) >>> 0;
          workQueue.push(block);
        }
      }
      return changesFlags;
    }
  },
  SsaGlobalValueNumberer_moveLoopInvariantCodeFromBlock_isLoopAlwaysTaken: {
    "^": "Closure:42;this_0,loopHeader_1",
    call$0: function() {
      var instruction, t1;
      instruction = this.loopHeader_1.last;
      if (!J.getInterceptor(instruction).$isHGoto) {
        t1 = instruction.inputs;
        if (0 >= t1.length)
          return H.ioore(t1, 0);
        t1 = t1[0].isConstantTrue$0();
      } else
        t1 = true;
      return t1;
    },
    $isFunction: true
  },
  SsaCodeMotion: {
    "^": "HBaseVisitor;name>,values>,currentBlock",
    visitGraph$1: function(graph) {
      var t1, i, t2, t3, t4;
      t1 = graph.blocks;
      this.values = H.setRuntimeTypeInfo(Array(t1.length), [B.ValueSet]);
      for (i = 0; i < t1.length; ++i) {
        t2 = this.values;
        t3 = J.get$id$x(t1[i]);
        t4 = Array(8);
        t4.$builtinTypeInfo = [B.HInstruction];
        if (t3 >>> 0 !== t3 || t3 >= t2.length)
          return H.ioore(t2, t3);
        t2[t3] = new B.ValueSet(0, t4, null);
      }
      this.visitPostDominatorTree$1(graph);
    },
    visitBasicBlock$1: function(block) {
      var successors, t1, t2, instructions, i, list, instruction, successor, t3, t4, t5, toRewrite, set_, flags, flags0, instruction0, canBeMoved, existing;
      successors = block.successors;
      if (successors.length > 1) {
        t1 = this.values;
        t2 = J.get$id$x(successors[0]);
        if (t2 >>> 0 !== t2 || t2 >= t1.length)
          return H.ioore(t1, t2);
        instructions = t1[t2];
        for (i = 1; i < successors.length; ++i) {
          t1 = this.values;
          t2 = J.get$id$x(successors[i]);
          if (t2 >>> 0 !== t2 || t2 >= t1.length)
            return H.ioore(t1, t2);
          instructions = instructions.intersection$1(0, t1[t2]);
        }
        if (instructions.size !== 0) {
          list = B.ValueSet_copyTo(H.setRuntimeTypeInfo([], [B.HInstruction]), instructions.table, instructions.collisions);
          for (t1 = H.setRuntimeTypeInfo(new H.ListIterator(list, J.get$length$asx(list), 0, null), [H.getTypeArgumentByIndex(list, 0)]); t1.moveNext$0();) {
            instruction = t1.__internal$_current;
            instruction.get$block().detach$1(instruction);
            block.moveAtExit$1(instruction);
            t2 = new H.ListIterator(successors, successors.length, 0, null);
            t2.$builtinTypeInfo = [H.getTypeArgumentByIndex(successors, 0)];
            for (; t2.moveNext$0();) {
              successor = t2.__internal$_current;
              t3 = this.values;
              t4 = J.getInterceptor$x(successor);
              t5 = t4.get$id(successor);
              if (t5 >>> 0 !== t5 || t5 >= t3.length)
                return H.ioore(t3, t5);
              toRewrite = t3[t5].lookup$1(instruction);
              if (toRewrite !== instruction) {
                successor.rewriteWithBetterUser$2(toRewrite, instruction);
                t4.remove$1(successor, toRewrite);
              }
            }
          }
        }
      }
      if (block.predecessors.length !== 1)
        return;
      t1 = this.values;
      t2 = block.id;
      if (t2 >>> 0 !== t2 || t2 >= t1.length)
        return H.ioore(t1, t2);
      set_ = t1[t2];
      instruction = block.first;
      for (flags = 0; instruction != null; flags = flags0, instruction = instruction0) {
        flags0 = flags | instruction.sideEffects.flags & 7;
        instruction0 = instruction.next;
        if (!instruction._useGvn || !instruction.get$isMovable())
          continue;
        if (instruction.canThrow$0())
          continue;
        if ((instruction.sideEffects.flags & flags << 3) >>> 0 !== 0)
          continue;
        t1 = instruction.inputs;
        t2 = new H.ListIterator(t1, t1.length, 0, null);
        t2.$builtinTypeInfo = [H.getTypeArgumentByIndex(t1, 0)];
        while (true) {
          if (!t2.moveNext$0()) {
            canBeMoved = true;
            break;
          }
          if (t2.__internal$_current.get$block() === block) {
            canBeMoved = false;
            break;
          }
        }
        if (!canBeMoved)
          continue;
        existing = set_.lookup$1(instruction);
        if (existing == null)
          set_.add$1(0, instruction);
        else {
          block.rewriteWithBetterUser$2(instruction, existing);
          block.remove$1(0, instruction);
        }
      }
    }
  },
  SsaTypeConversionInserter: {
    "^": "HBaseVisitor;name>,compiler<,currentBlock",
    visitGraph$1: function(graph) {
      this.visitDominatorTree$1(graph);
    },
    insertTypePropagationForDominatedUsers$3: function(dominator, input, convertedType) {
      var dominatedUsers, t1, t2, t3, newInput;
      dominatedUsers = input.dominatedUsers$1(dominator.first);
      if (dominatedUsers.get$isEmpty(dominatedUsers))
        return;
      t1 = [input];
      t1.$builtinTypeInfo = [B.HInstruction];
      t2 = $.HInstruction_idCounter;
      if (typeof t2 !== "number")
        return t2.$add();
      $.HInstruction_idCounter = t2 + 1;
      t3 = [];
      t3.$builtinTypeInfo = [B.HInstruction];
      newInput = new B.HTypeKnown(convertedType, false, null, null, t2, t1, t3, null, null, null, new Z.SideEffects(0), false, convertedType);
      newInput.HInstruction$2(t1, convertedType);
      newInput._useGvn = true;
      dominator.addBefore$2(dominator.first, newInput);
      dominatedUsers.forEach$1(0, new B.SsaTypeConversionInserter_insertTypePropagationForDominatedUsers_closure(input, newInput));
    },
    visitIs$1: function(instruction) {
      var element, ifUsers, notIfUsers, t1, convertedType, t2, input;
      element = instruction.typeExpression.get$element();
      if (instruction.kind !== 0)
        return;
      else if (element.kind === C.ElementKind_typedef_32)
        return;
      ifUsers = H.setRuntimeTypeInfo([], [B.HInstruction]);
      notIfUsers = H.setRuntimeTypeInfo([], [B.HInstruction]);
      this.collectIfUsers$3(instruction, ifUsers, notIfUsers);
      t1 = ifUsers.length;
      if (t1 === 0 && notIfUsers.length === 0)
        return;
      convertedType = new B.FlatTypeMask(element, 6);
      t2 = instruction.inputs;
      if (0 >= t2.length)
        return H.ioore(t2, 0);
      input = t2[0];
      for (t1 = H.setRuntimeTypeInfo(new H.ListIterator(ifUsers, t1, 0, null), [H.getTypeArgumentByIndex(ifUsers, 0)]); t1.moveNext$0();) {
        t2 = t1.__internal$_current.get$block().successors;
        if (0 >= t2.length)
          return H.ioore(t2, 0);
        this.insertTypePropagationForDominatedUsers$3(t2[0], input, convertedType);
      }
      for (t1 = H.setRuntimeTypeInfo(new H.ListIterator(notIfUsers, notIfUsers.length, 0, null), [H.getTypeArgumentByIndex(notIfUsers, 0)]); t1.moveNext$0();) {
        t2 = t1.__internal$_current.get$block().successors;
        if (1 >= t2.length)
          return H.ioore(t2, 1);
        this.insertTypePropagationForDominatedUsers$3(t2[1], input, convertedType);
      }
    },
    visitIdentity$1: function(instruction) {
      var t1, t2, left, right, input, ifUsers, notIfUsers, nonNullType;
      t1 = instruction.inputs;
      t2 = t1.length;
      if (0 >= t2)
        return H.ioore(t1, 0);
      left = t1[0];
      if (1 >= t2)
        return H.ioore(t1, 1);
      right = t1[1];
      if (left.isConstantNull$0())
        input = right;
      else {
        if (right.isConstantNull$0())
          ;
        else
          return;
        input = left;
      }
      if (!input.get$instructionType().get$isNullable())
        return;
      ifUsers = H.setRuntimeTypeInfo([], [B.HInstruction]);
      notIfUsers = H.setRuntimeTypeInfo([], [B.HInstruction]);
      this.collectIfUsers$3(instruction, ifUsers, notIfUsers);
      if (ifUsers.length === 0 && notIfUsers.length === 0)
        return;
      nonNullType = input.instructionType.nonNullable$0();
      for (t1 = H.setRuntimeTypeInfo(new H.ListIterator(ifUsers, ifUsers.length, 0, null), [H.getTypeArgumentByIndex(ifUsers, 0)]); t1.moveNext$0();) {
        t2 = t1.__internal$_current.get$block().successors;
        if (1 >= t2.length)
          return H.ioore(t2, 1);
        this.insertTypePropagationForDominatedUsers$3(t2[1], input, nonNullType);
      }
      for (t1 = H.setRuntimeTypeInfo(new H.ListIterator(notIfUsers, notIfUsers.length, 0, null), [H.getTypeArgumentByIndex(notIfUsers, 0)]); t1.moveNext$0();) {
        t2 = t1.__internal$_current.get$block().successors;
        if (0 >= t2.length)
          return H.ioore(t2, 0);
        this.insertTypePropagationForDominatedUsers$3(t2[0], input, nonNullType);
      }
    },
    collectIfUsers$3: function(instruction, ifUsers, notIfUsers) {
      var t1, t2, user;
      t1 = instruction.usedBy;
      t2 = new H.ListIterator(t1, t1.length, 0, null);
      t2.$builtinTypeInfo = [H.getTypeArgumentByIndex(t1, 0)];
      for (; t2.moveNext$0();) {
        user = t2.__internal$_current;
        t1 = J.getInterceptor(user);
        if (!!t1.$isHIf)
          ifUsers.push(user);
        else if (!!t1.$isHNot)
          this.collectIfUsers$3(user, notIfUsers, ifUsers);
      }
    }
  },
  SsaTypeConversionInserter_insertTypePropagationForDominatedUsers_closure: {
    "^": "Closure:290;input_0,newInput_1",
    call$1: function(user) {
      user.changeUse$2(this.input_0, this.newInput_1);
    },
    $isFunction: true
  },
  SsaLoadElimination: {
    "^": "HBaseVisitor;compiler<,name>,memorySet,memories,currentBlock",
    visitGraph$1: function(graph) {
      var t1, i, block, t2, j;
      t1 = graph.blocks;
      this.memories = H.setRuntimeTypeInfo(Array(t1.length), [B.MemorySet]);
      for (i = 0; i < t1.length; ++i) {
        block = t1[i];
        this.visitBasicBlock$1(block);
        if (block.get$successors().length !== 0) {
          t2 = block.get$successors();
          if (0 >= t2.length)
            return H.ioore(t2, 0);
          t2 = t2[0].isLoopHeader$0();
        } else
          t2 = false;
        if (t2) {
          t2 = block.get$successors();
          if (0 >= t2.length)
            return H.ioore(t2, 0);
          j = J.get$id$x(t2[0]);
          while (true) {
            t2 = block.get$id(block);
            if (typeof j !== "number")
              return j.$le();
            if (typeof t2 !== "number")
              return H.iae(t2);
            if (!(j <= t2))
              break;
            if (j < 0 || j >= t1.length)
              return H.ioore(t1, j);
            this.visitBasicBlock$1(t1[j]);
            ++j;
          }
        }
      }
    },
    visitBasicBlock$1: function(block) {
      var t1, t2, t3, i, instruction, next;
      if (block.get$predecessors().length === 0) {
        t1 = P.LinkedHashMap_LinkedHashMap$_empty(O.Element, [P.Map, B.HInstruction, B.HInstruction]);
        t2 = P.LinkedHashMap_LinkedHashMap$_empty(B.HInstruction, [P.Map, B.HInstruction, B.HInstruction]);
        t3 = new N.Setlet(C.C__SetletMarker, null);
        t3.$builtinTypeInfo = [B.HInstruction];
        this.memorySet = new B.MemorySet(this.compiler, t1, t2, t3);
      } else {
        if (block.get$predecessors().length === 1) {
          t1 = block.get$predecessors();
          if (0 >= t1.length)
            return H.ioore(t1, 0);
          t1 = t1[0].get$successors().length === 1;
        } else
          t1 = false;
        if (t1) {
          t1 = this.memories;
          t2 = block.get$predecessors();
          if (0 >= t2.length)
            return H.ioore(t2, 0);
          t2 = J.get$id$x(t2[0]);
          if (t2 >>> 0 !== t2 || t2 >= t1.length)
            return H.ioore(t1, t2);
          this.memorySet = t1[t2];
        } else {
          t1 = block.get$predecessors().length;
          t2 = this.memories;
          if (t1 === 1) {
            t1 = block.get$predecessors();
            if (0 >= t1.length)
              return H.ioore(t1, 0);
            t1 = J.get$id$x(t1[0]);
            if (t1 >>> 0 !== t1 || t1 >= t2.length)
              return H.ioore(t2, t1);
            this.memorySet = t2[t1].clone$0(0);
          } else {
            t1 = block.get$predecessors();
            if (0 >= t1.length)
              return H.ioore(t1, 0);
            t1 = J.get$id$x(t1[0]);
            if (t1 >>> 0 !== t1 || t1 >= t2.length)
              return H.ioore(t2, t1);
            this.memorySet = t2[t1];
            for (i = 1; i < block.get$predecessors().length; ++i) {
              t1 = this.memorySet;
              t2 = this.memories;
              t3 = block.get$predecessors();
              if (i >= t3.length)
                return H.ioore(t3, i);
              t3 = J.get$id$x(t3[i]);
              if (t3 >>> 0 !== t3 || t3 >= t2.length)
                return H.ioore(t2, t3);
              this.memorySet = t1.intersectionFor$3(t2[t3], block, i);
            }
          }
        }
      }
      t1 = this.memories;
      t2 = block.get$id(block);
      t3 = this.memorySet;
      if (t2 >>> 0 !== t2 || t2 >= t1.length)
        return H.ioore(t1, t2);
      t1[t2] = t3;
      instruction = block.first;
      for (; instruction != null; instruction = next) {
        next = instruction.next;
        instruction.accept$1(0, this);
      }
    },
    visitFieldGet$1: function(instruction) {
      var t1, t2, receiver, existing;
      t1 = instruction.element;
      if (t1 == null)
        return;
      t2 = instruction.inputs;
      if (0 >= t2.length)
        return H.ioore(t2, 0);
      receiver = t2[0].nonCheck$0();
      existing = this.memorySet.lookupFieldValue$2(t1, receiver);
      if (existing != null) {
        instruction.block.rewriteWithBetterUser$2(instruction, existing);
        instruction.block.remove$1(0, instruction);
      } else
        this.memorySet.registerFieldValue$3(t1, receiver, instruction);
    },
    visitFieldSet$1: function(instruction) {
      var t1, receiver;
      t1 = instruction.inputs;
      if (0 >= t1.length)
        return H.ioore(t1, 0);
      receiver = t1[0].nonCheck$0();
      this.memorySet.registerFieldValueUpdate$3(instruction.element, receiver, J.get$last$ax(t1));
    },
    visitForeignNew$1: function(instruction) {
      var t1 = {};
      this.memorySet.nonEscapingReceivers.add$1(0, instruction);
      t1.argumentIndex_0 = 0;
      instruction.element.forEachInstanceField$2$includeSuperAndInjectedMembers(new B.SsaLoadElimination_visitForeignNew_closure(t1, this, instruction), true);
      this.memorySet.killAffectedBy$1(instruction);
    },
    visitInstruction$1: function(instruction) {
      this.memorySet.killAffectedBy$1(instruction);
    },
    visitLazyStatic$1: function(instruction) {
      this.handleStaticLoad$2(instruction.element, instruction);
    },
    handleStaticLoad$2: function(element, instruction) {
      var existing = this.memorySet.lookupFieldValue$2(element, null);
      if (existing != null) {
        instruction.block.rewriteWithBetterUser$2(instruction, existing);
        instruction.block.remove$1(0, instruction);
      } else
        this.memorySet.registerFieldValue$3(element, null, instruction);
    },
    visitStatic$1: function(instruction) {
      this.handleStaticLoad$2(instruction.element, instruction);
    },
    visitStaticStore$1: function(instruction) {
      this.memorySet.registerFieldValueUpdate$3(instruction.element, null, J.get$last$ax(instruction.inputs));
    },
    visitLiteralList$1: function(instruction) {
      this.memorySet.nonEscapingReceivers.add$1(0, instruction);
      this.memorySet.killAffectedBy$1(instruction);
    },
    visitIndex$1: function(instruction) {
      var t1, receiver, t2, t3, map, existing;
      t1 = instruction.inputs;
      if (0 >= t1.length)
        return H.ioore(t1, 0);
      receiver = t1[0].nonCheck$0();
      t2 = this.memorySet;
      if (1 >= t1.length)
        return H.ioore(t1, 1);
      t3 = t1[1];
      map = t2.keyedValues.$index(0, receiver);
      existing = map == null ? null : J.$index$asx(map, t3);
      if (existing != null) {
        instruction.block.rewriteWithBetterUser$2(instruction, existing);
        instruction.block.remove$1(0, instruction);
      } else {
        t2 = this.memorySet;
        if (1 >= t1.length)
          return H.ioore(t1, 1);
        t2.registerKeyedValue$3(receiver, t1[1], instruction);
      }
    },
    visitIndexAssign$1: function(instruction) {
      var t1, receiver, t2, t3, t4;
      t1 = instruction.inputs;
      if (0 >= t1.length)
        return H.ioore(t1, 0);
      receiver = t1[0].nonCheck$0();
      t2 = this.memorySet;
      t3 = t1.length;
      if (1 >= t3)
        return H.ioore(t1, 1);
      t4 = t1[1];
      if (2 >= t3)
        return H.ioore(t1, 2);
      t2.registerKeyedValueUpdate$3(receiver, t4, t1[2]);
    }
  },
  SsaLoadElimination_visitForeignNew_closure: {
    "^": "Closure:48;box_0,this_1,instruction_2",
    call$2: function(_, member) {
      var t1, t2, t3, t4;
      t1 = this.this_1.memorySet;
      t2 = this.instruction_2;
      t3 = t2.inputs;
      t4 = this.box_0.argumentIndex_0++;
      if (t4 >= t3.length)
        return H.ioore(t3, t4);
      t1.registerFieldValue$3(member, t2, t3[t4]);
    },
    $isFunction: true
  },
  MemorySet: {
    "^": "Object;compiler<,fieldValues,keyedValues,nonEscapingReceivers",
    mayAlias$2: function(first, second) {
      var t1, intersection;
      if (first == null ? second == null : first === second)
        return true;
      if (this.isConcrete$1(first) && this.isConcrete$1(second))
        return false;
      t1 = this.nonEscapingReceivers;
      if (t1.contains$1(0, first) === true)
        return false;
      if (t1.contains$1(0, second) === true)
        return false;
      if (this.couldBeTypedArray$1(first) && this.couldBeTypedArray$1(second))
        return true;
      intersection = first.instructionType.intersection$2(0, second.get$instructionType(), this.compiler);
      if (intersection.get$isEmpty(intersection))
        return false;
      return true;
    },
    isFinal$1: [function(element) {
      return this.compiler.world.fieldNeverChanges$1(element);
    }, "call$1", "get$isFinal", 2, 0, 76],
    isConcrete$1: [function(instruction) {
      var t1 = J.getInterceptor(instruction);
      return !!t1.$isHForeignNew || !!t1.$isHConstant || !!t1.$isHLiteralList;
    }, "call$1", "get$isConcrete", 2, 0, 263],
    couldBeTypedArray$1: function(receiver) {
      return this.compiler.backend.couldBeTypedArray$1(receiver.get$instructionType());
    },
    registerFieldValueUpdate$3: function(element, receiver, value) {
      var map, t1;
      if (element.get$isNative())
        return;
      this.nonEscapingReceivers.remove$1(0, value);
      map = this.fieldValues.putIfAbsent$2(element, new B.MemorySet_registerFieldValueUpdate_closure());
      t1 = J.getInterceptor$ax(map);
      t1.forEach$1(map, new B.MemorySet_registerFieldValueUpdate_closure0(this, receiver, map));
      t1.$indexSet(map, receiver, value);
    },
    registerFieldValue$3: function(element, receiver, value) {
      if (element.get$isNative())
        return;
      J.$indexSet$ax(this.fieldValues.putIfAbsent$2(element, new B.MemorySet_registerFieldValue_closure()), receiver, value);
    },
    lookupFieldValue$2: function(element, receiver) {
      var map = this.fieldValues.$index(0, element);
      return map == null ? null : J.$index$asx(map, receiver);
    },
    killAffectedBy$1: function(instruction) {
      var t1 = instruction.inputs;
      t1.toString;
      H.IterableMixinWorkaround_forEach(t1, new B.MemorySet_killAffectedBy_closure(this));
      t1 = instruction.sideEffects.flags;
      if ((t1 & 2) !== 0 || (t1 & 4) !== 0)
        this.fieldValues.forEach$1(0, new B.MemorySet_killAffectedBy_closure0(this));
      if ((instruction.sideEffects.flags & 1) !== 0)
        this.keyedValues.forEach$1(0, new B.MemorySet_killAffectedBy_closure1(this));
    },
    registerKeyedValue$3: function(receiver, index, value) {
      J.$indexSet$ax(this.keyedValues.putIfAbsent$2(receiver, new B.MemorySet_registerKeyedValue_closure()), index, value);
    },
    registerKeyedValueUpdate$3: function(receiver, index, value) {
      var t1;
      this.nonEscapingReceivers.remove$1(0, value);
      t1 = this.keyedValues;
      t1.forEach$1(0, new B.MemorySet_registerKeyedValueUpdate_closure(this, receiver, index));
      if (this.couldBeTypedArray$1(receiver))
        return;
      J.$indexSet$ax(t1.putIfAbsent$2(receiver, new B.MemorySet_registerKeyedValueUpdate_closure0()), index, value);
    },
    findCommonInstruction$4: function(first, second, block, predecessorIndex) {
      var t1, phiType, t2, phi, i;
      if (first == null || second == null)
        return;
      t1 = J.getInterceptor(first);
      if (t1.$eq(first, second))
        return first;
      phiType = second.get$instructionType().union$2(first.get$instructionType(), this.compiler);
      if (!!t1.$isHPhi && first.block === block) {
        first.addInput$1(second);
        first.instructionType = phiType;
        return first;
      } else {
        t1 = H.setRuntimeTypeInfo([], [B.HInstruction]);
        t2 = $.HInstruction_idCounter;
        if (typeof t2 !== "number")
          return t2.$add();
        $.HInstruction_idCounter = t2 + 1;
        phi = new B.HPhi(0, null, null, t2, t1, H.setRuntimeTypeInfo([], [B.HInstruction]), null, null, null, new Z.SideEffects(0), false, phiType);
        phi.HInstruction$2(t1, phiType);
        phi.sourceElement = null;
        block.addPhi$1(phi);
        for (t2 = first.usedBy, i = 0; i < predecessorIndex; ++i) {
          t1.push(first);
          t2.push(phi);
        }
        phi.addInput$1(second);
        return phi;
      }
    },
    intersectionFor$3: function(other, block, predecessorIndex) {
      var result = new B.MemorySet(this.compiler, P.LinkedHashMap_LinkedHashMap$_empty(O.Element, [P.Map, B.HInstruction, B.HInstruction]), P.LinkedHashMap_LinkedHashMap$_empty(B.HInstruction, [P.Map, B.HInstruction, B.HInstruction]), H.setRuntimeTypeInfo(new N.Setlet(C.C__SetletMarker, null), [B.HInstruction]));
      if (other == null)
        return result;
      this.fieldValues.forEach$1(0, new B.MemorySet_intersectionFor_closure(this, other, block, predecessorIndex, result));
      this.keyedValues.forEach$1(0, new B.MemorySet_intersectionFor_closure0(this, other, block, predecessorIndex, result));
      this.nonEscapingReceivers.forEach$1(0, new B.MemorySet_intersectionFor_closure1(other, result));
      return result;
    },
    clone$0: function(_) {
      var t1, t2, t3, result;
      t1 = P.LinkedHashMap_LinkedHashMap$_empty(O.Element, [P.Map, B.HInstruction, B.HInstruction]);
      t2 = P.LinkedHashMap_LinkedHashMap$_empty(B.HInstruction, [P.Map, B.HInstruction, B.HInstruction]);
      t3 = H.setRuntimeTypeInfo(new N.Setlet(C.C__SetletMarker, null), [B.HInstruction]);
      result = new B.MemorySet(this.compiler, t1, t2, t3);
      this.fieldValues.forEach$1(0, new B.MemorySet_clone_closure(result));
      this.keyedValues.forEach$1(0, new B.MemorySet_clone_closure0(result));
      t3.addAll$1(0, this.nonEscapingReceivers);
      return result;
    }
  },
  MemorySet_registerFieldValueUpdate_closure: {
    "^": "Closure:23;",
    call$0: function() {
      return P.LinkedHashMap_LinkedHashMap$_empty(B.HInstruction, B.HInstruction);
    },
    $isFunction: true
  },
  MemorySet_registerFieldValueUpdate_closure0: {
    "^": "Closure:19;this_0,receiver_1,map_2",
    call$2: function(key, value) {
      if (this.this_0.mayAlias$2(this.receiver_1, key))
        this.map_2.$indexSet(0, key, null);
    },
    $isFunction: true
  },
  MemorySet_registerFieldValue_closure: {
    "^": "Closure:23;",
    call$0: function() {
      return P.LinkedHashMap_LinkedHashMap$_empty(B.HInstruction, B.HInstruction);
    },
    $isFunction: true
  },
  MemorySet_killAffectedBy_closure: {
    "^": "Closure:13;this_0",
    call$1: function(input) {
      this.this_0.nonEscapingReceivers.remove$1(0, input);
    },
    $isFunction: true
  },
  MemorySet_killAffectedBy_closure0: {
    "^": "Closure:19;this_1",
    call$2: function(element, map) {
      var t1 = this.this_1;
      if (t1.compiler.world.fieldNeverChanges$1(element))
        return;
      J.forEach$1$ax(map, new B.MemorySet_killAffectedBy__closure0(t1, map));
    },
    $isFunction: true
  },
  MemorySet_killAffectedBy__closure0: {
    "^": "Closure:19;this_2,map_3",
    call$2: function(receiver, value) {
      if (this.this_2.nonEscapingReceivers.contains$1(0, receiver) !== true)
        J.$indexSet$ax(this.map_3, receiver, null);
    },
    $isFunction: true
  },
  MemorySet_killAffectedBy_closure1: {
    "^": "Closure:19;this_4",
    call$2: function(receiver, map) {
      if (this.this_4.nonEscapingReceivers.contains$1(0, receiver) !== true)
        J.forEach$1$ax(map, new B.MemorySet_killAffectedBy__closure(map));
    },
    $isFunction: true
  },
  MemorySet_killAffectedBy__closure: {
    "^": "Closure:19;map_5",
    call$2: function(index, value) {
      J.$indexSet$ax(this.map_5, index, null);
    },
    $isFunction: true
  },
  MemorySet_registerKeyedValue_closure: {
    "^": "Closure:23;",
    call$0: function() {
      return P.LinkedHashMap_LinkedHashMap$_empty(B.HInstruction, B.HInstruction);
    },
    $isFunction: true
  },
  MemorySet_registerKeyedValueUpdate_closure: {
    "^": "Closure:19;this_0,receiver_1,index_2",
    call$2: function(key, values) {
      var t1, t2, weakIndex;
      t1 = this.this_0;
      t2 = this.receiver_1;
      if (t1.mayAlias$2(t2, key)) {
        weakIndex = t1.couldBeTypedArray$1(key) && t2 !== key;
        J.forEach$1$ax(values, new B.MemorySet_registerKeyedValueUpdate__closure(t1, this.index_2, values, weakIndex));
      }
    },
    $isFunction: true
  },
  MemorySet_registerKeyedValueUpdate__closure: {
    "^": "Closure:19;this_3,index_4,values_5,weakIndex_6",
    call$2: function(otherIndex, otherValue) {
      if (this.weakIndex_6 || this.this_3.mayAlias$2(this.index_4, otherIndex))
        J.$indexSet$ax(this.values_5, otherIndex, null);
    },
    $isFunction: true
  },
  MemorySet_registerKeyedValueUpdate_closure0: {
    "^": "Closure:23;",
    call$0: function() {
      return P.LinkedHashMap_LinkedHashMap$_empty(B.HInstruction, B.HInstruction);
    },
    $isFunction: true
  },
  MemorySet_intersectionFor_closure: {
    "^": "Closure:19;this_0,other_1,block_2,predecessorIndex_3,result_4",
    call$2: function(element, values) {
      var otherValues = this.other_1.fieldValues.$index(0, element);
      if (otherValues == null)
        return;
      J.forEach$1$ax(values, new B.MemorySet_intersectionFor__closure0(this.this_0, this.block_2, this.predecessorIndex_3, this.result_4, element, otherValues));
    },
    $isFunction: true
  },
  MemorySet_intersectionFor__closure0: {
    "^": "Closure:19;this_5,block_6,predecessorIndex_7,result_8,element_9,otherValues_10",
    call$2: function(receiver, value) {
      var instruction = this.this_5.findCommonInstruction$4(value, J.$index$asx(this.otherValues_10, receiver), this.block_6, this.predecessorIndex_7);
      if (instruction != null)
        this.result_8.registerFieldValue$3(this.element_9, receiver, instruction);
    },
    $isFunction: true
  },
  MemorySet_intersectionFor_closure0: {
    "^": "Closure:19;this_11,other_12,block_13,predecessorIndex_14,result_15",
    call$2: function(receiver, values) {
      var otherValues = this.other_12.keyedValues.$index(0, receiver);
      if (otherValues == null)
        return;
      J.forEach$1$ax(values, new B.MemorySet_intersectionFor__closure(this.this_11, this.block_13, this.predecessorIndex_14, this.result_15, receiver, otherValues));
    },
    $isFunction: true
  },
  MemorySet_intersectionFor__closure: {
    "^": "Closure:19;this_16,block_17,predecessorIndex_18,result_19,receiver_20,otherValues_21",
    call$2: function(index, value) {
      var instruction = this.this_16.findCommonInstruction$4(value, J.$index$asx(this.otherValues_21, index), this.block_17, this.predecessorIndex_18);
      if (instruction != null)
        this.result_19.registerKeyedValue$3(this.receiver_20, index, instruction);
    },
    $isFunction: true
  },
  MemorySet_intersectionFor_closure1: {
    "^": "Closure:13;other_22,result_23",
    call$1: function(receiver) {
      if (this.other_22.nonEscapingReceivers.contains$1(0, receiver) === true)
        this.result_23.nonEscapingReceivers.add$1(0, receiver);
    },
    $isFunction: true
  },
  MemorySet_clone_closure: {
    "^": "Closure:19;result_0",
    call$2: function(element, values) {
      var t1 = P.LinkedHashMap_LinkedHashMap(null, null, null, B.HInstruction, B.HInstruction);
      t1.addAll$1(0, values);
      this.result_0.fieldValues.$indexSet(0, element, t1);
    },
    $isFunction: true
  },
  MemorySet_clone_closure0: {
    "^": "Closure:19;result_1",
    call$2: function(receiver, values) {
      var t1 = P.LinkedHashMap_LinkedHashMap(null, null, null, B.HInstruction, B.HInstruction);
      t1.addAll$1(0, values);
      this.result_1.keyedValues.$indexSet(0, receiver, t1);
    },
    $isFunction: true
  },
  TypeMaskFactory_fromNativeBehavior_closure: {
    "^": "Closure:13;compiler_0",
    call$1: function(type) {
      return B.TypeMaskFactory_fromNativeType(type, this.compiler_0);
    },
    $isFunction: true
  },
  TypeMaskFactory_fromNativeBehavior_closure0: {
    "^": "Closure:19;compiler_1",
    call$2: function(t1, t2) {
      return t1.union$2(t2, this.compiler_1);
    },
    $isFunction: true
  },
  SsaTypePropagator: {
    "^": "HBaseVisitor;workmap,worklist,pendingOptimizations,compiler<,currentBlock",
    get$backend: function() {
      return this.compiler.backend;
    },
    get$name: function(_) {
      return "type propagator";
    },
    computeType$1: function(instruction) {
      return instruction.accept$1(0, this);
    },
    updateType$1: function(instruction) {
      var oldType, newType;
      oldType = instruction.instructionType;
      newType = instruction.accept$1(0, this);
      instruction.set$instructionType(newType);
      return !J.$eq(oldType, newType);
    },
    visitGraph$1: function(graph) {
      this.visitDominatorTree$1(graph);
      this.processWorklist$0();
    },
    visitBasicBlock$1: function(block) {
      var instruction;
      if (block.loopInformation != null)
        block.forEachPhi$1(new B.SsaTypePropagator_visitBasicBlock_closure(this));
      else
        block.forEachPhi$1(new B.SsaTypePropagator_visitBasicBlock_closure0(this));
      instruction = block.first;
      for (; instruction != null;) {
        if (this.updateType$1(instruction))
          this.addDependentInstructionsToWorkList$1(instruction);
        instruction = instruction.next;
      }
    },
    processWorklist$0: function() {
      var t1, t2, t3, id, instruction;
      t1 = this.worklist;
      t2 = this.workmap;
      do {
        for (; t3 = t1.length, t3 !== 0;) {
          if (0 >= t3)
            return H.ioore(t1, 0);
          id = t1.pop();
          instruction = t2.$index(0, id);
          t2.remove$1(0, id);
          if (this.updateType$1(instruction))
            this.addDependentInstructionsToWorkList$1(instruction);
        }
        this.processPendingOptimizations$0();
      } while (t1.length !== 0);
    },
    addToWorkList$1: function(instruction) {
      var id, t1;
      id = J.get$id$x(instruction);
      t1 = this.workmap;
      if (!t1.containsKey$1(id)) {
        this.worklist.push(id);
        t1.$indexSet(0, id, instruction);
      }
    },
    visitBinaryArithmetic$1: function(instruction) {
      var t1, t2, left, right;
      t1 = instruction.inputs;
      t2 = t1.length;
      if (0 >= t2)
        return H.ioore(t1, 0);
      left = t1[0];
      if (1 >= t2)
        return H.ioore(t1, 1);
      right = t1[1];
      t1 = this.compiler;
      if (left.get$instructionType().containsOnlyInt$1(t1) && !left.instructionType.get$isNullable() && right.get$instructionType().containsOnlyInt$1(t1) && !right.instructionType.get$isNullable())
        return t1.backend.compiler.typesTask.get$intType();
      if (left.instructionType.containsOnlyDouble$1(t1) && !left.instructionType.get$isNullable())
        return t1.backend.compiler.typesTask.get$doubleType();
      return t1.backend.compiler.typesTask.get$numType();
    },
    checkPositiveInteger$1: function(instruction) {
      var t1, t2, left, right;
      t1 = instruction.inputs;
      t2 = t1.length;
      if (0 >= t2)
        return H.ioore(t1, 0);
      left = t1[0];
      if (1 >= t2)
        return H.ioore(t1, 1);
      right = t1[1];
      t1 = this.compiler;
      if (left.isPositiveInteger$1(t1) && right.isPositiveInteger$1(t1))
        return t1.backend.compiler.typesTask.get$positiveIntType();
      return this.visitBinaryArithmetic$1(instruction);
    },
    visitMultiply$1: function(instruction) {
      return this.checkPositiveInteger$1(instruction);
    },
    visitAdd$1: function(instruction) {
      return this.checkPositiveInteger$1(instruction);
    },
    visitNegate$1: function(instruction) {
      var t1, operand, t2;
      t1 = instruction.inputs;
      if (0 >= t1.length)
        return H.ioore(t1, 0);
      operand = t1[0];
      t2 = this.compiler;
      if (operand.get$instructionType().containsOnlyInt$1(t2) && !operand.instructionType.get$isNullable())
        return t2.backend.compiler.typesTask.get$intType();
      if (0 >= t1.length)
        return H.ioore(t1, 0);
      return t1[0].get$instructionType();
    },
    visitInstruction$1: function(instruction) {
      return instruction.get$instructionType();
    },
    visitPhi$1: function(phi) {
      var t1, t2, $length, candidateType, i;
      t1 = this.compiler;
      t1.backend.toString;
      for (t2 = phi.inputs, $length = t2.length, candidateType = C.FlatTypeMask_null_0, i = 0; i < $length; ++i) {
        if (i >= t2.length)
          return H.ioore(t2, i);
        candidateType = candidateType.union$2(t2[i].get$instructionType(), t1);
      }
      return candidateType;
    },
    visitTypeConversion$1: function(instruction) {
      var t1, input, inputType, checkedType, outputType, t2;
      t1 = instruction.inputs;
      if (0 >= t1.length)
        return H.ioore(t1, 0);
      input = t1[0];
      inputType = input.get$instructionType();
      checkedType = instruction.checkedType;
      t1 = instruction.kind;
      if (t1 === 1 || t1 === 4) {
        t1 = this.compiler;
        if (checkedType.containsOnlyNum$1(t1) && !checkedType.containsOnlyDouble$1(t1) && input.instructionType.containsOnlyInt$1(t1))
          instruction.checkedType = t1.backend.compiler.typesTask.get$intType();
        else if (checkedType.containsOnlyInt$1(t1) && !input.instructionType.containsOnlyInt$1(t1))
          instruction.checkedType = t1.backend.compiler.typesTask.get$numType();
      }
      t1 = this.compiler;
      outputType = checkedType.intersection$2(0, inputType, t1);
      if (outputType.get$isEmpty(outputType) && !outputType.get$isNullable())
        if (inputType.containsOnlyInt$1(t1) && checkedType.containsOnlyDouble$1(t1)) {
          t2 = inputType.get$isNullable() && checkedType.get$isNullable();
          t1 = t1.backend;
          outputType = t2 ? t1.compiler.typesTask.get$doubleType().nullable$0() : t1.compiler.typesTask.get$doubleType();
        }
      return outputType;
    },
    visitTypeKnown$1: function(instruction) {
      var t1, input;
      t1 = instruction.inputs;
      if (0 >= t1.length)
        return H.ioore(t1, 0);
      input = t1[0];
      return instruction.knownType.intersection$2(0, input.get$instructionType(), this.compiler);
    },
    convertInput$4: function(instruction, input, type, kind) {
      var converted = B.HTypeConversion$(null, kind, type, input, kind === 4 ? instruction.selector : null);
      instruction.block.addBefore$2(instruction, converted);
      input.replaceAllUsersDominatedBy$2(instruction, converted);
    },
    isCheckEnoughForNsmOrAe$2: function(instruction, type) {
      var t1 = this.compiler;
      if (type.containsOnlyInt$1(t1))
        return instruction.instructionType.containsOnlyInt$1(t1);
      return true;
    },
    checkReceiver$1: function(instruction) {
      var t1, receiver, targets, t2, target, type;
      t1 = instruction.inputs;
      if (1 >= t1.length)
        return H.ioore(t1, 1);
      receiver = t1[1];
      t1 = this.compiler;
      if (receiver.get$instructionType().containsOnlyNum$1(t1) && !receiver.instructionType.get$isNullable())
        return false;
      if (receiver.instructionType.containsOnlyNum$1(t1)) {
        this.convertInput$4(instruction, receiver, receiver.instructionType.nonNullable$0(), 4);
        return true;
      } else if (instruction.element == null) {
        targets = t1.world.allFunctions.query$1(0, instruction.selector).functions;
        t2 = J.getInterceptor$asx(targets);
        if (t2.get$length(targets) === 1) {
          target = t2.get$first(targets);
          type = new B.FlatTypeMask(target.get$enclosingClass().get$declaration(), 4);
          if (!type.satisfies$2(t1.backend.get$jsIndexableClass(), t1) && !type.containsOnlyNum$1(t1) && !type.containsOnlyBool$1(t1))
            return false;
          if (!this.isCheckEnoughForNsmOrAe$2(receiver, type))
            return false;
          instruction.element = target;
          this.convertInput$4(instruction, receiver, type, 4);
          return true;
        }
      }
      return false;
    },
    checkArgument$1: function(instruction) {
      var t1, t2, t3, left, right;
      t1 = this.compiler;
      if (t1.enableTypeAssertions)
        return false;
      t2 = instruction.inputs;
      t3 = t2.length;
      if (1 >= t3)
        return H.ioore(t2, 1);
      left = t2[1];
      if (2 >= t3)
        return H.ioore(t2, 2);
      right = t2[2];
      if (instruction.selector.kind === C.SelectorKind_operator_3 && left.get$instructionType().containsOnlyNum$1(t1) && !left.instructionType.get$isNullable()) {
        if (right.get$instructionType().containsOnlyNum$1(t1) && !right.instructionType.get$isNullable())
          return false;
        this.convertInput$4(instruction, right, right.instructionType.containsOnlyInt$1(t1) ? right.instructionType.nonNullable$0() : t1.backend.compiler.typesTask.get$numType(), 1);
        return true;
      }
      return false;
    },
    processPendingOptimizations$0: function() {
      var t1 = this.pendingOptimizations;
      t1.forEach$1(0, new B.SsaTypePropagator_processPendingOptimizations_closure());
      t1.clear$0(0);
    },
    addDependentInstructionsToWorkList$1: function(instruction) {
      var t1, $length, t2, t3, i, t4, id;
      for (t1 = instruction.usedBy, $length = t1.length, t2 = this.workmap, t3 = this.worklist, i = 0; i < $length; ++i) {
        if (i >= t1.length)
          return H.ioore(t1, i);
        t4 = t1[i];
        id = J.get$id$x(t4);
        if (!t2.containsKey$1(id)) {
          t3.push(id);
          t2.$indexSet(0, id, t4);
        }
      }
    },
    addAllUsersBut$2: function(invoke, instruction) {
      H.IterableMixinWorkaround_forEach(instruction.get$usedBy(), new B.SsaTypePropagator_addAllUsersBut_closure(this, invoke));
    },
    visitInvokeDynamic$1: function(instruction) {
      var t1, t2, receiver, receiverType, selector, newType, next, t3, converted;
      if (instruction.get$isInterceptedCall())
        this.pendingOptimizations.putIfAbsent$2(instruction, new B.SsaTypePropagator_visitInvokeDynamic_closure(this, instruction));
      t1 = this.compiler;
      t2 = instruction.inputs;
      if (instruction.isCallOnInterceptor$1(t1)) {
        if (1 >= t2.length)
          return H.ioore(t2, 1);
        receiver = t2[1];
      } else {
        if (0 >= t2.length)
          return H.ioore(t2, 0);
        receiver = t2[0];
      }
      receiverType = receiver.get$instructionType();
      selector = Z.TypedSelector_TypedSelector(receiverType, instruction.selector, t1);
      instruction.selector = selector;
      t2 = receiver.dominatedUsers$1(instruction);
      if (t2.get$length(t2) !== 1 && !selector.get$isClosureCall()) {
        t2 = t1.world.allFunctions;
        newType = t2.query$1(0, selector).computeMask$1(t2.compiler).intersection$2(0, receiverType, t1);
        next = instruction.next;
        if (!!J.getInterceptor(next).$isHTypeKnown) {
          t2 = next.inputs;
          if (0 >= t2.length)
            return H.ioore(t2, 0);
          t2 = J.$eq(t2[0], receiver);
        } else
          t2 = false;
        if (t2) {
          if (!J.$eq(next.instructionType, newType)) {
            next.set$instructionType(newType);
            next.set$knownType(newType);
            this.addDependentInstructionsToWorkList$1(next);
          }
        } else if (!J.$eq(newType, receiverType)) {
          t2 = H.setRuntimeTypeInfo([receiver, instruction], [B.HInstruction]);
          t3 = $.HInstruction_idCounter;
          if (typeof t3 !== "number")
            return t3.$add();
          $.HInstruction_idCounter = t3 + 1;
          converted = new B.HTypeKnown(newType, true, null, null, t3, t2, H.setRuntimeTypeInfo([], [B.HInstruction]), null, null, null, new Z.SideEffects(0), false, newType);
          converted.HInstruction$2(t2, newType);
          converted._useGvn = true;
          instruction.block.addBefore$2(instruction.next, converted);
          receiver.replaceAllUsersDominatedBy$2(converted.next, converted);
          this.addDependentInstructionsToWorkList$1(converted);
        }
      }
      return instruction.specializer.computeTypeFromInputTypes$2(instruction, t1);
    }
  },
  SsaTypePropagator_visitBasicBlock_closure: {
    "^": "Closure:259;this_0",
    call$1: function(phi) {
      var t1 = phi.inputs;
      if (0 >= t1.length)
        return H.ioore(t1, 0);
      phi.instructionType = t1[0].get$instructionType();
      this.this_0.addToWorkList$1(phi);
    },
    $isFunction: true
  },
  SsaTypePropagator_visitBasicBlock_closure0: {
    "^": "Closure:259;this_1",
    call$1: function(phi) {
      var t1 = this.this_1;
      if (t1.updateType$1(phi))
        t1.addDependentInstructionsToWorkList$1(phi);
    },
    $isFunction: true
  },
  SsaTypePropagator_processPendingOptimizations_closure: {
    "^": "Closure:19;",
    call$2: function(instruction, action) {
      return action.call$0();
    },
    $isFunction: true
  },
  SsaTypePropagator_addAllUsersBut_closure: {
    "^": "Closure:290;this_0,invoke_1",
    call$1: function(user) {
      if (!J.$eq(user, this.invoke_1))
        this.this_0.addToWorkList$1(user);
    },
    $isFunction: true
  },
  SsaTypePropagator_visitInvokeDynamic_closure: {
    "^": "Closure:23;this_0,instruction_1",
    call$0: function() {
      return new B.SsaTypePropagator_visitInvokeDynamic__closure(this.this_0, this.instruction_1);
    },
    $isFunction: true
  },
  SsaTypePropagator_visitInvokeDynamic__closure: {
    "^": "Closure:23;this_2,instruction_3",
    call$0: function() {
      var t1, selector, t2, t3, t4;
      t1 = this.instruction_3;
      selector = t1.selector;
      t2 = selector.kind === C.SelectorKind_operator_3;
      if (t2 && selector.name !== "==") {
        t3 = this.this_2;
        if (t3.checkReceiver$1(t1)) {
          t4 = t1.inputs;
          if (1 >= t4.length)
            return H.ioore(t4, 1);
          t3.addAllUsersBut$2(t1, t4[1]);
        }
        if (!(t2 && selector.argumentCount === 0) && t3.checkArgument$1(t1)) {
          t2 = t1.inputs;
          if (2 >= t2.length)
            return H.ioore(t2, 2);
          t3.addAllUsersBut$2(t1, t2[2]);
        }
      }
    },
    $isFunction: true
  },
  ValueRangeInfo: {
    "^": "Object;constantSystem,intZero,intOne"
  },
  Value: {
    "^": "Object;info<",
    $add: function(_, other) {
      return C.UnknownValue_null;
    },
    $sub: function(_, other) {
      return C.UnknownValue_null;
    },
    $negate: function(_) {
      return C.UnknownValue_null;
    },
    $and: function(_, other) {
      return C.UnknownValue_null;
    },
    min$1: function(_, other) {
      var t1, value;
      if (this.$eq(0, other))
        return this;
      t1 = J.getInterceptor(other);
      if (t1.$eq(other, C.MinIntValue_null))
        return other;
      if (t1.$eq(other, C.MaxIntValue_null))
        return this;
      value = this.$sub(0, other);
      if (value.get$isPositive())
        return other;
      if (value.get$isNegative(value))
        return this;
      return C.UnknownValue_null;
    },
    max$1: function(_, other) {
      var t1, value;
      if (this.$eq(0, other))
        return this;
      t1 = J.getInterceptor(other);
      if (t1.$eq(other, C.MinIntValue_null))
        return this;
      if (t1.$eq(other, C.MaxIntValue_null))
        return other;
      value = this.$sub(0, other);
      if (value.get$isPositive())
        return this;
      if (value.get$isNegative(value))
        return other;
      return C.UnknownValue_null;
    },
    get$isNegative: function(_) {
      return false;
    },
    get$isPositive: function() {
      return false;
    },
    get$isZero: function() {
      return false;
    }
  },
  MarkerValue: {
    "^": "Value;positive,info",
    $add: function(_, other) {
      if (other.get$isPositive() && this.positive)
        return C.MaxIntValue_null;
      if (other.get$isNegative(other) && !this.positive)
        return C.MinIntValue_null;
      if (!!other.$isIntValue)
        return this;
      return C.UnknownValue_null;
    },
    $sub: function(_, other) {
      if (other.get$isPositive() && !this.positive)
        return C.MinIntValue_null;
      if (other.get$isNegative(other) && this.positive)
        return C.MaxIntValue_null;
      if (!!other.$isIntValue)
        return this;
      return C.UnknownValue_null;
    },
    $isMarkerValue: true
  },
  IntValue: {
    "^": "Value;value>,info",
    $add: function(_, other) {
      var t1, constantSystem, constant, t2;
      if (other.get$isZero())
        return this;
      if (!other.$isIntValue)
        return other.$add(0, this);
      t1 = this.info;
      constantSystem = t1.constantSystem;
      constant = constantSystem.get$add(constantSystem).fold$2(0, constantSystem.createInt$1(this.value), constantSystem.createInt$1(other.value));
      if (!constant.get$isInt())
        return C.UnknownValue_null;
      t2 = constant.get$value(constant);
      t1.toString;
      return new B.IntValue(t2, t1);
    },
    $sub: function(_, other) {
      var t1, constantSystem, constant, t2;
      if (other.get$isZero())
        return this;
      if (!other.$isIntValue)
        return other.$negate(0).$add(0, this);
      t1 = this.info;
      constantSystem = t1.constantSystem;
      constant = constantSystem.get$subtract().fold$2(0, constantSystem.createInt$1(this.value), constantSystem.createInt$1(other.value));
      if (!constant.get$isInt())
        return C.UnknownValue_null;
      t2 = constant.get$value(constant);
      t1.toString;
      return new B.IntValue(t2, t1);
    },
    $negate: function(_) {
      var t1, t2, constantSystem, constant;
      t1 = this.value;
      if (t1 === 0)
        return this;
      t2 = this.info;
      constantSystem = t2.constantSystem;
      constant = constantSystem.get$negate().fold$1(0, constantSystem.createInt$1(t1));
      if (!constant.get$isInt())
        return C.UnknownValue_null;
      t1 = constant.get$value(constant);
      t2.toString;
      return new B.IntValue(t1, t2);
    },
    $and: function(_, other) {
      var t1, constantSystem, t2;
      if (!J.getInterceptor(other).$isIntValue)
        return C.UnknownValue_null;
      t1 = this.info;
      constantSystem = t1.constantSystem;
      t2 = constantSystem.get$bitAnd().fold$2(0, constantSystem.createInt$1(this.value), constantSystem.createInt$1(other.value)).value;
      t1.toString;
      return new B.IntValue(t2, t1);
    },
    min$1: function(_, other) {
      var t1, t2;
      t1 = J.getInterceptor(other);
      if (!t1.$isIntValue)
        return t1.min$1(other, this);
      t1 = this.value;
      t2 = other.value;
      if (typeof t1 !== "number")
        return t1.$lt();
      if (typeof t2 !== "number")
        return H.iae(t2);
      return t1 < t2 ? this : other;
    },
    max$1: function(_, other) {
      var t1, t2;
      t1 = J.getInterceptor(other);
      if (!t1.$isIntValue)
        return t1.max$1(other, this);
      t1 = this.value;
      t2 = other.value;
      if (typeof t1 !== "number")
        return t1.$lt();
      if (typeof t2 !== "number")
        return H.iae(t2);
      return t1 < t2 ? other : this;
    },
    $eq: function(_, other) {
      var t1, t2;
      if (other == null)
        return false;
      if (!J.getInterceptor(other).$isIntValue)
        return false;
      t1 = this.value;
      t2 = other.value;
      return t1 == null ? t2 == null : t1 === t2;
    },
    get$hashCode: function(_) {
      return H.throwExpression(P.UnsupportedError$("IntValue.hashCode"));
    },
    toString$0: function(_) {
      return "IntValue " + H.S(this.value);
    },
    get$isNegative: function(_) {
      var t1 = this.value;
      if (typeof t1 !== "number")
        return t1.$lt();
      return t1 < 0;
    },
    get$isPositive: function() {
      var t1 = this.value;
      if (typeof t1 !== "number")
        return t1.$ge();
      return t1 >= 0;
    },
    get$isZero: function() {
      return this.value === 0;
    },
    $isIntValue: true
  },
  MaxIntValue: {
    "^": "Value;info",
    $add: function(_, other) {
      return this;
    },
    $sub: function(_, other) {
      return this;
    },
    $negate: function(_) {
      return C.MinIntValue_null;
    },
    min$1: function(_, other) {
      return other;
    },
    max$1: function(_, other) {
      return this;
    },
    toString$0: function(_) {
      return "Max";
    },
    get$isNegative: function(_) {
      return false;
    },
    get$isPositive: function() {
      return true;
    }
  },
  MinIntValue: {
    "^": "Value;info",
    $add: function(_, other) {
      return this;
    },
    $sub: function(_, other) {
      return this;
    },
    $negate: function(_) {
      return C.MaxIntValue_null;
    },
    min$1: function(_, other) {
      return this;
    },
    max$1: function(_, other) {
      return other;
    },
    toString$0: function(_) {
      return "Min";
    },
    get$isNegative: function(_) {
      return true;
    },
    get$isPositive: function() {
      return false;
    }
  },
  UnknownValue: {
    "^": "Value;info",
    $add: function(_, other) {
      return C.UnknownValue_null;
    },
    $sub: function(_, other) {
      return C.UnknownValue_null;
    },
    $negate: function(_) {
      return C.UnknownValue_null;
    },
    min$1: function(_, other) {
      return C.UnknownValue_null;
    },
    max$1: function(_, other) {
      return C.UnknownValue_null;
    },
    get$isNegative: function(_) {
      return false;
    },
    get$isPositive: function() {
      return false;
    },
    toString$0: function(_) {
      return "Unknown";
    }
  },
  InstructionValue: {
    "^": "Value;instruction,info",
    $eq: function(_, other) {
      if (other == null)
        return false;
      if (!J.getInterceptor(other).$isInstructionValue)
        return false;
      return this.instruction === other.instruction;
    },
    get$hashCode: function(_) {
      return H.throwExpression(P.UnsupportedError$("InstructionValue.hashCode"));
    },
    $add: function(_, other) {
      var t1, t2;
      if (other.get$isZero())
        return this;
      if (!!other.$isIntValue) {
        t1 = other.value;
        if (typeof t1 !== "number")
          return t1.$lt();
        if (t1 < 0) {
          t1 = this.info;
          t2 = other.$negate(0);
          t1.toString;
          return new B.SubtractValue(this, t2, t1);
        }
        t1 = this.info;
        t1.toString;
        return new B.AddValue(this, other, t1);
      }
      if (!!other.$isInstructionValue) {
        t1 = this.info;
        t1.toString;
        return new B.AddValue(this, other, t1);
      }
      return other.$add(0, this);
    },
    $sub: function(_, other) {
      var t1, t2;
      if (other.get$isZero())
        return this;
      if (this.$eq(0, other))
        return this.info.intZero;
      if (!!other.$isIntValue) {
        t1 = other.value;
        if (typeof t1 !== "number")
          return t1.$lt();
        if (t1 < 0) {
          t1 = this.info;
          t2 = other.$negate(0);
          t1.toString;
          return new B.AddValue(this, t2, t1);
        }
        t1 = this.info;
        t1.toString;
        return new B.SubtractValue(this, other, t1);
      }
      if (!!other.$isInstructionValue) {
        t1 = this.info;
        t1.toString;
        return new B.SubtractValue(this, other, t1);
      }
      return other.$negate(0).$add(0, this);
    },
    $negate: function(_) {
      var t1 = this.info;
      t1.toString;
      return new B.NegateValue(this, t1);
    },
    get$isNegative: function(_) {
      return false;
    },
    get$isPositive: function() {
      return false;
    },
    toString$0: function(_) {
      return "Instruction: " + this.instruction.toString$0(0);
    },
    $isInstructionValue: true
  },
  PositiveValue: {
    "^": "InstructionValue;instruction,info",
    get$isPositive: function() {
      return true;
    }
  },
  BinaryOperationValue: {
    "^": "Value;left>,right>",
    $isBinaryOperationValue: true
  },
  AddValue: {
    "^": "BinaryOperationValue;left,right,info",
    $eq: function(_, other) {
      var t1, t2;
      if (other == null)
        return false;
      if (!J.getInterceptor(other).$isAddValue)
        return false;
      t1 = this.left;
      t2 = other.left;
      if (!(t1.$eq(0, t2) && J.$eq(this.right, other.right)))
        t1 = t1.$eq(0, other.right) && J.$eq(this.right, t2);
      else
        t1 = true;
      return t1;
    },
    get$hashCode: function(_) {
      return H.throwExpression(P.UnsupportedError$("AddValue.hashCode"));
    },
    $negate: function(_) {
      return this.left.$negate(0).$sub(0, this.right);
    },
    $add: function(_, other) {
      var t1, value, t2;
      if (other.get$isZero())
        return this;
      t1 = this.left;
      value = t1.$add(0, other);
      t2 = J.getInterceptor(value);
      if (!t2.$eq(value, C.UnknownValue_null) && !t2.$isBinaryOperationValue)
        return t2.$add(value, this.right);
      value = this.right.$add(0, other);
      t2 = J.getInterceptor(value);
      if (!t2.$eq(value, C.UnknownValue_null) && !t2.$isBinaryOperationValue)
        return t1.$add(0, value);
      return C.UnknownValue_null;
    },
    $sub: function(_, other) {
      var t1, value, t2;
      if (other.get$isZero())
        return this;
      t1 = this.left;
      value = t1.$sub(0, other);
      t2 = J.getInterceptor(value);
      if (!t2.$eq(value, C.UnknownValue_null) && !t2.$isBinaryOperationValue)
        return t2.$add(value, this.right);
      value = this.right.$sub(0, other);
      t2 = J.getInterceptor(value);
      if (!t2.$eq(value, C.UnknownValue_null) && !t2.$isBinaryOperationValue)
        return t1.$add(0, value);
      return C.UnknownValue_null;
    },
    get$isNegative: function(_) {
      var t1 = this.left;
      if (t1.get$isNegative(t1)) {
        t1 = this.right;
        t1 = t1.get$isNegative(t1);
      } else
        t1 = false;
      return t1;
    },
    get$isPositive: function() {
      return this.left.get$isPositive() && this.right.get$isPositive();
    },
    toString$0: function(_) {
      return this.left.toString$0(0) + " + " + J.toString$0(this.right);
    },
    $isAddValue: true
  },
  SubtractValue: {
    "^": "BinaryOperationValue;left,right,info",
    $eq: function(_, other) {
      if (other == null)
        return false;
      if (!J.getInterceptor(other).$isSubtractValue)
        return false;
      return this.left.$eq(0, other.left) && J.$eq(this.right, other.right);
    },
    get$hashCode: function(_) {
      return H.throwExpression(P.UnsupportedError$("SubtractValue.hashCode"));
    },
    $negate: function(_) {
      return this.right.$sub(0, this.left);
    },
    $add: function(_, other) {
      var t1, value, t2;
      if (other.get$isZero())
        return this;
      t1 = this.left;
      value = t1.$add(0, other);
      t2 = J.getInterceptor(value);
      if (!t2.$eq(value, C.UnknownValue_null) && !t2.$isBinaryOperationValue)
        return t2.$sub(value, this.right);
      value = other.$sub(0, this.right);
      t2 = J.getInterceptor(value);
      if (!t2.$eq(value, C.UnknownValue_null) && !t2.$isBinaryOperationValue)
        return t1.$add(0, value);
      return C.UnknownValue_null;
    },
    $sub: function(_, other) {
      var t1, value, t2;
      if (other.get$isZero())
        return this;
      t1 = this.left;
      value = t1.$sub(0, other);
      t2 = J.getInterceptor(value);
      if (!t2.$eq(value, C.UnknownValue_null) && !t2.$isBinaryOperationValue)
        return t2.$sub(value, this.right);
      value = this.right.$add(0, other);
      t2 = J.getInterceptor(value);
      if (!t2.$eq(value, C.UnknownValue_null) && !t2.$isBinaryOperationValue)
        return t1.$sub(0, value);
      return C.UnknownValue_null;
    },
    get$isNegative: function(_) {
      var t1 = this.left;
      return t1.get$isNegative(t1) && this.right.get$isPositive();
    },
    get$isPositive: function() {
      if (this.left.get$isPositive()) {
        var t1 = this.right;
        t1 = t1.get$isNegative(t1);
      } else
        t1 = false;
      return t1;
    },
    toString$0: function(_) {
      return this.left.toString$0(0) + " - " + J.toString$0(this.right);
    },
    $isSubtractValue: true
  },
  NegateValue: {
    "^": "Value;value>,info",
    $eq: function(_, other) {
      if (other == null)
        return false;
      if (!J.getInterceptor(other).$isNegateValue)
        return false;
      return J.$eq(this.value, other.value);
    },
    get$hashCode: function(_) {
      return H.throwExpression(P.UnsupportedError$("Negate.hashCode"));
    },
    $add: function(_, other) {
      var t1, t2;
      if (other.get$isZero())
        return this;
      t1 = this.value;
      if (other.$eq(0, t1))
        return this.info.intZero;
      if (!!other.$isNegateValue)
        return this.$sub(0, other.value);
      if (!!other.$isIntValue) {
        t2 = other.value;
        if (typeof t2 !== "number")
          return t2.$lt();
        if (t2 < 0) {
          t1 = this.info;
          t2 = other.$negate(0);
          t1.toString;
          return new B.SubtractValue(this, t2, t1);
        }
        t2 = this.info;
        t2.toString;
        return new B.SubtractValue(other, t1, t2);
      }
      if (!!other.$isInstructionValue) {
        t2 = this.info;
        t2.toString;
        return new B.SubtractValue(other, t1, t2);
      }
      return other.$sub(0, t1);
    },
    $and: function(_, other) {
      return C.UnknownValue_null;
    },
    $sub: function(_, other) {
      var t1, t2;
      if (other.get$isZero())
        return this;
      if (!!other.$isIntValue) {
        t1 = other.value;
        if (typeof t1 !== "number")
          return t1.$lt();
        if (t1 < 0) {
          t1 = this.info;
          t2 = other.$negate(0);
          t1.toString;
          return new B.SubtractValue(t2, this.value, t1);
        }
        t1 = this.info;
        t1.toString;
        return new B.SubtractValue(this, other, t1);
      }
      if (!!other.$isInstructionValue) {
        t1 = this.info;
        t1.toString;
        return new B.SubtractValue(this, other, t1);
      }
      if (!!other.$isNegateValue)
        return this.$add(0, other.value);
      return other.$negate(0).$sub(0, this.value);
    },
    $negate: function(_) {
      return this.value;
    },
    get$isNegative: function(_) {
      return this.value.get$isPositive();
    },
    get$isPositive: function() {
      var t1 = this.value;
      return t1.get$isNegative(t1);
    },
    toString$0: function(_) {
      return "-" + J.toString$0(this.value);
    },
    $isNegateValue: true
  },
  Range: {
    "^": "Object;lower<,upper<,info<",
    union$1: function(other) {
      return B.Range$normalize(this.lower.min$1(0, other.get$lower()), this.upper.max$1(0, other.upper), this.info);
    },
    intersection$1: function(_, other) {
      var low, low0, low1, up, up0, up1;
      low = this.lower;
      low0 = other.lower;
      low1 = low.max$1(0, low0);
      up = this.upper;
      up0 = other.upper;
      up1 = up.min$1(0, up0);
      if (J.$eq(low1, C.UnknownValue_null)) {
        if (!!low.$isIntValue)
          ;
        else if (!!J.getInterceptor(low0).$isIntValue)
          low = low0;
      } else
        low = low1;
      if (J.$eq(up1, C.UnknownValue_null)) {
        if (!!up.$isIntValue)
          ;
        else if (!!J.getInterceptor(up0).$isIntValue)
          up = up0;
      } else
        up = up1;
      return B.Range$normalize(low, up, this.info);
    },
    $add: function(_, other) {
      return B.Range$normalize(this.lower.$add(0, other.get$lower()), this.upper.$add(0, other.upper), this.info);
    },
    $sub: function(_, other) {
      return B.Range$normalize(this.lower.$sub(0, other.get$upper()), this.upper.$sub(0, other.lower), this.info);
    },
    $negate: function(_) {
      return B.Range$normalize(this.upper.$negate(0), this.lower.$negate(0), this.info);
    },
    $and: function(_, other) {
      var t1, up, t2, up0;
      t1 = this.lower;
      up = this.upper;
      t2 = J.getInterceptor(t1);
      if (t2.$eq(t1, up) && J.$eq(other.get$lower(), other.upper) && !!t2.$isIntValue && !!J.getInterceptor(other.lower).$isIntValue)
        return B.Range$normalize(t2.$and(t1, other.get$lower()), up.$and(0, other.upper), this.info);
      if (t1.get$isPositive() && other.get$lower().get$isPositive()) {
        up0 = up.min$1(0, other.get$upper());
        if (J.$eq(up0, C.UnknownValue_null)) {
          up0 = !!up.$isIntValue ? up : other.upper;
          up = !J.getInterceptor(up0).$isIntValue && !up.$eq(0, other.upper) ? C.MaxIntValue_null : up0;
        } else
          up = up0;
        t1 = this.info;
        return B.Range$normalize(t1.intZero, up, t1);
      } else if (t1.get$isPositive()) {
        t1 = this.info;
        return B.Range$normalize(t1.intZero, up, t1);
      } else {
        t1 = this.info;
        if (other.get$lower().get$isPositive())
          return B.Range$normalize(t1.intZero, other.upper, t1);
        else
          return new B.Range(C.MinIntValue_null, C.MaxIntValue_null, t1);
      }
    },
    $eq: function(_, other) {
      if (other == null)
        return false;
      if (!J.getInterceptor(other).$isRange)
        return false;
      return J.$eq(other.lower, this.lower) && J.$eq(other.upper, this.upper);
    },
    get$hashCode: function(_) {
      return H.throwExpression(P.UnsupportedError$("Range.hashCode"));
    },
    $lt: function(_, other) {
      var t1, t2, t3;
      t1 = this.upper;
      t2 = other.lower;
      t3 = J.getInterceptor(t1);
      return !t3.$eq(t1, t2) && J.$eq(t3.min$1(t1, t2), t1);
    },
    $gt: function(_, other) {
      var t1, t2;
      t1 = this.lower;
      t2 = J.getInterceptor(t1);
      return !t2.$eq(t1, other.get$upper()) && J.$eq(t2.max$1(t1, other.upper), t1);
    },
    $le: function(_, other) {
      var t1 = this.upper;
      return J.$eq(t1.min$1(0, other.lower), t1);
    },
    $ge: function(_, other) {
      var t1 = this.lower;
      return J.$eq(t1.max$1(0, other.upper), t1);
    },
    get$isNegative: function(_) {
      var t1 = this.upper;
      return t1.get$isNegative(t1);
    },
    get$isPositive: function() {
      return this.lower.get$isPositive();
    },
    toString$0: function(_) {
      return "[" + J.toString$0(this.lower) + ", " + J.toString$0(this.upper) + "]";
    },
    $isRange: true,
    static: {Range$normalize: function(low, up, info) {
        var t1, t2;
        t1 = J.$eq(low, C.UnknownValue_null) ? C.MinIntValue_null : low;
        t2 = J.$eq(up, C.UnknownValue_null) ? C.MaxIntValue_null : up;
        return new B.Range(t1, t2, info);
      }}
  },
  SsaValueRangeAnalyzer: {
    "^": "HBaseVisitor;conversions,ranges<,compiler<,constantSystem,info<,work,graph,currentBlock",
    get$name: function(_) {
      return "SSA value range builder";
    },
    visitGraph$1: function(graph) {
      this.graph = graph;
      this.visitDominatorTree$1(graph);
      this.removeRangeConversion$0();
      this.compiler.backend.get$optimizer().ranges = this.ranges;
    },
    removeRangeConversion$0: function() {
      H.IterableMixinWorkaround_forEach(this.conversions, new B.SsaValueRangeAnalyzer_removeRangeConversion_closure());
    },
    visitBasicBlock$1: function(block) {
      var t1 = new B.SsaValueRangeAnalyzer_visitBasicBlock_visit(this);
      block.forEachPhi$1(t1);
      block.forEachInstruction$1(t1);
    },
    visitInstruction$1: function(instruction) {
      var t1, t2, value;
      t1 = this.compiler;
      if (instruction.isPositiveInteger$1(t1)) {
        t1 = this.info;
        return B.Range$normalize(t1.intZero, new B.PositiveValue(instruction, t1), t1);
      } else {
        t1 = instruction.instructionType.containsOnlyInt$1(t1) && !instruction.instructionType.get$isNullable();
        t2 = this.info;
        if (t1) {
          value = new B.InstructionValue(instruction, t2);
          return B.Range$normalize(value, value, t2);
        } else
          return new B.Range(C.MinIntValue_null, C.MaxIntValue_null, t2);
      }
    },
    visitPhi$1: function(phi) {
      var t1, t2, range, i, t3, t4, t5;
      t1 = this.compiler;
      if (!(phi.instructionType.containsOnlyInt$1(t1) && !phi.instructionType.get$isNullable()))
        return new B.Range(C.MinIntValue_null, C.MaxIntValue_null, this.info);
      t2 = phi.inputs;
      t2.toString;
      if (H.IterableMixinWorkaround_any(t2, new B.SsaValueRangeAnalyzer_visitPhi_closure(this)))
        return new B.Range(C.MinIntValue_null, C.MaxIntValue_null, this.info);
      if (phi.block.loopInformation != null) {
        t2 = this.info;
        range = new B.LoopUpdateRecognizer(t1, this.ranges, t2, null).run$1(phi);
        if (range == null)
          return new B.Range(C.MinIntValue_null, C.MaxIntValue_null, t2);
        return range;
      }
      t1 = this.ranges;
      if (0 >= t2.length)
        return H.ioore(t2, 0);
      range = t1.$index(0, t2[0]);
      for (i = 1; i < t2.length; ++i) {
        t3 = t1.$index(0, t2[i]);
        t4 = range.get$info();
        t5 = range.get$lower().min$1(0, t3.get$lower());
        t3 = range.upper.max$1(0, t3.upper);
        if (J.$eq(t5, C.UnknownValue_null))
          t5 = C.MinIntValue_null;
        if (J.$eq(t3, C.UnknownValue_null))
          t3 = C.MaxIntValue_null;
        range = new B.Range(t5, t3, t4);
      }
      return range;
    },
    visitConstant$1: function(hConstant) {
      var constant, constantNum, t1, value;
      if (!(hConstant.instructionType.containsOnlyInt$1(this.compiler) && !hConstant.instructionType.get$isNullable()))
        return new B.Range(C.MinIntValue_null, C.MaxIntValue_null, this.info);
      constant = hConstant.constant;
      constantNum = !!constant.$isDeferredConstant ? constant.referenced : constant;
      if (constantNum.get$isMinusZero())
        constantNum = K.IntConstant_IntConstant(0);
      t1 = this.info;
      value = new B.IntValue(constantNum.get$value(constantNum), t1);
      return B.Range$normalize(value, value, t1);
    },
    visitFieldGet$1: function(fieldGet) {
      var t1, t2;
      t1 = this.compiler;
      if (!(fieldGet.instructionType.containsOnlyInt$1(t1) && !fieldGet.instructionType.get$isNullable()))
        return new B.Range(C.MinIntValue_null, C.MaxIntValue_null, this.info);
      t2 = fieldGet.inputs;
      if (0 >= t2.length)
        return H.ioore(t2, 0);
      if (!t2[0].isIndexablePrimitive$1(t1))
        return this.visitInstruction$1(fieldGet);
      t1 = this.info;
      return B.Range$normalize(t1.intZero, new B.PositiveValue(fieldGet, t1), t1);
    },
    visitBoundsCheck$1: function(check) {
      var next, t1, t2, indexRange, lengthRange, t3, maxIndex, t4, t5, belowLength, low, newIndexRange;
      next = check.next;
      t1 = this.ranges;
      t2 = check.inputs;
      if (0 >= t2.length)
        return H.ioore(t2, 0);
      indexRange = t1.$index(0, t2[0]);
      if (1 >= t2.length)
        return H.ioore(t2, 1);
      lengthRange = t1.$index(0, t2[1]);
      if (indexRange == null)
        indexRange = new B.Range(C.MinIntValue_null, C.MaxIntValue_null, this.info);
      t3 = this.info;
      maxIndex = lengthRange.get$upper().$sub(0, t3.intOne);
      if (!(!J.$eq(maxIndex, C.MaxIntValue_null) && J.$eq(indexRange.get$upper().min$1(0, maxIndex), indexRange.upper))) {
        t4 = indexRange.get$upper();
        t5 = lengthRange.lower;
        if (!J.$eq(t4, t5)) {
          t4 = indexRange.upper;
          t4 = J.$eq(t4.min$1(0, t5), t4);
          belowLength = t4;
        } else
          belowLength = false;
      } else
        belowLength = true;
      if (indexRange.get$lower().get$isPositive() && belowLength) {
        t4 = check.block;
        if (0 >= t2.length)
          return H.ioore(t2, 0);
        t4.rewrite$2(check, t2[0]);
        check.block.remove$1(0, check);
      } else {
        t4 = indexRange.upper;
        if (t4.get$isNegative(t4) || lengthRange.$lt(0, indexRange)) {
          check.staticChecks = 0;
          return indexRange;
        } else if (indexRange.lower.get$isPositive())
          check.staticChecks = 2;
        else if (belowLength)
          check.staticChecks = 3;
      }
      t4 = indexRange.lower;
      if (t4.get$isPositive()) {
        low = lengthRange.lower.max$1(0, t4);
        if (!J.$eq(low, C.UnknownValue_null)) {
          if (1 >= t2.length)
            return H.ioore(t2, 1);
          t1.$indexSet(0, this.createRangeConversion$2(next, t2[1]), B.Range$normalize(low, lengthRange.upper, t3));
        }
      }
      newIndexRange = indexRange.intersection$1(0, B.Range$normalize(t3.intZero, maxIndex, t3));
      if (indexRange.$eq(0, newIndexRange))
        return indexRange;
      if (0 >= t2.length)
        return H.ioore(t2, 0);
      t1.$indexSet(0, this.createRangeConversion$2(next, t2[0]), newIndexRange);
      return newIndexRange;
    },
    visitRelational$1: function(relational) {
      var t1, right, left, t2, operation, t3, rightRange, leftRange;
      t1 = relational.inputs;
      if (1 >= t1.length)
        return H.ioore(t1, 1);
      right = t1[1];
      left = t1[0];
      t2 = this.compiler;
      if (!(left.get$instructionType().containsOnlyInt$1(t2) && !left.instructionType.get$isNullable()))
        return new B.Range(C.MinIntValue_null, C.MaxIntValue_null, this.info);
      if (!(right.get$instructionType().containsOnlyInt$1(t2) && !right.instructionType.get$isNullable()))
        return new B.Range(C.MinIntValue_null, C.MaxIntValue_null, this.info);
      operation = relational.operation$1(this.constantSystem);
      t3 = this.ranges;
      if (1 >= t1.length)
        return H.ioore(t1, 1);
      rightRange = t3.$index(0, t1[1]);
      if (0 >= t1.length)
        return H.ioore(t1, 0);
      leftRange = t3.$index(0, t1[0]);
      if (!!relational.$isHIdentity) {
        if (1 >= t1.length)
          return H.ioore(t1, 1);
        right = t3.$index(0, t1[1]);
        if (0 >= t1.length)
          return H.ioore(t1, 0);
        left = t3.$index(0, t1[0]);
        if (J.$eq(left.get$lower(), left.upper) && J.$eq(right.get$lower(), right.upper) && left.$eq(0, right)) {
          t1 = relational.block;
          t3 = this.graph;
          t3.toString;
          t1.rewrite$2(relational, t3.addConstant$2(t2.backend.get$constantSystem().createBool$1(true), t2));
          relational.block.remove$1(0, relational);
        }
      } else if (operation.apply$2(leftRange, rightRange) === true) {
        t1 = relational.block;
        t3 = this.graph;
        t3.toString;
        t1.rewrite$2(relational, t3.addConstant$2(t2.backend.get$constantSystem().createBool$1(true), t2));
        relational.block.remove$1(0, relational);
      } else if (B.SsaValueRangeAnalyzer_negateOperation(operation).apply$2(leftRange, rightRange)) {
        t1 = relational.block;
        t3 = this.graph;
        t3.toString;
        t1.rewrite$2(relational, t3.addConstant$2(t2.backend.get$constantSystem().createBool$1(false), t2));
        relational.block.remove$1(0, relational);
      }
      return new B.Range(C.MinIntValue_null, C.MaxIntValue_null, this.info);
    },
    handleInvokeModulo$1: function(invoke) {
      var t1, t2, left, right, divisor;
      t1 = invoke.inputs;
      t2 = t1.length;
      if (1 >= t2)
        return H.ioore(t1, 1);
      left = t1[1];
      if (2 >= t2)
        return H.ioore(t1, 2);
      right = t1[2];
      divisor = this.ranges.$index(0, right);
      if (divisor != null) {
        t1 = this.compiler;
        if (left.get$instructionType().containsOnlyInt$1(t1) && !left.instructionType.get$isNullable() && right.get$instructionType().containsOnlyInt$1(t1) && !right.instructionType.get$isNullable())
          if (divisor.get$lower().get$isPositive()) {
            t1 = this.info;
            return B.Range$normalize(t1.intZero, divisor.upper.$sub(0, t1.intOne), t1);
          } else {
            t1 = divisor.upper;
            if (t1.get$isNegative(t1)) {
              t1 = this.info;
              return B.Range$normalize(t1.intZero, new B.NegateValue(divisor.lower, t1).$sub(0, t1.intOne), t1);
            }
          }
        else if (left.instructionType.containsOnlyNum$1(t1) && !left.instructionType.get$isNullable() && right.get$instructionType().containsOnlyNum$1(t1) && !right.instructionType.get$isNullable())
          if (divisor.get$lower().get$isPositive()) {
            t1 = this.info;
            return B.Range$normalize(t1.intZero, divisor.upper, t1);
          } else {
            t1 = divisor.upper;
            if (t1.get$isNegative(t1)) {
              t1 = this.info;
              return B.Range$normalize(t1.intZero, new B.NegateValue(divisor.lower, t1), t1);
            }
          }
      }
      return new B.Range(C.MinIntValue_null, C.MaxIntValue_null, this.info);
    },
    visitInvokeDynamicMethod$1: function(invoke) {
      if (invoke.inputs.length === 3 && invoke.selector.name === "%")
        return this.handleInvokeModulo$1(invoke);
      return B.HBaseVisitor.prototype.visitInvokeDynamicMethod$1.call(this, invoke);
    },
    handleBinaryOperation$1: function(instruction) {
      var t1, t2, t3, t4;
      if (!(instruction.instructionType.containsOnlyInt$1(this.compiler) && !instruction.instructionType.get$isNullable()))
        return new B.Range(C.MinIntValue_null, C.MaxIntValue_null, this.info);
      t1 = instruction.operation$1(this.constantSystem);
      t2 = this.ranges;
      t3 = instruction.inputs;
      if (0 >= t3.length)
        return H.ioore(t3, 0);
      t4 = t2.$index(0, t3[0]);
      if (1 >= t3.length)
        return H.ioore(t3, 1);
      return t1.apply$2(t4, t2.$index(0, t3[1]));
    },
    visitAdd$1: function(add) {
      return this.handleBinaryOperation$1(add);
    },
    visitSubtract$1: function(sub) {
      return this.handleBinaryOperation$1(sub);
    },
    visitBitAnd$1: function(node) {
      var t1, t2, right, left;
      t1 = this.compiler;
      if (!(node.instructionType.containsOnlyInt$1(t1) && !node.instructionType.get$isNullable()))
        return new B.Range(C.MinIntValue_null, C.MaxIntValue_null, this.info);
      t2 = node.inputs;
      if (1 >= t2.length)
        return H.ioore(t2, 1);
      right = t2[1];
      left = t2[0];
      if (left.get$instructionType().containsOnlyInt$1(t1) && !left.instructionType.get$isNullable() && right.get$instructionType().containsOnlyInt$1(t1) && !right.instructionType.get$isNullable()) {
        t1 = this.ranges;
        return J.$and$n(t1.$index(0, left), t1.$index(0, right));
      }
      t2 = new B.SsaValueRangeAnalyzer_visitBitAnd_tryComputeRange(this);
      if (left.instructionType.containsOnlyInt$1(t1) && !left.instructionType.get$isNullable())
        return t2.call$1(left);
      else if (right.get$instructionType().containsOnlyInt$1(t1) && !right.instructionType.get$isNullable())
        return t2.call$1(right);
      return new B.Range(C.MinIntValue_null, C.MaxIntValue_null, this.info);
    },
    visitCheck$1: function(instruction) {
      var t1, t2;
      t1 = this.ranges;
      t2 = instruction.inputs;
      if (0 >= t2.length)
        return H.ioore(t2, 0);
      if (t1.$index(0, t2[0]) == null)
        return this.visitInstruction$1(instruction);
      if (0 >= t2.length)
        return H.ioore(t2, 0);
      return t1.$index(0, t2[0]);
    },
    createRangeConversion$2: function(cursor, instruction) {
      var t1, t2, t3, newInstruction;
      t1 = this.compiler.backend.compiler.typesTask.get$intType();
      t2 = H.setRuntimeTypeInfo([instruction], [B.HInstruction]);
      t3 = $.HInstruction_idCounter;
      if (typeof t3 !== "number")
        return t3.$add();
      $.HInstruction_idCounter = t3 + 1;
      newInstruction = new B.HRangeConversion(null, null, t3, t2, H.setRuntimeTypeInfo([], [B.HInstruction]), null, null, null, new Z.SideEffects(0), false, t1);
      newInstruction.HInstruction$2(t2, t1);
      newInstruction._useGvn = true;
      newInstruction.sourceElement = instruction.get$sourceElement();
      this.conversions.push(newInstruction);
      cursor.block.addBefore$2(cursor, newInstruction);
      instruction.replaceAllUsersDominatedBy$2(cursor, newInstruction);
      return newInstruction;
    },
    computeConstrainedRange$3: function(operation, leftRange, rightRange) {
      var t1, range;
      if (operation === C.LessOperation_gSJ) {
        t1 = this.info;
        range = B.Range$normalize(C.MinIntValue_null, rightRange.upper.$sub(0, t1.intOne), t1);
      } else if (operation === C.LessEqualOperation_gZb)
        range = B.Range$normalize(C.MinIntValue_null, rightRange.upper, this.info);
      else if (operation === C.GreaterOperation_JMh) {
        t1 = this.info;
        range = B.Range$normalize(rightRange.lower.$add(0, t1.intOne), C.MaxIntValue_null, t1);
      } else {
        t1 = this.info;
        range = operation === C.GreaterEqualOperation_Kld ? B.Range$normalize(rightRange.lower, C.MaxIntValue_null, t1) : new B.Range(C.MinIntValue_null, C.MaxIntValue_null, t1);
      }
      return range.intersection$1(0, leftRange);
    },
    visitConditionalBranch$1: function(branch) {
      var t1, condition, right, left, rightRange, leftRange, operation, mirrorOp, t2, range, reverse, reversedMirror;
      t1 = branch.inputs;
      if (0 >= t1.length)
        return H.ioore(t1, 0);
      condition = t1[0];
      t1 = J.getInterceptor(condition);
      if (!t1.$isHRelational)
        return new B.Range(C.MinIntValue_null, C.MaxIntValue_null, this.info);
      if (!!t1.$isHIdentity)
        return new B.Range(C.MinIntValue_null, C.MaxIntValue_null, this.info);
      t1 = condition.inputs;
      if (1 >= t1.length)
        return H.ioore(t1, 1);
      right = t1[1];
      left = t1[0];
      t1 = this.compiler;
      if (!(left.get$instructionType().containsOnlyInt$1(t1) && !left.instructionType.get$isNullable()))
        return new B.Range(C.MinIntValue_null, C.MaxIntValue_null, this.info);
      if (!(right.get$instructionType().containsOnlyInt$1(t1) && !right.instructionType.get$isNullable()))
        return new B.Range(C.MinIntValue_null, C.MaxIntValue_null, this.info);
      t1 = this.ranges;
      rightRange = t1.$index(0, right);
      leftRange = t1.$index(0, left);
      operation = condition.operation$1(this.constantSystem);
      mirrorOp = B.SsaValueRangeAnalyzer_flipOperation(operation);
      t2 = branch.block.successors;
      if (0 >= t2.length)
        return H.ioore(t2, 0);
      if (t2[0].get$predecessors().length === 1) {
        range = this.computeConstrainedRange$3(operation, leftRange, rightRange);
        if (!J.$eq(leftRange, range)) {
          t2 = branch.block.successors;
          if (0 >= t2.length)
            return H.ioore(t2, 0);
          t1.$indexSet(0, this.createRangeConversion$2(J.get$first$ax(t2[0]), left), range);
        }
        range = this.computeConstrainedRange$3(mirrorOp, rightRange, leftRange);
        if (!J.$eq(rightRange, range)) {
          t2 = branch.block.successors;
          if (0 >= t2.length)
            return H.ioore(t2, 0);
          t1.$indexSet(0, this.createRangeConversion$2(J.get$first$ax(t2[0]), right), range);
        }
      }
      t2 = branch.block.successors;
      if (1 >= t2.length)
        return H.ioore(t2, 1);
      if (t2[1].get$predecessors().length === 1) {
        reverse = B.SsaValueRangeAnalyzer_negateOperation(operation);
        reversedMirror = B.SsaValueRangeAnalyzer_flipOperation(reverse);
        range = this.computeConstrainedRange$3(reverse, leftRange, rightRange);
        if (!J.$eq(leftRange, range)) {
          t2 = branch.block.successors;
          if (1 >= t2.length)
            return H.ioore(t2, 1);
          t1.$indexSet(0, this.createRangeConversion$2(J.get$first$ax(t2[1]), left), range);
        }
        range = this.computeConstrainedRange$3(reversedMirror, rightRange, leftRange);
        if (!J.$eq(rightRange, range)) {
          t2 = branch.block.successors;
          if (1 >= t2.length)
            return H.ioore(t2, 1);
          t1.$indexSet(0, this.createRangeConversion$2(J.get$first$ax(t2[1]), right), range);
        }
      }
      return new B.Range(C.MinIntValue_null, C.MaxIntValue_null, this.info);
    },
    visitRangeConversion$1: function(conversion) {
      return this.ranges.$index(0, conversion);
    },
    static: {SsaValueRangeAnalyzer_negateOperation: function(operation) {
        if (operation === C.LessOperation_gSJ)
          return C.GreaterEqualOperation_Kld;
        else if (operation === C.LessEqualOperation_gZb)
          return C.GreaterOperation_JMh;
        else if (operation === C.GreaterOperation_JMh)
          return C.LessEqualOperation_gZb;
        else if (operation === C.GreaterEqualOperation_Kld)
          return C.LessOperation_gSJ;
        else
          return;
      }, SsaValueRangeAnalyzer_flipOperation: function(operation) {
        if (operation === C.LessOperation_gSJ)
          return C.GreaterOperation_JMh;
        else if (operation === C.LessEqualOperation_gZb)
          return C.GreaterEqualOperation_Kld;
        else if (operation === C.GreaterOperation_JMh)
          return C.LessOperation_gSJ;
        else if (operation === C.GreaterEqualOperation_Kld)
          return C.LessEqualOperation_gZb;
        else
          return;
      }}
  },
  SsaValueRangeAnalyzer_removeRangeConversion_closure: {
    "^": "Closure:291;",
    call$1: function(instruction) {
      var t1, t2;
      t1 = instruction.get$block();
      t2 = instruction.get$inputs();
      if (0 >= t2.length)
        return H.ioore(t2, 0);
      t1.rewrite$2(instruction, t2[0]);
      instruction.get$block().remove$1(0, instruction);
    },
    $isFunction: true
  },
  SsaValueRangeAnalyzer_visitBasicBlock_visit: {
    "^": "Closure:292;this_0",
    call$1: function(instruction) {
      var t1, range;
      t1 = this.this_0;
      range = instruction.accept$1(0, t1);
      if (instruction.instructionType.containsOnlyInt$1(t1.compiler) && !instruction.instructionType.get$isNullable())
        t1.ranges.$indexSet(0, instruction, range);
    },
    $isFunction: true
  },
  SsaValueRangeAnalyzer_visitPhi_closure: {
    "^": "Closure:13;this_0",
    call$1: function(i) {
      return !i.isInteger$1(this.this_0.compiler);
    },
    $isFunction: true
  },
  SsaValueRangeAnalyzer_visitBitAnd_tryComputeRange: {
    "^": "Closure:293;this_0",
    call$1: function(instruction) {
      var t1, range, t2;
      t1 = this.this_0;
      range = t1.ranges.$index(0, instruction);
      if (range.get$lower().get$isPositive()) {
        t1 = t1.info;
        return B.Range$normalize(t1.intZero, range.upper, t1);
      } else {
        t2 = range.upper;
        if (t2.get$isNegative(t2)) {
          t1 = t1.info;
          return B.Range$normalize(range.lower, t1.intZero, t1);
        }
      }
      return new B.Range(C.MinIntValue_null, C.MaxIntValue_null, t1.info);
    },
    $isFunction: true
  },
  LoopUpdateRecognizer: {
    "^": "HBaseVisitor;compiler<,ranges<,info<,currentBlock",
    run$1: function(loopPhi) {
      var t1, t2, t3, updateRange, startRange, low;
      t1 = this.ranges;
      t2 = this.info;
      t1.$indexSet(0, loopPhi, new B.Range(new B.MarkerValue(false, t2), new B.MarkerValue(true, t2), t2));
      t3 = loopPhi.inputs;
      if (1 >= t3.length)
        return H.ioore(t3, 1);
      updateRange = this.visit$1(t3[1]);
      t1.$indexSet(0, loopPhi, null);
      if (updateRange == null)
        return;
      if (0 >= t3.length)
        return H.ioore(t3, 0);
      startRange = t1.$index(0, t3[0]);
      t1 = updateRange.lower;
      t3 = J.getInterceptor(t1);
      low = !!t3.$isMarkerValue ? startRange.get$lower() : t3.min$1(t1, startRange.get$lower());
      t1 = updateRange.upper;
      t3 = J.getInterceptor(t1);
      return B.Range$normalize(low, !!t3.$isMarkerValue ? startRange.get$upper() : t3.max$1(t1, startRange.get$upper()), t2);
    },
    visit$1: function(instruction) {
      var t1;
      if (!(instruction.get$instructionType().containsOnlyInt$1(this.compiler) && !instruction.instructionType.get$isNullable()))
        return;
      t1 = this.ranges;
      if (t1.$index(0, instruction) != null)
        return t1.$index(0, instruction);
      return instruction.accept$1(0, this);
    },
    visitPhi$1: function(phi) {
      var t1, phiRange, inputRange, t2, t3, t4;
      if (phi.block.loopInformation != null)
        return;
      for (t1 = phi.inputs, t1 = H.setRuntimeTypeInfo(new H.ListIterator(t1, t1.length, 0, null), [H.getTypeArgumentByIndex(t1, 0)]), phiRange = null; t1.moveNext$0();) {
        inputRange = this.visit$1(t1.__internal$_current);
        if (inputRange == null)
          return;
        if (phiRange == null)
          phiRange = inputRange;
        else {
          t2 = phiRange.info;
          t3 = phiRange.lower.min$1(0, inputRange.lower);
          t4 = phiRange.upper.max$1(0, inputRange.upper);
          if (J.$eq(t3, C.UnknownValue_null))
            t3 = C.MinIntValue_null;
          if (J.$eq(t4, C.UnknownValue_null))
            t4 = C.MaxIntValue_null;
          phiRange = new B.Range(t3, t4, t2);
        }
      }
      return phiRange;
    },
    visitCheck$1: function(instruction) {
      var t1 = instruction.inputs;
      if (0 >= t1.length)
        return H.ioore(t1, 0);
      return this.visit$1(t1[0]);
    },
    visitAdd$1: function(operation) {
      return this.handleBinaryOperation$1(operation);
    },
    visitSubtract$1: function(operation) {
      return this.handleBinaryOperation$1(operation);
    },
    handleBinaryOperation$1: function(instruction) {
      var t1, leftRange, rightRange;
      t1 = instruction.inputs;
      if (0 >= t1.length)
        return H.ioore(t1, 0);
      leftRange = this.visit$1(t1[0]);
      if (1 >= t1.length)
        return H.ioore(t1, 1);
      rightRange = this.visit$1(t1[1]);
      if (leftRange == null || rightRange == null)
        return;
      return instruction.operation$1(this.info.constantSystem).apply$2(leftRange, rightRange);
    }
  },
  ValueSet: {
    "^": "Object;size>,table,collisions",
    get$isEmpty: function(_) {
      return this.size === 0;
    },
    get$length: function(_) {
      return this.size;
    },
    add$1: function(_, instruction) {
      var hashCode, t1, capacity, oldCollisions, index;
      hashCode = instruction.gvnHashCode$0();
      t1 = this.table;
      capacity = t1.length;
      if (this.size >= capacity >>> 1) {
        capacity = capacity << 1 >>> 0;
        oldCollisions = this.collisions;
        this.size = 0;
        this.table = H.setRuntimeTypeInfo(Array(capacity), [B.HInstruction]);
        this.collisions = null;
        B.ValueSet_copyTo(this, t1, oldCollisions);
      }
      index = C.JSInt_methods.$mod(hashCode, capacity);
      t1 = this.table;
      if (index >= t1.length)
        return H.ioore(t1, index);
      if (t1[index] == null)
        t1[index] = instruction;
      else
        this.collisions = new B.ValueSetNode(instruction, hashCode, this.collisions);
      ++this.size;
    },
    lookup$1: function(instruction) {
      var hashCode, t1, probe, node, cached;
      hashCode = instruction.gvnHashCode$0();
      t1 = this.table;
      probe = t1[C.JSInt_methods.$mod(hashCode, t1.length)];
      if (probe != null && probe.gvnEquals$1(instruction))
        return probe;
      for (node = this.collisions; node != null; node = node.next)
        if (node.hash === hashCode) {
          cached = node.value;
          if (cached.gvnEquals$1(instruction))
            return cached;
        }
      return;
    },
    kill$1: function(flags) {
      var depends, t1, $length, index, instruction, current, previous, next;
      if (flags === 0)
        return;
      if (typeof flags !== "number")
        return flags.$shl();
      depends = flags << 3;
      for (t1 = this.table, $length = t1.length, index = 0; index < $length; ++index) {
        if (index >= t1.length)
          return H.ioore(t1, index);
        instruction = t1[index];
        if (instruction != null && (instruction.sideEffects.flags & depends) >>> 0 !== 0) {
          t1[index] = null;
          --this.size;
        }
      }
      current = this.collisions;
      for (previous = null; current != null; current = next) {
        next = current.next;
        if ((current.value.sideEffects.flags & depends) >>> 0 !== 0) {
          if (previous == null)
            this.collisions = next;
          else
            previous.next = next;
          --this.size;
        } else
          previous = current;
      }
    },
    toList$0: function(_) {
      return B.ValueSet_copyTo(H.setRuntimeTypeInfo([], [B.HInstruction]), this.table, this.collisions);
    },
    intersection$1: function(_, other) {
      var result, $length, index, t1, instruction, current, value;
      if (this.size > other.size)
        return other.intersection$1(0, this);
      result = new B.ValueSet(0, H.setRuntimeTypeInfo(Array(8), [B.HInstruction]), null);
      for ($length = this.table.length, index = 0; index < $length; ++index) {
        t1 = this.table;
        if (index >= t1.length)
          return H.ioore(t1, index);
        instruction = t1[index];
        if (instruction != null && other.lookup$1(instruction) != null)
          result.add$1(0, instruction);
      }
      current = this.collisions;
      for (; current != null;) {
        value = current.value;
        if (other.lookup$1(value) != null)
          result.add$1(0, value);
        current = current.next;
      }
      return result;
    },
    static: {ValueSet_copyTo: function(other, table, collisions) {
        var $length, t1, index, instruction, current;
        for ($length = table.length, t1 = J.getInterceptor$ax(other), index = 0; index < $length; ++index) {
          instruction = table[index];
          if (instruction != null)
            t1.add$1(other, instruction);
        }
        for (current = collisions; current != null;) {
          t1.add$1(other, current.value);
          current = current.next;
        }
        return other;
      }}
  },
  ValueSetNode: {
    "^": "Object;value>,hash,next<",
    get$hashCode: function(_) {
      return this.hash;
    }
  },
  LiveRange: {
    "^": "Object;start>,end@",
    toString$0: function(_) {
      return "[" + H.S(this.start) + " " + H.S(this.end) + "[";
    }
  },
  LiveInterval: {
    "^": "Object;start*,ranges<",
    loopUpdate$2: function(from, to) {
      var t1, range, t2;
      for (t1 = this.ranges, t1 = H.setRuntimeTypeInfo(new H.ListIterator(t1, t1.length, 0, null), [H.getTypeArgumentByIndex(t1, 0)]); t1.moveNext$0();) {
        range = t1.__internal$_current;
        t2 = J.get$start$x(range);
        if (typeof from !== "number")
          return from.$le();
        if (typeof t2 !== "number")
          return H.iae(t2);
        if (from <= t2) {
          t2 = range.get$end();
          if (typeof t2 !== "number")
            return t2.$lt();
          if (typeof to !== "number")
            return H.iae(to);
          t2 = t2 < to;
        } else
          t2 = false;
        if (t2)
          range.set$end(to);
      }
    },
    add$1: function(_, interval) {
      this.ranges.push(interval);
    },
    diesAt$1: function(at) {
      var t1, t2;
      for (t1 = this.ranges, t1 = H.setRuntimeTypeInfo(new H.ListIterator(t1, t1.length, 0, null), [H.getTypeArgumentByIndex(t1, 0)]); t1.moveNext$0();) {
        t2 = t1.__internal$_current.get$end();
        if (t2 == null ? at == null : t2 === at)
          return true;
      }
      return false;
    },
    toString$0: function(_) {
      var res, t1;
      res = H.setRuntimeTypeInfo([], [P.String]);
      for (t1 = this.ranges, t1 = H.setRuntimeTypeInfo(new H.ListIterator(t1, t1.length, 0, null), [H.getTypeArgumentByIndex(t1, 0)]); t1.moveNext$0();)
        res.push(J.toString$0(t1.__internal$_current));
      return "(" + C.JSArray_methods.join$1(res, ", ") + ")";
    }
  },
  LiveEnvironment: {
    "^": "Object;startId,endId,loopMarkers<,liveInstructions<,liveIntervals",
    remove$2: function(_, instruction, id) {
      var interval, t1, lastId, t2;
      interval = this.liveIntervals.putIfAbsent$2(instruction, new B.LiveEnvironment_remove_closure());
      t1 = this.liveInstructions;
      lastId = t1.$index(0, instruction);
      t2 = lastId == null ? id : lastId;
      interval.get$ranges().push(new B.LiveRange(id, t2));
      J.set$start$x(interval, id);
      t1.remove$1(0, instruction);
    },
    add$2: function(_, instruction, userId) {
      this.liveInstructions.putIfAbsent$2(instruction, new B.LiveEnvironment_add_closure(userId));
    },
    mergeWith$1: function(other) {
      other.liveInstructions.forEach$1(0, new B.LiveEnvironment_mergeWith_closure(this, other));
      other.loopMarkers.forEach$1(0, new B.LiveEnvironment_mergeWith_closure0(this));
    },
    get$isEmpty: function(_) {
      return this.liveInstructions._collection$_length === 0 && this.loopMarkers._collection$_length === 0;
    },
    contains$1: function(_, instruction) {
      return this.liveInstructions.containsKey$1(instruction);
    },
    toString$0: function(_) {
      return P.Maps_mapToString(this.liveInstructions);
    }
  },
  LiveEnvironment_remove_closure: {
    "^": "Closure:23;",
    call$0: function() {
      return new B.LiveInterval(null, H.setRuntimeTypeInfo([], [B.LiveRange]));
    },
    $isFunction: true
  },
  LiveEnvironment_add_closure: {
    "^": "Closure:23;userId_0",
    call$0: function() {
      return this.userId_0;
    },
    $isFunction: true
  },
  LiveEnvironment_mergeWith_closure: {
    "^": "Closure:294;this_0,other_1",
    call$2: function(instruction, existingId) {
      var t1, t2, range, t3;
      t1 = this.this_0;
      t2 = t1.endId;
      if (J.$eq(existingId, t2))
        return;
      range = t1.liveIntervals.putIfAbsent$2(instruction, new B.LiveEnvironment_mergeWith__closure());
      t3 = this.other_1.startId;
      range.get$ranges().push(new B.LiveRange(t3, existingId));
      t1.liveInstructions.$indexSet(0, instruction, t2);
    },
    $isFunction: true
  },
  LiveEnvironment_mergeWith__closure: {
    "^": "Closure:23;",
    call$0: function() {
      return new B.LiveInterval(null, H.setRuntimeTypeInfo([], [B.LiveRange]));
    },
    $isFunction: true
  },
  LiveEnvironment_mergeWith_closure0: {
    "^": "Closure:19;this_2",
    call$2: function(k, v) {
      this.this_2.loopMarkers.$indexSet(0, k, v);
    },
    $isFunction: true
  },
  SsaLiveIntervalBuilder: {
    "^": "HBaseVisitor;compiler<,generateAtUseSite,controlFlowOperators,instructionId,liveInstructions<,liveIntervals,currentBlock",
    visitGraph$1: function(graph) {
      this.visitPostDominatorTree$1(graph);
      if (J.get$isEmpty$asx(this.liveInstructions.$index(0, graph.entry)) !== true)
        this.compiler.internalError$2(C._SpannableSentinel_0, "LiveIntervalBuilder.");
    },
    markInputsAsLiveInEnvironment$2: function(instruction, environment) {
      var t1, len, i;
      for (t1 = instruction.inputs, len = t1.length, i = 0; i < len; ++i) {
        if (i >= t1.length)
          return H.ioore(t1, i);
        this.markAsLiveInEnvironment$2(t1[i], environment);
      }
    },
    checkedInstructionOrNonGenerateAtUseSite$1: function(check) {
      var t1, checked, t2, next;
      t1 = check.inputs;
      if (0 >= t1.length)
        return H.ioore(t1, 0);
      checked = t1[0];
      for (t1 = this.generateAtUseSite; !!J.getInterceptor(checked).$isHCheck; checked = next) {
        t2 = checked.get$inputs();
        if (0 >= t2.length)
          return H.ioore(t2, 0);
        next = t2[0];
        if (t1.contains$1(0, next))
          break;
      }
      return checked;
    },
    markAsLiveInEnvironment$2: function(instruction, environment) {
      var t1, checked;
      t1 = this.generateAtUseSite;
      if (t1.contains$1(0, instruction))
        this.markInputsAsLiveInEnvironment$2(instruction, environment);
      else {
        environment.add$2(0, instruction, this.instructionId);
        if (!!J.getInterceptor(instruction).$isHCheck) {
          checked = this.checkedInstructionOrNonGenerateAtUseSite$1(instruction);
          if (!t1.contains$1(0, checked))
            environment.add$2(0, checked, this.instructionId);
        }
      }
    },
    removeFromEnvironment$2: function(instruction, environment) {
      var checked, t1;
      environment.remove$2(0, instruction, this.instructionId);
      if (!!instruction.$isHCheck) {
        checked = this.checkedInstructionOrNonGenerateAtUseSite$1(instruction);
        if (!this.generateAtUseSite.contains$1(0, checked)) {
          t1 = this.liveIntervals;
          t1.putIfAbsent$2(checked, new B.SsaLiveIntervalBuilder_removeFromEnvironment_closure());
          t1.$indexSet(0, instruction, new B.LiveInterval(this.instructionId, t1.$index(0, checked).get$ranges()));
        }
      }
    },
    visitBasicBlock$1: function(block) {
      var t1, t2, t3, environment, ifInstruction, joinBlock, i, successor, successorEnv, index, phi, instruction;
      t1 = this.instructionId;
      t2 = P.LinkedHashMap_LinkedHashMap(null, null, null, B.HInstruction, P.$int);
      t3 = P.LinkedHashMap_LinkedHashMap(null, null, null, B.HBasicBlock, P.$int);
      environment = new B.LiveEnvironment(null, t1, t3, t2, this.liveIntervals);
      if (this.controlFlowOperators.contains$1(0, block.last)) {
        ifInstruction = block.last;
        joinBlock = ifInstruction.get$blockInformation().continuation;
        if (this.generateAtUseSite.contains$1(0, joinBlock.phis.first))
          this.markInputsAsLiveInEnvironment$2(ifInstruction, this.liveInstructions.$index(0, joinBlock));
      }
      for (t1 = this.liveInstructions, i = 0; t2 = block.successors, i < t2.length; ++i) {
        successor = t2[i];
        successorEnv = t1.$index(0, successor);
        if (successorEnv != null)
          environment.mergeWith$1(successorEnv);
        else
          t3.$indexSet(0, successor, this.instructionId);
        t2 = successor.get$predecessors();
        index = H.Lists_indexOf(t2, block, 0, t2.length);
        for (phi = successor.get$phis().first; phi != null; phi = phi.next) {
          t2 = phi.inputs;
          if (index < 0 || index >= t2.length)
            return H.ioore(t2, index);
          this.markAsLiveInEnvironment$2(t2[index], environment);
        }
      }
      instruction = block.last;
      for (t2 = this.generateAtUseSite; instruction != null;) {
        if (!t2.contains$1(0, instruction)) {
          this.removeFromEnvironment$2(instruction, environment);
          this.markInputsAsLiveInEnvironment$2(instruction, environment);
        }
        --this.instructionId;
        instruction = instruction.previous;
      }
      for (phi = block.phis.first; phi != null; phi = phi.next)
        if (!t2.contains$1(0, phi))
          environment.remove$2(0, phi, this.instructionId);
      environment.startId = this.instructionId + 1;
      t1.$indexSet(0, block, environment);
      if (block.loopInformation != null && block.predecessors.length > 1)
        this.updateLoopMarker$1(block);
    },
    updateLoopMarker$1: function(header) {
      var t1, env, lastId;
      t1 = this.liveInstructions;
      env = t1.$index(0, header);
      lastId = env.get$loopMarkers().$index(0, header);
      env.liveInstructions.forEach$1(0, new B.SsaLiveIntervalBuilder_updateLoopMarker_closure(env, lastId));
      env.loopMarkers.remove$1(0, header);
      t1.forEach$1(0, new B.SsaLiveIntervalBuilder_updateLoopMarker_closure0(header, env));
    }
  },
  SsaLiveIntervalBuilder_removeFromEnvironment_closure: {
    "^": "Closure:23;",
    call$0: function() {
      return new B.LiveInterval(null, H.setRuntimeTypeInfo([], [B.LiveRange]));
    },
    $isFunction: true
  },
  SsaLiveIntervalBuilder_updateLoopMarker_closure: {
    "^": "Closure:294;env_0,lastId_1",
    call$2: function(instruction, id) {
      var t1, t2;
      t1 = this.env_0;
      t2 = this.lastId_1;
      t1.liveIntervals.putIfAbsent$2(instruction, new B.SsaLiveIntervalBuilder_updateLoopMarker__closure1()).loopUpdate$2(t1.startId, t2);
      t1.liveInstructions.$indexSet(0, instruction, t2);
    },
    $isFunction: true
  },
  SsaLiveIntervalBuilder_updateLoopMarker__closure1: {
    "^": "Closure:23;",
    call$0: function() {
      return new B.LiveInterval(null, H.setRuntimeTypeInfo([], [B.LiveRange]));
    },
    $isFunction: true
  },
  SsaLiveIntervalBuilder_updateLoopMarker_closure0: {
    "^": "Closure:295;header_2,env_3",
    call$2: function(block, other) {
      var t1, t2;
      t1 = this.header_2;
      if (other.get$loopMarkers().containsKey$1(t1)) {
        t2 = this.env_3;
        t2.liveInstructions.forEach$1(0, new B.SsaLiveIntervalBuilder_updateLoopMarker__closure(other));
        other.loopMarkers.remove$1(0, t1);
        t2.loopMarkers.forEach$1(0, new B.SsaLiveIntervalBuilder_updateLoopMarker__closure0(other));
      }
    },
    $isFunction: true
  },
  SsaLiveIntervalBuilder_updateLoopMarker__closure: {
    "^": "Closure:294;other_4",
    call$2: function(instruction, id) {
      this.other_4.liveInstructions.$indexSet(0, instruction, id);
    },
    $isFunction: true
  },
  SsaLiveIntervalBuilder_updateLoopMarker__closure0: {
    "^": "Closure:19;other_5",
    call$2: function(k, v) {
      this.other_5.loopMarkers.$indexSet(0, k, v);
    },
    $isFunction: true
  },
  Copy: {
    "^": "Object;source>,destination<",
    toString$0: function(_) {
      return H.S(this.destination) + " <- " + H.S(this.source);
    }
  },
  CopyHandler: {
    "^": "Object;copies<,assignments<",
    toString$0: function(_) {
      return "Copies: " + H.S(this.copies) + ", assignments: " + H.S(this.assignments);
    },
    get$isEmpty: function(_) {
      return this.copies.length === 0 && this.assignments.length === 0;
    },
    static: {CopyHandler$: function() {
        return new B.CopyHandler(H.setRuntimeTypeInfo([], [B.Copy]), H.setRuntimeTypeInfo([], [B.Copy]));
      }}
  },
  VariableNames: {
    "^": "Object;ownName,copyHandlers,allUsedNames,swapTemp",
    addCopy$3: function(block, source, destination) {
      this.copyHandlers.putIfAbsent$2(block, new B.VariableNames_addCopy_closure()).get$copies().push(new B.Copy(source, destination));
    },
    addAssignment$3: function(block, source, destination) {
      this.copyHandlers.putIfAbsent$2(block, new B.VariableNames_addAssignment_closure()).get$assignments().push(new B.Copy(source, destination));
    }
  },
  VariableNames_addCopy_closure: {
    "^": "Closure:23;",
    call$0: function() {
      return B.CopyHandler$();
    },
    $isFunction: true
  },
  VariableNames_addAssignment_closure: {
    "^": "Closure:23;",
    call$0: function() {
      return B.CopyHandler$();
    },
    $isFunction: true
  },
  VariableNamer: {
    "^": "Object;names,compiler<,usedNames,freeTemporaryNames,temporaryIndex",
    allocateWithHint$1: function(originalName) {
      var backend, t1, $name, t2, i, i0;
      backend = this.compiler.backend;
      t1 = backend.get$namer();
      $name = t1._safeName$2(originalName, t1.get$jsVariableReserved());
      for (t1 = this.usedNames, t2 = backend.namer, i = 0; t1.contains$1(0, $name); i = i0) {
        i0 = i + 1;
        $name = H.S(originalName) + i;
        if (t2.get$jsVariableReserved().contains$1(0, $name) || C.JSString_methods.startsWith$1($name, "$"))
          $name = "$" + $name;
      }
      return $name;
    },
    allocateTemporary$0: function() {
      var t1, t2, t3, $name;
      for (t1 = this.freeTemporaryNames, t2 = this.usedNames; t3 = t1.length, t3 !== 0;) {
        if (0 >= t3)
          return H.ioore(t1, 0);
        $name = t1.pop();
        if (!t2.contains$1(0, $name))
          return $name;
      }
      $name = "t" + this.temporaryIndex++;
      for (; t2.contains$1(0, $name);)
        $name = "t" + this.temporaryIndex++;
      return $name;
    },
    firstPhiUserWithElement$1: function(instruction) {
      var t1, user;
      for (t1 = instruction.usedBy, t1 = H.setRuntimeTypeInfo(new H.ListIterator(t1, t1.length, 0, null), [H.getTypeArgumentByIndex(t1, 0)]); t1.moveNext$0();) {
        user = t1.__internal$_current;
        if (!!J.getInterceptor(user).$isHPhi && user.sourceElement != null)
          return user;
      }
      return;
    },
    allocateName$1: function(instruction) {
      var t1, temp, t2, $name, phi;
      if (!!instruction.$isHCheck) {
        t1 = this.names.ownName;
        temp = instruction;
        do {
          t2 = temp.get$inputs();
          if (0 >= t2.length)
            return H.ioore(t2, 0);
          temp = t2[0];
          $name = t1.$index(0, temp);
          t2 = $name == null;
        } while (t2 && !!J.getInterceptor(temp).$isHCheck);
        if (!t2)
          return this.addAllocatedName$2(instruction, $name);
      }
      if (instruction.get$sourceElement() != null) {
        t1 = instruction.get$sourceElement();
        $name = this.allocateWithHint$1(t1.get$name(t1));
      } else {
        phi = this.firstPhiUserWithElement$1(instruction);
        if (phi != null) {
          t1 = phi.sourceElement;
          $name = this.allocateWithHint$1(t1.get$name(t1));
        } else
          $name = this.allocateTemporary$0();
      }
      return this.addAllocatedName$2(instruction, $name);
    },
    addAllocatedName$2: function(instruction, $name) {
      var t1;
      this.usedNames.add$1(0, $name);
      t1 = this.names;
      t1.allUsedNames.add$1(0, $name);
      t1.ownName.$indexSet(0, instruction, $name);
      return $name;
    },
    VariableNamer$3: function(environment, names, compiler) {
      this.usedNames.add$1(0, this.names.swapTemp);
      environment.get$liveInstructions().forEach$1(0, new B.VariableNamer_closure(this));
    },
    static: {"^": "VariableNamer_regexp", VariableNamer$: function(environment, names, compiler) {
        var t1 = new B.VariableNamer(names, compiler, P.LinkedHashSet_LinkedHashSet(null, null, null, P.String), H.setRuntimeTypeInfo([], [P.String]), 0);
        t1.VariableNamer$3(environment, names, compiler);
        return t1;
      }}
  },
  VariableNamer_closure: {
    "^": "Closure:294;this_0",
    call$2: function(instruction, index) {
      var t1, t2, $name;
      t1 = this.this_0;
      t2 = t1.names;
      $name = t2.ownName.$index(0, instruction);
      if ($name != null) {
        t1.usedNames.add$1(0, $name);
        t2.allUsedNames.add$1(0, $name);
      }
    },
    $isFunction: true
  },
  SsaVariableAllocator: {
    "^": "HBaseVisitor;compiler<,liveInstructions<,liveIntervals,generateAtUseSite,names,currentBlock",
    visitGraph$1: function(graph) {
      this.visitDominatorTree$1(graph);
    },
    visitBasicBlock$1: function(block) {
      var namer = B.VariableNamer$(this.liveInstructions.$index(0, block), this.names, this.compiler);
      block.forEachPhi$1(new B.SsaVariableAllocator_visitBasicBlock_closure(this, namer));
      block.forEachInstruction$1(new B.SsaVariableAllocator_visitBasicBlock_closure0(this, namer));
    },
    needsName$1: function(instruction) {
      var t1 = J.getInterceptor(instruction);
      if (!!t1.$isHThis)
        return false;
      if (!!t1.$isHParameterValue)
        return true;
      if (instruction.usedBy.length === 0)
        return false;
      if (this.generateAtUseSite.contains$1(0, instruction))
        return false;
      return !instruction.nonCheck$0().isCodeMotionInvariant$0();
    },
    freeUsedNamesAt$3: function(instruction, at, namer) {
      var t1, atInterval, ownName, len, i;
      if (this.needsName$1(instruction)) {
        t1 = this.liveIntervals;
        atInterval = t1.$index(0, at);
        if (t1.$index(0, instruction).diesAt$1(J.get$start$x(atInterval))) {
          ownName = namer.names.ownName.$index(0, instruction);
          if (ownName != null) {
            if (namer.temporaryIndex !== 0) {
              t1 = $.get$VariableNamer_regexp()._nativeRegExp;
              if (typeof ownName !== "string")
                H.throwExpression(P.ArgumentError$(ownName));
              t1 = t1.test(ownName);
            } else
              t1 = false;
            if (t1)
              namer.freeTemporaryNames.push(ownName);
            namer.usedNames.remove$1(0, ownName);
          }
        }
      } else if (this.generateAtUseSite.contains$1(0, instruction))
        for (t1 = instruction.inputs, len = t1.length, i = 0; i < len; ++i) {
          if (i >= t1.length)
            return H.ioore(t1, i);
          this.freeUsedNamesAt$3(t1[i], at, namer);
        }
    },
    handleInstruction$2: function(instruction, namer) {
      var t1, len, i;
      if (this.generateAtUseSite.contains$1(0, instruction))
        return;
      for (t1 = instruction.inputs, len = t1.length, i = 0; i < len; ++i) {
        if (i >= t1.length)
          return H.ioore(t1, i);
        this.freeUsedNamesAt$3(t1[i], instruction, namer);
      }
      if (this.needsName$1(instruction))
        namer.allocateName$1(instruction);
    },
    handlePhi$2: function(phi, namer) {
      var t1, t2, i, input, t3, predecessor;
      if (!this.needsName$1(phi))
        return;
      for (t1 = phi.inputs, t2 = this.names, i = 0; i < t1.length; ++i) {
        input = t1[i];
        t3 = phi.block.predecessors;
        if (i >= t3.length)
          return H.ioore(t3, i);
        predecessor = t3[i];
        for (; !!J.getInterceptor(input).$isHTypeKnown;) {
          t3 = input.get$inputs();
          if (0 >= t3.length)
            return H.ioore(t3, 0);
          input = t3[0];
        }
        if (!this.needsName$1(input))
          t2.addAssignment$3(predecessor, input, phi);
        else
          t2.addCopy$3(predecessor, input, phi);
      }
      namer.allocateName$1(phi);
    }
  },
  SsaVariableAllocator_visitBasicBlock_closure: {
    "^": "Closure:259;this_0,namer_1",
    call$1: function(phi) {
      this.this_0.handlePhi$2(phi, this.namer_1);
    },
    $isFunction: true
  },
  SsaVariableAllocator_visitBasicBlock_closure0: {
    "^": "Closure:290;this_2,namer_3",
    call$1: function(instruction) {
      this.this_2.handleInstruction$2(instruction, this.namer_3);
    },
    $isFunction: true
  }
}],
["ssa.tracer", "package:compiler/implementation/ssa/ssa_tracer.dart", , K, {
  "^": "",
  HTracer: {
    "^": "HGraphVisitor_TracerUtil;compiler<,context,output<,tracer$TracerUtil$_ind",
    traceGraph$2: function($name, graph) {
      this.tag$2(0, "cfg", new K.HTracer_traceGraph_closure(this, $name, graph));
    },
    addPredecessors$1: function(block) {
      var t1 = block.predecessors;
      if (t1.length === 0)
        this.printEmptyProperty$1("predecessors");
      else {
        this.addIndent$0();
        this.add$1(0, "predecessors");
        for (t1 = H.setRuntimeTypeInfo(new H.ListIterator(t1, t1.length, 0, null), [H.getTypeArgumentByIndex(t1, 0)]); t1.moveNext$0();)
          this.add$1(0, " \"B" + H.S(J.get$id$x(t1.__internal$_current)) + "\"");
        this.add$1(0, "\n");
      }
    },
    addSuccessors$1: function(block) {
      var t1;
      if (block.successors.length === 0)
        this.printEmptyProperty$1("successors");
      else {
        this.addIndent$0();
        this.add$1(0, "successors");
        for (t1 = block.successors, t1 = H.setRuntimeTypeInfo(new H.ListIterator(t1, t1.length, 0, null), [H.getTypeArgumentByIndex(t1, 0)]); t1.moveNext$0();)
          this.add$1(0, " \"B" + H.S(J.get$id$x(t1.__internal$_current)) + "\"");
        this.add$1(0, "\n");
      }
    },
    addInstructions$2: function(stringifier, list) {
      var instruction, uses, t1, changes, depends, temporaryId, instructionString;
      for (instruction = list.first; instruction != null; instruction = instruction.next) {
        uses = instruction.usedBy.length;
        t1 = instruction.sideEffects.flags;
        changes = (t1 & 7) !== 0 ? "!" : " ";
        depends = (t1 & 63) >>> 3 !== 0 ? "?" : "";
        this.addIndent$0();
        temporaryId = stringifier.temporaryId$1(instruction);
        instructionString = H.S(instruction.accept$1(0, stringifier)) + " " + J.toString$0(instruction.instructionType);
        this.add$1(0, "0 " + uses + " " + temporaryId + " " + instructionString + " " + changes + " " + depends + " <|@\n");
      }
    },
    visitBasicBlock$1: function(block) {
      var t1 = this.context;
      this.tag$2(0, "block", new K.HTracer_visitBasicBlock_closure(this, block, new K.HInstructionStringifier(this.compiler, t1, block)));
    }
  },
  HGraphVisitor_TracerUtil: {
    "^": "HGraphVisitor+TracerUtil;"
  },
  HTracer_traceGraph_closure: {
    "^": "Closure:23;this_0,name_1,graph_2",
    call$0: function() {
      var t1 = this.this_0;
      t1.printProperty$2("name", this.name_1);
      t1.visitDominatorTree$1(this.graph_2);
    },
    $isFunction: true
  },
  HTracer_visitBasicBlock_closure: {
    "^": "Closure:23;this_0,block_1,stringifier_2",
    call$0: function() {
      var t1, t2, t3;
      t1 = this.this_0;
      t2 = this.block_1;
      t1.printProperty$2("name", "B" + H.S(t2.id));
      t1.printProperty$2("from_bci", -1);
      t1.printProperty$2("to_bci", -1);
      t1.addPredecessors$1(t2);
      t1.addSuccessors$1(t2);
      t1.printEmptyProperty$1("xhandlers");
      t1.printEmptyProperty$1("flags");
      t3 = t2.dominator;
      if (t3 != null)
        t1.printProperty$2("dominator", "B" + H.S(t3.id));
      t3 = this.stringifier_2;
      t1.tag$2(0, "states", new K.HTracer_visitBasicBlock__closure(t1, t2, t3));
      t1.tag$2(0, "HIR", new K.HTracer_visitBasicBlock__closure0(t1, t2, t3));
    },
    $isFunction: true
  },
  HTracer_visitBasicBlock__closure: {
    "^": "Closure:23;this_3,block_4,stringifier_5",
    call$0: function() {
      var t1 = this.this_3;
      t1.tag$2(0, "locals", new K.HTracer_visitBasicBlock___closure(t1, this.block_4, this.stringifier_5));
    },
    $isFunction: true
  },
  HTracer_visitBasicBlock___closure: {
    "^": "Closure:23;this_6,block_7,stringifier_8",
    call$0: function() {
      var t1 = this.this_6;
      t1.printProperty$2("size", 0);
      t1.printProperty$2("method", "None");
      this.block_7.forEachPhi$1(new K.HTracer_visitBasicBlock____closure(t1, this.stringifier_8));
    },
    $isFunction: true
  },
  HTracer_visitBasicBlock____closure: {
    "^": "Closure:13;this_9,stringifier_10",
    call$1: function(phi) {
      var t1, phiId, inputIds, t2, i, t3;
      t1 = this.stringifier_10;
      phiId = t1.temporaryId$1(phi);
      inputIds = P.StringBuffer$("");
      for (t2 = phi.inputs, i = 0; i < t2.length; ++i) {
        t3 = t1.temporaryId$1(t2[i]);
        t3 = inputIds._contents += t3;
        inputIds._contents = t3 + " ";
      }
      this.this_9.println$1(H.S(phi.id) + " " + phiId + " [ " + H.S(inputIds) + "]");
    },
    $isFunction: true
  },
  HTracer_visitBasicBlock__closure0: {
    "^": "Closure:23;this_11,block_12,stringifier_13",
    call$0: function() {
      var t1, t2, t3;
      t1 = this.this_11;
      t2 = this.stringifier_13;
      t3 = this.block_12;
      t1.addInstructions$2(t2, t3.phis);
      t1.addInstructions$2(t2, t3);
    },
    $isFunction: true
  },
  HInstructionStringifier: {
    "^": "Object;compiler<,context,currentBlock",
    temporaryId$1: function(instruction) {
      var t1, prefix, backend;
      t1 = instruction.get$instructionType();
      if (t1.get$isEmpty(t1) && instruction.instructionType.get$isNullable())
        prefix = "u";
      else {
        t1 = instruction.instructionType;
        if (t1.get$isEmpty(t1) && !instruction.instructionType.get$isNullable())
          prefix = "c";
        else {
          t1 = this.compiler;
          backend = t1.backend;
          if (instruction.instructionType.containsOnly$1(backend.get$jsExtendableArrayClass()))
            prefix = "e";
          else {
            backend = t1.backend;
            if (instruction.instructionType.containsOnly$1(backend.get$jsFixedArrayClass()))
              prefix = "f";
            else {
              backend = t1.backend;
              if (instruction.instructionType.satisfies$2(backend.get$jsMutableArrayClass(), t1))
                prefix = "m";
              else {
                backend = t1.backend;
                if (instruction.instructionType.satisfies$2(backend.get$jsArrayClass(), t1))
                  prefix = "a";
                else if (instruction.instructionType.containsOnlyString$1(t1) && !instruction.instructionType.get$isNullable())
                  prefix = "s";
                else {
                  backend = t1.backend;
                  if (instruction.instructionType.containsOnlyString$1(t1) || instruction.instructionType.satisfies$2(backend.get$jsIndexableClass(), t1))
                    prefix = "r";
                  else if (instruction.instructionType.containsOnlyBool$1(t1) && !instruction.instructionType.get$isNullable())
                    prefix = "b";
                  else if (instruction.instructionType.containsOnlyInt$1(t1) && !instruction.instructionType.get$isNullable())
                    prefix = "i";
                  else if (instruction.instructionType.containsOnlyDouble$1(t1) && !instruction.instructionType.get$isNullable())
                    prefix = "d";
                  else if (instruction.instructionType.containsOnlyNum$1(t1) && !instruction.instructionType.get$isNullable())
                    prefix = "n";
                  else
                    prefix = instruction.instructionType.containsAll$1(t1) ? "v" : "U";
                }
              }
            }
          }
        }
      }
      return prefix + H.S(instruction.id);
    },
    visitBoolify$1: function(node) {
      var t1 = node.inputs;
      if (0 >= t1.length)
        return H.ioore(t1, 0);
      return "Boolify: " + this.temporaryId$1(t1[0]);
    },
    handleInvokeBinary$2: function(node, op) {
      var t1, left, right;
      t1 = node.inputs;
      if (0 >= t1.length)
        return H.ioore(t1, 0);
      left = this.temporaryId$1(t1[0]);
      if (1 >= t1.length)
        return H.ioore(t1, 1);
      right = this.temporaryId$1(t1[1]);
      return left + " " + op + " " + right;
    },
    visitAdd$1: function(node) {
      return this.handleInvokeBinary$2(node, "+");
    },
    visitBitAnd$1: function(node) {
      return this.handleInvokeBinary$2(node, "&");
    },
    visitBitNot$1: function(node) {
      var t1 = node.inputs;
      if (0 >= t1.length)
        return H.ioore(t1, 0);
      return "~" + this.temporaryId$1(t1[0]);
    },
    visitBitOr$1: function(node) {
      return this.handleInvokeBinary$2(node, "|");
    },
    visitBitXor$1: function(node) {
      return this.handleInvokeBinary$2(node, "^");
    },
    visitBoundsCheck$1: function(node) {
      var t1, lengthId, indexId;
      t1 = node.inputs;
      if (1 >= t1.length)
        return H.ioore(t1, 1);
      lengthId = this.temporaryId$1(t1[1]);
      if (0 >= t1.length)
        return H.ioore(t1, 0);
      indexId = this.temporaryId$1(t1[0]);
      return "Bounds check: length = " + lengthId + ", index = " + indexId;
    },
    visitBreak$1: function(node) {
      var t1, target;
      t1 = this.currentBlock.successors;
      if (0 >= t1.length)
        return H.ioore(t1, 0);
      target = t1[0];
      t1 = node.label;
      if (t1 != null)
        return "Break " + H.S(t1.get$labelName()) + ": (B" + H.S(J.get$id$x(target)) + ")";
      return "Break: (B" + H.S(J.get$id$x(target)) + ")";
    },
    visitConstant$1: function(constant) {
      return "Constant " + constant.constant.toString$0(0);
    },
    visitContinue$1: function(node) {
      var t1, target;
      t1 = this.currentBlock.successors;
      if (0 >= t1.length)
        return H.ioore(t1, 0);
      target = t1[0];
      t1 = node.label;
      if (t1 != null)
        return "Continue " + H.S(t1.get$labelName()) + ": (B" + H.S(J.get$id$x(target)) + ")";
      return "Continue: (B" + H.S(J.get$id$x(target)) + ")";
    },
    visitDivide$1: function(node) {
      return this.handleInvokeBinary$2(node, "/");
    },
    visitExit$1: function(node) {
      return "exit";
    },
    visitFieldGet$1: function(node) {
      var t1, fieldName;
      t1 = node.element;
      if (t1 == null) {
        t1 = node.inputs;
        if (0 >= t1.length)
          return H.ioore(t1, 0);
        return "null check on " + this.temporaryId$1(t1[0]);
      }
      fieldName = t1.get$name(t1);
      t1 = node.inputs;
      if (0 >= t1.length)
        return H.ioore(t1, 0);
      return "field get " + this.temporaryId$1(t1[0]) + "." + H.S(fieldName);
    },
    visitFieldSet$1: function(node) {
      var t1, valueId, t2, fieldName;
      t1 = node.inputs;
      if (1 >= t1.length)
        return H.ioore(t1, 1);
      valueId = this.temporaryId$1(t1[1]);
      t2 = node.element;
      fieldName = t2.get$name(t2);
      if (0 >= t1.length)
        return H.ioore(t1, 0);
      return "field set " + this.temporaryId$1(t1[0]) + "." + H.S(fieldName) + " to " + valueId;
    },
    visitReadModifyWrite$1: function(node) {
      var t1, fieldName, receiverId, op, t2, valueId;
      t1 = node.element;
      fieldName = t1.get$name(t1);
      t1 = node.inputs;
      if (0 >= t1.length)
        return H.ioore(t1, 0);
      receiverId = this.temporaryId$1(t1[0]);
      op = node.jsOp;
      t2 = node.opKind;
      if (t2 === 0) {
        if (1 >= t1.length)
          return H.ioore(t1, 1);
        valueId = this.temporaryId$1(t1[1]);
        return "field-update " + receiverId + "." + H.S(fieldName) + " " + op + "= " + valueId;
      } else if (t2 === 1)
        return "field-update " + op + receiverId + "." + H.S(fieldName);
      else
        return "field-update " + receiverId + "." + H.S(fieldName) + op;
    },
    visitLocalGet$1: function(node) {
      var t1, localName;
      t1 = node.variable;
      localName = t1.get$name(t1);
      t1 = node.inputs;
      if (0 >= t1.length)
        return H.ioore(t1, 0);
      return "local get " + this.temporaryId$1(t1[0]) + "." + H.S(localName);
    },
    visitLocalSet$1: function(node) {
      var t1, valueId, t2, localName;
      t1 = node.inputs;
      if (1 >= t1.length)
        return H.ioore(t1, 1);
      valueId = this.temporaryId$1(t1[1]);
      t2 = node.variable;
      localName = t2.get$name(t2);
      if (0 >= t1.length)
        return H.ioore(t1, 0);
      return "local set " + this.temporaryId$1(t1[0]) + "." + H.S(localName) + " to " + valueId;
    },
    visitGoto$1: function(node) {
      var t1 = this.currentBlock.successors;
      if (0 >= t1.length)
        return H.ioore(t1, 0);
      return "Goto: (B" + H.S(J.get$id$x(t1[0])) + ")";
    },
    visitGreater$1: function(node) {
      return this.handleInvokeBinary$2(node, ">");
    },
    visitGreaterEqual$1: function(node) {
      return this.handleInvokeBinary$2(node, ">=");
    },
    visitIdentity$1: function(node) {
      return this.handleInvokeBinary$2(node, "===");
    },
    visitIf$1: function(node) {
      var t1, t2, thenBlock, elseBlock;
      t1 = this.currentBlock.successors;
      t2 = t1.length;
      if (0 >= t2)
        return H.ioore(t1, 0);
      thenBlock = t1[0];
      if (1 >= t2)
        return H.ioore(t1, 1);
      elseBlock = t1[1];
      t1 = node.inputs;
      if (0 >= t1.length)
        return H.ioore(t1, 0);
      return "If (" + this.temporaryId$1(t1[0]) + "): (B" + H.S(J.get$id$x(thenBlock)) + ") else (B" + H.S(J.get$id$x(elseBlock)) + ")";
    },
    visitGenericInvoke$3: function(invokeType, functionName, $arguments) {
      var argumentsString, i, t1;
      argumentsString = P.StringBuffer$("");
      for (i = 0; i < $arguments.length; ++i) {
        if (i !== 0)
          argumentsString._contents += ", ";
        t1 = this.temporaryId$1($arguments[i]);
        argumentsString._contents += t1;
      }
      return invokeType + ": " + H.S(functionName) + "(" + H.S(argumentsString) + ")";
    },
    visitIndex$1: function(node) {
      var t1, receiver, index;
      t1 = node.inputs;
      if (0 >= t1.length)
        return H.ioore(t1, 0);
      receiver = this.temporaryId$1(t1[0]);
      if (1 >= t1.length)
        return H.ioore(t1, 1);
      index = this.temporaryId$1(t1[1]);
      return "Index: " + receiver + "[" + index + "]";
    },
    visitIndexAssign$1: function(node) {
      var t1, receiver, index, value;
      t1 = node.inputs;
      if (0 >= t1.length)
        return H.ioore(t1, 0);
      receiver = this.temporaryId$1(t1[0]);
      if (1 >= t1.length)
        return H.ioore(t1, 1);
      index = this.temporaryId$1(t1[1]);
      if (2 >= t1.length)
        return H.ioore(t1, 2);
      value = this.temporaryId$1(t1[2]);
      return "IndexAssign: " + receiver + "[" + index + "] = " + value;
    },
    visitInterceptor$1: function(node) {
      var t1, value;
      t1 = node.inputs;
      if (0 >= t1.length)
        return H.ioore(t1, 0);
      value = this.temporaryId$1(t1[0]);
      if (node.interceptedClasses != null)
        return "Intercept (" + this.compiler.backend.get$namer().getInterceptorSuffix$1(node.interceptedClasses) + "): " + value;
      return "Intercept: " + value;
    },
    visitInvokeClosure$1: function(node) {
      return this.visitInvokeDynamic$2(node, "closure");
    },
    visitInvokeDynamic$2: function(invoke, kind) {
      var t1, receiver, $name;
      t1 = invoke.inputs;
      if (0 >= t1.length)
        return H.ioore(t1, 0);
      receiver = this.temporaryId$1(t1[0]);
      $name = invoke.selector.name;
      return this.visitGenericInvoke$3("Invoke", "(" + kind + ") " + receiver + "." + H.S($name), J.sublist$1$ax(t1, 1)) + ("(" + J.toString$0(invoke.selector.get$mask()) + ")");
    },
    visitInvokeDynamicMethod$1: function(node) {
      return this.visitInvokeDynamic$2(node, "method");
    },
    visitInvokeDynamicGetter$1: function(node) {
      return this.visitInvokeDynamic$2(node, "get");
    },
    visitInvokeDynamicSetter$1: function(node) {
      return this.visitInvokeDynamic$2(node, "set");
    },
    visitInvokeStatic$1: function(invoke) {
      var t1 = invoke.element;
      return this.visitGenericInvoke$3("Invoke", t1.get$name(t1), invoke.inputs);
    },
    visitInvokeSuper$1: function(invoke) {
      var t1 = invoke.element;
      return this.visitGenericInvoke$3("Invoke super", t1.get$name(t1), invoke.inputs);
    },
    visitInvokeConstructorBody$1: function(invoke) {
      var t1 = invoke.element;
      return this.visitGenericInvoke$3("Invoke constructor body", t1.get$name(t1), invoke.inputs);
    },
    visitForeign$1: function(foreign) {
      return this.visitGenericInvoke$3("Foreign", J.toString$0(foreign.codeTemplate.ast), foreign.inputs);
    },
    visitForeignNew$1: function(node) {
      return this.visitGenericInvoke$3("New", H.S(node.element.name), node.inputs);
    },
    visitLess$1: function(node) {
      return this.handleInvokeBinary$2(node, "<");
    },
    visitLessEqual$1: function(node) {
      return this.handleInvokeBinary$2(node, "<=");
    },
    visitLiteralList$1: function(node) {
      var elementsString, t1, i, t2;
      elementsString = P.StringBuffer$("");
      for (t1 = node.inputs, i = 0; i < t1.length; ++i) {
        if (i !== 0)
          elementsString._contents += ", ";
        t2 = this.temporaryId$1(t1[i]);
        elementsString._contents += t2;
      }
      return "Literal list: [" + H.S(elementsString) + "]";
    },
    visitLoopBranch$1: function(branch) {
      var t1, t2, bodyBlock, exitBlock;
      t1 = this.currentBlock.successors;
      t2 = t1.length;
      if (0 >= t2)
        return H.ioore(t1, 0);
      bodyBlock = t1[0];
      if (1 >= t2)
        return H.ioore(t1, 1);
      exitBlock = t1[1];
      t1 = branch.inputs;
      if (0 >= t1.length)
        return H.ioore(t1, 0);
      return "While (" + this.temporaryId$1(t1[0]) + "): (B" + H.S(J.get$id$x(bodyBlock)) + ") then (B" + H.S(J.get$id$x(exitBlock)) + ")";
    },
    visitMultiply$1: function(node) {
      return this.handleInvokeBinary$2(node, "*");
    },
    visitNegate$1: function(node) {
      var t1 = node.inputs;
      if (0 >= t1.length)
        return H.ioore(t1, 0);
      return "-" + this.temporaryId$1(t1[0]);
    },
    visitNot$1: function(node) {
      var t1 = node.inputs;
      if (0 >= t1.length)
        return H.ioore(t1, 0);
      return "Not: " + this.temporaryId$1(t1[0]);
    },
    visitParameterValue$1: function(node) {
      var t1 = node.get$sourceElement();
      return "p" + H.S(t1.get$name(t1));
    },
    visitLocalValue$1: function(node) {
      var t1 = node.get$sourceElement();
      return "l" + H.S(t1.get$name(t1));
    },
    visitPhi$1: function(phi) {
      var buffer, t1, i, t2;
      buffer = P.StringBuffer$("");
      buffer.write$1("Phi(");
      for (t1 = phi.inputs, i = 0; i < t1.length; ++i) {
        if (i > 0)
          buffer._contents += ", ";
        t2 = this.temporaryId$1(t1[i]);
        buffer._contents += t2;
      }
      buffer.write$1(")");
      return buffer._contents;
    },
    visitReturn$1: function(node) {
      var t1 = node.inputs;
      if (0 >= t1.length)
        return H.ioore(t1, 0);
      return "Return " + this.temporaryId$1(t1[0]);
    },
    visitShiftLeft$1: function(node) {
      return this.handleInvokeBinary$2(node, "<<");
    },
    visitShiftRight$1: function(node) {
      return this.handleInvokeBinary$2(node, ">>");
    },
    visitStatic$1: function(node) {
      var t1 = node.element;
      return "Static " + H.S(t1.get$name(t1));
    },
    visitLazyStatic$1: function(node) {
      var t1 = node.element;
      return "LazyStatic " + H.S(t1.get$name(t1));
    },
    visitOneShotInterceptor$1: function(node) {
      return this.visitInvokeDynamic$2(node, "one shot interceptor");
    },
    visitStaticStore$1: function(node) {
      var t1, t2;
      t1 = node.element;
      t1 = "Static " + H.S(t1.get$name(t1)) + " = ";
      t2 = node.inputs;
      if (0 >= t2.length)
        return H.ioore(t2, 0);
      return t1 + this.temporaryId$1(t2[0]);
    },
    visitStringConcat$1: function(node) {
      var t1, leftId, rightId;
      t1 = node.inputs;
      if (0 >= t1.length)
        return H.ioore(t1, 0);
      leftId = this.temporaryId$1(t1[0]);
      if (1 >= t1.length)
        return H.ioore(t1, 1);
      rightId = this.temporaryId$1(t1[1]);
      return "StringConcat: " + leftId + " + " + rightId;
    },
    visitStringify$1: function(node) {
      var t1 = node.inputs;
      if (0 >= t1.length)
        return H.ioore(t1, 0);
      return "Stringify " + this.temporaryId$1(t1[0]);
    },
    visitSubtract$1: function(node) {
      return this.handleInvokeBinary$2(node, "-");
    },
    visitSwitch$1: function(node) {
      var buf, t1, i, t2, t3, str;
      buf = P.StringBuffer$("");
      buf.write$1("Switch: (");
      t1 = node.inputs;
      if (0 >= t1.length)
        return H.ioore(t1, 0);
      buf.write$1(this.temporaryId$1(t1[0]));
      buf.write$1(") ");
      for (i = 1; i < t1.length; ++i) {
        t2 = this.temporaryId$1(t1[i]);
        t2 = buf._contents += t2;
        buf._contents = t2 + ": B";
        t2 = node.block.successors;
        t3 = i - 1;
        if (t3 >= t2.length)
          return H.ioore(t2, t3);
        str = J.get$id$x(t2[t3]);
        t2 = buf._contents += typeof str === "string" ? str : H.S(str);
        buf._contents = t2 + ", ";
      }
      buf.write$1("default: B");
      buf.write$1(J.get$id$x(C.JSArray_methods.get$last(node.block.successors)));
      return buf._contents;
    },
    visitThis$1: function(node) {
      return "this";
    },
    visitThrow$1: function(node) {
      var t1 = node.inputs;
      if (0 >= t1.length)
        return H.ioore(t1, 0);
      return "Throw " + this.temporaryId$1(t1[0]);
    },
    visitThrowExpression$1: function(node) {
      var t1 = node.inputs;
      if (0 >= t1.length)
        return H.ioore(t1, 0);
      return "ThrowExpression " + this.temporaryId$1(t1[0]);
    },
    visitTruncatingDivide$1: function(node) {
      return this.handleInvokeBinary$2(node, "~/");
    },
    visitExitTry$1: function(node) {
      return "Exit try";
    },
    visitTry$1: function(node) {
      var successors, tryBlock, catchBlock, t1, finallyBlock;
      successors = this.currentBlock.successors;
      if (0 >= successors.length)
        return H.ioore(successors, 0);
      tryBlock = "B" + H.S(J.get$id$x(successors[0]));
      if (node.catchBlock != null) {
        if (1 >= successors.length)
          return H.ioore(successors, 1);
        catchBlock = "B" + H.S(J.get$id$x(successors[1]));
      } else
        catchBlock = "none";
      t1 = node.finallyBlock;
      finallyBlock = t1 != null ? "B" + H.S(t1.id) : "none";
      return "Try: " + tryBlock + ", Catch: " + catchBlock + ", Finally: " + finallyBlock + ", Join: B" + H.S(J.get$id$x(C.JSArray_methods.get$last(successors)));
    },
    visitIs$1: function(node) {
      var type, t1;
      type = node.typeExpression.toString$0(0);
      t1 = node.inputs;
      if (0 >= t1.length)
        return H.ioore(t1, 0);
      return "TypeTest: " + this.temporaryId$1(t1[0]) + " is " + H.S(type);
    },
    visitIsViaInterceptor$1: function(node) {
      var type, t1;
      type = node.typeExpression.toString$0(0);
      t1 = node.inputs;
      if (0 >= t1.length)
        return H.ioore(t1, 0);
      return "TypeTest: " + this.temporaryId$1(t1[0]) + " is " + H.S(type);
    },
    visitTypeConversion$1: function(node) {
      var t1, t2, otherInput;
      t1 = node.inputs;
      t2 = t1.length;
      if (t2 === 2) {
        if (1 >= t2)
          return H.ioore(t1, 1);
        otherInput = this.temporaryId$1(t1[1]);
      } else
        otherInput = "";
      if (0 >= t1.length)
        return H.ioore(t1, 0);
      return "TypeConversion: " + this.temporaryId$1(t1[0]) + " to " + J.toString$0(node.instructionType) + " " + otherInput;
    },
    visitTypeKnown$1: function(node) {
      var t1, result, t2, t3, t4;
      t1 = node.inputs;
      if (0 >= t1.length)
        return H.ioore(t1, 0);
      result = "TypeKnown: " + this.temporaryId$1(t1[0]) + " is " + J.toString$0(node.knownType);
      t2 = t1.length;
      t3 = t2 === 2;
      if (t3) {
        if (1 >= t2)
          return H.ioore(t1, 1);
        t4 = t1[1];
      } else
        t4 = null;
      if (t4 != null) {
        if (t3) {
          if (1 >= t2)
            return H.ioore(t1, 1);
          t1 = t1[1];
        } else
          t1 = null;
        result += " witnessed by " + this.temporaryId$1(t1);
      }
      return result;
    },
    visitRangeConversion$1: function(node) {
      var t1 = node.inputs;
      if (0 >= t1.length)
        return H.ioore(t1, 0);
      return "RangeConversion: " + H.S(t1[0]);
    },
    visitReadTypeVariable$1: function(node) {
      return "ReadTypeVariable: " + node.dartType.element.name + " " + node.hasReceiver;
    },
    visitFunctionType$1: function(node) {
      return "FunctionType: " + H.S(node.dartType);
    },
    visitVoidType$1: function(node) {
      return "VoidType";
    },
    visitInterfaceType$1: function(node) {
      return "InterfaceType: " + H.S(node.dartType);
    },
    visitDynamicType$1: function(node) {
      return "DynamicType";
    }
  }
}],
["statement_rewriter", "package:compiler/implementation/dart_backend/statement_rewriter.dart", , E, {
  "^": "",
  StatementRewriter: {
    "^": "Visitor0;environment<,labelRedirects",
    redirect$1: function(jump) {
      var newJump = this.labelRedirects.$index(0, jump.get$target(jump));
      return newJump != null ? newJump : jump;
    },
    rewrite$1: function(definition) {
      this.environment = H.setRuntimeTypeInfo([], [M.Assign]);
      definition.body = definition.body.accept$1(0, this);
    },
    visitVariable$1: function(node) {
      var t1 = this.environment;
      if (t1.length !== 0 && J.$eq(J.get$last$ax(t1).get$variable(), node) && J.get$last$ax(this.environment).get$hasExactlyOneUse()) {
        t1 = this.environment;
        if (0 >= t1.length)
          return H.ioore(t1, 0);
        t1 = t1.pop().get$definition();
        return t1.get$processed() ? t1 : t1.accept$1(0, this);
      }
      return node;
    },
    visitAssign$1: function(node) {
      var next, t1;
      this.environment.push(node);
      next = node.next.accept$1(0, this);
      t1 = this.environment;
      if (t1.length !== 0 && J.$eq(J.get$last$ax(t1), node)) {
        node.next = next;
        t1 = this.environment;
        if (0 >= t1.length)
          return H.ioore(t1, 0);
        t1.pop();
        t1 = node.definition;
        node.definition = t1.processed ? t1 : t1.accept$1(0, this);
        return node;
      }
      return next;
    },
    visitInvokeStatic$1: function(node) {
      var i, t1, t2;
      for (i = node.get$arguments().length - 1, t1 = node.arguments; i >= 0; --i) {
        if (i >= t1.length)
          return H.ioore(t1, i);
        t2 = t1[i];
        t2 = t2.get$processed() ? t2 : t2.accept$1(0, this);
        if (i >= t1.length)
          return H.ioore(t1, i);
        t1[i] = t2;
      }
      return node;
    },
    visitInvokeMethod$1: function(node) {
      var t1, t2, i, t3;
      for (t1 = node.arguments, t2 = t1.length, i = t2 - 1; i >= 0; --i, t2 = t3) {
        if (i >= t2)
          return H.ioore(t1, i);
        t2 = t1[i];
        t2 = t2.get$processed() ? t2 : t2.accept$1(0, this);
        t3 = t1.length;
        if (i >= t3)
          return H.ioore(t1, i);
        t1[i] = t2;
      }
      t1 = node.receiver;
      node.receiver = t1.processed ? t1 : t1.accept$1(0, this);
      return node;
    },
    visitInvokeSuperMethod$1: function(node) {
      var t1, t2, i, t3;
      for (t1 = node.arguments, t2 = t1.length, i = t2 - 1; i >= 0; --i, t2 = t3) {
        if (i >= t2)
          return H.ioore(t1, i);
        t2 = t1[i];
        t2 = t2.get$processed() ? t2 : t2.accept$1(0, this);
        t3 = t1.length;
        if (i >= t3)
          return H.ioore(t1, i);
        t1[i] = t2;
      }
      return node;
    },
    visitInvokeConstructor$1: function(node) {
      var t1, t2, i, t3;
      for (t1 = node.arguments, t2 = t1.length, i = t2 - 1; i >= 0; --i, t2 = t3) {
        if (i >= t2)
          return H.ioore(t1, i);
        t2 = t1[i];
        t2 = t2.get$processed() ? t2 : t2.accept$1(0, this);
        t3 = t1.length;
        if (i >= t3)
          return H.ioore(t1, i);
        t1[i] = t2;
      }
      return node;
    },
    visitConcatenateStrings$1: function(node) {
      var t1, t2, i, t3;
      for (t1 = node.arguments, t2 = t1.length, i = t2 - 1; i >= 0; --i, t2 = t3) {
        if (i >= t2)
          return H.ioore(t1, i);
        t2 = t1[i];
        t2 = t2.get$processed() ? t2 : t2.accept$1(0, this);
        t3 = t1.length;
        if (i >= t3)
          return H.ioore(t1, i);
        t1[i] = t2;
      }
      return node;
    },
    visitConditional$1: function(node) {
      var t1, savedEnvironment;
      t1 = node.condition;
      node.condition = t1.processed ? t1 : t1.accept$1(0, this);
      savedEnvironment = this.environment;
      this.environment = H.setRuntimeTypeInfo([], [M.Assign]);
      t1 = node.thenExpression;
      node.thenExpression = t1.processed ? t1 : t1.accept$1(0, this);
      t1 = node.elseExpression;
      node.elseExpression = t1.processed ? t1 : t1.accept$1(0, this);
      this.environment = savedEnvironment;
      return node;
    },
    visitLogicalOperator$1: function(node) {
      var t1 = node.left;
      node.left = t1.processed ? t1 : t1.accept$1(0, this);
      this.environment.push(null);
      t1 = node.right;
      node.right = t1.processed ? t1 : t1.accept$1(0, this);
      t1 = this.environment;
      if (0 >= t1.length)
        return H.ioore(t1, 0);
      t1.pop();
      return node;
    },
    visitNot$1: function(node) {
      var t1 = node.get$operand();
      node.operand = t1.processed ? t1 : t1.accept$1(0, this);
      return node;
    },
    visitFunctionExpression$1: function(node) {
      new E.StatementRewriter(null, P.LinkedHashMap_LinkedHashMap$_empty(M.Label0, M.Jump)).rewrite$1(node.definition);
      return node;
    },
    visitFunctionDeclaration$1: function(node) {
      new E.StatementRewriter(null, P.LinkedHashMap_LinkedHashMap$_empty(M.Label0, M.Jump)).rewrite$1(node.definition);
      node.next = node.next.accept$1(0, this);
      return node;
    },
    visitReturn$1: function(node) {
      var t1 = node.get$value(node);
      node.value = t1.processed ? t1 : t1.accept$1(0, this);
      return node;
    },
    visitBreak$1: function(node) {
      var jump = this.redirect$1(node);
      if (!!jump.$isBreak1 && jump.target.useCount === 1) {
        --jump.get$target(jump).useCount;
        return jump.get$target(jump).binding.get$next().accept$1(0, this);
      }
      return jump;
    },
    visitContinue$1: function(node) {
      return node;
    },
    visitLabeledStatement$1: function(node) {
      var t1, newJump, t2, t3, result, savedEnvironment;
      t1 = node.next;
      if (!!J.getInterceptor(t1).$isJump) {
        newJump = this.redirect$1(t1);
        t1 = this.labelRedirects;
        t2 = node.label;
        t1.$indexSet(0, t2, newJump);
        t3 = newJump.get$target(newJump);
        t3.useCount = t3.useCount + (t2.useCount - 1);
        t2.useCount = 0;
        result = node.body.accept$1(0, this);
        t1.remove$1(0, t2);
        return result;
      }
      t1 = node.body.accept$1(0, this);
      node.body = t1;
      if (node.label.useCount === 0)
        return t1;
      savedEnvironment = this.environment;
      this.environment = H.setRuntimeTypeInfo([], [M.Assign]);
      node.next = node.next.accept$1(0, this);
      this.environment = savedEnvironment;
      return node;
    },
    visitIf$1: function(node) {
      var t1, savedEnvironment, reduced;
      t1 = node.get$condition();
      node.set$condition(t1.processed ? t1 : t1.accept$1(0, this));
      savedEnvironment = this.environment;
      this.environment = H.setRuntimeTypeInfo([], [M.Assign]);
      node.thenStatement = node.thenStatement.accept$1(0, this);
      node.elseStatement = node.elseStatement.accept$1(0, this);
      this.environment = savedEnvironment;
      this.tryCollapseIf$1(node);
      reduced = E.StatementRewriter_combineStatementsWithSubexpressions(node.thenStatement, node.elseStatement, new E.StatementRewriter_visitIf_closure(node));
      if (reduced != null)
        return !!J.getInterceptor(reduced.get$next()).$isBreak1 ? reduced.accept$1(0, this) : reduced;
      return node;
    },
    visitWhileTrue$1: function(node) {
      var savedEnvironment = this.environment;
      this.environment = H.setRuntimeTypeInfo([], [M.Assign]);
      node.body = node.body.accept$1(0, this);
      this.environment = savedEnvironment;
      return node;
    },
    visitWhileCondition$1: function(node) {
      throw H.wrapException("Unexpected WhileCondition in StatementRewriter");
    },
    visitConstant$1: function(node) {
      return node;
    },
    visitThis$1: function(node) {
      return node;
    },
    visitReifyTypeVar$1: function(node) {
      return node;
    },
    visitLiteralList$1: function(node) {
      var i, t1, t2;
      for (i = node.get$values(node).length - 1, t1 = node.values; i >= 0; --i) {
        if (i >= t1.length)
          return H.ioore(t1, i);
        t2 = t1[i];
        t2 = t2.get$processed() ? t2 : t2.accept$1(0, this);
        if (i >= t1.length)
          return H.ioore(t1, i);
        t1[i] = t2;
      }
      return node;
    },
    visitLiteralMap$1: function(node) {
      var t1, i, t2, t3;
      for (t1 = node.values, i = t1.length - 1, t2 = node.keys; i >= 0; --i) {
        if (i >= t1.length)
          return H.ioore(t1, i);
        t3 = t1[i];
        t3 = t3.get$processed() ? t3 : t3.accept$1(0, this);
        if (i >= t1.length)
          return H.ioore(t1, i);
        t1[i] = t3;
        if (i >= t2.length)
          return H.ioore(t2, i);
        t3 = t2[i];
        t3 = t3.get$processed() ? t3 : t3.accept$1(0, this);
        if (i >= t2.length)
          return H.ioore(t2, i);
        t2[i] = t3;
      }
      return node;
    },
    visitTypeOperator$1: function(node) {
      var t1 = node.receiver;
      node.receiver = t1.processed ? t1 : t1.accept$1(0, this);
      return node;
    },
    visitExpressionStatement$1: function(node) {
      var t1, savedEnvironment;
      t1 = node.expression;
      node.expression = t1.processed ? t1 : t1.accept$1(0, this);
      savedEnvironment = this.environment;
      this.environment = H.setRuntimeTypeInfo([], [M.Assign]);
      node.next = node.next.accept$1(0, this);
      this.environment = savedEnvironment;
      return node;
    },
    tryCollapseIf$1: function(node) {
      var changed;
      for (changed = true; changed;) {
        changed = this.tryCollapseIfAux$3(node, true, true) && true;
        if (this.tryCollapseIfAux$3(node, true, false))
          changed = true;
        if (this.tryCollapseIfAux$3(node, false, true))
          changed = true;
        if (this.tryCollapseIfAux$3(node, false, false))
          changed = true;
      }
    },
    tryCollapseIfAux$3: function(outerIf, branch1, branch2) {
      var outerThen, outerElse, innerThen, innerElse, t1, t2, t3, savedEnvironment;
      outerThen = branch1 ? outerIf.thenStatement : outerIf.elseStatement;
      outerElse = !branch1 ? outerIf.thenStatement : outerIf.elseStatement;
      if (!!J.getInterceptor(outerThen).$isIf2 && !!J.getInterceptor(outerElse).$isBreak1) {
        innerThen = branch2 ? outerThen.get$thenStatement() : outerThen.get$elseStatement();
        innerElse = !branch2 ? outerThen.get$thenStatement() : outerThen.get$elseStatement();
        t1 = J.getInterceptor(innerElse);
        if (!!t1.$isBreak1) {
          t2 = innerElse.target;
          t3 = outerElse.get$target(outerElse);
          t3 = t2 == null ? t3 == null : t2 === t3;
          t2 = t3;
        } else
          t2 = false;
        if (t2) {
          t2 = outerIf.condition;
          t2 = branch1 ? t2 : new M.Not(t2, false);
          t3 = outerThen.get$condition();
          t3 = branch2 ? t3 : new M.Not(t3, false);
          outerIf.condition = new M.LogicalOperator(t2, true, t3, false);
          outerIf.thenStatement = innerThen;
          --t1.get$target(innerElse).useCount;
          savedEnvironment = this.environment;
          t1 = [];
          t1.$builtinTypeInfo = [M.Assign];
          this.environment = t1;
          t1 = outerElse.accept$1(0, this);
          outerIf.elseStatement = t1;
          this.environment = savedEnvironment;
          return !!J.getInterceptor(t1).$isIf2 && !!J.getInterceptor(innerThen).$isBreak1;
        }
      }
      return false;
    },
    $asVisitor0: function() {
      return [M.Statement0, M.Expression0];
    },
    static: {StatementRewriter_combineStatementsWithSubexpressions: function(s, t, combine) {
        var t1, t2, t3, next;
        t1 = J.getInterceptor(s);
        if (!!t1.$isReturn2 && !!J.getInterceptor(t).$isReturn2)
          return new M.Return2(combine.call$2(t1.get$value(s), t.get$value(t)));
        if (!!t1.$isAssign)
          if (!!J.getInterceptor(t).$isAssign) {
            t2 = s.variable;
            t3 = t.variable;
            t3 = t2 == null ? t3 == null : t2 === t3;
            t2 = t3;
          } else
            t2 = false;
        else
          t2 = false;
        if (t2) {
          next = E.StatementRewriter_combineStatements(s.get$next(), t.get$next());
          if (next != null) {
            --t.get$variable().writeCount;
            t1 = s.get$variable();
            t2 = combine.call$2(s.get$definition(), t.get$definition());
            ++t1.writeCount;
            return new M.Assign(next, t1, t2, false);
          }
        }
        if (!!t1.$isExpressionStatement2 && !!J.getInterceptor(t).$isExpressionStatement2) {
          next = E.StatementRewriter_combineStatements(s.get$next(), t.get$next());
          if (next != null)
            return new M.ExpressionStatement2(next, combine.call$2(s.get$expression(), t.get$expression()));
        }
        return;
      }, StatementRewriter_combineStatements: function(s, t) {
        var t1, t2, t3, e;
        t1 = J.getInterceptor(s);
        if (!!t1.$isBreak1)
          if (!!J.getInterceptor(t).$isBreak1) {
            t2 = s.target;
            t3 = t.target;
            t3 = t2 == null ? t3 == null : t2 === t3;
            t2 = t3;
          } else
            t2 = false;
        else
          t2 = false;
        if (t2) {
          --t.get$target(t).useCount;
          return s;
        }
        if (!!t1.$isContinue1)
          if (!!J.getInterceptor(t).$isContinue1) {
            t2 = s.target;
            t3 = t.target;
            t3 = t2 == null ? t3 == null : t2 === t3;
            t2 = t3;
          } else
            t2 = false;
        else
          t2 = false;
        if (t2) {
          --t.get$target(t).useCount;
          return s;
        }
        if (!!t1.$isReturn2 && !!J.getInterceptor(t).$isReturn2) {
          e = E.StatementRewriter_combineExpressions(t1.get$value(s), t.get$value(t));
          if (e != null)
            return new M.Return2(e);
        }
        return;
      }, StatementRewriter_combineExpressions: function(e1, e2) {
        var t1 = J.getInterceptor(e1);
        if (!!t1.$isVariable && e1 === e2) {
          e1.readCount = e1.get$readCount() - 1;
          return e1;
        }
        if (!!t1.$isConstant0 && !!J.getInterceptor(e2).$isConstant0 && J.$eq(e1.value, e2.value))
          return e1;
        return;
      }}
  },
  StatementRewriter_visitIf_closure: {
    "^": "Closure:19;node_0",
    call$2: function(t, f) {
      var t1 = new M.Conditional2(this.node_0.condition, t, f, false);
      t1.processed = true;
      return t1;
    },
    $isFunction: true
  }
}],
["stringvalidator", "package:compiler/implementation/string_validator.dart", , B, {
  "^": "",
  StringValidator: {
    "^": "Object;listener",
    validateInterpolationPart$4$isFirst$isLast: function(token, quoting, isFirst, isLast) {
      var source, t1, leftQuote, rightQuote, $content;
      source = token.get$value(token);
      if (isFirst) {
        t1 = quoting.raw ? 1 : 0;
        leftQuote = t1 + quoting.leftQuoteCharCount;
      } else
        leftQuote = 0;
      if (isLast)
        rightQuote = quoting.leftQuoteCharCount > 2 ? 3 : 1;
      else
        rightQuote = 0;
      $content = J.substring$2$s(source, leftQuote, source.length - rightQuote);
      return this.validateString$4(token, token.charOffset + leftQuote, $content, quoting);
    },
    stringParseError$3: function(message, token, offset) {
      this.listener.reportFatalError$3(token, C.MessageKind_wwi, P.LinkedHashMap_LinkedHashMap$_literal(["text", message + " @ " + offset], null, null));
    },
    validateString$4: function(token, startOffset, string, quoting) {
      var t1, invalidUtf16, iter, t2, index, $length, containsEscape, previousWasLeadSurrogate, t3, result, i, code, value, count, errorPosition;
      t1 = new J._CodeUnits(string);
      iter = H.setRuntimeTypeInfo(new P.HasNextIterator(t1.get$iterator(t1), 2), [null]);
      t1 = iter._collection$_iterator;
      t2 = this.listener;
      index = startOffset;
      $length = 0;
      containsEscape = false;
      previousWasLeadSurrogate = false;
      while (true) {
        t3 = iter._collection$_state;
        if (t3 === 2)
          if (t1.moveNext$0()) {
            iter._collection$_state = 0;
            t3 = 0;
          } else {
            iter._collection$_state = 1;
            t3 = 1;
          }
        if (!(t3 === 0)) {
          invalidUtf16 = false;
          break;
        }
        c$0: {
          ++index;
          if (t3 === 2)
            if (t1.moveNext$0()) {
              iter._collection$_state = 0;
              t3 = 0;
            } else {
              iter._collection$_state = 1;
              t3 = 1;
            }
          if (t3 !== 0)
            H.throwExpression(P.StateError$("No more elements"));
          result = t1.get$current();
          if (t1.moveNext$0())
            iter._collection$_state = 0;
          else
            iter._collection$_state = 1;
          if (J.$eq(result, 92)) {
            if (quoting.raw)
              break c$0;
            t3 = iter._collection$_state;
            if (t3 === 2)
              if (t1.moveNext$0()) {
                iter._collection$_state = 0;
                t3 = 0;
              } else {
                iter._collection$_state = 1;
                t3 = 1;
              }
            if (t3 !== 0)
              t2.reportFatalError$3(token, C.MessageKind_wwi, P.LinkedHashMap_LinkedHashMap$_literal(["text", "Incomplete escape sequence @ " + index], null, null));
            ++index;
            t3 = iter._collection$_state;
            if (t3 === 2)
              if (t1.moveNext$0()) {
                iter._collection$_state = 0;
                t3 = 0;
              } else {
                iter._collection$_state = 1;
                t3 = 1;
              }
            if (t3 !== 0)
              H.throwExpression(P.StateError$("No more elements"));
            result = t1.get$current();
            if (t1.moveNext$0())
              iter._collection$_state = 0;
            else
              iter._collection$_state = 1;
            t3 = J.getInterceptor(result);
            if (t3.$eq(result, 120)) {
              for (i = 0; i < 2; ++i) {
                t3 = iter._collection$_state;
                if (t3 === 2)
                  if (t1.moveNext$0()) {
                    iter._collection$_state = 0;
                    t3 = 0;
                  } else {
                    iter._collection$_state = 1;
                    t3 = 1;
                  }
                if (t3 !== 0)
                  t2.reportFatalError$3(token, C.MessageKind_wwi, P.LinkedHashMap_LinkedHashMap$_literal(["text", "Incomplete escape sequence @ " + index], null, null));
                ++index;
                t3 = iter._collection$_state;
                if (t3 === 2)
                  if (t1.moveNext$0()) {
                    iter._collection$_state = 0;
                    t3 = 0;
                  } else {
                    iter._collection$_state = 1;
                    t3 = 1;
                  }
                if (t3 !== 0)
                  H.throwExpression(P.StateError$("No more elements"));
                result = t1.get$current();
                if (t1.moveNext$0())
                  iter._collection$_state = 0;
                else
                  iter._collection$_state = 1;
                if (!Q.isHexDigit(result))
                  t2.reportFatalError$3(token, C.MessageKind_wwi, P.LinkedHashMap_LinkedHashMap$_literal(["text", "Invalid character in escape sequence @ " + index], null, null));
              }
              containsEscape = true;
              break c$0;
            } else if (t3.$eq(result, 117)) {
              ++index;
              t3 = iter._collection$_state;
              if (t3 === 2)
                if (t1.moveNext$0()) {
                  iter._collection$_state = 0;
                  t3 = 0;
                } else {
                  iter._collection$_state = 1;
                  t3 = 1;
                }
              if (t3 === 0) {
                if (t3 === 2)
                  if (t1.moveNext$0()) {
                    iter._collection$_state = 0;
                    t3 = 0;
                  } else {
                    iter._collection$_state = 1;
                    t3 = 1;
                  }
                if (t3 !== 0)
                  H.throwExpression(P.StateError$("No more elements"));
                result = t1.get$current();
                if (t1.moveNext$0())
                  iter._collection$_state = 0;
                else
                  iter._collection$_state = 1;
                code = result;
              } else
                code = 0;
              if (J.$eq(code, 123)) {
                value = 0;
                count = 0;
                while (true) {
                  t3 = iter._collection$_state;
                  if (t3 === 2)
                    if (t1.moveNext$0()) {
                      iter._collection$_state = 0;
                      t3 = 0;
                    } else {
                      iter._collection$_state = 1;
                      t3 = 1;
                    }
                  if (!(t3 === 0))
                    break;
                  if (t3 === 2)
                    if (t1.moveNext$0()) {
                      iter._collection$_state = 0;
                      t3 = 0;
                    } else {
                      iter._collection$_state = 1;
                      t3 = 1;
                    }
                  if (t3 !== 0)
                    H.throwExpression(P.StateError$("No more elements"));
                  result = t1.get$current();
                  if (t1.moveNext$0())
                    iter._collection$_state = 0;
                  else
                    iter._collection$_state = 1;
                  ++index;
                  if (J.$eq(result, 125)) {
                    code = result;
                    break;
                  }
                  if (!Q.isHexDigit(result))
                    t2.reportFatalError$3(token, C.MessageKind_wwi, P.LinkedHashMap_LinkedHashMap$_literal(["text", "Invalid character in escape sequence @ " + index], null, null));
                  ++count;
                  value = value * 16 + Q.hexDigitValue(result);
                  code = result;
                }
                if (!J.$eq(code, 125) || count === 0 || count > 6) {
                  errorPosition = index - count;
                  t2.reportFatalError$3(token, C.MessageKind_wwi, P.LinkedHashMap_LinkedHashMap$_literal(["text", "Invalid character in escape sequence @ " + (count > 6 ? errorPosition + 6 : errorPosition)], null, null));
                }
              } else
                for (value = 0, i = 0; i < 4; ++i) {
                  if (i > 0) {
                    t3 = iter._collection$_state;
                    if (t3 === 2)
                      if (t1.moveNext$0()) {
                        iter._collection$_state = 0;
                        t3 = 0;
                      } else {
                        iter._collection$_state = 1;
                        t3 = 1;
                      }
                    if (t3 === 0) {
                      ++index;
                      if (t3 === 2)
                        if (t1.moveNext$0()) {
                          iter._collection$_state = 0;
                          t3 = 0;
                        } else {
                          iter._collection$_state = 1;
                          t3 = 1;
                        }
                      if (t3 !== 0)
                        H.throwExpression(P.StateError$("No more elements"));
                      result = t1.get$current();
                      if (t1.moveNext$0())
                        iter._collection$_state = 0;
                      else
                        iter._collection$_state = 1;
                      code = result;
                    } else
                      code = 0;
                  }
                  if (!Q.isHexDigit(code))
                    t2.reportFatalError$3(token, C.MessageKind_wwi, P.LinkedHashMap_LinkedHashMap$_literal(["text", "Invalid character in escape sequence @ " + index], null, null));
                  value = value * 16 + Q.hexDigitValue(code);
                }
              code = value;
            } else
              code = result;
            containsEscape = true;
          } else
            code = result;
          t3 = J.getInterceptor$n(code);
          if (t3.$ge(code, 65536))
            ++$length;
          if (previousWasLeadSurrogate) {
            if (!(t3.$ge(code, 56320) && t3.$le(code, 57343))) {
              invalidUtf16 = true;
              break;
            }
            previousWasLeadSurrogate = false;
          } else if (t3.$ge(code, 55296) && t3.$le(code, 56319))
            previousWasLeadSurrogate = true;
          else {
            if (!t3.$lt(code, 55296))
              t3 = t3.$gt(code, 57343) && t3.$le(code, 1114111);
            else
              t3 = true;
            if (!t3) {
              invalidUtf16 = true;
              break;
            }
            previousWasLeadSurrogate = false;
          }
        }
        ++$length;
      }
      if (previousWasLeadSurrogate || invalidUtf16) {
        this.stringParseError$3("Invalid Utf16 surrogate", token, index);
        return;
      }
      if (quoting.raw || !containsEscape)
        return new Y.RawSourceDartString(string, $length);
      return new Y.EscapedSourceDartString(null, string, $length);
    },
    static: {StringValidator_quotingFromString: function(sourceString) {
        var t1, source, quoteChar, raw, leftQuoteLength, newLineLength, code;
        t1 = J.get$codeUnits$s(sourceString);
        source = t1.get$iterator(t1);
        source.moveNext$0();
        quoteChar = source.__internal$_current;
        if (J.$eq(quoteChar, 114)) {
          source.moveNext$0();
          quoteChar = source.__internal$_current;
          raw = true;
        } else
          raw = false;
        if (source.moveNext$0() && J.$eq(source.__internal$_current, quoteChar) && source.moveNext$0()) {
          newLineLength = 1;
          while (true) {
            if (!true) {
              leftQuoteLength = 3;
              break;
            }
            c$0: {
              source.moveNext$0();
              code = source.__internal$_current;
              if (J.$eq(code, 92)) {
                ++newLineLength;
                source.moveNext$0();
                code = source.__internal$_current;
              }
              t1 = J.getInterceptor(code);
              if (t1.$eq(code, 9) || t1.$eq(code, 32)) {
                ++newLineLength;
                break c$0;
              }
              if (t1.$eq(code, 13))
                leftQuoteLength = 3 + (source.moveNext$0() && J.$eq(source.__internal$_current, 10) ? newLineLength + 1 : newLineLength);
              else
                leftQuoteLength = t1.$eq(code, 10) ? 3 + newLineLength : 3;
              break;
            }
          }
        } else
          leftQuoteLength = 1;
        return Y.StringQuoting_getQuoting(quoteChar, raw, leftQuoteLength);
      }}
  }
}],
["tracer", "package:compiler/implementation/tracer.dart", , Z, {
  "^": "",
  Tracer: {
    "^": "TracerUtil;compiler<,context,traceActive,output<,isEnabled,tracer$TracerUtil$_ind",
    traceCompilation$3: function(methodName, compilationContext, compiler) {
      var t1;
      if (!this.isEnabled)
        return;
      t1 = null.hasMatch$1(methodName);
      this.traceActive = t1;
      if (!t1)
        return;
      this.context = compilationContext;
      this.compiler = compiler;
      this.tag$2(0, "compilation", new Z.Tracer_traceCompilation_closure(this, methodName));
    },
    traceGraph$2: function($name, irObject) {
      var t1;
      if (!this.traceActive)
        return;
      t1 = J.getInterceptor(irObject);
      if (!!t1.$isHGraph)
        new K.HTracer(this.compiler, this.context, this.output, new O.Indentation(0, H.setRuntimeTypeInfo([""], [P.String]), "  ")).traceGraph$2($name, irObject);
      else if (!!t1.$isFunctionDefinition)
        new S.IRTracer(this.output, null, new O.Indentation(0, H.setRuntimeTypeInfo([""], [P.String]), "  ")).traceGraph$2($name, irObject);
      else if (!!t1.$isFunctionDefinition0)
        new Z.TreeTracer(this.output, null, null, null, new O.Indentation(0, H.setRuntimeTypeInfo([""], [P.String]), "  ")).traceGraph$2($name, irObject);
    },
    close$0: function(_) {
      var t1 = this.output;
      if (t1 != null)
        t1.close$0(0);
    }
  },
  Tracer_traceCompilation_closure: {
    "^": "Closure:23;this_0,methodName_1",
    call$0: function() {
      var t1, t2, t3, t4, t5;
      t1 = this.this_0;
      t2 = this.methodName_1;
      t3 = "name " + t1.formatPrty$1(t2);
      t4 = t1.tracer$TracerUtil$_ind;
      t5 = t1.output;
      t5.add$1(0, t4.get$indentation());
      t5.add$1(0, t3);
      t5.add$1(0, "\n");
      t2 = "method " + t1.formatPrty$1(t2);
      t5.add$1(0, t4.get$indentation());
      t5.add$1(0, t2);
      t5.add$1(0, "\n");
      t2 = Date.now();
      new P.DateTime(t2, false).DateTime$_now$0();
      t2 = "date " + t1.formatPrty$1(t2);
      t5.add$1(0, t4.get$indentation());
      t5.add$1(0, t2);
      t5.add$1(0, "\n");
    },
    $isFunction: true
  },
  TracerUtil: {
    "^": "Object;",
    tag$2: function(_, tagName, f) {
      var t1, t2, t3;
      t1 = "begin_" + tagName;
      t2 = this.tracer$TracerUtil$_ind;
      t3 = t2.get$indentation();
      this.get$output().add$1(0, t3);
      this.get$output().add$1(0, t1);
      this.get$output().add$1(0, "\n");
      ++t2._indentLevel;
      f.call$0();
      --t2._indentLevel;
      t1 = "end_" + tagName;
      t2 = t2.get$indentation();
      this.get$output().add$1(0, t2);
      this.get$output().add$1(0, t1);
      this.get$output().add$1(0, "\n");
    },
    println$1: function(string) {
      var t1 = this.tracer$TracerUtil$_ind.get$indentation();
      this.get$output().add$1(0, t1);
      this.get$output().add$1(0, string);
      this.get$output().add$1(0, "\n");
    },
    printEmptyProperty$1: function(propertyName) {
      var t1 = this.tracer$TracerUtil$_ind.get$indentation();
      this.get$output().add$1(0, t1);
      this.get$output().add$1(0, propertyName);
      this.get$output().add$1(0, "\n");
    },
    formatPrty$1: function(x) {
      var t1;
      if (typeof x === "number")
        return H.S(x);
      else if (typeof x === "string")
        return "\"" + x + "\"";
      else {
        t1 = J.getInterceptor(x);
        if (!!t1.$isIterable)
          return t1.map$1(x, new Z.TracerUtil_formatPrty_closure(this)).join$1(0, " ");
        else
          throw H.wrapException("invalid property type: " + H.S(x));
      }
    },
    printProperty$2: function(propertyName, value) {
      var t1, t2;
      t1 = propertyName + " " + this.formatPrty$1(value);
      t2 = this.tracer$TracerUtil$_ind.get$indentation();
      this.get$output().add$1(0, t2);
      this.get$output().add$1(0, t1);
      this.get$output().add$1(0, "\n");
    },
    add$1: function(_, string) {
      this.get$output().add$1(0, string);
    },
    addIndent$0: function() {
      var t1 = this.tracer$TracerUtil$_ind.get$indentation();
      this.get$output().add$1(0, t1);
    }
  },
  TracerUtil_formatPrty_closure: {
    "^": "Closure:13;this_0",
    call$1: function(s) {
      return this.this_0.formatPrty$1(s);
    },
    $isFunction: true
  }
}],
["tree", "package:compiler/implementation/tree/tree.dart", , Y, {
  "^": "",
  DartString_DartString$concat: function(first, second) {
    if (first.get$isEmpty(first))
      return second;
    if (second.get$isEmpty(second))
      return first;
    return new Y.ConsDartString(first, second, first.get$length(first) + second.get$length(second), null);
  },
  firstBeginToken: function(first, second) {
    var token = first != null ? first.getBeginToken$0() : null;
    return token == null && second != null ? second.getBeginToken$0() : token;
  },
  Initializers_isSuperConstructorCall: function(node) {
    var t1, t2;
    t1 = node.receiver;
    t2 = t1 == null;
    if (!(t2 && node.selector.isSuper$0()))
      t1 = !t2 && t1.isSuper$0() && node.selector.asIdentifier$0() != null;
    else
      t1 = true;
    return t1;
  },
  Initializers_isConstructorRedirect: function(node) {
    var t1;
    if (!(node.get$receiver() == null && node.get$selector().isThis$0()))
      t1 = node.get$receiver() != null && node.get$receiver().isThis$0() && node.get$selector().asIdentifier$0() != null;
    else
      t1 = true;
    return t1;
  },
  DartString: {
    "^": "IterableBase;",
    get$isEmpty: function(_) {
      return this.get$length(this) === 0;
    },
    $eq: function(_, other) {
      var t1, it1, it2;
      if (other == null)
        return false;
      t1 = J.getInterceptor(other);
      if (!t1.$isDartString)
        return false;
      if (this.get$length(this) !== t1.get$length(other))
        return false;
      it1 = this.get$iterator(this);
      it2 = t1.get$iterator(other);
      for (; it1.moveNext$0();) {
        if (!it2.moveNext$0())
          return false;
        if (!J.$eq(it1.get$current(), it2.get$current()))
          return false;
      }
      return true;
    },
    get$hashCode: function(_) {
      return H.throwExpression(P.UnsupportedError$("DartString.hashCode"));
    },
    toString$0: function(_) {
      return "DartString#" + this.get$length(this) + ":" + H.S(this.slowToString$0());
    },
    $isDartString: true,
    $asIterableBase: function() {
      return [P.$int];
    },
    $asIterable: function() {
      return [P.$int];
    }
  },
  LiteralDartString: {
    "^": "DartString;string<",
    get$length: function(_) {
      return this.string.length;
    },
    get$iterator: function(_) {
      var t1 = J.get$codeUnits$s(this.string);
      return t1.get$iterator(t1);
    },
    slowToString$0: function() {
      return this.string;
    },
    $isLiteralDartString: true
  },
  SourceBasedDartString: {
    "^": "DartString;source>,length>",
    $isSourceBasedDartString: true
  },
  RawSourceDartString: {
    "^": "SourceBasedDartString;source,length",
    get$iterator: function(_) {
      var t1 = new J._CodeUnits(this.source);
      return t1.get$iterator(t1);
    },
    slowToString$0: function() {
      return this.source;
    }
  },
  EscapedSourceDartString: {
    "^": "SourceBasedDartString;toStringCache,source,length",
    get$iterator: function(_) {
      var t1 = this.toStringCache;
      if (t1 != null) {
        t1.toString;
        t1 = new J._CodeUnits(t1);
        return t1.get$iterator(t1);
      }
      t1 = new J._CodeUnits(this.source);
      return new Y.StringEscapeIterator(t1.get$iterator(t1), null);
    },
    slowToString$0: function() {
      var t1, buffer, it;
      t1 = this.toStringCache;
      if (t1 != null)
        return t1;
      buffer = P.StringBuffer$("");
      t1 = new J._CodeUnits(this.source);
      it = new Y.StringEscapeIterator(t1.get$iterator(t1), null);
      for (; it.moveNext$0();) {
        t1 = H.Primitives_stringFromCharCode(it._tree$_current);
        buffer._contents += t1;
      }
      t1 = buffer._contents;
      this.toStringCache = t1;
      return t1;
    }
  },
  ConsDartString: {
    "^": "DartString;left>,right>,length>,toStringCache",
    get$iterator: function(_) {
      var t1 = this.left;
      t1 = new Y.ConsDartStringIterator(H.setRuntimeTypeInfo(new P.HasNextIterator(t1.get$iterator(t1), 2), [P.$int]), this.right, null, null);
      t1.ConsDartStringIterator$1(this);
      return t1;
    },
    slowToString$0: function() {
      var t1, t2;
      t1 = this.toStringCache;
      if (t1 != null)
        return t1;
      t1 = this.left.slowToString$0();
      t2 = this.right.slowToString$0();
      if (typeof t1 !== "string")
        return t1.$add();
      t2 = C.JSString_methods.$add(t1, t2);
      this.toStringCache = t2;
      return t2;
    },
    get$source: function(_) {
      return this.slowToString$0();
    }
  },
  ConsDartStringIterator: {
    "^": "Object;currentIterator,right>,hasNextLookAhead,_tree$_current",
    get$current: function() {
      return this._tree$_current;
    },
    moveNext$0: function() {
      if (!this.hasNextLookAhead) {
        this._tree$_current = null;
        return false;
      }
      this._tree$_current = this.currentIterator.next$0();
      var t1 = this.currentIterator.get$hasNext();
      this.hasNextLookAhead = t1;
      if (!t1)
        this.nextPart$0();
      return true;
    },
    nextPart$0: function() {
      var t1 = this.right;
      if (t1 != null) {
        t1 = H.setRuntimeTypeInfo(new P.HasNextIterator(t1.get$iterator(t1), 2), [P.$int]);
        this.currentIterator = t1;
        this.right = null;
        this.hasNextLookAhead = t1.get$hasNext();
      }
    },
    ConsDartStringIterator$1: function(cons) {
      var t1 = this.currentIterator.get$hasNext();
      this.hasNextLookAhead = t1;
      if (!t1)
        this.nextPart$0();
    }
  },
  StringEscapeIterator: {
    "^": "Object;source>,_tree$_current",
    get$current: function() {
      return this._tree$_current;
    },
    moveNext$0: function() {
      var t1, code, value, i;
      t1 = this.source;
      if (!t1.moveNext$0()) {
        this._tree$_current = null;
        return false;
      }
      code = t1.__internal$_current;
      if (!J.$eq(code, 92)) {
        this._tree$_current = code;
        return true;
      }
      t1.moveNext$0();
      code = t1.__internal$_current;
      switch (code) {
        case 110:
          this._tree$_current = 10;
          break;
        case 114:
          this._tree$_current = 13;
          break;
        case 116:
          this._tree$_current = 9;
          break;
        case 98:
          this._tree$_current = 8;
          break;
        case 102:
          this._tree$_current = 12;
          break;
        case 118:
          this._tree$_current = 11;
          break;
        case 120:
          t1.moveNext$0();
          value = Q.hexDigitValue(t1.__internal$_current);
          t1.moveNext$0();
          this._tree$_current = value * 16 + Q.hexDigitValue(t1.__internal$_current);
          break;
        case 117:
          t1.moveNext$0();
          code = t1.__internal$_current;
          if (J.$eq(code, 123)) {
            t1.moveNext$0();
            for (value = 0; !J.$eq(t1.__internal$_current, 125);) {
              value = value * 16 + Q.hexDigitValue(t1.__internal$_current);
              t1.moveNext$0();
            }
            this._tree$_current = value;
            break;
          }
          value = Q.hexDigitValue(code);
          for (i = 0; i < 3; ++i) {
            t1.moveNext$0();
            value = value * 16 + Q.hexDigitValue(t1.__internal$_current);
          }
          this._tree$_current = value;
          break;
        default:
          this._tree$_current = code;
      }
      return true;
    }
  },
  Visitor: {
    "^": "Object;",
    visitBlock$1: function(node) {
      return this.visitNode$1(node);
    },
    visitBreakStatement$1: function(node) {
      return this.visitNode$1(node);
    },
    visitCascade$1: function(node) {
      return this.visitExpression$1(node);
    },
    visitCascadeReceiver$1: function(node) {
      return this.visitExpression$1(node);
    },
    visitCaseMatch$1: function(node) {
      return this.visitNode$1(node);
    },
    visitCatchBlock$1: function(node) {
      return this.visitNode$1(node);
    },
    visitClassNode$1: function(node) {
      return this.visitNode$1(node);
    },
    visitCombinator$1: function(node) {
      return this.visitNode$1(node);
    },
    visitConditional$1: function(node) {
      return this.visitExpression$1(node);
    },
    visitContinueStatement$1: function(node) {
      return this.visitNode$1(node);
    },
    visitDoWhile$1: function(node) {
      return this.visitLoop$1(node);
    },
    visitEmptyStatement$1: function(node) {
      return this.visitNode$1(node);
    },
    visitExport$1: function(node) {
      return this.visitNode$1(node);
    },
    visitExpression$1: function(node) {
      return this.visitNode$1(node);
    },
    visitExpressionStatement$1: function(node) {
      return this.visitNode$1(node);
    },
    visitFor$1: function(node) {
      return this.visitLoop$1(node);
    },
    visitForIn$1: function(node) {
      return this.visitLoop$1(node);
    },
    visitFunctionDeclaration$1: function(node) {
      return this.visitNode$1(node);
    },
    visitFunctionExpression$1: function(node) {
      return this.visitExpression$1(node);
    },
    visitIdentifier$1: function(node) {
      return this.visitExpression$1(node);
    },
    visitIf$1: function(node) {
      return this.visitNode$1(node);
    },
    visitImport$1: function(node) {
      return this.visitNode$1(node);
    },
    visitLabel$1: function(node) {
      return this.visitNode$1(node);
    },
    visitLabeledStatement$1: function(node) {
      return this.visitNode$1(node);
    },
    visitLibraryName$1: function(node) {
      return this.visitNode$1(node);
    },
    visitLiteralBool$1: function(node) {
      return this.visitExpression$1(node);
    },
    visitLiteralDouble$1: function(node) {
      return this.visitExpression$1(node);
    },
    visitLiteralInt$1: function(node) {
      return this.visitExpression$1(node);
    },
    visitLiteralList$1: function(node) {
      return this.visitExpression$1(node);
    },
    visitLiteralMap$1: function(node) {
      return this.visitExpression$1(node);
    },
    visitLiteralMapEntry$1: function(node) {
      return this.visitNode$1(node);
    },
    visitLiteralNull$1: function(node) {
      return this.visitExpression$1(node);
    },
    visitLiteralString$1: function(node) {
      return this.visitExpression$1(node);
    },
    visitStringJuxtaposition$1: function(node) {
      return this.visitExpression$1(node);
    },
    visitLoop$1: function(node) {
      return this.visitNode$1(node);
    },
    visitMetadata$1: function(node) {
      return this.visitNode$1(node);
    },
    visitMixinApplication$1: function(node) {
      return this.visitNode$1(node);
    },
    visitModifiers$1: function(node) {
      return this.visitNode$1(node);
    },
    visitNamedArgument$1: function(node) {
      return this.visitExpression$1(node);
    },
    visitNamedMixinApplication$1: function(node) {
      return this.visitMixinApplication$1(node);
    },
    visitNewExpression$1: function(node) {
      return this.visitExpression$1(node);
    },
    visitNodeList$1: function(node) {
      return this.visitNode$1(node);
    },
    visitOperator$1: function(node) {
      return this.visitIdentifier$1(node);
    },
    visitParenthesizedExpression$1: function(node) {
      return this.visitExpression$1(node);
    },
    visitPart$1: function(node) {
      return this.visitNode$1(node);
    },
    visitPartOf$1: function(node) {
      return this.visitNode$1(node);
    },
    visitPostfix$1: function(node) {
      return this.visitNodeList$1(node);
    },
    visitPrefix$1: function(node) {
      return this.visitNodeList$1(node);
    },
    visitRedirectingFactoryBody$1: function(node) {
      return this.visitNode$1(node);
    },
    visitRethrow$1: function(node) {
      return this.visitNode$1(node);
    },
    visitReturn$1: function(node) {
      return this.visitNode$1(node);
    },
    visitSend$1: function(node) {
      return this.visitExpression$1(node);
    },
    visitSendSet$1: function(node) {
      return this.visitSend$1(node);
    },
    visitStringInterpolation$1: function(node) {
      return this.visitExpression$1(node);
    },
    visitStringInterpolationPart$1: function(node) {
      return this.visitNode$1(node);
    },
    visitSwitchCase$1: function(node) {
      return this.visitNode$1(node);
    },
    visitSwitchStatement$1: function(node) {
      return this.visitNode$1(node);
    },
    visitLiteralSymbol$1: function(node) {
      return this.visitExpression$1(node);
    },
    visitThrow$1: function(node) {
      return this.visitExpression$1(node);
    },
    visitTryStatement$1: function(node) {
      return this.visitNode$1(node);
    },
    visitTypeAnnotation$1: function(node) {
      return this.visitNode$1(node);
    },
    visitTypedef$1: function(node) {
      return this.visitNode$1(node);
    },
    visitTypeVariable$1: function(node) {
      return this.visitNode$1(node);
    },
    visitVariableDefinitions$1: function(node) {
      return this.visitNode$1(node);
    },
    visitWhile$1: function(node) {
      return this.visitLoop$1(node);
    }
  },
  Node: {
    "^": "NullTreeElementMixin;hashCode>",
    toString$0: function(_) {
      var t1 = P.StringBuffer$("");
      new Y.Unparser(t1, true, false, true, 0, H.setRuntimeTypeInfo([""], [P.String]), "  ").visit$1(this);
      return t1._contents;
    },
    asBlock$0: function() {
      return;
    },
    asCascadeReceiver$0: function() {
      return;
    },
    asCaseMatch$0: function() {
      return;
    },
    asDoWhile$0: function() {
      return;
    },
    asEmptyStatement$0: function() {
      return;
    },
    asExpression$0: function() {
      return;
    },
    asExpressionStatement$0: function() {
      return;
    },
    asForIn$0: function() {
      return;
    },
    asFunctionExpression$0: function() {
      return;
    },
    asIdentifier$0: function() {
      return;
    },
    asImport$0: function() {
      return;
    },
    asLabel$0: function() {
      return;
    },
    asLiteralInt$0: function() {
      return;
    },
    asLiteralString$0: function() {
      return;
    },
    asMixinApplication$0: function() {
      return;
    },
    asNamedArgument$0: function() {
      return;
    },
    asNamedMixinApplication$0: function() {
      return;
    },
    asNewExpression$0: function() {
      return;
    },
    asNodeList$0: function() {
      return;
    },
    asOperator$0: function() {
      return;
    },
    asParenthesizedExpression$0: function() {
      return;
    },
    asRedirectingFactoryBody$0: function() {
      return;
    },
    asSend$0: function() {
      return;
    },
    asSendSet$0: function() {
      return;
    },
    asThrow$0: function() {
      return;
    },
    asVariableDefinitions$0: function() {
      return;
    },
    isValidBreakTarget$0: function() {
      return false;
    },
    isValidContinueTarget$0: function() {
      return false;
    },
    isThis$0: function() {
      return false;
    },
    isSuper$0: function() {
      return false;
    },
    get$isErroneous: function() {
      return false;
    },
    $isNode: true
  },
  ClassNode: {
    "^": "Node;modifiers<,name>,superclass<,interfaces,typeParameters<,body>,beginToken<,extendsKeyword,endToken,hashCode",
    accept$1: function(_, visitor) {
      return visitor.visitClassNode$1(this);
    },
    visitChildren$1: function(visitor) {
      var t1 = this.name;
      if (t1 != null)
        t1.accept$1(0, visitor);
      t1 = this.typeParameters;
      if (t1 != null) {
        t1.toString;
        visitor.visitNodeList$1(t1);
      }
      t1 = this.superclass;
      if (t1 != null)
        t1.accept$1(0, visitor);
      visitor.visitNodeList$1(this.interfaces);
      t1 = this.body;
      if (t1 != null) {
        t1.toString;
        visitor.visitNodeList$1(t1);
      }
    },
    getBeginToken$0: function() {
      return this.beginToken;
    },
    getEndToken$0: function() {
      return this.endToken;
    },
    $isClassNode: true
  },
  MixinApplication: {
    "^": "Node;superclass<,mixins<,hashCode",
    asMixinApplication$0: function() {
      return this;
    },
    accept$1: function(_, visitor) {
      return visitor.visitMixinApplication$1(this);
    },
    visitChildren$1: function(visitor) {
      var t1 = this.superclass;
      if (t1 != null) {
        t1.toString;
        visitor.visitTypeAnnotation$1(t1);
      }
      t1 = this.mixins;
      if (t1 != null) {
        t1.toString;
        visitor.visitNodeList$1(t1);
      }
    },
    getBeginToken$0: function() {
      return this.superclass.typeName.getBeginToken$0();
    },
    getEndToken$0: function() {
      return this.mixins.getEndToken$0();
    }
  },
  NamedMixinApplication: {
    "^": "Node;name>,typeParameters,modifiers<,mixinApplication,interfaces,classKeyword,endToken,hashCode",
    get$superclass: function() {
      return this.mixinApplication.get$superclass();
    },
    get$mixins: function() {
      return this.mixinApplication.get$mixins();
    },
    asMixinApplication$0: function() {
      return this;
    },
    asNamedMixinApplication$0: function() {
      return this;
    },
    accept$1: function(_, visitor) {
      return visitor.visitNamedMixinApplication$1(this);
    },
    visitChildren$1: function(visitor) {
      var t1;
      this.name.accept$1(0, visitor);
      t1 = this.typeParameters;
      if (t1 != null) {
        t1.toString;
        visitor.visitNodeList$1(t1);
      }
      t1 = this.modifiers;
      if (t1 != null) {
        t1.toString;
        visitor.visitModifiers$1(t1);
      }
      t1 = this.interfaces;
      if (t1 != null) {
        t1.toString;
        visitor.visitNodeList$1(t1);
      }
      this.mixinApplication.accept$1(0, visitor);
    },
    getBeginToken$0: function() {
      return this.classKeyword;
    },
    getEndToken$0: function() {
      return this.endToken;
    },
    $isNamedMixinApplication: true,
    $isNode: true
  },
  Expression2: {
    "^": "Node;",
    asExpression$0: function() {
      return this;
    }
  },
  Statement2: {
    "^": "Node;",
    isValidBreakTarget$0: function() {
      return true;
    }
  },
  ErrorExpression: {
    "^": "LiteralNull0;token,handler,hashCode",
    get$isErroneous: function() {
      return true;
    }
  },
  Send: {
    "^": "Expression_StoredTreeElementMixin;receiver<,selector<,argumentsNode<,secret_tree_element$StoredTreeElementMixin$_secret_tree_element$_element,hashCode",
    get$arguments: function() {
      return this.argumentsNode.nodes;
    },
    asSend$0: function() {
      return this;
    },
    accept$1: function(_, visitor) {
      return visitor.visitSend$1(this);
    },
    visitChildren$1: function(visitor) {
      var t1 = this.receiver;
      if (t1 != null)
        t1.accept$1(0, visitor);
      t1 = this.selector;
      if (t1 != null)
        t1.accept$1(0, visitor);
      t1 = this.argumentsNode;
      if (t1 != null) {
        t1.toString;
        visitor.visitNodeList$1(t1);
      }
    },
    argumentCount$0: [function() {
      var t1 = this.argumentsNode;
      return t1 == null ? -1 : t1.slowLength$0();
    }, "call$0", "get$argumentCount", 0, 0, 78],
    get$typeAnnotationFromIsCheckOrCast: function() {
      var t1, t2;
      t1 = this.selector;
      if (!!J.getInterceptor(t1).$isOperator) {
        t1 = t1.asOperator$0().token;
        t1 = t1.get$value(t1) === "is";
      } else
        t1 = false;
      if (t1) {
        t1 = this.argumentsNode.nodes;
        t1 = t1.get$head(t1).asSend$0() != null;
      } else
        t1 = false;
      t2 = this.argumentsNode;
      if (t1) {
        t1 = t2.nodes;
        t1 = t1.get$head(t1).asSend$0().receiver;
      } else {
        t1 = t2.nodes;
        t1 = t1.get$head(t1);
      }
      return t1;
    },
    getBeginToken$0: function() {
      if (!!J.getInterceptor(this.argumentsNode).$isPrefix0) {
        var t1 = this.selector;
        if (!!J.getInterceptor(t1).$isOperator) {
          t1 = t1.asOperator$0().token;
          t1 = t1.get$value(t1) === "[]";
        } else
          t1 = false;
        t1 = !t1;
      } else
        t1 = false;
      if (t1)
        return this.selector.getBeginToken$0();
      return Y.firstBeginToken(this.receiver, this.selector);
    },
    getEndToken$0: function() {
      var t1, t2, token;
      t1 = this.argumentsNode;
      t2 = J.getInterceptor(t1);
      if (!!t2.$isPrefix0) {
        t1 = this.receiver;
        if (t1 != null)
          return t1.getEndToken$0();
        t1 = this.selector;
        if (t1 != null)
          return t1.getEndToken$0();
        return;
      }
      if (!t2.$isPostfix0 && t1 != null) {
        token = t1.getEndToken$0();
        if (token != null)
          return token;
      }
      t1 = this.selector;
      if (t1 != null)
        return t1.getEndToken$0();
      return this.getBeginToken$0();
    },
    copyWithReceiver$1: function(newReceiver) {
      var t1 = $.Node__HASH_COUNTER + 1;
      $.Node__HASH_COUNTER = t1;
      return new Y.Send(newReceiver, this.selector, this.argumentsNode, null, t1);
    },
    $isSend: true
  },
  Expression_StoredTreeElementMixin: {
    "^": "Expression2+StoredTreeElementMixin;_secret_tree_element$_element:secret_tree_element$StoredTreeElementMixin$_secret_tree_element$_element@"
  },
  Postfix0: {
    "^": "NodeList;nodes,beginToken,endToken,delimiter,hashCode",
    $isPostfix0: true
  },
  Prefix0: {
    "^": "NodeList;nodes,beginToken,endToken,delimiter,hashCode",
    $isPrefix0: true
  },
  SendSet: {
    "^": "Send;assignmentOperator<,receiver,selector,argumentsNode,secret_tree_element$StoredTreeElementMixin$_secret_tree_element$_element,hashCode",
    asSendSet$0: function() {
      return this;
    },
    accept$1: function(_, visitor) {
      return visitor.visitSendSet$1(this);
    },
    visitChildren$1: function(visitor) {
      Y.Send.prototype.visitChildren$1.call(this, visitor);
      visitor.visitOperator$1(this.assignmentOperator);
    },
    copyWithReceiver$1: function(newReceiver) {
      var t1 = $.Node__HASH_COUNTER + 1;
      $.Node__HASH_COUNTER = t1;
      return new Y.SendSet(this.assignmentOperator, newReceiver, this.selector, this.argumentsNode, null, t1);
    },
    getBeginToken$0: function() {
      if (!!J.getInterceptor(this.argumentsNode).$isPrefix0)
        return this.assignmentOperator.token;
      return Y.Send.prototype.getBeginToken$0.call(this);
    },
    getEndToken$0: function() {
      if (!!J.getInterceptor(this.argumentsNode).$isPostfix0)
        return this.assignmentOperator.token;
      return Y.Send.prototype.getEndToken$0.call(this);
    },
    $isSendSet: true
  },
  NewExpression: {
    "^": "Expression2;newToken,send,hashCode",
    send$1: function($receiver, arg0) {
      return this.send.call$1(arg0);
    },
    asNewExpression$0: function() {
      return this;
    },
    accept$1: function(_, visitor) {
      return visitor.visitNewExpression$1(this);
    },
    visitChildren$1: function(visitor) {
      visitor.visitSend$1(this.send);
    },
    get$isConst: function() {
      var t1 = this.newToken;
      return t1 == null || t1.get$stringValue() === "const";
    },
    getBeginToken$0: function() {
      var t1 = this.newToken;
      return t1 != null ? t1 : this.send.getBeginToken$0();
    },
    getEndToken$0: function() {
      return this.send.getEndToken$0();
    }
  },
  NodeList: {
    "^": "Node;nodes>,beginToken<,endToken,delimiter,hashCode",
    get$isEmpty: function(_) {
      var t1 = this.nodes;
      return t1.get$isEmpty(t1);
    },
    get$iterator: function(_) {
      var t1 = this.nodes;
      t1.toString;
      return H.setRuntimeTypeInfo(new E.LinkIterator(null, t1), [H.getTypeArgumentByIndex(t1, 0)]);
    },
    asNodeList$0: function() {
      return this;
    },
    slowLength$0: function() {
      var cursor, result;
      for (cursor = this.nodes, result = 0; !cursor.get$isEmpty(cursor); cursor = cursor.get$tail())
        ++result;
      return result;
    },
    accept$1: function(_, visitor) {
      return visitor.visitNodeList$1(this);
    },
    visitChildren$1: function(visitor) {
      var link = this.nodes;
      if (link == null)
        return;
      for (; !link.get$isEmpty(link); link = link.get$tail())
        if (link.get$head(link) != null)
          J.accept$1$x(link.get$head(link), visitor);
    },
    getBeginToken$0: function() {
      var t1, link;
      t1 = this.beginToken;
      if (t1 != null)
        return t1;
      link = this.nodes;
      if (link != null)
        for (; !link.get$isEmpty(link); link = link.get$tail()) {
          if (link.get$head(link).getBeginToken$0() != null)
            return link.get$head(link).getBeginToken$0();
          if (link.get$head(link).getEndToken$0() != null)
            return link.get$head(link).getEndToken$0();
        }
      return this.endToken;
    },
    getEndToken$0: function() {
      var t1, link, lastNode;
      t1 = this.endToken;
      if (t1 != null)
        return t1;
      link = this.nodes;
      if (link != null) {
        if (link.get$isEmpty(link))
          return this.beginToken;
        for (; t1 = link.get$tail(), !t1.get$isEmpty(t1);)
          link = link.get$tail();
        lastNode = link.get$head(link);
        if (lastNode != null) {
          if (lastNode.getEndToken$0() != null)
            return lastNode.getEndToken$0();
          if (lastNode.getBeginToken$0() != null)
            return lastNode.getBeginToken$0();
        }
      }
      return this.beginToken;
    },
    $isNodeList: true
  },
  Block0: {
    "^": "Statement2;statements,hashCode",
    asBlock$0: function() {
      return this;
    },
    accept$1: function(_, visitor) {
      return visitor.visitBlock$1(this);
    },
    visitChildren$1: function(visitor) {
      visitor.visitNodeList$1(this.statements);
    },
    getBeginToken$0: function() {
      return this.statements.getBeginToken$0();
    },
    getEndToken$0: function() {
      return this.statements.getEndToken$0();
    },
    $isBlock0: true
  },
  If0: {
    "^": "Statement2;condition<,thenPart<,elsePart<,ifToken<,elseToken,hashCode",
    accept$1: function(_, visitor) {
      return visitor.visitIf$1(this);
    },
    visitChildren$1: function(visitor) {
      var t1 = this.condition;
      if (t1 != null) {
        t1.toString;
        visitor.visitParenthesizedExpression$1(t1);
      }
      t1 = this.thenPart;
      if (t1 != null)
        t1.accept$1(0, visitor);
      t1 = this.elsePart;
      if (t1 != null)
        t1.accept$1(0, visitor);
    },
    getBeginToken$0: function() {
      return this.ifToken;
    },
    getEndToken$0: function() {
      var t1 = this.elsePart;
      if (t1 == null)
        return this.thenPart.getEndToken$0();
      return t1.getEndToken$0();
    }
  },
  Conditional0: {
    "^": "Expression2;condition,thenExpression,elseExpression,questionToken,colonToken,hashCode",
    accept$1: function(_, visitor) {
      return visitor.visitConditional$1(this);
    },
    visitChildren$1: function(visitor) {
      this.condition.accept$1(0, visitor);
      this.thenExpression.accept$1(0, visitor);
      this.elseExpression.accept$1(0, visitor);
    },
    getBeginToken$0: function() {
      return this.condition.getBeginToken$0();
    },
    getEndToken$0: function() {
      return this.elseExpression.getEndToken$0();
    }
  },
  For0: {
    "^": "Loop;initializer<,conditionStatement,update,forToken<,body,hashCode",
    get$condition: function() {
      var t1 = this.conditionStatement;
      if (!!J.getInterceptor(t1).$isExpressionStatement0)
        return t1.asExpressionStatement$0().expression;
      else
        return;
    },
    accept$1: function(_, visitor) {
      return visitor.visitFor$1(this);
    },
    visitChildren$1: function(visitor) {
      var t1 = this.initializer;
      if (t1 != null)
        t1.accept$1(0, visitor);
      t1 = this.conditionStatement;
      if (t1 != null)
        t1.accept$1(0, visitor);
      visitor.visitNodeList$1(this.update);
      t1 = this.body;
      if (t1 != null)
        t1.accept$1(0, visitor);
    },
    getBeginToken$0: function() {
      return this.forToken;
    },
    getEndToken$0: function() {
      return this.body.getEndToken$0();
    }
  },
  FunctionDeclaration0: {
    "^": "Statement2;$function<,hashCode",
    accept$1: function(_, visitor) {
      return visitor.visitFunctionDeclaration$1(this);
    },
    visitChildren$1: function(visitor) {
      return this.$function.accept$1(0, visitor);
    },
    getBeginToken$0: function() {
      return this.$function.getBeginToken$0();
    },
    getEndToken$0: function() {
      return this.$function.getEndToken$0();
    }
  },
  FunctionExpression: {
    "^": "Expression_StoredTreeElementMixin0;name>,parameters<,body>,returnType<,modifiers<,initializers<,getOrSet,secret_tree_element$StoredTreeElementMixin$_secret_tree_element$_element,hashCode",
    asFunctionExpression$0: function() {
      return this;
    },
    accept$1: function(_, visitor) {
      return visitor.visitFunctionExpression$1(this);
    },
    get$isRedirectingFactory: function() {
      var t1 = this.body;
      return t1 != null && t1.asRedirectingFactoryBody$0() != null;
    },
    visitChildren$1: function(visitor) {
      var t1 = this.modifiers;
      if (t1 != null) {
        t1.toString;
        visitor.visitModifiers$1(t1);
      }
      t1 = this.returnType;
      if (t1 != null) {
        t1.toString;
        visitor.visitTypeAnnotation$1(t1);
      }
      t1 = this.name;
      if (t1 != null)
        t1.accept$1(0, visitor);
      t1 = this.parameters;
      if (t1 != null) {
        t1.toString;
        visitor.visitNodeList$1(t1);
      }
      t1 = this.initializers;
      if (t1 != null) {
        t1.toString;
        visitor.visitNodeList$1(t1);
      }
      t1 = this.body;
      if (t1 != null)
        t1.accept$1(0, visitor);
    },
    hasBody$0: function() {
      return this.body.asEmptyStatement$0() == null;
    },
    hasEmptyBody$0: function() {
      var block, t1;
      block = this.body.asBlock$0();
      if (block == null)
        return false;
      t1 = block.statements.nodes;
      return t1.get$isEmpty(t1);
    },
    getBeginToken$0: function() {
      var token, t1;
      token = Y.firstBeginToken(this.modifiers, this.returnType);
      if (token != null)
        return token;
      t1 = this.getOrSet;
      if (t1 != null)
        return t1;
      return Y.firstBeginToken(this.name, this.parameters);
    },
    getEndToken$0: function() {
      var t1, token;
      t1 = this.body;
      token = t1 == null ? null : t1.getEndToken$0();
      if (token == null)
        token = this.parameters.getEndToken$0();
      return token == null ? this.name.getEndToken$0() : token;
    },
    $isFunctionExpression: true
  },
  Expression_StoredTreeElementMixin0: {
    "^": "Expression2+StoredTreeElementMixin;_secret_tree_element$_element:secret_tree_element$StoredTreeElementMixin$_secret_tree_element$_element@"
  },
  Literal1: {
    "^": "Expression2;token<",
    visitChildren$1: function(visitor) {
    },
    getBeginToken$0: function() {
      return this.token;
    },
    getEndToken$0: function() {
      return this.token;
    }
  },
  LiteralInt: {
    "^": "Literal1;token,handler,hashCode",
    asLiteralInt$0: function() {
      return this;
    },
    get$value: function(_) {
      var valueToken, ex, t1, exception;
      try {
        valueToken = this.token;
        if (valueToken.get$info().kind === 43)
          valueToken = valueToken.get$next();
        t1 = H.Primitives_parseInt(J.get$value$x(valueToken), null, null);
        return t1;
      } catch (exception) {
        t1 = H.unwrapException(exception);
        if (!!J.getInterceptor(t1).$isFormatException) {
          ex = t1;
          this.handler.call$2(this.token, ex);
        } else
          throw exception;
      }

    },
    accept$1: function(_, visitor) {
      return visitor.visitLiteralInt$1(this);
    },
    $asLiteral1: function() {
      return [P.$int];
    }
  },
  LiteralDouble: {
    "^": "Literal1;token,handler,hashCode",
    get$value: function(_) {
      var valueToken, ex, t1, exception;
      try {
        valueToken = this.token;
        if (valueToken.get$info().kind === 43)
          valueToken = valueToken.get$next();
        t1 = H.Primitives_parseDouble(J.get$value$x(valueToken), null);
        return t1;
      } catch (exception) {
        t1 = H.unwrapException(exception);
        if (!!J.getInterceptor(t1).$isFormatException) {
          ex = t1;
          this.handler.call$2(this.token, ex);
        } else
          throw exception;
      }

    },
    accept$1: function(_, visitor) {
      return visitor.visitLiteralDouble$1(this);
    },
    $asLiteral1: function() {
      return [P.$double];
    }
  },
  LiteralBool0: {
    "^": "Literal1;token,handler,hashCode",
    get$value: function(_) {
      var t1 = this.token;
      if (t1.get$stringValue() === "true")
        return true;
      if (t1.get$stringValue() === "false")
        return false;
      this.handler.call$2(t1, "not a bool " + H.S(t1.get$value(t1)));
      throw H.wrapException(false);
    },
    accept$1: function(_, visitor) {
      return visitor.visitLiteralBool$1(this);
    },
    $asLiteral1: function() {
      return [P.bool];
    }
  },
  StringQuoting: {
    "^": "Object;raw<,leftQuoteCharCount,quote",
    static: {"^": "StringQuoting__mapping", StringQuoting_getQuoting: function(quote, raw, leftQuoteLength) {
        var quoteKindOffset, rawOffset, index;
        quoteKindOffset = quote === 34 ? 2 : 0;
        rawOffset = raw ? 1 : 0;
        index = (leftQuoteLength - 1) * 4 + rawOffset + quoteKindOffset;
        if (index < 24) {
          if (index < 0)
            return H.ioore(C.List_BmO, index);
          return C.List_BmO[index];
        }
        return new Y.StringQuoting(raw, leftQuoteLength, quote);
      }}
  },
  StringNode: {
    "^": "Expression2;",
    $isStringNode: true
  },
  LiteralString: {
    "^": "StringNode;token<,dartString<,hashCode",
    asLiteralString$0: function() {
      return this;
    },
    visitChildren$1: function(visitor) {
    },
    get$isInterpolation: function() {
      return false;
    },
    getBeginToken$0: function() {
      return this.token;
    },
    getEndToken$0: function() {
      return this.token;
    },
    accept$1: function(_, visitor) {
      return visitor.visitLiteralString$1(this);
    }
  },
  LiteralNull0: {
    "^": "Literal1;token,handler,hashCode",
    get$value: function(_) {
      return;
    },
    accept$1: function(_, visitor) {
      return visitor.visitLiteralNull$1(this);
    },
    $asLiteral1: function() {
      return [P.String];
    }
  },
  LiteralList: {
    "^": "Expression2;typeArguments<,elements>,constKeyword<,hashCode",
    get$isConst: function() {
      return this.constKeyword != null;
    },
    accept$1: function(_, visitor) {
      return visitor.visitLiteralList$1(this);
    },
    visitChildren$1: function(visitor) {
      var t1 = this.typeArguments;
      if (t1 != null) {
        t1.toString;
        visitor.visitNodeList$1(t1);
      }
      visitor.visitNodeList$1(this.elements);
    },
    getBeginToken$0: function() {
      var t1 = this.constKeyword;
      if (t1 != null)
        return t1;
      return Y.firstBeginToken(this.typeArguments, this.elements);
    },
    getEndToken$0: function() {
      return this.elements.getEndToken$0();
    }
  },
  LiteralSymbol: {
    "^": "Expression2;hashToken,identifiers,hashCode",
    visitChildren$1: function(visitor) {
      visitor.visitNodeList$1(this.identifiers);
    },
    accept$1: function(_, visitor) {
      return visitor.visitLiteralSymbol$1(this);
    },
    getBeginToken$0: function() {
      return this.hashToken;
    },
    getEndToken$0: function() {
      return this.identifiers.getEndToken$0();
    },
    get$slowNameString: function() {
      var t1 = P.StringBuffer$("");
      new Y.Unparser(t1, true, false, true, 0, H.setRuntimeTypeInfo([""], [P.String]), "  ").unparseNodeListOfIdentifiers$1(this.identifiers);
      return t1._contents;
    }
  },
  Identifier: {
    "^": "Expression_StoredTreeElementMixin1;token<,secret_tree_element$StoredTreeElementMixin$_secret_tree_element$_element,hashCode",
    get$source: function(_) {
      var t1 = this.token;
      return t1.get$value(t1);
    },
    isThis$0: function() {
      var t1 = this.token;
      return t1.get$value(t1) === "this";
    },
    isSuper$0: function() {
      var t1 = this.token;
      return t1.get$value(t1) === "super";
    },
    asIdentifier$0: function() {
      return this;
    },
    accept$1: function(_, visitor) {
      return visitor.visitIdentifier$1(this);
    },
    visitChildren$1: function(visitor) {
    },
    getBeginToken$0: function() {
      return this.token;
    },
    getEndToken$0: function() {
      return this.token;
    },
    $isIdentifier: true
  },
  Expression_StoredTreeElementMixin1: {
    "^": "Expression2+StoredTreeElementMixin;_secret_tree_element$_element:secret_tree_element$StoredTreeElementMixin$_secret_tree_element$_element@"
  },
  Operator: {
    "^": "Identifier;token,secret_tree_element$StoredTreeElementMixin$_secret_tree_element$_element,hashCode",
    asOperator$0: function() {
      return this;
    },
    accept$1: function(_, visitor) {
      return visitor.visitOperator$1(this);
    },
    $isOperator: true,
    static: {"^": "Operator_COMPLEX_OPERATORS,Operator_INCREMENT_OPERATORS"}
  },
  Return0: {
    "^": "Statement2;expression<,beginToken<,endToken,hashCode",
    accept$1: function(_, visitor) {
      return visitor.visitReturn$1(this);
    },
    visitChildren$1: function(visitor) {
      var t1 = this.expression;
      if (t1 != null)
        t1.accept$1(0, visitor);
    },
    getBeginToken$0: function() {
      return this.beginToken;
    },
    getEndToken$0: function() {
      var t1 = this.endToken;
      if (t1 == null)
        return this.expression.getEndToken$0();
      return t1;
    }
  },
  RedirectingFactoryBody: {
    "^": "Statement_StoredTreeElementMixin;constructorReference,beginToken<,endToken,secret_tree_element$StoredTreeElementMixin$_secret_tree_element$_element,hashCode",
    asRedirectingFactoryBody$0: function() {
      return this;
    },
    accept$1: function(_, visitor) {
      return visitor.visitRedirectingFactoryBody$1(this);
    },
    visitChildren$1: function(visitor) {
      this.constructorReference.accept$1(0, visitor);
    },
    getBeginToken$0: function() {
      return this.beginToken;
    },
    getEndToken$0: function() {
      return this.endToken;
    }
  },
  Statement_StoredTreeElementMixin: {
    "^": "Statement2+StoredTreeElementMixin;_secret_tree_element$_element:secret_tree_element$StoredTreeElementMixin$_secret_tree_element$_element@"
  },
  ExpressionStatement0: {
    "^": "Statement2;expression<,endToken,hashCode",
    asExpressionStatement$0: function() {
      return this;
    },
    accept$1: function(_, visitor) {
      return visitor.visitExpressionStatement$1(this);
    },
    visitChildren$1: function(visitor) {
      var t1 = this.expression;
      if (t1 != null)
        t1.accept$1(0, visitor);
    },
    getBeginToken$0: function() {
      return this.expression.getBeginToken$0();
    },
    getEndToken$0: function() {
      return this.endToken;
    },
    $isExpressionStatement0: true
  },
  Throw0: {
    "^": "Expression2;expression<,throwToken<,endToken,hashCode",
    asThrow$0: function() {
      return this;
    },
    accept$1: function(_, visitor) {
      return visitor.visitThrow$1(this);
    },
    visitChildren$1: function(visitor) {
      this.expression.accept$1(0, visitor);
    },
    getBeginToken$0: function() {
      return this.throwToken;
    },
    getEndToken$0: function() {
      return this.endToken;
    }
  },
  Rethrow: {
    "^": "Statement2;throwToken,endToken,hashCode",
    accept$1: function(_, visitor) {
      return visitor.visitRethrow$1(this);
    },
    visitChildren$1: function(visitor) {
    },
    getBeginToken$0: function() {
      return this.throwToken;
    },
    getEndToken$0: function() {
      return this.endToken;
    }
  },
  TypeAnnotation: {
    "^": "Node;typeName<,typeArguments<,hashCode",
    accept$1: function(_, visitor) {
      return visitor.visitTypeAnnotation$1(this);
    },
    visitChildren$1: function(visitor) {
      var t1;
      this.typeName.accept$1(0, visitor);
      t1 = this.typeArguments;
      if (t1 != null) {
        t1.toString;
        visitor.visitNodeList$1(t1);
      }
    },
    getBeginToken$0: function() {
      return this.typeName.getBeginToken$0();
    },
    getEndToken$0: function() {
      return this.typeName.getEndToken$0();
    },
    $isTypeAnnotation: true
  },
  TypeVariable: {
    "^": "Node;name>,bound<,hashCode",
    accept$1: function(_, visitor) {
      return visitor.visitTypeVariable$1(this);
    },
    visitChildren$1: function(visitor) {
      var t1;
      this.name.accept$1(0, visitor);
      t1 = this.bound;
      if (t1 != null) {
        t1.toString;
        visitor.visitTypeAnnotation$1(t1);
      }
    },
    getBeginToken$0: function() {
      return this.name.token;
    },
    getEndToken$0: function() {
      var t1 = this.bound;
      return t1 != null ? t1.typeName.getEndToken$0() : this.name.token;
    }
  },
  VariableDefinitions: {
    "^": "Statement2;metadata<,type>,modifiers<,definitions<,hashCode",
    asVariableDefinitions$0: function() {
      return this;
    },
    accept$1: function(_, visitor) {
      return visitor.visitVariableDefinitions$1(this);
    },
    visitChildren$1: function(visitor) {
      var t1 = this.type;
      if (t1 != null) {
        t1.toString;
        visitor.visitTypeAnnotation$1(t1);
      }
      visitor.visitNodeList$1(this.definitions);
    },
    getBeginToken$0: function() {
      var token = Y.firstBeginToken(this.modifiers, this.type);
      return token == null ? this.definitions.getBeginToken$0() : token;
    },
    getEndToken$0: function() {
      return this.definitions.getEndToken$0();
    },
    $isVariableDefinitions: true
  },
  Loop: {
    "^": "Statement2;body>",
    isValidContinueTarget$0: function() {
      return true;
    },
    $isLoop: true
  },
  DoWhile: {
    "^": "Loop;doKeyword,whileKeyword,endToken,condition,body,hashCode",
    asDoWhile$0: function() {
      return this;
    },
    accept$1: function(_, visitor) {
      return visitor.visitDoWhile$1(this);
    },
    visitChildren$1: function(visitor) {
      var t1 = this.condition;
      if (t1 != null)
        t1.accept$1(0, visitor);
      t1 = this.body;
      if (t1 != null)
        t1.accept$1(0, visitor);
    },
    getBeginToken$0: function() {
      return this.doKeyword;
    },
    getEndToken$0: function() {
      return this.endToken;
    }
  },
  While: {
    "^": "Loop;whileKeyword,condition,body,hashCode",
    accept$1: function(_, visitor) {
      return visitor.visitWhile$1(this);
    },
    visitChildren$1: function(visitor) {
      var t1 = this.condition;
      if (t1 != null)
        t1.accept$1(0, visitor);
      t1 = this.body;
      if (t1 != null)
        t1.accept$1(0, visitor);
    },
    getBeginToken$0: function() {
      return this.whileKeyword;
    },
    getEndToken$0: function() {
      return this.body.getEndToken$0();
    }
  },
  ParenthesizedExpression: {
    "^": "Expression2;expression<,beginToken<,hashCode",
    asParenthesizedExpression$0: function() {
      return this;
    },
    accept$1: function(_, visitor) {
      return visitor.visitParenthesizedExpression$1(this);
    },
    visitChildren$1: function(visitor) {
      var t1 = this.expression;
      if (t1 != null)
        t1.accept$1(0, visitor);
    },
    getBeginToken$0: function() {
      return this.beginToken;
    },
    getEndToken$0: function() {
      return this.beginToken.endGroup;
    }
  },
  Modifiers: {
    "^": "Node;nodes>,flags<,hashCode",
    findModifier$1: function(modifier) {
      var nodeList, t1;
      nodeList = this.nodes.nodes;
      for (; !nodeList.get$isEmpty(nodeList); nodeList = nodeList.get$tail()) {
        t1 = nodeList.get$head(nodeList).asIdentifier$0().token;
        if (t1.get$value(t1) === modifier)
          return nodeList.get$head(nodeList);
      }
      return;
    },
    getBeginToken$0: function() {
      return this.nodes.getBeginToken$0();
    },
    getEndToken$0: function() {
      return this.nodes.getEndToken$0();
    },
    accept$1: function(_, visitor) {
      return visitor.visitModifiers$1(this);
    },
    visitChildren$1: function(visitor) {
      var t1 = this.nodes;
      t1.toString;
      return visitor.visitNodeList$1(t1);
    },
    get$isStatic: function() {
      return (this.flags & 1) !== 0;
    },
    get$isAbstract: function() {
      return (this.flags & 2) !== 0;
    },
    get$isFinal: function() {
      return (this.flags & 4) !== 0;
    },
    get$isConst: function() {
      return (this.flags & 16) !== 0;
    },
    toString$0: function(_) {
      var t1, builder, buffer;
      t1 = this.flags;
      builder = H.setRuntimeTypeInfo(new E.LinkBuilderImplementation(null, null, 0), [null]);
      if ((t1 & 1) !== 0)
        builder.addLast$1("static");
      if ((t1 & 2) !== 0)
        builder.addLast$1("abstract");
      if ((t1 & 4) !== 0)
        builder.addLast$1("final");
      if ((t1 & 8) !== 0)
        builder.addLast$1("var");
      if ((t1 & 16) !== 0)
        builder.addLast$1("const");
      if ((t1 & 32) !== 0)
        builder.addLast$1("factory");
      if ((t1 & 64) !== 0)
        builder.addLast$1("external");
      buffer = P.StringBuffer$("");
      builder.toLink$0().printOn$2(buffer, ", ");
      return buffer._contents;
    },
    static: {"^": "Modifiers_EMPTY,Modifiers_FLAG_STATIC,Modifiers_FLAG_ABSTRACT,Modifiers_FLAG_FINAL,Modifiers_FLAG_VAR,Modifiers_FLAG_CONST,Modifiers_FLAG_FACTORY,Modifiers_FLAG_EXTERNAL", Modifiers_computeFlags: function(nodes) {
        var flags, t1, value;
        for (flags = 0; !nodes.get$isEmpty(nodes); nodes = nodes.get$tail()) {
          t1 = nodes.get$head(nodes).asIdentifier$0().token;
          value = t1.get$value(t1);
          if (value === "static")
            flags |= 1;
          else if (value === "abstract")
            flags |= 2;
          else if (value === "final")
            flags |= 4;
          else if (value === "var")
            flags |= 8;
          else if (value === "const")
            flags |= 16;
          else if (value === "factory")
            flags |= 32;
          else if (value === "external")
            flags |= 64;
          else
            throw H.wrapException("internal error: " + H.S(nodes.get$head(nodes)));
        }
        return flags;
      }}
  },
  StringInterpolation: {
    "^": "StringNode;string<,parts,hashCode",
    get$dartString: function() {
      return;
    },
    get$isInterpolation: function() {
      return true;
    },
    accept$1: function(_, visitor) {
      return visitor.visitStringInterpolation$1(this);
    },
    visitChildren$1: function(visitor) {
      visitor.visitLiteralString$1(this.string);
      visitor.visitNodeList$1(this.parts);
    },
    getBeginToken$0: function() {
      return this.string.token;
    },
    getEndToken$0: function() {
      return this.parts.getEndToken$0();
    }
  },
  StringInterpolationPart: {
    "^": "Node;expression<,string<,hashCode",
    accept$1: function(_, visitor) {
      return visitor.visitStringInterpolationPart$1(this);
    },
    visitChildren$1: function(visitor) {
      this.expression.accept$1(0, visitor);
      visitor.visitLiteralString$1(this.string);
    },
    getBeginToken$0: function() {
      return this.expression.getBeginToken$0();
    },
    getEndToken$0: function() {
      return this.string.token;
    }
  },
  StringJuxtaposition: {
    "^": "StringNode;first>,second,isInterpolationCache,dartStringCache,hashCode",
    get$isInterpolation: function() {
      var t1 = this.isInterpolationCache;
      if (t1 == null) {
        t1 = this.first.accept$1(0, C.C_IsInterpolationVisitor) === true || this.second.accept$1(0, C.C_IsInterpolationVisitor) === true;
        this.isInterpolationCache = t1;
      }
      return t1;
    },
    get$dartString: function() {
      var t1, firstString, secondString;
      if (this.get$isInterpolation() === true)
        throw H.wrapException(O.SpannableAssertionFailure$(this, "Getting dartString on interpolation;"));
      t1 = this.dartStringCache;
      if (t1 == null) {
        firstString = this.first.accept$1(0, C.C_GetDartStringVisitor);
        secondString = this.second.accept$1(0, C.C_GetDartStringVisitor);
        if (firstString == null || secondString == null)
          return;
        t1 = Y.DartString_DartString$concat(firstString, secondString);
        this.dartStringCache = t1;
      }
      return t1;
    },
    accept$1: function(_, visitor) {
      return visitor.visitStringJuxtaposition$1(this);
    },
    visitChildren$1: function(visitor) {
      this.first.accept$1(0, visitor);
      this.second.accept$1(0, visitor);
    },
    getBeginToken$0: function() {
      return this.first.getBeginToken$0();
    },
    getEndToken$0: function() {
      return this.second.getEndToken$0();
    }
  },
  EmptyStatement0: {
    "^": "Statement2;semicolonToken,hashCode",
    asEmptyStatement$0: function() {
      return this;
    },
    accept$1: function(_, visitor) {
      return visitor.visitEmptyStatement$1(this);
    },
    visitChildren$1: function(visitor) {
    },
    getBeginToken$0: function() {
      return this.semicolonToken;
    },
    getEndToken$0: function() {
      return this.semicolonToken;
    },
    $isEmptyStatement0: true
  },
  LiteralMap: {
    "^": "Expression2;typeArguments<,entries,constKeyword,hashCode",
    get$isConst: function() {
      return this.constKeyword != null;
    },
    accept$1: function(_, visitor) {
      return visitor.visitLiteralMap$1(this);
    },
    visitChildren$1: function(visitor) {
      var t1 = this.typeArguments;
      if (t1 != null) {
        t1.toString;
        visitor.visitNodeList$1(t1);
      }
      visitor.visitNodeList$1(this.entries);
    },
    getBeginToken$0: function() {
      var t1 = this.constKeyword;
      if (t1 != null)
        return t1;
      return Y.firstBeginToken(this.typeArguments, this.entries);
    },
    getEndToken$0: function() {
      return this.entries.getEndToken$0();
    }
  },
  LiteralMapEntry: {
    "^": "Node;key>,value>,colonToken,hashCode",
    accept$1: function(_, visitor) {
      return visitor.visitLiteralMapEntry$1(this);
    },
    visitChildren$1: function(visitor) {
      this.key.accept$1(0, visitor);
      this.value.accept$1(0, visitor);
    },
    getBeginToken$0: function() {
      return this.key.getBeginToken$0();
    },
    getEndToken$0: function() {
      return this.value.getEndToken$0();
    }
  },
  NamedArgument: {
    "^": "Expression2;name>,expression<,colonToken,hashCode",
    asNamedArgument$0: function() {
      return this;
    },
    accept$1: function(_, visitor) {
      return visitor.visitNamedArgument$1(this);
    },
    visitChildren$1: function(visitor) {
      this.name.accept$1(0, visitor);
      this.expression.accept$1(0, visitor);
    },
    getBeginToken$0: function() {
      return this.name.token;
    },
    getEndToken$0: function() {
      return this.expression.getEndToken$0();
    }
  },
  SwitchStatement: {
    "^": "Statement2;parenthesizedExpression,cases,switchKeyword,hashCode",
    get$expression: function() {
      return this.parenthesizedExpression.expression;
    },
    accept$1: function(_, visitor) {
      return visitor.visitSwitchStatement$1(this);
    },
    visitChildren$1: function(visitor) {
      var t1 = this.parenthesizedExpression;
      t1.toString;
      visitor.visitParenthesizedExpression$1(t1);
      t1 = this.cases;
      t1.toString;
      visitor.visitNodeList$1(t1);
    },
    getBeginToken$0: function() {
      return this.switchKeyword;
    },
    getEndToken$0: function() {
      return this.cases.getEndToken$0();
    },
    $isSwitchStatement: true
  },
  CaseMatch: {
    "^": "Node;caseKeyword,expression<,colonToken,hashCode",
    asCaseMatch$0: function() {
      return this;
    },
    getBeginToken$0: function() {
      return this.caseKeyword;
    },
    getEndToken$0: function() {
      return this.colonToken;
    },
    accept$1: function(_, visitor) {
      return visitor.visitCaseMatch$1(this);
    },
    visitChildren$1: function(visitor) {
      return this.expression.accept$1(0, visitor);
    },
    $isCaseMatch: true
  },
  SwitchCase: {
    "^": "Node;labelsAndCases<,defaultKeyword<,statements,startToken,hashCode",
    isValidContinueTarget$0: function() {
      return true;
    },
    accept$1: function(_, visitor) {
      return visitor.visitSwitchCase$1(this);
    },
    visitChildren$1: function(visitor) {
      visitor.visitNodeList$1(this.labelsAndCases);
      visitor.visitNodeList$1(this.statements);
    },
    getBeginToken$0: function() {
      return this.startToken;
    },
    getEndToken$0: function() {
      var t1, t2;
      t1 = this.statements;
      t2 = t1.nodes;
      if (t2.get$isEmpty(t2)) {
        t1 = this.defaultKeyword;
        if (t1 != null)
          return t1.next;
        return this.labelsAndCases.getEndToken$0();
      } else
        return t1.getEndToken$0();
    }
  },
  GotoStatement: {
    "^": "Statement2;target>,keywordToken<",
    visitChildren$1: function(visitor) {
      var t1 = this.target;
      if (t1 != null)
        t1.accept$1(0, visitor);
    },
    getBeginToken$0: function() {
      return this.keywordToken;
    },
    getEndToken$0: function() {
      return this.semicolonToken;
    }
  },
  BreakStatement: {
    "^": "GotoStatement;target,keywordToken,semicolonToken,hashCode",
    accept$1: function(_, visitor) {
      return visitor.visitBreakStatement$1(this);
    }
  },
  ContinueStatement: {
    "^": "GotoStatement;target,keywordToken,semicolonToken,hashCode",
    accept$1: function(_, visitor) {
      return visitor.visitContinueStatement$1(this);
    }
  },
  ForIn0: {
    "^": "Loop_StoredTreeElementMixin;declaredIdentifier,expression<,forToken<,inToken<,secret_tree_element$StoredTreeElementMixin$_secret_tree_element$_element,body,hashCode",
    asForIn$0: function() {
      return this;
    },
    accept$1: function(_, visitor) {
      return visitor.visitForIn$1(this);
    },
    visitChildren$1: function(visitor) {
      this.declaredIdentifier.accept$1(0, visitor);
      this.expression.accept$1(0, visitor);
      this.body.accept$1(0, visitor);
    },
    getBeginToken$0: function() {
      return this.forToken;
    },
    getEndToken$0: function() {
      return this.body.getEndToken$0();
    }
  },
  Loop_StoredTreeElementMixin: {
    "^": "Loop+StoredTreeElementMixin;_secret_tree_element$_element:secret_tree_element$StoredTreeElementMixin$_secret_tree_element$_element@"
  },
  Label: {
    "^": "Node;identifier<,colonToken,hashCode",
    get$labelName: function() {
      var t1 = this.identifier.token;
      return t1.get$value(t1);
    },
    asLabel$0: function() {
      return this;
    },
    accept$1: function(_, visitor) {
      return visitor.visitLabel$1(this);
    },
    visitChildren$1: function(visitor) {
      this.identifier.accept$1(0, visitor);
    },
    getBeginToken$0: function() {
      return this.identifier.token;
    },
    getEndToken$0: function() {
      return this.colonToken;
    }
  },
  LabeledStatement: {
    "^": "Statement2;labels,statement<,hashCode",
    accept$1: function(_, visitor) {
      return visitor.visitLabeledStatement$1(this);
    },
    visitChildren$1: function(visitor) {
      visitor.visitNodeList$1(this.labels);
      this.statement.accept$1(0, visitor);
    },
    getBeginToken$0: function() {
      return this.labels.getBeginToken$0();
    },
    getEndToken$0: function() {
      return this.statement.getEndToken$0();
    },
    isValidContinueTarget$0: function() {
      return this.statement.isValidContinueTarget$0();
    }
  },
  LibraryTag: {
    "^": "Node;metadata<",
    get$isLibraryName: function() {
      return false;
    },
    get$isImport: function() {
      return false;
    },
    get$isExport: function() {
      return false;
    },
    get$isPart: function() {
      return false;
    }
  },
  LibraryName: {
    "^": "LibraryTag;name>,libraryKeyword,metadata,hashCode",
    get$isLibraryName: function() {
      return true;
    },
    accept$1: function(_, visitor) {
      return visitor.visitLibraryName$1(this);
    },
    visitChildren$1: function(visitor) {
      return this.name.accept$1(0, visitor);
    },
    getBeginToken$0: function() {
      return this.libraryKeyword;
    },
    getEndToken$0: function() {
      return this.name.getEndToken$0().next;
    }
  },
  LibraryDependency: {
    "^": "LibraryTag;uri<",
    $isLibraryDependency: true
  },
  Import: {
    "^": "LibraryDependency;prefix<,importKeyword,isDeferred,uri,combinators,metadata,hashCode",
    get$isImport: function() {
      return true;
    },
    asImport$0: function() {
      return this;
    },
    accept$1: function(_, visitor) {
      return visitor.visitImport$1(this);
    },
    visitChildren$1: function(visitor) {
      var t1;
      this.uri.accept$1(0, visitor);
      t1 = this.prefix;
      if (t1 != null)
        t1.accept$1(0, visitor);
      t1 = this.combinators;
      if (t1 != null) {
        t1.toString;
        visitor.visitNodeList$1(t1);
      }
    },
    getBeginToken$0: function() {
      return this.importKeyword;
    },
    getEndToken$0: function() {
      var t1 = this.combinators;
      if (t1 != null)
        return t1.getEndToken$0().next;
      t1 = this.prefix;
      if (t1 != null)
        return t1.token.next;
      return this.uri.getEndToken$0().next;
    },
    $isImport: true
  },
  Export: {
    "^": "LibraryDependency;exportKeyword,uri,combinators,metadata,hashCode",
    get$isExport: function() {
      return true;
    },
    accept$1: function(_, visitor) {
      return visitor.visitExport$1(this);
    },
    visitChildren$1: function(visitor) {
      var t1;
      this.uri.accept$1(0, visitor);
      t1 = this.combinators;
      if (t1 != null) {
        t1.toString;
        visitor.visitNodeList$1(t1);
      }
    },
    getBeginToken$0: function() {
      return this.exportKeyword;
    },
    getEndToken$0: function() {
      var t1 = this.combinators;
      if (t1 != null)
        return t1.getEndToken$0().next;
      return this.uri.getEndToken$0().next;
    },
    $isExport: true
  },
  Part: {
    "^": "LibraryTag;uri<,partKeyword,metadata,hashCode",
    get$isPart: function() {
      return true;
    },
    accept$1: function(_, visitor) {
      return visitor.visitPart$1(this);
    },
    visitChildren$1: function(visitor) {
      return this.uri.accept$1(0, visitor);
    },
    getBeginToken$0: function() {
      return this.partKeyword;
    },
    getEndToken$0: function() {
      return this.uri.getEndToken$0().next;
    }
  },
  PartOf: {
    "^": "Node;name>,partKeyword,metadata<,hashCode",
    accept$1: function(_, visitor) {
      return visitor.visitPartOf$1(this);
    },
    visitChildren$1: function(visitor) {
      return this.name.accept$1(0, visitor);
    },
    getBeginToken$0: function() {
      return this.partKeyword;
    },
    getEndToken$0: function() {
      return this.name.getEndToken$0().next;
    }
  },
  Combinator: {
    "^": "Node;identifiers<,keywordToken<,hashCode",
    accept$1: function(_, visitor) {
      return visitor.visitCombinator$1(this);
    },
    visitChildren$1: function(visitor) {
      var t1 = this.identifiers;
      t1.toString;
      return visitor.visitNodeList$1(t1);
    },
    getBeginToken$0: function() {
      return this.keywordToken;
    },
    getEndToken$0: function() {
      return this.identifiers.getEndToken$0();
    }
  },
  Typedef: {
    "^": "Node;returnType<,name>,typeParameters<,formals,typedefKeyword,endToken,hashCode",
    accept$1: function(_, visitor) {
      return visitor.visitTypedef$1(this);
    },
    visitChildren$1: function(visitor) {
      var t1 = this.returnType;
      if (t1 != null) {
        t1.toString;
        visitor.visitTypeAnnotation$1(t1);
      }
      this.name.accept$1(0, visitor);
      t1 = this.typeParameters;
      if (t1 != null) {
        t1.toString;
        visitor.visitNodeList$1(t1);
      }
      t1 = this.formals;
      t1.toString;
      visitor.visitNodeList$1(t1);
    },
    getBeginToken$0: function() {
      return this.typedefKeyword;
    },
    getEndToken$0: function() {
      return this.endToken;
    }
  },
  TryStatement: {
    "^": "Statement2;tryBlock,catchBlocks,finallyBlock,tryKeyword,finallyKeyword,hashCode",
    accept$1: function(_, visitor) {
      return visitor.visitTryStatement$1(this);
    },
    visitChildren$1: function(visitor) {
      var t1 = this.tryBlock;
      t1.toString;
      visitor.visitBlock$1(t1);
      visitor.visitNodeList$1(this.catchBlocks);
      t1 = this.finallyBlock;
      if (t1 != null) {
        t1.toString;
        visitor.visitBlock$1(t1);
      }
    },
    getBeginToken$0: function() {
      return this.tryKeyword;
    },
    getEndToken$0: function() {
      var t1, t2;
      t1 = this.finallyBlock;
      if (t1 != null)
        return t1.statements.getEndToken$0();
      t1 = this.catchBlocks;
      t2 = t1.nodes;
      if (!t2.get$isEmpty(t2))
        return t1.getEndToken$0();
      return this.tryBlock.statements.getEndToken$0();
    }
  },
  Cascade: {
    "^": "Expression2;expression<,hashCode",
    accept$1: function(_, visitor) {
      return visitor.visitCascade$1(this);
    },
    visitChildren$1: function(visitor) {
      this.expression.accept$1(0, visitor);
    },
    getBeginToken$0: function() {
      return this.expression.getBeginToken$0();
    },
    getEndToken$0: function() {
      return this.expression.getEndToken$0();
    }
  },
  CascadeReceiver: {
    "^": "Expression2;expression<,cascadeOperator,hashCode",
    asCascadeReceiver$0: function() {
      return this;
    },
    accept$1: function(_, visitor) {
      return visitor.visitCascadeReceiver$1(this);
    },
    visitChildren$1: function(visitor) {
      this.expression.accept$1(0, visitor);
    },
    getBeginToken$0: function() {
      return this.expression.getBeginToken$0();
    },
    getEndToken$0: function() {
      return this.expression.getEndToken$0();
    }
  },
  CatchBlock: {
    "^": "Node;type>,formals,block<,onKeyword,catchKeyword,hashCode",
    accept$1: function(_, visitor) {
      return visitor.visitCatchBlock$1(this);
    },
    get$exception: function() {
      var t1, t2;
      t1 = this.formals;
      if (t1 != null) {
        t2 = t1.nodes;
        t2 = t2.get$isEmpty(t2);
      } else
        t2 = true;
      if (t2)
        return;
      t1 = t1.nodes;
      t1 = t1.get$head(t1).get$definitions().nodes;
      return t1.get$head(t1);
    },
    get$trace: function() {
      var t1, t2, declarations;
      t1 = this.formals;
      if (t1 != null) {
        t2 = t1.nodes;
        t2 = t2.get$isEmpty(t2);
      } else
        t2 = true;
      if (t2)
        return;
      declarations = t1.nodes.get$tail();
      if (declarations.get$isEmpty(declarations))
        return;
      t1 = declarations.get$head(declarations).get$definitions().nodes;
      return t1.get$head(t1);
    },
    visitChildren$1: function(visitor) {
      var t1 = this.type;
      if (t1 != null) {
        t1.toString;
        visitor.visitTypeAnnotation$1(t1);
      }
      t1 = this.formals;
      if (t1 != null) {
        t1.toString;
        visitor.visitNodeList$1(t1);
      }
      t1 = this.block;
      t1.toString;
      visitor.visitBlock$1(t1);
    },
    getBeginToken$0: function() {
      var t1 = this.onKeyword;
      return t1 != null ? t1 : this.catchKeyword;
    },
    getEndToken$0: function() {
      return this.block.statements.getEndToken$0();
    }
  },
  Metadata: {
    "^": "Node;token<,expression<,hashCode",
    accept$1: function(_, visitor) {
      return visitor.visitMetadata$1(this);
    },
    visitChildren$1: function(visitor) {
      this.expression.accept$1(0, visitor);
    },
    getBeginToken$0: function() {
      return this.token;
    },
    getEndToken$0: function() {
      return this.expression.getEndToken$0();
    }
  },
  GetDartStringVisitor: {
    "^": "Visitor;",
    visitNode$1: function(node) {
      return;
    },
    visitStringJuxtaposition$1: function(node) {
      return node.get$dartString();
    },
    visitLiteralString$1: function(node) {
      return node.dartString;
    },
    $asVisitor: function() {
      return [Y.DartString];
    }
  },
  IsInterpolationVisitor: {
    "^": "Visitor;",
    visitNode$1: function(node) {
      return false;
    },
    visitStringInterpolation$1: function(node) {
      return true;
    },
    visitStringJuxtaposition$1: function(node) {
      return node.get$isInterpolation();
    },
    $asVisitor: function() {
      return [P.bool];
    }
  },
  ErrorNode: {
    "^": "Node;token<,reason>,name>,definitions<,hashCode",
    get$beginToken: function() {
      return this.token;
    },
    getBeginToken$0: function() {
      return this.token;
    },
    getEndToken$0: function() {
      return this.token;
    },
    accept$1: function(_, visitor) {
    },
    visitChildren$1: function(visitor) {
    },
    get$isErroneous: function() {
      return true;
    },
    get$parameters: function() {
      return;
    },
    get$body: function(_) {
      return;
    },
    get$returnType: function() {
      return;
    },
    get$modifiers: function() {
      return $.get$Modifiers_EMPTY();
    },
    get$initializers: function() {
      return;
    },
    get$isRedirectingFactory: function() {
      return false;
    },
    hasBody$0: function() {
      return false;
    },
    hasEmptyBody$0: function() {
      return false;
    },
    get$metadata: function() {
      return;
    },
    get$type: function(_) {
      return;
    },
    get$typeParameters: function() {
      return;
    },
    $isNode: true,
    $isVariableDefinitions: true,
    $isFunctionExpression: true
  },
  PrettyPrinter: {
    "^": "Indentation;sb,tagStack,_indentLevel,_indentList,_indentationUnit",
    popTag$0: function() {
      var t1, tag;
      t1 = this.tagStack;
      tag = t1.get$head(t1);
      this.tagStack = this.tagStack.get$tail();
      --this._indentLevel;
      return tag;
    },
    add$1: function(_, string) {
      this.sb.write$1(string);
    },
    addBeginAndEndTokensToParams$2: function(node, params) {
      var t1 = node.getBeginToken$0();
      params.$indexSet(0, "getBeginToken", t1 == null ? null : t1.get$stringValue());
      t1 = node.getEndToken$0();
      params.$indexSet(0, "getEndToken", t1 == null ? null : t1.get$stringValue());
    },
    openNode$3: function(node, type, params) {
      if (params == null)
        params = P.LinkedHashMap_LinkedHashMap(null, null, null, null, null);
      this.sb.write$1(this.get$indentation());
      this.sb.write$1("<");
      this.addBeginAndEndTokensToParams$2(node, params);
      this.addTypeWithParams$2(type, params);
      this.sb.write$1(">\n");
      this.tagStack = this.tagStack.prepend$1(type);
      ++this._indentLevel;
    },
    openNode$2: function(node, type) {
      return this.openNode$3(node, type, null);
    },
    openAndCloseNode$3: function(node, type, params) {
      this.sb.write$1(this.get$indentation());
      this.sb.write$1("<");
      this.addBeginAndEndTokensToParams$2(node, params);
      this.addTypeWithParams$2(type, params);
      this.sb.write$1("/>\n");
    },
    closeNode$0: function() {
      var tag = this.popTag$0();
      this.sb.write$1(this.get$indentation());
      this.sb.write$1("</");
      this.addTypeWithParams$1(tag);
      this.sb.write$1(">\n");
    },
    addTypeWithParams$2: function(type, params) {
      if (params == null)
        params = P.LinkedHashMap_LinkedHashMap(null, null, null, null, null);
      this.sb.write$1(H.S(type));
      params.forEach$1(0, new Y.PrettyPrinter_addTypeWithParams_closure(this));
    },
    addTypeWithParams$1: function(type) {
      return this.addTypeWithParams$2(type, null);
    },
    visitBlock$1: function(node) {
      this.openNode$2(node, "Block");
      node.visitChildren$1(this);
      this.closeNode$0();
    },
    visitBreakStatement$1: function(node) {
      this.openNode$2(node, "BreakStatement");
      node.visitChildren$1(this);
      this.closeNode$0();
    },
    visitCascade$1: function(node) {
      this.openNode$2(node, "Cascade");
      node.visitChildren$1(this);
      this.closeNode$0();
    },
    visitCascadeReceiver$1: function(node) {
      this.openNode$2(node, "CascadeReceiver");
      node.visitChildren$1(this);
      this.closeNode$0();
    },
    visitCaseMatch$1: function(node) {
      this.openNode$2(node, "CaseMatch");
      node.visitChildren$1(this);
      this.closeNode$0();
    },
    visitCatchBlock$1: function(node) {
      this.openNode$2(node, "CatchBlock");
      node.visitChildren$1(this);
      this.closeNode$0();
    },
    visitClassNode$1: function(node) {
      var t1 = node.extendsKeyword;
      this.openNode$3(node, "ClassNode", P.LinkedHashMap_LinkedHashMap$_literal(["extendsKeyword", t1 == null ? null : t1.get$stringValue()], null, null));
      this.visitChildNode$2(node.name, "name");
      this.visitChildNode$2(node.superclass, "superclass");
      this.visitChildNode$2(node.interfaces, "interfaces");
      this.visitChildNode$2(node.typeParameters, "typeParameters");
      this.closeNode$0();
    },
    visitConditional$1: function(node) {
      this.openNode$2(node, "Conditional");
      node.visitChildren$1(this);
      this.closeNode$0();
    },
    visitContinueStatement$1: function(node) {
      this.openNode$2(node, "ContinueStatement");
      node.visitChildren$1(this);
      this.closeNode$0();
    },
    visitDoWhile$1: function(node) {
      this.openNode$2(node, "DoWhile");
      node.visitChildren$1(this);
      this.closeNode$0();
    },
    visitEmptyStatement$1: function(node) {
      this.openNode$2(node, "EmptyStatement");
      node.visitChildren$1(this);
      this.closeNode$0();
    },
    visitExpressionStatement$1: function(node) {
      this.openNode$2(node, "ExpressionStatement");
      node.visitChildren$1(this);
      this.closeNode$0();
    },
    visitFor$1: function(node) {
      this.openNode$2(node, "For");
      node.visitChildren$1(this);
      this.closeNode$0();
    },
    visitForIn$1: function(node) {
      this.openNode$2(node, "ForIn");
      node.visitChildren$1(this);
      this.closeNode$0();
    },
    visitFunctionDeclaration$1: function(node) {
      this.openNode$2(node, "FunctionDeclaration");
      node.visitChildren$1(this);
      this.closeNode$0();
    },
    visitFunctionExpression$1: function(node) {
      var t1 = node.getOrSet;
      this.openNode$3(node, "FunctionExpression", P.LinkedHashMap_LinkedHashMap$_literal(["getOrSet", t1 == null ? null : t1.get$stringValue()], null, null));
      this.visitChildNode$2(node.modifiers, "modifiers");
      this.visitChildNode$2(node.returnType, "returnType");
      this.visitChildNode$2(node.name, "name");
      this.visitChildNode$2(node.parameters, "parameters");
      this.visitChildNode$2(node.initializers, "initializers");
      this.visitChildNode$2(node.body, "body");
      this.closeNode$0();
    },
    visitIdentifier$1: function(node) {
      this.openAndCloseNode$3(node, "Identifier", P.LinkedHashMap_LinkedHashMap$_literal(["token", node.token], null, null));
    },
    visitIf$1: function(node) {
      this.openNode$2(node, "If");
      node.visitChildren$1(this);
      this.closeNode$0();
    },
    visitLabel$1: function(node) {
      this.openNode$2(node, "Label");
      node.visitChildren$1(this);
      this.closeNode$0();
    },
    visitLabeledStatement$1: function(node) {
      this.openNode$2(node, "LabeledStatement");
      node.visitChildren$1(this);
      this.closeNode$0();
    },
    visitLiteralBool$1: function(node) {
      this.openAndCloseNode$3(node, "LiteralBool", P.LinkedHashMap_LinkedHashMap$_literal(["value", C.JSBool_methods.toString$0(node.get$value(node))], null, null));
    },
    visitLiteralDouble$1: function(node) {
      this.openAndCloseNode$3(node, "LiteralDouble", P.LinkedHashMap_LinkedHashMap$_literal(["value", J.toString$0(node.get$value(node))], null, null));
    },
    visitLiteralInt$1: function(node) {
      this.openAndCloseNode$3(node, "LiteralInt", P.LinkedHashMap_LinkedHashMap$_literal(["value", J.toString$0(node.get$value(node))], null, null));
    },
    visitLiteralList$1: function(node) {
      var t1 = node.get$constKeyword();
      this.openNode$3(node, "LiteralList", P.LinkedHashMap_LinkedHashMap$_literal(["constKeyword", t1 == null ? null : t1.get$stringValue()], null, null));
      this.visitChildNode$2(node.typeArguments, "typeArguments");
      this.visitChildNode$2(node.elements, "elements");
      this.closeNode$0();
    },
    visitLiteralMap$1: function(node) {
      this.openNode$2(node, "LiteralMap");
      node.visitChildren$1(this);
      this.closeNode$0();
    },
    visitLiteralMapEntry$1: function(node) {
      this.openNode$2(node, "LiteralMapEntry");
      node.visitChildren$1(this);
      this.closeNode$0();
    },
    visitLiteralNull$1: function(node) {
      this.openAndCloseNode$3(node, "LiteralNull", P.LinkedHashMap_LinkedHashMap$_literal(["value", C.JSNull_methods.toString$0(node.get$value(node))], null, null));
    },
    visitLiteralString$1: function(node) {
      this.openAndCloseNode$3(node, "LiteralString", P.LinkedHashMap_LinkedHashMap$_literal(["value", node.token], null, null));
    },
    visitMixinApplication$1: function(node) {
      this.openNode$2(node, "MixinApplication");
      node.visitChildren$1(this);
      this.closeNode$0();
    },
    visitModifiers$1: function(node) {
      this.openNode$2(node, "Modifiers");
      node.visitChildren$1(this);
      this.closeNode$0();
    },
    visitNamedArgument$1: function(node) {
      this.openNode$2(node, "NamedArgument");
      node.visitChildren$1(this);
      this.closeNode$0();
    },
    visitNamedMixinApplication$1: function(node) {
      this.openNode$2(node, "NamedMixinApplication");
      node.visitChildren$1(this);
      this.closeNode$0();
    },
    visitNewExpression$1: function(node) {
      this.openNode$2(node, "NewExpression");
      node.visitChildren$1(this);
      this.closeNode$0();
    },
    visitNodeList$1: function(node) {
      var params, t1;
      params = P.LinkedHashMap_LinkedHashMap$_literal(["delimiter", node.delimiter], null, null);
      t1 = node.nodes;
      if (t1.get$isEmpty(t1))
        this.openAndCloseNode$3(node, "NodeList", params);
      else {
        this.openNode$3(node, "NodeList", params);
        node.visitChildren$1(this);
        this.closeNode$0();
      }
    },
    visitOperator$1: function(node) {
      this.openAndCloseNode$3(node, "Operator", P.LinkedHashMap_LinkedHashMap$_literal(["value", node.token], null, null));
    },
    visitParenthesizedExpression$1: function(node) {
      this.openNode$2(node, "ParenthesizedExpression");
      node.visitChildren$1(this);
      this.closeNode$0();
    },
    visitRedirectingFactoryBody$1: function(node) {
      this.openNode$2(node, "RedirectingFactoryBody");
      this.visitChildNode$2(node.constructorReference, "constructorReference");
      this.closeNode$0();
    },
    visitRethrow$1: function(node) {
      this.openNode$2(node, "Rethrow");
      node.visitChildren$1(this);
      this.closeNode$0();
    },
    visitReturn$1: function(node) {
      this.openNode$2(node, "Return");
      this.visitChildNode$2(node.get$expression(), "expression");
      this.closeNode$0();
    },
    visitChildNode$2: function(node, fieldName) {
      if (node == null)
        return;
      this.sb.write$1(this.get$indentation());
      this.sb.write$1("<" + fieldName + ">\n");
      this.tagStack = this.tagStack.prepend$1(fieldName);
      ++this._indentLevel;
      node.accept$1(0, this);
      this.popTag$0();
      this.sb.write$1(this.get$indentation());
      this.sb.write$1("</" + fieldName + ">\n");
    },
    openSendNodeWithFields$2: function(node, type) {
      var t1, t2, t3, t4, t5;
      t1 = node.argumentsNode;
      t2 = J.getInterceptor(t1);
      t3 = "" + !!t2.$isPrefix0;
      t2 = "" + !!t2.$isPostfix0;
      t4 = node.selector;
      if (!!J.getInterceptor(t4).$isOperator) {
        t5 = t4.asOperator$0().token;
        t5 = t5.get$value(t5) === "[]";
      } else
        t5 = false;
      this.openNode$3(node, type, P.LinkedHashMap_LinkedHashMap$_literal(["isPrefix", t3, "isPostfix", t2, "isIndex", "" + t5], null, null));
      this.visitChildNode$2(node.receiver, "receiver");
      this.visitChildNode$2(t4, "selector");
      this.visitChildNode$2(t1, "argumentsNode");
    },
    visitSend$1: function(node) {
      this.openSendNodeWithFields$2(node, "Send");
      this.closeNode$0();
    },
    visitSendSet$1: function(node) {
      this.openSendNodeWithFields$2(node, "SendSet");
      this.visitChildNode$2(node.assignmentOperator, "assignmentOperator");
      this.closeNode$0();
    },
    visitStringInterpolation$1: function(node) {
      this.openNode$2(node, "StringInterpolation");
      node.visitChildren$1(this);
      this.closeNode$0();
    },
    visitStringInterpolationPart$1: function(node) {
      this.openNode$2(node, "StringInterpolationPart");
      node.visitChildren$1(this);
      this.closeNode$0();
    },
    visitStringJuxtaposition$1: function(node) {
      this.openNode$2(node, "StringJuxtaposition");
      node.visitChildren$1(this);
      this.closeNode$0();
    },
    visitSwitchCase$1: function(node) {
      this.openNode$2(node, "SwitchCase");
      node.visitChildren$1(this);
      this.closeNode$0();
    },
    visitSwitchStatement$1: function(node) {
      this.openNode$2(node, "SwitchStatement");
      node.visitChildren$1(this);
      this.closeNode$0();
    },
    visitLiteralSymbol$1: function(node) {
      this.openNode$2(node, "LiteralSymbol");
      this.visitChildNode$2(node.identifiers, "identifiers");
      this.closeNode$0();
    },
    visitThrow$1: function(node) {
      this.openNode$2(node, "Throw");
      node.visitChildren$1(this);
      this.closeNode$0();
    },
    visitTryStatement$1: function(node) {
      this.openNode$2(node, "TryStatement");
      node.visitChildren$1(this);
      this.closeNode$0();
    },
    visitTypeAnnotation$1: function(node) {
      this.openNode$2(node, "TypeAnnotation");
      this.visitChildNode$2(node.typeName, "typeName");
      this.visitChildNode$2(node.typeArguments, "typeArguments");
      this.closeNode$0();
    },
    visitTypedef$1: function(node) {
      this.openNode$2(node, "Typedef");
      node.visitChildren$1(this);
      this.closeNode$0();
    },
    visitTypeVariable$1: function(node) {
      this.openNode$2(node, "TypeVariable");
      this.visitChildNode$2(node.name, "name");
      this.visitChildNode$2(node.bound, "bound");
      this.closeNode$0();
    },
    visitVariableDefinitions$1: function(node) {
      this.openNode$2(node, "VariableDefinitions");
      this.visitChildNode$2(node.type, "type");
      this.visitChildNode$2(node.modifiers, "modifiers");
      this.visitChildNode$2(node.definitions, "definitions");
      this.closeNode$0();
    },
    visitWhile$1: function(node) {
      this.openNode$2(node, "While");
      node.visitChildren$1(this);
      this.closeNode$0();
    },
    visitMetadata$1: function(node) {
      this.openNode$3(node, "Metadata", P.LinkedHashMap_LinkedHashMap$_literal(["token", node.token], null, null));
      this.visitChildNode$2(node.expression, "expression");
      this.closeNode$0();
    },
    visitCombinator$1: function(node) {
      var t1 = node.keywordToken;
      this.openNode$3(node, "Combinator", P.LinkedHashMap_LinkedHashMap$_literal(["isShow", "" + (t1.get$stringValue() === "show"), "isHide", "" + (t1.get$stringValue() === "hide")], null, null));
      this.closeNode$0();
    },
    visitExport$1: function(node) {
      this.openNode$2(node, "Export");
      this.visitChildNode$2(node.uri, "uri");
      this.visitChildNode$2(node.combinators, "combinators");
      this.closeNode$0();
    },
    visitImport$1: function(node) {
      var t1;
      this.openNode$3(node, "Import", P.LinkedHashMap_LinkedHashMap$_literal(["isDeferred", H.S(node.isDeferred)], null, null));
      this.visitChildNode$2(node.uri, "uri");
      this.visitChildNode$2(node.combinators, "combinators");
      t1 = node.prefix;
      if (t1 != null)
        this.visitChildNode$2(t1, "prefix");
      this.closeNode$0();
    },
    visitPart$1: function(node) {
      this.openNode$2(node, "Part");
      this.visitChildNode$2(node.uri, "uri");
      this.closeNode$0();
    },
    visitPartOf$1: function(node) {
      this.openNode$2(node, "PartOf");
      this.visitChildNode$2(node.name, "name");
      this.closeNode$0();
    },
    visitLibraryName$1: function(node) {
      this.openNode$2(node, "LibraryName");
      this.visitChildNode$2(node.name, "name");
      this.closeNode$0();
    },
    visitPostfix$1: function(node) {
      this.unimplemented$2$node("visitNode", node);
    },
    visitPrefix$1: function(node) {
      this.unimplemented$2$node("visitNode", node);
    },
    unimplemented$2$node: function(message, node) {
      throw H.wrapException(message);
    },
    static: {PrettyPrinter_prettyPrint: function(node) {
        var p = new Y.PrettyPrinter(P.StringBuffer$(""), C.C_Link14, 0, H.setRuntimeTypeInfo([""], [P.String]), "  ");
        node.accept$1(0, p);
        return p.sb._contents;
      }}
  },
  PrettyPrinter_addTypeWithParams_closure: {
    "^": "Closure:19;this_0",
    call$2: function(k, v) {
      var t1, value;
      if (v != null) {
        t1 = J.getInterceptor(v);
        t1 = J.replaceAll$2$s(!!t1.$isToken ? t1.get$value(v) : v, "<", "&lt;");
        t1 = H.stringReplaceAllUnchecked(t1, ">", "&gt;");
        value = H.stringReplaceAllUnchecked(t1, "\"", "'");
      } else
        value = "[null]";
      this.this_0.sb.write$1(" " + H.S(k) + "=\"" + value + "\"");
    },
    $isFunction: true
  },
  Unparser: {
    "^": "Indentation;sb,minify,stripTypes,onEmptyLine,_indentLevel,_indentList,_indentationUnit",
    newline$0: function() {
      if (!this.minify) {
        this.sb._contents += "\n";
        this.onEmptyLine = true;
      }
    },
    addToken$1: function(token) {
      if (token == null)
        return;
      this.write$1(token.get$value(token));
      if (token.get$info().kind === 107 || token.get$info().kind === 97)
        this.write$1(" ");
    },
    write$1: function(object) {
      var s, t1, str;
      s = J.toString$0(object);
      if (s === "")
        return;
      if (this.onEmptyLine) {
        t1 = this.get$indentation();
        this.sb._contents += t1;
      }
      str = typeof s === "string" ? s : H.S(s);
      this.sb._contents += str;
      this.onEmptyLine = false;
    },
    visit$1: function(node) {
      if (node != null)
        J.accept$1$x(node, this);
    },
    visitBlock$1: function(node) {
      return this.unparseBlockStatements$1(node.statements);
    },
    unparseBlockStatements$1: function(statements) {
      var nodes, t1, link, t2;
      this.addToken$1(statements.beginToken);
      nodes = statements.nodes;
      if (nodes != null && !nodes.get$isEmpty(nodes)) {
        ++this._indentLevel;
        this.newline$0();
        this.visit$1(nodes.get$head(nodes));
        t1 = statements.delimiter;
        if (t1 == null)
          ;
        else
          H.S(t1);
        for (link = nodes.get$tail(), t1 = !this.minify, t2 = this.sb; !link.get$isEmpty(link); link = link.get$tail()) {
          if (t1) {
            t2._contents += "\n";
            this.onEmptyLine = true;
          }
          this.visit$1(link.get$head(link));
        }
        --this._indentLevel;
        this.newline$0();
      }
      t1 = statements.endToken;
      if (t1 != null)
        this.write$1(t1.get$value(t1));
    },
    visitCascade$1: function(node) {
      this.visit$1(node.expression);
    },
    visitCascadeReceiver$1: function(node) {
      this.visit$1(node.expression);
    },
    unparseClassWithBody$2: function(node, members) {
      var t1, t2, t3;
      t1 = node.beginToken;
      this.addToken$1(t1);
      if (t1.get$stringValue() === "abstract")
        this.addToken$1(t1.next);
      this.visit$1(node.name);
      t1 = node.typeParameters;
      if (t1 != null)
        this.visit$1(t1);
      t1 = node.extendsKeyword;
      if (t1 != null) {
        this.write$1(" ");
        this.addToken$1(t1);
        this.visit$1(node.superclass);
      }
      t1 = node.interfaces;
      t2 = t1.nodes;
      if (!t2.get$isEmpty(t2)) {
        this.write$1(" ");
        this.visit$1(t1);
      }
      t1 = this.minify;
      this.write$1(t1 ? "" : " ");
      this.write$1("{");
      t2 = J.getInterceptor$asx(members);
      if (t2.get$isEmpty(members) !== true) {
        this.newline$0();
        ++this._indentLevel;
        for (t2 = t2.get$iterator(members), t1 = !t1, t3 = this.sb; t2.moveNext$0();) {
          this.visit$1(t2.get$current());
          if (t1) {
            t3._contents += "\n";
            this.onEmptyLine = true;
          }
        }
        --this._indentLevel;
      }
      this.write$1("}");
    },
    visitClassNode$1: function(node) {
      this.unparseClassWithBody$2(node, node.body.nodes);
    },
    visitMixinApplication$1: function(node) {
      this.visit$1(node.superclass);
      this.write$1(" with ");
      this.visit$1(node.mixins);
    },
    visitNamedMixinApplication$1: function(node) {
      var t1, t2;
      t1 = node.modifiers;
      t2 = t1.nodes.nodes;
      if (!t2.get$isEmpty(t2)) {
        this.visit$1(t1);
        this.write$1(" ");
      }
      this.write$1("class ");
      this.visit$1(node.name);
      t1 = node.typeParameters;
      if (t1 != null)
        this.visit$1(t1);
      this.write$1(" = ");
      this.visit$1(node.mixinApplication);
      t1 = node.interfaces;
      if (t1 != null) {
        this.write$1(" implements ");
        this.visit$1(t1);
      }
      this.write$1(";");
    },
    visitConditional$1: function(node) {
      var t1, t2;
      this.visit$1(node.condition);
      t1 = this.minify;
      this.write$1(t1 ? "" : " ");
      t2 = node.questionToken;
      this.write$1(t2.get$value(t2));
      this.write$1(t1 ? "" : " ");
      this.visit$1(node.thenExpression);
      this.write$1(t1 ? "" : " ");
      t2 = node.colonToken;
      this.write$1(t2.get$value(t2));
      this.write$1(t1 ? "" : " ");
      this.visit$1(node.elseExpression);
    },
    visitExpressionStatement$1: function(node) {
      var t1;
      this.visit$1(node.expression);
      t1 = node.endToken;
      this.write$1(t1.get$value(t1));
    },
    visitFor$1: function(node) {
      var t1, t2, t3;
      t1 = node.forToken;
      this.write$1(t1.get$value(t1));
      t1 = this.minify;
      this.write$1(t1 ? "" : " ");
      this.write$1("(");
      this.visit$1(node.initializer);
      this.write$1(";");
      t2 = node.conditionStatement;
      if (!J.getInterceptor(t2).$isEmptyStatement0)
        this.write$1(t1 ? "" : " ");
      this.visit$1(t2);
      t2 = node.update;
      t3 = t2.nodes;
      if (!t3.get$isEmpty(t3))
        this.write$1(t1 ? "" : " ");
      this.visit$1(t2);
      this.write$1(")");
      this.write$1(t1 ? "" : " ");
      this.visit$1(node.body);
    },
    visitFunctionDeclaration$1: function(node) {
      this.visit$1(node.$function);
    },
    unparseFunctionName$1: function($name) {
      var t1, t2;
      if (!!J.getInterceptor($name).$isSend) {
        t1 = $name.selector;
        t2 = $name.receiver;
        if (!J.getInterceptor(t1).$isOperator) {
          this.visit$1(t2);
          this.write$1(".");
        } else {
          this.visit$1(t2);
          t2 = t1.asIdentifier$0().token;
          if (t2.get$info().kind === 107)
            this.write$1(" ");
          else if (t2.get$value(t2) === "negate")
            this.write$1(" ");
        }
        this.visit$1(t1);
      } else
        this.visit$1($name);
    },
    visitFunctionExpression$1: function(node) {
      var t1, t2;
      t1 = node.modifiers;
      t2 = t1.nodes.nodes;
      if (!t2.get$isEmpty(t2)) {
        this.visit$1(t1);
        this.write$1(" ");
      }
      t1 = node.returnType;
      if (t1 != null && !this.stripTypes) {
        this.visit$1(t1);
        this.write$1(" ");
      }
      t1 = node.getOrSet;
      if (t1 != null) {
        this.write$1(t1.get$value(t1));
        this.write$1(" ");
      }
      this.unparseFunctionName$1(node.name);
      this.visit$1(node.parameters);
      t1 = node.initializers;
      if (t1 != null) {
        t2 = this.minify;
        this.write$1(t2 ? "" : " ");
        this.write$1(":");
        this.write$1(t2 ? "" : " ");
        this.unparseNodeListFrom$3$spaces(t1, t1.nodes, true);
      }
      t1 = node.body;
      if (t1 != null && !J.getInterceptor(t1).$isEmptyStatement0)
        this.write$1(this.minify ? "" : " ");
      this.visit$1(t1);
    },
    visitIdentifier$1: function(node) {
      var t1 = node.token;
      this.write$1(t1.get$value(t1));
    },
    visitIf$1: function(node) {
      var t1, t2, t3;
      t1 = node.get$ifToken();
      this.write$1(t1.get$value(t1));
      t1 = this.minify;
      this.write$1(t1 ? "" : " ");
      this.visit$1(node.condition);
      this.write$1(t1 ? "" : " ");
      this.visit$1(node.thenPart);
      t2 = node.elsePart;
      if (t2 != null) {
        this.write$1(t1 ? "" : " ");
        t3 = node.elseToken;
        this.write$1(t3.get$value(t3));
        this.write$1(t1 ? "" : " ");
        if (!J.getInterceptor(t2).$isBlock0 && t1)
          this.write$1(" ");
        this.visit$1(t2);
      }
    },
    visitLiteralBool$1: function(node) {
      var t1 = node.token;
      this.write$1(t1.get$value(t1));
    },
    visitLiteralDouble$1: function(node) {
      var t1 = node.token;
      this.write$1(t1.get$value(t1));
      if (t1.get$info().kind === 43) {
        t1 = t1.next;
        this.write$1(t1.get$value(t1));
      }
    },
    visitLiteralInt$1: function(node) {
      var t1 = node.token;
      this.write$1(t1.get$value(t1));
      if (t1.get$info().kind === 43) {
        t1 = t1.next;
        this.write$1(t1.get$value(t1));
      }
    },
    visitLiteralString$1: function(node) {
      var t1 = node.token;
      this.write$1(t1.get$value(t1));
    },
    visitStringJuxtaposition$1: function(node) {
      this.visit$1(node.first);
      this.write$1(" ");
      this.visit$1(node.second);
    },
    visitLiteralNull$1: function(node) {
      var t1 = node.token;
      this.write$1(t1.get$value(t1));
    },
    visitLiteralSymbol$1: function(node) {
      var t1 = node.hashToken;
      this.write$1(t1.get$value(t1));
      this.unparseNodeListOfIdentifiers$1(node.identifiers);
    },
    unparseNodeListOfIdentifiers$1: function(node) {
      var l, t1;
      l = node.nodes;
      t1 = l.get$head(l).asIdentifier$0().token;
      this.write$1(t1.get$value(t1));
      for (l = l.get$tail(); !l.get$isEmpty(l); l = l.get$tail()) {
        this.write$1(".");
        t1 = l.get$head(l).asIdentifier$0().token;
        this.write$1(t1.get$value(t1));
      }
    },
    visitNewExpression$1: function(node) {
      this.addToken$1(node.newToken);
      this.visit$1(node.send);
    },
    visitLiteralList$1: function(node) {
      var t1;
      if (node.get$constKeyword() != null) {
        t1 = node.constKeyword;
        this.write$1(t1.get$value(t1));
      }
      this.visit$1(node.typeArguments);
      t1 = node.elements;
      this.visit$1(t1);
      if (this.minify) {
        t1 = t1.nodes;
        t1 = t1.get$isEmpty(t1);
      } else
        t1 = false;
      if (t1)
        this.write$1(" ");
    },
    visitModifiers$1: function(node) {
      this.unparseNodeList$2$spaces(node.nodes, false);
    },
    unparseNodeListFrom$3$spaces: function(node, from, spaces) {
      var t1, delimiter, link;
      if (from.get$isEmpty(from))
        return;
      t1 = node.delimiter;
      delimiter = t1 == null ? "" : H.S(t1);
      this.visit$1(from.get$head(from));
      for (link = from.get$tail(), t1 = this.minify; !link.get$isEmpty(link); link = link.get$tail()) {
        this.write$1(delimiter);
        if (spaces)
          this.write$1(t1 ? "" : " ");
        this.visit$1(link.get$head(link));
      }
    },
    unparseNodeListFrom$2: function(node, from) {
      return this.unparseNodeListFrom$3$spaces(node, from, true);
    },
    unparseNodeList$2$spaces: function(node, spaces) {
      var t1;
      this.addToken$1(node.beginToken);
      t1 = node.nodes;
      if (t1 != null)
        this.unparseNodeListFrom$3$spaces(node, t1, spaces);
      t1 = node.endToken;
      if (t1 != null)
        this.write$1(t1.get$value(t1));
    },
    unparseNodeList$1: function(node) {
      return this.unparseNodeList$2$spaces(node, true);
    },
    visitNodeList$1: function(node) {
      this.unparseNodeList$1(node);
    },
    visitOperator$1: function(node) {
      var t1 = node.token;
      this.write$1(t1.get$value(t1));
    },
    visitRedirectingFactoryBody$1: function(node) {
      var t1, t2;
      t1 = this.minify;
      this.write$1(t1 ? "" : " ");
      t2 = node.beginToken;
      this.write$1(t2.get$value(t2));
      this.write$1(t1 ? "" : " ");
      this.visit$1(node.constructorReference);
      t2 = node.endToken;
      this.write$1(t2.get$value(t2));
    },
    visitRethrow$1: function(node) {
      this.write$1("rethrow;");
    },
    visitReturn$1: function(node) {
      var t1 = node.get$beginToken();
      this.write$1(t1.get$value(t1));
      t1 = node.expression;
      if (t1 != null && node.beginToken.get$stringValue() !== "=>")
        this.write$1(" ");
      if (node.beginToken.get$stringValue() === "=>")
        this.write$1(this.minify ? "" : " ");
      this.visit$1(t1);
      t1 = node.endToken;
      if (t1 != null)
        this.write$1(t1.get$value(t1));
    },
    unparseSendReceiver$2$spacesNeeded: function(node, spacesNeeded) {
      var t1, asCascadeReceiver;
      t1 = node.receiver;
      if (t1 == null)
        return;
      this.visit$1(t1);
      asCascadeReceiver = t1.asCascadeReceiver$0();
      if (asCascadeReceiver != null) {
        this.newline$0();
        this._indentLevel = ++this._indentLevel + 1;
        t1 = asCascadeReceiver.cascadeOperator;
        this.write$1(t1.get$value(t1));
        this._indentLevel = --this._indentLevel - 1;
      } else if (node.selector.asOperator$0() == null)
        this.write$1(".");
      else if (spacesNeeded)
        this.write$1(" ");
    },
    unparseSendReceiver$1: function(node) {
      return this.unparseSendReceiver$2$spacesNeeded(node, false);
    },
    unparseSendArgument$2$spacesNeeded: function(node, spacesNeeded) {
      var t1, t2, argNode;
      t1 = node.argumentsNode;
      if (t1 == null)
        return;
      t2 = node.selector;
      if (!!J.getInterceptor(t2).$isOperator) {
        t2 = t2.asOperator$0().token;
        t2 = t2.get$value(t2) === "is";
      } else
        t2 = false;
      if (t2) {
        t2 = t1.nodes;
        t2 = t2.get$head(t2).asSend$0() != null;
      } else
        t2 = false;
      if (t2) {
        t1 = t1.nodes;
        argNode = t1.get$head(t1);
        this.visit$1(argNode.get$selector());
        this.write$1(this.minify ? "" : " ");
        this.visit$1(argNode.get$receiver());
      } else {
        if (spacesNeeded)
          this.write$1(" ");
        this.visit$1(t1);
      }
    },
    visitSend$1: function(node) {
      var t1, t2, op, t3, opString, spacesNeeded, t4, t5;
      t1 = {};
      t2 = node.selector;
      op = t2.asOperator$0();
      if (op != null) {
        t3 = op.token;
        opString = t3.get$value(t3);
      } else
        opString = null;
      if (this.minify)
        spacesNeeded = opString === "is" || opString === "as";
      else if (opString != null) {
        if (!J.getInterceptor(node.argumentsNode).$isPrefix0) {
          if (!!t2.$isOperator) {
            t3 = t2.asOperator$0().token;
            t3 = t3.get$value(t3) === "[]";
          } else
            t3 = false;
          t3 = !t3;
        } else
          t3 = false;
        spacesNeeded = t3;
      } else
        spacesNeeded = false;
      t1.spacesNeeded_0 = spacesNeeded;
      t3 = new Y.Unparser_visitSend_minusMinusSpace(t1, this, opString);
      t4 = node.argumentsNode;
      t5 = !!J.getInterceptor(t4).$isPrefix0;
      if (t5) {
        this.visit$1(t2);
        t3.call$1(node.receiver);
      }
      this.unparseSendReceiver$2$spacesNeeded(node, t1.spacesNeeded_0);
      if (!t5) {
        if (!!t2.$isOperator) {
          t5 = t2.asOperator$0().token;
          t5 = t5.get$value(t5) === "[]";
        } else
          t5 = false;
        t5 = !t5;
      } else
        t5 = false;
      if (t5)
        this.visit$1(t2);
      t3.call$1(t4);
      this.unparseSendArgument$2$spacesNeeded(node, t1.spacesNeeded_0);
    },
    visitSendSet$1: function(node) {
      var t1, t2, t3, t4, t5;
      t1 = node.argumentsNode;
      t2 = J.getInterceptor(t1);
      t3 = !!t2.$isPrefix0;
      if (t3) {
        if (this.minify)
          this.write$1(" ");
        this.visit$1(node.assignmentOperator);
      }
      this.unparseSendReceiver$1(node);
      t4 = node.selector;
      if (!!J.getInterceptor(t4).$isOperator) {
        t5 = t4.asOperator$0().token;
        t5 = t5.get$value(t5) === "[]";
      } else
        t5 = false;
      if (t5) {
        this.write$1("[");
        t4 = t1.nodes;
        this.visit$1(t4.get$head(t4));
        this.write$1("]");
        if (!t3) {
          t2 = !t2.$isPostfix0;
          if (t2)
            this.write$1(this.minify ? "" : " ");
          this.visit$1(node.assignmentOperator);
          if (t2)
            this.write$1(this.minify ? "" : " ");
        }
        this.unparseNodeListFrom$2(t1, t4.get$tail());
      } else {
        this.visit$1(t4);
        if (!t3) {
          t2 = !t2.$isPostfix0;
          if (t2) {
            t3 = node.assignmentOperator.token;
            t3 = t3.get$value(t3) !== ":";
          } else
            t3 = false;
          if (t3)
            this.write$1(this.minify ? "" : " ");
          t3 = node.assignmentOperator;
          this.visit$1(t3);
          if (t2)
            this.write$1(this.minify ? "" : " ");
          if (this.minify) {
            t2 = t3.token;
            t2 = t2.get$value(t2) !== "=";
          } else
            t2 = false;
          if (t2)
            this.write$1(" ");
        }
        this.visit$1(t1);
      }
    },
    visitThrow$1: function(node) {
      var t1 = node.get$throwToken();
      this.write$1(t1.get$value(t1));
      this.write$1(" ");
      this.visit$1(node.expression);
    },
    visitTypeAnnotation$1: function(node) {
      this.visit$1(node.typeName);
      this.visit$1(node.typeArguments);
    },
    visitTypeVariable$1: function(node) {
      var t1;
      this.visit$1(node.name);
      t1 = node.bound;
      if (t1 != null) {
        this.write$1(" extends ");
        this.visit$1(t1);
      }
    },
    visitVariableDefinitions$1: function(node) {
      var t1 = node.metadata;
      if (t1 != null) {
        this.visit$1(t1);
        this.write$1(" ");
      }
      t1 = node.modifiers;
      this.visit$1(t1);
      t1 = t1.nodes.nodes;
      if (!t1.get$isEmpty(t1))
        this.write$1(" ");
      t1 = node.type;
      if (t1 != null) {
        this.visit$1(t1);
        this.write$1(" ");
      }
      this.visit$1(node.definitions);
    },
    visitDoWhile$1: function(node) {
      var t1, t2;
      t1 = node.doKeyword;
      this.write$1(t1.get$value(t1));
      t1 = node.body;
      if (!J.getInterceptor(t1).$isBlock0)
        this.write$1(" ");
      else
        this.write$1(this.minify ? "" : " ");
      this.visit$1(t1);
      t1 = this.minify;
      this.write$1(t1 ? "" : " ");
      t2 = node.whileKeyword;
      this.write$1(t2.get$value(t2));
      this.write$1(t1 ? "" : " ");
      this.visit$1(node.condition);
      t2 = node.endToken;
      this.write$1(t2.get$value(t2));
    },
    visitWhile$1: function(node) {
      var t1 = node.whileKeyword;
      this.write$1(t1.get$value(t1));
      t1 = this.minify;
      this.write$1(t1 ? "" : " ");
      this.visit$1(node.condition);
      this.write$1(t1 ? "" : " ");
      this.visit$1(node.body);
    },
    visitParenthesizedExpression$1: function(node) {
      var t1 = node.beginToken;
      this.write$1(t1.info.value);
      this.visit$1(node.expression);
      t1 = t1.endGroup;
      this.write$1(t1.get$value(t1));
    },
    visitStringInterpolation$1: function(node) {
      this.visit$1(node.string);
      this.unparseNodeList$2$spaces(node.parts, false);
    },
    visitStringInterpolationPart$1: function(node) {
      this.write$1("${");
      this.visit$1(node.expression);
      this.write$1("}");
      this.visit$1(node.string);
    },
    visitEmptyStatement$1: function(node) {
      var t1 = node.semicolonToken;
      this.write$1(t1.get$value(t1));
    },
    visitGotoStatement$1: function(node) {
      var t1 = node.keywordToken;
      this.write$1(t1.get$value(t1));
      t1 = node.target;
      if (t1 != null) {
        this.write$1(" ");
        this.visit$1(t1);
      }
      t1 = node.semicolonToken;
      this.write$1(t1.get$value(t1));
    },
    visitBreakStatement$1: function(node) {
      this.visitGotoStatement$1(node);
    },
    visitContinueStatement$1: function(node) {
      this.visitGotoStatement$1(node);
    },
    visitForIn$1: function(node) {
      var t1 = node.forToken;
      this.write$1(t1.get$value(t1));
      t1 = this.minify;
      this.write$1(t1 ? "" : " ");
      this.write$1("(");
      this.visit$1(node.declaredIdentifier);
      this.write$1(" ");
      this.addToken$1(node.inToken);
      this.visit$1(node.expression);
      this.write$1(")");
      this.write$1(t1 ? "" : " ");
      this.visit$1(node.body);
    },
    visitLabel$1: function(node) {
      var t1;
      this.visit$1(node.identifier);
      t1 = node.colonToken;
      this.write$1(t1.get$value(t1));
    },
    visitLabeledStatement$1: function(node) {
      this.visit$1(node.labels);
      this.visit$1(node.statement);
    },
    visitLiteralMap$1: function(node) {
      var t1 = node.constKeyword;
      if (t1 != null)
        this.write$1(t1.get$value(t1));
      t1 = node.typeArguments;
      if (t1 != null)
        this.visit$1(t1);
      this.visit$1(node.entries);
    },
    visitLiteralMapEntry$1: function(node) {
      var t1;
      this.visit$1(node.key);
      t1 = node.colonToken;
      this.write$1(t1.get$value(t1));
      this.write$1(this.minify ? "" : " ");
      this.visit$1(node.value);
    },
    visitNamedArgument$1: function(node) {
      var t1;
      this.visit$1(node.name);
      t1 = node.colonToken;
      this.write$1(t1.get$value(t1));
      this.write$1(this.minify ? "" : " ");
      this.visit$1(node.expression);
    },
    visitSwitchStatement$1: function(node) {
      this.addToken$1(node.switchKeyword);
      this.visit$1(node.parenthesizedExpression);
      this.write$1(this.minify ? "" : " ");
      this.unparseNodeList$2$spaces(node.cases, false);
    },
    visitSwitchCase$1: function(node) {
      this.newline$0();
      ++this._indentLevel;
      this.visit$1(node.labelsAndCases);
      if (node.defaultKeyword != null)
        this.write$1("default:");
      this.unparseBlockStatements$1(node.statements);
      --this._indentLevel;
    },
    visitTryStatement$1: function(node) {
      var t1;
      this.addToken$1(node.tryKeyword);
      this.visit$1(node.tryBlock);
      this.visit$1(node.catchBlocks);
      t1 = node.finallyKeyword;
      if (t1 != null) {
        this.write$1(this.minify ? "" : " ");
        this.addToken$1(t1);
        this.visit$1(node.finallyBlock);
      }
    },
    visitCaseMatch$1: function(node) {
      var t1;
      this.addToken$1(node.caseKeyword);
      this.visit$1(node.expression);
      t1 = node.colonToken;
      this.write$1(t1.get$value(t1));
    },
    visitCatchBlock$1: function(node) {
      var t1;
      this.addToken$1(node.onKeyword);
      t1 = node.type;
      if (t1 != null) {
        this.visit$1(t1);
        this.write$1(" ");
      }
      t1 = this.minify;
      this.write$1(t1 ? "" : " ");
      this.addToken$1(node.catchKeyword);
      this.visit$1(node.formals);
      this.write$1(t1 ? "" : " ");
      this.visit$1(node.block);
    },
    visitTypedef$1: function(node) {
      var t1;
      this.addToken$1(node.typedefKeyword);
      t1 = node.returnType;
      if (t1 != null) {
        this.visit$1(t1);
        this.write$1(" ");
      }
      this.visit$1(node.name);
      t1 = node.typeParameters;
      if (t1 != null)
        this.visit$1(t1);
      this.visit$1(node.formals);
      t1 = node.endToken;
      this.write$1(t1.get$value(t1));
    },
    visitLibraryName$1: function(node) {
      var t1;
      this.addToken$1(node.libraryKeyword);
      t1 = node.name;
      t1.accept$1(0, this);
      t1 = t1.getEndToken$0().next;
      this.write$1(t1.get$value(t1));
      this.newline$0();
    },
    visitImport$1: function(node) {
      var t1;
      this.addToken$1(node.importKeyword);
      this.visit$1(node.uri);
      if (node.isDeferred === true)
        this.write$1(" deferred");
      t1 = node.prefix;
      if (t1 != null) {
        this.write$1(" as ");
        this.visit$1(t1);
      }
      t1 = node.combinators;
      if (t1 != null) {
        this.write$1(" ");
        this.visit$1(t1);
      }
      t1 = node.getEndToken$0();
      this.write$1(t1.get$value(t1));
      this.newline$0();
    },
    visitExport$1: function(node) {
      var t1;
      this.addToken$1(node.exportKeyword);
      this.visit$1(node.uri);
      t1 = node.combinators;
      if (t1 != null) {
        this.write$1(" ");
        this.visit$1(t1);
      }
      t1 = node.getEndToken$0();
      this.write$1(t1.get$value(t1));
      this.newline$0();
    },
    visitPart$1: function(node) {
      var t1;
      this.addToken$1(node.partKeyword);
      t1 = node.uri;
      this.visit$1(t1);
      t1 = t1.getEndToken$0().next;
      this.write$1(t1.get$value(t1));
    },
    visitPartOf$1: function(node) {
      var t1 = node.partKeyword;
      this.addToken$1(t1);
      this.addToken$1(t1.next);
      t1 = node.name;
      this.visit$1(t1);
      t1 = t1.getEndToken$0().next;
      this.write$1(t1.get$value(t1));
    },
    visitCombinator$1: function(node) {
      this.addToken$1(node.keywordToken);
      this.visit$1(node.identifiers);
    },
    visitMetadata$1: function(node) {
      this.addToken$1(node.token);
      this.visit$1(node.expression);
    },
    visitPostfix$1: function(node) {
      throw H.wrapException("internal error");
    },
    visitPrefix$1: function(node) {
      throw H.wrapException("internal error");
    }
  },
  Unparser_visitSend_minusMinusSpace: {
    "^": "Closure:296;box_0,this_1,opString_2",
    call$1: function(other) {
      var beginToken;
      if (other != null && this.opString_2 === "-") {
        beginToken = other.getBeginToken$0();
        if (beginToken != null && beginToken.get$stringValue() != null && J.startsWith$1$s(beginToken.get$stringValue(), "-")) {
          this.this_1.sb.write$1(" ");
          this.box_0.spacesNeeded_0 = false;
        }
      }
    },
    $isFunction: true
  }
}],
["tree_ir_builder", "package:compiler/implementation/dart_backend/tree_ir_builder.dart", , X, {
  "^": "",
  Builder: {
    "^": "Visitor1;compiler<,element2variables,local2closure,labels,$function<,returnContinuation,parent*,phiTempVar",
    getClosureVariable$1: function(local) {
      var t1, variable;
      if (local.get$executableContext() !== this.$function.element)
        return this.parent.getClosureVariable$1(local);
      t1 = this.local2closure;
      variable = t1.$index(0, local);
      if (variable == null) {
        variable = new M.Variable(this.$function, local, 0, 0, false);
        t1.$indexSet(0, local, variable);
      }
      return variable;
    },
    getVariable$1: function(primitive) {
      var t1, variables, t2;
      if (primitive.get$registerIndex() == null)
        return;
      t1 = this.element2variables;
      variables = t1.$index(0, primitive.hint);
      if (variables == null) {
        variables = [];
        variables.$builtinTypeInfo = [M.Variable];
        t1.$indexSet(0, primitive.hint, variables);
      }
      while (true) {
        t1 = variables.length;
        t2 = primitive.registerIndex;
        if (typeof t2 !== "number")
          return H.iae(t2);
        if (!(t1 <= t2))
          break;
        variables.push(new M.Variable(this.$function, primitive.hint, 0, 0, false));
      }
      return variables[t2];
    },
    getVariableReference$1: function(reference) {
      var variable, t1;
      variable = this.getVariable$1(reference.get$definition());
      if (variable == null) {
        t1 = this.compiler;
        t1.internalError$2(t1._currentElement, "Reference to " + J.toString$0(reference.get$definition()) + " has no register");
      }
      ++variable.readCount;
      return variable;
    },
    translateArguments$1: function(args) {
      return P.List_List$generate(args.length, new X.Builder_translateArguments_closure(this, args), true, M.Expression0);
    },
    translatePhiArguments$1: function(args) {
      return P.List_List$generate(args.length, new X.Builder_translatePhiArguments_closure(this, args), true, M.Variable);
    },
    buildPhiAssignments$3: function(parameters, $arguments, buildRest) {
      var t1, rightHand, i, t2, param, arg, list, assignmentSrc, done, t3;
      t1 = {};
      rightHand = P.LinkedHashMap_LinkedHashMap$_empty(M.Variable, [P.List, P.$int]);
      for (i = 0; t2 = parameters.length, i < t2; ++i) {
        param = this.getVariable$1(parameters[i]);
        if (i >= $arguments.length)
          return H.ioore($arguments, i);
        arg = $arguments[i];
        if (param == null || param === arg)
          continue;
        list = rightHand.$index(0, arg);
        if (list == null) {
          list = [];
          list.$builtinTypeInfo = [P.$int];
          rightHand.$indexSet(0, arg, list);
        }
        J.add$1$ax(list, i);
      }
      t1.first_0 = null;
      t1.current_1 = null;
      assignmentSrc = H.setRuntimeTypeInfo(Array(t2), [M.Variable]);
      done = H.setRuntimeTypeInfo(Array(parameters.length), [P.bool]);
      t2 = new X.Builder_buildPhiAssignments_visitAssignment(this, parameters, $arguments, rightHand, new X.Builder_buildPhiAssignments_addAssignment(t1), assignmentSrc, done);
      for (t3 = done.length, i = 0; i < parameters.length; ++i) {
        if (i >= t3)
          return H.ioore(done, i);
        if (done[i] == null)
          t2.call$1(i);
      }
      if (t1.first_0 == null)
        t1.first_0 = buildRest.call$0();
      else
        t1.current_1.next = buildRest.call$0();
      return t1.first_0;
    },
    visitNode$1: function(node) {
      return H.throwExpression("Unhandled node: " + H.S(node));
    },
    visitFunctionDefinition$1: function(node) {
      var parameters, t1, parameter;
      parameters = H.setRuntimeTypeInfo([], [M.Variable]);
      this.$function = new M.FunctionDefinition0(node.element, parameters, null, node.localConstants, node.defaultParameterValues);
      this.returnContinuation = node.returnContinuation;
      for (t1 = node.parameters, t1 = H.setRuntimeTypeInfo(new H.ListIterator(t1, t1.length, 0, null), [H.getTypeArgumentByIndex(t1, 0)]); t1.moveNext$0();) {
        parameter = this.getVariable$1(t1.__internal$_current);
        ++parameter.writeCount;
        parameters.push(parameter);
      }
      t1 = this.$function;
      this.phiTempVar = new M.Variable(t1, null, 0, 0, false);
      t1.body = node.body.accept$1(0, this);
      return;
    },
    visitLetPrim$1: function(node) {
      var t1, variable, definition;
      t1 = node.primitive;
      variable = this.getVariable$1(t1);
      if (variable == null)
        return node.body.accept$1(0, this);
      definition = t1.accept$1(0, this);
      t1 = node.body;
      if (!!J.getInterceptor(definition).$isStatement0) {
        definition.set$next(t1.accept$1(0, this));
        return definition;
      } else {
        t1 = t1.accept$1(0, this);
        ++variable.writeCount;
        return new M.Assign(t1, variable, definition, false);
      }
    },
    visitLetCont$1: function(node) {
      var t1, t2, label, body;
      t1 = node.continuation;
      t2 = t1.firstRef;
      if (!(t2 == null || t2.next == null)) {
        label = new M.Label0(null, 0, null);
        this.labels.$indexSet(0, t1, label);
      } else
        label = null;
      body = node.body.accept$1(0, this);
      if (label == null || node.continuation.isRecursive)
        return body;
      t1 = new M.LabeledStatement1(node.continuation.body.accept$1(0, this), label, body);
      label.binding = t1;
      return t1;
    },
    visitInvokeStatic$1: function(node) {
      return this.continueWithExpression$2(node.continuation, new M.InvokeStatic(node.target, this.translateArguments$1(node.get$arguments()), node.selector, false));
    },
    visitInvokeMethod$1: function(node) {
      return this.continueWithExpression$2(node.continuation, new M.InvokeMethod(this.getVariableReference$1(node.receiver), node.selector, this.translateArguments$1(node.arguments), false));
    },
    visitInvokeSuperMethod$1: function(node) {
      return this.continueWithExpression$2(node.continuation, new M.InvokeSuperMethod0(node.selector, this.translateArguments$1(node.arguments), false));
    },
    visitConcatenateStrings$1: function(node) {
      return this.continueWithExpression$2(node.continuation, new M.ConcatenateStrings0(this.translateArguments$1(node.arguments), null, false));
    },
    continueWithExpression$2: function(continuation, expression) {
      var cont, t1, nextBuilder, variable, assignment;
      cont = continuation.definition;
      t1 = this.returnContinuation;
      if (cont == null ? t1 == null : cont === t1)
        return new M.Return2(expression);
      else {
        t1 = cont.firstRef;
        nextBuilder = t1 != null && t1.next == null ? new X.Builder_continueWithExpression_closure(this, cont) : new X.Builder_continueWithExpression_closure0(this, cont);
        variable = this.getVariable$1(C.JSArray_methods.get$single(cont.get$parameters()));
        if (variable == null)
          assignment = new M.ExpressionStatement2(null, expression);
        else {
          assignment = new M.Assign(null, variable, expression, false);
          ++variable.writeCount;
        }
        assignment.set$next(nextBuilder.call$0());
        return assignment;
      }
    },
    visitGetClosureVariable$1: function(node) {
      return this.getClosureVariable$1(node.variable);
    },
    visitSetClosureVariable$1: function(node) {
      var variable, value, t1;
      variable = this.getClosureVariable$1(node.variable);
      value = this.getVariableReference$1(node.value);
      t1 = node.body.accept$1(0, this);
      ++variable.writeCount;
      return new M.Assign(t1, variable, value, node.isDeclaration);
    },
    visitDeclareFunction$1: function(node) {
      var variable, t1, $function;
      variable = this.getClosureVariable$1(node.variable);
      t1 = new X.Builder(this.compiler, P.LinkedHashMap_LinkedHashMap$_empty(O.Element, [P.List, M.Variable]), P.LinkedHashMap_LinkedHashMap$_empty(O.Local, M.Variable), P.LinkedHashMap_LinkedHashMap$_empty(D.Continuation, M.Label0), null, null, this, null);
      node.definition.accept$1(0, t1);
      $function = t1.$function;
      t1 = node.body.accept$1(0, this);
      ++variable.writeCount;
      return new M.FunctionDeclaration2(variable, $function, t1);
    },
    visitTypeOperator$1: function(node) {
      return this.continueWithExpression$2(node.continuation, new M.TypeOperator1(this.getVariableReference$1(node.receiver), node.type, node.operator, false));
    },
    visitInvokeConstructor$1: function(node) {
      return this.continueWithExpression$2(node.continuation, new M.InvokeConstructor0(node.type, node.target, this.translateArguments$1(node.arguments), node.selector, null, false));
    },
    visitInvokeContinuation$1: function(node) {
      var cont, t1, t2, $arguments;
      cont = node.continuation.definition;
      t1 = this.returnContinuation;
      t2 = node.arguments;
      if (cont == null ? t1 == null : cont === t1)
        return new M.Return2(this.getVariableReference$1(J.get$single$ax(t2)));
      else {
        $arguments = this.translatePhiArguments$1(t2);
        return this.buildPhiAssignments$3(cont.get$parameters(), $arguments, new X.Builder_visitInvokeContinuation_closure(this, node, cont));
      }
    },
    visitBranch$1: function(node) {
      var condition, cont, t1, thenStatement, elseStatement;
      condition = node.condition.accept$1(0, this);
      cont = node.trueContinuation.definition;
      t1 = cont.firstRef;
      if (t1 != null && t1.next == null)
        thenStatement = cont.get$body(cont).accept$1(0, this);
      else {
        t1 = this.labels.$index(0, cont);
        thenStatement = new M.Break1(t1);
        ++t1.useCount;
      }
      cont = node.falseContinuation.definition;
      t1 = cont.firstRef;
      if (t1 != null && t1.next == null)
        elseStatement = cont.get$body(cont).accept$1(0, this);
      else {
        t1 = this.labels.$index(0, cont);
        elseStatement = new M.Break1(t1);
        ++t1.useCount;
      }
      return new M.If2(condition, thenStatement, elseStatement);
    },
    visitConstant$1: function(node) {
      return new M.Constant0(node.get$expression(), node.value, false);
    },
    visitThis$1: function(node) {
      return new M.This1(false);
    },
    visitReifyTypeVar$1: function(node) {
      return new M.ReifyTypeVar1(node.typeVariable, false);
    },
    visitLiteralList$1: function(node) {
      return new M.LiteralList2(node.get$type(node), this.translateArguments$1(node.values), false);
    },
    visitLiteralMap$1: function(node) {
      return new M.LiteralMap2(node.type, this.translateArguments$1(node.keys), this.translateArguments$1(node.values), false);
    },
    visitCreateFunction$1: function(node) {
      var t1, t2, def, signature;
      t1 = node.definition;
      t2 = new X.Builder(this.compiler, P.LinkedHashMap_LinkedHashMap$_empty(O.Element, [P.List, M.Variable]), P.LinkedHashMap_LinkedHashMap$_empty(O.Local, M.Variable), P.LinkedHashMap_LinkedHashMap$_empty(D.Continuation, M.Label0), null, null, this, null);
      t1.accept$1(0, t2);
      def = t2.$function;
      signature = t1.element.get$functionSignature();
      if (!signature.get$type(signature).returnType.get$treatAsDynamic()) {
        t1 = this.getVariable$1(node);
        ++t1.writeCount;
        return new M.FunctionDeclaration2(t1, def, null);
      } else
        return new M.FunctionExpression1(def, false);
    },
    visitParameter$1: function(node) {
      var t1 = this.compiler;
      t1.internalError$2(t1._currentElement, "Unexpected IR node.");
    },
    visitContinuation$1: function(node) {
      var t1 = this.compiler;
      t1.internalError$2(t1._currentElement, "Unexpected IR node.");
    },
    visitIsTrue$1: function(node) {
      return this.getVariableReference$1(node.value);
    },
    $asVisitor1: function() {
      return [M.Node2];
    }
  },
  Builder_translateArguments_closure: {
    "^": "Closure:165;this_0,args_1",
    call$1: function(index) {
      var t1 = this.args_1;
      if (index >= t1.length)
        return H.ioore(t1, index);
      return this.this_0.getVariableReference$1(t1[index]);
    },
    $isFunction: true
  },
  Builder_translatePhiArguments_closure: {
    "^": "Closure:165;this_0,args_1",
    call$1: function(index) {
      var t1 = this.args_1;
      if (index >= t1.length)
        return H.ioore(t1, index);
      return this.this_0.getVariableReference$1(t1[index]);
    },
    $isFunction: true
  },
  Builder_buildPhiAssignments_addAssignment: {
    "^": "Closure:297;box_0",
    call$2: function(dst, src) {
      var t1, current, t2;
      t1 = this.box_0;
      if (t1.first_0 == null) {
        current = new M.Assign(null, dst, src, false);
        ++dst.writeCount;
        t1.current_1 = current;
        t1.first_0 = current;
      } else {
        t2 = t1.current_1;
        current = new M.Assign(null, dst, src, false);
        ++dst.writeCount;
        t2.next = current;
        t1.current_1 = current;
      }
    },
    $isFunction: true
  },
  Builder_buildPhiAssignments_visitAssignment: {
    "^": "Closure:298;this_1,parameters_2,arguments_3,rightHand_4,addAssignment_5,assignmentSrc_6,done_7",
    call$1: function(i) {
      var t1, t2, t3, param, arg, t4, paramUses;
      t1 = this.done_7;
      if (i >>> 0 !== i || i >= t1.length)
        return H.ioore(t1, i);
      if (t1[i] === true)
        return;
      t2 = this.this_1;
      t3 = this.parameters_2;
      if (i >= t3.length)
        return H.ioore(t3, i);
      param = t2.getVariable$1(t3[i]);
      t3 = this.arguments_3;
      if (i >= t3.length)
        return H.ioore(t3, i);
      arg = t3[i];
      if (param == null || param === arg)
        return;
      t3 = this.assignmentSrc_6;
      if (i >= t3.length)
        return H.ioore(t3, i);
      t4 = t3[i];
      if (t4 != null) {
        t1 = t2.phiTempVar;
        if (t4 == null ? t1 != null : t4 !== t1) {
          t3[i] = t1;
          this.addAssignment_5.call$2(t1, arg);
        }
        return;
      }
      t3[i] = arg;
      paramUses = this.rightHand_4.$index(0, param);
      if (paramUses != null)
        for (t2 = H.setRuntimeTypeInfo(new H.ListIterator(paramUses, paramUses.length, 0, null), [H.getTypeArgumentByIndex(paramUses, 0)]); t2.moveNext$0();)
          this.call$1(t2.__internal$_current);
      this.addAssignment_5.call$2(param, t3[i]);
      t1[i] = true;
    },
    $isFunction: true
  },
  Builder_continueWithExpression_closure: {
    "^": "Closure:23;this_0,cont_1",
    call$0: function() {
      return this.cont_1.body.accept$1(0, this.this_0);
    },
    $isFunction: true
  },
  Builder_continueWithExpression_closure0: {
    "^": "Closure:23;this_2,cont_3",
    call$0: function() {
      var t1 = this.this_2.labels.$index(0, this.cont_3);
      ++t1.useCount;
      return new M.Break1(t1);
    },
    $isFunction: true
  },
  Builder_visitInvokeContinuation_closure: {
    "^": "Closure:23;this_0,node_1,cont_2",
    call$0: function() {
      var t1, t2, t3;
      t1 = this.cont_2;
      if (t1.isRecursive) {
        t2 = this.this_0;
        if (this.node_1.isRecursive) {
          t1 = t2.labels.$index(0, t1);
          t2 = new M.Continue1(t1);
          ++t1.useCount;
          t1 = t2;
        } else {
          t3 = t2.labels.$index(0, t1);
          t2 = new M.WhileTrue(t3, t1.body.accept$1(0, t2));
          t3.binding = t2;
          t1 = t2;
        }
        return t1;
      } else {
        t2 = t1.firstRef;
        t2 = t2 != null && t2.next == null;
        t3 = this.this_0;
        if (t2)
          t1 = t1.body.accept$1(0, t3);
        else {
          t1 = t3.labels.$index(0, t1);
          t2 = new M.Break1(t1);
          ++t1.useCount;
          t1 = t2;
        }
        return t1;
      }
    },
    $isFunction: true
  }
}],
["tree_ir_nodes", "package:compiler/implementation/dart_backend/tree_ir_nodes.dart", , M, {
  "^": "",
  Node2: {
    "^": "Object;"
  },
  Expression0: {
    "^": "Node2;processed<"
  },
  Statement0: {
    "^": "Node2;",
    $isStatement0: true
  },
  Label0: {
    "^": "Object;cachedName,useCount,binding",
    get$name: function(_) {
      var t1 = this.cachedName;
      if (t1 == null) {
        t1 = $.Label_counter;
        $.Label_counter = t1 + 1;
        t1 = "L" + t1;
        this.cachedName = t1;
      }
      return t1;
    },
    static: {"^": "Label_counter"}
  },
  Variable: {
    "^": "Expression0;host,element<,readCount<,writeCount,processed",
    accept$1: function(_, visitor) {
      return visitor.visitVariable$1(this);
    },
    $isVariable: true
  },
  InvokeStatic: {
    "^": "Expression0;target>,arguments<,selector<,processed",
    accept$1: function(_, visitor) {
      return visitor.visitInvokeStatic$1(this);
    }
  },
  InvokeMethod: {
    "^": "Expression0;receiver<,selector<,arguments<,processed",
    accept$1: function(_, visitor) {
      return visitor.visitInvokeMethod$1(this);
    }
  },
  InvokeSuperMethod0: {
    "^": "Expression0;selector<,arguments<,processed",
    accept$1: function(_, visitor) {
      return visitor.visitInvokeSuperMethod$1(this);
    }
  },
  InvokeConstructor0: {
    "^": "Expression0;type>,target>,arguments<,selector<,constant<,processed",
    accept$1: function(_, visitor) {
      return visitor.visitInvokeConstructor$1(this);
    }
  },
  ConcatenateStrings0: {
    "^": "Expression0;arguments<,constant<,processed",
    accept$1: function(_, visitor) {
      return visitor.visitConcatenateStrings$1(this);
    }
  },
  Constant0: {
    "^": "Expression0;expression<,value>,processed",
    accept$1: function(_, visitor) {
      return visitor.visitConstant$1(this);
    },
    $isConstant0: true
  },
  This1: {
    "^": "Expression0;processed",
    accept$1: function(_, visitor) {
      return visitor.visitThis$1(this);
    }
  },
  ReifyTypeVar1: {
    "^": "Expression0;typeVariable,processed",
    accept$1: function(_, visitor) {
      return visitor.visitReifyTypeVar$1(this);
    }
  },
  LiteralList2: {
    "^": "Expression0;type>,values>,processed",
    accept$1: function(_, visitor) {
      return visitor.visitLiteralList$1(this);
    }
  },
  LiteralMap2: {
    "^": "Expression0;type>,keys<,values>,processed",
    accept$1: function(_, visitor) {
      return visitor.visitLiteralMap$1(this);
    }
  },
  TypeOperator1: {
    "^": "Expression0;receiver<,type>,operator>,processed",
    accept$1: function(_, visitor) {
      return visitor.visitTypeOperator$1(this);
    }
  },
  Conditional2: {
    "^": "Expression0;condition,thenExpression,elseExpression,processed",
    accept$1: function(_, visitor) {
      return visitor.visitConditional$1(this);
    },
    $isConditional2: true
  },
  LogicalOperator: {
    "^": "Expression0;left>,isAnd,right>,processed",
    get$operator: function(_) {
      return this.isAnd ? "&&" : "||";
    },
    accept$1: function(_, visitor) {
      return visitor.visitLogicalOperator$1(this);
    },
    $isLogicalOperator: true
  },
  Not: {
    "^": "Expression0;operand<,processed",
    accept$1: function(_, visitor) {
      return visitor.visitNot$1(this);
    },
    $isNot: true
  },
  FunctionExpression1: {
    "^": "Expression0;definition<,processed",
    accept$1: function(_, visitor) {
      return visitor.visitFunctionExpression$1(this);
    },
    $isFunctionExpression1: true
  },
  FunctionDeclaration2: {
    "^": "Statement0;variable<,definition<,next@",
    accept$1: function(_, visitor) {
      return visitor.visitFunctionDeclaration$1(this);
    }
  },
  JumpTarget0: {
    "^": "Statement0;"
  },
  LabeledStatement1: {
    "^": "JumpTarget0;next@,label,body*",
    accept$1: function(_, visitor) {
      return visitor.visitLabeledStatement$1(this);
    }
  },
  Loop1: {
    "^": "JumpTarget0;"
  },
  WhileTrue: {
    "^": "Loop1;label,body*",
    get$next: function() {
      return;
    },
    set$next: function(s) {
      return H.throwExpression("UNREACHABLE");
    },
    accept$1: function(_, visitor) {
      return visitor.visitWhileTrue$1(this);
    }
  },
  WhileCondition: {
    "^": "Loop1;label,condition<,body*,next@",
    accept$1: function(_, visitor) {
      return visitor.visitWhileCondition$1(this);
    }
  },
  Jump: {
    "^": "Statement0;",
    $isJump: true
  },
  Break1: {
    "^": "Jump;target>",
    get$next: function() {
      return;
    },
    set$next: function(s) {
      return H.throwExpression("UNREACHABLE");
    },
    accept$1: function(_, visitor) {
      return visitor.visitBreak$1(this);
    },
    $isBreak1: true
  },
  Continue1: {
    "^": "Jump;target>",
    get$next: function() {
      return;
    },
    set$next: function(s) {
      return H.throwExpression("UNREACHABLE");
    },
    accept$1: function(_, visitor) {
      return visitor.visitContinue$1(this);
    },
    $isContinue1: true
  },
  Assign: {
    "^": "Statement0;next@,variable<,definition<,isDeclaration<",
    get$hasExactlyOneUse: function() {
      return this.variable.readCount === 1;
    },
    accept$1: function(_, visitor) {
      return visitor.visitAssign$1(this);
    },
    $isAssign: true
  },
  Return2: {
    "^": "Statement0;value>",
    get$next: function() {
      return;
    },
    set$next: function(s) {
      return H.throwExpression("UNREACHABLE");
    },
    accept$1: function(_, visitor) {
      return visitor.visitReturn$1(this);
    },
    $isReturn2: true
  },
  If2: {
    "^": "Statement0;condition@,thenStatement<,elseStatement<",
    get$next: function() {
      return;
    },
    set$next: function(s) {
      return H.throwExpression("UNREACHABLE");
    },
    accept$1: function(_, visitor) {
      return visitor.visitIf$1(this);
    },
    $isIf2: true
  },
  ExpressionStatement2: {
    "^": "Statement0;next@,expression<",
    accept$1: function(_, visitor) {
      return visitor.visitExpressionStatement$1(this);
    },
    $isExpressionStatement2: true
  },
  FunctionDefinition0: {
    "^": "Node2;element<,parameters<,body*,localConstants,defaultParameterValues",
    $isFunctionDefinition0: true
  },
  ExpressionVisitor: {
    "^": "Object;",
    visitExpression$1: [function(e) {
      return J.accept$1$x(e, this);
    }, "call$1", "get$visitExpression", 2, 0, function() {
      return H.computeSignature(function(E) {
        return {func: "E__Expression", ret: E, args: [M.Expression0]};
      }, this.$receiver, "ExpressionVisitor");
    }]
  },
  StatementVisitor: {
    "^": "Object;",
    visitStatement$1: function(s) {
      return J.accept$1$x(s, this);
    }
  },
  Visitor0: {
    "^": "Object;",
    visitExpression$1: [function(e) {
      return J.accept$1$x(e, this);
    }, "call$1", "get$visitExpression", 2, 0, function() {
      return H.computeSignature(function(S, E) {
        return {func: "E__Expression0", ret: E, args: [M.Expression0]};
      }, this.$receiver, "Visitor0");
    }]
  },
  RecursiveVisitor: {
    "^": "Visitor0;",
    visitFunctionDefinition$1: function(node) {
      node.body.accept$1(0, this);
    },
    visitVariable$1: function(node) {
    },
    visitInvokeStatic$1: function(node) {
      H.IterableMixinWorkaround_forEach(node.get$arguments(), this.get$visitExpression());
    },
    visitInvokeMethod$1: function(node) {
      node.receiver.accept$1(0, this);
      H.IterableMixinWorkaround_forEach(node.arguments, this.get$visitExpression());
    },
    visitInvokeSuperMethod$1: function(node) {
      H.IterableMixinWorkaround_forEach(node.arguments, this.get$visitExpression());
    },
    visitInvokeConstructor$1: function(node) {
      H.IterableMixinWorkaround_forEach(node.arguments, this.get$visitExpression());
    },
    visitConcatenateStrings$1: function(node) {
      H.IterableMixinWorkaround_forEach(node.arguments, this.get$visitExpression());
    },
    visitConstant$1: function(node) {
    },
    visitThis$1: function(node) {
    },
    visitReifyTypeVar$1: function(node) {
    },
    visitConditional$1: function(node) {
      node.condition.accept$1(0, this);
      node.thenExpression.accept$1(0, this);
      node.elseExpression.accept$1(0, this);
    },
    visitLogicalOperator$1: function(node) {
      node.left.accept$1(0, this);
      node.right.accept$1(0, this);
    },
    visitNot$1: function(node) {
      node.get$operand().accept$1(0, this);
    },
    visitLiteralList$1: function(node) {
      H.IterableMixinWorkaround_forEach(node.get$values(node), this.get$visitExpression());
    },
    visitLiteralMap$1: function(node) {
      var t1, t2, i;
      for (t1 = node.keys, t2 = node.values, i = 0; i < t1.length; ++i) {
        J.accept$1$x(t1[i], this);
        if (i >= t2.length)
          return H.ioore(t2, i);
        J.accept$1$x(t2[i], this);
      }
    },
    visitTypeOperator$1: function(node) {
      node.receiver.accept$1(0, this);
    },
    visitFunctionExpression$1: function(node) {
      this.visitFunctionDefinition$1(node.definition);
    },
    visitLabeledStatement$1: function(node) {
      node.body.accept$1(0, this);
      node.next.accept$1(0, this);
    },
    visitAssign$1: function(node) {
      node.definition.accept$1(0, this);
      this.visitVariable$1(node.variable);
      node.next.accept$1(0, this);
    },
    visitReturn$1: function(node) {
      node.get$value(node).accept$1(0, this);
    },
    visitBreak$1: function(node) {
    },
    visitContinue$1: function(node) {
    },
    visitIf$1: function(node) {
      node.get$condition().accept$1(0, this);
      node.get$thenStatement().accept$1(0, this);
      node.elseStatement.accept$1(0, this);
    },
    visitWhileTrue$1: function(node) {
      node.body.accept$1(0, this);
    },
    visitWhileCondition$1: function(node) {
      node.condition.accept$1(0, this);
      node.body.accept$1(0, this);
      node.next.accept$1(0, this);
    },
    visitFunctionDeclaration$1: function(node) {
      this.visitFunctionDefinition$1(node.definition);
      node.next.accept$1(0, this);
    },
    visitExpressionStatement$1: function(node) {
      node.expression.accept$1(0, this);
      node.next.accept$1(0, this);
    },
    $asVisitor0: function() {
      return [null, null];
    }
  }
}],
["tree_ir_tracer", "package:compiler/implementation/dart_backend/tree_ir_tracer.dart", , Z, {
  "^": "",
  Block2: {
    "^": "Object;label,index>,statements,predecessors<,successors<",
    get$name: function(_) {
      return "B" + H.S(this.index);
    },
    $isBlock2: true
  },
  BlockCollector: {
    "^": "StatementVisitor;blocks,breakTargets,continueTargets,ifTargets",
    visitLabeledStatement$1: function(node) {
      var t1, target;
      t1 = node.label;
      target = new Z.Block2(t1, null, [], H.setRuntimeTypeInfo([], [Z.Block2]), H.setRuntimeTypeInfo([], [Z.Block2]));
      this.breakTargets.$indexSet(0, t1, target);
      node.body.accept$1(0, this);
      t1 = this.blocks;
      target.index = t1.length;
      t1.push(target);
      node.next.accept$1(0, this);
    },
    visitAssign$1: function(node) {
      C.JSArray_methods.get$last(this.blocks).statements.push(node);
      node.next.accept$1(0, this);
    },
    visitReturn$1: function(node) {
      C.JSArray_methods.get$last(this.blocks).statements.push(node);
    },
    visitBreak$1: function(node) {
      var t1, t2;
      t1 = this.blocks;
      C.JSArray_methods.get$last(t1).statements.push(node);
      t1 = C.JSArray_methods.get$last(t1);
      t2 = this.breakTargets.$index(0, node.get$target(node));
      t1.successors.push(t2);
      t2.predecessors.push(t1);
    },
    visitContinue$1: function(node) {
      var t1, t2;
      t1 = this.blocks;
      C.JSArray_methods.get$last(t1).statements.push(node);
      t1 = C.JSArray_methods.get$last(t1);
      t2 = this.continueTargets.$index(0, node.get$target(node));
      t1.successors.push(t2);
      t2.predecessors.push(t1);
    },
    visitIf$1: function(node) {
      var t1, t2, thenTarget, t3, elseTarget, t4;
      t1 = this.blocks;
      C.JSArray_methods.get$last(t1).statements.push(node);
      t2 = H.setRuntimeTypeInfo([], [Z.Block2]);
      thenTarget = new Z.Block2(null, null, [], t2, H.setRuntimeTypeInfo([], [Z.Block2]));
      t3 = H.setRuntimeTypeInfo([], [Z.Block2]);
      elseTarget = new Z.Block2(null, null, [], t3, H.setRuntimeTypeInfo([], [Z.Block2]));
      t4 = this.ifTargets;
      t4.$indexSet(0, node.get$thenStatement(), thenTarget);
      t4.$indexSet(0, node.elseStatement, elseTarget);
      t4 = C.JSArray_methods.get$last(t1);
      t4.successors.push(thenTarget);
      t2.push(t4);
      t4 = C.JSArray_methods.get$last(t1);
      t4.successors.push(elseTarget);
      t3.push(t4);
      thenTarget.index = t1.length;
      t1.push(thenTarget);
      node.thenStatement.accept$1(0, this);
      elseTarget.index = t1.length;
      t1.push(elseTarget);
      node.elseStatement.accept$1(0, this);
    },
    visitWhileTrue$1: function(node) {
      var t1, continueTarget, t2, t3;
      t1 = H.setRuntimeTypeInfo([], [Z.Block2]);
      continueTarget = new Z.Block2(null, null, [], t1, H.setRuntimeTypeInfo([], [Z.Block2]));
      t2 = this.blocks;
      C.JSArray_methods.get$last(t2).statements.push(continueTarget);
      this.continueTargets.$indexSet(0, node.label, continueTarget);
      t3 = C.JSArray_methods.get$last(t2);
      t3.successors.push(continueTarget);
      t1.push(t3);
      continueTarget.index = t2.length;
      t2.push(continueTarget);
      C.JSArray_methods.get$last(t2).statements.push(node);
      node.body.accept$1(0, this);
    },
    visitWhileCondition$1: function(node) {
      var t1, t2, t3, whileBlock, t4, bodyBlock, nextBlock;
      t1 = [];
      t2 = H.setRuntimeTypeInfo([], [Z.Block2]);
      t3 = H.setRuntimeTypeInfo([], [Z.Block2]);
      whileBlock = new Z.Block2(null, null, t1, t2, t3);
      t4 = this.blocks;
      C.JSArray_methods.get$last(t4).statements.push(whileBlock);
      whileBlock.index = t4.length;
      t4.push(whileBlock);
      C.JSArray_methods.get$last(t4).statements.push(node);
      t1.push(node);
      t1 = C.JSArray_methods.get$last(t4);
      t1.successors.push(whileBlock);
      t2.push(t1);
      t1 = H.setRuntimeTypeInfo([], [Z.Block2]);
      bodyBlock = new Z.Block2(null, null, [], t1, H.setRuntimeTypeInfo([], [Z.Block2]));
      t2 = H.setRuntimeTypeInfo([], [Z.Block2]);
      nextBlock = new Z.Block2(null, null, [], t2, H.setRuntimeTypeInfo([], [Z.Block2]));
      t3.push(bodyBlock);
      t1.push(whileBlock);
      t3.push(nextBlock);
      t2.push(whileBlock);
      this.continueTargets.$indexSet(0, node.label, bodyBlock);
      bodyBlock.index = t4.length;
      t4.push(bodyBlock);
      node.body.accept$1(0, this);
      nextBlock.index = t4.length;
      t4.push(nextBlock);
      node.next.accept$1(0, this);
      t4 = this.ifTargets;
      t4.$indexSet(0, node.body, bodyBlock);
      t4.$indexSet(0, node.next, nextBlock);
    },
    visitExpressionStatement$1: function(node) {
      C.JSArray_methods.get$last(this.blocks).statements.push(node);
      node.next.accept$1(0, this);
    },
    visitFunctionDeclaration$1: function(node) {
      C.JSArray_methods.get$last(this.blocks).statements.push(node);
      node.next.accept$1(0, this);
    },
    $asStatementVisitor: function() {
      return [null];
    }
  },
  TreeTracer: {
    "^": "TracerUtil_StatementVisitor;output<,names,collector,statementCounter,tracer$TracerUtil$_ind",
    traceGraph$2: function($name, $function) {
      var t1;
      this.names = new Z.Names(P.LinkedHashMap_LinkedHashMap$_empty(null, null), P.LinkedHashSet_LinkedHashSet(null, null, null, null), 0);
      this.statementCounter = 0;
      t1 = new Z.Block2(null, null, [], H.setRuntimeTypeInfo([], [Z.Block2]), H.setRuntimeTypeInfo([], [Z.Block2]));
      t1.index = 0;
      t1 = new Z.BlockCollector([t1], P.LinkedHashMap_LinkedHashMap$_empty(M.Label0, Z.Block2), P.LinkedHashMap_LinkedHashMap$_empty(M.Label0, Z.Block2), P.LinkedHashMap_LinkedHashMap$_empty(M.Statement0, Z.Block2));
      this.collector = t1;
      $function.body.accept$1(0, t1);
      this.tag$2(0, "cfg", new Z.TreeTracer_traceGraph_closure(this, $name));
      this.names = null;
    },
    printBlock$1: [function(block) {
      this.tag$2(0, "block", new Z.TreeTracer_printBlock_closure(this, block));
    }, "call$1", "get$printBlock", 2, 0, 299],
    visitBlockMember$1: [function(member) {
      if (!!J.getInterceptor(member).$isBlock2)
        this.printStatement$2(null, "goto block B" + ("B" + H.S(member.index)));
      else
        this.visitStatement$1(member);
    }, "call$1", "get$visitBlockMember", 2, 0, 8],
    printStatement$2: function($name, contents) {
      var t1 = this.statementCounter;
      if (typeof t1 !== "number")
        return t1.$add();
      this.statementCounter = t1 + 1;
      $name = "x" + t1;
      t1 = this.output;
      t1.add$1(0, this.tracer$TracerUtil$_ind.get$indentation());
      t1.add$1(0, "0 0 " + $name + " " + H.S(contents) + " <|@\n");
    },
    visitLabeledStatement$1: function(node) {
    },
    visitAssign$1: function(node) {
      var $name, rhs, extra;
      $name = this.names.varName$1(node.variable);
      rhs = node.definition.accept$1(0, new Z.SubexpressionVisitor(this.names));
      extra = node.variable.readCount === 1 ? "[single-use]" : "";
      this.printStatement$2(null, "assign " + H.S($name) + " = " + H.S(rhs) + " " + extra);
    },
    visitReturn$1: function(node) {
      this.printStatement$2(null, "return " + H.S(node.get$value(node).accept$1(0, new Z.SubexpressionVisitor(this.names))));
    },
    visitBreak$1: function(node) {
      this.printStatement$2(null, "break " + ("B" + H.S(this.collector.breakTargets.$index(0, node.get$target(node)).index)));
    },
    visitContinue$1: function(node) {
      this.printStatement$2(null, "continue " + ("B" + H.S(this.collector.continueTargets.$index(0, node.get$target(node)).index)));
    },
    visitIf$1: function(node) {
      var condition, thenTarget, elseTarget;
      condition = node.get$condition().accept$1(0, new Z.SubexpressionVisitor(this.names));
      thenTarget = "B" + H.S(this.collector.ifTargets.$index(0, node.get$thenStatement()).index);
      elseTarget = "B" + H.S(this.collector.ifTargets.$index(0, node.elseStatement).index);
      this.printStatement$2(null, "if " + H.S(condition) + " then " + thenTarget + " else " + elseTarget);
    },
    visitWhileTrue$1: function(node) {
      this.printStatement$2(null, "while true do");
    },
    visitWhileCondition$1: function(node) {
      var bodyTarget, nextTarget;
      bodyTarget = "B" + H.S(this.collector.ifTargets.$index(0, node.body).index);
      nextTarget = "B" + H.S(this.collector.ifTargets.$index(0, node.next).index);
      this.printStatement$2(null, "while " + H.S(node.condition.accept$1(0, new Z.SubexpressionVisitor(this.names))));
      this.printStatement$2(null, "do " + bodyTarget);
      this.printStatement$2(null, "then " + nextTarget);
    },
    visitExpressionStatement$1: function(node) {
      this.printStatement$2(null, node.expression.accept$1(0, new Z.SubexpressionVisitor(this.names)));
    },
    visitFunctionDeclaration$1: function(node) {
      this.printStatement$2(null, "function " + H.S(node.definition.element.name));
    }
  },
  TracerUtil_StatementVisitor: {
    "^": "TracerUtil+StatementVisitor;"
  },
  TreeTracer_traceGraph_closure: {
    "^": "Closure:23;this_0,name_1",
    call$0: function() {
      var t1, t2, t3;
      t1 = this.this_0;
      t2 = "name " + t1.formatPrty$1(this.name_1);
      t3 = t1.output;
      t3.add$1(0, t1.tracer$TracerUtil$_ind.get$indentation());
      t3.add$1(0, t2);
      t3.add$1(0, "\n");
      H.IterableMixinWorkaround_forEach(t1.collector.blocks, t1.get$printBlock());
    },
    $isFunction: true
  },
  TreeTracer_printBlock_closure: {
    "^": "Closure:23;this_0,block_1",
    call$0: function() {
      var t1, t2, t3, t4, t5;
      t1 = this.this_0;
      t2 = this.block_1;
      t3 = "name " + t1.formatPrty$1("B" + H.S(t2.index));
      t4 = t1.tracer$TracerUtil$_ind;
      t5 = t1.output;
      t5.add$1(0, t4.get$indentation());
      t5.add$1(0, t3);
      t5.add$1(0, "\n");
      t3 = "from_bci " + t1.formatPrty$1(-1);
      t5.add$1(0, t4.get$indentation());
      t5.add$1(0, t3);
      t5.add$1(0, "\n");
      t3 = "to_bci " + t1.formatPrty$1(-1);
      t5.add$1(0, t4.get$indentation());
      t5.add$1(0, t3);
      t5.add$1(0, "\n");
      t3 = "predecessors " + t1.formatPrty$1(H.setRuntimeTypeInfo(new H.MappedListIterable(t2.predecessors, new Z.TreeTracer_printBlock__closure()), [null, null]));
      t5.add$1(0, t4.get$indentation());
      t5.add$1(0, t3);
      t5.add$1(0, "\n");
      t3 = "successors " + t1.formatPrty$1(H.setRuntimeTypeInfo(new H.MappedListIterable(t2.successors, new Z.TreeTracer_printBlock__closure0()), [null, null]));
      t5.add$1(0, t4.get$indentation());
      t5.add$1(0, t3);
      t5.add$1(0, "\n");
      t5.add$1(0, t4.get$indentation());
      t5.add$1(0, "xhandlers");
      t5.add$1(0, "\n");
      t5.add$1(0, t4.get$indentation());
      t5.add$1(0, "flags");
      t5.add$1(0, "\n");
      t1.tag$2(0, "states", new Z.TreeTracer_printBlock__closure1(t1));
      t1.tag$2(0, "HIR", new Z.TreeTracer_printBlock__closure2(t1, t2));
    },
    $isFunction: true
  },
  TreeTracer_printBlock__closure: {
    "^": "Closure:13;",
    call$1: function(b) {
      return J.get$name$x(b);
    },
    $isFunction: true
  },
  TreeTracer_printBlock__closure0: {
    "^": "Closure:13;",
    call$1: function(b) {
      return J.get$name$x(b);
    },
    $isFunction: true
  },
  TreeTracer_printBlock__closure1: {
    "^": "Closure:23;this_2",
    call$0: function() {
      var t1 = this.this_2;
      t1.tag$2(0, "locals", new Z.TreeTracer_printBlock___closure(t1));
    },
    $isFunction: true
  },
  TreeTracer_printBlock___closure: {
    "^": "Closure:23;this_3",
    call$0: function() {
      var t1, t2, t3, t4;
      t1 = this.this_3;
      t2 = "size " + t1.formatPrty$1(0);
      t3 = t1.tracer$TracerUtil$_ind;
      t4 = t1.output;
      t4.add$1(0, t3.get$indentation());
      t4.add$1(0, t2);
      t4.add$1(0, "\n");
      t1 = "method " + t1.formatPrty$1("None");
      t4.add$1(0, t3.get$indentation());
      t4.add$1(0, t1);
      t4.add$1(0, "\n");
    },
    $isFunction: true
  },
  TreeTracer_printBlock__closure2: {
    "^": "Closure:23;this_4,block_5",
    call$0: function() {
      var t1, t2;
      t1 = this.block_5;
      t2 = t1.label;
      if (t2 != null)
        this.this_4.printStatement$2(null, "Label " + ("B" + H.S(t1.index)) + ", useCount=" + t2.useCount);
      H.IterableMixinWorkaround_forEach(t1.statements, this.this_4.get$visitBlockMember());
    },
    $isFunction: true
  },
  SubexpressionVisitor: {
    "^": "ExpressionVisitor;names",
    visitVariable$1: function(node) {
      return this.names.varName$1(node);
    },
    formatArguments$1: function(node) {
      var args, t1, positionalArgumentCount, i, $name, t2, arg;
      args = H.setRuntimeTypeInfo([], [P.String]);
      t1 = node.get$selector();
      positionalArgumentCount = t1.argumentCount - t1.namedArguments.length;
      for (i = 0; i < positionalArgumentCount; ++i) {
        t1 = node.get$arguments();
        if (i >= t1.length)
          return H.ioore(t1, i);
        args.push(J.accept$1$x(t1[i], this));
      }
      for (i = 0; i < node.get$selector().namedArguments.length; ++i) {
        t1 = node.get$selector().namedArguments;
        if (i >= t1.length)
          return H.ioore(t1, i);
        $name = t1[i];
        t1 = node.get$arguments();
        t2 = positionalArgumentCount + i;
        if (t2 < 0 || t2 >= t1.length)
          return H.ioore(t1, t2);
        arg = J.accept$1$x(t1[t2], this);
        args.push(H.S($name) + ": " + H.S(arg));
      }
      return C.JSArray_methods.join$1(args, ", ");
    },
    visitInvokeStatic$1: function(node) {
      var t1, head, args;
      t1 = node.get$target(node);
      head = t1.get$name(t1);
      args = this.formatArguments$1(node);
      return H.S(head) + "(" + args + ")";
    },
    visitInvokeMethod$1: function(node) {
      var receiver, $name, args;
      receiver = node.receiver.accept$1(0, this);
      $name = node.selector.name;
      args = this.formatArguments$1(node);
      return H.S(receiver) + "." + H.S($name) + "(" + args + ")";
    },
    visitInvokeSuperMethod$1: function(node) {
      var $name, args;
      $name = node.selector.name;
      args = this.formatArguments$1(node);
      return "super." + H.S($name) + "(" + args + ")";
    },
    visitInvokeConstructor$1: function(node) {
      var t1, t2, callName, args;
      t1 = node.target;
      t2 = node.type;
      callName = J.get$isEmpty$asx(t1.get$name(t1)) ? J.toString$0(t2) : J.toString$0(t2) + "." + H.S(t1.name);
      args = this.formatArguments$1(node);
      return "new " + H.S(callName) + "(" + args + ")";
    },
    visitConcatenateStrings$1: function(node) {
      return "concat [" + H.setRuntimeTypeInfo(new H.MappedListIterable(node.arguments, this.get$visitExpression()), [null, null]).join$1(0, ", ") + "]";
    },
    visitLiteralList$1: function(node) {
      return "list [" + H.setRuntimeTypeInfo(new H.MappedListIterable(node.get$values(node), this.get$visitExpression()), [null, null]).join$1(0, ", ") + "]";
    },
    visitLiteralMap$1: function(node) {
      var entries, t1, t2, i, key, value;
      entries = H.setRuntimeTypeInfo([], [P.String]);
      for (t1 = node.values, t2 = node.keys, i = 0; i < t1.length; ++i) {
        if (i >= t2.length)
          return H.ioore(t2, i);
        key = J.accept$1$x(t2[i], this);
        if (i >= t1.length)
          return H.ioore(t1, i);
        value = J.accept$1$x(t1[i], this);
        entries.push(H.S(key) + ": " + H.S(value));
      }
      return "map [" + C.JSArray_methods.join$1(entries, ", ") + "]";
    },
    visitConstant$1: function(node) {
      return J.toString$0(node.get$value(node));
    },
    visitThis$1: function(node) {
      return "this";
    },
    visitReifyTypeVar$1: function(node) {
      return "typevar [" + H.S(node.typeVariable.name) + "]";
    },
    visitConditional$1: function(node) {
      var condition, thenExpr, elseExpr;
      condition = node.condition.accept$1(0, this);
      thenExpr = node.thenExpression.accept$1(0, this);
      elseExpr = node.elseExpression.accept$1(0, this);
      return H.S(condition) + " ? " + H.S(thenExpr) + " : " + H.S(elseExpr);
    },
    visitLogicalOperator$1: function(node) {
      var left, right, t1;
      left = node.left.accept$1(0, this);
      right = node.right.accept$1(0, this);
      t1 = J.getInterceptor(node.left);
      if (!!t1.$isConditional2 || !!t1.$isLogicalOperator)
        left = "(" + H.S(left) + ")";
      t1 = J.getInterceptor(node.right);
      if (!!t1.$isConditional2 || !!t1.$isLogicalOperator)
        right = "(" + H.S(right) + ")";
      t1 = H.S(left) + " ";
      return t1 + (node.isAnd ? "&&" : "||") + " " + H.S(right);
    },
    visitTypeOperator$1: function(node) {
      var receiver, type;
      receiver = node.receiver.accept$1(0, this);
      type = J.toString$0(node.type);
      return "TypeOperator " + H.S(receiver) + " " + H.S(node.operator) + " " + type;
    },
    visitNot$1: function(node) {
      var operand, t1;
      operand = node.get$operand().accept$1(0, this);
      t1 = J.getInterceptor(node.operand);
      return "!" + H.S(!!t1.$isConditional2 || !!t1.$isLogicalOperator ? "(" + H.S(operand) + ")" : operand);
    },
    visitFunctionExpression$1: function(node) {
      return "function " + H.S(node.definition.element.name);
    },
    $asExpressionVisitor: function() {
      return [P.String];
    }
  },
  Names: {
    "^": "Object;_names,_usedNames,_counter",
    varName$1: function(v) {
      var t1, $name, t2, prefix;
      t1 = this._names;
      $name = t1.$index(0, v);
      if ($name == null) {
        t2 = v.element;
        prefix = t2 == null ? "v" : H.S(t2.get$name(t2)) + "_";
        t2 = this._usedNames;
        while (true) {
          if (!($name == null || t2.contains$1(0, $name)))
            break;
          $name = prefix + this._counter++;
        }
        t1.$indexSet(0, v, $name);
        t2.add$1(0, $name);
      }
      return $name;
    }
  }
}],
["type_graph_inferrer", "package:compiler/implementation/inferrer/type_graph_inferrer.dart", , G, {
  "^": "",
  ClosureTracerVisitor: {
    "^": "TracerVisitor;tracedElements,tracedType,inferrer,compiler,analyzedElements,workList,listsToAnalyze,mapsToAnalyze,flowsInto,currentUser,continueAnalyzing",
    run$0: function() {
      var t1, t2;
      for (t1 = this.tracedElements, t2 = H.setRuntimeTypeInfo(new H.ListIterator(t1, t1.length, 0, null), [H.getTypeArgumentByIndex(t1, 0)]); t2.moveNext$0();)
        t2.__internal$_current.get$functionSignature().forEachParameter$1(new G.ClosureTracerVisitor_run_closure(this));
      this.analyze$0();
      for (t1 = H.setRuntimeTypeInfo(new H.ListIterator(t1, t1.length, 0, null), [H.getTypeArgumentByIndex(t1, 0)]); t1.moveNext$0();)
        t1.__internal$_current.get$functionSignature().forEachParameter$1(new G.ClosureTracerVisitor_run_closure0(this));
    },
    tagAsFunctionApplyTarget$1: function(reason) {
      var t1 = this.tracedType;
      t1.set$mightBePassedToFunctionApply(true);
      if ($._VERBOSE)
        P.print("Closure " + H.S(t1) + " might be passed to apply: " + reason);
    },
    analyzeCall$1: function(info) {
      H.IterableMixinWorkaround_forEach(this.tracedElements, new G.ClosureTracerVisitor_analyzeCall_closure(this, info, info.get$selector()));
    },
    visitClosureCallSiteTypeInformation$1: function(info) {
      var t1, t2;
      G.TracerVisitor.prototype.visitClosureCallSiteTypeInformation$1.call(this, info);
      t1 = info.closure;
      t2 = this.currentUser;
      if (t1 == null ? t2 == null : t1 === t2)
        this.analyzeCall$1(info);
      else
        this.bailout$1("Passed to a closure");
    },
    visitStaticCallSiteTypeInformation$1: function(info) {
      var called, t1, $name, t2, t3;
      G.TracerVisitor.prototype.visitStaticCallSiteTypeInformation$1.call(this, info);
      called = info.calledElement;
      t1 = this.compiler;
      if (called.isForeign$1(t1)) {
        $name = called.name;
        if ($name === "JS" || $name === "DART_CLOSURE_TO_JS")
          this.bailout$1("Used in JS " + J.toString$0(info.$call));
      }
      if (called.get$isGetter()) {
        t2 = info.selector;
        if (t2 != null)
          if (t2.kind === C.SelectorKind_call_2) {
            t2 = this.inferrer.types.getInferredTypeOf$1(called);
            t3 = this.currentUser;
            t3 = t2 == null ? t3 == null : t2 === t3;
            t2 = t3;
          } else
            t2 = false;
        else
          t2 = false;
      } else
        t2 = false;
      if (t2)
        this.analyzeCall$1(info);
      if (t1.functionApplyMethod === called) {
        t1 = info.arguments;
        if (t1 != null) {
          t2 = this.currentUser;
          t1 = C.JSArray_methods.contains$1(t1.positional, t2) || t1.named.containsValue$1(t2);
        } else
          t1 = false;
      } else
        t1 = false;
      if (t1)
        this.tagAsFunctionApplyTarget$1("static call");
    },
    checkIfFunctionApply$1: [function(element) {
      var t1 = this.compiler.functionApplyMethod;
      return t1 == null ? element == null : t1 === element;
    }, "call$1", "get$checkIfFunctionApply", 2, 0, 300],
    visitDynamicCallSiteTypeInformation$1: function(info) {
      var t1, t2;
      G.TracerVisitor.prototype.visitDynamicCallSiteTypeInformation$1.call(this, info);
      t1 = info.selector;
      t2 = t1.kind;
      if (t2 === C.SelectorKind_call_2) {
        t1 = info.arguments;
        t2 = this.currentUser;
        if (C.JSArray_methods.contains$1(t1.positional, t2) || t1.named.containsValue$1(t2)) {
          if (!J.every$1$ax(info.targets, new G.ClosureTracerVisitor_visitDynamicCallSiteTypeInformation_closure()))
            this.bailout$1("Passed to a closure");
          if (J.any$1$ax(info.targets, this.get$checkIfFunctionApply()))
            this.tagAsFunctionApplyTarget$1("dynamic call");
        } else if (J.any$1$ax(info.targets, new G.ClosureTracerVisitor_visitDynamicCallSiteTypeInformation_closure0(this)))
          this.analyzeCall$1(info);
      } else if (t2 === C.SelectorKind_getter_0 && t1.name === "call")
        this.addNewEscapeInformation$1(info);
    },
    $asTracerVisitor: function() {
      return [G.ApplyableTypeInformation];
    }
  },
  ClosureTracerVisitor_run_closure: {
    "^": "Closure:77;this_0",
    call$1: function(parameter) {
      var info, t1, t2;
      info = this.this_0.inferrer.types.getInferredTypeOf$1(parameter);
      if (info.abandonInferencing) {
        t1 = info.assignments;
        t2 = $.get$TypeInformation_STOP_TRACKING_ASSIGNMENTS_MARKER();
        t2 = t1 == null ? t2 == null : t1 === t2;
        t1 = t2;
      } else
        t1 = false;
      info.abandonInferencing = t1;
    },
    $isFunction: true
  },
  ClosureTracerVisitor_run_closure0: {
    "^": "Closure:77;this_1",
    call$1: function(parameter) {
      var t1, t2, info;
      t1 = this.this_1;
      t2 = t1.inferrer;
      info = t2.types.getInferredTypeOf$1(parameter);
      if (t1.continueAnalyzing)
        info.disableInferenceForClosures = false;
      else
        info.giveUp$1(t2);
    },
    $isFunction: true
  },
  ClosureTracerVisitor_analyzeCall_closure: {
    "^": "Closure:128;this_0,info_1,selector_2",
    call$1: function(functionElement) {
      var t1, t2, t3;
      t1 = this.selector_2;
      t2 = this.this_0;
      if (!t1.signatureApplies$2(functionElement, t2.compiler))
        return;
      t3 = this.info_1;
      t2.inferrer.updateParameterAssignments$6$addToQueue$remove(t3, functionElement, t3.get$arguments(), t1, false, false);
    },
    $isFunction: true
  },
  ClosureTracerVisitor_visitDynamicCallSiteTypeInformation_closure: {
    "^": "Closure:13;",
    call$1: function(element) {
      return element.get$isFunction();
    },
    $isFunction: true
  },
  ClosureTracerVisitor_visitDynamicCallSiteTypeInformation_closure0: {
    "^": "Closure:13;this_0",
    call$1: function(element) {
      var t1, t2;
      t1 = this.this_0;
      t2 = t1.inferrer.types.getInferredTypeOf$1(element);
      t1 = t1.currentUser;
      return t2 == null ? t1 == null : t2 === t1;
    },
    $isFunction: true
  },
  StaticTearOffClosureTracerVisitor: {
    "^": "ClosureTracerVisitor;tracedElements,tracedType,inferrer,compiler,analyzedElements,workList,listsToAnalyze,mapsToAnalyze,flowsInto,currentUser,continueAnalyzing",
    visitStaticCallSiteTypeInformation$1: function(info) {
      var t1, t2;
      G.ClosureTracerVisitor.prototype.visitStaticCallSiteTypeInformation$1.call(this, info);
      t1 = info.calledElement;
      t2 = C.JSArray_methods.get$first(this.tracedElements);
      if (t1 == null ? t2 == null : t1 === t2) {
        t1 = info.selector;
        t1 = t1 != null && t1.kind === C.SelectorKind_getter_0;
      } else
        t1 = false;
      if (t1)
        this.addNewEscapeInformation$1(info);
    }
  },
  ListTracerVisitor: {
    "^": "TracerVisitor;assignments<,callsGrowableMethod,tracedType,inferrer,compiler,analyzedElements,workList,listsToAnalyze,mapsToAnalyze,flowsInto,currentUser,continueAnalyzing",
    run$0: function() {
      this.analyze$0();
      var list = this.tracedType;
      if (this.continueAnalyzing) {
        if (!this.callsGrowableMethod && list.get$inferredLength() == null)
          list.inferredLength = list.get$originalLength();
        list.get$flowsInto().addAll$1(0, this.flowsInto);
        return true;
      } else {
        this.callsGrowableMethod = true;
        this.assignments = null;
        return false;
      }
    },
    visitClosureCallSiteTypeInformation$1: function(info) {
      this.bailout$1("Passed to a closure");
    },
    visitStaticCallSiteTypeInformation$1: function(info) {
      var called;
      G.TracerVisitor.prototype.visitStaticCallSiteTypeInformation$1.call(this, info);
      called = info.calledElement;
      if (called.isForeign$1(this.compiler) && called.name === "JS")
        this.bailout$1("Used in JS " + J.toString$0(info.$call));
    },
    visitDynamicCallSiteTypeInformation$1: function(info) {
      var selector, selectorName, t1, t2, positionalLength;
      G.TracerVisitor.prototype.visitDynamicCallSiteTypeInformation$1.call(this, info);
      selector = info.selector;
      selectorName = selector.name;
      t1 = this.currentUser;
      t2 = info.receiver;
      if (t1 == null ? t2 == null : t1 === t2) {
        if (!$.get$okListSelectorsSet().contains$1(0, selectorName)) {
          t1 = selector.kind;
          if (t1 === C.SelectorKind_call_2) {
            t1 = info.arguments.positional;
            positionalLength = t1.length;
            if (selectorName === "add") {
              if (positionalLength === 1) {
                t2 = this.assignments;
                if (0 >= positionalLength)
                  return H.ioore(t1, 0);
                t2.push(t1[0]);
              }
            } else if (selectorName === "insert") {
              if (positionalLength === 2) {
                t2 = this.assignments;
                if (1 >= positionalLength)
                  return H.ioore(t1, 1);
                t2.push(t1[1]);
              }
            } else {
              this.bailout$1("Used in a not-ok selector");
              return;
            }
          } else {
            t1 = t1 === C.SelectorKind_index_4;
            if (t1 && selector.argumentCount === 2) {
              t1 = this.assignments;
              t2 = info.arguments.positional;
              if (1 >= t2.length)
                return H.ioore(t2, 1);
              t1.push(t2[1]);
            } else if (!(t1 && selector.argumentCount === 1)) {
              this.bailout$1("Used in a not-ok selector");
              return;
            }
          }
        }
        if (!$.get$doNotChangeLengthSelectorsSet().contains$1(0, selectorName))
          this.callsGrowableMethod = true;
        if (selectorName === "length" && selector.kind === C.SelectorKind_setter_1) {
          this.callsGrowableMethod = true;
          this.assignments.push(this.inferrer.types.get$nullType());
        }
      } else if (selector.kind === C.SelectorKind_call_2 && !J.every$1$ax(info.targets, new G.ListTracerVisitor_visitDynamicCallSiteTypeInformation_closure())) {
        this.bailout$1("Passed to a closure");
        return;
      }
    },
    $asTracerVisitor: function() {
      return [G.ListTypeInformation];
    }
  },
  ListTracerVisitor_visitDynamicCallSiteTypeInformation_closure: {
    "^": "Closure:13;",
    call$1: function(element) {
      return element.get$isFunction();
    },
    $isFunction: true
  },
  MapTracerVisitor: {
    "^": "TracerVisitor;keyAssignments,valueAssignments,mapAssignments,tracedType,inferrer,compiler,analyzedElements,workList,listsToAnalyze,mapsToAnalyze,flowsInto,currentUser,continueAnalyzing",
    run$0: function() {
      this.analyze$0();
      if (this.continueAnalyzing) {
        this.tracedType.get$flowsInto().addAll$1(0, this.flowsInto);
        return true;
      }
      this.mapAssignments = null;
      this.valueAssignments = null;
      this.keyAssignments = null;
      return false;
    },
    visitClosureCallSiteTypeInformation$1: function(info) {
      this.bailout$1("Passed to a closure");
    },
    visitStaticCallSiteTypeInformation$1: function(info) {
      var called;
      G.TracerVisitor.prototype.visitStaticCallSiteTypeInformation$1.call(this, info);
      called = info.calledElement;
      if (called.isForeign$1(this.compiler) && called.name === "JS")
        this.bailout$1("Used in JS " + J.toString$0(info.$call));
    },
    visitDynamicCallSiteTypeInformation$1: function(info) {
      var selector, selectorName, t1, t2, map;
      G.TracerVisitor.prototype.visitDynamicCallSiteTypeInformation$1.call(this, info);
      selector = info.selector;
      selectorName = selector.name;
      t1 = this.currentUser;
      t2 = info.receiver;
      if (t1 == null ? t2 == null : t1 === t2) {
        if (!$.get$okMapSelectorsSet().contains$1(0, selectorName)) {
          t1 = selector.kind;
          if (t1 === C.SelectorKind_call_2) {
            t1 = info.arguments.positional;
            if (selectorName === "addAll") {
              if (0 >= t1.length)
                return H.ioore(t1, 0);
              map = t1[0];
              if (!!J.getInterceptor(map).$isMapTypeInformation) {
                this.inferrer.analyzeMapAndEnqueue$1(map);
                this.mapAssignments.push(map);
              } else
                this.bailout$1("Adding map with unknown typeinfo to current map");
            } else if (selectorName === "putIfAbsent") {
              t2 = this.keyAssignments;
              if (0 >= t1.length)
                return H.ioore(t1, 0);
              t2.push(t1[0]);
              this.valueAssignments.push(this.inferrer.types.get$dynamicType());
            } else {
              this.bailout$1("Map used in a not-ok selector [" + H.S(selectorName) + "]");
              return;
            }
          } else {
            t1 = t1 === C.SelectorKind_index_4;
            if (t1 && selector.argumentCount === 2) {
              t1 = this.keyAssignments;
              t2 = info.arguments.positional;
              if (0 >= t2.length)
                return H.ioore(t2, 0);
              t1.push(t2[0]);
              t1 = this.valueAssignments;
              if (1 >= t2.length)
                return H.ioore(t2, 1);
              t1.push(t2[1]);
            } else if (!(t1 && selector.argumentCount === 1)) {
              this.bailout$1("Map used in a not-ok selector [" + H.S(selectorName) + "]");
              return;
            }
          }
        }
      } else if (selector.kind === C.SelectorKind_call_2 && !J.every$1$ax(info.targets, new G.MapTracerVisitor_visitDynamicCallSiteTypeInformation_closure())) {
        this.bailout$1("Passed to a closure");
        return;
      }
    },
    $asTracerVisitor: function() {
      return [G.MapTypeInformation];
    }
  },
  MapTracerVisitor_visitDynamicCallSiteTypeInformation_closure: {
    "^": "Closure:13;",
    call$1: function(element) {
      return element.get$isFunction();
    },
    $isFunction: true
  },
  TracerVisitor: {
    "^": "Object;compiler<,flowsInto<",
    addNewEscapeInformation$1: function(info) {
      var t1 = this.flowsInto;
      if (t1.contains$1(0, info) === true)
        return;
      t1.add$1(0, info);
      this.workList.push(info);
    },
    analyze$0: function() {
      var t1, t2, t3, t4, t5, t6, t7, line, info;
      t1 = this.tracedType;
      this.addNewEscapeInformation$1(t1);
      for (t2 = this.workList, t3 = this.mapsToAnalyze, t4 = this.listsToAnalyze, t5 = this.analyzedElements; t6 = t2.length, t6 !== 0;) {
        if (0 >= t6)
          return H.ioore(t2, 0);
        this.currentUser = t2.pop();
        t6 = t5.get$length(t5);
        t7 = J.get$length$asx(this.currentUser.users);
        if (typeof t6 !== "number")
          return t6.$add();
        if (typeof t7 !== "number")
          return H.iae(t7);
        if (t6 + t7 > 16) {
          if ($._VERBOSE) {
            line = "Bailing out on " + H.S(t1) + " because: Too many users";
            H.printString(line);
          }
          this.continueAnalyzing = false;
          break;
        }
        for (t6 = J.get$iterator$ax(this.currentUser.users); t6.moveNext$0();) {
          info = t6.get$current();
          t5.add$1(0, info.get$owner());
          info.accept$1(0, this);
        }
        for (; t6 = t4.length, t6 !== 0;) {
          if (0 >= t6)
            return H.ioore(t4, 0);
          this.analyzeStoredIntoList$1(t4.pop());
        }
        for (; t6 = t3.length, t6 !== 0;) {
          if (0 >= t6)
            return H.ioore(t3, 0);
          this.analyzeStoredIntoMap$1(t3.pop());
        }
        if (!this.continueAnalyzing)
          break;
      }
    },
    bailout$1: function(reason) {
      var line;
      if ($._VERBOSE) {
        line = "Bailing out on " + H.S(this.tracedType) + " because: " + reason;
        H.printString(line);
      }
      this.continueAnalyzing = false;
    },
    visitNarrowTypeInformation$1: function(info) {
      this.addNewEscapeInformation$1(info);
    },
    visitPhiElementTypeInformation$1: function(info) {
      this.addNewEscapeInformation$1(info);
    },
    visitElementInContainerTypeInformation$1: function(info) {
      this.addNewEscapeInformation$1(info);
    },
    visitKeyInMapTypeInformation$1: function(info) {
      this.bailout$1("Used as key in Map");
    },
    visitValueInMapTypeInformation$1: function(info) {
      this.addNewEscapeInformation$1(info);
    },
    visitListTypeInformation$1: function(info) {
      this.listsToAnalyze.push(info);
    },
    visitMapTypeInformation$1: function(info) {
      this.mapsToAnalyze.push(info);
    },
    visitConcreteTypeInformation$1: function(info) {
    },
    visitStringLiteralTypeInformation$1: function(info) {
    },
    visitClosureTypeInformation$1: function(info) {
    },
    visitClosureCallSiteTypeInformation$1: function(info) {
    },
    visitStaticCallSiteTypeInformation$1: function(info) {
      var t1, t2;
      t1 = this.inferrer.types.getInferredTypeOf$1(info.calledElement);
      t2 = this.currentUser;
      if (t1 == null ? t2 == null : t1 === t2)
        this.addNewEscapeInformation$1(info);
    },
    analyzeStoredIntoList$1: function(list) {
      var line;
      this.inferrer.analyzeListAndEnqueue$1(list);
      if (list.bailedOut) {
        if ($._VERBOSE) {
          line = "Bailing out on " + H.S(this.tracedType) + " because: Stored in a list that bailed out";
          H.printString(line);
        }
        this.continueAnalyzing = false;
      } else
        list.flowsInto.forEach$1(0, new G.TracerVisitor_analyzeStoredIntoList_closure(this));
    },
    analyzeStoredIntoMap$1: function(map) {
      var line;
      this.inferrer.analyzeMapAndEnqueue$1(map);
      if (map.bailedOut) {
        if ($._VERBOSE) {
          line = "Bailing out on " + H.S(this.tracedType) + " because: Stored in a map that bailed out";
          H.printString(line);
        }
        this.continueAnalyzing = false;
      } else
        map.flowsInto.forEach$1(0, new G.TracerVisitor_analyzeStoredIntoMap_closure(this));
    },
    isAddedToContainer$1: function(info) {
      var t1, selectorName, $arguments, t2;
      t1 = info.arguments;
      if (t1 == null)
        return false;
      if (!info.receiver.type.get$isContainer())
        return false;
      selectorName = info.selector.name;
      $arguments = t1.positional;
      if (selectorName === "[]=") {
        t1 = this.currentUser;
        if (1 >= $arguments.length)
          return H.ioore($arguments, 1);
        t2 = $arguments[1];
        t2 = t1 == null ? t2 == null : t1 === t2;
        t1 = t2;
      } else
        t1 = false;
      if (!t1) {
        if (selectorName === "insert") {
          t1 = this.currentUser;
          if (1 >= $arguments.length)
            return H.ioore($arguments, 1);
          t2 = $arguments[1];
          t2 = t1 == null ? t2 == null : t1 === t2;
          t1 = t2;
        } else
          t1 = false;
        if (!t1)
          if (selectorName === "add") {
            t1 = this.currentUser;
            if (0 >= $arguments.length)
              return H.ioore($arguments, 0);
            t2 = $arguments[0];
            t2 = t1 == null ? t2 == null : t1 === t2;
            t1 = t2;
          } else
            t1 = false;
        else
          t1 = true;
      } else
        t1 = true;
      return t1;
    },
    isIndexSetOnMap$1: function(info) {
      var receiverType;
      if (info.arguments == null)
        return false;
      receiverType = info.receiver.type;
      if (!receiverType.get$isMap(receiverType))
        return false;
      return info.selector.name === "[]=";
    },
    visitDynamicCallSiteTypeInformation$1: function(info) {
      var mask, t1, t2;
      if (this.isAddedToContainer$1(info)) {
        mask = info.receiver.type;
        if (mask.get$allocationNode() != null)
          this.listsToAnalyze.push(this.inferrer.types.allocatedLists.$index(0, mask.get$allocationNode()));
        else
          this.bailout$1("Stored in too many containers");
      } else {
        if (this.isIndexSetOnMap$1(info)) {
          t1 = this.currentUser;
          t2 = info.arguments.positional;
          if (1 >= t2.length)
            return H.ioore(t2, 1);
          t2 = t2[1];
          t2 = t1 == null ? t2 == null : t1 === t2;
          t1 = t2;
        } else
          t1 = false;
        if (t1) {
          mask = info.receiver.type;
          if (mask.get$allocationNode() != null)
            this.mapsToAnalyze.push(this.inferrer.types.allocatedMaps.$index(0, mask.get$allocationNode()));
          else
            this.bailout$1("Stored in too many maps");
        } else {
          if (this.isIndexSetOnMap$1(info)) {
            t1 = this.currentUser;
            t2 = info.arguments.positional;
            if (0 >= t2.length)
              return H.ioore(t2, 0);
            t2 = t2[0];
            t2 = t1 == null ? t2 == null : t1 === t2;
            t1 = t2;
          } else
            t1 = false;
          if (t1)
            this.bailout$1("Used as key in Map");
        }
      }
      if (info.get$targetsIncludeNoSuchMethod()) {
        t1 = info.arguments;
        if (t1 != null) {
          t2 = this.currentUser;
          t1 = C.JSArray_methods.contains$1(t1.positional, t2) || t1.named.containsValue$1(t2);
        } else
          t1 = false;
      } else
        t1 = false;
      if (t1)
        this.bailout$1("Passed to noSuchMethod");
      if (J.map$1$ax(info.targets, new G.TracerVisitor_visitDynamicCallSiteTypeInformation_closure(this)).any$1(0, new G.TracerVisitor_visitDynamicCallSiteTypeInformation_closure0(this)))
        this.addNewEscapeInformation$1(info);
    },
    isParameterOfListAddingMethod$1: function(element) {
      var t1, t2, method;
      if (element.get$kind(element) !== C.ElementKind_parameter_1)
        return false;
      t1 = element.get$enclosingClass();
      t2 = this.compiler.backend.get$listImplementation();
      if (t1 == null ? t2 != null : t1 !== t2)
        return false;
      method = element.get$enclosingElement();
      if (method.get$name(method) !== "[]=") {
        t1 = method.name;
        t1 = t1 === "add" || t1 === "insert";
      } else
        t1 = true;
      return t1;
    },
    isParameterOfMapAddingMethod$1: function(element) {
      var t1, t2, method;
      if (element.get$kind(element) !== C.ElementKind_parameter_1)
        return false;
      t1 = element.get$enclosingClass();
      t2 = this.compiler.backend.get$mapImplementation();
      if (t1 == null ? t2 != null : t1 !== t2)
        return false;
      method = element.get$enclosingElement();
      return method.get$name(method) === "[]=";
    },
    isClosure$1: function(element) {
      var t1, t2;
      if (!element.get$isFunction())
        return false;
      if (element.get$isInstanceMember() && element.name === "call")
        return true;
      t1 = element.get$outermostEnclosingMemberOrTopLevel().get$declaration();
      t2 = element.get$declaration();
      return t1 == null ? t2 != null : t1 !== t2;
    },
    visitElementTypeInformation$1: function(info) {
      var element = info.element;
      if (element.get$kind(element) === C.ElementKind_parameter_1 && this.inferrer.isNativeElement$1(element.get$enclosingElement()))
        this.bailout$1("Passed to a native method");
      if (info.closurizedCount > 0)
        this.bailout$1("Returned from a closurized method");
      if (this.isClosure$1(element))
        this.bailout$1("Returned from a closure");
      if (this.compiler.backend.isAccessibleByReflection$1(element))
        this.bailout$1("Escape in reflection");
      if (!this.inferrer.compiler.backend.canBeUsedForGlobalOptimizations$1(element))
        this.bailout$1("Escape to code that has special backend treatment");
      if (this.isParameterOfListAddingMethod$1(element) || this.isParameterOfMapAddingMethod$1(element))
        return;
      this.addNewEscapeInformation$1(info);
    }
  },
  TracerVisitor_analyzeStoredIntoList_closure: {
    "^": "Closure:13;this_0",
    call$1: function(flow) {
      J.forEach$1$ax(flow.get$users(), new G.TracerVisitor_analyzeStoredIntoList__closure(this.this_0, flow));
    },
    $isFunction: true
  },
  TracerVisitor_analyzeStoredIntoList__closure: {
    "^": "Closure:13;this_1,flow_2",
    call$1: function(user) {
      var t1, t2, t3;
      if (!J.getInterceptor(user).$isDynamicCallSiteTypeInformation)
        return;
      if (user.receiver !== this.flow_2)
        return;
      t1 = this.this_1;
      t2 = user.selector;
      if (t1.inferrer._returnsListElementTypeSet.contains$1(0, t2))
        t1.addNewEscapeInformation$1(user);
      else {
        t3 = $.get$doesNotEscapeListSet();
        t2 = t2.name;
        if (!t3.contains$1(0, t2))
          t1.bailout$1("Escape from a list via [" + H.S(t2) + "]");
      }
    },
    $isFunction: true
  },
  TracerVisitor_analyzeStoredIntoMap_closure: {
    "^": "Closure:13;this_0",
    call$1: function(flow) {
      J.forEach$1$ax(flow.get$users(), new G.TracerVisitor_analyzeStoredIntoMap__closure(this.this_0, flow));
    },
    $isFunction: true
  },
  TracerVisitor_analyzeStoredIntoMap__closure: {
    "^": "Closure:13;this_1,flow_2",
    call$1: function(user) {
      var t1, t2;
      if (!J.getInterceptor(user).$isDynamicCallSiteTypeInformation)
        return;
      if (user.receiver !== this.flow_2)
        return;
      t1 = user.selector;
      if (t1.kind === C.SelectorKind_index_4 && t1.argumentCount === 1)
        this.this_1.addNewEscapeInformation$1(user);
      else {
        t2 = $.get$doesNotEscapeMapSet();
        t1 = t1.name;
        if (!t2.contains$1(0, t1))
          this.this_1.bailout$1("Escape from a map via [" + H.S(t1) + "]");
      }
    },
    $isFunction: true
  },
  TracerVisitor_visitDynamicCallSiteTypeInformation_closure: {
    "^": "Closure:13;this_0",
    call$1: function(element) {
      return this.this_0.inferrer.types.getInferredTypeOf$1(element);
    },
    $isFunction: true
  },
  TracerVisitor_visitDynamicCallSiteTypeInformation_closure0: {
    "^": "Closure:13;this_1",
    call$1: function(user) {
      return J.$eq(user, this.this_1.currentUser);
    },
    $isFunction: true
  },
  TypeInformationSystem: {
    "^": "TypeSystem;compiler<,typeInformations,allocatedLists,allocatedMaps,allocatedClosures,concreteTypes,allocatedTypes,nullTypeCache,intTypeCache,uint32TypeCache,uint31TypeCache,positiveIntTypeCache,doubleTypeCache,numTypeCache,boolTypeCache,functionTypeCache,listTypeCache,constListTypeCache,fixedListTypeCache,growableListTypeCache,mapTypeCache,constMapTypeCache,stringTypeCache,typeTypeCache,dynamicTypeCache,nonNullEmptyType",
    get$nullType: function() {
      var t1 = this.nullTypeCache;
      if (t1 != null)
        return t1;
      t1 = this.getConcreteTypeFor$1(this.compiler.typesTask.get$nullType());
      this.nullTypeCache = t1;
      return t1;
    },
    get$intType: function() {
      var t1 = this.intTypeCache;
      if (t1 != null)
        return t1;
      t1 = this.getConcreteTypeFor$1(this.compiler.typesTask.get$intType());
      this.intTypeCache = t1;
      return t1;
    },
    get$uint31Type: function() {
      var t1 = this.uint31TypeCache;
      if (t1 != null)
        return t1;
      t1 = this.getConcreteTypeFor$1(this.compiler.typesTask.get$uint31Type());
      this.uint31TypeCache = t1;
      return t1;
    },
    get$positiveIntType: function() {
      var t1 = this.positiveIntTypeCache;
      if (t1 != null)
        return t1;
      t1 = this.getConcreteTypeFor$1(this.compiler.typesTask.get$positiveIntType());
      this.positiveIntTypeCache = t1;
      return t1;
    },
    get$doubleType: function() {
      var t1 = this.doubleTypeCache;
      if (t1 != null)
        return t1;
      t1 = this.getConcreteTypeFor$1(this.compiler.typesTask.get$doubleType());
      this.doubleTypeCache = t1;
      return t1;
    },
    get$numType: function() {
      var t1 = this.numTypeCache;
      if (t1 != null)
        return t1;
      t1 = this.getConcreteTypeFor$1(this.compiler.typesTask.get$numType());
      this.numTypeCache = t1;
      return t1;
    },
    get$boolType: function() {
      var t1 = this.boolTypeCache;
      if (t1 != null)
        return t1;
      t1 = this.getConcreteTypeFor$1(this.compiler.typesTask.get$boolType());
      this.boolTypeCache = t1;
      return t1;
    },
    get$functionType: function() {
      var t1 = this.functionTypeCache;
      if (t1 != null)
        return t1;
      t1 = this.getConcreteTypeFor$1(this.compiler.typesTask.get$functionType());
      this.functionTypeCache = t1;
      return t1;
    },
    get$constListType: function() {
      var t1 = this.constListTypeCache;
      if (t1 != null)
        return t1;
      t1 = this.getConcreteTypeFor$1(this.compiler.typesTask.get$constListType());
      this.constListTypeCache = t1;
      return t1;
    },
    get$fixedListType: function() {
      var t1 = this.fixedListTypeCache;
      if (t1 != null)
        return t1;
      t1 = this.getConcreteTypeFor$1(this.compiler.typesTask.get$fixedListType());
      this.fixedListTypeCache = t1;
      return t1;
    },
    get$growableListType: function() {
      var t1 = this.growableListTypeCache;
      if (t1 != null)
        return t1;
      t1 = this.getConcreteTypeFor$1(this.compiler.typesTask.get$growableListType());
      this.growableListTypeCache = t1;
      return t1;
    },
    get$mapType: function() {
      var t1 = this.mapTypeCache;
      if (t1 != null)
        return t1;
      t1 = this.getConcreteTypeFor$1(this.compiler.typesTask.get$mapType());
      this.mapTypeCache = t1;
      return t1;
    },
    get$constMapType: function() {
      var t1 = this.constMapTypeCache;
      if (t1 != null)
        return t1;
      t1 = this.getConcreteTypeFor$1(this.compiler.typesTask.get$constMapType());
      this.constMapTypeCache = t1;
      return t1;
    },
    get$stringType: function() {
      var t1 = this.stringTypeCache;
      if (t1 != null)
        return t1;
      t1 = this.getConcreteTypeFor$1(this.compiler.typesTask.get$stringType());
      this.stringTypeCache = t1;
      return t1;
    },
    get$typeType: function() {
      var t1 = this.typeTypeCache;
      if (t1 != null)
        return t1;
      t1 = this.getConcreteTypeFor$1(this.compiler.typesTask.get$typeType());
      this.typeTypeCache = t1;
      return t1;
    },
    get$dynamicType: function() {
      var t1 = this.dynamicTypeCache;
      if (t1 != null)
        return t1;
      t1 = this.getConcreteTypeFor$1(this.compiler.typesTask.get$dynamicType());
      this.dynamicTypeCache = t1;
      return t1;
    },
    stringLiteralType$1: function(value) {
      var t1, t2, t3;
      t1 = this.compiler.typesTask.get$stringType();
      t2 = value.slowToString$0();
      t3 = $.TypeInformation_staticHashCode;
      $.TypeInformation_staticHashCode = t3 + 1;
      t3 = new G.StringLiteralTypeInformation(value, C.List_empty10, C.List_empty10, C.FlatTypeMask_null_0, false, 0, false, false, t3);
      t3.ConcreteTypeInformation$1(new B.ValueTypeMask(t1, t2));
      return t3;
    },
    computeLUB$2: function(firstType, secondType) {
      var t1, t2;
      if (firstType == null)
        return secondType;
      if (firstType === secondType)
        return firstType;
      t1 = this.nonNullEmptyType;
      if (firstType === t1)
        return secondType;
      t2 = J.getInterceptor(secondType);
      if (t2.$eq(secondType, t1))
        return firstType;
      if (firstType === this.get$dynamicType() || t2.$eq(secondType, this.get$dynamicType()))
        return this.get$dynamicType();
      return this.getConcreteTypeFor$1(firstType.get$type(firstType).union$2(t2.get$type(secondType), this.compiler));
    },
    refineReceiver$2: function(selector, receiver) {
      var t1, t2, otherType, t3, newType;
      if (J.get$type$x(receiver).get$isExact())
        return receiver;
      t1 = this.compiler;
      t2 = t1.world.allFunctions;
      otherType = t2.query$1(0, selector).computeMask$1(t2.compiler);
      if (otherType.get$isNullable() && otherType.containsAll$1(t1))
        return receiver;
      t1 = $.TypeInformation_staticHashCode;
      $.TypeInformation_staticHashCode = t1 + 1;
      t2 = H.setRuntimeTypeInfo(new N.Setlet(C.C__SetletMarker, null), [G.TypeInformation]);
      t3 = H.setRuntimeTypeInfo([], [G.TypeInformation]);
      newType = new G.NarrowTypeInformation(otherType, t2, t3, C.FlatTypeMask_null_0, false, 0, false, false, t1);
      G.TypeInformation.prototype.addAssignment$1.call(newType, receiver);
      this.allocatedTypes.push(newType);
      return newType;
    },
    narrowType$3$isNullable: function(type, annotation, isNullable) {
      var t1, t2, t3, otherType, newType;
      if (annotation.get$treatAsDynamic())
        return type;
      if (annotation.get$kind(annotation) === C.TypeKind_void)
        return this.get$nullType();
      t1 = annotation.get$element();
      t2 = this.compiler;
      t3 = t2.objectClass;
      if ((t1 == null ? t3 == null : t1 === t3) && isNullable)
        return type;
      if (annotation.get$kind(annotation) === C.TypeKind_typedef || annotation.get$kind(annotation) === C.TypeKind_function)
        otherType = this.get$functionType().type;
      else if (annotation.get$kind(annotation) === C.TypeKind_kuk)
        return type;
      else {
        t1 = annotation.get$element();
        t2 = t2.objectClass;
        otherType = (t1 == null ? t2 == null : t1 === t2) ? this.get$dynamicType().type.nonNullable$0() : new B.FlatTypeMask(annotation.get$element(), 6);
      }
      if (isNullable)
        otherType = otherType.nullable$0();
      if (J.get$type$x(type).get$isExact())
        return type;
      else {
        t1 = $.TypeInformation_staticHashCode;
        $.TypeInformation_staticHashCode = t1 + 1;
        t2 = H.setRuntimeTypeInfo(new N.Setlet(C.C__SetletMarker, null), [G.TypeInformation]);
        t3 = H.setRuntimeTypeInfo([], [G.TypeInformation]);
        newType = new G.NarrowTypeInformation(otherType, t2, t3, C.FlatTypeMask_null_0, false, 0, false, false, t1);
        G.TypeInformation.prototype.addAssignment$1.call(newType, type);
        this.allocatedTypes.push(newType);
        return newType;
      }
    },
    narrowType$2: function(type, annotation) {
      return this.narrowType$3$isNullable(type, annotation, true);
    },
    getInferredTypeOf$1: function(element) {
      var t1 = {};
      t1.element_0 = element;
      element = J.get$implementation$x(element);
      t1.element_0 = element;
      return this.typeInformations.putIfAbsent$2(element, new G.TypeInformationSystem_getInferredTypeOf_closure(t1));
    },
    getConcreteTypeFor$1: function(mask) {
      return this.concreteTypes.putIfAbsent$2(mask, new G.TypeInformationSystem_getConcreteTypeFor_closure(mask));
    },
    getInferredSignatureOf$1: function($function) {
      var t1, info, signature, res;
      t1 = {};
      info = this.getInferredTypeOf$1($function);
      signature = $function.get$implementation($function).get$functionSignature();
      t1.res_0 = "";
      signature.forEachParameter$1(new G.TypeInformationSystem_getInferredSignatureOf_closure(t1, this));
      res = t1.res_0 + (") -> " + J.toString$0(info.type));
      t1.res_0 = res;
      return res;
    },
    nonNullSubtype$1: function(type) {
      return this.getConcreteTypeFor$1(new B.FlatTypeMask(type.get$declaration(), 6));
    },
    nonNullSubclass$1: function(type) {
      return this.getConcreteTypeFor$1(new B.FlatTypeMask(type.get$declaration(), 4));
    },
    nonNullExact$1: function(type) {
      return this.getConcreteTypeFor$1(new B.FlatTypeMask(type.get$declaration(), 2));
    },
    nonNullEmpty$0: function() {
      return this.nonNullEmptyType;
    },
    isNull$1: [function(type) {
      return J.$eq(type, this.get$nullType());
    }, "call$1", "get$isNull", 2, 0, 301],
    allocateList$5: function(type, node, enclosing, elementType, $length) {
      var t1, isTypedArray, isConst, isFixed, isElementInferred, inferredLength, elementTypeMask, mask, t2, t3, element, t4;
      t1 = this.compiler;
      isTypedArray = t1.typedDataClass != null && type.get$type(type).satisfies$2(t1.typedDataClass, t1);
      isConst = J.$eq(type.get$type(type), t1.typesTask.get$constListType());
      isFixed = J.$eq(type.type, t1.typesTask.get$fixedListType()) || isConst || isTypedArray;
      isElementInferred = isConst || isTypedArray;
      inferredLength = isFixed ? $length : null;
      elementTypeMask = isElementInferred ? J.get$type$x(elementType) : this.get$dynamicType().type;
      mask = new B.ContainerTypeMask(type.type, node, enclosing, elementTypeMask, inferredLength);
      t1 = $.TypeInformation_staticHashCode;
      $.TypeInformation_staticHashCode = t1 + 1;
      t2 = H.setRuntimeTypeInfo(new N.Setlet(C.C__SetletMarker, null), [G.TypeInformation]);
      t3 = H.setRuntimeTypeInfo([], [G.TypeInformation]);
      element = new G.ElementInContainerTypeInformation(false, t2, t3, C.FlatTypeMask_null_0, false, 0, false, false, t1);
      if (elementType != null)
        element.addAssignment$1(elementType);
      element.inferred = isElementInferred;
      this.allocatedTypes.push(element);
      t1 = H.setRuntimeTypeInfo(new N.Setlet(C.C__SetletMarker, null), [G.TypeInformation]);
      t2 = $.TypeInformation_staticHashCode;
      $.TypeInformation_staticHashCode = t2 + 1;
      t3 = H.setRuntimeTypeInfo(new N.Setlet(C.C__SetletMarker, null), [G.TypeInformation]);
      t4 = H.setRuntimeTypeInfo([], [G.TypeInformation]);
      t2 = new G.ListTypeInformation(element, mask, $length, null, true, t1, true, false, t3, t4, C.FlatTypeMask_null_0, false, 0, false, false, t2);
      t2.type = mask;
      t2.inferredLength = inferredLength;
      J.add$1$ax(element.users, t2);
      this.allocatedLists.$indexSet(0, node, t2);
      return t2;
    },
    allocateClosure$2: function(node, element) {
      var t1, t2, t3, result;
      t1 = $.TypeInformation_staticHashCode;
      $.TypeInformation_staticHashCode = t1 + 1;
      t2 = H.setRuntimeTypeInfo(new N.Setlet(C.C__SetletMarker, null), [G.TypeInformation]);
      t3 = H.setRuntimeTypeInfo([], [G.TypeInformation]);
      result = new G.ClosureTypeInformation(node, element, false, t2, t3, C.FlatTypeMask_null_0, false, 0, false, false, t1);
      this.allocatedClosures.add$1(0, result);
      return result;
    },
    allocateMap$5: function(type, node, element, keyTypes, valueTypes) {
      var isFixed, keyType, valueType, mask, t1, t2, t3, keyTypeInfo, valueTypeInfo, t4, t5, t6, map, i, newType;
      isFixed = J.$eq(type.get$type(type), this.compiler.typesTask.get$constMapType());
      if (isFixed) {
        keyType = H.IterableMixinWorkaround_fold(keyTypes, this.nonNullEmptyType.type, new G.TypeInformationSystem_allocateMap_closure(this));
        valueType = H.IterableMixinWorkaround_fold(valueTypes, this.nonNullEmptyType.type, new G.TypeInformationSystem_allocateMap_closure0(this));
      } else {
        valueType = this.get$dynamicType().type;
        keyType = valueType;
      }
      mask = new B.MapTypeMask(type.type, node, element, valueType, keyType);
      t1 = $.TypeInformation_staticHashCode;
      $.TypeInformation_staticHashCode = t1 + 1;
      t2 = H.setRuntimeTypeInfo(new N.Setlet(C.C__SetletMarker, null), [G.TypeInformation]);
      t3 = H.setRuntimeTypeInfo([], [G.TypeInformation]);
      keyTypeInfo = new G.KeyInMapTypeInformation(false, t2, t3, C.FlatTypeMask_null_0, false, 0, false, false, t1);
      t1 = $.TypeInformation_staticHashCode;
      $.TypeInformation_staticHashCode = t1 + 1;
      t2 = H.setRuntimeTypeInfo(new N.Setlet(C.C__SetletMarker, null), [G.TypeInformation]);
      t3 = H.setRuntimeTypeInfo([], [G.TypeInformation]);
      valueTypeInfo = new G.ValueInMapTypeInformation(false, false, t2, t3, C.FlatTypeMask_null_0, false, 0, false, false, t1);
      t1 = this.allocatedTypes;
      t1.push(keyTypeInfo);
      t1.push(valueTypeInfo);
      t2 = P.LinkedHashMap_LinkedHashMap$_empty(null, null);
      t3 = H.setRuntimeTypeInfo(new N.Setlet(C.C__SetletMarker, null), [G.TypeInformation]);
      t4 = $.TypeInformation_staticHashCode;
      $.TypeInformation_staticHashCode = t4 + 1;
      t5 = H.setRuntimeTypeInfo(new N.Setlet(C.C__SetletMarker, null), [G.TypeInformation]);
      t6 = H.setRuntimeTypeInfo([], [G.TypeInformation]);
      map = new G.MapTypeInformation(t2, keyTypeInfo, valueTypeInfo, mask, t3, true, false, true, t5, t6, C.FlatTypeMask_null_0, false, 0, false, false, t4);
      J.add$1$ax(keyTypeInfo.users, map);
      J.add$1$ax(valueTypeInfo.users, map);
      map.type = mask;
      for (i = 0; i < keyTypes.length; ++i) {
        t2 = keyTypes[i];
        if (i >= valueTypes.length)
          return H.ioore(valueTypes, i);
        newType = map.addEntryAssignment$3(t2, valueTypes[i], true);
        if (newType != null)
          t1.push(newType);
      }
      if (isFixed)
        map.markAsInferred$0();
      this.allocatedMaps.$indexSet(0, node, map);
      return map;
    },
    newTypedSelector$2: function(info, selector) {
      return info.get$isConcrete() ? Z.TypedSelector_TypedSelector(info.get$type(info), selector, this.compiler) : selector;
    },
    allocateDiamondPhi$2: function(firstInput, secondInput) {
      var t1, t2, t3, result;
      t1 = $.TypeInformation_staticHashCode;
      $.TypeInformation_staticHashCode = t1 + 1;
      t2 = H.setRuntimeTypeInfo(new N.Setlet(C.C__SetletMarker, null), [G.TypeInformation]);
      t3 = H.setRuntimeTypeInfo([], [G.TypeInformation]);
      result = new G.PhiElementTypeInformation(null, false, null, t2, t3, C.FlatTypeMask_null_0, false, 0, false, false, t1);
      result.addAssignment$1(firstInput);
      result.addAssignment$1(secondInput);
      this.allocatedTypes.push(result);
      return result;
    },
    allocatePhi$3: function(node, variable, inputType) {
      var t1, t2, t3, result;
      if (!!J.getInterceptor(inputType).$isPhiElementTypeInformation) {
        t1 = inputType.branchNode;
        t1 = t1 == null ? node == null : t1 === node;
      } else
        t1 = false;
      if (t1)
        return inputType;
      t1 = $.TypeInformation_staticHashCode;
      $.TypeInformation_staticHashCode = t1 + 1;
      t2 = H.setRuntimeTypeInfo(new N.Setlet(C.C__SetletMarker, null), [G.TypeInformation]);
      t3 = H.setRuntimeTypeInfo([], [G.TypeInformation]);
      result = new G.PhiElementTypeInformation(node, true, variable, t2, t3, C.FlatTypeMask_null_0, false, 0, false, false, t1);
      this.allocatedTypes.push(result);
      result.addAssignment$1(inputType);
      return result;
    },
    simplifyPhi$3: function(node, variable, phiType) {
      if (J.get$length$asx(phiType.get$assignments()) === 1)
        return J.get$first$ax(phiType.get$assignments());
      return phiType;
    },
    addPhiInput$3: function(variable, phiType, newType) {
      phiType.addAssignment$1(newType);
      return phiType;
    },
    computeTypeMask$1: function(assignments) {
      return this.joinTypeMasks$1(J.map$1$ax(assignments, new G.TypeInformationSystem_computeTypeMask_closure()));
    },
    joinTypeMasks$1: function(masks) {
      var t1, t2, newType;
      for (t1 = masks.get$iterator(masks), t2 = this.compiler, newType = C.FlatTypeMask_null_0; t1.moveNext$0();)
        newType = newType.union$2(t1.get$current(), t2);
      return newType.containsAll$1(t2) ? this.get$dynamicType().type : newType;
    },
    $asTypeSystem: function() {
      return [G.TypeInformation];
    }
  },
  TypeInformationSystem_getInferredTypeOf_closure: {
    "^": "Closure:23;box_0",
    call$0: function() {
      var t1, t2, assignments, t3, t4, t5;
      t1 = this.box_0.element_0;
      if (t1.get$enclosingElement().get$isInstanceMember()) {
        t2 = t1.kind;
        t2 = t2 === C.ElementKind_parameter_1 || t2 === C.ElementKind_initializing_formal_1;
      } else
        t2 = false;
      assignments = t2 ? new G.ParameterAssignments(P.LinkedHashMap_LinkedHashMap(null, null, null, G.TypeInformation, P.$int)) : null;
      t2 = P.LinkedHashMap_LinkedHashMap(null, null, null, O.Element, N.Setlet);
      t3 = $.TypeInformation_staticHashCode;
      $.TypeInformation_staticHashCode = t3 + 1;
      t4 = H.setRuntimeTypeInfo(new N.Setlet(C.C__SetletMarker, null), [G.TypeInformation]);
      t5 = assignments == null ? H.setRuntimeTypeInfo([], [G.TypeInformation]) : assignments;
      return new G.ElementTypeInformation(t1, true, 0, t2, false, t4, t5, C.FlatTypeMask_null_0, false, 0, false, false, t3);
    },
    $isFunction: true
  },
  TypeInformationSystem_getConcreteTypeFor_closure: {
    "^": "Closure:23;mask_0",
    call$0: function() {
      return G.ConcreteTypeInformation$(this.mask_0);
    },
    $isFunction: true
  },
  TypeInformationSystem_getInferredSignatureOf_closure: {
    "^": "Closure:77;box_0,this_1",
    call$1: function(parameter) {
      var type, t1, t2, t3;
      type = this.this_1.getInferredTypeOf$1(parameter);
      t1 = this.box_0;
      t2 = t1.res_0;
      t3 = t2.length === 0 ? "(" : ", ";
      t1.res_0 = t2 + (t3 + J.toString$0(type.type) + " " + H.S(J.get$name$x(parameter)));
    },
    $isFunction: true
  },
  TypeInformationSystem_allocateMap_closure: {
    "^": "Closure:19;this_0",
    call$2: function(type, info) {
      return type.union$2(J.get$type$x(info), this.this_0.compiler);
    },
    $isFunction: true
  },
  TypeInformationSystem_allocateMap_closure0: {
    "^": "Closure:19;this_1",
    call$2: function(type, info) {
      return type.union$2(J.get$type$x(info), this.this_1.compiler);
    },
    $isFunction: true
  },
  TypeInformationSystem_computeTypeMask_closure: {
    "^": "Closure:13;",
    call$1: function(e) {
      return J.get$type$x(e);
    },
    $isFunction: true
  },
  WorkQueue0: {
    "^": "Object;queue",
    add$1: [function(_, element) {
      if (element.get$abandonInferencing())
        return;
      if (element.inQueue)
        return;
      this.queue._add$1(element);
      element.inQueue = true;
    }, "call$1", "get$add", 2, 0, 302],
    addAll$1: function(_, all) {
      J.forEach$1$ax(all, this.get$add(this));
    },
    get$isEmpty: function(_) {
      var t1 = this.queue;
      return t1._head === t1._tail;
    },
    get$length: function(_) {
      var t1 = this.queue;
      return t1.get$length(t1);
    }
  },
  TypeGraphInferrerEngine: {
    "^": "InferrerEngine;defaultTypeOfParameter,allocatedCalls,workQueue,mainElement,analyzedElements,MAX_CHANGE_COUNT,overallRefineCount,addedInGraph,_returnsListElementTypeSet,compiler,types,concreteTypes,generativeConstructorsExposingThis",
    returnsListElementType$1: function(selector) {
      return selector.get$mask() != null && selector.get$mask().get$isContainer() && this._returnsListElementTypeSet.contains$1(0, selector.get$asUntyped());
    },
    returnsMapValueType$1: function(selector) {
      var t1;
      if (selector.get$mask() != null) {
        t1 = selector.get$mask();
        t1 = t1.get$isMap(t1) && selector.kind === C.SelectorKind_index_4 && selector.argumentCount === 1;
      } else
        t1 = false;
      return t1;
    },
    analyzeListAndEnqueue$1: function(info) {
      var t1, tracer, t2, fixedListType, t3;
      if (info.analyzed)
        return;
      info.analyzed = true;
      t1 = this.compiler;
      tracer = new G.ListTracerVisitor(H.setRuntimeTypeInfo([], [G.TypeInformation]), false, info, this, t1, H.setRuntimeTypeInfo(new N.Setlet(C.C__SetletMarker, null), [O.Element]), H.setRuntimeTypeInfo([], [G.TypeInformation]), H.setRuntimeTypeInfo([], [G.ListTypeInformation]), H.setRuntimeTypeInfo([], [G.MapTypeInformation]), H.setRuntimeTypeInfo(new N.Setlet(C.C__SetletMarker, null), [G.TypeInformation]), null, true);
      if (!tracer.run$0())
        return;
      info.bailedOut = false;
      t2 = info.elementType;
      t2.inferred = true;
      fixedListType = t1.typesTask.get$fixedListType();
      if (J.$eq(info.originalContainerType.forwardTo, fixedListType))
        info.checksGrowable = tracer.callsGrowableMethod;
      t1 = tracer.assignments;
      t3 = t2.get$addAssignment();
      t1.toString;
      H.IterableMixinWorkaround_forEach(t1, t3);
      t3 = this.workQueue;
      t3.add$1(0, info);
      t3.add$1(0, t2);
    },
    analyzeMapAndEnqueue$1: function(info) {
      var tracer, t1, i, t2, t3, newType;
      if (info.analyzed)
        return;
      info.analyzed = true;
      tracer = new G.MapTracerVisitor(H.setRuntimeTypeInfo([], [G.TypeInformation]), H.setRuntimeTypeInfo([], [G.TypeInformation]), H.setRuntimeTypeInfo([], [G.MapTypeInformation]), info, this, this.compiler, H.setRuntimeTypeInfo(new N.Setlet(C.C__SetletMarker, null), [O.Element]), H.setRuntimeTypeInfo([], [G.TypeInformation]), H.setRuntimeTypeInfo([], [G.ListTypeInformation]), H.setRuntimeTypeInfo([], [G.MapTypeInformation]), H.setRuntimeTypeInfo(new N.Setlet(C.C__SetletMarker, null), [G.TypeInformation]), null, true);
      if (!tracer.run$0())
        return;
      info.bailedOut = false;
      for (t1 = this.workQueue, i = 0; t2 = tracer.keyAssignments, i < t2.length; ++i) {
        t2 = t2[i];
        t3 = tracer.valueAssignments;
        if (i >= t3.length)
          return H.ioore(t3, i);
        newType = info.addEntryAssignment$2(t2, t3[i]);
        if (newType != null)
          t1.add$1(0, newType);
      }
      for (t2 = tracer.mapAssignments, t2 = H.setRuntimeTypeInfo(new H.ListIterator(t2, t2.length, 0, null), [H.getTypeArgumentByIndex(t2, 0)]); t2.moveNext$0();)
        C.JSArray_methods.forEach$1(info.addMapAssignment$1(t2.__internal$_current), t1.get$add(t1));
      info.markAsInferred$0();
      t1.add$1(0, info.keyType);
      t1.add$1(0, info.valueType);
      t2 = info.typeInfoMap;
      t2.get$values(t2).forEach$1(0, t1.get$add(t1));
      t1.add$1(0, info);
    },
    runOverAllElements$0: function() {
      var t1, t2, t3, t4, t5, seenTypes, t6, element;
      t1 = this.compiler;
      if (t1.disableTypeInferenceFlag)
        return;
      t1.progress.reset$0(0);
      H.IterableMixinWorkaround_forEach(this.sortResolvedElements$0(), new G.TypeGraphInferrerEngine_runOverAllElements_closure(this));
      t1.log$1("Added " + this.addedInGraph + " elements in inferencing graph.");
      t2 = this.workQueue;
      t3 = this.types;
      t4 = t3.typeInformations;
      t4.get$values(t4).forEach$1(0, t2.get$add(t2));
      C.JSArray_methods.forEach$1(t3.allocatedTypes, t2.get$add(t2));
      t4 = t3.allocatedClosures;
      t4.forEach$1(0, t2.get$add(t2));
      C.JSArray_methods.forEach$1(this.allocatedCalls, t2.get$add(t2));
      this.refine$0();
      t5 = t3.allocatedLists;
      t5.get$values(t5).forEach$1(0, new G.TypeGraphInferrerEngine_runOverAllElements_closure0(this));
      t3 = t3.allocatedMaps;
      t3.get$values(t3).forEach$1(0, new G.TypeGraphInferrerEngine_runOverAllElements_closure1(this));
      t4.forEach$1(0, new G.TypeGraphInferrerEngine_runOverAllElements_closure2(this));
      seenTypes = P.LinkedHashSet_LinkedHashSet(null, null, null, G.TypeInformation);
      for (t6 = t2.queue; t6._head !== t6._tail;) {
        element = t6.removeFirst$0();
        element.set$inQueue(false);
        if (seenTypes.contains$1(0, element))
          continue;
        element.reset$1(0, this);
        seenTypes.add$1(0, element);
        J.forEach$1$ax(element.users, t2.get$add(t2));
      }
      seenTypes.forEach$1(0, t2.get$add(t2));
      this.refine$0();
      if ($._PRINT_SUMMARY) {
        t5.get$values(t5).forEach$1(0, new G.TypeGraphInferrerEngine_runOverAllElements_closure3());
        t3.get$values(t3).forEach$1(0, new G.TypeGraphInferrerEngine_runOverAllElements_closure4());
        t4.forEach$1(0, new G.TypeGraphInferrerEngine_runOverAllElements_closure5(this));
        this.analyzedElements.forEach$1(0, new G.TypeGraphInferrerEngine_runOverAllElements_closure6(this));
      }
      t1.log$1("Inferred " + this.overallRefineCount + " types.");
      this.processLoopInformation$0();
    },
    analyze$2: function(element, $arguments) {
      var t1, t2, t3, t4, t5, visitor, node, value, t6, t7, type, argument;
      t1 = {};
      element = element.get$implementation(element);
      t2 = this.analyzedElements;
      if (t2.contains$1(0, element))
        return;
      t2.add$1(0, element);
      t2 = this.compiler;
      t3 = H.setRuntimeTypeInfo(new N.Setlet(C.C__SetletMarker, null), [O.Element]);
      t4 = element.get$outermostEnclosingMemberOrTopLevel();
      t4 = t4.get$implementation(t4);
      t5 = this.types;
      visitor = H.setRuntimeTypeInfo(new Q.SimpleTypeInferrerVisitor(null, false, false, false, new Z.SideEffects(0), t4, this, t3, element, t5, this, P.LinkedHashMap_LinkedHashMap(null, null, null, O.JumpTarget, [P.List, [X.LocalsHandler, null]]), P.LinkedHashMap_LinkedHashMap(null, null, null, O.JumpTarget, [P.List, [X.LocalsHandler, null]]), null, H.setRuntimeTypeInfo([], [null]), false, false, null, 0, null, null, t2, element.get$resolvedAst().elements), [null]);
      visitor.InferrerVisitor$5(element, this, t5, t2, null, null, [Q.InferrerEngine, null, [X.TypeSystem, null]]);
      visitor.SimpleTypeInferrerVisitor$internal$5(element, t4, this, t2, null, null);
      t1.type_0 = null;
      t2.withCurrentElement$2(element, new G.TypeGraphInferrerEngine_analyze_closure(t1, visitor));
      ++this.addedInGraph;
      if (element.get$isField()) {
        node = element.get$node();
        if ((element.get$modifiers().flags & 4) !== 0 || (element.get$modifiers().flags & 16) !== 0) {
          if (element.get$initializer() != null) {
            t3 = J.getInterceptor(t1.type_0);
            if (!t3.$isListTypeInformation && !t3.$isMapTypeInformation) {
              value = t2.backend.get$constants().getConstantForVariable$1(element);
              if (value != null)
                if (value.get$isFunction())
                  t1.type_0 = t5.allocateClosure$2(node, value.get$element());
                else {
                  t3 = t1.type_0;
                  t2 = value.computeMask$1(t2);
                  t4 = $.TypeInformation_staticHashCode;
                  $.TypeInformation_staticHashCode = t4 + 1;
                  t6 = H.setRuntimeTypeInfo(new N.Setlet(C.C__SetletMarker, null), [G.TypeInformation]);
                  t7 = H.setRuntimeTypeInfo([], [G.TypeInformation]);
                  type = new G.NarrowTypeInformation(t2, t6, t7, C.FlatTypeMask_null_0, false, 0, false, false, t4);
                  G.TypeInformation.prototype.addAssignment$1.call(type, t3);
                  t1.type_0 = type;
                  t5.allocatedTypes.push(type);
                }
            }
            t1 = t1.type_0;
            t5.getInferredTypeOf$1(element).addAssignment$1(t1);
          } else if (!element.get$isInstanceMember()) {
            t1 = t5.get$nullType();
            t5.getInferredTypeOf$1(element).addAssignment$1(t1);
          }
        } else if (element.get$initializer() == null) {
          if (O.Elements_isStaticOrTopLevelField(element)) {
            t1 = t1.type_0;
            t5.getInferredTypeOf$1(element).addAssignment$1(t1);
          }
        } else {
          t1 = t1.type_0;
          t5.getInferredTypeOf$1(element).addAssignment$1(t1);
        }
        if (O.Elements_isStaticOrTopLevelField(element) && element.get$initializer() != null && (element.get$modifiers().flags & 16) === 0) {
          argument = element.get$initializer();
          if (argument.asSend$0() == null)
            t1 = argument.asNewExpression$0() != null && !argument.get$isConst();
          else
            t1 = true;
          if (t1) {
            t1 = t5.get$nullType();
            t5.getInferredTypeOf$1(element).addAssignment$1(t1);
          }
        }
      } else
        this.recordReturnType$2(element, t1.type_0);
    },
    processLoopInformation$0: function() {
      H.IterableMixinWorkaround_forEach(this.allocatedCalls, new G.TypeGraphInferrerEngine_processLoopInformation_closure(this));
    },
    refine$0: function() {
      var t1, t2, t3, t4, t5, t6, t7, element, oldType, newType;
      for (t1 = this.workQueue, t2 = t1.queue, t3 = this.compiler, t4 = t3.progress, t5 = this.MAX_CHANGE_COUNT; t2._head !== t2._tail;) {
        t6 = t4.get$elapsedTicks();
        t7 = $.Stopwatch__frequency;
        if (typeof t7 !== "number")
          return H.iae(t7);
        if (C.JSInt_methods.$tdiv(t6 * 1000, t7) > 500) {
          t3.log$1("Inferred " + this.overallRefineCount + " types.");
          t4.reset$0(0);
        }
        element = t2.removeFirst$0();
        element.set$inQueue(false);
        oldType = element.type;
        newType = element.refine$1(this);
        element.type = newType;
        if (!J.$eq(newType, oldType)) {
          ++this.overallRefineCount;
          ++element.refineCount;
          J.forEach$1$ax(element.users, t1.get$add(t1));
          if (element.hasStableType$1(this)) {
            element.removeAndClearReferences$1(this);
            element.assignments = $.get$TypeInformation_STOP_TRACKING_ASSIGNMENTS_MARKER();
            element.abandonInferencing = true;
            element.isStable = true;
          } else if (element.refineCount > t5)
            element.giveUp$1(this);
        }
      }
    },
    updateParameterAssignments$6$addToQueue$remove: function(caller, callee, $arguments, selector, addToQueue, remove) {
      var t1, t2, info, t3, signature;
      t1 = {};
      t2 = J.getInterceptor$x(callee);
      if (t2.get$name(callee) === "noSuchMethod")
        return;
      if (t2.get$kind(callee) === C.ElementKind_field_1) {
        if (selector.kind === C.SelectorKind_setter_1) {
          info = this.types.getInferredTypeOf$1(callee);
          if (remove) {
            t1 = $arguments.get$positional();
            if (0 >= t1.length)
              return H.ioore(t1, 0);
            info.removeAssignment$1(t1[0]);
          } else {
            t1 = $arguments.get$positional();
            if (0 >= t1.length)
              return H.ioore(t1, 0);
            info.addAssignment$1(t1[0]);
          }
          if (addToQueue)
            this.workQueue.add$1(0, info);
        }
      } else if (callee.get$isGetter())
        return;
      else if (selector != null && selector.kind === C.SelectorKind_getter_0) {
        t1 = this.types;
        info = t1.getInferredTypeOf$1(callee);
        if (remove)
          --info.closurizedCount;
        else {
          ++info.closurizedCount;
          t3 = O.Elements_isStaticOrTopLevel(callee);
          t1 = t1.allocatedClosures;
          if (t3)
            t1.add$1(0, info);
          else
            t1.add$1(0, caller);
          t2.get$implementation(callee).get$functionSignature().forEachParameter$1(new G.TypeGraphInferrerEngine_updateParameterAssignments_closure(this, addToQueue));
        }
      } else {
        signature = t2.get$implementation(callee).get$functionSignature();
        t1.parameterIndex_0 = 0;
        t1.visitingRequiredParameter_1 = true;
        signature.forEachParameter$1(new G.TypeGraphInferrerEngine_updateParameterAssignments_closure0(t1, this, $arguments, remove, addToQueue, signature));
      }
    },
    setDefaultTypeOfParameter$2: function(parameter, type) {
      var t1, existing, info, assignments, count, i, t2;
      t1 = this.defaultTypeOfParameter;
      existing = t1.$index(0, parameter);
      t1.$indexSet(0, parameter, type);
      info = this.types.getInferredTypeOf$1(parameter);
      if (!info.abandonInferencing && existing != null && existing !== type)
        if (parameter.get$functionDeclaration().get$isInstanceMember()) {
          assignments = info.assignments;
          count = J.$index$asx(assignments.get$assignments(), existing);
          if (count == null)
            return;
          type.addUser$1(info);
          J.$indexSet$ax(assignments.get$assignments(), type, count);
          J.remove$1$ax(assignments.get$assignments(), existing);
        } else {
          assignments = info.assignments;
          t1 = J.getInterceptor$asx(assignments);
          i = 0;
          while (true) {
            t2 = t1.get$length(assignments);
            if (typeof t2 !== "number")
              return H.iae(t2);
            if (!(i < t2))
              break;
            if (J.$eq(t1.$index(assignments, i), existing)) {
              J.$indexSet$ax(info.assignments, i, type);
              type.addUser$1(info);
            }
            ++i;
          }
        }
    },
    getDefaultTypeOfParameter$1: function(parameter) {
      return this.defaultTypeOfParameter.putIfAbsent$2(parameter, new G.TypeGraphInferrerEngine_getDefaultTypeOfParameter_closure(this));
    },
    typeOfElement$1: function(element) {
      if (!!J.getInterceptor(element).$isFunctionElement)
        return this.types.get$functionType();
      return this.types.getInferredTypeOf$1(element);
    },
    returnTypeOfElement$1: function(element) {
      if (!J.getInterceptor(element).$isFunctionElement)
        return this.types.get$dynamicType();
      return this.types.getInferredTypeOf$1(element);
    },
    recordTypeOfFinalField$4: function(node, analyzed, element, type) {
      this.types.getInferredTypeOf$1(element).addAssignment$1(type);
    },
    recordTypeOfNonFinalField$3: function(node, element, type) {
      this.types.getInferredTypeOf$1(element).addAssignment$1(type);
    },
    recordType$2: function(element, type) {
      this.types.getInferredTypeOf$1(element).addAssignment$1(type);
    },
    recordReturnType$2: function(element, type) {
      var t1, info;
      t1 = this.types;
      info = t1.getInferredTypeOf$1(element);
      if (element.get$name(element) === "==")
        info.addAssignment$1(t1.get$boolType());
      if (type == null)
        return;
      if (J.get$isEmpty$asx(info.assignments) === true)
        info.addAssignment$1(type);
    },
    addReturnTypeFor$3: function(element, unused, newType) {
      var type = this.types.getInferredTypeOf$1(element);
      if (element.get$kind(element) === C.ElementKind_generative_constructor_16)
        return type;
      type.addAssignment$1(newType);
      return type;
    },
    registerCalledElement$7: function(node, selector, caller, callee, $arguments, sideEffects, inLoop) {
      var t1, t2, info;
      t1 = $.TypeInformation_staticHashCode;
      $.TypeInformation_staticHashCode = t1 + 1;
      t2 = H.setRuntimeTypeInfo(new N.Setlet(C.C__SetletMarker, null), [G.TypeInformation]);
      info = new G.StaticCallSiteTypeInformation(callee, node, caller, selector, $arguments, inLoop, false, t2, C.List_empty10, C.FlatTypeMask_null_0, false, 0, false, false, t1);
      info.addToGraph$1(this);
      this.allocatedCalls.push(info);
      this.updateSideEffects$3(sideEffects, selector, callee);
      return info;
    },
    registerCalledSelector$7: function(node, selector, receiverType, caller, $arguments, sideEffects, inLoop) {
      var t1, t2, info;
      if (selector.get$isClosureCall())
        return this.registerCalledClosure$7(node, selector, receiverType, caller, $arguments, sideEffects, inLoop);
      J.forEach$1$ax(this.compiler.world.allFunctions.query$1(0, selector).functions, new G.TypeGraphInferrerEngine_registerCalledSelector_closure(this, selector, sideEffects));
      t1 = $.TypeInformation_staticHashCode;
      $.TypeInformation_staticHashCode = t1 + 1;
      t2 = H.setRuntimeTypeInfo(new N.Setlet(C.C__SetletMarker, null), [G.TypeInformation]);
      info = new G.DynamicCallSiteTypeInformation(receiverType, null, node, caller, selector, $arguments, inLoop, false, t2, C.List_empty10, C.FlatTypeMask_null_0, false, 0, false, false, t1);
      info.addToGraph$1(this);
      this.allocatedCalls.push(info);
      return info;
    },
    registerCalledClosure$7: function(node, selector, closure, caller, $arguments, sideEffects, inLoop) {
      var t1, t2, info;
      sideEffects.setDependsOnSomething$0();
      sideEffects.flags = (sideEffects.flags | 7) >>> 0;
      t1 = $.TypeInformation_staticHashCode;
      $.TypeInformation_staticHashCode = t1 + 1;
      t2 = H.setRuntimeTypeInfo(new N.Setlet(C.C__SetletMarker, null), [G.TypeInformation]);
      info = new G.ClosureCallSiteTypeInformation(closure, node, caller, selector, $arguments, inLoop, false, t2, C.List_empty10, C.FlatTypeMask_null_0, false, 0, false, false, t1);
      info.addToGraph$1(this);
      this.allocatedCalls.push(info);
      return info;
    },
    sortResolvedElements$0: function() {
      var t1, methodSizes, result, i, set;
      t1 = {};
      t1.max_0 = 0;
      methodSizes = P.LinkedHashMap_LinkedHashMap(null, null, null, P.$int, [N.Setlet, O.Element]);
      this.compiler.enqueuer.resolution.resolvedElements.forEach$1(0, new G.TypeGraphInferrerEngine_sortResolvedElements_closure(t1, this, methodSizes));
      result = H.setRuntimeTypeInfo([], [O.Element]);
      for (i = 0; i <= t1.max_0; ++i) {
        set = methodSizes.$index(0, i);
        if (set != null)
          C.JSArray_methods.addAll$1(result, set);
      }
      return result;
    },
    clear$0: function(_) {
      var t1, t2;
      C.JSArray_methods.set$length(this.allocatedCalls, 0);
      this.defaultTypeOfParameter.clear$0(0);
      t1 = this.types;
      t2 = t1.typeInformations;
      t2.get$values(t2).forEach$1(0, new G.TypeGraphInferrerEngine_clear_closure());
      C.JSArray_methods.set$length(t1.allocatedTypes, 0);
      t1.concreteTypes.clear$0(0);
      t1.allocatedClosures.clear$0(0);
      this.analyzedElements.clear$0(0);
      this.generativeConstructorsExposingThis.clear$0(0);
    },
    typeOfElementWithSelector$2: function(element, selector) {
      var t1, t2, t3;
      t1 = J.getInterceptor$x(element);
      if (t1.get$name(element) === "noSuchMethod") {
        t2 = selector.name;
        t3 = t1.get$name(element);
        t3 = t2 == null ? t3 != null : t2 !== t3;
        t2 = t3;
      } else
        t2 = false;
      if (t2)
        return this.returnTypeOfElement$1(element);
      else if (selector.kind === C.SelectorKind_getter_0)
        if (element.get$isFunction()) {
          t1 = this.types;
          return t1.get$functionType() == null ? t1.get$dynamicType() : t1.get$functionType();
        } else if (t1.get$kind(element) === C.ElementKind_field_1)
          return this.typeOfElement$1(element);
        else if (element.get$isErroneous())
          return this.types.get$dynamicType();
        else
          return this.returnTypeOfElement$1(element);
      else if (element.get$isGetter() || t1.get$kind(element) === C.ElementKind_field_1)
        return this.types.get$dynamicType();
      else
        return this.returnTypeOfElement$1(element);
    },
    recordCapturedLocalRead$1: function(local) {
    },
    recordLocalUpdate$2: function(local, type) {
    },
    $asInferrerEngine: function() {
      return [G.TypeInformation, G.TypeInformationSystem];
    }
  },
  TypeGraphInferrerEngine_runOverAllElements_closure: {
    "^": "Closure:77;this_0",
    call$1: function(element) {
      var t1, t2, t3, t4, t5;
      t1 = this.this_0;
      t2 = t1.compiler;
      t3 = t2.progress;
      t4 = t3.get$elapsedTicks();
      t5 = $.Stopwatch__frequency;
      if (typeof t5 !== "number")
        return H.iae(t5);
      if (C.JSInt_methods.$tdiv(t4 * 1000, t5) > 500) {
        t2.log$1("Added " + t1.addedInGraph + " elements in inferencing graph.");
        t3.reset$0(0);
      }
      t1.types.getInferredTypeOf$1(element);
      t1.analyze$2(element, null);
    },
    $isFunction: true
  },
  TypeGraphInferrerEngine_runOverAllElements_closure0: {
    "^": "Closure:303;this_1",
    call$1: function(info) {
      this.this_1.analyzeListAndEnqueue$1(info);
    },
    $isFunction: true
  },
  TypeGraphInferrerEngine_runOverAllElements_closure1: {
    "^": "Closure:304;this_2",
    call$1: function(info) {
      this.this_2.analyzeMapAndEnqueue$1(info);
    },
    $isFunction: true
  },
  TypeGraphInferrerEngine_runOverAllElements_closure2: {
    "^": "Closure:13;this_3",
    call$1: function(info) {
      var t1, t2, t3, elements, t4;
      t1 = this.this_3;
      t2 = new G.TypeGraphInferrerEngine_runOverAllElements__trace(t1);
      t3 = J.getInterceptor(info);
      if (!!t3.$isClosureTypeInformation) {
        elements = [info.element];
        t2.call$2(elements, new G.ClosureTracerVisitor(elements, info, t1, t1.compiler, H.setRuntimeTypeInfo(new N.Setlet(C.C__SetletMarker, null), [O.Element]), H.setRuntimeTypeInfo([], [G.TypeInformation]), H.setRuntimeTypeInfo([], [G.ListTypeInformation]), H.setRuntimeTypeInfo([], [G.MapTypeInformation]), H.setRuntimeTypeInfo(new N.Setlet(C.C__SetletMarker, null), [G.TypeInformation]), null, true));
      } else {
        t4 = t1.compiler;
        if (!!t3.$isCallSiteTypeInformation) {
          t3 = J.where$1$ax(info.get$callees(), new G.TypeGraphInferrerEngine_runOverAllElements__closure());
          elements = P.List_List$from(t3, true, H.getRuntimeTypeArgument(t3, "IterableBase", 0));
          t2.call$2(elements, new G.ClosureTracerVisitor(elements, info, t1, t4, H.setRuntimeTypeInfo(new N.Setlet(C.C__SetletMarker, null), [O.Element]), H.setRuntimeTypeInfo([], [G.TypeInformation]), H.setRuntimeTypeInfo([], [G.ListTypeInformation]), H.setRuntimeTypeInfo([], [G.MapTypeInformation]), H.setRuntimeTypeInfo(new N.Setlet(C.C__SetletMarker, null), [G.TypeInformation]), null, true));
        } else
          t2.call$2([info.get$element()], new G.StaticTearOffClosureTracerVisitor([info.get$element()], info, t1, t4, H.setRuntimeTypeInfo(new N.Setlet(C.C__SetletMarker, null), [O.Element]), H.setRuntimeTypeInfo([], [G.TypeInformation]), H.setRuntimeTypeInfo([], [G.ListTypeInformation]), H.setRuntimeTypeInfo([], [G.MapTypeInformation]), H.setRuntimeTypeInfo(new N.Setlet(C.C__SetletMarker, null), [G.TypeInformation]), null, true));
      }
    },
    $isFunction: true
  },
  TypeGraphInferrerEngine_runOverAllElements__trace: {
    "^": "Closure:305;this_4",
    call$2: function(elements, tracer) {
      tracer.run$0();
      if (!tracer.continueAnalyzing) {
        H.IterableMixinWorkaround_forEach(elements, new G.TypeGraphInferrerEngine_runOverAllElements__trace_closure(this.this_4));
        return;
      }
      H.IterableMixinWorkaround_forEach(elements, new G.TypeGraphInferrerEngine_runOverAllElements__trace_closure0(this.this_4, tracer));
    },
    $isFunction: true
  },
  TypeGraphInferrerEngine_runOverAllElements__trace_closure: {
    "^": "Closure:128;this_5",
    call$1: function(e) {
      this.this_5.compiler.world.functionsThatMightBePassedToApply.add$1(0, e);
      if ($._VERBOSE)
        P.print("traced closure " + H.S(e) + " as true (bail)");
    },
    $isFunction: true
  },
  TypeGraphInferrerEngine_runOverAllElements__trace_closure0: {
    "^": "Closure:128;this_6,tracer_7",
    call$1: function(e) {
      var t1 = this.this_6;
      e.get$functionSignature().forEachParameter$1(new G.TypeGraphInferrerEngine_runOverAllElements__trace__closure(t1));
      if (this.tracer_7.tracedType.get$mightBePassedToFunctionApply())
        t1.compiler.world.functionsThatMightBePassedToApply.add$1(0, e);
      if ($._VERBOSE)
        P.print("traced closure " + H.S(e) + " as " + t1.compiler.world.getMightBePassedToApply$1(e));
    },
    $isFunction: true
  },
  TypeGraphInferrerEngine_runOverAllElements__trace__closure: {
    "^": "Closure:13;this_8",
    call$1: function(parameter) {
      var t1 = this.this_8;
      t1.workQueue.add$1(0, t1.types.getInferredTypeOf$1(parameter));
    },
    $isFunction: true
  },
  TypeGraphInferrerEngine_runOverAllElements__closure: {
    "^": "Closure:13;",
    call$1: function(e) {
      return e.get$isFunction();
    },
    $isFunction: true
  },
  TypeGraphInferrerEngine_runOverAllElements_closure3: {
    "^": "Closure:303;",
    call$1: function(info) {
      P.print(J.toString$0(J.get$type$x(info)) + " for " + J.toString$0(info.get$originalContainerType().allocationNode) + " at " + J.toString$0(info.originalContainerType.allocationElement) + " after " + info.refineCount);
    },
    $isFunction: true
  },
  TypeGraphInferrerEngine_runOverAllElements_closure4: {
    "^": "Closure:304;",
    call$1: function(info) {
      var t1 = J.getInterceptor$x(info);
      P.print(J.toString$0(t1.get$type(info)) + " for " + J.toString$0(H.interceptedTypeCast(t1.get$type(info), "$isMapTypeMask").allocationNode) + " at " + J.toString$0(H.interceptedTypeCast(t1.get$type(info), "$isMapTypeMask").allocationElement) + " after " + info.get$refineCount());
    },
    $isFunction: true
  },
  TypeGraphInferrerEngine_runOverAllElements_closure5: {
    "^": "Closure:306;this_9",
    call$1: function(info) {
      var t1, t2, target, line;
      t1 = J.getInterceptor(info);
      if (!!t1.$isElementTypeInformation) {
        t1 = info.element;
        P.print(this.this_9.types.getInferredSignatureOf$1(t1) + " for " + t1.toString$0(0));
      } else if (!!t1.$isClosureTypeInformation) {
        t1 = info.element;
        P.print(this.this_9.types.getInferredSignatureOf$1(t1) + " for " + J.toString$0(t1));
      } else if (!!t1.$isDynamicCallSiteTypeInformation)
        for (t1 = J.get$iterator$ax(info.targets), t2 = this.this_9.types; t1.moveNext$0();) {
          target = t1.get$current();
          if (!!J.getInterceptor(target).$isFunctionElement) {
            line = t2.getInferredSignatureOf$1(target) + " for " + H.S(target);
            H.printString(line);
          } else {
            line = J.toString$0(t2.getInferredTypeOf$1(target).type) + " for " + H.S(target);
            H.printString(line);
          }
        }
      else
        P.print(J.toString$0(t1.get$type(info)) + " for some unknown kind of closure");
    },
    $isFunction: true
  },
  TypeGraphInferrerEngine_runOverAllElements_closure6: {
    "^": "Closure:77;this_10",
    call$1: function(elem) {
      var type = this.this_10.types.getInferredTypeOf$1(elem);
      P.print(H.S(elem) + " :: " + J.toString$0(type) + " from " + H.S(type.assignments) + " ");
    },
    $isFunction: true
  },
  TypeGraphInferrerEngine_analyze_closure: {
    "^": "Closure:23;box_0,visitor_1",
    call$0: function() {
      this.box_0.type_0 = this.visitor_1.run$0();
    },
    $isFunction: true
  },
  TypeGraphInferrerEngine_processLoopInformation_closure: {
    "^": "Closure:13;this_0",
    call$1: function(info) {
      var t1, t2;
      if (!info.get$inLoop())
        return;
      if (!!info.$isStaticCallSiteTypeInformation) {
        t1 = this.this_0.compiler.world;
        t2 = info.calledElement;
        t1.functionsCalledInLoop.add$1(0, t2.get$declaration());
      } else if (info.get$selector().get$mask() != null && !info.selector.get$mask().containsAll$1(this.this_0.compiler))
        J.forEach$1$ax(info.get$targets(), this.this_0.compiler.world.get$addFunctionCalledInLoop());
    },
    $isFunction: true
  },
  TypeGraphInferrerEngine_updateParameterAssignments_closure: {
    "^": "Closure:77;this_1,addToQueue_2",
    call$1: function(parameter) {
      var t1, info;
      t1 = this.this_1;
      info = t1.types.getInferredTypeOf$1(parameter);
      info.giveUp$2$clearAssignments(t1, false);
      if (this.addToQueue_2) {
        t1 = t1.workQueue;
        J.forEach$1$ax(info.users, t1.get$add(t1));
      }
    },
    $isFunction: true
  },
  TypeGraphInferrerEngine_updateParameterAssignments_closure0: {
    "^": "Closure:77;box_0,this_3,arguments_4,remove_5,addToQueue_6,signature_7",
    call$1: function(parameter) {
      var t1, t2, t3, type, info;
      t1 = this.signature_7;
      t2 = J.getInterceptor(parameter);
      if (t2.$eq(parameter, t1.get$firstOptionalParameter()))
        this.box_0.visitingRequiredParameter_1 = false;
      t3 = this.box_0;
      if (t3.visitingRequiredParameter_1) {
        t1 = this.arguments_4.positional;
        t2 = t3.parameterIndex_0;
        if (t2 >= t1.length)
          return H.ioore(t1, t2);
        type = t1[t2];
      } else if (t1.optionalParametersAreNamed) {
        t1 = this.arguments_4.named.$index(0, t2.get$name(parameter));
        type = t1;
      } else {
        t1 = t3.parameterIndex_0;
        t2 = this.arguments_4.positional;
        t1 = t1 < t2.length ? t2[t1] : null;
        type = t1;
      }
      if (type == null)
        type = this.this_3.getDefaultTypeOfParameter$1(parameter);
      t1 = this.this_3;
      info = t1.types.getInferredTypeOf$1(parameter);
      if (this.remove_5)
        info.removeAssignment$1(type);
      else
        info.addAssignment$1(type);
      ++t3.parameterIndex_0;
      if (this.addToQueue_6)
        t1.workQueue.add$1(0, info);
    },
    $isFunction: true
  },
  TypeGraphInferrerEngine_getDefaultTypeOfParameter_closure: {
    "^": "Closure:23;this_0",
    call$0: function() {
      return G.ConcreteTypeInformation$(this.this_0.types.get$dynamicType().type);
    },
    $isFunction: true
  },
  TypeGraphInferrerEngine_registerCalledSelector_closure: {
    "^": "Closure:13;this_0,selector_1,sideEffects_2",
    call$1: function(callee) {
      this.this_0.updateSideEffects$3(this.sideEffects_2, this.selector_1, callee);
    },
    $isFunction: true
  },
  TypeGraphInferrerEngine_sortResolvedElements_closure: {
    "^": "Closure:95;box_0,this_1,methodSizes_2",
    call$1: function(element) {
      var t1, $length, max;
      if (!this.this_1.compiler.enqueuer.resolution.resolvedElements.contains$1(0, element.get$analyzableElement().get$declaration()))
        return;
      t1 = element.get$resolvedAst();
      element = element.get$implementation(element);
      if ((element.get$kind(element).category & 164) !== 0)
        return;
      if (element.get$isAbstract())
        return;
      t1 = t1.elements._selectors;
      $length = t1 == null ? 0 : t1.get$length(t1);
      t1 = this.box_0;
      max = t1.max_0;
      if (typeof $length !== "number")
        return $length.$gt();
      if ($length > max)
        max = $length;
      t1.max_0 = max;
      J.add$1$ax(this.methodSizes_2.putIfAbsent$2($length, new G.TypeGraphInferrerEngine_sortResolvedElements__closure()), element);
    },
    $isFunction: true
  },
  TypeGraphInferrerEngine_sortResolvedElements__closure: {
    "^": "Closure:23;",
    call$0: function() {
      return H.setRuntimeTypeInfo(new N.Setlet(C.C__SetletMarker, null), [O.Element]);
    },
    $isFunction: true
  },
  TypeGraphInferrerEngine_clear_closure: {
    "^": "Closure:13;",
    call$1: function(info) {
      return J.clear$0$ax(info);
    },
    $isFunction: true
  },
  TypeGraphInferrer: {
    "^": "Object;inferrer,compiler<",
    get$name: function(_) {
      return "Graph inferrer";
    },
    getReturnTypeOfElement$1: function(element) {
      var t1 = this.compiler;
      if (t1.disableTypeInferenceFlag)
        return t1.typesTask.get$dynamicType();
      if (!J.getInterceptor(element).$isFunctionElement)
        return t1.typesTask.get$dynamicType();
      return this.inferrer.types.getInferredTypeOf$1(element).type;
    },
    getTypeOfElement$1: function(element) {
      var t1 = this.compiler;
      if (t1.disableTypeInferenceFlag)
        return t1.typesTask.get$dynamicType();
      if (!!J.getInterceptor(element).$isFunctionElement)
        return t1.typesTask.get$functionType();
      return this.inferrer.types.getInferredTypeOf$1(element).type;
    },
    getTypeOfNode$2: function(owner, node) {
      var t1 = this.compiler;
      if (t1.disableTypeInferenceFlag)
        return t1.typesTask.get$dynamicType();
      return J.get$type$x(this.inferrer.types.allocatedLists.$index(0, node));
    },
    isFixedArrayCheckedForGrowable$1: function(node) {
      if (this.compiler.disableTypeInferenceFlag)
        return true;
      return this.inferrer.types.allocatedLists.$index(0, node).get$checksGrowable();
    },
    getTypeOfSelector$1: function(selector) {
      var t1, t2, elementType, valueType, result, element;
      t1 = this.compiler;
      if (t1.disableTypeInferenceFlag)
        return t1.typesTask.get$dynamicType();
      if (selector.get$isClosureCall())
        return t1.typesTask.get$dynamicType();
      t2 = selector.kind;
      if (t2 !== C.SelectorKind_setter_1)
        t2 = t2 === C.SelectorKind_index_4 && selector.argumentCount === 2;
      else
        t2 = true;
      if (t2)
        return t1.typesTask.get$dynamicType();
      if (this.inferrer.returnsListElementType$1(selector)) {
        elementType = selector.get$mask().get$elementType();
        return elementType == null ? t1.typesTask.get$dynamicType() : elementType;
      }
      if (this.inferrer.returnsMapValueType$1(selector)) {
        valueType = selector.get$mask().get$valueType();
        return valueType == null ? t1.typesTask.get$dynamicType() : valueType;
      }
      for (t2 = J.get$iterator$ax(t1.world.allFunctions.query$1(0, selector).functions), result = C.FlatTypeMask_null_0; t2.moveNext$0();) {
        element = t2.get$current();
        result = result.union$2(this.inferrer.typeOfElementWithSelector$2(element, selector).type, t1);
      }
      return result;
    },
    isCalledOnce$1: function(element) {
      if (this.compiler.disableTypeInferenceFlag)
        return false;
      return this.inferrer.types.getInferredTypeOf$1(element).isCalledOnce$0();
    },
    clear$0: function(_) {
      this.inferrer.clear$0(0);
    }
  },
  TypeInformation: {
    "^": "Object;users<,assignments<,type>,abandonInferencing<,refineCount<,inQueue?,isStable<,hashCode>",
    get$isConcrete: function() {
      return false;
    },
    addUser$1: function(user) {
      J.add$1$ax(this.users, user);
    },
    removeUser$1: function(user) {
      J.remove$1$ax(this.users, user);
    },
    addAssignment$1: [function(assignment) {
      if (J.$eq(assignment, this))
        return;
      if (!J.$eq(this.assignments, $.get$TypeInformation_STOP_TRACKING_ASSIGNMENTS_MARKER()))
        J.add$1$ax(this.assignments, assignment);
      assignment.addUser$1(this);
    }, "call$1", "get$addAssignment", 2, 0, 302],
    removeAssignment$1: function(assignment) {
      var t1, t2;
      if (this.abandonInferencing) {
        t1 = this.assignments;
        t2 = $.get$TypeInformation_STOP_TRACKING_ASSIGNMENTS_MARKER();
        t2 = t1 == null ? t2 != null : t1 !== t2;
        t1 = t2;
      } else
        t1 = true;
      if (t1)
        J.remove$1$ax(this.assignments, assignment);
      if (J.contains$1$asx(this.assignments, assignment) !== true)
        assignment.removeUser$1(this);
    },
    refine$1: function(inferrer) {
      return this.type;
    },
    giveUp$2$clearAssignments: function(inferrer, clearAssignments) {
      this.abandonInferencing = true;
      this.type = inferrer.types.get$dynamicType().type;
      if (clearAssignments)
        this.assignments = $.get$TypeInformation_STOP_TRACKING_ASSIGNMENTS_MARKER();
    },
    giveUp$1: function(inferrer) {
      return this.giveUp$2$clearAssignments(inferrer, true);
    },
    clear$0: function(_) {
      this.assignments = $.get$TypeInformation_STOP_TRACKING_ASSIGNMENTS_MARKER();
      this.users = C.List_empty10;
    },
    reset$1: function(_, inferrer) {
      if (this.abandonInferencing)
        return;
      this.type = C.FlatTypeMask_null_0;
      this.refineCount = 0;
    },
    get$owner: function() {
      return;
    },
    hasStableType$1: function(inferrer) {
      var t1, t2;
      t1 = this.assignments;
      t2 = $.get$TypeInformation_STOP_TRACKING_ASSIGNMENTS_MARKER();
      return (t1 == null ? t2 == null : t1 === t2) && J.every$1$ax(t1, new G.TypeInformation_hasStableType_closure()) === true;
    },
    removeAndClearReferences$1: function(inferrer) {
      J.forEach$1$ax(this.assignments, new G.TypeInformation_removeAndClearReferences_closure(this));
    }
  },
  TypeInformation_hasStableType_closure: {
    "^": "Closure:13;",
    call$1: function(e) {
      return e.get$isStable();
    },
    $isFunction: true
  },
  TypeInformation_removeAndClearReferences_closure: {
    "^": "Closure:13;this_0",
    call$1: function(info) {
      info.removeUser$1(this.this_0);
    },
    $isFunction: true
  },
  ApplyableTypeInformation: {
    "^": "TypeInformation;mightBePassedToFunctionApply@"
  },
  ParameterAssignments: {
    "^": "IterableBase;assignments<",
    remove$1: function(_, info) {
      var t1, existing, t2;
      t1 = this.assignments;
      existing = t1.$index(0, info);
      if (existing == null)
        return;
      t2 = J.getInterceptor(existing);
      if (t2.$eq(existing, 1))
        t1.remove$1(0, info);
      else
        t1.$indexSet(0, info, t2.$sub(existing, 1));
    },
    add$1: function(_, info) {
      var t1, existing;
      t1 = this.assignments;
      existing = t1.$index(0, info);
      if (existing == null)
        t1.$indexSet(0, info, 1);
      else
        t1.$indexSet(0, info, J.$add$ns(existing, 1));
    },
    get$iterator: function(_) {
      var t1, t2;
      t1 = this.assignments;
      t1 = H.setRuntimeTypeInfo(new P.LinkedHashMapKeyIterable(t1), [H.getTypeArgumentByIndex(t1, 0)]);
      t2 = t1._map;
      t1 = H.setRuntimeTypeInfo(new P.LinkedHashMapKeyIterator(t2, t2._modifications, null, null), [H.getTypeArgumentByIndex(t1, 0)]);
      t1._cell = t1._map._first;
      return t1;
    },
    where$1: function(_, f) {
      var t1 = this.assignments;
      t1 = H.setRuntimeTypeInfo(new P.LinkedHashMapKeyIterable(t1), [H.getTypeArgumentByIndex(t1, 0)]);
      return H.setRuntimeTypeInfo(new H.WhereIterable(t1, f), [H.getRuntimeTypeArgument(t1, "IterableBase", 0)]);
    },
    contains$1: function(_, info) {
      return this.assignments.containsKey$1(info);
    },
    toString$0: function(_) {
      var t1 = this.assignments;
      t1 = H.setRuntimeTypeInfo(new P.LinkedHashMapKeyIterable(t1), [H.getTypeArgumentByIndex(t1, 0)]);
      return P.IterableBase_iterableToFullString(P.List_List$from(t1, true, H.getRuntimeTypeArgument(t1, "IterableBase", 0)), "[", "]");
    },
    $asIterableBase: function() {
      return [G.TypeInformation];
    },
    $asIterable: function() {
      return [G.TypeInformation];
    }
  },
  ElementTypeInformation: {
    "^": "ApplyableTypeInformation;element<,disableInferenceForClosures,closurizedCount,_callers,mightBePassedToFunctionApply,users,assignments,type,abandonInferencing,refineCount,inQueue,isStable,hashCode",
    addCall$2: function(caller, node) {
      J.add$1$ax(this._callers.putIfAbsent$2(caller, new G.ElementTypeInformation_addCall_closure()), node);
    },
    removeCall$2: function(caller, node) {
      var t1, calls, t2;
      t1 = this._callers;
      calls = t1.$index(0, caller);
      if (calls == null)
        return;
      t2 = J.getInterceptor$ax(calls);
      t2.remove$1(calls, node);
      if (t2.get$isEmpty(calls))
        t1.remove$1(0, caller);
    },
    isCalledOnce$0: function() {
      var t1, count, t2;
      for (t1 = this._callers, t1 = t1.get$values(t1), t1 = H.setRuntimeTypeInfo(new H.MappedIterator(null, J.get$iterator$ax(t1._iterable), t1._f), [H.getTypeArgumentByIndex(t1, 0), H.getTypeArgumentByIndex(t1, 1)]), count = 0; t1.moveNext$0();) {
        t2 = J.get$length$asx(t1.__internal$_current);
        if (typeof t2 !== "number")
          return H.iae(t2);
        count += t2;
        if (count > 1)
          return false;
      }
      return count === 1;
    },
    get$isStable: function() {
      return this.isStable && this.closurizedCount <= 0;
    },
    handleSpecialCases$1: function(inferrer) {
      var t1, enclosing, t2, compiler, t3;
      if (this.abandonInferencing)
        return this.type;
      t1 = this.element;
      if (t1.get$kind(t1) === C.ElementKind_parameter_1) {
        enclosing = t1.get$enclosingElement();
        if (O.Elements_isLocal(enclosing) && this.disableInferenceForClosures) {
          this.giveUp$2$clearAssignments(inferrer, false);
          return this.type;
        } else {
          if (enclosing.get$isInstanceMember()) {
            t2 = enclosing.name;
            if (t2 !== "noSuchMethod")
              t2 = t2 === "call" && this.disableInferenceForClosures;
            else
              t2 = true;
          } else
            t2 = false;
          if (t2) {
            this.giveUp$1(inferrer);
            return this.type;
          } else if (enclosing === inferrer.mainElement) {
            this.giveUp$1(inferrer);
            return this.type;
          }
        }
      }
      if (t1.kind === C.ElementKind_field_1 || t1.kind === C.ElementKind_parameter_1 || t1.kind === C.ElementKind_initializing_formal_1)
        if (!inferrer.compiler.backend.canBeUsedForGlobalOptimizations$1(t1)) {
          this.giveUp$1(inferrer);
          return this.type;
        }
      if (inferrer.isNativeElement$1(t1)) {
        this.giveUp$1(inferrer);
        if (t1.kind === C.ElementKind_field_1) {
          t1 = inferrer.typeOfNativeBehavior$1(L.NativeBehavior_ofFieldLoad(t1, inferrer.compiler));
          return t1.get$type(t1);
        } else if (!J.$eq(J.get$kind$x(t1.get$type(t1)), C.TypeKind_function))
          return this.type;
        else {
          t1 = inferrer.typeOfNativeBehavior$1(L.NativeBehavior_ofMethod(t1, inferrer.compiler));
          return t1.get$type(t1);
        }
      }
      compiler = inferrer.compiler;
      t2 = t1.get$declaration();
      t3 = compiler.intEnvironment;
      if (t2 == null ? t3 == null : t2 === t3) {
        this.giveUp$1(inferrer);
        return compiler.typesTask.get$intType().nullable$0();
      } else {
        t2 = t1.get$declaration();
        t3 = compiler.boolEnvironment;
        if (t2 == null ? t3 == null : t2 === t3) {
          this.giveUp$1(inferrer);
          return compiler.typesTask.get$boolType().nullable$0();
        } else {
          t1 = t1.get$declaration();
          t2 = compiler.stringEnvironment;
          if (t1 == null ? t2 == null : t1 === t2) {
            this.giveUp$1(inferrer);
            return compiler.typesTask.get$stringType().nullable$0();
          }
        }
      }
      return;
    },
    potentiallyNarrowType$2: function(mask, inferrer) {
      var compiler, t1, type;
      compiler = inferrer.compiler;
      t1 = this.element;
      if (t1.get$kind(t1) === C.ElementKind_parameter_1 || t1.kind === C.ElementKind_initializing_formal_1)
        return mask;
      if (!compiler.trustTypeAnnotations && !compiler.enableTypeAssertions)
        return mask;
      if (t1.kind === C.ElementKind_generative_constructor_16 || t1.kind === C.ElementKind_setter_0)
        return mask;
      type = t1.computeType$1(compiler);
      if (t1.get$isFunction() || t1.get$isGetter() || t1.get$isFactoryConstructor())
        type = type.get$returnType();
      return new Q.TypeMaskSystem(compiler).narrowType$2(mask, type);
    },
    refine$1: function(inferrer) {
      var special = this.handleSpecialCases$1(inferrer);
      if (special != null)
        return this.potentiallyNarrowType$2(special, inferrer);
      return this.potentiallyNarrowType$2(inferrer.types.computeTypeMask$1(this.assignments), inferrer);
    },
    toString$0: function(_) {
      return "Element " + this.element.toString$0(0) + " " + J.toString$0(this.type);
    },
    accept$1: function(_, visitor) {
      return visitor.visitElementTypeInformation$1(this);
    },
    get$owner: function() {
      return this.element.get$outermostEnclosingMemberOrTopLevel();
    },
    hasStableType$1: function(inferrer) {
      var t1, t2;
      t1 = this.element;
      if (t1.get$kind(t1) === C.ElementKind_parameter_1 && t1.get$enclosingElement().get$isInstanceMember())
        return false;
      if (t1.kind === C.ElementKind_field_1)
        t2 = !(t1.get$isConst() || t1.get$isFinal());
      else
        t2 = false;
      if (t2)
        return false;
      if (t1.get$isFunction())
        return false;
      return G.TypeInformation.prototype.hasStableType$1.call(this, inferrer);
    },
    $isElementTypeInformation: true
  },
  ElementTypeInformation_addCall_closure: {
    "^": "Closure:23;",
    call$0: function() {
      return H.setRuntimeTypeInfo(new N.Setlet(C.C__SetletMarker, null), [null]);
    },
    $isFunction: true
  },
  CallSiteTypeInformation: {
    "^": "ApplyableTypeInformation;selector<,arguments<,inLoop<",
    call$1: function(arg0) {
      return this.$call.call$1(arg0);
    },
    call$4: function(arg0, arg1, arg2, arg3) {
      return this.$call.call$4(arg0, arg1, arg2, arg3);
    },
    call$0: function() {
      return this.$call.call$0();
    },
    call$2: function(arg0, arg1) {
      return this.$call.call$2(arg0, arg1);
    },
    call$4$cancelOnError$onDone$onError: function(arg0, arg1, arg2, arg3) {
      return this.$call.call$4$cancelOnError$onDone$onError(arg0, arg1, arg2, arg3);
    },
    call$2$onError: function(arg0, arg1) {
      return this.$call.call$2$onError(arg0, arg1);
    },
    call$3: function(arg0, arg1, arg2) {
      return this.$call.call$3(arg0, arg1, arg2);
    },
    call$3$async: function(arg0, arg1, arg2) {
      return this.$call.call$3$async(arg0, arg1, arg2);
    },
    call$2$includeSuperAndInjectedMembers: function(arg0, arg1) {
      return this.$call.call$2$includeSuperAndInjectedMembers(arg0, arg1);
    },
    call$5: function(arg0, arg1, arg2, arg3, arg4) {
      return this.$call.call$5(arg0, arg1, arg2, arg3, arg4);
    },
    call$2$includedEnclosing: function(arg0, arg1) {
      return this.$call.call$2$includedEnclosing(arg0, arg1);
    },
    call$4$ensureSafe: function(arg0, arg1, arg2, arg3) {
      return this.$call.call$4$ensureSafe(arg0, arg1, arg2, arg3);
    },
    call$3$includeBackendMembers$includeSuperAndInjectedMembers: function(arg0, arg1, arg2) {
      return this.$call.call$3$includeBackendMembers$includeSuperAndInjectedMembers(arg0, arg1, arg2);
    },
    call$3$isConst: function(arg0, arg1, arg2) {
      return this.$call.call$3$isConst(arg0, arg1, arg2);
    },
    call$3$erroneousElement: function(arg0, arg1, arg2) {
      return this.$call.call$3$erroneousElement(arg0, arg1, arg2);
    },
    call$3$userProvidedBadType: function(arg0, arg1, arg2) {
      return this.$call.call$3$userProvidedBadType(arg0, arg1, arg2);
    },
    call$3$onDone$onError: function(arg0, arg1, arg2) {
      return this.$call.call$3$onDone$onError(arg0, arg1, arg2);
    },
    call$4$emitStatics: function(arg0, arg1, arg2, arg3) {
      return this.$call.call$4$emitStatics(arg0, arg1, arg2, arg3);
    },
    call$2$isTypeArgument: function(arg0, arg1) {
      return this.$call.call$2$isTypeArgument(arg0, arg1);
    },
    call$6: function(arg0, arg1, arg2, arg3, arg4, arg5) {
      return this.$call.call$6(arg0, arg1, arg2, arg3, arg4, arg5);
    },
    call$4$onlyForRti: function(arg0, arg1, arg2, arg3) {
      return this.$call.call$4$onlyForRti(arg0, arg1, arg2, arg3);
    },
    call$2$emitNull: function(arg0, arg1) {
      return this.$call.call$2$emitNull(arg0, arg1);
    },
    call$2$includeBackendMembers: function(arg0, arg1) {
      return this.$call.call$2$includeBackendMembers(arg0, arg1);
    },
    call$4$classIsNative: function(arg0, arg1, arg2, arg3) {
      return this.$call.call$4$classIsNative(arg0, arg1, arg2, arg3);
    },
    call$1$node: function(arg0) {
      return this.$call.call$1$node(arg0);
    },
    call$3$onType$onVar: function(arg0, arg1, arg2) {
      return this.$call.call$3$onType$onVar(arg0, arg1, arg2);
    },
    call$4$onType$onVar$onVoid: function(arg0, arg1, arg2, arg3) {
      return this.$call.call$4$onType$onVar$onVoid(arg0, arg1, arg2, arg3);
    },
    call$2$node: function(arg0, arg1) {
      return this.$call.call$2$node(arg0, arg1);
    },
    call$2$spacesNeeded: function(arg0, arg1) {
      return this.$call.call$2$spacesNeeded(arg0, arg1);
    },
    call$7: function(arg0, arg1, arg2, arg3, arg4, arg5, arg6) {
      return this.$call.call$7(arg0, arg1, arg2, arg3, arg4, arg5, arg6);
    },
    call$3$isNullable: function(arg0, arg1, arg2) {
      return this.$call.call$3$isNullable(arg0, arg1, arg2);
    },
    call$3$argumentValues: function(arg0, arg1, arg2) {
      return this.$call.call$3$argumentValues(arg0, arg1, arg2);
    },
    call$3$argumentNodes: function(arg0, arg1, arg2) {
      return this.$call.call$3$argumentNodes(arg0, arg1, arg2);
    },
    call$4$argumentNodes$existingArguments: function(arg0, arg1, arg2, arg3) {
      return this.$call.call$4$argumentNodes$existingArguments(arg0, arg1, arg2, arg3);
    },
    call$3$reportError: function(arg0, arg1, arg2) {
      return this.$call.call$3$reportError(arg0, arg1, arg2);
    },
    toString$0: function(_) {
      return "Call site " + J.toString$0(this.$call) + " " + J.toString$0(this.type);
    },
    get$owner: function() {
      return this.caller;
    },
    $isCallSiteTypeInformation: true
  },
  StaticCallSiteTypeInformation: {
    "^": "CallSiteTypeInformation;calledElement,$call,caller,selector,arguments,inLoop,mightBePassedToFunctionApply,users,assignments,type,abandonInferencing,refineCount,inQueue,isStable,hashCode",
    addToGraph$1: function(inferrer) {
      var t1, callee, t2, t3, t4;
      t1 = this.calledElement;
      callee = inferrer.types.getInferredTypeOf$1(t1);
      callee.addCall$2(this.caller, this.$call);
      J.add$1$ax(callee.users, this);
      t2 = this.arguments;
      if (t2 != null) {
        t3 = new G.StaticCallSiteTypeInformation_addToGraph_closure(this);
        H.IterableMixinWorkaround_forEach(t2.positional, t3);
        t4 = t2.named;
        J.forEach$1$ax(t4.get$values(t4), t3);
      }
      inferrer.updateParameterAssignments$6$addToQueue$remove(this, t1, t2, this.selector, false, false);
    },
    get$isSynthesized: function() {
      return this.selector == null;
    },
    refine$1: function(inferrer) {
      var t1, t2;
      t1 = this.selector;
      t2 = this.calledElement;
      if (t1 == null)
        return inferrer.types.getInferredTypeOf$1(t2).type;
      else
        return inferrer.typeOfElementWithSelector$2(t2, t1).type;
    },
    get$callees: function() {
      var t1 = this.calledElement;
      return [t1.get$implementation(t1)];
    },
    accept$1: function(_, visitor) {
      return visitor.visitStaticCallSiteTypeInformation$1(this);
    },
    hasStableType$1: function(inferrer) {
      var t1, t2;
      t1 = inferrer.types.getInferredTypeOf$1(this.calledElement);
      t1.toString;
      if (t1.isStable && t1.closurizedCount <= 0) {
        t1 = this.arguments;
        if (t1 != null) {
          t2 = new G.StaticCallSiteTypeInformation_hasStableType_closure();
          if (H.IterableMixinWorkaround_every(t1.positional, t2)) {
            t1 = t1.named;
            t2 = J.every$1$ax(t1.get$values(t1), t2);
            t1 = t2;
          } else
            t1 = false;
        } else
          t1 = true;
        t1 = t1 && G.TypeInformation.prototype.hasStableType$1.call(this, inferrer);
      } else
        t1 = false;
      return t1;
    },
    removeAndClearReferences$1: function(inferrer) {
      var t1, t2;
      J.remove$1$ax(inferrer.types.getInferredTypeOf$1(this.calledElement).users, this);
      t1 = this.arguments;
      if (t1 != null) {
        t2 = new G.StaticCallSiteTypeInformation_removeAndClearReferences_closure(this);
        H.IterableMixinWorkaround_forEach(t1.positional, t2);
        t1 = t1.named;
        J.forEach$1$ax(t1.get$values(t1), t2);
      }
      G.TypeInformation.prototype.removeAndClearReferences$1.call(this, inferrer);
    },
    $isStaticCallSiteTypeInformation: true
  },
  StaticCallSiteTypeInformation_addToGraph_closure: {
    "^": "Closure:13;this_0",
    call$1: function(info) {
      return info.addUser$1(this.this_0);
    },
    $isFunction: true
  },
  StaticCallSiteTypeInformation_hasStableType_closure: {
    "^": "Closure:13;",
    call$1: function(info) {
      return info.get$isStable();
    },
    $isFunction: true
  },
  StaticCallSiteTypeInformation_removeAndClearReferences_closure: {
    "^": "Closure:13;this_0",
    call$1: function(info) {
      return info.removeUser$1(this.this_0);
    },
    $isFunction: true
  },
  DynamicCallSiteTypeInformation: {
    "^": "CallSiteTypeInformation;receiver<,targets<,$call,caller,selector,arguments,inLoop,mightBePassedToFunctionApply,users,assignments,type,abandonInferencing,refineCount,inQueue,isStable,hashCode",
    addToGraph$1: function(inferrer) {
      var typedSelector, t1, t2, t3, t4, t5, element, callee;
      typedSelector = this.computeTypedSelector$1(inferrer);
      this.targets = inferrer.compiler.world.allFunctions.query$1(0, typedSelector).functions;
      this.receiver.addUser$1(this);
      t1 = this.arguments;
      if (t1 != null) {
        t2 = new G.DynamicCallSiteTypeInformation_addToGraph_closure(this);
        H.IterableMixinWorkaround_forEach(t1.positional, t2);
        t3 = t1.named;
        J.forEach$1$ax(t3.get$values(t3), t2);
      }
      for (t2 = J.get$iterator$ax(this.targets), t3 = inferrer.types, t4 = this.caller, t5 = this.$call; t2.moveNext$0();) {
        element = t2.get$current();
        callee = t3.getInferredTypeOf$1(element);
        callee.addCall$2(t4, t5);
        J.add$1$ax(callee.users, this);
        inferrer.updateParameterAssignments$6$addToQueue$remove(this, element, t1, typedSelector, false, false);
      }
    },
    get$callees: function() {
      return J.map$1$ax(this.targets, new G.DynamicCallSiteTypeInformation_callees_closure());
    },
    computeTypedSelector$1: function(inferrer) {
      var receiverType, t1, t2;
      receiverType = this.receiver.type;
      t1 = this.selector;
      if (!J.$eq(t1.get$mask(), receiverType)) {
        t2 = inferrer.compiler;
        return J.$eq(receiverType, t2.typesTask.get$dynamicType()) ? t1.get$asUntyped() : Z.TypedSelector_TypedSelector(receiverType, t1, t2);
      } else
        return t1;
    },
    get$targetsIncludeNoSuchMethod: function() {
      return J.any$1$ax(this.targets, new G.DynamicCallSiteTypeInformation_targetsIncludeNoSuchMethod_closure());
    },
    handleIntrisifiedSelector$2: function(selector, inferrer) {
      var compiler, t1, t2, t3, t4, t5, t6, t7, $name;
      compiler = inferrer.compiler;
      if (!compiler.backend.get$intImplementation().get$isResolved())
        return;
      if (selector.get$mask() == null)
        return;
      if (!selector.get$mask().containsOnlyInt$1(compiler))
        return;
      t1 = selector.kind;
      if (t1 !== C.SelectorKind_call_2 && t1 !== C.SelectorKind_operator_3)
        return;
      t1 = this.arguments;
      t2 = t1.named;
      if (!t2.get$isEmpty(t2))
        return;
      t3 = t1.positional;
      if (t3.length > 1)
        return;
      t4 = new G.DynamicCallSiteTypeInformation_handleIntrisifiedSelector_isInt(compiler);
      t5 = new G.DynamicCallSiteTypeInformation_handleIntrisifiedSelector_isEmpty(C.FlatTypeMask_null_0);
      t6 = new G.DynamicCallSiteTypeInformation_handleIntrisifiedSelector_isUInt31(compiler, compiler.backend.get$uint31Implementation());
      t7 = new G.DynamicCallSiteTypeInformation_handleIntrisifiedSelector_isPositiveInt(compiler);
      $name = selector.name;
      if ($name === "*" || $name === "+" || $name === "%" || $name === "remainder" || $name === "~/")
        if (t7.call$1(this.receiver) === true && t1.hasOnePositionalArgumentThatMatches$1(t7))
          return inferrer.types.get$positiveIntType();
        else if (t1.hasOnePositionalArgumentThatMatches$1(t4))
          return inferrer.types.get$intType();
        else if (t1.hasOnePositionalArgumentThatMatches$1(t5))
          return inferrer.types.nonNullEmptyType;
        else
          return;
      else if ($name === "|" || $name === "^") {
        if (t6.call$1(this.receiver) === true && t1.hasOnePositionalArgumentThatMatches$1(t6))
          return inferrer.types.get$uint31Type();
      } else if ($name === ">>") {
        if (t6.call$1(this.receiver) === true)
          return inferrer.types.get$uint31Type();
      } else if ($name === "&") {
        if (t6.call$1(this.receiver) === true || t1.hasOnePositionalArgumentThatMatches$1(t6))
          return inferrer.types.get$uint31Type();
      } else if ($name === "unary-")
        return inferrer.types.get$intType();
      else if ($name === "-") {
        if (t1.hasOnePositionalArgumentThatMatches$1(t4))
          return inferrer.types.get$intType();
        else if (t1.hasOnePositionalArgumentThatMatches$1(t5))
          return inferrer.types.nonNullEmptyType;
        return;
      } else if ($name === "abs")
        return t3.length === 0 && t2.get$isEmpty(t2) ? inferrer.types.get$positiveIntType() : null;
      return;
    },
    refine$1: function(inferrer) {
      var oldTargets, typedSelector, compiler, selectorToUse, canReachAll, typedTargets, newType;
      oldTargets = this.targets;
      typedSelector = this.computeTypedSelector$1(inferrer);
      inferrer.updateSelectorInTree$3(this.caller, this.$call, typedSelector);
      compiler = inferrer.compiler;
      selectorToUse = typedSelector.extendIfReachesAll$1(compiler);
      canReachAll = compiler.enabledInvokeOn && selectorToUse !== typedSelector;
      typedTargets = compiler.world.allFunctions.query$1(0, selectorToUse).functions;
      this.targets = typedTargets;
      if (canReachAll)
        typedTargets = compiler.world.allFunctions.query$1(0, typedSelector).functions;
      newType = inferrer.types.joinTypeMasks$1(J.map$1$ax(this.targets, new G.DynamicCallSiteTypeInformation_refine_closure(this, inferrer, oldTargets, typedSelector, canReachAll, typedTargets)));
      J.forEach$1$ax(oldTargets, new G.DynamicCallSiteTypeInformation_refine_closure0(this, inferrer, typedSelector));
      return newType;
    },
    giveUp$2$clearAssignments: function(inferrer, clearAssignments) {
      var t1, t2, t3, oldTargets, t4, t5, t6, t7, element;
      t1 = this.caller;
      t2 = this.$call;
      t3 = this.selector;
      inferrer.updateSelectorInTree$3(t1, t2, t3);
      oldTargets = this.targets;
      t4 = inferrer.compiler.world.allFunctions.query$1(0, t3).functions;
      this.targets = t4;
      for (t4 = J.get$iterator$ax(t4), t5 = J.getInterceptor$asx(oldTargets), t6 = inferrer.types, t7 = this.arguments; t4.moveNext$0();) {
        element = t4.get$current();
        if (t5.contains$1(oldTargets, element) !== true) {
          t6.getInferredTypeOf$1(element).addCall$2(t1, t2);
          inferrer.updateParameterAssignments$6$addToQueue$remove(this, element, t7, t3, true, false);
        }
      }
      G.TypeInformation.prototype.giveUp$2$clearAssignments.call(this, inferrer, clearAssignments);
    },
    giveUp$1: function(inferrer) {
      return this.giveUp$2$clearAssignments(inferrer, true);
    },
    removeAndClearReferences$1: function(inferrer) {
      var t1, t2;
      for (t1 = J.get$iterator$ax(this.targets), t2 = inferrer.types; t1.moveNext$0();)
        J.remove$1$ax(t2.getInferredTypeOf$1(t1.get$current()).users, this);
      t1 = this.arguments;
      if (t1 != null) {
        t2 = new G.DynamicCallSiteTypeInformation_removeAndClearReferences_closure(this);
        H.IterableMixinWorkaround_forEach(t1.positional, t2);
        t1 = t1.named;
        J.forEach$1$ax(t1.get$values(t1), t2);
      }
      G.TypeInformation.prototype.removeAndClearReferences$1.call(this, inferrer);
    },
    toString$0: function(_) {
      return "Call site " + J.toString$0(this.$call) + " on " + J.toString$0(this.receiver.type) + " " + J.toString$0(this.type);
    },
    accept$1: function(_, visitor) {
      return visitor.visitDynamicCallSiteTypeInformation$1(this);
    },
    hasStableType$1: function(inferrer) {
      var t1, t2;
      if (this.receiver.get$isStable())
        if (J.every$1$ax(this.targets, new G.DynamicCallSiteTypeInformation_hasStableType_closure(inferrer))) {
          t1 = this.arguments;
          if (t1 != null) {
            t2 = new G.DynamicCallSiteTypeInformation_hasStableType_closure0();
            if (H.IterableMixinWorkaround_every(t1.positional, t2)) {
              t1 = t1.named;
              t2 = J.every$1$ax(t1.get$values(t1), t2);
              t1 = t2;
            } else
              t1 = false;
          } else
            t1 = true;
          t1 = t1 && G.TypeInformation.prototype.hasStableType$1.call(this, inferrer);
        } else
          t1 = false;
      else
        t1 = false;
      return t1;
    },
    $isDynamicCallSiteTypeInformation: true
  },
  DynamicCallSiteTypeInformation_addToGraph_closure: {
    "^": "Closure:13;this_0",
    call$1: function(info) {
      return info.addUser$1(this.this_0);
    },
    $isFunction: true
  },
  DynamicCallSiteTypeInformation_callees_closure: {
    "^": "Closure:13;",
    call$1: function(e) {
      return J.get$implementation$x(e);
    },
    $isFunction: true
  },
  DynamicCallSiteTypeInformation_targetsIncludeNoSuchMethod_closure: {
    "^": "Closure:77;",
    call$1: function(e) {
      return !!J.getInterceptor(e).$isFunctionElement && e.get$isInstanceMember() && e.name === "noSuchMethod";
    },
    $isFunction: true
  },
  DynamicCallSiteTypeInformation_handleIntrisifiedSelector_isInt: {
    "^": "Closure:300;compiler_0",
    call$1: function(info) {
      return J.get$type$x(info).containsOnlyInt$1(this.compiler_0);
    },
    $isFunction: true
  },
  DynamicCallSiteTypeInformation_handleIntrisifiedSelector_isEmpty: {
    "^": "Closure:300;emptyType_1",
    call$1: function(info) {
      return J.$eq(J.get$type$x(info), this.emptyType_1);
    },
    $isFunction: true
  },
  DynamicCallSiteTypeInformation_handleIntrisifiedSelector_isUInt31: {
    "^": "Closure:300;compiler_2,uint31Implementation_3",
    call$1: function(info) {
      return J.get$type$x(info).satisfies$2(this.uint31Implementation_3, this.compiler_2);
    },
    $isFunction: true
  },
  DynamicCallSiteTypeInformation_handleIntrisifiedSelector_isPositiveInt: {
    "^": "Closure:300;compiler_4",
    call$1: function(info) {
      var t1 = this.compiler_4;
      return J.get$type$x(info).satisfies$2(t1.backend.get$positiveIntImplementation(), t1);
    },
    $isFunction: true
  },
  DynamicCallSiteTypeInformation_refine_closure: {
    "^": "Closure:13;this_0,inferrer_1,oldTargets_2,typedSelector_3,canReachAll_4,typedTargets_5",
    call$1: function(element) {
      var t1, callee, t2, t3, mask, key, info;
      if (J.contains$1$asx(this.oldTargets_2, element) !== true) {
        t1 = this.inferrer_1;
        callee = t1.types.getInferredTypeOf$1(element);
        t2 = this.this_0;
        callee.addCall$2(t2.caller, t2.$call);
        J.add$1$ax(callee.users, t2);
        t1.updateParameterAssignments$6$addToQueue$remove(t2, element, t2.arguments, this.typedSelector_3, true, false);
      }
      if (this.canReachAll_4 && J.contains$1$asx(this.typedTargets_5, element) !== true)
        return C.FlatTypeMask_null_0;
      t1 = this.inferrer_1;
      t2 = this.typedSelector_3;
      if (t1.returnsListElementType$1(t2))
        return this.this_0.receiver.type.get$elementType();
      else if (t1.returnsMapValueType$1(t2)) {
        if (t2.get$mask().get$isDictionary()) {
          t3 = this.this_0.arguments.positional;
          if (0 >= t3.length)
            return H.ioore(t3, 0);
          t3 = J.get$type$x(t3[0]).get$isValue();
        } else
          t3 = false;
        if (t3) {
          mask = t2.get$mask();
          t2 = this.this_0.arguments.positional;
          if (0 >= t2.length)
            return H.ioore(t2, 0);
          key = J.get$value$x(J.get$type$x(t2[0]));
          if (mask.get$typeMap().containsKey$1(key)) {
            if ($._VERBOSE)
              P.print("Dictionary lookup for " + H.S(key) + " yields " + H.S(mask.typeMap.$index(0, key)) + ".");
            return mask.typeMap.$index(0, key);
          } else {
            if ($._VERBOSE)
              P.print("Dictionary lookup for " + H.S(key) + " yields [null].");
            return t1.types.get$nullType().type;
          }
        }
        mask = t2.get$mask();
        if ($._VERBOSE)
          P.print("Map lookup for " + t2.toString$0(0) + " yields " + J.toString$0(mask.get$valueType()) + ".");
        return mask.get$valueType();
      } else {
        info = this.this_0.handleIntrisifiedSelector$2(t2, t1);
        if (info != null)
          return info.type;
        return t1.typeOfElementWithSelector$2(element, t2).type;
      }
    },
    $isFunction: true
  },
  DynamicCallSiteTypeInformation_refine_closure0: {
    "^": "Closure:13;this_6,inferrer_7,typedSelector_8",
    call$1: function(element) {
      var t1, t2, callee;
      t1 = this.this_6;
      if (J.contains$1$asx(t1.targets, element) !== true) {
        t2 = this.inferrer_7;
        callee = t2.types.getInferredTypeOf$1(element);
        callee.removeCall$2(t1.caller, t1.$call);
        J.remove$1$ax(callee.users, t1);
        t2.updateParameterAssignments$6$addToQueue$remove(t1, element, t1.arguments, this.typedSelector_8, true, true);
      }
    },
    $isFunction: true
  },
  DynamicCallSiteTypeInformation_removeAndClearReferences_closure: {
    "^": "Closure:13;this_0",
    call$1: function(info) {
      return info.removeUser$1(this.this_0);
    },
    $isFunction: true
  },
  DynamicCallSiteTypeInformation_hasStableType_closure: {
    "^": "Closure:13;inferrer_0",
    call$1: function(element) {
      var t1 = this.inferrer_0.types.getInferredTypeOf$1(element);
      t1.toString;
      return t1.isStable && t1.closurizedCount <= 0;
    },
    $isFunction: true
  },
  DynamicCallSiteTypeInformation_hasStableType_closure0: {
    "^": "Closure:13;",
    call$1: function(info) {
      return info.get$isStable();
    },
    $isFunction: true
  },
  ClosureCallSiteTypeInformation: {
    "^": "CallSiteTypeInformation;closure,$call,caller,selector,arguments,inLoop,mightBePassedToFunctionApply,users,assignments,type,abandonInferencing,refineCount,inQueue,isStable,hashCode",
    addToGraph$1: function(inferrer) {
      var t1, t2;
      t1 = this.arguments;
      t2 = new G.ClosureCallSiteTypeInformation_addToGraph_closure(this);
      H.IterableMixinWorkaround_forEach(t1.positional, t2);
      t1 = t1.named;
      J.forEach$1$ax(t1.get$values(t1), t2);
      this.closure.addUser$1(this);
    },
    refine$1: function(inferrer) {
      return inferrer.types.get$dynamicType().type;
    },
    get$callees: function() {
      throw H.wrapException(P.UnsupportedError$("Cannot compute callees of a closure call."));
    },
    toString$0: function(_) {
      return "Closure call " + J.toString$0(this.$call) + " on " + J.toString$0(this.closure);
    },
    accept$1: function(_, visitor) {
      return visitor.visitClosureCallSiteTypeInformation$1(this);
    },
    removeAndClearReferences$1: function(inferrer) {
      return G.TypeInformation.prototype.removeAndClearReferences$1.call(this, inferrer);
    }
  },
  ClosureCallSiteTypeInformation_addToGraph_closure: {
    "^": "Closure:13;this_0",
    call$1: function(info) {
      return info.addUser$1(this.this_0);
    },
    $isFunction: true
  },
  ConcreteTypeInformation: {
    "^": "TypeInformation;users,assignments,type,abandonInferencing,refineCount,inQueue,isStable,hashCode",
    get$isConcrete: function() {
      return true;
    },
    addUser$1: function(user) {
    },
    removeUser$1: function(user) {
    },
    addAssignment$1: function(assignment) {
    },
    reset$1: function(_, inferrer) {
    },
    toString$0: function(_) {
      return "Type " + J.toString$0(this.type);
    },
    accept$1: function(_, visitor) {
      return visitor.visitConcreteTypeInformation$1(this);
    },
    hasStableType$1: function(inferrer) {
      return true;
    },
    ConcreteTypeInformation$1: function(type) {
      this.type = type;
      this.isStable = true;
    },
    static: {ConcreteTypeInformation$: function(type) {
        var t1 = $.TypeInformation_staticHashCode;
        $.TypeInformation_staticHashCode = t1 + 1;
        t1 = new G.ConcreteTypeInformation(C.List_empty10, C.List_empty10, C.FlatTypeMask_null_0, false, 0, false, false, t1);
        t1.ConcreteTypeInformation$1(type);
        return t1;
      }}
  },
  StringLiteralTypeInformation: {
    "^": "ConcreteTypeInformation;value>,users,assignments,type,abandonInferencing,refineCount,inQueue,isStable,hashCode",
    toString$0: function(_) {
      return "Type " + J.toString$0(this.type) + " value " + H.S(this.value.slowToString$0());
    },
    accept$1: function(_, visitor) {
      return visitor.visitStringLiteralTypeInformation$1(this);
    },
    $isStringLiteralTypeInformation: true
  },
  NarrowTypeInformation: {
    "^": "TypeInformation;typeAnnotation,users,assignments,type,abandonInferencing,refineCount,inQueue,isStable,hashCode",
    addAssignment$1: function(info) {
      G.TypeInformation.prototype.addAssignment$1.call(this, info);
    },
    refine$1: function(inferrer) {
      var intersection = J.intersection$2$x(J.get$type$x(J.$index$asx(this.assignments, 0)), this.typeAnnotation, inferrer.compiler);
      return intersection;
    },
    toString$0: function(_) {
      return "Narrow to " + J.toString$0(this.typeAnnotation) + " " + J.toString$0(this.type);
    },
    accept$1: function(_, visitor) {
      return visitor.visitNarrowTypeInformation$1(this);
    }
  },
  InferredTypeInformation: {
    "^": "TypeInformation;inferred?",
    refine$1: function(inferrer) {
      if (!this.inferred)
        return inferrer.types.get$dynamicType().type;
      return inferrer.types.computeTypeMask$1(this.assignments);
    },
    hasStableType$1: function(inferrer) {
      return this.inferred && G.TypeInformation.prototype.hasStableType$1.call(this, inferrer);
    }
  },
  ListTypeInformation: {
    "^": "TypeInformation;elementType,originalContainerType<,originalLength<,inferredLength<,checksGrowable<,flowsInto<,bailedOut<,analyzed,users,assignments,type,abandonInferencing,refineCount,inQueue,isStable,hashCode",
    toString$0: function(_) {
      return "List type " + J.toString$0(this.type);
    },
    accept$1: function(_, visitor) {
      return visitor.visitListTypeInformation$1(this);
    },
    hasStableType$1: function(inferrer) {
      return this.elementType.isStable && G.TypeInformation.prototype.hasStableType$1.call(this, inferrer);
    },
    refine$1: function(inferrer) {
      var mask, t1, t2;
      mask = this.type;
      if (mask.get$isContainer())
        if (J.$eq(mask.get$elementType(), this.elementType.type)) {
          t1 = mask.length;
          t2 = this.inferredLength;
          t2 = t1 == null ? t2 != null : t1 !== t2;
          t1 = t2;
        } else
          t1 = true;
      else
        t1 = true;
      if (t1) {
        t1 = this.originalContainerType;
        return new B.ContainerTypeMask(t1.forwardTo, t1.allocationNode, t1.allocationElement, this.elementType.type, this.inferredLength);
      }
      return mask;
    },
    giveUp$2$clearAssignments: function(inferrer, clearAssignments) {
      var t1;
      G.TypeInformation.prototype.giveUp$2$clearAssignments.call(this, inferrer, clearAssignments);
      t1 = this.originalContainerType;
      this.type = new B.ContainerTypeMask(t1.forwardTo, t1.allocationNode, t1.allocationElement, inferrer.types.get$dynamicType().type, null);
    },
    giveUp$1: function(inferrer) {
      return this.giveUp$2$clearAssignments(inferrer, true);
    },
    $isListTypeInformation: true
  },
  ElementInContainerTypeInformation: {
    "^": "InferredTypeInformation;inferred,users,assignments,type,abandonInferencing,refineCount,inQueue,isStable,hashCode",
    toString$0: function(_) {
      return "Element in container " + J.toString$0(this.type);
    },
    accept$1: function(_, visitor) {
      return visitor.visitElementInContainerTypeInformation$1(this);
    }
  },
  MapTypeInformation: {
    "^": "TypeInformation;typeInfoMap<,keyType<,valueType<,initialType,flowsInto<,bailedOut<,analyzed,_allKeysAreStrings<,users,assignments,type,abandonInferencing,refineCount,inQueue,isStable,hashCode",
    addEntryAssignment$3: function(key, value, nonNull) {
      var t1, t2, t3, keyString;
      t1 = {};
      t1.newInfo_0 = null;
      t2 = this._allKeysAreStrings && !!J.getInterceptor(key).$isStringLiteralTypeInformation;
      t3 = this.typeInfoMap;
      if (t2) {
        keyString = J.get$value$x(key).slowToString$0();
        t3.putIfAbsent$2(keyString, new G.MapTypeInformation_addEntryAssignment_closure(t1, nonNull));
        t3.$index(0, keyString).addAssignment$1(value);
      } else {
        this._allKeysAreStrings = false;
        t3.clear$0(0);
      }
      this.keyType.addAssignment$1(key);
      this.valueType.addAssignment$1(value);
      t2 = t1.newInfo_0;
      if (t2 != null)
        J.add$1$ax(t2.users, this);
      return t1.newInfo_0;
    },
    addEntryAssignment$2: function(key, value) {
      return this.addEntryAssignment$3(key, value, false);
    },
    addMapAssignment$1: function(other) {
      var newInfos = H.setRuntimeTypeInfo([], [G.TypeInformation]);
      if (this._allKeysAreStrings && !other.get$bailedOut() && other.get$_allKeysAreStrings())
        other.get$typeInfoMap().forEach$1(0, new G.MapTypeInformation_addMapAssignment_closure(this, newInfos));
      else {
        this._allKeysAreStrings = false;
        this.typeInfoMap.clear$0(0);
      }
      this.keyType.addAssignment$1(other.get$keyType());
      this.valueType.addAssignment$1(other.valueType);
      return newInfos;
    },
    markAsInferred$0: function() {
      this.valueType.inferred = true;
      this.keyType.inferred = true;
      var t1 = this.typeInfoMap;
      t1.get$values(t1).forEach$1(0, new G.MapTypeInformation_markAsInferred_closure());
    },
    addAssignment$1: function(other) {
      throw H.wrapException("not supported");
    },
    accept$1: function(_, visitor) {
      return visitor.visitMapTypeInformation$1(this);
    },
    toTypeMask$1: function(inferrer) {
      var mappings, t1, t2, key;
      if (!this.bailedOut && this._allKeysAreStrings) {
        mappings = P.LinkedHashMap_LinkedHashMap(null, null, null, P.String, B.TypeMask);
        for (t1 = this.typeInfoMap, t2 = t1.get$keys(), t2 = t2.get$iterator(t2); t2.moveNext$0();) {
          key = t2.get$current();
          mappings.$indexSet(0, key, J.get$type$x(t1.$index(0, key)));
        }
        t1 = this.initialType;
        t2 = this.keyType.type;
        return new B.DictionaryTypeMask(mappings, t1.forwardTo, t1.allocationNode, t1.allocationElement, this.valueType.type, t2);
      } else {
        t1 = this.initialType;
        t2 = this.keyType.type;
        return new B.MapTypeMask(t1.forwardTo, t1.allocationNode, t1.allocationElement, this.valueType.type, t2);
      }
    },
    refine$1: function(inferrer) {
      var t1, mask, t2, t3, key, value, t4;
      t1 = this.type.get$isDictionary();
      if (t1 !== (!this.bailedOut && this._allKeysAreStrings))
        return this.toTypeMask$1(inferrer);
      else if (this.type.get$isDictionary()) {
        mask = this.type;
        for (t1 = this.typeInfoMap, t2 = t1.get$keys(), t2 = t2.get$iterator(t2), t3 = inferrer.compiler; t2.moveNext$0();) {
          key = t2.get$current();
          value = t1.$index(0, key);
          if (!mask.get$typeMap().containsKey$1(key)) {
            t4 = J.getInterceptor$x(value);
            t4 = !t4.get$type(value).containsAll$1(t3) && !t4.get$type(value).get$isNullable();
          } else
            t4 = false;
          if (t4)
            return this.toTypeMask$1(inferrer);
          if (!J.$eq(mask.typeMap.$index(0, key), J.get$type$x(t1.$index(0, key))))
            return this.toTypeMask$1(inferrer);
        }
      } else {
        t1 = this.type;
        if (t1.get$isMap(t1)) {
          mask = this.type;
          if (!J.$eq(mask.get$keyType(), this.keyType.type) || !J.$eq(mask.valueType, this.valueType.type))
            return this.toTypeMask$1(inferrer);
        } else
          return this.toTypeMask$1(inferrer);
      }
      return this.type;
    },
    hasStableType$1: function(inferrer) {
      return this.keyType.isStable && this.valueType.isStable && G.TypeInformation.prototype.hasStableType$1.call(this, inferrer);
    },
    toString$0: function(_) {
      return "Map " + J.toString$0(this.type) + " (K:" + ("Key in Map " + J.toString$0(this.keyType.type)) + ", V:" + ("Value in Map " + J.toString$0(this.valueType.type)) + ") contents " + this.typeInfoMap.toString$0(0);
    },
    $isMapTypeInformation: true
  },
  MapTypeInformation_addEntryAssignment_closure: {
    "^": "Closure:23;box_0,nonNull_1",
    call$0: function() {
      var t1, t2, t3, newInfo;
      t1 = $.TypeInformation_staticHashCode;
      $.TypeInformation_staticHashCode = t1 + 1;
      t2 = H.setRuntimeTypeInfo(new N.Setlet(C.C__SetletMarker, null), [G.TypeInformation]);
      t3 = H.setRuntimeTypeInfo([], [G.TypeInformation]);
      newInfo = new G.ValueInMapTypeInformation(this.nonNull_1, false, t2, t3, C.FlatTypeMask_null_0, false, 0, false, false, t1);
      this.box_0.newInfo_0 = newInfo;
      return newInfo;
    },
    $isFunction: true
  },
  MapTypeInformation_addMapAssignment_closure: {
    "^": "Closure:19;this_0,newInfos_1",
    call$2: function(keyString, value) {
      var t1 = this.this_0.typeInfoMap;
      t1.putIfAbsent$2(keyString, new G.MapTypeInformation_addMapAssignment__closure(this.newInfos_1));
      t1.$index(0, keyString).addAssignment$1(value);
    },
    $isFunction: true
  },
  MapTypeInformation_addMapAssignment__closure: {
    "^": "Closure:23;newInfos_2",
    call$0: function() {
      var t1, t2, t3, newInfo;
      t1 = $.TypeInformation_staticHashCode;
      $.TypeInformation_staticHashCode = t1 + 1;
      t2 = H.setRuntimeTypeInfo(new N.Setlet(C.C__SetletMarker, null), [G.TypeInformation]);
      t3 = H.setRuntimeTypeInfo([], [G.TypeInformation]);
      newInfo = new G.ValueInMapTypeInformation(false, false, t2, t3, C.FlatTypeMask_null_0, false, 0, false, false, t1);
      this.newInfos_2.push(newInfo);
      return newInfo;
    },
    $isFunction: true
  },
  MapTypeInformation_markAsInferred_closure: {
    "^": "Closure:13;",
    call$1: function(v) {
      v.set$inferred(true);
      return true;
    },
    $isFunction: true
  },
  KeyInMapTypeInformation: {
    "^": "InferredTypeInformation;inferred,users,assignments,type,abandonInferencing,refineCount,inQueue,isStable,hashCode",
    accept$1: function(_, visitor) {
      return visitor.visitKeyInMapTypeInformation$1(this);
    },
    refine$1: function(inferrer) {
      return G.InferredTypeInformation.prototype.refine$1.call(this, inferrer);
    },
    toString$0: function(_) {
      return "Key in Map " + J.toString$0(this.type);
    }
  },
  ValueInMapTypeInformation: {
    "^": "InferredTypeInformation;nonNull,inferred,users,assignments,type,abandonInferencing,refineCount,inQueue,isStable,hashCode",
    accept$1: function(_, visitor) {
      return visitor.visitValueInMapTypeInformation$1(this);
    },
    refine$1: function(inferrer) {
      return this.nonNull ? G.InferredTypeInformation.prototype.refine$1.call(this, inferrer) : G.InferredTypeInformation.prototype.refine$1.call(this, inferrer).nullable$0();
    },
    toString$0: function(_) {
      return "Value in Map " + J.toString$0(this.type);
    }
  },
  PhiElementTypeInformation: {
    "^": "TypeInformation;branchNode,isLoopPhi,variable<,users,assignments,type,abandonInferencing,refineCount,inQueue,isStable,hashCode",
    refine$1: function(inferrer) {
      return inferrer.types.computeTypeMask$1(this.assignments);
    },
    toString$0: function(_) {
      return "Phi " + J.toString$0(this.variable) + " " + J.toString$0(this.type);
    },
    accept$1: function(_, visitor) {
      return visitor.visitPhiElementTypeInformation$1(this);
    },
    $isPhiElementTypeInformation: true
  },
  ClosureTypeInformation: {
    "^": "ApplyableTypeInformation;node<,element<,mightBePassedToFunctionApply,users,assignments,type,abandonInferencing,refineCount,inQueue,isStable,hashCode",
    refine$1: function(inferrer) {
      return inferrer.types.get$functionType().type;
    },
    toString$0: function(_) {
      return "Closure " + J.toString$0(this.element);
    },
    accept$1: function(_, visitor) {
      return visitor.visitClosureTypeInformation$1(this);
    },
    hasStableType$1: function(inferrer) {
      return false;
    },
    $isClosureTypeInformation: true
  }
}],
["types", "package:compiler/implementation/types/types.dart", , B, {
  "^": "",
  ContainerTypeMask: {
    "^": "ForwardingTypeMask;forwardTo<,allocationNode<,allocationElement,elementType<,length>",
    nullable$0: function() {
      var t1 = this.forwardTo;
      return t1.get$isNullable() ? this : new B.ContainerTypeMask(t1.nullable$0(), this.allocationNode, this.allocationElement, this.elementType, this.length);
    },
    nonNullable$0: function() {
      var t1 = this.forwardTo;
      return t1.get$isNullable() ? new B.ContainerTypeMask(t1.nonNullable$0(), this.allocationNode, this.allocationElement, this.elementType, this.length) : this;
    },
    get$isContainer: function() {
      return true;
    },
    get$isExact: function() {
      return true;
    },
    equalsDisregardNull$1: function(other) {
      var t1, t2;
      if (!J.getInterceptor(other).$isContainerTypeMask)
        return false;
      if (B.ForwardingTypeMask.prototype.equalsDisregardNull$1.call(this, other)) {
        t1 = this.allocationNode;
        t2 = other.allocationNode;
        if (t1 == null ? t2 == null : t1 === t2)
          if (J.$eq(this.elementType, other.elementType)) {
            t1 = this.length;
            t2 = other.length;
            t2 = t1 == null ? t2 == null : t1 === t2;
            t1 = t2;
          } else
            t1 = false;
        else
          t1 = false;
      } else
        t1 = false;
      return t1;
    },
    intersection$2: function(_, other, compiler) {
      var forwardIntersection = this.forwardTo.intersection$2(0, other, compiler);
      if (forwardIntersection.get$isEmpty(forwardIntersection))
        return forwardIntersection;
      return forwardIntersection.get$isNullable() ? this.nullable$0() : this.nonNullable$0();
    },
    union$2: function(other, compiler) {
      var newElementType, newLength, t1, newForwardTo, t2, t3;
      if (this.$eq(0, other))
        return this;
      else if (this.equalsDisregardNull$1(other))
        return other.get$isNullable() ? other : this;
      else if (J.get$isEmpty$asx(other) === true)
        return other.get$isNullable() ? this.nullable$0() : this;
      else if (other.get$isContainer() && this.elementType != null && other.get$elementType() != null) {
        newElementType = this.elementType.union$2(other.get$elementType(), compiler);
        newLength = this.length;
        t1 = other.length;
        newLength = (newLength == null ? t1 == null : newLength === t1) ? newLength : null;
        newForwardTo = this.forwardTo.union$2(other.forwardTo, compiler);
        t1 = this.allocationNode;
        t2 = other.allocationNode;
        t1 = (t1 == null ? t2 == null : t1 === t2) ? t1 : null;
        t2 = this.allocationElement;
        t3 = other.allocationElement;
        t2 = (t2 == null ? t3 == null : t2 === t3) ? t2 : null;
        return new B.ContainerTypeMask(newForwardTo, t1, t2, newElementType, newLength);
      } else
        return this.forwardTo.union$2(other, compiler);
    },
    $eq: function(_, other) {
      if (other == null)
        return false;
      return B.ForwardingTypeMask.prototype.$eq.call(this, this, other);
    },
    get$hashCode: function(_) {
      var t1 = this.forwardTo;
      return O.computeHashCode(this.allocationNode, t1.get$isNullable(), this.elementType, this.length, t1);
    },
    toString$0: function(_) {
      return "Container mask: " + J.toString$0(this.elementType) + " length: " + H.S(this.length) + " type: " + J.toString$0(this.forwardTo);
    },
    $isContainerTypeMask: true
  },
  DictionaryTypeMask: {
    "^": "MapTypeMask;typeMap<,forwardTo,allocationNode,allocationElement,valueType,keyType",
    nullable$0: function() {
      var t1 = this.forwardTo;
      return t1.get$isNullable() ? this : new B.DictionaryTypeMask(this.typeMap, t1.nullable$0(), this.allocationNode, this.allocationElement, this.valueType, this.keyType);
    },
    nonNullable$0: function() {
      var t1 = this.forwardTo;
      return t1.get$isNullable() ? new B.DictionaryTypeMask(this.typeMap, t1.nonNullable$0(), this.allocationNode, this.allocationElement, this.valueType, this.keyType) : this;
    },
    get$isDictionary: function() {
      return true;
    },
    get$isExact: function() {
      return true;
    },
    equalsDisregardNull$1: function(other) {
      var t1, t2;
      if (!J.getInterceptor(other).$isDictionaryTypeMask)
        return false;
      t1 = this.allocationNode;
      t2 = other.allocationNode;
      return (t1 == null ? t2 == null : t1 === t2) && J.$eq(this.keyType, other.keyType) && J.$eq(this.valueType, other.valueType) && this.typeMap.get$keys().every$1(0, new B.DictionaryTypeMask_equalsDisregardNull_closure(other)) && other.typeMap.get$keys().every$1(0, new B.DictionaryTypeMask_equalsDisregardNull_closure0(this, other));
    },
    intersection$2: function(_, other, compiler) {
      var forwardIntersection = this.forwardTo.intersection$2(0, other, compiler);
      if (forwardIntersection.get$isEmpty(forwardIntersection))
        return forwardIntersection;
      return forwardIntersection.get$isNullable() ? this.nullable$0() : this.nonNullable$0();
    },
    union$2: function(other, compiler) {
      var t1, newForwardTo, newKeyType, newValueType, mappings, t2;
      if (this.$eq(0, other))
        return this;
      else if (this.equalsDisregardNull$1(other))
        return other.get$isNullable() ? other : this;
      else {
        t1 = J.getInterceptor$asx(other);
        if (t1.get$isEmpty(other) === true)
          return other.get$isNullable() ? this.nullable$0() : this;
        else if (other.get$isDictionary()) {
          newForwardTo = this.forwardTo.union$2(other.get$forwardTo(), compiler);
          newKeyType = this.keyType.union$2(other.get$keyType(), compiler);
          newValueType = this.valueType.union$2(other.valueType, compiler);
          mappings = P.LinkedHashMap_LinkedHashMap$_empty(P.String, B.TypeMask);
          this.typeMap.forEach$1(0, new B.DictionaryTypeMask_union_closure(other, mappings));
          other.get$typeMap().forEach$1(0, new B.DictionaryTypeMask_union_closure0(this, compiler, mappings));
          return new B.DictionaryTypeMask(mappings, newForwardTo, null, null, newValueType, newKeyType);
        } else {
          t1 = t1.get$isMap(other) && other.get$keyType() != null && other.valueType != null;
          t2 = this.forwardTo;
          if (t1) {
            newForwardTo = t2.union$2(other.get$forwardTo(), compiler);
            newKeyType = this.keyType.union$2(other.get$keyType(), compiler);
            return new B.MapTypeMask(newForwardTo, null, null, this.valueType.union$2(other.valueType, compiler), newKeyType);
          } else
            return t2.union$2(other, compiler);
        }
      }
    },
    $eq: function(_, other) {
      if (other == null)
        return false;
      return B.MapTypeMask.prototype.$eq.call(this, this, other);
    },
    get$hashCode: function(_) {
      var t1 = this.forwardTo;
      return O.computeHashCode(this.allocationNode, t1.get$isNullable(), this.typeMap, t1, null);
    },
    toString$0: function(_) {
      return "Dictionary mask: [" + J.toString$0(this.keyType) + "/" + J.toString$0(this.valueType) + " with " + this.typeMap.toString$0(0) + "] type: " + J.toString$0(this.forwardTo);
    },
    $isDictionaryTypeMask: true
  },
  DictionaryTypeMask_equalsDisregardNull_closure: {
    "^": "Closure:13;other_0",
    call$1: function(k) {
      return this.other_0.typeMap.containsKey$1(k);
    },
    $isFunction: true
  },
  DictionaryTypeMask_equalsDisregardNull_closure0: {
    "^": "Closure:13;this_1,other_2",
    call$1: function(k) {
      var t1 = this.this_1.typeMap;
      return t1.containsKey$1(k) && J.$eq(t1.$index(0, k), this.other_2.typeMap.$index(0, k));
    },
    $isFunction: true
  },
  DictionaryTypeMask_union_closure: {
    "^": "Closure:19;other_0,mappings_1",
    call$2: function(k, v) {
      if (!this.other_0.get$typeMap().containsKey$1(k))
        this.mappings_1.$indexSet(0, k, v.nullable$0());
    },
    $isFunction: true
  },
  DictionaryTypeMask_union_closure0: {
    "^": "Closure:19;this_2,compiler_3,mappings_4",
    call$2: function(k, v) {
      var t1, t2;
      t1 = this.this_2.typeMap;
      t2 = this.mappings_4;
      if (t1.containsKey$1(k))
        t2.$indexSet(0, k, v.union$2(t1.$index(0, k), this.compiler_3));
      else
        t2.$indexSet(0, k, v.nullable$0());
    },
    $isFunction: true
  },
  FlatTypeMask: {
    "^": "Object;base<,flags<",
    get$isEmpty: function(_) {
      return this.flags >>> 1 === 0;
    },
    get$isExact: function() {
      return this.flags >>> 1 === 1;
    },
    get$isNullable: function() {
      return (this.flags & 1) !== 0;
    },
    get$isUnion: function() {
      return false;
    },
    get$isContainer: function() {
      return false;
    },
    get$isMap: function(_) {
      return false;
    },
    get$isDictionary: function() {
      return false;
    },
    get$isForwarding: function() {
      return false;
    },
    get$isValue: function() {
      return false;
    },
    get$isSubtype: function() {
      return this.flags >>> 1 === 3;
    },
    nullable$0: function() {
      var t1 = this.flags;
      return (t1 & 1) !== 0 ? this : new B.FlatTypeMask(this.base, (t1 | 1) >>> 0);
    },
    nonNullable$0: function() {
      var t1 = this.flags;
      return (t1 & 1) !== 0 ? new B.FlatTypeMask(this.base, (t1 & 4294967294) >>> 0) : this;
    },
    contains$2: function(_, type, compiler) {
      var t1, t2;
      t1 = this.flags >>> 1;
      if (t1 === 0)
        return false;
      else {
        t2 = this.base;
        if (t2 == null ? type == null : t2 === type)
          return true;
        else if (t1 === 1)
          return false;
        else if (t1 === 2)
          return B.FlatTypeMask_isSubclassOf(type, t2, compiler);
        else
          return B.FlatTypeMask_isSubtypeOf(type, t2, compiler);
      }
    },
    isSingleImplementationOf$2: function(cls, compiler) {
      var backend, t1;
      backend = compiler.backend;
      if (this.containsOnlyString$1(compiler)) {
        t1 = compiler.stringClass;
        if (cls == null ? t1 != null : cls !== t1) {
          t1 = backend.get$stringImplementation();
          t1 = cls == null ? t1 == null : cls === t1;
        } else
          t1 = true;
        return t1;
      }
      if (this.containsOnlyBool$1(compiler)) {
        t1 = compiler.boolClass;
        if (cls == null ? t1 != null : cls !== t1) {
          t1 = backend.get$boolImplementation();
          t1 = cls == null ? t1 == null : cls === t1;
        } else
          t1 = true;
        return t1;
      }
      if (this.containsOnlyInt$1(compiler)) {
        t1 = compiler.intClass;
        if (cls == null ? t1 != null : cls !== t1) {
          t1 = backend.get$intImplementation();
          if (cls == null ? t1 != null : cls !== t1) {
            t1 = backend.get$positiveIntImplementation();
            if (cls == null ? t1 != null : cls !== t1) {
              t1 = backend.get$uint32Implementation();
              if (cls == null ? t1 != null : cls !== t1) {
                t1 = backend.get$uint31Implementation();
                t1 = cls == null ? t1 == null : cls === t1;
              } else
                t1 = true;
            } else
              t1 = true;
          } else
            t1 = true;
        } else
          t1 = true;
        return t1;
      }
      if (this.containsOnlyDouble$1(compiler)) {
        t1 = compiler.doubleClass;
        if (cls == null ? t1 != null : cls !== t1) {
          t1 = compiler.backend.get$doubleImplementation();
          t1 = cls == null ? t1 == null : cls === t1;
        } else
          t1 = true;
        return t1;
      }
      return false;
    },
    isInMask$2: function(other, compiler) {
      var t1, t2, otherBase;
      t1 = this.flags;
      t2 = t1 >>> 1;
      if (t2 === 0)
        return (t1 & 1) === 0 || other.get$isNullable();
      if (other.get$isEmpty(other))
        return false;
      if ((t1 & 1) !== 0 && !other.get$isNullable())
        return false;
      if (!other.$isFlatTypeMask)
        return other.containsMask$2(this, compiler);
      otherBase = other.base;
      t1 = other.flags >>> 1;
      if (t1 === 1) {
        if (t2 === 1) {
          t1 = this.base;
          t1 = t1 == null ? otherBase == null : t1 === otherBase;
        } else
          t1 = false;
        return t1 || this.isSingleImplementationOf$2(otherBase, compiler);
      }
      if (t1 === 2) {
        if (t2 === 3)
          return false;
        t1 = this.base;
        return (t1 == null ? otherBase == null : t1 === otherBase) || B.FlatTypeMask_isSubclassOf(t1, otherBase, compiler) === true;
      }
      return this.satisfies$2(otherBase, compiler);
    },
    containsMask$2: function(other, compiler) {
      return other.isInMask$2(this, compiler);
    },
    containsOnlyInt$1: function(compiler) {
      var t1, t2;
      t1 = this.base;
      t2 = compiler.intClass;
      if (t1 == null ? t2 != null : t1 !== t2) {
        t2 = compiler.backend.get$intImplementation();
        if (t1 == null ? t2 != null : t1 !== t2) {
          t2 = compiler.backend.get$positiveIntImplementation();
          if (t1 == null ? t2 != null : t1 !== t2) {
            t2 = compiler.backend.get$uint31Implementation();
            if (t1 == null ? t2 != null : t1 !== t2) {
              t2 = compiler.backend.get$uint32Implementation();
              t2 = t1 == null ? t2 == null : t1 === t2;
              t1 = t2;
            } else
              t1 = true;
          } else
            t1 = true;
        } else
          t1 = true;
      } else
        t1 = true;
      return t1;
    },
    containsOnlyDouble$1: function(compiler) {
      var t1, t2;
      t1 = this.base;
      t2 = compiler.doubleClass;
      if (t1 == null ? t2 != null : t1 !== t2) {
        t2 = compiler.backend.get$doubleImplementation();
        t2 = t1 == null ? t2 == null : t1 === t2;
        t1 = t2;
      } else
        t1 = true;
      return t1;
    },
    containsOnlyNum$1: function(compiler) {
      var t1, t2;
      if (!this.containsOnlyInt$1(compiler))
        if (!this.containsOnlyDouble$1(compiler)) {
          t1 = this.base;
          t2 = compiler.numClass;
          if (t1 == null ? t2 != null : t1 !== t2) {
            t2 = compiler.backend.get$numImplementation();
            t2 = t1 == null ? t2 == null : t1 === t2;
            t1 = t2;
          } else
            t1 = true;
        } else
          t1 = true;
      else
        t1 = true;
      return t1;
    },
    containsOnlyBool$1: function(compiler) {
      var t1, t2;
      t1 = this.base;
      t2 = compiler.boolClass;
      if (t1 == null ? t2 != null : t1 !== t2) {
        t2 = compiler.backend.get$boolImplementation();
        t2 = t1 == null ? t2 == null : t1 === t2;
        t1 = t2;
      } else
        t1 = true;
      return t1;
    },
    containsOnlyString$1: function(compiler) {
      var t1, t2;
      t1 = this.base;
      t2 = compiler.stringClass;
      if (t1 == null ? t2 != null : t1 !== t2) {
        t2 = compiler.backend.get$stringImplementation();
        t2 = t1 == null ? t2 == null : t1 === t2;
        t1 = t2;
      } else
        t1 = true;
      return t1;
    },
    containsOnly$1: function(cls) {
      var t1 = this.base;
      return t1 == null ? cls == null : t1 === cls;
    },
    satisfies$2: function(cls, compiler) {
      var t1;
      if (this.flags >>> 1 === 0)
        return false;
      t1 = this.base;
      if (t1 == null ? cls == null : t1 === cls)
        return true;
      if (B.FlatTypeMask_isSubtypeOf(t1, cls, compiler))
        return true;
      return false;
    },
    singleClass$1: function(compiler) {
      var t1, t2;
      t1 = this.flags;
      t2 = t1 >>> 1;
      if (t2 === 0)
        return;
      if ((t1 & 1) !== 0)
        return;
      if (t2 === 1)
        return this.base;
      else if (t2 === 2) {
        t1 = this.base;
        return compiler.world.hasAnySubclass$1(t1) ? null : t1;
      } else
        return;
    },
    containsAll$1: function(compiler) {
      var t1, t2;
      t1 = this.flags >>> 1;
      if (t1 === 0 || t1 === 1)
        return false;
      t1 = this.base;
      t2 = compiler.objectClass;
      return t1 == null ? t2 == null : t1 === t2;
    },
    union$2: function(other, compiler) {
      var t1, t2;
      if (!J.getInterceptor(other).$isFlatTypeMask)
        return other.union$2(this, compiler);
      t1 = this.flags;
      if (t1 >>> 1 === 0)
        return (t1 & 1) !== 0 ? other.nullable$0() : other;
      else {
        t1 = other.flags;
        if (t1 >>> 1 === 0)
          return (t1 & 1) !== 0 ? this.nullable$0() : this;
        else {
          t1 = this.base;
          t2 = other.base;
          if (t1 == null ? t2 == null : t1 === t2)
            return this.unionSame$2(other, compiler);
          else if (B.FlatTypeMask_isSubclassOf(t2, t1, compiler) === true)
            return this.unionSubclass$2(other, compiler);
          else if (B.FlatTypeMask_isSubclassOf(t1, t2, compiler) === true)
            return other.unionSubclass$2(this, compiler);
          else if (B.FlatTypeMask_isSubtypeOf(t2, t1, compiler))
            return this.unionSubtype$2(other, compiler);
          else if (B.FlatTypeMask_isSubtypeOf(t1, t2, compiler))
            return other.unionSubtype$2(this, compiler);
          else
            return new B.UnionTypeMask(H.setRuntimeTypeInfo([this, other], [B.FlatTypeMask]));
        }
      }
    },
    unionSame$2: function(other, compiler) {
      var t1, t2, combined;
      t1 = this.flags;
      t2 = other.flags;
      combined = t1 > t2 ? (t1 | t2 & 1) >>> 0 : (t2 | t1 & 1) >>> 0;
      if (t1 === combined)
        return this;
      else if (t2 === combined)
        return other;
      else
        return new B.FlatTypeMask(this.base, combined);
    },
    unionSubclass$2: function(other, compiler) {
      var t1, t2, t3, combined;
      t1 = this.flags;
      if (!(t1 >>> 1 === 1 && other.flags >>> 1 === 1)) {
        t2 = this.base;
        t3 = compiler.objectClass;
        t3 = t2 == null ? t3 == null : t2 === t3;
        t2 = t3;
      } else
        t2 = true;
      if (t2)
        combined = 4 | (t1 | other.flags) & 1;
      else {
        t2 = other.flags;
        combined = t1 > t2 ? (t1 | t2 & 1) >>> 0 : (t2 | t1 & 1) >>> 0;
      }
      return t1 !== combined ? new B.FlatTypeMask(this.base, combined) : this;
    },
    unionSubtype$2: function(other, compiler) {
      var t1, combined;
      t1 = this.flags;
      combined = 6 | (t1 | other.flags) & 1;
      return t1 !== combined ? new B.FlatTypeMask(this.base, combined) : this;
    },
    intersection$2: function(_, other, compiler) {
      var t1, t2;
      t1 = J.getInterceptor(other);
      if (!t1.$isFlatTypeMask)
        return t1.intersection$2(other, this, compiler);
      t1 = this.flags;
      if (t1 >>> 1 === 0)
        return (other.flags & 1) !== 0 ? this : this.nonNullable$0();
      else if (other.flags >>> 1 === 0)
        return (t1 & 1) !== 0 ? other : other.nonNullable$0();
      else {
        t1 = this.base;
        t2 = other.base;
        if (t1 == null ? t2 == null : t1 === t2)
          return this.intersectionSame$2(other, compiler);
        else if (B.FlatTypeMask_isSubclassOf(t2, t1, compiler) === true)
          return this.intersectionSubclass$2(other, compiler);
        else if (B.FlatTypeMask_isSubclassOf(t1, t2, compiler) === true)
          return other.intersectionSubclass$2(this, compiler);
        else if (B.FlatTypeMask_isSubtypeOf(t2, t1, compiler))
          return this.intersectionSubtype$2(other, compiler);
        else if (B.FlatTypeMask_isSubtypeOf(t1, t2, compiler))
          return other.intersectionSubtype$2(this, compiler);
        else
          return this.intersectionHelper$2(other, compiler);
      }
    },
    intersectionSame$2: function(other, compiler) {
      var t1, t2, combined;
      t1 = this.flags;
      t2 = other.flags;
      combined = t1 < t2 ? (t1 & (t2 & 1 | 4294967294)) >>> 0 : (t2 & (t1 & 1 | 4294967294)) >>> 0;
      if (t1 === combined)
        return this;
      else if (t2 === combined)
        return other;
      else
        return new B.FlatTypeMask(this.base, combined);
    },
    intersectionSubclass$2: function(other, compiler) {
      var t1, t2, combined;
      t1 = this.flags;
      if (t1 >>> 1 === 1)
        return new B.FlatTypeMask(null, 0 | ((t1 & 1) !== 0 && (other.flags & 1) !== 0 ? 1 : 0));
      t2 = other.flags;
      combined = (t2 & (t1 & 1 | 4294967294)) >>> 0;
      if (t2 === combined)
        return other;
      else
        return new B.FlatTypeMask(other.base, combined);
    },
    intersectionSubtype$2: function(other, compiler) {
      var t1, t2, combined;
      t1 = this.flags;
      if (t1 >>> 1 !== 3)
        return this.intersectionHelper$2(other, compiler);
      t2 = other.flags;
      combined = (t2 & (t1 & 1 | 4294967294)) >>> 0;
      if (t2 === combined)
        return other;
      else
        return new B.FlatTypeMask(other.base, combined);
    },
    intersectionHelper$2: function(other, compiler) {
      var t1, t2, kind, common, candidates, combined, result, mask;
      t1 = this.flags;
      t2 = t1 >>> 1;
      if (t2 === 1 || other.flags >>> 1 === 1)
        return new B.FlatTypeMask(null, 0 | ((t1 & 1) !== 0 && (other.flags & 1) !== 0 ? 1 : 0));
      t2 = t2 === 2;
      if (t2 && other.flags >>> 1 === 2)
        return new B.FlatTypeMask(null, 0 | ((t1 & 1) !== 0 && (other.flags & 1) !== 0 ? 1 : 0));
      kind = t2 || other.flags >>> 1 === 2 ? 2 : 3;
      common = B.FlatTypeMask_commonContainedClasses(this, other, compiler);
      if (common == null || common._collection$_length === 0)
        return new B.FlatTypeMask(null, 0 | ((t1 & 1) !== 0 && (other.flags & 1) !== 0 ? 1 : 0));
      common.toString;
      candidates = H.setRuntimeTypeInfo(new H.WhereIterable(common, new B.FlatTypeMask_intersectionHelper_closure(kind, common)), [H.getTypeArgumentByIndex(common, 0)]);
      combined = (kind << 1 | t1 & other.flags & 1) >>> 0;
      for (t1 = H.setRuntimeTypeInfo(new H.WhereIterator(J.get$iterator$ax(candidates._iterable), candidates._f), [H.getTypeArgumentByIndex(candidates, 0)]), t2 = t1._iterator, result = null; t1.moveNext$0();) {
        mask = new B.FlatTypeMask(t2.get$current(), combined);
        result = result == null ? mask : result.union$2(mask, compiler);
      }
      return result;
    },
    canHit$3: function(element, selector, compiler) {
      var t1, t2, $self, other, mixinUses;
      t1 = this.flags;
      t2 = t1 >>> 1;
      if (t2 === 0) {
        if ((t1 & 1) === 0)
          return false;
        return B.FlatTypeMask_hasElementIn(compiler.backend.get$nullImplementation(), selector, element, compiler);
      }
      $self = this.base;
      if ($self.get$kind($self) === C.ElementKind_typedef_32)
        return false;
      other = element.get$enclosingClass();
      if (compiler.backend.isNullImplementation$1(other))
        return (t1 & 1) !== 0;
      else if (t2 === 1)
        return B.FlatTypeMask_hasElementIn($self, selector, element, compiler);
      else if (t2 === 2)
        return B.FlatTypeMask_hasElementIn($self, selector, element, compiler) || other.isSubclassOf$1($self) || compiler.world.hasAnySubclassThatMixes$2($self, other);
      else {
        if (B.FlatTypeMask_hasElementIn($self, selector, element, compiler) || other.implementsInterface$1($self) || compiler.world.hasAnySubclassThatImplements$2(other, $self) === true || compiler.world.hasAnySubclassOfMixinUseThatImplements$2(other, $self))
          return true;
        mixinUses = compiler.world.mixinUses.$index(0, $self);
        if (mixinUses == null)
          return false;
        return J.any$1$ax(mixinUses, new B.FlatTypeMask_canHit_closure(element, selector, compiler, other));
      }
    },
    needsNoSuchMethodHandling$2: function(selector, compiler) {
      var t1, t2, t3, hasMatch, subtypesToCheck;
      t1 = this.flags >>> 1;
      if (t1 === 0)
        return false;
      t2 = t1 === 1;
      if (t2 && this.base.get$isAbstract())
        return false;
      t3 = this.base;
      hasMatch = B.FlatTypeMask_hasConcreteMatch(t3, selector, compiler);
      if (t2)
        return !hasMatch;
      if (!t3.get$isAbstract() && !hasMatch)
        return true;
      t2 = compiler.world;
      subtypesToCheck = t1 === 3 ? t2._subtypes.$index(0, t3.get$declaration()) : t2._subclasses.$index(0, t3.get$declaration());
      return subtypesToCheck != null && J.any$1$ax(subtypesToCheck, new B.FlatTypeMask_needsNoSuchMethodHandling_closure(selector, compiler));
    },
    locateSingleElement$2: function(selector, compiler) {
      var targets, t1, result;
      if (this.flags >>> 1 === 0)
        return;
      targets = compiler.world.allFunctions.query$1(0, selector).functions;
      t1 = J.getInterceptor$asx(targets);
      if (t1.get$length(targets) !== 1)
        return;
      result = t1.get$first(targets);
      return this.base.isSubclassOf$1(result.get$enclosingClass()) ? result : null;
    },
    $eq: function(_, other) {
      var t1, t2;
      if (other == null)
        return false;
      if (!J.getInterceptor(other).$isFlatTypeMask)
        return false;
      if (this.flags === other.flags) {
        t1 = this.base;
        t2 = other.base;
        t2 = t1 == null ? t2 == null : t1 === t2;
        t1 = t2;
      } else
        t1 = false;
      return t1;
    },
    get$hashCode: function(_) {
      var t1 = this.base;
      t1 = t1 == null ? 0 : J.get$hashCode$(t1);
      if (typeof t1 !== "number")
        return t1.$add();
      return t1 + 31 * (this.flags & 0x1FFFFFFF);
    },
    toString$0: function(_) {
      var t1, t2, buffer;
      t1 = this.flags;
      t2 = t1 >>> 1;
      if (t2 === 0)
        return (t1 & 1) !== 0 ? "[null]" : "[empty]";
      buffer = P.StringBuffer$("");
      if ((t1 & 1) !== 0)
        buffer.write$1("null|");
      if (t2 === 1)
        buffer.write$1("exact=");
      if (t2 === 2)
        buffer.write$1("subclass=");
      if (t2 === 3)
        buffer.write$1("subtype=");
      t1 = this.base;
      buffer.write$1(t1.get$name(t1));
      return "[" + buffer._contents + "]";
    },
    $isFlatTypeMask: true,
    static: {"^": "FlatTypeMask_EMPTY,FlatTypeMask_EXACT,FlatTypeMask_SUBCLASS,FlatTypeMask_SUBTYPE", FlatTypeMask_hasElementIn: function(cls, selector, element, compiler) {
        var result, t1, t2;
        result = J.get$implementation$x(cls).lookupSelector$2(selector, compiler);
        if (result == null)
          t1 = false;
        else {
          t1 = result.get$implementation(result);
          t2 = element.get$implementation(element);
          t2 = t1 == null ? t2 == null : t1 === t2;
          t1 = t2;
        }
        return t1;
      }, FlatTypeMask_hasConcreteMatch: function(cls, selector, compiler) {
        var element = cls.get$implementation(cls).lookupSelector$2(selector, compiler);
        if (element == null)
          return false;
        if (element.get$isAbstract())
          return B.FlatTypeMask_hasConcreteMatch(element.get$enclosingClass().get$superclass(), selector, compiler);
        return selector.appliesUntyped$2(element, compiler);
      }, FlatTypeMask_isSubclassOf: function(x, y, compiler) {
        var subclasses = compiler.world._subclasses.$index(0, y.get$declaration());
        return subclasses != null && J.contains$1$asx(subclasses, x);
      }, FlatTypeMask_isSubtypeOf: function(x, y, compiler) {
        var subtypes = compiler.world._subtypes.$index(0, y.get$declaration());
        if (subtypes != null && J.contains$1$asx(subtypes, x) === true)
          return true;
        if (y !== compiler.functionClass)
          return false;
        return x.get$callType() != null;
      }, FlatTypeMask_commonContainedClasses: function(x, y, compiler) {
        var t1, xSubset, ySubset, t2, t3, smallSet, result;
        t1 = {};
        xSubset = B.FlatTypeMask_containedSubset(x, compiler);
        if (xSubset == null)
          return;
        ySubset = B.FlatTypeMask_containedSubset(y, compiler);
        if (ySubset == null)
          return;
        t1.largeSet_0 = null;
        t2 = xSubset.get$length(xSubset);
        t3 = ySubset.get$length(ySubset);
        if (typeof t2 !== "number")
          return t2.$le();
        if (typeof t3 !== "number")
          return H.iae(t3);
        if (t2 <= t3) {
          t1.largeSet_0 = ySubset;
          smallSet = xSubset;
        } else {
          t1.largeSet_0 = xSubset;
          smallSet = ySubset;
        }
        result = smallSet.where$1(0, new B.FlatTypeMask_commonContainedClasses_closure(t1));
        t1 = P.LinkedHashSet_LinkedHashSet(null, null, null, H.getRuntimeTypeArgument(result, "IterableBase", 0));
        t1.addAll$1(0, result);
        return t1;
      }, FlatTypeMask_containedSubset: function(x, compiler) {
        var element, t1, t2;
        element = x.base;
        t1 = x.flags >>> 1;
        if (t1 === 1)
          return;
        else {
          t2 = compiler.world;
          if (t1 === 2)
            return t2._subclasses.$index(0, element.get$declaration());
          else
            return t2._subtypes.$index(0, element.get$declaration());
        }
      }}
  },
  FlatTypeMask_intersectionHelper_closure: {
    "^": "Closure:87;kind_0,common_1",
    call$1: function(each) {
      var t1, t2, link;
      t1 = this.common_1;
      t2 = !t1.contains$1(0, each.get$supertype().get$element());
      if (!t2 || this.kind_0 === 2)
        return t2;
      for (link = each.interfaces; !link.get$isEmpty(link); link = link.get$tail())
        if (t1.contains$1(0, link.get$head(link).get$element()))
          return false;
      return true;
    },
    $isFunction: true
  },
  FlatTypeMask_canHit_closure: {
    "^": "Closure:13;element_0,selector_1,compiler_2,other_3",
    call$1: function(mixinApplication) {
      var t1, t2;
      t1 = this.compiler_2;
      if (!B.FlatTypeMask_hasElementIn(mixinApplication, this.selector_1, this.element_0, t1)) {
        t2 = this.other_3;
        t1 = t2.isSubclassOf$1(mixinApplication) || t1.world.hasAnySubclassThatMixes$2(mixinApplication, t2);
      } else
        t1 = true;
      return t1;
    },
    $isFunction: true
  },
  FlatTypeMask_needsNoSuchMethodHandling_closure: {
    "^": "Closure:87;selector_0,compiler_1",
    call$1: function(cls) {
      return !cls.get$isAbstract() && !B.FlatTypeMask_hasConcreteMatch(cls, this.selector_0, this.compiler_1);
    },
    $isFunction: true
  },
  FlatTypeMask_commonContainedClasses_closure: {
    "^": "Closure:87;box_0",
    call$1: function(each) {
      return this.box_0.largeSet_0.contains$1(0, each);
    },
    $isFunction: true
  },
  ForwardingTypeMask: {
    "^": "Object;",
    get$isEmpty: function(_) {
      var t1 = this.get$forwardTo();
      return t1.get$isEmpty(t1);
    },
    get$isNullable: function() {
      return this.get$forwardTo().get$isNullable();
    },
    get$isExact: function() {
      return this.get$forwardTo().get$isExact();
    },
    get$isUnion: function() {
      return false;
    },
    get$isContainer: function() {
      return false;
    },
    get$isMap: function(_) {
      return false;
    },
    get$isDictionary: function() {
      return false;
    },
    get$isValue: function() {
      return false;
    },
    get$isForwarding: function() {
      return true;
    },
    isInMask$2: function(other, compiler) {
      return this.get$forwardTo().isInMask$2(other, compiler);
    },
    containsMask$2: function(other, compiler) {
      return this.get$forwardTo().containsMask$2(other, compiler);
    },
    containsOnlyInt$1: function(compiler) {
      return this.get$forwardTo().containsOnlyInt$1(compiler);
    },
    containsOnlyDouble$1: function(compiler) {
      return this.get$forwardTo().containsOnlyDouble$1(compiler);
    },
    containsOnlyNum$1: function(compiler) {
      return this.get$forwardTo().containsOnlyNum$1(compiler);
    },
    containsOnlyBool$1: function(compiler) {
      return this.get$forwardTo().containsOnlyBool$1(compiler);
    },
    containsOnlyString$1: function(compiler) {
      return this.get$forwardTo().containsOnlyString$1(compiler);
    },
    containsOnly$1: function(element) {
      return this.get$forwardTo().containsOnly$1(element);
    },
    satisfies$2: function(cls, compiler) {
      return this.get$forwardTo().satisfies$2(cls, compiler);
    },
    contains$2: function(_, type, compiler) {
      return this.get$forwardTo().contains$2(0, type, compiler);
    },
    containsAll$1: function(compiler) {
      return this.get$forwardTo().containsAll$1(compiler);
    },
    singleClass$1: function(compiler) {
      return this.get$forwardTo().singleClass$1(compiler);
    },
    union$2: function(other, compiler) {
      if (this.$eq(0, other))
        return this;
      else if (this.equalsDisregardNull$1(other))
        return other.get$isNullable() ? other : this;
      else if (J.get$isEmpty$asx(other) === true)
        return other.get$isNullable() ? this.nullable$0() : this;
      return this.get$forwardTo().union$2(other, compiler);
    },
    intersection$2: function(_, other, compiler) {
      return this.get$forwardTo().intersection$2(0, other, compiler);
    },
    needsNoSuchMethodHandling$2: function(selector, compiler) {
      return this.get$forwardTo().needsNoSuchMethodHandling$2(selector, compiler);
    },
    canHit$3: function(element, selector, compiler) {
      return this.get$forwardTo().canHit$3(element, selector, compiler);
    },
    locateSingleElement$2: function(selector, compiler) {
      return this.get$forwardTo().locateSingleElement$2(selector, compiler);
    },
    equalsDisregardNull$1: function(other) {
      if (!J.getInterceptor(other).$isForwardingTypeMask)
        return false;
      if (this.get$forwardTo().get$isNullable())
        return J.$eq(this.get$forwardTo(), other.get$forwardTo().nullable$0());
      else
        return J.$eq(this.get$forwardTo(), other.get$forwardTo().nonNullable$0());
    },
    $eq: function(_, other) {
      if (other == null)
        return false;
      return this.equalsDisregardNull$1(other) && this.get$forwardTo().get$isNullable() === other.get$isNullable();
    },
    get$hashCode: function(_) {
      return H.throwExpression("Subclass should implement hashCode getter");
    },
    $isForwardingTypeMask: true
  },
  MapTypeMask: {
    "^": "ForwardingTypeMask;forwardTo<,allocationNode<,allocationElement,valueType<,keyType<",
    nullable$0: function() {
      var t1 = this.forwardTo;
      return t1.get$isNullable() ? this : new B.MapTypeMask(t1.nullable$0(), this.allocationNode, this.allocationElement, this.valueType, this.keyType);
    },
    nonNullable$0: function() {
      var t1 = this.forwardTo;
      return t1.get$isNullable() ? new B.MapTypeMask(t1.nonNullable$0(), this.allocationNode, this.allocationElement, this.valueType, this.keyType) : this;
    },
    get$isContainer: function() {
      return false;
    },
    get$isMap: function(_) {
      return true;
    },
    get$isExact: function() {
      return true;
    },
    equalsDisregardNull$1: function(other) {
      var t1, t2;
      if (!J.getInterceptor(other).$isMapTypeMask)
        return false;
      if (B.ForwardingTypeMask.prototype.equalsDisregardNull$1.call(this, other)) {
        t1 = this.allocationNode;
        t2 = other.allocationNode;
        t1 = (t1 == null ? t2 == null : t1 === t2) && J.$eq(this.keyType, other.keyType) && J.$eq(this.valueType, other.valueType);
      } else
        t1 = false;
      return t1;
    },
    intersection$2: function(_, other, compiler) {
      var forwardIntersection = this.forwardTo.intersection$2(0, other, compiler);
      if (forwardIntersection.get$isEmpty(forwardIntersection))
        return forwardIntersection;
      return forwardIntersection.get$isNullable() ? this.nullable$0() : this.nonNullable$0();
    },
    union$2: function(other, compiler) {
      var t1, newKeyType, newValueType, t2, t3, newForwardTo;
      if (this.$eq(0, other))
        return this;
      else if (this.equalsDisregardNull$1(other))
        return other.get$isNullable() ? other : this;
      else {
        t1 = J.getInterceptor$asx(other);
        if (t1.get$isEmpty(other) === true)
          return other.get$isNullable() ? this.nullable$0() : this;
        else if (t1.get$isMap(other) === true && this.keyType != null && other.get$keyType() != null && this.valueType != null && other.get$valueType() != null) {
          newKeyType = this.keyType.union$2(other.get$keyType(), compiler);
          newValueType = this.valueType.union$2(other.get$valueType(), compiler);
          return new B.MapTypeMask(this.forwardTo.union$2(other.get$forwardTo(), compiler), null, null, newValueType, newKeyType);
        } else {
          t1 = this.forwardTo;
          if (other.get$isDictionary()) {
            t2 = this.keyType;
            newKeyType = t2.union$2(compiler.typesTask.get$stringType(), compiler);
            t3 = other.get$typeMap();
            newValueType = t3.get$values(t3).fold$2(0, t2, new B.MapTypeMask_union_closure(compiler));
            newForwardTo = t1.union$2(other.forwardTo, compiler);
            t1 = this.allocationNode;
            t2 = other.allocationNode;
            t1 = (t1 == null ? t2 == null : t1 === t2) ? t1 : null;
            t2 = this.allocationElement;
            t3 = other.allocationElement;
            t2 = (t2 == null ? t3 == null : t2 === t3) ? t2 : null;
            return new B.MapTypeMask(newForwardTo, t1, t2, newValueType, newKeyType);
          } else
            return t1.union$2(other, compiler);
        }
      }
    },
    $eq: function(_, other) {
      if (other == null)
        return false;
      return B.ForwardingTypeMask.prototype.$eq.call(this, this, other);
    },
    get$hashCode: function(_) {
      var t1 = this.forwardTo;
      return O.computeHashCode(this.allocationNode, t1.get$isNullable(), this.keyType, this.valueType, t1);
    },
    toString$0: function(_) {
      return "Map mask: [" + J.toString$0(this.keyType) + "/" + J.toString$0(this.valueType) + "] type: " + J.toString$0(this.forwardTo);
    },
    $isMapTypeMask: true
  },
  MapTypeMask_union_closure: {
    "^": "Closure:19;compiler_0",
    call$2: function(p, n) {
      return p.union$2(n, this.compiler_0);
    },
    $isFunction: true
  },
  TypeMask: {
    "^": "Object;"
  },
  TypesTask: {
    "^": "CompilerTask;name>,typesInferrer,concreteTypesInferrer,dynamicTypeCache,nonNullTypeCache,nullTypeCache,intTypeCache,uint32TypeCache,uint31TypeCache,positiveIntTypeCache,doubleTypeCache,numTypeCache,boolTypeCache,functionTypeCache,listTypeCache,constListTypeCache,fixedListTypeCache,growableListTypeCache,mapTypeCache,constMapTypeCache,stringTypeCache,typeTypeCache,compiler,watch,profilerTag",
    get$dynamicType: function() {
      var t1 = this.dynamicTypeCache;
      if (t1 == null) {
        t1 = new B.FlatTypeMask(this.compiler.objectClass, 5);
        this.dynamicTypeCache = t1;
      }
      return t1;
    },
    get$nonNullType: function() {
      var t1 = this.nonNullTypeCache;
      if (t1 == null) {
        t1 = new B.FlatTypeMask(this.compiler.objectClass, 4);
        this.nonNullTypeCache = t1;
      }
      return t1;
    },
    get$intType: function() {
      var t1 = this.intTypeCache;
      if (t1 == null) {
        t1 = new B.FlatTypeMask(this.compiler.backend.get$intImplementation(), 4);
        this.intTypeCache = t1;
      }
      return t1;
    },
    get$uint32Type: function() {
      var t1 = this.uint32TypeCache;
      if (t1 == null) {
        t1 = new B.FlatTypeMask(this.compiler.backend.get$uint32Implementation(), 4);
        this.uint32TypeCache = t1;
      }
      return t1;
    },
    get$uint31Type: function() {
      var t1 = this.uint31TypeCache;
      if (t1 == null) {
        t1 = new B.FlatTypeMask(this.compiler.backend.get$uint31Implementation(), 2);
        this.uint31TypeCache = t1;
      }
      return t1;
    },
    get$positiveIntType: function() {
      var t1 = this.positiveIntTypeCache;
      if (t1 == null) {
        t1 = new B.FlatTypeMask(this.compiler.backend.get$positiveIntImplementation(), 4);
        this.positiveIntTypeCache = t1;
      }
      return t1;
    },
    get$doubleType: function() {
      var t1 = this.doubleTypeCache;
      if (t1 == null) {
        t1 = new B.FlatTypeMask(this.compiler.backend.get$doubleImplementation(), 2);
        this.doubleTypeCache = t1;
      }
      return t1;
    },
    get$numType: function() {
      var t1 = this.numTypeCache;
      if (t1 == null) {
        t1 = new B.FlatTypeMask(this.compiler.backend.get$numImplementation(), 4);
        this.numTypeCache = t1;
      }
      return t1;
    },
    get$boolType: function() {
      var t1 = this.boolTypeCache;
      if (t1 == null) {
        t1 = new B.FlatTypeMask(this.compiler.backend.get$boolImplementation(), 2);
        this.boolTypeCache = t1;
      }
      return t1;
    },
    get$functionType: function() {
      var t1 = this.functionTypeCache;
      if (t1 == null) {
        t1 = new B.FlatTypeMask(this.compiler.backend.compiler.functionClass, 6);
        this.functionTypeCache = t1;
      }
      return t1;
    },
    get$constListType: function() {
      var t1 = this.constListTypeCache;
      if (t1 == null) {
        t1 = new B.FlatTypeMask(this.compiler.backend.get$constListImplementation(), 2);
        this.constListTypeCache = t1;
      }
      return t1;
    },
    get$fixedListType: function() {
      var t1 = this.fixedListTypeCache;
      if (t1 == null) {
        t1 = new B.FlatTypeMask(this.compiler.backend.get$fixedListImplementation(), 2);
        this.fixedListTypeCache = t1;
      }
      return t1;
    },
    get$growableListType: function() {
      var t1 = this.growableListTypeCache;
      if (t1 == null) {
        t1 = new B.FlatTypeMask(this.compiler.backend.get$growableListImplementation(), 2);
        this.growableListTypeCache = t1;
      }
      return t1;
    },
    get$mapType: function() {
      var t1 = this.mapTypeCache;
      if (t1 == null) {
        t1 = new B.FlatTypeMask(this.compiler.backend.get$mapImplementation(), 6);
        this.mapTypeCache = t1;
      }
      return t1;
    },
    get$constMapType: function() {
      var t1 = this.constMapTypeCache;
      if (t1 == null) {
        t1 = new B.FlatTypeMask(this.compiler.backend.get$constMapImplementation(), 6);
        this.constMapTypeCache = t1;
      }
      return t1;
    },
    get$stringType: function() {
      var t1 = this.stringTypeCache;
      if (t1 == null) {
        t1 = new B.FlatTypeMask(this.compiler.backend.get$stringImplementation(), 2);
        this.stringTypeCache = t1;
      }
      return t1;
    },
    get$typeType: function() {
      var t1 = this.typeTypeCache;
      if (t1 == null) {
        t1 = new B.FlatTypeMask(this.compiler.backend.get$typeImplementation(), 2);
        this.typeTypeCache = t1;
      }
      return t1;
    },
    get$nullType: function() {
      var t1 = this.nullTypeCache;
      if (t1 == null) {
        this.nullTypeCache = C.FlatTypeMask_null_1;
        t1 = C.FlatTypeMask_null_1;
      }
      return t1;
    },
    _intersection$2: function(type1, type2) {
      if (type1 == null)
        return type2;
      if (type2 == null)
        return type1;
      return type1.intersection$2(0, type2, this.compiler);
    },
    intersection$3: function(_, type1, type2, element) {
      var result = this._intersection$2(type1, type2);
      return result;
    },
    onResolutionComplete$1: function(mainElement) {
      this.measure$1(new B.TypesTask_onResolutionComplete_closure(this, mainElement));
      this.typesInferrer.inferrer.clear$0(0);
    },
    getGuaranteedTypeOfElement$1: function(element) {
      return this.measure$1(new B.TypesTask_getGuaranteedTypeOfElement_closure(this, element));
    },
    getGuaranteedReturnTypeOfElement$1: function(element) {
      return this.measure$1(new B.TypesTask_getGuaranteedReturnTypeOfElement_closure(this, element));
    },
    getGuaranteedTypeOfNode$2: function(owner, node) {
      return this.measure$1(new B.TypesTask_getGuaranteedTypeOfNode_closure(this, owner, node));
    },
    getGuaranteedTypeOfSelector$1: function(selector) {
      return this.measure$1(new B.TypesTask_getGuaranteedTypeOfSelector_closure(this, selector));
    },
    TypesTask$1: function(compiler) {
      var t1, t2, t3, t4, t5, t6, t7;
      this.typesInferrer = new G.TypeGraphInferrer(null, compiler);
      if (compiler.enableConcreteTypeInference) {
        t1 = P.LinkedHashMap_LinkedHashMap(null, null, null, O.FunctionElement, [P.Map, L.ConcreteTypesEnvironment, L.ConcreteType]);
        t2 = P.LinkedHashMap_LinkedHashMap(null, null, null, O.FunctionElement, L.ClosureEnvironment);
        t3 = P.LinkedHashMap_LinkedHashMap(null, null, null, Y.Node, L.ConcreteType);
        t4 = P.LinkedHashMap_LinkedHashMap(null, null, null, O.Element, L.ConcreteType);
        t5 = P.LinkedHashMap_LinkedHashMap(null, null, null, O.VariableElement, L.ConcreteType);
        t6 = L.InferenceWorkItem;
        t7 = H.setRuntimeTypeInfo(new P.ListQueue(null, 0, 0, 0), [t6]);
        t7.ListQueue$1(null, t6);
        this.concreteTypesInferrer = new L.ConcreteTypesInferrer("Type inferrer", false, null, null, null, null, null, null, null, null, null, C.C_UnknownConcreteType, null, null, t1, new L.Closures(compiler, t2), t3, t4, P.LinkedHashMap_LinkedHashMap(null, null, null, O.FunctionElement, [P.Set, O.Element]), P.LinkedHashMap_LinkedHashMap(null, null, null, O.Element, [P.Set, O.Element]), P.LinkedHashMap_LinkedHashMap(null, null, null, O.Local, [P.Set, O.FunctionElement]), P.LinkedHashSet_LinkedHashSet(null, null, null, O.ClassElement), P.LinkedHashMap_LinkedHashMap(null, null, null, P.String, [P.Set, O.FunctionElement]), null, t5, P.LinkedHashMap_LinkedHashMap(null, null, null, Z.Selector, [P.Map, B.TypeMask, B.TypeMask]), new L.WorkQueue(t7), null, compiler, null, P.LinkedHashMap_LinkedHashMap(null, null, null, Y.Node, L.ConcreteType), P.LinkedHashSet_LinkedHashSet(null, null, null, O.Element));
      }
    },
    static: {"^": "TypesTask_DUMP_BAD_CPA_RESULTS,TypesTask_DUMP_GOOD_CPA_RESULTS"}
  },
  TypesTask_onResolutionComplete_closure: {
    "^": "Closure:23;this_0,mainElement_1",
    call$0: function() {
      var t1, t2, t3, t4, t5, t6, t7, t8, t9, t10;
      t1 = this.this_0;
      t2 = t1.typesInferrer;
      t3 = this.mainElement_1;
      t4 = t2.compiler;
      t5 = P.LinkedHashMap_LinkedHashMap(null, null, null, O.Element, G.TypeInformation);
      t6 = H.setRuntimeTypeInfo([], [G.CallSiteTypeInformation]);
      t7 = G.TypeInformation;
      t8 = H.setRuntimeTypeInfo(new P.ListQueue(null, 0, 0, 0), [t7]);
      t8.ListQueue$1(null, t7);
      t7 = P.LinkedHashSet_LinkedHashSet(null, null, null, O.Element);
      t9 = H.setRuntimeTypeInfo([Z.Selector_Selector(C.SelectorKind_getter_0, "first", null, 0, null), Z.Selector_Selector(C.SelectorKind_getter_0, "last", null, 0, null), Z.Selector_Selector(C.SelectorKind_getter_0, "single", null, 0, null), Z.Selector_Selector(C.SelectorKind_call_2, "singleWhere", null, 1, null), Z.Selector_Selector(C.SelectorKind_call_2, "elementAt", null, 1, null), Z.Selector_Selector(C.SelectorKind_index_4, O.Elements_constructOperatorName("[]", false), null, 1, null), Z.Selector_Selector(C.SelectorKind_call_2, "removeAt", null, 1, null), Z.Selector_Selector(C.SelectorKind_call_2, "removeLast", null, 0, null)], [Z.Selector]);
      t10 = P.LinkedHashSet_LinkedHashSet(null, null, null, Z.Selector);
      t10.addAll$1(0, t9);
      t9 = new G.TypeInformationSystem(t4, P.LinkedHashMap_LinkedHashMap(null, null, null, O.Element, G.TypeInformation), P.LinkedHashMap_LinkedHashMap(null, null, null, Y.Node, G.TypeInformation), P.LinkedHashMap_LinkedHashMap(null, null, null, Y.Node, G.TypeInformation), P.LinkedHashSet_LinkedHashSet(null, null, null, G.TypeInformation), P.LinkedHashMap_LinkedHashMap(null, null, null, B.TypeMask, G.TypeInformation), H.setRuntimeTypeInfo([], [G.TypeInformation]), null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null);
      t9.nonNullEmptyType = t9.getConcreteTypeFor$1(C.FlatTypeMask_null_0);
      t9 = new G.TypeGraphInferrerEngine(t5, t6, new G.WorkQueue0(t8), t3, t7, 6, 0, 0, t10, t4, t9, P.LinkedHashMap_LinkedHashMap(null, null, null, Y.Node, G.TypeInformation), P.LinkedHashSet_LinkedHashSet(null, null, null, O.Element));
      t2.inferrer = t9;
      t9.runOverAllElements$0();
      t2 = t1.concreteTypesInferrer;
      if (t2 != null)
        if (!t2.analyzeMain$1(t3))
          t1.concreteTypesInferrer = null;
    },
    $isFunction: true
  },
  TypesTask_getGuaranteedTypeOfElement_closure: {
    "^": "Closure:23;this_0,element_1",
    call$0: function() {
      var t1, t2, guaranteedType, t3, result;
      t1 = this.this_0;
      t2 = this.element_1;
      guaranteedType = t1.typesInferrer.getTypeOfElement$1(t2);
      t3 = t1.concreteTypesInferrer;
      if (t3 == null)
        t1 = guaranteedType;
      else {
        result = t3.concrete_types_inferrer$ConcreteTypesInferrer$types.concreteTypeToTypeMask$1(t3.typeOfElement$1(t2));
        t1 = t1.intersection$3(0, guaranteedType, J.$eq(result, C.C_DynamicTypeMask) ? null : result, t2);
      }
      return t1;
    },
    $isFunction: true
  },
  TypesTask_getGuaranteedReturnTypeOfElement_closure: {
    "^": "Closure:23;this_0,element_1",
    call$0: function() {
      var t1, t2, guaranteedType, t3;
      t1 = this.this_0;
      t2 = this.element_1;
      guaranteedType = t1.typesInferrer.getReturnTypeOfElement$1(t2);
      t3 = t1.concreteTypesInferrer;
      return t3 == null ? guaranteedType : t1.intersection$3(0, guaranteedType, t3.getReturnTypeOfElement$1(t2), t2);
    },
    $isFunction: true
  },
  TypesTask_getGuaranteedTypeOfNode_closure: {
    "^": "Closure:23;this_0,owner_1,node_2",
    call$0: function() {
      var t1, t2, guaranteedType, t3, result;
      t1 = this.this_0;
      t2 = this.node_2;
      guaranteedType = t1.typesInferrer.getTypeOfNode$2(this.owner_1, t2);
      t3 = t1.concreteTypesInferrer;
      if (t3 == null)
        t1 = guaranteedType;
      else {
        result = t3.concrete_types_inferrer$ConcreteTypesInferrer$types.concreteTypeToTypeMask$1(t3.inferredTypes.$index(0, t2));
        t1 = t1.intersection$3(0, guaranteedType, J.$eq(result, C.C_DynamicTypeMask) ? null : result, t2);
      }
      return t1;
    },
    $isFunction: true
  },
  TypesTask_getGuaranteedTypeOfSelector_closure: {
    "^": "Closure:23;this_0,selector_1",
    call$0: function() {
      var t1, t2, guaranteedType, t3;
      t1 = this.this_0;
      t2 = this.selector_1;
      guaranteedType = t1.typesInferrer.getTypeOfSelector$1(t2);
      t3 = t1.concreteTypesInferrer;
      return t3 == null ? guaranteedType : t1.intersection$3(0, guaranteedType, t3.getTypeOfSelector$1(t2), t2);
    },
    $isFunction: true
  },
  UnionTypeMask: {
    "^": "Object;disjointMasks<",
    union$2: function(other, compiler) {
      var newList;
      other = B.UnionTypeMask_nonForwardingMask(other);
      if (!other.get$isUnion() && J.contains$1$asx(this.disjointMasks, other))
        return this;
      newList = P.List_List$from(this.disjointMasks, true, B.FlatTypeMask);
      if (!other.get$isUnion())
        newList.push(other);
      else
        C.JSArray_methods.addAll$1(newList, other.get$disjointMasks());
      return B.UnionTypeMask_unionOf(newList, compiler);
    },
    intersection$2: function(_, other, compiler) {
      var intersections, t1, current, t2, t3;
      other = B.UnionTypeMask_nonForwardingMask(other);
      if (!other.get$isUnion() && J.contains$1$asx(this.disjointMasks, other))
        return other;
      intersections = H.setRuntimeTypeInfo([], [B.TypeMask]);
      for (t1 = J.get$iterator$ax(this.disjointMasks); t1.moveNext$0();) {
        current = t1.__internal$_current;
        if (other.get$isUnion())
          for (t2 = J.get$iterator$ax(other.get$disjointMasks()), t3 = J.getInterceptor$x(current); t2.moveNext$0();)
            intersections.push(t3.intersection$2(current, t2.__internal$_current, compiler));
        else
          intersections.push(J.intersection$2$x(current, other, compiler));
      }
      return B.UnionTypeMask_unionOf(intersections, compiler);
    },
    nullable$0: function() {
      var newList, t1;
      if (this.get$isNullable())
        return this;
      newList = P.List_List$from(this.disjointMasks, true, B.FlatTypeMask);
      if (0 >= newList.length)
        return H.ioore(newList, 0);
      t1 = newList[0].nullable$0();
      if (0 >= newList.length)
        return H.ioore(newList, 0);
      newList[0] = t1;
      return new B.UnionTypeMask(newList);
    },
    nonNullable$0: function() {
      if (!this.get$isNullable())
        return this;
      return new B.UnionTypeMask(J.map$1$ax(this.disjointMasks, new B.UnionTypeMask_nonNullable_closure()));
    },
    get$isEmpty: function(_) {
      return false;
    },
    get$isNullable: function() {
      return J.any$1$ax(this.disjointMasks, new B.UnionTypeMask_isNullable_closure());
    },
    get$isExact: function() {
      return false;
    },
    get$isUnion: function() {
      return true;
    },
    get$isContainer: function() {
      return false;
    },
    get$isMap: function(_) {
      return false;
    },
    get$isDictionary: function() {
      return false;
    },
    get$isForwarding: function() {
      return false;
    },
    get$isValue: function() {
      return false;
    },
    isInMask$2: function(other, compiler) {
      return J.every$1$ax(this.disjointMasks, new B.UnionTypeMask_isInMask_closure(other, compiler));
    },
    containsMask$2: function(other, compiler) {
      return J.any$1$ax(this.disjointMasks, new B.UnionTypeMask_containsMask_closure(other, compiler));
    },
    containsOnlyInt$1: function(compiler) {
      return J.every$1$ax(this.disjointMasks, new B.UnionTypeMask_containsOnlyInt_closure(compiler));
    },
    containsOnlyDouble$1: function(compiler) {
      return J.every$1$ax(this.disjointMasks, new B.UnionTypeMask_containsOnlyDouble_closure(compiler));
    },
    containsOnlyNum$1: function(compiler) {
      return J.every$1$ax(this.disjointMasks, new B.UnionTypeMask_containsOnlyNum_closure(compiler));
    },
    containsOnlyBool$1: function(compiler) {
      return J.every$1$ax(this.disjointMasks, new B.UnionTypeMask_containsOnlyBool_closure(compiler));
    },
    containsOnlyString$1: function(compiler) {
      return J.every$1$ax(this.disjointMasks, new B.UnionTypeMask_containsOnlyString_closure(compiler));
    },
    containsOnly$1: function(element) {
      return J.every$1$ax(this.disjointMasks, new B.UnionTypeMask_containsOnly_closure(element));
    },
    satisfies$2: function(cls, compiler) {
      return J.every$1$ax(this.disjointMasks, new B.UnionTypeMask_satisfies_closure(cls, compiler));
    },
    contains$2: function(_, type, compiler) {
      return J.any$1$ax(this.disjointMasks, new B.UnionTypeMask_contains_closure(type, compiler));
    },
    containsAll$1: function(compiler) {
      return J.any$1$ax(this.disjointMasks, new B.UnionTypeMask_containsAll_closure(compiler));
    },
    singleClass$1: function(compiler) {
      return;
    },
    needsNoSuchMethodHandling$2: function(selector, compiler) {
      return J.any$1$ax(this.disjointMasks, new B.UnionTypeMask_needsNoSuchMethodHandling_closure(selector, compiler));
    },
    canHit$3: function(element, selector, compiler) {
      return J.any$1$ax(this.disjointMasks, new B.UnionTypeMask_canHit_closure(element, selector, compiler));
    },
    locateSingleElement$2: function(selector, compiler) {
      var t1, candidate, current;
      for (t1 = J.get$iterator$ax(this.disjointMasks), candidate = null; t1.moveNext$0();) {
        current = t1.__internal$_current.locateSingleElement$2(selector, compiler);
        if (current == null)
          return;
        else if (candidate == null)
          candidate = current;
        else if (candidate !== current)
          return;
      }
      return candidate;
    },
    toString$0: function(_) {
      return "Union of " + H.S(this.disjointMasks);
    },
    $eq: function(_, other) {
      if (other == null)
        return false;
      if (this === other)
        return true;
      return !!J.getInterceptor(other).$isUnionTypeMask && other.get$isNullable() === this.get$isNullable() && J.get$length$asx(other.disjointMasks) === J.get$length$asx(this.disjointMasks) && new B.UnionTypeMask_operator$eq_containsAll(this, other).call$0() === true;
    },
    get$hashCode: function(_) {
      var hashCode, t1, t2;
      hashCode = this.get$isNullable() ? 86 : 43;
      for (t1 = J.get$iterator$ax(this.disjointMasks); t1.moveNext$0();) {
        t2 = t1.__internal$_current.nonNullable$0();
        hashCode = (hashCode ^ t2.get$hashCode(t2)) & 1073741823;
      }
      return hashCode;
    },
    $isUnionTypeMask: true,
    static: {"^": "UnionTypeMask_MAX_UNION_LENGTH", UnionTypeMask_unionOf: function(masks, compiler) {
        var disjoint, t1;
        disjoint = H.setRuntimeTypeInfo([], [B.FlatTypeMask]);
        B.UnionTypeMask_unionOfHelper(masks, disjoint, compiler);
        t1 = disjoint.length;
        if (t1 === 0)
          return new B.FlatTypeMask(null, 0);
        if (t1 > 4)
          return B.UnionTypeMask_flatten(disjoint, compiler);
        if (t1 === 1)
          return disjoint[0];
        return new B.UnionTypeMask(disjoint);
      }, UnionTypeMask_nonForwardingMask: function(mask) {
        for (; mask.get$isForwarding();)
          mask = mask.get$forwardTo();
        return mask;
      }, UnionTypeMask_unionOfHelper: function(masks, disjoint, compiler) {
        var t1, mask, inListIndex, covered, i, t2, current, newMask;
        for (t1 = J.get$iterator$ax(masks); t1.moveNext$0();) {
          mask = B.UnionTypeMask_nonForwardingMask(t1.get$current());
          if (mask.get$isUnion())
            B.UnionTypeMask_unionOfHelper(mask.get$disjointMasks(), disjoint, compiler);
          else if (mask.get$isEmpty(mask) && !mask.get$isNullable())
            continue;
          else {
            for (inListIndex = -1, covered = false, i = 0; t2 = disjoint.length, i < t2; ++i) {
              if (i < 0)
                return H.ioore(disjoint, i);
              current = disjoint[i];
              if (current == null)
                continue;
              newMask = mask.union$2(current, compiler);
              if (newMask.get$isUnion())
                continue;
              if (J.$eq(current, newMask)) {
                covered = true;
                break;
              }
              t2 = disjoint.length;
              if (i >= t2)
                return H.ioore(disjoint, i);
              disjoint[i] = newMask;
              if (inListIndex !== -1) {
                if (inListIndex < 0 || inListIndex >= t2)
                  H.throwExpression(P.RangeError$value(inListIndex));
                disjoint.splice(inListIndex, 1)[0];
                --i;
              }
              inListIndex = i;
              mask = newMask;
              covered = true;
            }
            if (!covered)
              disjoint.push(mask);
          }
        }
      }, UnionTypeMask_flatten: function(masks, compiler) {
        var useSubclass, isNullable, firstElement, secondElement, candidates, unseenType, i, element, supertypes, t1, bestElement, bestKind, bestSize, candidate, subclasses, size, kind, t2;
        useSubclass = H.IterableMixinWorkaround_every(masks, new B.UnionTypeMask_flatten_closure());
        isNullable = H.IterableMixinWorkaround_any(masks, new B.UnionTypeMask_flatten_closure0());
        if (0 >= masks.length)
          return H.ioore(masks, 0);
        firstElement = masks[0].get$base();
        if (1 >= masks.length)
          return H.ioore(masks, 1);
        secondElement = masks[1].get$base();
        candidates = compiler.world.commonSupertypesOf$2(firstElement, secondElement);
        i = 2;
        while (true) {
          if (!(i < masks.length)) {
            unseenType = false;
            break;
          }
          element = masks[i].get$base();
          supertypes = compiler.world._dart2js$_supertypes.$index(0, element.get$declaration());
          if (supertypes == null) {
            unseenType = true;
            break;
          }
          candidates = J.where$1$ax(candidates, new B.UnionTypeMask_flatten_closure1(supertypes));
          ++i;
        }
        t1 = J.getInterceptor$asx(candidates);
        if (t1.get$isEmpty(candidates) || unseenType) {
          t1 = compiler.objectClass;
          return new B.FlatTypeMask(t1, 4 | (isNullable ? 1 : 0));
        }
        for (t1 = t1.get$iterator(candidates), bestElement = null, bestKind = null, bestSize = null; t1.moveNext$0();) {
          candidate = t1.get$current();
          subclasses = useSubclass ? compiler.world._subclasses.$index(0, candidate.get$declaration()) : null;
          if (subclasses != null && H.IterableMixinWorkaround_every(masks, new B.UnionTypeMask_flatten_closure2(subclasses))) {
            size = J.get$length$asx(subclasses);
            kind = 2;
          } else {
            size = J.get$length$asx(compiler.world._subtypes.$index(0, candidate.get$declaration()));
            kind = 3;
          }
          if (bestElement != null) {
            if (typeof size !== "number")
              return size.$lt();
            if (typeof bestSize !== "number")
              return H.iae(bestSize);
            t2 = size < bestSize;
          } else
            t2 = true;
          if (t2) {
            bestSize = size;
            bestKind = kind;
            bestElement = candidate;
          }
        }
        if (J.$eq(bestElement, compiler.objectClass))
          bestKind = 2;
        if (typeof bestKind !== "number")
          return bestKind.$shl();
        t1 = isNullable ? 1 : 0;
        return new B.FlatTypeMask(bestElement, (bestKind << 1 | t1) >>> 0);
      }}
  },
  UnionTypeMask_flatten_closure: {
    "^": "Closure:13;",
    call$1: function(e) {
      return e.get$isSubtype() !== true;
    },
    $isFunction: true
  },
  UnionTypeMask_flatten_closure0: {
    "^": "Closure:13;",
    call$1: function(e) {
      return e.get$isNullable();
    },
    $isFunction: true
  },
  UnionTypeMask_flatten_closure1: {
    "^": "Closure:13;supertypes_0",
    call$1: function(e) {
      return this.supertypes_0.contains$1(0, e);
    },
    $isFunction: true
  },
  UnionTypeMask_flatten_closure2: {
    "^": "Closure:13;subclasses_1",
    call$1: function(t) {
      return this.subclasses_1.contains$1(0, t.get$base());
    },
    $isFunction: true
  },
  UnionTypeMask_nonNullable_closure: {
    "^": "Closure:13;",
    call$1: function(e) {
      return e.nonNullable$0();
    },
    $isFunction: true
  },
  UnionTypeMask_isNullable_closure: {
    "^": "Closure:13;",
    call$1: function(e) {
      return e.get$isNullable();
    },
    $isFunction: true
  },
  UnionTypeMask_isInMask_closure: {
    "^": "Closure:13;other_0,compiler_1",
    call$1: function(mask) {
      return mask.isInMask$2(this.other_0, this.compiler_1);
    },
    $isFunction: true
  },
  UnionTypeMask_containsMask_closure: {
    "^": "Closure:13;other_0,compiler_1",
    call$1: function(mask) {
      return mask.containsMask$2(this.other_0, this.compiler_1);
    },
    $isFunction: true
  },
  UnionTypeMask_containsOnlyInt_closure: {
    "^": "Closure:13;compiler_0",
    call$1: function(mask) {
      return mask.containsOnlyInt$1(this.compiler_0);
    },
    $isFunction: true
  },
  UnionTypeMask_containsOnlyDouble_closure: {
    "^": "Closure:13;compiler_0",
    call$1: function(mask) {
      return mask.containsOnlyDouble$1(this.compiler_0);
    },
    $isFunction: true
  },
  UnionTypeMask_containsOnlyNum_closure: {
    "^": "Closure:13;compiler_0",
    call$1: function(mask) {
      return mask.containsOnlyNum$1(this.compiler_0);
    },
    $isFunction: true
  },
  UnionTypeMask_containsOnlyBool_closure: {
    "^": "Closure:13;compiler_0",
    call$1: function(mask) {
      return mask.containsOnlyBool$1(this.compiler_0);
    },
    $isFunction: true
  },
  UnionTypeMask_containsOnlyString_closure: {
    "^": "Closure:13;compiler_0",
    call$1: function(mask) {
      return mask.containsOnlyString$1(this.compiler_0);
    },
    $isFunction: true
  },
  UnionTypeMask_containsOnly_closure: {
    "^": "Closure:13;element_0",
    call$1: function(mask) {
      return mask.containsOnly$1(this.element_0);
    },
    $isFunction: true
  },
  UnionTypeMask_satisfies_closure: {
    "^": "Closure:13;cls_0,compiler_1",
    call$1: function(mask) {
      return mask.satisfies$2(this.cls_0, this.compiler_1);
    },
    $isFunction: true
  },
  UnionTypeMask_contains_closure: {
    "^": "Closure:13;type_0,compiler_1",
    call$1: function(e) {
      return J.contains$2$asx(e, this.type_0, this.compiler_1);
    },
    $isFunction: true
  },
  UnionTypeMask_containsAll_closure: {
    "^": "Closure:13;compiler_0",
    call$1: function(mask) {
      return mask.containsAll$1(this.compiler_0);
    },
    $isFunction: true
  },
  UnionTypeMask_needsNoSuchMethodHandling_closure: {
    "^": "Closure:13;selector_0,compiler_1",
    call$1: function(e) {
      return e.needsNoSuchMethodHandling$2(this.selector_0, this.compiler_1);
    },
    $isFunction: true
  },
  UnionTypeMask_canHit_closure: {
    "^": "Closure:13;element_0,selector_1,compiler_2",
    call$1: function(e) {
      return e.canHit$3(this.element_0, this.selector_1, this.compiler_2);
    },
    $isFunction: true
  },
  UnionTypeMask_operator$eq_containsAll: {
    "^": "Closure:42;this_0,other_1",
    call$0: function() {
      return J.every$1$ax(this.other_1.get$disjointMasks(), new B.UnionTypeMask_operator$eq_containsAll_closure(this.this_0));
    },
    $isFunction: true
  },
  UnionTypeMask_operator$eq_containsAll_closure: {
    "^": "Closure:13;this_2",
    call$1: function(e) {
      return J.map$1$ax(this.this_2.disjointMasks, new B.UnionTypeMask_operator$eq_containsAll__closure()).contains$1(0, e.nonNullable$0());
    },
    $isFunction: true
  },
  UnionTypeMask_operator$eq_containsAll__closure: {
    "^": "Closure:13;",
    call$1: function(e) {
      return e.nonNullable$0();
    },
    $isFunction: true
  },
  ValueTypeMask: {
    "^": "ForwardingTypeMask;forwardTo<,value>",
    nullable$0: function() {
      var t1 = this.forwardTo;
      return t1.get$isNullable() ? this : new B.ValueTypeMask(t1.nullable$0(), this.value);
    },
    nonNullable$0: function() {
      var t1 = this.forwardTo;
      return t1.get$isNullable() ? new B.ValueTypeMask(t1.nonNullable$0(), this.value) : this;
    },
    get$isValue: function() {
      return true;
    },
    equalsDisregardNull$1: function(other) {
      var t1, t2;
      if (!J.getInterceptor(other).$isValueTypeMask)
        return false;
      if (B.ForwardingTypeMask.prototype.equalsDisregardNull$1.call(this, other)) {
        t1 = this.value;
        t2 = other.value;
        t2 = t1 == null ? t2 == null : t1 === t2;
        t1 = t2;
      } else
        t1 = false;
      return t1;
    },
    intersection$2: function(_, other, compiler) {
      var t1, forwardIntersection;
      t1 = this.forwardTo;
      forwardIntersection = t1.intersection$2(0, other, compiler);
      if (forwardIntersection.get$isEmpty(forwardIntersection))
        return forwardIntersection;
      if (forwardIntersection.get$isNullable())
        t1 = t1.get$isNullable() ? this : new B.ValueTypeMask(t1.nullable$0(), this.value);
      else
        t1 = t1.get$isNullable() ? new B.ValueTypeMask(t1.nonNullable$0(), this.value) : this;
      return t1;
    },
    $eq: function(_, other) {
      if (other == null)
        return false;
      return B.ForwardingTypeMask.prototype.$eq.call(this, this, other);
    },
    get$hashCode: function(_) {
      var t1 = this.forwardTo;
      return O.computeHashCode(this.value, t1.get$isNullable(), t1, null, null);
    },
    toString$0: function(_) {
      return "Value mask: [" + H.S(this.value) + "] type: " + J.toString$0(this.forwardTo);
    },
    $isValueTypeMask: true
  }
}],
["universe", "package:compiler/implementation/universe/universe.dart", , Z, {
  "^": "",
  FunctionSet: {
    "^": "Object;compiler<,nodes>",
    add$1: function(_, element) {
      var $name = J.get$name$x(element);
      J.add$1$ax(this.nodes.putIfAbsent$2($name, new Z.FunctionSet_add_closure(this, $name)), element);
    },
    remove$1: function(_, element) {
      var node = this.nodes.$index(0, J.get$name$x(element));
      if (node != null)
        J.remove$1$ax(node, element);
    },
    contains$1: function(_, element) {
      var node = this.nodes.$index(0, J.get$name$x(element));
      return node != null && J.contains$1$asx(node, element);
    },
    query$1: function(_, selector) {
      var t1, node, noSuchMethods;
      t1 = this.nodes;
      node = t1.$index(0, selector.name);
      noSuchMethods = t1.$index(0, "noSuchMethod");
      if (node != null)
        return J.query$3$x(node, selector, this.compiler, noSuchMethods);
      if (noSuchMethods == null)
        return C.FunctionSetQuery_List_empty;
      t1 = this.compiler;
      return J.query$3$x(noSuchMethods, selector.get$mask() == null ? t1.noSuchMethodSelector : Z.TypedSelector_TypedSelector(selector.get$mask(), t1.noSuchMethodSelector, t1), t1, null);
    },
    forEach$1: function(_, action) {
      this.nodes.forEach$1(0, new Z.FunctionSet_forEach_closure(action));
    }
  },
  FunctionSet_add_closure: {
    "^": "Closure:23;this_0,name_1",
    call$0: function() {
      return new Z.FunctionSetNode(this.name_1, P.LinkedHashMap_LinkedHashMap(null, null, null, Z.Selector, Z.FunctionSetQuery), H.setRuntimeTypeInfo([], [O.Element]), true);
    },
    $isFunction: true
  },
  FunctionSet_forEach_closure: {
    "^": "Closure:307;action_0",
    call$2: function($name, node) {
      J.forEach$1$ax(J.get$elements$x(node), this.action_0);
    },
    $isFunction: true
  },
  FunctionSetNode: {
    "^": "Object;name>,cache,elements>,isList<",
    add$1: function(_, element) {
      var t1;
      if (!J.contains$1$asx(this.elements, element)) {
        if (this.isList && J.get$length$asx(this.elements) >= 8) {
          this.elements = J.toSet$0$ax(this.elements);
          this.isList = false;
        }
        J.add$1$ax(this.elements, element);
        t1 = this.cache;
        if (t1._collection$_length !== 0)
          t1.clear$0(0);
      }
    },
    remove$1: function(_, element) {
      var t1, list, index, last;
      t1 = this.isList;
      list = this.elements;
      if (t1) {
        t1 = J.getInterceptor$asx(list);
        index = H.Lists_indexOf(list, element, 0, t1.get$length(list));
        if (index < 0)
          return;
        last = t1.removeLast$0(list);
        t1 = list.length;
        if (index !== t1) {
          if (index >= t1)
            return H.ioore(list, index);
          list[index] = last;
        }
        t1 = this.cache;
        if (t1._collection$_length !== 0)
          t1.clear$0(0);
      } else if (J.remove$1$ax(list, element)) {
        t1 = this.cache;
        if (t1._collection$_length !== 0)
          t1.clear$0(0);
      }
    },
    contains$1: function(_, element) {
      return J.contains$1$asx(this.elements, element);
    },
    forEach$1: function(_, action) {
      J.forEach$1$ax(this.elements, action);
    },
    query$3: function(_, selector, compiler, noSuchMethods) {
      var t1, result, t2, functions, element, mask;
      t1 = this.cache;
      result = t1.$index(0, selector);
      if (result != null)
        return result;
      for (t2 = J.get$iterator$ax(this.elements), functions = null; t2.moveNext$0();) {
        element = t2.get$current();
        if (selector.appliesUnnamed$2(element, compiler)) {
          if (functions == null) {
            functions = new N.Setlet(C.C__SetletMarker, null);
            functions.$builtinTypeInfo = [O.Element];
          }
          functions.add$1(0, element);
        }
      }
      mask = selector.get$mask() != null ? selector.get$mask() : new B.FlatTypeMask(compiler.objectClass, 5);
      if (noSuchMethods != null && mask.needsNoSuchMethodHandling$2(selector, compiler)) {
        t2 = noSuchMethods.query$3(0, Z.TypedSelector_TypedSelector(mask, compiler.noSuchMethodSelector, compiler), compiler, null).functions;
        if (!J.get$isEmpty$asx(t2))
          if (functions == null) {
            functions = H.setRuntimeTypeInfo(new N.Setlet(C.C__SetletMarker, null), [O.Element]);
            functions.addAll$1(0, t2);
          } else
            functions.addAll$1(0, t2);
      }
      result = functions != null ? new Z.FullFunctionSetQuery(null, functions) : C.FunctionSetQuery_List_empty;
      t1.$indexSet(0, selector, result);
      return result;
    },
    static: {"^": "FunctionSetNode_MAX_ELEMENTS_IN_LIST"}
  },
  FunctionSetQuery: {
    "^": "Object;functions",
    computeMask$1: function(compiler) {
      return C.FlatTypeMask_null_0;
    }
  },
  FullFunctionSetQuery: {
    "^": "FunctionSetQuery;_mask,functions",
    computeMask$1: function(compiler) {
      var t1 = this._mask;
      if (t1 != null)
        return t1;
      t1 = J.expand$1$ax(this.functions, new Z.FullFunctionSetQuery_computeMask_closure(compiler));
      t1 = B.UnionTypeMask_unionOf(H.MappedIterable_MappedIterable(t1, new Z.FullFunctionSetQuery_computeMask_closure0(compiler), H.getRuntimeTypeArgument(t1, "IterableBase", 0), null), compiler);
      this._mask = t1;
      return t1;
    }
  },
  FullFunctionSetQuery_computeMask_closure: {
    "^": "Closure:13;compiler_0",
    call$1: function(element) {
      var cls, t1, t2;
      cls = element.get$enclosingClass();
      t1 = this.compiler_0;
      if (t1.world.isUsedAsMixin$1(cls)) {
        t2 = [cls];
        C.JSArray_methods.addAll$1(t2, t1.world.mixinUses.$index(0, cls));
        t1 = t2;
      } else
        t1 = [cls];
      return t1;
    },
    $isFunction: true
  },
  FullFunctionSetQuery_computeMask_closure0: {
    "^": "Closure:13;compiler_1",
    call$1: function(cls) {
      var t1, subclasses;
      t1 = this.compiler_1;
      if (t1.backend.isNullImplementation$1(cls))
        return C.FlatTypeMask_null_1;
      subclasses = t1.world.compiler.world._subclasses.$index(0, cls.get$declaration());
      return subclasses != null && !J.get$isEmpty$asx(subclasses) ? new B.FlatTypeMask(cls.get$declaration(), 4) : new B.FlatTypeMask(cls.get$declaration(), 2);
    },
    $isFunction: true
  },
  SideEffects: {
    "^": "Object;flags<",
    $eq: function(_, other) {
      if (other == null)
        return false;
      return this.flags === other.get$flags();
    },
    get$hashCode: function(_) {
      return H.throwExpression(P.UnsupportedError$("SideEffects.hashCode"));
    },
    getDependsOnFlags$0: function() {
      return (this.flags & 63) >>> 3;
    },
    clearAllSideEffects$0: function() {
      this.flags = (this.flags & 4294967288) >>> 0;
    },
    setDependsOnSomething$0: function() {
      this.flags = (this.flags | 56) >>> 0;
    },
    clearAllDependencies$0: function() {
      this.flags = (this.flags & 4294967239) >>> 0;
    },
    add$1: function(_, other) {
      this.flags = (this.flags | other.get$flags()) >>> 0;
    },
    toString$0: function(_) {
      var buffer = P.StringBuffer$("");
      buffer.write$1("Depends on");
      if ((this.flags & 8) !== 0)
        buffer.write$1(" []");
      if ((this.flags & 16) !== 0)
        buffer.write$1(" field store");
      if ((this.flags & 32) !== 0)
        buffer.write$1(" static store");
      if (this.getDependsOnFlags$0() === 0)
        buffer.write$1(" nothing");
      buffer.write$1(", Changes");
      if ((this.flags & 1) !== 0)
        buffer.write$1(" []");
      if ((this.flags & 2) !== 0)
        buffer.write$1(" field");
      if ((this.flags & 4) !== 0)
        buffer.write$1(" static");
      if ((this.flags & 7) === 0)
        buffer.write$1(" nothing");
      buffer.write$1(".");
      return buffer._contents;
    },
    static: {"^": "SideEffects_FLAG_CHANGES_INDEX,SideEffects_FLAG_CHANGES_INSTANCE_PROPERTY,SideEffects_FLAG_CHANGES_STATIC_PROPERTY,SideEffects_FLAG_CHANGES_COUNT,SideEffects_FLAG_DEPENDS_ON_INDEX_STORE,SideEffects_FLAG_DEPENDS_ON_INSTANCE_PROPERTY_STORE,SideEffects_FLAG_DEPENDS_ON_STATIC_PROPERTY_STORE,SideEffects_FLAG_DEPENDS_ON_COUNT"}
  },
  Universe: {
    "^": "Object;instantiatedClasses,instantiatedTypes,staticFunctionsNeedingGetter,methodsNeedingSuperGetter,invokedNames,invokedGetters,invokedSetters,fieldGetters,fieldSetters,isChecks,genericCallMethods,genericClosures,allClosures,closurizedMembers,usingFactoryWithTypeArguments",
    hasMatchingSelector$3: function(selectors, member, compiler) {
      var t1;
      if (selectors == null)
        return false;
      for (t1 = J.get$iterator$ax(selectors); t1.moveNext$0();)
        if (t1.get$current().appliesUnnamed$2(member, compiler))
          return true;
      return false;
    }
  },
  SelectorKind: {
    "^": "Object;name>,hashCode>",
    toString$0: function(_) {
      return this.name;
    },
    static: {"^": "SelectorKind_GETTER,SelectorKind_SETTER,SelectorKind_CALL,SelectorKind_OPERATOR,SelectorKind_INDEX"}
  },
  Selector: {
    "^": "Object;kind>,name>,library<,argumentCount<,namedArguments<,_orderedNamedArguments,hashCode>",
    get$isGetter: function() {
      return this.kind === C.SelectorKind_getter_0;
    },
    get$isSetter: function() {
      return this.kind === C.SelectorKind_setter_1;
    },
    get$isClosureCall: function() {
      return this.kind === C.SelectorKind_call_2 && this.name === "call";
    },
    get$mask: function() {
      return;
    },
    get$asUntyped: function() {
      return this;
    },
    get$invocationMirrorMemberName: function() {
      var t1 = this.name;
      return this.kind === C.SelectorKind_setter_1 ? H.S(t1) + "=" : t1;
    },
    get$invocationMirrorKind: function() {
      var t1, kind;
      t1 = this.kind;
      if (t1 === C.SelectorKind_getter_0)
        kind = 1;
      else
        kind = t1 === C.SelectorKind_setter_1 ? 2 : 0;
      return kind;
    },
    appliesUnnamed$2: function(element, compiler) {
      return this.appliesUntyped$2(element, compiler);
    },
    appliesUntyped$2: function(element, compiler) {
      var t1, t2;
      if (element == null || element.get$isErroneous())
        return false;
      t1 = this.name;
      if (!J.getInterceptor$asx(t1).get$isEmpty(t1) && C.JSString_methods.codeUnitAt$1(t1, 0) === 95) {
        t1 = this.library;
        t2 = element.get$library();
        t2 = t1 == null ? t2 != null : t1 !== t2;
        t1 = t2;
      } else
        t1 = false;
      if (t1)
        return false;
      if (element.isForeign$1(compiler))
        return true;
      t1 = element.kind;
      if (t1 === C.ElementKind_setter_0)
        return this.kind === C.SelectorKind_setter_1;
      if (element.get$isGetter()) {
        t1 = this.kind;
        return t1 === C.SelectorKind_getter_0 || t1 === C.SelectorKind_call_2;
      }
      if (t1 === C.ElementKind_field_1) {
        t1 = this.kind;
        if (t1 === C.SelectorKind_setter_1)
          t1 = (element.get$modifiers().flags & 4) === 0 && (element.get$modifiers().flags & 16) === 0;
        else
          t1 = t1 === C.SelectorKind_getter_0 || t1 === C.SelectorKind_call_2;
        return t1;
      }
      t1 = this.kind;
      if (t1 === C.SelectorKind_getter_0)
        return true;
      if (t1 === C.SelectorKind_setter_1)
        return false;
      return this.signatureApplies$2(element, compiler);
    },
    signatureApplies$2: function($function, compiler) {
      var parameters, t1, requiredParameterCount, optionalParameterCount, t2, t3, nameSet, $name;
      parameters = $function.computeSignature$1(compiler);
      t1 = this.argumentCount;
      if (t1 > parameters.get$parameterCount())
        return false;
      requiredParameterCount = parameters.requiredParameterCount;
      optionalParameterCount = parameters.optionalParameterCount;
      t2 = this.namedArguments;
      t3 = t2.length;
      t1 -= t3;
      if (t1 < requiredParameterCount)
        return false;
      if (!parameters.optionalParametersAreNamed)
        return t3 === 0;
      else {
        if (t1 > requiredParameterCount)
          return false;
        if (t3 > optionalParameterCount)
          return false;
        nameSet = P.LinkedHashSet_LinkedHashSet(null, null, null, P.String);
        parameters.optionalParameters.forEach$1(0, new Z.Selector_signatureApplies_closure(nameSet));
        for (t1 = H.setRuntimeTypeInfo(new H.ListIterator(t2, t2.length, 0, null), [H.getTypeArgumentByIndex(t2, 0)]); t1.moveNext$0();) {
          $name = t1.__internal$_current;
          if (!nameSet.contains$1(0, $name))
            return false;
          nameSet.remove$1(0, $name);
        }
        return true;
      }
    },
    applies$2: function(element, compiler) {
      var t1, t2;
      t1 = J.getInterceptor$x(element);
      if (!(t1.get$kind(element) === C.ElementKind_generative_constructor_16 || element.get$isFactoryConstructor())) {
        t2 = this.name;
        t1 = t1.get$name(element);
        if (t2 == null ? t1 != null : t2 !== t1)
          t1 = t2 === "assert" && compiler.backend.isAssertMethod$1(element);
        else
          t1 = true;
      } else
        t1 = true;
      if (!t1)
        return false;
      return this.appliesUnnamed$2(element, compiler);
    },
    addArgumentsToList$6: function($arguments, list, element, compileArgument, compileConstant, compiler) {
      var t1, parameters, compiledNamedArguments, t2;
      t1 = {};
      t1.arguments_0 = $arguments;
      if (!this.applies$2(element, compiler))
        return false;
      parameters = element.get$functionSignature();
      parameters.forEachRequiredParameter$1(new Z.Selector_addArgumentsToList_closure(t1, list, compileArgument));
      if (!parameters.optionalParametersAreNamed)
        parameters.forEachOptionalParameter$1(new Z.Selector_addArgumentsToList_closure0(t1, list, compileArgument, compileConstant));
      else {
        compiledNamedArguments = [];
        for (; t2 = t1.arguments_0, !t2.get$isEmpty(t2); t1.arguments_0 = t1.arguments_0.get$tail()) {
          t2 = t1.arguments_0;
          compiledNamedArguments.push(compileArgument.call$1(t2.get$head(t2).get$expression()));
        }
        H.IterableMixinWorkaround_forEach(parameters.orderedOptionalParameters, new Z.Selector_addArgumentsToList_closure1(this, list, compileConstant, compiledNamedArguments));
      }
      return true;
    },
    getOrderedNamedArguments$0: function() {
      var t1, t2;
      t1 = this.namedArguments;
      if (t1.length === 0)
        return t1;
      t2 = this._orderedNamedArguments;
      if (t2.length !== 0)
        return t2;
      C.JSArray_methods.addAll$1(t2, t1);
      if (!!t2.immutable$list)
        H.throwExpression(P.UnsupportedError$("sort"));
      H.IterableMixinWorkaround_sortList(t2, new Z.Selector_getOrderedNamedArguments_closure());
      return t2;
    },
    namedArgumentsToString$0: function() {
      var t1, result, i, str;
      t1 = this.namedArguments;
      if (t1.length > 0) {
        result = P.StringBuffer$("");
        for (i = 0; i < t1.length; ++i) {
          if (i !== 0)
            result._contents += ", ";
          str = t1[i];
          result._contents += typeof str === "string" ? str : H.S(str);
        }
        return "[" + H.S(result) + "]";
      }
      return "";
    },
    toString$0: function(_) {
      var named, type;
      named = this.namedArguments.length > 0 ? ", named=" + this.namedArgumentsToString$0() : "";
      type = this.get$mask() != null ? ", mask=" + J.toString$0(this.get$mask()) : "";
      return "Selector(" + this.kind.name + ", " + H.S(this.name) + ", arity=" + this.argumentCount + named + type + ")";
    },
    extendIfReachesAll$1: function(compiler) {
      return Z.TypedSelector_TypedSelector(compiler.typesTask.get$dynamicType(), this, compiler);
    },
    Selector$internal$7: function(kind, $name, library, argumentCount, namedArguments, _orderedNamedArguments, hashCode) {
    },
    $isSelector: true,
    static: {"^": "Selector_INDEX_NAME,Selector_INDEX_SET_NAME,Selector_CALL_NAME,Selector_canonicalizedValues", Selector$internal: function(kind, $name, library, argumentCount, namedArguments, _orderedNamedArguments, hashCode) {
        var t1 = new Z.Selector(kind, $name, library, argumentCount, namedArguments, _orderedNamedArguments, hashCode);
        t1.Selector$internal$7(kind, $name, library, argumentCount, namedArguments, _orderedNamedArguments, hashCode);
        return t1;
      }, Selector_Selector: function(kind, $name, library, argumentCount, namedArguments) {
        var hashCode, list, t1, i, t2, existing, result;
        if (!(!J.getInterceptor$asx($name).get$isEmpty($name) && C.JSString_methods.codeUnitAt$1($name, 0) === 95))
          library = null;
        if (namedArguments == null)
          namedArguments = C.List_empty0;
        hashCode = Z.Selector_computeHashCode(kind, $name, library, argumentCount, namedArguments);
        list = $.get$Selector_canonicalizedValues().putIfAbsent$2(hashCode, new Z.Selector_Selector_closure());
        t1 = J.getInterceptor$asx(list);
        i = 0;
        while (true) {
          t2 = t1.get$length(list);
          if (typeof t2 !== "number")
            return H.iae(t2);
          if (!(i < t2))
            break;
          existing = t1.$index(list, i);
          t2 = J.getInterceptor$x(existing);
          if (t2.get$kind(existing) === kind)
            if (t2.get$name(existing) === $name) {
              t2 = existing.get$library();
              t2 = (t2 == null ? library == null : t2 === library) && existing.get$argumentCount() === argumentCount && existing.get$namedArguments().length === namedArguments.length && Z.Selector_sameNames(existing.namedArguments, namedArguments);
            } else
              t2 = false;
          else
            t2 = false;
          if (t2)
            return existing;
          ++i;
        }
        result = Z.Selector$internal(kind, $name, library, argumentCount, namedArguments, namedArguments.length === 0 ? C.List_empty0 : H.setRuntimeTypeInfo([], [P.String]), hashCode);
        t1.add$1(list, result);
        return result;
      }, Selector_Selector$fromElement: function(element, compiler) {
        var $name, signature, arity, namedArguments, t1;
        $name = element.name;
        if (element.get$isFunction()) {
          if ($name === "[]")
            return Z.Selector_Selector(C.SelectorKind_index_4, O.Elements_constructOperatorName("[]", false), null, 1, null);
          else if ($name === "[]=")
            return Z.Selector_Selector(C.SelectorKind_index_4, O.Elements_constructOperatorName("[]=", false), null, 2, null);
          signature = element.asFunctionElement$0().computeSignature$1(compiler);
          arity = signature.get$parameterCount();
          namedArguments = signature.optionalParametersAreNamed ? H.setRuntimeTypeInfo(new H.MappedListIterable(signature.orderedOptionalParameters, new Z.Selector_Selector$fromElement_closure()), [null, null]).toList$0(0) : null;
          if ($name === "unary-" || Y.isUserDefinableOperator($name))
            return Z.Selector_Selector(C.SelectorKind_operator_3, $name, null, arity, namedArguments);
          else
            return Z.Selector_Selector(C.SelectorKind_call_2, $name, element.get$library(), arity, namedArguments);
        } else {
          t1 = element.kind;
          if (t1 === C.ElementKind_setter_0)
            return Z.Selector_Selector(C.SelectorKind_setter_1, $name, element.get$library(), 1, null);
          else if (element.get$isGetter())
            return Z.Selector_Selector(C.SelectorKind_getter_0, $name, element.get$library(), 0, null);
          else if (t1 === C.ElementKind_field_1)
            return Z.Selector_Selector(C.SelectorKind_getter_0, $name, element.get$library(), 0, null);
          else
            throw H.wrapException(O.SpannableAssertionFailure$(element, "Can't get selector from " + element.toString$0(0)));
        }
      }, Selector_addForwardingElementArgumentsToList: function(caller, list, callee, compileArgument, compileConstant, compiler) {
        var signature, mapping, nodes, namedParameters;
        signature = caller.get$functionSignature();
        mapping = P.LinkedHashMap_LinkedHashMap(null, null, null, null, null);
        nodes = new Z.Selector_addForwardingElementArgumentsToList_computeCallNodesFromParameters(signature, mapping).call$0();
        namedParameters = signature.get$optionalParametersAreNamed() ? signature.optionalParameters.mapToList$1(new Z.Selector_addForwardingElementArgumentsToList_closure()) : null;
        return Z.Selector_Selector(C.SelectorKind_call_2, callee.get$name(callee), caller.enclosingElement.get$library(), signature.get$parameterCount(), namedParameters).addArgumentsToList$6(nodes, list, callee, new Z.Selector_addForwardingElementArgumentsToList_internalCompileArgument(compileArgument, mapping), compileConstant, compiler);
      }, Selector_sameNames: function(first, second) {
        var i, t1;
        for (i = 0; i < first.length; ++i) {
          t1 = first[i];
          if (i >= second.length)
            return H.ioore(second, i);
          if (!J.$eq(t1, second[i]))
            return false;
        }
        return true;
      }, Selector_computeHashCode: function(kind, $name, library, argumentCount, namedArguments) {
        var hash, named, i;
        hash = Z.Selector_mixHashCodeBits(J.get$hashCode$($name), kind.hashCode);
        hash = Z.Selector_mixHashCodeBits(library != null ? Z.Selector_mixHashCodeBits(hash, library.hashCode) : hash, argumentCount);
        named = namedArguments.length;
        hash = Z.Selector_mixHashCodeBits(hash, named);
        for (i = 0; i < named; ++i) {
          if (i >= namedArguments.length)
            return H.ioore(namedArguments, i);
          hash = Z.Selector_mixHashCodeBits(hash, J.get$hashCode$(namedArguments[i]));
        }
        return hash;
      }, Selector_mixHashCodeBits: function(existing, value) {
        var h;
        if (typeof value !== "number")
          return value.$and();
        h = value & 536870911;
        h += ((h & 16383) << 15 ^ 536857981) >>> 0;
        h = (h ^ h >>> 10) >>> 0;
        h += (h & 67108863) << 3 >>> 0;
        h = (h ^ h >>> 6) >>> 0;
        h += ((h & 134217727) << 2 >>> 0) + ((h & 32767) << 14 >>> 0);
        return (C.JSInt_methods._shrOtherPositive$1(existing, 15) * 13 ^ (existing & 32767) * 997 ^ h ^ h >>> 16) >>> 0;
      }}
  },
  Selector_Selector_closure: {
    "^": "Closure:23;",
    call$0: function() {
      return H.setRuntimeTypeInfo([], [Z.Selector]);
    },
    $isFunction: true
  },
  Selector_Selector$fromElement_closure: {
    "^": "Closure:13;",
    call$1: function(e) {
      return J.get$name$x(e);
    },
    $isFunction: true
  },
  Selector_signatureApplies_closure: {
    "^": "Closure:77;nameSet_0",
    call$1: function(element) {
      this.nameSet_0.add$1(0, J.get$name$x(element));
    },
    $isFunction: true
  },
  Selector_addArgumentsToList_closure: {
    "^": "Closure:13;box_0,list_1,compileArgument_2",
    call$1: function(element) {
      var t1, t2;
      t1 = this.box_0;
      t2 = t1.arguments_0;
      this.list_1.push(this.compileArgument_2.call$1(t2.get$head(t2)));
      t1.arguments_0 = t1.arguments_0.get$tail();
    },
    $isFunction: true
  },
  Selector_addArgumentsToList_closure0: {
    "^": "Closure:13;box_0,list_3,compileArgument_4,compileConstant_5",
    call$1: function(element) {
      var t1, t2, t3;
      t1 = this.box_0;
      t2 = t1.arguments_0;
      t3 = this.list_3;
      if (!t2.get$isEmpty(t2)) {
        t2 = t1.arguments_0;
        t3.push(this.compileArgument_4.call$1(t2.get$head(t2)));
        t1.arguments_0 = t1.arguments_0.get$tail();
      } else
        t3.push(this.compileConstant_5.call$1(element));
    },
    $isFunction: true
  },
  Selector_addArgumentsToList_closure1: {
    "^": "Closure:13;this_6,list_7,compileConstant_8,compiledNamedArguments_9",
    call$1: function(element) {
      var t1, foundIndex, t2;
      t1 = this.this_6.namedArguments;
      foundIndex = H.Lists_indexOf(t1, J.get$name$x(element), 0, t1.length);
      t1 = this.list_7;
      if (foundIndex !== -1) {
        t2 = this.compiledNamedArguments_9;
        if (foundIndex < 0 || foundIndex >= t2.length)
          return H.ioore(t2, foundIndex);
        t1.push(t2[foundIndex]);
      } else
        t1.push(this.compileConstant_8.call$1(element));
    },
    $isFunction: true
  },
  Selector_addForwardingElementArgumentsToList_computeCallNodesFromParameters: {
    "^": "Closure:308;signature_0,mapping_1",
    call$0: function() {
      var builder, t1, t2;
      builder = H.setRuntimeTypeInfo(new E.LinkBuilderImplementation(null, null, 0), [null]);
      t1 = this.signature_0;
      t2 = this.mapping_1;
      t1.forEachRequiredParameter$1(new Z.Selector_addForwardingElementArgumentsToList_computeCallNodesFromParameters_closure(t2, builder));
      if (t1.optionalParametersAreNamed)
        t1.forEachOptionalParameter$1(new Z.Selector_addForwardingElementArgumentsToList_computeCallNodesFromParameters_closure0(t2, builder));
      else
        t1.forEachOptionalParameter$1(new Z.Selector_addForwardingElementArgumentsToList_computeCallNodesFromParameters_closure1(t2, builder));
      return builder.toLink$0();
    },
    $isFunction: true
  },
  Selector_addForwardingElementArgumentsToList_computeCallNodesFromParameters_closure: {
    "^": "Closure:50;mapping_2,builder_3",
    call$1: function(element) {
      var node = element.get$node();
      this.mapping_2.$indexSet(0, node, element);
      this.builder_3.addLast$1(node);
    },
    $isFunction: true
  },
  Selector_addForwardingElementArgumentsToList_computeCallNodesFromParameters_closure0: {
    "^": "Closure:50;mapping_4,builder_5",
    call$1: function(element) {
      var t1, t2;
      this.mapping_4.$indexSet(0, element.get$initializer(), element);
      t1 = element.get$initializer();
      t2 = $.Node__HASH_COUNTER + 1;
      $.Node__HASH_COUNTER = t2;
      this.builder_5.addLast$1(new Y.NamedArgument(null, t1, null, t2));
    },
    $isFunction: true
  },
  Selector_addForwardingElementArgumentsToList_computeCallNodesFromParameters_closure1: {
    "^": "Closure:50;mapping_6,builder_7",
    call$1: function(element) {
      var node = element.get$node();
      this.mapping_6.$indexSet(0, node, element);
      this.builder_7.addLast$1(node);
    },
    $isFunction: true
  },
  Selector_addForwardingElementArgumentsToList_internalCompileArgument: {
    "^": "Closure:309;compileArgument_8,mapping_9",
    call$1: function(node) {
      return this.compileArgument_8.call$1(this.mapping_9.$index(0, node));
    },
    $isFunction: true
  },
  Selector_addForwardingElementArgumentsToList_closure: {
    "^": "Closure:13;",
    call$1: function(e) {
      return J.get$name$x(e);
    },
    $isFunction: true
  },
  Selector_getOrderedNamedArguments_closure: {
    "^": "Closure:310;",
    call$2: function(first, second) {
      return J.compareTo$1$ns(first, second);
    },
    $isFunction: true
  },
  TypedSelector: {
    "^": "Selector;asUntyped<,mask<,kind,name,library,argumentCount,namedArguments,_orderedNamedArguments,hashCode",
    appliesUnnamed$2: function(element, compiler) {
      if (!element.get$isClassMember())
        return false;
      if (element.get$enclosingClass().get$isClosure())
        return this.appliesUntyped$2(element, compiler);
      if (!this.mask.canHit$3(element, this, compiler))
        return false;
      return this.appliesUntyped$2(element, compiler);
    },
    extendIfReachesAll$1: function(compiler) {
      return compiler.enabledInvokeOn && this.mask.needsNoSuchMethodHandling$2(this, compiler) ? Z.TypedSelector_TypedSelector(compiler.typesTask.get$dynamicType(), this, compiler) : this;
    },
    TypedSelector$internal$3: function(mask, selector, hashCode) {
    },
    static: {"^": "TypedSelector_canonicalizedValues", TypedSelector_TypedSelector: function(mask, selector, compiler) {
        var untyped, map, t1, result, hashCode, t2, t3, t4, t5, t6, t7;
        if (J.$eq(selector.get$mask(), mask))
          return selector;
        untyped = selector.get$asUntyped();
        map = $.get$TypedSelector_canonicalizedValues().putIfAbsent$2(untyped, new Z.TypedSelector_TypedSelector_closure());
        t1 = J.getInterceptor$asx(map);
        result = t1.$index(map, mask);
        if (result == null) {
          hashCode = Z.Selector_mixHashCodeBits(untyped.hashCode, J.get$hashCode$(mask));
          t2 = untyped.kind;
          t3 = untyped.name;
          t4 = untyped.library;
          t5 = untyped.argumentCount;
          t6 = untyped.namedArguments;
          t7 = untyped._orderedNamedArguments;
          result = new Z.TypedSelector(untyped, mask, t2, t3, t4, t5, t6, t7, hashCode);
          result.Selector$internal$7(t2, t3, t4, t5, t6, t7, hashCode);
          result.TypedSelector$internal$3(mask, untyped, hashCode);
          t1.$indexSet(map, mask, result);
        }
        return result;
      }}
  },
  TypedSelector_TypedSelector_closure: {
    "^": "Closure:23;",
    call$0: function() {
      return P.LinkedHashMap_LinkedHashMap(null, null, null, B.TypeMask, Z.TypedSelector);
    },
    $isFunction: true
  }
}],
["uri_extras", "package:compiler/implementation/util/uri_extras.dart", , X, {
  "^": "",
  relativize: function(base, uri, isWindows) {
    var t1, t2, t3, t4, t5, uriParts, baseParts, $length, common, sb, i;
    t1 = base._path;
    if (!C.JSString_methods.startsWith$1(t1, "/"))
      throw H.wrapException(P.ArgumentError$("Expected absolute path: " + base.get$path(base)));
    t2 = uri._path;
    if (!C.JSString_methods.startsWith$1(t2, "/"))
      throw H.wrapException(P.ArgumentError$("Expected absolute path: " + uri.get$path(uri)));
    t3 = new X.relativize_equalsNCS();
    t4 = new X.relativize_normalize(isWindows);
    t5 = base.scheme;
    if (t3.call$2(t5, "file") === true)
      if (t3.call$2(t5, uri.scheme) === true)
        if (base._userInfo === uri._userInfo)
          if (t3.call$2(base.get$host(base), uri.get$host(uri)) === true) {
            t3 = base.get$port(base);
            t5 = uri.get$port(uri);
            if (t3 == null ? t5 == null : t3 === t5) {
              t3 = uri._query;
              if ((t3 == null ? "" : t3) === "") {
                t3 = uri._fragment;
                t3 = (t3 == null ? "" : t3) === "";
              } else
                t3 = false;
            } else
              t3 = false;
          } else
            t3 = false;
        else
          t3 = false;
      else
        t3 = false;
    else
      t3 = false;
    if (t3) {
      if (J.startsWith$1$s(t4.call$1(t2), t4.call$1(t1)))
        return C.JSString_methods.substring$1(t2, C.JSString_methods.lastIndexOf$1(t1, "/") + 1);
      uriParts = t2.split("/");
      baseParts = t1.split("/");
      $length = P.min(uriParts.length, baseParts.length);
      common = 0;
      while (true) {
        if (common < $length) {
          if (common >= uriParts.length)
            return H.ioore(uriParts, common);
          t1 = t4.call$1(uriParts[common]);
          if (common >= baseParts.length)
            return H.ioore(baseParts, common);
          t1 = J.$eq(t1, t4.call$1(baseParts[common]));
        } else
          t1 = false;
        if (!t1)
          break;
        ++common;
      }
      if (common !== 1)
        t1 = isWindows && common === 2;
      else
        t1 = true;
      if (t1)
        if (baseParts.length > common + 1)
          return t2;
      sb = P.StringBuffer$("");
      for (i = common + 1; i < baseParts.length; ++i)
        sb._contents += "../";
      for (i = common; i < uriParts.length - 1; ++i) {
        t1 = H.S(uriParts[i]) + "/";
        sb._contents += t1;
      }
      sb.write$1(H.S(C.JSArray_methods.get$last(uriParts)));
      return sb._contents;
    }
    return J.toString$0(uri);
  },
  relativize_equalsNCS: {
    "^": "Closure:311;",
    call$2: function(a, b) {
      var t1;
      a.toString;
      t1 = a.toLowerCase();
      b.toString;
      return t1 === b.toLowerCase();
    },
    $isFunction: true
  },
  relativize_normalize: {
    "^": "Closure:3;isWindows_0",
    call$1: function(path) {
      if (this.isWindows_0)
        return J.toLowerCase$0$s(path);
      else
        return path;
    },
    $isFunction: true
  }
}],
["util_implementation", "package:compiler/implementation/util/util_implementation.dart", , E, {
  "^": "",
  LinkIterator: {
    "^": "Object;_util_implementation$_current,_link",
    get$current: function() {
      return this._util_implementation$_current;
    },
    moveNext$0: function() {
      var t1 = this._link;
      if (t1.get$isEmpty(t1)) {
        this._util_implementation$_current = null;
        return false;
      }
      t1 = this._link;
      this._util_implementation$_current = t1.get$head(t1);
      this._link = this._link.get$tail();
      return true;
    }
  },
  MappedLinkIterator: {
    "^": "Iterator;_transformation,_link,_util_implementation$_current",
    _transformation$1: function(arg0) {
      return this._transformation.call$1(arg0);
    },
    get$current: function() {
      return this._util_implementation$_current;
    },
    moveNext$0: function() {
      var t1 = this._link;
      if (t1.get$isEmpty(t1)) {
        this._util_implementation$_current = null;
        return false;
      }
      t1 = this._link;
      this._util_implementation$_current = this._transformation$1(t1.get$head(t1));
      this._link = this._link.get$tail();
      return true;
    },
    $asIterator: function($S, $T) {
      return [$T];
    }
  },
  MappedLinkIterable: {
    "^": "IterableBase;_transformation,_link",
    get$iterator: function(_) {
      var t1 = new E.MappedLinkIterator(this._transformation, this._link, null);
      t1.$builtinTypeInfo = this.$builtinTypeInfo;
      return t1;
    },
    $asIterableBase: function($S, $T) {
      return [$T];
    },
    $asIterable: function($S, $T) {
      return [$T];
    }
  },
  LinkEntry: {
    "^": "Link;head>,tail@",
    prepend$1: function(element) {
      return E.LinkEntry$(element, this, H.getTypeArgumentByIndex(this, 0));
    },
    printOn$2: function(buffer, separatedBy) {
      var link, str;
      buffer.write$1(this.head);
      for (link = this.tail; !link.get$isEmpty(link); link = link.get$tail()) {
        buffer._contents += separatedBy;
        str = link.get$head(link);
        buffer._contents += typeof str === "string" ? str : H.S(str);
      }
    },
    toString$0: function(_) {
      var buffer = P.StringBuffer$("");
      buffer.write$1("[ ");
      this.printOn$2(buffer, ", ");
      buffer.write$1(" ]");
      return buffer._contents;
    },
    reverse$0: function() {
      var result, link;
      for (result = C.C_Link10, link = this; !link.get$isEmpty(link); link = link.get$tail())
        result = result.prepend$1(link.get$head(link));
      return result;
    },
    skip$1: function(_, n) {
      var link, i;
      if (typeof n !== "number")
        return H.iae(n);
      link = this;
      i = 0;
      for (; i < n; ++i) {
        if (link.get$isEmpty(link))
          throw H.wrapException(P.RangeError$("Index " + n + " out of range"));
        link = link.get$tail();
      }
      return link;
    },
    get$isEmpty: function(_) {
      return false;
    },
    forEach$1: function(_, f) {
      var link;
      for (link = this; !link.get$isEmpty(link); link = link.get$tail())
        f.call$1(link.get$head(link));
    },
    $eq: function(_, other) {
      var t1, myElements;
      if (other == null)
        return false;
      t1 = H.checkSubtype(other, "$isLink", [H.getTypeArgumentByIndex(this, 0)], "$asLink");
      if (!t1)
        return false;
      myElements = this;
      while (true) {
        if (!(!myElements.get$isEmpty(myElements) && !J.get$isEmpty$asx(other)))
          break;
        if (!J.$eq(myElements.get$head(myElements), J.get$head$x(other)))
          return false;
        myElements = myElements.get$tail();
        other = other.get$tail();
      }
      return myElements.get$isEmpty(myElements) && J.get$isEmpty$asx(other);
    },
    get$hashCode: function(_) {
      return H.throwExpression(P.UnsupportedError$("LinkEntry.hashCode"));
    },
    slowLength$0: function() {
      return 1 + this.tail.slowLength$0();
    },
    static: {LinkEntry$: function(head, tail, $T) {
        var t1 = tail == null ? H.setRuntimeTypeInfo(new O.Link(), [$T]) : tail;
        return H.setRuntimeTypeInfo(new E.LinkEntry(head, t1), [$T]);
      }}
  },
  LinkBuilderImplementation: {
    "^": "Object;head>,lastLink,length*",
    toLink$1: function(tail) {
      var t1 = this.head;
      if (t1 == null)
        return tail;
      this.lastLink.tail = tail;
      this.lastLink = null;
      this.head = null;
      return t1;
    },
    toLink$0: function() {
      return this.toLink$1(C.C_Link10);
    },
    toList$0: function(_) {
      var t1, list, link, index, t2;
      t1 = this.length;
      if (t1 === 0) {
        t1 = Array(0);
        t1.fixed$length = init;
        return H.setRuntimeTypeInfo(t1, [H.getTypeArgumentByIndex(this, 0)]);
      }
      t1 = Array(t1);
      t1.fixed$length = init;
      list = H.setRuntimeTypeInfo(t1, [H.getTypeArgumentByIndex(this, 0)]);
      link = this.head;
      for (t1 = list.length, index = 0; !link.get$isEmpty(link);) {
        t2 = link.get$head(link);
        if (index >= t1)
          return H.ioore(list, index);
        list[index] = t2;
        link = link.get$tail();
        ++index;
      }
      this.lastLink = null;
      this.head = null;
      return list;
    },
    addLast$1: function(t) {
      var entry;
      ++this.length;
      entry = E.LinkEntry$(t, null, H.getTypeArgumentByIndex(this, 0));
      if (this.head == null)
        this.head = entry;
      else
        this.lastLink.tail = entry;
      this.lastLink = entry;
    },
    get$isEmpty: function(_) {
      return this.length === 0;
    }
  }
}],
["visitor", "package:compiler/implementation/elements/visitor.dart", , O, {
  "^": "",
  ElementVisitor: {
    "^": "Object;",
    visitLibraryElement$1: function(e) {
      return this.visitElement$1(e);
    },
    visitTypedefElement$1: function(e) {
      return this.visitElement$1(e);
    },
    visitFieldElement$1: function(e) {
      return this.visitElement$1(e);
    },
    visitFunctionElement$1: function(e) {
      return this.visitElement$1(e);
    },
    visitConstructorBodyElement$1: function(e) {
      return this.visitElement$1(e);
    },
    visitClassElement$1: function(e) {
      return this.visitElement$1(e);
    }
  }
}],
]);
Isolate.$finishClasses($$, $, null);
$$ = null;

// Runtime type support
;(function() {
  var TRUE = !0, _;
  _ = W.Node1;
  _.$isNode1 = TRUE;
  _.$isObject = TRUE;
  _ = P.$int;
  _.$is$int = TRUE;
  _.$isnum = TRUE;
  _.$isComparable = TRUE;
  _.$asComparable = [P.num];
  _.$isObject = TRUE;
  _ = P.$double;
  _.$isnum = TRUE;
  _.$isComparable = TRUE;
  _.$asComparable = [P.num];
  _.$isObject = TRUE;
  W.Entry.$isObject = TRUE;
  _ = P.String;
  _.$isString = TRUE;
  _.$isPattern = TRUE;
  _.$isComparable = TRUE;
  _.$asComparable = [P.String];
  _.$isObject = TRUE;
  _ = P.num;
  _.$isnum = TRUE;
  _.$isComparable = TRUE;
  _.$asComparable = [P.num];
  _.$isObject = TRUE;
  _ = P.Duration;
  _.$isDuration = TRUE;
  _.$isComparable = TRUE;
  _.$asComparable = [P.Duration];
  _.$isObject = TRUE;
  P.Object.$isObject = TRUE;
  _ = P.List;
  _.$isList = TRUE;
  _.$isIterable = TRUE;
  _.$isObject = TRUE;
  _ = P.bool;
  _.$isbool = TRUE;
  _.$isObject = TRUE;
  _ = V.DartType;
  _.$isDartType = TRUE;
  _.$isObject = TRUE;
  _ = Q.Node0;
  _.$isNode0 = TRUE;
  _.$isObject = TRUE;
  _ = P.Match;
  _.$isMatch = TRUE;
  _.$isObject = TRUE;
  _ = L.ConcreteType;
  _.$isConcreteType = TRUE;
  _.$isObject = TRUE;
  L.ConcreteTypeSystem.$isObject = TRUE;
  A.ResolutionResult.$isObject = TRUE;
  _ = O.FunctionElement;
  _.$isFunctionElement = TRUE;
  _.$isElement = TRUE;
  _.$isTypedElement = TRUE;
  _.$isAstElement = TRUE;
  _.$isEntity = TRUE;
  _.$isSpannable = TRUE;
  _.$isElement = TRUE;
  _.$isAstElement = TRUE;
  _.$isTypedElement = TRUE;
  _.$isEntity = TRUE;
  _.$isSpannable = TRUE;
  _.$isElement = TRUE;
  _.$isEntity = TRUE;
  _.$isSpannable = TRUE;
  _.$isElement = TRUE;
  _.$isEntity = TRUE;
  _.$isSpannable = TRUE;
  _.$isElement = TRUE;
  _.$isEntity = TRUE;
  _.$isSpannable = TRUE;
  _.$isElement = TRUE;
  _.$isEntity = TRUE;
  _.$isSpannable = TRUE;
  _.$isElement = TRUE;
  _.$isEntity = TRUE;
  _.$isSpannable = TRUE;
  _.$isObject = TRUE;
  _ = U.FormalElementX;
  _.$isFormalElement = TRUE;
  _.$isElement = TRUE;
  _.$isEntity = TRUE;
  _.$isSpannable = TRUE;
  _.$isAstElement = TRUE;
  _.$isElement = TRUE;
  _.$isEntity = TRUE;
  _.$isSpannable = TRUE;
  _.$isElement = TRUE;
  _.$isAstElement = TRUE;
  _.$isTypedElement = TRUE;
  _.$isEntity = TRUE;
  _.$isSpannable = TRUE;
  _.$isElement = TRUE;
  _.$isEntity = TRUE;
  _.$isSpannable = TRUE;
  _.$isElement = TRUE;
  _.$isEntity = TRUE;
  _.$isSpannable = TRUE;
  _.$isElement = TRUE;
  _.$isEntity = TRUE;
  _.$isSpannable = TRUE;
  _.$isObject = TRUE;
  _ = Q.Expression;
  _.$isExpression = TRUE;
  _.$isNode0 = TRUE;
  _.$isObject = TRUE;
  _ = P.Map;
  _.$isMap = TRUE;
  _.$isObject = TRUE;
  _ = Y.Identifier;
  _.$isIdentifier = TRUE;
  _.$isExpression2 = TRUE;
  _.$isNode = TRUE;
  _.$isSpannable = TRUE;
  _.$isSpannable = TRUE;
  _.$isObject = TRUE;
  _ = O.Element;
  _.$isElement = TRUE;
  _.$isEntity = TRUE;
  _.$isSpannable = TRUE;
  _.$isObject = TRUE;
  _ = O.ParameterElement;
  _.$isParameterElement = TRUE;
  _.$isElement = TRUE;
  _.$isLocalElement = TRUE;
  _.$isFormalElement = TRUE;
  _.$isVariableElement = TRUE;
  _.$isEntity = TRUE;
  _.$isSpannable = TRUE;
  _.$isElement = TRUE;
  _.$isLocal = TRUE;
  _.$isTypedElement = TRUE;
  _.$isEntity = TRUE;
  _.$isSpannable = TRUE;
  _.$isEntity = TRUE;
  _.$isSpannable = TRUE;
  _.$isElement = TRUE;
  _.$isEntity = TRUE;
  _.$isSpannable = TRUE;
  _.$isElement = TRUE;
  _.$isAstElement = TRUE;
  _.$isTypedElement = TRUE;
  _.$isEntity = TRUE;
  _.$isSpannable = TRUE;
  _.$isElement = TRUE;
  _.$isEntity = TRUE;
  _.$isSpannable = TRUE;
  _.$isElement = TRUE;
  _.$isEntity = TRUE;
  _.$isSpannable = TRUE;
  _.$isElement = TRUE;
  _.$isEntity = TRUE;
  _.$isSpannable = TRUE;
  _.$isElement = TRUE;
  _.$isAstElement = TRUE;
  _.$isTypedElement = TRUE;
  _.$isEntity = TRUE;
  _.$isSpannable = TRUE;
  _.$isElement = TRUE;
  _.$isEntity = TRUE;
  _.$isSpannable = TRUE;
  _.$isElement = TRUE;
  _.$isEntity = TRUE;
  _.$isSpannable = TRUE;
  _.$isObject = TRUE;
  _ = Y.DartString;
  _.$isIterable = TRUE;
  _.$asIterable = [P.$int];
  _.$isObject = TRUE;
  _ = V.TypedefType;
  _.$isGenericType = TRUE;
  _.$isDartType = TRUE;
  _.$isObject = TRUE;
  _ = O.ClassElement;
  _.$isClassElement = TRUE;
  _.$isScopeContainerElement = TRUE;
  _.$isElement = TRUE;
  _.$isAstElement = TRUE;
  _.$isEntity = TRUE;
  _.$isSpannable = TRUE;
  _.$isElement = TRUE;
  _.$isEntity = TRUE;
  _.$isSpannable = TRUE;
  _.$isElement = TRUE;
  _.$isEntity = TRUE;
  _.$isSpannable = TRUE;
  _.$isObject = TRUE;
  _ = V.InterfaceType;
  _.$isInterfaceType = TRUE;
  _.$isGenericType = TRUE;
  _.$isDartType = TRUE;
  _.$isObject = TRUE;
  M.Node2.$isObject = TRUE;
  M.Statement0.$isObject = TRUE;
  _ = M.Expression0;
  _.$isExpression0 = TRUE;
  _.$isObject = TRUE;
  _ = F.Expression1;
  _.$isExpression1 = TRUE;
  _.$isArgument = TRUE;
  _.$isObject = TRUE;
  _ = G.TypeInformation;
  _.$isTypeInformation = TRUE;
  _.$isObject = TRUE;
  G.TypeInformationSystem.$isObject = TRUE;
  Q.InferrerEngine.$isObject = TRUE;
  X.TypeSystem.$isObject = TRUE;
  L.ConcreteTypesEnvironment.$isObject = TRUE;
  _ = G.ApplyableTypeInformation;
  _.$isTypeInformation = TRUE;
  _.$isObject = TRUE;
  _ = G.MapTypeInformation;
  _.$isMapTypeInformation = TRUE;
  _.$isTypeInformation = TRUE;
  _.$isObject = TRUE;
  _ = G.ListTypeInformation;
  _.$isListTypeInformation = TRUE;
  _.$isTypeInformation = TRUE;
  _.$isObject = TRUE;
  _ = B.TypeMask;
  _.$isTypeMask = TRUE;
  _.$isObject = TRUE;
  _ = D.Primitive;
  _.$isPrimitive = TRUE;
  _.$isDefinition = TRUE;
  _.$isNode4 = TRUE;
  _.$isObject = TRUE;
  _ = M.ConstExp;
  _.$isConstExp = TRUE;
  _.$isObject = TRUE;
  B.SsaBuilder.$isObject = TRUE;
  _ = U.LibraryElementX;
  _.$isLibraryElement = TRUE;
  _.$isElement = TRUE;
  _.$isEntity = TRUE;
  _.$isSpannable = TRUE;
  _.$isElement = TRUE;
  _.$isEntity = TRUE;
  _.$isSpannable = TRUE;
  _.$isElement = TRUE;
  _.$isEntity = TRUE;
  _.$isSpannable = TRUE;
  _.$isElement = TRUE;
  _.$isScopeContainerElement = TRUE;
  _.$isEntity = TRUE;
  _.$isSpannable = TRUE;
  _.$isElement = TRUE;
  _.$isEntity = TRUE;
  _.$isSpannable = TRUE;
  _.$isElement = TRUE;
  _.$isEntity = TRUE;
  _.$isSpannable = TRUE;
  _.$isObject = TRUE;
  K.TokenKey.$isObject = TRUE;
  _ = Y.Token;
  _.$isToken = TRUE;
  _.$isSpannable = TRUE;
  _.$isObject = TRUE;
  _ = P.Uri;
  _.$isUri = TRUE;
  _.$isObject = TRUE;
  _ = K.SuppressionInfo;
  _.$isSuppressionInfo = TRUE;
  _.$isObject = TRUE;
  Z.Dependency.$isObject = TRUE;
  K.CompilerTask.$isObject = TRUE;
  _ = Z.SideEffects;
  _.$isSideEffects = TRUE;
  _.$isObject = TRUE;
  _ = O.TypedefElement;
  _.$isTypedefElement = TRUE;
  _.$isElement = TRUE;
  _.$isAstElement = TRUE;
  _.$isEntity = TRUE;
  _.$isSpannable = TRUE;
  _.$isElement = TRUE;
  _.$isEntity = TRUE;
  _.$isSpannable = TRUE;
  _.$isElement = TRUE;
  _.$isAstElement = TRUE;
  _.$isEntity = TRUE;
  _.$isSpannable = TRUE;
  _.$isElement = TRUE;
  _.$isEntity = TRUE;
  _.$isSpannable = TRUE;
  _.$isElement = TRUE;
  _.$isEntity = TRUE;
  _.$isSpannable = TRUE;
  _.$isObject = TRUE;
  _ = P.Set;
  _.$isSet = TRUE;
  _.$isIterable = TRUE;
  _.$isObject = TRUE;
  _ = O.MixinApplicationElement;
  _.$isMixinApplicationElement = TRUE;
  _.$isClassElement = TRUE;
  _.$isScopeContainerElement = TRUE;
  _.$isElement = TRUE;
  _.$isAstElement = TRUE;
  _.$isEntity = TRUE;
  _.$isSpannable = TRUE;
  _.$isElement = TRUE;
  _.$isEntity = TRUE;
  _.$isSpannable = TRUE;
  _.$isElement = TRUE;
  _.$isEntity = TRUE;
  _.$isSpannable = TRUE;
  _.$isObject = TRUE;
  _ = Z.FunctionSetNode;
  _.$isFunctionSetNode = TRUE;
  _.$isObject = TRUE;
  Z.CheckedModeHelper.$isObject = TRUE;
  _ = V.FunctionType;
  _.$isFunctionType = TRUE;
  _.$isDartType = TRUE;
  _.$isObject = TRUE;
  _ = O.LibraryElement;
  _.$isLibraryElement = TRUE;
  _.$isElement = TRUE;
  _.$isScopeContainerElement = TRUE;
  _.$isEntity = TRUE;
  _.$isSpannable = TRUE;
  _.$isElement = TRUE;
  _.$isEntity = TRUE;
  _.$isSpannable = TRUE;
  _.$isElement = TRUE;
  _.$isEntity = TRUE;
  _.$isSpannable = TRUE;
  _.$isObject = TRUE;
  _ = K.Constant;
  _.$isConstant = TRUE;
  _.$isObject = TRUE;
  _ = Z.Selector;
  _.$isSelector = TRUE;
  _.$isObject = TRUE;
  _ = Y.ClassNode;
  _.$isNode = TRUE;
  _.$isSpannable = TRUE;
  _.$isSpannable = TRUE;
  _.$isObject = TRUE;
  _ = Y.Node;
  _.$isNode = TRUE;
  _.$isSpannable = TRUE;
  _.$isSpannable = TRUE;
  _.$isObject = TRUE;
  _ = O.VariableElement;
  _.$isVariableElement = TRUE;
  _.$isElement = TRUE;
  _.$isAstElement = TRUE;
  _.$isTypedElement = TRUE;
  _.$isEntity = TRUE;
  _.$isSpannable = TRUE;
  _.$isElement = TRUE;
  _.$isEntity = TRUE;
  _.$isSpannable = TRUE;
  _.$isElement = TRUE;
  _.$isEntity = TRUE;
  _.$isSpannable = TRUE;
  _.$isObject = TRUE;
  Q.ClosureClassMap.$isObject = TRUE;
  _ = D.FunctionDefinition;
  _.$isNode4 = TRUE;
  _.$isNode4 = TRUE;
  _.$isObject = TRUE;
  _ = Y.Import;
  _.$isImport = TRUE;
  _.$isLibraryDependency = TRUE;
  _.$isLibraryTag = TRUE;
  _.$isNode = TRUE;
  _.$isSpannable = TRUE;
  _.$isSpannable = TRUE;
  _.$isObject = TRUE;
  _ = B.OutputUnit;
  _.$isOutputUnit = TRUE;
  _.$isObject = TRUE;
  _ = O.Link;
  _.$isLink = TRUE;
  _.$isObject = TRUE;
  _ = O.LocalFunctionElement;
  _.$isFunctionElement = TRUE;
  _.$isLocalElement = TRUE;
  _.$isElement = TRUE;
  _.$isTypedElement = TRUE;
  _.$isAstElement = TRUE;
  _.$isEntity = TRUE;
  _.$isSpannable = TRUE;
  _.$isElement = TRUE;
  _.$isAstElement = TRUE;
  _.$isTypedElement = TRUE;
  _.$isEntity = TRUE;
  _.$isSpannable = TRUE;
  _.$isElement = TRUE;
  _.$isEntity = TRUE;
  _.$isSpannable = TRUE;
  _.$isElement = TRUE;
  _.$isEntity = TRUE;
  _.$isSpannable = TRUE;
  _.$isElement = TRUE;
  _.$isEntity = TRUE;
  _.$isSpannable = TRUE;
  _.$isElement = TRUE;
  _.$isEntity = TRUE;
  _.$isSpannable = TRUE;
  _.$isElement = TRUE;
  _.$isEntity = TRUE;
  _.$isSpannable = TRUE;
  _.$isElement = TRUE;
  _.$isLocal = TRUE;
  _.$isTypedElement = TRUE;
  _.$isEntity = TRUE;
  _.$isSpannable = TRUE;
  _.$isEntity = TRUE;
  _.$isSpannable = TRUE;
  _.$isElement = TRUE;
  _.$isEntity = TRUE;
  _.$isSpannable = TRUE;
  _.$isObject = TRUE;
  _ = O.AstElement;
  _.$isAstElement = TRUE;
  _.$isElement = TRUE;
  _.$isEntity = TRUE;
  _.$isSpannable = TRUE;
  _.$isObject = TRUE;
  _ = K.ResolutionWorkItem;
  _.$isWorkItem = TRUE;
  _.$isObject = TRUE;
  K.DeferredTask.$isObject = TRUE;
  _ = K.CodegenWorkItem;
  _.$isCodegenWorkItem = TRUE;
  _.$isWorkItem = TRUE;
  _.$isObject = TRUE;
  L.NativeBehavior.$isObject = TRUE;
  _ = Q.InterpolatedNode;
  _.$isNode0 = TRUE;
  _.$isObject = TRUE;
  Q.Template.$isObject = TRUE;
  _ = Q.ArrayElement;
  _.$isArrayElement = TRUE;
  _.$isNode0 = TRUE;
  _.$isObject = TRUE;
  _ = Q.Property;
  _.$isProperty = TRUE;
  _.$isNode0 = TRUE;
  _.$isObject = TRUE;
  _ = Q.Parameter;
  _.$isParameter = TRUE;
  _.$isExpression = TRUE;
  _.$isNode0 = TRUE;
  _.$isObject = TRUE;
  _ = Q.Statement;
  _.$isStatement = TRUE;
  _.$isNode0 = TRUE;
  _.$isObject = TRUE;
  _ = Q.VariableInitialization;
  _.$isExpression = TRUE;
  _.$isNode0 = TRUE;
  _.$isObject = TRUE;
  _ = O.Name;
  _.$isName = TRUE;
  _.$isObject = TRUE;
  _ = B.HInstruction;
  _.$isHInstruction = TRUE;
  _.$isSpannable = TRUE;
  _.$isObject = TRUE;
  L.ClosureEnvironment.$isObject = TRUE;
  _ = L.InferenceWorkItem;
  _.$isInferenceWorkItem = TRUE;
  _.$isObject = TRUE;
  _ = O.Local;
  _.$isLocal = TRUE;
  _.$isEntity = TRUE;
  _.$isSpannable = TRUE;
  _.$isObject = TRUE;
  K.CodeBufferMarker.$isObject = TRUE;
  _ = K.CodeBuffer;
  _.$isCodeBuffer = TRUE;
  _.$isObject = TRUE;
  _ = O.TypeVariableElement;
  _.$isElement = TRUE;
  _.$isTypedElement = TRUE;
  _.$isAstElement = TRUE;
  _.$isEntity = TRUE;
  _.$isSpannable = TRUE;
  _.$isElement = TRUE;
  _.$isEntity = TRUE;
  _.$isSpannable = TRUE;
  _.$isElement = TRUE;
  _.$isEntity = TRUE;
  _.$isSpannable = TRUE;
  _.$isObject = TRUE;
  K.ClassBuilder.$isObject = TRUE;
  _ = B.Range;
  _.$isRange = TRUE;
  _.$isObject = TRUE;
  _ = O.MetadataAnnotation;
  _.$isMetadataAnnotation = TRUE;
  _.$isSpannable = TRUE;
  _.$isObject = TRUE;
  K.TypePromotion.$isObject = TRUE;
  K.TypePromotionMessage.$isObject = TRUE;
  _ = O.LabelDefinition;
  _.$isLabelDefinition = TRUE;
  _.$isEntity = TRUE;
  _.$isSpannable = TRUE;
  _.$isObject = TRUE;
  _ = O.JumpTarget;
  _.$isJumpTarget = TRUE;
  _.$isLocal = TRUE;
  _.$isEntity = TRUE;
  _.$isSpannable = TRUE;
  _.$isObject = TRUE;
  _ = O.Spannable;
  _.$isSpannable = TRUE;
  _.$isObject = TRUE;
  _ = Z.FunctionSetQuery;
  _.$isFunctionSetQuery = TRUE;
  _.$isObject = TRUE;
  _ = Z.TypedSelector;
  _.$isSelector = TRUE;
  _.$isObject = TRUE;
  E.Selection.$isObject = TRUE;
  _ = B.FlatTypeMask;
  _.$isTypeMask = TRUE;
  _.$isObject = TRUE;
  _ = T.SourceMapEntry;
  _.$isSourceMapEntry = TRUE;
  _.$isObject = TRUE;
  Z.TypeCheck.$isObject = TRUE;
  G.DeclarationTypePlaceholder.$isObject = TRUE;
  G.ConstructorPlaceholder.$isObject = TRUE;
  _ = G.ElementAst;
  _.$isElementAst = TRUE;
  _.$isObject = TRUE;
  G.FunctionScope.$isObject = TRUE;
  _ = O.Entity;
  _.$isEntity = TRUE;
  _.$isSpannable = TRUE;
  _.$isObject = TRUE;
  _ = Y.StringQuoting;
  _.$isStringQuoting = TRUE;
  _.$isObject = TRUE;
  _ = G.LocalPlaceholder;
  _.$isLocalPlaceholder = TRUE;
  _.$isObject = TRUE;
  _ = V.TypeVariableType;
  _.$isTypeVariableType = TRUE;
  _.$isDartType = TRUE;
  _.$isObject = TRUE;
  _ = Y.Send;
  _.$isSend = TRUE;
  _.$isExpression2 = TRUE;
  _.$isNode = TRUE;
  _.$isSpannable = TRUE;
  _.$isSpannable = TRUE;
  _.$isObject = TRUE;
  _ = Y.StringInterpolationPart;
  _.$isNode = TRUE;
  _.$isSpannable = TRUE;
  _.$isSpannable = TRUE;
  _.$isObject = TRUE;
  _ = Y.GotoStatement;
  _.$isNode = TRUE;
  _.$isSpannable = TRUE;
  _.$isSpannable = TRUE;
  _.$isObject = TRUE;
  _ = Y.Label;
  _.$isNode = TRUE;
  _.$isSpannable = TRUE;
  _.$isSpannable = TRUE;
  _.$isObject = TRUE;
  _ = E.LinkEntry;
  _.$isLink = TRUE;
  _.$isObject = TRUE;
  _ = O.Member;
  _.$isMember = TRUE;
  _.$isMemberSignature = TRUE;
  _.$isObject = TRUE;
  _ = O.MemberSignature;
  _.$isMemberSignature = TRUE;
  _.$isObject = TRUE;
  _ = K.MessageKind;
  _.$isMessageKind = TRUE;
  _.$isObject = TRUE;
  _ = N.Setlet;
  _.$isSetlet = TRUE;
  _.$isSet = TRUE;
  _.$isIterable = TRUE;
  _.$isIterable = TRUE;
  _.$isObject = TRUE;
  _ = Y.BeginGroupToken;
  _.$isToken = TRUE;
  _.$isSpannable = TRUE;
  _.$isObject = TRUE;
  Y.Keyword.$isObject = TRUE;
  _ = Y.KeywordState;
  _.$isKeywordState = TRUE;
  _.$isObject = TRUE;
  _ = G.Renamable;
  _.$isComparable = TRUE;
  _.$asComparable = [null];
  _.$isObject = TRUE;
  _ = F.VariableDeclaration0;
  _.$isVariableDeclaration0 = TRUE;
  _.$isObject = TRUE;
  _ = F.Statement1;
  _.$isStatement1 = TRUE;
  _.$isObject = TRUE;
  _ = D.Continuation;
  _.$isDefinition = TRUE;
  _.$isNode4 = TRUE;
  _.$isNode4 = TRUE;
  _.$isObject = TRUE;
  _ = D.InvokeContinuation;
  _.$isExpression3 = TRUE;
  _.$isNode4 = TRUE;
  _.$isObject = TRUE;
  _ = D.Reference;
  _.$isReference = TRUE;
  _.$isObject = TRUE;
  D.RegisterArray.$isObject = TRUE;
  _ = M.Variable;
  _.$isVariable = TRUE;
  _.$isExpression0 = TRUE;
  _.$isObject = TRUE;
  M.Label0.$isObject = TRUE;
  M.Jump.$isObject = TRUE;
  M.Assign.$isObject = TRUE;
  F.OpenStringChunk.$isObject = TRUE;
  _ = F.TypeAnnotation0;
  _.$isTypeAnnotation0 = TRUE;
  _.$isObject = TRUE;
  _ = F.LiteralMapEntry0;
  _.$isLiteralMapEntry0 = TRUE;
  _.$isObject = TRUE;
  _ = F.Parameter0;
  _.$isParameter0 = TRUE;
  _.$isObject = TRUE;
  X._ReductionTask.$isObject = TRUE;
  _ = Z.Block2;
  _.$isBlock2 = TRUE;
  _.$isObject = TRUE;
  S.Block3.$isObject = TRUE;
  _ = G.CallSiteTypeInformation;
  _.$isTypeInformation = TRUE;
  _.$isObject = TRUE;
  _ = L.BaseType;
  _.$isBaseType = TRUE;
  _.$isObject = TRUE;
  _ = X.LocalsHandler;
  _.$isLocalsHandler = TRUE;
  _.$isObject = TRUE;
  P.Iterator.$isObject = TRUE;
  _ = Y.Expression2;
  _.$isExpression2 = TRUE;
  _.$isNode = TRUE;
  _.$isSpannable = TRUE;
  _.$isSpannable = TRUE;
  _.$isObject = TRUE;
  _ = Q.BoxFieldElement;
  _.$isBoxFieldElement = TRUE;
  _.$isCapturedVariable = TRUE;
  _.$isTypedElement = TRUE;
  _.$isElement = TRUE;
  _.$isEntity = TRUE;
  _.$isSpannable = TRUE;
  _.$isElement = TRUE;
  _.$isEntity = TRUE;
  _.$isSpannable = TRUE;
  _.$isObject = TRUE;
  _ = O.LocalVariableElement;
  _.$isLocalVariableElement = TRUE;
  _.$isVariableElement = TRUE;
  _.$isLocalElement = TRUE;
  _.$isElement = TRUE;
  _.$isAstElement = TRUE;
  _.$isTypedElement = TRUE;
  _.$isEntity = TRUE;
  _.$isSpannable = TRUE;
  _.$isElement = TRUE;
  _.$isEntity = TRUE;
  _.$isSpannable = TRUE;
  _.$isElement = TRUE;
  _.$isEntity = TRUE;
  _.$isSpannable = TRUE;
  _.$isElement = TRUE;
  _.$isLocal = TRUE;
  _.$isTypedElement = TRUE;
  _.$isEntity = TRUE;
  _.$isSpannable = TRUE;
  _.$isEntity = TRUE;
  _.$isSpannable = TRUE;
  _.$isElement = TRUE;
  _.$isEntity = TRUE;
  _.$isSpannable = TRUE;
  _.$isObject = TRUE;
  _ = Q.CapturedVariable;
  _.$isCapturedVariable = TRUE;
  _.$isObject = TRUE;
  _ = Q.ClosureFieldElement;
  _.$isClosureFieldElement = TRUE;
  _.$isCapturedVariable = TRUE;
  _.$isVariableElement = TRUE;
  _.$isElement = TRUE;
  _.$isEntity = TRUE;
  _.$isSpannable = TRUE;
  _.$isElement = TRUE;
  _.$isAstElement = TRUE;
  _.$isTypedElement = TRUE;
  _.$isEntity = TRUE;
  _.$isSpannable = TRUE;
  _.$isElement = TRUE;
  _.$isEntity = TRUE;
  _.$isSpannable = TRUE;
  _.$isElement = TRUE;
  _.$isEntity = TRUE;
  _.$isSpannable = TRUE;
  _.$isObject = TRUE;
  _ = Q.ClosureScope;
  _.$isClosureScope = TRUE;
  _.$isObject = TRUE;
  _ = Q.BoxLocal;
  _.$isLocal = TRUE;
  _.$isEntity = TRUE;
  _.$isSpannable = TRUE;
  _.$isObject = TRUE;
  _ = D.Parameter1;
  _.$isParameter1 = TRUE;
  _.$isPrimitive = TRUE;
  _.$isDefinition = TRUE;
  _.$isNode4 = TRUE;
  _.$isObject = TRUE;
  K.JumpCollector.$isObject = TRUE;
  M.ConstDeclaration.$isObject = TRUE;
  _ = F.Argument;
  _.$isArgument = TRUE;
  _.$isObject = TRUE;
  K.Environment.$isObject = TRUE;
  _ = B.HBasicBlock;
  _.$isHBasicBlock = TRUE;
  _.$isObject = TRUE;
  _ = B.LiveEnvironment;
  _.$isLiveEnvironment = TRUE;
  _.$isObject = TRUE;
  B.LiveInterval.$isObject = TRUE;
  B.CopyHandler.$isObject = TRUE;
  _ = B.Copy;
  _.$isCopy = TRUE;
  _.$isObject = TRUE;
  _ = B.LiveRange;
  _.$isLiveRange = TRUE;
  _.$isObject = TRUE;
  _ = Q.Block;
  _.$isStatement = TRUE;
  _.$isNode0 = TRUE;
  _.$isObject = TRUE;
  _ = B.HRangeConversion;
  _.$isHRangeConversion = TRUE;
  _.$isHInstruction = TRUE;
  _.$isSpannable = TRUE;
  _.$isObject = TRUE;
  B.OptimizationPhase.$isObject = TRUE;
  _ = P.Function;
  _.$isFunction = TRUE;
  _.$isObject = TRUE;
  B.GvnWorkItem.$isObject = TRUE;
  _ = B.HPhi;
  _.$isHPhi = TRUE;
  _.$isHInstruction = TRUE;
  _.$isSpannable = TRUE;
  _.$isObject = TRUE;
  B.ValueSet.$isObject = TRUE;
  B.MemorySet.$isObject = TRUE;
  B.AstInliningState.$isObject = TRUE;
  _ = B.HConstant;
  _.$isHConstant = TRUE;
  _.$isHInstruction = TRUE;
  _.$isSpannable = TRUE;
  _.$isObject = TRUE;
  B.JumpHandler.$isObject = TRUE;
  _ = B.HLocalValue;
  _.$isHInstruction = TRUE;
  _.$isSpannable = TRUE;
  _.$isObject = TRUE;
  _ = Q.TypeVariableLocal;
  _.$isLocal = TRUE;
  _.$isEntity = TRUE;
  _.$isSpannable = TRUE;
  _.$isObject = TRUE;
  _ = B.HCheck;
  _.$isHInstruction = TRUE;
  _.$isSpannable = TRUE;
  _.$isObject = TRUE;
  _ = Y.SwitchCase;
  _.$isSwitchCase = TRUE;
  _.$isNode = TRUE;
  _.$isSpannable = TRUE;
  _.$isSpannable = TRUE;
  _.$isObject = TRUE;
  B.HStatementInformation.$isObject = TRUE;
  _ = B.LocalsHandler0;
  _.$isLocalsHandler0 = TRUE;
  _.$isObject = TRUE;
  _ = Y.CaseMatch;
  _.$isCaseMatch = TRUE;
  _.$isNode = TRUE;
  _.$isSpannable = TRUE;
  _.$isSpannable = TRUE;
  _.$isObject = TRUE;
  _ = Q.SwitchClause;
  _.$isNode0 = TRUE;
  _.$isObject = TRUE;
  B.JumpHandlerEntry.$isObject = TRUE;
  _ = Q.Assignment;
  _.$isExpression = TRUE;
  _.$isNode0 = TRUE;
  _.$isObject = TRUE;
  _ = F.MirrorUsage;
  _.$isMirrorUsage = TRUE;
  _.$isObject = TRUE;
  _ = Z.LibraryDependencyNode;
  _.$isLibraryDependencyNode = TRUE;
  _.$isObject = TRUE;
  _ = Y.LibraryDependency;
  _.$isLibraryDependency = TRUE;
  _.$isLibraryTag = TRUE;
  _.$isNode = TRUE;
  _.$isSpannable = TRUE;
  _.$isSpannable = TRUE;
  _.$isObject = TRUE;
  _ = O.CompilationUnitElement;
  _.$isElement = TRUE;
  _.$isEntity = TRUE;
  _.$isSpannable = TRUE;
  _.$isObject = TRUE;
  Z.ImportLink.$isObject = TRUE;
  Z.ExportLink.$isObject = TRUE;
  _ = Y.Export;
  _.$isExport = TRUE;
  _.$isLibraryDependency = TRUE;
  _.$isLibraryTag = TRUE;
  _.$isNode = TRUE;
  _.$isSpannable = TRUE;
  _.$isSpannable = TRUE;
  _.$isObject = TRUE;
  W.HttpRequest.$isObject = TRUE;
  _ = W.ProgressEvent;
  _.$isEvent = TRUE;
  _.$isObject = TRUE;
  _ = P.Future;
  _.$isFuture = TRUE;
  _.$isObject = TRUE;
  H.RawReceivePortImpl.$isObject = TRUE;
  H._IsolateEvent.$isObject = TRUE;
  H._IsolateContext.$isObject = TRUE;
  _ = P.Symbol;
  _.$isSymbol = TRUE;
  _.$isObject = TRUE;
  _ = P.StackTrace;
  _.$isStackTrace = TRUE;
  _.$isObject = TRUE;
  _ = D.Diagnostic;
  _.$isDiagnostic = TRUE;
  _.$isObject = TRUE;
  _ = Q.InterpolatedExpression;
  _.$isInterpolatedExpression = TRUE;
  _.$isExpression = TRUE;
  _.$isNode0 = TRUE;
  _.$isNode0 = TRUE;
  _.$isObject = TRUE;
  _ = O.ScopeContainerElement;
  _.$isScopeContainerElement = TRUE;
  _.$isElement = TRUE;
  _.$isEntity = TRUE;
  _.$isSpannable = TRUE;
  _.$isObject = TRUE;
  _ = K.WorkItem;
  _.$isWorkItem = TRUE;
  _.$isObject = TRUE;
  _ = P.Iterable;
  _.$isIterable = TRUE;
  _.$isObject = TRUE;
  _ = Q.Fun;
  _.$isFun = TRUE;
  _.$isExpression = TRUE;
  _.$isNode0 = TRUE;
  _.$isObject = TRUE;
  _ = Y.Parser;
  _.$isParser = TRUE;
  _.$isObject = TRUE;
  _ = Y.FunctionExpression;
  _.$isFunctionExpression = TRUE;
  _.$isExpression2 = TRUE;
  _.$isNode = TRUE;
  _.$isSpannable = TRUE;
  _.$isSpannable = TRUE;
  _.$isObject = TRUE;
  _ = K.ElementAccess;
  _.$isElementAccess = TRUE;
  _.$isObject = TRUE;
  _ = U.VariableList;
  _.$isVariableList = TRUE;
  _.$isObject = TRUE;
  _ = A.DeclaredMember;
  _.$isDeclaredMember = TRUE;
  _.$isMember = TRUE;
  _.$isMemberSignature = TRUE;
  _.$isObject = TRUE;
  _ = F.StringChunk;
  _.$isStringChunk = TRUE;
  _.$isObject = TRUE;
  _ = D.Definition;
  _.$isDefinition = TRUE;
  _.$isNode4 = TRUE;
  _.$isObject = TRUE;
  _ = O.FieldElement;
  _.$isFieldElement = TRUE;
  _.$isVariableElement = TRUE;
  _.$isElement = TRUE;
  _.$isAstElement = TRUE;
  _.$isTypedElement = TRUE;
  _.$isEntity = TRUE;
  _.$isSpannable = TRUE;
  _.$isElement = TRUE;
  _.$isEntity = TRUE;
  _.$isSpannable = TRUE;
  _.$isElement = TRUE;
  _.$isEntity = TRUE;
  _.$isSpannable = TRUE;
  _.$isElement = TRUE;
  _.$isEntity = TRUE;
  _.$isSpannable = TRUE;
  _.$isElement = TRUE;
  _.$isAstElement = TRUE;
  _.$isTypedElement = TRUE;
  _.$isEntity = TRUE;
  _.$isSpannable = TRUE;
  _.$isElement = TRUE;
  _.$isEntity = TRUE;
  _.$isSpannable = TRUE;
  _.$isElement = TRUE;
  _.$isEntity = TRUE;
  _.$isSpannable = TRUE;
  _.$isObject = TRUE;
  _ = G.ClosureTracerVisitor;
  _.$isClosureTracerVisitor = TRUE;
  _.$isObject = TRUE;
  _ = Y.LiteralMapEntry;
  _.$isLiteralMapEntry = TRUE;
  _.$isNode = TRUE;
  _.$isSpannable = TRUE;
  _.$isSpannable = TRUE;
  _.$isObject = TRUE;
  _ = O.TypedElement;
  _.$isTypedElement = TRUE;
  _.$isElement = TRUE;
  _.$isEntity = TRUE;
  _.$isSpannable = TRUE;
  _.$isObject = TRUE;
  _ = O.ConstructorElement;
  _.$isConstructorElement = TRUE;
  _.$isFunctionElement = TRUE;
  _.$isElement = TRUE;
  _.$isTypedElement = TRUE;
  _.$isAstElement = TRUE;
  _.$isEntity = TRUE;
  _.$isSpannable = TRUE;
  _.$isElement = TRUE;
  _.$isAstElement = TRUE;
  _.$isTypedElement = TRUE;
  _.$isEntity = TRUE;
  _.$isSpannable = TRUE;
  _.$isElement = TRUE;
  _.$isEntity = TRUE;
  _.$isSpannable = TRUE;
  _.$isElement = TRUE;
  _.$isEntity = TRUE;
  _.$isSpannable = TRUE;
  _.$isElement = TRUE;
  _.$isEntity = TRUE;
  _.$isSpannable = TRUE;
  _.$isElement = TRUE;
  _.$isEntity = TRUE;
  _.$isSpannable = TRUE;
  _.$isElement = TRUE;
  _.$isEntity = TRUE;
  _.$isSpannable = TRUE;
  _.$isElement = TRUE;
  _.$isEntity = TRUE;
  _.$isSpannable = TRUE;
  _.$isElement = TRUE;
  _.$isAstElement = TRUE;
  _.$isTypedElement = TRUE;
  _.$isEntity = TRUE;
  _.$isSpannable = TRUE;
  _.$isElement = TRUE;
  _.$isEntity = TRUE;
  _.$isSpannable = TRUE;
  _.$isElement = TRUE;
  _.$isEntity = TRUE;
  _.$isSpannable = TRUE;
  _.$isObject = TRUE;
  _ = K.StringConstant;
  _.$isStringConstant = TRUE;
  _.$isConstant = TRUE;
  _.$isObject = TRUE;
  _ = Y.CatchBlock;
  _.$isCatchBlock = TRUE;
  _.$isNode = TRUE;
  _.$isSpannable = TRUE;
  _.$isSpannable = TRUE;
  _.$isObject = TRUE;
  _ = B.HBreak;
  _.$isHBreak = TRUE;
  _.$isHControlFlow = TRUE;
  _.$isHInstruction = TRUE;
  _.$isSpannable = TRUE;
  _.$isObject = TRUE;
  _ = B.HContinue;
  _.$isHContinue = TRUE;
  _.$isHControlFlow = TRUE;
  _.$isHInstruction = TRUE;
  _.$isSpannable = TRUE;
  _.$isObject = TRUE;
  _ = V.GenericType;
  _.$isGenericType = TRUE;
  _.$isDartType = TRUE;
  _.$isObject = TRUE;
  _ = K.Script;
  _.$isScript = TRUE;
  _.$isObject = TRUE;
  _ = Y.LibraryTag;
  _.$isLibraryTag = TRUE;
  _.$isNode = TRUE;
  _.$isSpannable = TRUE;
  _.$isSpannable = TRUE;
  _.$isObject = TRUE;
  _ = W.Event;
  _.$isEvent = TRUE;
  _.$isObject = TRUE;
  _ = P.SendPort;
  _.$isSendPort = TRUE;
  _.$isObject = TRUE;
  _ = K.NullSink;
  _.$isNullSink = TRUE;
  _.$isObject = TRUE;
  _ = P.Comparable;
  _.$isComparable = TRUE;
  _.$isObject = TRUE;
  _ = W.Element0;
  _.$isElement0 = TRUE;
  _.$isNode1 = TRUE;
  _.$isObject = TRUE;
  _ = P._EventSink;
  _.$is_EventSink = TRUE;
  _.$isObject = TRUE;
  _ = K.CodegenEnqueuer;
  _.$isCodegenEnqueuer = TRUE;
  _.$isEnqueuer = TRUE;
  _.$isObject = TRUE;
  _ = K.Message;
  _.$isMessage = TRUE;
  _.$isObject = TRUE;
  _ = K.ItemCompilationContext;
  _.$isItemCompilationContext = TRUE;
  _.$isObject = TRUE;
  _ = Z.JavaScriptItemCompilationContext;
  _.$isJavaScriptItemCompilationContext = TRUE;
  _.$isItemCompilationContext = TRUE;
  _.$isObject = TRUE;
  _ = P.DateTime;
  _.$isDateTime = TRUE;
  _.$isComparable = TRUE;
  _.$asComparable = [null];
  _.$isObject = TRUE;
  _ = P._DelayedEvent;
  _.$is_DelayedEvent = TRUE;
  _.$isObject = TRUE;
  _ = K.Compiler0;
  _.$isCompiler0 = TRUE;
  _.$isDiagnosticListener = TRUE;
  _.$isObject = TRUE;
  _ = K.Enqueuer;
  _.$isEnqueuer = TRUE;
  _.$isObject = TRUE;
  _ = K.ResolutionEnqueuer;
  _.$isResolutionEnqueuer = TRUE;
  _.$isEnqueuer = TRUE;
  _.$isObject = TRUE;
  _ = K.DiagnosticListener;
  _.$isDiagnosticListener = TRUE;
  _.$isObject = TRUE;
  _ = D.Expression3;
  _.$isExpression3 = TRUE;
  _.$isNode4 = TRUE;
  _.$isObject = TRUE;
  _ = D.Node4;
  _.$isNode4 = TRUE;
  _.$isObject = TRUE;
  _ = Q.LiteralString0;
  _.$isLiteralString0 = TRUE;
  _.$isExpression = TRUE;
  _.$isNode0 = TRUE;
  _.$isObject = TRUE;
  _ = O.LocalElement;
  _.$isLocalElement = TRUE;
  _.$isElement = TRUE;
  _.$isLocal = TRUE;
  _.$isTypedElement = TRUE;
  _.$isEntity = TRUE;
  _.$isSpannable = TRUE;
  _.$isEntity = TRUE;
  _.$isSpannable = TRUE;
  _.$isElement = TRUE;
  _.$isEntity = TRUE;
  _.$isSpannable = TRUE;
  _.$isObject = TRUE;
  _ = P.Uint8List;
  _.$isUint8List = TRUE;
  _.$isList = TRUE;
  _.$asList = [P.$int];
  _.$isIterable = TRUE;
  _.$asIterable = [P.$int];
  _.$isObject = TRUE;
  _ = P.Stream;
  _.$isStream = TRUE;
  _.$isObject = TRUE;
  _ = P.Pattern;
  _.$isPattern = TRUE;
  _.$isObject = TRUE;
  _ = Y.TypeAnnotation;
  _.$isTypeAnnotation = TRUE;
  _.$isNode = TRUE;
  _.$isSpannable = TRUE;
  _.$isSpannable = TRUE;
  _.$isObject = TRUE;
  _ = F.SwitchCase0;
  _.$isSwitchCase0 = TRUE;
  _.$isObject = TRUE;
  _ = F.CatchBlock0;
  _.$isCatchBlock0 = TRUE;
  _.$isObject = TRUE;
  _ = O.FormalElement;
  _.$isFormalElement = TRUE;
  _.$isElement = TRUE;
  _.$isAstElement = TRUE;
  _.$isTypedElement = TRUE;
  _.$isEntity = TRUE;
  _.$isSpannable = TRUE;
  _.$isElement = TRUE;
  _.$isEntity = TRUE;
  _.$isSpannable = TRUE;
  _.$isElement = TRUE;
  _.$isEntity = TRUE;
  _.$isSpannable = TRUE;
  _.$isElement = TRUE;
  _.$isEntity = TRUE;
  _.$isSpannable = TRUE;
  _.$isObject = TRUE;
  _ = M.VariableConstExp;
  _.$isVariableConstExp = TRUE;
  _.$isConstExp = TRUE;
  _.$isObject = TRUE;
  _ = K.TrueConstant;
  _.$isTrueConstant = TRUE;
  _.$isBoolConstant = TRUE;
  _.$isConstant = TRUE;
  _.$isObject = TRUE;
  _ = K.BoolConstant;
  _.$isBoolConstant = TRUE;
  _.$isConstant = TRUE;
  _.$isObject = TRUE;
  _ = K.FalseConstant;
  _.$isFalseConstant = TRUE;
  _.$isBoolConstant = TRUE;
  _.$isConstant = TRUE;
  _.$isObject = TRUE;
  _ = B.HControlFlow;
  _.$isHControlFlow = TRUE;
  _.$isHInstruction = TRUE;
  _.$isSpannable = TRUE;
  _.$isObject = TRUE;
  _ = T.SourceFileLocation;
  _.$isSourceFileLocation = TRUE;
  _.$isObject = TRUE;
  _ = P.StreamSubscription;
  _.$isStreamSubscription = TRUE;
  _.$isObject = TRUE;
  _ = Q.Comment;
  _.$isComment = TRUE;
  _.$isStatement = TRUE;
  _.$isNode0 = TRUE;
  _.$isObject = TRUE;
  _ = Z.Substitution;
  _.$isSubstitution = TRUE;
  _.$isObject = TRUE;
  _ = Q.LiteralNumber;
  _.$isLiteralNumber = TRUE;
  _.$isExpression = TRUE;
  _.$isNode0 = TRUE;
  _.$isObject = TRUE;
})();
;
// getInterceptor methods
J.getInterceptor = function(receiver) {
  if (typeof receiver == "number") {
    if (Math.floor(receiver) == receiver)
      return J.JSInt.prototype;
    return J.JSDouble.prototype;
  }
  if (typeof receiver == "string")
    return J.JSString.prototype;
  if (receiver == null)
    return J.JSNull.prototype;
  if (typeof receiver == "boolean")
    return J.JSBool.prototype;
  if (receiver.constructor == Array)
    return J.JSArray.prototype;
  if (typeof receiver != "object")
    return receiver;
  if (receiver instanceof P.Object)
    return receiver;
  return J.getNativeInterceptor(receiver);
};
J.getInterceptor$asx = function(receiver) {
  if (typeof receiver == "string")
    return J.JSString.prototype;
  if (receiver == null)
    return receiver;
  if (receiver.constructor == Array)
    return J.JSArray.prototype;
  if (typeof receiver != "object")
    return receiver;
  if (receiver instanceof P.Object)
    return receiver;
  return J.getNativeInterceptor(receiver);
};
J.getInterceptor$ax = function(receiver) {
  if (receiver == null)
    return receiver;
  if (receiver.constructor == Array)
    return J.JSArray.prototype;
  if (typeof receiver != "object")
    return receiver;
  if (receiver instanceof P.Object)
    return receiver;
  return J.getNativeInterceptor(receiver);
};
J.getInterceptor$i = function(receiver) {
  if (typeof receiver == "number") {
    if (Math.floor(receiver) == receiver)
      return J.JSInt.prototype;
    return J.JSNumber.prototype;
  }
  if (receiver == null)
    return receiver;
  if (!(receiver instanceof P.Object))
    return J.UnknownJavaScriptObject.prototype;
  return receiver;
};
J.getInterceptor$n = function(receiver) {
  if (typeof receiver == "number")
    return J.JSNumber.prototype;
  if (receiver == null)
    return receiver;
  if (!(receiver instanceof P.Object))
    return J.UnknownJavaScriptObject.prototype;
  return receiver;
};
J.getInterceptor$ns = function(receiver) {
  if (typeof receiver == "number")
    return J.JSNumber.prototype;
  if (typeof receiver == "string")
    return J.JSString.prototype;
  if (receiver == null)
    return receiver;
  if (!(receiver instanceof P.Object))
    return J.UnknownJavaScriptObject.prototype;
  return receiver;
};
J.getInterceptor$s = function(receiver) {
  if (typeof receiver == "string")
    return J.JSString.prototype;
  if (receiver == null)
    return receiver;
  if (!(receiver instanceof P.Object))
    return J.UnknownJavaScriptObject.prototype;
  return receiver;
};
J.getInterceptor$x = function(receiver) {
  if (receiver == null)
    return receiver;
  if (typeof receiver != "object")
    return receiver;
  if (receiver instanceof P.Object)
    return receiver;
  return J.getNativeInterceptor(receiver);
};
J.$add$ns = function(receiver, a0) {
  if (typeof receiver == "number" && typeof a0 == "number")
    return receiver + a0;
  return J.getInterceptor$ns(receiver).$add(receiver, a0);
};
J.$and$n = function(receiver, a0) {
  if (typeof receiver == "number" && typeof a0 == "number")
    return (receiver & a0) >>> 0;
  return J.getInterceptor$n(receiver).$and(receiver, a0);
};
J.$eq = function(receiver, a0) {
  if (receiver == null)
    return a0 == null;
  if (typeof receiver != "object")
    return a0 != null && receiver === a0;
  return J.getInterceptor(receiver).$eq(receiver, a0);
};
J.$gt$n = function(receiver, a0) {
  if (typeof receiver == "number" && typeof a0 == "number")
    return receiver > a0;
  return J.getInterceptor$n(receiver).$gt(receiver, a0);
};
J.$index$asx = function(receiver, a0) {
  if (receiver.constructor == Array || typeof receiver == "string" || H.isJsIndexable(receiver, receiver[init.dispatchPropertyName]))
    if (a0 >>> 0 === a0 && a0 < receiver.length)
      return receiver[a0];
  return J.getInterceptor$asx(receiver).$index(receiver, a0);
};
J.$indexSet$ax = function(receiver, a0, a1) {
  if ((receiver.constructor == Array || H.isJsIndexable(receiver, receiver[init.dispatchPropertyName])) && !receiver.immutable$list && a0 >>> 0 === a0 && a0 < receiver.length)
    return receiver[a0] = a1;
  return J.getInterceptor$ax(receiver).$indexSet(receiver, a0, a1);
};
J.$lt$n = function(receiver, a0) {
  if (typeof receiver == "number" && typeof a0 == "number")
    return receiver < a0;
  return J.getInterceptor$n(receiver).$lt(receiver, a0);
};
J.$mul$ns = function(receiver, a0) {
  if (typeof receiver == "number" && typeof a0 == "number")
    return receiver * a0;
  return J.getInterceptor$ns(receiver).$mul(receiver, a0);
};
J.$not$i = function(receiver) {
  if (typeof receiver == "number" && Math.floor(receiver) == receiver)
    return ~receiver >>> 0;
  return J.getInterceptor$i(receiver).$not(receiver);
};
J.$sub$n = function(receiver, a0) {
  if (typeof receiver == "number" && typeof a0 == "number")
    return receiver - a0;
  return J.getInterceptor$n(receiver).$sub(receiver, a0);
};
J.$tdiv$n = function(receiver, a0) {
  return J.getInterceptor$n(receiver).$tdiv(receiver, a0);
};
J._clearChildren$0$x = function(receiver) {
  return J.getInterceptor$x(receiver)._clearChildren$0(receiver);
};
J._shrOtherPositive$1$n = function(receiver, a0) {
  return J.getInterceptor$n(receiver)._shrOtherPositive$1(receiver, a0);
};
J.abs$0$n = function(receiver) {
  return J.getInterceptor$n(receiver).abs$0(receiver);
};
J.accept$1$x = function(receiver, a0) {
  return J.getInterceptor$x(receiver).accept$1(receiver, a0);
};
J.accept$2$x = function(receiver, a0, a1) {
  return J.getInterceptor$x(receiver).accept$2(receiver, a0, a1);
};
J.add$1$ax = function(receiver, a0) {
  return J.getInterceptor$ax(receiver).add$1(receiver, a0);
};
J.addAll$1$ax = function(receiver, a0) {
  return J.getInterceptor$ax(receiver).addAll$1(receiver, a0);
};
J.addEventListener$3$x = function(receiver, a0, a1, a2) {
  return J.getInterceptor$x(receiver).addEventListener$3(receiver, a0, a1, a2);
};
J.any$1$ax = function(receiver, a0) {
  return J.getInterceptor$ax(receiver).any$1(receiver, a0);
};
J.clear$0$ax = function(receiver) {
  return J.getInterceptor$ax(receiver).clear$0(receiver);
};
J.codeUnitAt$1$s = function(receiver, a0) {
  return J.getInterceptor$s(receiver).codeUnitAt$1(receiver, a0);
};
J.compareTo$1$ns = function(receiver, a0) {
  return J.getInterceptor$ns(receiver).compareTo$1(receiver, a0);
};
J.contains$1$asx = function(receiver, a0) {
  return J.getInterceptor$asx(receiver).contains$1(receiver, a0);
};
J.contains$2$asx = function(receiver, a0, a1) {
  return J.getInterceptor$asx(receiver).contains$2(receiver, a0, a1);
};
J.elementAt$1$ax = function(receiver, a0) {
  return J.getInterceptor$ax(receiver).elementAt$1(receiver, a0);
};
J.endsWith$1$s = function(receiver, a0) {
  return J.getInterceptor$s(receiver).endsWith$1(receiver, a0);
};
J.every$1$ax = function(receiver, a0) {
  return J.getInterceptor$ax(receiver).every$1(receiver, a0);
};
J.expand$1$ax = function(receiver, a0) {
  return J.getInterceptor$ax(receiver).expand$1(receiver, a0);
};
J.find$1$x = function(receiver, a0) {
  return J.getInterceptor$x(receiver).find$1(receiver, a0);
};
J.fold$1$ax = function(receiver, a0) {
  return J.getInterceptor$ax(receiver).fold$1(receiver, a0);
};
J.fold$2$ax = function(receiver, a0, a1) {
  return J.getInterceptor$ax(receiver).fold$2(receiver, a0, a1);
};
J.forEach$1$ax = function(receiver, a0) {
  return J.getInterceptor$ax(receiver).forEach$1(receiver, a0);
};
J.get$_get_target$x = function(receiver) {
  return J.getInterceptor$x(receiver).get$_get_target(receiver);
};
J.get$action$x = function(receiver) {
  return J.getInterceptor$x(receiver).get$action(receiver);
};
J.get$body$x = function(receiver) {
  return J.getInterceptor$x(receiver).get$body(receiver);
};
J.get$codeUnits$s = function(receiver) {
  return J.getInterceptor$s(receiver).get$codeUnits(receiver);
};
J.get$data$x = function(receiver) {
  return J.getInterceptor$x(receiver).get$data(receiver);
};
J.get$elements$x = function(receiver) {
  return J.getInterceptor$x(receiver).get$elements(receiver);
};
J.get$error$x = function(receiver) {
  return J.getInterceptor$x(receiver).get$error(receiver);
};
J.get$first$ax = function(receiver) {
  return J.getInterceptor$ax(receiver).get$first(receiver);
};
J.get$hashCode$ = function(receiver) {
  return J.getInterceptor(receiver).get$hashCode(receiver);
};
J.get$head$x = function(receiver) {
  return J.getInterceptor$x(receiver).get$head(receiver);
};
J.get$id$x = function(receiver) {
  return J.getInterceptor$x(receiver).get$id(receiver);
};
J.get$implementation$x = function(receiver) {
  return J.getInterceptor$x(receiver).get$implementation(receiver);
};
J.get$index$x = function(receiver) {
  return J.getInterceptor$x(receiver).get$index(receiver);
};
J.get$isEmpty$asx = function(receiver) {
  return J.getInterceptor$asx(receiver).get$isEmpty(receiver);
};
J.get$isNegative$n = function(receiver) {
  return J.getInterceptor$n(receiver).get$isNegative(receiver);
};
J.get$isNotEmpty$asx = function(receiver) {
  return J.getInterceptor$asx(receiver).get$isNotEmpty(receiver);
};
J.get$iterator$ax = function(receiver) {
  return J.getInterceptor$ax(receiver).get$iterator(receiver);
};
J.get$kind$x = function(receiver) {
  return J.getInterceptor$x(receiver).get$kind(receiver);
};
J.get$last$ax = function(receiver) {
  return J.getInterceptor$ax(receiver).get$last(receiver);
};
J.get$length$asx = function(receiver) {
  return J.getInterceptor$asx(receiver).get$length(receiver);
};
J.get$name$x = function(receiver) {
  return J.getInterceptor$x(receiver).get$name(receiver);
};
J.get$nodes$x = function(receiver) {
  return J.getInterceptor$x(receiver).get$nodes(receiver);
};
J.get$position$x = function(receiver) {
  return J.getInterceptor$x(receiver).get$position(receiver);
};
J.get$reason$x = function(receiver) {
  return J.getInterceptor$x(receiver).get$reason(receiver);
};
J.get$responseText$x = function(receiver) {
  return J.getInterceptor$x(receiver).get$responseText(receiver);
};
J.get$single$ax = function(receiver) {
  return J.getInterceptor$ax(receiver).get$single(receiver);
};
J.get$size$x = function(receiver) {
  return J.getInterceptor$x(receiver).get$size(receiver);
};
J.get$source$x = function(receiver) {
  return J.getInterceptor$x(receiver).get$source(receiver);
};
J.get$start$x = function(receiver) {
  return J.getInterceptor$x(receiver).get$start(receiver);
};
J.get$target$x = function(receiver) {
  return J.getInterceptor$x(receiver).get$target(receiver);
};
J.get$type$x = function(receiver) {
  return J.getInterceptor$x(receiver).get$type(receiver);
};
J.get$value$x = function(receiver) {
  return J.getInterceptor$x(receiver).get$value(receiver);
};
J.get$values$x = function(receiver) {
  return J.getInterceptor$x(receiver).get$values(receiver);
};
J.indexOf$1$asx = function(receiver, a0) {
  return J.getInterceptor$asx(receiver).indexOf$1(receiver, a0);
};
J.indexOf$2$asx = function(receiver, a0, a1) {
  return J.getInterceptor$asx(receiver).indexOf$2(receiver, a0, a1);
};
J.intersection$1$x = function(receiver, a0) {
  return J.getInterceptor$x(receiver).intersection$1(receiver, a0);
};
J.intersection$2$x = function(receiver, a0, a1) {
  return J.getInterceptor$x(receiver).intersection$2(receiver, a0, a1);
};
J.join$1$ax = function(receiver, a0) {
  return J.getInterceptor$ax(receiver).join$1(receiver, a0);
};
J.map$1$ax = function(receiver, a0) {
  return J.getInterceptor$ax(receiver).map$1(receiver, a0);
};
J.matchAsPrefix$2$s = function(receiver, a0, a1) {
  return J.getInterceptor$s(receiver).matchAsPrefix$2(receiver, a0, a1);
};
J.query$3$x = function(receiver, a0, a1, a2) {
  return J.getInterceptor$x(receiver).query$3(receiver, a0, a1, a2);
};
J.remove$1$ax = function(receiver, a0) {
  return J.getInterceptor$ax(receiver).remove$1(receiver, a0);
};
J.removeEventListener$3$x = function(receiver, a0, a1, a2) {
  return J.getInterceptor$x(receiver).removeEventListener$3(receiver, a0, a1, a2);
};
J.removeWhere$1$ax = function(receiver, a0) {
  return J.getInterceptor$ax(receiver).removeWhere$1(receiver, a0);
};
J.replaceAll$2$s = function(receiver, a0, a1) {
  return J.getInterceptor$s(receiver).replaceAll$2(receiver, a0, a1);
};
J.send$1$x = function(receiver, a0) {
  return J.getInterceptor$x(receiver).send$1(receiver, a0);
};
J.set$body$x = function(receiver, value) {
  return J.getInterceptor$x(receiver).set$body(receiver, value);
};
J.set$length$asx = function(receiver, value) {
  return J.getInterceptor$asx(receiver).set$length(receiver, value);
};
J.set$parent$x = function(receiver, value) {
  return J.getInterceptor$x(receiver).set$parent(receiver, value);
};
J.set$start$x = function(receiver, value) {
  return J.getInterceptor$x(receiver).set$start(receiver, value);
};
J.startsWith$1$s = function(receiver, a0) {
  return J.getInterceptor$s(receiver).startsWith$1(receiver, a0);
};
J.sublist$1$ax = function(receiver, a0) {
  return J.getInterceptor$ax(receiver).sublist$1(receiver, a0);
};
J.sublist$2$ax = function(receiver, a0, a1) {
  return J.getInterceptor$ax(receiver).sublist$2(receiver, a0, a1);
};
J.substring$1$s = function(receiver, a0) {
  return J.getInterceptor$s(receiver).substring$1(receiver, a0);
};
J.substring$2$s = function(receiver, a0, a1) {
  return J.getInterceptor$s(receiver).substring$2(receiver, a0, a1);
};
J.toDouble$0$n = function(receiver) {
  return J.getInterceptor$n(receiver).toDouble$0(receiver);
};
J.toInt$0$n = function(receiver) {
  return J.getInterceptor$n(receiver).toInt$0(receiver);
};
J.toList$0$ax = function(receiver) {
  return J.getInterceptor$ax(receiver).toList$0(receiver);
};
J.toLowerCase$0$s = function(receiver) {
  return J.getInterceptor$s(receiver).toLowerCase$0(receiver);
};
J.toRadixString$1$n = function(receiver, a0) {
  return J.getInterceptor$n(receiver).toRadixString$1(receiver, a0);
};
J.toSet$0$ax = function(receiver) {
  return J.getInterceptor$ax(receiver).toSet$0(receiver);
};
J.toString$0 = function(receiver) {
  return J.getInterceptor(receiver).toString$0(receiver);
};
J.trim$0$s = function(receiver) {
  return J.getInterceptor$s(receiver).trim$0(receiver);
};
J.where$1$ax = function(receiver, a0) {
  return J.getInterceptor$ax(receiver).where$1(receiver, a0);
};
C.HttpRequest_methods = W.HttpRequest.prototype;
C.JSArray_methods = J.JSArray.prototype;
C.JSBool_methods = J.JSBool.prototype;
C.JSInt_methods = J.JSInt.prototype;
C.JSNull_methods = J.JSNull.prototype;
C.JSNumber_methods = J.JSNumber.prototype;
C.JSString_methods = J.JSString.prototype;
C.NodeList_methods = W.NodeList0.prototype;
C.PlainJavaScriptObject_methods = J.PlainJavaScriptObject.prototype;
C.UnknownJavaScriptObject_methods = J.UnknownJavaScriptObject.prototype;
C.C_AddSpecializer = new B.AddSpecializer();
C.C_AssertAccess = new K.AssertAccess();
C.C_AssertResult = new A.AssertResult();
C.C_BitAndSpecializer = new B.BitAndSpecializer();
C.C_BitNotSpecializer = new B.BitNotSpecializer();
C.C_BitOrSpecializer = new B.BitOrSpecializer();
C.C_BitXorSpecializer = new B.BitXorSpecializer();
C.C_CombinatorFilter = new Z.CombinatorFilter();
C.C_DivideSpecializer = new B.DivideSpecializer();
C.C_DynamicAccess = new K.DynamicAccess();
C.C_DynamicRuntimeType = new H.DynamicRuntimeType();
C.C_DynamicType = new V.DynamicType();
C.C_DynamicTypeMask = new L.DynamicTypeMask();
C.C_EmptyIterator = new H.EmptyIterator();
C.C_EmptyLabelScope = new A.EmptyLabelScope();
C.C_EqualsSpecializer = new B.EqualsSpecializer();
C.C_GetDartStringVisitor = new Y.GetDartStringVisitor();
C.C_GreaterEqualSpecializer = new B.GreaterEqualSpecializer();
C.C_GreaterSpecializer = new B.GreaterSpecializer();
C.C_IndexAssignSpecializer = new B.IndexAssignSpecializer();
C.C_IndexSpecializer = new B.IndexSpecializer();
C.C_InvokeDynamicSpecializer = new B.InvokeDynamicSpecializer();
C.C_IsInterpolationVisitor = new Y.IsInterpolationVisitor();
C.C_JsBuilder = new Q.JsBuilder();
C.C_LessEqualSpecializer = new B.LessEqualSpecializer();
C.C_LessSpecializer = new B.LessSpecializer();
C.C_Link = H.setRuntimeTypeInfo(new O.Link(), [O.Element]);
C.C_Link0 = H.setRuntimeTypeInfo(new O.Link(), [V.DartType]);
C.C_Link1 = H.setRuntimeTypeInfo(new O.Link(), [K.TypePromotion]);
C.C_Link10 = new O.Link();
C.C_Link11 = H.setRuntimeTypeInfo(new O.Link(), [Y.Token]);
C.C_Link12 = H.setRuntimeTypeInfo(new O.Link(), [O.TypedefElement]);
C.C_Link13 = H.setRuntimeTypeInfo(new O.Link(), [Y.BeginGroupToken]);
C.C_Link14 = H.setRuntimeTypeInfo(new O.Link(), [P.String]);
C.C_Link15 = H.setRuntimeTypeInfo(new O.Link(), [Y.Import]);
C.C_Link16 = H.setRuntimeTypeInfo(new O.Link(), [B.HCheck]);
C.C_Link17 = H.setRuntimeTypeInfo(new O.Link(), [O.Entity]);
C.C_Link18 = H.setRuntimeTypeInfo(new O.Link(), [O.CompilationUnitElement]);
C.C_Link19 = H.setRuntimeTypeInfo(new O.Link(), [Z.ImportLink]);
C.C_Link2 = H.setRuntimeTypeInfo(new O.Link(), [O.MetadataAnnotation]);
C.C_Link20 = H.setRuntimeTypeInfo(new O.Link(), [Z.ExportLink]);
C.C_Link21 = H.setRuntimeTypeInfo(new O.Link(), [Y.Export]);
C.C_Link3 = H.setRuntimeTypeInfo(new O.Link(), [Y.Node]);
C.C_Link4 = H.setRuntimeTypeInfo(new O.Link(), [O.LabelDefinition]);
C.C_Link5 = H.setRuntimeTypeInfo(new O.Link(), [O.JumpTarget]);
C.C_Link6 = H.setRuntimeTypeInfo(new O.Link(), [Y.StringQuoting]);
C.C_Link7 = H.setRuntimeTypeInfo(new O.Link(), [P.bool]);
C.C_Link8 = H.setRuntimeTypeInfo(new O.Link(), [O.TypeVariableElement]);
C.C_Link9 = H.setRuntimeTypeInfo(new O.Link(), [Y.StringInterpolationPart]);
C.C_LoopTypeVisitor = new B.LoopTypeVisitor();
C.C_ModuloSpecializer = new B.ModuloSpecializer();
C.C_MultiplySpecializer = new B.MultiplySpecializer();
C.C_NativeAnnotationHandler = new S.NativeAnnotationHandler();
C.C_NullBaseType = new L.NullBaseType();
C.C_NullConstant = new K.NullConstant();
C.C_OutOfMemoryError = new P.OutOfMemoryError();
C.C_PatchAnnotationHandler = new S.PatchAnnotationHandler();
C.C_ShiftLeftSpecializer = new B.ShiftLeftSpecializer();
C.C_ShiftRightSpecializer = new B.ShiftRightSpecializer();
C.C_StatementType = new V.StatementType();
C.C_SubtractSpecializer = new B.SubtractSpecializer();
C.C_TruncatingDivideSpecializer = new B.TruncatingDivideSpecializer();
C.C_UnaryNegateSpecializer = new B.UnaryNegateSpecializer();
C.C_UnknownBaseType = new L.UnknownBaseType();
C.C_UnknownConcreteType = new L.UnknownConcreteType();
C.C_VoidType = new V.VoidType();
C.C__DelayedDone = new P._DelayedDone();
C.C__MapletMarker = new M._MapletMarker();
C.C__RootZone = new P._RootZone();
C.C__SetletMarker = new N._SetletMarker();
C.CheckedModeHelper_boolConversionCheck = new Z.CheckedModeHelper("boolConversionCheck");
C.AddOperation_seG = new K.AddOperation("+");
C.BitAndOperation_QZH = new K.BitAndOperation("&");
C.BitNotOperation_ECL = new K.BitNotOperation("~");
C.BitOrOperation_iHz = new K.BitOrOperation("|");
C.BitXorOperation_Jey = new K.BitXorOperation("^");
C.BooleanAndOperation_qbZ = new K.BooleanAndOperation("&&");
C.BooleanOrOperation_ofU = new K.BooleanOrOperation("||");
C.DivideOperation_Kf5 = new K.DivideOperation("/");
C.EqualsOperation_43h = new K.EqualsOperation("==");
C.GreaterEqualOperation_Kld = new K.GreaterEqualOperation(">=");
C.GreaterOperation_JMh = new K.GreaterOperation(">");
C.IdentityOperation_ijN = new K.IdentityOperation("===");
C.LessEqualOperation_gZb = new K.LessEqualOperation("<=");
C.LessOperation_gSJ = new K.LessOperation("<");
C.ModuloOperation_SFH = new K.ModuloOperation("%");
C.MultiplyOperation_oJL = new K.MultiplyOperation("*");
C.NegateOperation_negate = new K.NegateOperation("negate");
C.NotOperation_Mcd = new K.NotOperation("!");
C.ShiftLeftOperation_jrB = new K.ShiftLeftOperation("<<");
C.ShiftRightOperation_JFX = new K.ShiftRightOperation(">>");
C.SubtractOperation_1rA = new K.SubtractOperation("-");
C.TruncatingDivideOperation_Qxi = new K.TruncatingDivideOperation("~/");
C.DartConstantSystem_CJj = new K.DartConstantSystem(C.AddOperation_seG, C.BitAndOperation_QZH, C.BitNotOperation_ECL, C.BitOrOperation_iHz, C.BitXorOperation_Jey, C.BooleanAndOperation_qbZ, C.BooleanOrOperation_ofU, C.DivideOperation_Kf5, C.EqualsOperation_43h, C.GreaterEqualOperation_Kld, C.GreaterOperation_JMh, C.IdentityOperation_ijN, C.LessEqualOperation_gZb, C.LessOperation_gSJ, C.ModuloOperation_SFH, C.MultiplyOperation_oJL, C.NegateOperation_negate, C.NotOperation_Mcd, C.ShiftLeftOperation_jrB, C.ShiftRightOperation_JFX, C.SubtractOperation_1rA, C.TruncatingDivideOperation_Qxi);
C.Diagnostic_1_error = new D.Diagnostic(1, "error");
C.Diagnostic_2_warning = new D.Diagnostic(2, "warning");
C.Diagnostic_32_crash = new D.Diagnostic(32, "crash");
C.Diagnostic_4_hint = new D.Diagnostic(4, "hint");
C.Diagnostic_8_info = new D.Diagnostic(8, "info");
C.Diagnostic_kiE = new D.Diagnostic(16, "verbose info");
C.DoubleConstant_0 = new K.DoubleConstant(0);
C.DoubleConstant_1 = new K.DoubleConstant(1);
C.DoubleConstant_AmO = new K.DoubleConstant(-1 / 0);
C.DoubleConstant_C8D = new K.DoubleConstant(1 / 0);
C.DoubleConstant_PZL = new K.DoubleConstant(0 / 0);
C.Duration_0 = new P.Duration(0);
C.ElementKind_abstract_field_1 = new O.ElementKind("abstract_field", 1);
C.ElementKind_ambiguous_0 = new O.ElementKind("ambiguous", 0);
C.ElementKind_class_4 = new O.ElementKind("class", 4);
C.ElementKind_compilation_unit_0 = new O.ElementKind("compilation_unit", 0);
C.ElementKind_error_0 = new O.ElementKind("error", 0);
C.ElementKind_field_1 = new O.ElementKind("field", 1);
C.ElementKind_function_2 = new O.ElementKind("function", 2);
C.ElementKind_generative_constructor_16 = new O.ElementKind("generative_constructor", 16);
C.ElementKind_generative_constructor_body_0 = new O.ElementKind("generative_constructor_body", 0);
C.ElementKind_getter_0 = new O.ElementKind("getter", 0);
C.ElementKind_initializing_formal_1 = new O.ElementKind("initializing_formal", 1);
C.ElementKind_library_0 = new O.ElementKind("library", 0);
C.ElementKind_parameter_1 = new O.ElementKind("parameter", 1);
C.ElementKind_prefix_8 = new O.ElementKind("prefix", 8);
C.ElementKind_setter_0 = new O.ElementKind("setter", 0);
C.ElementKind_type_variable_128 = new O.ElementKind("type_variable", 128);
C.ElementKind_typedef_32 = new O.ElementKind("typedef", 32);
C.ElementKind_variable_1 = new O.ElementKind("variable", 1);
C.ElementKind_warn_on_use_0 = new O.ElementKind("warn_on_use", 0);
C.EventStreamProvider_error = H.setRuntimeTypeInfo(new W.EventStreamProvider("error"), [W.ProgressEvent]);
C.EventStreamProvider_load = H.setRuntimeTypeInfo(new W.EventStreamProvider("load"), [W.ProgressEvent]);
C.FalseConstant_false = new K.FalseConstant(false);
C.FlatTypeMask_null_0 = new B.FlatTypeMask(null, 0);
C.FlatTypeMask_null_1 = new B.FlatTypeMask(null, 1);
C.FormalParameterType_named = new Y.FormalParameterType("named");
C.FormalParameterType_positional = new Y.FormalParameterType("positional");
C.FormalParameterType_required = new Y.FormalParameterType("required");
Isolate.makeConstantList = function(list) {
  list.immutable$list = init;
  list.fixed$length = init;
  return list;
};
;
C.List_empty8 = H.setRuntimeTypeInfo(Isolate.makeConstantList([]), [O.Element]);
C.FunctionSetQuery_List_empty = new Z.FunctionSetQuery(C.List_empty8);
C.IntConstant_0 = new K.IntConstant(0);
C.IntConstant_1 = new K.IntConstant(1);
C.IntConstant_10 = new K.IntConstant(10);
C.IntConstant_2 = new K.IntConstant(2);
C.IntConstant_3 = new K.IntConstant(3);
C.IntConstant_4 = new K.IntConstant(4);
C.IntConstant_5 = new K.IntConstant(5);
C.IntConstant_6 = new K.IntConstant(6);
C.IntConstant_7 = new K.IntConstant(7);
C.IntConstant_8 = new K.IntConstant(8);
C.IntConstant_9 = new K.IntConstant(9);
C.IntConstant_m1 = new K.IntConstant(-1);
C.IntConstant_m2 = new K.IntConstant(-2);
C.JS_CONST_0 = function(hooks) {
  if (typeof dartExperimentalFixupGetTag != "function") return hooks;
  hooks.getTag = dartExperimentalFixupGetTag(hooks.getTag);
};
C.JS_CONST_4hp = function(hooks) {
  var userAgent = typeof navigator == "object" ? navigator.userAgent : "";
  if (userAgent.indexOf("Firefox") == -1) return hooks;
  var getTag = hooks.getTag;
  var quickMap = {
    "BeforeUnloadEvent": "Event",
    "DataTransfer": "Clipboard",
    "GeoGeolocation": "Geolocation",
    "Location": "!Location",
    "WorkerMessageEvent": "MessageEvent",
    "XMLDocument": "!Document"};
  function getTagFirefox(o) {
    var tag = getTag(o);
    return quickMap[tag] || tag;
  }
  hooks.getTag = getTagFirefox;
};
C.JS_CONST_8ZY = function getTagFallback(o) {
  var constructor = o.constructor;
  if (typeof constructor == "function") {
    var name = constructor.name;
    if (typeof name == "string" &&
        name.length > 2 &&
        name !== "Object" &&
        name !== "Function.prototype") {
      return name;
    }
  }
  var s = Object.prototype.toString.call(o);
  return s.substring(8, s.length - 1);
};
C.JS_CONST_Fs4 = function(hooks) { return hooks; }
;
C.JS_CONST_QJm = function(getTagFallback) {
  return function(hooks) {
    if (typeof navigator != "object") return hooks;
    var ua = navigator.userAgent;
    if (ua.indexOf("DumpRenderTree") >= 0) return hooks;
    if (ua.indexOf("Chrome") >= 0) {
      function confirm(p) {
        return typeof window == "object" && window[p] && window[p].name == p;
      }
      if (confirm("Window") && confirm("HTMLElement")) return hooks;
    }
    hooks.getTag = getTagFallback;
  };
};
C.JS_CONST_gkc = function(hooks) {
  var userAgent = typeof navigator == "object" ? navigator.userAgent : "";
  if (userAgent.indexOf("Trident/") == -1) return hooks;
  var getTag = hooks.getTag;
  var quickMap = {
    "BeforeUnloadEvent": "Event",
    "DataTransfer": "Clipboard",
    "HTMLDDElement": "HTMLElement",
    "HTMLDTElement": "HTMLElement",
    "HTMLPhraseElement": "HTMLElement",
    "Position": "Geoposition"
  };
  function getTagIE(o) {
    var tag = getTag(o);
    var newTag = quickMap[tag];
    if (newTag) return newTag;
    if (tag == "Object") {
      if (window.DataView && (o instanceof window.DataView)) return "DataView";
    }
    return tag;
  }
  function prototypeForTagIE(tag) {
    var constructor = window[tag];
    if (constructor == null) return null;
    return constructor.prototype;
  }
  hooks.getTag = getTagIE;
  hooks.prototypeForTag = prototypeForTagIE;
};
C.JS_CONST_oRe = function() {
  function typeNameInChrome(o) {
    var name = o.constructor.name;
    if (name) return name;
    var s = Object.prototype.toString.call(o);
    return s.substring(8, s.length - 1);
  }
  function getUnknownTag(object, tag) {
    if (/^HTML[A-Z].*Element$/.test(tag)) {
      var name = Object.prototype.toString.call(object);
      if (name == "[object Object]") return null;
      return "HTMLElement";
    }
  }
  function getUnknownTagGenericBrowser(object, tag) {
    if (self.HTMLElement && object instanceof HTMLElement) return "HTMLElement";
    return getUnknownTag(object, tag);
  }
  function prototypeForTag(tag) {
    if (typeof window == "undefined") return null;
    if (typeof window[tag] == "undefined") return null;
    var constructor = window[tag];
    if (typeof constructor != "function") return null;
    return constructor.prototype;
  }
  function discriminator(tag) { return null; }
  var isBrowser = typeof navigator == "object";
  return {
    getTag: typeNameInChrome,
    getUnknownTag: isBrowser ? getUnknownTagGenericBrowser : getUnknownTag,
    prototypeForTag: prototypeForTag,
    discriminator: discriminator };
};
C.JS_CONST_rr7 = function(hooks) {
  var getTag = hooks.getTag;
  var prototypeForTag = hooks.prototypeForTag;
  function getTagFixed(o) {
    var tag = getTag(o);
    if (tag == "Document") {
      if (!!o.xmlVersion) return "!Document";
      return "!HTMLDocument";
    }
    return tag;
  }
  function prototypeForTagFixed(tag) {
    if (tag == "Document") return null;
    return prototypeForTag(tag);
  }
  hooks.getTag = getTagFixed;
  hooks.prototypeForTag = prototypeForTagFixed;
};
C.JavaScriptBinaryArithmeticOperation_WfY = new Z.JavaScriptBinaryArithmeticOperation(C.AddOperation_seG);
C.JavaScriptBinaryBitOperation_woc = new Z.JavaScriptBinaryBitOperation(C.BitAndOperation_QZH);
C.JavaScriptBitNotOperation_c4u = new Z.JavaScriptBitNotOperation("~");
C.JavaScriptBinaryBitOperation_Icz = new Z.JavaScriptBinaryBitOperation(C.BitOrOperation_iHz);
C.JavaScriptBinaryBitOperation_o1R = new Z.JavaScriptBinaryBitOperation(C.BitXorOperation_Jey);
C.JavaScriptBinaryArithmeticOperation_ClO = new Z.JavaScriptBinaryArithmeticOperation(C.DivideOperation_Kf5);
C.JavaScriptIdentityOperation_y2d = new Z.JavaScriptIdentityOperation(C.IdentityOperation_ijN);
C.JavaScriptBinaryArithmeticOperation_OBP = new Z.JavaScriptBinaryArithmeticOperation(C.ModuloOperation_SFH);
C.JavaScriptBinaryArithmeticOperation_ifx = new Z.JavaScriptBinaryArithmeticOperation(C.MultiplyOperation_oJL);
C.JavaScriptNegateOperation_NegateOperation_negate = new Z.JavaScriptNegateOperation(C.NegateOperation_negate);
C.JavaScriptBinaryBitOperation_a9P = new Z.JavaScriptBinaryBitOperation(C.ShiftLeftOperation_jrB);
C.JavaScriptShiftRightOperation_Aui = new Z.JavaScriptShiftRightOperation(C.ShiftRightOperation_JFX);
C.JavaScriptBinaryArithmeticOperation_i2M = new Z.JavaScriptBinaryArithmeticOperation(C.SubtractOperation_1rA);
C.JavaScriptBinaryArithmeticOperation_npd = new Z.JavaScriptBinaryArithmeticOperation(C.TruncatingDivideOperation_Qxi);
C.JavaScriptConstantSystem_2Vk = new Z.JavaScriptConstantSystem(2415919103, 4294967295, C.JavaScriptBinaryArithmeticOperation_WfY, C.JavaScriptBinaryBitOperation_woc, C.JavaScriptBitNotOperation_c4u, C.JavaScriptBinaryBitOperation_Icz, C.JavaScriptBinaryBitOperation_o1R, C.BooleanAndOperation_qbZ, C.BooleanOrOperation_ofU, C.JavaScriptBinaryArithmeticOperation_ClO, C.EqualsOperation_43h, C.GreaterEqualOperation_Kld, C.GreaterOperation_JMh, C.JavaScriptIdentityOperation_y2d, C.LessEqualOperation_gZb, C.LessOperation_gSJ, C.JavaScriptBinaryArithmeticOperation_OBP, C.JavaScriptBinaryArithmeticOperation_ifx, C.JavaScriptNegateOperation_NegateOperation_negate, C.NotOperation_Mcd, C.JavaScriptBinaryBitOperation_a9P, C.JavaScriptShiftRightOperation_Aui, C.JavaScriptBinaryArithmeticOperation_i2M, C.JavaScriptBinaryArithmeticOperation_npd);
C.JsonCodec_null_null = new P.JsonCodec(null, null);
C.JsonDecoder_null = new P.JsonDecoder(null);
C.JsonEncoder_null_null = new P.JsonEncoder(null, null);
C.PrecedenceInfo_keyword_0_107 = new Y.PrecedenceInfo("keyword", 0, 107);
C.Keyword_27z = new Y.Keyword("assert", false, false, C.PrecedenceInfo_keyword_0_107);
C.Keyword_hZu = new Y.Keyword("break", false, false, C.PrecedenceInfo_keyword_0_107);
C.Keyword_YAJ = new Y.Keyword("case", false, false, C.PrecedenceInfo_keyword_0_107);
C.Keyword_EoR = new Y.Keyword("catch", false, false, C.PrecedenceInfo_keyword_0_107);
C.Keyword_doc = new Y.Keyword("class", false, false, C.PrecedenceInfo_keyword_0_107);
C.Keyword_Fb0 = new Y.Keyword("const", false, false, C.PrecedenceInfo_keyword_0_107);
C.Keyword_WJY = new Y.Keyword("continue", false, false, C.PrecedenceInfo_keyword_0_107);
C.Keyword_IYb = new Y.Keyword("default", false, false, C.PrecedenceInfo_keyword_0_107);
C.Keyword_woc = new Y.Keyword("do", false, false, C.PrecedenceInfo_keyword_0_107);
C.Keyword_yPV = new Y.Keyword("else", false, false, C.PrecedenceInfo_keyword_0_107);
C.Keyword_426 = new Y.Keyword("extends", false, false, C.PrecedenceInfo_keyword_0_107);
C.Keyword_C72 = new Y.Keyword("false", false, false, C.PrecedenceInfo_keyword_0_107);
C.Keyword_gkc = new Y.Keyword("final", false, false, C.PrecedenceInfo_keyword_0_107);
C.Keyword_oMO = new Y.Keyword("finally", false, false, C.PrecedenceInfo_keyword_0_107);
C.Keyword_pq7 = new Y.Keyword("for", false, false, C.PrecedenceInfo_keyword_0_107);
C.Keyword_ODT = new Y.Keyword("if", false, false, C.PrecedenceInfo_keyword_0_107);
C.Keyword_bh5 = new Y.Keyword("in", false, false, C.PrecedenceInfo_keyword_0_107);
C.Keyword_8eb = new Y.Keyword("new", false, false, C.PrecedenceInfo_keyword_0_107);
C.Keyword_APm = new Y.Keyword("null", false, false, C.PrecedenceInfo_keyword_0_107);
C.Keyword_M12 = new Y.Keyword("rethrow", false, false, C.PrecedenceInfo_keyword_0_107);
C.Keyword_yoM = new Y.Keyword("return", false, false, C.PrecedenceInfo_keyword_0_107);
C.Keyword_BSc = new Y.Keyword("super", false, false, C.PrecedenceInfo_keyword_0_107);
C.Keyword_jNy = new Y.Keyword("switch", false, false, C.PrecedenceInfo_keyword_0_107);
C.Keyword_7RH = new Y.Keyword("this", false, false, C.PrecedenceInfo_keyword_0_107);
C.Keyword_EAs = new Y.Keyword("throw", false, false, C.PrecedenceInfo_keyword_0_107);
C.Keyword_ub5 = new Y.Keyword("true", false, false, C.PrecedenceInfo_keyword_0_107);
C.Keyword_1uL = new Y.Keyword("try", false, false, C.PrecedenceInfo_keyword_0_107);
C.Keyword_IM8 = new Y.Keyword("var", false, false, C.PrecedenceInfo_keyword_0_107);
C.Keyword_4QF = new Y.Keyword("void", false, false, C.PrecedenceInfo_keyword_0_107);
C.Keyword_7eS = new Y.Keyword("while", false, false, C.PrecedenceInfo_keyword_0_107);
C.Keyword_ijO = new Y.Keyword("with", false, false, C.PrecedenceInfo_keyword_0_107);
C.PrecedenceInfo_is_7_107 = new Y.PrecedenceInfo("is", 7, 107);
C.Keyword_b1C = new Y.Keyword("is", false, false, C.PrecedenceInfo_is_7_107);
C.Keyword_i4E = new Y.Keyword("abstract", false, true, C.PrecedenceInfo_keyword_0_107);
C.PrecedenceInfo_as_7_107 = new Y.PrecedenceInfo("as", 7, 107);
C.Keyword_hwK = new Y.Keyword("as", false, true, C.PrecedenceInfo_as_7_107);
C.Keyword_2jN = new Y.Keyword("dynamic", false, true, C.PrecedenceInfo_keyword_0_107);
C.Keyword_KYP = new Y.Keyword("export", false, true, C.PrecedenceInfo_keyword_0_107);
C.Keyword_e1j = new Y.Keyword("external", false, true, C.PrecedenceInfo_keyword_0_107);
C.Keyword_Cfi = new Y.Keyword("factory", false, true, C.PrecedenceInfo_keyword_0_107);
C.Keyword_GDx = new Y.Keyword("get", false, true, C.PrecedenceInfo_keyword_0_107);
C.Keyword_oKF = new Y.Keyword("implements", false, true, C.PrecedenceInfo_keyword_0_107);
C.Keyword_GTJ = new Y.Keyword("import", false, true, C.PrecedenceInfo_keyword_0_107);
C.Keyword_cKo = new Y.Keyword("library", false, true, C.PrecedenceInfo_keyword_0_107);
C.Keyword_Ix1 = new Y.Keyword("operator", false, true, C.PrecedenceInfo_keyword_0_107);
C.Keyword_8aB = new Y.Keyword("part", false, true, C.PrecedenceInfo_keyword_0_107);
C.Keyword_GW5 = new Y.Keyword("set", false, true, C.PrecedenceInfo_keyword_0_107);
C.Keyword_a8C = new Y.Keyword("static", false, true, C.PrecedenceInfo_keyword_0_107);
C.Keyword_oyU = new Y.Keyword("typedef", false, true, C.PrecedenceInfo_keyword_0_107);
C.Keyword_0Y9 = new Y.Keyword("hide", true, false, C.PrecedenceInfo_keyword_0_107);
C.Keyword_iZu = new Y.Keyword("native", true, false, C.PrecedenceInfo_keyword_0_107);
C.Keyword_TOW = new Y.Keyword("of", true, false, C.PrecedenceInfo_keyword_0_107);
C.Keyword_KUx = new Y.Keyword("on", true, false, C.PrecedenceInfo_keyword_0_107);
C.Keyword_3vZ = new Y.Keyword("show", true, false, C.PrecedenceInfo_keyword_0_107);
C.Keyword_sFA = new Y.Keyword("source", true, false, C.PrecedenceInfo_keyword_0_107);
C.Keyword_23h = new Y.Keyword("deferred", true, false, C.PrecedenceInfo_keyword_0_107);
C.List_0 = H.setRuntimeTypeInfo(Isolate.makeConstantList([C.Keyword_27z, C.Keyword_hZu, C.Keyword_YAJ, C.Keyword_EoR, C.Keyword_doc, C.Keyword_Fb0, C.Keyword_WJY, C.Keyword_IYb, C.Keyword_woc, C.Keyword_yPV, C.Keyword_426, C.Keyword_C72, C.Keyword_gkc, C.Keyword_oMO, C.Keyword_pq7, C.Keyword_ODT, C.Keyword_bh5, C.Keyword_8eb, C.Keyword_APm, C.Keyword_M12, C.Keyword_yoM, C.Keyword_BSc, C.Keyword_jNy, C.Keyword_7RH, C.Keyword_EAs, C.Keyword_ub5, C.Keyword_1uL, C.Keyword_IM8, C.Keyword_4QF, C.Keyword_7eS, C.Keyword_ijO, C.Keyword_b1C, C.Keyword_i4E, C.Keyword_hwK, C.Keyword_2jN, C.Keyword_KYP, C.Keyword_e1j, C.Keyword_Cfi, C.Keyword_GDx, C.Keyword_oKF, C.Keyword_GTJ, C.Keyword_cKo, C.Keyword_Ix1, C.Keyword_8aB, C.Keyword_GW5, C.Keyword_a8C, C.Keyword_oyU, C.Keyword_0Y9, C.Keyword_iZu, C.Keyword_TOW, C.Keyword_KUx, C.Keyword_3vZ, C.Keyword_sFA, C.Keyword_23h]), [Y.Keyword]);
C.List_127_2047_65535_1114111 = H.setRuntimeTypeInfo(Isolate.makeConstantList([127, 2047, 65535, 1114111]), [P.$int]);
C.List_2Vk = Isolate.makeConstantList([0, 0, 32776, 33792, 1, 10240, 0, 0]);
C.List_3CK = H.setRuntimeTypeInfo(Isolate.makeConstantList(["NaN", "Infinity", "undefined", "eval", "parseInt", "parseFloat", "isNaN", "isFinite", "decodeURI", "decodeURIComponent", "encodeURI", "encodeURIComponent", "Object", "Function", "Array", "String", "Boolean", "Number", "Date", "RegExp", "Error", "EvalError", "RangeError", "ReferenceError", "SyntaxError", "TypeError", "URIError", "Math", "arguments", "escape", "unescape", "applicationCache", "closed", "Components", "content", "controllers", "crypto", "defaultStatus", "dialogArguments", "directories", "document", "frameElement", "frames", "fullScreen", "globalStorage", "history", "innerHeight", "innerWidth", "length", "location", "locationbar", "localStorage", "menubar", "mozInnerScreenX", "mozInnerScreenY", "mozScreenPixelsPerCssPixel", "name", "navigator", "opener", "outerHeight", "outerWidth", "pageXOffset", "pageYOffset", "parent", "personalbar", "pkcs11", "returnValue", "screen", "scrollbars", "scrollMaxX", "scrollMaxY", "self", "sessionStorage", "sidebar", "status", "statusbar", "toolbar", "top", "window", "alert", "addEventListener", "atob", "back", "blur", "btoa", "captureEvents", "clearInterval", "clearTimeout", "close", "confirm", "disableExternalCapture", "dispatchEvent", "dump", "enableExternalCapture", "escape", "find", "focus", "forward", "GeckoActiveXObject", "getAttention", "getAttentionWithCycleCount", "getComputedStyle", "getSelection", "home", "maximize", "minimize", "moveBy", "moveTo", "open", "openDialog", "postMessage", "print", "prompt", "QueryInterface", "releaseEvents", "removeEventListener", "resizeBy", "resizeTo", "restore", "routeEvent", "scroll", "scrollBy", "scrollByLines", "scrollByPages", "scrollTo", "setInterval", "setResizeable", "setTimeout", "showModalDialog", "sizeToContent", "stop", "uuescape", "updateCommands", "XPCNativeWrapper", "XPCSafeJSOjbectWrapper", "onabort", "onbeforeunload", "onchange", "onclick", "onclose", "oncontextmenu", "ondragdrop", "onerror", "onfocus", "onhashchange", "onkeydown", "onkeypress", "onkeyup", "onload", "onmousedown", "onmousemove", "onmouseout", "onmouseover", "onmouseup", "onmozorientation", "onpaint", "onreset", "onresize", "onscroll", "onselect", "onsubmit", "onunload", "ontouchcancel", "ontouchend", "ontouchmove", "ontouchstart", "ongesturestart", "ongesturechange", "ongestureend", "uneval", "getPrototypeOf", "let", "yield", "abstract", "int", "short", "boolean", "interface", "static", "byte", "long", "char", "final", "native", "synchronized", "float", "package", "throws", "goto", "private", "transient", "implements", "protected", "volatile", "double", "public", "attachEvent", "clientInformation", "clipboardData", "createPopup", "dialogHeight", "dialogLeft", "dialogTop", "dialogWidth", "onafterprint", "onbeforedeactivate", "onbeforeprint", "oncontrolselect", "ondeactivate", "onhelp", "onresizeend", "event", "external", "Debug", "Enumerator", "Global", "Image", "ActiveXObject", "VBArray", "Components", "toString", "getClass", "constructor", "prototype", "valueOf", "Anchor", "Applet", "Attr", "Canvas", "CanvasGradient", "CanvasPattern", "CanvasRenderingContext2D", "CDATASection", "CharacterData", "Comment", "CSS2Properties", "CSSRule", "CSSStyleSheet", "Document", "DocumentFragment", "DocumentType", "DOMException", "DOMImplementation", "DOMParser", "Element", "Event", "ExternalInterface", "FlashPlayer", "Form", "Frame", "History", "HTMLCollection", "HTMLDocument", "HTMLElement", "IFrame", "Image", "Input", "JSObject", "KeyEvent", "Link", "Location", "MimeType", "MouseEvent", "Navigator", "Node", "NodeList", "Option", "Plugin", "ProcessingInstruction", "Range", "RangeException", "Screen", "Select", "Table", "TableCell", "TableRow", "TableSelection", "Text", "TextArea", "UIEvent", "Window", "XMLHttpRequest", "XMLSerializer", "XPathException", "XPathResult", "XSLTProcessor", "java", "Packages", "netscape", "sun", "JavaObject", "JavaClass", "JavaArray", "JavaMember"]), [P.String]);
C.MalformedCheckedModeHelper_checkMalformedType = new Z.MalformedCheckedModeHelper("checkMalformedType");
C.CheckedModeHelper_voidTypeCheck = new Z.CheckedModeHelper("voidTypeCheck");
C.CheckedModeHelper_stringTypeCast = new Z.CheckedModeHelper("stringTypeCast");
C.CheckedModeHelper_stringTypeCheck = new Z.CheckedModeHelper("stringTypeCheck");
C.CheckedModeHelper_doubleTypeCast = new Z.CheckedModeHelper("doubleTypeCast");
C.CheckedModeHelper_doubleTypeCheck = new Z.CheckedModeHelper("doubleTypeCheck");
C.CheckedModeHelper_numTypeCast = new Z.CheckedModeHelper("numTypeCast");
C.CheckedModeHelper_numTypeCheck = new Z.CheckedModeHelper("numTypeCheck");
C.CheckedModeHelper_boolTypeCast = new Z.CheckedModeHelper("boolTypeCast");
C.CheckedModeHelper_boolTypeCheck = new Z.CheckedModeHelper("boolTypeCheck");
C.CheckedModeHelper_intTypeCast = new Z.CheckedModeHelper("intTypeCast");
C.CheckedModeHelper_intTypeCheck = new Z.CheckedModeHelper("intTypeCheck");
C.PropertyCheckedModeHelper_1G6 = new Z.PropertyCheckedModeHelper("numberOrStringSuperNativeTypeCast");
C.PropertyCheckedModeHelper_SDG = new Z.PropertyCheckedModeHelper("numberOrStringSuperNativeTypeCheck");
C.PropertyCheckedModeHelper_numberOrStringSuperTypeCast = new Z.PropertyCheckedModeHelper("numberOrStringSuperTypeCast");
C.PropertyCheckedModeHelper_numberOrStringSuperTypeCheck = new Z.PropertyCheckedModeHelper("numberOrStringSuperTypeCheck");
C.PropertyCheckedModeHelper_stringSuperNativeTypeCast = new Z.PropertyCheckedModeHelper("stringSuperNativeTypeCast");
C.PropertyCheckedModeHelper_stringSuperNativeTypeCheck = new Z.PropertyCheckedModeHelper("stringSuperNativeTypeCheck");
C.PropertyCheckedModeHelper_stringSuperTypeCast = new Z.PropertyCheckedModeHelper("stringSuperTypeCast");
C.PropertyCheckedModeHelper_stringSuperTypeCheck = new Z.PropertyCheckedModeHelper("stringSuperTypeCheck");
C.CheckedModeHelper_listTypeCast = new Z.CheckedModeHelper("listTypeCast");
C.CheckedModeHelper_listTypeCheck = new Z.CheckedModeHelper("listTypeCheck");
C.PropertyCheckedModeHelper_listSuperNativeTypeCast = new Z.PropertyCheckedModeHelper("listSuperNativeTypeCast");
C.PropertyCheckedModeHelper_listSuperNativeTypeCheck = new Z.PropertyCheckedModeHelper("listSuperNativeTypeCheck");
C.PropertyCheckedModeHelper_listSuperTypeCast = new Z.PropertyCheckedModeHelper("listSuperTypeCast");
C.PropertyCheckedModeHelper_listSuperTypeCheck = new Z.PropertyCheckedModeHelper("listSuperTypeCheck");
C.PropertyCheckedModeHelper_interceptedTypeCast = new Z.PropertyCheckedModeHelper("interceptedTypeCast");
C.PropertyCheckedModeHelper_interceptedTypeCheck = new Z.PropertyCheckedModeHelper("interceptedTypeCheck");
C.SubtypeCheckedModeHelper_subtypeCast = new Z.SubtypeCheckedModeHelper("subtypeCast");
C.SubtypeCheckedModeHelper_assertSubtype = new Z.SubtypeCheckedModeHelper("assertSubtype");
C.TypeVariableCheckedModeHelper_subtypeOfRuntimeTypeCast = new Z.TypeVariableCheckedModeHelper("subtypeOfRuntimeTypeCast");
C.TypeVariableCheckedModeHelper_assertSubtypeOfRuntimeType = new Z.TypeVariableCheckedModeHelper("assertSubtypeOfRuntimeType");
C.PropertyCheckedModeHelper_propertyTypeCast = new Z.PropertyCheckedModeHelper("propertyTypeCast");
C.PropertyCheckedModeHelper_propertyTypeCheck = new Z.PropertyCheckedModeHelper("propertyTypeCheck");
C.List_4vz = H.setRuntimeTypeInfo(Isolate.makeConstantList([C.MalformedCheckedModeHelper_checkMalformedType, C.CheckedModeHelper_voidTypeCheck, C.CheckedModeHelper_stringTypeCast, C.CheckedModeHelper_stringTypeCheck, C.CheckedModeHelper_doubleTypeCast, C.CheckedModeHelper_doubleTypeCheck, C.CheckedModeHelper_numTypeCast, C.CheckedModeHelper_numTypeCheck, C.CheckedModeHelper_boolTypeCast, C.CheckedModeHelper_boolTypeCheck, C.CheckedModeHelper_intTypeCast, C.CheckedModeHelper_intTypeCheck, C.PropertyCheckedModeHelper_1G6, C.PropertyCheckedModeHelper_SDG, C.PropertyCheckedModeHelper_numberOrStringSuperTypeCast, C.PropertyCheckedModeHelper_numberOrStringSuperTypeCheck, C.PropertyCheckedModeHelper_stringSuperNativeTypeCast, C.PropertyCheckedModeHelper_stringSuperNativeTypeCheck, C.PropertyCheckedModeHelper_stringSuperTypeCast, C.PropertyCheckedModeHelper_stringSuperTypeCheck, C.CheckedModeHelper_listTypeCast, C.CheckedModeHelper_listTypeCheck, C.PropertyCheckedModeHelper_listSuperNativeTypeCast, C.PropertyCheckedModeHelper_listSuperNativeTypeCheck, C.PropertyCheckedModeHelper_listSuperTypeCast, C.PropertyCheckedModeHelper_listSuperTypeCheck, C.PropertyCheckedModeHelper_interceptedTypeCast, C.PropertyCheckedModeHelper_interceptedTypeCheck, C.SubtypeCheckedModeHelper_subtypeCast, C.SubtypeCheckedModeHelper_assertSubtype, C.TypeVariableCheckedModeHelper_subtypeOfRuntimeTypeCast, C.TypeVariableCheckedModeHelper_assertSubtypeOfRuntimeType, C.PropertyCheckedModeHelper_propertyTypeCast, C.PropertyCheckedModeHelper_propertyTypeCheck]), [Z.CheckedModeHelper]);
C.List_69t = H.setRuntimeTypeInfo(Isolate.makeConstantList(["A", "B", "C", "D", "E", "F", "G", "H", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z"]), [P.String]);
C.StringQuoting_false_1_39 = new Y.StringQuoting(false, 1, 39);
C.StringQuoting_true_1_39 = new Y.StringQuoting(true, 1, 39);
C.StringQuoting_false_1_34 = new Y.StringQuoting(false, 1, 34);
C.StringQuoting_true_1_34 = new Y.StringQuoting(true, 1, 34);
C.StringQuoting_false_3_39 = new Y.StringQuoting(false, 3, 39);
C.StringQuoting_true_3_39 = new Y.StringQuoting(true, 3, 39);
C.StringQuoting_false_3_34 = new Y.StringQuoting(false, 3, 34);
C.StringQuoting_true_3_34 = new Y.StringQuoting(true, 3, 34);
C.StringQuoting_false_4_39 = new Y.StringQuoting(false, 4, 39);
C.StringQuoting_true_4_39 = new Y.StringQuoting(true, 4, 39);
C.StringQuoting_false_4_34 = new Y.StringQuoting(false, 4, 34);
C.StringQuoting_true_4_34 = new Y.StringQuoting(true, 4, 34);
C.StringQuoting_false_5_39 = new Y.StringQuoting(false, 5, 39);
C.StringQuoting_true_5_39 = new Y.StringQuoting(true, 5, 39);
C.StringQuoting_false_5_34 = new Y.StringQuoting(false, 5, 34);
C.StringQuoting_true_5_34 = new Y.StringQuoting(true, 5, 34);
C.StringQuoting_false_6_39 = new Y.StringQuoting(false, 6, 39);
C.StringQuoting_true_6_39 = new Y.StringQuoting(true, 6, 39);
C.StringQuoting_false_6_34 = new Y.StringQuoting(false, 6, 34);
C.StringQuoting_true_6_34 = new Y.StringQuoting(true, 6, 34);
C.List_BmO = H.setRuntimeTypeInfo(Isolate.makeConstantList([C.StringQuoting_false_1_39, C.StringQuoting_true_1_39, C.StringQuoting_false_1_34, C.StringQuoting_true_1_34, null, null, null, null, C.StringQuoting_false_3_39, C.StringQuoting_true_3_39, C.StringQuoting_false_3_34, C.StringQuoting_true_3_34, C.StringQuoting_false_4_39, C.StringQuoting_true_4_39, C.StringQuoting_false_4_34, C.StringQuoting_true_4_34, C.StringQuoting_false_5_39, C.StringQuoting_true_5_39, C.StringQuoting_false_5_34, C.StringQuoting_true_5_34, C.StringQuoting_false_6_39, C.StringQuoting_true_6_39, C.StringQuoting_false_6_34, C.StringQuoting_true_6_34]), [Y.StringQuoting]);
C.List_CKg = H.setRuntimeTypeInfo(Isolate.makeConstantList(["==", "hashCode", "toString", "noSuchMethod", "runtimeType", "iterator", "map", "where", "expand", "contains", "forEach", "reduce", "fold", "every", "join", "any", "toList", "toSet", "length", "isEmpty", "isNotEmpty", "take", "takeWhile", "skip", "skipWhile", "first", "last", "single", "firstWhere", "lastWhere", "singleWhere", "elementAt", "[]", "[]=", "length", "reversed", "sort", "indexOf", "lastIndexOf", "sublist", "getRange", "asMap", "checkMutable", "checkGrowable"]), [P.String]);
C.List_CVk = Isolate.makeConstantList([0, 0, 65490, 45055, 65535, 34815, 65534, 18431]);
C.List_D72 = Isolate.makeConstantList(["Map", "List", "num", "int", "double", "bool"]);
C.List_IEE = H.setRuntimeTypeInfo(Isolate.makeConstantList(["Object", "wrapException", "$eq", "S", "ioore", "UnsupportedError$", "length", "$sub", "getInterceptor$JSArrayJSString", "$add", "$gt", "$ge", "$lt", "$le", "add", "getInterceptor$JSNumber", "iterator", "$index", "iae", "getInterceptor$JSArray", "ArgumentError$", "BoundClosure", "StateError$", "getInterceptor", "max", "$mul", "List_List", "Map_Map", "getInterceptor$JSString", "$div", "$indexSet", "List_List$from", "Set_Set$from", "toString", "toInt", "min", "StringBuffer_StringBuffer", "contains1", "WhereIterable$", "RangeError$value", "JSString", "JSNumber", "JSArray", "createInvocationMirror"]), [P.String]);
C.List_JYB = Isolate.makeConstantList([0, 0, 26624, 1023, 65534, 2047, 65534, 2047]);
C.List_MIo = Isolate.makeConstantList(["startRootIsolate", "_currentIsolate", "_callInIsolate"]);
C.List_O5a = H.setRuntimeTypeInfo(Isolate.makeConstantList(["__proto__", "prototype", "constructor", "call"]), [P.String]);
C.List_Odk = H.setRuntimeTypeInfo(Isolate.makeConstantList(["break", "delete", "function", "return", "typeof", "case", "do", "if", "switch", "var", "catch", "else", "in", "this", "void", "continue", "false", "instanceof", "throw", "while", "debugger", "finally", "new", "true", "with", "default", "for", "null", "try", "abstract", "double", "goto", "native", "static", "boolean", "enum", "implements", "package", "super", "byte", "export", "import", "private", "synchronized", "char", "extends", "int", "protected", "throws", "class", "final", "interface", "public", "transient", "const", "float", "long", "short", "volatile"]), [P.String]);
C.List_Phq = H.setRuntimeTypeInfo(Isolate.makeConstantList(["==", "hashCode", "toString", "noSuchMethod", "runtimeType", "iterator", "map", "where", "expand", "contains", "forEach", "reduce", "fold", "every", "join", "any", "toList", "toSet", "length", "isEmpty", "isNotEmpty", "take", "takeWhile", "skip", "skipWhile", "first", "last", "single", "firstWhere", "lastWhere", "singleWhere", "elementAt", "[]", "length", "reversed", "sort", "indexOf", "lastIndexOf", "clear", "remove", "removeAt", "removeLast", "removeWhere", "retainWhere", "sublist", "getRange", "removeRange", "asMap", "checkMutable", "checkGrowable"]), [P.String]);
C.List_RUC = H.setRuntimeTypeInfo(Isolate.makeConstantList(["==", "hashCode", "toString", "noSuchMethod", "runtimeType", "[]", "isEmpty", "isNotEmpty", "keys", "length", "values", "clear", "containsKey", "containsValue", "forEach", "remove"]), [P.String]);
C.List_THA = H.setRuntimeTypeInfo(Isolate.makeConstantList(["==", "hashCode", "toString", "noSuchMethod", "runtimeType", "isEmpty", "isNotEmpty", "length", "any", "contains", "every", "join", "add", "addAll", "clear", "fillRange", "indexOf", "insert", "insertAll", "lastIndexOf", "remove", "removeRange", "replaceRange", "setAll", "setRange", "shuffle", "[]=", "checkMutable", "checkGrowable"]), [P.String]);
C.List_U2X = H.setRuntimeTypeInfo(Isolate.makeConstantList(["$add", "add$1", "$and", "codeUnitAt$1", "$or", "current", "$shr", "$eq", "$ne", "getPrototypeOf", "hasOwnProperty", "$index", "$indexSet", "$isJavaScriptIndexingBehavior", "$xor", "iterator", "length", "$lt", "$gt", "$le", "$ge", "moveNext$0", "node", "on", "$negate", "push", "self", "start", "target", "$shl", "value", "width", "style", "noSuchMethod$1", "$mul", "$div", "$sub", "$not", "$mod", "$tdiv"]), [P.String]);
C.List_aWd = H.setRuntimeTypeInfo(Isolate.makeConstantList(["Q", "a", "b", "c", "d", "e", "f", "r", "x", "y", "z", "ch", "cx", "cy", "db", "dx", "dy", "fr", "fx", "fy", "go", "id", "k1", "k2", "k3", "k4", "r1", "r2", "rx", "ry", "x1", "x2", "y1", "y2", "add", "all", "alt", "arc", "CCW", "cmp", "dir", "end", "get", "in1", "in2", "INT", "key", "log", "low", "m11", "m12", "m13", "m14", "m21", "m22", "m23", "m24", "m31", "m32", "m33", "m34", "m41", "m42", "m43", "m44", "max", "min", "now", "ONE", "put", "red", "rel", "rev", "RGB", "sdp", "set", "src", "tag", "top", "uid", "uri", "url", "URL", "abbr", "atob", "Attr", "axes", "axis", "back", "BACK", "beta", "bias", "Blob", "blue", "blur", "BLUR", "body", "BOOL", "BOTH", "btoa", "BYTE", "cite", "clip", "code", "cols", "cues", "data", "DECR", "DONE", "face", "file", "File", "fill", "find", "font", "form", "gain", "hash", "head", "high", "hint", "host", "href", "HRTF", "IDLE", "INCR", "info", "INIT", "isId", "item", "KEEP", "kind", "knee", "lang", "left", "LESS", "line", "link", "list", "load", "loop", "mode", "name", "Node", "None", "NONE", "only", "open", "OPEN", "ping", "play", "port", "rect", "Rect", "refX", "refY", "RGBA", "root", "rows", "save", "seed", "seek", "self", "send", "show", "SINE", "size", "span", "stat", "step", "stop", "tags", "text", "Text", "time", "type", "view", "warn", "wrap", "ZERO"]), [P.String]);
C.List_empty = Isolate.makeConstantList([]);
C.List_empty0 = H.setRuntimeTypeInfo(Isolate.makeConstantList([]), [P.String]);
C.List_empty1 = H.setRuntimeTypeInfo(Isolate.makeConstantList([]), [Y.Node]);
C.List_empty10 = H.setRuntimeTypeInfo(Isolate.makeConstantList([]), [G.TypeInformation]);
C.List_empty11 = H.setRuntimeTypeInfo(Isolate.makeConstantList([]), [O.VariableElement]);
C.List_empty12 = H.setRuntimeTypeInfo(Isolate.makeConstantList([]), [B.HInstruction]);
C.List_empty13 = H.setRuntimeTypeInfo(Isolate.makeConstantList([]), [B.HBasicBlock]);
C.List_empty14 = H.setRuntimeTypeInfo(Isolate.makeConstantList([]), [O.LabelDefinition]);
C.List_empty2 = H.setRuntimeTypeInfo(Isolate.makeConstantList([]), [K.Constant]);
C.List_empty3 = H.setRuntimeTypeInfo(Isolate.makeConstantList([]), [V.DartType]);
C.List_empty4 = H.setRuntimeTypeInfo(Isolate.makeConstantList([]), [E.Selection]);
C.List_empty5 = H.setRuntimeTypeInfo(Isolate.makeConstantList([]), [O.ClassElement]);
C.List_empty6 = H.setRuntimeTypeInfo(Isolate.makeConstantList([]), [Z.TypeCheck]);
C.List_empty7 = H.setRuntimeTypeInfo(Isolate.makeConstantList([]), [P.$int]);
C.List_empty9 = H.setRuntimeTypeInfo(Isolate.makeConstantList([]), [F.TypeAnnotation0]);
C.List_gRj = Isolate.makeConstantList([0, 0, 32722, 12287, 65534, 34815, 65534, 18431]);
C.List_init_Isolate = H.setRuntimeTypeInfo(Isolate.makeConstantList(["init", "Isolate"]), [P.String]);
C.List_mJb = H.setRuntimeTypeInfo(Isolate.makeConstantList([18, 18, 18, 18, 18, 18, 18, 18, 18, 17, 17, 18, 18, 17, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 17, 3, 18, 16, 0, 3, 3, 18, 6, 7, 3, 3, 12, 3, 5, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 14, 15, 3, 3, 3, 13, 18, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 10, 18, 11, 3, 0, 18, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 3, 9, 3]), [P.$int]);
C.List_nxB = Isolate.makeConstantList([0, 0, 24576, 1023, 65534, 34815, 65534, 18431]);
C.List_p2F = H.setRuntimeTypeInfo(Isolate.makeConstantList(["++", "--"]), [P.String]);
C.List_qNA = Isolate.makeConstantList([0, 0, 32754, 11263, 65534, 34815, 65534, 18431]);
C.List_qg4 = Isolate.makeConstantList([0, 0, 65490, 12287, 65535, 34815, 65534, 18431]);
C.List_qg40 = Isolate.makeConstantList([0, 0, 32722, 12287, 65535, 34815, 65534, 18431]);
C.List_ru3 = H.setRuntimeTypeInfo(Isolate.makeConstantList([C.StringQuoting_false_1_34, C.StringQuoting_true_1_34, C.StringQuoting_false_1_39, C.StringQuoting_true_1_39]), [Y.StringQuoting]);
C.List_wcp = H.setRuntimeTypeInfo(Isolate.makeConstantList(["==", "hashCode", "toString", "noSuchMethod", "runtimeType", "isEmpty", "isNotEmpty", "length", "clear", "containsKey", "containsValue", "[]=", "keys"]), [P.String]);
C.List_yTu = H.setRuntimeTypeInfo(Isolate.makeConstantList([0, 2, 2, 3, 4]), [P.$int]);
C.LiteralDartString_IUt = new Y.LiteralDartString("");
C.LiteralDartString___proto__ = new Y.LiteralDartString("__proto__");
C.LiteralDartString_false = new Y.LiteralDartString("false");
C.LiteralDartString_null = new Y.LiteralDartString("null");
C.LiteralDartString_true = new Y.LiteralDartString("true");
C.List_4uk = Isolate.makeConstantList(["(", "[", "{", "<", "${"]);
C.Map_4u8XL = new H.ConstantStringMap(5, {"(": ")", "[": "]", "{": "}", "<": ">", "${": "}"}, C.List_4uk);
C.PrecedenceInfo_MIj = new Y.PrecedenceInfo(")", 0, 41);
C.PrecedenceInfo_6L0 = new Y.PrecedenceInfo("]", 0, 93);
C.PrecedenceInfo_atK = new Y.PrecedenceInfo("}", 0, 125);
C.PrecedenceInfo_TG0 = new Y.PrecedenceInfo(">", 7, 62);
C.Map_4uNPy = new H.ConstantStringMap(5, {"(": C.PrecedenceInfo_MIj, "[": C.PrecedenceInfo_6L0, "{": C.PrecedenceInfo_atK, "<": C.PrecedenceInfo_TG0, "${": C.PrecedenceInfo_atK}, C.List_4uk);
C.Map_empty = new H.ConstantStringMap(0, {}, C.List_empty);
C.List_eo1 = H.setRuntimeTypeInfo(Isolate.makeConstantList(["==", "!=", "===", "!==", "<", "<=", ">", ">="]), [P.String]);
C.Map_eoXV6 = H.setRuntimeTypeInfo(new H.ConstantStringMap(8, {"==": "!=", "!=": "==", "===": "!==", "!==": "===", "<": ">=", "<=": ">", ">": "<=", ">=": "<"}, C.List_eo1), [P.String, P.String]);
C.List_orQ = Isolate.makeConstantList(["async", "_blink", "_chrome", "collection", "convert", "core", "html", "html_common", "indexed_db", "io", "isolate", "js", "math", "mirrors", "profiler", "nativewrappers", "typed_data", "_native_typed_data", "svg", "web_audio", "web_gl", "web_sql", "_internal", "_js_helper", "_interceptors", "_foreign_helper", "_isolate_helper", "_js_mirrors", "_js_names", "_js_primitives", "_mirror_helper"]);
C.Maturity_QAb = new D.Maturity(4, "Stable", "The library is stable. API backwards-compatibility is guaranteed.\nHowever implementation details might change.");
C.LibraryInfo_iT4 = new D.LibraryInfo("async/async.dart", "Shared", null, "_internal/lib/async_patch.dart", true, 3, false, C.Maturity_QAb);
C.Maturity_4CA = new D.Maturity(-1, "Unspecified", "The maturity for this library has not been specified.");
C.LibraryInfo_gkc = new D.LibraryInfo("_blink/dartium/_blink_dartium.dart", "Client", null, null, false, 2, true, C.Maturity_4CA);
C.LibraryInfo_aZ8 = new D.LibraryInfo("_chrome/dart2js/chrome_dart2js.dart", "Client", null, null, false, 3, false, C.Maturity_4CA);
C.LibraryInfo_86y = new D.LibraryInfo("collection/collection.dart", "Shared", null, "_internal/lib/collection_patch.dart", true, 3, false, C.Maturity_QAb);
C.LibraryInfo_k2a = new D.LibraryInfo("convert/convert.dart", "Shared", null, "_internal/lib/convert_patch.dart", true, 3, false, C.Maturity_QAb);
C.LibraryInfo_D9n = new D.LibraryInfo("core/core.dart", "Shared", null, "_internal/lib/core_patch.dart", true, 3, false, C.Maturity_QAb);
C.Maturity_Mm5 = new D.Maturity(3, "Web Stable", "This library is tracking the DOM evolution as defined by WC3.\nBackwards-compatibility is NOT guaranteed.");
C.LibraryInfo_ALH = new D.LibraryInfo("html/dartium/html_dartium.dart", "Client", "html/dart2js/html_dart2js.dart", null, true, 3, false, C.Maturity_Mm5);
C.LibraryInfo_Nm5 = new D.LibraryInfo("html/html_common/html_common.dart", "Client", "html/html_common/html_common_dart2js.dart", null, false, 3, true, C.Maturity_Mm5);
C.LibraryInfo_OLF = new D.LibraryInfo("indexed_db/dartium/indexed_db_dartium.dart", "Client", "indexed_db/dart2js/indexed_db_dart2js.dart", null, true, 3, false, C.Maturity_Mm5);
C.LibraryInfo_7mY = new D.LibraryInfo("io/io.dart", "Server", null, "_internal/lib/io_patch.dart", true, 3, false, C.Maturity_QAb);
C.LibraryInfo_JmU = new D.LibraryInfo("isolate/isolate.dart", "Shared", null, "_internal/lib/isolate_patch.dart", true, 3, false, C.Maturity_QAb);
C.LibraryInfo_UVz = new D.LibraryInfo("js/dartium/js_dartium.dart", "Client", "js/dart2js/js_dart2js.dart", null, true, 3, false, C.Maturity_QAb);
C.LibraryInfo_OMf = new D.LibraryInfo("math/math.dart", "Shared", null, "_internal/lib/math_patch.dart", true, 3, false, C.Maturity_QAb);
C.Maturity_Toh = new D.Maturity(2, "Unstable", "This library is in still changing and have not yet endured\nsufficient real-world testing.\nBackwards-compatibility is NOT guaranteed.");
C.LibraryInfo_Yqr = new D.LibraryInfo("mirrors/mirrors.dart", "Shared", null, "_internal/lib/mirrors_patch.dart", true, 3, false, C.Maturity_Toh);
C.LibraryInfo_YCM = new D.LibraryInfo("profiler/profiler.dart", "Shared", null, null, true, 3, false, C.Maturity_Toh);
C.LibraryInfo_NS7 = new D.LibraryInfo("html/dartium/nativewrappers.dart", "Client", null, null, false, 2, true, C.Maturity_4CA);
C.LibraryInfo_qp8 = new D.LibraryInfo("typed_data/typed_data.dart", "Shared", null, "_internal/lib/typed_data_patch.dart", true, 3, false, C.Maturity_QAb);
C.LibraryInfo_yXb = new D.LibraryInfo("_internal/lib/native_typed_data.dart", "Internal", null, null, false, 1, true, C.Maturity_4CA);
C.LibraryInfo_vFz = new D.LibraryInfo("svg/dartium/svg_dartium.dart", "Client", "svg/dart2js/svg_dart2js.dart", null, true, 3, false, C.Maturity_Mm5);
C.LibraryInfo_Ir3 = new D.LibraryInfo("web_audio/dartium/web_audio_dartium.dart", "Client", "web_audio/dart2js/web_audio_dart2js.dart", null, true, 3, false, C.Maturity_Mm5);
C.LibraryInfo_bPQ = new D.LibraryInfo("web_gl/dartium/web_gl_dartium.dart", "Client", "web_gl/dart2js/web_gl_dart2js.dart", null, true, 3, false, C.Maturity_Mm5);
C.LibraryInfo_OHR = new D.LibraryInfo("web_sql/dartium/web_sql_dartium.dart", "Client", "web_sql/dart2js/web_sql_dart2js.dart", null, true, 3, false, C.Maturity_Mm5);
C.LibraryInfo_e1Q = new D.LibraryInfo("internal/internal.dart", "Internal", null, "_internal/lib/internal_patch.dart", false, 3, false, C.Maturity_4CA);
C.LibraryInfo_uo1 = new D.LibraryInfo("_internal/lib/js_helper.dart", "Internal", null, null, false, 1, false, C.Maturity_4CA);
C.LibraryInfo_0sb = new D.LibraryInfo("_internal/lib/interceptors.dart", "Internal", null, null, false, 1, false, C.Maturity_4CA);
C.LibraryInfo_8co = new D.LibraryInfo("_internal/lib/foreign_helper.dart", "Internal", null, null, false, 1, false, C.Maturity_4CA);
C.LibraryInfo_GF2 = new D.LibraryInfo("_internal/lib/isolate_helper.dart", "Internal", null, null, false, 1, false, C.Maturity_4CA);
C.LibraryInfo_ijq = new D.LibraryInfo("_internal/lib/js_mirrors.dart", "Internal", null, null, false, 1, false, C.Maturity_4CA);
C.LibraryInfo_wqv = new D.LibraryInfo("_internal/lib/js_names.dart", "Internal", null, null, false, 1, false, C.Maturity_4CA);
C.LibraryInfo_7PY = new D.LibraryInfo("_internal/lib/js_primitives.dart", "Internal", null, null, false, 1, false, C.Maturity_4CA);
C.LibraryInfo_8aB = new D.LibraryInfo("_internal/lib/mirror_helper.dart", "Internal", null, null, false, 1, false, C.Maturity_4CA);
C.Map_or8xz = new H.ConstantStringMap(31, {async: C.LibraryInfo_iT4, _blink: C.LibraryInfo_gkc, _chrome: C.LibraryInfo_aZ8, collection: C.LibraryInfo_86y, convert: C.LibraryInfo_k2a, core: C.LibraryInfo_D9n, html: C.LibraryInfo_ALH, html_common: C.LibraryInfo_Nm5, indexed_db: C.LibraryInfo_OLF, io: C.LibraryInfo_7mY, isolate: C.LibraryInfo_JmU, js: C.LibraryInfo_UVz, math: C.LibraryInfo_OMf, mirrors: C.LibraryInfo_Yqr, profiler: C.LibraryInfo_YCM, nativewrappers: C.LibraryInfo_NS7, typed_data: C.LibraryInfo_qp8, _native_typed_data: C.LibraryInfo_yXb, svg: C.LibraryInfo_vFz, web_audio: C.LibraryInfo_Ir3, web_gl: C.LibraryInfo_bPQ, web_sql: C.LibraryInfo_OHR, _internal: C.LibraryInfo_e1Q, _js_helper: C.LibraryInfo_uo1, _interceptors: C.LibraryInfo_0sb, _foreign_helper: C.LibraryInfo_8co, _isolate_helper: C.LibraryInfo_GF2, _js_mirrors: C.LibraryInfo_ijq, _js_names: C.LibraryInfo_wqv, _js_primitives: C.LibraryInfo_7PY, _mirror_helper: C.LibraryInfo_8aB}, C.List_orQ);
C.List_qww = Isolate.makeConstantList(["&&", "||", "==", "!=", ">", ">=", "<", "<=", "|", "^", "&", ">>", "<<", "+", "-", "*", "%", "/", "~/"]);
C.Map_qwccO = new H.ConstantStringMap(19, {"&&": 4, "||": 3, "==": 6, "!=": 6, ">": 7, ">=": 7, "<": 7, "<=": 7, "|": 8, "^": 9, "&": 10, ">>": 11, "<<": 11, "+": 12, "-": 12, "*": 13, "%": 13, "/": 13, "~/": 13}, C.List_qww);
C.MaxIntValue_null = new B.MaxIntValue(null);
C.MemberKind_getter = new K.MemberKind("getter");
C.MemberKind_method = new K.MemberKind("method");
C.MemberKind_operator = new K.MemberKind("operator");
C.MemberKind_setter = new K.MemberKind("setter");
C.MessageKind_0 = new K.MessageKind("Incorrect number of type arguments on '#{type}'.", null, null);
C.List_IeE = Isolate.makeConstantList(["// 'List' is misspelled.\n@MirrorsUsed(targets: 'dart.core.Lsit')\nimport 'dart:mirrors';\n\nmain() {}\n"]);
C.MessageKind_00 = new K.MessageKind("Can't find '#{name}' in the library '#{library}'.", "Is '#{name}' spelled right?", C.List_IeE);
C.MessageKind_01 = new K.MessageKind("'#{value}' is not a valid Symbol name because is not:\n * an empty String,\n * a user defined operator,\n * a qualified non-private identifier optionally followed by '=', or\n * a qualified non-private identifier followed by '.' and a user-defined operator.", null, null);
C.List_IoD = Isolate.makeConstantList(["// 'addAll' is misspelled.\n@MirrorsUsed(targets: 'dart.core.List.addAl')\nimport 'dart:mirrors';\n\nmain() {}\n"]);
C.MessageKind_27z = new K.MessageKind("Can't find '#{name}' in '#{element}'.", "Is '#{name}' spelled right?", C.List_IoD);
C.MessageKind_2No = new K.MessageKind("Patch return type '#{patchReturnType}' does not match '#{originReturnType}' on origin method '#{methodName}'.", null, null);
C.List_nRX = Isolate.makeConstantList(["main.dart", "decl1.dart", "decl2.dart"]);
C.Map_nRhU9 = new H.ConstantStringMap(3, {"main.dart": "export 'decl1.dart';\nexport 'decl2.dart';\n\nmain() {}", "decl1.dart": "class Class {}", "decl2.dart": "class Class {}"}, C.List_nRX);
C.List_Map_nRhU9 = Isolate.makeConstantList([C.Map_nRhU9]);
C.MessageKind_2No0 = new K.MessageKind("Duplicate export of '#{name}'.", "Trying adding 'hide #{name}' to one of the exports.", C.List_Map_nRhU9);
C.MessageKind_2Rm = new K.MessageKind("This is the setter patch '#{setterName}'.", null, null);
C.MessageKind_2Rm0 = new K.MessageKind("This is the getter patch '#{getterName}'.", null, null);
C.MessageKind_2Vk = new K.MessageKind("Variable '#{variableName}' is not shown to have type '#{shownType}' because '#{shownType}' is not more specific than the known type '#{knownType}' of '#{variableName}'.", null, null);
C.MessageKind_2Vk0 = new K.MessageKind("#{hints} hint(s) suppressed in #{uri}.", null, null);
C.MessageKind_2rf = new K.MessageKind("'super' is only available in instance methods.", null, null);
C.MessageKind_3KU = new K.MessageKind("'===' is not an operator. Did you mean '#{lhs} == #{rhs}' or 'identical(#{lhs}, #{rhs})'?", null, null);
C.MessageKind_3bx = new K.MessageKind("Existing definition of '#{name}'.", null, null);
C.MessageKind_3fE = new K.MessageKind("Variable '#{variableName}' is not known to be of type '#{shownType}' because it is accessed by a closure in the scope for promotion and potentially mutated in the scope of '#{variableName}'.", null, null);
C.MessageKind_43h = new K.MessageKind("Formal parameters are missing.", null, null);
C.MessageKind_43h0 = new K.MessageKind("Class used as mixin introduces mixin cycle: '#{mixinName1}' <-> '#{mixinName2}'.", null, null);
C.MessageKind_44i = new K.MessageKind("Field '#{fieldName}' is initialized more than once.", null, null);
C.MessageKind_46y = new K.MessageKind("Operator '#{operatorName}' must have no parameters.", null, null);
C.MessageKind_46y0 = new K.MessageKind("Cannot assign a value to a method.", null, null);
C.MessageKind_4AN = new K.MessageKind("Const-map key type '#{type}' overrides 'operator =='.", null, null);
C.List_HTT = Isolate.makeConstantList(["class B { }\nclass M1 {  }\ntypedef C = B with M1;  // Need to replace 'typedef' with 'class'.\nmain() { new C(); }\n"]);
C.MessageKind_4AN0 = new K.MessageKind("'typedef' not allowed here. ", "Try replacing 'typedef' with 'class'.", C.List_HTT);
C.List_KcR = Isolate.makeConstantList(["class C {\n  const C() {}\n}\n\nmain() => new C();"]);
C.MessageKind_4CA = new K.MessageKind("Const constructor or factory can't have a body.", "Remove the 'const' keyword or the body", C.List_KcR);
C.MessageKind_4CA0 = new K.MessageKind("'#{className}.#{memberName}' is not static.", null, null);
C.List_aEk = Isolate.makeConstantList(["main() {\n}\n/*"]);
C.MessageKind_4DV = new K.MessageKind("Comment starting with '/*' must end with '*/'.", "", C.List_aEk);
C.MessageKind_4MG = new K.MessageKind("Cannot resolve label '#{labelName}'.", null, null);
C.MessageKind_4Nc = new K.MessageKind("Missing argument of type '#{argumentType}'.", null, null);
C.MessageKind_4QU = new K.MessageKind("'#{node}' is not a type.", null, null);
C.MessageKind_4YV = new K.MessageKind("'#{type}' can not be both extended and implemented.", null, null);
C.MessageKind_4lO = new K.MessageKind("Cannot use optional parameters in catch.", null, null);
C.List_mGg = Isolate.makeConstantList(["void x; main() {}", "foo(void x) {} main() { foo(null); }"]);
C.MessageKind_4lY = new K.MessageKind("Type 'void' can't be used here because it isn't a return type.", "Try removing 'void' keyword or replace it with 'var', 'final', or a type.", C.List_mGg);
C.List_NWH = Isolate.makeConstantList(["typedef void F([int arg = 0]);\n\nmain() {\n  F f;\n}", "typedef void F({int arg: 0});\n\nmain() {\n  F f;\n}"]);
C.MessageKind_4u1 = new K.MessageKind("A parameter of a typedef can't specify a default value.", "Try removing the default value.", C.List_NWH);
C.MessageKind_56y = new K.MessageKind("This is the declaration of '#{name}'.", null, null);
C.MessageKind_5Jd = new K.MessageKind("Operator '#{operatorName}' cannot have optional parameters.", null, null);
C.MessageKind_5NE = new K.MessageKind("Redirecting constructor can't have a body.", null, null);
C.MessageKind_5UV = new K.MessageKind("Cannot use class '#{className}' as a mixin because it uses 'super'.", null, null);
C.MessageKind_5iV = new K.MessageKind("Cyclic constructor redirection.", null, null);
C.List_8aB = Isolate.makeConstantList(["abstract class A {} main() { new A(); }"]);
C.MessageKind_5ib = new K.MessageKind("Can't instantiate abstract class.", "", C.List_8aB);
C.MessageKind_63w = new K.MessageKind("Patch method parameter '#{parameterName}' type '#{patchParameterType}' does not match '#{originParameterType}' on origin method '#{methodName}'.", null, null);
C.MessageKind_69x = new K.MessageKind("No expression after 'throw'. Did you mean 'rethrow'?", null, null);
C.MessageKind_6QF = new K.MessageKind("Constructor is not a 'const' constructor.", null, null);
C.MessageKind_6aU = new K.MessageKind("Only constructors can have initializers.", null, null);
C.MessageKind_6dL = new K.MessageKind("'super' not allowed here.", null, null);
C.List_hgS = Isolate.makeConstantList(["main() {\n  var m = const {'foo': 1, 'foo': 2};\n}"]);
C.MessageKind_6ez = new K.MessageKind("An entry with the same key already exists in the map.", "Try removing the previous entry or changing the key in one of the entries.", C.List_hgS);
C.MessageKind_6hp = new K.MessageKind("Cannot patch non-constructor with constructor patch '#{constructorName}'.", null, null);
C.MessageKind_6qD = new K.MessageKind("Cannot have return type for constructor.", null, null);
C.MessageKind_6xV = new K.MessageKind("The class '#{class}' overrides 'operator==', but not 'get hashCode'.", null, null);
C.MessageKind_7Re = new K.MessageKind("`null` can't be used here.", null, null);
C.MessageKind_7Re0 = new K.MessageKind("Getter '#{name}' in '#{class}' can't override method from '#{inheritedClass}'.", null, null);
C.List_DV7 = Isolate.makeConstantList(["abstract class I {\n  get m;\n}\nclass C implements I {}\nmain() => new C();\n", "abstract class I {\n  get m;\n}\nclass C extends I {}\nmain() => new C();\n"]);
C.MessageKind_8Gl = new K.MessageKind("'#{class}' doesn't implement the getter '#{name}' declared in '#{declarer}'.", "Try adding an implementation of '#{name}' or declaring '#{class}' to be 'abstract'.", C.List_DV7);
C.MessageKind_8aB = new K.MessageKind("The getter '#{name}' is declared here in class '#{class}'.", null, null);
C.List_IF2 = Isolate.makeConstantList(["foo(f(int i, [a = 1])) {}\n\nmain() {\n  foo(1, 2);\n}", "foo(f(int i, {a: 1})) {}\n\nmain() {\n  foo(1, a: 2);\n}"]);
C.MessageKind_8eb = new K.MessageKind("A function type parameter can't specify a default value.", "Try removing the default value.", C.List_IF2);
C.MessageKind_8h5 = new K.MessageKind("No named argument '#{argumentName}' found on method.", null, null);
C.MessageKind_8hf = new K.MessageKind("'case' expression of type '#{type}'.", null, null);
C.List_dOG = Isolate.makeConstantList(["// '1' is not a string.\n@MirrorsUsed(targets: 1)\nimport 'dart:mirrors';\n\nmain() {}\n"]);
C.MessageKind_8sC = new K.MessageKind("Can't use '#{name}' here because it's an instance of '#{type}' but a 'String', 'Type', or 'List' value is expected.", "Did you forget to add quotes?", C.List_dOG);
C.MessageKind_8xB = new K.MessageKind("Implicit 'super' call arguments and constructor parameters do not match.", null, null);
C.List_EQs = Isolate.makeConstantList(["class A {\n  get member => null;\n}\nclass B {\n  member() {}\n}\nclass Class implements A, B {\n}\nmain() => new Class();\n"]);
C.MessageKind_9U7 = new K.MessageKind("The class '#{class}' can't inherit both getters and methods by the named '#{name}'.", "", C.List_EQs);
C.List_iD3 = Isolate.makeConstantList(["class C { static final field; } main() => C.field;"]);
C.MessageKind_ACG = new K.MessageKind("A final variable must be initialized.", "Try adding an initializer or removing the 'final' modifier.", C.List_iD3);
C.MessageKind_AHF = new K.MessageKind("Constructor name must start with '#{name}'.", null, null);
C.MessageKind_AHc = new K.MessageKind("'case' expression may not be of type '#{type}'.", null, null);
C.MessageKind_AIG = new K.MessageKind("'continue' statement not inside loop.", null, null);
C.MessageKind_AQu = new K.MessageKind("The setter '#{name}' is declared here in class '#{class}'.", null, null);
C.MessageKind_AYZ = new K.MessageKind("Missing type argument.", null, null);
C.MessageKind_Agx = new K.MessageKind("Target of break is not a statement.", null, null);
C.MessageKind_B8J = new K.MessageKind("This is the overridden method '#{name}' declared in class '#{class}'.", null, null);
C.MessageKind_C1h = new K.MessageKind("No setter found for setter patch '#{setterName}'.", null, null);
C.MessageKind_C3e = new K.MessageKind("The getter '#{name}' is implicitly declared by this field in class '#{class}'.", null, null);
C.MessageKind_CBD = new K.MessageKind("The exported '#{name}' from export #{uriString} is defined here.", null, null);
C.MessageKind_CFL = new K.MessageKind("Extra parameter in catch declaration.", null, null);
C.MessageKind_CRg = new K.MessageKind("This is the overridden field '#{name}' declared in class '#{class}'.", null, null);
C.MessageKind_CnH = new K.MessageKind("The type '#{declaredType}' of field '#{name}' declared in '#{class}' is not assignable to the type '#{inheritedType}' of the overridden field inherited from '#{inheritedClass}'.", null, null);
C.MessageKind_Djp = new K.MessageKind("Variable '#{variableName}' is not shown to have type '#{shownType}' because '#{shownType}' is not more specific than the known type '#{knownType}' of '#{variableName}'.", "Try replacing '#{shownType}' with '#{shownTypeSuggestion}'.", null);
C.MessageKind_E4y = new K.MessageKind("This is the field that cannot be overridden by a method.", null, null);
C.List_dOG0 = Isolate.makeConstantList(["main() {\n  String x = \u00e7;\n}\n"]);
C.MessageKind_EDB = new K.MessageKind("Character U+#{characterHex} isn't allowed here.", "", C.List_dOG0);
C.MessageKind_EKW = new K.MessageKind("'!==' is not an operator. Did you mean '#{lhs} != #{rhs}' or '!identical(#{lhs}, #{rhs})'?", null, null);
C.MessageKind_EOZ = new K.MessageKind("A setter must have exactly one argument.", null, null);
C.MessageKind_EUF = new K.MessageKind("Original declaration of duplicate label '#{labelName}'.", null, null);
C.MessageKind_EWB = new K.MessageKind("Additional type argument.", null, null);
C.List_TDm = Isolate.makeConstantList(["class A implements Malformed {}\nmain() => new A();"]);
C.MessageKind_Eba = new K.MessageKind("Class '#{className}' can't implement the type '#{malformedType}' because it is malformed.", "Try correcting the malformed type annotation or removing the type from the 'implements' clause.", C.List_TDm);
C.MessageKind_EkK = new K.MessageKind("Class used as mixin cannot have non-factory constructor.", null, null);
C.List_gQg = Isolate.makeConstantList(["class A extends Malformed {}\nmain() => new A();"]);
C.MessageKind_EqP = new K.MessageKind("Class '#{className}' can't extend the type '#{malformedType}' because it is malformed.", "Try correcting the malformed type annotation or removing the 'extends' clause.", C.List_gQg);
C.MessageKind_Ewx = new K.MessageKind("Using 'new #{name}' may lead to unnecessarily large generated code.", "Try using 'const #{name}' or adding '@MirrorsUsed(...)' as described at https://goo.gl/Akrrog.", null);
C.MessageKind_EyN = new K.MessageKind("Cycle in the compile-time constant computation.", null, null);
C.MessageKind_EyN0 = new K.MessageKind("Field initializer expected.", null, null);
C.List_3jH = Isolate.makeConstantList(["foo(const x) {}\nmain() => foo(42);\n", "foo({const x}) {}\nmain() => foo(42);\n", "foo([const x]) {}\nmain() => foo(42);\n"]);
C.MessageKind_FGJ = new K.MessageKind("A formal parameter can't be declared const.", "Try removing 'const'.", C.List_3jH);
C.MessageKind_FKl = new K.MessageKind("Directive not allowed here.", null, null);
C.MessageKind_G79 = new K.MessageKind("Cannot refer to type variable '#{typeVariableName}' within a static member.", null, null);
C.List_BEW = Isolate.makeConstantList(["main.dart", "part.dart"]);
C.Map_BEU49 = new H.ConstantStringMap(2, {"main.dart": "library lib.foo;\n\npart 'part.dart';\n\nmain() {}\n", "part.dart": "part of lib.bar;\n"}, C.List_BEW);
C.List_Map_BEU49 = Isolate.makeConstantList([C.Map_BEU49]);
C.MessageKind_GXH = new K.MessageKind("Expected part of library name '#{libraryName}'.", "Trying changing the directive to 'part of #{libraryName};'.", C.List_Map_BEU49);
C.MessageKind_GnF = new K.MessageKind("'default' only allowed on last case of a switch.", null, null);
C.List_sE2 = Isolate.makeConstantList(["class DeadCode {} main() {}"]);
C.MessageKind_Gpa = new K.MessageKind("The class '#{name}' is never used.", "Consider deleting it.", C.List_sE2);
C.List_yXb = Isolate.makeConstantList(["// 'main' is a method, not a class.\n@MirrorsUsed(targets: const [main])\nimport 'dart:mirrors';\n\nmain() {}\n"]);
C.MessageKind_Gx4 = new K.MessageKind("Can't use '#{name}' here because it's an instance of '#{type}' and a 'String' or 'Type' value is expected.", "Did you forget to add quotes?", C.List_yXb);
C.MessageKind_HRf = new K.MessageKind("'#{name}' is (re)exported by multiple libraries.", null, null);
C.List_qBv = Isolate.makeConstantList(["abstract class I {\n  get m;\n}\nabstract class J {\n  get m;\n}\nclass C implements I, J {}\nmain() => new C();\n", "abstract class I {\n  get m;\n}\nabstract class J {\n  get m;\n}\nclass C extends I implements J {}\nmain() => new C();\n"]);
C.MessageKind_I6V = new K.MessageKind("'#{class}' doesn't implement the getter '#{name}'.", "Try adding an implementation of '#{name}' or declaring '#{class}' to be 'abstract'.", C.List_qBv);
C.MessageKind_IAi = new K.MessageKind("This const constructor is not allowed due to non-final fields.", null, null);
C.MessageKind_IFE = new K.MessageKind("No getter found for getter patch '#{getterName}'.", null, null);
C.MessageKind_IGI = new K.MessageKind("Cannot resolve '#{memberName}' in a superclass of '#{className}'.", null, null);
C.List_Wrl = Isolate.makeConstantList(["main() {\n  return '$';\n}\n", "main() {\n  return \"$\";\n}\n", "main() {\n  return '''$''';\n}\n", "main() {\n  return \"\"\"$\"\"\";\n}\n"]);
C.MessageKind_IMh = new K.MessageKind("A '$' has special meaning inside a string, and must be followed by an identifier or an expression in curly braces ({}).", "Try adding a backslash (\\) to escape the '$'.", C.List_Wrl);
C.List_96V = Isolate.makeConstantList(["main() {\n  return '\n;\n}\n", "main() {\n  return \"\n;\n}\n", "main() {\n  return r'\n;\n}\n", "main() {\n  return r\"\n;\n}\n", "main() => '''\n", "main() => \"\"\"\n", "main() => r'''\n", "main() => r\"\"\"\n"]);
C.MessageKind_IqA = new K.MessageKind("String must end with #{quote}.", "", C.List_96V);
C.MessageKind_IyK = new K.MessageKind("No method named '#{memberName}' in class '#{className}'.", null, null);
C.List_pMf = Isolate.makeConstantList(["abstract class I {\n  m();\n}\n\nabstract class J {\n  m();\n}\n\nclass C implements I, J {}\n\nmain() {\n new C();\n}\n", "abstract class I {\n  m();\n}\n\nabstract class J {\n  m();\n}\n\nclass C extends I implements J {}\n\nmain() {\n new C();\n}\n"]);
C.MessageKind_IzL = new K.MessageKind("'#{class}' doesn't implement '#{method}'.", "Try adding an implementation of '#{name}' or declaring '#{class}' to be 'abstract'.", C.List_pMf);
C.MessageKind_JAZ = new K.MessageKind("The inherited getter '#{name}' is implicitly declared by this field in class '#{class}'.", null, null);
C.MessageKind_JAi = new K.MessageKind("Unnamed argument after named argument.", null, null);
C.MessageKind_JJ0 = new K.MessageKind("Could not find '#{main}'.", "Try adding a method named '#{main}' to your program.", null);
C.MessageKind_Jik = new K.MessageKind("Expected 'catch' or 'finally'.", null, null);
C.MessageKind_Jsm = new K.MessageKind("Dart2js does not currently support inheritance of the same class with different type arguments: Both #{firstType} and #{secondType} are supertypes of #{thisType}.", null, null);
C.List_UZQ = Isolate.makeConstantList(["var String foo; main(){}", "var set foo; main(){}", "var final foo; main(){}", "var var foo; main(){}", "var const foo; main(){}", "var abstract foo; main(){}", "var static foo; main(){}", "var external foo; main(){}", "get var foo; main(){}", "set var foo; main(){}", "final var foo; main(){}", "var var foo; main(){}", "const var foo; main(){}", "abstract var foo; main(){}", "static var foo; main(){}", "external var foo; main(){}"]);
C.MessageKind_KQp = new K.MessageKind("Can't have modifier '#{modifier}' here.", "Try removing '#{modifier}'.", C.List_UZQ);
C.List_43h = Isolate.makeConstantList(["class C<T> {\n  const C();\n\n  m(T t) => const C<T>();\n}\n\nvoid main() => new C().m(null);\n"]);
C.MessageKind_Kz0 = new K.MessageKind("Constant expressions can't refer to type variables.", "Try removing the type variable or replacing it with a concrete type.", C.List_43h);
C.MessageKind_LJp = new K.MessageKind("Did you forget a factory keyword here?", null, null);
C.MessageKind_LQb = new K.MessageKind("'#{fieldName}' is not an instance field.", null, null);
C.MessageKind_M2I = new K.MessageKind("Invalid initializer.", null, null);
C.List_MjY = Isolate.makeConstantList(["class C extends Object with String {}\n\nmain() => new C();\n", "typedef C = Object with String;\n\nmain() => new C();\n"]);
C.MessageKind_M2b = new K.MessageKind("The type '#{type}' can't be mixed in.", "Try removing '#{type}' from the 'with' clause.", C.List_MjY);
C.MessageKind_MQy = new K.MessageKind("'#{className}' creates a cycle in the class hierarchy.", null, null);
C.MessageKind_MUs = new K.MessageKind("Import of 'dart:mirrors'.", null, null);
C.MessageKind_MYA = new K.MessageKind("Patching non-class with class patch '#{className}'.", null, null);
C.List_6Zp = Isolate.makeConstantList(["class C {\n  const int a = 1;\n}\n\nmain() => new C();"]);
C.MessageKind_Mkc = new K.MessageKind("Cannot have const modifier on non-static field.", "Try adding a static modifier, or removing the const modifier.", C.List_6Zp);
C.MessageKind_MmD = new K.MessageKind("Additional argument.", null, null);
C.MessageKind_Mny = new K.MessageKind("Initializing formal parameter only allowed in generative constructor.", null, null);
C.MessageKind_MyU = new K.MessageKind("Instance member '#{memberName}' and static member of superclass '#{className}' have the same name.", null, null);
C.Map_BEgPO = new H.ConstantStringMap(2, {"main.dart": "part 'part.dart';\n\nmain() {}\n", "part.dart": "part of lib.foo;\n"}, C.List_BEW);
C.List_Map_BEgPO = Isolate.makeConstantList([C.Map_BEgPO]);
C.MessageKind_NMc = new K.MessageKind("Library has no name. Part directive expected library name to be '#{libraryName}'.", "Trying adding 'library #{libraryName};' to the library.", C.List_Map_BEgPO);
C.List_OW3 = Isolate.makeConstantList(["foo(var int x(int a)) {}\nmain() => foo((y) => 42);\n", "foo({var int x(int a)}) {}\nmain() => foo((y) => 42);\n", "foo([var int x(int a)]) {}\nmain() => foo((y) => 42);\n"]);
C.MessageKind_NYu = new K.MessageKind("A function type parameter can't be declared with 'var'.", "Try removing 'var'.", C.List_OW3);
C.List_4ig = Isolate.makeConstantList(["class A extends Object with Malformed {}\nmain() => new A();"]);
C.MessageKind_NcA = new K.MessageKind("Class '#{className}' can't mixin the type '#{malformedType}' because it is malformed.", "Try correcting the malformed type annotation or removing the type from the 'with' clause.", C.List_4ig);
C.MessageKind_O92 = new K.MessageKind("Optional parameter count of patch method (#{patchParameterCount}) does not match parameter count on origin method '#{methodName}' (#{originParameterCount}).", null, null);
C.MessageKind_OOv = new K.MessageKind("This is the method that cannot be overridden by a field.", null, null);
C.MessageKind_OPN = new K.MessageKind("Type variable '#{typeVariableName}' already declared.", null, null);
C.List_sty = Isolate.makeConstantList(["typedef F F(); // The return type 'F' is a self-reference.\nmain() { F f = null; }"]);
C.MessageKind_Olq = new K.MessageKind("A typedef can't refer to itself.", "Try removing all references to '#{typedefName}' in the definition of '#{typedefName}'.", C.List_sty);
C.MessageKind_PPt = new K.MessageKind("#{warnings} warning(s) suppressed in #{uri}.", null, null);
C.MessageKind_PTQ = new K.MessageKind("No member named '#{memberName}' in class '#{className}'.", null, null);
C.MessageKind_Pn6 = new K.MessageKind("No getter named '#{memberName}' in class '#{className}'.", null, null);
C.MessageKind_Q4d = new K.MessageKind("'Object' cannot have a super initializer.", null, null);
C.List_axY = Isolate.makeConstantList(["var main;"]);
C.MessageKind_Q8B = new K.MessageKind("'#{main}' is not a function.", "", C.List_axY);
C.MessageKind_Q9z = new K.MessageKind("A Deferred value cannot be used as a compile-time constant.", null, null);
C.MessageKind_Qcp = new K.MessageKind("Incomplete token.", null, null);
C.List_bfs = Isolate.makeConstantList(["class Class {\n  method();\n}\nmain() => new Class().method();\n"]);
C.MessageKind_QgR = new K.MessageKind("The method '#{name}' has no implementation in class '#{class}'.", "Try adding a body to '#{name}' or declaring '#{class}' to be 'abstract'.", C.List_bfs);
C.MessageKind_QnN = new K.MessageKind("'#{libraryName}' has no member named '#{memberName}'.", null, null);
C.List_2jN = Isolate.makeConstantList(["class C {\n  // 'a' must be declared final to allow for the const constructor.\n  var a;\n  const C(this.a);\n}\n\nmain() => new C(0);"]);
C.MessageKind_QpY = new K.MessageKind("Can't declare constructor 'const' on class #{className} because the class contains non-final instance fields.", "Try making all fields final.", C.List_2jN);
C.MessageKind_QtW = new K.MessageKind("The type '#{declaredType}' of getter '#{name}' declared in '#{class}' is not assignable to the type '#{inheritedType}' of the overridden getter inherited from '#{inheritedClass}'.", null, null);
C.MessageKind_QtW0 = new K.MessageKind("The type '#{declaredType}' of setter '#{name}' declared in '#{class}' is not assignable to the type '#{inheritedType}' of the overridden setter inherited from '#{inheritedClass}'.", null, null);
C.MessageKind_R1M = new K.MessageKind("'#{type}' cannot be extended.", null, null);
C.MessageKind_RoN = new K.MessageKind("'case' expression type '#{type}' overrides 'operator =='.", null, null);
C.MessageKind_RsV = new K.MessageKind("Wrong number of arguments to assert. Should be 1, but given #{argumentCount}.", null, null);
C.MessageKind_S4x = new K.MessageKind("Top-level variable cannot be declared static.", null, null);
C.MessageKind_SFN = new K.MessageKind("Cannot resolve '#{name}'.", null, null);
C.MessageKind_Tj8 = new K.MessageKind("'break' statement not inside switch or loop.", null, null);
C.MessageKind_U8J = new K.MessageKind("The inherited method '#{name}' is declared here in class '#{class}'.", null, null);
C.MessageKind_UEe = new K.MessageKind("Part header must come before top-level definitions.", null, null);
C.List_xw8 = Isolate.makeConstantList(["void main() {\n  const c; // This constant variable must be initialized.\n}"]);
C.MessageKind_UQk = new K.MessageKind("A constant variable must be initialized.", "Try adding an initializer or removing the 'const' modifier.", C.List_xw8);
C.MessageKind_USZ = new K.MessageKind("Duplicated part-of directive.", null, null);
C.MessageKind_UyX = new K.MessageKind("'assert' takes no named arguments, but given #{argumentCount}.", null, null);
C.List_mEp = Isolate.makeConstantList(["main(", "main(){", "main(){]}"]);
C.MessageKind_V4w = new K.MessageKind("Can't find '#{end}' to match '#{begin}'.", "", C.List_mEp);
C.MessageKind_VUC = new K.MessageKind("Invalid for-in variable declaration.", null, null);
C.MessageKind_VyX = new K.MessageKind("Cannot resolve type '#{typeName}'.", null, null);
C.MessageKind_W1e = new K.MessageKind("This is the part of directive.", null, null);
C.MessageKind_W7h = new K.MessageKind("This is the instance member that cannot be overridden by a static member.", null, null);
C.MessageKind_WR8 = new K.MessageKind("The compiler crashed when compiling this element.", null, null);
C.MessageKind_WR80 = new K.MessageKind("Variable '#{variableName}' is not known to be of type '#{shownType}' because it is potentially mutated in the scope for promotion.", null, null);
C.MessageKind_WR81 = new K.MessageKind("Type variable '#{typeVariableName}' is a supertype of itself.", null, null);
C.MessageKind_Wfv = new K.MessageKind("'#{value}' is not a valid Symbol name because it starts with '_'.", null, null);
C.MessageKind_Wfv0 = new K.MessageKind("Cannot patch non-function with function patch '#{functionName}'.", null, null);
C.List_xEP = Isolate.makeConstantList(["main() => true ? 1;", "main() => foo(x: 1 y: 2);"]);
C.MessageKind_Whe = new K.MessageKind("Expected '#{token}' before this.", "", C.List_xEP);
C.List_ZeB = Isolate.makeConstantList(["class A {\n  A.foo() {}\n}\nclass B extends A {\n  B();\n}\nmain() => new B();\n"]);
C.MessageKind_Wv6 = new K.MessageKind("cannot resolve constructor '#{constructorName}' for implicit super call.", "Try explicitly invoking a constructor of the super class", C.List_ZeB);
C.List_UwQ = Isolate.makeConstantList(["main() {\n  foo(a: 1) => print(a);\n  foo(2);\n}", "main() {\n  foo(a = 1) => print(a);\n  foo(2);\n}"]);
C.MessageKind_XSe = new K.MessageKind("Non-optional parameters can't have a default value.", "Try removing the default value or making the parameter optional.", C.List_UwQ);
C.MessageKind_XXT = new K.MessageKind("'#{name}' is defined here.", null, null);
C.MessageKind_YAz = new K.MessageKind("This is the overridden getter '#{name}' declared in class '#{class}'.", null, null);
C.MessageKind_YZe = new K.MessageKind("#{warnings} warning(s) and #{hints} hint(s) suppressed in #{uri}.", null, null);
C.MessageKind_YZn = new K.MessageKind("This import is not annotated with @MirrorsUsed, which may lead to unnecessarily large generated code.", "Try adding '@MirrorsUsed(...)' as described at https://goo.gl/Akrrog.", null);
C.MessageKind_Yeh = new K.MessageKind("'#{fromType}' is not assignable to '#{toType}'.", null, null);
C.MessageKind_Yqn = new K.MessageKind("'#{name}' cannot be called on super.", null, null);
C.List_h0k = Isolate.makeConstantList(["main() {\n  foo({a = 1}) => print(a);\n  foo(a: 2);\n}"]);
C.MessageKind_ZaR = new K.MessageKind("Named optional parameters can't use '=' to specify a default value.", "Try replacing '=' with ':'.", C.List_h0k);
C.List_4AN = Isolate.makeConstantList(["class C {\n  C() {\n    return 1;\n  }\n}\n\nmain() => new C();"]);
C.MessageKind_aBG = new K.MessageKind("Constructors can't return values.", "Remove the return statement or use a factory constructor.", C.List_4AN);
C.MessageKind_aI0 = new K.MessageKind("A deferred class cannot be used to create acompile-time constant.", null, null);
C.MessageKind_aPa = new K.MessageKind("Redirecting factory leads to a cyclic redirection.", null, null);
C.List_O92 = Isolate.makeConstantList(["foo(static x) {}\nmain() => foo(42);\n", "foo({static x}) {}\nmain() => foo(42);\n", "foo([static x]) {}\nmain() => foo(42);\n"]);
C.MessageKind_aTW = new K.MessageKind("A formal parameter can't be declared static.", "Try removing 'static'.", C.List_O92);
C.MessageKind_aVU = new K.MessageKind("Deferred loading is not supported by the dart backend yet.The output will not be split.", null, null);
C.MessageKind_aVa = new K.MessageKind("Operator '-' must have 0 or 1 parameters.", null, null);
C.List_Fcu = Isolate.makeConstantList(["abstract class I {\n  set m(_);\n}\nabstract class J {\n  set m(_);\n}\nclass C implements I, J {}\nmain() => new C();\n", "abstract class I {\n  set m(_);\n}\nabstract class J {\n  set m(_);\n}\nclass C extends I implements J {}\nmain() => new C();\n"]);
C.MessageKind_ad7 = new K.MessageKind("'#{class}' doesn't implement the setter '#{name}'.", "Try adding an implementation of '#{name}' or declaring '#{class}' to be 'abstract'.", C.List_Fcu);
C.MessageKind_ahM = new K.MessageKind("Variable '#{variableName}' is not known to be of type '#{shownType}' because it is potentially mutated within a closure.", null, null);
C.MessageKind_avx = new K.MessageKind("Cannot initialize static field '#{fieldName}'.", null, null);
C.MessageKind_axq = new K.MessageKind("Illegal mixin application modifiers: '#{modifiers}'.", null, null);
C.List_MMm = Isolate.makeConstantList(["class A { var A; }\nmain() {\n  var a = new A();\n  a.A = 1;\n}\n", "class A { static var A; }\nmain() => A.A = 1;\n"]);
C.MessageKind_bTF = new K.MessageKind("Member variable can't have the same name as the class it is declared in.", "Try renaming the variable.", C.List_MMm);
C.MessageKind_bkG = new K.MessageKind("'#{fieldName}' was already initialized here.", null, null);
C.List_PLv = Isolate.makeConstantList(["// 'foo.dart' does not exist.\nimport 'foo.dart';\n\nmain() {}\n"]);
C.MessageKind_brT = new K.MessageKind("Can't read '#{uri}' (#{exception}).", "", C.List_PLv);
C.MessageKind_bti = new K.MessageKind("Duplicated library name '#{libraryName}'.", null, null);
C.MessageKind_c0h = new K.MessageKind("Duplicate definition of '#{name}'.", null, null);
C.List_Imx = Isolate.makeConstantList(["// 'window' is not in scope because dart:html isn't imported.\n@MirrorsUsed(targets: 'window')\nimport 'dart:mirrors';\n\nmain() {}\n"]);
C.MessageKind_c2k = new K.MessageKind("Can't find '#{name}' in the current library.", "Did you forget to add an import?", C.List_Imx);
C.MessageKind_cAH = new K.MessageKind("Illegal constructor modifiers: '#{modifiers}'.", null, null);
C.MessageKind_cOu = new K.MessageKind("Cannot use modifiers in catch.", null, null);
C.MessageKind_cWx = new K.MessageKind("This file has no part-of tag, but it is being used as a part.", null, null);
C.MessageKind_cg9 = new K.MessageKind("Optional parameters of origin and patch method '#{methodName}' must both be either named or positional.", null, null);
C.MessageKind_cgH = new K.MessageKind("This is the class patch '#{className}'.", null, null);
C.MessageKind_csC = new K.MessageKind("Required parameter count of patch method (#{patchParameterCount}) does not match parameter count on origin method '#{methodName}' (#{originParameterCount}).", null, null);
C.MessageKind_csC0 = new K.MessageKind("Only external functions can be patched.", null, null);
C.MessageKind_d2A = new K.MessageKind("Cannot resolve constructor '#{constructorName}'.", null, null);
C.MessageKind_dIz = new K.MessageKind("Origin does not exist for patch '#{name}'.", null, null);
C.MessageKind_dTZ = new K.MessageKind("Static member cannot override instance member '#{memberName}' of '#{className}'.", null, null);
C.List_bH5 = Isolate.makeConstantList(["class Class {\n  get getter;\n}\nmain() => new Class();\n"]);
C.MessageKind_dWH = new K.MessageKind("The getter '#{name}' has no implementation in class '#{class}'.", "Try adding a body to '#{name}' or declaring '#{class}' to be 'abstract'.", C.List_bH5);
C.List_QcL = Isolate.makeConstantList(["main() {\n  var i = 0x;\n}\n"]);
C.MessageKind_e3S = new K.MessageKind("A hex digit (0-9 or A-F) must follow '0x'.", "", C.List_QcL);
C.MessageKind_e4R = new K.MessageKind("Expression does not yield a value.", null, null);
C.MessageKind_e5Z = new K.MessageKind("'case' expressions do not all have type '#{type}'.", null, null);
C.MessageKind_eQ2 = new K.MessageKind("The prefix of this deferred import is not unique.", "Try changing the import prefix.", null);
C.MessageKind_eRS = new K.MessageKind("This non-final field prevents using const constructors.", null, null);
C.MessageKind_eT2 = new K.MessageKind("'const' constructor cannot call a non-const constructor.", null, null);
C.MessageKind_ek3 = new K.MessageKind("External method without an implementation.", null, null);
C.MessageKind_fHw = new K.MessageKind("Cannot assign a value to a type.", null, null);
C.List_qNR = Isolate.makeConstantList(["typedef DeadCode(); main() {}"]);
C.MessageKind_fVf = new K.MessageKind("The typedef '#{name}' is never used.", "Consider deleting it.", C.List_qNR);
C.List_ij9 = Isolate.makeConstantList(["main() => +2;  // No longer a valid way to write '2'"]);
C.MessageKind_fWv = new K.MessageKind("'+' is not a prefix operator. ", "Try removing '+'.", C.List_ij9);
C.MessageKind_ftt = new K.MessageKind("Modifier static is only allowed on functions declared in a class.", null, null);
C.MessageKind_gg9 = new K.MessageKind("Method '#{name}' in '#{class}' can't override getter from '#{inheritedClass}'.", null, null);
C.MessageKind_giZ = new K.MessageKind("'#{elementName}' is not callable.", null, null);
C.MessageKind_gkc = new K.MessageKind("The type '#{declaredType}' of method '#{name}' declared in '#{class}' is not a subtype of the overridden method type '#{inheritedType}' inherited from '#{inheritedClass}'.", null, null);
C.MessageKind_gld = new K.MessageKind("Variable '#{variableName}' is not shown to have type '#{shownType}' because '#{shownType}' is not a subtype of the known type '#{knownType}' of '#{variableName}'.", null, null);
C.List_QcL0 = Isolate.makeConstantList(["main() {\n  var i = 1e;\n}\n"]);
C.MessageKind_gsm = new K.MessageKind("Numbers in exponential notation should always contain an exponent (an integer number with an optional sign).", "Make sure there is an exponent, and remove any whitespace before it.", C.List_QcL0);
C.List_B8J = Isolate.makeConstantList(["foo(final int x(int a)) {}\nmain() => foo((y) => 42);\n", "foo({final int x(int a)}) {}\nmain() => foo((y) => 42);\n", "foo([final int x(int a)]) {}\nmain() => foo((y) => 42);\n"]);
C.MessageKind_hOe = new K.MessageKind("A function type parameter can't be declared final.", "Try removing 'final'.", C.List_B8J);
C.MessageKind_hU4 = new K.MessageKind("No setter named '#{memberName}' in class '#{className}'.", null, null);
C.List_Vmf = Isolate.makeConstantList(["foo(t) {\n  var t = t;\n  return t;\n}\n\nmain() => foo(1);\n"]);
C.MessageKind_hbB = new K.MessageKind("Variable '#{variableName}' is referenced during its initialization.", "If you are trying to reference a shadowed variable, rename one of the variables.", C.List_Vmf);
C.MessageKind_iGN = new K.MessageKind("Non-supported 'call' member on a native class, or a subclass of a native class.", null, null);
C.MessageKind_iZu = new K.MessageKind("'#{type}' must not occur more than once in the implements clause.", null, null);
C.MessageKind_ieL = new K.MessageKind("This is the method that cannot be overridden by a getter.", null, null);
C.MessageKind_ieL0 = new K.MessageKind("This is the getter that cannot be overridden by a method.", null, null);
C.MessageKind_ifn = new K.MessageKind("Variable '#{variableName}' is potentially mutated in a closure here.", null, null);
C.MessageKind_iim = new K.MessageKind("Formal parameters are not allowed here.", null, null);
C.List_kye = Isolate.makeConstantList(["// 'Foo' is not a string.\n@MirrorsUsed(symbols: Foo)\nimport 'dart:mirrors';\n\nclass Foo {}\n\nmain() {}\n"]);
C.MessageKind_ijq = new K.MessageKind("Can't use '#{name}' here because it's an instance of '#{type}' and a 'String' or 'List' value is expected.", "Did you forget to add quotes?", C.List_kye);
C.MessageKind_iqP = new K.MessageKind("'super' call arguments and constructor parameters do not match.", null, null);
C.MessageKind_iqV = new K.MessageKind("Expected an identifier in catch declaration.", null, null);
C.List_4CA = Isolate.makeConstantList(["main(a, b, c) {}"]);
C.MessageKind_ird = new K.MessageKind("'#{main}' cannot have more than two parameters.", "", C.List_4CA);
C.MessageKind_ivD = new K.MessageKind("Cannot have more than one super initializer.", null, null);
C.MessageKind_jV0 = new K.MessageKind("'#{name}' is declared private within library '#{libraryName}'.", null, null);
C.MessageKind_jzZ = new K.MessageKind("This is the patch parameter '#{parameterName}'.", null, null);
C.MessageKind_k2M = new K.MessageKind("The resource '#{resourceUri}' is loaded through both '#{canonicalUri1}' and '#{canonicalUri2}'.", null, null);
C.List_00 = Isolate.makeConstantList(["main(x) {x}"]);
C.MessageKind_kSE = new K.MessageKind("Expected '#{token}' after this.", "", C.List_00);
C.List_OtN = Isolate.makeConstantList(["main.dart", "future.dart"]);
C.Map_OtgLt = new H.ConstantStringMap(2, {"main.dart": "import 'dart:async'; // This imports a class Future.\nimport 'future.dart';\n\nvoid main() => new Future();", "future.dart": "library future;\n\nclass Future {}"}, C.List_OtN);
C.Map_OtA0N = new H.ConstantStringMap(2, {"main.dart": "import 'future.dart';\nimport 'dart:async'; // This imports a class Future.\n\nvoid main() => new Future();", "future.dart": "library future;\n\nclass Future {}"}, C.List_OtN);
C.List_uMp = Isolate.makeConstantList(["main.dart", "future.dart", "export.dart"]);
C.Map_uM561 = new H.ConstantStringMap(3, {"main.dart": "import 'export.dart';\nimport 'dart:async'; // This imports a class Future.\n\nvoid main() => new Future();", "future.dart": "library future;\n\nclass Future {}", "export.dart": "library export;\n\nexport 'future.dart';"}, C.List_uMp);
C.Map_Ot6TW = new H.ConstantStringMap(2, {"main.dart": "import 'future.dart' as prefix;\nimport 'dart:async' as prefix; // This imports a class Future.\n\nvoid main() => new prefix.Future();", "future.dart": "library future;\n\nclass Future {}"}, C.List_OtN);
C.List_Q05 = Isolate.makeConstantList([C.Map_OtgLt, C.Map_OtA0N, C.Map_uM561, C.Map_Ot6TW]);
C.MessageKind_kSE0 = new K.MessageKind("'#{name}' from library '#{hiddenUri}' is hidden by '#{name}' from library '#{hidingUri}'.", "Try adding 'hide #{name}' to the import of '#{hiddenUri}'.", C.List_Q05);
C.MessageKind_kWM = new K.MessageKind("This import is deferred but there is no prefix keyword.", "Try adding a prefix to the import.", null);
C.MessageKind_kXN = new K.MessageKind("Variable cannot be of type void.", null, null);
C.List_kMT = Isolate.makeConstantList(["foo({int _p}) {} main() => foo();"]);
C.MessageKind_knt = new K.MessageKind("Named optional parameter can't have a library private name.", "Try removing the '_' or making the parameter positional or required.", C.List_kMT);
C.MessageKind_kr3 = new K.MessageKind("'#{node}' is not a prefix.", null, null);
C.MessageKind_ku2 = new K.MessageKind("Cannot find constructor '#{constructorName}'.", null, null);
C.List_t2U = Isolate.makeConstantList(["// 'Foo' is a type literal, not a string.\n@MirrorsUsed(symbols: const [Foo])\nimport 'dart:mirrors';\n\nclass Foo {}\n\nmain() {}\n"]);
C.MessageKind_l2M = new K.MessageKind("Can't use '#{name}' here because it's an instance of '#{type}' and a 'String' value is expected.", "Did you forget to add quotes?", C.List_t2U);
C.List_01 = Isolate.makeConstantList(["class Class {\n  set setter(_);\n}\nmain() => new Class();\n"]);
C.MessageKind_lLu = new K.MessageKind("The setter '#{name}' has no implementation in class '#{class}'.", "Try adding a body to '#{name}' or declaring '#{class}' to be 'abstract'.", C.List_01);
C.MessageKind_lUo = new K.MessageKind("Cannot use type annotations in catch.", null, null);
C.MessageKind_laS = new K.MessageKind("Duplicate import of '#{name}'.", null, null);
C.List_RsV = Isolate.makeConstantList(["deadCode() {} main() {}"]);
C.MessageKind_lmC = new K.MessageKind("The method '#{name}' is never called.", "Consider deleting it.", C.List_RsV);
C.MessageKind_mJ1 = new K.MessageKind("Cannot instantiate typedef '#{typedefName}'.", null, null);
C.MessageKind_mJ10 = new K.MessageKind("Internal library '#{resolvedUri}' is not accessible.", null, null);
C.MessageKind_mJ11 = new K.MessageKind("'#{name}' is imported here.", null, null);
C.MessageKind_map = new K.MessageKind("#{count} methods retained for use by dart:mirrors out of #{total} total methods (#{percentage}%).", null, null);
C.MessageKind_mdN = new K.MessageKind("When run on the command-line, the compiled output might require a preamble file located in:\n  <sdk>/lib/_internal/lib/preambles.", null, null);
C.MessageKind_nTW = new K.MessageKind("Operator '#{operatorName}' must have exactly 2 parameters.", null, null);
C.MessageKind_o2c = new K.MessageKind("'#{type}' cannot be implemented.", null, null);
C.List_iyO = Isolate.makeConstantList(["set foo; main(){}", "abstract foo; main(){}", "static foo; main(){}", "external foo; main(){}"]);
C.MessageKind_o53 = new K.MessageKind("Can't have modifier '#{modifier}' here.", "Try replacing modifier '#{modifier}' with 'var', 'final', or a type.", C.List_iyO);
C.MessageKind_oEw = new K.MessageKind("Unused label '#{labelName}'.", null, null);
C.List_yXb0 = Isolate.makeConstantList(["abstract class I {\n  set m(_);\n}\nclass C implements I {}\nclass D implements I {\n  set m(_) {}\n}\nmain() {\n new D().m = 0;\n new C();\n}\n"]);
C.MessageKind_oUC = new K.MessageKind("'#{class}' doesn't implement the setter '#{name}' declared in '#{declarer}'.", "Try adding an implementation of '#{name}' or declaring '#{class}' to be 'abstract'.", C.List_yXb0);
C.MessageKind_ocl = new K.MessageKind("Internal library '#{resolvedUri}' is not accessible from '#{importingUri}'.", null, null);
C.MessageKind_omH = new K.MessageKind("The method '#{name}' is declared here in class '#{class}'.", null, null);
C.List_ESz = Isolate.makeConstantList(["main() {\n  foo([a: 1]) => print(a);\n  foo(2);\n}"]);
C.MessageKind_oqh = new K.MessageKind("Positional optional parameters can't use ':' to specify a default value.", "Try replacing ':' with '='.", C.List_ESz);
C.List_42A = Isolate.makeConstantList(["main();"]);
C.MessageKind_ouf = new K.MessageKind("Expected a function body or '=>'.", "Try adding {}.", C.List_42A);
C.MessageKind_oyn = new K.MessageKind("Setter disagrees on: '#{modifiers}'.", null, null);
C.MessageKind_p6D = new K.MessageKind("This is the static member with the same name.", null, null);
C.MessageKind_pSV = new K.MessageKind("Redirecting constructor cannot have other initializers.", null, null);
C.MessageKind_pi1 = new K.MessageKind("Cannot instantiate type variable '#{typeVariableName}'.", null, null);
C.MessageKind_pi10 = new K.MessageKind("Cannot resolve getter.", null, null);
C.MessageKind_pi11 = new K.MessageKind("Cannot resolve setter.", null, null);
C.MessageKind_q9Q = new K.MessageKind("Cannot patch non-setter '#{name}' with setter patch.", null, null);
C.MessageKind_q9Q0 = new K.MessageKind("Cannot patch non-getter '#{name}' with getter patch.", null, null);
C.List_4e8 = Isolate.makeConstantList(["class A {\n  A([a]);\n  factory A.foo([a = 1]) = A;\n}\n\nmain() {\n  new A.foo(1);\n}", "class A {\n  A({a});\n  factory A.foo({a: 1}) = A;\n}\n\nmain() {\n  new A.foo(a: 1);\n}"]);
C.MessageKind_qfd = new K.MessageKind("A parameter of a redirecting factory constructor can't specify a default value.", "Try removing the default value.", C.List_4e8);
C.MessageKind_qhc = new K.MessageKind("This is the function patch '#{functionName}'.", null, null);
C.MessageKind_qlM = new K.MessageKind("The setter '#{name}' is implicitly declared by this field in class '#{class}'.", null, null);
C.MessageKind_qxi = new K.MessageKind("Cannot resolve parameter.", null, null);
C.MessageKind_qxw = new K.MessageKind("Class name expected.", null, null);
C.MessageKind_r9o = new K.MessageKind("Getter disagrees on: '#{modifiers}'.", null, null);
C.List_Ooj = Isolate.makeConstantList(["do() {} main() {}"]);
C.MessageKind_rBh = new K.MessageKind("'#{keyword}' is a reserved word and can't be used here.", "Try using a different name.", C.List_Ooj);
C.MessageKind_rYI = new K.MessageKind("'#{fieldName}' is not a field.", null, null);
C.List_02 = Isolate.makeConstantList([""]);
C.MessageKind_rti = new K.MessageKind("Could not find '#{main}'.  Nothing will be analyzed.", "Try using '--analyze-all' to analyze everything.", C.List_02);
C.MessageKind_sBE = new K.MessageKind("This is the overridden setter '#{name}' declared in class '#{class}'.", null, null);
C.MessageKind_sQK = new K.MessageKind("Duplicate declaration of label '#{labelName}'.", null, null);
C.MessageKind_soG = new K.MessageKind("Using '#{class}.#{name}' may lead to unnecessarily large generated code.", "Try adding '@MirrorsUsed(...)' as described at https://goo.gl/Akrrog.", null);
C.MessageKind_t1T = new K.MessageKind("Use of 'super' in class used as mixin.", null, null);
C.MessageKind_tMf = new K.MessageKind("Invalid offset (#{offset}) in source map.\nFile: #{fileName}\nLength: #{length}", null, null);
C.MessageKind_u5H = new K.MessageKind("The compiler is broken.\n\nWhen compiling the above element, the compiler crashed. It is not\npossible to tell if this is caused by a problem in your program or\nnot. Regardless, the compiler should not crash.\n\nThe Dart team would greatly appreciate if you would take a moment to\nreport this problem at http://dartbug.com/new.\n\nPlease include the following information:\n\n* the name and version of your operating system,\n\n* the Dart SDK build number (#{buildId}), and\n\n* the entire message you see here (including the full stack trace\n  below as well as the source location above).\n", null, null);
C.MessageKind_u61 = new K.MessageKind("Cannot have final modifier on method.", null, null);
C.MessageKind_u8x = new K.MessageKind("The type '#{declaredType}' of getter '#{name}' declared in '#{class}' is not assignable to the type '#{inheritedType}' of the overridden field inherited from '#{inheritedClass}'.", null, null);
C.MessageKind_u8x0 = new K.MessageKind("The type '#{declaredType}' of setter '#{name}' declared in '#{class}' is not assignable to the type '#{inheritedType}' of the overridden field inherited from '#{inheritedClass}'.", null, null);
C.MessageKind_uCu = new K.MessageKind("Cannot return value from void function.", null, null);
C.MessageKind_uJO = new K.MessageKind("Target of continue is not a loop or switch case.", null, null);
C.MessageKind_uez = new K.MessageKind("Field '#{name}' in '#{class}' can't override method from '#{inheritedClass}'.", null, null);
C.List_IQp = Isolate.makeConstantList(["class C<T extends num> {}\n\n// 'String' is not a valid instantiation of T with bound num.'.\nmain() => new C<String>();\n"]);
C.MessageKind_uz8 = new K.MessageKind("'#{typeArgument}' is not a subtype of bound '#{bound}' for type variable '#{typeVariable}' of type '#{thisType}'.", "Try to change or remove the type argument.", C.List_IQp);
C.MessageKind_w4L = new K.MessageKind("Value of type '#{returnType}' expected.", null, null);
C.MessageKind_wAS = new K.MessageKind("Unnamed constructor name must be '#{name}'.", null, null);
C.MessageKind_wC3 = new K.MessageKind("Operator '#{operatorName}' cannot have named parameters.", null, null);
C.MessageKind_wEh = new K.MessageKind("The library '#{libraryName}' in '#{resourceUri}' is loaded through both '#{canonicalUri1}' and '#{canonicalUri2}'.", null, null);
C.MessageKind_wU7 = new K.MessageKind("Argument for 'JS_INTERCEPTOR_CONSTANT' must be a type constant.", null, null);
C.MessageKind_wco = new K.MessageKind("Patch method parameter '#{patchParameter}' does not match '#{originParameter}' on origin method '#{methodName}'.", null, null);
C.MessageKind_wdf = new K.MessageKind("Not a compile-time constant.", null, null);
C.MessageKind_wiD = new K.MessageKind("The type #{node} is deferred. Deferred types are not valid as type annotations.", "Try using a non-deferred abstract class as an interface.", null);
C.MessageKind_woc = new K.MessageKind("Class used as mixin must have Object as superclass.", null, null);
C.MessageKind_woc0 = new K.MessageKind("Method '#{name}' in '#{class}' can't override field from '#{inheritedClass}'.", null, null);
C.MessageKind_wwi = new K.MessageKind("#{text}", null, null);
C.List_OBK = Isolate.makeConstantList(["main() { var f = func() {}; }"]);
C.MessageKind_wwi0 = new K.MessageKind("Function expression '#{name}' cannot be named.", "Try removing the name.", C.List_OBK);
C.MessageKind_x0h = new K.MessageKind("The type '#{declaredType}' of field '#{name}' declared in '#{class}' is not assignable to the type '#{inheritedType}' of the overridden getter inherited from '#{inheritedClass}'.", null, null);
C.MessageKind_x0h0 = new K.MessageKind("The type '#{declaredType}' of field '#{name}' declared in '#{class}' is not assignable to the type '#{inheritedType}' of the overridden setter inherited from '#{inheritedClass}'.", null, null);
C.MessageKind_x49 = new K.MessageKind("only call to 'this' or 'super' constructor allowed.", null, null);
C.MessageKind_xES = new K.MessageKind("Operator '#{operatorName}' must have exactly 1 parameter.", null, null);
C.MessageKind_xKU = new K.MessageKind("Variable '#{variableName}' is accessed in a closure here.", null, null);
C.MessageKind_xw8 = new K.MessageKind("This is the method declaration.", null, null);
C.List_izW = Isolate.makeConstantList(["typedef G F(); // The return type 'G' is a self-reference through typedef 'G'.\ntypedef F G(); // The return type 'F' is a self-reference through typedef 'F'.\nmain() { F f = null; }", "typedef G F(); // The return type 'G' creates a self-reference.\ntypedef H G(); // The return type 'H' creates a self-reference.\ntypedef H(F f); // The argument type 'F' creates a self-reference.\nmain() { F f = null; }"]);
C.MessageKind_xw80 = new K.MessageKind("A typedef can't refer to itself through another typedef.", "Try removing all references to '#{otherTypedefName}' in the definition of '#{typedefName}'.", C.List_izW);
C.List_Oho = Isolate.makeConstantList(["abstract class I {\n  m();\n}\nclass C implements I {}\nmain() => new C();\n", "abstract class I {\n  m();\n}\nclass C extends I {}\nmain() => new C();\n"]);
C.MessageKind_xw81 = new K.MessageKind("'#{class}' doesn't implement '#{method}' declared in '#{declarer}'.", "Try adding an implementation of '#{name}' or declaring '#{class}' to be 'abstract'.", C.List_Oho);
C.MessageKind_y1j = new K.MessageKind("Factory redirection only allowed in factories.", null, null);
C.MessageKind_yDL = new K.MessageKind("Cannot use Object as mixin.", null, null);
C.MessageKind_yDL0 = new K.MessageKind("Only classes and functions can be patched.", null, null);
C.MessageKind_yFk = new K.MessageKind("Library not found '#{resolvedUri}'.", null, null);
C.MessageKind_yHq = new K.MessageKind("Arguments do not match the expected parameters of constructor '#{constructorName}'.", null, null);
C.MessageKind_yP5 = new K.MessageKind("'#{name}' is only available in instance methods.", null, null);
C.MessageKind_yPB = new K.MessageKind("Expected a 'String', but got an instance of '#{type}'.", null, null);
C.MessageKind_yT2 = new K.MessageKind("No operator '#{memberName}' in class '#{className}'.", null, null);
C.MessageKind_yXb = new K.MessageKind("Variable '#{variableName}' is potentially mutated here.", null, null);
C.List_H05 = Isolate.makeConstantList(["main.dart", "type.dart"]);
C.Map_H0KIf = new H.ConstantStringMap(2, {"main.dart": "// This hides the implicit import of class Type from dart:core.\nimport 'type.dart';\n\nvoid main() => new Type();", "type.dart": "library type;\n\nclass Type {}"}, C.List_H05);
C.List_SSi = Isolate.makeConstantList(["conflictsWithDart.dart", "conflictsWithDartAsWell.dart", "main.dart"]);
C.Map_SSDxo = new H.ConstantStringMap(3, {"conflictsWithDart.dart": "library conflictsWithDart;\n\nclass Duration {\n  static var x = 100;\n}\n", "conflictsWithDartAsWell.dart": "library conflictsWithDartAsWell;\n\nclass Duration {\n  static var x = 100;\n}\n", "main.dart": "library testDartConflicts;\n\nimport 'conflictsWithDart.dart';\nimport 'conflictsWithDartAsWell.dart';\n\nmain() {\n  print(\"Hail Caesar ${Duration.x}\");\n}\n"}, C.List_SSi);
C.List_Map_H0KIf_Map_SSDxo = Isolate.makeConstantList([C.Map_H0KIf, C.Map_SSDxo]);
C.MessageKind_yXb0 = new K.MessageKind("'#{name}' from library '#{hiddenUri}' is hidden by '#{name}' from library '#{hidingUri}'.", "Try adding an explicit 'import \"#{hiddenUri}\" hide #{name}'.", C.List_Map_H0KIf_Map_SSDxo);
C.MessageKind_ynF = new K.MessageKind("The inherited getter '#{name}' is declared here in class '#{class}'.", null, null);
C.MessageKind_yzJ = new K.MessageKind("This is the constructor patch '#{constructorName}'.", null, null);
C.MessageKind_z3C = new K.MessageKind("Cannot use re-throw outside of catch block (expression expected after 'throw').", null, null);
C.MessageKind_zVP = new K.MessageKind("Symbol literal '##{value}' is currently unsupported by dart2js.", null, null);
C.MessageKind_zre = new K.MessageKind("This is another export of '#{name}'.", null, null);
C.MinIntValue_null = new B.MinIntValue(null);
C.PrecedenceInfo_$_0_159 = new Y.PrecedenceInfo("$", 0, 159);
C.PrecedenceInfo_06W = new Y.PrecedenceInfo("-", 12, 45);
C.PrecedenceInfo_10U = new Y.PrecedenceInfo("`", 0, 96);
C.PrecedenceInfo_1Vp = new Y.PrecedenceInfo("<=", 7, 129);
C.PrecedenceInfo_1nr = new Y.PrecedenceInfo("&", 10, 38);
C.PrecedenceInfo_3u5 = new Y.PrecedenceInfo("?", 3, 63);
C.PrecedenceInfo_43h = new Y.PrecedenceInfo("==", 6, 135);
C.PrecedenceInfo_4AN = new Y.PrecedenceInfo("%", 13, 37);
C.PrecedenceInfo_4QZ = new Y.PrecedenceInfo("===", 6, 134);
C.PrecedenceInfo_6el = new Y.PrecedenceInfo("...", 0, 132);
C.PrecedenceInfo_8cP = new Y.PrecedenceInfo("~/", 13, 154);
C.PrecedenceInfo_9Uv = new Y.PrecedenceInfo("/", 13, 47);
C.PrecedenceInfo_A0t = new Y.PrecedenceInfo(">>", 11, 156);
C.PrecedenceInfo_Axo = new Y.PrecedenceInfo(".", 14, 46);
C.PrecedenceInfo_CJR = new Y.PrecedenceInfo("@", 0, 64);
C.PrecedenceInfo_CRA = new Y.PrecedenceInfo("[]", 0, 141);
C.PrecedenceInfo_DYf = new Y.PrecedenceInfo("${", 0, 128);
C.PrecedenceInfo_DqM = new Y.PrecedenceInfo("~/=", 1, 153);
C.PrecedenceInfo_EOF_0_0 = new Y.PrecedenceInfo("EOF", 0, 0);
C.PrecedenceInfo_EsG = new Y.PrecedenceInfo("!==", 6, 142);
C.PrecedenceInfo_FeL = new Y.PrecedenceInfo("~", 0, 126);
C.PrecedenceInfo_I7d = new Y.PrecedenceInfo("[]=", 0, 140);
C.PrecedenceInfo_Mr4 = new Y.PrecedenceInfo("!", 0, 33);
C.PrecedenceInfo_Nm5 = new Y.PrecedenceInfo("^", 9, 94);
C.PrecedenceInfo_OJ0 = new Y.PrecedenceInfo("^=", 1, 157);
C.PrecedenceInfo_Odk = new Y.PrecedenceInfo(",", 0, 44);
C.PrecedenceInfo_Ogk = new Y.PrecedenceInfo("||", 4, 146);
C.PrecedenceInfo_P1e = new Y.PrecedenceInfo("|", 8, 124);
C.PrecedenceInfo_S9I = new Y.PrecedenceInfo("<", 7, 60);
C.PrecedenceInfo_TLM = new Y.PrecedenceInfo("<<=", 1, 136);
C.PrecedenceInfo_TVl = new Y.PrecedenceInfo(">>=", 1, 139);
C.PrecedenceInfo_U48 = new Y.PrecedenceInfo("=>", 0, 130);
C.PrecedenceInfo_W2j = new Y.PrecedenceInfo("+", 12, 43);
C.PrecedenceInfo_WZn = new Y.PrecedenceInfo("*=", 1, 148);
C.PrecedenceInfo_YfA = new Y.PrecedenceInfo("#", 0, 35);
C.PrecedenceInfo_YwG = new Y.PrecedenceInfo("|=", 1, 147);
C.PrecedenceInfo_atn = new Y.PrecedenceInfo("[", 14, 91);
C.PrecedenceInfo_cD9 = new Y.PrecedenceInfo("<<", 11, 137);
C.PrecedenceInfo_comment_0_158 = new Y.PrecedenceInfo("comment", 0, 158);
C.PrecedenceInfo_double_0_100 = new Y.PrecedenceInfo("double", 0, 100);
C.PrecedenceInfo_hexadecimal_0_120 = new Y.PrecedenceInfo("hexadecimal", 0, 120);
C.PrecedenceInfo_iHe = new Y.PrecedenceInfo("+=", 1, 150);
C.PrecedenceInfo_identifier_0_97 = new Y.PrecedenceInfo("identifier", 0, 97);
C.PrecedenceInfo_ifx = new Y.PrecedenceInfo("--", 14, 151);
C.PrecedenceInfo_ij7 = new Y.PrecedenceInfo("-=", 1, 152);
C.PrecedenceInfo_int_0_105 = new Y.PrecedenceInfo("int", 0, 105);
C.PrecedenceInfo_ivD = new Y.PrecedenceInfo("++", 14, 149);
C.PrecedenceInfo_k6K = new Y.PrecedenceInfo("%=", 1, 155);
C.PrecedenceInfo_kCU = new Y.PrecedenceInfo("/=", 1, 131);
C.PrecedenceInfo_kuc = new Y.PrecedenceInfo(";", 0, 59);
C.PrecedenceInfo_mJ8 = new Y.PrecedenceInfo("malformed input", 0, 88);
C.PrecedenceInfo_ouN = new Y.PrecedenceInfo("..", 2, 133);
C.PrecedenceInfo_pmZ = new Y.PrecedenceInfo(":", 0, 58);
C.PrecedenceInfo_qBT = new Y.PrecedenceInfo(">=", 7, 138);
C.PrecedenceInfo_qJU = new Y.PrecedenceInfo("{", 0, 123);
C.PrecedenceInfo_sUe = new Y.PrecedenceInfo("*", 13, 42);
C.PrecedenceInfo_string_0_39 = new Y.PrecedenceInfo("string", 0, 39);
C.PrecedenceInfo_sx4 = new Y.PrecedenceInfo("/* new backend */ ", 0, 123);
C.PrecedenceInfo_sxw = new Y.PrecedenceInfo("&=", 1, 145);
C.PrecedenceInfo_v9T = new Y.PrecedenceInfo("&&", 5, 144);
C.PrecedenceInfo_wYn = new Y.PrecedenceInfo("(", 14, 40);
C.PrecedenceInfo_woc = new Y.PrecedenceInfo("\\", 0, 92);
C.PrecedenceInfo_xw8 = new Y.PrecedenceInfo("=", 1, 61);
C.PrecedenceInfo_zPV = new Y.PrecedenceInfo("!=", 6, 143);
C.PublicName_call_false = new O.PublicName("call", false);
C.PublicName_noSuchMethod_false = new O.PublicName("noSuchMethod", false);
C.SelectorKind_call_2 = new Z.SelectorKind("call", 2);
C.SelectorKind_getter_0 = new Z.SelectorKind("getter", 0);
C.SelectorKind_index_4 = new Z.SelectorKind("index", 4);
C.SelectorKind_operator_3 = new Z.SelectorKind("operator", 3);
C.SelectorKind_setter_1 = new Z.SelectorKind("setter", 1);
C.SpecialType_MYA = new L.SpecialType("=Object");
C.TrueConstant_true = new K.TrueConstant(true);
C.TypeKind_dynamic = new V.TypeKind("dynamic");
C.TypeKind_function = new V.TypeKind("function");
C.TypeKind_interface = new V.TypeKind("interface");
C.TypeKind_kuk = new V.TypeKind("type variable");
C.TypeKind_malformed = new V.TypeKind("malformed");
C.TypeKind_statement = new V.TypeKind("statement");
C.TypeKind_typedef = new V.TypeKind("typedef");
C.TypeKind_void = new V.TypeKind("void");
C.Type_AHF = H.createRuntimeType('NativeTypedArray');
C.Type_EQs = H.createRuntimeType('GlobalEventHandlers');
C.Type_NlB = H.createRuntimeType('NativeTypedArrayOfDouble');
C.Type_QyU = H.createRuntimeType('WindowEventHandlers');
C.Type_wOW = H.createRuntimeType('NativeTypedArrayOfInt');
C.UnknownValue_null = new B.UnknownValue(null);
C.Utf8Codec_false = new P.Utf8Codec(false);
C._ReductionKind_Jmi = new X._ReductionKind("eta-cont", 3);
C._ReductionKind_RsV = new X._ReductionKind("dead-cont", 1);
C._ReductionKind_Yqr = new X._ReductionKind("beta-cont-lin", 2);
C._ReductionKind_yP5 = new X._ReductionKind("dead-val", 0);
C._SpannableSentinel_0 = new O._SpannableSentinel("Current element");
C._SpannableSentinel_fBD = new O._SpannableSentinel("No location");
$.libraries_to_load = {};
$.IsolateNatives_enableSpawnWorker = null;
$.RawReceivePortImpl__nextFreeId = 1;
$.Primitives_mirrorFunctionCacheName = "$cachedFunction";
$.Primitives_mirrorInvokeCacheName = "$cachedInvocation";
$.Primitives_timerFrequency = null;
$.Primitives_timerTicks = null;
$.Closure_functionCounter = 0;
$.BoundClosure_selfFieldNameCache = null;
$.BoundClosure_receiverFieldNameCache = null;
$.RuntimeFunctionType_inAssert = false;
$.getTagFunction = null;
$.alternateTagFunction = null;
$.prototypeForTagFunction = null;
$.dispatchRecordsForInstanceTags = null;
$.interceptorsForUncacheableTags = null;
$.initNativeDispatchFlag = null;
$.sdkLocation = null;
$.cachedCompiler = null;
$.printToZone = null;
$._nextCallback = null;
$._lastCallback = null;
$._lastPriorityCallback = null;
$._isInCallbackLoop = false;
$.Zone__current = C.C__RootZone;
$.Expando__keyCount = 0;
$.Stopwatch__frequency = null;
$.Node_hashCount = 0;
$.LibraryDependencyNode_hashCodeCounter = 0;
$.MalformedType_nextHash = 43765;
$.ElementX_elementHashCode = 0;
$.Device__isOpera = null;
$.Device__isWebKit = null;
$.MiniJsParser_HIGHEST_PARSE_BINARY_PRECEDENCE = 16;
$.TypeCheck_nextHash = 49;
$.TreeElementMapping__hashCodeCounter = 0;
$.ClassMemberMixin__EMPTY_MEMBERS_NAMES = C.List_empty0;
$.Keyword__keywords = null;
$.KeywordState__KEYWORD_STATE = null;
$.HInstruction_idCounter = null;
$.Node__HASH_COUNTER = 0;
$.Label_counter = 0;
$._VERBOSE = false;
$._PRINT_SUMMARY = false;
$.TypeInformation_staticHashCode = 0;
Isolate.$lazy($, "thisScript", "IsolateNatives_thisScript", "get$IsolateNatives_thisScript", function() {
  return H.IsolateNatives_computeThisScript();
});
Isolate.$lazy($, "workerIds", "IsolateNatives_workerIds", "get$IsolateNatives_workerIds", function() {
  return H.setRuntimeTypeInfo(new P.Expando(null), [P.$int]);
});
Isolate.$lazy($, "noSuchMethodPattern", "TypeErrorDecoder_noSuchMethodPattern", "get$TypeErrorDecoder_noSuchMethodPattern", function() {
  return H.TypeErrorDecoder_extractPattern(H.TypeErrorDecoder_provokeCallErrorOn({toString: function() {
      return "$receiver$";
    }}));
});
Isolate.$lazy($, "notClosurePattern", "TypeErrorDecoder_notClosurePattern", "get$TypeErrorDecoder_notClosurePattern", function() {
  return H.TypeErrorDecoder_extractPattern(H.TypeErrorDecoder_provokeCallErrorOn({$method$: null, toString: function() {
      return "$receiver$";
    }}));
});
Isolate.$lazy($, "nullCallPattern", "TypeErrorDecoder_nullCallPattern", "get$TypeErrorDecoder_nullCallPattern", function() {
  return H.TypeErrorDecoder_extractPattern(H.TypeErrorDecoder_provokeCallErrorOn(null));
});
Isolate.$lazy($, "nullLiteralCallPattern", "TypeErrorDecoder_nullLiteralCallPattern", "get$TypeErrorDecoder_nullLiteralCallPattern", function() {
  return H.TypeErrorDecoder_extractPattern(function() {
    var $argumentsExpr$ = '$arguments$';
    try {
      null.$method$($argumentsExpr$);
    } catch (e) {
      return e.message;
    }

  }());
});
Isolate.$lazy($, "undefinedCallPattern", "TypeErrorDecoder_undefinedCallPattern", "get$TypeErrorDecoder_undefinedCallPattern", function() {
  return H.TypeErrorDecoder_extractPattern(H.TypeErrorDecoder_provokeCallErrorOn(void 0));
});
Isolate.$lazy($, "undefinedLiteralCallPattern", "TypeErrorDecoder_undefinedLiteralCallPattern", "get$TypeErrorDecoder_undefinedLiteralCallPattern", function() {
  return H.TypeErrorDecoder_extractPattern(function() {
    var $argumentsExpr$ = '$arguments$';
    try {
      (void 0).$method$($argumentsExpr$);
    } catch (e) {
      return e.message;
    }

  }());
});
Isolate.$lazy($, "nullPropertyPattern", "TypeErrorDecoder_nullPropertyPattern", "get$TypeErrorDecoder_nullPropertyPattern", function() {
  return H.TypeErrorDecoder_extractPattern(H.TypeErrorDecoder_provokePropertyErrorOn(null));
});
Isolate.$lazy($, "nullLiteralPropertyPattern", "TypeErrorDecoder_nullLiteralPropertyPattern", "get$TypeErrorDecoder_nullLiteralPropertyPattern", function() {
  return H.TypeErrorDecoder_extractPattern(function() {
    try {
      null.$method$;
    } catch (e) {
      return e.message;
    }

  }());
});
Isolate.$lazy($, "undefinedPropertyPattern", "TypeErrorDecoder_undefinedPropertyPattern", "get$TypeErrorDecoder_undefinedPropertyPattern", function() {
  return H.TypeErrorDecoder_extractPattern(H.TypeErrorDecoder_provokePropertyErrorOn(void 0));
});
Isolate.$lazy($, "undefinedLiteralPropertyPattern", "TypeErrorDecoder_undefinedLiteralPropertyPattern", "get$TypeErrorDecoder_undefinedLiteralPropertyPattern", function() {
  return H.TypeErrorDecoder_extractPattern(function() {
    try {
      (void 0).$method$;
    } catch (e) {
      return e.message;
    }

  }());
});
Isolate.$lazy($, "_instance", "SuperReceiver__instance", "get$SuperReceiver__instance", function() {
  return new F.SuperReceiver();
});
Isolate.$lazy($, "_instance", "This__instance", "get$This__instance", function() {
  return new F.This0();
});
Isolate.$lazy($, "cachedSources", "cachedSources", "get$cachedSources", function() {
  return P.LinkedHashMap_LinkedHashMap(null, null, null, P.Uri, [P.Future, P.String]);
});
Isolate.$lazy($, "options", "options", "get$options", function() {
  return [];
});
Isolate.$lazy($, "scheduleImmediateClosure", "_AsyncRun_scheduleImmediateClosure", "get$_AsyncRun_scheduleImmediateClosure", function() {
  return P._AsyncRun__initializeScheduleImmediate();
});
Isolate.$lazy($, "_nullFuture", "Future__nullFuture", "get$Future__nullFuture", function() {
  return P._Future$immediate(null, null);
});
Isolate.$lazy($, "_toStringVisiting", "IterableBase__toStringVisiting", "get$IterableBase__toStringVisiting", function() {
  return [];
});
Isolate.$lazy($, "_instances", "_FakeUserTag__instances", "get$_FakeUserTag__instances", function() {
  return P.LinkedHashMap_LinkedHashMap$_empty(null, null);
});
Isolate.$lazy($, "_defaultTag", "_FakeUserTag__defaultTag", "get$_FakeUserTag__defaultTag", function() {
  return P._FakeUserTag__FakeUserTag("Default");
});
Isolate.$lazy($, "_currentTag", "_currentTag", "get$_currentTag", function() {
  return $.get$_FakeUserTag__defaultTag();
});
Isolate.$lazy($, "DART_CORE", "Compiler_DART_CORE", "get$Compiler_DART_CORE", function() {
  return P.Uri_Uri(null, null, "core", null, null, null, null, "dart", "");
});
Isolate.$lazy($, "DART_MIRRORS", "Compiler_DART_MIRRORS", "get$Compiler_DART_MIRRORS", function() {
  return P.Uri_Uri(null, null, "mirrors", null, null, null, null, "dart", "");
});
Isolate.$lazy($, "DART_NATIVE_TYPED_DATA", "Compiler_DART_NATIVE_TYPED_DATA", "get$Compiler_DART_NATIVE_TYPED_DATA", function() {
  return P.Uri_Uri(null, null, "_native_typed_data", null, null, null, null, "dart", "");
});
Isolate.$lazy($, "DART_INTERNAL", "Compiler_DART_INTERNAL", "get$Compiler_DART_INTERNAL", function() {
  return P.Uri_Uri(null, null, "_internal", null, null, null, null, "dart", "");
});
Isolate.$lazy($, "DART_ASYNC", "Compiler_DART_ASYNC", "get$Compiler_DART_ASYNC", function() {
  return P.Uri_Uri(null, null, "async", null, null, null, null, "dart", "");
});
Isolate.$lazy($, "_DELETED", "ShrinkingReducer__DELETED", "get$ShrinkingReducer__DELETED", function() {
  var t1 = $.Node_hashCount + 1 & 1073741823;
  $.Node_hashCount = t1;
  return new X._DeletedNode(t1, null);
});
Isolate.$lazy($, "templateManager", "templateManager", "get$templateManager", function() {
  return new Q.TemplateManager(P.LinkedHashMap_LinkedHashMap(null, null, null, P.String, Q.Template), P.LinkedHashMap_LinkedHashMap(null, null, null, P.String, Q.Template));
});
Isolate.$lazy($, "BINARY_PRECEDENCE", "MiniJsParser_BINARY_PRECEDENCE", "get$MiniJsParser_BINARY_PRECEDENCE", function() {
  return P.LinkedHashMap_LinkedHashMap$_literal(["+=", 17, "-=", 17, "*=", 17, "/=", 17, "%=", 17, "^=", 17, "|=", 17, "&=", 17, "<<=", 17, ">>=", 17, ">>>=", 17, "=", 17, "||", 14, "&&", 13, "|", 12, "^", 11, "&", 10, "!=", 9, "==", 9, "!==", 9, "===", 9, "<", 8, "<=", 8, ">=", 8, ">", 8, "in", 8, "instanceof", 8, "<<", 7, ">>", 7, ">>>", 7, "+", 6, "-", 6, "*", 5, "/", 5, "%", 5], null, null);
});
Isolate.$lazy($, "UNARY_OPERATORS", "MiniJsParser_UNARY_OPERATORS", "get$MiniJsParser_UNARY_OPERATORS", function() {
  var t1, t2;
  t1 = ["++", "--", "+", "-", "~", "!", "typeof", "void", "delete"];
  t2 = P.LinkedHashSet_LinkedHashSet(null, null, null, H.getTypeArgumentByIndex(t1, 0));
  t2.addAll$1(0, t1);
  return t2;
});
Isolate.$lazy($, "OPERATORS_THAT_LOOK_LIKE_IDENTIFIERS", "MiniJsParser_OPERATORS_THAT_LOOK_LIKE_IDENTIFIERS", "get$MiniJsParser_OPERATORS_THAT_LOOK_LIKE_IDENTIFIERS", function() {
  var t1, t2;
  t1 = ["typeof", "void", "delete", "in", "instanceof"];
  t2 = P.LinkedHashSet_LinkedHashSet(null, null, null, H.getTypeArgumentByIndex(t1, 0));
  t2.addAll$1(0, t1);
  return t2;
});
Isolate.$lazy($, "identifierCharacterRegExp", "Printer_identifierCharacterRegExp", "get$Printer_identifierCharacterRegExp", function() {
  return new H.JSSyntaxRegExp("^[a-zA-Z_0-9$]", H.JSSyntaxRegExp_makeNative("^[a-zA-Z_0-9$]", false, true, false), null, null);
});
Isolate.$lazy($, "expressionContinuationRegExp", "Printer_expressionContinuationRegExp", "get$Printer_expressionContinuationRegExp", function() {
  return new H.JSSyntaxRegExp("^[-+([]", H.JSSyntaxRegExp_makeNative("^[-+([]", false, true, false), null, null);
});
Isolate.$lazy($, "DART_JS_HELPER", "JavaScriptBackend_DART_JS_HELPER", "get$JavaScriptBackend_DART_JS_HELPER", function() {
  return P.Uri_Uri(null, null, "_js_helper", null, null, null, null, "dart", "");
});
Isolate.$lazy($, "DART_INTERCEPTORS", "JavaScriptBackend_DART_INTERCEPTORS", "get$JavaScriptBackend_DART_INTERCEPTORS", function() {
  return P.Uri_Uri(null, null, "_interceptors", null, null, null, null, "dart", "");
});
Isolate.$lazy($, "DART_FOREIGN_HELPER", "JavaScriptBackend_DART_FOREIGN_HELPER", "get$JavaScriptBackend_DART_FOREIGN_HELPER", function() {
  return P.Uri_Uri(null, null, "_foreign_helper", null, null, null, null, "dart", "");
});
Isolate.$lazy($, "DART_JS_MIRRORS", "JavaScriptBackend_DART_JS_MIRRORS", "get$JavaScriptBackend_DART_JS_MIRRORS", function() {
  return P.Uri_Uri(null, null, "_js_mirrors", null, null, null, null, "dart", "");
});
Isolate.$lazy($, "DART_JS_NAMES", "JavaScriptBackend_DART_JS_NAMES", "get$JavaScriptBackend_DART_JS_NAMES", function() {
  return P.Uri_Uri(null, null, "_js_names", null, null, null, null, "dart", "");
});
Isolate.$lazy($, "DART_ISOLATE_HELPER", "JavaScriptBackend_DART_ISOLATE_HELPER", "get$JavaScriptBackend_DART_ISOLATE_HELPER", function() {
  return P.Uri_Uri(null, null, "_isolate_helper", null, null, null, null, "dart", "");
});
Isolate.$lazy($, "DART_HTML", "JavaScriptBackend_DART_HTML", "get$JavaScriptBackend_DART_HTML", function() {
  return P.Uri_Uri(null, null, "html", null, null, null, null, "dart", "");
});
Isolate.$lazy($, "COMMENT_RE", "ConstantLiteralEmitter_COMMENT_RE", "get$ConstantLiteralEmitter_COMMENT_RE", function() {
  return new H.JSSyntaxRegExp("^ *(//.*)?\\n|  *//[^''\"\\n]*$", H.JSSyntaxRegExp_makeNative("^ *(//.*)?\\n|  *//[^''\"\\n]*$", true, true, false), null, null);
});
Isolate.$lazy($, "userGlobalObjects", "Namer_userGlobalObjects", "get$Namer_userGlobalObjects", function() {
  var t1 = P.List_List$from(C.List_69t, true, null);
  C.JSArray_methods.remove$1(t1, "C");
  C.JSArray_methods.remove$1(t1, "H");
  C.JSArray_methods.remove$1(t1, "J");
  C.JSArray_methods.remove$1(t1, "P");
  C.JSArray_methods.remove$1(t1, "W");
  return t1;
});
Isolate.$lazy($, "IDENTIFIER", "Namer_IDENTIFIER", "get$Namer_IDENTIFIER", function() {
  return new H.JSSyntaxRegExp("^[A-Za-z_$][A-Za-z0-9_$]*$", H.JSSyntaxRegExp_makeNative("^[A-Za-z_$][A-Za-z0-9_$]*$", false, true, false), null, null);
});
Isolate.$lazy($, "NON_IDENTIFIER_CHAR", "Namer_NON_IDENTIFIER_CHAR", "get$Namer_NON_IDENTIFIER_CHAR", function() {
  return new H.JSSyntaxRegExp("[^A-Za-z_0-9$]", H.JSSyntaxRegExp_makeNative("[^A-Za-z_0-9$]", false, true, false), null, null);
});
Isolate.$lazy($, "IDENTIFIER", "ConstantNamingVisitor_IDENTIFIER", "get$ConstantNamingVisitor_IDENTIFIER", function() {
  return new H.JSSyntaxRegExp("^[A-Za-z_$][A-Za-z0-9_$]*$", H.JSSyntaxRegExp_makeNative("^[A-Za-z_$][A-Za-z0-9_$]*$", false, true, false), null, null);
});
Isolate.$lazy($, "DART_MIRROR_HELPER", "MirrorRenamer_DART_MIRROR_HELPER", "get$MirrorRenamer_DART_MIRROR_HELPER", function() {
  return P.Uri_Uri(null, null, "_mirror_helper", null, null, null, null, "dart", "");
});
Isolate.$lazy($, "NONE", "NativeBehavior_NONE", "get$NativeBehavior_NONE", function() {
  return new L.NativeBehavior([], [], null, new Z.SideEffects(0));
});
Isolate.$lazy($, "nativeRedirectionRegExp", "nativeRedirectionRegExp", "get$nativeRedirectionRegExp", function() {
  return new H.JSSyntaxRegExp("^[a-zA-Z][a-zA-Z_$0-9]*$", H.JSSyntaxRegExp_makeNative("^[a-zA-Z][a-zA-Z_$0-9]*$", false, true, false), null, null);
});
Isolate.$lazy($, "symbolValidationPattern", "ResolverVisitor_symbolValidationPattern", "get$ResolverVisitor_symbolValidationPattern", function() {
  return new H.JSSyntaxRegExp("^(?:[a-zA-Z$][a-zA-Z$0-9_]*\\.)*(?:[a-zA-Z$][a-zA-Z$0-9_]*=?|-|unary-|\\[\\]=|~|==|\\[\\]|\\*|/|%|~/|\\+|<<|>>|>=|>|<=|<|&|\\^|\\|)$", H.JSSyntaxRegExp_makeNative("^(?:[a-zA-Z$][a-zA-Z$0-9_]*\\.)*(?:[a-zA-Z$][a-zA-Z$0-9_]*=?|-|unary-|\\[\\]=|~|==|\\[\\]|\\*|/|%|~/|\\+|<<|>>|>=|>|<=|<|&|\\^|\\|)$", false, true, false), null, null);
});
Isolate.$lazy($, "canonicalizedSubstrings", "StringToken_canonicalizedSubstrings", "get$StringToken_canonicalizedSubstrings", function() {
  return P.HashSet_HashSet(null, null, null, P.String);
});
Isolate.$lazy($, "regexp", "VariableNamer_regexp", "get$VariableNamer_regexp", function() {
  return new H.JSSyntaxRegExp("t[0-9]+", H.JSSyntaxRegExp_makeNative("t[0-9]+", false, true, false), null, null);
});
Isolate.$lazy($, "EMPTY", "Modifiers_EMPTY", "get$Modifiers_EMPTY", function() {
  var t1, t2, t3;
  t1 = $.Node__HASH_COUNTER + 1;
  $.Node__HASH_COUNTER = t1;
  t2 = Y.Modifiers_computeFlags(C.C_Link3);
  t3 = $.Node__HASH_COUNTER + 1;
  $.Node__HASH_COUNTER = t3;
  return new Y.Modifiers(new Y.NodeList(C.C_Link3, null, null, null, t1), t2, t3);
});
Isolate.$lazy($, "okListSelectorsSet", "okListSelectorsSet", "get$okListSelectorsSet", function() {
  var t1 = P.LinkedHashSet_LinkedHashSet(null, null, null, P.String);
  t1.addAll$1(0, C.List_Phq);
  return t1;
});
Isolate.$lazy($, "doNotChangeLengthSelectorsSet", "doNotChangeLengthSelectorsSet", "get$doNotChangeLengthSelectorsSet", function() {
  var t1 = P.LinkedHashSet_LinkedHashSet(null, null, null, P.String);
  t1.addAll$1(0, C.List_CKg);
  return t1;
});
Isolate.$lazy($, "okMapSelectorsSet", "okMapSelectorsSet", "get$okMapSelectorsSet", function() {
  var t1 = P.LinkedHashSet_LinkedHashSet(null, null, null, null);
  t1.addAll$1(0, C.List_RUC);
  return t1;
});
Isolate.$lazy($, "doesNotEscapeListSet", "doesNotEscapeListSet", "get$doesNotEscapeListSet", function() {
  var t1 = P.LinkedHashSet_LinkedHashSet(null, null, null, P.String);
  t1.addAll$1(0, C.List_THA);
  return t1;
});
Isolate.$lazy($, "doesNotEscapeMapSet", "doesNotEscapeMapSet", "get$doesNotEscapeMapSet", function() {
  var t1 = P.LinkedHashSet_LinkedHashSet(null, null, null, P.String);
  t1.addAll$1(0, C.List_wcp);
  return t1;
});
Isolate.$lazy($, "STOP_TRACKING_ASSIGNMENTS_MARKER", "TypeInformation_STOP_TRACKING_ASSIGNMENTS_MARKER", "get$TypeInformation_STOP_TRACKING_ASSIGNMENTS_MARKER", function() {
  var t1 = Array(0);
  t1.fixed$length = init;
  return H.setRuntimeTypeInfo(t1, [G.TypeInformation]);
});
Isolate.$lazy($, "canonicalizedValues", "Selector_canonicalizedValues", "get$Selector_canonicalizedValues", function() {
  return P.LinkedHashMap_LinkedHashMap(null, null, null, P.$int, [P.List, Z.Selector]);
});
Isolate.$lazy($, "canonicalizedValues", "TypedSelector_canonicalizedValues", "get$TypedSelector_canonicalizedValues", function() {
  return P.LinkedHashMap_LinkedHashMap(null, null, null, Z.Selector, [P.Map, B.TypeMask, Z.TypedSelector]);
});
// Native classes

init.metadata = [{func: "dynamic__String", args: [P.String]},
{func: "num_", ret: P.num},
{func: "String__Match", ret: P.String, args: [P.Match]},
{func: "String__String", ret: P.String, args: [P.String]},
{func: "bool__Statement", ret: P.bool, args: [F.Statement1]},
{func: "void__List_SendPort", void: true, args: [[P.List, P.String], P.SendPort]},
{func: "void__void_", void: true, args: [{func: "void_", void: true}]},
{func: "void_", void: true},
{func: "void__dynamic", void: true, args: [null]},
{func: "void__dynamic__StackTrace", void: true, args: [null], opt: [P.StackTrace]},
,
{func: "bool__dynamic_dynamic", ret: P.bool, args: [null, null]},
{func: "int__dynamic", ret: P.$int, args: [null]},
{func: "args1", args: [null]},
{func: "int__Comparable_Comparable", ret: P.$int, args: [P.Comparable, P.Comparable]},
{func: "bool__Object_Object", ret: P.bool, args: [P.Object, P.Object]},
{func: "int__Object", ret: P.$int, args: [P.Object]},
{func: "NullSink__String_String", ret: K.NullSink, args: [P.String, P.String]},
{func: "ClassElement__MixinApplicationElement", ret: O.ClassElement, args: [O.MixinApplicationElement]},
{func: "args2", args: [null, null]},
{func: "Identifier__String", ret: Y.Identifier, args: [P.String]},
{func: "int__Element_Element", ret: P.$int, args: [O.Element, O.Element]},
{func: "Node__dynamic", ret: Q.Node0, args: [null]},
{func: "args0"},
{func: "int__int", ret: P.$int, args: [P.$int]},
{func: "dynamic__dynamic_String", args: [null, P.String]},
{func: "Parameter__FormalElement__String", ret: F.Parameter0, args: [O.FormalElement], opt: [P.String]},
{func: "TypeAnnotation__DartType", ret: F.TypeAnnotation0, args: [V.DartType]},
{func: "void__Expression", void: true, args: [F.Expression1]},
{func: "int__StringQuoting", ret: P.$int, args: [Y.StringQuoting]},
{func: "void__List_List_int_num__StringQuoting", void: true, args: [[P.List, P.$int], [P.List, P.$int], P.$int, {func: "num__StringQuoting", ret: P.num, args: [Y.StringQuoting]}]},
{func: "StringChunk__int", ret: F.StringChunk, args: [P.$int]},
{func: "dynamic__ClosureScope", args: [Q.ClosureScope]},
{func: "dynamic__Local", args: [O.Local]},
{func: "void__Local_String", void: true, args: [O.Local, P.String]},
{func: "int__dynamic_dynamic", ret: P.$int, args: [null, null]},
{func: "bool__Local", ret: P.bool, args: [O.Local]},
{func: "dynamic__TypeVariableType", args: [V.TypeVariableType]},
{func: "void__LocalVariableElement", void: true, args: [O.LocalVariableElement]},
{func: "Future__Uri", ret: [P.Future, P.String], args: [P.Uri]},
{func: "dynamic__Event", args: [W.Event]},
{func: "void__Uri_int_int_String_Diagnostic", void: true, args: [P.Uri, P.$int, P.$int, P.String, D.Diagnostic]},
{func: "bool_", ret: P.bool},
{func: "bool__ConcreteType", ret: P.bool, args: [L.ConcreteType]},
{func: "dynamic__BaseType", args: [L.BaseType]},
{func: "void__ClassElement", void: true, args: [O.ClassElement]},
{func: "void__VariableElement_ConcreteType", void: true, args: [O.VariableElement, L.ConcreteType]},
{func: "void__Element", void: true, args: [O.Element]},
{func: "dynamic__dynamic_Element", args: [null, O.Element]},
{func: "dynamic__TypeMask_TypeMask", args: [B.TypeMask, B.TypeMask]},
{func: "dynamic__ParameterElement", args: [O.ParameterElement]},
{func: "void__ClassElement_Element", void: true, args: [O.ClassElement, O.Element]},
{func: "void__Variable", void: true, args: [M.Variable]},
{func: "dynamic__void_", args: [{func: "void_", void: true}]},
{func: "dynamic__bool", args: [P.bool]},
{func: "void__Object__StackTrace", void: true, args: [P.Object], opt: [P.StackTrace]},
{func: "dynamic__dynamic__dynamic", args: [null], opt: [null]},
{func: "dynamic__dynamic_StackTrace", args: [null, P.StackTrace]},
{func: "void__dynamic_StackTrace", void: true, args: [null, P.StackTrace]},
{func: "bool__Object", ret: P.bool, args: [P.Object]},
{func: "dynamic__String_dynamic", args: [P.String, null]},
{func: "int__dynamic_int", ret: P.$int, args: [null, P.$int]},
{func: "void__int_int", void: true, args: [P.$int, P.$int]},
{func: "dynamic__Symbol_dynamic", args: [P.Symbol, null]},
{func: "String__int", ret: P.String, args: [P.$int]},
{func: "bool__int", ret: P.bool, args: [P.$int]},
{func: "void__String", void: true, args: [P.String]},
{func: "void__String__dynamic", void: true, args: [P.String], opt: [null]},
{func: "int__int_int", ret: P.$int, args: [P.$int, P.$int]},
{func: "Constant__VariableElement", ret: K.Constant, args: [O.VariableElement]},
{func: "Constant__Node", ret: K.Constant, args: [Y.Node]},
{func: "dynamic__Node_MessageKind", args: [Y.Node, K.MessageKind]},
{func: "List__dynamic", ret: [P.List, K.Constant], args: [null]},
{func: "List__FunctionElement", ret: [P.List, K.Constant], args: [O.FunctionElement]},
{func: "dynamic__ClassElement_Element", args: [O.ClassElement, O.Element]},
{func: "ItemCompilationContext_", ret: K.ItemCompilationContext},
{func: "bool__Element", ret: P.bool, args: [O.Element]},
{func: "dynamic__Element", args: [O.Element]},
{func: "int_", ret: P.$int},
{func: "dynamic__LibraryElement", args: [O.LibraryElement]},
{func: "ClassElement__String", ret: O.ClassElement, args: [P.String]},
{func: "dynamic__Uri_SuppressionInfo", args: [P.Uri, K.SuppressionInfo]},
{func: "dynamic__WorkItem", args: [K.WorkItem]},
{func: "bool__Constant", ret: P.bool, args: [K.Constant]},
{func: "bool__Compiler_DartType_DartType", ret: P.bool, args: [K.Compiler0, V.DartType, V.DartType]},
{func: "dynamic__Element_Constant", args: [O.Element, K.Constant]},
{func: "dynamic__Member", args: [O.Member]},
{func: "dynamic__ClassElement", args: [O.ClassElement]},
{func: "DartType__DartType", ret: V.DartType, args: [V.DartType]},
{func: "InterfaceType__DartType", ret: V.InterfaceType, args: [V.DartType]},
{func: "MemberSignature__Name_InterfaceType", ret: O.MemberSignature, args: [O.Name, V.InterfaceType]},
{func: "ElementAccess__Name_DartType_InterfaceType", ret: K.ElementAccess, args: [O.Name, V.DartType, V.InterfaceType]},
{func: "void__MemberSignature", void: true, args: [O.MemberSignature]},
{func: "Set__ClassElement", ret: [P.Set, O.ClassElement], args: [O.ClassElement]},
{func: "bool__ClassElement_ClassElement", ret: P.bool, args: [O.ClassElement, O.ClassElement]},
{func: "dynamic__AstElement", args: [O.AstElement]},
{func: "Primitive__Node", ret: D.Primitive, args: [Y.Node]},
{func: "dynamic__LiteralMapEntry", args: [Y.LiteralMapEntry]},
{func: "ConstExp__Node", ret: M.ConstExp, args: [Y.Node]},
{func: "dynamic__Reference", args: [D.Reference]},
{func: "dynamic__Parameter", args: [D.Parameter1]},
{func: "void__Primitive", void: true, args: [D.Primitive]},
{func: "void__Reference", void: true, args: [D.Reference]},
{func: "String__Reference", ret: P.String, args: [D.Reference]},
{func: "String__dynamic", ret: P.String, args: [null]},
{func: "Property__String_Expression", ret: Q.Property, args: [P.String, Q.Expression]},
{func: "dynamic__Element_String_String_bool_bool_bool", args: [O.Element, P.String, P.String, P.bool, P.bool, P.bool]},
{func: "dynamic__VariableElement_String_String_bool_bool_bool", args: [O.VariableElement, P.String, P.String, P.bool, P.bool, P.bool]},
{func: "void__Element_VariableElement", void: true, args: [O.Element, O.VariableElement]},
{func: "int__Constant_Constant", ret: P.$int, args: [K.Constant, K.Constant]},
{func: "dynamic__dynamic_Iterable", args: [null, [P.Iterable, O.ClassElement]]},
{func: "void__Iterable", void: true, args: [[P.Iterable, O.ClassElement]]},
{func: "Set_", ret: [P.Set, Z.Selector]},
{func: "dynamic__Selector", args: [Z.Selector]},
{func: "Expression_", ret: Q.Expression},
{func: "dynamic__Selector_Fun", args: [Z.Selector, Q.Fun]},
{func: "dynamic__MetadataAnnotation", args: [O.MetadataAnnotation]},
{func: "Expression__ClassElement", ret: Q.Expression, args: [O.ClassElement]},
{func: "Statement__ClassElement", ret: Q.Statement, args: [O.ClassElement]},
{func: "Expression__dynamic_dynamic", ret: Q.Expression, args: [null, null]},
{func: "void__String_Set", void: true, args: [P.String, [P.Set, Z.Selector]]},
{func: "Expression__String_Selector", ret: Q.Expression, args: [P.String, Z.Selector]},
{func: "int__String", ret: P.$int, args: [P.String]},
{func: "dynamic__DartType", args: [V.DartType]},
{func: "void__FunctionElement_FunctionType", void: true, args: [O.FunctionElement, V.FunctionType]},
{func: "void__ClassElement__bool", void: true, args: [O.ClassElement], named: {emitNull: P.bool}},
{func: "void__dynamic__dynamic", void: true, args: [null], named: {emitNull: null}},
{func: "dynamic__FunctionType_bool", args: [V.FunctionType, P.bool]},
{func: "dynamic__FunctionElement", args: [O.FunctionElement]},
{func: "void__LibraryElement", void: true, args: [O.LibraryElement]},
{func: "int__int_LibraryTag", ret: P.$int, args: [P.$int, Y.LibraryTag]},
{func: "dynamic__LibraryTag", args: [Y.LibraryTag]},
{func: "dynamic__Script", args: [K.Script]},
{func: "void__Element_Link__bool", void: true, args: [O.Element, [O.Link, Y.Export]], named: {reportError: P.bool}},
{func: "void__Element_Link", void: true, args: [O.Element, [O.Link, Y.Export]]},
{func: "dynamic__dynamic_LibraryDependencyNode", args: [null, Z.LibraryDependencyNode]},
{func: "dynamic__LibraryDependencyNode_Map", args: [Z.LibraryDependencyNode, [P.Map, O.Element, [O.Link, Y.Export]]]},
{func: "dynamic__Element_Link", args: [O.Element, [O.Link, Y.Export]]},
{func: "dynamic__LibraryElement_LibraryDependencyNode", args: [O.LibraryElement, Z.LibraryDependencyNode]},
{func: "dynamic__LibraryElement_List", args: [O.LibraryElement, [P.List, F.MirrorUsage]]},
{func: "dynamic__Node_Constant", args: [Y.Node, K.Constant]},
{func: "Definition__int", ret: D.Definition, args: [P.$int]},
{func: "void__dynamic_int", void: true, args: [null, P.$int]},
{func: "void__String_dynamic", void: true, args: [P.String, null]},
{func: "bool__LibraryElement", ret: P.bool, args: [O.LibraryElement]},
{func: "ElementAst__AstElement", ret: G.ElementAst, args: [O.AstElement]},
{func: "void__Element_ElementAst", void: true, args: [O.Element, G.ElementAst]},
{func: "dynamic__AstElement_ElementAst", args: [O.AstElement, G.ElementAst]},
{func: "dynamic__TypedefElement", args: [O.TypedefElement]},
{func: "LocalPlaceholder_", ret: G.LocalPlaceholder},
{func: "bool__Identifier", ret: P.bool, args: [Y.Identifier]},
{func: "dynamic__LocalPlaceholder", args: [G.LocalPlaceholder]},
{func: "dynamic__Element_Set", args: [O.Element, [P.Set, Y.Node]]},
{func: "dynamic__String_Set", args: [P.String, [P.Set, Y.Identifier]]},
{func: "dynamic__LibraryElement_Set", args: [O.LibraryElement, [P.Set, Y.Identifier]]},
{func: "Node__Argument", ret: Y.Node, args: [F.Argument]},
{func: "Node__Expression", ret: Y.Node, args: [F.Expression1]},
{func: "LiteralMapEntry__LiteralMapEntry", ret: Y.LiteralMapEntry, args: [F.LiteralMapEntry0]},
{func: "Node__VariableDeclaration", ret: Y.Node, args: [F.VariableDeclaration0]},
{func: "TypeAnnotation__TypeAnnotation", ret: Y.TypeAnnotation, args: [F.TypeAnnotation0]},
{func: "Node__Parameter__Token", ret: Y.Node, args: [F.Parameter0], opt: [Y.Token]},
{func: "Node__StringChunk", ret: Y.Node, args: [F.StringChunk]},
{func: "bool__InterfaceType_InterfaceType", ret: P.bool, args: [V.InterfaceType, V.InterfaceType]},
{func: "bool__DartType_DartType", ret: P.bool, args: [V.DartType, V.DartType]},
{func: "Set__InterfaceType_int", ret: [P.Set, V.DartType], args: [V.InterfaceType, P.$int]},
{func: "dynamic__int", args: [P.$int]},
{func: "bool__Import", ret: P.bool, args: [Y.Import]},
{func: "void__Constant", void: true, args: [K.Constant]},
{func: "dynamic__Node_dynamic", args: [Y.Node, null]},
{func: "void__Element_Import", void: true, args: [O.Element, Y.Import]},
{func: "dynamic__LibraryElement_Import", args: [O.LibraryElement, Y.Import]},
{func: "String__String_Set", ret: P.String, args: [P.String, [P.Set, P.String]]},
{func: "void__Import", void: true, args: [Y.Import]},
{func: "void__OutputUnit", void: true, args: [B.OutputUnit]},
{func: "Node__Node", ret: Y.Node, args: [Y.Node]},
{func: "int__Node", ret: P.$int, args: [Q.Node0]},
{func: "void__Import_MessageKind_Element_Element", void: true, args: [Y.Import, K.MessageKind, O.Element, O.Element]},
{func: "bool__Compiler", ret: P.bool, args: [K.Compiler0]},
{func: "void__Local", void: true, args: [O.Local]},
{func: "dynamic__Local_dynamic", args: [O.Local, null]},
{func: "void__Element_DartType_Node", void: true, args: [O.Element, V.DartType, Y.Node]},
{func: "void__void__JumpTarget", void: true, args: [{func: "void__JumpTarget", void: true, args: [O.JumpTarget]}]},
{func: "dynamic__JumpTarget", args: [O.JumpTarget]},
{func: "Statement__String__dynamic", ret: Q.Statement, args: [P.String], opt: [null]},
{func: "LiteralString__String", ret: Q.LiteralString0, args: [P.String]},
{func: "LiteralNumber__num", ret: Q.LiteralNumber, args: [P.num]},
{func: "Expression__String__dynamic", ret: Q.Expression, args: [P.String], opt: [null]},
{func: "Statement_", ret: Q.Statement},
{func: "Statement__Expression", ret: Q.Statement, args: [Q.Expression]},
{func: "dynamic__Node", args: [Q.Node0]},
{func: "void__Node", void: true, args: [Q.Node0]},
{func: "Instantiator__Node", ret: {func: "Node__dynamic", ret: Q.Node0, args: [null]}, args: [Q.Node0]},
{func: "Expression__dynamic", ret: Q.Expression, args: [null]},
{func: "Parameter__dynamic", ret: Q.Parameter, args: [null]},
{func: "Statement__dynamic", ret: Q.Statement, args: [null]},
{func: "dynamic__InterpolatedExpression", args: [Q.InterpolatedExpression]},
{func: "dynamic__ArrayElement", args: [Q.ArrayElement]},
{func: "void__Expression0", void: true, args: [Q.Expression]},
{func: "JavaScriptItemCompilationContext_", ret: Z.JavaScriptItemCompilationContext},
{func: "bool__Element__dynamic", ret: P.bool, args: [O.Element], opt: [null]},
true,
{func: "Element__String_int", ret: O.Element, args: [P.String, P.$int]},
{func: "VariableElement__String", ret: O.VariableElement, args: [P.String]},
{func: "FunctionElement__String", ret: O.FunctionElement, args: [P.String]},
{func: "dynamic__ConstructorElement", args: [O.ConstructorElement]},
{func: "bool__TypeMask_TypeMask", ret: P.bool, args: [B.TypeMask, B.TypeMask]},
{func: "void__ScopeContainerElement", void: true, args: [O.ScopeContainerElement]},
{func: "List__ClassElement", ret: [P.List, O.Element], args: [O.ClassElement]},
{func: "String__ClassElement", ret: P.String, args: [O.ClassElement]},
{func: "String__Iterable", ret: P.String, args: [[P.Iterable, P.String]]},
{func: "ClassElement__ClassElement", ret: O.ClassElement, args: [O.ClassElement]},
{func: "void__TypedElement", void: true, args: [O.TypedElement]},
{func: "void__Iterable0", void: true, args: [[P.Iterable, V.DartType]]},
{func: "void__Iterable__bool", void: true, args: [[P.Iterable, V.DartType]], named: {isTypeArgument: P.bool}},
{func: "Expression__TypeVariableType", ret: Q.Expression, args: [V.TypeVariableType]},
{func: "void__String_Expression", void: true, args: [P.String, Q.Expression]},
{func: "bool__ClassElement", ret: P.bool, args: [O.ClassElement]},
{func: "Node__String", ret: Y.Node, args: [P.String]},
{func: "Token__Token", ret: Y.Token, args: [Y.Token]},
{func: "String__Token", ret: P.String, args: [Y.Token]},
{func: "ClassElement__dynamic", ret: O.ClassElement, args: [null]},
{func: "void__String__args1_args0_args0", void: true, args: [P.String], named: {onType: {func: "args1", args: [null]}, onVar: {func: "args0"}, onVoid: {func: "args0"}}},
{func: "DartType__String", ret: V.DartType, args: [P.String]},
{func: "HInstruction__ParameterElement_FunctionType", ret: B.HInstruction, args: [O.ParameterElement, V.FunctionType]},
{func: "dynamic__Spannable_MessageKind__dynamic", args: [O.Spannable, K.MessageKind], opt: [null]},
C.Map_empty,
{func: "dynamic___dynamic", opt: [null]},
{func: "dynamic__Node_MessageKind__dynamic", args: [Y.Node, K.MessageKind], opt: [null]},
{func: "void__Spannable_MessageKind__Map", void: true, args: [O.Spannable, K.MessageKind], opt: [P.Map]},
{func: "DartType__MessageKind_Map__Element_DartType", ret: V.DartType, args: [K.MessageKind, P.Map], named: {erroneousElement: O.Element, userProvidedBadType: V.DartType}},
{func: "void__dynamic_DartType_TypeVariableType_DartType", void: true, args: [null, V.DartType, V.TypeVariableType, V.DartType]},
{func: "dynamic__String_LabelDefinition", args: [P.String, O.LabelDefinition]},
{func: "void__FunctionExpression", void: true, args: [Y.FunctionExpression]},
{func: "dynamic__Element_Element", args: [O.Element, O.Element]},
{func: "void__DeclaredMember", void: true, args: [A.DeclaredMember]},
{func: "void__Name_DartType_FunctionType", void: true, args: [O.Name, V.DartType, V.FunctionType]},
{func: "dynamic__MessageKind_MessageKind_MessageKind__MessageKind", args: [K.MessageKind, K.MessageKind, K.MessageKind], opt: [K.MessageKind]},
{func: "void__MessageKind_MessageKind", void: true, args: [K.MessageKind, K.MessageKind]},
{func: "void__dynamic_MessageKind_MessageKind", void: true, args: [null, K.MessageKind, K.MessageKind]},
{func: "dynamic__Name_Member", args: [O.Name, O.Member]},
{func: "void__InterfaceType_MemberSignature", void: true, args: [V.InterfaceType, O.MemberSignature]},
{func: "void__InterfaceType", void: true, args: [V.InterfaceType]},
{func: "dynamic__MemberSignature", args: [O.MemberSignature]},
{func: "dynamic__Name_MemberSignature", args: [O.Name, O.MemberSignature]},
{func: "dynamic__Name_Setlet", args: [O.Name, [N.Setlet, O.Member]]},
{func: "void__Identifier_VariableList", void: true, args: [Y.Identifier, U.VariableList]},
{func: "KeywordState__int", ret: Y.KeywordState, args: [P.$int]},
{func: "void__String_Token", void: true, args: [P.String, Y.Token]},
{func: "dynamic__Parser", args: [Y.Parser]},
{func: "bool__Token", ret: P.bool, args: [Y.Token]},
{func: "args3", args: [null, null, null]},
{func: "bool__TypeMask", ret: P.bool, args: [B.TypeMask]},
{func: "dynamic__dynamic_FieldElement", args: [null, O.FieldElement]},
{func: "void__int_SourceFileLocation", void: true, args: [P.$int, T.SourceFileLocation]},
{func: "bool__int_dynamic", ret: P.bool, args: [P.$int, null]},
{func: "dynamic__SourceMapEntry", args: [T.SourceMapEntry]},
{func: "dynamic__LocalVariableElement_BoxFieldElement", args: [O.LocalVariableElement, Q.BoxFieldElement]},
{func: "dynamic__Local_CapturedVariable", args: [O.Local, Q.CapturedVariable]},
{func: "dynamic__Local_HInstruction", args: [O.Local, B.HInstruction]},
{func: "dynamic__HPhi", args: [B.HPhi]},
{func: "HInstruction__Element", ret: B.HInstruction, args: [O.Element]},
{func: "HInstruction__ParameterElement", ret: B.HInstruction, args: [O.ParameterElement]},
{func: "dynamic__ClassElement_VariableElement", args: [O.ClassElement, O.VariableElement]},
{func: "bool__HInstruction", ret: P.bool, args: [B.HInstruction]},
{func: "dynamic__HBreak_LocalsHandler", args: [B.HBreak, B.LocalsHandler0]},
{func: "dynamic__HContinue_LocalsHandler", args: [B.HContinue, B.LocalsHandler0]},
{func: "dynamic__HBreak_dynamic", args: [B.HBreak, null]},
{func: "HInstruction_", ret: B.HInstruction},
{func: "dynamic__ClosureFieldElement", args: [Q.ClosureFieldElement]},
{func: "HInstruction__Node", ret: B.HInstruction, args: [Y.Node]},
{func: "TypeMask__dynamic", ret: B.TypeMask, args: [null]},
{func: "dynamic__GenericType_DartType_TypeVariableType_DartType", args: [V.GenericType, V.DartType, V.TypeVariableType, V.DartType]},
{func: "bool__Selector_Element", ret: P.bool, args: [Z.Selector, O.Element]},
{func: "Iterable__SwitchCase", ret: [P.Iterable, K.Constant], args: [Y.SwitchCase]},
{func: "bool__SwitchCase", ret: P.bool, args: [Y.SwitchCase]},
{func: "void__SwitchCase", void: true, args: [Y.SwitchCase]},
{func: "void__CatchBlock", void: true, args: [Y.CatchBlock]},
{func: "void__LabelDefinition", void: true, args: [O.LabelDefinition]},
{func: "void__JumpTarget", void: true, args: [O.JumpTarget]},
{func: "void__String_String", void: true, args: [P.String, P.String]},
{func: "bool__Expression", ret: P.bool, args: [Q.Expression]},
{func: "dynamic__Copy", args: [B.Copy]},
{func: "HInstruction__HInstruction_HInstruction", ret: B.HInstruction, args: [B.HInstruction, B.HInstruction]},
{func: "HInstruction__String_String", ret: B.HInstruction, args: [P.String, P.String]},
{func: "HInstruction__String_HInstruction_HInstruction", ret: B.HInstruction, args: [P.String, B.HInstruction, B.HInstruction]},
{func: "HInstruction__String", ret: B.HInstruction, args: [P.String]},
{func: "bool__HInstruction_Compiler", ret: P.bool, args: [B.HInstruction, K.Compiler0]},
{func: "void__HBasicBlock", void: true, args: [B.HBasicBlock]},
{func: "HConstant__int", ret: B.HConstant, args: [P.$int]},
{func: "StringConstant__HInstruction", ret: K.StringConstant, args: [B.HInstruction]},
{func: "dynamic__HInstruction", args: [B.HInstruction]},
{func: "dynamic__HRangeConversion", args: [B.HRangeConversion]},
{func: "void__HInstruction", void: true, args: [B.HInstruction]},
{func: "Range__HInstruction", ret: B.Range, args: [B.HInstruction]},
{func: "dynamic__HInstruction_int", args: [B.HInstruction, P.$int]},
{func: "dynamic__HBasicBlock_LiveEnvironment", args: [B.HBasicBlock, B.LiveEnvironment]},
{func: "void__Node0", void: true, args: [Y.Node]},
{func: "void__Variable_Variable", void: true, args: [M.Variable, M.Variable]},
{func: "void__int", void: true, args: [P.$int]},
{func: "void__Block", void: true, args: [Z.Block2]},
{func: "bool__dynamic", ret: P.bool, args: [null]},
{func: "bool__TypeInformation", ret: P.bool, args: [G.TypeInformation]},
{func: "void__TypeInformation", void: true, args: [G.TypeInformation]},
{func: "dynamic__ListTypeInformation", args: [G.ListTypeInformation]},
{func: "dynamic__MapTypeInformation", args: [G.MapTypeInformation]},
{func: "void__Iterable_ClosureTracerVisitor", void: true, args: [[P.Iterable, O.FunctionElement], G.ClosureTracerVisitor]},
{func: "dynamic__TypeInformation", args: [G.TypeInformation]},
{func: "dynamic__String_FunctionSetNode", args: [P.String, Z.FunctionSetNode]},
{func: "Link_", ret: O.Link},
{func: "dynamic__Node0", args: [Y.Node]},
{func: "dynamic__String_String", args: [P.String, P.String]},
{func: "bool__String_String", ret: P.bool, args: [P.String, P.String]},
];
$ = null;
Isolate = Isolate.$finishIsolateConstructor(Isolate);
$ = new Isolate();
function convertToFastObject(properties) {
  function MyClass() {
  }
  MyClass.prototype = properties;
  new MyClass();
  return properties;
}
;
A = convertToFastObject(A);
B = convertToFastObject(B);
C = convertToFastObject(C);
D = convertToFastObject(D);
E = convertToFastObject(E);
F = convertToFastObject(F);
G = convertToFastObject(G);
H = convertToFastObject(H);
J = convertToFastObject(J);
K = convertToFastObject(K);
L = convertToFastObject(L);
M = convertToFastObject(M);
N = convertToFastObject(N);
O = convertToFastObject(O);
P = convertToFastObject(P);
Q = convertToFastObject(Q);
R = convertToFastObject(R);
S = convertToFastObject(S);
T = convertToFastObject(T);
U = convertToFastObject(U);
V = convertToFastObject(V);
W = convertToFastObject(W);
X = convertToFastObject(X);
Y = convertToFastObject(Y);
Z = convertToFastObject(Z);
function init() {
  Isolate.$isolateProperties = {};
  function generateAccessor(fieldDescriptor, accessors, cls) {
    var fieldInformation = fieldDescriptor.split("-");
    var field = fieldInformation[0];
    var len = field.length;
    var code = field.charCodeAt(len - 1);
    var reflectable;
    if (fieldInformation.length > 1)
      reflectable = true;
    else
      reflectable = false;
    code = code >= 60 && code <= 64 ? code - 59 : code >= 123 && code <= 126 ? code - 117 : code >= 37 && code <= 43 ? code - 27 : 0;
    if (code) {
      var getterCode = code & 3;
      var setterCode = code >> 2;
      var accessorName = field = field.substring(0, len - 1);
      var divider = field.indexOf(":");
      if (divider > 0) {
        accessorName = field.substring(0, divider);
        field = field.substring(divider + 1);
      }
      if (getterCode) {
        var args = getterCode & 2 ? "receiver" : "";
        var receiver = getterCode & 1 ? "this" : "receiver";
        var body = "return " + receiver + "." + field;
        var property = cls + ".prototype.get$" + accessorName + "=";
        var fn = "function(" + args + "){" + body + "}";
        if (reflectable)
          accessors.push(property + "$reflectable(" + fn + ");\n");
        else
          accessors.push(property + fn + ";\n");
      }
      if (setterCode) {
        var args = setterCode & 2 ? "receiver, value" : "value";
        var receiver = setterCode & 1 ? "this" : "receiver";
        var body = receiver + "." + field + " = value";
        var property = cls + ".prototype.set$" + accessorName + "=";
        var fn = "function(" + args + "){" + body + "}";
        if (reflectable)
          accessors.push(property + "$reflectable(" + fn + ");\n");
        else
          accessors.push(property + fn + ";\n");
      }
    }
    return field;
  }
  Isolate.$isolateProperties.$generateAccessor = generateAccessor;
  function defineClass(name, cls, fields) {
    var accessors = [];
    var str = "function " + cls + "(";
    var body = "";
    for (var i = 0; i < fields.length; i++) {
      if (i != 0)
        str += ", ";
      var field = generateAccessor(fields[i], accessors, cls);
      var parameter = "parameter_" + field;
      str += parameter;
      body += "this." + field + " = " + parameter + ";\n";
    }
    str += ") {\n" + body + "}\n";
    str += cls + ".builtin$cls=\"" + name + "\";\n";
    str += "$desc=$collectedClasses." + cls + ";\n";
    str += "if($desc instanceof Array) $desc = $desc[1];\n";
    str += cls + ".prototype = $desc;\n";
    if (typeof defineClass.name != "string") {
      str += cls + ".name=\"" + cls + "\";\n";
    }
    str += accessors.join("");
    return str;
  }
  var inheritFrom = function() {
    function tmp() {
    }
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    return function(constructor, superConstructor) {
      tmp.prototype = superConstructor.prototype;
      var object = new tmp();
      var properties = constructor.prototype;
      for (var member in properties)
        if (hasOwnProperty.call(properties, member))
          object[member] = properties[member];
      object.constructor = constructor;
      constructor.prototype = object;
      return object;
    };
  }();
  Isolate.$finishClasses = function(collectedClasses, isolateProperties, existingIsolateProperties) {
    var pendingClasses = {};
    if (!init.allClasses)
      init.allClasses = {};
    var allClasses = init.allClasses;
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    if (typeof dart_precompiled == "function") {
      var constructors = dart_precompiled(collectedClasses);
    } else {
      var combinedConstructorFunction = "function $reflectable(fn){fn.$reflectable=1;return fn};\n" + "var $desc;\n";
      var constructorsList = [];
    }
    for (var cls in collectedClasses) {
      if (hasOwnProperty.call(collectedClasses, cls)) {
        var desc = collectedClasses[cls];
        if (desc instanceof Array)
          desc = desc[1];
        var classData = desc["^"], supr, name = cls, fields = classData;
        if (typeof classData == "string") {
          var split = classData.split("/");
          if (split.length == 2) {
            name = split[0];
            fields = split[1];
          }
        }
        var s = fields.split(";");
        fields = s[1] == "" ? [] : s[1].split(",");
        supr = s[0];
        split = supr.split(":");
        if (split.length == 2) {
          supr = split[0];
          var functionSignature = split[1];
          if (functionSignature)
            desc.$signature = function(s) {
              return function() {
                return init.metadata[s];
              };
            }(functionSignature);
        }
        if (supr && supr.indexOf("+") > 0) {
          s = supr.split("+");
          supr = s[0];
          var mixin = collectedClasses[s[1]];
          if (mixin instanceof Array)
            mixin = mixin[1];
          for (var d in mixin) {
            if (hasOwnProperty.call(mixin, d) && !hasOwnProperty.call(desc, d))
              desc[d] = mixin[d];
          }
        }
        if (typeof dart_precompiled != "function") {
          combinedConstructorFunction += defineClass(name, cls, fields);
          constructorsList.push(cls);
        }
        if (supr)
          pendingClasses[cls] = supr;
      }
    }
    if (typeof dart_precompiled != "function") {
      combinedConstructorFunction += "return [\n  " + constructorsList.join(",\n  ") + "\n]";
      var constructors = new Function("$collectedClasses", combinedConstructorFunction)(collectedClasses);
      combinedConstructorFunction = null;
    }
    for (var i = 0; i < constructors.length; i++) {
      var constructor = constructors[i];
      var cls = constructor.name;
      var desc = collectedClasses[cls];
      var globalObject = isolateProperties;
      if (desc instanceof Array) {
        globalObject = desc[0] || isolateProperties;
        desc = desc[1];
      }
      allClasses[cls] = constructor;
      globalObject[cls] = constructor;
    }
    constructors = null;
    var finishedClasses = {};
    init.interceptorsByTag = Object.create(null);
    init.leafTags = {};
    function finishClass(cls) {
      var hasOwnProperty = Object.prototype.hasOwnProperty;
      if (hasOwnProperty.call(finishedClasses, cls))
        return;
      finishedClasses[cls] = true;
      var superclass = pendingClasses[cls];
      if (!superclass || typeof superclass != "string")
        return;
      finishClass(superclass);
      var constructor = allClasses[cls];
      var superConstructor = allClasses[superclass];
      if (!superConstructor)
        superConstructor = existingIsolateProperties[superclass];
      var prototype = inheritFrom(constructor, superConstructor);
      if (hasOwnProperty.call(prototype, "%")) {
        var nativeSpec = prototype["%"].split(";");
        if (nativeSpec[0]) {
          var tags = nativeSpec[0].split("|");
          for (var i = 0; i < tags.length; i++) {
            init.interceptorsByTag[tags[i]] = constructor;
            init.leafTags[tags[i]] = true;
          }
        }
        if (nativeSpec[1]) {
          tags = nativeSpec[1].split("|");
          if (nativeSpec[2]) {
            var subclasses = nativeSpec[2].split("|");
            for (var i = 0; i < subclasses.length; i++) {
              var subclass = allClasses[subclasses[i]];
              subclass.$nativeSuperclassTag = tags[0];
            }
          }
          for (i = 0; i < tags.length; i++) {
            init.interceptorsByTag[tags[i]] = constructor;
            init.leafTags[tags[i]] = false;
          }
        }
      }
    }
    for (var cls in pendingClasses)
      finishClass(cls);
  };
  Isolate.$lazy = function(prototype, staticName, fieldName, getterName, lazyValue) {
    var sentinelUndefined = {};
    var sentinelInProgress = {};
    prototype[fieldName] = sentinelUndefined;
    prototype[getterName] = function() {
      var result = $[fieldName];
      try {
        if (result === sentinelUndefined) {
          $[fieldName] = sentinelInProgress;
          try {
            result = $[fieldName] = lazyValue();
          } finally {
            if (result === sentinelUndefined)
              if ($[fieldName] === sentinelInProgress)
                $[fieldName] = null;
          }
        } else {
          if (result === sentinelInProgress)
            H.throwCyclicInit(staticName);
        }
        return result;
      } finally {
        $[getterName] = function() {
          return this[fieldName];
        };
      }
    };
  };
  Isolate.$finishIsolateConstructor = function(oldIsolate) {
    var isolateProperties = oldIsolate.$isolateProperties;
    function Isolate() {
      var hasOwnProperty = Object.prototype.hasOwnProperty;
      for (var staticName in isolateProperties)
        if (hasOwnProperty.call(isolateProperties, staticName))
          this[staticName] = isolateProperties[staticName];
      function ForceEfficientMap() {
      }
      ForceEfficientMap.prototype = this;
      new ForceEfficientMap();
    }
    Isolate.prototype = oldIsolate.prototype;
    Isolate.prototype.constructor = Isolate;
    Isolate.$isolateProperties = isolateProperties;
    Isolate.$finishClasses = oldIsolate.$finishClasses;
    Isolate.makeConstantList = oldIsolate.makeConstantList;
    return Isolate;
  };
}
!function() {
  function intern(s) {
    var o = {};
    o[s] = 1;
    return Object.keys(convertToFastObject(o))[0];
  }
  init.getIsolateTag = function(name) {
    return intern("___dart_" + name + init.isolateTag);
  };
  var tableProperty = "___dart_isolate_tags_";
  var usedProperties = Object[tableProperty] || (Object[tableProperty] = Object.create(null));
  var rootProperty = "_ZxYxX";
  for (var i = 0;; i++) {
    var property = intern(rootProperty + "_" + i + "_");
    if (!(property in usedProperties)) {
      usedProperties[property] = 1;
      init.isolateTag = property;
      break;
    }
  }
}();
init.dispatchPropertyName = init.getIsolateTag("dispatch_record");
// BEGIN invoke [main].
;(function(callback) {
  if (typeof document === "undefined") {
    callback(null);
    return;
  }
  if (document.currentScript) {
    callback(document.currentScript);
    return;
  }
  var scripts = document.scripts;
  function onLoad(event) {
    for (var i = 0; i < scripts.length; ++i) {
      scripts[i].removeEventListener("load", onLoad, false);
    }
    callback(event.target);
  }
  for (var i = 0; i < scripts.length; ++i) {
    scripts[i].addEventListener("load", onLoad, false);
  }
})(function(currentScript) {
  init.currentScript = currentScript;
  if (typeof dartMainRunner === "function") {
    dartMainRunner(function(a) {
      H.startRootIsolate(O.main$closure(), a);
    }, []);
  } else {
    (function(a) {
      H.startRootIsolate(O.main$closure(), a);
    })([]);
  }
});
;
// END invoke [main].
})()

//# sourceMappingURL=compiler_isolate.dart.js.map
